Audit Report

## Title 
Legacy Gas Metering in Aptos Move VM: Native Functions Can Bypass Per-Operation Gas Limit Checks

## Summary
When the Aptos Move VM operates in legacy gas metering mode (pre-gas_feature_version 36, i.e., before RELEASE_V1_32), several native functions (including all move-stdlib and table natives) disable incremental gas charging. In this mode, gas is only charged at the end of native execution, allowing malicious transactions to consume computation vastly exceeding the remaining budget, causing validator DoS at greatly discounted cost.

## Finding Description
For gas_feature_version < 36 (RELEASE_V1_32):

- Native functions like those in move-stdlib and table-natives are registered via `with_incremental_gas_charging(false, ...)`, which disables incremental checks during native calls.
- In this legacy mode, `SafeNativeContext::charge` only accumulates gas charges into `legacy_gas_used` and does not enforce the gas limit until the native function returns.
- If a native function performs a computationally expensive operation (e.g., expensive serialization in table_natives), and the remaining transaction gas is insufficient, the computation still completes in full.
- Only after returning does the interpreter call `charge_native_function()`, which fails the transaction with OUT_OF_GAS, but validator CPU and memory resources have already been consumed.

This design breaks the Move VM safety and resource limits invariants, as it enables computational resource exhaustion and violates the expectation that gas charging precisely limits computation in real-time.

## Impact Explanation
This bug enables a high-severity denial-of-service vulnerability:

- Any unprivileged user can submit transactions that consume nearly all available gas, then use a native function like `table::borrow_box` on a large, complex key/value, causing significantly more computation than the remaining gas budget covers.
- Validators must execute the full computation, only to discover after the fact (via OUT_OF_GAS) that the transaction should have been stopped sooner.
- Attackers can repeatedly consume CPU resources at approximately 1% of normal gas cost (paying only for "leftover" gas), enabling DoS and resource underpricing.

Per Aptos bug bounty rules, this is "Validator node slowdowns" and "Significant protocol violations," qualifying as HIGH severity.

## Likelihood Explanation
This vulnerability is easily exploitable by any transaction sender as long as the network’s gas_feature_version < 36. 
- Many networks, devnets, forks, or private deployments could still be running a legacy version and be instantly vulnerable.
- On upgraded mainnet/testnet environments (feature_version ≥ 36), the exploit is gated off by runtime checks and cannot be used.

## Recommendation
**Immediate:**
- Audit production networks, devnets, and testnets for gas_feature_version and upgrade all to >= 36 (RELEASE_V1_32) or higher as soon as possible.
- Add test coverage to detect if `legacy_gas_budget`/legacy metering pathways are active in any mainnet or production configurations.

**Code Hardening:**
- Remove all legacy gas metering code once all networks are confirmed migrated.
- In the interim, add a fatal panic or transaction rejection if legacy metering is used (`legacy_enable_incremental_gas_charging == false`), except in secure test/dev environments.

```rust
// Pseudo-fix: abort if legacy mode is ever enabled
assert!(
    self.gas_feature_version >= RELEASE_V1_32,
    "Legacy gas system (pre-v1.32) is unsupported and unsafe"
);
```

## Proof of Concept

1. Construct a Move script/transaction that calls a move-stdlib or table-native with a very large, complex input when the transaction’s gas remaining is minimal (e.g., 1000 units).
2. The native code accumulates charges, but validation is delayed.
3. The native completes 100,000 units worth of computation.
4. Finally, OUT_OF_GAS is returned and only 1000 units are charged.

References: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) 

---

Notes:

- If gas_feature_version >= 36 (RELEASE_V1_32) on mainnet and all public testnets, the vulnerable legacy code path is securely unreachable. In that case, the practical severity is low or none.
- The vulnerability *does* remain in the codebase and is reachable via config or network type—so any misconfiguration, replay, or fork exposes it.
- No consensus-splitting or funds-loss scenario occurs, so the highest impact is validator node resource exhaustion.

### Citations

**File:** aptos-move/aptos-native-interface/src/context.rs (L75-103)
```rust
    pub fn charge(
        &mut self,
        abstract_amount: impl GasExpression<NativeGasParameters, Unit = InternalGasUnit>,
    ) -> SafeNativeResult<()> {
        let amount = abstract_amount.evaluate(self.gas_feature_version, self.native_gas_params);

        if let Some(hook) = self.gas_hook {
            let node = abstract_amount.to_dynamic();
            hook(node);
        }

        if self.has_direct_gas_meter_access_in_native_context() {
            self.gas_meter()
                .charge_native_execution(amount)
                .map_err(LimitExceededError::from_err)?;
            Ok(())
        } else {
            self.legacy_gas_used += amount;
            if self.legacy_gas_used > self.legacy_gas_budget()
                && self.legacy_enable_incremental_gas_charging
            {
                Err(SafeNativeError::LimitExceeded(
                    LimitExceededError::LegacyOutOfGas,
                ))
            } else {
                Ok(())
            }
        }
    }
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L38-77)
```rust
    /// Creates a new safe native builder.
    ///
    /// The configurations provided will be accessible by all native functions created later.
    pub fn new(
        gas_feature_version: u64,
        native_gas_params: NativeGasParameters,
        misc_gas_params: MiscGasParameters,
        timed_features: TimedFeatures,
        features: Features,
        gas_hook: Option<Arc<dyn Fn(DynamicExpression) + Send + Sync>>,
    ) -> Self {
        Self {
            data: Arc::new(SharedData {
                gas_feature_version,
                native_gas_params,
                misc_gas_params,
                timed_features,
                features,
            }),
            enable_incremental_gas_charging: true,
            gas_hook,
        }
    }

    /// Convenience function that allows one to set the incremental gas charging behavior only for
    /// natives created within the given closure.
    ///
    /// This can be useful if you want to configure the default for natives from a particular group
    /// without affecting the others.
    pub fn with_incremental_gas_charging<F, R>(&mut self, enable: bool, action: F) -> R
    where
        F: FnOnce(&mut Self) -> R,
    {
        let old = self.enable_incremental_gas_charging;
        self.enable_incremental_gas_charging = enable;
        let res = action(self);
        self.enable_incremental_gas_charging = old;
        res
    }

```

**File:** aptos-move/framework/move-stdlib/src/natives/mod.rs (L38-51)
```rust
    builder.with_incremental_gas_charging(false, |builder| {
        add_natives!("bcs", bcs::make_all(builder));
        add_natives!("cmp", cmp::make_all(builder));
        add_natives!("hash", hash::make_all(builder));
        add_natives!("mem", mem::make_all(builder));
        add_natives!("reflect", reflect::make_all(builder));
        add_natives!("signer", signer::make_all(builder));
        add_natives!("string", string::make_all(builder));
        add_natives!("vector", vector::make_all(builder));
        #[cfg(feature = "testing")]
        {
            add_natives!("unit_test", unit_test::make_all(builder));
        }
    });
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L301-323)
```rust
    builder.with_incremental_gas_charging(false, |builder| {
        builder
            .make_named_natives([
                ("new_table_handle", native_new_table_handle as RawSafeNative),
                ("add_box", native_add_box),
                ("borrow_box", native_borrow_box),
                ("borrow_box_mut", native_borrow_box),
                ("remove_box", native_remove_box),
                ("contains_box", native_contains_box),
                ("destroy_empty_box", native_destroy_empty_box),
                ("drop_unchecked_box", native_drop_unchecked_box),
            ])
            .map(|(func_name, func)| {
                (
                    table_addr,
                    Identifier::new("table").unwrap(),
                    Identifier::new(func_name).unwrap(),
                    func,
                )
            })
            .collect()
    })
}
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L386-445)
```rust
fn native_add_box(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 3);

    context.charge(ADD_BOX_BASE)?;
    let fix_memory_double_counting =
        context.timed_feature_enabled(TimedFeatureFlag::FixTableNativesMemoryDoubleCounting);

    let (extensions, mut loader_context, abs_val_gas_params, gas_feature_version) =
        context.extensions_with_loader_context_and_gas_params();
    let table_context = extensions.get::<NativeTableContext>();
    let mut table_data = table_context.table_data.borrow_mut();

    let val = args.pop_back().unwrap();
    let key = args.pop_back().unwrap();
    let handle = get_table_handle(&safely_pop_arg!(args, StructRef))?;

    let table =
        table_data.get_or_create_table(&mut loader_context, handle, &ty_args[0], &ty_args[2])?;

    let function_value_extension = loader_context.function_value_extension();
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);

    let (gv, loaded) =
        table.get_or_create_global_value(&function_value_extension, table_context, key_bytes)?;
    let mem_usage = if !fix_memory_double_counting || loaded.is_some() {
        gv.view()
            .map(|val| {
                abs_val_gas_params
                    .abstract_heap_size(&val, gas_feature_version)
                    .map(u64::from)
            })
            .transpose()?
    } else {
        None
    };

    let res = match gv.move_to(val) {
        Ok(_) => Ok(smallvec![]),
        Err(_) => Err(SafeNativeError::Abort {
            abort_code: ALREADY_EXISTS,
        }),
    };

    drop(table_data);

    // TODO(Gas): Figure out a way to charge this earlier.
    context.charge(key_cost)?;
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
    charge_load_cost(context, loaded)?;

    res
}
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1090-1176)
```rust
        gas_meter.charge_native_function_before_execution(
            ty_args.iter().map(|ty| TypeWithRuntimeEnvironment {
                ty,
                runtime_environment: self.loader.runtime_environment(),
            }),
            args.iter(),
        )?;

        let mut native_context = NativeContext::new(
            self,
            data_cache,
            self.loader.unmetered_module_storage(),
            extensions,
            gas_meter,
            traversal_context,
        );
        let result = native_function(&mut native_context, ty_args, args)?;

        // Note(Gas): The order by which gas is charged / error gets returned MUST NOT be modified
        //            here or otherwise it becomes an incompatible change!!!
        match result {
            NativeResult::Success {
                cost,
                ret_vals: return_values,
            } => {
                gas_meter.charge_native_function(cost, Some(return_values.iter()))?;
                // Paranoid check to protect us against incorrect native function implementations. A native function that
                // returns a different number of values than its declared types will trigger this check.
                if return_values.len() != function.return_tys().len() {
                    return Err(PartialVMError::new_invariant_violation(
                        "Arity mismatch: return value count does not match return type count",
                    ));
                }
                // Put return values on the top of the operand stack, where the caller will find them.
                // This is one of only two times the operand stack is shared across call stack frames; the other is in handling
                // the Return instruction for normal calls
                for value in return_values {
                    self.operand_stack.push(value)?;
                }

                // If the caller requires checks, push return types of native function to
                // satisfy runtime check protocol.
                if RTTCheck::should_perform_checks(&current_frame.function.function) {
                    if function.ty_args().is_empty() {
                        for ty in function.return_tys() {
                            self.operand_stack.push_ty(ty.clone())?;
                        }
                    } else {
                        for ty in function.return_tys() {
                            let ty = ty_builder.create_ty_with_subst(ty, ty_args)?;
                            self.operand_stack.push_ty(ty)?;
                        }
                    }
                }
                // Perform reference transition for native call-return.
                RTRCheck::native_static_dispatch_transition(function, mask, &mut self.ref_state)?;

                current_frame.pc += 1; // advance past the Call instruction in the caller
                Ok(false)
            },
            NativeResult::Abort { cost, abort_code } => {
                gas_meter.charge_native_function(cost, Option::<std::iter::Empty<&Value>>::None)?;
                Err(PartialVMError::new(StatusCode::ABORTED).with_sub_status(abort_code))
            },
            NativeResult::OutOfGas { partial_cost } => {
                let err = match gas_meter
                    .charge_native_function(partial_cost, Option::<std::iter::Empty<&Value>>::None)
                {
                    Err(err) if err.major_status() == StatusCode::OUT_OF_GAS => err,
                    Ok(_) | Err(_) => PartialVMError::new_invariant_violation(
                        "The partial cost returned by the native function did \
                        not cause the gas meter to trigger an OutOfGas error, at least \
                        one of them is violating the contract",
                    ),
                };

                Err(err)
            },
            NativeResult::CallFunction {
                cost,
                module_name,
                func_name,
                ty_args,
                args,
            } => {
                gas_meter.charge_native_function(cost, Option::<std::iter::Empty<&Value>>::None)?;

```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L173-209)
```rust
    fn charge_execution(
        &mut self,
        abstract_amount: impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + Debug,
    ) -> PartialVMResult<()> {
        self.counter_for_kill_switch += 1;
        if self.counter_for_kill_switch & 3 == 0
            && self.block_synchronization_kill_switch.interrupt_requested()
        {
            return Err(
                PartialVMError::new(StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR)
                    .with_message("Interrupted from block synchronization view".to_string()),
            );
        }

        let amount = abstract_amount.evaluate(self.feature_version, &self.vm_gas_params);

        match self.balance.checked_sub(amount) {
            Some(new_balance) => {
                self.balance = new_balance;
                self.execution_gas_used += amount;
            },
            None => {
                let old_balance = self.balance;
                self.balance = 0.into();
                if self.feature_version >= 12 {
                    self.execution_gas_used += old_balance;
                }
                return Err(PartialVMError::new(StatusCode::OUT_OF_GAS));
            },
        };

        if self.feature_version >= 7 && self.execution_gas_used > self.max_execution_gas {
            Err(PartialVMError::new(StatusCode::EXECUTION_LIMIT_REACHED))
        } else {
            Ok(())
        }
    }
```
