# Audit Report

## Title
Consensus Observer Accepts Malicious Consensus Data from Untrusted Peers on Non-Mutual-Auth Networks

## Summary
The consensus observer implementation fails to validate that subscribed peers are trusted before accepting consensus data. On fullnode networks without mutual authentication, any attacker can advertise support for consensus observer protocols, respond to subscription requests, and inject malicious consensus data into fullnodes, causing state inconsistencies and potential consensus splits.

## Finding Description

The `.expect()` call in `create_consensus_observer_and_publisher()` only checks that `consensus_observer_interfaces` exists, but does **not** validate that the network interfaces came from trusted sources. [1](#0-0) 

The core vulnerability exists in the peer selection and subscription logic. When consensus observer sorts peers for subscription, it only validates protocol support, not peer trust status: [2](#0-1) 

The function `supports_consensus_observer()` only checks if peers advertise the protocol - it does **not** check if they are in the trusted peers set or have appropriate peer roles.

On fullnode networks, the authentication mode can be `MaybeMutual`, which allows untrusted peers to connect: [3](#0-2) 

Under `MaybeMutual` mode, inbound connections from untrusted peers are accepted and marked as `PeerRole::Unknown`: [4](#0-3) 

Consensus observer is registered on **all** networks where it's enabled, including fullnode networks without mutual authentication: [5](#0-4) 

Once a subscription is created, message validation only checks if the sender is an active subscription - **not** if they are trusted: [6](#0-5) 

**Attack Path:**
1. Attacker runs a malicious node that advertises `ProtocolId::ConsensusObserver` and `ProtocolId::ConsensusObserverRpc`
2. Attacker connects to a fullnode running consensus observer on a network with `MaybeMutual` authentication (e.g., VFN or public network)
3. Fullnode's handshake accepts the connection, assigning attacker `PeerRole::Unknown`
4. Consensus observer's peer selection includes the attacker because `supports_consensus_observer()` returns true
5. Fullnode sends a subscription request to the attacker
6. Attacker responds with `SubscribeAck`
7. Fullnode creates an active subscription to the attacker
8. Attacker sends malicious consensus messages (blocks, ordered blocks, commit decisions)
9. Fullnode processes and commits these malicious messages as legitimate consensus data
10. Fullnode's state diverges from the real validator consensus, violating **Deterministic Execution** and **Consensus Safety** invariants

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Consensus Safety Violations**: Different fullnodes can commit different blocks based on which attacker they're subscribed to, breaking the fundamental assumption that all nodes see the same blockchain state.

2. **State Inconsistencies**: Fullnodes will compute and commit incorrect state roots, violating the **State Consistency** invariant that state transitions must be verifiable via Merkle proofs.

3. **Deterministic Execution Violation**: Fullnodes will execute transactions from attacker-crafted blocks that were never agreed upon by real validators, violating the invariant that "all validators must produce identical state roots for identical blocks."

4. **Loss of Funds**: Users querying compromised fullnodes will see incorrect balances, transaction statuses, and account states. This can lead to double-spending if services rely on these fullnodes.

5. **Non-Recoverable Network Partition**: If many fullnodes subscribe to different attackers, the network effectively partitions into incompatible views of blockchain state, potentially requiring manual intervention or a hardfork to resolve.

This meets the **Critical Severity** criteria per the Aptos bug bounty program, particularly "Consensus/Safety violations" and "Non-recoverable network partition."

## Likelihood Explanation

**HIGH Likelihood** - The attack is highly feasible because:

1. **No special access required**: Any attacker can run a node and connect to public fullnode networks
2. **Simple protocol implementation**: Attacker only needs to implement basic protocol handlers for consensus observer messages
3. **Automatic target selection**: Fullnodes automatically discover and subscribe to peers advertising the protocols
4. **No cryptographic barriers**: On `MaybeMutual` networks, there's no requirement to possess validator keys or be in the trusted set
5. **Wide deployment**: Consensus observer is enabled by default on VFNs and can be enabled on PFNs, creating a large attack surface

The only requirement is that the fullnode's consensus observer feature is enabled and operating on a network without mandatory mutual authentication.

## Recommendation

Implement mandatory peer trust validation before creating consensus observer subscriptions:

1. **Modify subscription peer selection** to filter peers by their role and trust status:
   - Only accept subscriptions from peers with `PeerRole::Validator` or `PeerRole::ValidatorFullNode`
   - Reject peers with `PeerRole::Unknown` or `PeerRole::Downstream`
   - Verify peers are in the trusted peers set for the network

2. **Add trust validation in `verify_message_for_subscription()`**:
   ```rust
   pub fn verify_message_for_subscription(
       &mut self,
       message_sender: PeerNetworkId,
       peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
   ) -> Result<(), Error> {
       // Check if the message is from an active subscription
       if let Some(active_subscription) = self
           .active_observer_subscriptions
           .lock()
           .get_mut(&message_sender)
       {
           // NEW: Verify the peer is trusted
           if let Some(peer_metadata) = peers_and_metadata.get(&message_sender) {
               let peer_role = peer_metadata.get_connection_metadata().role;
               if !matches!(peer_role, PeerRole::Validator | PeerRole::ValidatorFullNode) {
                   return Err(Error::InvalidMessageError(format!(
                       "Received message from untrusted peer role: {:?}", peer_role
                   )));
               }
           }
           
           active_subscription.update_last_message_receive_time();
           return Ok(());
       }
       // ... rest of function
   }
   ```

3. **Enforce mutual authentication** or trusted peer validation on networks where consensus observer is enabled, or restrict consensus observer to validator networks only.

4. **Add explicit validation in `sort_peers_by_subscription_optimality()`** to exclude untrusted peers before sorting.

## Proof of Concept

```rust
// Attacker node simulation demonstrating the vulnerability
// This would be run as a separate malicious node connecting to the network

use aptos_network::ProtocolId;
use consensus_observer_message::{ConsensusObserverMessage, ConsensusObserverResponse};

// 1. Attacker advertises consensus observer protocol support
let supported_protocols = vec![
    ProtocolId::ConsensusObserver,
    ProtocolId::ConsensusObserverRpc,
];

// 2. Attacker handles incoming subscription request from fullnode
async fn handle_subscription_request(request: ConsensusObserverRequest) -> ConsensusObserverResponse {
    match request {
        ConsensusObserverRequest::Subscribe => {
            // Respond with SubscribeAck to establish subscription
            ConsensusObserverResponse::SubscribeAck
        }
    }
}

// 3. After subscription is established, send malicious consensus data
async fn send_malicious_blocks(peer: PeerNetworkId) {
    // Craft fake ordered block with arbitrary transactions
    let malicious_block = create_fake_ordered_block();
    
    // Send to subscribed fullnode
    send_direct_send_message(
        peer,
        ConsensusObserverDirectSend::OrderedBlock(malicious_block)
    );
    
    // Fullnode will process this as legitimate consensus data
    // because verify_message_for_subscription() only checks
    // if the peer is in active_observer_subscriptions map,
    // NOT if the peer is trusted or has appropriate role
}
```

To verify the vulnerability:
1. Run a fullnode with consensus observer enabled on a public network
2. Connect an attacker node that advertises consensus observer protocols
3. Observe the fullnode sending subscription requests to the attacker
4. Respond with `SubscribeAck` and send crafted consensus messages
5. Monitor the fullnode's logs and state - it will process the malicious data

## Notes

This vulnerability stems from a design assumption that consensus observer would only run on networks with mutual authentication where all peers are pre-validated. However, the code allows it to run on any network, including public fullnode networks where `MaybeMutual` authentication accepts untrusted peers. The lack of runtime trust validation creates a critical security gap where consensus data integrity depends entirely on network-level authentication, which is insufficient for this use case.

### Citations

**File:** aptos-node/src/consensus.rs (L165-166)
```rust
    let consensus_observer_interfaces = consensus_observer_interfaces
        .expect("Consensus observer is enabled, but the network interfaces are missing!");
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L352-356)
```rust
/// Returns true iff the peer metadata indicates support for consensus observer
fn supports_consensus_observer(peer_metadata: &PeerMetadata) -> bool {
    peer_metadata.supports_protocol(ProtocolId::ConsensusObserver)
        && peer_metadata.supports_protocol(ProtocolId::ConsensusObserverRpc)
}
```

**File:** network/framework/src/peer_manager/builder.rs (L37-46)
```rust
pub enum AuthenticationMode {
    /// Inbound connections will first be checked against the known peers set, and
    /// if the `PeerId` is known it will be authenticated against it's `PublicKey`
    /// Otherwise, the incoming connections will be allowed through in the common
    /// pool of unknown peers.
    MaybeMutual(x25519::PrivateKey),
    /// Both dialer and listener will verify public keys of each other in the
    /// handshake.
    Mutual(x25519::PrivateKey),
}
```

**File:** network/framework/src/noise/handshake.rs (L384-410)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
```

**File:** aptos-node/src/network.rs (L336-358)
```rust
        // Register consensus observer (both client and server) with the network
        if node_config
            .consensus_observer
            .is_observer_or_publisher_enabled()
        {
            // Create the network handle for this network type
            let network_handle = register_client_and_service_with_network(
                &mut network_builder,
                network_id,
                &network_config,
                consensus_observer_network_configuration(node_config),
                false,
            );

            // Add the network handle to the set of handles
            if let Some(consensus_observer_network_handles) =
                &mut consensus_observer_network_handles
            {
                consensus_observer_network_handles.push(network_handle);
            } else {
                consensus_observer_network_handles = Some(vec![network_handle]);
            }
        }
```

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L363-385)
```rust
    pub fn verify_message_for_subscription(
        &mut self,
        message_sender: PeerNetworkId,
    ) -> Result<(), Error> {
        // Check if the message is from an active subscription
        if let Some(active_subscription) = self
            .active_observer_subscriptions
            .lock()
            .get_mut(&message_sender)
        {
            // Update the last message receive time and return early
            active_subscription.update_last_message_receive_time();
            return Ok(());
        }

        // Otherwise, the message is not from an active subscription.
        // Send another unsubscribe request, and return an error.
        self.unsubscribe_from_peer(message_sender);
        Err(Error::InvalidMessageError(format!(
            "Received message from unexpected peer, and not an active subscription: {}!",
            message_sender
        )))
    }
```
