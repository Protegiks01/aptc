# Audit Report

## Title
Sanity Check Bypass in Data Streaming Service Allows Version Range Mismatch and State Synchronization Corruption

## Summary
The `sanity_check_client_response_type()` function validates only response payload types but fails to verify that response data matches request parameters (version ranges, epochs). This allows malicious peers to send transactions/outputs for incorrect version ranges that bypass validation, corrupting stream state tracking and potentially causing incomplete state synchronization.

## Finding Description

The vulnerability exists in the data streaming service's response validation logic. When processing data client responses, the system performs a sanity check at line 469 of `data_stream.rs`: [1](#0-0) 

However, the `sanity_check_client_response_type()` function only validates payload types using pattern matching, without verifying semantic correctness: [2](#0-1) 

This validation only checks if a `TransactionsWithProofRequest` receives a `TransactionsWithProof` payload, but **does not verify** that the transactions are for the requested version range (start_version to end_version).

**Attack Flow:**

1. Node sends `TransactionsWithProofRequest` for versions 100-200
2. Malicious peer responds with `TransactionsWithProof` containing transactions for versions 1000-1100 (wrong range)
3. Sanity check passes (only checks payload type matches)
4. The `request_missing_data()` function incorrectly assumes received data starts at requested version: [3](#0-2) 

This function calculates `num_received_transactions` and assumes they start at `request.start_version`, computing the next start version as `request.start_version + num_received_transactions` without validating the actual version range in the response.

5. The stream engine updates version tracking based on request parameters, not actual response data: [4](#0-3) 

At line 568, it calculates: `last_received_version = request_start_version + num_received_versions - 1`, **assuming** transactions start at `request_start_version` without validation.

6. Stream's internal state is corrupted: it believes it has synced versions 100-199, but actually received 1000-1100
7. Next request will be for versions 200+, creating a **gap** in synchronized data (versions 100-199 are missing)
8. Client receives DataNotification with transactions for wrong versions, causing proof verification failures and stream retries

**Invariant Violations:**

This breaks the **State Consistency** invariant (#4): "State transitions must be atomic and verifiable via Merkle proofs." The stream service forwards unvalidated data that causes version tracking desynchronization, potentially leading to incomplete state with missing transaction ranges.

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple critical impact categories:

1. **State Inconsistencies**: Nodes can end up with gaps in their transaction history (e.g., missing versions 100-199), violating state consistency requirements. While proof verification should catch this at the client level, the corrupted stream tracking can cause persistent synchronization failures.

2. **Network Liveness Impact**: State sync is critical for nodes joining the network or recovering from downtime. By repeatedly sending malformed responses that bypass sanity checks, attackers can:
   - Force infinite retry loops
   - Corrupt version tracking to request wrong ranges
   - Prevent nodes from successfully synchronizing state
   - Cause resource exhaustion through repeated processing of invalid data

3. **Consensus Safety Risk**: If stream tracking corruption causes nodes to skip transaction ranges and request non-sequential versions, different nodes could potentially end up with different state views if the client-side validation is insufficient.

4. **DoS Vector**: Any malicious peer can exploit this without validator privileges, affecting all nodes performing state synchronization.

## Likelihood Explanation

**High Likelihood:**

1. **Easy to Exploit**: Any network peer can send malformed responses; no special privileges required
2. **No Authentication Barrier**: The vulnerability exists in the response validation logic accessible to all peers
3. **Fundamental Design Flaw**: The sanity check is insufficient by design, not an edge case
4. **Active Attack Surface**: State sync is constantly active as nodes join/recover
5. **No Rate Limiting**: Attackers can repeatedly send malformed responses to cause persistent DoS

The attack requires only:
- Ability to respond to data client requests (any peer can do this)
- Knowledge of the request format
- Crafting responses with correct payload types but wrong version ranges

## Recommendation

Add comprehensive validation to verify response data matches request parameters. The sanity check should be enhanced to validate:

1. **Version Range Validation**: For `TransactionsWithProof` and `TransactionOutputsWithProof` responses, verify that `first_transaction_version` matches the requested `start_version`
2. **Epoch Validation**: Verify response epochs match request epochs
3. **Proof Version Validation**: Verify proof versions are correct

**Recommended Fix** in `data_stream.rs` - add a new validation function:

```rust
fn validate_response_data_correctness(
    data_client_request: &DataClientRequest,
    data_client_response: &Response<ResponsePayload>,
) -> bool {
    match data_client_request {
        DataClientRequest::TransactionsWithProof(request) => {
            if let ResponsePayload::TransactionsWithProof(txns) = &data_client_response.payload {
                // Validate version range
                if let Some(first_version) = txns.get_first_transaction_version() {
                    if first_version != request.start_version {
                        return false;
                    }
                }
                // Additional validations...
                true
            } else {
                false
            }
        },
        DataClientRequest::TransactionOutputsWithProof(request) => {
            if let ResponsePayload::TransactionOutputsWithProof(outputs) = &data_client_response.payload {
                if let Some(first_version) = outputs.get_first_output_version() {
                    if first_version != request.start_version {
                        return false;
                    }
                }
                true
            } else {
                false
            }
        },
        // Similar validation for other request types...
        _ => true
    }
}
```

Then call this function immediately after `sanity_check_client_response_type()` at line 469.

## Proof of Concept

```rust
#[tokio::test]
async fn test_version_range_mismatch_bypass() {
    use aptos_types::transaction::Version;
    
    // Setup: Create a data stream requesting versions 100-200
    let request = TransactionsWithProofRequest {
        start_version: 100,
        end_version: 200,
        proof_version: 200,
        include_events: false,
    };
    
    // Attacker creates response with transactions for versions 1000-1100
    // (instead of requested 100-200)
    let malicious_txns = create_transaction_list_with_proof(
        1000, // first_version - WRONG!
        1100, // last_version - WRONG!
        200,  // proof_version
    );
    
    let malicious_response = Response::new(
        response_context,
        ResponsePayload::TransactionsWithProof(malicious_txns)
    );
    
    let client_request = DataClientRequest::TransactionsWithProof(request);
    
    // BUG: Sanity check passes despite version mismatch
    assert!(sanity_check_client_response_type(&client_request, &malicious_response));
    
    // BUG: request_missing_data incorrectly assumes data starts at version 100
    // and calculates no missing data, when actually versions 100-200 are still missing
    let missing_data = create_missing_data_request(&client_request, &malicious_response.payload);
    assert!(missing_data.is_ok());
    assert!(missing_data.unwrap().is_none()); // Incorrectly reports no missing data!
    
    // Stream state becomes corrupted: thinks it has versions 100-199,
    // but actually received 1000-1100
    // Next request will be for version 200+, creating a gap
}
```

**Notes:**

The vulnerability exists because the validation architecture separates type checking (sanity check) from semantic validation (missing data check), but the semantic validation incorrectly assumes the sanity check has already verified data correctness. This creates a validation gap where type-correct but semantically incorrect responses bypass all checks, corrupting stream state and potentially causing incomplete state synchronization across the network.

### Citations

**File:** state-sync/data-streaming-service/src/data_stream.rs (L469-469)
```rust
                    if sanity_check_client_response_type(client_request, &client_response) {
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1148-1191)
```rust
/// Creates and returns a missing transactions request if the given client
/// response doesn't satisfy the original request. If the request is satisfied,
/// None is returned.
fn create_missing_transactions_request(
    request: &TransactionsWithProofRequest,
    response_payload: &ResponsePayload,
) -> Result<Option<DataClientRequest>, Error> {
    // Determine the number of requested transactions
    let num_requested_transactions = request
        .end_version
        .checked_sub(request.start_version)
        .and_then(|v| v.checked_add(1))
        .ok_or_else(|| {
            Error::IntegerOverflow("Number of requested transactions has overflown!".into())
        })?;

    // Identify the missing data if the request was not satisfied
    match response_payload {
        ResponsePayload::TransactionsWithProof(transactions_with_proof) => {
            // Check if the request was satisfied
            let num_received_transactions = transactions_with_proof.get_num_transactions() as u64;
            if num_received_transactions < num_requested_transactions {
                let start_version = request
                    .start_version
                    .checked_add(num_received_transactions)
                    .ok_or_else(|| Error::IntegerOverflow("Start version has overflown!".into()))?;
                Ok(Some(DataClientRequest::TransactionsWithProof(
                    TransactionsWithProofRequest {
                        start_version,
                        end_version: request.end_version,
                        proof_version: request.proof_version,
                        include_events: request.include_events,
                    },
                )))
            } else {
                Ok(None) // The request was satisfied!
            }
        },
        payload => Err(Error::AptosDataClientResponseIsInvalid(format!(
            "Invalid response payload found for transactions request: {:?}",
            payload
        ))),
    }
}
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1292-1379)
```rust
fn sanity_check_client_response_type(
    data_client_request: &DataClientRequest,
    data_client_response: &Response<ResponsePayload>,
) -> bool {
    match data_client_request {
        DataClientRequest::EpochEndingLedgerInfos(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::EpochEndingLedgerInfos(_)
            )
        },
        DataClientRequest::NewTransactionOutputsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionOutputsWithProof(_)
            )
        },
        DataClientRequest::NewTransactionsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionsWithProof(_)
            )
        },
        DataClientRequest::NewTransactionsOrOutputsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionsWithProof(_)
            ) || matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionOutputsWithProof(_)
            )
        },
        DataClientRequest::NumberOfStates(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::NumberOfStates(_)
            )
        },
        DataClientRequest::StateValuesWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::StateValuesWithProof(_)
            )
        },
        DataClientRequest::SubscribeTransactionsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionsWithProof(_)
            )
        },
        DataClientRequest::SubscribeTransactionOutputsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionOutputsWithProof(_)
            )
        },
        DataClientRequest::SubscribeTransactionsOrOutputsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionsWithProof(_)
            ) || matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionOutputsWithProof(_)
            )
        },
        DataClientRequest::TransactionsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::TransactionsWithProof(_)
            )
        },
        DataClientRequest::TransactionOutputsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::TransactionOutputsWithProof(_)
            )
        },
        DataClientRequest::TransactionsOrOutputsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::TransactionsWithProof(_)
            ) || matches!(
                data_client_response.payload,
                ResponsePayload::TransactionOutputsWithProof(_)
            )
        },
    }
}
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L543-595)
```rust
    fn create_notification_for_continuous_data(
        &mut self,
        request_start_version: Version,
        request_end_version: Version,
        client_response_payload: ResponsePayload,
        notification_id_generator: Arc<U64IdGenerator>,
    ) -> Result<DataNotification, Error> {
        // Check the number of received versions
        let num_received_versions = match &client_response_payload {
            ResponsePayload::TransactionsWithProof(transactions_with_proof) => {
                transactions_with_proof.get_num_transactions()
            },
            ResponsePayload::TransactionOutputsWithProof(outputs_with_proof) => {
                outputs_with_proof.get_num_outputs()
            },
            _ => invalid_response_type!(client_response_payload),
        };
        if num_received_versions == 0 {
            return Err(Error::AptosDataClientResponseIsInvalid(format!(
                "Received an empty continuous data response! Request: {:?}",
                self.request
            )));
        }

        // Identify the last received version and bound it appropriately
        let last_received_version = request_start_version
            .checked_add(num_received_versions as u64)
            .and_then(|version| version.checked_sub(1))
            .ok_or_else(|| Error::IntegerOverflow("Last received version has overflown!".into()))?;
        let last_received_version = bound_by_range(
            last_received_version,
            request_start_version,
            request_end_version,
        );

        // Update the stream version
        let target_ledger_info = self.get_target_ledger_info()?.clone();
        self.update_stream_version_and_epoch(
            request_start_version,
            request_end_version,
            &target_ledger_info,
            last_received_version,
        )?;

        // Create the data notification
        let data_notification = create_data_notification(
            notification_id_generator,
            client_response_payload,
            Some(target_ledger_info),
            self.clone().into(),
        )?;
        Ok(data_notification)
    }
```
