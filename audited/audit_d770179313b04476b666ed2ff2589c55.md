# Audit Report

## Title
Filter Bypass in EntryFunctionFilter: Module-Only Filters Completely Ignored

## Summary
The `EntryFunctionFilter` implementation contains a critical logic flaw where filtering by module name alone is completely bypassed. When both `address` and `function` fields are `None`, the module validation logic is skipped, causing all entry function transactions to pass through regardless of their actual module, completely violating the filter contract.

## Finding Description

The vulnerability exists in the `EntryFunctionFilter::matches` implementation. The filter validation allows creating filters with only the `module` field set, but the matching logic contains a conditional that skips module validation when both `address` and `function` are `None`. [1](#0-0) 

The validation correctly requires at least one field to be set, allowing configurations like `{ address: None, module: Some("coin"), function: None }`.

However, the matching logic contains a critical flaw: [2](#0-1) 

At line 196, the condition `if self.address.is_some() || self.function.is_some()` determines whether to validate the module. When BOTH are `None`, this condition is false, causing lines 197-207 (which contain the actual module validation logic) to be skipped entirely.

**Exploitation Flow:**

1. Indexer client creates filter: `EntryFunctionFilter { address: None, module: Some("coin"), function: None }`
2. Filter validation passes (at least one field is set)
3. Transaction arrives: `0x999::hacker::steal()`
4. `matches()` is called:
   - Line 192: `self.function` is `None`, so `matches(&"steal")` returns `true` (allow all)
   - Line 196: Both `address.is_some()` and `function.is_some()` are `false`, condition fails
   - Lines 197-207 are skipped (module is never checked!)
   - Line 210: Returns `true` - transaction allowed through

The client expects only `0x*::coin::*` transactions but receives ALL entry function transactions regardless of module. [3](#0-2) 

The filter is applied in the GRPC stream coordinator, meaning bypassed transactions are sent to clients over the network.

## Impact Explanation

This is a **Medium severity** issue under the Aptos bug bounty criteria. While the indexer GRPC service is not part of core consensus, it creates **state inconsistencies** in the data layer that could require intervention:

1. **Downstream Application Failures**: Applications relying on filtered indexer data may process unexpected transaction types, causing logic errors or incorrect business decisions
2. **Resource Exhaustion**: Clients receive significantly more data than expected, consuming bandwidth and processing resources
3. **Data Integrity Violations**: The indexer service provides incorrect query results, violating its contract with clients

The filter system is designed as a security boundary for data access - its complete failure represents a breakdown of that boundary. Given that the indexer infrastructure is part of the Aptos ecosystem and documented in official services, this qualifies as a state inconsistency requiring intervention.

## Likelihood Explanation

**Likelihood: High**

This vulnerability will trigger in any scenario where:
1. A client creates a module-only filter (a documented and expected use case)
2. Any entry function transaction is processed

The bug is deterministic and requires no special conditions. Module-only filtering is a legitimate and intuitive use case (e.g., "show me all transactions interacting with the coin module"). The validation explicitly allows this configuration, making it highly likely to be used in production.

## Recommendation

Fix the conditional logic in `EntryFunctionFilter::matches` to check the module field directly rather than inferring its presence from other fields:

```rust
fn matches(&self, module_id: &EntryFunctionId) -> bool {
    if !self.function.matches(&module_id.name) {
        return false;
    }

    // Always check module and address if they are set, regardless of other fields
    if let Some(module) = module_id.module.as_ref() {
        if !self.get_standardized_address()
            .matches(&standardize_address(&module.address))
        {
            return false;
        }
        if !self.module.matches(&module.name) {
            return false;
        }
    } else {
        // If we're filtering by address or module but transaction has no module, reject
        if self.address.is_some() || self.module.is_some() {
            return false;
        }
    }

    true
}
```

This ensures module and address filters are always evaluated when present, eliminating the ambiguity.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_protos::transaction::v1::{EntryFunctionId, MoveModuleId};

    #[test]
    fn test_module_only_filter_bypass() {
        // Create a module-only filter (should match only "coin" module)
        let filter = EntryFunctionFilter {
            address: None,
            module: Some("coin".to_string()),
            function: None,
            standardized_address: OnceCell::new(),
        };

        // This filter passes validation
        assert!(filter.validate_state().is_ok());

        // Create an entry function ID for a DIFFERENT module
        let entry_function = EntryFunctionId {
            module: Some(MoveModuleId {
                address: "0x999".to_string(),
                name: "hacker".to_string(), // NOT "coin"!
            }),
            name: "steal".to_string(),
        };

        // BUG: Filter incorrectly matches despite module mismatch
        assert!(
            !filter.matches(&entry_function),
            "Module-only filter should reject transactions from different modules, but it doesn't!"
        );
    }
}
```

This test will FAIL with the current implementation, demonstrating that the module filter is completely bypassed when used alone. The filter should reject the `hacker` module but incorrectly allows it through.

---

## Notes

This vulnerability demonstrates the security question's concern about "ambiguous behavior where some None means 'allow all' and other None means 'match nothing'". The `None` values for `address` and `function` create an unintended side effect where the module filter (which is `Some`) gets silently disabled, representing exactly the kind of semantic ambiguity the question warned about in nested Option-based filter composition.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L183-187)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.address.is_none() && self.module.is_none() && self.function.is_none() {
            return Err(anyhow!("At least one of address, name or function must be set").into());
        };
        Ok(())
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L191-211)
```rust
    fn matches(&self, module_id: &EntryFunctionId) -> bool {
        if !self.function.matches(&module_id.name) {
            return false;
        }

        if self.address.is_some() || self.function.is_some() {
            if let Some(module) = &module_id.module.as_ref() {
                if !(self
                    .get_standardized_address()
                    .matches(&standardize_address(&module.address))
                    && self.module.matches(&module.name))
                {
                    return false;
                }
            } else {
                return false;
            }
        }

        true
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L175-182)
```rust
                let pb_txns = if let Some(ref filter) = filter {
                    pb_txns
                        .into_iter()
                        .filter(|txn| filter.matches(txn))
                        .collect::<Vec<_>>()
                } else {
                    pb_txns
                };
```
