# Audit Report

## Title
Write Operation Limit Bypass via Unmaterialized Aggregator Deltas and Delayed Field Changes

## Summary
The `num_write_ops()` function in the `ChangeSetInterface` trait implementation for `VMChangeSet` fails to count aggregator v1 delta operations and delayed field changes. These unmaterialized changes bypass the `max_write_ops_per_transaction` limit check but are later converted into actual write operations during materialization, allowing transactions to exceed the intended write operation limit of 8,192 operations.

## Finding Description
The vulnerability exists in how write operations are counted for transaction validation. The implementation has a critical logic flaw in the sequence of operations:

The `num_write_ops()` method only counts two types of write operations: [1](#0-0) 

However, the `VMChangeSet` structure contains additional write operation containers that are NOT counted: [2](#0-1) 

During transaction execution, aggregator operations create delta entries that are stored in `aggregator_v1_delta_set`: [3](#0-2) 

The validation occurs via `check_change_set()` which uses `num_write_ops()` to enforce the limit: [4](#0-3) 

This check is called during `UserSessionChangeSet::new()` before materialization: [5](#0-4) 

However, materialization happens AFTER this check in the execution flow: [6](#0-5) 

During materialization, each delta is converted into a separate write operation: [7](#0-6) 

**Attack Path:**
1. Attacker creates a transaction that performs many aggregator v1 add/sub operations or delayed field operations
2. Each operation creates a delta entry in `aggregator_v1_delta_set` or an entry in `delayed_field_change_set`
3. Transaction validation calls `check_change_set()` which only counts regular writes in `resource_write_set` and `aggregator_v1_write_set`
4. Check passes because deltas are not counted (e.g., 100 regular writes + 8,100 deltas = 100 counted operations)
5. Transaction commits successfully
6. Post-commit, `try_materialize_aggregator_v1_delta_set()` converts all 8,100 deltas into write operations
7. Total materialized writes: 8,200 operations, exceeding the 8,192 limit by 8 operations

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation
This is a **High Severity** vulnerability according to Aptos bug bounty criteria:

**Validator Node Slowdowns**: Transactions with thousands of unmaterialized deltas can bypass the write operation limit, causing excessive storage writes during materialization. This leads to:
- Increased disk I/O during state commitment
- Memory pressure from holding large change sets
- Slower block processing affecting validator performance

**Resource Exhaustion**: An attacker can repeatedly submit transactions that exploit this bypass to:
- Consume excessive storage bandwidth
- Increase state bloat beyond intended limits
- Degrade overall network performance

The `max_write_ops_per_transaction` limit exists specifically to prevent such resource exhaustion attacks. The default limit is 8,192 write operations: [8](#0-7) 

## Likelihood Explanation
**Likelihood: High**

The vulnerability is highly likely to be exploited because:

1. **Low Attack Complexity**: Any user can create aggregator operations through Move smart contracts or direct aggregator v2 API calls
2. **No Special Privileges Required**: Standard transaction senders can exploit this without validator access
3. **Measurable Profit**: Attackers can cause disproportionate resource consumption relative to gas paid
4. **Easy to Discover**: The code comment explicitly acknowledges deltas are excluded from counting: [9](#0-8) 

The attack requires only creating a Move module that performs many aggregator operations in a loop, which is a standard programming pattern.

## Recommendation
The `num_write_ops()` method must count all operations that will eventually become write operations after materialization. 

**Recommended Fix:**

Modify the `num_write_ops()` implementation to include both delta sets and delayed field changes:

```rust
fn num_write_ops(&self) -> usize {
    self.resource_write_set().len() 
        + self.aggregator_v1_write_set().len()
        + self.aggregator_v1_delta_set().len()  // Add delta count
        + self.delayed_field_change_set().len()  // Add delayed field count
}
```

**Alternative Solution:**

If deltas should legitimately not count toward the limit (for optimization reasons), then add a separate validation check AFTER materialization in the execution flow:

```rust
// After materialization in executor.rs
output.legacy_sequential_materialize_agg_v1(&latest_view);
let output_after_materialization = output.before_materialization()?;

// Validate total write ops after materialization
change_set_configs.check_change_set(&output_after_materialization)?;
```

## Proof of Concept

```move
// Save as sources/write_op_bypass_poc.move
module attacker::write_op_bypass {
    use aptos_framework::aggregator_v2::{Self, Aggregator};
    use std::vector;

    struct AggregatorStore has key {
        aggregators: vector<Aggregator<u64>>,
    }

    /// Creates many aggregator deltas to bypass write op limit
    public entry fun exploit_write_limit(account: &signer) {
        // Create 9000 aggregators (more than the 8192 limit)
        let aggregators = vector::empty<Aggregator<u64>>();
        let i = 0;
        
        while (i < 9000) {
            let agg = aggregator_v2::create_aggregator<u64>(1000000);
            // Each add() creates a delta entry in aggregator_v1_delta_set
            aggregator_v2::add(&mut agg, 1);
            vector::push_back(&mut aggregators, agg);
            i = i + 1;
        };

        move_to(account, AggregatorStore { aggregators });
        
        // At this point:
        // - num_write_ops() counts only 1 resource write (AggregatorStore)
        // - But we have 9000 aggregator deltas that will be materialized
        // - After materialization: 1 resource + 9000 aggregator writes = 9001 total
        // - This exceeds the 8192 limit but bypasses the check!
    }
}
```

**Rust Reproduction Steps:**

1. Deploy the Move module above to a test account
2. Submit a transaction calling `exploit_write_limit`
3. Observe that `check_change_set()` validation passes (only 1 write counted)
4. After execution, observe materialization converts 9,000 deltas to write ops
5. Confirm total write operations (9,001) exceeds the configured limit (8,192)
6. Measure validator node performance degradation during state commitment

The vulnerability is confirmed by the code structure where validation precedes materialization with incomplete write operation counting.

### Citations

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L81-92)
```rust
pub struct VMChangeSet {
    resource_write_set: BTreeMap<StateKey, AbstractResourceWriteOp>,
    events: Vec<(ContractEvent, Option<MoveTypeLayout>)>,

    // Changes separated out from the writes, for better concurrency,
    // materialized back into resources when transaction output is computed.
    delayed_field_change_set: BTreeMap<DelayedFieldID, DelayedChange<DelayedFieldID>>,

    // TODO[agg_v1](cleanup) deprecate aggregator_v1 fields.
    aggregator_v1_write_set: BTreeMap<StateKey, WriteOp>,
    aggregator_v1_delta_set: BTreeMap<StateKey, DeltaOp>,
}
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L391-397)
```rust
        let aggregator_v1_delta_set = std::mem::take(&mut self.aggregator_v1_delta_set);
        let materialized_aggregator_delta_set = aggregator_v1_delta_set
            .into_iter()
            .map(into_write)
            .collect::<VMResult<BTreeMap<StateKey, WriteOp>>>()?;
        self.aggregator_v1_write_set
            .extend(materialized_aggregator_delta_set);
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L856-860)
```rust
    fn num_write_ops(&self) -> usize {
        // Note: we only use resources and aggregators because they use write ops directly,
        // and deltas & events are not part of these.
        self.resource_write_set().len() + self.aggregator_v1_write_set().len()
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L493-495)
```rust
                AggregatorChangeV1::Merge(delta_op) => {
                    aggregator_v1_delta_set.insert(state_key, delta_op);
                },
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L82-82)
```rust
            params.max_write_ops_per_transaction.into(),
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L95-99)
```rust
        if self.max_write_ops_per_transaction != 0
            && change_set.num_write_ops() as u64 > self.max_write_ops_per_transaction
        {
            return storage_write_limit_reached(Some("Too many write ops."));
        }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/session_change_sets.rs (L33-33)
```rust
        change_set_configs.check_change_set(&user_session_change_set)?;
```

**File:** aptos-move/block-executor/src/executor.rs (L2304-2312)
```rust
                    block_limit_processor.accumulate_fee_statement(
                        output_before_guard.fee_statement(),
                        read_write_summary,
                        approx_output_size,
                    );

                    // Drop to acquire a write lock, then re-assign the output_before_guard.
                    drop(output_before_guard);
                    output.legacy_sequential_materialize_agg_v1(&latest_view);
```
