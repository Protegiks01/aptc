# Audit Report

## Title
Race Condition in Peer Monitoring Service Causes Version-Timestamp Invariant Violations

## Summary
The peer monitoring service's `StorageReader` implementation makes separate, non-atomic calls to retrieve ledger metadata, allowing concurrent commits to cause inconsistent responses where version and timestamp come from different ledger states, violating the blockchain invariant that these values should always correspond to the same committed block.

## Finding Description

The `StorageReader` implementation in `peer-monitoring-service/server/src/storage.rs` provides three separate methods that each independently call `get_latest_ledger_info()`: [1](#0-0) 

Each method makes an independent call to retrieve the latest ledger info from storage. When these methods are called sequentially by `get_node_information()`, a race condition can occur: [2](#0-1) 

**Attack Scenario:**

1. At time T1, `get_highest_synced_epoch_and_version()` is called (line 264-265), which internally calls `get_latest_ledger_info()` and retrieves ledger state L1 with (epoch=E1, version=V1, timestamp=T1)

2. Between time T1 and T2, a new block commits, advancing the ledger to state L2 with (epoch=E1, version=V2, timestamp=T2) where V2 > V1 and T2 > T1

3. At time T2, `get_ledger_timestamp_usecs()` is called (line 266), which internally calls `get_latest_ledger_info()` again and retrieves the new ledger state L2, returning timestamp=T2

4. The resulting `NodeInformationResponse` contains: {highest_synced_version: V1, ledger_timestamp_usecs: T2}

This violates the blockchain invariant that a specific version should always be associated with its corresponding timestamp. The response incorrectly claims that version V1 has timestamp T2, when in reality timestamp T2 belongs to version V2.

The Aptos blockchain enforces timestamp monotonicity at the consensus level, as documented in the codebase. A `LedgerInfo` is an atomic unit containing epoch, version, and timestamp from a single committed block. By splitting the retrieval across multiple calls, the peer monitoring service breaks this atomicity.

Notably, the `DbReader` interface provides a proper atomic method `get_latest_commit_metadata()` that retrieves both version and timestamp in a single call: [3](#0-2) 

However, the peer monitoring service does not use this method and instead makes separate calls.

## Impact Explanation

This issue constitutes a **Medium to High severity** finding based on the Aptos bug bounty criteria:

**Medium Severity Impact:**
- Creates state inconsistencies in peer monitoring metadata that could require intervention
- Violates documented protocol invariants about version-timestamp correspondence

**High Severity Impact (if applicable):**
- Could be classified as a "significant protocol violation" since it breaks a fundamental blockchain invariant
- The inconsistent data is used by mempool for peer health assessment and prioritization

The `ledger_timestamp_usecs` field is used by mempool's `check_peer_metadata_health()` function to determine peer health: [4](#0-3) 

If a peer reports version V1 with timestamp T2 (where T2 corresponds to a later version V2), the peer may appear more synchronized than it actually is, potentially affecting transaction routing decisions in the mempool.

While this does not directly break consensus safety or cause fund loss, it does compromise the integrity of peer monitoring data and could lead to suboptimal network behavior.

## Likelihood Explanation

**Likelihood: Medium to High**

This race condition will occur whenever:
1. A peer monitoring service request is received during active block production
2. A block commits between the two storage method calls (approximately microseconds apart)
3. High transaction throughput environments increase commit frequency, raising the probability

On a high-performance blockchain like Aptos with sub-second block times, this race window, while small, will be hit regularly across the network. Any monitoring client polling multiple peers will eventually observe inconsistent version-timestamp pairs.

The issue requires no attacker action - it occurs naturally during normal operation. However, an attacker could increase the likelihood by:
- Repeatedly querying peers during known high-activity periods
- Using the inconsistent data to make false claims about peer reliability

## Recommendation

**Solution: Make ledger metadata retrieval atomic**

Modify the `StorageReader` implementation to fetch all required metadata in a single call. Replace the separate methods with a unified approach:

```rust
impl StorageReaderInterface for StorageReader {
    fn get_highest_synced_epoch_and_version(&self) -> Result<(u64, u64), Error> {
        let latest_ledger_info = self.get_latest_ledger_info()?;
        Ok((latest_ledger_info.epoch(), latest_ledger_info.version()))
    }

    fn get_ledger_timestamp_usecs(&self) -> Result<u64, Error> {
        let latest_ledger_info = self.get_latest_ledger_info()?;
        Ok(latest_ledger_info.timestamp_usecs())
    }
    
    // ... rest of implementation
}
```

**Better Solution: Cache the LedgerInfo and use it for all fields**

Modify `Handler::get_node_information()` to retrieve the ledger info once and extract all needed fields:

```rust
fn get_node_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
    let build_information = aptos_build_info::get_build_information();
    let current_time: Instant = self.time_service.now();
    let uptime = current_time.duration_since(self.start_time);
    
    // Get all ledger metadata from a single snapshot
    let latest_ledger_info = self.storage.get_latest_ledger_info()?;
    let highest_synced_epoch = latest_ledger_info.ledger_info().epoch();
    let highest_synced_version = latest_ledger_info.ledger_info().version();
    let ledger_timestamp_usecs = latest_ledger_info.ledger_info().timestamp_usecs();
    
    let lowest_available_version = self.storage.get_lowest_available_version()?;

    let node_information_response = NodeInformationResponse {
        build_information,
        highest_synced_epoch,
        highest_synced_version,
        ledger_timestamp_usecs,
        lowest_available_version,
        uptime,
    };
    Ok(PeerMonitoringServiceResponse::NodeInformation(node_information_response))
}
```

This ensures all metadata comes from the same ledger state snapshot, preserving the version-timestamp invariant.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_storage_interface::mock::MockDbReaderWriter;
    use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
    use aptos_types::block_info::BlockInfo;
    use std::sync::Arc;
    use std::sync::atomic::{AtomicU64, Ordering};
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_race_condition_version_timestamp_mismatch() {
        // Create a mock storage that simulates concurrent commits
        let storage = Arc::new(MockDbReaderWriter::new());
        let version_counter = Arc::new(AtomicU64::new(100));
        let timestamp_counter = Arc::new(AtomicU64::new(1000000));
        
        // Spawn a background thread that simulates commits
        let version_counter_clone = version_counter.clone();
        let timestamp_counter_clone = timestamp_counter.clone();
        let commit_thread = thread::spawn(move || {
            for _ in 0..1000 {
                version_counter_clone.fetch_add(1, Ordering::SeqCst);
                timestamp_counter_clone.fetch_add(1000, Ordering::SeqCst);
                thread::sleep(Duration::from_micros(100));
            }
        });
        
        let storage_reader = StorageReader::new(storage);
        
        // Repeatedly call the methods and check for inconsistencies
        let mut inconsistency_found = false;
        for _ in 0..500 {
            let (_, version_1) = storage_reader.get_highest_synced_epoch_and_version().unwrap();
            // Small delay to increase chance of commit happening between calls
            thread::sleep(Duration::from_micros(50));
            let timestamp_1 = storage_reader.get_ledger_timestamp_usecs().unwrap();
            
            // Get a consistent snapshot for comparison
            thread::sleep(Duration::from_micros(50));
            let (_, version_2) = storage_reader.get_highest_synced_epoch_and_version().unwrap();
            let timestamp_2 = storage_reader.get_ledger_timestamp_usecs().unwrap();
            
            // Check if we got version from one state and timestamp from another
            if version_1 == version_2 && timestamp_1 != timestamp_2 {
                inconsistency_found = true;
                println!("Inconsistency detected: version={}, timestamp1={}, timestamp2={}", 
                         version_1, timestamp_1, timestamp_2);
                break;
            }
        }
        
        commit_thread.join().unwrap();
        assert!(inconsistency_found, "Race condition should cause version-timestamp mismatch");
    }
}
```

**Note:** This PoC demonstrates the race condition concept. The actual implementation would need to properly mock the `DbReader` interface to simulate concurrent state changes during the `get_latest_ledger_info()` calls.

---

## Notes

While this vulnerability does not directly compromise consensus safety or enable fund theft, it represents a clear violation of the blockchain's version-timestamp consistency invariant. The inconsistent monitoring data could lead to incorrect peer health assessments in the mempool and confusion in network monitoring. The fix is straightforward: ensure atomic retrieval of related ledger metadata fields from a single snapshot.

### Citations

**File:** peer-monitoring-service/server/src/storage.rs (L45-53)
```rust
    fn get_highest_synced_epoch_and_version(&self) -> Result<(u64, u64), Error> {
        let latest_ledger_info = self.get_latest_ledger_info()?;
        Ok((latest_ledger_info.epoch(), latest_ledger_info.version()))
    }

    fn get_ledger_timestamp_usecs(&self) -> Result<u64, Error> {
        let latest_ledger_info = self.get_latest_ledger_info()?;
        Ok(latest_ledger_info.timestamp_usecs())
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L264-267)
```rust
        let (highest_synced_epoch, highest_synced_version) =
            self.storage.get_highest_synced_epoch_and_version()?;
        let ledger_timestamp_usecs = self.storage.get_ledger_timestamp_usecs()?;
        let lowest_available_version = self.storage.get_lowest_available_version()?;
```

**File:** storage/storage-interface/src/lib.rs (L540-544)
```rust
    fn get_latest_commit_metadata(&self) -> Result<(Version, u64)> {
        let ledger_info_with_sig = self.get_latest_ledger_info()?;
        let ledger_info = ledger_info_with_sig.ledger_info();
        Ok((ledger_info.version(), ledger_info.timestamp_usecs()))
    }
```

**File:** mempool/src/shared_mempool/priority.rs (L562-589)
```rust
fn check_peer_metadata_health(
    mempool_config: &MempoolConfig,
    time_service: &TimeService,
    monitoring_metadata: &Option<&PeerMonitoringMetadata>,
) -> bool {
    monitoring_metadata
        .and_then(|metadata| {
            metadata
                .latest_node_info_response
                .as_ref()
                .map(|node_information_response| {
                    // Get the peer's ledger timestamp and the current timestamp
                    let peer_ledger_timestamp_usecs =
                        node_information_response.ledger_timestamp_usecs;
                    let current_timestamp_usecs = get_timestamp_now_usecs(time_service);

                    // Calculate the max sync lag before the peer is considered unhealthy (in microseconds)
                    let max_sync_lag_secs =
                        mempool_config.max_sync_lag_before_unhealthy_secs as u64;
                    let max_sync_lag_usecs = max_sync_lag_secs * MICROS_PER_SECOND;

                    // Determine if the peer is healthy
                    current_timestamp_usecs.saturating_sub(peer_ledger_timestamp_usecs)
                        < max_sync_lag_usecs
                })
        })
        .unwrap_or(false) // If metadata is missing, consider the peer unhealthy
}
```
