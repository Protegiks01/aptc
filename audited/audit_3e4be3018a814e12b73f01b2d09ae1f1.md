# Audit Report

## Title
Redis Credentials Exposed in Stdout Logs During Indexer Data Service Startup

## Summary
The indexer-grpc-data-service exposes Redis connection URLs containing potential credentials to stdout during startup through debug logging, regardless of whether the service successfully starts or fails. This violates the principle of failing safely without exposing sensitive configuration data.

## Finding Description

The service logs Redis connection details to stdout during the initialization phase. [1](#0-0) 

The Redis URL is printed using Debug formatting (`{:?}`), which outputs the complete URL including any embedded credentials. Redis URLs commonly follow the format `redis://username:password@host:port/db`, where authentication credentials are embedded directly in the URL string.

The `RedisUrl` type is a wrapper around `url::Url` [2](#0-1)  with a derived Debug implementation that exposes the full URL contents.

**Attack Path:**
1. Service is configured with Redis URL containing credentials (e.g., `redis://user:secretpass@redis.internal:6379`)
2. Service starts and enters the `run()` method
3. Line 162-165 prints the Redis URL to stdout before attempting connection
4. If any subsequent failure occurs (Redis connection failure, cache initialization failure, server setup failure), the credentials have already been exposed
5. Stdout logs are typically captured by logging infrastructure (systemd, Docker, Kubernetes, log aggregation services)
6. Attacker with access to log storage or monitoring systems can extract the credentials
7. Attacker uses credentials to access Redis, potentially reading/modifying cached data or disrupting service

The vulnerability exists in the normal startup flow, not just during error conditions. The credentials are exposed to stdout on every service start, regardless of success or failure.

## Impact Explanation

This qualifies as a **Low to Medium severity information disclosure vulnerability**:

- **Information Exposure**: Redis credentials that could grant unauthorized access to the caching layer
- **Potential for Escalation**: Compromised Redis access could allow:
  - Reading cached blockchain transaction data
  - Manipulating cache contents to serve incorrect data
  - Denial of service through cache poisoning or deletion
  - Pivoting to other services if Redis is shared

While this is an auxiliary indexing service (not core consensus), credential exposure in logs is a well-recognized security anti-pattern. The question explicitly designates this as "(Medium)" severity, reflecting that while it doesn't directly affect blockchain consensus, it compromises infrastructure security that supports the ecosystem.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability will trigger in common deployment scenarios:
1. **Redis with authentication** is a standard security practice, meaning credentials will be in the URL
2. **Stdout log collection** is universal in production environments (Docker, Kubernetes, systemd all capture stdout)
3. **Log aggregation systems** (Splunk, ELK, CloudWatch, etc.) store these logs, expanding the attack surface
4. **No special conditions required** - happens on every service start

The barrier to exploitation is relatively low: an attacker needs access to log storage systems, which may be compromised through:
- Misconfigured log access controls
- Compromised log aggregation infrastructure
- Insider threats
- Cloud provider breaches

## Recommendation

**Immediate Fix:** Remove the debug logging of the Redis URL. Replace with a sanitized log message:

```rust
// BEFORE (vulnerable):
println!(
    ">>>> Starting Redis connection: {:?}",
    &self.redis_read_replica_address.0
);

// AFTER (secure):
tracing::info!(
    "Starting Redis connection to host: {}:{}",
    self.redis_read_replica_address.host_str().unwrap_or("unknown"),
    self.redis_read_replica_address.port().unwrap_or(6379)
);
```

**Additional Recommendations:**
1. Audit all `println!` statements in startup code for similar credential exposure
2. Use structured logging (`tracing`) instead of `println!` for better control
3. Implement a custom Debug implementation for `RedisUrl` that masks credentials:

```rust
impl std::fmt::Debug for RedisUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "redis://[REDACTED]@{}:{}", 
            self.host_str().unwrap_or("unknown"),
            self.port().unwrap_or(6379))
    }
}
```

4. Use environment variables or secret management systems for credentials instead of embedding in URLs

## Proof of Concept

**Setup:**
1. Configure the indexer-grpc-data-service with a Redis URL containing credentials:
```yaml
redis_read_replica_address: "redis://indexer:MySecretPassword123@redis-host:6379"
```

2. Start the service:
```bash
cargo run --bin aptos-indexer-grpc-data-service -- --config-path config.yaml 2>&1 | tee startup.log
```

3. Observe the stdout output:
```
>>>> Starting Redis connection: Url { scheme: "redis", cannot_be_a_base: false, username: "indexer", password: Some("MySecretPassword123"), host: Some(Domain("redis-host")), port: Some(6379), path: "/", query: None, fragment: None }
```

The password `MySecretPassword123` is visible in the Debug output.

**Expected Result:** The credentials should NOT appear in any logs.

**Actual Result:** The full Redis URL including the password field is printed to stdout during every service startup, where it is captured by logging infrastructure and persists in log files and monitoring systems.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L162-165)
```rust
        println!(
            ">>>> Starting Redis connection: {:?}",
            &self.redis_read_replica_address.0
        );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/types.rs (L12-14)
```rust
/// A URL that only allows the redis:// scheme.
#[derive(Clone, Debug, Eq, PartialEq, Serialize)]
pub struct RedisUrl(pub Url);
```
