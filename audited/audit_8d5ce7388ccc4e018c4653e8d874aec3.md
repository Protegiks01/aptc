# Audit Report

## Title
Constant-Time Cryptographic Operation Verification Gap in CI/CD Allows Potential Timing Attack Regressions in Validator Randomness Beacon

## Summary
The constant-time property tests for BLS12-381 scalar multiplication are not run in CI/CD pipelines, creating a regression risk where timing-vulnerable code could be deployed to validators participating in the DKG randomness beacon without detection.

## Finding Description

The Aptos codebase uses BLS12-381 scalar multiplication in the validator randomness beacon system through the Weighted Verifiable Unpredictable Function (WVUF). This operation must be constant-time to prevent timing attacks that could leak validator secret key shares.

**The Testing Gap:**

1. Constant-time verification tests exist but are marked `#[ignore]` and require explicit `--release --ignored` flags: [1](#0-0) 

2. Example files exist but are not executed in CI: [2](#0-1) 

3. CI/CD workflows do NOT run these tests with the required flags: [3](#0-2) 

4. The pepper service runs constant-time checks on startup, but **validator nodes do not**: [4](#0-3) 

**Where Timing Vulnerabilities Matter:**

Validators use scalar multiplication in the randomness beacon WVUF implementation: [5](#0-4) 

The VUF evaluation function performs scalar multiplication with secret keys: [6](#0-5) 

The pepper service VUF also uses constant-time-critical operations: [7](#0-6) 

**Attack Scenario:**
1. A code change introduces timing variance in blstrs scalar multiplication
2. CI/CD passes (no constant-time tests run)
3. Pepper service deployment fails (has startup checks) ✓
4. Validator nodes deploy successfully (no startup checks) ✗
5. Network adversary measures timing variations in randomness generation responses
6. Statistical analysis correlates timing with secret key bits
7. With sufficient measurements, adversary recovers validator secret key shares
8. Adversary can predict/manipulate future randomness once threshold shares are recovered

## Impact Explanation

**Medium Severity** - This represents a testing gap rather than an active vulnerability. However, if exploited after a regression:

- **Randomness Manipulation**: Recovery of validator secret key shares would allow prediction and potential manipulation of the randomness beacon
- **Consensus Impact**: Randomness beacon is critical for leader election and transaction ordering
- **Scope**: Affects all validators participating in DKG (full validator set)

The impact is limited by:
- Requires a regression to be introduced first
- Pepper service checks provide partial protection
- Timing attacks over networks are complex and may not be feasible
- The underlying blstrs library likely already implements constant-time operations correctly

## Likelihood Explanation

**Low to Medium Likelihood:**

**Factors Increasing Likelihood:**
- No CI/CD verification means regressions could be introduced unknowingly
- Validator nodes lack startup verification that pepper service has
- Scalar multiplication is used in production cryptographic operations

**Factors Decreasing Likelihood:**
- The blstrs library is likely already constant-time (tests verify existing behavior)
- Pepper service startup checks would catch regressions affecting BLS operations
- Timing attacks over network are extremely difficult and may not be practical
- Code review processes may catch obvious timing vulnerabilities
- The constant-time properties are tested manually during development

## Recommendation

**Immediate Actions:**

1. **Add CI/CD Constant-Time Verification Job:**
   Add to `.github/workflows/lint-test.yaml`:
   ```yaml
   rust-constant-time-tests:
     runs-on: runs-on,cpu=64,family=c7,disk=large,image=aptos-ubuntu-x64,run-id=${{ github.run_id }}
     if: github.event_name == 'push' || contains(github.event.pull_request.labels.*.name, 'CICD:run-all-unit-tests')
     steps:
       - uses: actions/checkout@v4
       - name: Run constant-time verification tests
         run: |
           cargo test --release -p aptos-crypto test_blstrs_fixed_base_g1_scalar_mul_is_constant_time -- --ignored --nocapture
           cargo test --release -p aptos-crypto test_blstrs_random_base_g1_scalar_mul_is_constant_time -- --ignored --nocapture
   ```

2. **Add Validator Node Startup Checks:**
   Extend validator node initialization to verify constant-time properties similar to pepper service: [8](#0-7) 

3. **Document Testing Requirements:**
   Add to `crates/aptos-crypto/README.md` requiring constant-time tests to pass before merging crypto changes.

## Proof of Concept

**Demonstrating the Gap (Not an Exploit):**

This PoC shows that constant-time tests are not run in normal CI:

```rust
// File: crates/aptos-crypto/src/lib.rs (hypothetical regression)
// Add a deliberately non-constant-time operation to demonstrate the gap

#[cfg(test)]
mod regression_demonstration {
    use blstrs::{G1Projective, Scalar};
    use group::Group;
    use std::ops::Mul;
    
    // This function introduces timing variance based on scalar value
    // In a real regression, this could be accidental
    fn non_constant_time_mul(base: &G1Projective, scalar: &Scalar) -> G1Projective {
        // Hypothetical: early exit for zero (introduces timing leak)
        if scalar == &Scalar::zero() {
            return G1Projective::identity();
        }
        base.mul(scalar)
    }
    
    #[test]
    fn test_regression_would_pass_normal_ci() {
        // This test passes in normal CI
        let base = G1Projective::generator();
        let scalar = Scalar::from(42u64);
        let _ = non_constant_time_mul(&base, &scalar);
        // Normal functional tests pass, but constant-time property is violated
    }
}
```

**To verify the gap exists:**
```bash
# 1. Normal CI tests run without --ignored flag
cargo nextest run --profile ci --workspace --exclude smoke-test

# 2. Constant-time tests are NOT run (marked #[ignore])
# They require explicit: cargo test --release --ignored

# 3. Validator nodes don't verify constant-time on startup
# Only pepper service does (see main.rs lines 402-410)
```

The PoC demonstrates the testing gap exists but cannot demonstrate an actual timing attack, as:
1. The blstrs library correctly implements constant-time operations
2. Network timing attacks require sophisticated statistical analysis
3. No actual regression currently exists in the codebase

**Notes**

This finding identifies a **defensive testing gap** rather than an active vulnerability. The core issue is that constant-time property verification is:

1. ✓ Implemented in test code [9](#0-8) 
2. ✓ Enforced in pepper service production [10](#0-9) 
3. ✗ NOT run in CI/CD pipelines [11](#0-10) 
4. ✗ NOT enforced in validator node startup

The actual cryptographic operations are likely already constant-time due to the blstrs library implementation. However, without continuous verification in CI/CD, future regressions could be introduced inadvertently. The pepper service provides partial protection by running these checks at startup, but validators (which use the same scalar multiplication in the randomness beacon) lack this safeguard.

### Citations

**File:** crates/aptos-crypto/src/unit_tests/constant_time_test.rs (L1-63)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::constant_time;
use dudect_bencher::ctbench::{run_bench, BenchName};
use more_asserts::assert_le;
use num_traits::ToPrimitive;

#[test]
#[ignore]
/// WARNING: This is marked as "ignored" because unit tests are typically run in debug mode, and we
/// would need this to run in release mode to make sure the dudect framework's statistical measurements
/// are meaningful.
///
/// Nonetheless, we wrote this test to serve as an example for how to call the dudect framework
/// manually, without using the macros that would generate a `main` function, which would not work
/// if we want to run these tests in some other `main` function (like the pepper service).
///
/// To run this test properly, do:
///
///    cargo test --release test_blstrs_fixed_base_g1_scalar_mul_is_constant_time -- --ignored --nocapture
///
fn test_blstrs_fixed_base_g1_scalar_mul_is_constant_time() {
    let ct_summary = run_bench(
        &BenchName("blstrs_scalar_mul_fixed_base"),
        constant_time::blstrs_scalar_mul::run_bench_with_fixed_bases,
        None,
    )
    .1;

    eprintln!("{:?}", ct_summary);

    let max_t = ct_summary
        .max_t
        .abs()
        .to_i64()
        .expect("Floating point arithmetic went awry.");
    assert_le!(max_t, 5);
}

#[test]
#[ignore]
/// To run this test properly, do:
///
///    cargo test --release test_blstrs_random_base_g1_scalar_mul_is_constant_time -- --ignored --nocapture
///
fn test_blstrs_random_base_g1_scalar_mul_is_constant_time() {
    let ct_summary = run_bench(
        &BenchName("blstrs_scalar_mul_random_base"),
        constant_time::blstrs_scalar_mul::run_bench_with_random_bases,
        None,
    )
    .1;

    eprintln!("{:?}", ct_summary);

    let max_t = ct_summary
        .max_t
        .abs()
        .to_i64()
        .expect("Floating point arithmetic went awry.");
    assert_le!(max_t, 5);
}
```

**File:** crates/aptos-crypto/examples/is_zkcrypto_constant_time.rs (L1-7)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

pub use aptos_crypto::constant_time;
use dudect_bencher::ctbench_main;

ctbench_main!(constant_time::zkcrypto_scalar_mul::run_bench);
```

**File:** .github/actions/rust-unit-tests/action.yaml (L32-46)
```yaml
    - name: Run all unit tests
      run: |
        cargo nextest run \
          --profile ci \
          --cargo-profile ci \
          --locked \
          --workspace \
          --exclude smoke-test \
          --exclude aptos-testcases \
          --exclude aptos-keyless-circuit \
          --retries 3 \
          --no-fail-fast \
          --message-format libtest-json > nextest_output.json || python3 .github/actions/rust-unit-tests/nextest_summary.py nextest_output.json "$GITHUB_STEP_SUMMARY" -f
        python3 .github/actions/rust-unit-tests/nextest_summary.py nextest_output.json "$GITHUB_STEP_SUMMARY" || echo "summary generation had an error"
        rm nextest_output.json
```

**File:** keyless/pepper/service/src/main.rs (L154-154)
```rust
const ABS_MAX_T: i64 = 5;
```

**File:** keyless/pepper/service/src/main.rs (L363-392)
```rust
/// Verifies that scalar multiplication is constant time
fn verify_constant_time_scalar_multiplication() {
    // Run the constant time benchmarks for random bases
    let abs_max_t = ctbench::run_bench(
        &BenchName("blstrs_scalar_mul/random_bases"),
        constant_time::blstrs_scalar_mul::run_bench_with_random_bases,
        None,
    )
    .1
    .max_t
    .abs()
    .ceil()
    .to_i64()
    .expect("Floating point arithmetic went awry.");
    assert_le!(abs_max_t, ABS_MAX_T);

    // Run the constant time benchmarks for fixed bases
    let abs_max_t = ctbench::run_bench(
        &BenchName("blstrs_scalar_mul/fixed_bases"),
        constant_time::blstrs_scalar_mul::run_bench_with_fixed_bases,
        None,
    )
    .1
    .max_t
    .abs()
    .ceil()
    .to_i64()
    .expect("Floating point arithmetic went awry.");
    assert_le!(abs_max_t, ABS_MAX_T);
}
```

**File:** keyless/pepper/service/src/main.rs (L402-410)
```rust
    // Verify constant-time scalar multiplication if in production.
    if args.local_development_mode {
        info!(
            "Constant-time scalar multiplication verification skipped in local development mode."
        );
    } else {
        info!("Verifying constant-time scalar multiplication...");
        verify_constant_time_scalar_multiplication();
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/bls/mod.rs (L71-77)
```rust
    fn create_share(ask: &Self::AugmentedSecretKeyShare, msg: &[u8]) -> Self::ProofShare {
        let hash = Self::hash_to_curve(msg);

        ask.iter()
            .map(|sk| hash.mul(sk))
            .collect::<Vec<G1Projective>>()
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/bls/mod.rs (L138-141)
```rust
    fn eval(sk: &Self::SecretKey, msg: &[u8]) -> Self::Evaluation {
        let h = Self::hash_to_curve(msg);
        h.mul(sk)
    }
```

**File:** keyless/pepper/common/src/vuf/bls12381_g1_bls.rs (L81-87)
```rust
    /// WARNING: This function must remain constant-time w.r.t. to `sk` and `input`.
    fn eval(sk: &Scalar, input: &[u8]) -> anyhow::Result<(Vec<u8>, Vec<u8>)> {
        let input_g1 = Self::hash_to_g1(input);
        let output_g1 = input_g1.mul(sk);
        let output_bytes = output_g1.to_compressed().to_vec();
        Ok((output_bytes, vec![]))
    }
```

**File:** .github/workflows/lint-test.yaml (L1-248)
```yaml
name: "Lint+Test"
on:
  pull_request:
    types: [labeled, opened, synchronize, reopened, auto_merge_enabled]
  push:
    branches:
      - main
      - devnet
      - testnet
      - mainnet
      - aptos-node-v*
      - aptos-release-v*
  workflow_dispatch:

env:
  HAS_BUILDPULSE_SECRETS: ${{ secrets.BUILDPULSE_ACCESS_KEY_ID != '' && secrets.BUILDPULSE_SECRET_ACCESS_KEY != '' }}
  HAS_DATADOG_SECRETS: ${{ secrets.DD_API_KEY != '' }}
  CARGO_INCREMENTAL: "0"
  CARGO_TERM_COLOR: always

# cancel redundant builds
concurrency:
  # cancel redundant builds on PRs (only on PR, not on branches)
  group: ${{ github.workflow }}-${{ (github.event_name == 'pull_request' && github.ref) || github.sha }}
  cancel-in-progress: true

jobs:
  # This job determines which files were changed
  file_change_determinator:
    runs-on: 2cpu-gh-ubuntu24-x64
    outputs:
      only_docs_changed: ${{ steps.determine_file_changes.outputs.only_docs_changed }}
    steps:
      - uses: actions/checkout@v4
      - name: Run the file change determinator
        id: determine_file_changes
        uses: ./.github/actions/file-change-determinator

  # Run all general lints (i.e., non-rust and docs lints). This is a PR required job.
  general-lints:
    needs: file_change_determinator
    runs-on: 2cpu-gh-ubuntu24-x64
    steps:
      - uses: actions/checkout@v4
        if: needs.file_change_determinator.outputs.only_docs_changed != 'true'
        with:
          fetch-depth: 0 # get all the history because python-lint-tests requires it.
      - name: Run general lints
        uses: ./.github/actions/general-lints
        if: needs.file_change_determinator.outputs.only_docs_changed != 'true'
        with:
          GIT_CREDENTIALS: ${{ secrets.GIT_CREDENTIALS }}
      - run: echo "Skipping general lints! Unrelated changes detected."
        if: needs.file_change_determinator.outputs.only_docs_changed == 'true'

  # Run the crypto hasher domain separation checks
  rust-cryptohasher-domain-separation-check:
    needs: file_change_determinator
    runs-on: runs-on,cpu=64,family=c7,disk=large,image=aptos-ubuntu-x64,run-id=${{ github.run_id }}
    if: contains(github.event.pull_request.labels.*.name, 'CICD:non-required-tests')
    steps:
      - uses: actions/checkout@v4
      - run: python3 scripts/check-cryptohasher-symbols.py

  # Run all rust lints. This is a PR required job.
  rust-lints:
    needs: file_change_determinator
    runs-on: runs-on,cpu=64,family=c7,disk=large,image=aptos-ubuntu-x64,run-id=${{ github.run_id }}
    steps:
      - uses: actions/checkout@v4
        if: needs.file_change_determinator.outputs.only_docs_changed != 'true'
        with:
          fetch-depth: 0 # get all the history because cargo xtest --change-since origin/main requires it.
      - name: Run rust lints
        uses: ./.github/actions/rust-lints
        if: needs.file_change_determinator.outputs.only_docs_changed != 'true'
        with:
          GIT_CREDENTIALS: ${{ secrets.GIT_CREDENTIALS }}
      - run: echo "Skipping rust lints! Unrelated changes detected."
        if: needs.file_change_determinator.outputs.only_docs_changed == 'true'

  # Run cargo deny. This is a PR required job.
  rust-cargo-deny:
    needs: file_change_determinator
    runs-on: 2cpu-gh-ubuntu24-x64
    steps:
      - uses: actions/checkout@v4
        if: needs.file_change_determinator.outputs.only_docs_changed != 'true'
      - uses: EmbarkStudios/cargo-deny-action@v2
        with:
          command: check licenses
      - run: echo "Skipping cargo deny! Unrelated changes detected."
        if: needs.file_change_determinator.outputs.only_docs_changed == 'true'

  # Run the docs tests. This is a PR required job.
  rust-doc-tests:
    if: | # Only run when an appropriate event occurs
      (
        github.event_name == 'workflow_dispatch' ||
        github.event_name == 'push' ||
        contains(github.event.pull_request.labels.*.name, 'CICD:run-e2e-tests') ||
        github.event.pull_request.auto_merge != null
      )
    runs-on: runs-on,cpu=64,family=c7,disk=large,image=aptos-ubuntu-x64,run-id=${{ github.run_id }}
    steps:
      - uses: actions/checkout@v4
      - name: Run rust doc tests
        uses: ./.github/actions/rust-doc-tests
        with:
          GIT_CREDENTIALS: ${{ secrets.GIT_CREDENTIALS }}

  # Run all rust smoke tests. This is a PR required job.
  rust-smoke-tests:
    needs: file_change_determinator
    if: | # Only run on each PR once an appropriate event occurs
      (
        github.event_name == 'workflow_dispatch' ||
        github.event_name == 'push' ||
        contains(github.event.pull_request.labels.*.name, 'CICD:run-e2e-tests') ||
        github.event.pull_request.auto_merge != null) ||
        contains(github.event.pull_request.body, '#e2e'
      )
    runs-on: runs-on,cpu=64,family=c7,disk=large,image=aptos-ubuntu-x64,run-id=${{ github.run_id }}
    steps:
      - uses: actions/checkout@v4
        if: needs.file_change_determinator.outputs.only_docs_changed != 'true'
      - name: Run rust smoke tests
        uses: ./.github/actions/rust-smoke-tests
        if: needs.file_change_determinator.outputs.only_docs_changed != 'true'
        with:
          GIT_CREDENTIALS: ${{ secrets.GIT_CREDENTIALS }}
      - run: echo "Skipping rust smoke tests! Unrelated changes detected."
        if: needs.file_change_determinator.outputs.only_docs_changed == 'true'

  # Check the freshess of the merge base. This is a PR required job.
  rust-check-merge-base:
    if: | # Don't run on release branches
      (
        !contains(github.event.pull_request.base.ref, '-release-')
      )
    needs: file_change_determinator
    runs-on: runs-on,cpu=64,family=c7,disk=large,image=aptos-ubuntu-x64,run-id=${{ github.run_id }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0 # Fetch all git history for accurate target determination
      - name: Run the merge base freshness check
        uses: ./.github/actions/rust-check-merge-base
        with:
          GIT_CREDENTIALS: ${{ secrets.GIT_CREDENTIALS }}

  # Run only the targeted rust unit tests. This is a PR required job.
  rust-targeted-unit-tests:
    if: | # Don't run on release branches. Instead, all unit tests will be triggered.
      (
        !contains(github.event.pull_request.base.ref, '-release-')
      )
    needs: file_change_determinator
    runs-on: runs-on,cpu=64,family=c7,disk=large,image=aptos-ubuntu-x64,run-id=${{ github.run_id }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0 # Fetch all git history for accurate target determination

      - name: Run dev_setup.sh
        run: |
          scripts/dev_setup.sh -b -p -r -y -P -t

      - name: Run targeted rust unit tests
        uses: ./.github/actions/rust-targeted-unit-tests
        with:
          GIT_CREDENTIALS: ${{ secrets.GIT_CREDENTIALS }}

  # Run all rust unit tests. This is not a PR required job.
  rust-unit-tests:
    if: | # Only run when an appropriate event occurs
      (
        github.event_name == 'workflow_dispatch' ||
        github.event_name == 'push' ||
        contains(github.event.pull_request.labels.*.name, 'CICD:run-all-unit-tests') ||
        contains(github.event.pull_request.base.ref, '-release-')
      )
    runs-on: runs-on,cpu=64,family=c7,disk=large,image=aptos-ubuntu-x64,run-id=${{ github.run_id }}
    steps:
      - uses: actions/checkout@v4
      # Install Move Prover tools
      - name: Run dev_setup.sh
        run: |
          scripts/dev_setup.sh -b -y
      - name: Run rust unit tests
        uses: ./.github/actions/rust-unit-tests
        with:
          GIT_CREDENTIALS: ${{ secrets.GIT_CREDENTIALS }}
          TRUNK_API_TOKEN: ${{ secrets.TRUNK_API_TOKEN }}

  # Run the cached packages build. This is a PR required job.
  rust-build-cached-packages:
    needs: file_change_determinator
    if: | # Only run on each PR once an appropriate event occurs
      (
        github.event_name == 'workflow_dispatch' ||
        github.event_name == 'push' ||
        contains(github.event.pull_request.labels.*.name, 'CICD:run-e2e-tests') ||
        github.event.pull_request.auto_merge != null
      )
    runs-on: runs-on,cpu=64,family=c7,disk=large,image=aptos-ubuntu-x64,run-id=${{ github.run_id }}
    steps:
      - uses: actions/checkout@v4
        if: needs.file_change_determinator.outputs.only_docs_changed != 'true'
      - name: Run aptos cached packages build test
        if: needs.file_change_determinator.outputs.only_docs_changed != 'true'
        run: scripts/cargo_build_aptos_cached_packages.sh --check
      - run: echo "Skipping cached packages test! Unrelated changes detected."
        if: needs.file_change_determinator.outputs.only_docs_changed == 'true'

  # Run the consensus only unit tests
  rust-consensus-only-unit-test:
    runs-on: runs-on,cpu=64,family=c7,disk=large,image=aptos-ubuntu-x64,run-id=${{ github.run_id }}
    if: contains(github.event.pull_request.labels.*.name, 'CICD:build-consensus-only-image')
    steps:
      - uses: actions/checkout@v4
      - run: cargo nextest run --locked --workspace --exclude smoke-test --exclude aptos-testcases --exclude aptos-api --exclude aptos-executor-benchmark --exclude aptos-backup-cli --retries 3 --no-fail-fast -F consensus-only-perf-test
        env:
          RUST_MIN_STACK: 4297152

  # Run the consensus only smoke test
  rust-consensus-only-smoke-test:
    runs-on: runs-on,cpu=64,family=c7,disk=large,image=aptos-ubuntu-x64,run-id=${{ github.run_id }}
    if: contains(github.event.pull_request.labels.*.name, 'CICD:build-consensus-only-image')
    steps:
      - uses: actions/checkout@v4
      # prebuild aptos-node binary, so that tests don't start before node is built.
      # also prebuild aptos-node binary as a separate step to avoid feature unification issues
      - run: cargo build --locked --package=aptos-node -F consensus-only-perf-test --release && LOCAL_SWARM_NODE_RELEASE=1 CONSENSUS_ONLY_PERF_TEST=1 cargo nextest run --release --package smoke-test -E "test(test_consensus_only_with_txn_emitter)" --run-ignored all

      # We always try to create the artifact, but it only creates on flaky or failed smoke tests -- when the directories are empty.
      - name: Upload smoke test logs for failed and flaky tests
        uses: actions/upload-artifact@v4
        if: ${{ failure() || success() }}
        with:
          name: failed-consensus-only-smoke-test-logs
          # Retain all smoke test data except for the db (which may be large).
          path: |
            /tmp/.tmp*
            !/tmp/.tmp*/**/db/
          retention-days: 14
```
