# Audit Report

## Title
Session State Corruption via Non-Atomic File Writes During Signal Interruption

## Summary

The `Session` implementation in the Aptos transaction simulation tool uses non-atomic file writes when persisting session state. If a user interrupts the process (e.g., Ctrl+C) during critical state-modifying operations like `fund_account()` or `execute_transaction()`, the session can enter an inconsistent state where the operation counter (`config.json`) reflects a completed operation but the state delta (`delta.json`) does not contain the corresponding state changes. This violates the session consistency invariant and can cause loss of simulation work. [1](#0-0) 

## Finding Description

The vulnerability exists in state-modifying operations within the `Session` struct. When operations like `fund_account()` or `execute_transaction()` are performed, they follow this sequence:

1. Modify the in-memory state store
2. Write summary files to disk
3. Increment the operation counter
4. Save `config.json` (contains operation count)
5. Save `delta.json` (contains actual state changes) [2](#0-1) 

Both file writes use `std::fs::write()` which is **not atomic**. There is no use of the temp-file-then-rename pattern that other critical components in the codebase employ for atomic writes. [3](#0-2) [4](#0-3) 

Furthermore, the Aptos CLI main entry point has no signal handler for SIGINT (Ctrl+C): [5](#0-4) 

When a user presses Ctrl+C, the process terminates immediately without cleanup. If this occurs after `config.json` is written but before `delta.json` is saved, the session enters an inconsistent state:

- `config.json` shows N operations were performed
- `delta.json` contains state changes for only N-1 operations  
- Summary files for operation N exist on disk
- On next `Session::load()`, the state is missing the changes from operation N

The same issue exists in `execute_transaction()`: [6](#0-5) 

In contrast, other critical components in the Aptos codebase use atomic file writes via the temp-file-then-rename pattern: [7](#0-6) 

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Concrete Impacts:**

1. **Lost Funding Operations**: A user funds an account with test tokens using `aptos move sim fund`. If interrupted, the account doesn't receive the funds on session reload, but the session believes the operation completed.

2. **Lost Transaction Executions**: A user executes a transaction that modifies blockchain state. If interrupted, the state changes are lost but gas was consumed (in simulation) and events were recorded in summary files.

3. **Session Corruption**: Users must manually detect and fix the inconsistency by deleting the session directory and starting over, losing all simulation work.

4. **Misleading Development Experience**: Developers testing Move code may see inconsistent behavior between what they believe happened and actual session state, potentially leading to incorrect conclusions about their code's behavior.

While this doesn't directly affect the Aptos blockchain network (it's a local simulation tool), it violates the **State Consistency** invariant: "State transitions must be atomic and verifiable."

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability requires:
- User running a session operation (`fund`, `execute`)
- User pressing Ctrl+C during execution
- Timing window between `config.json` save and `delta.json` save

**Factors increasing likelihood:**
- The timing window exists in every state-modifying operation
- Users commonly interrupt long-running operations with Ctrl+C
- No warning or protection against interruption
- The file I/O operations create a measurable window (disk writes are not instantaneous)
- When forking from remote networks, network latency can extend operation time, widening the attack window

**Factors decreasing likelihood:**
- The timing window is relatively small (milliseconds to tens of milliseconds typically)
- Both files are small JSON files that write quickly on modern systems
- Requires manual user interruption (not automatically exploitable)

## Recommendation

Implement atomic file writes using the temp-file-then-rename pattern already used elsewhere in the codebase:

```rust
use aptos_temppath::TempPath;
use std::fs;
use std::io::Write;

// In Config::save_to_file()
pub fn save_to_file(&self, path: &std::path::Path) -> Result<()> {
    let json = serde_json::to_string_pretty(self)?;
    
    // Create temp file in same directory as target
    let temp_path = TempPath::new_with_temp_dir(
        path.parent().unwrap_or_else(|| std::path::Path::new("."))
    );
    
    // Write to temp file
    let mut file = std::fs::File::create(temp_path.path())?;
    file.write_all(json.as_bytes())?;
    file.sync_all()?; // Ensure data is flushed to disk
    
    // Atomic rename
    fs::rename(temp_path.path(), path)?;
    Ok(())
}

// Similar changes for save_delta()
```

**Additional Recommendations:**

1. **Batch State Persistence**: Save both `config.json` and `delta.json` in a single atomic operation by writing to a staging directory then renaming the entire directory.

2. **Write-Ahead Logging**: Implement a WAL pattern where operations are logged before execution, allowing recovery from incomplete operations.

3. **Signal Handler**: Add a SIGINT handler that sets a flag allowing operations to complete before exit, similar to the pattern in `crates/aptos/src/node/local_testnet/mod.rs`.

4. **Session Validation**: On `Session::load()`, validate that the operation count matches the number of summary files and state changes in the delta.

## Proof of Concept

**Reproduction Steps:**

1. Create a new session:
```bash
mkdir -p /tmp/test-session
aptos move sim init --path /tmp/test-session
```

2. Create a script to interrupt at the critical moment:
```bash
#!/bin/bash
# Send funding operation in background
aptos move sim fund --session /tmp/test-session --account 0x1 --amount 1000000000 &
PID=$!

# Wait briefly for config.json write
sleep 0.1

# Send SIGINT before delta.json write completes
kill -INT $PID
wait $PID
```

3. Verify inconsistency:
```bash
# Check operation count in config.json (shows 1 operation)
cat /tmp/test-session/config.json

# Check delta.json (should not contain the funding state change if timing was right)
cat /tmp/test-session/delta.json

# Reload session and try to view the funded account
# The funding will not be present despite config showing 1 operation completed
```

**Expected Result**: 
- `config.json` shows `"ops": 1`
- `[0] fund (fungible)/summary.json` exists
- Account 0x1 does not have the funded amount when session is reloaded
- This demonstrates the state inconsistency

## Notes

This vulnerability is specific to the local simulation tool and does not affect the Aptos blockchain network itself. However, it can impact developers' workflow and confidence in their test results. The issue is particularly problematic when forking from remote networks, where the initialization can take longer and users are more likely to interrupt operations.

The fix should align with existing patterns in the codebase for critical file operations, as demonstrated in `secure/storage/src/on_disk.rs`.

### Citations

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L242-264)
```rust
    pub fn fund_account(&mut self, account: AccountAddress, amount: u64) -> Result<()> {
        let (before, after) = self.state_store.fund_apt_fungible_store(account, amount)?;

        let summary = Summary::FundFungible {
            account,
            amount,
            before,
            after,
        };
        let summary_path = self
            .path
            .join(format!("[{}] fund (fungible)", self.config.ops))
            .join("summary.json");
        std::fs::create_dir_all(summary_path.parent().unwrap())?;
        std::fs::write(summary_path, serde_json::to_string_pretty(&summary)?)?;

        self.config.ops += 1;

        self.config.save_to_file(&self.path.join("config.json"))?;
        save_delta(&self.path.join("delta.json"), &self.state_store.delta())?;

        Ok(())
    }
```

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L347-349)
```rust
        self.config.ops += 1;
        self.config.save_to_file(&self.path.join("config.json"))?;
        save_delta(&self.path.join("delta.json"), &self.state_store.delta())?;
```

**File:** aptos-move/aptos-transaction-simulation-session/src/config.rs (L56-59)
```rust
    pub fn save_to_file(&self, path: &std::path::Path) -> Result<()> {
        let json = serde_json::to_string_pretty(self)?;
        std::fs::write(path, json)?;
        Ok(())
```

**File:** aptos-move/aptos-transaction-simulation-session/src/delta.rs (L15-31)
```rust
pub fn save_delta(delta_path: &Path, delta: &HashMap<StateKey, Option<StateValue>>) -> Result<()> {
    // Use BTreeMap to ensure deterministic ordering
    let mut delta_str = BTreeMap::new();

    for (k, v) in delta {
        let key_str = HumanReadable(k).to_string();
        let val_str_opt = match v {
            Some(v) => Some(hex::encode(&bcs::to_bytes(&v)?)),
            None => None,
        };
        delta_str.insert(key_str, val_str_opt);
    }

    let json = serde_json::to_string_pretty(&delta_str)?;
    std::fs::write(delta_path, json)?;

    Ok(())
```

**File:** crates/aptos/src/main.rs (L16-40)
```rust
fn main() {
    // Register hooks.
    move_tool::register_package_hooks();

    // Create a runtime.
    let runtime = tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap();

    // Run the corresponding tool.
    let result = runtime.block_on(Tool::parse().execute());

    // Shutdown the runtime with a timeout. We do this to make sure that we don't sit
    // here waiting forever waiting for tasks that sometimes don't want to exit on
    // their own (e.g. telemetry, containers spawned by the localnet, etc).
    runtime.shutdown_timeout(Duration::from_millis(50));

    match result {
        Ok(inner) => println!("{}", inner),
        Err(inner) => {
            println!("{}", inner);
            exit(1);
        },
    }
```

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```
