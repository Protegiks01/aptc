# Audit Report

## Title
Insufficient Validation of Peer Monitoring Metadata Enables Routing Manipulation Attacks

## Summary
Peer monitoring metadata (`distance_from_validators` and `ledger_timestamp_usecs`) is accepted without sufficient validation and directly used for mempool transaction routing decisions. Malicious peers can report falsified health metrics to gain preferential routing priority, enabling MEV extraction and network performance degradation.

## Finding Description

The peer monitoring system allows any connected peer to self-report their distance from validators and ledger synchronization status. This metadata is stored and used to prioritize peers for transaction forwarding in mempool, but the validation is insufficient.

**Vulnerability 1: Distance from Validators**

For `distance_from_validators >= 2`, validation only checks if the value is below `MAX_DISTANCE_FROM_VALIDATORS` (100): [1](#0-0) 

However, when a peer reports their distance, this value is calculated by taking the minimum distance among all connected peers and adding 1: [2](#0-1) 

A malicious public fullnode can report `distance_from_validators = 2` (falsely claiming to be close to validators) instead of their true distance (e.g., 5 or higher). This passes validation and is stored: [3](#0-2) 

**Vulnerability 2: Ledger Timestamp**

The `ledger_timestamp_usecs` field is stored with **no validation whatsoever**: [4](#0-3) 

A malicious peer can report any timestamp, including a very recent or future timestamp, to falsely appear fully synchronized.

**Exploitation in Routing Decisions**

These falsified metrics are directly used in mempool's intelligent peer prioritization: [5](#0-4) 

The prioritization algorithm favors:
1. Healthy peers (those with recent ledger timestamps)
2. Peers with lower `distance_from_validators` [6](#0-5) [7](#0-6) 

**Attack Scenario:**
1. Malicious peer connects to honest VFN/PFN as an untrusted public fullnode
2. When queried for network information, reports `distance_from_validators = 2` (instead of true value ≥5)
3. When queried for node information, reports `ledger_timestamp_usecs` matching current time (falsely appearing synced)
4. Honest node stores this metadata and uses it for routing priority
5. Malicious peer receives higher priority than honest peers for transaction forwarding
6. Malicious peer sees transactions before honest peers (MEV opportunity)

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:

- **Not Critical/High**: Does not directly break consensus, steal funds, or cause total network failure
- **Medium Impact**: Enables protocol manipulation with measurable harm:
  - **MEV Extraction**: Malicious peers see transactions first, enabling front-running
  - **Performance Degradation**: If malicious peers drop/delay transactions, victim nodes experience degraded transaction propagation
  - **Network-Wide Effect**: Multiple malicious peers can systematically dominate routing across many honest nodes
  - **Targeted DoS**: Attackers can make specific victims preferentially route to malicious infrastructure

The impact is limited because:
- Transactions still reach the network eventually through other paths
- Consensus remains secure
- No funds are directly stolen or frozen

## Likelihood Explanation

**Likelihood: High**

- **Low Barrier to Entry**: Any public fullnode can execute this attack without special privileges or stake
- **Easy to Execute**: Simply respond to monitoring queries with false values
- **Difficult to Detect**: Falsified values appear within valid ranges and don't trigger obvious alarms
- **Network Reachability**: Attacker only needs network connectivity to victims
- **Scalable**: Single attacker can operate multiple malicious peers affecting many nodes

The attack is economically viable for:
- MEV searchers seeking transaction priority
- Competitors degrading rival infrastructure
- State-level actors targeting network performance

## Recommendation

Implement stricter validation and cross-verification for peer monitoring metadata:

**For `distance_from_validators`:**
1. Validate that untrusted peers cannot claim distances below their expected minimum (e.g., untrusted PFNs should report ≥3)
2. Compare reported distances against network topology (peers of known VFNs shouldn't claim distance 2)
3. Implement outlier detection: if one peer reports distance 2 while all others report 5+, treat it as suspicious
4. Weight the routing decision by connection metadata (trusted peers with authentic roles)

**For `ledger_timestamp_usecs`:**
1. Validate that reported timestamps are not in the future: `ledger_timestamp_usecs <= current_time`
2. Cross-check with consensus-verified ledger timestamp: validate the reported timestamp is reasonable compared to the node's own synchronized state
3. Implement sanity bounds: reject timestamps that are impossibly old (e.g., > 1 year behind)
4. Add freshness verification: peers claiming perfect sync should be able to respond to queries about recent blocks

**Code Fix Outline:**
```rust
// In peer-monitoring-service/client/src/peer_states/node_info.rs
fn handle_monitoring_service_response(...) {
    // Add validation
    let current_time_usecs = time_service.now_unix_time().as_micros() as u64;
    if node_info_response.ledger_timestamp_usecs > current_time_usecs {
        // Reject future timestamps
        self.handle_request_failure();
        return;
    }
    
    // Add bounds check
    let max_acceptable_lag = 365 * 24 * 3600 * 1_000_000; // 1 year
    if current_time_usecs - node_info_response.ledger_timestamp_usecs > max_acceptable_lag {
        self.handle_request_failure();
        return;
    }
    
    self.record_node_info_response(node_info_response);
}
```

## Proof of Concept

```rust
// Proof of Concept: Malicious peer receives routing priority

use aptos_config::network_id::{NetworkId, PeerNetworkId};
use aptos_peer_monitoring_service_types::{
    response::{NetworkInformationResponse, NodeInformationResponse},
    PeerMonitoringMetadata,
};
use aptos_network::application::storage::PeersAndMetadata;
use std::collections::BTreeMap;

#[test]
fn test_malicious_peer_routing_priority() {
    // Setup: Create peers and metadata storage
    let peers_and_metadata = PeersAndMetadata::new(&[NetworkId::Public]);
    
    // Create honest peer with true metadata
    let honest_peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    let honest_metadata = PeerMonitoringMetadata::new(
        Some(0.05), // Good latency
        Some(0.05),
        Some(NetworkInformationResponse {
            connected_peers: BTreeMap::new(),
            distance_from_validators: 5, // True distance
        }),
        Some(NodeInformationResponse {
            ledger_timestamp_usecs: now_usecs() - 10_000_000, // 10 seconds behind
            ..Default::default()
        }),
        None,
    );
    
    // Create malicious peer with falsified metadata
    let malicious_peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    let malicious_metadata = PeerMonitoringMetadata::new(
        Some(0.05), // Same latency
        Some(0.05),
        Some(NetworkInformationResponse {
            connected_peers: BTreeMap::new(),
            distance_from_validators: 2, // FAKE: Claims to be close to validators
        }),
        Some(NodeInformationResponse {
            ledger_timestamp_usecs: now_usecs(), // FAKE: Claims perfect sync
            ..Default::default()
        }),
        None,
    );
    
    // Store metadata
    peers_and_metadata.update_peer_monitoring_metadata(honest_peer, honest_metadata).unwrap();
    peers_and_metadata.update_peer_monitoring_metadata(malicious_peer, malicious_metadata).unwrap();
    
    // Create prioritization state
    let mut priority_state = PrioritizedPeersState::new(
        MempoolConfig::default(),
        NodeType::PublicFullnode,
        TimeService::real(),
    );
    
    // Update priorities
    let peers = vec![
        (honest_peer, Some(&honest_peer_metadata)),
        (malicious_peer, Some(&malicious_peer_metadata)),
    ];
    priority_state.update_prioritized_peers(peers, 0, 0);
    
    // Verify malicious peer is prioritized higher (lower index = higher priority)
    let honest_priority = priority_state.get_peer_priority(&honest_peer);
    let malicious_priority = priority_state.get_peer_priority(&malicious_peer);
    
    assert!(malicious_priority < honest_priority, 
        "Malicious peer with fake metadata should be prioritized higher. \
         Malicious priority: {}, Honest priority: {}", 
         malicious_priority, honest_priority);
}
```

**Notes:**
- The vulnerability is confirmed: malicious peers can report fake `distance_from_validators` (for distances ≥2) and fake `ledger_timestamp_usecs` without proper validation
- These fake metrics directly influence routing priority in mempool, consensus observer, and state sync
- The attack requires no special privileges—any public fullnode can execute it
- While not consensus-breaking, this enables MEV extraction and network performance degradation at Medium severity

### Citations

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L137-141)
```rust
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };
```

**File:** peer-monitoring-service/server/src/lib.rs (L321-333)
```rust
    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }
```

**File:** network/framework/src/application/storage.rs (L294-317)
```rust
    pub fn update_peer_monitoring_metadata(
        &self,
        peer_network_id: PeerNetworkId,
        peer_monitoring_metadata: PeerMonitoringMetadata,
    ) -> Result<(), Error> {
        // Grab the write lock for the peer metadata
        let mut peers_and_metadata = self.peers_and_metadata.write();

        // Fetch the peer metadata for the given network
        let peer_metadata_for_network =
            get_peer_metadata_for_network(&peer_network_id, &mut peers_and_metadata)?;

        // Update the peer monitoring metadata for the peer
        if let Some(peer_metadata) = peer_metadata_for_network.get_mut(&peer_network_id.peer_id()) {
            peer_metadata.peer_monitoring_metadata = peer_monitoring_metadata;
        } else {
            return Err(missing_peer_metadata_error(&peer_network_id));
        }

        // Update the cached peers and metadata
        self.set_cached_peers_and_metadata(peers_and_metadata.clone());

        Ok(())
    }
```

**File:** peer-monitoring-service/client/src/peer_states/node_info.rs (L79-106)
```rust
    fn handle_monitoring_service_response(
        &mut self,
        peer_network_id: &PeerNetworkId,
        _peer_metadata: PeerMetadata,
        _monitoring_service_request: PeerMonitoringServiceRequest,
        monitoring_service_response: PeerMonitoringServiceResponse,
        _response_time_secs: f64,
    ) {
        // Verify the response type is valid
        let node_info_response = match monitoring_service_response {
            PeerMonitoringServiceResponse::NodeInformation(node_information_response) => {
                node_information_response
            },
            _ => {
                warn!(LogSchema::new(LogEntry::NodeInfoRequest)
                    .event(LogEvent::ResponseError)
                    .peer(peer_network_id)
                    .message(
                        "An unexpected response was received instead of a node info response!"
                    ));
                self.handle_request_failure();
                return;
            },
        };

        // Store the new latency ping result
        self.record_node_info_response(node_info_response);
    }
```

**File:** mempool/src/shared_mempool/priority.rs (L72-120)
```rust
    /// Provides intelligent ordering for peers when forwarding transactions.
    /// Higher priority peers are greater than lower priority peers.
    fn compare_intelligent(
        &self,
        peer_a: &(PeerNetworkId, Option<&PeerMonitoringMetadata>),
        peer_b: &(PeerNetworkId, Option<&PeerMonitoringMetadata>),
    ) -> Ordering {
        // Deconstruct the peer tuples
        let (peer_network_id_a, monitoring_metadata_a) = peer_a;
        let (peer_network_id_b, monitoring_metadata_b) = peer_b;

        // First, compare the peers by health (e.g., sync lag)
        let unhealthy_ordering = compare_peer_health(
            &self.mempool_config,
            &self.time_service,
            monitoring_metadata_a,
            monitoring_metadata_b,
        );
        if !unhealthy_ordering.is_eq() {
            return unhealthy_ordering; // Only return if it's not equal
        }

        // Next, compare by network ID (i.e., Validator > VFN > Public)
        let network_ordering = compare_network_id(
            &peer_network_id_a.network_id(),
            &peer_network_id_b.network_id(),
        );
        if !network_ordering.is_eq() {
            return network_ordering; // Only return if it's not equal
        }

        // Otherwise, compare by peer distance from the validators.
        // This avoids badly configured/connected peers (e.g., broken VN-VFN connections).
        let distance_ordering =
            compare_validator_distance(monitoring_metadata_a, monitoring_metadata_b);
        if !distance_ordering.is_eq() {
            return distance_ordering; // Only return if it's not equal
        }

        // Otherwise, compare by peer ping latency (the lower the better)
        let latency_ordering = compare_ping_latency(monitoring_metadata_a, monitoring_metadata_b);
        if !latency_ordering.is_eq() {
            return latency_ordering; // Only return if it's not equal
        }

        // Otherwise, simply hash the peer IDs and compare the hashes.
        // In practice, this should be relatively rare.
        self.compare_hash(peer_network_id_a, peer_network_id_b)
    }
```

**File:** mempool/src/shared_mempool/priority.rs (L559-589)
```rust
/// Returns true iff the given peer monitoring metadata is healthy. A peer is
/// considered healthy if its latest ledger timestamp is within the max acceptable
/// sync lag. If the monitoring metadata is missing, the peer is considered unhealthy.
fn check_peer_metadata_health(
    mempool_config: &MempoolConfig,
    time_service: &TimeService,
    monitoring_metadata: &Option<&PeerMonitoringMetadata>,
) -> bool {
    monitoring_metadata
        .and_then(|metadata| {
            metadata
                .latest_node_info_response
                .as_ref()
                .map(|node_information_response| {
                    // Get the peer's ledger timestamp and the current timestamp
                    let peer_ledger_timestamp_usecs =
                        node_information_response.ledger_timestamp_usecs;
                    let current_timestamp_usecs = get_timestamp_now_usecs(time_service);

                    // Calculate the max sync lag before the peer is considered unhealthy (in microseconds)
                    let max_sync_lag_secs =
                        mempool_config.max_sync_lag_before_unhealthy_secs as u64;
                    let max_sync_lag_usecs = max_sync_lag_secs * MICROS_PER_SECOND;

                    // Determine if the peer is healthy
                    current_timestamp_usecs.saturating_sub(peer_ledger_timestamp_usecs)
                        < max_sync_lag_usecs
                })
        })
        .unwrap_or(false) // If metadata is missing, consider the peer unhealthy
}
```

**File:** mempool/src/shared_mempool/priority.rs (L613-639)
```rust
/// Compares the validator distance for the given pair of monitoring metadata.
/// The peer with the lowest validator distance is prioritized.
fn compare_validator_distance(
    monitoring_metadata_a: &Option<&PeerMonitoringMetadata>,
    monitoring_metadata_b: &Option<&PeerMonitoringMetadata>,
) -> Ordering {
    // Get the validator distance from the monitoring metadata
    let validator_distance_a = get_distance_from_validators(monitoring_metadata_a);
    let validator_distance_b = get_distance_from_validators(monitoring_metadata_b);

    // Compare the distances
    match (validator_distance_a, validator_distance_b) {
        (Some(validator_distance_a), Some(validator_distance_b)) => {
            // Prioritize the peer with the lowest validator distance
            validator_distance_a.cmp(&validator_distance_b).reverse()
        },
        (Some(_), None) => {
            Ordering::Greater // Prioritize the peer with a validator distance
        },
        (None, Some(_)) => {
            Ordering::Less // Prioritize the peer with a validator distance
        },
        (None, None) => {
            Ordering::Equal // Neither peer has a validator distance
        },
    }
}
```
