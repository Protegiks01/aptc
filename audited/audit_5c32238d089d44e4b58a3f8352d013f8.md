# Audit Report

## Title
Unauthenticated Network Access to SafetyRules Server Enables Validator Compromise

## Summary
The SafetyRules remote service (Process mode) uses an unauthenticated TCP connection that allows any process with network access to send arbitrary consensus signing commands. If an attacker compromises the host running the remote client, they can directly connect to the SafetyRules server and issue commands to query state, attempt forced equivocation, or cause denial of service against the validator's consensus operations.

## Finding Description

The SafetyRules service in "Process" mode runs as a separate process communicating via `NetworkServer` and `NetworkClient` from the `secure/net` module. The critical security flaw is that this network layer implements **zero authentication mechanisms**. [1](#0-0) 

The client creates a plain `NetworkClient` connecting to the server address. On the server side: [2](#0-1) 

The server accepts connections and processes messages without authentication: [3](#0-2) 

The `listener.accept()` call at line 376 accepts **any** incoming TCP connection without verifying client identity, IP address, or any authentication token. The server then deserializes the incoming JSON directly into `SafetyRulesInput` commands: [4](#0-3) 

These commands control critical consensus operations including signing proposals, votes, and timeouts using the validator's private consensus key.

**Attack Scenario:**
1. Attacker compromises the host running the consensus client (as stated in the question)
2. Attacker locates the `server_address` from configuration files (typically `127.0.0.1:5555`)
3. Attacker creates their own `NetworkClient` to this address
4. Attacker sends arbitrary `SafetyRulesInput` commands:
   - `ConsensusState` - leaks validator state information (epoch, last voted round, one-chain round)
   - `SignProposal` / `ConstructAndSignVoteTwoChain` - attempts to force malicious signatures
   - Flood the server with requests causing denial of service

While SafetyRules has internal safety checks (epoch verification, round tracking, vote deduplication), these do not defend against:
- **Information disclosure** via `ConsensusState` queries
- **Denial of service** through request flooding
- **Race condition attacks** where attacker intercepts legitimate requests and replays them
- **Timing attacks** that manipulate when votes are signed

## Impact Explanation

**Critical Severity** - This vulnerability meets the following critical impact criteria:

1. **Consensus Safety Violation**: The lack of authentication exposes the validator's signing operations to unauthorized access. An attacker with sufficient knowledge could craft requests that exploit timing windows or race conditions to cause equivocation (double-signing).

2. **Validator Identity Compromise**: The SafetyRules service holds the validator's BLS consensus private key. Unauthorized access to signing operations effectively compromises the validator's cryptographic identity.

3. **Information Disclosure**: The `ConsensusState` command reveals sensitive validator state that could be used to coordinate attacks or understand network topology.

4. **Denial of Service**: An attacker can flood the server with malformed requests, preventing legitimate consensus operations and causing the validator to lose liveness.

This breaks **Critical Invariant #2** (Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine).

## Likelihood Explanation

**HIGH Likelihood** for the following reasons:

1. **Realistic Threat Model**: Host compromise is a well-documented threat vector in validator operations. Malware, supply chain attacks, or insider threats can all lead to host compromise.

2. **Default Configuration**: While mainnet validators are advised to use `Local` mode, the configuration sanitizer only generates a **warning**, not an error: [5](#0-4) 

The Process mode remains a supported configuration option.

3. **Simple Exploitation**: The attack requires no cryptographic bypass or protocol manipulation - just basic TCP socket programming to the localhost address.

4. **No Defense in Depth**: There are no compensating controls like IP whitelisting, connection limits, or authentication tokens.

## Recommendation

**Immediate Fix**: Implement mutual TLS authentication for the SafetyRules remote service:

```rust
// In secure/net/src/lib.rs - Add TLS support
use rustls::{ServerConfig, ClientConfig};
use tokio_rustls::{TlsAcceptor, TlsConnector};

pub struct NetworkServer {
    service: String,
    listener: Option<TcpListener>,
    stream: Option<NetworkStream>,
    tls_acceptor: Option<TlsAcceptor>, // Add TLS acceptor
    timeout_ms: u64,
}

// Validate client certificate during accept
fn client(&mut self) -> Result<&mut NetworkStream, Error> {
    // ... existing code ...
    let (stream, stream_addr) = listener.accept()?;
    
    // Add certificate validation
    if let Some(acceptor) = &self.tls_acceptor {
        let tls_stream = acceptor.accept(stream).await?;
        // Verify client certificate matches expected validator identity
    }
    // ... rest of code ...
}
```

**Alternative Mitigations**:

1. **Configuration Enforcement**: Make the sanitizer return an **error** (not warning) when Process mode is used in production: [5](#0-4) 

Change to:
```rust
if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "The safety rules service MUST be set to local in mainnet!".to_string(),
    ));
}
```

2. **Authentication Tokens**: Add a shared secret authentication token passed in requests
3. **Unix Domain Sockets**: Use Unix domain sockets instead of TCP for localhost-only communication with file permission controls

## Proof of Concept

```rust
// PoC demonstrating unauthorized access to SafetyRules server
use aptos_secure_net::NetworkClient;
use consensus_safety_rules::serializer::SafetyRulesInput;
use std::net::{IpAddr, Ipv4Addr, SocketAddr};

#[test]
fn test_unauthorized_safety_rules_access() {
    // Attacker on compromised host discovers the SafetyRules server address
    let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 5555);
    
    // Attacker creates their own NetworkClient (no authentication required)
    let mut malicious_client = NetworkClient::new(
        "attacker-client".to_string(),
        server_addr,
        5000, // timeout
    );
    
    // Attacker queries consensus state (information disclosure)
    let input = SafetyRulesInput::ConsensusState;
    let request = serde_json::to_vec(&input).unwrap();
    
    // This succeeds because there's NO authentication!
    malicious_client.write(&request).unwrap();
    let response = malicious_client.read().unwrap();
    
    // Attacker now has access to validator's consensus state
    let consensus_state: ConsensusState = serde_json::from_slice(&response).unwrap();
    println!("Stolen validator state: epoch={}, last_voted_round={}", 
             consensus_state.epoch(), 
             consensus_state.last_voted_round());
    
    // Attacker can continue sending arbitrary SafetyRulesInput commands...
}
```

**Notes**:
- This PoC demonstrates that any process with network access can connect and issue commands
- The validator configuration example confirms localhost binding, but host compromise defeats this protection
- While SafetyRules has internal validation logic, the exposed attack surface enables information disclosure and potential exploitation of timing-dependent race conditions
- The recommendation to use `Local` mode in mainnet is advisory, not enforced, leaving production systems vulnerable if misconfigured

### Citations

**File:** consensus/safety-rules/src/remote_service.rs (L15-22)
```rust
        let network_client = NetworkClient::new(
            "safety-rules".to_string(),
            self.server_address(),
            self.network_timeout_ms(),
        );
        let service = Box::new(RemoteClient::new(network_client));
        SerializerClient::new_client(service)
    }
```

**File:** consensus/safety-rules/src/remote_service.rs (L30-44)
```rust
pub fn execute(storage: PersistentSafetyStorage, listen_addr: SocketAddr, network_timeout_ms: u64) {
    let mut safety_rules = SafetyRules::new(storage, false);
    if let Err(e) = safety_rules.consensus_state() {
        warn!("Unable to print consensus state: {}", e);
    }

    let mut serializer_service = SerializerService::new(safety_rules);
    let mut network_server =
        NetworkServer::new("safety-rules".to_string(), listen_addr, network_timeout_ms);

    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
```

**File:** secure/net/src/lib.rs (L365-404)
```rust
    fn client(&mut self) -> Result<&mut NetworkStream, Error> {
        if self.stream.is_none() {
            self.increment_counter(Method::Connect, MethodResult::Query);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::ConnectionAttempt,
            ));

            let listener = self.listener.as_mut().ok_or(Error::AlreadyShutdown)?;

            let (stream, stream_addr) = match listener.accept() {
                Ok(ok) => ok,
                Err(err) => {
                    self.increment_counter(Method::Connect, MethodResult::Failure);
                    let err = err.into();
                    warn!(SecureNetLogSchema::new(
                        &self.service,
                        NetworkMode::Server,
                        LogEvent::ConnectionSuccessful,
                    )
                    .error(&err));
                    return Err(err);
                },
            };

            self.increment_counter(Method::Connect, MethodResult::Success);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::ConnectionSuccessful,
            )
            .remote_peer(&stream_addr));

            stream.set_nodelay(true)?;
            self.stream = Some(NetworkStream::new(stream, stream_addr, self.timeout_ms));
        }

        self.stream.as_mut().ok_or(Error::NoActiveStream)
    }
```

**File:** consensus/safety-rules/src/serializer.rs (L45-82)
```rust
    pub fn handle_message(&mut self, input_message: Vec<u8>) -> Result<Vec<u8>, Error> {
        let input = serde_json::from_slice(&input_message)?;

        let output = match input {
            SafetyRulesInput::ConsensusState => {
                serde_json::to_vec(&self.internal.consensus_state())
            },
            SafetyRulesInput::Initialize(li) => serde_json::to_vec(&self.internal.initialize(&li)),
            SafetyRulesInput::SignProposal(block_data) => {
                serde_json::to_vec(&self.internal.sign_proposal(&block_data))
            },
            SafetyRulesInput::SignTimeoutWithQC(timeout, maybe_tc) => serde_json::to_vec(
                &self
                    .internal
                    .sign_timeout_with_qc(&timeout, maybe_tc.as_ref().as_ref()),
            ),
            SafetyRulesInput::ConstructAndSignVoteTwoChain(vote_proposal, maybe_tc) => {
                serde_json::to_vec(
                    &self.internal.construct_and_sign_vote_two_chain(
                        &vote_proposal,
                        maybe_tc.as_ref().as_ref(),
                    ),
                )
            },
            SafetyRulesInput::ConstructAndSignOrderVote(order_vote_proposal) => serde_json::to_vec(
                &self
                    .internal
                    .construct_and_sign_order_vote(&order_vote_proposal),
            ),
            SafetyRulesInput::SignCommitVote(ledger_info, new_ledger_info) => serde_json::to_vec(
                &self
                    .internal
                    .sign_commit_vote(*ledger_info, *new_ledger_info),
            ),
        };

        Ok(output?)
    }
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```
