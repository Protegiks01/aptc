# Audit Report

## Title
Integer Overflow DoS in State Snapshot Restore via Malicious Chunk Indices

## Summary
The `StateSnapshotChunk` structure in the backup/restore system deserializes `first_idx` and `last_idx` fields from JSON without validation. An attacker can craft a malicious manifest with `last_idx = usize::MAX`, causing an integer overflow panic during restore operations due to unchecked arithmetic in logging statements, resulting in a denial of service against disaster recovery procedures.

## Finding Description

The state snapshot backup system uses `StateSnapshotChunk` to represent chunks of state data with ordinal indices (`first_idx`, `last_idx`). These indices are metadata fields that track the position of accounts in the global state sequence. [1](#0-0) 

When a node operator initiates a state snapshot restore or verification, the manifest is loaded from external backup storage without validating the index bounds: [2](#0-1) 

During chunk processing, the restore code performs arithmetic on these indices for logging and metrics: [3](#0-2) 

The critical vulnerability is at line 221: `chunk.last_idx + 1 - start_idx`. If `chunk.last_idx` equals `usize::MAX`, the addition operation overflows. Aptos explicitly enables overflow checks even in release builds: [4](#0-3) 

**Attack Path:**
1. Attacker crafts a malicious `StateSnapshotBackup` manifest JSON with `last_idx: 18446744073709551615` (usize::MAX on 64-bit systems)
2. Attacker provides this manifest along with valid cryptographic proofs (which validate state data, not the indices)
3. Node operator initiates restore/verify operation using this backup
4. The manifest loads successfully and passes cryptographic verification
5. During chunk processing, the overflow occurs in the logging calculation
6. The restore operation panics and aborts

**Why cryptographic validation doesn't prevent this:**
The `SparseMerkleRangeProof` validates the correctness of state keys and values, but the ordinal indices (`first_idx`, `last_idx`) are not cryptographically bound to the proof. They are merely metadata for progress tracking and logging. An attacker can provide legitimate state data with valid proofs but malicious indices.

Unlike `TransactionBackup` and `EpochEndingBackup` which have `verify()` methods to check chunk continuity, `StateSnapshotBackup` has no such validation: [5](#0-4) 

## Impact Explanation

This vulnerability constitutes a **Medium severity** denial of service according to Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: Prevents nodes from completing disaster recovery operations
- **DoS against critical subsystem**: Backup/restore is essential for node recovery, disaster scenarios, and new validator onboarding
- **No consensus impact**: Does not affect live consensus or running nodes
- **No fund loss**: Does not enable theft or manipulation of funds
- **Limited scope**: Only affects nodes performing restore/verify operations, not the broader network

The attack requires the attacker to control or compromise backup storage (S3, GCS, or local filesystem), which is realistic in scenarios involving:
- Third-party backup providers
- Compromised cloud storage credentials
- Malicious insiders providing "backup assistance"
- Supply chain attacks on backup infrastructure

## Likelihood Explanation

**Likelihood: Medium to High**

**Attacker Requirements:**
- Ability to provide backup storage location to node operator
- Capability to craft JSON manifests (trivial)
- Optional: Valid state data and proofs (can reuse legitimate backups)

**Realistic Scenarios:**
- Node operators commonly restore from external backups during disaster recovery
- New validators often bootstrap from community-provided snapshots
- Backup verification is performed on untrusted backup sources
- The default logger level is `Level::Info`, meaning the vulnerable logging code executes by default: [6](#0-5) 

**Exploitation Complexity:** Low - requires only JSON manipulation, no deep protocol knowledge

## Recommendation

Implement explicit validation of chunk indices before use. Add a `verify()` method to `StateSnapshotBackup` similar to other backup types:

```rust
impl StateSnapshotBackup {
    pub fn verify(&self) -> Result<()> {
        ensure!(!self.chunks.is_empty(), "No chunks.");
        
        let mut next_idx: u64 = 0;
        for chunk in &self.chunks {
            // Validate chunk range is valid
            ensure!(
                chunk.first_idx <= chunk.last_idx,
                "Invalid chunk range: first_idx {} > last_idx {}",
                chunk.first_idx,
                chunk.last_idx
            );
            
            // Validate continuity
            ensure!(
                chunk.first_idx == next_idx as usize,
                "Chunk ranges not continuous. Expected first_idx: {}, actual: {}",
                next_idx,
                chunk.first_idx
            );
            
            // Check for overflow before incrementing
            let chunk_size = (chunk.last_idx as u64)
                .checked_sub(chunk.first_idx as u64)
                .and_then(|diff| diff.checked_add(1))
                .ok_or_else(|| anyhow!("Chunk size calculation overflowed"))?;
            
            next_idx = next_idx
                .checked_add(chunk_size)
                .ok_or_else(|| anyhow!("Next index calculation overflowed"))?;
        }
        
        Ok(())
    }
}
```

Call this verification method in `StateSnapshotRestoreController::run_impl()` immediately after loading the manifest:

```rust
let manifest: StateSnapshotBackup =
    self.storage.load_json_file(&self.manifest_handle).await?;
manifest.verify()?;  // Add this line
```

Additionally, use checked arithmetic in logging statements to prevent panics:

```rust
values_per_second = chunk.last_idx
    .checked_add(1)
    .and_then(|v| v.checked_sub(start_idx))
    .map(|v| (v as f64 / start.as_ref().unwrap().elapsed().as_secs_f64()) as u64)
    .unwrap_or(0),
```

## Proof of Concept

Create a malicious manifest file `malicious_state_manifest.json`:

```json
{
  "version": 1000,
  "epoch": 10,
  "root_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "chunks": [
    {
      "first_idx": 0,
      "last_idx": 18446744073709551615,
      "first_key": "0x0000000000000000000000000000000000000000000000000000000000000000",
      "last_key": "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
      "blobs": "state_blobs.bin",
      "proof": "state_proof.bin"
    }
  ],
  "proof": "manifest_proof.bin"
}
```

Execute restore operation:
```bash
aptos-db-tool restore \
  --state-manifest malicious_state_manifest.json \
  --state-into-version 1000 \
  --target-db-dir /tmp/restored_db
```

**Expected Result:** The restore operation panics with an overflow error when processing the first chunk, demonstrating the vulnerability.

**Notes:**
This vulnerability affects the backup/restore subsystem, which is critical for disaster recovery. While it doesn't directly impact consensus or live operations, it represents a significant availability risk for node operators who depend on backups for recovery scenarios. The lack of index validation in `StateSnapshotBackup` contrasts with the explicit validation present in `TransactionBackup` and `EpochEndingBackup`, indicating an oversight in the security hardening of this code path.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/manifest.rs (L12-27)
```rust
pub struct StateSnapshotChunk {
    /// index of the first account in this chunk over all accounts.
    pub first_idx: usize,
    /// index of the last account in this chunk over all accounts.
    pub last_idx: usize,
    /// key of the first account in this chunk.
    pub first_key: HashValue,
    /// key of the last account in this chunk.
    pub last_key: HashValue,
    /// Repeated `len(record) + record` where `record` is BCS serialized tuple
    /// `(key, state_value)`
    pub blobs: FileHandle,
    /// BCS serialized `SparseMerkleRangeProof` that proves this chunk adds up to the root hash
    /// indicated in the backup (`StateSnapshotBackup::root_hash`).
    pub proof: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-124)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L217-225)
```rust
            info!(
                chunk = chunk_idx,
                chunks_to_add = chunks_to_add,
                last_idx = chunk.last_idx,
                values_per_second = ((chunk.last_idx + 1 - start_idx) as f64
                    / start.as_ref().unwrap().elapsed().as_secs_f64())
                    as u64,
                "State chunk added.",
            );
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L49-88)
```rust
impl TransactionBackup {
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints
        ensure!(
            self.first_version <= self.last_version,
            "Bad version range: [{}, {}]",
            self.first_version,
            self.last_version,
        );

        // check chunk ranges
        ensure!(!self.chunks.is_empty(), "No chunks.");

        let mut next_version = self.first_version;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_version == next_version,
                "Chunk ranges not continuous. Expected first version: {}, actual: {}.",
                next_version,
                chunk.first_version,
            );
            ensure!(
                chunk.last_version >= chunk.first_version,
                "Chunk range invalid. [{}, {}]",
                chunk.first_version,
                chunk.last_version,
            );
            next_version = chunk.last_version + 1;
        }

        // check last version in chunk matches manifest
        ensure!(
            next_version - 1 == self.last_version, // okay to -1 because chunks is not empty.
            "Last version in chunks: {}, in manifest: {}",
            next_version - 1,
            self.last_version,
        );

        Ok(())
    }
```

**File:** config/src/config/logger_config.rs (L40-56)
```rust
impl Default for LoggerConfig {
    fn default() -> LoggerConfig {
        LoggerConfig {
            chan_size: CHANNEL_SIZE,
            enable_backtrace: false,
            is_async: true,
            level: Level::Info,
            enable_telemetry_remote_log: true,
            enable_telemetry_flush: true,
            telemetry_level: Level::Error,

            // This is the default port used by tokio-console.
            // Setting this to None will disable tokio-console
            // even if the "tokio-console" feature is enabled.
            tokio_console_port: None,
        }
    }
```
