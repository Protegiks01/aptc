# Audit Report

## Title
Division by Zero Panic in Block Partitioner When num_shards=0

## Summary
Setting `num_shards` to 0 in the block partitioner causes a panic due to modulo division by zero in the `get_anchor_shard_id()` function. This vulnerability affects multiple entry points including command-line tools and executor service binaries.

## Finding Description
The core vulnerability exists in the partitioning logic that determines which shard should handle specific storage locations. When transactions are partitioned across shards, the system uses a hash-based assignment function that performs modulo arithmetic with `num_shards`. [1](#0-0) 

This function is called during the partition initialization phase when processing transaction read/write hints: [2](#0-1) 

The vulnerability propagates through multiple code paths:

**Entry Point 1: Block Partitioner Benchmark Tool**
The standalone partitioner binary accepts `num_shards` from command-line arguments with no validation: [3](#0-2) 

The binary directly calls partition with the user-supplied value: [4](#0-3) 

**Entry Point 2: Executor Service Binary**
The executor service binary similarly accepts `num_shards` without validation: [5](#0-4) [6](#0-5) 

**Secondary Vulnerability: Division in Thread Pool Calculation**
Additionally, there's a division by zero in the executor shard setup: [7](#0-6) 

**Additional Issue: Empty Vector Access**
When `num_shards=0`, vector initialization creates empty vectors that cause out-of-bounds panics: [8](#0-7) 

This leads to panics when accessing `start_txn_idxs_by_shard[shard_id]` later: [9](#0-8) 

## Impact Explanation
This vulnerability causes **Denial of Service (DoS)** through panic-induced crashes. While the impact is primarily on availability, it affects critical infrastructure components:

- **Validator node crashes**: If a validator operator misconfigures sharding parameters, their node will panic during block execution
- **Benchmark tool failures**: Development and testing workflows are disrupted
- **Distributed execution failures**: Sharded execution deployments become unusable

However, this does NOT qualify for bug bounty severity levels because:
- It requires privileged access (running binaries with specific command-line flags)
- Does not affect consensus safety (only crashes the local node)
- Does not cause fund loss or network-wide disruption
- Main production path has validation checks

The primary production path in `block_preparation.rs` has protective checks: [10](#0-9) 

## Likelihood Explanation
**Low likelihood** in production environments because:
- Main execution path includes validation
- Requires operator error in specialized deployment configurations
- Command-line tools are primarily used for testing/benchmarking
- Standard validator nodes don't expose these parameters to external actors

## Recommendation
Add explicit validation at all entry points that accept `num_shards`:

```rust
pub fn new(
    num_threads: usize,
    num_shards: usize,
    partitioner_config: &dyn PartitionerConfig,
) -> Self {
    assert!(num_shards > 0, "num_shards must be greater than 0");
    // ... rest of initialization
}
```

Apply similar validation in:
1. `PartitionState::new()` 
2. `ShardedExecutorService::new()`
3. All command-line argument parsers
4. `get_anchor_shard_id()` function

Alternatively, use checked arithmetic:
```rust
fn get_anchor_shard_id(storage_location: &StorageLocation, num_shards: usize) -> ShardId {
    assert!(num_shards > 0, "num_shards cannot be zero");
    let mut hasher = DefaultHasher::new();
    storage_location.hash(&mut hasher);
    (hasher.finish() % num_shards as u64) as usize
}
```

## Proof of Concept
```bash
# Compile the block-partitioner binary
cargo build --release --bin aptos-block-partitioner

# Trigger division by zero panic
./target/release/aptos-block-partitioner --num-shards 0 --block-size 100

# Expected output: thread panicked at 'attempt to calculate the remainder with a divisor of zero'
```

---

**Notes:**
While this is a legitimate panic/crash vulnerability, it **does not meet Aptos bug bounty criteria** for the following reasons:
1. Requires privileged access to run binaries with specific parameters
2. Does not affect consensus, state integrity, or fund security  
3. Impact limited to single-node DoS under operator control
4. Main production codepaths include protective validation
5. Does not qualify for Medium/High/Critical severity tiers

This is a **code quality/robustness issue** rather than a security vulnerability exploitable by untrusted actors.

### Citations

**File:** execution/block-partitioner/src/lib.rs (L39-43)
```rust
fn get_anchor_shard_id(storage_location: &StorageLocation, num_shards: usize) -> ShardId {
    let mut hasher = DefaultHasher::new();
    storage_location.hash(&mut hasher);
    (hasher.finish() % num_shards as u64) as usize
}
```

**File:** execution/block-partitioner/src/v2/init.rs (L46-49)
```rust
                                let anchor_shard_id = get_anchor_shard_id(
                                    storage_location,
                                    state.num_executor_shards,
                                );
```

**File:** execution/block-partitioner/src/main.rs (L16-29)
```rust
#[derive(Debug, Parser)]
struct Args {
    #[clap(long, default_value_t = 1000000)]
    pub num_accounts: usize,

    #[clap(long, default_value_t = 100000)]
    pub block_size: usize,

    #[clap(long, default_value_t = 9)]
    pub num_blocks: usize,

    #[clap(long, default_value_t = 48)]
    pub num_shards: usize,
}
```

**File:** execution/block-partitioner/src/main.rs (L48-48)
```rust
        let _partitioned = partitioner.partition(transactions.clone(), args.num_shards);
```

**File:** execution/executor-service/src/main.rs (L9-25)
```rust
#[derive(Debug, Parser)]
struct Args {
    #[clap(long, default_value_t = 8)]
    pub num_executor_threads: usize,

    #[clap(long)]
    pub shard_id: usize,

    #[clap(long)]
    pub num_shards: usize,

    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
}
```

**File:** execution/executor-service/src/main.rs (L37-43)
```rust
    let _exe_service = ProcessExecutorService::new(
        args.shard_id,
        args.num_shards,
        args.num_executor_threads,
        args.coordinator_address,
        args.remote_executor_addresses,
    );
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L82-83)
```rust
        let num_threads = num_threads
            .unwrap_or_else(|| (num_cpus::get() as f64 / num_shards as f64).ceil() as usize);
```

**File:** execution/block-partitioner/src/v2/state.rs (L150-150)
```rust
            start_txn_idxs_by_shard: vec![0; num_executor_shards],
```

**File:** execution/block-partitioner/src/v2/state.rs (L214-216)
```rust
        let range_start = self.start_txn_idxs_by_shard[tracker.anchor_shard_id];
        let range_end = self.start_txn_idxs_by_shard[shard_id];
        tracker.has_write_in_range(range_start, range_end)
```

**File:** execution/executor-benchmark/src/block_preparation.rs (L47-52)
```rust
        let maybe_partitioner = if num_shards == 0 {
            None
        } else {
            let partitioner = partitioner_config.build();
            Some(partitioner)
        };
```
