# Audit Report

## Title
Integer Overflow in Epoch Ending Backup Manifest Verification Allows Validation Bypass

## Summary
The `verify()` function in the epoch ending backup manifest uses unchecked arithmetic operations that overflow in production (release mode) builds when epoch values approach `u64::MAX`. This allows an attacker to craft malicious backup manifests that bypass validation checks, potentially leading to state corruption during node restoration.

## Finding Description

The vulnerability exists in the manifest verification logic that validates the consistency of epoch ranges in backup data. [1](#0-0) 

Three critical overflow points exist:

**1. Waypoints Count Validation (Line 33):**
The expression `self.last_epoch - self.first_epoch + 1` uses unchecked arithmetic. When `last_epoch = u64::MAX` and `first_epoch = 0`, the calculation wraps: `u64::MAX - 0 + 1 = 0` (overflow), making the validator accept 0 waypoints when it should require `u64::MAX + 1` waypoints. [2](#0-1) 

**2. Chunk Range Tracking (Line 56):**
The expression `next_epoch = chunk.last_epoch + 1` overflows when `chunk.last_epoch = u64::MAX`, wrapping to 0. [3](#0-2) 

**3. Final Epoch Verification (Line 61):**
The expression `next_epoch - 1` underflows when `next_epoch = 0`, wrapping to `u64::MAX` and incorrectly matching `self.last_epoch = u64::MAX`. [4](#0-3) 

The same pattern exists in the restore process: [5](#0-4) 

This contrasts with the proper implementation found elsewhere in the codebase, which uses checked arithmetic: [6](#0-5) 

**Attack Scenario:**

An attacker controlling backup storage (via compromise, supply chain attack, or social engineering) crafts a malicious manifest:
- `first_epoch = 0`
- `last_epoch = u64::MAX` 
- `waypoints = []` (empty)
- `chunks = [chunk]` where chunk spans `[0, u64::MAX]`

All arithmetic operations overflow symmetrically, causing the validation to pass when it should reject this malformed data. The manifest is loaded during restore: [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Validator Node Impact**: Malicious backup data can cause node crashes during restoration attempts, leading to validator node slowdowns and operational disruptions.

2. **State Inconsistency**: If the malformed manifest bypasses validation and proceeds to restoration, it could result in corrupted epoch history, causing the node to have an inconsistent view of the blockchain state.

3. **Protocol Violation**: A node with corrupted epoch data may reject valid blocks or accept invalid blocks when attempting to sync with the network, representing a significant protocol violation.

4. **Defense-in-Depth Failure**: While downstream cryptographic checks (signature verification, trusted waypoints) provide additional protection, the manifest verification represents the first security boundary. Its bypass weakens the overall security posture and could be chained with other vulnerabilities.

The backup/restore system is critical infrastructure for disaster recovery. Vulnerabilities in this system affect node operators' ability to recover from failures safely.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires:
1. Attacker access to backup storage (via compromise, MITM, or social engineering)
2. Target operator performing a restore operation from the malicious backup
3. Absence of trusted waypoints that would catch the malicious data

While epochs cannot naturally reach `u64::MAX` in normal operation (would require ~50 billion years at daily epoch changes), the vulnerability is exploitable through deliberately crafted malicious input. Production deployments use release mode where integer overflow wraps silently rather than panicking, making the exploit reliable.

The backup/restore flow represents a realistic attack surface since operators regularly perform these operations for:
- Disaster recovery
- Node migration
- Network upgrades
- Historical data restoration

## Recommendation

Replace all unchecked arithmetic operations with checked variants that explicitly handle overflow conditions. Follow the pattern already established in the codebase:

```rust
impl EpochEndingBackup {
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints with overflow protection
        ensure!(
            self.first_epoch <= self.last_epoch,
            "first_epoch must be <= last_epoch"
        );
        
        let expected_waypoints = self.last_epoch
            .checked_sub(self.first_epoch)
            .ok_or_else(|| anyhow::anyhow!("Epoch range underflow"))?
            .checked_add(1)
            .ok_or_else(|| anyhow::anyhow!("Epoch range overflow (last_epoch cannot be u64::MAX)"))?;
            
        ensure!(
            expected_waypoints == self.waypoints.len() as u64,
            "Malformed manifest. first epoch: {}, last epoch {}, expected waypoints {}, actual {}",
            self.first_epoch,
            self.last_epoch,
            expected_waypoints,
            self.waypoints.len(),
        );

        // check chunk ranges
        ensure!(!self.chunks.is_empty(), "No chunks.");
        let mut next_epoch = self.first_epoch;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_epoch == next_epoch,
                "Chunk ranges not continuous. Expected first epoch: {}, actual: {}.",
                next_epoch,
                chunk.first_epoch,
            );
            ensure!(
                chunk.last_epoch >= chunk.first_epoch,
                "Chunk range invalid. [{}, {}]",
                chunk.first_epoch,
                chunk.last_epoch,
            );
            next_epoch = chunk.last_epoch
                .checked_add(1)
                .ok_or_else(|| anyhow::anyhow!("Chunk last_epoch cannot be u64::MAX"))?;
        }

        // check last epoch in chunk matches manifest
        ensure!(
            next_epoch.checked_sub(1) == Some(self.last_epoch),
            "Last epoch in chunks: {:?}, in manifest: {}",
            next_epoch.checked_sub(1),
            self.last_epoch,
        );

        Ok(())
    }
}
```

Apply similar fixes to the restore validation at line 99.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::waypoint::Waypoint;
    use aptos_crypto::HashValue;
    
    #[test]
    fn test_manifest_overflow_vulnerability() {
        // Create malicious manifest with epochs near u64::MAX
        let malicious_manifest = EpochEndingBackup {
            first_epoch: 0,
            last_epoch: u64::MAX,
            waypoints: vec![], // Should require u64::MAX + 1 waypoints, but overflow makes it expect 0
            chunks: vec![EpochEndingChunk {
                first_epoch: 0,
                last_epoch: u64::MAX,
                ledger_infos: FileHandle::new("fake_handle".to_string()),
            }],
        };
        
        // This should FAIL but currently PASSES due to overflow
        // Expected: Err("Malformed manifest...")
        // Actual: Ok(()) due to overflow making 0 == 0
        let result = malicious_manifest.verify();
        
        // In release mode (production), this incorrectly passes:
        // u64::MAX - 0 + 1 = 0 (overflow)
        // 0 == waypoints.len() = 0 âœ“ (false validation)
        
        // Demonstrate the overflow behavior
        let calculation: u64 = u64::MAX.wrapping_sub(0).wrapping_add(1);
        assert_eq!(calculation, 0, "Overflow wraps to 0 in release mode");
        
        println!("Manifest verification result: {:?}", result);
        println!("Expected to fail with overflow check, but may pass in release mode");
    }
    
    #[test]
    fn test_chunk_overflow() {
        // Demonstrate chunk range overflow
        let last_epoch = u64::MAX;
        let next_epoch = last_epoch.wrapping_add(1); // Overflows to 0
        let check = next_epoch.wrapping_sub(1); // Underflows to u64::MAX
        
        assert_eq!(next_epoch, 0, "next_epoch overflows to 0");
        assert_eq!(check, u64::MAX, "Underflow wraps back to u64::MAX");
        
        // This makes the validation at line 61 incorrectly pass
        assert_eq!(check, last_epoch, "Validation incorrectly passes");
    }
}
```

**Notes:**
- In debug builds, these overflows panic
- In release builds (production), they wrap around silently, enabling the exploit
- The PoC demonstrates the core arithmetic vulnerability
- A complete exploit would require crafting actual backup files and testing the full restore flow

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L31-38)
```rust
        ensure!(
            self.first_epoch <= self.last_epoch
                && self.last_epoch - self.first_epoch + 1 == self.waypoints.len() as u64,
            "Malformed manifest. first epoch: {}, last epoch {}, num waypoints {}",
            self.first_epoch,
            self.last_epoch,
            self.waypoints.len(),
        );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L56-56)
```rust
            next_epoch = chunk.last_epoch + 1;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L61-61)
```rust
            next_epoch - 1 == self.last_epoch, // okay to -1 because chunks is not empty.
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L81-83)
```rust
        let manifest: EpochEndingBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        manifest.verify()?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L98-105)
```rust
            ensure!(
                chunk.first_epoch + lis.len() as u64 == chunk.last_epoch + 1,
                "Number of items in chunks doesn't match that in manifest. \
                first_epoch: {}, last_epoch: {}, items in chunk: {}",
                chunk.first_epoch,
                chunk.last_epoch,
                lis.len(),
            );
```

**File:** state-sync/storage-service/server/src/storage.rs (L1485-1493)
```rust
fn inclusive_range_len(start: u64, end: u64) -> aptos_storage_service_types::Result<u64, Error> {
    // len = end - start + 1
    let len = end.checked_sub(start).ok_or_else(|| {
        Error::InvalidRequest(format!("end ({}) must be >= start ({})", end, start))
    })?;
    let len = len
        .checked_add(1)
        .ok_or_else(|| Error::InvalidRequest(format!("end ({}) must not be u64::MAX", end)))?;
    Ok(len)
```
