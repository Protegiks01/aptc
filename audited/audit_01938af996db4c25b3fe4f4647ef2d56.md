# Audit Report

## Title
JWK Consensus Session Key Collision via Unnormalized Issuer and KID Values

## Summary
The JWK consensus system in per-key mode creates session keys from raw byte representations of Issuer and KID without any normalization, allowing equivalent but differently-formatted URLs (e.g., with/without trailing slashes, different case, or explicit default ports) to create separate consensus sessions and validator transaction pool entries for the same logical OIDC provider and key.

## Finding Description

The `ConsensusSessionKey` type in per-key mode is defined as a tuple `(Issuer, KID)` where both types are `Vec<u8>`. [1](#0-0) 

Session keys are extracted directly from quorum-certified updates without any normalization: [2](#0-1) 

The `Issuer` type is defined as raw bytes: [3](#0-2) 

Issuer conversion from strings is performed without normalization: [4](#0-3) 

JWK observers convert issuers to bytes without normalization: [5](#0-4) 

Evidence of URL format inconsistency exists in the codebase, with Auth0 requiring trailing slashes: [6](#0-5) 

While Google is defined without: [7](#0-6) 

These unnormalized session keys are used as HashMap keys: [8](#0-7) 

And as validator transaction pool Topic keys: [9](#0-8) 

The validator transaction pool maintains only one transaction per Topic, but different byte representations create different Topics: [10](#0-9) 

**Attack Scenario:**
1. An OIDC provider is configured via governance as `https://accounts.google.com`
2. Later, the same provider is added as `https://accounts.google.com/` (with trailing slash)
3. Different validators may observe JWKs from different sources that return URLs with different normalization
4. This creates two separate consensus sessions for the same logical (issuer, kid) pair
5. Validators submit different transactions to the pool with different Topics
6. Different validators may include different transactions in proposed blocks, causing consensus disagreements

## Impact Explanation

This vulnerability represents a **High Severity** issue under the Aptos bug bounty program, specifically "Significant protocol violations" and state inconsistencies.

**Broken Invariants:**
1. **Deterministic Execution**: Validators may execute different state transitions based on which URL variant they observe
2. **State Consistency**: The on-chain state may become inconsistent as validators disagree on which JWK update to apply

**Concrete Impact:**
- Multiple concurrent consensus sessions for the same logical JWK, wasting validator resources
- Validator transaction pool maintains duplicate entries under different Topics
- Potential consensus disagreements where validators include different transactions in blocks
- State inconsistency requiring manual intervention to resolve
- Degraded validator performance due to redundant consensus processes

This does not reach Critical severity because it does not directly cause fund loss or permanent network partition, but it significantly impacts protocol correctness and validator coordination.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability can occur through multiple realistic scenarios:

1. **Governance Configuration Errors**: Different governance proposals adding the same OIDC provider with different URL formats (highly likely given human error)

2. **OIDC Provider Behavior**: External OIDC providers may return their issuer URLs with different formatting in different contexts (e.g., OpenID configuration endpoint vs. JWT `iss` claim)

3. **URL Standards Ambiguity**: RFC 3986 allows equivalent URLs to be represented differently (trailing slashes, case variations in scheme/host, explicit default ports)

The issue requires no malicious intent - it can occur naturally through configuration drift or external provider inconsistencies. While it requires governance action or provider configuration changes, these are routine operations in the JWK consensus system.

## Recommendation

Implement URL normalization for OIDC issuer values before using them as session keys or comparison. The normalization should:

1. **Trim trailing slashes** from the path component
2. **Lowercase the scheme and host** components
3. **Remove explicit default ports** (443 for https, 80 for http)
4. **Normalize percent-encoding** to canonical form

**Proposed Fix in `types/src/jwks/mod.rs`:**

```rust
pub fn issuer_from_str(s: &str) -> Issuer {
    normalize_issuer_url(s).as_bytes().to_vec()
}

fn normalize_issuer_url(url: &str) -> String {
    // Parse URL or return as-is if invalid
    let parsed = match url::Url::parse(url) {
        Ok(u) => u,
        Err(_) => return url.to_string(),
    };
    
    let mut normalized = String::new();
    
    // Lowercase scheme
    normalized.push_str(&parsed.scheme().to_lowercase());
    normalized.push_str("://");
    
    // Lowercase host
    if let Some(host) = parsed.host_str() {
        normalized.push_str(&host.to_lowercase());
    }
    
    // Omit default ports
    if let Some(port) = parsed.port() {
        let is_default = (parsed.scheme() == "https" && port == 443) ||
                        (parsed.scheme() == "http" && port == 80);
        if !is_default {
            normalized.push(':');
            normalized.push_str(&port.to_string());
        }
    }
    
    // Trim trailing slash from path
    let path = parsed.path().trim_end_matches('/');
    if !path.is_empty() {
        normalized.push_str(path);
    }
    
    normalized
}
```

Apply the same normalization in:
- `jwk_observer.rs` when converting observed issuers
- `KeyLevelUpdate::try_from_issuer_level_repr` when extracting issuer from updates
- All issuer comparison operations

**KID Normalization:**

For KID values from RSA_JWK, ensure consistent string encoding: [11](#0-10) 

Consider Unicode normalization (NFC) for KID strings to prevent equivalent but differently-encoded identifiers.

## Proof of Concept

**Rust Test demonstrating the vulnerability:**

```rust
#[test]
fn test_issuer_normalization_vulnerability() {
    use aptos_types::jwks::{issuer_from_str, Issuer};
    
    // Same issuer, different representations
    let issuer1: Issuer = issuer_from_str("https://accounts.google.com");
    let issuer2: Issuer = issuer_from_str("https://accounts.google.com/");
    let issuer3: Issuer = issuer_from_str("HTTPS://ACCOUNTS.GOOGLE.COM");
    let issuer4: Issuer = issuer_from_str("https://accounts.google.com:443");
    
    // These should be equal after normalization, but aren't
    assert_ne!(issuer1, issuer2); // FAILS - trailing slash differs
    assert_ne!(issuer1, issuer3); // FAILS - case differs
    assert_ne!(issuer1, issuer4); // FAILS - explicit port differs
    
    // These create different session keys
    let kid = b"test-kid".to_vec();
    let session_key1 = (issuer1, kid.clone());
    let session_key2 = (issuer2, kid.clone());
    
    // Different session keys for same logical issuer+kid
    assert_ne!(session_key1, session_key2);
    
    // This causes different Topics in validator transaction pool
    use aptos_types::validator_txn::Topic;
    let topic1 = Topic::JWK_CONSENSUS_PER_KEY_MODE {
        issuer: session_key1.0,
        kid: session_key1.1,
    };
    let topic2 = Topic::JWK_CONSENSUS_PER_KEY_MODE {
        issuer: session_key2.0,
        kid: session_key2.1,
    };
    assert_ne!(topic1, topic2); // Different topics = different pool entries
}
```

**Move Test demonstrating governance configuration issue:**

```move
#[test(framework = @aptos_framework)]
fun test_duplicate_issuer_variants(framework: &signer) {
    use aptos_framework::jwks;
    use std::string::utf8;
    
    jwks::initialize_for_test(framework);
    
    // Add issuer without trailing slash
    jwks::upsert_oidc_provider(
        framework,
        b"https://example.com",
        b"https://example.com/.well-known/openid-configuration"
    );
    
    // Add same issuer with trailing slash - should be same but isn't
    jwks::upsert_oidc_provider(
        framework,
        b"https://example.com/",
        b"https://example.com/.well-known/openid-configuration"
    );
    
    // Now we have TWO separate OIDC providers for the same logical entity
    // This will cause two separate consensus sessions
}
```

### Citations

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L12-12)
```rust
    type ConsensusSessionKey = (Issuer, KID);
```

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L59-64)
```rust
    fn session_key_from_qc(qc: &QuorumCertifiedUpdate) -> anyhow::Result<(Issuer, KID)> {
        let KeyLevelUpdate { issuer, kid, .. } =
            KeyLevelUpdate::try_from_issuer_level_repr(&qc.update)
                .context("session_key_from_qc failed with repr translation")?;
        Ok((issuer, kid))
    }
```

**File:** types/src/jwks/mod.rs (L36-36)
```rust
pub type Issuer = Vec<u8>;
```

**File:** types/src/jwks/mod.rs (L48-50)
```rust
pub fn issuer_from_str(s: &str) -> Issuer {
    s.as_bytes().to_vec()
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L80-80)
```rust
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
```

**File:** keyless/pepper/service/src/external_resources/jwk_fetcher.rs (L27-27)
```rust
const ISSUER_GOOGLE: &str = "https://accounts.google.com";
```

**File:** keyless/pepper/service/src/external_resources/jwk_fetcher.rs (L38-38)
```rust
pub const AUTH0_REGEX_STR: &str = r"^https://[a-zA-Z0-9-]+\.us\.auth0\.com/$";
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L59-59)
```rust
    states_by_key: HashMap<(Issuer, KID), ConsensusState<ObservedKeyLevelUpdate>>,
```

**File:** types/src/validator_txn.rs (L60-63)
```rust
    JWK_CONSENSUS_PER_KEY_MODE {
        issuer: jwks::Issuer,
        kid: jwks::KID,
    },
```

**File:** crates/validator-transaction-pool/src/lib.rs (L74-76)
```rust
        if let Some(old_seq_num) = pool.seq_nums_by_topic.insert(topic.clone(), seq_num) {
            pool.txn_queue.remove(&old_seq_num);
        }
```

**File:** types/src/jwks/rsa/mod.rs (L97-99)
```rust
    pub fn id(&self) -> Vec<u8> {
        self.kid.as_bytes().to_vec()
    }
```
