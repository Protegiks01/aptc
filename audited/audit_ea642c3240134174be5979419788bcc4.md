# Audit Report

## Title
Information Disclosure via Event Pagination Error Messages Exposes Internal Sequence Numbers and Pruning State

## Summary
The event query API endpoints expose internal database sequence numbers and storage keys in error messages when pagination encounters discontinuities, allowing attackers to map pruning boundaries and event stream gaps.

## Finding Description
The `get_events_by_event_handle()` and `get_events_by_creation_number()` functions in the Events API leak internal implementation details through error messages when querying events with pagination parameters.

When the storage layer encounters sequence number discontinuities (due to pruning or database gaps), it generates detailed error messages that are propagated to API clients. Specifically: [1](#0-0) 

This error message exposes:
- The expected sequence number (`cur_seq`)
- The actual sequence number found in storage (`seq`)
- Whether this is the first requested event (indicating pruning) or a mid-stream gap (indicating corruption)

The error is then wrapped with additional context: [2](#0-1) 

The complete error chain is formatted into an `AptosError` struct and serialized to JSON for the client: [3](#0-2) 

An example error response reveals:
```
{
  "message": "Failed to find events by key 0x0500000000000000000000000000000000000000000000000000000000000001\n\nCaused by:\n    First requested event is probably pruned. expected: 100, actual: 500",
  "error_code": "internal_error"
}
```

## Impact Explanation
This qualifies as **Low Severity** per the Aptos bug bounty program criteria for "Minor information leaks." The vulnerability does NOT:
- Enable theft or minting of funds
- Cause consensus safety violations
- Affect network availability or partition the network
- Corrupt state or require hardfork intervention

The information disclosed allows attackers to:
1. Probe for pruned sequence numbers and determine exact pruning boundaries
2. Learn the node's storage configuration (pruning policies, retention periods)
3. Map gaps in event streams that may reveal implementation details
4. Potentially fingerprint node age or configuration

However, this does not directly lead to exploitable security vulnerabilities affecting funds, consensus, or availability.

## Likelihood Explanation
This issue occurs with HIGH frequency for any API user querying events on nodes with pruning enabled. The attack requires only:
- Public API access (no authentication required)
- Knowledge of valid account addresses (publicly available on-chain)
- Basic understanding of event query parameters

The information leak is deterministic and reproducible across all nodes with pruning enabled.

## Recommendation
Sanitize error messages to remove internal sequence numbers before returning to clients. Replace detailed error messages with generic responses that don't reveal storage implementation details:

```rust
// In storage/indexer/src/db_indexer.rs, replace lines 232-239:
if seq != cur_seq {
    if cur_seq == start_seq_num {
        bail!("Requested event sequence number is not available (possibly pruned)");
    } else {
        bail!("Event sequence is not continuous");
    }
}

// In api/src/events.rs, replace line 171:
.context("Failed to retrieve events")
```

Additionally, consider rate-limiting event queries to prevent rapid enumeration attempts.

## Proof of Concept
```bash
# Query events with a sequence number that has been pruned
curl -X GET "https://fullnode.mainnet.aptoslabs.com/v1/accounts/0x1/events/0x1::account::Account/coin_register_events?start=1" \
  -H "Accept: application/json"

# Response reveals internal details:
# {
#   "message": "Failed to find events by key 0x0100000000000000...\n\nCaused by:\n    First requested event is probably pruned. expected: 1, actual: 1000000",
#   "error_code": "internal_error"
# }

# Attacker can binary search to find exact pruning boundary:
# Try start=500000 -> Error reveals actual: 1000000
# Try start=750000 -> Error reveals actual: 1000000
# Try start=1000000 -> Success, found boundary
```

**Note:** While this is a valid information disclosure issue, it falls under Low severity and does not meet the Critical/High/Medium impact threshold specified in the validation checklist requirements for exploitation affecting funds, consensus, or availability.

### Citations

**File:** storage/indexer/src/db_indexer.rs (L232-239)
```rust
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
            }
```

**File:** api/src/events.rs (L163-178)
```rust
        let events = self
            .context
            .get_events(
                &event_key,
                page.start_option(),
                page.limit(&latest_ledger_info)?,
                ledger_version,
            )
            .context(format!("Failed to find events by key {}", event_key))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &latest_ledger_info,
                )
            })?;
```

**File:** api/types/src/error.rs (L28-38)
```rust
impl AptosError {
    pub fn new_with_error_code<ErrorType: std::fmt::Display>(
        error: ErrorType,
        error_code: AptosErrorCode,
    ) -> AptosError {
        Self {
            message: format!("{:#}", error),
            error_code,
            vm_error_code: None,
        }
    }
```
