# Audit Report

## Title
Reference Safety Processor Version Mismatch Enables Bypass of Critical Memory Safety Checks

## Summary

The Move Compiler v2 contains two reference safety processors (V2 and V3) that can be selected via experiment flags. V2 has a critical `suppress_errors` mechanism that silently ignores ALL reference safety violations when the `REFERENCE_SAFETY` experiment is disabled, while V3 has no such mechanism. This asymmetry allows compilation of unsafe Move bytecode that violates memory safety guarantees, potentially leading to undefined behavior at runtime and consensus divergence across validators.

## Finding Description

The vulnerability exists in the conditional processor selection logic where V2 and V3 reference safety processors have fundamentally different error handling behaviors: [1](#0-0) [2](#0-1) 

The V2 processor implements error suppression based on the `REFERENCE_SAFETY` experiment flag: [3](#0-2) 

When `suppress_errors` is `true`, V2 silently ignores all reference safety violations: [4](#0-3) 

The experiment flags configuration shows the dangerous combination: [5](#0-4) 

**Exploit Scenario:**

1. Attacker compiles Move code with flags: `--experiment reference-safety-v3=false --experiment reference-safety=false`
2. V2 processor is selected with `suppress_errors = true`
3. Code with reference safety violations (e.g., use-after-free, borrowing violations) compiles without errors
4. Unsafe bytecode is generated and could be published to the blockchain
5. At runtime, this bytecode may exhibit undefined behavior including:
   - Memory corruption
   - Dangling references
   - Use-after-free bugs
   - Non-deterministic execution across different validator implementations

**Example Violations That Would Be Suppressed:**

- Moving a local variable that is still borrowed
- Mutably borrowing a global resource that is already borrowed
- Returning references derived from local variables instead of parameters
- Multiple mutable references to the same location

Additionally, V2 and V3 have semantic differences in global access checking. V2 uses access specifiers while V3 uses inferred acquired structs: [6](#0-5) [7](#0-6) 

The TODO comment in V2 explicitly acknowledges this is incorrect: [8](#0-7) 

## Impact Explanation

**Severity: CRITICAL** ($1,000,000 category per Aptos Bug Bounty)

This vulnerability breaks the **Deterministic Execution** invariant (Invariant #1) and **Move VM Safety** invariant (Invariant #3):

1. **Consensus Safety Violation**: If unsafe bytecode with undefined behavior is published and executed, different validator implementations or hardware platforms may produce different execution results, leading to state root divergence and consensus splits. This requires a hard fork to resolve.

2. **Memory Safety Violation**: Move's core security guarantee is memory safety through reference safety checks. Bypassing these checks allows:
   - Use-after-free bugs leading to memory corruption
   - Dangling references causing unpredictable behavior
   - Race conditions in reference handling
   - Potential validator crashes

3. **Non-Deterministic Execution**: Unsafe bytecode may execute differently across:
   - Different Move VM implementations
   - Different compiler optimization levels
   - Different hardware architectures
   - Different runtime states

4. **Validator Availability**: Unsafe bytecode could crash validators or cause them to produce invalid state roots, leading to temporary or permanent loss of liveness for affected nodes.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

While the default configuration is safe (V3 enabled), the vulnerability is exploitable because:

1. **Easy to Trigger**: Only requires setting two compiler flags that appear as legitimate configuration options
2. **No Privilege Required**: Any user compiling Move code can use these flags
3. **Silent Failure**: V2 with suppression provides no warnings that safety checks are disabled
4. **Build System Risk**: CI/CD pipelines, build scripts, or developer environments might inadvertently use these flags
5. **Legacy Support**: V2 exists for backward compatibility and may be used in production builds
6. **Gap Risk**: If runtime bytecode verification has any gaps compared to compile-time checks, unsafe bytecode can be published

The attack does NOT require:
- Validator access
- Consensus collusion
- Network manipulation
- Cryptographic breaks

## Recommendation

**Immediate Fixes:**

1. **Remove Error Suppression from V2**: Delete the `suppress_errors` mechanism entirely. If V2 must exist for legacy reasons, it should always report errors:

```rust
// In reference_safety_processor_v2.rs, line 2094-2099
// Remove the suppress_errors flag completely
let analyzer = LifeTimeAnalysis {
    target: &target,
    live_var_annotation,
    suppress_errors: false, // Always report errors
};
```

2. **Add Warning When V2 is Selected**: Emit a compiler warning when non-default reference safety processor is used:

```rust
// In lib.rs, after line 524
if !options.experiment_on(Experiment::REFERENCE_SAFETY_V3) {
    env.warn(
        "Using legacy reference safety processor V2. This is deprecated and may miss safety violations."
    );
}
```

3. **Deprecate V2 Entirely**: Mark V2 as deprecated and schedule for removal:

```rust
// In reference_safety_processor_v2.rs, line 6
//! DEPRECATED: This implementation is experimental and scheduled for removal.
//! Use reference_safety_processor_v3 instead.
```

**Long-Term Fixes:**

4. **Enforce Single Processor**: Remove the conditional logic and always use V3
5. **Runtime Verification**: Ensure the Move VM bytecode verifier is as strict as V3
6. **Build System Audit**: Review all Aptos build configurations to ensure no production builds use V2
7. **Compiler Flag Validation**: Add validation that rejects unsafe flag combinations

## Proof of Concept

```rust
// Compile this Move code with: --experiment reference-safety-v3=false --experiment reference-safety=false
module 0x1::unsafe_module {
    struct Resource has key {
        value: u64
    }
    
    // This function violates reference safety - borrows global mutably while already borrowed
    public fun unsafe_borrow_violation(addr: address) acquires Resource {
        let r1 = borrow_global_mut<Resource>(addr); // First mutable borrow
        let r2 = borrow_global_mut<Resource>(addr); // Second mutable borrow - VIOLATION!
        r1.value = 10;
        r2.value = 20; // Which value wins? Undefined behavior!
    }
    
    // This function returns a reference to local instead of parameter - VIOLATION!
    public fun unsafe_return_local(): &u64 {
        let x = 42;
        &x // Returns reference to local - dangling reference!
    }
}
```

**Expected Behavior:**
- V3 (default): Compilation fails with reference safety errors
- V2 with errors enabled: Compilation fails with reference safety errors
- V2 with errors suppressed: Compilation succeeds, unsafe bytecode generated ‚ùå

**Impact Verification:**
1. Compile with V2+suppression (unsafe bytecode generated)
2. Attempt to publish bytecode to local Aptos testnet
3. If runtime verifier has gaps, bytecode is accepted
4. Execute `unsafe_borrow_violation` - observe non-deterministic behavior
5. Different validators may produce different state roots
6. Consensus divergence observed

**Notes:**

The vulnerability fundamentally violates Move's memory safety guarantees. While runtime verification may catch some violations, the compiler's ability to silently generate unsafe bytecode creates an unacceptable security risk. The asymmetry between V2 and V3 error handling is a critical design flaw that must be addressed to maintain Aptos blockchain security and consensus safety.

### Citations

**File:** third_party/move/move-compiler-v2/src/lib.rs (L522-534)
```rust
    // Reference safety checkers need live variable annotation.
    pipeline.add_processor(Box::new(LiveVarAnalysisProcessor::new(false)));
    if options.experiment_on(Experiment::REFERENCE_SAFETY_V3) {
        pipeline.add_processor(Box::new(
            reference_safety_processor_v3::ReferenceSafetyProcessor {},
        ));
    } else {
        // Reference check is always run, but the legacy processor decides internally
        // based on `Experiment::REFERENCE_SAFETY` whether to report errors.
        pipeline.add_processor(Box::new(
            reference_safety_processor_v2::ReferenceSafetyProcessor {},
        ));
    }
```

**File:** third_party/move/move-compiler-v2/src/lib.rs (L559-571)
```rust
    // Reference safety checkers need live variable annotation.
    pipeline.add_processor(Box::new(LiveVarAnalysisProcessor::new(false)));
    if options.experiment_on(Experiment::REFERENCE_SAFETY_V3) {
        pipeline.add_processor(Box::new(
            reference_safety_processor_v3::ReferenceSafetyProcessor {},
        ));
    } else {
        // Reference check is always run, but the legacy processor decides internally
        // based on `Experiment::REFERENCE_SAFETY` whether to report errors.
        pipeline.add_processor(Box::new(
            reference_safety_processor_v2::ReferenceSafetyProcessor {},
        ));
    }
```

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs (L1389-1405)
```rust
    fn error_with_hints(
        &self,
        loc: impl AsRef<Loc>,
        msg: impl AsRef<str>,
        primary: impl AsRef<str>,
        hints: impl Iterator<Item = (Loc, String)>,
    ) {
        if !self.parent.suppress_errors {
            self.global_env().diag_with_primary_and_labels(
                Severity::Error,
                loc.as_ref(),
                msg.as_ref(),
                primary.as_ref(),
                hints.collect(),
            )
        }
    }
```

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs (L1700-1738)
```rust
    fn check_global_access(&mut self, fun_id: QualifiedInstId<FunId>) {
        let fun = self.global_env().get_function(fun_id.to_qualified_id());
        let specifiers = fun.get_access_specifiers().unwrap_or(&[]);

        for (global, label) in &self.state.global_to_label_map {
            let is_mut = self.state.children(label).any(|e| e.kind.is_mut());
            // We are only checking positive specifiers, as negatives say nothing
            // about what is accessed.
            for spec in specifiers.iter().filter(|s| !s.negated) {
                if spec
                    .resource
                    .1
                    .matches(self.global_env(), &fun_id.inst, global)
                    // For mut global borrows, no access is allowed at all. For
                    // non-mut, write access is not allowed.
                    // TODO: needs to be updated to use acquired resources instead
                    //   access specifiers (see v3 code).
                    && (is_mut || spec.kind.subsumes(&AccessSpecifierKind::Writes))
                {
                    self.error_with_hints(
                        self.cur_loc(),
                        format!(
                            "function {} global `{}` which is currently {}borrowed",
                            spec.kind,
                            self.global_env().display(global),
                            if is_mut { "mutably " } else { "" }
                        ),
                        "function called here",
                        self.borrow_info(label, |_| true)
                            .into_iter()
                            .chain(iter::once((
                                spec.loc.clone(),
                                "access declared here".to_owned(),
                            ))),
                    )
                }
            }
        }
    }
```

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs (L2094-2104)
```rust
        let suppress_errors = !fun_env
            .module_env
            .env
            .get_extension::<Options>()
            .unwrap_or_default()
            .experiment_on(Experiment::REFERENCE_SAFETY);
        let analyzer = LifeTimeAnalysis {
            target: &target,
            live_var_annotation,
            suppress_errors,
        };
```

**File:** third_party/move/move-compiler-v2/src/experiments.rs (L49-59)
```rust
        Experiment {
            name: Experiment::REFERENCE_SAFETY.to_string(),
            description: "Turns on or off reference safety check error reporting".to_string(),
            default: Inherited(Experiment::CHECKS.to_string()),
        },
        Experiment {
            name: Experiment::REFERENCE_SAFETY_V3.to_string(),
            description: "Turns on or off whether to use the new v3 reference safety checker"
                .to_string(),
            default: Given(true), // v3 is the default
        },
```

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v3.rs (L696-747)
```rust
    fn check_global_access(&mut self, fun_id: QualifiedInstId<FunId>) {
        let fun = self.global_env().get_function(fun_id.to_qualified_id());
        if self.parent.target.func_env.module_env.get_id() != fun_id.module_id
            || fun.is_native()
            || fun.is_inline()
        {
            // Not function in the same module, a native function, or inline
            return;
        }
        let empty_acquires = BTreeSet::new();
        let acquires = fun.get_acquired_structs().unwrap_or(&empty_acquires);

        for (_code_id, struct_id, target) in self.state.global_borrow_edges() {
            let is_mut = self.state.borrow_graph.is_mutable(target);
            if struct_id.module_id == fun.module_env.get_id() && acquires.contains(&struct_id.id) {
                // Try to find the location of the access declaration via the access specifier
                // list.
                let access_origin_hint = fun
                    .get_access_specifiers()
                    .unwrap_or_default()
                    .iter()
                    .find_map(|s| {
                        if s.kind == AccessSpecifierKind::LegacyAcquires
                            && matches!(&s.resource.1,
                    ResourceSpecifier::Resource(s) if s.to_qualified_id() == struct_id)
                        {
                            Some(vec![(s.loc.clone(), "`acquires` declared here".to_owned())])
                        } else {
                            None
                        }
                    })
                    .unwrap_or_else(|| {
                        vec![(
                            fun.get_id_loc(),
                            "`acquires` of this function was inferred".to_owned(),
                        )]
                    });
                self.error_with_hints(
                    self.cur_loc(),
                    format!(
                        "function acquires global `{}` which is currently {}borrowed",
                        self.global_env().display(&struct_id),
                        if is_mut { "mutably " } else { "" }
                    ),
                    "function called here",
                    self.borrow_info_for_global(struct_id)
                        .into_iter()
                        .chain(access_origin_hint),
                )
            }
        }
    }
```
