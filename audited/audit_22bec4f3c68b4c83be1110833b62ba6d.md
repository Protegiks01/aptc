# Audit Report

## Title
Critical Authentication Bypass in Aptos Faucet via Unchecked JWT Header Flag

## Summary
The `AuthTokenChecker` in the Aptos faucet service bypasses authentication when the `X_IS_JWT_HEADER` header is present, assuming JWT validation will occur elsewhere. However, JWT validation is only performed by `FirebaseJwtVerifier` within `RedisRatelimitChecker` when explicitly configured with JWT mode. If a faucet is deployed with `AuthTokenChecker` enabled but without a JWT-configured rate limiter, attackers can bypass all authentication by simply adding the `X_IS_JWT_HEADER` header to their requests, enabling unlimited fund withdrawals.

## Finding Description

The vulnerability exists in the authentication logic of the Aptos faucet service. When the `X_IS_JWT_HEADER` header is present in a request, the `AuthTokenChecker::check()` function immediately returns success without validating any credentials: [1](#0-0) 

This early return assumes that JWT validation will be performed by `FirebaseJwtVerifier` later in the request processing pipeline. However, `FirebaseJwtVerifier` is **only instantiated and used** within the `RedisRatelimitChecker` when configured with the `Jwt` variant of `RatelimitKeyProviderConfig`: [2](#0-1) 

The critical issue is that `RatelimitKeyProviderConfig` defaults to `Ip` mode, not `Jwt` mode: [3](#0-2) 

**Attack Flow:**

1. Attacker sends a fund request to the faucet API endpoint
2. Request includes the `X_IS_JWT_HEADER` header (any value or just presence)
3. The `preprocess_request()` function runs all configured checkers: [4](#0-3) 

4. When `AuthTokenChecker` runs, it detects the header and returns `Ok(vec![])`, bypassing authentication
5. If no `RedisRatelimitChecker` with JWT config exists, **no JWT validation ever occurs**
6. Request proceeds to funding without any authentication

**Vulnerable Configuration Example:**
```yaml
checker_configs:
  - type: AuthToken
    file_path: "/path/to/tokens.txt"
  - type: RedisRatelimit
    database_address: "redis.example.com"
    max_requests_per_day: 100
    # ratelimit_key_provider_config defaults to "Ip"
```

There is **no validation** in the configuration system that enforces the invariant: "If `X_IS_JWT_HEADER` bypass is enabled in `AuthTokenChecker`, then JWT validation MUST be configured." [5](#0-4) 

The validation only checks if the YAML is parseable, not if the checker configuration is logically secure.

## Impact Explanation

**Severity: CRITICAL (Loss of Funds)**

This vulnerability enables complete authentication bypass on production Aptos faucet deployments, allowing attackers to:

1. **Drain Faucet Funds**: Make unlimited funding requests without authentication
2. **Bypass Rate Limiting**: If rate limiting is IP-based, attackers can use proxies/VPNs
3. **Disable DoS Protection**: Authentication-based DoS protections are circumvented

**Affected Deployments:**
- Any faucet with `AuthTokenChecker` enabled
- AND lacking `RedisRatelimitChecker` with explicit `Jwt` configuration
- OR with `RedisRatelimitChecker` using default `Ip` mode

Per Aptos Bug Bounty criteria, this qualifies as **Critical Severity** ($1,000,000 maximum) because it enables:
- **Loss of Funds**: Direct theft from faucet treasury
- **Access Control Bypass**: Complete circumvention of authentication system

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Simple Exploitation**: Requires only adding a single HTTP header
2. **No Special Privileges**: Any anonymous user can exploit this
3. **Configuration Ambiguity**: Default configurations may be vulnerable
4. **Common Deployment Pattern**: Many faucets likely use IP-based rate limiting (the default)

The misconfiguration is easy to introduce because:
- The `Ip` mode is the **default** for rate limiting
- Documentation doesn't clearly warn about the security dependency
- Configuration validation doesn't catch this logical error
- The JWT header bypass appears intentional, hiding the vulnerability

## Recommendation

**Immediate Mitigation:**
1. Audit all production faucet configurations
2. Ensure any faucet using `AuthTokenChecker` also has `RedisRatelimitChecker` with `type: Jwt`
3. Add runtime validation that rejects requests with `X_IS_JWT_HEADER` if JWT verification is not configured

**Code Fix:**

In `AuthTokenChecker::check()`, remove the unconditional bypass and make JWT support explicit through configuration:

```rust
// Remove the automatic bypass:
// if data.headers.contains_key(X_IS_JWT_HEADER) {
//     return Ok(vec![]);
// }

// Instead, treat JWT requests as invalid for this checker:
if data.headers.contains_key(X_IS_JWT_HEADER) {
    return Ok(vec![RejectionReason::new(
        "JWT authentication is not supported by this checker. Configure RedisRatelimitChecker with JWT mode.".to_string(),
        RejectionReasonCode::AuthTokenInvalid,
    )]);
}
```

**Structural Fix:**

Add configuration validation in `RunConfig::run_impl()`:

```rust
// After building checkers, validate JWT configuration
let has_auth_token_checker = self.checker_configs.iter().any(|c| matches!(c, CheckerConfig::AuthToken(_)));
let has_jwt_ratelimit = self.checker_configs.iter().any(|c| {
    matches!(c, CheckerConfig::RedisRatelimit(config) 
        if matches!(config.ratelimit_key_provider_config, RatelimitKeyProviderConfig::Jwt(_)))
});

if has_auth_token_checker && !has_jwt_ratelimit {
    anyhow::bail!("Security: AuthTokenChecker is configured but JWT validation is not enabled. Add RedisRatelimit with type: Jwt");
}
```

## Proof of Concept

**Test Configuration (VULNERABLE):**
```yaml
server_config:
  listen_address: "0.0.0.0"
  listen_port: 8081
  api_path_base: ""

checker_configs:
  - type: AuthToken
    file_path: "/tmp/valid_tokens.txt"  # Contains "valid_token_123"
  - type: RedisRatelimit
    database_address: "localhost"
    database_port: 6379
    max_requests_per_day: 5
    # Vulnerable: ratelimit_key_provider_config defaults to Ip, not Jwt

funder_config:
  # ... standard config ...
```

**Exploitation Steps:**

1. **Legitimate Request (REJECTED):**
```bash
curl -X POST http://localhost:8081/fund \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer wrong_token" \
  -d '{"address": "0x1234567890abcdef"}'
# Result: 403 Forbidden - "auth token is not allowed"
```

2. **Attack Request (BYPASSES AUTH):**
```bash
curl -X POST http://localhost:8081/fund \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer anything_or_nothing" \
  -H "x-is-jwt: true" \
  -d '{"address": "0x1234567890abcdef"}'
# Result: 200 OK - Funds transferred WITHOUT authentication!
```

The second request bypasses authentication entirely because:
- `AuthTokenChecker` sees `x-is-jwt` header and returns `Ok(vec![])`
- No JWT validation occurs because `RedisRatelimitChecker` is using IP mode
- Request proceeds to funding without any auth check

**Expected Result:** Both requests should be rejected if the token is invalid.

**Actual Result:** Second request succeeds, proving complete authentication bypass.

---

**Notes:**

This vulnerability represents a critical invariant violation: **"All faucet fund requests must be authenticated."** The broken trust assumption is that JWT validation will always occur when `X_IS_JWT_HEADER` is present, but this is not enforced by the codebase. The faucet service is not part of consensus or the core blockchain, but it represents a critical operational component that manages testnet/devnet fund distribution. Complete authentication bypass enables theft of all faucet funds and undermines the entire faucet security model.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L37-40)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L18-24)
```rust
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(tag = "type")]
pub enum RatelimitKeyProviderConfig {
    #[default]
    Ip,
    Jwt(FirebaseJwtVerifierConfig),
}
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L162-167)
```rust
        let ratelimit_key_provider = match args.ratelimit_key_provider_config.clone() {
            RatelimitKeyProviderConfig::Ip => RatelimitKeyProvider::Ip,
            RatelimitKeyProviderConfig::Jwt(config) => {
                RatelimitKeyProvider::Jwt(FirebaseJwtVerifier::new(config).await?)
            },
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L262-270)
```rust
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }
```

**File:** crates/aptos-faucet/core/src/server/validate_config.rs (L16-35)
```rust
impl ValidateConfig {
    pub async fn validate_config(&self) -> Result<()> {
        let file = File::open(&self.config_path).with_context(|| {
            format!(
                "Failed to load config at {}",
                self.config_path.to_string_lossy()
            )
        })?;
        let reader = BufReader::new(file);
        let run_config: RunConfig = serde_yaml::from_reader(reader).with_context(|| {
            format!(
                "Failed to parse config at {}",
                self.config_path.to_string_lossy()
            )
        })?;

        info!("Config is valid: {:#?}", run_config);

        Ok(())
    }
```
