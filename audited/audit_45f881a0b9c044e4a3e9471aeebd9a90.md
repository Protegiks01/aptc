# Audit Report

## Title
MagicHeaderChecker Provides No Amount Control - Attackers Can Request Maximum Funds With Leaked Header

## Summary
The `MagicHeaderChecker` provides no control over requested fund amounts. Once an attacker obtains the magic header value (a shared secret), they can repeatedly request the maximum configured amount, limited only by rate limits and the global `maximum_amount` configuration. This creates a security risk where a leaked authentication token allows unrestricted high-value requests.

## Finding Description

The `MagicHeaderChecker.check()` function only validates the presence and correctness of a magic HTTP header, but has zero visibility or control over the requested fund amount. [1](#0-0) 

The `CheckerData` structure passed to all checkers contains only metadata (receiver address, source IP, headers, timestamp) but **excludes the amount field entirely**: [2](#0-1) 

The fund amount is processed separately by the `Funder` after all checkers pass, where it is only capped by `TransactionSubmissionConfig.maximum_amount`: [3](#0-2) 

The `MintFunder.get_amount()` implementation shows the amount is capped using `std::cmp::min()` against the configured maximum, with no per-checker or per-identity quotas: [4](#0-3) 

**Attack Path:**
1. Faucet operator configures `MagicHeaderChecker` with header `"secret-key": "secret-value"` for internal testing
2. Operator sets `maximum_amount: 1000000000` (10 APT) assuming the magic header provides access control
3. Magic header value leaks through configuration files, logs, or test scripts
4. Attacker discovers the header value and crafts requests:
   ```
   POST /fund
   Headers: { "secret-key": "secret-value" }
   Body: { "amount": 1000000000, "address": "0x..." }
   ```
5. Each request passes the `MagicHeaderChecker` and receives the maximum 10 APT
6. Attacker repeats until rate limits are hit or faucet is drained

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" - in this case, per-identity fund quotas should exist but don't.

## Impact Explanation

**Medium Severity** per Aptos Bug Bounty criteria: "Limited funds loss or manipulation"

- **Funds at Risk**: Attacker can drain `maximum_amount Ã— rate_limit_count` per time period
- **Real-world Example**: If `maximum_amount = 10 APT` and rate limit allows 100 requests/day, attacker drains 1000 APT/day
- **Limited by**: Rate limiting mechanisms (`MemoryRatelimit`, `RedisRatelimit`) and `maximum_amount` configuration
- **Not Critical** because: Damage is bounded by configuration, not unlimited fund minting

The impact is constrained but real - operators may set high limits expecting the magic header to provide fine-grained control, when it only provides binary authentication.

## Likelihood Explanation

**Moderate to High Likelihood:**

**Attack Prerequisites:**
- Attacker must obtain magic header value (shared secret)
- Header can leak through:
  - Configuration files committed to repositories
  - Application logs exposing request headers
  - Test scripts or documentation
  - Developer machines or CI/CD pipelines

**Ease of Exploitation:**
- Once header is obtained, exploitation is trivial (simple HTTP requests)
- No cryptographic operations or complex timing required
- Can be automated for repeated exploitation

**Real-world Plausibility:**
- Shared secrets like magic headers frequently leak in practice
- Developers often hardcode them in test environments
- The faucet service is specifically designed for public access, increasing exposure surface

## Recommendation

Implement per-checker amount limits or identity-based quotas:

**Option 1: Add amount visibility to checkers**
Modify `CheckerData` to include the requested amount, allowing checkers to enforce limits:

```rust
pub struct CheckerData {
    pub time_request_received_secs: u64,
    pub receiver: AccountAddress,
    pub source_ip: IpAddr,
    pub headers: Arc<HeaderMap>,
    pub requested_amount: Option<u64>,  // ADD THIS
}
```

Then update `MagicHeaderChecker` to enforce a maximum:

```rust
pub struct MagicHeaderCheckerConfig {
    pub magic_header_key: String,
    pub magic_header_value: String,
    pub max_amount_per_request: Option<u64>,  // ADD THIS
}

impl CheckerTrait for MagicHeaderChecker {
    async fn check(&self, data: CheckerData, _dry_run: bool) -> Result<Vec<RejectionReason>, AptosTapError> {
        // ... existing header validation ...
        
        // Enforce amount limit if configured
        if let (Some(max), Some(requested)) = (self.config.max_amount_per_request, data.requested_amount) {
            if requested > max {
                return Ok(vec![RejectionReason::new(
                    format!("Requested amount {} exceeds magic header limit {}", requested, max),
                    RejectionReasonCode::AmountExceeded,
                )]);
            }
        }
        Ok(vec![])
    }
}
```

**Option 2: Use identity-based quotas**
Replace shared magic headers with per-identity tokens that have associated quota limits stored in Redis/PostgreSQL.

**Option 3: Clear documentation**
At minimum, document clearly that `MagicHeaderChecker` provides only binary authentication and operators must carefully configure `maximum_amount` to limit exposure.

## Proof of Concept

**Test Configuration** (`vulnerable_config.yaml`):
```yaml
checker_configs:
  - type: "MagicHeader"
    magic_header_key: "x-internal-access"
    magic_header_value: "leaked-secret-123"
funder_config:
  type: "MintFunder"
  maximum_amount: 10000000000  # 100 APT
  # ... other config ...
```

**Exploitation Steps:**

1. Start faucet with vulnerable config:
```bash
cargo run -- run -c vulnerable_config.yaml
```

2. Attacker obtains leaked header value `"leaked-secret-123"`

3. Attacker requests maximum amount repeatedly:
```bash
# Request 1: Get 100 APT
curl -X POST http://localhost:10212/fund \
  -H 'Content-Type: application/json' \
  -H 'x-internal-access: leaked-secret-123' \
  -d '{"amount": 10000000000, "address": "0x1234..."}'

# Request 2: Get another 100 APT (different address)
curl -X POST http://localhost:10212/fund \
  -H 'Content-Type: application/json' \
  -H 'x-internal-access: leaked-secret-123' \
  -d '{"amount": 10000000000, "address": "0x5678..."}'

# Repeat until rate limited or faucet drained
```

4. Verify each request receives full 100 APT despite checker providing no amount restrictions

**Expected Result:** All requests with correct header receive maximum amount  
**Actual Result:** Same - confirming the vulnerability

This can be tested against the existing test infrastructure by modifying the test at: [5](#0-4) 

## Notes

This is a **design limitation** that creates a **security misconfiguration risk**. While the system works as architecturally intended (separating authentication from amount limiting), it creates a dangerous scenario where:

1. Operators may incorrectly assume magic headers provide granular access control
2. Shared secrets (magic headers) are weaker than per-identity credentials
3. No per-identity quotas exist, only global rate limits

The vulnerability is **confirmed** and appropriately rated as **Medium severity** because attackers with leaked credentials can cause limited but significant fund drainage, bounded by configuration rather than unlimited.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/magic_header.rs (L28-52)
```rust
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        let header_value = match data.headers.get(&self.config.magic_header_key) {
            Some(header_value) => header_value,
            None => {
                return Ok(vec![RejectionReason::new(
                    format!("Magic header {} not found", self.config.magic_header_key),
                    RejectionReasonCode::MagicHeaderIncorrect,
                )])
            },
        };
        if header_value != &self.config.magic_header_value {
            return Ok(vec![RejectionReason::new(
                format!(
                    "Magic header value wrong {} not found",
                    self.config.magic_header_key
                ),
                RejectionReasonCode::MagicHeaderIncorrect,
            )]);
        }
        Ok(vec![])
    }
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L147-153)
```rust
#[derive(Clone, Debug)]
pub struct CheckerData {
    pub time_request_received_secs: u64,
    pub receiver: AccountAddress,
    pub source_ip: IpAddr,
    pub headers: Arc<HeaderMap>,
}
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L283-309)
```rust
    async fn fund_inner(
        &self,
        fund_request: FundRequest,
        // This automagically uses FromRequest to get this data from the request.
        // It takes into things like X-Forwarded-IP and X-Real-IP.
        source_ip: RealIp,
        // Same thing, this uses FromRequest.
        header_map: &HeaderMap,
        dry_run: bool,
        asset: Option<String>,
    ) -> poem::Result<Vec<SignedTransaction>, AptosTapError> {
        let (checker_data, bypass, _semaphore_permit) = self
            .preprocess_request(&fund_request, source_ip, header_map, dry_run)
            .await?;

        // Fund the account - pass asset directly, funder will use its configured default if None
        let asset_for_logging = asset.clone();
        let fund_result = self
            .funder
            .fund(
                fund_request.amount,
                checker_data.receiver,
                asset,
                false,
                bypass,
            )
            .await;
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L540-550)
```rust
    fn get_amount(&self, amount: Option<u64>, did_bypass_checkers: bool) -> u64 {
        match (
            amount,
            self.txn_config.get_maximum_amount(did_bypass_checkers),
        ) {
            (Some(amount), Some(maximum_amount)) => std::cmp::min(amount, maximum_amount),
            (Some(amount), None) => amount,
            (None, Some(maximum_amount)) => std::cmp::min(self.amount_to_fund, maximum_amount),
            (None, None) => self.amount_to_fund,
        }
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L936-1004)
```rust
    #[tokio::test(flavor = "multi_thread", worker_threads = 2)]
    async fn test_maximum_amount_with_bypass() -> Result<()> {
        make_auth_tokens_file(&["test_token"])?;

        // Assert that a localnet is alive.
        let aptos_node_api_client = aptos_sdk::rest_client::Client::new(
            reqwest::Url::from_str("http://127.0.0.1:8080").unwrap(),
        );
        aptos_node_api_client
            .get_index_bcs()
            .await
            .context("Localnet API couldn't be reached at port 8080, have you started one?")?;

        init();
        let (port, _handle) = {
            // Ensure this server and that for test_mint_funder_*
            // don't start up simultaneously, since they're using the same mint key.
            let _guard = MUTEX.get().unwrap().lock().await;
            let config_content =
                include_str!("../../../configs/testing_mint_funder_local_wait_for_txns.yaml");
            start_server(config_content).await?
        };

        // Make a request for more than maximum_amount. This should be accepted as is
        // because we're including an auth token that lets us bypass the checkers,
        // meaning we're instead bound by maximum_amount_with_bypass.
        let fund_request = get_fund_request(Some(1000));
        unwrap_reqwest_result(
            reqwest::Client::new()
                .post(get_fund_endpoint(port))
                .body(fund_request.to_json_string())
                .header(CONTENT_TYPE, "application/json")
                .header(AUTHORIZATION, "Bearer test_token")
                .send()
                .await,
        )
        .await?;

        // Confirm that the account was given the full 1000 OCTA as requested.
        let response = aptos_node_api_client
            .view_apt_account_balance(
                AccountAddress::from_str(&fund_request.address.unwrap()).unwrap(),
            )
            .await?;

        assert_eq!(response.into_inner(), 1000);

        // This time, don't include the auth token. We request more than maximum_amount,
        // but later we'll see that the faucet will only give us maximum_amount, not
        // the amount we requested.
        let fund_request = get_fund_request(Some(1000));
        reqwest::Client::new()
            .post(get_fund_endpoint(port))
            .body(fund_request.to_json_string())
            .header(CONTENT_TYPE, "application/json")
            .send()
            .await?;

        // Confirm that the account was only given 100 OCTA (maximum_amount), not 1000.
        let response = aptos_node_api_client
            .view_apt_account_balance(
                AccountAddress::from_str(&fund_request.address.unwrap()).unwrap(),
            )
            .await?;

        assert_eq!(response.into_inner(), 100);

        Ok(())
    }
```
