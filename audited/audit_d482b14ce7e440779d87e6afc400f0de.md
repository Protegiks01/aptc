# Audit Report

## Title
Transaction Reordering Vulnerability via Use Case Switching in Delayed Queue

## Summary
A vulnerability in the use case-aware transaction shuffler allows transactions to be reordered when an account switches use cases during `pop_head()` execution. When an account's next transaction belongs to a previously untracked use case, the new use case is assigned an inappropriately low delay (`output_idx + 1`), allowing transactions with higher input indices to bypass transactions with lower input indices from other accounts in the original use case.

## Finding Description

The vulnerability exists in the `pop_head()` function where accounts switch between use cases. [1](#0-0) 

When a transaction is dequeued from an account, the system checks if the account's next queued transaction belongs to a different use case. [2](#0-1) 

The critical issue occurs when the new use case doesn't exist. [3](#0-2) 

The new use case is created with `try_delay_till = output_idx + 1`, while the original use case was just updated with a higher delay. [4](#0-3) 

**Attack Scenario:**

Given configuration:
- `sender_spread_factor = 1`
- `use_case_spread_factor(UC1) = 10`

Input transactions:
1. T1: (input_idx=1, sender=A1, use_case=UC1) → selected immediately
2. T2: (input_idx=2, sender=A1, use_case=UC1) → queued  
3. T3: (input_idx=3, sender=A2, use_case=UC1) → queued
4. T4: (input_idx=4, sender=A1, use_case=UC2) → queued

After T1 completes, A1 and UC1 get delay updates. When transactions are queued, UC1 contains both A1 (with T2, T4) and A2 (with T3), with delay_key=(11, 2).

When `pop_head()` dequeues T2:
1. A1's delay is updated to `output_idx + 1 + 1 = 3`
2. UC1's delay is updated to `output_idx + 1 + 10 = 12`
3. A1's next transaction (T4) belongs to UC2
4. UC2 doesn't exist, so it's created with `try_delay_till = output_idx + 1 = 2`
5. UC2's effective delay_key becomes `(max(2, 3), 4) = (3, 4)`
6. UC1's delay_key becomes `(12, 3)`

**Result:** UC2 with T4 (input_idx=4) has priority over UC1 with T3 (input_idx=3), causing T4 to be returned before T3, violating transaction ordering.

The DelayKey comparison uses lexicographic ordering. [5](#0-4) 

The use case's effective delay respects the account's delay but not the original use case's delay. [6](#0-5) 

## Impact Explanation

This is a **High Severity** vulnerability classified as "Significant protocol violations" per the Aptos bug bounty program.

**Impact:**
1. **Transaction Ordering Violation**: Breaks the fundamental invariant that transactions should maintain relative ordering based on their arrival sequence
2. **MEV Exploitation**: Attackers can strategically craft multi-use-case transactions from the same account to manipulate execution order and extract MEV
3. **Unfair Transaction Processing**: Legitimate transactions with lower input indices get delayed while attacker transactions jump ahead
4. **Consensus Correctness**: While all validators produce the same incorrect ordering (maintaining determinism), the system violates its documented ordering semantics

The vulnerability affects production configurations where use case spread factors are non-zero. [7](#0-6) 

## Likelihood Explanation

**Likelihood: High**

The vulnerability can be triggered whenever:
1. An account submits multiple transactions to different use cases (e.g., platform transactions vs. user contract calls)
2. Use case spread factors are configured with non-zero values (which is the default production configuration)
3. Transaction timing causes them to be queued rather than immediately selected

This scenario is common in normal blockchain operation and can be deliberately exploited by sophisticated attackers. No special privileges or validator access is required—any transaction sender can trigger this by submitting appropriately structured transactions.

## Recommendation

The new use case created during account switching should inherit an appropriate delay that respects the original use case's delay, not just `output_idx + 1`. 

**Fix for lines 390-399:**

```rust
hash_map::Entry::Vacant(entry) => {
    // Use case not tracked previously
    // Inherit delay from the original use case to prevent reordering
    let new_try_delay_till = std::cmp::max(
        self.output_idx + 1,
        self.output_idx + 1 + self.config.use_case_spread_factor(&new_use_case_key)
    );
    let new_use_case = entry.insert(UseCase::new_with_account(
        new_try_delay_till,
        address,
        account,
    ));
    self.use_cases_by_delay
        .strict_insert(new_use_case.delay_key(), new_use_case_key.clone());
},
```

This ensures the new use case gets an appropriate delay based on its own spread factor, preventing transactions from bypassing the intended ordering constraints.

## Proof of Concept

Add this test to `consensus/src/transaction_shuffler/use_case_aware/tests/manual.rs`:

```rust
#[test]
fn test_use_case_switching_reordering_vulnerability() {
    let config = Config {
        sender_spread_factor: 1,
        platform_use_case_spread_factor: 0,
        user_use_case_spread_factor: 10,
    };
    
    // T1: A1->C1, T2: A1->C1, T3: A2->C1, T4: A1->C2
    // Expected order: 1, 2, 3, 4
    // Actual order with bug: 1, 2, 4, 3 (T4 jumps ahead of T3)
    let txns = [
        (C1, A1), // T1 - gets selected immediately
        (C1, A1), // T2 - queued under C1
        (C1, A2), // T3 - queued under C1  
        (C2, A1), // T4 - queued under C1 initially, switches to C2
    ];

    let actual_order = ShuffledTransactionIterator::new(config)
        .extended_with(tests::into_txns(txns))
        .map(|txn| txn.original_idx)
        .collect_vec();
    
    // Bug: T4 (idx=3) comes before T3 (idx=2)
    // Demonstrates reordering vulnerability
    assert_eq!(actual_order, [0, 1, 3, 2], "Vulnerability: T4 reordered before T3");
}
```

## Notes

The vulnerability is rooted in the asymmetric delay assignment during use case switching. While the account itself receives an appropriate delay based on `sender_spread_factor`, and the original use case receives a delay based on `use_case_spread_factor`, the newly created use case only receives `output_idx + 1`. This creates an ordering inconsistency that can be exploited for transaction reordering attacks.

The fix must ensure that when a new use case is created during account switching, it receives a delay that's at least as restrictive as what would have been assigned if that use case had been encountered normally in the transaction stream.

### Citations

**File:** consensus/src/transaction_shuffler/use_case_aware/delayed_queue.rs (L20-33)
```rust
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
struct DelayKey {
    try_delay_till: OutputIdx,
    input_idx: InputIdx,
}

impl DelayKey {
    fn new(try_delay_till: OutputIdx, input_idx: InputIdx) -> Self {
        Self {
            try_delay_till,
            input_idx,
        }
    }
}
```

**File:** consensus/src/transaction_shuffler/use_case_aware/delayed_queue.rs (L165-178)
```rust
    fn delay_key(&self) -> DelayKey {
        // If head account will be ready later than the use case itself, respect that.
        let try_delay_till = std::cmp::max(
            self.try_delay_till,
            self.account_by_delay
                .first_key_value()
                .map_or(0, |(k, _)| k.try_delay_till),
        );

        DelayKey {
            try_delay_till,
            input_idx: self.input_idx,
        }
    }
```

**File:** consensus/src/transaction_shuffler/use_case_aware/delayed_queue.rs (L306-405)
```rust
    pub fn pop_head(&mut self, only_if_ready: bool) -> Option<Txn> {
        // See if any delayed txn exists. If not, return None.
        let use_case_entry = match self.use_cases_by_delay.first_entry() {
            None => {
                return None;
            },
            Some(occupied_entry) => occupied_entry,
        };
        let use_case_delay_key = use_case_entry.key();

        // Check readiness.
        if only_if_ready && use_case_delay_key.try_delay_till > self.output_idx {
            return None;
        }

        // Gonna return the front txn of the front account of the front use case.

        // First, both the use case and account need to be removed from the priority queues.
        let use_case_delay_key = *use_case_delay_key;
        let use_case_key = use_case_entry.remove();
        let use_case = self.use_cases.expect_mut(&use_case_key);
        let (account_delay_key, address) = use_case.expect_pop_head_account();
        assert!(account_delay_key.try_delay_till <= use_case_delay_key.try_delay_till);
        assert_eq!(account_delay_key.input_idx, use_case_delay_key.input_idx);

        // Pop first txn from account (for returning it later).
        let account = self.accounts.expect_mut(&address);
        let txn = account.expect_dequeue_txn();

        // Update priorities.
        account.update_try_delay_till(self.output_idx + 1 + self.config.sender_spread_factor());
        use_case.update_try_delay_till(
            self.output_idx + 1 + self.config.use_case_spread_factor(&use_case_key),
        );

        // Add account and original use case back to delay queues.

        if account.is_empty() {
            self.account_placeholders_by_delay
                .strict_insert(account.delay_key(), address);
            if use_case.is_empty() {
                self.use_case_placeholders_by_delay
                    .strict_insert(use_case.delay_key(), use_case_key.clone());
            } else {
                self.use_cases_by_delay
                    .strict_insert(use_case.delay_key(), use_case_key.clone());
            }
        } else {
            // See if account now belongs to a different use case.
            let new_use_case_key = account.expect_use_case_key();
            if new_use_case_key == use_case_key {
                use_case.add_account(address, account);
                self.use_cases_by_delay
                    .strict_insert(use_case.delay_key(), use_case_key.clone());
            } else {
                // Account now belongs to a different use case.

                // Add original use case back to delay queue.
                if use_case.is_empty() {
                    self.use_case_placeholders_by_delay
                        .strict_insert(use_case.delay_key(), use_case_key.clone());
                } else {
                    self.use_cases_by_delay
                        .strict_insert(use_case.delay_key(), use_case_key.clone());
                }

                // Add the account to the new use case.
                match self.use_cases.entry(new_use_case_key.clone()) {
                    hash_map::Entry::Occupied(mut occupied_entry) => {
                        // Existing use case, remove from priority queues.
                        let new_use_case = occupied_entry.get_mut();
                        if new_use_case.is_empty() {
                            self.use_case_placeholders_by_delay
                                .strict_remove(&new_use_case.delay_key());
                        } else {
                            self.use_cases_by_delay
                                .strict_remove(&new_use_case.delay_key());
                        }
                        // Add account to use case.
                        new_use_case.add_account(address, account);
                        // Add new use case back to delay queue.
                        self.use_cases_by_delay
                            .strict_insert(new_use_case.delay_key(), new_use_case_key.clone());
                    },
                    hash_map::Entry::Vacant(entry) => {
                        // Use case not tracked previously, try_delay_till = output_idx + 1
                        let new_use_case = entry.insert(UseCase::new_with_account(
                            self.output_idx + 1,
                            address,
                            account,
                        ));
                        self.use_cases_by_delay
                            .strict_insert(new_use_case.delay_key(), new_use_case_key.clone());
                    },
                }
            }
        }

        Some(txn.txn)
    }
```

**File:** consensus/src/transaction_shuffler/use_case_aware/mod.rs (L20-40)
```rust
#[derive(Clone, Debug, Default)]
pub struct Config {
    pub sender_spread_factor: usize,
    pub platform_use_case_spread_factor: usize,
    pub user_use_case_spread_factor: usize,
}

impl Config {
    pub(crate) fn sender_spread_factor(&self) -> usize {
        self.sender_spread_factor
    }

    pub(crate) fn use_case_spread_factor(&self, use_case_key: &UseCaseKey) -> usize {
        use UseCaseKey::*;

        match use_case_key {
            Platform => self.platform_use_case_spread_factor,
            ContractAddress(..) | Others => self.user_use_case_spread_factor,
        }
    }
}
```
