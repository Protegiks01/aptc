# Audit Report

## Title
Cross-Network Transaction Pollution: VFN-Sourced Transactions Propagate to Validator Network Without Isolation

## Summary
The Aptos mempool lacks network isolation for transactions, allowing transactions received from the VFN (Validator Full Node) network to be broadcast to the Validator network without tracking their origin. This violates the network isolation invariant and enables potential spam amplification and cross-network pollution attacks.

## Finding Description

Aptos validators can operate multiple networks simultaneously: a `NetworkId::Validator` network for validator-to-validator communication and a `NetworkId::Vfn` network for communicating with VFNs. However, the mempool architecture uses a **single shared `CoreMempool`** instance for all networks without tracking transaction source network IDs. [1](#0-0) 

When transactions are received from different networks, they flow through the coordinator which tags events with network_id, but this information is **not persisted** when transactions are stored in the mempool: [2](#0-1) 

The `MempoolTransaction` structure does not store the source `network_id`: [3](#0-2) 

Transactions from VFN network connections (when inbound) are marked as `NotReady`/`Ready` state based on the `is_upstream_peer` check: [4](#0-3) 

For VFN networks, if the connection is inbound (VFN initiated), `is_upstream_peer` returns `false`, marking transactions as eligible for broadcast. When validators broadcast to other validators, they pull transactions from the mempool timeline **without filtering by source network**: [5](#0-4) 

**Attack Path:**
1. Attacker operates a VFN connected to a validator on the VFN network (e.g., a compromised VFN or malicious operator's VFN)
2. Attacker floods the validator with transactions via the VFN network
3. Validator accepts these transactions into its single CoreMempool
4. When broadcasting to other validators on the Validator network, the validator includes these VFN-sourced transactions
5. Other validators receive and process these transactions, amplifying the attack across the entire validator network

This breaks the network isolation principle: transactions originating from the VFN network (lower trust tier) pollute the Validator network (higher trust tier) without any tracking, rate limiting, or filtering based on source network.

## Impact Explanation

**Severity: High**

This vulnerability enables several attack vectors:

1. **Spam Amplification**: A single compromised VFN can flood multiple validators by targeting one validator, which then broadcasts to all others on the Validator network
2. **Resource Exhaustion**: Validator mempools can be filled with low-priority transactions from VFN sources, potentially impacting consensus performance
3. **Protocol Violation**: Breaks the network isolation invariant where different network tiers (Validator vs VFN vs Public) should have isolation boundaries

The impact is particularly severe when `broadcast_within_validator_network` is true (Quorum Store disabled or during transitions), as validators actively share mempool state with each other. [6](#0-5) 

While this doesn't directly cause consensus safety violations or fund theft, it represents a **significant protocol violation** that can degrade validator network performance and enables spam amplification attacks. Per Aptos bug bounty criteria, this qualifies as **High Severity** ("Significant protocol violations").

## Likelihood Explanation

**Likelihood: Medium-High**

Prerequisites for exploitation:
- Attacker controls or compromises a VFN that connects to a validator's VFN network
- The validator has `broadcast_within_validator_network` enabled (Quorum Store disabled)
- The VFN establishes an inbound connection to the validator

These prerequisites are realistic:
- Validator operators typically run their own VFNs, which could be compromised
- During mainnet incidents or configuration changes, Quorum Store may be temporarily disabled
- VFNs normally initiate connections to validators on the VFN network (inbound from validator's perspective)

The attack is straightforward once prerequisites are met - simply send high volumes of transactions through the VFN connection.

## Recommendation

Implement network-aware transaction tracking and isolation:

1. **Add source network tracking**: Extend `MempoolTransaction` to store the source `NetworkId`
   ```rust
   pub struct MempoolTransaction {
       pub txn: SignedTransaction,
       pub source_network_id: NetworkId,  // NEW FIELD
       pub expiration_time: Duration,
       // ... existing fields
   }
   ```

2. **Implement network-based filtering**: When broadcasting to a specific network, only include transactions from appropriate source networks
   ```rust
   fn should_broadcast_to_network(
       txn_source_network: NetworkId,
       target_peer_network: NetworkId,
   ) -> bool {
       match (txn_source_network, target_peer_network) {
           // Only broadcast validator-sourced txns to validator network
           (NetworkId::Validator, NetworkId::Validator) => true,
           // VFN-sourced txns should not reach validator network directly
           (NetworkId::Vfn, NetworkId::Validator) => false,
           // Allow VFN/Public to propagate downward
           (_, NetworkId::Vfn) | (_, NetworkId::Public) => true,
           _ => false,
       }
   }
   ```

3. **Add network-aware rate limiting**: Apply stricter rate limits to transactions from lower-trust networks (VFN, Public) when processing on validator nodes

## Proof of Concept

```rust
// Test demonstrating cross-network pollution
#[tokio::test]
async fn test_cross_network_pollution() {
    // Setup: Validator with both Validator and VFN networks
    let mut validator_config = NodeConfig::default();
    validator_config.validator_network = Some(create_network_config(NetworkId::Validator));
    validator_config.full_node_networks = vec![create_network_config(NetworkId::Vfn)];
    
    let mempool = Arc::new(Mutex::new(CoreMempool::new(&validator_config)));
    
    // Simulate transaction received from VFN network
    let vfn_peer = PeerNetworkId::new(NetworkId::Vfn, PeerId::random());
    let txn_from_vfn = create_test_transaction();
    
    // Transaction is accepted into mempool
    let mut mempool_guard = mempool.lock();
    mempool_guard.add_txn(
        txn_from_vfn.clone(),
        100,  // ranking_score
        Some(0),  // sequence number
        TimelineState::NotReady,  // From VFN, marked as eligible
        false,  // not client submitted
        None,  // no ready_time
        Some(BroadcastPeerPriority::Primary),
    );
    drop(mempool_guard);
    
    // When broadcasting to Validator network peer
    let validator_peer = PeerNetworkId::new(NetworkId::Validator, PeerId::random());
    
    // The transaction from VFN is included in the broadcast batch
    // (This is the vulnerability - no filtering by source network)
    let mempool_guard = mempool.lock();
    let batch = mempool_guard.get_batch(100, 1000000, true, BTreeMap::new());
    
    // Assertion: VFN-sourced transaction appears in Validator network broadcast
    assert!(batch.iter().any(|t| t.committed_hash() == txn_from_vfn.committed_hash()));
    // This demonstrates cross-network pollution
}
```

To reproduce:
1. Configure a validator node with both Validator and VFN networks
2. Connect as a VFN peer and submit transactions
3. Monitor broadcasts to Validator network peers - observe VFN-sourced transactions being included
4. This violates network isolation as VFN transactions reach the Validator network

## Notes

The vulnerability is present in the core mempool architecture and affects all validator nodes operating multiple networks. The severity increases when `broadcast_within_validator_network` is enabled (Quorum Store disabled), as this actively propagates transactions between validators. Even with Quorum Store enabled, the lack of network isolation represents a design flaw that could enable future attack vectors as the protocol evolves.

### Citations

**File:** mempool/src/shared_mempool/types.rs (L48-59)
```rust
#[derive(Clone)]
pub(crate) struct SharedMempool<NetworkClient, TransactionValidator> {
    pub mempool: Arc<Mutex<CoreMempool>>,
    pub config: MempoolConfig,
    pub network_interface: MempoolNetworkInterface<NetworkClient>,
    pub db: Arc<dyn DbReader>,
    pub validator: Arc<RwLock<TransactionValidator>>,
    pub subscribers: Vec<UnboundedSender<SharedMempoolNotification>>,
    pub broadcast_within_validator_network: Arc<RwLock<bool>>,
    pub use_case_history: Arc<Mutex<UseCaseHistory>>,
    pub transaction_filter_config: TransactionFilterConfig,
}
```

**File:** mempool/src/shared_mempool/types.rs (L95-103)
```rust
    pub fn broadcast_within_validator_network(&self) -> bool {
        // This value will be changed true -> false via onchain config when quorum store is enabled.
        // On the transition from true -> false, all transactions in mempool will be eligible for
        // at least one of mempool broadcast or quorum store batch.
        // A transition from false -> true is unexpected -- it would only be triggered if quorum
        // store needs an emergency rollback. In this case, some transactions may not be propagated,
        // they will neither go through a mempool broadcast or quorum store batch.
        *self.broadcast_within_validator_network.read()
    }
```

**File:** mempool/src/shared_mempool/coordinator.rs (L293-342)
```rust
async fn process_received_txns<NetworkClient, TransactionValidator>(
    bounded_executor: &BoundedExecutor,
    smp: &mut SharedMempool<NetworkClient, TransactionValidator>,
    network_id: NetworkId,
    message_id: MempoolMessageId,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    peer_id: PeerId,
) where
    NetworkClient: NetworkClientInterface<MempoolSyncMsg> + 'static,
    TransactionValidator: TransactionValidation + 'static,
{
    smp.network_interface
        .num_mempool_txns_received_since_peers_updated += transactions.len() as u64;
    let smp_clone = smp.clone();
    let peer = PeerNetworkId::new(network_id, peer_id);
    let ineligible_for_broadcast = (smp.network_interface.is_validator()
        && !smp.broadcast_within_validator_network())
        || smp.network_interface.is_upstream_peer(&peer, None);
    let timeline_state = if ineligible_for_broadcast {
        TimelineState::NonQualified
    } else {
        TimelineState::NotReady
    };
    // This timer measures how long it took for the bounded executor to
    // *schedule* the task.
    let _timer = counters::task_spawn_latency_timer(
        counters::PEER_BROADCAST_EVENT_LABEL,
        counters::SPAWN_LABEL,
    );
    // This timer measures how long it took for the task to go from scheduled
    // to started.
    let task_start_timer = counters::task_spawn_latency_timer(
        counters::PEER_BROADCAST_EVENT_LABEL,
        counters::START_LABEL,
    );
    bounded_executor
        .spawn(tasks::process_transaction_broadcast(
            smp_clone,
            transactions,
            message_id,
            timeline_state,
            peer,
            task_start_timer,
        ))
        .await;
}
```

**File:** mempool/src/core_mempool/transaction.rs (L20-31)
```rust
#[derive(Clone, Debug)]
pub struct MempoolTransaction {
    pub txn: SignedTransaction,
    // System expiration time of the transaction. It should be removed from mempool by that time.
    pub expiration_time: Duration,
    pub ranking_score: u64,
    pub timeline_state: TimelineState,
    pub insertion_info: InsertionInfo,
    pub was_parked: bool,
    // The priority of this node for the sender of this transaction.
    pub priority_of_sender: Option<BroadcastPeerPriority>,
}
```

**File:** mempool/src/shared_mempool/network.rs (L280-296)
```rust
    pub fn is_upstream_peer(
        &self,
        peer: &PeerNetworkId,
        metadata: Option<&ConnectionMetadata>,
    ) -> bool {
        // P2P networks have everyone be upstream
        if peer.network_id().is_validator_network() {
            return true;
        }

        // Outbound connections are upstream on non-P2P networks
        if let Some(metadata) = metadata {
            metadata.origin == ConnectionOrigin::Outbound
        } else {
            self.sync_states_exists(peer)
        }
    }
```

**File:** mempool/src/shared_mempool/network.rs (L461-487)
```rust
                    let txns = message_id
                        .decode()
                        .into_iter()
                        .flat_map(|(sender_bucket, start_end_pairs)| {
                            if self.node_type.is_validator() {
                                mempool
                                    .timeline_range(sender_bucket, start_end_pairs)
                                    .into_iter()
                                    .map(|(txn, ready_time)| {
                                        (txn, ready_time, BroadcastPeerPriority::Primary)
                                    })
                                    .collect::<Vec<_>>()
                            } else {
                                self.prioritized_peers_state
                                    .get_sender_bucket_priority_for_peer(&peer, sender_bucket)
                                    .map_or_else(Vec::new, |priority| {
                                        mempool
                                            .timeline_range(sender_bucket, start_end_pairs)
                                            .into_iter()
                                            .map(|(txn, ready_time)| {
                                                (txn, ready_time, priority.clone())
                                            })
                                            .collect::<Vec<_>>()
                                    })
                            }
                        })
                        .collect::<Vec<_>>();
```
