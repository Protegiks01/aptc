# Audit Report

## Title
Off-By-One Error in Gas Feature Version Check Enables Free Storage Operations When REFUNDABLE_BYTES Feature is Misaligned

## Summary
A version mismatch between the `DiskSpacePricing` selection logic and gas parameter availability can result in zero storage fees when `gas_feature_version = 13` and `REFUNDABLE_BYTES` feature flag is enabled. The pricing logic checks for `gas_feature_version >= 13` to enable V2 pricing, but the V2 storage fee parameters only exist for `gas_feature_version >= 14`, causing them to default to zero. [1](#0-0) 

## Finding Description

The vulnerability stems from an off-by-one error in the gas feature version compatibility check. The `DiskSpacePricing::new()` function determines which pricing model to use based on both the gas feature version and the `REFUNDABLE_BYTES` feature flag. [1](#0-0) 

However, the V2 pricing model relies on gas parameters `storage_fee_per_state_slot` and `storage_fee_per_state_byte` that are only defined for gas feature versions 14 and above: [2](#0-1) 

The gas parameter loading mechanism initializes all parameters to zero, then only populates those that exist for the current version: [3](#0-2) 

For gas feature version 13 (which corresponds to `RELEASE_V1_9` and is a valid version): [4](#0-3) 

The parameters `storage_fee_per_state_slot` and `storage_fee_per_state_byte` are not present in the gas schedule, so they remain at their zero default values. When V2 pricing is used with these zero parameters, all storage operations become free: [5](#0-4) 

**Attack Scenario:**

If governance proposals (malicious, buggy, or during specific upgrade paths) result in:
1. Gas schedule with `feature_version = 13`  
2. `REFUNDABLE_BYTES` feature flag enabled

Then all validators would deterministically use V2 pricing with zero fees, enabling:
- Free state slot creation (unlimited accounts, resources, tables)
- Free state byte allocation (unlimited on-chain data storage)
- State bloat attacks at zero cost
- Complete breakdown of storage economics

The storage gas parameters are fetched during transaction execution: [6](#0-5) 

## Impact Explanation

This vulnerability breaks the **Resource Limits** invariant (#9: "All operations must respect gas, storage, and computational limits") and causes severe economic damage, though not a consensus split since all validators calculate the same (incorrect) zero fees.

**Severity Assessment: HIGH**

While this does not cause consensus failure (validators agree on the broken calculation), it causes:
- **Economic Damage**: Complete loss of storage fee revenue
- **State Bloat**: Unbounded database growth from free storage
- **Operational Impact**: Validator node resource exhaustion from unlimited state growth
- **Protocol Violation**: Fundamental gas metering assumptions broken

This meets the **High Severity** criteria per the Aptos bug bounty program as a "significant protocol violation" that could cause "validator node slowdowns" and state inconsistencies.

## Likelihood Explanation

**Current Exploitability: LOW to MEDIUM**

The gas schedule validation prevents downgrading: [7](#0-6) 

Current mainnet (likely at version 45) cannot downgrade to version 13. However, exploitation is possible in these scenarios:

1. **Historical**: If this code path existed when mainnet transitioned through version 13
2. **Testnets/New Chains**: Networks that initialize or operate at version 13
3. **Governance Bugs**: Validation bypass or execution errors during proposal processing
4. **Coordinated Proposals**: Separate gas schedule and feature flag proposals timed to create the vulnerable state

The bug is a clear implementation error that violates the intended design where V2 pricing should only activate when the corresponding parameters exist.

## Recommendation

Fix the off-by-one error by changing the version check to match when V2 parameters actually exist:

```rust
// In aptos-move/aptos-vm-types/src/storage/space_pricing.rs
impl DiskSpacePricing {
    pub fn new(gas_feature_version: u64, features: &Features) -> Self {
        // Changed from >= 13 to >= 15 (since version 14 was skipped)
        // Or use >= 14 with a comment explaining version 14 is skipped
        if gas_feature_version >= 15 && features.is_refundable_bytes_enabled() {
            Self::V2
        } else {
            Self::V1
        }
    }
    // ... rest of implementation
}
```

Additionally, add validation in the gas schedule update logic to ensure feature flag compatibility:

```move
// In gas_schedule.move set_for_next_epoch()
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    // ... existing validation ...
    
    // Add check: if REFUNDABLE_BYTES is enabled, require version >= 15
    if (features::is_refundable_bytes_enabled() && new_gas_schedule.feature_version < 15) {
        abort error::invalid_argument(EINVALID_FEATURE_COMBINATION)
    };
    
    config_buffer::upsert(new_gas_schedule);
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_free_storage_at_version_13() {
    use aptos_types::on_chain_config::Features;
    use aptos_gas_schedule::AptosGasParameters;
    
    // Setup: gas_feature_version = 13 with REFUNDABLE_BYTES enabled
    let gas_feature_version = 13;
    let mut features = Features::default();
    // Enable REFUNDABLE_BYTES (feature flag 51)
    features.enable(aptos_types::on_chain_config::FeatureFlag::REFUNDABLE_BYTES);
    
    // Load gas parameters for version 13
    let gas_params = AptosGasParameters::from_on_chain_gas_schedule_for_version(13);
    
    // Create StorageGasParameters
    let storage_params = StorageGasParameters::new(
        gas_feature_version,
        &features,
        &gas_params,
        &dummy_config_storage
    );
    
    // Verify that DiskSpacePricing is V2
    assert!(matches!(storage_params.space_pricing, DiskSpacePricing::V2));
    
    // Verify that V2 parameters are ZERO (the vulnerability)
    assert_eq!(gas_params.vm.txn.storage_fee_per_state_slot, 0);
    assert_eq!(gas_params.vm.txn.storage_fee_per_state_byte, 0);
    
    // This means storage operations would be FREE
    // All charge_refund_write_op_v2 calculations result in 0 fees
}
```

**Notes:**
- This vulnerability exists due to the version check being `>= 13` instead of `>= 15`
- All validators would agree on the (incorrect) zero fees, so no consensus split occurs
- The economic impact is severe if this state is reached through governance
- Current mainnet protections reduce but don't eliminate the risk entirely

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L37-43)
```rust
    pub fn new(gas_feature_version: u64, features: &Features) -> Self {
        if gas_feature_version >= 13 && features.is_refundable_bytes_enabled() {
            Self::V2
        } else {
            Self::V1
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L169-186)
```rust
        let key_size = op.key.size() as u64;
        let num_bytes = key_size + op.op_size.write_len().unwrap_or(0);
        let target_bytes_deposit: u64 = num_bytes * u64::from(params.storage_fee_per_state_byte);

        match op.op_size {
            Creation { .. } => {
                // permanent storage fee
                let slot_deposit = u64::from(params.storage_fee_per_state_slot);

                op.metadata_mut.maybe_upgrade();
                op.metadata_mut.set_slot_deposit(slot_deposit);
                op.metadata_mut.set_bytes_deposit(target_bytes_deposit);

                ChargeAndRefund {
                    charge: (slot_deposit + target_bytes_deposit).into(),
                    refund: 0.into(),
                }
            },
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L184-199)
```rust
            storage_fee_per_state_slot: FeePerSlot,
            { 14.. => "storage_fee_per_state_slot" },
            // 0.8 million APT for 2 billion state slots
            40_000,
        ],
        [
            legacy_storage_fee_per_excess_state_byte: FeePerByte,
            { 7..=13 => "storage_fee_per_excess_state_byte", 14.. => "legacy_storage_fee_per_excess_state_byte" },
            50,
        ],
        [
            storage_fee_per_state_byte: FeePerByte,
            { 14.. => "storage_fee_per_state_byte" },
            // 0.8 million APT for 2 TB state bytes
            40,
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L34-45)
```rust
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L78-82)
```rust
pub mod gas_feature_versions {
    pub const RELEASE_V1_8: u64 = 11;
    pub const RELEASE_V1_9_SKIPPED: u64 = 12;
    pub const RELEASE_V1_9: u64 = 13;
    pub const RELEASE_V1_10: u64 = 15;
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L50-64)
```rust
pub(crate) fn get_gas_parameters(
    sha3_256: &mut Sha3_256,
    features: &Features,
    state_view: &impl StateView,
) -> (
    Result<AptosGasParameters, String>,
    Result<StorageGasParameters, String>,
    u64,
) {
    let (mut gas_params, gas_feature_version) = get_gas_config_from_storage(sha3_256, state_view);

    let storage_gas_params = match &mut gas_params {
        Ok(gas_params) => {
            let storage_gas_params =
                StorageGasParameters::new(gas_feature_version, features, gas_params, state_view);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L95-101)
```text
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
```
