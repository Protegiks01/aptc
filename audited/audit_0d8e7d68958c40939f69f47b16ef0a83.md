# Audit Report

## Title
Local Testnet Startup Failure When txn_stream_port Set to Zero Results in Invalid URL Construction

## Summary
The local testnet node allows `txn_stream_port` to be set to 0 (requesting OS-assigned random port), but fails to retrieve the actual bound port after binding. This causes URL construction to return invalid `http://127.0.0.1:0` addresses, leading to health check timeouts and complete localnet initialization failure.

## Finding Description

In the local testnet node implementation, the `txn_stream_port` parameter can be set to 0, which is a valid socket binding value that requests the operating system to assign a random available port. However, the implementation incorrectly handles this case: [1](#0-0) 

The port is stored in the configuration without validation: [2](#0-1) 

When constructing the data service URL for health checks and processor connections, the code directly reads the port from the configuration: [3](#0-2) 

The URL construction function uses the configured port value directly: [4](#0-3) 

This results in a URL like `http://127.0.0.1:0`. When the health checker attempts to validate this service, it tries to connect to port 0: [5](#0-4) 

The health checker will timeout after 120 seconds: [6](#0-5) 

Meanwhile, the actual node binds to an OS-assigned random port (e.g., port 52341), but this actual port is never communicated back to the NodeManager because `start_test_environment_node` calls `start()` which doesn't use port reporting: [7](#0-6) 

**Comparison with Correct Implementation:**

The workspace server implementation correctly handles port 0 by using the port reporting mechanism: [8](#0-7) 

The indexer gRPC bootstrap function properly reports the actual bound port: [9](#0-8) 

## Impact Explanation

This is a **Low to Medium** severity issue with the following impacts:

1. **Complete Local Testnet Startup Failure**: Developers who explicitly set `--txn-stream-port 0` to avoid port conflicts will experience complete localnet initialization failure after a 120-second timeout.

2. **Processor Connection Failure**: Even if the node starts, processors receive the invalid URL and cannot connect to the transaction stream: [10](#0-9) 

3. **Developer Experience Degradation**: This is a reasonable configuration choice for developers working in environments with port conflicts, but it completely breaks functionality.

**Severity Assessment**: While this only affects local development environments (not production validators or mainnet), it represents a complete availability failure for affected developers. The issue falls under "Non-critical implementation bugs" but with significant developer impact.

## Likelihood Explanation

**Likelihood: Low to Medium**

- **Trigger Condition**: Requires explicit configuration of `--txn-stream-port 0` via CLI
- **User Intent**: Some developers may intentionally use port 0 to avoid port conflicts in containerized or multi-instance development environments
- **Detection**: Immediate and obvious - localnet fails to start with health check timeout errors
- **Workaround**: Use a specific non-zero port number

## Recommendation

Implement port reporting for the local testnet node similar to the workspace server implementation:

1. **Option A**: Use `start_and_report_ports` with oneshot channels to retrieve actual bound ports, then construct URLs with actual ports after binding.

2. **Option B**: Add validation to reject port 0 with a clear error message if port reporting is not implemented.

3. **Option C (Recommended)**: Implement proper port reporting in `NodeManager`:

```rust
// In NodeManager::new_with_config, store oneshot receivers
// In NodeManager::run_service, use start_and_report_ports and await actual ports
// In NodeManager::get_data_service_url, return URL with actual reported port
```

The fix should mirror the pattern used in: [11](#0-10) 

## Proof of Concept

**Steps to Reproduce:**

1. Start local testnet with port 0:
```bash
aptos node run-local-testnet --txn-stream-port 0 --with-indexer-api
```

2. Observe the failure:
```
    - Health check for "Transaction stream" at http://127.0.0.1:0 times out after 120 seconds
    - Error: "Transaction stream at http://127.0.0.1:0 did not start up"
    - Localnet initialization fails
```

3. Verify actual node is listening on random port (check logs or `netstat`), but health checks target port 0.

**Expected vs Actual:**
- **Expected**: Node binds to OS-assigned port (e.g., 52341), health checks connect to that port, localnet starts successfully
- **Actual**: Node binds to random port, but health checks attempt to connect to port 0, causing complete startup failure

## Notes

This vulnerability is confirmed through code analysis and logical flow tracing. The workspace server implementation demonstrates the correct pattern for handling port 0. The local testnet implementation lacks the port reporting mechanism, resulting in URL construction with invalid port 0 addresses.

### Citations

**File:** crates/aptos/src/node/local_testnet/node.rs (L60-62)
```rust
    /// The port at which to expose the grpc transaction stream.
    #[clap(long, default_value_t = DEFAULT_GRPC_STREAM_PORT)]
    txn_stream_port: u16,
```

**File:** crates/aptos/src/node/local_testnet/node.rs (L154-154)
```rust
        node_config.indexer_grpc.address.set_port(txn_stream_port);
```

**File:** crates/aptos/src/node/local_testnet/node.rs (L187-194)
```rust
    pub fn get_data_service_url(&self) -> Url {
        let mut addr = self.config.indexer_grpc.address;
        // If bound to 0.0.0.0, clients should connect to 127.0.0.1 instead.
        if addr.ip().is_unspecified() {
            addr.set_ip(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));
        }
        socket_addr_to_url(&addr, "http").unwrap()
    }
```

**File:** crates/aptos/src/node/local_testnet/utils.rs (L8-15)
```rust
pub fn socket_addr_to_url(socket_addr: &SocketAddr, scheme: &str) -> Result<Url> {
    let host = match socket_addr {
        SocketAddr::V4(v4) => format!("{}", v4.ip()),
        SocketAddr::V6(v6) => format!("[{}]", v6.ip()),
    };
    let full_url = format!("{}://{}:{}", scheme, host, socket_addr.port());
    Ok(Url::parse(&full_url)?)
}
```

**File:** crates/aptos/src/node/local_testnet/health_checker.rs (L18-19)
```rust
const MAX_WAIT_S: u64 = 120;
const WAIT_INTERVAL_MS: u64 = 200;
```

**File:** crates/aptos/src/node/local_testnet/health_checker.rs (L59-87)
```rust
            HealthChecker::DataServiceGrpc(url) => {
                let backoff = backoff::ExponentialBackoff {
                    max_elapsed_time: Some(Duration::from_secs(5)),
                    ..Default::default()
                };
                backoff::future::retry(backoff, || async {
                    let transaction_stream_config = TransactionStreamConfig {
                        indexer_grpc_data_service_address: url.clone(),
                        auth_token: "notused".to_string(),
                        starting_version: Some(0),
                        request_ending_version: None,
                        request_name_header: "notused".to_string(),
                        additional_headers: Default::default(),
                        indexer_grpc_http2_ping_interval_secs: Default::default(),
                        indexer_grpc_http2_ping_timeout_secs: 60,
                        indexer_grpc_response_item_timeout_secs: 60,
                        indexer_grpc_reconnection_timeout_secs: 60,
                        indexer_grpc_reconnection_max_retries: Default::default(),
                        transaction_filter: None,
                    };
                    get_chain_id(transaction_stream_config)
                        .await
                        .context("Failed to get chain id")?;
                    Ok(())
                })
                .await
                .context("Failed to get a response from gRPC")?;
                Ok(())
            },
```

**File:** aptos-node/src/lib.rs (L217-223)
```rust
pub fn start(
    config: NodeConfig,
    log_file: Option<PathBuf>,
    create_global_rayon_pool: bool,
) -> anyhow::Result<()> {
    start_and_report_ports(config, log_file, create_global_rayon_pool, None, None)
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L123-126)
```rust
        let listener = TcpListener::bind(address).await.unwrap();
        if let Some(port_tx) = port_tx {
            port_tx.send(listener.local_addr().unwrap().port()).unwrap();
        }
```

**File:** crates/aptos/src/node/local_testnet/processors.rs (L74-75)
```rust
            transaction_stream_config: TransactionStreamConfig {
                indexer_grpc_data_service_address: data_service_url,
```
