# Audit Report

## Title
Unsafe HTTP Redirect Following in Node-Checker REST Client Enables SSRF and Credential Leakage

## Summary
The node-checker's REST client follows HTTP redirects without validation, allowing malicious or compromised nodes to redirect requests to internal network addresses (SSRF) or attacker-controlled domains, potentially exposing cloud metadata services, internal APIs, and leaking authentication credentials.

## Finding Description
The `get_validator_infos()` function in the node-checker creates an `AptosClient` that uses reqwest with default redirect handling. [1](#0-0) 

The `AptosClient` is constructed using `ClientBuilder` which builds a reqwest HTTP client without any redirect policy configuration: [2](#0-1) 

By default, reqwest follows up to 10 redirects with no validation of redirect targets. When the node-checker queries a malicious or compromised node for validator information, the node can return HTTP 3xx redirects to:

1. **Internal network addresses** (SSRF): `http://localhost:8080/admin`, `http://192.168.1.1/router`, `http://169.254.169.254/latest/meta-data/` (AWS metadata service)
2. **Attacker-controlled domains**: To capture request headers (including any API keys or authentication tokens)
3. **Redirect chains**: Up to 10 redirects causing delays

The underlying reqwest client (version 0.11.11) is configured without redirect controls: [3](#0-2) 

**Attack Path:**
1. Operator runs: `node-checker --node-address http://compromised-node.com`
2. Compromised node responds to `/v1/accounts/0x1/resource/0x1::stake::ValidatorSet` with HTTP 302 redirect to `http://169.254.169.254/latest/meta-data/iam/security-credentials/`
3. Client follows redirect and makes request to AWS metadata service
4. Attacker captures cloud credentials or internal API responses
5. If API keys exist in headers, they are forwarded to redirect targets

## Impact Explanation
**Assessment: Low-to-Medium Severity**

While this is a legitimate SSRF vulnerability, it affects the node-checker diagnostic tool rather than core blockchain operations. According to Aptos bug bounty criteria:

- **NOT Critical**: No consensus violation, no funds at risk, no blockchain state corruption
- **NOT High**: No validator node degradation (node-checker is not a validator component)
- **Borderline Medium**: "Minor information leaks" - potential exposure of internal services, cloud credentials, or network topology information

However, this does NOT break any of the 10 critical blockchain invariants (deterministic execution, consensus safety, Move VM safety, state consistency, governance integrity, staking security, transaction validation, access control, resource limits, cryptographic correctness).

The impact is limited to the security posture of systems running the node-checker tool, not the Aptos blockchain itself.

## Likelihood Explanation
**Medium Likelihood** - Requires operator to target a malicious/compromised node or be misled into using a malicious node address. Exploitation is straightforward once attacker controls the target node's HTTP responses. However, this scenario is realistic in adversarial network environments or during targeted attacks against infrastructure operators.

## Recommendation
Configure explicit redirect policy in `ClientBuilder::build()`:

```rust
pub fn build(self) -> Client {
    let version_path_base = get_version_path_with_base(self.base_url.clone());
    
    Client {
        inner: self
            .reqwest_builder
            .default_headers(self.headers)
            .timeout(self.timeout)
            .cookie_store(true)
            // Add redirect policy - disable redirects or validate targets
            .redirect(reqwest::redirect::Policy::none()) // Safest option
            // Or use limited redirects with validation:
            // .redirect(reqwest::redirect::Policy::custom(|attempt| {
            //     // Validate redirect target is not localhost/private IP
            //     // Validate redirect target domain is in allowlist
            // }))
            .build()
            .unwrap(),
        base_url: self.base_url,
        version_path_base,
    }
}
```

Additionally, implement redirect target validation to prevent SSRF to private IP ranges (127.0.0.0/8, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) and cloud metadata endpoints.

## Proof of Concept
```rust
// Test demonstrating unsafe redirect following
#[tokio::test]
async fn test_unsafe_redirect_ssrf() {
    use wiremock::{Mock, MockServer, ResponseTemplate};
    use wiremock::matchers::{method, path};
    
    // Setup malicious mock server that redirects to localhost
    let mock_server = MockServer::start().await;
    Mock::given(method("GET"))
        .and(path("/v1/accounts/0x1/resource/0x1::stake::ValidatorSet"))
        .respond_with(
            ResponseTemplate::new(302)
                .insert_header("Location", "http://localhost:8080/admin")
        )
        .mount(&mock_server)
        .await;
    
    // Node-checker attempts to fetch validator info
    let client = aptos_rest_client::Client::new(
        mock_server.uri().parse().unwrap()
    );
    
    // Client will follow redirect to localhost (SSRF)
    let result = client.get_account_resource_bcs::<ValidatorSet>(
        CORE_CODE_ADDRESS,
        "0x1::stake::ValidatorSet"
    ).await;
    
    // The request was made to localhost, demonstrating SSRF
    // In production, this could access AWS metadata or internal services
    assert!(result.is_err()); // Would succeed if localhost:8080 was running
}
```

## Notes
This vulnerability exists but affects only the node-checker diagnostic tool, not core blockchain consensus, state management, or validator operations. While it represents a security risk for infrastructure operators running the node-checker, it does not directly compromise the Aptos blockchain's security guarantees or meet the Medium/High/Critical severity thresholds defined in the bug bounty program, as it doesn't affect funds, consensus safety, or blockchain availability.

### Citations

**File:** ecosystem/node-checker/fn-check-client/src/get_vfns.rs (L37-49)
```rust
    async fn get_validator_infos(&self) -> Result<Vec<ValidatorInfo>> {
        let client = AptosClient::new(self.node_address.clone());
        let response = client
            .get_account_resource_bcs::<ValidatorSet>(CORE_CODE_ADDRESS, "0x1::stake::ValidatorSet")
            .await?;
        let active_validators = response.into_inner().active_validators;
        info!(
            "Pulled {} active validators. First: {}. Last: {}",
            active_validators.len(),
            active_validators.first().unwrap().account_address(),
            active_validators.last().unwrap().account_address()
        );
        Ok(active_validators)
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L95-109)
```rust
    pub fn build(self) -> Client {
        let version_path_base = get_version_path_with_base(self.base_url.clone());

        Client {
            inner: self
                .reqwest_builder
                .default_headers(self.headers)
                .timeout(self.timeout)
                .cookie_store(true)
                .build()
                .unwrap(),
            base_url: self.base_url,
            version_path_base,
        }
    }
```

**File:** Cargo.toml (L761-767)
```text
reqwest = { version = "0.11.11", features = [
    "blocking",
    "cookies",
    "json",
    "multipart",
    "stream",
] }
```
