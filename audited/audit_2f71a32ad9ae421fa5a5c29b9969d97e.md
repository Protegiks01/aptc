# Audit Report

## Title
Governance Proposal Validation Bypass via Unvalidated Framework Path Injection

## Summary
The `aptos-release-builder` tool uses `aptos_framework_path()` without validation when simulating and submitting governance proposals, allowing attackers to inject a malicious Aptos Framework path via the `--aptos-core-path` CLI argument. This enables simulation of proposals against malicious framework code, bypassing the intended security validation process for governance proposals.

## Finding Description

The governance proposal workflow in `aptos-release-builder` relies on simulation to validate proposals before submission. However, the framework path used during compilation and simulation can be arbitrarily overridden without any security validation.

**Attack Flow:**

1. The `--aptos-core-path` CLI argument is accepted without validation [1](#0-0) 

2. This path is directly set as the core path without checks [2](#0-1) 

3. The framework path is derived by simply appending to this unvalidated path [3](#0-2) 

4. During simulation, scripts are compiled against this malicious framework path [4](#0-3) 

5. The malicious framework is added as a local dependency during compilation [5](#0-4) 

6. During proposal submission, the same malicious framework is used for compilation [6](#0-5) 

**Vulnerability Mechanism:**

An attacker can create a malicious framework at `/malicious/aptos-move/framework/aptos-framework/` that mimics the real Aptos Framework but with altered semantics. By convincing a proposal author to use `--aptos-core-path /malicious`, the attacker causes:

- **Simulation Deception**: The simulation executes against malicious framework modules, showing fake results that hide the true behavior of proposals
- **Bytecode Poisoning**: Scripts compile against malicious framework dependencies, producing bytecode with unexpected semantics
- **Trust Violation**: Proposal authors trust simulation results to validate safety, but the validation is performed against compromised code

This breaks the **Governance Integrity** invariant that voting and proposal validation must be based on accurate representation of proposal behavior.

## Impact Explanation

This vulnerability represents a **Medium Severity** issue under the Aptos Bug Bounty program category of "State inconsistencies requiring intervention."

The attack compromises the integrity of the governance proposal validation process, which could lead to:

1. **Deployment of Flawed Proposals**: Proposals that appear safe during simulation but have different behavior when compiled with the real framework
2. **Governance Process Disruption**: Failed proposal executions due to bytecode/framework mismatches, requiring manual intervention
3. **Resource Waste**: Validator time and gas spent on proposals that were incorrectly validated
4. **Trust Erosion**: Undermining confidence in the governance proposal development and validation workflow

While this does not directly enable theft of funds or consensus violations, it compromises a critical security boundary in the governance process - the simulation-based validation that proposal authors rely on before deployment.

## Likelihood Explanation

**Likelihood: Medium**

The attack is feasible through several vectors:

1. **Social Engineering**: Attacker provides malicious documentation or scripts to proposal authors suggesting the use of a custom `--aptos-core-path`
2. **Compromised CI/CD**: In automated environments, the path could be injected via environment variables or configuration files
3. **Supply Chain**: Malicious dependencies or build scripts could set the path
4. **Copy-Paste Attacks**: Malicious commands shared in forums or documentation

The attack complexity is low - it only requires:
- Creating a malicious framework directory structure
- Convincing the victim to add a single CLI flag
- No special permissions or access required

However, the target is limited to trusted proposal authors who use this development tool, reducing the overall likelihood compared to attacks on production nodes.

## Recommendation

Implement strict validation of the framework path with the following controls:

**1. Path Validation:** [2](#0-1) 

Add validation to ensure the path points to a legitimate Aptos framework:

```rust
pub fn initialize_aptos_core_path(overriden_path: Option<PathBuf>) -> Result<()> {
    let path = if let Some(path) = overriden_path {
        validate_aptos_core_path(&path)?;
        path
    } else {
        aptos_core_path_at_compile_time()
    };
    
    APTOS_CORE_PATH.set(path)
        .map_err(|_| anyhow!("APTOS_CORE_PATH already initialized"))
}

fn validate_aptos_core_path(path: &Path) -> Result<()> {
    // Verify path is canonical (no .. or symlinks)
    let canonical = path.canonicalize()
        .context("Failed to canonicalize aptos-core path")?;
    
    // Check for path traversal attempts
    if canonical.components().any(|c| matches!(c, Component::ParentDir)) {
        bail!("Path traversal detected in aptos-core-path");
    }
    
    // Verify framework directory exists with expected structure
    let framework_path = canonical.join("aptos-move/framework/aptos-framework");
    if !framework_path.exists() {
        bail!("Invalid aptos-core path: framework directory not found");
    }
    
    // Verify critical framework files exist
    let move_toml = framework_path.join("Move.toml");
    if !move_toml.exists() {
        bail!("Invalid aptos-core path: framework Move.toml not found");
    }
    
    // Optional: Verify framework package name and address match expected values
    verify_framework_identity(&move_toml)?;
    
    Ok(())
}
```

**2. Warning Messages:**

Add prominent warnings when custom paths are used:

```rust
if overriden_path.is_some() {
    eprintln!("⚠️  WARNING: Using custom aptos-core-path. Ensure this points to a trusted Aptos repository.");
    eprintln!("⚠️  Malicious framework code can compromise governance proposal validation.");
}
```

**3. Restrict in Production:**

Consider disabling custom paths in release builds or requiring an explicit `--allow-custom-framework` flag to acknowledge the risks.

## Proof of Concept

**Setup:**

```bash
# 1. Create malicious framework structure
mkdir -p /tmp/malicious-aptos/aptos-move/framework/aptos-framework/sources
cd /tmp/malicious-aptos/aptos-move/framework/aptos-framework

# 2. Create malicious Move.toml
cat > Move.toml << 'EOF'
[package]
name = "AptosFramework"
version = "1.0.0"

[addresses]
std = "0x1"
aptos_framework = "0x1"

[dependencies]
AptosStdlib = { local = "../aptos-stdlib" }
EOF

# 3. Create malicious module that hides proposal effects
cat > sources/coin.move << 'EOF'
module aptos_framework::coin {
    // Malicious implementation that logs operations but doesn't execute them
    public fun transfer<CoinType>(
        from: &signer,
        to: address,
        amount: u64,
    ) {
        // Silently drop the transfer - simulation shows success but nothing happens
        // Real framework would perform the transfer
    }
}
EOF

# 4. Run simulation with malicious framework
cd /path/to/aptos-core
cargo run --bin aptos-release-builder -- \
    --aptos-core-path /tmp/malicious-aptos \
    simulate \
    --network testnet \
    --path ./my-proposal

# Result: Simulation executes against malicious framework
# Proposal appears to work correctly, but uses fake transfer() implementation
# Developer trusts simulation and deploys proposal
# Actual on-chain execution fails or behaves unexpectedly
```

**Verification:**

The PoC demonstrates that:
1. A malicious framework path is accepted without validation
2. Scripts compile against the malicious framework
3. Simulation executes using malicious framework modules
4. No warnings or errors are shown to the user

This proves the vulnerability allows bypassing the intended security validation of governance proposals.

---

**Notes:**

This vulnerability affects the trust model of the governance proposal development workflow. While the on-chain protocol itself may reject maliciously-compiled bytecode due to type mismatches, the compromised validation process could lead to:
- Wasted effort deploying proposals that will fail
- Missed detection of proposal flaws during simulation
- False confidence in proposal safety
- Potential for sophisticated attacks where malicious bytecode still links correctly but has unintended effects

The fix should include both technical validation and user warnings to prevent accidental or malicious path injection.

### Citations

**File:** aptos-move/aptos-release-builder/src/main.rs (L30-31)
```rust
    aptos_core_path: Option<PathBuf>,
}
```

**File:** aptos-move/aptos-release-builder/src/lib.rs (L37-45)
```rust
pub fn initialize_aptos_core_path(overriden_path: Option<PathBuf>) {
    if let Some(path) = overriden_path {
        APTOS_CORE_PATH.set(path).unwrap();
    } else {
        APTOS_CORE_PATH
            .set(aptos_core_path_at_compile_time())
            .unwrap();
    };
}
```

**File:** aptos-move/aptos-release-builder/src/lib.rs (L53-57)
```rust
pub(crate) fn aptos_framework_path() -> PathBuf {
    let mut path = aptos_core_path();
    path.push("aptos-move/framework/aptos-framework");
    path
}
```

**File:** aptos-move/aptos-release-builder/src/simulate.rs (L376-384)
```rust
        let framework_package_args = FrameworkPackageArgs::try_parse_from([
            "dummy_executable_name",
            "--framework-local-dir",
            &aptos_framework_path().to_string_lossy(),
            "--skip-fetch-latest-git-deps",
        ])
        .context(
            "failed to parse framework package args for compiling scripts, this should not happen",
        )?;
```

**File:** crates/aptos/src/move_tool/mod.rs (L250-258)
```rust
        if let Some(ref path) = self.framework_local_dir {
            dependencies.insert(APTOS_FRAMEWORK.to_string(), Dependency {
                local: Some(path.display().to_string()),
                git: None,
                rev: None,
                subdir: None,
                aptos: None,
                address: None,
            });
```

**File:** aptos-move/aptos-release-builder/src/validate.rs (L230-240)
```rust
        let rev_string = self.framework_git_rev.clone();
        let framework_path = aptos_framework_path();
        let proposal_summary = if let Some(rev) = &rev_string {
            args.push("--framework-git-rev");
            args.push(rev.as_str());
            SubmitProposal::try_parse_from(args)?.execute().await?
        } else {
            args.push("--framework-local-dir");
            args.push(framework_path.as_os_str().to_str().unwrap());
            SubmitProposal::try_parse_from(args)?.execute().await?
        };
```
