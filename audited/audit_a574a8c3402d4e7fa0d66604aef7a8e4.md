# Audit Report

## Title
Indexer Crash Due to Unchecked Error in AccountTransaction Deserialization

## Summary
The coin processor's `process_transactions()` function uses `.unwrap()` on `AccountTransaction::from_transaction()`, which can panic and crash the indexer when processing transactions containing resources that fail deserialization.

## Finding Description

The vulnerability exists in the coin processor at line 314: [1](#0-0) 

The `AccountTransaction::from_transaction()` function returns `anyhow::Result<HashMap<AccountTransactionPK, Self>>`: [2](#0-1) 

This function can fail when processing WriteSetChanges that contain ObjectCore or other v2 token resources. The error path is:

1. `AccountTransaction::from_transaction()` iterates through WriteSetChanges
2. For WriteResource changes, it calls `from_write_resource()` with error propagation: [3](#0-2) 

3. This calls `ObjectWithMetadata::from_write_resource()` which attempts deserialization: [4](#0-3) 

4. Which calls `V2TokenResource::from_resource()` that performs `serde_json::from_value()`: [5](#0-4) 

If deserialization fails (e.g., malformed `guid_creation_num` field, missing required fields, type mismatches), the error propagates back through the `?` operators, and the `.unwrap()` panics, crashing the entire indexer process. [6](#0-5) 

## Impact Explanation

**Severity: High** - Per Aptos bug bounty criteria "API crashes"

The indexer crash results in:
- Complete service disruption for coin balance queries
- Stopped transaction indexing, leading to stale data
- Requires manual intervention to restart the indexer
- Affects all downstream applications relying on indexed data

While this does not affect blockchain consensus or validator operations, it disrupts critical infrastructure services that applications depend on for querying chain state.

## Likelihood Explanation

**Likelihood: Medium**

This can occur through:
1. **API serialization bugs**: Errors in REST API or gRPC streaming producing malformed JSON
2. **Data corruption**: Database corruption or network transmission errors
3. **Version mismatches**: Framework upgrades changing resource schemas before indexer updates
4. **Custom deserializer failures**: The `deserialize_from_string` function failing on invalid number formats [7](#0-6) 

While transactions are validated before execution, the indexer processes the serialized output, which could contain unexpected formats in edge cases.

## Recommendation

Replace the `.unwrap()` with proper error handling:

```rust
// At line 314 in coin_processor.rs, change from:
account_transactions.extend(AccountTransaction::from_transaction(txn).unwrap());

// To:
match AccountTransaction::from_transaction(txn) {
    Ok(txns) => account_transactions.extend(txns),
    Err(e) => {
        aptos_logger::error!(
            "Failed to extract account transactions for version {}: {}",
            txn.version().unwrap_or(0),
            e
        );
        // Continue processing other transactions
    }
}
```

This allows the indexer to log errors and continue processing instead of crashing.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_api_types::*;
    use serde_json::json;

    #[test]
    fn test_malformed_object_core_causes_error() {
        // Create a WriteResource with ObjectCore type but malformed data
        let write_resource = WriteResource {
            address: "0x1".parse().unwrap(),
            state_key_hash: "test_hash".to_string(),
            data: MoveResource {
                typ: MoveStructTag {
                    address: "0x1".parse().unwrap(),
                    module: "object".into(),
                    name: "ObjectCore".into(),
                    generic_type_params: vec![],
                },
                data: json!({
                    "allow_ungated_transfer": true,
                    // Missing owner field
                    "guid_creation_num": "not_a_number" // Invalid number format
                }),
            },
        };

        // This should return an error, not panic
        let result = AccountTransaction::from_write_resource(&write_resource, 1);
        assert!(result.is_err());
    }
}
```

## Notes

This vulnerability specifically affects the indexer infrastructure, not core blockchain consensus or execution. The indexer is a critical service component but operates independently from validator nodes. The fix should include comprehensive error handling across all processor types to prevent similar crashes from other deserialization failures.

### Citations

**File:** crates/indexer/src/processors/coin_processor.rs (L314-314)
```rust
            account_transactions.extend(AccountTransaction::from_transaction(txn).unwrap());
```

**File:** crates/indexer/src/models/coin_models/account_transactions.rs (L38-40)
```rust
    pub fn from_transaction(
        transaction: &Transaction,
    ) -> anyhow::Result<HashMap<AccountTransactionPK, Self>> {
```

**File:** crates/indexer/src/models/coin_models/account_transactions.rs (L79-81)
```rust
                WriteSetChange::WriteResource(res) => {
                    account_transactions.extend(Self::from_write_resource(res, txn_version)?);
                },
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L68-74)
```rust
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ObjectCore {
    pub allow_ungated_transfer: bool,
    #[serde(deserialize_with = "deserialize_from_string")]
    pub guid_creation_num: BigDecimal,
    owner: String,
}
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L102-106)
```rust
        if let V2TokenResource::ObjectCore(inner) = V2TokenResource::from_resource(
            &type_str,
            &serde_json::to_value(&write_resource.data.data).unwrap(),
            txn_version,
        )? {
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L471-498)
```rust
        match data_type {
            "0x1::object::ObjectCore" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::ObjectCore(inner)))
            },
            "0x4::collection::Collection" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::Collection(inner)))
            },
            "0x4::collection::FixedSupply" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::FixedSupply(inner)))
            },
            "0x4::collection::UnlimitedSupply" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::UnlimitedSupply(inner)))
            },
            "0x4::aptos_token::AptosCollection" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::AptosCollection(inner)))
            },
            "0x4::token::Token" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::TokenV2(inner)))
            },
            "0x4::property_map::PropertyMap" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::PropertyMap(inner)))
            },
            _ => Ok(None),
        }
        .context(format!(
            "version {} failed! failed to parse type {}, data {:?}",
            txn_version, data_type, data
        ))?
```

**File:** api/types/src/lib.rs (L63-73)
```rust
pub fn deserialize_from_string<'de, D, T>(deserializer: D) -> Result<T, D::Error>
where
    D: Deserializer<'de>,
    T: FromStr,
    <T as FromStr>::Err: std::fmt::Display,
{
    use serde::de::Error;

    let s = <String>::deserialize(deserializer)?;
    s.parse::<T>().map_err(D::Error::custom)
}
```
