# Audit Report

## Title
Feature Gate Bypass: Unstable Language Features Can Be Deployed on Mainnet Through Metadata Manipulation

## Summary
The runtime check `reject_unstable_bytecode()` can be trivially bypassed by removing or manipulating compilation metadata, allowing unstable language features (such as public structs from V2.4+) to be deployed on mainnet despite being explicitly prohibited.

## Finding Description

The Aptos blockchain enforces a security policy that unstable language versions should not be deployed on mainnet. Language version V2.4 and V2.5 are marked as unstable and enable the public struct feature, which allows cross-module struct operations through automatically generated accessor functions. [1](#0-0) 

The feature gate check occurs at compile-time, where the compiler verifies the language version before generating public struct accessor functions (named `pack$`, `unpack$`, `borrow$`, etc.): [2](#0-1) 

At runtime, the VM attempts to enforce this policy through the `reject_unstable_bytecode()` function: [3](#0-2) 

**The Critical Flaw**: The runtime check uses an optional pattern `if let Some(metadata)`. If compilation metadata is absent or has been manipulated to claim a stable version, the check is bypassed entirely.

**Attack Path**:
1. Attacker compiles a Move module using language version V2.4+, obtaining bytecode with public struct accessor functions
2. Attacker deserializes the compiled module bytecode
3. Attacker either:
   - Removes the compilation metadata entirely, OR
   - Modifies the metadata to claim `language_version: "2.3"` and `unstable: false`
4. Attacker re-serializes and publishes the manipulated module on mainnet
5. The `reject_unstable_bytecode()` check passes because:
   - If metadata is removed: `get_compilation_metadata()` returns `None`, check is skipped
   - If metadata is falsified: `metadata.unstable` evaluates to `false`, check passes
6. The module is now deployed with unstable V2.4 features on production mainnet

The compilation metadata structure shows no cryptographic protection or integrity verification: [4](#0-3) 

## Impact Explanation

This vulnerability constitutes a **High severity** issue under the "Significant protocol violations" category because:

1. **Security Control Bypass**: It completely circumvents a fundamental security control designed to protect mainnet from untested, unstable code
2. **Deterministic Execution Risk**: Unstable features may contain undiscovered bugs that could cause non-deterministic behavior across validator nodes, potentially leading to consensus issues
3. **Policy Violation**: The explicit marking of V2.4/V2.5 as unstable indicates these versions contain features not yet vetted for production deployment
4. **Attack Surface Expansion**: Allows attackers to deploy features with potentially unknown security vulnerabilities on the production network

While this doesn't directly cause fund loss or immediate consensus failure, it undermines a critical defense-in-depth layer protecting the blockchain's integrity.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Trivial Exploitation**: Requires only basic bytecode manipulation skills - no cryptographic attacks or complex exploits
2. **Low Detection Risk**: Manipulated modules appear as valid bytecode and pass all existing verification checks
3. **Clear Attacker Motivation**: Enables use of advanced language features before official release, potentially for malicious purposes
4. **No Access Barriers**: Any user with module publishing rights can execute this attack
5. **Tool Availability**: Standard serialization libraries (BCS) make bytecode manipulation straightforward

The only requirement is the ability to deserialize/reserialize the `CompiledModule` format, which is well-documented and uses standard BCS encoding.

## Recommendation

Implement mandatory compilation metadata validation with integrity protection:

```rust
fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        for module in modules {
            // MANDATORY metadata check - reject if missing
            let metadata = get_compilation_metadata(module)
                .ok_or_else(|| {
                    PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                        .with_message(
                            "compilation metadata required for mainnet deployment".to_string(),
                        )
                        .finish(Location::Undefined)
                })?;
            
            // Verify metadata consistency with bytecode features
            let has_public_struct_accessors = self.detect_public_struct_accessors(module)?;
            let claims_pre_v2_4 = metadata.language_version()
                .map(|v| v < LanguageVersion::V2_4)
                .unwrap_or(false);
            
            if has_public_struct_accessors && claims_pre_v2_4 {
                return Err(PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                    .with_message(
                        "bytecode contains V2.4+ features but claims older version".to_string(),
                    )
                    .finish(Location::Undefined));
            }
            
            // Existing unstable check
            if metadata.unstable {
                return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message(
                        "code marked unstable is not published on mainnet".to_string(),
                    )
                    .finish(Location::Undefined));
            }
        }
    }
    Ok(())
}

// Helper to detect public struct accessor functions
fn detect_public_struct_accessors(&self, module: &CompiledModule) -> VMResult<bool> {
    for func_def in module.function_defs() {
        let handle = module.function_handle_at(func_def.function);
        let name = module.identifier_at(handle.name).as_str();
        if name.starts_with("pack$") || name.starts_with("unpack$") || 
           name.starts_with("borrow$") || name.starts_with("test_variant$") {
            return Ok(true);
        }
    }
    Ok(false)
}
```

Additionally, consider cryptographic signing of compilation metadata by the compiler to prevent tampering.

## Proof of Concept

```rust
use move_binary_format::CompiledModule;
use move_model::metadata::CompilationMetadata;
use bcs;

fn exploit_metadata_bypass(compiled_module_bytes: &[u8]) -> Vec<u8> {
    // 1. Deserialize the compiled module
    let mut module: CompiledModule = bcs::from_bytes(compiled_module_bytes)
        .expect("Failed to deserialize module");
    
    // 2. Remove compilation metadata (or modify it to claim V2.3)
    module.metadata.retain(|md| md.key != b"compilation_metadata");
    
    // Alternative: Modify to claim stable V2.3
    // let fake_metadata = CompilationMetadata {
    //     unstable: false,
    //     compiler_version: "2.0".to_string(),
    //     language_version: "2.3".to_string(),
    // };
    // module.metadata.push(Metadata {
    //     key: b"compilation_metadata".to_vec(),
    //     value: bcs::to_bytes(&fake_metadata).unwrap(),
    // });
    
    // 3. Re-serialize the manipulated module
    bcs::to_bytes(&module).expect("Failed to serialize module")
}

// The manipulated module can now be published on mainnet
// despite containing V2.4 public struct accessor functions
// like pack$MyStruct, unpack$MyStruct, etc.
```

This PoC demonstrates that an attacker can:
1. Compile a module with V2.4 to obtain public struct features
2. Strip or forge the compilation metadata
3. Deploy the result on mainnet, bypassing the feature gate entirely

The resulting module will pass `reject_unstable_bytecode()` and execute successfully with unstable features on production.

---

**Notes**

The vulnerability exists because the security check treats compilation metadata as optional advisory information rather than mandatory security-critical data. The `if let Some(metadata)` pattern on line 1745 allows the entire check to be skipped when metadata is absent. Furthermore, the metadata format has no integrity protection, allowing arbitrary modification post-compilation. This represents a fundamental gap in the defense-in-depth strategy for preventing unstable code on mainnet.

### Citations

**File:** third_party/move/move-model/src/metadata.rs (L49-85)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CompilationMetadata {
    /// A flag indicating whether, at time of creation, the compilation
    /// result was considered as unstable. Unstable code may have restrictions
    /// for deployment on production networks. This flag is true if either the
    /// compiler or language versions are unstable.
    pub unstable: bool,
    /// The version of the compiler, as a string. See
    /// `CompilationVersion::from_str` for supported version strings.
    pub compiler_version: String,
    /// The version of the language, as a string. See
    /// `LanguageVersion::from_str` for supported version strings.
    pub language_version: String,
}

impl CompilationMetadata {
    pub fn new(compiler_version: CompilerVersion, language_version: LanguageVersion) -> Self {
        Self {
            compiler_version: compiler_version.to_string(),
            language_version: language_version.to_string(),
            unstable: compiler_version.unstable() || language_version.unstable(),
        }
    }

    pub fn compiler_version(&self) -> anyhow::Result<CompilerVersion> {
        CompilerVersion::from_str(&self.compiler_version)
    }

    pub fn language_version(&self) -> anyhow::Result<LanguageVersion> {
        LanguageVersion::from_str(&self.language_version)
    }

    /// Returns true of the compilation was created as unstable.
    pub fn created_as_unstable(&self) -> bool {
        self.unstable
    }
}
```

**File:** third_party/move/move-model/src/metadata.rs (L288-294)
```rust
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```

**File:** third_party/move/move-compiler-v2/src/file_format_generator/module_generator.rs (L240-251)
```rust
            if ctx
                .env
                .language_version()
                .language_version_for_public_struct()
                && struct_env.get_visibility().is_public_or_friend()
            {
                FunctionGenerator::gen_struct_test_variant_api(self, ctx, &struct_env);
                FunctionGenerator::gen_struct_pack_api(self, ctx, &struct_env);
                FunctionGenerator::gen_struct_unpack_api(self, ctx, &struct_env);
                FunctionGenerator::gen_struct_borrow_field_api(self, ctx, &struct_env, true);
                FunctionGenerator::gen_struct_borrow_field_api(self, ctx, &struct_env, false);
            }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```
