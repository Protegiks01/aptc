# Audit Report

## Title
Idempotent Transaction Replay Enables Metric Pollution and Resource Exhaustion

## Summary
An attacker can repeatedly submit identical transactions to inflate the `CORE_MEMPOOL_IDEMPOTENT_TXNS` counter without capacity limits, wasting VM validation resources and degrading the accuracy of mempool monitoring metrics.

## Finding Description

The mempool's transaction insertion logic performs expensive VM validation on every transaction submission, even for idempotent duplicates that are already in the mempool. When a transaction with identical payload, expiration timestamp, max gas amount, and gas price is resubmitted, it increments the idempotent counter and returns early without being inserted again. [1](#0-0) 

The vulnerability exists because VM validation occurs **before** the idempotent check: [2](#0-1) 

An attacker can exploit this by:
1. Submitting a valid transaction (consumes 1/100 of per-user capacity)
2. Resubmitting the identical transaction thousands of times
3. Each resubmission triggers full VM validation (signature verification, prologue execution, state reads)
4. The idempotent counter increments without bound
5. No mempool capacity is consumed after the initial insertion [3](#0-2) 

This breaks the **Resource Limits** invariant by allowing unbounded VM validation work per unique transaction, and the **metrics accuracy** invariant by polluting observability data.

## Impact Explanation

This is a **Low Severity** issue per the Aptos bug bounty criteria:
- **Minor information leak**: Inflated idempotent counter reduces metric accuracy for operational monitoring
- **Non-critical implementation bug**: Does not affect consensus, fund safety, or network liveness

While the attack wastes CPU resources on repeated VM validation, it does not:
- Compromise consensus safety or deterministic execution
- Enable fund theft or state manipulation  
- Cause network partition or total availability loss
- Bypass critical security controls

The primary harm is **metrics pollution** making it harder to:
- Detect legitimate transaction patterns during incident response
- Assess actual mempool load and capacity utilization
- Identify other anomalous transaction behaviors

Additionally, high rates of idempotent submissions could cause **validator node slowdowns** via CPU exhaustion, potentially approaching High severity. However, this would be visible in other metrics (CPU usage, VM validation latency) and is rate-limited by API throttling. [4](#0-3) 

No Prometheus alerts are configured based on this counter, limiting the "masking" potential: [5](#0-4) 

## Likelihood Explanation

**High likelihood** of occurrence:
- Any transaction sender can execute this attack
- No special permissions or validator access required
- Minimal cost (API rate limits are the only barrier)
- Simple to implement (repeatedly submit same transaction)

However, practical impact is limited by:
- Default API rate limiting (100 requests/minute per the documentation)
- Per-user capacity limits (100 sequence number transactions) for initial submission
- Noisy attack signature (CPU spikes visible in monitoring) [6](#0-5) 

## Recommendation

Implement idempotent transaction detection **before** VM validation to avoid wasting resources on duplicate submissions:

```rust
// In mempool/src/shared_mempool/tasks.rs, modify validate_and_add_transactions:

// Before VM validation, check mempool for existing transactions
let (transactions, cached_results): (Vec<_>, Vec<_>) = transactions
    .into_iter()
    .partition(|(txn, account_seq_num, _, _)| {
        let mempool = smp.mempool.lock();
        if let Some(existing) = mempool.get_txn(&txn.sender(), txn.replay_protector()) {
            // Check if idempotent
            if existing.txn.payload() == txn.payload() &&
               existing.txn.expiration_timestamp_secs() == txn.expiration_timestamp_secs() &&
               existing.txn.max_gas_amount() == txn.max_gas_amount() &&
               existing.get_gas_price() == txn.gas_price() {
                counters::CORE_MEMPOOL_IDEMPOTENT_TXNS.inc();
                statuses.push((txn.clone(), (MempoolStatus::new(MempoolStatusCode::Accepted), None)));
                return false; // Filter out, don't validate
            }
        }
        true // Keep for validation
    });

// Then perform VM validation only on non-idempotent transactions
```

Alternatively, add rate limiting specifically for idempotent submissions per sender address.

## Proof of Concept

```rust
// Rust test to demonstrate the vulnerability
#[tokio::test]
async fn test_idempotent_transaction_resource_exhaustion() {
    let mut smp = create_test_mempool(); // Setup test mempool
    
    // Create a valid transaction
    let txn = create_signed_transaction(/* valid params */);
    
    // Submit once - goes through VM validation and mempool insertion
    let result1 = process_incoming_transactions(&smp, vec![(txn.clone(), None, None)], TimelineState::NotReady, true);
    assert!(matches!(result1[0].1.0.code, MempoolStatusCode::Accepted));
    
    // Track VM validation count
    let initial_validations = get_vm_validation_count();
    
    // Submit the SAME transaction 1000 times
    for _ in 0..1000 {
        let result = process_incoming_transactions(&smp, vec![(txn.clone(), None, None)], TimelineState::NotReady, true);
        assert!(matches!(result[0].1.0.code, MempoolStatusCode::Accepted));
    }
    
    let final_validations = get_vm_validation_count();
    
    // Verify: VM validation was called 1000 additional times
    assert_eq!(final_validations - initial_validations, 1000);
    
    // Verify: Only 1 transaction in mempool (not 1001)
    assert_eq!(smp.mempool.lock().size(), 1);
    
    // Verify: Counter incremented 1000 times
    assert_eq!(counters::CORE_MEMPOOL_IDEMPOTENT_TXNS.get(), 1000);
}
```

## Notes

This finding confirms the security question's premise: attackers can deliberately inflate the `CORE_MEMPOOL_IDEMPOTENT_TXNS` counter. While this does cause metrics pollution and resource waste, the "masking" potential is limited because:

1. No alerts depend on this metric specifically
2. Other metrics (CPU, validation latency) would reveal the attack
3. API rate limiting provides partial mitigation

The primary impact is reduced observability and operational difficulty rather than a direct security compromise, appropriately categorized as **Low Severity**.

### Citations

**File:** mempool/src/core_mempool/transaction_store.rs (L256-293)
```rust
        if let Some(txns) = self.transactions.get_mut(&address) {
            if let Some(current_version) = txns.get_mut(&txn_replay_protector) {
                if current_version.txn.payload() != txn.txn.payload() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different payload".to_string(),
                    );
                } else if current_version.txn.expiration_timestamp_secs()
                    != txn.txn.expiration_timestamp_secs()
                {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different expiration timestamp"
                            .to_string(),
                    );
                } else if current_version.txn.max_gas_amount() != txn.txn.max_gas_amount() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different max gas amount"
                            .to_string(),
                    );
                } else if current_version.get_gas_price() < txn.get_gas_price() {
                    // Update txn if gas unit price is a larger value than before
                    if let Some(txn) = txns.remove(&txn_replay_protector) {
                        self.index_remove(&txn);
                    };
                    counters::CORE_MEMPOOL_GAS_UPGRADED_TXNS.inc();
                } else if current_version.get_gas_price() > txn.get_gas_price() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a higher gas price".to_string(),
                    );
                } else {
                    // If the transaction is the same, it's an idempotent call
                    // Updating signers is not supported, the previous submission must fail
                    counters::CORE_MEMPOOL_IDEMPOTENT_TXNS.inc();
                    if let Some(acc_seq_num) = account_sequence_number {
                        self.process_ready_seq_num_based_transactions(&address, acc_seq_num);
                    }
                    return MempoolStatus::new(MempoolStatusCode::Accepted);
                }
            }
```

**File:** mempool/src/shared_mempool/tasks.rs (L490-504)
```rust
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
    vm_validation_timer.stop_and_record();
```

**File:** mempool/src/counters.rs (L186-192)
```rust
pub static CORE_MEMPOOL_IDEMPOTENT_TXNS: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!(
        "aptos_core_mempool_idempotent_txns_count",
        "Number of txns received that are idempotent duplicates"
    )
    .unwrap()
});
```

**File:** terraform/helm/monitoring/files/rules/alerts.yml (L44-79)
```yaml
    # Mempool alerts
  - alert: Mempool has no active upstream peers
    expr: (sum by (kubernetes_pod_name) (aptos_mempool_active_upstream_peers_count)) == 0
    for: 3m
    labels:
      severity: error
      summary: "Mempool has no active upstream peers (unable to forward transactions to anyone!)"
    annotations:
  - alert: Mempool is at >80% capacity (count)
    expr: aptos_core_mempool_index_size{index="system_ttl"} > 1600000 # assumes default mempool size 2_000_000
    for: 5m
    labels:
      severity: warning
      summary: "Mempool count is at >80% capacity (it may soon become full!)"
    annotations:
  - alert: Mempool is at >80% capacity (bytes)
    expr: aptos_core_mempool_index_size{index="size_bytes"} > 1717986918 # assumes default mempool size 2 * 1024 * 1024 * 1024
    for: 5m
    labels:
      severity: warning
      summary: "Mempool bytes is at >80% capacity (it may soon become full!)"
    annotations:
  - alert: Mempool is growing at a significant rate (count)
    expr: rate(aptos_core_mempool_index_size{index="system_ttl"}[1m]) > 60000 # 3% growth per minute - assumes default mempool size 2_000_000
    for: 10m
    labels:
      severity: warning
      summary: "Mempool count is growing at a significant rate (it may soon become full!)"
    annotations:
  - alert: Mempool is growing at a significant rate (bytes)
    expr: rate(aptos_core_mempool_index_size{index="size_bytes"}[1m]) > 64424509 # 3% growth per minute - assumes default mempool size 2 * 1024 * 1024 * 1024
    for: 10m
    labels:
      severity: warning
      summary: "Mempool bytes is growing at a significant rate (it may soon become full!)"
    annotations:
```

**File:** config/src/config/mempool_config.rs (L121-123)
```rust
            capacity: 2_000_000,
            capacity_bytes: 2 * 1024 * 1024 * 1024,
            capacity_per_user: 100,
```
