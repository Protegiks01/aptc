# Audit Report

## Title
Division-by-Zero Panic in Proposer Election Leading to Complete Network Halt via Malicious Governance Config

## Summary
A critical vulnerability exists in the consensus proposer election mechanism where setting all reputation weight parameters to zero through on-chain governance causes a division-by-zero panic in all validator nodes, resulting in complete network unavailability. The vulnerability stems from insufficient validation of on-chain consensus configuration parameters combined with unsafe modulo operation in the leader election randomness function.

## Finding Description

The vulnerability exists in the `next_in_range()` function which performs a modulo operation without checking if the divisor is zero: [1](#0-0) 

When `max` is 0, line 45 executes `u128::from_le_bytes(temp) % 0`, causing an immediate panic. This function is called by `choose_index()`: [2](#0-1) 

The `total_weight` becomes 0 when all weights in the input vector are 0, which propagates to `next_in_range()` as the `max` parameter at line 59.

The vulnerability is triggered through the following attack path:

**Step 1: Malicious Governance Proposal**
An attacker (or compromised governance) creates a governance proposal to update the `ConsensusConfig` with all reputation weight parameters set to 0. The on-chain validation only checks vector length: [3](#0-2) 

This validation does NOT inspect the actual weight values inside the config bytes.

**Step 2: Config Deserialization Without Value Validation**
When validators load the config, deserialization only checks BCS format validity: [4](#0-3) 

No validation ensures weights are non-zero.

**Step 3: Zero Weights Propagate to Proposer Election**
When `LeaderReputation::get_valid_proposer_and_voting_power_participation_ratio()` is called, it retrieves reputation weights: [5](#0-4) 

The `ProposerAndVoterHeuristic::get_weights()` returns reputation weights based on the configurable parameters: [6](#0-5) 

Each validator receives one of `failed_weight`, `active_weight`, or `inactive_weight`. If all three are 0, all entries in the weights vector become 0. Even after multiplying by voting power at line 714, the result remains 0.

**Step 4: Panic During Proposer Election**
The zero-weighted `stake_weights` vector is passed to `choose_index()`: [7](#0-6) 

This causes `total_weight` to be 0, triggering the division-by-zero panic in `next_in_range()`.

**Broken Invariant:** This violates the **Consensus Liveness** invariant - the network must be able to elect leaders and produce blocks continuously.

## Impact Explanation

**Severity: Critical** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability causes **Total loss of liveness/network availability**:

1. **All validator nodes crash simultaneously** when attempting proposer election
2. **No new blocks can be produced** - complete consensus halt
3. **Network-wide outage** - all transactions stop processing
4. **Requires hard fork to recover** - emergency governance proposal cannot be executed because the network is halted
5. **Deterministic and unavoidable** - once the malicious config activates, the crash is guaranteed at the next proposer election

The impact matches the Critical severity category: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: Medium-High**

**Requirements for exploitation:**
- Malicious governance proposal must be created and passed
- Proposal sets `active_weight`, `inactive_weight`, and `failed_weight` to 0
- Standard governance voting process must approve it

**Factors increasing likelihood:**
- No runtime validation catches this configuration
- No pre-deployment testing would detect it unless explicitly tested
- Default values are non-zero, but governance can change them: [8](#0-7) 

- Once deployed, the attack succeeds with 100% certainty
- Governance compromise or insider threat could intentionally exploit this

**Factors decreasing likelihood:**
- Requires governance consensus (unless governance is compromised)
- Unusual configuration that might raise suspicion during review

However, once the malicious config is activated, the network halt is **guaranteed and immediate**.

## Recommendation

Implement multi-layered validation:

**1. On-Chain Validation (Move)**
Add value validation in `consensus_config.move::set_for_next_epoch()`:

```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // Validate config contents before accepting
    assert!(validator_config_weights_valid(config), error::invalid_argument(EINVALID_CONFIG));
    
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}

native fun validator_config_weights_valid(config_bytes: vector<u8>): bool;
```

**2. Off-Chain Validation (Rust)**
Add validation in `OnChainConsensusConfig::deserialize_into_config()`:

```rust
fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
    let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
    let config: Self = bcs::from_bytes(&raw_bytes)
        .map_err(|e| format_err!("[on-chain config] Failed to deserialize: {}", e))?;
    
    // Validate weights are non-zero
    config.validate_weights()?;
    Ok(config)
}
```

**3. Runtime Safety Check**
Add defensive check in `next_in_range()`:

```rust
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    if max == 0 {
        panic!("CRITICAL: next_in_range called with max=0, invalid config detected");
    }
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    u128::from_le_bytes(temp) % max
}
```

Better yet, ensure minimum weight of 1:

```rust
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    let max = std::cmp::max(max, 1); // Ensure at least 1
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    u128::from_le_bytes(temp) % max
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    #[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
    fn test_zero_max_causes_panic() {
        // This demonstrates the vulnerability
        let state = vec![1, 2, 3, 4];
        let _result = next_in_range(state, 0); // This panics
    }
    
    #[test]
    #[should_panic]
    fn test_all_zero_weights_causes_panic() {
        // Simulate malicious config scenario
        let weights = vec![0u128, 0, 0, 0]; // All validators have 0 weight
        let state = vec![1, 2, 3, 4];
        let _index = choose_index(weights, state); // This panics
    }
    
    #[test]
    fn test_empty_weights_causes_panic() {
        // Edge case: empty validator set
        let weights: Vec<u128> = vec![];
        let state = vec![1, 2, 3, 4];
        // This also panics because total_weight remains 0
        let _index = choose_index(weights, state);
    }
}
```

To verify in a live testnet environment, create a governance proposal with:

```rust
let malicious_config = OnChainConsensusConfig::V5 {
    alg: ConsensusAlgorithmConfig::JolteonV2 {
        main: ConsensusConfigV1 {
            // ... other fields ...
            proposer_election_type: ProposerElectionType::LeaderReputation(
                LeaderReputationType::ProposerAndVoterV2(ProposerAndVoterConfig {
                    active_weight: 0,      // MALICIOUS: Set to 0
                    inactive_weight: 0,    // MALICIOUS: Set to 0
                    failed_weight: 0,      // MALICIOUS: Set to 0
                    failure_threshold_percent: 10,
                    proposer_window_num_validators_multiplier: 10,
                    voter_window_num_validators_multiplier: 1,
                    weight_by_voting_power: true,
                    use_history_from_previous_epoch_max_count: 5,
                })
            ),
        },
        quorum_store_enabled: true,
        order_vote_enabled: true,
    },
    vtxn: ValidatorTxnConfig::default_enabled(),
    window_size: DEFAULT_ENABLED_WINDOW_SIZE,
    rand_check_enabled: true,
};

// Serialize and submit via governance
let config_bytes = bcs::to_bytes(&malicious_config)?;
consensus_config::set_for_next_epoch(&framework_signer, config_bytes);
```

After epoch transition, all validators will crash with division-by-zero panic when electing the next proposer.

### Citations

**File:** consensus/src/liveness/proposer_election.rs (L39-46)
```rust
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    // hash = SHA-3-256(state)
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    // return hash[0..16]
    u128::from_le_bytes(temp) % max
}
```

**File:** consensus/src/liveness/proposer_election.rs (L49-69)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
    weights
        .binary_search_by(|w| {
            if *w <= chosen_weight {
                Ordering::Less
            } else {
                Ordering::Greater
            }
        })
        .expect_err("Comparison never returns equals, so it's always guaranteed to be error")
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L464-468)
```rust
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
        bcs::from_bytes(&raw_bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L490-492)
```rust
                    active_weight: 1000,
                    inactive_weight: 10,
                    failed_weight: 1,
```

**File:** consensus/src/liveness/leader_reputation.rs (L521-552)
```rust
impl ReputationHeuristic for ProposerAndVoterHeuristic {
    fn get_weights(
        &self,
        epoch: u64,
        epoch_to_candidates: &HashMap<u64, Vec<Author>>,
        history: &[NewBlockEvent],
    ) -> Vec<u64> {
        assert!(epoch_to_candidates.contains_key(&epoch));

        let (votes, proposals, failed_proposals) =
            self.aggregation
                .get_aggregated_metrics(epoch_to_candidates, history, &self.author);

        epoch_to_candidates[&epoch]
            .iter()
            .map(|author| {
                let cur_votes = *votes.get(author).unwrap_or(&0);
                let cur_proposals = *proposals.get(author).unwrap_or(&0);
                let cur_failed_proposals = *failed_proposals.get(author).unwrap_or(&0);

                if cur_failed_proposals * 100
                    > (cur_proposals + cur_failed_proposals) * self.failure_threshold_percent
                {
                    self.failed_weight
                } else if cur_proposals > 0 || cur_votes > 0 {
                    self.active_weight
                } else {
                    self.inactive_weight
                }
            })
            .collect()
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L704-715)
```rust
        let mut weights =
            self.heuristic
                .get_weights(self.epoch, &self.epoch_to_proposers, &sliding_window);
        let proposers = &self.epoch_to_proposers[&self.epoch];
        assert_eq!(weights.len(), proposers.len());

        // Multiply weights by voting power:
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();
```

**File:** consensus/src/liveness/leader_reputation.rs (L732-732)
```rust
        let chosen_index = choose_index(stake_weights, state);
```
