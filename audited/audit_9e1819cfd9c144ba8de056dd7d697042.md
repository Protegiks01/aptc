# Audit Report

## Title
Orphaned Bootstrap Notification Subscription Blocks Node Initialization via Async Task Cancellation

## Summary
A concurrency vulnerability in the state-sync-driver component allows orphaned bootstrap notification subscriptions to block future legitimate subscription attempts when a task calling `notify_once_bootstrapped()` is aborted after sending the notification but before awaiting the response. This can prevent critical node components from properly waiting for bootstrap completion, potentially causing node initialization failures.

## Finding Description

The vulnerability exists in the interaction between `DriverClient::notify_once_bootstrapped()` and `Bootstrapper::subscribe_to_bootstrap_notifications()`. [1](#0-0) 

When `notify_once_bootstrapped()` is called, it creates a oneshot channel pair and sends the Sender to the driver via an unbounded mpsc channel. If the task executing this future is aborted via `JoinHandle::abort()` after line 40 completes (notification sent) but before line 42 (awaiting response), the `callback_receiver` is dropped while the `callback_sender` remains queued for processing.

The driver processes this notification and stores the orphaned Sender: [2](#0-1) 

The bootstrapper enforces a single-subscriber policy: [3](#0-2) 

**Critical Issue:** If the node is NOT yet bootstrapped when the orphaned subscription is processed, the channel is stored at line 391, but `notify_listeners_if_bootstrapped()` returns early because `is_bootstrapped()` returns false. The orphaned `callback_sender` remains in `bootstrap_notifier_channel` indefinitely until bootstrapping completes. [4](#0-3) 

Any subsequent legitimate caller attempting to subscribe will be rejected with "Only one bootstrap subscriber is supported at a time!" at lines 385-388.

**Real-World Impact:** The production code uses this mechanism during node initialization: [5](#0-4) [6](#0-5) 

While the current production code uses `block_on()` (which cannot be aborted), the test infrastructure demonstrates the vulnerable pattern: [7](#0-6) 

## Impact Explanation

**Medium Severity** - This vulnerability causes state inconsistencies requiring intervention, meeting the Medium severity criteria in the Aptos bug bounty program.

If exploited, the orphaned subscription blocks the critical node initialization path. The node cannot proceed past the bootstrap wait phase, resulting in:
- Failed node startup
- Denial of service on node availability
- Consensus/validator nodes unable to participate in the network
- Requires manual intervention (node restart) to recover

However, this does NOT reach High/Critical severity because:
- No funds are at risk
- No consensus safety violations occur
- Network remains available (only affects individual nodes)
- Recovery is possible via restart

## Likelihood Explanation

**Low to Medium Likelihood** in current codebase:

**Current State:**
- Production code uses `block_on()` which is not abortable
- No vulnerable spawn patterns exist in production paths
- Requires internal code execution access

**Future Risk:**
- If developers refactor to use `tokio::spawn()` for async initialization
- If internal task orchestration introduces cancellation
- If third-party code integrates with state-sync APIs

**Exploitability:**
- Requires internal code execution (not exploitable by external attackers)
- Not exploitable via RPC, network messages, or transactions
- Would require either a compromised node or a separate bug causing task cancellation

## Recommendation

Implement receiver liveness checking and graceful handling of orphaned subscriptions:

```rust
// In bootstrapper.rs - subscribe_to_bootstrap_notifications()
pub async fn subscribe_to_bootstrap_notifications(
    &mut self,
    bootstrap_notifier_channel: oneshot::Sender<Result<(), Error>>,
) -> Result<(), Error> {
    // Check if the receiver is still alive
    if bootstrap_notifier_channel.is_canceled() {
        return Err(Error::UnexpectedError(
            "Bootstrap notification receiver was dropped before subscription".into(),
        ));
    }
    
    if self.bootstrap_notifier_channel.is_some() {
        return Err(Error::UnexpectedError(
            "Only one bootstrap subscriber is supported at a time!".into(),
        ));
    }

    self.bootstrap_notifier_channel = Some(bootstrap_notifier_channel);
    self.notify_listeners_if_bootstrapped().await
}

// In notify_listeners_if_bootstrapped() - don't return error on send failure
async fn notify_listeners_if_bootstrapped(&mut self) -> Result<(), Error> {
    if self.is_bootstrapped() {
        if let Some(notifier_channel) = self.bootstrap_notifier_channel.take() {
            if let Err(_error) = notifier_channel.send(Ok(())) {
                // Receiver was dropped - log but don't fail
                // This is expected if the caller was cancelled
                debug!("Bootstrap notification receiver was dropped");
            }
        }
        self.reset_active_stream(None).await?;
        self.storage_synchronizer.finish_chunk_executor();
    }
    Ok(())
}
```

Alternative: Support multiple subscribers with a broadcast channel instead of enforcing single-subscriber limitation.

## Proof of Concept

```rust
// Reproduction test demonstrating the vulnerability
#[tokio::test]
async fn test_orphaned_bootstrap_subscription_blocks_future_callers() {
    // Setup: Create a driver that is NOT yet bootstrapped
    let (notification_sender, mut notification_receiver) = 
        mpsc::unbounded::<DriverNotification>();
    let driver_client = DriverClient::new(notification_sender);
    
    // Step 1: Spawn a task that calls notify_once_bootstrapped
    let handle = tokio::spawn({
        let client = driver_client.clone();
        async move {
            client.notify_once_bootstrapped().await.unwrap();
        }
    });
    
    // Step 2: Wait for notification to be sent (but not processed yet)
    tokio::time::sleep(Duration::from_millis(10)).await;
    
    // Step 3: Abort the task (receiver gets dropped)
    handle.abort();
    
    // Step 4: Driver processes the orphaned notification
    let notification = notification_receiver.next().await.unwrap();
    let DriverNotification::NotifyOnceBootstrapped(orphaned_sender) = notification;
    
    // Store in bootstrapper (simulating driver behavior)
    let mut bootstrapper = create_test_bootstrapper(); // Not yet bootstrapped
    bootstrapper.subscribe_to_bootstrap_notifications(orphaned_sender).await.unwrap();
    
    // Step 5: Legitimate caller tries to subscribe
    let (legit_sender, _legit_receiver) = oneshot::channel();
    let result = bootstrapper.subscribe_to_bootstrap_notifications(legit_sender).await;
    
    // Expected: Error due to orphaned subscription blocking
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Only one bootstrap subscriber"));
    
    // Node initialization is now blocked until bootstrap completes
}
```

**Notes**

This vulnerability demonstrates a subtle async concurrency issue where task cancellation semantics interact poorly with single-subscriber channel patterns. While the current production code doesn't exhibit the vulnerable pattern (using `block_on()` instead of `spawn()`), the architectural weakness exists and could manifest if code is refactored for async task-based initialization. The issue is exacerbated by the single-subscriber enforcement, which was likely designed for simplicity but creates a fragile synchronization point during critical node initialization.

### Citations

**File:** state-sync/state-sync-driver/src/driver_client.rs (L34-44)
```rust
    pub fn notify_once_bootstrapped(&self) -> impl Future<Output = Result<(), Error>> + use<> {
        let mut notification_sender = self.notification_sender.clone();
        let (callback_sender, callback_receiver) = oneshot::channel();

        async move {
            notification_sender
                .send(DriverNotification::NotifyOnceBootstrapped(callback_sender))
                .await?;
            callback_receiver.await?
        }
    }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L445-467)
```rust
    async fn handle_client_notification(&mut self, notification: DriverNotification) {
        debug!(LogSchema::new(LogEntry::ClientNotification)
            .message("Received a notify bootstrap notification from the client!"));
        metrics::increment_counter(
            &metrics::DRIVER_COUNTERS,
            metrics::DRIVER_CLIENT_NOTIFICATION,
        );

        // TODO(joshlind): refactor this if the client only supports one notification type!
        // Extract the bootstrap notifier channel
        let DriverNotification::NotifyOnceBootstrapped(notifier_channel) = notification;

        // Subscribe the bootstrap notifier channel
        if let Err(error) = self
            .bootstrapper
            .subscribe_to_bootstrap_notifications(notifier_channel)
            .await
        {
            warn!(LogSchema::new(LogEntry::ClientNotification)
                .error(&error)
                .message("Failed to subscribe to bootstrap notifications!"));
        }
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L380-393)
```rust
    /// Subscribes the specified channel to bootstrap completion notifications
    pub async fn subscribe_to_bootstrap_notifications(
        &mut self,
        bootstrap_notifier_channel: oneshot::Sender<Result<(), Error>>,
    ) -> Result<(), Error> {
        if self.bootstrap_notifier_channel.is_some() {
            return Err(Error::UnexpectedError(
                "Only one boostrap subscriber is supported at a time!".into(),
            ));
        }

        self.bootstrap_notifier_channel = Some(bootstrap_notifier_channel);
        self.notify_listeners_if_bootstrapped().await
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L395-411)
```rust
    /// Notifies any listeners if we've now bootstrapped
    async fn notify_listeners_if_bootstrapped(&mut self) -> Result<(), Error> {
        if self.is_bootstrapped() {
            if let Some(notifier_channel) = self.bootstrap_notifier_channel.take() {
                if let Err(error) = notifier_channel.send(Ok(())) {
                    return Err(Error::CallbackSendFailed(format!(
                        "Bootstrap notification error: {:?}",
                        error
                    )));
                }
            }
            self.reset_active_stream(None).await?;
            self.storage_synchronizer.finish_chunk_executor(); // The bootstrapper is now complete
        }

        Ok(())
    }
```

**File:** aptos-node/src/lib.rs (L824-827)
```rust
    // Wait until state sync has been initialized
    debug!("Waiting until state sync is initialized!");
    state_sync_runtimes.block_until_initialized();
    debug!("State sync initialization complete.");
```

**File:** state-sync/state-sync-driver/src/driver_factory.rs (L231-235)
```rust
    pub fn block_until_initialized(&self) {
        let state_sync_client = self.state_sync.create_driver_client();
        block_on(state_sync_client.notify_once_bootstrapped())
            .expect("State sync v2 initialization failure");
    }
```

**File:** state-sync/state-sync-driver/src/tests/driver.rs (L427-447)
```rust
async fn wait_for_auto_bootstrapping(validator_driver: DriverFactory, time_service: TimeService) {
    // Create the driver client and a join handle that waits on auto bootstrapping
    let driver_client = validator_driver.create_driver_client();
    let auto_bootstrapping_handle = tokio::spawn(async move {
        driver_client.notify_once_bootstrapped().await.unwrap();
    });

    // Spawn a task that continuously elapses time
    tokio::spawn(async move {
        time_service
            .into_mock()
            .advance_async(Duration::from_secs(
                StateSyncDriverConfig::default().max_connection_deadline_secs,
            ))
            .await;
        sleep(Duration::from_secs(1)).await;
    });

    // Wait until the validator is auto-bootstrapped
    auto_bootstrapping_handle.await.unwrap();
}
```
