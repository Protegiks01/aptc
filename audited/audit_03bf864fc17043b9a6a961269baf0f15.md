# Audit Report

## Title
Missing Protocol Validation in Inbound Message Handler Allows Resource Exhaustion via Falsified Capability Advertisement

## Summary
A malicious peer can advertise support for protocols in their `HandshakeMsg` without actually implementing handlers for those protocols. When honest nodes send RPC requests to these advertised protocols, the malicious peer silently drops them, causing RPC timeouts and resource waste on honest nodes.

## Finding Description

During the AptosNet handshake protocol, peers exchange `HandshakeMsg` structures containing their `supported_protocols`. The `perform_handshake()` function negotiates the intersection of supported protocols between peers and stores this in `ConnectionMetadata.application_protocols`. [1](#0-0) 

However, when receiving inbound messages, the `handle_inbound_network_message()` function only validates whether a local `upstream_handler` exists for the protocol_id - it does NOT validate that the protocol_id is one of the negotiated `application_protocols`. [2](#0-1) 

**Attack Flow:**

1. **Malicious Handshake**: Attacker sends `HandshakeMsg` claiming support for critical protocols (e.g., `ConsensusRpcBcs`, `StorageServiceRpc`) in their `supported_protocols` field
2. **Successful Negotiation**: The honest node performs handshake and negotiates these protocols as common
3. **Protocol Selection**: When sending messages, the honest node's `get_preferred_protocol_for_peer()` validates the peer supports the protocol before sending [3](#0-2) 

4. **Silent Drops**: Attacker receives RPC requests for advertised protocols but has no registered `upstream_handlers`, causing messages to be silently dropped with only metric increments [4](#0-3) 

5. **RPC Timeouts**: Honest node's outbound RPC tasks wait for the full timeout duration before failing [5](#0-4) 

**Key Vulnerability**: There is no enforcement that a peer must handle the protocols they advertise during handshake. The negotiated `application_protocols` stored in `ConnectionMetadata` are never checked against incoming message protocol_ids.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program criterion of "Validator node slowdowns":

- **Consensus Impact**: If attackers advertise consensus protocols (`ConsensusRpcBcs`, `ConsensusRpcCompressed`) without implementing them, validators attempting to send consensus messages experience repeated RPC timeouts during critical consensus rounds
- **Resource Exhaustion**: Each RPC timeout wastes the configured timeout duration (typically seconds) and occupies slots in the outbound RPC queue
- **Cascading Effects**: Multiple malicious peers can amplify the impact, slowing down block production and state synchronization
- **Validator Performance**: Honest validators waste computational resources managing timed-out RPCs instead of processing blocks

## Likelihood Explanation

**Very High Likelihood:**
- **Zero Authentication Required**: Any peer can connect and send a malicious `HandshakeMsg`
- **Simple Exploit**: Attacker only needs to claim protocols without implementing handlers
- **No Detection**: The attack is silent - only metric counters (`UNKNOWN_LABEL`) increment, with no alerts or connection termination
- **Persistent Effect**: Once connected, the malicious peer continues affecting all RPC attempts until manually disconnected

## Recommendation

Add validation in `handle_inbound_network_message()` to verify incoming protocol_ids match the negotiated `application_protocols`:

```rust
fn handle_inbound_network_message(
    &mut self,
    message: NetworkMessage,
) -> Result<(), PeerManagerError> {
    match &message {
        NetworkMessage::DirectSendMsg(direct) => {
            // ADDED: Validate protocol was negotiated
            if !self.connection_metadata.application_protocols.contains(direct.protocol_id) {
                warn!(
                    "Peer {} sent message for unadvertised protocol: {:?}",
                    self.remote_peer_id().short_str(),
                    direct.protocol_id
                );
                counters::direct_send_messages(&self.network_context, "unadvertised").inc();
                self.shutdown(DisconnectReason::RequestedByPeerManager);
                return Err(PeerManagerError::NotSupported);
            }
            // ... existing code
        },
        NetworkMessage::RpcRequest(request) => {
            // ADDED: Validate protocol was negotiated
            if !self.connection_metadata.application_protocols.contains(request.protocol_id) {
                warn!(
                    "Peer {} sent RPC for unadvertised protocol: {:?}",
                    self.remote_peer_id().short_str(),
                    request.protocol_id
                );
                counters::rpc_messages(&self.network_context, "unadvertised", "inbound", "rejected").inc();
                self.shutdown(DisconnectReason::RequestedByPeerManager);
                return Err(PeerManagerError::NotSupported);
            }
            // ... existing code
        },
        // ... other cases
    }
}
```

Additionally, when a peer receives a message for which no handler exists (even if negotiated), it should send an error response rather than silently dropping: [6](#0-5) 

## Proof of Concept

```rust
#[test]
fn test_falsified_protocol_capability() {
    use crate::protocols::wire::handshake::v1::{HandshakeMsg, ProtocolIdSet, MessagingProtocolVersion};
    use crate::ProtocolId;
    use std::collections::BTreeMap;
    
    // Attacker creates HandshakeMsg claiming ConsensusRpc support
    let mut attacker_protocols = BTreeMap::new();
    attacker_protocols.insert(
        MessagingProtocolVersion::V1,
        ProtocolIdSet::from_iter([
            ProtocolId::ConsensusRpcBcs,
            ProtocolId::HealthCheckerRpc,
        ])
    );
    let attacker_handshake = HandshakeMsg {
        chain_id: ChainId::test(),
        network_id: NetworkId::Validator,
        supported_protocols: attacker_protocols,
    };
    
    // Honest node's handshake
    let mut honest_protocols = BTreeMap::new();
    honest_protocols.insert(
        MessagingProtocolVersion::V1,
        ProtocolIdSet::from_iter([ProtocolId::ConsensusRpcBcs])
    );
    let honest_handshake = HandshakeMsg {
        chain_id: ChainId::test(),
        network_id: NetworkId::Validator,
        supported_protocols: honest_protocols,
    };
    
    // Handshake succeeds - ConsensusRpcBcs is in intersection
    let (version, common) = honest_handshake
        .perform_handshake(&attacker_handshake)
        .unwrap();
    assert!(common.contains(ProtocolId::ConsensusRpcBcs));
    
    // Honest node sends ConsensusRpc to attacker
    // Attacker has NO upstream_handler registered for ConsensusRpcBcs
    // Message is silently dropped -> RPC times out
    // Resource waste occurs, honest validator slowed down
}
```

### Citations

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L431-465)
```rust
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/peer/mod.rs (L447-541)
```rust
    fn handle_inbound_network_message(
        &mut self,
        message: NetworkMessage,
    ) -> Result<(), PeerManagerError> {
        match &message {
            NetworkMessage::DirectSendMsg(direct) => {
                let data_len = direct.raw_msg.len();
                network_application_inbound_traffic(
                    self.network_context,
                    direct.protocol_id,
                    data_len as u64,
                );
                match self.upstream_handlers.get(&direct.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(data_len as u64);
                    },
                    Some(handler) => {
                        let key = (self.connection_metadata.remote_peer_id, direct.protocol_id);
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        match handler.push(key, ReceivedMessage::new(message, sender)) {
                            Err(_err) => {
                                // NOTE: aptos_channel never returns other than Ok(()), but we might switch to tokio::sync::mpsc and then this would work
                                counters::direct_send_messages(
                                    &self.network_context,
                                    DECLINED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, DECLINED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                            Ok(_) => {
                                counters::direct_send_messages(
                                    &self.network_context,
                                    RECEIVED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, RECEIVED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                        }
                    },
                }
            },
            NetworkMessage::Error(error_msg) => {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata(&self.connection_metadata),
                    error_msg = ?error_msg,
                    "{} Peer {} sent an error message: {:?}",
                    self.network_context,
                    self.remote_peer_id().short_str(),
                    error_msg,
                );
            },
            NetworkMessage::RpcRequest(request) => {
                match self.upstream_handlers.get(&request.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(request.raw_request.len() as u64);
                    },
                    Some(handler) => {
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        if let Err(err) = self
                            .inbound_rpcs
                            .handle_inbound_request(handler, ReceivedMessage::new(message, sender))
                        {
                            warn!(
                                NetworkSchema::new(&self.network_context)
                                    .connection_metadata(&self.connection_metadata),
                                error = %err,
                                "{} Error handling inbound rpc request: {}",
                                self.network_context,
                                err
                            );
                        }
                    },
                }
            },
            NetworkMessage::RpcResponse(_) => {
                // non-reference cast identical to this match case
                let NetworkMessage::RpcResponse(response) = message else {
                    unreachable!("NetworkMessage type changed between match and let")
                };
                self.outbound_rpcs.handle_inbound_response(response)
            },
        };
        Ok(())
    }
```

**File:** network/framework/src/application/interface.rs (L142-158)
```rust
    fn get_preferred_protocol_for_peer(
        &self,
        peer: &PeerNetworkId,
        preferred_protocols: &[ProtocolId],
    ) -> Result<ProtocolId, Error> {
        let protocols_supported_by_peer = self.get_supported_protocols(peer)?;
        for protocol in preferred_protocols {
            if protocols_supported_by_peer.contains(*protocol) {
                return Ok(*protocol);
            }
        }
        Err(Error::NetworkError(format!(
            "None of the preferred protocols are supported by this peer! \
            Peer: {:?}, supported protocols: {:?}",
            peer, protocols_supported_by_peer
        )))
    }
```

**File:** network/framework/src/protocols/rpc/mod.rs (L515-525)
```rust
        let wait_for_response = self
            .time_service
            .timeout(timeout, response_rx)
            .map(|result| {
                // Flatten errors.
                match result {
                    Ok(Ok(response)) => Ok(Bytes::from(response.raw_response)),
                    Ok(Err(oneshot::Canceled)) => Err(RpcError::UnexpectedResponseChannelCancel),
                    Err(timeout::Elapsed) => Err(RpcError::TimedOut),
                }
            });
```
