# Audit Report

## Title
Upgrade Policy Bypass via FunctionInfo References in Module Publishing

## Summary
The `FunctionInfo` mechanism allows modules to store references to functions in other modules without declaring them as dependencies. This bypasses the upgrade policy validation system, enabling "immutable" modules to effectively depend on "arbitrary" (freely upgradeable) modules. An attacker can publish an immutable module that dispatches to a mutable module, then upgrade the mutable module to change the immutable module's behavior, breaking fundamental security guarantees.

## Finding Description

The Aptos module publishing system enforces upgrade policies to ensure that modules with stricter policies (e.g., `immutable`) cannot depend on modules with weaker policies (e.g., `arbitrary`). This prevents immutable modules from having their behavior changed through dependency upgrades. [1](#0-0) 

The validation checks dependencies at publish time by examining the `immediate_dependencies()` from the compiled module's bytecode: [2](#0-1) 

However, `FunctionInfo` provides a way to create runtime references to functions that bypass this validation. When creating a `FunctionInfo`, only identifier validity is checked—not whether the target module is in `allowed_deps` or has a compatible upgrade policy: [3](#0-2) 

During module initialization, `init_module` can create and store `FunctionInfo` references to any module: [4](#0-3) 

When these `FunctionInfo` references are later validated and used for dispatch, only type compatibility and visibility checks are performed—no dependency or upgrade policy validation: [5](#0-4) [6](#0-5) 

**Attack Flow:**
1. Attacker publishes Module A with `upgrade_policy = immutable` and no bytecode dependency on Module C
2. Module A's `init_module` creates `FunctionInfo` pointing to Module C (which has `upgrade_policy = arbitrary`)
3. Module A stores this `FunctionInfo` and uses it for critical operations (e.g., withdraw authorization)
4. Users trust Module A because it's marked immutable
5. Attacker upgrades Module C to malicious version
6. Module A's behavior changes despite being "immutable"

This breaks the fundamental invariant that immutable modules have unchanging behavior.

## Impact Explanation

**Severity: Critical** (up to $1,000,000 per Aptos bug bounty)

This vulnerability qualifies as Critical severity because it:

1. **Enables Loss of Funds**: An attacker can publish an "immutable" DeFi protocol that appears trustworthy, then steal user funds by upgrading a hidden dependency referenced via `FunctionInfo`. Users deposit funds believing the contract cannot be changed.

2. **Breaks Core Security Guarantees**: The upgrade policy system is a fundamental security mechanism. Users explicitly choose immutable modules to ensure code cannot change. This bypass makes the immutability guarantee meaningless.

3. **Affects Protocol Integrity**: Many high-value applications (fungible assets, NFT platforms, DeFi protocols) use `FunctionInfo` for dispatch functions. All such "immutable" modules are potentially compromised if they reference mutable modules.

4. **Consensus Determinism**: While not directly causing consensus failures, different validators could execute different versions of dispatched functions if upgrades occur mid-block, potentially causing state divergence.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Easy to Execute**: Publishing a module with `FunctionInfo` requires no special privileges or technical sophistication
2. **Hard to Detect**: Users inspecting an "immutable" module won't see the hidden dependency in its declared package metadata
3. **Common Pattern**: The fungible asset framework encourages using `FunctionInfo` for custom withdraw/deposit logic, as shown in multiple examples
4. **High Incentive**: DeFi protocols hold significant value, creating strong financial motivation for attackers

Real-world example pattern from the codebase: [7](#0-6) 

## Recommendation

Add upgrade policy validation when `FunctionInfo` targets are registered or used for dispatch:

**Option 1: Validate at Registration Time**
Modify `register_dispatch_functions` to check that the target module's upgrade policy is compatible with the calling module's policy. This requires:
- Passing the calling module's upgrade policy to the registration function
- Looking up the target module's `PackageMetadata` from `PackageRegistry`  
- Asserting that `target_policy >= caller_policy`

**Option 2: Validate During Publishing**
Extend module metadata to include `FunctionInfo` targets that will be created in `init_module`:
- Add a new metadata field for "dynamic dependencies"
- Extract this during compilation
- Validate these references against `allowed_deps` in `validate_publish_request`

**Option 3: Runtime Enforcement**
Modify the native dispatch functions to check upgrade policy compatibility before dispatching:
- Store the calling module's upgrade policy in dispatch metadata
- Check target module's policy at dispatch time
- Abort if policies are incompatible

**Recommended Fix (Option 1 - most practical):**

```move
public(friend) fun register_dispatch_functions(
    constructor_ref: &ConstructorRef,
    caller_upgrade_policy: u8,  // NEW: Pass caller's upgrade policy
    withdraw_function: Option<FunctionInfo>,
    deposit_function: Option<FunctionInfo>,
    derived_balance_function: Option<FunctionInfo>
) acquires PackageRegistry {  // NEW: Acquire PackageRegistry
    withdraw_function.for_each_ref(|f| {
        validate_dispatch_dependency(caller_upgrade_policy, f);  // NEW
        // ... existing type checks
    });
    // Similar for deposit_function and derived_balance_function
}

fun validate_dispatch_dependency(
    caller_policy: u8, 
    target: &FunctionInfo
) acquires PackageRegistry {
    let target_addr = target.module_address;
    if (is_policy_exempted_address(target_addr)) return;
    
    let registry = borrow_global<PackageRegistry>(target_addr);
    let target_policy = /* lookup policy for target.module_name */;
    assert!(
        target_policy >= caller_policy,
        error::invalid_argument(EDEP_WEAKER_POLICY)
    );
}
```

## Proof of Concept

```move
// Module A: Claims to be immutable but has hidden dependency
module 0xattacker::immutable_vault {
    use aptos_framework::function_info;
    use aptos_framework::fungible_asset::{Self, FungibleAsset};
    use std::string;
    
    struct VaultController has key {
        withdraw_auth: FunctionInfo,  // Hidden reference to arbitrary module
    }
    
    fun init_module(deployer: &signer) {
        // Create reference to Module B (arbitrary policy) 
        // WITHOUT declaring it as dependency!
        let malicious_auth = function_info::new_function_info(
            deployer,
            string::utf8(b"mutable_backdoor"),  // Module B
            string::utf8(b"authorize_withdraw")
        );
        
        move_to(deployer, VaultController {
            withdraw_auth: malicious_auth
        });
    }
    
    public fun withdraw(user: &signer, amount: u64): FungibleAsset 
    acquires VaultController {
        let controller = borrow_global<VaultController>(@0xattacker);
        
        // Dispatch to Module B for authorization
        // Module B can be upgraded to always return true!
        function_info::load_module_from_function(&controller.withdraw_auth);
        // ... dispatch logic using controller.withdraw_auth
        
        // Withdraw funds (authorization was bypassed)
        fungible_asset::withdraw(user, /* ... */)
    }
}

// Module B: Arbitrary upgrade policy - can be changed anytime
module 0xattacker::mutable_backdoor {
    public fun authorize_withdraw(
        user: &signer,
        amount: u64,
        // ... function info parameter
    ): bool {
        // BEFORE ATTACK: Legitimate authorization logic
        // check_user_permissions(user, amount)
        
        // AFTER ATTACK: Upgraded to always authorize attacker
        true  // Attacker can now withdraw all funds!
    }
}

// Package metadata for Module A claims:
// upgrade_policy: immutable (policy = 2)
// deps: [] (no dependencies declared!)

// Package metadata for Module B:
// upgrade_policy: arbitrary (policy = 0)
// This allows free upgrades to malicious logic
```

**Exploitation Steps:**
1. Publish Module A with `upgrade_policy: immutable`, Module B with `upgrade_policy: arbitrary`
2. Users deposit funds into Module A, trusting its immutability
3. Attacker calls `code::publish_package` to upgrade Module B with malicious `authorize_withdraw`
4. Attacker calls `immutable_vault::withdraw` to drain all user funds
5. The "immutable" vault's behavior changed through the hidden dependency

**Notes:**
- This bypasses the check at line 316-318 in code.move because Module B is not in Module A's declared `deps`
- The validation at line 1699-1714 in aptos_vm.rs only checks `immediate_dependencies()` from bytecode, which doesn't include `FunctionInfo` references
- No runtime check prevents this because `check_dispatch_type_compatibility_impl` only validates type signatures, not policies (lines 126-133 in function_info.rs)

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L295-344)
```text
    /// Check that the upgrade policies of all packages are equal or higher quality than this package. Also
    /// compute the list of module dependencies which are allowed by the package metadata. The later
    /// is passed on to the native layer to verify that bytecode dependencies are actually what is pretended here.
    fun check_dependencies(publish_address: address, pack: &PackageMetadata): vector<AllowedDep>
    acquires PackageRegistry {
        let allowed_module_deps = vector::empty();
        let deps = &pack.deps;
        vector::for_each_ref(deps, |dep| {
            let dep: &PackageDep = dep;
            assert!(exists<PackageRegistry>(dep.account), error::not_found(EPACKAGE_DEP_MISSING));
            if (is_policy_exempted_address(dep.account)) {
                // Allow all modules from this address, by using "" as a wildcard in the AllowedDep
                let account: address = dep.account;
                let module_name = string::utf8(b"");
                vector::push_back(&mut allowed_module_deps, AllowedDep { account, module_name });
            } else {
                let registry = borrow_global<PackageRegistry>(dep.account);
                let found = vector::any(&registry.packages, |dep_pack| {
                    let dep_pack: &PackageMetadata = dep_pack;
                    if (dep_pack.name == dep.package_name) {
                        // Check policy
                        assert!(
                            dep_pack.upgrade_policy.policy >= pack.upgrade_policy.policy,
                            error::invalid_argument(EDEP_WEAKER_POLICY)
                        );
                        if (dep_pack.upgrade_policy == upgrade_policy_arbitrary()) {
                            assert!(
                                dep.account == publish_address,
                                error::invalid_argument(EDEP_ARBITRARY_NOT_SAME_ADDRESS)
                            )
                        };
                        // Add allowed deps
                        let account = dep.account;
                        let k = 0;
                        let r = vector::length(&dep_pack.modules);
                        while (k < r) {
                            let module_name = vector::borrow(&dep_pack.modules, k).name;
                            vector::push_back(&mut allowed_module_deps, AllowedDep { account, module_name });
                            k = k + 1;
                        };
                        true
                    } else {
                        false
                    }
                });
                assert!(found, error::not_found(EPACKAGE_DEP_MISSING));
            };
        });
        allowed_module_deps
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1699-1714)
```rust
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
```

**File:** aptos-move/framework/aptos-framework/sources/function_info.move (L35-53)
```text
    public fun new_function_info_from_address(
        module_address: address,
        module_name: String,
        function_name: String,
    ): FunctionInfo {
        assert!(
            is_identifier(string::bytes(&module_name)),
            EINVALID_IDENTIFIER
        );
        assert!(
            is_identifier(string::bytes(&function_name)),
            EINVALID_IDENTIFIER
        );
        FunctionInfo {
            module_address,
            module_name,
            function_name,
        }
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L104-120)
```rust
        let init_func_name = ident_str!("init_module");
        for module in modules {
            // INVARIANT:
            //   We have charged for the old version (if it exists) before when pre-processing the
            //   module bundle. We have also charged for the new versions as well.
            if features.is_lazy_loading_enabled() {
                traversal_context
                    .check_is_special_or_visited(module.self_addr(), module.self_name())
                    .map_err(|err| err.finish(Location::Undefined))?;
            }

            if module_storage
                .unmetered_check_module_exists(module.self_addr(), module.self_name())?
            {
                // Module existed before, so do not run initialization.
                continue;
            }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L376-392)
```text
        // Verify that caller type matches callee type so wrongly typed function cannot be registered.
        withdraw_function.for_each_ref(|withdraw_function| {
                let dispatcher_withdraw_function_info =
                    function_info::new_function_info_from_address(
                        @aptos_framework,
                        string::utf8(b"dispatchable_fungible_asset"),
                        string::utf8(b"dispatchable_withdraw")
                    );

                assert!(
                    function_info::check_dispatch_type_compatibility(
                        &dispatcher_withdraw_function_info,
                        withdraw_function
                    ),
                    error::invalid_argument(EWITHDRAW_FUNCTION_SIGNATURE_MISMATCH)
                );
            });
```

**File:** aptos-move/framework/src/natives/function_info.rs (L126-133)
```rust
    Ok(smallvec![Value::bool(
        rhs.ty_param_abilities() == lhs.ty_param_abilities()
            && rhs.return_tys() == lhs.return_tys()
            && &lhs.param_tys()[0..lhs.param_count() - 1] == rhs.param_tys()
            && rhs.is_public()
            && !rhs.is_native()
            && lhs_id != rhs_id
    )])
```

**File:** aptos-move/move-examples/bonding_curve_launchpad/sources/bonding_curve_launchpad.move (L46-66)
```text
    fun init_module(account: &signer) {
        // Create and store the permissioned_withdraw function (global freezing based on FA status) while access to
        // the account signer is available.
        let permissioned_withdraw = function_info::new_function_info(
            account,
            string::utf8(b"bonding_curve_launchpad"),
            string::utf8(b"withdraw")
        );
        // Since the account signer can't be placed in storage, we'll use an object and it's retrievable signer for any
        // required signer usage. Primarily, when generating new Fungible Assets.
        let fa_generator_extend_ref = object::generate_extend_ref(
            &object::create_named_object(account, b"FA Generator")
        );
        move_to(
            account,
            LaunchPad {
                permissioned_withdraw,
                fa_generator_extend_ref
            }
        );
    }
```
