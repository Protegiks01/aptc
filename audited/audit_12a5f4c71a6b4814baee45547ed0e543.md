# Audit Report

## Title
Memory Exhaustion DoS via Unbounded File Reading in Secure Backend Configuration

## Summary
The `read_file()` function in `config/src/config/secure_backend_config.rs` uses `read_to_string()` without size limits, allowing arbitrary file sizes to be loaded into memory during node startup. This can cause memory exhaustion and node crash when large files or device files (e.g., `/dev/zero`, `/dev/urandom`, `/dev/sda`) are specified in the VaultConfig or Token configuration paths. [1](#0-0) 

## Finding Description
The vulnerability exists in the `read_file()` helper function which is called during secure storage initialization. This function opens a file and attempts to read its entire contents into a String without any size validation or limits.

The function is invoked in two security-critical paths:

1. **CA Certificate Loading**: When VaultConfig specifies a CA certificate path, the `ca_certificate()` method calls `read_file()` to load the certificate. [2](#0-1) 

2. **Token Loading**: When Token is configured via `FromDisk` variant, the `read_token()` method calls `read_file()` to load the authentication token. [3](#0-2) 

Both paths are triggered during the `Storage::from(&SecureBackend)` conversion, which is called when initializing secure storage backends for SafetyRules (consensus critical component) and other validator operations. [4](#0-3) 

**Attack Scenario**:
If a validator operator accidentally misconfigures the `ca_certificate` or `token.from_disk` path to point to:
- `/dev/zero` - infinite stream of null bytes
- `/dev/urandom` - infinite stream of random data  
- `/dev/sda` or `/dev/nvme0n1` - raw disk device (potentially hundreds of GB)
- Very large log files or system files

The node will attempt to read the entire file into memory during startup, causing:
- Memory exhaustion and OOM killer termination
- Node hang/freeze while attempting to allocate memory
- Failure to start, resulting in validator unavailability

## Impact Explanation
This qualifies as **High Severity** under Aptos Bug Bounty criteria: "Validator node slowdowns" and "API crashes".

The impact includes:
- **Validator Node Unavailability**: The node fails to start, preventing the validator from participating in consensus
- **Memory Exhaustion**: Can crash the entire system if OOM killer is triggered
- **Network Liveness Impact**: If multiple validators are affected by the same misconfiguration (e.g., using a common deployment template), this could impact network liveness

While this doesn't directly compromise consensus safety or cause fund loss, it violates the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits."

## Likelihood Explanation
**Likelihood: LOW to MEDIUM**

This vulnerability can be triggered through:

1. **Accidental Misconfiguration**: Validator operators might accidentally specify incorrect paths during setup or maintenance. Common mistakes include:
   - Typos in file paths pointing to device files
   - Copy-paste errors from documentation or templates
   - Automated deployment scripts with incorrect path variables

2. **Compromised Configuration**: If an attacker gains write access to the node's configuration file (through a separate vulnerability or system compromise), they can intentionally point paths to large files to DoS the node.

The likelihood is reduced by:
- Configuration files are typically managed by experienced validator operators
- The issue is immediately apparent during node startup (fail-fast)
- Validators typically test configurations in staging environments first

However, defense-in-depth principles suggest protecting against operator errors, especially in a production blockchain environment where validator availability is critical.

## Recommendation
Implement a maximum file size limit for files read by `read_file()`. The limit should be appropriate for the expected content (CA certificates are typically < 10KB, tokens are typically < 1KB).

**Recommended Fix**:
```rust
const MAX_FILE_SIZE_BYTES: u64 = 1024 * 1024; // 1 MB should be more than sufficient

fn read_file(path: &Path) -> Result<String, Error> {
    let mut file = File::open(path)
        .map_err(|e| Error::IO(path.to_str().unwrap().to_string(), e))?;
    
    // Check file size before reading
    let metadata = file.metadata()
        .map_err(|e| Error::IO(path.to_str().unwrap().to_string(), e))?;
    
    if metadata.len() > MAX_FILE_SIZE_BYTES {
        return Err(Error::InvariantViolation(format!(
            "File too large: {} bytes (max: {} bytes). Path: {:?}",
            metadata.len(),
            MAX_FILE_SIZE_BYTES,
            path
        )));
    }
    
    let mut contents = String::new();
    file.read_to_string(&mut contents)
        .map_err(|e| Error::IO(path.to_str().unwrap().to_string(), e))?;
    
    Ok(contents)
}
```

Additionally, consider validating that the path is a regular file (not a device file or named pipe) before attempting to read it.

## Proof of Concept

**Setup**: Create a validator node configuration that points the CA certificate to a device file:

```yaml
# malicious_validator.yaml
base:
  role: validator
  data_dir: "/opt/aptos/data"

consensus:
  safety_rules:
    backend:
      type: vault
      server: "http://localhost:8200"
      token:
        from_config: "test_token"
      ca_certificate: "/dev/zero"  # Points to infinite zero stream
```

**Reproduction Steps**:
1. Create the malicious configuration file as shown above
2. Start the aptos-node with this configuration:
   ```bash
   aptos-node -f malicious_validator.yaml
   ```
3. Monitor memory usage: `watch -n 1 'free -h'`

**Expected Result**: The node process will continuously allocate memory attempting to read from `/dev/zero`, eventually triggering OOM killer or system hang.

**Alternative PoC with actual large file**:
```bash
# Create a 10GB sparse file
dd if=/dev/zero of=/tmp/large_cert.pem bs=1M count=10240

# Update config to point to this file
sed -i 's|ca_certificate: .*|ca_certificate: "/tmp/large_cert.pem"|' validator.yaml

# Attempt to start node - it will hang/crash
aptos-node -f validator.yaml
```

## Notes
While validator operators are considered trusted actors in the Aptos threat model, defense-in-depth principles dictate that the system should protect against operational errors and misconfigurations. File size limits are a standard security practice in production systems handling file I/O, especially in security-critical components like consensus SafetyRules initialization.

### Citations

**File:** config/src/config/secure_backend_config.rs (L76-84)
```rust
impl VaultConfig {
    pub fn ca_certificate(&self) -> Result<String, Error> {
        let path = self
            .ca_certificate
            .as_ref()
            .ok_or(Error::Missing("ca_certificate"))?;
        read_file(path)
    }
}
```

**File:** config/src/config/secure_backend_config.rs (L108-115)
```rust
impl Token {
    pub fn read_token(&self) -> Result<String, Error> {
        match self {
            Token::FromDisk(path) => read_file(path),
            Token::FromConfig(token) => Ok(token.clone()),
        }
    }
}
```

**File:** config/src/config/secure_backend_config.rs (L153-160)
```rust
fn read_file(path: &Path) -> Result<String, Error> {
    let mut file =
        File::open(path).map_err(|e| Error::IO(path.to_str().unwrap().to_string(), e))?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)
        .map_err(|e| Error::IO(path.to_str().unwrap().to_string(), e))?;
    Ok(contents)
}
```

**File:** config/src/config/secure_backend_config.rs (L174-186)
```rust
            SecureBackend::Vault(config) => {
                let storage = Storage::from(VaultStorage::new(
                    config.server.clone(),
                    config.token.read_token().expect("Unable to read token"),
                    config
                        .ca_certificate
                        .as_ref()
                        .map(|_| config.ca_certificate().unwrap()),
                    config.renew_ttl_secs,
                    config.disable_cas.map_or_else(|| true, |disable| !disable),
                    config.connection_timeout_ms,
                    config.response_timeout_ms,
                ));
```
