# Audit Report

## Title
Supply Chain Attack via Automatic Git Branch Dependency Updates in Move Package Manager

## Summary
The Move package manager automatically fetches and updates branch-based git dependencies during each build without explicit user consent or cryptographic verification, enabling supply chain attacks. An attacker who compromises a dependency's git repository can inject malicious code that will be automatically incorporated into downstream projects, including critical Aptos validator nodes and framework packages.

## Finding Description

The Move CLI build system in `build.rs` delegates to `BuildConfig::compile_package()` which resolves dependencies through `ResolutionGraph`. When processing git dependencies, the system implements different update behaviors based on the revision type (commit hash, tag, or branch). [1](#0-0) 

The critical vulnerability lies in the dependency update logic: [2](#0-1) 

The code implements the following logic:
1. For commit hashes: Skips updates (safe)
2. For tags: Checks local tags and skips updates (safe)  
3. For branches: **Automatically fetches and resets to the latest remote version**

The branch update mechanism uses: [3](#0-2) [4](#0-3) 

The `skip_fetch_latest_git_deps` flag defaults to `false`, meaning automatic updates are enabled by default: [5](#0-4) 

**Attack Scenario:**
1. A Move package depends on `LibraryX` with `git = "https://github.com/trusted/libx", rev = "main"`
2. User builds their project, cloning `LibraryX` at commit A (benign)
3. Attacker compromises the `trusted/libx` repository
4. Attacker pushes commit B containing malicious Move code to the `main` branch
5. User rebuilds their project (routine operation)
6. System automatically runs `git fetch origin` and `git reset --hard origin/main`
7. Malicious code from commit B is now incorporated into the user's build

There is **no cryptographic verification** of git commits or tags: [6](#0-5) 

Digest verification is **optional** and not enforced: [7](#0-6) 

This breaks the **Deterministic Execution** invariant: identical source code built at different times produces different binaries, violating the requirement that "all validators must produce identical state roots for identical blocks."

## Impact Explanation

**High Severity** - This vulnerability enables supply chain attacks affecting:

1. **Validator Infrastructure**: Malicious code injected into dependencies used by validator nodes could compromise consensus participation, leading to "significant protocol violations"

2. **Framework Packages**: The Aptos framework itself could depend on external Move libraries. Compromised dependencies could inject backdoors into core system contracts

3. **Non-Deterministic Builds**: Different validators building at different times would produce different bytecode, potentially causing consensus failures or state divergence

4. **Silent Compromise**: Unlike explicit dependency updates, this happens automatically during routine builds without user awareness or approval

While this doesn't directly cause "Loss of Funds" or "Consensus Safety violations" on its own, it provides the mechanism for attackers to inject code that could achieve these impacts. The automatic, silent nature and lack of cryptographic verification makes this a significant protocol-level security issue.

## Likelihood Explanation

**High Likelihood** because:

1. **Common Practice**: Many Move projects use branch-based dependencies (e.g., `rev = "main"`) for development convenience
2. **Default Behavior**: Automatic fetching is enabled by default (`skip_fetch_latest_git_deps: false`)
3. **Routine Trigger**: Every build triggers the update check, not requiring special user action
4. **Known Attack Vector**: Repository compromise is a proven supply chain attack method (SolarWinds, CodeCov, etc.)
5. **No Warnings**: Users are not warned about the security implications of branch-based dependencies

Attack Requirements:
- Compromise a git repository used as a dependency (OR man-in-the-middle during fetch)
- Wait for downstream users to rebuild their projects

## Recommendation

Implement a multi-layered defense:

1. **Enforce Immutable Dependencies for Production**:
   - Warn users when branch-based dependencies are detected
   - Require `--allow-mutable-deps` flag to proceed with branch dependencies
   - Document that only tags or commit hashes should be used in production

2. **Implement Cryptographic Verification**:
   - Add optional GPG signature verification for git tags and commits
   - Verify signatures against a trusted keyring
   - Add configuration option: `verify_git_signatures: true`

3. **Make Digest Verification Mandatory**:
   - Require `digest` field for all dependencies in production builds
   - Auto-generate digests and prompt user to add them to Move.toml
   - Fail builds if digest mismatches

4. **Change Default Behavior**:
   - Set `skip_fetch_latest_git_deps: true` as the default
   - Require explicit `--update-deps` flag to fetch latest versions
   - Add lockfile mechanism similar to Cargo.lock

5. **Audit Logging**:
   - Log all dependency updates with timestamps and commit hashes
   - Alert when cached dependencies are modified

Example code fix for warning users:

```rust
fn download_and_update_if_remote<W: Write>(
    dep_name: PackageName,
    dep: &Dependency,
    skip_fetch_latest_git_deps: bool,
    writer: &mut W,
) -> Result<()> {
    if let Some(git_info) = &dep.git_info {
        let git_rev = git_info.git_rev.as_str();
        
        // Check if this is a branch (not a commit hash or tag)
        if !git_rev.chars().all(|c| c.is_ascii_hexdigit()) {
            if let Ok(tag) = git::find_tag(git_path, git_rev) {
                // It's a tag, safe
            } else {
                // Likely a branch - warn user
                writeln!(
                    writer,
                    "{} Dependency '{}' uses branch '{}' which will auto-update. \
                     For production, use a commit hash or tag instead.",
                    "WARNING:".bold().yellow(),
                    dep_name,
                    git_rev
                )?;
            }
        }
        
        // Rest of existing logic...
    }
    Ok(())
}
```

## Proof of Concept

**Setup:**
1. Create a malicious git repository with two commits:
   - Commit A: Benign Move module
   - Commit B: Modified module with backdoor code

2. Create a Move project depending on this repository at branch `main`

3. Build the project (gets commit A)

4. Force-push commit B to `main`

5. Rebuild the project

**Expected Result**: Project automatically fetches and incorporates commit B without user intervention or warning.

**PoC Script** (pseudo-code):

```bash
#!/bin/bash

# Setup malicious repo
git init malicious-lib
cd malicious-lib
# Create benign version
echo "module 0x1::Lib { public fun safe() {} }" > sources/lib.move
git add . && git commit -m "Benign version"
git tag v1.0.0
COMMIT_A=$(git rev-parse HEAD)

# Create victim project
cd ..
mkdir victim-project
cat > victim-project/Move.toml << EOF
[package]
name = "VictimProject"
version = "0.0.1"

[dependencies]
MaliciousLib = { git = "file://$(pwd)/malicious-lib", rev = "main" }
EOF

# First build (benign)
cd victim-project
move build
echo "First build complete with commit: $COMMIT_A"

# Attacker compromises repo
cd ../malicious-lib
echo "module 0x1::Lib { public fun safe() { abort 999 } }" > sources/lib.move
git add . && git commit -m "Malicious version"
COMMIT_B=$(git rev-parse HEAD)

# Victim rebuilds
cd ../victim-project
move build
echo "Second build complete with commit: $COMMIT_B"
echo "Malicious code automatically incorporated!"
```

This demonstrates that branch-based dependencies are automatically updated, allowing post-download repository manipulation to inject malicious code.

## Notes

- **Tag-based dependencies ARE protected**: The code correctly skips updates for local tags, so manipulating remote tags after initial download does not affect cached dependencies using tags
- **Commit hash dependencies ARE protected**: Updates are skipped for commit hashes
- **Branch dependencies ARE vulnerable**: This is the exploitable attack vector
- The vulnerability is in the **design and default configuration**, not a traditional implementation bug
- Affects any Move project using branch-based git dependencies, including potential Aptos infrastructure components

### Citations

**File:** third_party/move/tools/move-cli/src/base/build.rs (L15-27)
```rust
    pub fn execute(self, path: Option<PathBuf>, config: BuildConfig) -> anyhow::Result<()> {
        let rerooted_path = reroot_path(path)?;
        if config.fetch_deps_only {
            let mut config = config;
            if config.test_mode {
                config.dev_mode = true;
            }
            config.download_deps_for_package(&rerooted_path, &mut std::io::stdout())?;
            return Ok(());
        }
        config.compile_package(&rerooted_path, &mut std::io::stdout())?;
        Ok(())
    }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L456-472)
```rust
        match dep.digest {
            None => (),
            Some(fixed_digest) => {
                let resolved_pkg = self
                    .package_table
                    .get(&dep_name_in_pkg)
                    .context("Unable to find resolved package by name")?;
                if fixed_digest != resolved_pkg.source_digest {
                    bail!(
                        "Source digest mismatch in dependency '{}'. Expected '{}' but got '{}'.",
                        dep_name_in_pkg,
                        fixed_digest,
                        resolved_pkg.source_digest
                    )
                }
            },
        }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L551-616)
```rust
    fn download_and_update_if_remote<W: Write>(
        dep_name: PackageName,
        dep: &Dependency,
        skip_fetch_latest_git_deps: bool,
        writer: &mut W,
    ) -> Result<()> {
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();

            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
            } else if !skip_fetch_latest_git_deps {
                // Confirm git is available.
                git::confirm_git_available()?;

                // Update the git dependency
                // Check first that it isn't a git rev (if it doesn't work, just continue with the fetch)
                if let Ok(parsed_rev) = git::find_rev(git_path, git_rev) {
                    // If it's exactly the same, then it's a git rev
                    if parsed_rev.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                if let Ok(tag) = git::find_tag(git_path, git_rev) {
                    // If it's exactly the same, then it's a git tag, for now tags won't be updated
                    // Tags don't easily update locally and you can't use reset --hard to cleanup
                    // any extra files
                    if tag.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                writeln!(
                    writer,
                    "{} {}",
                    "UPDATING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;
                // If the current folder exists, do a fetch and reset to ensure that the branch
                // is up to date
                // NOTE: this means that you must run the package system with a working network connection
                git::fetch_origin(git_path, dep_name)?;
                git::reset_hard(git_path, git_rev, dep_name)?;
            }
        }
        if let Some(node_info) = &dep.node_info {
            package_hooks::resolve_custom_dependency(dep_name, node_info)?
        }
        Ok(())
    }
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L70-95)
```rust
pub(crate) fn fetch_origin(repo_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args([
            "-C",
            repo_path,
            "fetch",
            "origin",
        ])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!(
                "Failed to fetch latest Git state for package '{}', to skip set --skip-fetch-latest-git-deps",
                dep_name
            )
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to fetch to latest Git state for package '{}', to skip set --skip-fetch-latest-git-deps | Exit status: {}",
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L97-125)
```rust
pub(crate) fn reset_hard(repo_path: &str, rev: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args([
            "-C",
            repo_path,
            "reset",
            "--hard",
            &format!("origin/{}", rev)
        ])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!(
                "Failed to reset to latest Git state '{}' for package '{}', to skip set --skip-fetch-latest-git-deps",
                rev,
                dep_name
            )
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to reset to latest Git state '{}' for package '{}', to skip set --skip-fetch-latest-git-deps | Exit status: {}",
            rev,
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** aptos-move/framework/src/built_package.rs (L130-132)
```rust
            // This is false by default, because it could accidentally pull new dependencies
            // while in a test (and cause some havoc)
            skip_fetch_latest_git_deps: false,
```
