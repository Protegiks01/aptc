# Audit Report

## Title
Incomplete Speculative Failure Propagation in Commit-Time Validation Functions

## Summary
The `non_delayed_field_speculative_failure` flag is not checked by `validate_aggregator_v1_reads()` and `validate_delayed_field_reads()` during commit-time validation, creating an inconsistency where these validations could succeed despite speculative execution failures detected in regular resource reads. [1](#0-0) [2](#0-1) 

## Finding Description

When transaction execution detects an inconsistent read (e.g., reading the same resource twice and getting different values due to concurrent modifications), the `capture_read()` function sets `non_delayed_field_speculative_failure = true`: [3](#0-2) 

This flag is properly checked by three validation functions:
- `validate_data_reads()` (checks at line 956-958)
- `validate_group_reads()` (checks at line 1098-1100)  
- `validate_module_reads()` (checks at line 1056-1058) [4](#0-3) 

However, two validation functions called during commit-time validation do NOT check this flag:

1. **`validate_aggregator_v1_reads()`** - Used exclusively in BlockSTMv2 for legacy aggregator validation: [5](#0-4) 

2. **`validate_delayed_field_reads()`** - Validates delayed field reads at commit time: [6](#0-5) 

Note that `validate_delayed_field_reads()` only checks `delayed_field_speculative_failure`, not `non_delayed_field_speculative_failure`.

These functions are called in `validate_and_commit_delayed_fields()`: [7](#0-6) 

### Exploitation Scenario

While the regular validation flow (via `validate()`) would catch transactions with `non_delayed_field_speculative_failure=true`, the commit-time validation creates a defense-in-depth violation:

1. A transaction executes and encounters an inconsistency in a regular resource read
2. `non_delayed_field_speculative_failure` is set to true in `CapturedReads`
3. If the execution doesn't result in `SpeculativeExecutionAbortError`, the `is_speculative_failure` flag in `TxnLastInputOutput` remains false
4. Regular validation catches the issue via `validate_data_reads()` which properly checks the flag
5. However, if validation logic changes, or if there's a code path where commit-time validation runs independently, `validate_aggregator_v1_reads()` and `validate_delayed_field_reads()` would succeed despite the speculative failure

The issue is exacerbated in BlockSTMv2 where aggregator v1 reads are validated separately from regular data reads at commit time only.

## Impact Explanation

This vulnerability represents a **High Severity** issue because:

1. **Consensus Safety Violation**: If commit-time validations succeed despite speculative failures, transactions could be committed with inconsistent read sets, causing different validators to commit different state roots for the same block, violating the "Deterministic Execution" invariant.

2. **Defense-in-Depth Failure**: The inconsistency creates a brittle validation architecture where changing the validation flow could introduce consensus bugs.

3. **BlockSTMv2 Specific Risk**: In BlockSTMv2, aggregator v1 reads are validated exclusively at commit time via `validate_aggregator_v1_reads()`, making this code path more critical.

While the current code flow appears to prevent direct exploitation (regular validation catches the issue first), this represents a significant code quality and safety issue that could lead to consensus divergence if:
- Future refactoring changes the validation order
- New execution paths bypass regular validation
- Race conditions cause validation state inconsistencies

## Likelihood Explanation

**Current Likelihood: Low-Medium** - The regular validation flow provides a safety net that prevents immediate exploitation.

**Future Likelihood: High** - Any refactoring of the validation flow, addition of new execution modes, or optimization that changes validation ordering could activate this latent bug.

The issue is particularly concerning because:
- It's a silent failure - no error would be raised
- It affects commit-time validation where consistency is most critical
- BlockSTMv2 introduces different validation flows that increase attack surface

## Recommendation

Add `non_delayed_field_speculative_failure` checks to both validation functions:

**For `validate_aggregator_v1_reads()`:**
```rust
pub(crate) fn validate_aggregator_v1_reads(
    &self,
    data_map: &VersionedData<T::Key, T::Value>,
    aggregator_write_keys: impl Iterator<Item = T::Key>,
    idx_to_validate: TxnIndex,
) -> Result<bool, PanicError> {
    // ADD THIS CHECK
    if self.non_delayed_field_speculative_failure {
        return Ok(false);
    }
    
    // ... rest of function
}
```

**For `validate_delayed_field_reads()`:**
```rust
pub(crate) fn validate_delayed_field_reads(
    &self,
    delayed_fields: &dyn TVersionedDelayedFieldView<DelayedFieldID>,
    idx_to_validate: TxnIndex,
) -> Result<bool, PanicError> {
    // MODIFY THIS CHECK
    if self.delayed_field_speculative_failure || self.non_delayed_field_speculative_failure {
        return Ok(false);
    }
    
    // ... rest of function
}
```

This ensures that ALL validation functions respect ALL speculative failure flags, maintaining consistency and defense-in-depth.

## Proof of Concept

The following test demonstrates that the flag is not checked:

```rust
#[test]
fn test_non_delayed_field_speculative_failure_not_checked_in_commit_validation() {
    let mut captured_reads = CapturedReads::<
        TestTransactionType,
        u32,
        MockDeserializedCode,
        MockVerifiedCode,
        MockExtension,
    >::new(Some(0)); // BlockSTMv2 mode
    
    let mvhashmap = MVHashMap::<KeyType<u32>, u32, ValueType, DelayedFieldID>::new();
    
    // Simulate speculative failure in non-delayed field
    captured_reads.non_delayed_field_speculative_failure = true;
    
    // Regular validation correctly returns false
    assert!(!captured_reads.validate_data_reads(mvhashmap.data(), 0));
    assert!(!captured_reads.validate_group_reads(mvhashmap.group_data(), 0));
    assert!(!captured_reads.validate_module_reads(&GlobalModuleCache::empty(), 
                                                   &SyncModuleCache::empty(), None));
    
    // BUG: Commit-time validations don't check the flag and return true!
    assert_ok_eq!(
        captured_reads.validate_delayed_field_reads(mvhashmap.delayed_fields(), 0),
        true  // Should be false!
    );
    
    // BUG: Aggregator v1 validation also doesn't check the flag
    assert_ok_eq!(
        captured_reads.validate_aggregator_v1_reads(
            mvhashmap.data(),
            std::iter::empty(),
            0
        ),
        true  // Should be false!
    );
}
```

This test can be added to `aptos-move/block-executor/src/captured_reads.rs` in the test module to verify the issue and confirm the fix.

## Notes

This finding represents a critical gap in the validation consistency checks. While the current execution flow provides protection through regular validation, the lack of flag checking in commit-time validation functions violates the principle of independent validation and creates technical debt that could manifest as a consensus bug under future changes. The fix is straightforward and should be applied to ensure all validation functions maintain consistent behavior regarding speculative failure handling.

### Citations

**File:** aptos-move/block-executor/src/captured_reads.rs (L808-810)
```rust
            UpdateResult::Inconsistency => {
                self.non_delayed_field_speculative_failure = true;
                Err(PanicOr::Or(()))
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L956-958)
```rust
        if self.non_delayed_field_speculative_failure {
            return false;
        }
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L966-1010)
```rust
    pub(crate) fn validate_aggregator_v1_reads(
        &self,
        data_map: &VersionedData<T::Key, T::Value>,
        aggregator_write_keys: impl Iterator<Item = T::Key>,
        idx_to_validate: TxnIndex,
    ) -> Result<bool, PanicError> {
        // Few aggregator v1 instances exist in the system (and legacy now, deprecated
        // by DelayedFields), hence the efficiency of construction below is not a concern.
        let mut aggregator_v1_iterable = Vec::with_capacity(self.aggregator_v1_reads.len());
        for k in &self.aggregator_v1_reads {
            match self.data_reads.get(k) {
                Some(data_read) => aggregator_v1_iterable.push((k, data_read)),
                None => {
                    return Err(code_invariant_error(format!(
                        "Aggregator v1 read {:?} not found among captured data reads",
                        k
                    )));
                },
            }
        }

        let ret = self.validate_data_reads_impl(
            aggregator_v1_iterable.into_iter(),
            data_map,
            idx_to_validate,
        );

        if ret {
            // Additional invariant check (that AggregatorV1 reads are captured for
            // aggregator write keys). This protects against the case where aggregator v1
            // state value read was read by a wrong interface (e.g. via resource API).
            for key in aggregator_write_keys {
                if self.data_reads.contains_key(&key) && !self.aggregator_v1_reads.contains(&key) {
                    // Not assuming read-before-write here: if there was a read, it must also be
                    // captured as an aggregator_v1 read.
                    return Err(code_invariant_error(format!(
                        "Captured read at aggregator key {:?} not found among AggregatorV1 reads",
                        key
                    )));
                }
            }
        }

        Ok(ret)
    }
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1142-1184)
```rust
    pub(crate) fn validate_delayed_field_reads(
        &self,
        delayed_fields: &dyn TVersionedDelayedFieldView<DelayedFieldID>,
        idx_to_validate: TxnIndex,
    ) -> Result<bool, PanicError> {
        if self.delayed_field_speculative_failure {
            return Ok(false);
        }

        use MVDelayedFieldsError::*;
        for (id, read_value) in &self.delayed_field_reads {
            match delayed_fields.read_latest_predicted_value(
                id,
                idx_to_validate,
                ReadPosition::BeforeCurrentTxn,
            ) {
                Ok(current_value) => match read_value {
                    DelayedFieldRead::Value { value, .. } => {
                        if value != &current_value {
                            return Ok(false);
                        }
                    },
                    DelayedFieldRead::HistoryBounded {
                        restriction,
                        max_value,
                        ..
                    } => match restriction.validate_against_base_value(
                        current_value.into_aggregator_value()?,
                        *max_value,
                    ) {
                        Ok(_) => {},
                        Err(_) => {
                            return Ok(false);
                        },
                    },
                },
                Err(NotFound) | Err(Dependency(_)) | Err(DeltaApplicationFailure) => {
                    return Ok(false);
                },
            }
        }
        Ok(true)
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L860-870)
```rust
        if !read_set.validate_delayed_field_reads(versioned_cache.delayed_fields(), txn_idx)?
            || (is_v2
                && !read_set.validate_aggregator_v1_reads(
                    versioned_cache.data(),
                    last_input_output
                        .modified_aggregator_v1_keys(txn_idx)
                        .ok_or_else(|| {
                            code_invariant_error("Modified aggregator v1 keys must be recorded")
                        })?,
                    txn_idx,
                )?)
```
