# Audit Report

## Title
Database Corruption via Non-Atomic Save and Skipped Recovery in Backup Restore

## Summary
The `restore_handler.save_transactions` operation at line 508 in `restore.rs` is **not atomic** and performs two separate database commits (state KV, then ledger). If interrupted between these commits, the database enters an inconsistent state. Critically, the backup restore process opens the database with `empty_buffered_state_for_restore=true`, which **skips the recovery mechanism** (`sync_commit_progress`) designed to fix such inconsistencies, leading to permanent database corruption and potential consensus violations.

## Finding Description

The vulnerability exists in the backup restore workflow and violates the **State Consistency** invariant (#4): "State transitions must be atomic and verifiable via Merkle proofs."

### Root Cause Analysis

**Non-Atomic Commits**: The `save_transactions` function performs two separate database commits that are not atomic together: [1](#0-0) 

This code first commits the state KV database, then commits the ledger database. These are two independent RocksDB write operations with no transactional wrapper.

**Skipped Recovery Mechanism**: When the backup restore process initializes the database, it uses `AptosDB::open_kv_only`: [2](#0-1) 

This function passes `empty_buffered_state_for_restore=true`: [3](#0-2) 

Which causes `StateStore::new` to **skip** the critical `sync_commit_progress` recovery mechanism: [4](#0-3) 

The `sync_commit_progress` function is designed to fix exactly this type of inconsistency by truncating databases to match `OverallCommitProgress`: [5](#0-4) 

### Attack Scenario

1. **Restore Process Begins**: Operator starts backup restore on a fresh node
2. **First Chunk Processing**: `save_transactions` is called for versions 101-110
3. **Partial Commit**: State KV DB commits successfully (StateKvCommitProgress=110), but process crashes before ledger DB commit completes (OverallCommitProgress remains at 100)
4. **Inconsistent State**: Database now has:
   - State KV data at versions 101-110 with StateKvCommitProgress=110
   - Ledger DB with OverallCommitProgress=100
   - **This violates the invariant that OverallCommitProgress is the source of truth**
5. **Restore Restart**: Operator restarts the restore process
6. **Recovery Skipped**: Database opens with `empty_buffered_state_for_restore=true`, **skipping** `sync_commit_progress`
7. **Incorrect Version Detection**: `get_next_expected_transaction_version()` reads OverallCommitProgress=100, returns version 101: [6](#0-5) [7](#0-6) 

8. **Corruption Propagates**: Restore continues writing transactions from version 101 onwards, but state KV already has (potentially different) data at these versions
9. **Permanent Inconsistency**: Once OverallCommitProgress eventually advances past 110, the inconsistency becomes permanent

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple Critical severity criteria:

1. **Consensus/Safety Violations**: If multiple validators restore from backups and experience partial commits at different points, they will have different state KV data for the same versions. This leads to **non-deterministic state roots** and consensus divergence when they start participating in the network.

2. **Non-Recoverable Network Partition**: Once the corrupted database is committed beyond the inconsistent region, there is no automatic recovery mechanism. The inconsistency persists permanently, potentially requiring manual intervention or hard fork.

3. **State Consistency Violation**: The fundamental invariant that `OverallCommitProgress` represents the authoritative committed version is violated. State KV contains data beyond this progress marker, breaking all downstream assumptions.

The vulnerability affects:
- **All validators** performing backup restores (common during node setup, disaster recovery, or catching up)
- **Network consensus** if validators end up with divergent states
- **Data integrity** across the entire blockchain state

## Likelihood Explanation

**High Likelihood** due to:

1. **Common Operation**: Backup restore is a standard operational procedure for:
   - Setting up new validator nodes
   - Recovering from hardware failures  
   - Migrating infrastructure
   - Catching up after extended downtime

2. **Easy to Trigger**: Any interruption during the critical window (between state KV commit and ledger DB commit) triggers the bug:
   - Process crashes (OOM, segfault, signal)
   - Hardware failures (disk errors, power loss)
   - Operator interruption (SIGKILL, container termination)
   - Network storage issues

3. **No Automatic Detection**: The inconsistency is silent - no error is raised when the database reopens, and the restore continues with corrupted state.

4. **Persistent Across Restarts**: Once the inconsistency exists, it persists through all subsequent database opens because recovery is skipped.

## Recommendation

**Immediate Fix**: Do NOT skip `sync_commit_progress` during backup restore initialization. The recovery mechanism should ALWAYS run to ensure database consistency.

**Code Fix**:

In `storage/aptosdb/src/state_store/mod.rs`, modify the condition to always run recovery for non-test scenarios:

```rust
// OLD (vulnerable):
if !hack_for_tests && !empty_buffered_state_for_restore {
    Self::sync_commit_progress(...)
}

// NEW (fixed):
if !hack_for_tests {
    Self::sync_commit_progress(
        Arc::clone(&ledger_db),
        Arc::clone(&state_kv_db),
        Arc::clone(&state_merkle_db),
        /*crash_if_difference_is_too_large=*/ true,
    );
}
```

The `empty_buffered_state_for_restore` flag should ONLY control whether to create an empty buffered state (line 376-395), not whether to run critical recovery procedures.

**Alternative Approach**: Make the commits truly atomic using a two-phase commit protocol or write-ahead logging, but this requires more extensive changes to the storage layer.

**Additional Hardening**:
1. Add explicit consistency checks before restore continues
2. Log warnings when StateKvCommitProgress != OverallCommitProgress
3. Consider adding a progress marker specifically for restore operations

## Proof of Concept

**Reproduction Steps**:

```rust
// 1. Simulate partial commit during restore
use aptos_db::AptosDB;
use aptos_backup_cli::backup_types::transaction::restore::TransactionRestoreController;

#[test]
fn test_partial_commit_corruption() {
    // Setup: Create a database and populate with initial state
    let db_path = TempPath::new();
    let db = AptosDB::new_for_test(&db_path);
    
    // Populate initial versions 0-100
    populate_transactions(&db, 0, 100);
    
    // Close database
    drop(db);
    
    // Simulate partial commit by manually corrupting state
    // Open database directly and write state KV data for versions 101-110
    // without updating OverallCommitProgress
    let state_kv_db = StateKvDb::open_sharded(&db_path, ...);
    let mut batch = state_kv_db.new_sharded_native_batches();
    
    // Write state KV for versions 101-110
    for version in 101..=110 {
        write_test_state_value(&mut batch, version);
    }
    state_kv_db.commit(110, None, batch).unwrap();
    
    // OverallCommitProgress is still 100!
    
    // Now open database for restore (this is the bug - recovery is skipped)
    let db = AptosDB::open_kv_only(
        db_path,
        false, // readonly
        NO_OP_STORAGE_PRUNER_CONFIG,
        default_rocksdb_configs(),
        false, // enable_indexer
        BUFFERED_STATE_TARGET_ITEMS,
        DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD,
        None, // internal_indexer_db
    ).unwrap();
    
    // Check: get_synced_version should return 100, but state KV has data up to 110
    let synced_version = db.get_synced_version().unwrap().unwrap();
    assert_eq!(synced_version, 100); // OverallCommitProgress
    
    // But state KV has data at version 110!
    let state_value = db.state_store.get_state_value_by_version(&test_key(), 110);
    assert!(state_value.is_ok() && state_value.unwrap().is_some()); // Data exists!
    
    // This inconsistency will cause corruption when restore continues
    let restore_handler = db.get_restore_handler();
    
    // Next call to save_transactions will try to write from version 101 again!
    // This demonstrates the corruption vulnerability
}
```

**Verification**: Run the test to confirm that state KV contains data beyond OverallCommitProgress after the partial commit simulation, demonstrating the persistence of inconsistency through database reopening with `empty_buffered_state_for_restore=true`.

## Notes

This vulnerability is particularly insidious because:
1. It only manifests during operational procedures (backup restore), not normal operation
2. The inconsistency is silent and may not be detected until consensus divergence occurs
3. The fix (removing the recovery skip) was likely an optimization to speed up restore, but it sacrifices correctness for performance
4. The system was designed with proper recovery mechanisms (`sync_commit_progress`), but they're being bypassed in the exact scenario where they're most needed

### Citations

**File:** storage/aptosdb/src/backup/restore_utils.rs (L164-172)
```rust
        // get the last version and commit to the state kv db
        // commit the state kv before ledger in case of failure happens
        let last_version = first_version + txns.len() as u64 - 1;
        state_store
            .state_db
            .state_kv_db
            .commit(last_version, None, sharded_kv_schema_batch)?;

        ledger_db.write_schemas(ledger_db_batch)?;
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L305-315)
```rust
            let restore_handler = Arc::new(AptosDB::open_kv_only(
                StorageDirPaths::from_path(db_dir),
                false,                       /* read_only */
                NO_OP_STORAGE_PRUNER_CONFIG, /* pruner config */
                opt.rocksdb_opt.clone().into(),
                false, /* indexer */
                BUFFERED_STATE_TARGET_ITEMS,
                DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD,
                internal_indexer_db,
            )?)
            .get_restore_handler();
```

**File:** storage/aptosdb/src/db/mod.rs (L82-103)
```rust
    pub fn open_kv_only(
        db_paths: StorageDirPaths,
        readonly: bool,
        pruner_config: PrunerConfig,
        rocksdb_configs: RocksdbConfigs,
        enable_indexer: bool,
        buffered_state_target_items: usize,
        max_num_nodes_per_lru_cache_shard: usize,
        internal_indexer_db: Option<InternalIndexerDB>,
    ) -> Result<Self> {
        Self::open_internal(
            &db_paths,
            readonly,
            pruner_config,
            rocksdb_configs,
            enable_indexer,
            buffered_state_target_items,
            max_num_nodes_per_lru_cache_shard,
            true,
            internal_indexer_db,
            HotStateConfig::default(),
        )
```

**File:** storage/aptosdb/src/state_store/mod.rs (L353-359)
```rust
        if !hack_for_tests && !empty_buffered_state_for_restore {
            Self::sync_commit_progress(
                Arc::clone(&ledger_db),
                Arc::clone(&state_kv_db),
                Arc::clone(&state_merkle_db),
                /*crash_if_difference_is_too_large=*/ true,
            );
```

**File:** storage/aptosdb/src/state_store/mod.rs (L410-467)
```rust
    pub fn sync_commit_progress(
        ledger_db: Arc<LedgerDb>,
        state_kv_db: Arc<StateKvDb>,
        state_merkle_db: Arc<StateMerkleDb>,
        crash_if_difference_is_too_large: bool,
    ) {
        let ledger_metadata_db = ledger_db.metadata_db();
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");

            // State K/V commit progress isn't (can't be) written atomically with the data,
            // because there are shards, so we have to attempt truncation anyway.
            info!(
                state_kv_commit_progress = state_kv_commit_progress,
                "Start state KV truncation..."
            );
            let difference = state_kv_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_state_kv_db(
                &state_kv_db,
                state_kv_commit_progress,
                overall_commit_progress,
                std::cmp::max(difference as usize, 1), /* batch_size */
            )
            .expect("Failed to truncate state K/V db.");
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L128-130)
```rust
    pub fn get_next_expected_transaction_version(&self) -> Result<Version> {
        Ok(self.aptosdb.get_synced_version()?.map_or(0, |ver| ver + 1))
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L76-78)
```rust
    pub(crate) fn get_synced_version(&self) -> Result<Option<Version>> {
        get_progress(&self.db, &DbMetadataKey::OverallCommitProgress)
    }
```
