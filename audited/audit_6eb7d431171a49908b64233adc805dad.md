# Audit Report

## Title
Governance Deadlock via Unconstrained min_voting_threshold Configuration

## Summary
The `min_voting_threshold` parameter (u128) used in governance proposal validation is only validated against the total AptosCoin supply, not against the actual total staked voting power. This allows `min_voting_threshold` to be set to a value that exceeds the maximum achievable voting power, causing permanent governance deadlock where proposals can be created but never accumulate sufficient votes to pass.

## Finding Description

The governance system validates `min_voting_threshold` against the wrong metric during proposal creation. The vulnerability spans multiple files:

**In `aptos_governance.move`**, when creating proposals, the early resolution threshold is calculated based on total coin supply: [1](#0-0) 

**In `voting.move`**, the only validation of `min_vote_threshold` checks it against this supply-based threshold: [2](#0-1) 

**Critical Issue**: The validation compares `min_vote_threshold` against `total_supply / 2 + 1`, but actual voting power comes from **staked coins only**, not the total supply. The `get_voting_power()` function calculates voting power from staked amounts: [3](#0-2) 

Individual votes (u64) are accumulated as u128: [4](#0-3) 

Proposal success requires: `yes_votes + no_votes >= min_vote_threshold` [5](#0-4) 

**The Problem**: If `min_voting_threshold` is set such that:
- `min_voting_threshold â‰¤ total_supply / 2 + 1` (passes validation) 
- `min_voting_threshold > actual_total_staked_voting_power` (impossible to achieve)

Then governance enters deadlock: proposals can be created but never pass.

**Missing Validations**:

Genesis configuration validation does NOT check `min_voting_threshold`: [6](#0-5) 

The `update_governance_config()` function accepts any u128 value without validation: [7](#0-6) 

**Attack Scenarios**:

1. **Genesis Misconfiguration**: Setting `min_voting_threshold` to 400M APT (mainnet default) when initial stake is only 300M APT [8](#0-7) 

2. **Natural Stake Decrease**: Validators unstaking over time, causing total stake to drop below the threshold

3. **Governance Capture**: A barely-passing proposal updates `min_voting_threshold` to an unreachable value, preventing future governance actions

## Impact Explanation

**Severity: High** (per "Significant protocol violations")

This vulnerability causes complete governance liveness failure. Once `min_voting_threshold` exceeds actual staking power:
- No proposals can accumulate sufficient votes to pass
- The network cannot update configurations via governance
- Critical upgrades, parameter changes, and emergency actions become impossible
- Requires social coordination and potential hard fork to recover

While this doesn't directly cause loss of funds or consensus safety violations, it breaks **Invariant #5: Governance Integrity** and represents a significant protocol violation that degrades network security and upgradeability.

## Likelihood Explanation

**Likelihood: Medium-High**

This can occur through:
1. **Configuration errors** during genesis or governance updates (human error)
2. **Natural evolution** where validators unstake as economic conditions change
3. **Malicious governance proposals** (requires 51% attack on governance, but then permanently locks future governance)

The mainnet configuration with 400M APT threshold is particularly vulnerable if total stake drops below this value while total supply remains at 1B+ APT.

## Recommendation

Add validation to ensure `min_voting_threshold` is achievable with actual voting power:

**For Genesis Configuration** (in `vm-genesis/src/lib.rs`):
```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    // Existing validations...
    
    // NEW: Validate min_voting_threshold is reasonable
    // Assuming max possible validators and max stake each
    let max_possible_voting_power = (MAX_VALIDATORS as u128) * (genesis_config.max_stake as u128);
    assert!(
        genesis_config.min_voting_threshold <= max_possible_voting_power,
        "min_voting_threshold must be achievable with maximum possible staking"
    );
}
```

**For Runtime Updates** (in `aptos_governance.move`):
```move
public fun update_governance_config(
    aptos_framework: &signer,
    min_voting_threshold: u128,
    required_proposer_stake: u64,
    voting_duration_secs: u64,
) acquires GovernanceConfig, GovernanceEvents {
    system_addresses::assert_aptos_framework(aptos_framework);
    
    // NEW: Validate against total staked voting power
    let total_staked_power = stake::get_total_voting_power();
    assert!(
        min_voting_threshold <= (total_staked_power as u128),
        error::invalid_argument(EINVALID_VOTING_THRESHOLD)
    );
    
    // Continue with existing logic...
}
```

Additionally, consider making validation dynamic during proposal creation to warn if threshold is unreachable given current staking levels.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, proposer = @0x123, voter = @0x234)]
fun test_governance_deadlock_via_threshold_mismatch(
    aptos_framework: signer,
    proposer: signer, 
    voter: signer
) {
    // Setup: Initialize with 100M APT total stake
    setup_governance_with_stake(&aptos_framework, &proposer, &voter, 100_000_000);
    
    // Malicious proposal: Update threshold to 500M APT (impossible to reach)
    // This requires passing with current threshold first
    create_and_pass_proposal_to_update_threshold(
        &proposer,
        &voter, 
        500_000_000 * APTOS_COINS_BASE_WITH_DECIMALS as u128
    );
    
    // Now try to create new proposal - it should succeed (validated against supply)
    let total_supply = coin::supply<AptosCoin>(); // Returns ~1B APT
    assert!(500M < total_supply / 2 + 1, 0); // Validation passes
    
    create_proposal(&proposer, ...); // Succeeds
    
    // But voting cannot reach threshold
    vote(&voter, proposal_id, all_voting_power, true);
    let (yes, no) = voting::get_votes(proposal_id);
    assert!(yes + no == 100M, 0); // Total votes = actual stake
    assert!(100M < 500M, 0); // Cannot meet threshold!
    
    // Proposal cannot pass - governance deadlock
    timestamp::fast_forward(voting_period);
    assert!(voting::get_proposal_state(proposal_id) == PROPOSAL_STATE_FAILED, 0);
}
```

This demonstrates how `min_voting_threshold` can be set above actual voting capacity, creating an irrecoverable governance deadlock despite passing all current validation checks.

## Notes

The issue stems from validating against economic supply (total coins) rather than governance capacity (staked voting power). In Aptos, only staked coins participate in governance, but validation assumes all coins can vote. This mismatch between validation and reality creates the deadlock vulnerability.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L243-254)
```text
    public fun update_governance_config(
        aptos_framework: &signer,
        min_voting_threshold: u128,
        required_proposer_stake: u64,
        voting_duration_secs: u64,
    ) acquires GovernanceConfig, GovernanceEvents {
        system_addresses::assert_aptos_framework(aptos_framework);

        let governance_config = borrow_global_mut<GovernanceConfig>(@aptos_framework);
        governance_config.voting_duration_secs = voting_duration_secs;
        governance_config.min_voting_threshold = min_voting_threshold;
        governance_config.required_proposer_stake = required_proposer_stake;
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L443-449)
```text
        let total_voting_token_supply = coin::supply<AptosCoin>();
        let early_resolution_vote_threshold = option::none<u128>();
        if (option::is_some(&total_voting_token_supply)) {
            let total_supply = *option::borrow(&total_voting_token_supply);
            // 50% + 1 to avoid rounding errors.
            early_resolution_vote_threshold = option::some(total_supply / 2 + 1);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L730-742)
```text
    /// Return the voting power a stake pool has with respect to governance proposals.
    public fun get_voting_power(pool_address: address): u64 {
        let allow_validator_set_change = staking_config::get_allow_validator_set_change(&staking_config::get());
        if (allow_validator_set_change) {
            let (active, _, pending_active, pending_inactive) = stake::get_stake(pool_address);
            // We calculate the voting power as total non-inactive stakes of the pool. Even if the validator is not in the
            // active validator set, as long as they have a lockup (separately checked in create_proposal and voting), their
            // stake would still count in their voting power for governance proposals.
            active + pending_active + pending_inactive
        } else {
            stake::get_current_epoch_voting_power(pool_address)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L304-309)
```text
        if (option::is_some(&early_resolution_vote_threshold)) {
            assert!(
                min_vote_threshold <= *option::borrow(&early_resolution_vote_threshold),
                error::invalid_argument(EINVALID_MIN_VOTE_THRESHOLD),
            );
        };
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L405-409)
```text
        if (should_pass) {
            proposal.yes_votes = proposal.yes_votes + (num_votes as u128);
        } else {
            proposal.no_votes = proposal.no_votes + (num_votes as u128);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L664-668)
```text
            if (yes_votes > no_votes && yes_votes + no_votes >= proposal.min_vote_threshold) {
                PROPOSAL_STATE_SUCCEEDED
            } else {
                PROPOSAL_STATE_FAILED
            }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L405-439)
```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    assert!(
        genesis_config.min_stake <= genesis_config.max_stake,
        "Min stake must be smaller than or equal to max stake"
    );
    assert!(
        genesis_config.epoch_duration_secs > 0,
        "Epoch duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs > 0,
        "Recurring lockup duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs >= genesis_config.epoch_duration_secs,
        "Recurring lockup duration must be at least as long as epoch duration"
    );
    assert!(
        genesis_config.rewards_apy_percentage > 0 && genesis_config.rewards_apy_percentage < 100,
        "Rewards APY must be > 0% and < 100%"
    );
    assert!(
        genesis_config.voting_duration_secs > 0,
        "On-chain voting duration must be > 0"
    );
    assert!(
        genesis_config.voting_duration_secs < genesis_config.recurring_lockup_duration_secs,
        "Voting duration must be strictly smaller than recurring lockup"
    );
    assert!(
        genesis_config.voting_power_increase_limit > 0
            && genesis_config.voting_power_increase_limit <= 50,
        "voting_power_increase_limit must be > 0 and <= 50"
    );
}
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1480-1483)
```rust
        min_stake: 1_000_000 * APTOS_COINS_BASE_WITH_DECIMALS, // 1M APT
        // 400M APT
        min_voting_threshold: (400_000_000 * APTOS_COINS_BASE_WITH_DECIMALS as u128),
        max_stake: 50_000_000 * APTOS_COINS_BASE_WITH_DECIMALS, // 50M APT.
```
