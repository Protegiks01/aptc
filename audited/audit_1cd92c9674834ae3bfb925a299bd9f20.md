# Audit Report

## Title
SafetyData Round Rollback via Backward-Compatible Deserialization During Upgrades

## Summary
The `SafetyData` struct's use of `#[serde(default)]` attributes on `highest_timeout_round` and `one_chain_round` fields creates a critical round rollback vulnerability during network upgrades. When validators upgrade from older code versions to newer versions that include these fields, the deserialization process resets these values to 0 while preserving `last_voted_round`, violating the consensus safety invariant that prevents order votes on rounds where timeouts have been signed.

## Finding Description

The `SafetyData` struct defines critical round tracking fields with backward-compatible deserialization: [1](#0-0) 

The fields `one_chain_round` and `highest_timeout_round` use `#[serde(default)]` to support backward compatibility during upgrades. This creates a vulnerability scenario:

**Pre-Upgrade State (Old Code):**
- Validator running old code without `highest_timeout_round` field
- Currently at round 150, has signed timeout for round 100
- SafetyData in storage: `{epoch: 1, last_voted_round: 150, preferred_round: 149}`

**During Upgrade:**
When the validator restarts with new code, the deserialization test confirms this behavior: [2](#0-1) 

The deserialized SafetyData becomes: `{epoch: 1, last_voted_round: 150, preferred_round: 149, one_chain_round: 0, highest_timeout_round: 0}`

**Post-Upgrade Exploitation:**
The `safe_for_order_vote` function enforces the critical safety check: [3](#0-2) 

With `highest_timeout_round` reset to 0, this check becomes `round > 0` instead of the correct `round > 100`, allowing order votes on rounds 1-100 that should be forbidden.

The order vote signing process only validates against this field: [4](#0-3) 

Critically, there is NO call to `verify_and_update_last_vote_round` for order votes, unlike regular votes. The safety test confirms this invariant must hold: [5](#0-4) 

**No Recovery Mechanism:**
While `highest_2chain_timeout_certificate` is persisted in ConsensusDB and recovered: [6](#0-5) 

There is NO mechanism that uses this recovered timeout certificate to restore the correct `highest_timeout_round` value in SafetyData after deserialization.

## Impact Explanation

This represents a **Critical Severity** consensus safety violation. According to the 2-chain consensus protocol, once a validator signs a timeout for round R, they must never sign order votes for rounds â‰¤ R. This is a fundamental safety invariant.

During a coordinated network upgrade where all validators upgrade simultaneously:
1. All validators' `highest_timeout_round` resets to 0
2. Malicious leader can propose OrderVoteProposals for old rounds (e.g., round 50-100)
3. Validators incorrectly accept and sign these order votes
4. This violates the timeout safety invariant, potentially allowing:
   - Conflicting block ordering decisions
   - Equivocation in the consensus protocol
   - Safety breaks in the 2-chain commit rule

This meets Critical Severity criteria: **Consensus/Safety violations** that could lead to chain splits or double-spending under coordinated attack during upgrade windows.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability triggers during every network upgrade where:
1. Validators upgrade from pre-`highest_timeout_round` code to current code
2. Network remains in the same epoch (no epoch transition to reset fields properly)
3. The upgrade window provides opportunity for malicious proposals

The vulnerability is particularly concerning because:
- Network upgrades are regular occurrences
- All validators are affected simultaneously during coordinated upgrades
- The window of vulnerability persists until new timeouts are signed
- No automatic recovery mechanism exists

The exploit requires a malicious validator or compromised leader to send crafted OrderVoteProposals during the upgrade window, which is feasible if any validator is compromised or Byzantine.

## Recommendation

Implement a recovery mechanism to restore `highest_timeout_round` from the persisted `highest_2chain_timeout_certificate` during SafetyData initialization:

```rust
// In persistent_safety_storage.rs, modify safety_data() method:
pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
    let mut safety_data = if !self.enable_cached_safety_data {
        let _timer = counters::start_timer("get", SAFETY_DATA);
        self.internal_store.get(SAFETY_DATA).map(|v| v.value)?
    } else {
        // ... existing cached logic
    };
    
    // Recovery mechanism: restore highest_timeout_round from persisted TC
    if safety_data.highest_timeout_round == 0 {
        if let Ok(tc) = self.get_highest_timeout_cert() {
            if tc.epoch() == safety_data.epoch {
                safety_data.highest_timeout_round = tc.round();
                // Persist the corrected value
                self.set_safety_data(safety_data.clone())?;
            }
        }
    }
    
    Ok(safety_data)
}
```

Additionally, add explicit validation in `guarded_construct_and_sign_order_vote` to cross-check against recovered timeout certificates when `highest_timeout_round` is suspiciously low.

## Proof of Concept

```rust
#[test]
fn test_safety_data_round_rollback_vulnerability() {
    use serde_json;
    use consensus_types::safety_data::SafetyData;
    
    // Simulate old SafetyData without highest_timeout_round field
    let old_data_json = r#"{
        "epoch": 1,
        "last_voted_round": 150,
        "preferred_round": 149,
        "last_vote": null
    }"#;
    
    // Deserialize with new SafetyData structure
    let deserialized: SafetyData = serde_json::from_str(old_data_json).unwrap();
    
    // Verify the vulnerability: highest_timeout_round defaults to 0
    assert_eq!(deserialized.epoch, 1);
    assert_eq!(deserialized.last_voted_round, 150);
    assert_eq!(deserialized.preferred_round, 149);
    assert_eq!(deserialized.highest_timeout_round, 0); // VULNERABILITY: Should be preserved
    
    // Demonstrate safety violation: safe_for_order_vote would incorrectly pass
    // for round 100, even if validator had timed out at round 100
    let problematic_round = 100;
    assert!(problematic_round > deserialized.highest_timeout_round); // Would incorrectly return true
    
    println!("VULNERABILITY: Validator can now sign order votes for round {} even though it should be forbidden", problematic_round);
}
```

**Notes**

This vulnerability specifically affects the transition period during network upgrades and represents a critical gap in the consensus safety guarantees. The backward compatibility mechanism prioritizes liveness over safety during upgrades, which violates the fundamental requirement that consensus safety must never be compromised. The lack of a recovery mechanism to restore timeout state from ConsensusDB represents a significant architectural oversight in the upgrade path.

### Citations

**File:** consensus/consensus-types/src/safety_data.rs (L10-21)
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/consensus-types/src/safety_data.rs (L53-70)
```rust
#[test]
fn test_safety_data_upgrade() {
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    let old_data = OldSafetyData {
        epoch: 1,
        last_voted_round: 10,
        preferred_round: 100,
        last_vote: None,
    };
    let value = serde_json::to_value(old_data).unwrap();
    let _: SafetyData = serde_json::from_value(value).unwrap();
}
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L97-119)
```rust
    pub(crate) fn guarded_construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        // Exit early if we cannot sign
        self.signer()?;
        self.verify_order_vote_proposal(order_vote_proposal)?;
        let proposed_block = order_vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // Record 1-chain data
        self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

        self.safe_for_order_vote(proposed_block, &safety_data)?;
        // Construct and sign order vote
        let author = self.signer()?.author();
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
        let signature = self.sign(&ledger_info)?;
        let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
        self.persistent_storage.set_safety_data(safety_data)?;
        Ok(order_vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L168-178)
```rust
    fn safe_for_order_vote(&self, block: &Block, safety_data: &SafetyData) -> Result<(), Error> {
        let round = block.round();
        if round > safety_data.highest_timeout_round {
            Ok(())
        } else {
            Err(Error::NotSafeForOrderVote(
                round,
                safety_data.highest_timeout_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/tests/suite.rs (L313-324)
```rust
    // Cannot sign order vote for round 3 after signing timeout for round 4
    assert_err!(safety_rules.construct_and_sign_order_vote(&ov3));

    // Cannot sign vote for round 4 after signing timeout for round 4
    assert_err!(safety_rules.construct_and_sign_vote_two_chain(&p3, None));

    safety_rules
        .construct_and_sign_vote_two_chain(&p4b, Some(&tc3))
        .unwrap();

    // Cannot sign order vote for round 4 after signing timeoiut for round 4
    assert_err!(safety_rules.construct_and_sign_order_vote(&ov4));
```

**File:** consensus/src/persistent_liveness_storage.rs (L414-417)
```rust
            highest_2chain_timeout_certificate: match highest_2chain_timeout_cert {
                Some(tc) if tc.epoch() == epoch => Some(tc),
                _ => None,
            },
```
