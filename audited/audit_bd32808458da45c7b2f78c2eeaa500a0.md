# Audit Report

## Title
Byzantine Validators Can Inject Fake Timeout Reasons to Censor Legitimate Validators via Unsigned RoundTimeoutReason Field

## Summary
The `RoundTimeout` struct's `reason` field is not covered by the cryptographic signature, allowing Byzantine validators to create legitimately-signed timeout messages with fabricated timeout reasons. This enables Byzantine validators with ≥ f+1 voting power to falsely accuse innocent validators of having unavailable payloads, causing those validators' batches to be excluded from future Optimistic Quorum Store (OptQS) proposals.

## Finding Description
The `RoundTimeout` structure contains a `reason` field of type `RoundTimeoutReason` that indicates why a validator timed out on a consensus round. [1](#0-0) 

When a validator signs a timeout, the signature only covers the `epoch`, `round`, and `hqc_round` fields through the `TimeoutSigningRepr` structure. [2](#0-1) 

The signature is created by signing this reduced representation. [3](#0-2) 

During verification, only the signature and quorum certificate are validated—the `reason` field receives no cryptographic verification. [4](#0-3) 

**Attack Scenario:**
1. A Byzantine validator creates a legitimate `TwoChainTimeout` with valid epoch, round, and hqc_round
2. Signs it properly with their private key (signature covers epoch/round/hqc_round only)
3. Attaches a fabricated `RoundTimeoutReason::PayloadUnavailable { missing_authors: [victim_validators] }` with arbitrary validators marked as having unavailable payloads
4. Broadcasts the message to the network
5. Other validators deserialize and verify the message—verification succeeds because the signature doesn't cover the `reason` field
6. The fake reason is stored and aggregated with other timeout reasons [5](#0-4) 
7. If Byzantine validators controlling ≥ f+1 voting power report specific victims, those victims are marked as having unavailable payloads in the aggregated timeout reason [6](#0-5) 
8. The `ExponentialWindowFailureTracker` extracts these victims from `PayloadUnavailable` timeout reasons and adds them to an `exclude_authors` set [7](#0-6) 
9. These excluded validators' batches are filtered out from future OptQS proposals, effectively censoring their transaction submissions

## Impact Explanation
This vulnerability enables **censorship attacks** against legitimate validators through false accusation. Byzantine validators can frame innocent validators as having unavailable payloads, causing the protocol to exclude those validators' batches from consensus proposals.

**Impact classification: High Severity** - This constitutes a "Significant protocol violation" under the Aptos bug bounty program. Specifically:
- Violates the integrity of the timeout reporting mechanism
- Enables unfair penalization of honest validators
- Degrades protocol liveness by unnecessarily disabling OptQS
- Allows Byzantine validators to manipulate which validators' transactions are included in blocks
- Breaks the accountability property that validators should only be penalized for their actual behavior

While this does not directly violate consensus safety (no double-spend or chain forks), it significantly impacts protocol fairness and liveness guarantees.

## Likelihood Explanation
**Likelihood: Medium**

**Requirements for exploitation:**
- Byzantine validator(s) controlling ≥ f+1 total voting power (approximately ≥33% stake)
- This threshold can be met by a single large validator OR multiple colluding validators

**Factors increasing likelihood:**
- The attack is trivial to execute once the voting power threshold is met—it requires only creating a single malicious message
- No complex timing, race conditions, or sophisticated cryptographic manipulation needed
- The unsigned `reason` field is an obvious oversight that sophisticated attackers would discover

**Factors decreasing likelihood:**
- Requires significant stake or validator collusion
- The ≥ f+1 threshold exceeds the protocol's Byzantine fault tolerance guarantee (< f)
- Detection is possible through monitoring if validators observe divergent timeout reasons for the same round

## Recommendation
**Fix: Include the `reason` field in the cryptographic signature**

Modify the `TimeoutSigningRepr` structure to include the timeout reason in the signed data: [8](#0-7) 

The signing format should be updated to:
```rust
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
    pub reason: RoundTimeoutReason,  // ADD THIS FIELD
}
```

Update the `signing_format()` method to include the reason: [3](#0-2) 

This ensures that validators cannot create timeout messages with fake reasons, as the signature verification would fail if the reason is modified.

**Note:** This fix requires a protocol upgrade and coordination across all validators, as it changes the signature format.

## Proof of Concept

```rust
// This PoC demonstrates that RoundTimeout signatures don't cover the reason field
// Location: consensus/consensus-types/src/round_timeout.rs (add as test)

#[cfg(test)]
mod security_tests {
    use super::*;
    use crate::{
        quorum_cert::QuorumCert,
        timeout_2chain::TwoChainTimeout,
        vote_data::VoteData,
    };
    use aptos_bitvec::BitVec;
    use aptos_crypto::hash::CryptoHash;
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithVerifiedSignatures},
        aggregate_signature::PartialSignatures,
        validator_verifier::random_validator_verifier,
    };

    #[test]
    fn test_unsigned_reason_field_vulnerability() {
        // Setup: Create validator set
        let (signers, validators) = random_validator_verifier(4, None, false);
        let byzantine_signer = &signers[0];
        let byzantine_author = byzantine_signer.author();
        
        // Create a legitimate QC for round 2
        let vote_data = VoteData::new(BlockInfo::random(2), BlockInfo::random(0));
        let mut ledger_info = LedgerInfoWithVerifiedSignatures::new(
            LedgerInfo::new(BlockInfo::empty(), vote_data.hash()),
            PartialSignatures::empty(),
        );
        for signer in &signers[0..3] {
            let signature = signer.sign(ledger_info.ledger_info()).unwrap();
            ledger_info.add_signature(signer.author(), signature);
        }
        let qc = QuorumCert::new(
            vote_data,
            ledger_info.aggregate_signatures(&validators).unwrap(),
        );
        
        // Byzantine validator creates timeout for round 3 with legitimate signature
        let timeout = TwoChainTimeout::new(1, 3, qc);
        let legitimate_signature = timeout.sign(byzantine_signer).unwrap();
        
        // Create RoundTimeout with FAKE reason claiming victim validators have unavailable payloads
        let mut fake_missing_authors = BitVec::with_num_bits(4);
        fake_missing_authors.set(1); // Falsely accuse validator 1
        fake_missing_authors.set(2); // Falsely accuse validator 2
        
        let fake_reason = RoundTimeoutReason::PayloadUnavailable {
            missing_authors: fake_missing_authors,
        };
        
        // Create RoundTimeout with fake reason but legitimate signature
        let malicious_timeout = RoundTimeout::new(
            timeout.clone(),
            byzantine_author,
            fake_reason, // FAKE REASON
            legitimate_signature, // But LEGITIMATE signature
        );
        
        // VULNERABILITY: Verification passes even though reason is fake!
        assert!(malicious_timeout.verify(&validators).is_ok(),
            "Malicious timeout with fake reason should NOT verify, but it does!");
        
        // Create another RoundTimeout with different (legitimate) reason but SAME signature
        let legitimate_reason = RoundTimeoutReason::ProposalNotReceived;
        let timeout_with_different_reason = RoundTimeout::new(
            timeout,
            byzantine_author,
            legitimate_reason, // Different reason
            legitimate_signature.clone(), // Same signature
        );
        
        // VULNERABILITY: This also verifies! Same signature works for ANY reason!
        assert!(timeout_with_different_reason.verify(&validators).is_ok(),
            "Timeout with different reason but same signature should NOT verify, but it does!");
        
        // This proves the signature doesn't cover the reason field
        println!("VULNERABILITY CONFIRMED: RoundTimeout signatures don't cover the reason field!");
        println!("Byzantine validators can attach arbitrary fake reasons to legitimately-signed timeouts!");
    }
}
```

## Notes

**Key Technical Details:**
- The vulnerability stems from the `TimeoutSigningRepr` structure excluding the `reason` field from the cryptographic signature [8](#0-7) 
- The `RoundTimeout` struct derives `Deserialize`, allowing direct field deserialization without constructor validation [1](#0-0) 
- Timeout reasons are aggregated by voting power, requiring ≥ f+1 Byzantine voting power for a fake reason to become the consensus reason [9](#0-8) 
- The attack specifically targets the OptQS (Optimistic Quorum Store) mechanism's author exclusion feature [7](#0-6) 

**Limitations:**
- Requires Byzantine validators with ≥ f+1 (approximately ≥33%) total voting power
- Does not break consensus safety properties (no double-spend or forks possible)
- Impact is primarily on liveness and fairness rather than safety

**Detection Possibilities:**
- Validators could implement cross-validation by comparing their local timeout reasons with broadcasted reasons
- Monitoring for validators being excluded from OptQS despite having available payloads
- Analyzing timeout reason patterns for suspicious accusation clustering

### Citations

**File:** consensus/consensus-types/src/round_timeout.rs (L37-45)
```rust
#[derive(Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct RoundTimeout {
    // The timeout
    timeout: TwoChainTimeout,
    author: Author,
    reason: RoundTimeoutReason,
    /// Signature on the Timeout
    signature: bls12381::Signature,
}
```

**File:** consensus/consensus-types/src/round_timeout.rs (L97-107)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        self.timeout.verify(validator)?;
        validator
            .verify(
                self.author(),
                &self.timeout.signing_format(),
                &self.signature,
            )
            .context("Failed to verify 2-chain timeout signature")?;
        Ok(())
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L66-72)
```rust
    pub fn signing_format(&self) -> TimeoutSigningRepr {
        TimeoutSigningRepr {
            epoch: self.epoch(),
            round: self.round(),
            hqc_round: self.hqc_round(),
        }
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L96-103)
```rust
/// Validators sign this structure that allows the TwoChainTimeoutCertificate to store a round number
/// instead of a quorum cert per validator in the signatures field.
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
}
```

**File:** consensus/src/pending_votes.rs (L78-87)
```rust
    pub(super) fn add(
        &mut self,
        author: Author,
        timeout: TwoChainTimeout,
        signature: bls12381::Signature,
        reason: RoundTimeoutReason,
    ) {
        self.partial_2chain_tc.add(author, timeout, signature);
        self.timeout_reason.entry(author).or_insert(reason);
    }
```

**File:** consensus/src/pending_votes.rs (L93-150)
```rust
    fn aggregated_timeout_reason(&self, verifier: &ValidatorVerifier) -> RoundTimeoutReason {
        let mut reason_voting_power: HashMap<RoundTimeoutReason, u128> = HashMap::new();
        let mut missing_batch_authors: HashMap<usize, u128> = HashMap::new();
        // let ordered_authors = verifier.get_ordered_account_addresses();
        for (author, reason) in &self.timeout_reason {
            // To aggregate the reason, we only care about the variant type itself and
            // exclude any data within the variants.
            let reason_key = match reason {
                reason @ RoundTimeoutReason::Unknown
                | reason @ RoundTimeoutReason::ProposalNotReceived
                | reason @ RoundTimeoutReason::NoQC => reason.clone(),
                RoundTimeoutReason::PayloadUnavailable { missing_authors } => {
                    for missing_idx in missing_authors.iter_ones() {
                        *missing_batch_authors.entry(missing_idx).or_default() +=
                            verifier.get_voting_power(author).unwrap_or_default() as u128;
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        // Since we care only about the variant type, we replace the bitvec
                        // with a placeholder.
                        missing_authors: BitVec::with_num_bits(verifier.len() as u16),
                    }
                },
            };
            *reason_voting_power.entry(reason_key).or_default() +=
                verifier.get_voting_power(author).unwrap_or_default() as u128;
        }
        // The aggregated timeout reason is the reason with the most voting power received from
        // at least f+1 peers by voting power. If such voting power does not exist, then the
        // reason is unknown.

        reason_voting_power
            .into_iter()
            .max_by_key(|(_, voting_power)| *voting_power)
            .filter(|(_, voting_power)| {
                verifier
                    .check_aggregated_voting_power(*voting_power, false)
                    .is_ok()
            })
            .map(|(reason, _)| {
                // If the aggregated reason is due to unavailable payload, we will compute the
                // aggregated missing authors bitvec counting batch authors that have been reported
                // missing by minority peers.
                if matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }) {
                    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
                    for (author_idx, voting_power) in missing_batch_authors {
                        if verifier
                            .check_aggregated_voting_power(voting_power, false)
                            .is_ok()
                        {
                            aggregated_bitvec.set(author_idx as u16);
                        }
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        missing_authors: aggregated_bitvec,
                    }
                } else {
                    reason
                }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```
