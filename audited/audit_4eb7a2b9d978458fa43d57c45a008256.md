# Audit Report

## Title
Quorum Store Batch Expiry Gap Configuration Allows Zero Value Leading to Immediate Batch Expiration and Validator Self-DoS

## Summary
The `batch_expiry_gap_when_init_usecs` configuration parameter lacks minimum value validation, allowing it to be set to 0. This causes all locally created batches to expire immediately, preventing the validator from contributing batches to consensus.

## Finding Description
The `batch_expiry_gap_when_init_usecs` parameter in `QuorumStoreConfig` determines the lifetime of locally created batches by setting their expiration time. [1](#0-0) 

When a batch is created, its expiration time is calculated as: [2](#0-1) 

If `batch_expiry_gap_when_init_usecs = 0`, then `expiry_time = current_time + 0 = current_time`, meaning batches expire immediately upon creation.

When proofs arrive at the `BatchProofQueue`, they are validated against expiration: [3](#0-2) 

The `latest_block_timestamp` is updated from committed blocks: [4](#0-3) 

Since batches expire at creation time and `latest_block_timestamp` advances with each committed block, by the time proofs return (after network propagation + signature aggregation delays), they are rejected as expired.

Additionally, the expiration handler removes all expired batches: [5](#0-4) 

The `ConfigSanitizer` for `QuorumStoreConfig` only validates send/recv and batch/total limits, but does NOT validate minimum values for expiry gaps: [6](#0-5) 

## Impact Explanation
This issue qualifies as **Medium severity** per Aptos bug bounty criteria as it causes validator node operational issues. While setting this value to 0 would be a misconfiguration by the validator operator (a trusted role), the lack of validation violates defense-in-depth principles. The impact is:

- **Validator node slowdown/inability to contribute**: The affected validator cannot include any of their batches in consensus proposals
- **State inconsistencies requiring intervention**: The validator's quorum store state becomes inconsistent, requiring manual configuration fix and restart

However, this is a **self-inflicted configuration issue** that only affects the misconfigured validator, not the network.

## Likelihood Explanation
Likelihood is LOW to MEDIUM:
- Requires validator operator to explicitly set the configuration value to 0 (or very low value)
- Likely to occur through misconfiguration or incomplete testing rather than malicious intent
- Default value is 60 seconds, so requires active change
- No on-chain mechanism can force this value on validators

## Recommendation
Add validation in the `ConfigSanitizer` to enforce a minimum value for `batch_expiry_gap_when_init_usecs`. Add to the `sanitize` function in `QuorumStoreConfig`:

```rust
impl ConfigSanitizer for QuorumStoreConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = &node_config.consensus.quorum_store;

        // Validate minimum batch expiry gap
        const MIN_BATCH_EXPIRY_GAP_USECS: u64 = Duration::from_secs(5).as_micros() as u64;
        if config.batch_expiry_gap_when_init_usecs < MIN_BATCH_EXPIRY_GAP_USECS {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.to_owned(),
                format!(
                    "batch_expiry_gap_when_init_usecs ({}) must be >= {} usecs (5 seconds)",
                    config.batch_expiry_gap_when_init_usecs,
                    MIN_BATCH_EXPIRY_GAP_USECS
                ),
            ));
        }
        
        // ... existing validations ...
    }
}
```

## Proof of Concept
```rust
#[test]
fn test_zero_batch_expiry_gap_rejected() {
    use crate::config::{ConsensusConfig, NodeConfig, QuorumStoreConfig};
    use crate::config::config_sanitizer::ConfigSanitizer;
    
    // Create config with zero batch expiry gap
    let node_config = NodeConfig {
        consensus: ConsensusConfig {
            quorum_store: QuorumStoreConfig {
                batch_expiry_gap_when_init_usecs: 0,
                ..Default::default()
            },
            ..Default::default()
        },
        ..Default::default()
    };
    
    // Sanitize should fail
    let result = QuorumStoreConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::testnet()),
    );
    
    assert!(result.is_err());
    assert!(matches!(result.unwrap_err(), Error::ConfigSanitizerFailed(_, _)));
}
```

**Notes:**
This is a **configuration validation issue** rather than a traditional security vulnerability exploitable by external attackers. It violates defense-in-depth principles by allowing invalid configurations that cause validator operational failures. The fix should be implemented to prevent misconfiguration, but the issue does not meet the strict criteria for a security vulnerability exploitable by untrusted actors since it requires the validator operator (a trusted role) to set an invalid configuration value.

### Citations

**File:** config/src/config/quorum_store_config.rs (L89-91)
```rust
    pub batch_expiry_gap_when_init_usecs: u64,
    /// Duration for expiring remotely created batches. The txns are filtered to prevent dupliation across validators.
    pub remote_batch_expiry_gap_when_init_usecs: u64,
```

**File:** config/src/config/quorum_store_config.rs (L253-271)
```rust
impl ConfigSanitizer for QuorumStoreConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        // Sanitize the send/recv batch limits
        Self::sanitize_send_recv_batch_limits(
            &sanitizer_name,
            &node_config.consensus.quorum_store,
        )?;

        // Sanitize the batch total limits
        Self::sanitize_batch_total_limits(&sanitizer_name, &node_config.consensus.quorum_store)?;

        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L383-384)
```rust
        let expiry_time = aptos_infallible::duration_since_epoch().as_micros() as u64
            + self.config.batch_expiry_gap_when_init_usecs;
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L176-179)
```rust
        if proof.expiration() <= self.latest_block_timestamp {
            counters::inc_rejected_pos_count(counters::POS_EXPIRED_LABEL);
            return;
        }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L716-722)
```rust
    pub(crate) fn handle_updated_block_timestamp(&mut self, block_timestamp: u64) {
        // tolerate asynchronous notification
        if self.latest_block_timestamp > block_timestamp {
            return;
        }
        let start = Instant::now();
        self.latest_block_timestamp = block_timestamp;
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L729-760)
```rust
        let expired = self.expirations.expire(block_timestamp);
        let mut num_expired_but_not_committed = 0;
        for key in &expired {
            if let Some(mut queue) = self.author_to_batches.remove(&key.author()) {
                if let Some(batch) = queue.remove(key) {
                    let item = self
                        .items
                        .get(&key.batch_key)
                        .expect("Entry for unexpired batch must exist");
                    if item.proof.is_some() {
                        // not committed proof that is expired
                        num_expired_but_not_committed += 1;
                        counters::GAP_BETWEEN_BATCH_EXPIRATION_AND_CURRENT_TIME_WHEN_COMMIT
                            .observe((block_timestamp - batch.expiration()) as f64);
                        if let Some(ref txn_summaries) = item.txn_summaries {
                            for txn_summary in txn_summaries {
                                if let Some(count) =
                                    self.txn_summary_num_occurrences.get_mut(txn_summary)
                                {
                                    *count -= 1;
                                    if *count == 0 {
                                        self.txn_summary_num_occurrences.remove(txn_summary);
                                    }
                                };
                            }
                        }
                        self.dec_remaining_proofs(&batch.author(), batch.num_txns());
                        counters::GARBAGE_COLLECTED_IN_PROOF_QUEUE_COUNTER
                            .with_label_values(&["expired_proof"])
                            .inc();
                    }
                    claims::assert_some!(self.items.remove(&key.batch_key));
```
