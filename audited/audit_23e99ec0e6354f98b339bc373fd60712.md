# Audit Report

## Title
Unsafe Default Configuration Exposes Mainnet Validator Information Due to Backward Compatibility Issue

## Summary
Old configuration files lacking the `inspection_service` section or missing individual `expose_*` fields deserialize to unsafe defaults when loaded by newer Aptos node versions. This causes mainnet validators to unintentionally expose sensitive network topology information (identity, peer connections, and system details) through HTTP endpoints, violating security best practices and enabling reconnaissance attacks.

## Finding Description

The `InspectionServiceConfig` struct defines default values for endpoint exposure flags that are unsafe for production validators: [1](#0-0) 

When old configuration files are loaded that don't specify the `inspection_service` section (common in production validator configs), Serde's `#[serde(default)]` attribute automatically fills in missing fields using the `Default` trait: [2](#0-1) 

Real-world validator configuration files lack the `inspection_service` section entirely: [3](#0-2) [4](#0-3) 

The configuration sanitizer only validates that `expose_configuration` is disabled for mainnet validators, but fails to check the other three exposure flags: [5](#0-4) 

Meanwhile, the configuration optimizer does not modify these values for mainnet nodes: [6](#0-5) 

The exposed endpoints reveal sensitive information:

**Identity Information** - Exposes validator network and fullnode peer IDs: [7](#0-6) 

**Peer Information** - Exposes all connected peers, trusted validator set, connection metadata, and state sync data: [8](#0-7) [9](#0-8) 

**System Information** - Exposes build version and system details: [10](#0-9) 

The inspection service binds to `0.0.0.0:9101` by default and serves these endpoints via HTTP: [11](#0-10) 

## Impact Explanation

This vulnerability meets **Medium severity** criteria per the Aptos bug bounty program as an information disclosure issue that aids reconnaissance:

1. **Network Topology Exposure**: Attackers can enumerate the validator set, their peer IDs, and connection relationships, enabling targeted attacks on specific validators
2. **Validator Identification**: Peer IDs allow attackers to track and target specific validators across the network
3. **State Sync Intelligence**: Exposed state sync metadata reveals which validators are lagging or have issues, identifying weak targets
4. **Build Version Disclosure**: System information reveals software versions, enabling version-specific exploit targeting

While this doesn't directly cause fund loss or consensus violations, it provides critical intelligence for planning more sophisticated attacks against the validator network. The explicit sanitizer check for `expose_configuration` on mainnet validators indicates the Aptos team intended to prevent such information exposure.

## Likelihood Explanation

**High likelihood of occurrence:**

1. **Production Config Pattern**: Real validator configs from official Aptos deployments (Docker, Helm charts) lack the `inspection_service` section entirely
2. **Automatic Trigger**: No attacker action required—vulnerability triggers automatically when old configs are loaded by newer node versions
3. **Silent Failure**: No error or warning is generated; the unsafe defaults are silently applied
4. **Version Skew Window**: Any node upgrading from an older version to one with these config fields will be affected
5. **Default Port Exposure**: If port 9101 is accessible (common in cloud deployments), the information is immediately available

The vulnerability is trivially exploitable once exposed—attackers simply need to make HTTP GET requests to the endpoints.

## Recommendation

Add comprehensive sanitization checks for all exposure flags on mainnet validators:

```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose sensitive information
        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                
                // Add checks for the other exposure flags
                if inspection_service_config.expose_identity_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose identity information!".to_string(),
                    ));
                }
                
                if inspection_service_config.expose_peer_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose peer information!".to_string(),
                    ));
                }
                
                if inspection_service_config.expose_system_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose system information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

Additionally, change the default values to be secure by default:

```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false,  // Changed to false
            expose_peer_information: false,      // Changed to false
            expose_system_information: false,    // Changed to false
        }
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_unsafe_defaults {
    use super::*;
    use crate::config::{NodeConfig, NodeConfigLoader};
    use aptos_types::chain_id::ChainId;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_old_validator_config_exposes_endpoints() {
        // Create a temporary directory for the test
        let temp_dir = TempDir::new().unwrap();
        let config_path = temp_dir.path().join("validator.yaml");

        // Write an old-style validator config WITHOUT inspection_service section
        let old_config = r#"
base:
  role: "validator"
  data_dir: "/opt/aptos/data"

consensus:
  safety_rules:
    service:
      type: "local"

validator_network:
  discovery_method: "onchain"
  mutual_authentication: true

execution:
  genesis_file_location: "/opt/aptos/genesis/genesis.blob"
"#;
        fs::write(&config_path, old_config).unwrap();

        // Load the config (this will apply defaults via serde)
        let node_config = NodeConfig::load_config(&config_path).unwrap();

        // Verify that the dangerous defaults were applied
        assert_eq!(node_config.inspection_service.expose_configuration, false);
        assert_eq!(node_config.inspection_service.expose_identity_information, true);  // UNSAFE!
        assert_eq!(node_config.inspection_service.expose_peer_information, true);      // UNSAFE!
        assert_eq!(node_config.inspection_service.expose_system_information, true);    // UNSAFE!

        // Verify that sanitization fails to catch this for mainnet validators
        let node_type = NodeType::Validator;
        let chain_id = Some(ChainId::mainnet());
        
        // This should fail but currently passes (demonstrating the vulnerability)
        let sanitize_result = InspectionServiceConfig::sanitize(
            &node_config,
            node_type,
            chain_id,
        );
        
        // The sanitizer incorrectly passes despite unsafe defaults
        assert!(sanitize_result.is_ok());
        
        println!("VULNERABILITY CONFIRMED: Old validator config exposes:");
        println!("  - Identity information: {}", node_config.inspection_service.expose_identity_information);
        println!("  - Peer information: {}", node_config.inspection_service.expose_peer_information);
        println!("  - System information: {}", node_config.inspection_service.expose_system_information);
    }
}
```

## Notes

This vulnerability represents a violation of the security principle of "secure by default" and creates a backward compatibility hazard. The presence of an explicit sanitizer check for `expose_configuration` demonstrates that the Aptos team intended to prevent information exposure on mainnet validators, but the incomplete implementation left three critical exposure vectors unprotected. Upgrading existing mainnet validators to newer node versions would automatically enable these information disclosure endpoints without any operator awareness.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L54-65)
```rust
        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }
```

**File:** config/src/config/inspection_service_config.rs (L82-105)
```rust
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }
```

**File:** config/src/config/node_config.rs (L35-66)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct NodeConfig {
    #[serde(default)]
    pub admin_service: AdminServiceConfig,
    #[serde(default)]
    pub api: ApiConfig,
    #[serde(default)]
    pub base: BaseConfig,
    #[serde(default)]
    pub consensus: ConsensusConfig,
    #[serde(default)]
    pub consensus_observer: ConsensusObserverConfig,
    #[serde(default)]
    pub dag_consensus: DagConsensusConfig,
    #[serde(default)]
    pub dkg: DKGConfig,
    #[serde(default)]
    pub execution: ExecutionConfig,
    #[serde(default)]
    pub failpoints: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub full_node_networks: Vec<NetworkConfig>,
    #[serde(default)]
    pub indexer: IndexerConfig,
    #[serde(default)]
    pub indexer_grpc: IndexerGrpcConfig,
    #[serde(default)]
    pub indexer_table_info: IndexerTableInfoConfig,
    #[serde(default)]
    pub inspection_service: InspectionServiceConfig,
    #[serde(default)]
```

**File:** docker/compose/aptos-node/validator.yaml (L1-46)
```yaml
base:
  role: "validator"
  data_dir: "/opt/aptos/data"
  waypoint:
    from_file: "/opt/aptos/genesis/waypoint.txt"

consensus:
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
    initial_safety_rules_config:
      from_file:
        waypoint:
          from_file: /opt/aptos/genesis/waypoint.txt
        identity_blob_path: /opt/aptos/genesis/validator-identity.yaml

execution:
  genesis_file_location: "/opt/aptos/genesis/genesis.blob"

storage:
  rocksdb_configs:
    enable_storage_sharding: true

validator_network:
  discovery_method: "onchain"
  mutual_authentication: true
  identity:
    type: "from_file"
    path: /opt/aptos/genesis/validator-identity.yaml

full_node_networks:
- network_id:
    private: "vfn"
  listen_address: "/ip4/0.0.0.0/tcp/6181"
  identity:
    type: "from_config"
    key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
    peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"

api:
  enabled: true
  address: "0.0.0.0:8080"
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L1-48)
```yaml
###
### This is the base validator NodeConfig to work with this helm chart
### Additional overrides to the NodeConfig can be specified via .Values.validator.config or .Values.overrideNodeConfig
###
base:
  role: validator
  waypoint:
    from_file: /opt/aptos/genesis/waypoint.txt

consensus:
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
    initial_safety_rules_config:
      from_file:
        waypoint:
          from_file: /opt/aptos/genesis/waypoint.txt
        identity_blob_path: /opt/aptos/genesis/validator-identity.yaml

execution:
  genesis_file_location: /opt/aptos/genesis/genesis.blob

full_node_networks:
  - network_id:
      private: "vfn"
    listen_address: "/ip4/0.0.0.0/tcp/6181"
    identity:
      type: "from_config"
      key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
      peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"

storage:
  rocksdb_configs:
    enable_storage_sharding: true

api:
  enabled: true
  address: "0.0.0.0:8080"

validator_network:
  discovery_method: "onchain"
  identity:
    type: "from_file"
    path: /opt/aptos/genesis/validator-identity.yaml
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L28-52)
```rust
/// Returns a simple text formatted string with identity information
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L40-106)
```rust
/// Returns a simple text formatted string with peer and network information
fn get_peer_information(
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> String {
    // Get all registered networks
    let registered_networks: Vec<NetworkId> =
        peers_and_metadata.get_registered_networks().collect();

    // Get all peers (sorted by peer ID)
    let mut all_peers = peers_and_metadata.get_all_peers();
    all_peers.sort();

    // Display a summary of all peers and networks
    let mut peer_information_output = Vec::<String>::new();
    display_peer_information_summary(
        &mut peer_information_output,
        &all_peers,
        &registered_networks,
    );
    peer_information_output.push("\n".into());

    // Display connection metadata for each peer
    display_peer_connection_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display the entire set of trusted peers
    display_trusted_peers(
        &mut peer_information_output,
        registered_networks,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display basic peer metadata for each peer
    display_peer_monitoring_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display state sync metadata for each peer
    display_state_sync_metadata(&mut peer_information_output, &all_peers, aptos_data_client);
    peer_information_output.push("\n".into());

    // Display detailed peer metadata for each peer
    display_detailed_monitoring_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display the internal client state for each peer
    display_internal_client_state(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );

    peer_information_output.join("\n") // Separate each entry with a newline to construct the output
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L273-300)
```rust
/// Displays the entire set of trusted peers
fn display_trusted_peers(
    peer_information_output: &mut Vec<String>,
    registered_networks: Vec<NetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Trusted peers (validator set & seeds):".into());

    // Fetch and display the trusted peers for each network
    for network in registered_networks {
        peer_information_output.push(format!("\t- Network: {}", network));
        if let Ok(trusted_peers) = peers_and_metadata.get_trusted_peers(&network) {
            // Sort the peers before displaying them
            let mut sorted_trusted_peers = BTreeMap::new();
            for (peer_id, peer_info) in trusted_peers {
                sorted_trusted_peers.insert(peer_id, peer_info);
            }

            // Display the trusted peers
            for (peer_id, peer_info) in sorted_trusted_peers {
                peer_information_output.push(format!(
                    "\t\t- Peer: {:?}, peer information: {:?}",
                    peer_id, peer_info
                ));
            }
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/system_information.rs (L31-42)
```rust
/// Returns a simple JSON formatted string with system information
fn get_system_information_json() -> String {
    // Get the system and build information
    let mut system_information = aptos_telemetry::system_information::get_system_information();
    system_information.extend(build_information!());

    // Return the system information as a JSON string
    match serde_json::to_string(&system_information) {
        Ok(system_information) => system_information,
        Err(error) => format!("Failed to get system information! Error: {}", error),
    }
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L111-169)
```rust
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };
```
