# Audit Report

## Title
Network Address Validation Bypass Allows Malformed Seed Peers Causing Node Isolation

## Summary
The `is_aptosnet_addr()` validation function accepts network addresses with extra protocols between the NoiseIK and Handshake layers, but the runtime dialing code strictly rejects such addresses. This validation-usage mismatch allows malformed seed peer addresses to pass configuration validation but fail all connection attempts, potentially isolating nodes from the network.

## Finding Description

The vulnerability exists in the network address validation logic across multiple components:

**Root Cause:** The `parse_handshake()` function uses `.last()` to check if the final protocol is a Handshake, but fails to verify that Handshake immediately follows NoiseIK without intermediate protocols. [1](#0-0) 

This allows `parse_aptosnet_protos()` to accept addresses like:
`/ip4/1.2.3.4/tcp/6180/noise-ik/<pubkey>/memory/9999/handshake/0` [2](#0-1) 

**Validation Bypass:** The `validate_address()` function in the network checker and `verify_address()` in network config both rely on `is_aptosnet_addr()`, accepting malformed addresses: [3](#0-2) [4](#0-3) 

**Runtime Failure:** The `parse_dial_addr()` function uses strict pattern matching that requires EXACTLY `[NoiseIK, Handshake]` with no intermediate protocols: [5](#0-4) 

**Attack Scenario:**
1. Attacker provides a node configuration file with seed peers containing extra protocols: `/ip4/1.2.3.4/tcp/6180/noise-ik/<pubkey>/memory/12345/handshake/0`
2. The `verify_seeds()` validation passes because `is_aptosnet_addr()` returns true
3. Node starts and attempts to dial seed peers
4. All dial attempts fail with "Unexpected dialing network address" error
5. ConnectivityManager retries with exponential backoff, but continues failing indefinitely
6. If all seed peers are malformed, the node becomes isolated from the network

## Impact Explanation

**High Severity** - This vulnerability affects network availability and liveness:

- **Validator nodes** relying on configured seed peers cannot join the network, preventing participation in consensus
- **Full nodes** cannot establish initial connections or sync blockchain state
- **Private networks** or testnets with custom seed configurations are particularly vulnerable
- Potential for **network partition** if multiple operators use the same malicious configuration
- Results in **denial of service** for affected nodes

While this requires controlling node configuration files (not achievable via network protocol alone), it's a significant operational security issue that could affect node operators who receive configuration from external sources or deploy using untrusted templates.

## Likelihood Explanation

**Medium Likelihood:**
- Requires attacker to influence node configuration (via malicious config templates, compromised deployment scripts, or social engineering)
- Mainnet/testnet hardcoded seed peers in `config_optimizer.rs` are not affected, but custom deployments are vulnerable
- Private networks and test environments with manual seed peer configuration are at higher risk
- The validation bypass is subtle and would not be caught by casual inspection

## Recommendation

Fix the `parse_handshake()` function to verify that the suffix contains EXACTLY one Handshake protocol, not just that the last protocol is Handshake:

```rust
pub fn parse_handshake(protos: &[Protocol]) -> Option<u8> {
    // Ensure suffix is exactly [Handshake(version)] with no extra protocols
    match protos {
        [Protocol::Handshake(version)] => Some(*version),
        _ => None,
    }
}
```

This ensures `parse_aptosnet_protos()` rejects addresses with extra protocols, making validation consistent with runtime usage.

## Proof of Concept

```rust
#[test]
fn test_malformed_address_validation_bypass() {
    use aptos_types::network_address::{NetworkAddress, Protocol};
    use std::str::FromStr;
    use aptos_crypto::x25519;
    
    // Create a malformed address with an extra Memory protocol
    let pubkey = x25519::PrivateKey::generate(&mut rand::thread_rng()).public_key();
    let addr_str = format!(
        "/ip4/1.2.3.4/tcp/6180/noise-ik/{}/memory/9999/handshake/0",
        pubkey
    );
    
    let addr = NetworkAddress::from_str(&addr_str).unwrap();
    
    // This passes validation (BUG!)
    assert!(addr.is_aptosnet_addr(), "Malformed address passed validation");
    
    // But parse_dial_addr would reject it at runtime
    use aptos_network::transport::AptosNetTransport;
    let result = AptosNetTransport::parse_dial_addr(&addr);
    assert!(result.is_err(), "Runtime parsing should fail");
    assert!(result.unwrap_err().to_string().contains("Unexpected dialing network address"));
}
```

**Notes**

The discrepancy between permissive validation (`is_aptosnet_addr()`) and strict runtime parsing (`parse_dial_addr()`) creates a dangerous gap. The comment at line 888 in `parse_aptosnet_protos()` claims it "ensures there are no trailing protos after handshake", but the implementation using `.last()` only prevents protocols AFTER handshake, not protocols BETWEEN NoiseIK and Handshake. This allows configuration-time validation to succeed while runtime connections always fail, resulting in persistent node isolation.

### Citations

**File:** types/src/network_address/mod.rs (L852-857)
```rust
pub fn parse_handshake(protos: &[Protocol]) -> Option<u8> {
    match protos.last() {
        Some(Protocol::Handshake(version)) => Some(*version),
        _ => None,
    }
}
```

**File:** types/src/network_address/mod.rs (L862-892)
```rust
fn parse_aptosnet_protos(protos: &[Protocol]) -> Option<&[Protocol]> {
    // parse base transport layer
    // ---
    // parse_ip_tcp
    // <or> parse_dns_tcp
    // <or> cfg!(test) parse_memory

    let transport_suffix = parse_ip_tcp(protos)
        .map(|x| x.1)
        .or_else(|| parse_dns_tcp(protos).map(|x| x.1))
        .or_else(|| {
            if cfg!(test) {
                parse_memory(protos).map(|x| x.1)
            } else {
                None
            }
        })?;

    // parse authentication layer
    // ---
    // parse_noise_ik

    let auth_suffix = parse_noise_ik(transport_suffix).map(|x| x.1)?;

    // parse handshake layer

    // also ensures there are no trailing protos after handshake
    parse_handshake(auth_suffix)?;

    Some(protos)
}
```

**File:** crates/aptos-network-checker/src/args.rs (L62-69)
```rust
pub fn validate_address(address: &str) -> Result<NetworkAddress> {
    let address = NetworkAddress::from_str(address)
        .with_context(|| format!("Invalid address: {}", address))?;
    if !address.is_aptosnet_addr() {
        bail!("Address must have IP / DNS, TCP, noise key, and handshake")
    }
    Ok(address)
}
```

**File:** config/src/config/network_config.rs (L306-316)
```rust
    fn verify_address(peer_id: &PeerId, addr: &NetworkAddress) -> Result<(), Error> {
        if !addr.is_aptosnet_addr() {
            return Err(Error::InvariantViolation(format!(
                "Unexpected seed peer address format: peer_id: {}, addr: '{}'",
                peer_id.short_str(),
                addr,
            )));
        }

        Ok(())
    }
```

**File:** network/framework/src/transport/mod.rs (L498-512)
```rust
        match base_transport_suffix {
            [NoiseIK(pubkey), Handshake(version)] => {
                let base_addr = NetworkAddress::try_from(base_transport_protos.to_vec())
                    .expect("base_transport_protos is always non-empty");
                Ok((base_addr, *pubkey, *version))
            },
            _ => Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!(
                    "Unexpected dialing network address: '{}', expected: \
                     '/../noise-ik/<pubkey>/handshake/<version>'",
                    addr
                ),
            )),
        }
```
