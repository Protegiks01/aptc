# Audit Report

## Title
Unsafe Environment Variable Mutation Causes Data Race and Undefined Behavior in Indexer GCS Authentication

## Summary
The `GcsFileStore::new()` function uses `unsafe { env::set_var() }` to set the `SERVICE_ACCOUNT` environment variable while the indexer service runs in a multi-threaded tokio runtime. This violates Rust's memory safety guarantees by creating a data race when other threads concurrently read environment variables, leading to undefined behavior and potential memory corruption or service crashes. [1](#0-0) 

## Finding Description

The vulnerability exists in the GCS file store initialization code where environment variables are modified unsafely in a concurrent context.

**Root Cause**: The code uses `unsafe { env::set_var(SERVICE_ACCOUNT_ENV_VAR, service_account_path) }` within an async function. [2](#0-1) 

Rust's `std::env::set_var()` is marked as `unsafe` because it modifies global mutable state (the process environment) without synchronization. When other threads read environment variables concurrently (via `env::var()`, C FFI, or third-party libraries), it creates a data race—a fundamental violation of Rust's memory safety guarantees.

**Concurrent Execution Context**: The indexer services run with `#[tokio::main]`, which defaults to a multi-threaded runtime. [3](#0-2) 

**Concurrent Operations**: Multiple tasks spawn concurrent operations that use the GCS file store operator, creating parallel access patterns. [4](#0-3) 

Each spawned task performs GCS operations [5](#0-4)  which internally trigger the `cloud_storage` library to read the `SERVICE_ACCOUNT` environment variable for authentication.

**The Race Condition**: 
1. Thread A calls `GcsFileStore::new()` → executes `env::set_var()` 
2. Thread B (or the cloud_storage library in any thread) reads `SERVICE_ACCOUNT` via `env::var()`
3. Simultaneous write + read on the same global state = **data race** = **undefined behavior**

The same vulnerability exists in the legacy implementation. [6](#0-5) 

The developers acknowledged this risk with a TODO comment but did not implement proper synchronization. [7](#0-6) 

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria:

1. **API Crashes**: Undefined behavior in Rust can manifest as segmentation faults, panics, or silent memory corruption, directly causing indexer API service crashes. This falls under "API crashes" (High Severity).

2. **Availability Impact**: The indexer services provide critical APIs for dApps, wallets, and ecosystem tools. Crashes impact ecosystem-wide availability.

3. **Memory Corruption**: Data races are undefined behavior in Rust. While the exact manifestation is unpredictable, potential outcomes include:
   - Corrupted authentication credentials
   - Service crashes and restarts
   - Inconsistent API responses
   - In worst case, exploitable memory corruption

4. **Widespread Occurrence**: The pattern affects multiple indexer services that use GCS storage. [8](#0-7) 

## Likelihood Explanation

**High Likelihood**: This vulnerability is triggered automatically during normal indexer operation:

- No attacker action required—occurs during service initialization and concurrent GCS operations
- Multiple indexer services are affected (data-service, manager, backfiller, etc.)
- The multi-threaded tokio runtime guarantees concurrent execution
- The backfiller explicitly spawns multiple concurrent tasks for parallel processing

The race window is small but occurs repeatedly during service operation, making exploitation via crashes or corruption a matter of time rather than possibility.

## Recommendation

**Remove the unsafe environment variable mutation entirely**. Instead, pass the service account path through the application state:

```rust
pub struct GcsFileStore {
    bucket_name: String,
    bucket_sub_dir: Option<PathBuf>,
    service_account_path: String, // Store the path
}

impl GcsFileStore {
    pub async fn new(
        bucket_name: String,
        bucket_sub_dir: Option<PathBuf>,
        service_account_path: String,
    ) -> Self {
        // Remove the unsafe block entirely
        // Set the environment variable BEFORE creating the tokio runtime
        // OR use the cloud_storage library's direct authentication methods
        // instead of relying on environment variables
        
        info!(
            bucket_name = bucket_name,
            "Verifying the bucket exists for GcsFileStore."
        );

        // Use service_account_path directly if the library supports it,
        // or ensure env::set_var is called once at startup before any threads exist
        Bucket::read(&bucket_name)
            .await
            .expect("Failed to read bucket.");

        Self {
            bucket_name,
            bucket_sub_dir,
            service_account_path,
        }
    }
}
```

**Alternative Fix**: Set the environment variable once at process startup in `main()` before initializing the tokio runtime, ensuring it happens in a single-threaded context. However, this is fragile and should be avoided if possible.

**Best Practice**: Use the cloud_storage library's builder pattern or direct credential passing APIs instead of environment variables to avoid global state mutation entirely.

## Proof of Concept

```rust
// This demonstrates the race condition
// Save as: indexer_race_poc.rs

use std::{env, thread, time::Duration};

fn main() {
    // Simulate the indexer scenario: concurrent env reads and writes
    
    let writer = thread::spawn(|| {
        for i in 0..1000 {
            unsafe {
                env::set_var("SERVICE_ACCOUNT", format!("/path/to/account-{}.json", i));
            }
            thread::sleep(Duration::from_micros(10));
        }
    });
    
    let reader1 = thread::spawn(|| {
        for _ in 0..1000 {
            let _val = env::var("SERVICE_ACCOUNT").ok();
            thread::sleep(Duration::from_micros(10));
        }
    });
    
    let reader2 = thread::spawn(|| {
        for _ in 0..1000 {
            let _val = env::var("SERVICE_ACCOUNT").ok();
            thread::sleep(Duration::from_micros(10));
        }
    });
    
    writer.join().unwrap();
    reader1.join().unwrap();
    reader2.join().unwrap();
    
    // This program exhibits undefined behavior due to the data race
    // Run with: cargo +nightly miri run
    // Miri will detect the data race and report undefined behavior
    println!("If you see this without Miri errors, you were 'lucky' this time.");
    println!("The undefined behavior is still present and can manifest unpredictably.");
}
```

**Reproduction Steps**:
1. Run the indexer-grpc-file-store-backfiller with GCS configuration
2. Use Rust's Miri tool or ThreadSanitizer to detect the data race
3. Under high load with multiple concurrent GCS operations, crashes may occur
4. Use `RUST_BACKTRACE=1` to observe crashes originating from environment variable access

## Notes

This vulnerability affects both v1 and v2 implementations of the GCS file store operator, indicating a systemic pattern that should be addressed across the entire indexer-grpc codebase. The issue is infrastructure-critical as indexer services provide essential APIs for the Aptos ecosystem, and crashes directly impact dApp availability and user experience.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/gcs.rs (L22-30)
```rust
    pub async fn new(
        bucket_name: String,
        bucket_sub_dir: Option<PathBuf>,
        service_account_path: String,
    ) -> Self {
        // TODO: Audit that the environment access only happens in single-threaded code.
        unsafe {
            env::set_var(SERVICE_ACCOUNT_ENV_VAR, service_account_path);
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/main.rs (L13-16)
```rust
#[tokio::main]
async fn main() -> Result<()> {
    let args = ServerArgs::parse();
    args.run::<IndexerGrpcManagerConfig>().await
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L173-178)
```rust
        for _ in 0..self.backfill_processing_task_count {
            tracing::info!("Creating a new task");
            let mut current_file_store_operator = file_store_operator.clone_box();
            let current_finished_starting_versions = finished_starting_versions.clone();
            let receiver_ref = receiver_ref.clone();
            let task = tokio::spawn(async move {
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L204-207)
```rust
                    current_file_store_operator
                        .upload_transaction_batch(chain_id, transactions)
                        .await
                        .unwrap();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator/gcs.rs (L35-38)
```rust
        // TODO: Audit that the environment access only happens in single-threaded code.
        unsafe {
            env::set_var(SERVICE_ACCOUNT_ENV_VAR, service_account_path);
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/config.rs (L47-59)
```rust
    pub async fn create_filestore(
        self,
    ) -> Arc<dyn crate::file_store_operator_v2::common::IFileStore> {
        match self {
            IndexerGrpcFileStoreConfig::GcsFileStore(gcs_file_store) => Arc::new(
                crate::file_store_operator_v2::gcs::GcsFileStore::new(
                    gcs_file_store.gcs_file_store_bucket_name,
                    gcs_file_store.gcs_file_store_bucket_sub_dir,
                    gcs_file_store
                        .gcs_file_store_service_account_key_path
                        .clone(),
                )
                .await,
```
