# Audit Report

## Title
Indexer gRPC Configuration Sanitizer Fails to Validate Critical Dependency Chain Leading to Node Panic

## Summary
The `sanitize()` function in `indexer_grpc_config.rs` fails to properly validate that the indexer gRPC service has all required dependencies when `indexer_grpc.enabled=true`. The sanitizer only checks for the legacy `storage.enable_indexer` flag, which does not create the `IndexerReader` interface that the indexer gRPC service requires at runtime. This configuration validation gap allows nodes to start with invalid configurations that result in runtime panics, causing denial of service.

## Finding Description

The vulnerability exists in the dependency validation logic for the indexer gRPC service. The sanitizer performs an incomplete check: [1](#0-0) 

The sanitizer only verifies that either `storage.enable_indexer` OR `indexer_table_info.table_info_service_mode.is_enabled()` is true. However, this check is insufficient because:

1. **Legacy Indexer Confusion**: The `storage.enable_indexer` flag only initializes a deprecated legacy indexer in AptosDB, not the `IndexerReader` interface required by the indexer gRPC service: [2](#0-1) 

2. **Actual Dependency Creation**: The indexer gRPC service requires an `IndexerReader` which is only created when BOTH of the following conditions are met in the bootstrap process: [3](#0-2) 

The `IndexerReaders::new()` function returns `None` when both readers are absent: [4](#0-3) 

3. **Missing Validation**: The sanitizer does NOT check whether `indexer_db_config.is_internal_indexer_db_enabled()` is true, which is required for the internal indexer DB: [5](#0-4) 

4. **Runtime Panic**: When the indexer gRPC service starts with `indexer_reader = None`, it will panic when processing requests: [6](#0-5) 

The `expect("Table info reader not set")` causes an immediate panic when `indexer_reader` is `None`.

**Attack Scenario:**
An operator configures a fullnode with:
- `indexer_grpc.enabled = true`
- `storage.enable_indexer = true` (legacy flag)
- `indexer_table_info.table_info_service_mode = Disabled`
- `indexer_db_config` all features disabled

This configuration passes sanitization but crashes at runtime when any client connects to the indexer gRPC service.

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria:
- **Validator node slowdowns / API crashes**: The node panics when the indexer gRPC service receives requests
- **Service unavailability**: Complete denial of service for the indexer gRPC functionality
- **Configuration validation bypass**: Security control failure in the sanitization layer

The impact includes:
- Immediate node crash/panic upon first indexer gRPC request
- Potential for cascading failures if multiple nodes are misconfigured
- Service degradation for applications relying on indexer data streams
- Operational disruption requiring node restart and reconfiguration

While this does not directly impact consensus or lead to fund loss, it represents a significant availability and operational security issue that violates the invariant that configuration sanitizers must prevent invalid runtime states.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability is likely to manifest in production because:

1. **Configuration Complexity**: The distinction between `storage.enable_indexer` (legacy) and the new indexer system (`indexer_table_info` + `indexer_db_config`) is subtle and poorly documented
2. **Migration Path**: Operators upgrading from older versions may enable `storage.enable_indexer` expecting it to work with the new indexer gRPC service
3. **No Runtime Warning**: The configuration passes all validation checks during startup
4. **Immediate Trigger**: Any client connecting to the indexer gRPC service triggers the panic
5. **No Attacker Required**: This is a self-inflicted misconfiguration that requires no malicious actor

The vulnerability does not require specialized knowledge or access - it's a natural consequence of incomplete validation logic that will manifest whenever operators make reasonable configuration mistakes.

## Recommendation

The sanitizer must verify that at least one actual `IndexerReader` source is enabled when `indexer_grpc.enabled=true`. The fix should check:

```rust
fn sanitize(
    node_config: &NodeConfig,
    _node_type: NodeType,
    _chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = Self::get_sanitizer_name();

    if !node_config.indexer_grpc.enabled {
        return Ok(());
    }

    // Check that at least one IndexerReader source is enabled
    let table_info_enabled = node_config
        .indexer_table_info
        .table_info_service_mode
        .is_enabled();
    
    let internal_indexer_enabled = node_config
        .indexer_db_config
        .is_internal_indexer_db_enabled();

    if !table_info_enabled && !internal_indexer_enabled {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "indexer_grpc requires either indexer_table_info.table_info_service_mode to be enabled OR indexer_db_config to have at least one feature enabled (enable_transaction, enable_event, or enable_statekeys)".to_string(),
        ));
    }

    Ok(())
}
```

Additionally:
1. Deprecate or remove the `storage.enable_indexer` check entirely as it's misleading
2. Add documentation explaining the dependency requirements
3. Consider adding a runtime check in the indexer gRPC bootstrap to fail gracefully with a clear error message rather than panicking

## Proof of Concept

**Configuration File (node_config.yaml)**:
```yaml
indexer_grpc:
  enabled: true
  address: "0.0.0.0:50051"

storage:
  enable_indexer: true  # Legacy flag - does NOT create IndexerReader

indexer_table_info:
  table_info_service_mode: Disabled  # No table info indexer

indexer_db_config:
  enable_transaction: false  # All internal indexer features disabled
  enable_event: false
  enable_statekeys: false
```

**Steps to Reproduce**:
1. Start an Aptos fullnode with the above configuration
2. The node starts successfully (sanitization passes)
3. Connect a client to the indexer gRPC service at port 50051
4. Send a `GetTransactionsFromNode` request
5. The node panics with: `thread 'indexer-grpc' panicked at 'Table info reader not set'`

**Expected Behavior**: Configuration sanitization should reject this configuration during startup with a clear error message.

**Actual Behavior**: Node starts successfully but crashes when the indexer gRPC service is first accessed.

**Evidence from Bootstrap Flow**: [7](#0-6) 

The bootstrap accepts `indexer_reader: Option<Arc<dyn IndexerReader>>` and passes it to the service context without validation. When this is `None` and a client makes a request, the panic occurs in the stream coordinator's version checking logic.

---

**Notes**

This vulnerability represents a critical gap in the configuration validation layer. While `storage.enable_indexer` historically served a purpose for the legacy indexer, its inclusion in the indexer gRPC sanitization check creates a false sense of security. The sanitizer must enforce that the actual runtime dependencies (IndexerReader implementations) are available, not just related-but-insufficient legacy flags.

The fix is straightforward and should be implemented immediately to prevent operational issues in production deployments.

### Citations

**File:** config/src/config/indexer_grpc_config.rs (L103-127)
```rust
impl ConfigSanitizer for IndexerGrpcConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if !node_config.indexer_grpc.enabled {
            return Ok(());
        }

        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }
        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L184-189)
```rust
        if !readonly && enable_indexer {
            myself.open_indexer(
                db_paths.default_root_path(),
                rocksdb_configs.index_db_config,
            )?;
        }
```

**File:** aptos-node/src/services.rs (L72-98)
```rust
    let (indexer_table_info_runtime, indexer_async_v2) = match bootstrap_indexer_table_info(
        node_config,
        chain_id,
        db_rw.clone(),
        mempool_client_sender.clone(),
    ) {
        Some((runtime, indexer_v2)) => (Some(runtime), Some(indexer_v2)),
        None => (None, None),
    };

    let (db_indexer_runtime, txn_event_reader) = match bootstrap_internal_indexer_db(
        node_config,
        db_rw.clone(),
        internal_indexer_db,
        update_receiver,
    ) {
        Some((runtime, db_indexer)) => (Some(runtime), Some(db_indexer)),
        None => (None, None),
    };

    let indexer_readers = IndexerReaders::new(indexer_async_v2, txn_event_reader);

    // Create the API runtime
    let indexer_reader: Option<Arc<dyn IndexerReader>> = indexer_readers.map(|readers| {
        let trait_object: Arc<dyn IndexerReader> = Arc::new(readers);
        trait_object
    });
```

**File:** storage/indexer/src/indexer_reader.rs (L27-39)
```rust
    pub fn new(
        table_info_reader: Option<Arc<IndexerAsyncV2>>,
        db_indexer_reader: Option<Arc<DBIndexer>>,
    ) -> Option<Self> {
        if table_info_reader.is_none() && db_indexer_reader.is_none() {
            None
        } else {
            Some(Self {
                table_info_reader,
                db_indexer_reader,
            })
        }
    }
```

**File:** config/src/config/internal_indexer_db_config.rs (L60-62)
```rust
    pub fn is_internal_indexer_db_enabled(&self) -> bool {
        self.enable_transaction || self.enable_event || self.enable_statekeys
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L532-546)
```rust
    pub fn set_highest_known_version(&mut self) -> anyhow::Result<()> {
        let info = self.context.get_latest_ledger_info_wrapped()?;
        let latest_table_info_version = self
            .context
            .indexer_reader
            .as_ref()
            .expect("Table info reader not set")
            .get_latest_table_info_ledger_version()?
            .expect("Table info ledger version not set");

        self.highest_known_version =
            std::cmp::min(info.ledger_version.0, latest_table_info_version);

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L36-46)
```rust
pub fn bootstrap(
    config: &NodeConfig,
    chain_id: ChainId,
    db: Arc<dyn DbReader>,
    mp_sender: MempoolClientSender,
    indexer_reader: Option<Arc<dyn IndexerReader>>,
    port_tx: Option<oneshot::Sender<u16>>,
) -> Option<Runtime> {
    if !config.indexer_grpc.enabled {
        return None;
    }
```
