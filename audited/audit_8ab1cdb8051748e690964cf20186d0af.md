# Audit Report

## Title
Information Disclosure of Private Function Signatures via View Function Type Argument Validation

## Summary
The `convert_view_function` method in the API layer reveals the number of generic type parameters for private functions that are not exposed in the public module ABI, allowing attackers to probe and discover internal function signatures through error messages.

## Finding Description

During view function conversion, the code validates type argument counts before checking function visibility or view function attributes. [1](#0-0) 

The vulnerability occurs when an attacker sends a view function request with mismatched type arguments for any function name (including private, non-entry functions):

1. The `find_function` method locates ANY function by name, regardless of visibility [2](#0-1) 

2. The error message explicitly reveals `func.generic_type_params.len()`, which is not part of the public ABI for private functions

3. The module's public ABI only exposes entry functions or public/friend visibility functions [3](#0-2) 

4. This check occurs before the view filter validation [4](#0-3)  and before VM-level view function validation [5](#0-4) 

An attacker can systematically probe function names with varying type argument counts to discover private function signatures that should remain internal implementation details.

## Impact Explanation

This falls under **Low Severity** per the Aptos bug bounty program as a "Minor information leak" (up to $1,000). The vulnerability:

- Does NOT lead to loss of funds or consensus violations
- Does NOT enable unauthorized state modifications
- Does NOT cause network availability issues
- Only reveals partial function signature information (generic parameter count)
- Does not expose function implementations or business logic

## Likelihood Explanation

**Medium likelihood**: An attacker can easily enumerate common function names and probe with different type argument counts. The attack requires no special privileges and can be automated through simple HTTP requests. However, the practical impact is limited as it only reveals signature metadata, not exploitable vulnerabilities.

## Recommendation

Validate that the function is marked as a view function and passes visibility checks BEFORE revealing signature details in error messages:

```rust
pub fn convert_view_function(&self, view_request: ViewRequest) -> Result<ViewFunction> {
    let ViewRequest {
        function,
        type_arguments,
        arguments,
    } = view_request;

    let module = function.module.clone();
    let code = self.inner.view_existing_module(&module.clone().into())? as Arc<dyn Bytecode>;
    let func = code
        .find_function(function.name.0.as_ident_str())
        .ok_or_else(|| format_err!("could not find function by {}", function))?;
    
    // NEW: Check if function is a view function before revealing signature details
    if !code.function_is_view(function.name.0.as_ident_str()) {
        bail!("function {} is not a view function", function);
    }
    
    // Use generic error message that doesn't reveal parameter count
    ensure!(
        func.generic_type_params.len() == type_arguments.len(),
        "type argument count mismatch for function {}",
        function
    );
    
    // ... rest of the function
}
```

## Proof of Concept

```bash
# Probe private function signature
curl -X POST http://localhost:8080/v1/view \
  -H "Content-Type: application/json" \
  -d '{
    "function": "0x1::hidden_module::private_internal_function",
    "type_arguments": [],
    "arguments": []
  }'

# Response reveals: "expected 2 type arguments for view function 0x1::hidden_module::private_internal_function, but got 0"
# Attacker now knows this function exists and has 2 generic type parameters

# Verify the function is not in public ABI:
curl http://localhost:8080/v1/accounts/0x1/module/hidden_module

# The exposed_functions array will not contain private_internal_function if it's private and not an entry function
```

## Notes

While this is a valid information disclosure vulnerability, it has **Low severity** and does not meet the validation checklist requirement for "Critical, High, or Medium severity" impact. The issue is correctly classified as a minor information leak that does not compromise funds, consensus integrity, or network availability.

### Citations

**File:** api/types/src/convert.rs (L1033-1042)
```rust
        let func = code
            .find_function(function.name.0.as_ident_str())
            .ok_or_else(|| format_err!("could not find view function by {}", function))?;
        ensure!(
            func.generic_type_params.len() == type_arguments.len(),
            "expected {} type arguments for view function {}, but got {}",
            func.generic_type_params.len(),
            function,
            type_arguments.len()
        );
```

**File:** api/types/src/bytecode.rs (L263-271)
```rust
    fn find_function(&self, name: &IdentStr) -> Option<MoveFunction> {
        self.function_defs
            .iter()
            .find(|def| {
                let fhandle = ModuleAccess::function_handle_at(self, def.function);
                ModuleAccess::identifier_at(self, fhandle.name) == name
            })
            .map(|def| self.new_move_function(def))
    }
```

**File:** api/types/src/move_types.rs (L1014-1028)
```rust
            exposed_functions: m
                .function_defs
                .iter()
                // Return all entry or public functions.
                // Private entry functions are still callable by entry function transactions so
                // they should be included.
                .filter(|def| {
                    def.is_entry
                        || match def.visibility {
                            Visibility::Public | Visibility::Friend => true,
                            Visibility::Private => false,
                        }
                })
                .map(|def| m.new_move_function(def))
                .collect(),
```

**File:** api/src/view_function.rs (L139-152)
```rust
    // Reject the request if it's not allowed by the filter.
    if !context.node_config.api.view_filter.allows(
        view_function.module.address(),
        view_function.module.name().as_str(),
        view_function.function.as_str(),
    ) {
        return Err(BasicErrorWith404::forbidden_with_code_no_info(
            format!(
                "Function {}::{} is not allowed",
                view_function.module, view_function.function
            ),
            AptosErrorCode::InvalidInput,
        ));
    }
```

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L35-53)
```rust
pub(crate) fn validate_view_function(
    session: &mut SessionExt<impl AptosMoveResolver>,
    loader: &impl Loader,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    args: Vec<Vec<u8>>,
    fun_name: &IdentStr,
    func: &LoadedFunction,
    module_metadata: Option<&RuntimeModuleMetadataV1>,
    struct_constructors_feature: bool,
) -> PartialVMResult<Vec<Vec<u8>>> {
    // Must be marked as view function.
    let is_view = determine_is_view(module_metadata, fun_name);
    if !is_view {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("function not marked as view function".to_string()),
        );
    }
```
