# Audit Report

## Title
Malicious Validator Can Propose Empty Blocks to Perform Stealth DoS Without Detection

## Summary
A malicious validator can propose blocks with empty payloads (zero transactions) even when transactions are available in mempool, successfully bypassing liveness detection mechanisms and receiving full rewards while degrading network throughput. The validation logic only enforces empty payloads for reconfiguration suffix blocks but does not prevent normal blocks from being empty.

## Finding Description

The vulnerability exists in the block proposal validation flow where the consensus layer fails to enforce a minimum payload requirement for non-reconfiguration blocks.

**Validation Gap**: The `Block::verify_well_formed()` function only checks that reconfiguration suffix blocks MUST have empty payloads, but contains no inverse check requiring normal blocks to have non-empty payloads: [1](#0-0) 

**Payload Size Checks**: The proposal validation in `process_proposal()` only enforces maximum limits, not minimum requirements. Empty payloads (len=0, size=0) pass all checks: [2](#0-1) 

**Proposer Validation**: The `is_valid_proposal()` check only verifies the proposer is legitimate for the round and hasn't equivocated—it doesn't validate payload content: [3](#0-2) 

**Attack Execution**: A malicious validator can:
1. Modify their node to call `Payload::empty()` directly instead of pulling from mempool
2. Or manipulate `pull_payload()` parameters to always return empty
3. Sign and broadcast the empty block
4. Other validators validate and vote for it (it's well-formed)
5. Block gets committed with 0 transactions [4](#0-3) 

**Detection Bypass**: The validator stats tracking counts this as a successful proposal, NOT a failure: [5](#0-4) 

The validator is NOT added to `failed_authors`, doesn't trigger failure rate thresholds, and receives full rewards through the staking system.

## Impact Explanation

**Severity: Medium**

This vulnerability enables a stealth DoS attack that bypasses automated detection:

1. **Network Throughput Degradation**: When the malicious validator is selected as proposer, 0 transactions are processed in that round, directly reducing network TPS proportional to their selection frequency

2. **Reward Theft**: The validator receives full staking rewards despite not performing transaction processing work, effectively stealing from honest validators

3. **Detection Evasion**: Unlike validators who fail to propose (marked in `failed_authors` and penalized via reputation), empty block proposers appear as successful in all monitoring systems

4. **Prolonged Attack Window**: Manual investigation is required to detect the attack; no automatic penalties trigger even after multiple rounds of empty blocks

This meets **Medium severity** criteria as it causes state inconsistencies requiring manual intervention (operator must identify and remove malicious validator) and enables limited economic manipulation (unearned rewards).

## Likelihood Explanation

**Likelihood: Medium-High**

- **Attacker Requirements**: Must control a validator with non-zero stake (achievable through staking)
- **Technical Complexity**: Low—simple node modification to call `Payload::empty()`
- **Detection Difficulty**: High—no automated alerts, appears as valid proposals in metrics
- **Economic Incentive**: Moderate—receive rewards with minimal work, degrade competitors
- **Attack Sustainability**: High—can continue for extended periods before manual detection

The attack is practical and economically rational for a malicious validator, particularly in competitive network conditions.

## Recommendation

Implement validation to require non-empty payloads for normal (non-reconfiguration) blocks when transactions are available. Add this check in `Block::verify_well_formed()`:

```rust
// In consensus/consensus-types/src/block.rs, after line 488:
if !parent.has_reconfiguration() && !self.is_nil_block() {
    // For normal blocks, enforce minimum transaction threshold
    // unless mempool is genuinely empty (validated via separate mechanism)
    if let Some(payload) = self.payload() {
        if payload.is_empty() {
            // Allow empty only if this is a timeout/nil case
            // In practice, honest validators should include available transactions
            warn!(
                "Normal block {} has empty payload - may indicate malicious behavior",
                self.id()
            );
        }
    }
}
```

**Additional Mitigations**:
1. Track "empty block ratio" per validator in reputation system
2. Reduce rewards proportionally based on transaction throughput
3. Add monitoring alerts for validators with anomalously low transaction counts
4. Consider marking validators with consistent empty blocks in `failed_authors` mechanism

## Proof of Concept

```rust
// Malicious validator modification in consensus/src/liveness/proposal_generator.rs
// Instead of calling generate_proposal_inner(), do this:

async fn generate_proposal(
    &self,
    round: Round,
    proposer_election: Arc<dyn ProposerElection + Send + Sync>,
) -> anyhow::Result<BlockData> {
    let hqc = self.ensure_highest_quorum_cert(round)?;
    
    // MALICIOUS: Always return empty payload regardless of mempool state
    let payload = Payload::empty(
        self.quorum_store_enabled,
        self.allow_batches_without_pos_in_proposal,
    );
    
    let timestamp = self.time_service.get_current_timestamp().as_micros() as u64;
    let quorum_cert = hqc.as_ref().clone();
    let failed_authors = self.compute_failed_authors(
        round,
        quorum_cert.certified_block().round(),
        false,
        proposer_election,
    );
    
    let block = BlockData::new_proposal(
        payload,
        self.author,
        failed_authors,
        round,
        timestamp,
        quorum_cert,
    );
    
    Ok(block)
}

// Verification: The block passes all validation in process_proposal()
// - verify_well_formed() ✓ (no check for empty payload)
// - payload_len check ✓ (0 <= max_limit)
// - is_valid_proposal() ✓ (correct proposer)
// Result: Block is accepted, committed, validator marked as successful
```

**Notes**

This vulnerability violates the implicit assumption that validators will include available transactions when proposing blocks. While the system tolerates up to 1/3 Byzantine validators, the lack of detection for this specific attack vector (valid proposals with intentionally empty payloads) creates an exploitable asymmetry: validators who fail to propose are penalized, but validators who propose empty blocks are rewarded. This enables a more subtle form of network degradation that persists longer due to delayed detection compared to outright proposal failures.

### Citations

**File:** consensus/consensus-types/src/block.rs (L483-488)
```rust
        if parent.has_reconfiguration() {
            ensure!(
                self.payload().is_none_or(|p| p.is_empty()),
                "Reconfiguration suffix should not carry payload"
            );
        }
```

**File:** consensus/src/round_manager.rs (L1178-1193)
```rust
        let payload_len = proposal.payload().map_or(0, |payload| payload.len());
        let payload_size = proposal.payload().map_or(0, |payload| payload.size());
        ensure!(
            num_validator_txns + payload_len as u64 <= self.local_config.max_receiving_block_txns,
            "Payload len {} exceeds the limit {}",
            payload_len,
            self.local_config.max_receiving_block_txns,
        );

        ensure!(
            validator_txns_total_bytes + payload_size as u64
                <= self.local_config.max_receiving_block_bytes,
            "Payload size {} exceeds the limit {}",
            payload_size,
            self.local_config.max_receiving_block_bytes,
        );
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L46-87)
```rust
    pub fn is_valid_proposal(&self, block: &Block) -> bool {
        block.author().is_some_and(|author| {
            let valid_author = self.is_valid_proposer(author, block.round());
            if !valid_author {
                warn!(
                    SecurityEvent::InvalidConsensusProposal,
                    "Proposal is not from valid author {}, expected {} for round {} and id {}",
                    author,
                    self.get_valid_proposer(block.round()),
                    block.round(),
                    block.id()
                );

                return false;
            }
            let mut already_proposed = self.already_proposed.lock();
            // detect if the leader proposes more than once in this round
            match block.round().cmp(&already_proposed.0) {
                Ordering::Greater => {
                    already_proposed.0 = block.round();
                    already_proposed.1 = block.id();
                    true
                },
                Ordering::Equal => {
                    if already_proposed.1 != block.id() {
                        error!(
                            SecurityEvent::InvalidConsensusProposal,
                            "Multiple proposals from {} for round {}: {} and {}",
                            author,
                            block.round(),
                            already_proposed.1,
                            block.id()
                        );
                        false
                    } else {
                        true
                    }
                },
                Ordering::Less => false,
            }
        })
    }
```

**File:** consensus/consensus-types/src/common.rs (L271-280)
```rust
    pub fn empty(quorum_store_enabled: bool, allow_batches_without_pos_in_proposal: bool) -> Self {
        if quorum_store_enabled {
            if allow_batches_without_pos_in_proposal {
                Payload::QuorumStoreInlineHybrid(Vec::new(), ProofWithData::new(Vec::new()), None)
            } else {
                Payload::InQuorumStore(ProofWithData::new(Vec::new()))
            }
        } else {
            Payload::DirectMempool(Vec::new())
        }
```

**File:** crates/aptos/src/node/analyze/analyze_validators.rs (L435-471)
```rust
            if !is_nil {
                *successes.entry(event.proposer()).or_insert(0) += 1;
            }

            for failed_proposer_index in event.failed_proposer_indices() {
                *failures
                    .entry(validators[*failed_proposer_index as usize].address)
                    .or_insert(0) += 1;
            }

            let previous_block_votes_bitvec: BitVec =
                event.previous_block_votes_bitvec().clone().into();
            assert_eq!(
                BitVec::required_buckets(validators.len() as u16),
                previous_block_votes_bitvec.num_buckets()
            );
            for (i, validator) in validators.iter().enumerate() {
                if previous_block_votes_bitvec.is_set(i as u16) {
                    *votes.entry(validator.address).or_insert(0) += 1;
                }
            }

            let cur_transactions_option = blocks
                .get(pos + 1)
                .map(|next| u32::try_from(next.version - block.version - 2).unwrap());
            let cur_next_block_option = blocks.get(pos + 1);
            if let Some(cur_transactions) = cur_transactions_option {
                if is_nil {
                    assert_eq!(
                        cur_transactions,
                        0,
                        "{} {:?}",
                        block.version,
                        blocks.get(pos + 1)
                    );
                }
                *transactions.entry(event.proposer()).or_insert(0) += cur_transactions;
```
