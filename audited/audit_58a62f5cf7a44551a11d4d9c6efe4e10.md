# Audit Report

## Title
Null Pointer Panic in Indexer Status Page Due to Missing Timestamp Validation

## Summary
The `get_throughput_from_samples()` function in the indexer-grpc status page unconditionally calls `.unwrap()` on optional timestamp fields without validation. A malicious or buggy data service can send heartbeat messages containing `StreamProgressSampleProto` with `None` timestamps, causing the grpc-manager status page to panic and crash when accessed.

## Finding Description

The vulnerability exists in the status page rendering code that displays throughput metrics for active data streams. The Protocol Buffer definition marks the timestamp field as optional [1](#0-0) , which translates to `Option<Timestamp>` in the generated Rust code [2](#0-1) .

The grpc-manager service receives heartbeat requests from external data services via gRPC [3](#0-2) . These heartbeat messages contain stream progress information that is stored without validation [4](#0-3) .

When the status page is rendered, the stored progress data is passed to `get_throughput_from_samples()` [5](#0-4) , which unconditionally unwraps the timestamp field [6](#0-5) . Additional unwrap calls exist at lines 104-105 of the same function.

**Attack Flow:**
1. Attacker deploys a malicious data service that connects to the grpc-manager
2. The malicious service sends heartbeat requests with `StreamProgressSampleProto` containing `timestamp: None`
3. The grpc-manager stores this malformed data without validation
4. When an administrator or monitoring system accesses the status page endpoint
5. The `get_throughput_from_samples()` function panics on `.unwrap()`, crashing the status page handler

While the legitimate data service implementation always sets timestamps [7](#0-6) , there is no enforcement at the protocol or validation layer preventing malformed data from external sources.

## Impact Explanation

This vulnerability is classified as **High Severity** per the Aptos bug bounty program under the "API crashes" category. 

**Impact:**
- The status page API becomes unavailable when accessed after malformed data is received
- Operational visibility is lost for monitoring indexer service health
- Potential for repeated DoS attacks by continuously sending malformed heartbeats
- The grpc-manager service itself may become unstable if the panic propagates

While this does not affect core blockchain consensus, execution, or fund security, it significantly impacts the availability of critical monitoring infrastructure for the Aptos indexer ecosystem.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is straightforward to execute:
- **Low barrier to entry:** Any entity can deploy a data service and connect to the grpc-manager
- **No authentication bypass needed:** The vulnerability exists in normal protocol flow
- **Immediate impact:** Single malformed heartbeat can cause status page crashes
- **Persistent effect:** Malformed data is stored and will cause crashes on every status page access

The likelihood is somewhat reduced because:
- Legitimate data services consistently set timestamps correctly
- The attack requires the attacker to operate a registered data service
- Detection would be relatively quick due to immediate status page failures

However, a buggy data service implementation could also trigger this unintentionally, making the vulnerability relevant even without malicious intent.

## Recommendation

Add defensive validation to check for `None` timestamps before unwrapping. The fix should be applied in `get_throughput_from_samples()`:

```rust
pub fn get_throughput_from_samples(
    progress: Option<&StreamProgress>,
    duration: Duration,
) -> String {
    if let Some(progress) = progress {
        let now = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap()
            .as_secs_f64();
        let index = progress.samples.partition_point(|p| {
            // Add validation for timestamp presence
            let Some(timestamp) = p.timestamp.as_ref() else {
                return false; // Skip samples without timestamps
            };
            let diff = now - timestamp_to_unixtime(timestamp);
            diff > duration.as_secs_f64()
        });

        if index + 1 < progress.samples.len() {
            let sample_a = progress.samples[index];
            let sample_b = progress.samples.last().unwrap();
            
            // Validate timestamps exist before processing
            let (Some(timestamp_a), Some(timestamp_b)) = 
                (sample_a.timestamp.as_ref(), sample_b.timestamp.as_ref()) else {
                return "Invalid data".to_string();
            };
            
            let time_diff = timestamp_to_unixtime(timestamp_b)
                - timestamp_to_unixtime(timestamp_a);
            let tps = (sample_b.version - sample_a.version) as f64 / time_diff;
            let bps = (sample_b.size_bytes - sample_a.size_bytes) as f64 / time_diff;
            return format!(
                "{} tps, {} / s",
                tps as u64,
                bytesize::to_string(bps as u64, false)
            );
        }
    }

    "No data".to_string()
}
```

Additionally, consider adding validation in the heartbeat handler to reject malformed data early and log warnings about data services sending invalid samples.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_protos::indexer::v1::{StreamProgress, StreamProgressSampleProto};

    #[test]
    #[should_panic(expected = "called `Option::unwrap()` on a `None` value")]
    fn test_panic_on_none_timestamp() {
        // Create a StreamProgressSampleProto with None timestamp
        let sample = StreamProgressSampleProto {
            timestamp: None,  // Malicious/malformed data
            version: 1000,
            size_bytes: 50000,
        };
        
        let progress = StreamProgress {
            samples: vec![sample],
        };
        
        // This will panic when accessing the status page
        let result = get_throughput_from_samples(
            Some(&progress),
            Duration::from_secs(10),
        );
        
        // Should not reach here due to panic
        println!("Result: {}", result);
    }
}
```

To demonstrate the vulnerability in a live system:
1. Deploy a modified data service that sends heartbeats with `timestamp: None` in sample protos
2. Connect it to a grpc-manager instance  
3. Send at least one heartbeat containing malformed samples
4. Access the status page endpoint (`/status`)
5. Observe the panic and service crash in the grpc-manager logs

### Citations

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L12-16)
```text
message StreamProgressSampleProto {
  optional aptos.util.timestamp.Timestamp timestamp = 1;
  uint64 version = 2;
  uint64 size_bytes = 3;
}
```

**File:** protos/rust/src/pb/aptos.indexer.v1.rs (L159-167)
```rust
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StreamProgressSampleProto {
    #[prost(message, optional, tag="1")]
    pub timestamp: ::core::option::Option<super::super::util::timestamp::Timestamp>,
    #[prost(uint64, tag="2")]
    pub version: u64,
    #[prost(uint64, tag="3")]
    pub size_bytes: u64,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/status_page.rs (L327-343)
```rust
                            get_throughput_from_samples(
                                active_stream.progress.as_ref(),
                                Duration::from_secs(10),
                            ),
                        ))
                        .with_cell(TableCell::new(TableCellType::Data).with_raw(
                            get_throughput_from_samples(
                                active_stream.progress.as_ref(),
                                Duration::from_secs(60),
                            ),
                        ))
                        .with_cell(TableCell::new(TableCellType::Data).with_raw(
                            get_throughput_from_samples(
                                active_stream.progress.as_ref(),
                                Duration::from_secs(600),
                            ),
                        )),
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/status_page/mod.rs (L94-96)
```rust
        let index = progress.samples.partition_point(|p| {
            let diff = now - timestamp_to_unixtime(p.timestamp.as_ref().unwrap());
            diff > duration.as_secs_f64()
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L42-52)
```rust
    fn to_proto(&self) -> Vec<StreamProgressSampleProto> {
        self.old_samples
            .iter()
            .chain(self.recent_samples.iter())
            .map(|sample| StreamProgressSampleProto {
                timestamp: Some(system_time_to_proto(sample.timestamp)),
                version: sample.version,
                size_bytes: sample.size_bytes,
            })
            .collect()
    }
```
