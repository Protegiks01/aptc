# Audit Report

## Title
Unauthenticated Denial of Service via Malformed BCS Deserialization in Remote Executor Service

## Summary
The `RemoteCrossShardClient` in the executor service uses `.unwrap()` on BCS deserialization of incoming network messages, allowing an unauthenticated attacker to crash executor service shards by sending malformed messages through the network controller's gRPC interface.

## Finding Description

The network controller system in `secure/net/src/network_controller/mod.rs` uses gRPC with protobuf for message transport, but application payloads are serialized using BCS (Binary Canonical Serialization). The `RemoteCrossShardClient` implementation contains a critical parsing vulnerability where BCS deserialization failures cause service panics. [1](#0-0) 

The vulnerability exists because:

1. The network controller accepts messages from any network peer without authentication
2. Messages are routed based on a string-based `message_type` field (e.g., "cross_shard_0")
3. The message payload is raw bytes that should deserialize to a `CrossShardMsg`
4. Line 64 uses `.unwrap()` which panics if deserialization fails

The network controller infrastructure lacks authentication: [2](#0-1) 

The gRPC service accepts messages from any remote address without verifying peer identity. An attacker can send a protobuf `NetworkMessage` with a valid `message_type` but malformed BCS bytes in the `message` field.

**Attack Propagation:**
1. Attacker connects to executor service's gRPC endpoint (address specified in command-line arguments)
2. Sends gRPC `SimpleMsgExchange` request with `message_type="cross_shard_0"` 
3. Provides invalid BCS bytes in `message` field (e.g., truncated data, wrong enum variant, corrupted structure)
4. Message routes to registered handler which calls `receive_cross_shard_msg()`
5. BCS deserialization fails, `.unwrap()` panics, executor service thread crashes

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." A parsing failure should return an error, not crash the service.

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria: "API crashes" and "Validator node slowdowns."

**Impact Scope:**
- Crashes individual executor service shards handling sharded block execution
- If all shards are repeatedly crashed, distributed block execution becomes unavailable
- Affects validators using distributed execution mode for performance scaling
- No authentication barrier - any network peer can exploit this
- Can be automated to maintain persistent DoS

The executor service is production code with a compiled binary: [3](#0-2) 

While not every validator may use sharded execution, those that do become vulnerable. The 80 MB message size limit doesn't prevent this attack since even a 1-byte malformed payload triggers the panic. [4](#0-3) 

## Likelihood Explanation

**Likelihood: High**

Attack requirements:
- Network access to executor service gRPC endpoint (may be internal network)
- Ability to send gRPC requests (standard tools like grpcurl suffice)
- Knowledge of message type format ("cross_shard_N" where N is round number)
- No authentication or authorization needed

Attacker complexity: **Low**
- Craft malformed BCS bytes (even random data works)
- Send via standard gRPC client
- Automated attacks are trivial to implement

The lack of authentication in the network controller is confirmed by examining the codebase - there's no handshake, peer validation, or access control in the `GRPCNetworkMessageServiceServerWrapper` implementation.

## Recommendation

**Immediate Fix:** Replace `.unwrap()` with proper error handling in `receive_cross_shard_msg`:

```rust
fn receive_cross_shard_msg(&self, current_round: RoundId) -> Result<CrossShardMsg, CrossShardError> {
    let rx = self.message_rxs[current_round].lock().unwrap();
    let message = rx.recv().map_err(|e| CrossShardError::ReceiveError(e))?;
    let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes())
        .map_err(|e| CrossShardError::DeserializationError(e))?;
    Ok(msg)
}
```

**Long-term Fixes:**
1. Add authentication to the network controller using Noise protocol handshakes (similar to the main network layer)
2. Implement peer allowlisting for executor services
3. Add message validation before deserialization (check message type registry)
4. Add comprehensive error handling for all BCS deserialization operations
5. Consider using Result types throughout the CrossShardClient trait

Similar patterns should be audited throughout the codebase: [5](#0-4) 

Line 56 also uses `.unwrap()` on serialization (though less critical since it's outbound).

## Proof of Concept

```rust
// Add to execution/executor-service/src/tests.rs

#[test]
fn test_malformed_cross_shard_message_crash() {
    use aptos_secure_net::network_controller::{Message, NetworkController};
    use std::net::{IpAddr, Ipv4Addr, SocketAddr};
    
    // Setup executor service
    let server_port = aptos_config::utils::get_available_port();
    let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), server_port);
    let mut controller = NetworkController::new("test".to_string(), server_addr, 1000);
    
    let client = RemoteCrossShardClient::new(&mut controller, vec![server_addr]);
    controller.start();
    
    // Create malformed BCS data (not a valid CrossShardMsg)
    let malformed_bcs = vec![0xFF, 0xFF, 0xFF, 0xFF]; // Invalid BCS enum variant
    
    // Send message through network controller
    let tx = controller.create_outbound_channel(server_addr, "cross_shard_0".to_string());
    tx.send(Message::new(malformed_bcs)).unwrap();
    
    // This should panic on unwrap() in receive_cross_shard_msg
    // In production, this crashes the executor service
    let result = std::panic::catch_unwind(|| {
        client.receive_cross_shard_msg(0)
    });
    
    assert!(result.is_err(), "Service should panic on malformed message");
}
```

To reproduce manually:
1. Start an executor service: `cargo run --bin aptos-executor-service -- --shard-id 0 --num-shards 2 --coordinator-address 127.0.0.1:8000 --remote-executor-addresses 127.0.0.1:8001 127.0.0.1:8002`
2. Send malformed gRPC message using grpcurl with invalid BCS bytes
3. Observe service crash with panic message

## Notes

The serde-based `NetworkMessage` struct at line 22 of `secure/net/src/network_controller/mod.rs` is dead code with `#[allow(dead_code)]` and is never used for network serialization. The actual vulnerability exists in the BCS deserialization layer that processes message payloads, not in serde itself. However, this still constitutes a "parsing bug that could be exploited with crafted messages" as specified in the security question, since BCS deserialization is the parsing operation that processes incoming network messages in this system.

### Citations

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-59)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L61-66)
```rust
    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```

**File:** secure/net/src/grpc_network_service/mod.rs (L92-115)
```rust
impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** execution/executor-service/src/main.rs (L27-48)
```rust
fn main() {
    let args = Args::parse();
    aptos_logger::Logger::new().init();

    let (tx, rx) = crossbeam_channel::unbounded();
    ctrlc::set_handler(move || {
        tx.send(()).unwrap();
    })
    .expect("Error setting Ctrl-C handler");

    let _exe_service = ProcessExecutorService::new(
        args.shard_id,
        args.num_shards,
        args.num_executor_threads,
        args.coordinator_address,
        args.remote_executor_addresses,
    );

    rx.recv()
        .expect("Could not receive Ctrl-C msg from channel.");
    info!("Process executor service shutdown successfully.");
}
```
