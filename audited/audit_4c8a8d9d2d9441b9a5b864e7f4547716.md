# Audit Report

## Title
Gas Undercharging via Deferred Charging in Legacy Native Function Execution Path

## Summary
In the legacy gas charging path (gas_feature_version < 36), native functions with incremental gas charging disabled can accumulate gas charges that collectively exceed the remaining gas budget without triggering immediate out-of-gas errors. This allows attackers to obtain computational work that exceeds what they paid for, as the VM only charges the remaining balance when the accumulated gas finally exceeds the budget.

## Finding Description

The vulnerability exists in the `charge()` function's legacy execution path. [1](#0-0) 

When `legacy_enable_incremental_gas_charging` is `false` (which is the default for table natives and stdlib natives), the `charge()` function accumulates gas in `legacy_gas_used` without checking if it exceeds the budget. [2](#0-1) 

Table natives explicitly disable incremental gas charging: [3](#0-2) 

Move stdlib natives also disable incremental gas charging: [4](#0-3) 

Table natives follow a problematic pattern where they charge base costs upfront, perform expensive operations, then charge variable costs based on the work already done: [5](#0-4) 

The code even contains TODO comments acknowledging this issue: [6](#0-5) 

After the native function completes, the VM charges the accumulated gas: [7](#0-6) 

When the charge fails due to insufficient balance, only the remaining balance is deducted: [8](#0-7) 

**Attack Flow:**
1. Attacker initiates transaction with 1,000 gas remaining
2. Calls `native_borrow_box` with a large key
3. Native charges base cost (e.g., 100 gas) - succeeds, `legacy_gas_used = 100`
4. Native performs key serialization and table operations (expensive work)
5. Native charges variable costs (e.g., 5,000 gas for large key) - succeeds without checking budget, `legacy_gas_used = 5,100`
6. Native returns accumulated gas of 5,100
7. VM attempts to charge 5,100 gas but only 1,000 remains
8. Charges 1,000 gas and aborts transaction
9. Attacker obtained 5,100 gas worth of computation for 1,000 gas

This breaks the **Resource Limits** invariant that "All operations must respect gas limits" and the **Move VM Safety** invariant that "Bytecode execution must respect gas limits and memory constraints."

## Impact Explanation

**Medium Severity** - This constitutes gas undercharging and resource exhaustion:

1. **Validator Resource Exhaustion**: Attackers can force validators to perform expensive computations (key serialization, table lookups, cryptographic operations) that are not fully paid for.

2. **Gas Mechanism Bypass**: The fundamental gas metering system is bypassed, allowing operations to complete that should have been rejected due to insufficient gas.

3. **Economic Impact**: While state changes are rolled back on transaction abort, the computational resources (CPU cycles, memory bandwidth) have already been consumed without proper compensation.

The impact qualifies as Medium severity under "Limited funds loss" (validators lose computational resources) and could enable targeted DoS attacks against validator nodes.

## Likelihood Explanation

**Low to Medium Likelihood:**

**Limiting Factors:**
- Only affects deployments running `gas_feature_version < 36` (RELEASE_V1_32)
- Current latest version is 45 (RELEASE_V1_41) [9](#0-8) 
- Modern deployments use direct gas meter access which is not vulnerable [10](#0-9) 

**Risk Scenarios:**
- Testnets or private deployments running older gas feature versions
- Regression scenarios where gas feature version is inadvertently lowered
- Long-running private chains that haven't upgraded
- Rollback scenarios during incident response

**Ease of Exploitation:**
- High - Attack only requires crafting transactions with large inputs to table operations
- No special privileges required
- Can be automated for sustained attacks

## Recommendation

**Immediate Fix**: Enforce incremental gas checking even in legacy mode:

```rust
// In context.rs, charge() function:
} else {
    self.legacy_gas_used += amount;
    // Always check budget, regardless of incremental charging flag
    if self.legacy_gas_used > self.legacy_gas_budget() {
        Err(SafeNativeError::LimitExceeded(
            LimitExceededError::LegacyOutOfGas,
        ))
    } else {
        Ok(())
    }
}
```

**Structural Fix for Table Natives**: Implement pre-calculation of maximum possible gas cost before performing operations:

```rust
fn native_add_box(...) -> SafeNativeResult<...> {
    // Estimate maximum possible cost upfront
    let max_key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(estimated_max_key_size);
    let max_total_cost = ADD_BOX_BASE + max_key_cost;
    
    // Charge maximum upfront
    context.charge(max_total_cost)?;
    
    // Perform operations
    let key_bytes = serialize_key(...)?;
    let actual_key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len());
    
    // Refund difference (requires refund mechanism)
    let refund = max_total_cost - ADD_BOX_BASE - actual_key_cost;
    context.refund(refund)?;
    
    // Continue with operation
}
```

**Long-term**: Deprecate and remove legacy gas charging path entirely once all networks upgrade to gas_feature_version >= 36.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_gas_undercharging_via_deferred_charging() {
    use aptos_gas_schedule::gas_params::natives::table::*;
    use move_core_types::gas_algebra::NumBytes;
    
    // Setup: gas_feature_version = 35 (legacy mode)
    // Initial balance: 1000 internal gas units
    // Attacker calls native_borrow_box with large key
    
    let base_cost = 100;  // ADD_BOX_BASE
    let key_size = 5000;  // Large key
    let per_byte_cost = 1;  // ADD_BOX_PER_BYTE_SERIALIZED
    let variable_cost = per_byte_cost * key_size;
    
    let total_cost = base_cost + variable_cost;  // 5100 gas
    let remaining_balance = 1000;  // Attacker's remaining gas
    
    // Step 1: Charge base cost (succeeds)
    assert!(base_cost <= remaining_balance);
    let accumulated = base_cost;
    
    // Step 2: Perform expensive work (key serialization, table lookup)
    // ... operations happen here ...
    
    // Step 3: Charge variable cost (succeeds in legacy mode without checking)
    // In legacy mode with incremental_gas_charging = false:
    // charge() returns Ok() even though accumulated + variable_cost > remaining_balance
    let accumulated = accumulated + variable_cost;  // 5100
    
    // Step 4: VM charges total accumulated gas
    // Only 1000 gas remains, so charges 1000 and aborts
    let actually_charged = remaining_balance;  // 1000
    
    // Result: Attacker got 5100 gas worth of work for 1000 gas
    let free_computation = total_cost - actually_charged;
    assert_eq!(free_computation, 4100);  // 4100 gas of free work
    
    println!("Attacker obtained {} gas units of free computation", free_computation);
}
```

## Notes

This vulnerability is **limited to the legacy gas charging path** which is only active when `gas_feature_version < 36`. The modern path introduced in RELEASE_V1_32 uses direct gas meter access and is **not vulnerable** because it checks gas limits immediately on each charge call. [10](#0-9) 

The legacy path exists for backward compatibility and may still be in use on testnets, private deployments, or older networks that have not upgraded to gas feature version 36 or higher. Current mainnet deployments likely use version 45 and are not affected. [11](#0-10)

### Citations

**File:** aptos-move/aptos-native-interface/src/context.rs (L86-90)
```rust
        if self.has_direct_gas_meter_access_in_native_context() {
            self.gas_meter()
                .charge_native_execution(amount)
                .map_err(LimitExceededError::from_err)?;
            Ok(())
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L91-102)
```rust
        } else {
            self.legacy_gas_used += amount;
            if self.legacy_gas_used > self.legacy_gas_budget()
                && self.legacy_enable_incremental_gas_charging
            {
                Err(SafeNativeError::LimitExceeded(
                    LimitExceededError::LegacyOutOfGas,
                ))
            } else {
                Ok(())
            }
        }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L301-301)
```rust
    builder.with_incremental_gas_charging(false, |builder| {
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L394-444)
```rust
    context.charge(ADD_BOX_BASE)?;
    let fix_memory_double_counting =
        context.timed_feature_enabled(TimedFeatureFlag::FixTableNativesMemoryDoubleCounting);

    let (extensions, mut loader_context, abs_val_gas_params, gas_feature_version) =
        context.extensions_with_loader_context_and_gas_params();
    let table_context = extensions.get::<NativeTableContext>();
    let mut table_data = table_context.table_data.borrow_mut();

    let val = args.pop_back().unwrap();
    let key = args.pop_back().unwrap();
    let handle = get_table_handle(&safely_pop_arg!(args, StructRef))?;

    let table =
        table_data.get_or_create_table(&mut loader_context, handle, &ty_args[0], &ty_args[2])?;

    let function_value_extension = loader_context.function_value_extension();
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);

    let (gv, loaded) =
        table.get_or_create_global_value(&function_value_extension, table_context, key_bytes)?;
    let mem_usage = if !fix_memory_double_counting || loaded.is_some() {
        gv.view()
            .map(|val| {
                abs_val_gas_params
                    .abstract_heap_size(&val, gas_feature_version)
                    .map(u64::from)
            })
            .transpose()?
    } else {
        None
    };

    let res = match gv.move_to(val) {
        Ok(_) => Ok(smallvec![]),
        Err(_) => Err(SafeNativeError::Abort {
            abort_code: ALREADY_EXISTS,
        }),
    };

    drop(table_data);

    // TODO(Gas): Figure out a way to charge this earlier.
    context.charge(key_cost)?;
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
    charge_load_cost(context, loaded)?;

    res
```

**File:** aptos-move/framework/move-stdlib/src/natives/mod.rs (L38-38)
```rust
    builder.with_incremental_gas_charging(false, |builder| {
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1106-1115)
```rust
        let result = native_function(&mut native_context, ty_args, args)?;

        // Note(Gas): The order by which gas is charged / error gets returned MUST NOT be modified
        //            here or otherwise it becomes an incompatible change!!!
        match result {
            NativeResult::Success {
                cost,
                ret_vals: return_values,
            } => {
                gas_meter.charge_native_function(cost, Some(return_values.iter()))?;
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L189-201)
```rust
        match self.balance.checked_sub(amount) {
            Some(new_balance) => {
                self.balance = new_balance;
                self.execution_gas_used += amount;
            },
            None => {
                let old_balance = self.balance;
                self.balance = 0.into();
                if self.feature_version >= 12 {
                    self.execution_gas_used += old_balance;
                }
                return Err(PartialVMError::new(StatusCode::OUT_OF_GAS));
            },
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L76-76)
```rust
pub const LATEST_GAS_FEATURE_VERSION: u64 = gas_feature_versions::RELEASE_V1_41;
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L102-102)
```rust
    pub const RELEASE_V1_32: u64 = 36;
```
