# Audit Report

## Title
PVSS Transcript Verification Accepts Trivial Transcripts with Identity Elements, Enabling Free-Riding in DKG

## Summary
A malicious validator can construct a PVSS transcript containing only identity elements (zero group elements) that passes all cryptographic verification checks in the weighted DAS protocol. This allows validators to appear to participate in Distributed Key Generation (DKG) without contributing any randomness, violating the protocol's security assumptions.

## Finding Description

The PVSS transcript verification in `weighted_protocol.rs` accepts transcripts where all commitments (`V`, `V_hat`, `R`, `R_hat`, `C`) are identity elements, and the dealt public key is the identity element. This breaks the fundamental security guarantee that verified transcripts contribute non-trivial secrets to the DKG. [1](#0-0) 

**Why All Verification Checks Pass:**

1. **Schnorr Proof-of-Knowledge Verification**: When the dealt public key is identity (discrete log = 0), an attacker can construct a valid PoK by setting `R = g^r`, `s = r`. The verification equation `R^γ * pk^(e*γ) * g^(-s*γ) = g^(r*γ) * identity^(e*γ) * g^(-r*γ) = identity` holds trivially. [2](#0-1) 

2. **Low-Degree Test**: When all `V` elements are identity, `multi_exp(V, coefficients)` returns identity regardless of coefficients, making the check `identity == identity` pass. [3](#0-2) 

3. **Multi-Pairing Correctness Check**: All linear combinations become identity since `multi_exp_iter` of identity elements returns identity. Since `pairing(g, identity) = 1_Gt` for any `g`, the entire pairing equation evaluates to `1_Gt = 1_Gt`. [4](#0-3) 

**The underlying issue** is that `multi_exp_iter` returns identity when all bases are identity, regardless of the scalar values: [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. Malicious validator creates `Transcript` with all identity elements
2. Constructs valid Schnorr PoK for identity commitment  
3. Signs contribution with legitimate BLS key
4. Submits transcript to DKG protocol
5. Transcript passes verification and appears valid
6. When aggregated with honest transcripts, contributes zero (identity is additive no-op) [7](#0-6) 

## Impact Explanation

**Severity: HIGH** - Significant protocol violation per Aptos bug bounty criteria.

This vulnerability enables:
- **Protocol Violation**: Validators can bypass cryptographic verification while appearing to participate honestly
- **Randomness Security Degradation**: If multiple validators exploit this, the effective entropy of the randomness beacon decreases
- **Free-Riding Attack**: Malicious validators gain validator rewards without contributing to protocol security
- **Liveness Risk**: If threshold number of validators submit trivial transcripts, DKG may fail to generate sufficient randomness

The impact violates the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure." The verification accepts cryptographically meaningless commitments that don't prove knowledge of any secret.

## Likelihood Explanation

**Likelihood: HIGH**

- Requires only single malicious validator (no collusion needed)
- Trivial to construct: just fill arrays with `G1Projective::identity()` / `G2Projective::identity()`
- No computational barriers or timing constraints
- Indistinguishable from valid transcripts until decryption time
- No detection mechanism in place

The attack is practical and could be deployed by any validator wishing to reduce participation costs or harm randomness generation.

## Recommendation

Add explicit validation that dealt public keys and commitments are not identity elements:

```rust
// In weighted_protocol.rs, add to verify() function after line 288:

// Validate dealt public key is not identity
if self.V[W] == G1Projective::identity() || self.V_hat[W] == G2Projective::identity() {
    bail!("Dealt public key cannot be the identity element");
}

// Validate commitments are non-trivial
for i in 0..W {
    if self.V[i] == G1Projective::identity() || 
       self.V_hat[i] == G2Projective::identity() ||
       self.R[i] == G1Projective::identity() ||
       self.R_hat[i] == G2Projective::identity() ||
       self.C[i] == G1Projective::identity() {
        bail!("Transcript commitments cannot contain identity elements");
    }
}
```

Additionally, consider adding a non-zero check in the input secret generation: [8](#0-7) 

## Proof of Concept

```rust
#[test]
fn test_trivial_transcript_passes_verification() {
    use aptos_dkg::pvss::{
        das::{weighted_protocol::Transcript, PublicParameters},
        traits::{AggregatableTranscript, Transcript as _},
        WeightedConfigBlstrs,
    };
    use aptos_crypto::bls12381::PrivateKey;
    use blstrs::{G1Projective, G2Projective};
    use group::Group;
    
    // Setup
    let sc = WeightedConfigBlstrs::new(2, 3, vec![1, 1, 1]).unwrap();
    let pp = PublicParameters::default();
    let ssk = PrivateKey::genesis();
    let spk = ssk.public_key();
    
    // Create trivial transcript with all identity elements
    let W = sc.get_total_weight();
    let mut transcript = Transcript {
        soks: vec![(
            sc.get_player(0),
            G1Projective::identity(),
            ssk.sign(&aptos_dkg::pvss::contribution::Contribution {
                comm: G1Projective::identity(),
                player: sc.get_player(0),
                aux: 0usize,
            }).unwrap(),
            (G1Projective::identity(), blstrs::Scalar::ZERO),
        )],
        V: vec![G1Projective::identity(); W + 1],
        V_hat: vec![G2Projective::identity(); W + 1],
        R: vec![G1Projective::identity(); W],
        R_hat: vec![G2Projective::identity(); W],
        C: vec![G1Projective::identity(); W],
    };
    
    let eks = vec![/* ... encryption keys ... */];
    let auxs = vec![0usize];
    
    // This should fail but currently passes!
    let result = transcript.verify(&sc, &pp, &[spk], &eks, &auxs);
    assert!(result.is_ok(), "Trivial transcript should be rejected but passes!");
}
```

## Notes

This vulnerability affects the core DKG randomness generation mechanism used by Aptos validators. While the aggregated randomness remains secure as long as sufficient honest validators participate, the ability to bypass verification without detection represents a significant protocol violation. The fix should be implemented before deploying DKG to mainnet or when validators can exploit this for economic gain.

### Citations

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L280-377)
```rust
    fn verify<A: Serialize + Clone>(
        &self,
        sc: &<Self as traits::Transcript>::SecretSharingConfig,
        pp: &Self::PublicParameters,
        spks: &[Self::SigningPubKey],
        eks: &[Self::EncryptPubKey],
        auxs: &[A],
    ) -> anyhow::Result<()> {
        self.check_sizes(sc)?;
        let n = sc.get_total_num_players();
        if eks.len() != n {
            bail!("Expected {} encryption keys, but got {}", n, eks.len());
        }
        let W = sc.get_total_weight();

        // Deriving challenges by flipping coins: less complex to implement & less likely to get wrong. Creates bad RNG risks but we deem that acceptable.
        let mut rng = rand::thread_rng();
        let extra = random_scalars(2 + W * 3, &mut rng);

        let sok_vrfy_challenge = &extra[W * 3 + 1];
        let g_2 = pp.get_commitment_base();
        let g_1 = pp.get_encryption_public_params().pubkey_base();
        batch_verify_soks::<G1Projective, A>(
            self.soks.as_slice(),
            g_1,
            &self.V[W],
            spks,
            auxs,
            sok_vrfy_challenge,
        )?;

        let ldt = LowDegreeTest::random(
            &mut rng,
            sc.get_threshold_weight(),
            W + 1,
            true,
            sc.get_batch_evaluation_domain(),
        );
        ldt.low_degree_test_on_g1(&self.V)?;

        //
        // Correctness of encryptions check
        //

        let alphas_betas_and_gammas = &extra[0..W * 3 + 1];
        let (alphas_and_betas, gammas) = alphas_betas_and_gammas.split_at(2 * W + 1);
        let (alphas, betas) = alphas_and_betas.split_at(W + 1);
        assert_eq!(alphas.len(), W + 1);
        assert_eq!(betas.len(), W);
        assert_eq!(gammas.len(), W);

        let lc_VR_hat = G2Projective::multi_exp_iter(
            self.V_hat.iter().chain(self.R_hat.iter()),
            alphas_and_betas.iter(),
        );
        let lc_VRC = G1Projective::multi_exp_iter(
            self.V.iter().chain(self.R.iter()).chain(self.C.iter()),
            alphas_betas_and_gammas.iter(),
        );
        let lc_V_hat = G2Projective::multi_exp_iter(self.V_hat.iter().take(W), gammas.iter());
        let mut lc_R_hat = Vec::with_capacity(n);

        for i in 0..n {
            let p = sc.get_player(i);
            let weight = sc.get_player_weight(&p);
            let s_i = sc.get_player_starting_index(&p);

            lc_R_hat.push(g2_multi_exp(
                &self.R_hat[s_i..s_i + weight],
                &gammas[s_i..s_i + weight],
            ));
        }

        let h = pp.get_encryption_public_params().message_base();
        let g_2_neg = g_2.neg();
        let eks = eks
            .iter()
            .map(Into::<G1Projective>::into)
            .collect::<Vec<G1Projective>>();
        // The vector of left-hand-side ($\mathbb{G}_2$) inputs to each pairing in the multi-pairing.
        let lhs = [g_1, &lc_VRC, h].into_iter().chain(&eks);
        // The vector of right-hand-side ($\mathbb{G}_2$) inputs to each pairing in the multi-pairing.
        let rhs = [&lc_VR_hat, &g_2_neg, &lc_V_hat]
            .into_iter()
            .chain(&lc_R_hat);

        let res = multi_pairing(lhs, rhs);
        if res != Gt::identity() {
            bail!(
                "Expected zero during multi-pairing check for {} {}, but got {}",
                sc,
                <Self as traits::Transcript>::scheme_name(),
                res
            );
        }

        return Ok(());
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L384-410)
```rust
    fn aggregate_with(
        &mut self,
        sc: &WeightedConfig<ThresholdConfigBlstrs>,
        other: &Transcript,
    ) -> anyhow::Result<()> {
        let W = sc.get_total_weight();

        debug_assert!(self.check_sizes(sc).is_ok());
        debug_assert!(other.check_sizes(sc).is_ok());

        for i in 0..self.V.len() {
            self.V[i] += other.V[i];
            self.V_hat[i] += other.V_hat[i];
        }

        for i in 0..W {
            self.R[i] += other.R[i];
            self.R_hat[i] += other.R_hat[i];
            self.C[i] += other.C[i];
        }

        for sok in &other.soks {
            self.soks.push(sok.clone());
        }

        Ok(())
    }
```

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L69-108)
```rust
pub fn pok_batch_verify<'a, Gr>(
    poks: &Vec<(Gr, PoK<Gr>)>,
    g: &Gr,
    gamma: &Scalar,
) -> anyhow::Result<()>
where
    Gr: Serialize + Group + Mul<&'a Scalar> + HasMultiExp,
{
    let n = poks.len();
    let mut exps = Vec::with_capacity(2 * n + 1);
    let mut bases = Vec::with_capacity(2 * n + 1);

    // Compute \gamma_i = \gamma^i, for all i \in [0, n]
    let mut gammas = Vec::with_capacity(n);
    gammas.push(Scalar::ONE);
    for _ in 0..(n - 1) {
        gammas.push(gammas.last().unwrap().mul(gamma));
    }

    let mut last_exp = Scalar::ZERO;
    for i in 0..n {
        let (pk, (R, s)) = poks[i];

        bases.push(R);
        exps.push(gammas[i]);

        bases.push(pk);
        exps.push(schnorr_hash(Challenge::<Gr> { R, pk, g: *g }) * gammas[i]);

        last_exp += s * gammas[i];
    }

    bases.push(*g);
    exps.push(last_exp.neg());

    if Gr::multi_exp_iter(bases.iter(), exps.iter()) != Gr::identity() {
        bail!("Schnorr PoK batch verification failed");
    }

    Ok(())
```

**File:** crates/aptos-dkg/src/pvss/low_degree_test.rs (L141-161)
```rust
    pub fn low_degree_test_on_g1(self, evals: &Vec<G1Projective>) -> anyhow::Result<()> {
        if evals.len() != self.n {
            bail!("Expected {} evaluations; got {}", self.n, evals.len())
        }

        if self.t == self.n {
            return Ok(());
        }

        let v_times_f = self.dual_code_word();

        debug_assert_eq!(evals.len(), v_times_f.len());
        let zero = g1_multi_exp(evals.as_ref(), v_times_f.as_slice());

        (zero == G1Projective::identity())
            .then_some(())
            .context(format!(
                "the LDT G1 multiexp should return zero, but instead returned {}",
                zero
            ))
    }
```

**File:** crates/aptos-dkg/src/utils/mod.rs (L58-88)
```rust
pub fn g1_multi_exp(bases: &[G1Projective], scalars: &[blstrs::Scalar]) -> G1Projective {
    if bases.len() != scalars.len() {
        panic!(
            "blstrs's multiexp has heisenbugs when the # of bases != # of scalars ({} != {})",
            bases.len(),
            scalars.len()
        );
    }

    match bases.len() {
        0 => G1Projective::identity(),
        1 => bases[0].mul(scalars[0]),
        _ => G1Projective::multi_exp(bases, scalars),
    }
}

/// Works around the `blst_hell` bug (see README.md).
pub fn g2_multi_exp(bases: &[G2Projective], scalars: &[blstrs::Scalar]) -> G2Projective {
    if bases.len() != scalars.len() {
        panic!(
            "blstrs's multiexp has heisenbugs when the # of bases != # of scalars ({} != {})",
            bases.len(),
            scalars.len()
        );
    }
    match bases.len() {
        0 => G2Projective::identity(),
        1 => bases[0].mul(scalars[0]),
        _ => G2Projective::multi_exp(bases, scalars),
    }
}
```

**File:** crates/aptos-dkg/src/utils/mod.rs (L144-157)
```rust
    fn multi_exp_iter<'a, 'b, I>(
        bases: I,
        scalars: impl Iterator<Item = &'b blstrs::Scalar>,
    ) -> Self
    where
        I: Iterator<Item = &'a Self>,
        Self: 'a,
    {
        // TODO(Perf): blstrs does not work with iterators, which leads to unnecessary cloning here.
        Self::multi_exp_slice(
            bases.cloned().collect::<Vec<Self>>().as_slice(),
            scalars.cloned().collect::<Vec<blstrs::Scalar>>().as_slice(),
        )
    }
```

**File:** crates/aptos-crypto/src/input_secret.rs (L53-61)
```rust
impl Zero for InputSecret {
    fn zero() -> Self {
        InputSecret { a: Scalar::ZERO }
    }

    fn is_zero(&self) -> bool {
        self.a.is_zero_vartime()
    }
}
```
