# Audit Report

## Title
Non-Canonical BitVec Representation Allows Transaction Deduplication Bypass

## Summary
The `BitVec` struct used in `MultiKeyAuthenticator` can have non-canonical representations (with or without trailing zero bytes) that are semantically identical but treated as distinct by the deduplication logic in `TxnHashAndAuthenticatorDeduper`, allowing an attacker to bypass transaction deduplication and include multiple copies of the same logical transaction in a block.

## Finding Description

The transaction deduplication mechanism in consensus uses `(committed_hash, authenticator)` tuples stored in a `HashSet` to filter duplicates. [1](#0-0) 

The `TransactionAuthenticator` and `AccountAuthenticator` enums derive `Hash` and `Eq` traits, which means comparison is done structurally on the in-memory representation. [2](#0-1) 

The `MultiKeyAuthenticator` struct contains a `signatures_bitmap` field of type `BitVec` that also derives `Hash` and `Eq`. [3](#0-2) 

The critical issue is in the `BitVec` implementation. The struct derives `Hash` and `Eq`, which compare the inner `Vec<u8>` directly. [4](#0-3) 

However, the deserialization logic accepts any length vector up to `MAX_BUCKETS` without normalizing to canonical form. [5](#0-4) 

This means two `BitVec` instances can represent the same logical bitmap (e.g., `[0b1000_0000]` and `[0b1000_0000, 0, 0, 0]`) but will be considered different by `Hash` and `Eq`, causing them to bypass deduplication.

**Attack Path:**
1. Attacker creates a valid transaction with a `MultiKeyAuthenticator`
2. Attacker serializes the transaction to BCS bytes
3. Attacker manually modifies the serialized bytes to add trailing zero bytes to the `BitVec` field within the `MultiKeyAuthenticator`
4. The modified transaction passes BCS deserialization
5. The transaction passes signature verification (trailing zeros don't affect `count_ones()` or `last_set_bit()`)
6. The deduplication logic treats it as a different transaction due to the non-canonical `BitVec`
7. Multiple semantically identical transactions can be included in the same block

## Impact Explanation

This vulnerability has **Medium** severity impact:

1. **Resource Exhaustion**: An attacker can fill blocks with "duplicate" transactions that bypass deduplication, wasting block space and network resources.

2. **Deterministic Execution Violation**: While all validators will execute the blocks deterministically, the system allows inclusion of semantically duplicate transactions that should have been filtered, violating the intended deduplication invariant.

3. **Limited Direct Harm**: Only the first transaction will execute successfully; subsequent duplicates will fail with sequence number errors. The attacker pays gas fees for all failed transactions, providing a natural rate-limiting mechanism.

This does not reach **High** or **Critical** severity because:
- No funds are stolen or minted
- No consensus safety violation (all validators agree on block contents)
- No state corruption occurs
- The attacker must pay gas fees for all duplicate transactions

However, it does qualify as **Medium** severity per the bug bounty criteria as it represents a "state inconsistency requiring intervention" - the blockchain accumulates failed transactions that should have been deduplicated.

## Likelihood Explanation

**Likelihood: Medium**

The attack is moderately likely to occur because:

1. **Low Technical Barrier**: An attacker only needs to understand BCS serialization and manually modify transaction bytes
2. **No Privileged Access Required**: Any transaction sender can perform this attack
3. **Limited Benefit**: The attacker pays gas fees for all duplicate transactions, making this attack economically unattractive for pure profit but viable for griefing/DoS purposes
4. **Detection Difficulty**: The non-canonical transactions appear valid and pass all verification checks

## Recommendation

Implement canonical normalization for `BitVec` during deserialization by removing trailing zero bytes:

```rust
impl<'de> Deserialize<'de> for BitVec {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(rename = "BitVec")]
        struct RawData {
            #[serde(with = "serde_bytes")]
            inner: Vec<u8>,
        }
        let mut v = RawData::deserialize(deserializer)?.inner;
        if v.len() > MAX_BUCKETS {
            return Err(D::Error::custom(format!("BitVec too long: {}", v.len())));
        }
        
        // Normalize by removing trailing zero bytes
        while v.last() == Some(&0) && v.len() > 1 {
            v.pop();
        }
        
        Ok(BitVec { inner: v })
    }
}
```

Additionally, add validation in `MultiKeyAuthenticator::new` to ensure the bitmap is in canonical form.

## Proof of Concept

```rust
#[test]
fn test_non_canonical_bitvec_bypass_deduplication() {
    use aptos_bitvec::BitVec;
    use std::collections::HashSet;
    
    // Create two semantically identical BitVecs with different representations
    let canonical = BitVec::from(vec![0b1000_0000u8]);
    let non_canonical = BitVec::from(vec![0b1000_0000u8, 0, 0, 0]);
    
    // Both represent the same logical bitmap (only bit 0 is set)
    assert_eq!(canonical.is_set(0), true);
    assert_eq!(non_canonical.is_set(0), true);
    assert_eq!(canonical.count_ones(), non_canonical.count_ones());
    
    // But they are considered different by Eq
    assert_ne!(canonical, non_canonical);
    
    // And they hash differently
    let mut set = HashSet::new();
    set.insert(canonical.clone());
    assert!(set.insert(non_canonical.clone())); // Returns true - treated as different!
    
    // This demonstrates that deduplication can be bypassed
    assert_eq!(set.len(), 2);
}
```

This test demonstrates that two `BitVec` instances with the same semantic meaning but different internal representations are treated as distinct by `HashSet`, which is the same mechanism used in transaction deduplication. [6](#0-5) 

## Notes

The vulnerability stems from the inconsistency between:
1. The semantic equivalence of `BitVec` instances (same set bits)
2. The structural comparison used by derived `Hash` and `Eq` implementations (different byte vectors)

This affects all transaction types using `MultiKeyAuthenticator`, which is embedded in the `AccountAuthenticator` enum used throughout the system for transaction authentication. The issue propagates through the entire authentication hierarchy due to derived trait implementations at each level.

### Citations

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L68-68)
```rust
                true => Some((txn.committed_hash(), txn.authenticator())),
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L74-90)
```rust
        let mut seen_hashes = HashSet::new();
        let mut num_duplicates: usize = 0;
        let filtered: Vec<_> = hash_and_authenticators
            .into_iter()
            .zip(transactions)
            .filter_map(|(maybe_hash, txn)| match maybe_hash {
                None => Some(txn),
                Some(hash_and_authenticator) => {
                    if seen_hashes.insert(hash_and_authenticator) {
                        Some(txn)
                    } else {
                        num_duplicates += 1;
                        None
                    }
                },
            })
            .collect();
```

**File:** types/src/transaction/authenticator.rs (L73-73)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
```

**File:** types/src/transaction/authenticator.rs (L1025-1030)
```rust
#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize, Deserialize)]
pub struct MultiKeyAuthenticator {
    public_keys: MultiKey,
    signatures: Vec<AnySignature>,
    signatures_bitmap: aptos_bitvec::BitVec,
}
```

**File:** crates/aptos-bitvec/src/lib.rs (L66-70)
```rust
#[derive(Clone, Default, Debug, Eq, Hash, PartialEq, Serialize)]
pub struct BitVec {
    #[serde(with = "serde_bytes")]
    inner: Vec<u8>,
}
```

**File:** crates/aptos-bitvec/src/lib.rs (L235-251)
```rust
impl<'de> Deserialize<'de> for BitVec {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(rename = "BitVec")]
        struct RawData {
            #[serde(with = "serde_bytes")]
            inner: Vec<u8>,
        }
        let v = RawData::deserialize(deserializer)?.inner;
        if v.len() > MAX_BUCKETS {
            return Err(D::Error::custom(format!("BitVec too long: {}", v.len())));
        }
        Ok(BitVec { inner: v })
    }
```
