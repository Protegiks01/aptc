# Audit Report

## Title
Transaction Accumulator Corruption via Unvalidated Backup Restoration

## Summary
The transaction restore process accepts backups without validating `LedgerInfoWithSignatures` signatures when `epoch_history` is `None`. An attacker controlling the backup source can provide fabricated data with malicious `left_siblings` that pass internal consistency checks but corrupt the transaction accumulator's frozen subtrees, leading to consensus splits and ledger corruption.

## Finding Description

The vulnerability exists in the transaction backup restoration flow where frozen subtrees are saved to the accumulator without proper validation of the source data. [1](#0-0) 

The code loads a `LedgerInfoWithSignatures` from backup storage and only validates it if `epoch_history` is provided. However, in production restore scenarios, `epoch_history` is explicitly set to `None`: [2](#0-1) 

This means the `LedgerInfoWithSignatures` object—which should contain validator signatures proving consensus—is **never validated**. The restoration process then verifies the range proof against this unvalidated ledger info: [3](#0-2) 

The range proof verification ensures internal consistency (that `left_siblings` + `transaction_infos` + `right_siblings` = ledger info root hash), but does NOT validate that the ledger info itself is legitimate.

Finally, the `left_siblings` from this unvalidated range proof are saved as frozen subtrees: [4](#0-3) [5](#0-4) 

**Attack Path:**
1. Attacker provides a malicious backup containing fabricated transactions, transaction infos, and a fake `LedgerInfoWithSignatures` with an arbitrary root hash (no valid signatures needed)
2. Attacker crafts a `TransactionAccumulatorRangeProof` with malicious `left_siblings` that verify against the fake root
3. Victim restores using the db-tool with `epoch_history=None`
4. The range proof passes verification (internally consistent with fake ledger info)
5. Malicious `left_siblings` are persisted as frozen subtrees in the transaction accumulator database [6](#0-5) 

This corrupts the fundamental Merkle accumulator structure used for transaction verification.

## Impact Explanation

**Critical Severity** - This vulnerability breaks the **State Consistency** and **Consensus Safety** invariants:

1. **Accumulator Corruption**: The transaction accumulator is the authoritative structure for proving transaction inclusion. Corrupted frozen subtrees cause incorrect root hash calculations for all subsequent transactions.

2. **Consensus Split Risk**: If different validator nodes restore from different malicious backups (or mix legitimate and malicious backups), they will have divergent accumulator states. This leads to:
   - Different nodes computing different root hashes for the same transactions
   - Inability to reach consensus on blocks
   - Network partition requiring hard fork to recover

3. **Transaction Verification Failure**: Honest nodes cannot verify transactions against a corrupted accumulator, breaking the blockchain's ability to process new transactions.

4. **Non-Recoverable State**: Once frozen subtrees are corrupted in the database, the only recovery is to restore from a known-good backup or perform a hard fork, meeting the Critical severity threshold of "non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**High Likelihood** in disaster recovery scenarios:

- Validators commonly use backup/restore for disaster recovery, state sync catch-up, and bootstrapping new nodes
- The db-tool explicitly sets `epoch_history=None` in production code, making this the default configuration
- Backup sources may include cloud storage, CDNs, or peer-provided backups that could be compromised
- No warning or error is generated when epoch_history is None—the restoration appears successful
- The attack requires only the ability to serve malicious backup data, not validator key compromise or consensus participation

## Recommendation

**Immediate Fix**: Always validate `LedgerInfoWithSignatures` before accepting backup data:

```rust
// In LoadedChunk::load(), after line 151:
let (range_proof, ledger_info) = storage
    .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
        &manifest.proof,
    )
    .await?;

// ADD MANDATORY VALIDATION:
if let Some(epoch_history) = epoch_history {
    epoch_history.verify_ledger_info(&ledger_info)?;
} else {
    // CRITICAL: Do not accept backups without epoch history validation
    return Err(anyhow!(
        "Cannot restore transactions without epoch_history for ledger info validation. \
         This is required to prevent accumulator corruption from malicious backups."
    ));
}
```

**Long-term Fix**: Require waypoint-based or signature-based validation of all ledger infos during restore, with no bypass option.

## Proof of Concept

```rust
// Proof of Concept: Malicious Backup Creation
// This demonstrates how an attacker can create a backup that passes verification
// but corrupts the accumulator

use aptos_types::{
    transaction::{Transaction, TransactionInfo},
    ledger_info::LedgerInfoWithSignatures,
    proof::TransactionAccumulatorRangeProof,
};
use aptos_crypto::HashValue;

fn create_malicious_backup() {
    // 1. Create fake transactions
    let fake_txns = vec![/* fabricated transactions */];
    
    // 2. Create fake transaction infos with arbitrary hashes
    let fake_txn_infos: Vec<TransactionInfo> = fake_txns.iter()
        .map(|_| TransactionInfo::new(
            HashValue::random(), // fake hash
            HashValue::random(), // fake state root
            HashValue::random(), // fake event root
            0, // gas
            aptos_types::transaction::ExecutionStatus::Success,
        ))
        .collect();
    
    // 3. Create fake accumulator with arbitrary frozen subtrees
    let malicious_left_siblings = vec![
        HashValue::random(), // These will corrupt the accumulator!
        HashValue::random(),
    ];
    
    // 4. Compute a fake root that makes the proof internally consistent
    let fake_root = compute_fake_root(&fake_txn_infos, &malicious_left_siblings);
    
    // 5. Create unsigned/fake-signed LedgerInfoWithSignatures
    // (No signature validation happens when epoch_history is None!)
    let fake_ledger_info = create_fake_ledger_info_with_root(fake_root);
    
    // 6. Create range proof that verifies against fake ledger info
    let malicious_proof = TransactionAccumulatorRangeProof::new(
        malicious_left_siblings, // These will be saved as frozen subtrees!
        vec![], // right siblings
    );
    
    // 7. When victim restores with epoch_history=None:
    //    - proof.verify() passes (internally consistent)
    //    - malicious_left_siblings saved to DB
    //    - Accumulator corrupted!
}
```

**Validation**: This attack requires only the ability to serve backup data to a victim. The victim's node will accept the malicious backup without error when using the standard db-tool restore command with its default `epoch_history=None` configuration.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L147-154)
```rust
        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L167-167)
```rust
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L415-418)
```rust
            restore_handler.confirm_or_save_frozen_subtrees(
                first_chunk.manifest.first_version,
                first_chunk.range_proof.left_siblings(),
            )?;
```

**File:** storage/db-tool/src/restore.rs (L102-108)
```rust
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L78-111)
```rust
pub fn confirm_or_save_frozen_subtrees(
    transaction_accumulator_db: &DB,
    num_leaves: LeafCount,
    frozen_subtrees: &[HashValue],
    existing_batch: Option<&mut SchemaBatch>,
) -> Result<()> {
    let positions: Vec<_> = FrozenSubTreeIterator::new(num_leaves).collect();
    ensure!(
        positions.len() == frozen_subtrees.len(),
        "Number of frozen subtree roots not expected. Expected: {}, actual: {}",
        positions.len(),
        frozen_subtrees.len(),
    );

    if let Some(existing_batch) = existing_batch {
        confirm_or_save_frozen_subtrees_impl(
            transaction_accumulator_db,
            frozen_subtrees,
            positions,
            existing_batch,
        )?;
    } else {
        let mut batch = SchemaBatch::new();
        confirm_or_save_frozen_subtrees_impl(
            transaction_accumulator_db,
            frozen_subtrees,
            positions,
            &mut batch,
        )?;
        transaction_accumulator_db.write_schemas(batch)?;
    }

    Ok(())
}
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L297-322)
```rust
fn confirm_or_save_frozen_subtrees_impl(
    transaction_accumulator_db: &DB,
    frozen_subtrees: &[HashValue],
    positions: Vec<Position>,
    batch: &mut SchemaBatch,
) -> Result<()> {
    positions
        .iter()
        .zip(frozen_subtrees.iter().rev())
        .map(|(p, h)| {
            if let Some(_h) = transaction_accumulator_db.get::<TransactionAccumulatorSchema>(p)? {
                ensure!(
                        h == &_h,
                        "Frozen subtree root does not match that already in DB. Provided: {}, in db: {}.",
                        h,
                        _h,
                    );
            } else {
                batch.put::<TransactionAccumulatorSchema>(p, h)?;
            }
            Ok(())
        })
        .collect::<Result<Vec<_>>>()?;

    Ok(())
}
```
