# Audit Report

## Title
Critical Simulation Divergence: Transaction Context Not Properly Initialized in Local Simulation

## Summary
The local simulation functionality in `local_simulation.rs` passes `PersistedAuxiliaryInfo::None` when executing transactions, while production consensus execution uses `PersistedAuxiliaryInfo::V1` with actual transaction indices. This causes Move contracts that call `transaction_context::monotonically_increasing_counter()` to abort with `ETRANSACTION_INDEX_NOT_AVAILABLE` in simulation but execute successfully in production, creating a critical simulation-production divergence.

## Finding Description

The local simulation system fails to properly initialize transaction context, breaking the fundamental guarantee that simulation results match production execution.

**In Production Consensus Execution:** [1](#0-0) 

Production creates proper `AuxiliaryInfo` with `PersistedAuxiliaryInfo::V1` containing transaction indices and ephemeral info with proposer indices.

**In Local Simulation:** [2](#0-1) [3](#0-2) 

Simulation passes `PersistedAuxiliaryInfo::None` without transaction context information.

**Impact on Move Native Function:** [4](#0-3) 

When `monotonically_increasing_counter()` is called:
- With `PersistedAuxiliaryInfo::None` → `TransactionIndexKind::NotAvailable` → **ABORTS** with `ETRANSACTION_INDEX_NOT_AVAILABLE`
- With `PersistedAuxiliaryInfo::V1` → `TransactionIndexKind::BlockExecution` → Returns valid counter value

**Real-World Usage:** [5](#0-4) 

The experimental trading/order book framework uses this function to generate unique order IDs. Any contract using this function will experience divergent behavior.

## Impact Explanation

This vulnerability enables attackers to:

1. **Deploy Untested Exploits**: Create malicious contracts that abort in simulation (appearing broken/safe) but execute successfully in production with unexpected behavior
2. **Bypass Security Testing**: Circumvent security audits that rely on local simulation to validate contract behavior  
3. **Hide Malicious Logic**: Structure contracts where security-critical paths only execute in production but are hidden during simulation testing
4. **Break Developer Tooling**: Cause legitimate developers to incorrectly diagnose issues, thinking their correct code is broken when it only fails in simulation

This breaks the **Deterministic Execution** invariant by creating non-deterministic behavior between testing and production environments. While validators produce consistent results in production, the simulation-production divergence allows attackers to deploy code with behavior that cannot be accurately predicted or tested using the provided tooling.

**Severity Assessment**: This qualifies as **High Severity** under "Significant protocol violations" - the simulation protocol is critical infrastructure for safe contract development, and its failure to match production execution represents a significant violation of expected behavior that could lead to deployed exploits and fund loss scenarios.

## Likelihood Explanation

**Likelihood: HIGH**

- Any developer using `aptos move run --local` or local simulation tools will encounter this issue
- Any contract calling `transaction_context::monotonically_increasing_counter()` will exhibit divergent behavior  
- The experimental trading framework already uses this function, indicating it's an intended API
- No warnings or documentation exist about this limitation
- Developers naturally assume simulation matches production behavior

The vulnerability is **trivially exploitable** - simply deploying a contract that uses the affected function will result in divergent behavior.

## Recommendation

The simulation should use `PersistedAuxiliaryInfo::TimestampNotYetAssignedV1` instead of `None` to properly indicate simulation context:

**Fix for `simulate_using_debugger`:**
```rust
// In crates/aptos/src/common/transactions.rs, line 308
// Change from:
PersistedAuxiliaryInfo::None,

// To:
PersistedAuxiliaryInfo::TimestampNotYetAssignedV1 { 
    transaction_index: 0  // Single transaction simulation uses index 0
},
```

This allows `monotonically_increasing_counter()` to work in simulation with `reserved_byte=1` (indicating validation/simulation mode) while still producing consistent, testable behavior. [6](#0-5) 

The `TimestampNotYetAssignedV1` variant exists specifically for simulation/validation contexts.

## Proof of Concept

**Move Module (test_counter.move):**
```move
module 0x1::test_counter {
    use aptos_framework::transaction_context;
    
    public entry fun use_counter() {
        // This will ABORT in local simulation with ETRANSACTION_INDEX_NOT_AVAILABLE
        // But will succeed in production/testnet execution
        let _counter = transaction_context::monotonically_increasing_counter();
    }
}
```

**Reproduction Steps:**
1. Save the above module
2. Run with local simulation: `aptos move run --function-id 0x1::test_counter::use_counter --local`
   - **Result**: Transaction aborts with error code 327685 (ETRANSACTION_INDEX_NOT_AVAILABLE)
3. Deploy to testnet and execute
   - **Result**: Transaction succeeds

This demonstrates the simulation-production divergence that allows attackers to deploy contracts with untestable behavior.

**Notes**

The vulnerability exists because the simulation infrastructure was not updated when the `monotonically_increasing_counter()` feature was added. The native function expects proper transaction context that production provides but simulation omits. This creates a dangerous testing gap where developers cannot reliably validate contract behavior before production deployment.

### Citations

**File:** consensus/src/pipeline/pipeline_builder.rs (L831-854)
```rust
        let auxiliary_info: Vec<_> = txns
            .iter()
            .enumerate()
            .map(|(txn_index, txn)| {
                let persisted_auxiliary_info = match persisted_auxiliary_info_version {
                    0 => PersistedAuxiliaryInfo::None,
                    1 => PersistedAuxiliaryInfo::V1 {
                        transaction_index: txn_index as u32,
                    },
                    _ => unimplemented!("Unsupported persisted auxiliary info version"),
                };

                let ephemeral_auxiliary_info = txn
                    .borrow_into_inner()
                    .try_as_signed_user_txn()
                    .and_then(|_| {
                        proposer_index.map(|index| EphemeralAuxiliaryInfo {
                            proposer_index: index as u64,
                        })
                    });

                AuxiliaryInfo::new(persisted_auxiliary_info, ephemeral_auxiliary_info)
            })
            .collect();
```

**File:** crates/aptos/src/common/local_simulation.rs (L18-42)
```rust
pub fn run_transaction_using_debugger(
    debugger: &AptosDebugger,
    version: u64,
    transaction: SignedTransaction,
    _hash: HashValue,
    persisted_auxiliary_info: PersistedAuxiliaryInfo,
) -> CliTypedResult<(VMStatus, VMOutput)> {
    let state_view = debugger.state_view_at_version(version);
    let env = AptosEnvironment::new(&state_view);
    let vm = AptosVM::new(&env);
    let log_context = AdapterLogSchema::new(state_view.id(), 0);

    let resolver = state_view.as_move_resolver();
    let code_storage = state_view.as_aptos_code_storage(&env);

    let (vm_status, vm_output) = vm.execute_user_transaction(
        &resolver,
        &code_storage,
        &transaction,
        &log_context,
        &AuxiliaryInfo::new(persisted_auxiliary_info, None),
    );

    Ok((vm_status, vm_output))
}
```

**File:** crates/aptos/src/common/transactions.rs (L303-309)
```rust
        let (vm_status, vm_output) = execute(
            &debugger,
            version,
            transaction,
            hash,
            PersistedAuxiliaryInfo::None,
        )?;
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L187-211)
```rust
        // monotonically_increasing_counter (128 bits) = `<reserved_byte (8 bits)> || timestamp_us (64 bits) || transaction_index (32 bits) || session counter (8 bits) || local_counter (16 bits)`
        // reserved_byte: 0 for block/chunk execution (V1), 1 for validation/simulation (TimestampNotYetAssignedV1)
        let timestamp_us = safely_pop_arg!(args, u64);
        let transaction_index_kind = user_transaction_context.transaction_index_kind();

        let (reserved_byte, transaction_index) = match transaction_index_kind {
            TransactionIndexKind::BlockExecution { transaction_index } => {
                (0u128, transaction_index)
            },
            TransactionIndexKind::ValidationOrSimulation { transaction_index } => {
                (1u128, transaction_index)
            },
            TransactionIndexKind::NotAvailable => {
                return Err(SafeNativeError::Abort {
                    abort_code: error::invalid_state(abort_codes::ETRANSACTION_INDEX_NOT_AVAILABLE),
                });
            },
        };

        let mut monotonically_increasing_counter: u128 = reserved_byte << 120;
        monotonically_increasing_counter |= (timestamp_us as u128) << 56;
        monotonically_increasing_counter |= (transaction_index as u128) << 24;
        monotonically_increasing_counter |= session_counter << 16;
        monotonically_increasing_counter |= local_counter;
        Ok(smallvec![Value::u128(monotonically_increasing_counter)])
```

**File:** aptos-move/framework/aptos-experimental/sources/trading/order_book/order_book_types.move (L75-78)
```text
    public fun next_order_id(): OrderIdType {
        // reverse bits to make order ids random, so indices on top of them are shuffled.
        OrderIdType { order_id: reverse_bits(transaction_context::monotonically_increasing_counter()) }
    }
```

**File:** types/src/transaction/mod.rs (L3313-3318)
```rust
    // When we are doing a simulation or validation of transactions, the transaction is not executed
    // within the context of a block. The timestamp is not yet assigned, but we still track the
    // transaction index for multi-transaction simulations. For single transaction simulation or
    // validation, the transaction index is set to 0.
    TimestampNotYetAssignedV1 { transaction_index: u32 },
}
```
