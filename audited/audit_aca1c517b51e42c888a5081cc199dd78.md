# Audit Report

## Title
Validator Transaction Topic Duplication Violates One-Transaction-Per-Topic Invariant Leading to Consensus Safety Violation

## Summary
The validator transaction pool's filtering mechanism uses transaction hashes instead of Topics when excluding pending transactions. This allows multiple validator transactions with duplicate Topic values to be pulled simultaneously into different blocks, violating the one-transaction-per-topic invariant and causing non-deterministic execution that breaks consensus safety.

## Finding Description

The validator transaction pool enforces a one-transaction-per-topic invariant internally through a `seq_nums_by_topic` HashMap. [1](#0-0) 

When a new transaction with an existing Topic is added, the pool correctly replaces the old transaction: [2](#0-1) 

However, when the proposal generator creates the exclusion filter for validator transactions, it collects transaction **hashes** from pending blocks, not Topics: [3](#0-2) 

The filter then excludes transactions by comparing hashes: [4](#0-3) 

**Attack Scenario:**

1. Validator transaction `VTxn_1` with Topic `JWK_CONSENSUS(issuer_A)` and hash `H1` is added to the pool
2. Proposer for round R1 pulls `VTxn_1` into block `B1`
3. `VTxn_1`'s hash `H1` is added to `pending_validator_txn_hashes`
4. Before `B1` commits, a new validator transaction `VTxn_2` with the **same Topic** `JWK_CONSENSUS(issuer_A)` but different content (hash `H2`) arrives
5. The pool's `put` method replaces `VTxn_1` with `VTxn_2` (maintaining pool invariant)
6. Proposer for round R2 pulls from pool with filter excluding hash `H1`
7. `VTxn_2` (hash `H2`) passes the filter because `H2 â‰  H1`
8. Both blocks `B1` (containing `VTxn_1`) and `B2` (containing `VTxn_2`) are now pending in consensus with duplicate Topics

**Consensus Safety Violation:**

JWK update transactions enforce strict version sequencing. The execution logic verifies: [5](#0-4) 

When both transactions execute (in different speculative branches or on different validators):
- If both transactions propose version `v+1` but with different content
- Execution order determines which succeeds and which fails with `IncorrectVersion`
- Different validators may execute different branches in different orders
- This creates **non-deterministic execution** and **state divergence**

The block validation logic does NOT check for duplicate Topics across pending blocks: [6](#0-5) 

During execution, validator transactions are simply extracted from blocks without deduplication: [7](#0-6) 

## Impact Explanation

**Critical Severity - Consensus/Safety Violation**

This vulnerability breaks the **Deterministic Execution** invariant, which states: "All validators must produce identical state roots for identical blocks." When multiple validator transactions with the same Topic are executed in different orders across validators:

1. **State Divergence**: Validators executing different branch orders will reach different states
2. **Consensus Split**: Validators may fail to reach agreement on state roots, causing chain halt
3. **Non-Recoverable**: Requires manual intervention or hard fork to resolve if validators diverge on committed state
4. **Universal Impact**: Affects all validator nodes, not just Byzantine participants

This directly maps to the Critical Severity category: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)."

## Likelihood Explanation

**High Likelihood**

The vulnerability can be triggered during normal operation:

1. **No Byzantine Behavior Required**: Honest validators following protocol can trigger this through network timing
2. **Common Scenario**: JWK updates and DKG results are regularly submitted by validators
3. **Race Condition Window**: Between when a transaction is pulled and when the block commits (typically multiple rounds)
4. **Natural Occurrence**: If validators have different views of pending transactions due to network delays

Attack requirements:
- Ability to submit validator transactions (standard validator capability)
- Timing window of a few rounds (easily achievable)
- No special access or Byzantine collusion needed

## Recommendation

**Fix: Filter by Topic Instead of Hash**

Modify the filter construction to track pending Topics rather than transaction hashes:

```rust
// In proposal_generator.rs
let pending_validator_txn_topics: HashSet<Topic> = pending_blocks
    .iter()
    .filter_map(|block| block.validator_txns())
    .flatten()
    .map(|vtxn| get_topic_for_transaction(vtxn)) // New function needed
    .collect();

let validator_txn_filter = 
    vtxn_pool::TransactionFilter::PendingTopicSet(pending_validator_txn_topics);
```

Add a method to extract Topic from ValidatorTransaction:
```rust
// In types/src/validator_txn.rs
impl ValidatorTransaction {
    pub fn topic(&self) -> Topic {
        match self {
            ValidatorTransaction::DKGResult(_) => Topic::DKG,
            ValidatorTransaction::ObservedJWKUpdate(update) => {
                // Extract issuer from update to construct appropriate Topic
                Topic::JWK_CONSENSUS(update.update.issuer.clone())
            }
        }
    }
}
```

Update the filter to support Topic-based exclusion:
```rust
// In crates/validator-transaction-pool/src/lib.rs
pub enum TransactionFilter {
    PendingTxnHashSet(HashSet<HashValue>),
    PendingTopicSet(HashSet<Topic>), // Add this variant
}

impl TransactionFilter {
    pub fn should_exclude(&self, txn: &ValidatorTransaction, topic: &Topic) -> bool {
        match self {
            TransactionFilter::PendingTxnHashSet(set) => set.contains(&txn.hash()),
            TransactionFilter::PendingTopicSet(set) => set.contains(topic),
        }
    }
}
```

Update the pull method to use Topic for filtering:
```rust
// In pull method
.filter(|(_, item)| {
    item.txn.size_in_bytes() as u64 <= max_bytes
        && !filter.should_exclude(&item.txn, &item.topic)
})
```

## Proof of Concept

```rust
#[test]
fn test_duplicate_topic_violation() {
    use aptos_types::validator_txn::{Topic, ValidatorTransaction};
    use aptos_types::jwks::{QuorumCertifiedUpdate, dummy_issuer};
    use std::sync::Arc;
    use std::collections::HashSet;
    
    // Setup pool
    let pool = VTxnPoolState::default();
    
    // Create two different JWK updates for the same issuer (same Topic)
    let issuer = dummy_issuer();
    let topic = Topic::JWK_CONSENSUS(issuer);
    
    let txn_1 = ValidatorTransaction::ObservedJWKUpdate(
        QuorumCertifiedUpdate::dummy_with_version(11)
    );
    let txn_2 = ValidatorTransaction::ObservedJWKUpdate(
        QuorumCertifiedUpdate::dummy_with_version(11) // Same version, different content
    );
    
    // First transaction gets added and pulled into Block 1
    let _guard_1 = pool.put(topic.clone(), Arc::new(txn_1.clone()), None);
    let pulled_1 = pool.pull(
        Instant::now().add(Duration::from_secs(10)),
        10,
        2048,
        TransactionFilter::default(),
    );
    assert_eq!(pulled_1.len(), 1);
    
    // Simulate: Block 1 is now pending with txn_1
    // Create filter excluding txn_1 by hash (current behavior)
    let pending_hashes: HashSet<HashValue> = vec![txn_1.hash()].into_iter().collect();
    let filter = TransactionFilter::PendingTxnHashSet(pending_hashes);
    
    // New transaction with SAME Topic arrives
    let _guard_2 = pool.put(topic.clone(), Arc::new(txn_2.clone()), None);
    
    // BUG: txn_2 can be pulled because it has different hash than txn_1
    let pulled_2 = pool.pull(
        Instant::now().add(Duration::from_secs(10)),
        10,
        2048,
        filter,
    );
    
    // VULNERABILITY: Both transactions with same Topic are now in flight
    assert_eq!(pulled_2.len(), 1);
    assert_eq!(pulled_2[0].hash(), txn_2.hash());
    assert_ne!(txn_1.hash(), txn_2.hash()); // Different hashes
    
    // This violates the one-transaction-per-topic invariant at consensus level
    // Both txn_1 (in Block 1) and txn_2 (in Block 2) have the same Topic
    // When executed, this causes non-deterministic results depending on execution order
}
```

## Notes

This vulnerability exists because the filtering mechanism was designed to prevent duplicate transaction **content** (by hash) rather than duplicate transaction **purpose** (by Topic). The one-transaction-per-topic invariant is critical for validator transactions because:

1. **JWK Updates** must be sequential by version per issuer
2. **DKG Results** should only have one result per epoch
3. Multiple updates for the same Topic executing in different orders cause consensus splits

The fix requires tracking Topics in the pending transaction set and using Topic-based exclusion in the filter, ensuring the consensus-level invariant matches the pool-level invariant.

### Citations

**File:** crates/validator-transaction-pool/src/lib.rs (L30-34)
```rust
    pub fn should_exclude(&self, txn: &ValidatorTransaction) -> bool {
        match self {
            TransactionFilter::PendingTxnHashSet(set) => set.contains(&txn.hash()),
        }
    }
```

**File:** crates/validator-transaction-pool/src/lib.rs (L74-76)
```rust
        if let Some(old_seq_num) = pool.seq_nums_by_topic.insert(topic.clone(), seq_num) {
            pool.txn_queue.remove(&old_seq_num);
        }
```

**File:** crates/validator-transaction-pool/src/lib.rs (L118-120)
```rust
    /// Track Topic -> seq_num mapping.
    /// We allow only 1 txn per topic and this index helps find the old txn when adding a new one for the same topic.
    seq_nums_by_topic: HashMap<Topic, u64>,
```

**File:** consensus/src/liveness/proposal_generator.rs (L643-650)
```rust
        let pending_validator_txn_hashes: HashSet<HashValue> = pending_blocks
            .iter()
            .filter_map(|block| block.validator_txns())
            .flatten()
            .map(ValidatorTransaction::hash)
            .collect();
        let validator_txn_filter =
            vtxn_pool::TransactionFilter::PendingTxnHashSet(pending_validator_txn_hashes);
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L128-130)
```rust
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```

**File:** consensus/src/round_manager.rs (L1126-1137)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
        }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L816-823)
```rust
            block
                .validator_txns()
                .cloned()
                .unwrap_or_default()
                .into_iter()
                .map(Transaction::ValidatorTransaction)
                .map(SignatureVerifiedTransaction::from)
                .collect(),
```
