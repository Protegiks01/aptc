# Audit Report

## Title
Missing Auditable On-Chain Events for Validator Penalties, Ejections, and Equivocation

## Summary
The Aptos consensus and staking systems lack auditable on-chain events for critical validator penalty actions including automatic ejections, failed proposals, and equivocation detection. While these actions occur correctly, they leave no on-chain audit trail, creating accountability gaps for delegators and governance participants.

## Finding Description

The security issue manifests across three critical areas:

**1. Consensus Layer - Missing Equivocation Events**

The `LogEvent` enum in the consensus logging module contains no variants for validator misbehavior, slashing, or penalties: [1](#0-0) 

When equivocation is detected in the consensus voting system, it only logs to application error logs using `SecurityEvent::ConsensusEquivocatingVote`, but emits no on-chain event: [2](#0-1) 

**2. Staking Layer - Missing Performance Penalty Events**

The `update_performance_statistics` function tracks failed and successful proposals but emits no events when validators fail proposals: [3](#0-2) 

The `StakePool` struct contains event handles for various staking operations but lacks any event handles for performance updates or penalties: [4](#0-3) 

**3. Automatic Ejection Without Events**

During epoch transitions in `on_new_epoch`, validators with insufficient stake are silently excluded from the next epoch without emitting any event: [5](#0-4) 

Note that `LeaveValidatorSet` events are only emitted when validators explicitly request to leave, not for automatic ejections: [6](#0-5) 

**4. Slashing Not Yet Implemented**

The codebase acknowledges that slashing is planned but not implemented: [7](#0-6) 

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria for "State inconsistencies requiring intervention" because:

1. **Governance Accountability Gap**: Network participants cannot audit validator behavior through on-chain events alone
2. **Delegator Information Asymmetry**: Delegators lack transparent evidence of their validator's performance degradation or misbehavior
3. **Dispute Resolution Impairment**: Without on-chain event trails, disputes about validator ejections or penalties cannot be definitively resolved
4. **Regulatory Compliance Risk**: Lack of auditable trails for penalties may violate transparency requirements

While the system functions correctly (validators are penalized through reduced rewards and ejected appropriately), the absence of on-chain event evidence breaks the blockchain's core transparency and auditability guarantees.

## Likelihood Explanation

**Likelihood: HIGH**

This issue occurs automatically in normal operations:
- Every time a validator fails a proposal (tracked but not logged)
- Every time a validator is automatically ejected due to insufficient stake (happens without events)
- Every time equivocation is detected (logged to application logs only)

The impact compounds over time as the blockchain accumulates undocumented penalty actions, making historical audits impossible.

## Recommendation

**1. Add Validator Performance Events to Consensus LogEvent Enum:**

```rust
// In consensus/src/logging.rs
pub enum LogEvent {
    // ... existing events ...
    ValidatorEquivocation,
    ValidatorFailedProposal,
    ValidatorMisbehavior,
}
```

**2. Add Performance Event Handles to StakePool:**

```move
// In aptos-move/framework/aptos-framework/sources/stake.move
struct StakePool has key {
    // ... existing fields ...
    validator_performance_events: EventHandle<ValidatorPerformanceEvent>,
    validator_ejection_events: EventHandle<ValidatorEjectionEvent>,
}

#[event]
struct ValidatorPerformanceEvent has drop, store {
    pool_address: address,
    epoch: u64,
    successful_proposals: u64,
    failed_proposals: u64,
}

#[event]
struct ValidatorEjectionEvent has drop, store {
    pool_address: address,
    epoch: u64,
    reason: u8, // 1=insufficient_stake, 2=slashing, etc.
    final_stake: u64,
}
```

**3. Emit Events in update_performance_statistics:**

```move
// After updating performance counters
if (features::module_event_migration_enabled()) {
    event::emit(ValidatorPerformanceUpdate {
        validator_index,
        successful_proposals: validator.successful_proposals,
        failed_proposals: validator.failed_proposals,
    });
}
```

**4. Emit Events During Automatic Ejection:**

```move
// In on_new_epoch, when validator is excluded
if (new_validator_info.voting_power < minimum_stake) {
    event::emit(ValidatorEjectionEvent {
        pool_address,
        epoch: current_epoch,
        reason: EJECTION_REASON_INSUFFICIENT_STAKE,
        final_stake: new_validator_info.voting_power,
    });
}
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, validator = @0x123)]
public entry fun test_validator_ejection_no_event(
    aptos_framework: &signer,
    validator: &signer,
) {
    // Setup: Initialize validator with minimum stake
    stake::initialize_validator(validator, ...);
    stake::add_stake(validator, 1000000); // Just above minimum
    stake::join_validator_set(validator);
    
    // Action: Unlock most stake, falling below minimum
    stake::unlock(validator, 900000);
    
    // Trigger epoch transition
    stake::on_new_epoch();
    
    // Verify: Validator is ejected but NO ValidatorEjectionEvent exists
    assert!(stake::get_validator_state(@0x123) == VALIDATOR_STATUS_INACTIVE, 0);
    
    // BUG: No event was emitted for this ejection
    // Delegators have no on-chain proof their validator was kicked
    // Governance cannot audit why validator was removed
}

#[test]
public entry fun test_failed_proposal_no_event() {
    // Setup validators and consensus
    // ...
    
    // Action: Validator fails to propose (due to offline, malicious, etc.)
    block::prologue(proposer_index, failed_proposer_indices = vector[validator_idx]);
    
    // Verify: failed_proposals counter incremented but NO event emitted
    let perf = stake::get_validator_performance(validator_idx);
    assert!(perf.failed_proposals == 1, 0);
    
    // BUG: No ValidatorPerformanceEvent was emitted
    // No on-chain audit trail for this penalty
}
```

**Notes**

While the core staking and consensus mechanisms function correctly—validators are appropriately penalized through reduced rewards and ejected when stake falls below thresholds—the absence of on-chain events creates a critical transparency gap. The system relies solely on resource state changes (e.g., `ValidatorPerformance` resource updates) which are visible in transaction write sets but lack the semantic clarity and accessibility of dedicated events. This design choice prioritizes gas efficiency over auditability, but breaks the expectation that blockchain operations provide immutable audit trails. The delegation pool code's explicit acknowledgment that "Slashing (if implemented)" suggests this is a known gap in the system's maturity.

### Citations

**File:** consensus/src/logging.rs (L20-69)
```rust
#[derive(Serialize)]
pub enum LogEvent {
    BroadcastOrderVote,
    CommitViaBlock,
    CommitViaSync,
    IncrementalProofExpired,
    NetworkReceiveProposal,
    NewEpoch,
    NewRound,
    ProofOfStoreInit,
    ProofOfStoreReady,
    ProofOfStoreCommit,
    Propose,
    ReceiveBatchRetrieval,
    ReceiveBlockRetrieval,
    ReceiveEpochChangeProof,
    ReceiveEpochRetrieval,
    ReceiveMessageFromDifferentEpoch,
    ReceiveNewCertificate,
    ReceiveProposal,
    ReceiveSyncInfo,
    ReceiveVote,
    ReceiveRoundTimeout,
    ReceiveOrderVote,
    RetrieveBlock,
    StateSync,
    Timeout,
    Vote,
    VoteNIL,
    // log events related to randomness generation
    BroadcastRandShare,
    ReceiveProactiveRandShare,
    ReceiveReactiveRandShare,
    BroadcastAugData,
    ReceiveAugData,
    BroadcastCertifiedAugData,
    ReceiveCertifiedAugData,
    // randomness fast path
    BroadcastRandShareFastPath,
    ReceiveRandShareFastPath,
    // optimistic proposal
    OptPropose,
    NetworkReceiveOptProposal,
    ReceiveOptProposal,
    ProcessOptProposal,
    // secret sharing events
    ReceiveSecretShare,
    BroadcastSecretShare,
    ReceiveReactiveSecretShare,
}
```

**File:** consensus/src/pending_votes.rs (L287-308)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L125-158)
```text
    struct StakePool has key {
        // active stake
        active: Coin<AptosCoin>,
        // inactive stake, can be withdrawn
        inactive: Coin<AptosCoin>,
        // pending activation for next epoch
        pending_active: Coin<AptosCoin>,
        // pending deactivation for next epoch
        pending_inactive: Coin<AptosCoin>,
        locked_until_secs: u64,
        // Track the current operator of the validator node.
        // This allows the operator to be different from the original account and allow for separation of
        // the validator operations and ownership.
        // Only the account holding OwnerCapability of the staking pool can update this.
        operator_address: address,

        // Track the current vote delegator of the staking pool.
        // Only the account holding OwnerCapability of the staking pool can update this.
        delegated_voter: address,

        // The events emitted for the entire StakePool's lifecycle.
        initialize_validator_events: EventHandle<RegisterValidatorCandidateEvent>,
        set_operator_events: EventHandle<SetOperatorEvent>,
        add_stake_events: EventHandle<AddStakeEvent>,
        reactivate_stake_events: EventHandle<ReactivateStakeEvent>,
        rotate_consensus_key_events: EventHandle<RotateConsensusKeyEvent>,
        update_network_and_fullnode_addresses_events: EventHandle<UpdateNetworkAndFullnodeAddressesEvent>,
        increase_lockup_events: EventHandle<IncreaseLockupEvent>,
        join_validator_set_events: EventHandle<JoinValidatorSetEvent>,
        distribute_rewards_events: EventHandle<DistributeRewardsEvent>,
        unlock_stake_events: EventHandle<UnlockStakeEvent>,
        withdraw_stake_events: EventHandle<WithdrawStakeEvent>,
        leave_validator_set_events: EventHandle<LeaveValidatorSetEvent>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1258-1267)
```text
            if (std::features::module_event_migration_enabled()) {
                event::emit(LeaveValidatorSet { pool_address });
            } else {
                event::emit_event(
                    &mut stake_pool.leave_validator_set_events,
                    LeaveValidatorSetEvent {
                        pool_address,
                    },
                );
            };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1282-1332)
```text
    public(friend) fun update_performance_statistics(
        proposer_index: Option<u64>,
        failed_proposer_indices: vector<u64>
    ) acquires ValidatorPerformance {
        // Validator set cannot change until the end of the epoch, so the validator index in arguments should
        // match with those of the validators in ValidatorPerformance resource.
        let validator_perf = borrow_global_mut<ValidatorPerformance>(@aptos_framework);
        let validator_len = vector::length(&validator_perf.validators);

        spec {
            update ghost_valid_perf = validator_perf;
            update ghost_proposer_idx = proposer_index;
        };
        // proposer_index is an option because it can be missing (for NilBlocks)
        if (option::is_some(&proposer_index)) {
            let cur_proposer_index = option::extract(&mut proposer_index);
            // Here, and in all other vector::borrow, skip any validator indices that are out of bounds,
            // this ensures that this function doesn't abort if there are out of bounds errors.
            if (cur_proposer_index < validator_len) {
                let validator = vector::borrow_mut(&mut validator_perf.validators, cur_proposer_index);
                spec {
                    assume validator.successful_proposals + 1 <= MAX_U64;
                };
                validator.successful_proposals = validator.successful_proposals + 1;
            };
        };

        let f = 0;
        let f_len = vector::length(&failed_proposer_indices);
        while ({
            spec {
                invariant len(validator_perf.validators) == validator_len;
                invariant (option::is_some(ghost_proposer_idx) && option::borrow(
                    ghost_proposer_idx
                ) < validator_len) ==>
                    (validator_perf.validators[option::borrow(ghost_proposer_idx)].successful_proposals ==
                        ghost_valid_perf.validators[option::borrow(ghost_proposer_idx)].successful_proposals + 1);
            };
            f < f_len
        }) {
            let validator_index = *vector::borrow(&failed_proposer_indices, f);
            if (validator_index < validator_len) {
                let validator = vector::borrow_mut(&mut validator_perf.validators, validator_index);
                spec {
                    assume validator.failed_proposals + 1 <= MAX_U64;
                };
                validator.failed_proposals = validator.failed_proposals + 1;
            };
            f = f + 1;
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1384-1398)
```text
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L153-157)
```text
    /// Slashing (if implemented) should not be applied to already `inactive` stake.
    /// Not only it invalidates the accounting of past observed lockup cycles (OLC),
    /// but is also unfair to delegators whose stake has been inactive before validator started misbehaving.
    /// Additionally, the inactive stake does not count on the voting power of validator.
    const ESLASHED_INACTIVE_STAKE_ON_PAST_OLC: u64 = 7;
```
