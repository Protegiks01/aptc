# Audit Report

## Title
State Inconsistency in Ledger Metadata Pruner After Database Truncation

## Summary
The `LedgerMetadataPruner::new()` fallback initialization can create an incorrect `min_readable_version` when `VersionData` entries are deleted by database truncation without updating `LedgerPrunerProgress`, causing the system to report wrong availability information to clients.

## Finding Description

The vulnerability occurs in the fallback initialization path of `LedgerMetadataPruner::new()`: [1](#0-0) 

When `LedgerPrunerProgress` doesn't exist in the database, the code falls back to checking the first `VersionData` entry. If all `VersionData` entries were previously deleted by the truncation mechanism, `iter.next()` returns `None` and the progress is initialized to version 0.

The truncation mechanism in `truncation_helper.rs` can delete `VersionData` entries without updating `LedgerPrunerProgress`: [2](#0-1) 

This creates a state inconsistency where:

1. The pruner progress is set to 0 (believing no data has been pruned)
2. But all `VersionData` was actually deleted by truncation
3. The `LedgerPrunerManager` uses this incorrect progress to set `min_readable_version`: [3](#0-2) 

4. API methods return incorrect availability information: [4](#0-3) 

5. Validation checks pass incorrectly: [5](#0-4) 

Clients attempting to read data within the claimed range (version 0 onwards) will receive "NotFound" errors instead of proper "pruned" error messages, breaking the API contract.

## Impact Explanation

This qualifies as **Medium severity** under "State inconsistencies requiring intervention" because:
- The system's metadata (min_readable_version) becomes inconsistent with actual data availability
- API responses provide incorrect information about data availability
- Clients receive misleading error messages
- Does not directly impact consensus, funds, or network availability

## Likelihood Explanation

**Low likelihood** - Requires specific conditions:
1. Database without `LedgerPrunerProgress` (old database or manual deletion)
2. Database truncation operation that deletes all `VersionData` entries
3. Operator must run db-debugger truncate command or similar maintenance operations
4. Subsequent pruner initialization

This is primarily an operational/administrative scenario, not something an unprivileged attacker can trigger.

## Recommendation

Update the truncation mechanism to properly maintain pruner progress metadata:

```rust
// In truncation_helper.rs, after deleting VersionData:
fn truncate_ledger_db_single_batch(...) -> Result<()> {
    // ... existing truncation code ...
    
    // Update pruner progress to match truncation
    let mut progress_batch = SchemaBatch::new();
    progress_batch.put::<DbMetadataSchema>(
        &DbMetadataKey::LedgerPrunerProgress,
        &DbMetadataValue::Version(start_version - 1),
    )?;
    ledger_db.metadata_db().write_schemas(progress_batch)?;
    
    // ... rest of code ...
}
```

Alternatively, improve the fallback initialization to detect when data is missing and use the actual committed version range instead of defaulting to 0.

## Proof of Concept

```rust
#[test]
fn test_pruner_state_inconsistency_after_truncation() {
    // 1. Initialize database with VersionData up to version 1000
    let tmpdir = TempPath::new();
    let db = AptosDB::new_for_test(&tmpdir);
    
    // Commit transactions creating VersionData entries
    for i in 0..=1000 {
        // ... commit transaction at version i ...
    }
    
    // 2. Manually delete all VersionData entries (simulating truncation)
    let mut batch = SchemaBatch::new();
    for version in 0..=1000 {
        batch.delete::<VersionDataSchema>(&version).unwrap();
    }
    db.ledger_db.metadata_db().write_schemas(batch).unwrap();
    
    // 3. Delete LedgerPrunerProgress to trigger fallback
    let mut batch = SchemaBatch::new();
    batch.delete::<DbMetadataSchema>(&DbMetadataKey::LedgerPrunerProgress).unwrap();
    db.ledger_db.metadata_db().write_schemas(batch).unwrap();
    
    drop(db);
    
    // 4. Reinitialize database, triggering fallback initialization
    let db = AptosDB::new_for_test(&tmpdir);
    
    // 5. Check min_readable_version - it will be 0 despite no data existing
    let min_readable = db.ledger_pruner.get_min_readable_version();
    assert_eq!(min_readable, 0); // Incorrectly reports 0
    
    // 6. Attempt to read VersionData at version 500
    let result = db.ledger_db.metadata_db().get_usage(500);
    // Returns "NotFound" instead of "pruned" error
    assert!(result.is_err());
    
    // But error_if_ledger_pruned doesn't catch it:
    let check = db.error_if_ledger_pruned("VersionData", 500);
    assert!(check.is_ok()); // WRONG - should error since data is pruned
}
```

**Notes:**
- This is an operational issue requiring database administrator actions
- The inconsistency affects error reporting and API contracts but doesn't compromise consensus or funds
- The issue can be manually corrected by setting proper pruner progress metadata

### Citations

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_metadata_pruner.rs (L19-40)
```rust
    pub(in crate::pruner) fn new(ledger_metadata_db: Arc<DB>) -> Result<Self> {
        if let Some(v) =
            ledger_metadata_db.get::<DbMetadataSchema>(&DbMetadataKey::LedgerPrunerProgress)?
        {
            v.expect_version();
        } else {
            // NOTE: I **think** all db should have the LedgerPrunerProgress. Have a fallback path
            // here in case the database was super old before we introducing this progress counter.
            let mut iter = ledger_metadata_db.iter::<VersionDataSchema>()?;
            iter.seek_to_first();
            let version = match iter.next().transpose()? {
                Some((version, _)) => version,
                None => 0,
            };
            ledger_metadata_db.put::<DbMetadataSchema>(
                &DbMetadataKey::LedgerPrunerProgress,
                &DbMetadataValue::Version(version),
            )?;
        }

        Ok(LedgerMetadataPruner { ledger_metadata_db })
    }
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L450-454)
```rust
    delete_per_version_data_impl::<VersionDataSchema>(
        &ledger_db.metadata_db_arc(),
        start_version,
        &mut batch.ledger_metadata_db_batches,
    )?;
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L123-124)
```rust
        let min_readable_version =
            pruner_utils::get_ledger_pruner_progress(&ledger_db).expect("Must succeed.");
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L329-332)
```rust
    fn get_first_txn_version(&self) -> Result<Option<Version>> {
        gauged_api("get_first_txn_version", || {
            Ok(Some(self.ledger_pruner.get_min_readable_version()))
        })
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L261-271)
```rust
    pub(super) fn error_if_ledger_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.ledger_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```
