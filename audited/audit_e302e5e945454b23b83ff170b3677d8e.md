# Audit Report

## Title
Missing Recursive Type Parameter Validation in Transaction Argument Checking for Parameterized Structs

## Summary
The compile-time and runtime validation for entry function parameters fails to recursively validate type parameters of allowed structs (Object<T>, Option<T>), allowing attackers to bypass transaction argument type restrictions by wrapping disallowed types in allowed generic containers.

## Finding Description
The transaction argument validation in Aptos has two layers:
1. Compile-time validation in `check_transaction_input_type()` 
2. Runtime validation in `is_valid_txn_arg()`

Both validation layers exhibit the same critical flaw: they validate generic struct types (like `Object<T>`, `Option<T>`) by only checking if the base struct name is in the allowed list, without recursively validating the type parameters. [1](#0-0) [2](#0-1) 

In contrast, `Vector<T>` types ARE recursively validated: [3](#0-2) 

This inconsistency creates a bypass: while user-defined structs cannot be used directly as transaction arguments, they can be used indirectly as type parameters to `Object<T>` or `Option<T>`.

When an entry function with type parameters is called (e.g., `entry fun process<T: key>(obj: Object<T>)`), the type substitution occurs before validation: [4](#0-3) 

After substitution, `Object<UserStruct>` only checks if "0x1::object::Object" is allowed, ignoring whether `UserStruct` should be permitted.

## Impact Explanation
**Severity: Medium** 

This issue violates the **Transaction Validation** invariant by allowing types that should not be transaction arguments to enter the system indirectly. While this doesn't directly lead to fund loss or consensus violations, it breaks the security boundary that transaction argument validation is meant to enforce.

The impact is limited because:
- Constructor ability checks still enforce type constraints (e.g., `T: key` for `Object<T>`)
- The wrapped type is not directly deserialized from transaction bytes
- No immediate consensus or state corruption occurs

However, this could enable:
- Bypassing developer-intended type restrictions in entry functions
- Using arbitrary user-defined types where only framework types were expected
- Potential future exploits if code assumes only validated types appear in parameters

## Likelihood Explanation
**Likelihood: High**

This vulnerability is highly likely to be exploited because:
1. Entry functions commonly use generic type parameters for flexibility
2. Attackers can easily craft transactions with arbitrary type arguments
3. No special permissions or validator access required
4. The validation bypass is deterministic and reliable

## Recommendation
Implement recursive type parameter validation for all allowed structs, consistent with how vectors are validated. Modify both validation functions to check type arguments:

**For compile-time validation** (`extended_checks.rs`):
```rust
Struct(mid, sid, type_args) if self.is_allowed_input_struct(mid.qualified(*sid)) => {
    // Recursively validate all type parameters
    for ty_arg in type_args {
        self.check_transaction_input_type(loc, ty_arg);
    }
}
```

**For runtime validation** (`transaction_arg_validation.rs`):
```rust
Struct { ty_args, .. } | StructInstantiation { ty_args, .. } => {
    runtime_environment.get_struct_name(ty).ok().flatten().is_some_and(|(module_id, identifier)| {
        let base_allowed = allowed_structs.contains_key(&format!("{}::{}", module_id.short_str_lossless(), identifier));
        // Recursively validate type arguments
        let ty_args_valid = ty_args.iter().all(|ty_arg| is_valid_txn_arg(runtime_environment, ty_arg, allowed_structs));
        base_allowed && ty_args_valid
    })
}
```

## Proof of Concept
```move
// Module deployed by attacker
module attacker::exploit {
    use std::signer;
    use aptos_framework::object::{Self, Object};
    
    // User-defined struct with key - NOT in allowed_structs list
    struct MaliciousResource has key {
        data: vector<u8>
    }
    
    // Entry function with generic type parameter
    // Validation incorrectly allows Object<MaliciousResource>
    entry fun exploit<T: key>(caller: &signer, obj: Object<T>) {
        // Type T can be MaliciousResource, bypassing validation
        // that would reject MaliciousResource as direct parameter
        let addr = object::object_address(&obj);
        // ... exploit logic using the wrapped type
    }
    
    // Setup function to create the malicious resource
    public entry fun setup(caller: &signer) {
        let constructor_ref = object::create_object(@attacker);
        let obj_signer = object::generate_signer(&constructor_ref);
        move_to(&obj_signer, MaliciousResource { data: vector::empty() });
    }
}

// Attack execution:
// 1. Call setup() to create MaliciousResource at some address
// 2. Call exploit<MaliciousResource>(obj) where obj is Object<MaliciousResource>
// 3. Validation passes despite MaliciousResource not being in allowed_structs
```

## Notes
The vulnerability exists due to inconsistent validation between primitive/vector types (which validate recursively) and struct types (which don't). The TODO comment acknowledges synchronization issues between compile-time and runtime validation, but the deeper issue is the missing recursive validation of generic type parameters. [5](#0-4)

### Citations

**File:** aptos-move/framework/src/extended_checks.rs (L257-259)
```rust
            Struct(mid, sid, _) if self.is_allowed_input_struct(mid.qualified(*sid)) => {
                // Specific struct types are allowed
            },
```

**File:** aptos-move/framework/src/extended_checks.rs (L275-275)
```rust
        // TODO(gerben) find a nice way to keep this in sync with allowed_structs in aptos-vm
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L139-149)
```rust
    for ty in func.param_tys()[signer_param_cnt..].iter() {
        let subst_res = ty_builder.create_ty_with_subst(ty, func.ty_args());
        let ty = subst_res.map_err(|e| e.finish(Location::Undefined).into_vm_status())?;
        let valid = is_valid_txn_arg(loader.runtime_environment(), &ty, allowed_structs);
        if !valid {
            return Err(VMStatus::error(
                StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE,
                None,
            ));
        }
    }
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L208-208)
```rust
        Vector(inner) => is_valid_txn_arg(runtime_environment, inner, allowed_structs),
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L209-223)
```rust
        Struct { .. } | StructInstantiation { .. } => {
            // Note: Original behavior was to return false even if the module loading fails (e.g.,
            //       if struct does not exist. This preserves it.
            runtime_environment
                .get_struct_name(ty)
                .ok()
                .flatten()
                .is_some_and(|(module_id, identifier)| {
                    allowed_structs.contains_key(&format!(
                        "{}::{}",
                        module_id.short_str_lossless(),
                        identifier
                    ))
                })
        },
```
