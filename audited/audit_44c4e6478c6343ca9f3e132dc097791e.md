# Audit Report

## Title
Transaction Ordering Vulnerability in Chunked Package Publishing with Nonce-Based Replay Protection

## Summary
The `chunk_package_and_create_payloads()` function generates multiple transaction payloads that must execute in exact sequential order for correct package assembly. However, when users specify `--replay-protection-type nonce`, these transactions become orderless and can execute in any sequence, causing metadata and code chunks to be assembled incorrectly in the `large_packages.move` module. While this primarily results in failed deployments, it represents a missing validation that allows an unsupported and dangerous configuration. [1](#0-0) 

## Finding Description
The chunked package publishing mechanism splits large Move packages into multiple transactions. The Rust function `chunk_package_and_create_payloads()` creates a vector of `TransactionPayload` objects that stage chunks sequentially before final publication. [2](#0-1) 

The Move module `stage_code_chunk_internal` uses order-dependent operations:
- Line 159: `vector::append(&mut staging_area.metadata_serialized, metadata_chunk)` appends metadata chunks in received order
- Lines 168-170: Code chunks are appended to existing SmartTable entries in received order [3](#0-2) 

Users can specify `--replay-protection-type nonce` when publishing, which converts transactions to use nonce-based replay protection instead of sequence numbers. [4](#0-3) 

**Attack Path:**
1. User publishes large package with: `aptos move publish --chunked-publish --replay-protection-type nonce`
2. Multiple staging transactions are created with nonce-based replay protection
3. Nonce transactions are orderless and can execute in any sequence
4. If Transaction 2 executes before Transaction 1, metadata chunks append as: chunk2_data + chunk1_data (wrong order)
5. Code chunks for the same module index concatenate in wrong order
6. Package deployment fails or produces corrupted bytecode [5](#0-4) 

The mempool enforces sequence number ordering (lines 459-497) but explicitly allows nonce-based transactions to execute without order constraints (lines 499-505).

**Developer Awareness:** [6](#0-5) [7](#0-6) 

TODO comments indicate developers are aware of orderless transaction limitations but haven't implemented proper support or validation.

## Impact Explanation
**Severity Assessment: Medium (does not reach Critical/High thresholds)**

While this represents a design flaw, the actual security impact is limited:

1. **Self-inflicted harm only**: The vulnerability only affects the user publishing the package, not other users or the blockchain
2. **Deployment will fail**: The corrupted metadata/bytecode will fail Move VM validation checks
3. **No funds at risk**: No mechanism for theft or unauthorized minting
4. **No consensus impact**: Does not affect validator agreement or blockchain state
5. **Wasted gas**: Users lose gas on failed transactions but no permanent damage

This is primarily a **missing validation** that allows users to select an unsupported configuration. The system should either:
- Reject the combination of `--chunked-publish` and `--replay-protection-type nonce`
- Properly support orderless chunked publishing

Per Aptos bug bounty criteria, this falls short of Critical/High severity as it doesn't cause loss of funds, consensus violations, or deployment of malicious code.

## Likelihood Explanation
**Likelihood: Low**

Several factors make this unlikely to occur in practice:
1. Default replay protection is sequence numbers, not nonces
2. Users must explicitly opt-in to nonce-based transactions
3. The combination of chunked publish + nonce is not documented or recommended
4. Failed deployments provide immediate feedback, preventing repeated attempts
5. Developers are aware (TODO comments) and likely warning users

However, the lack of validation means sophisticated users exploring orderless transactions could encounter this issue.

## Recommendation

**Option 1: Add validation to reject unsupported combination**
```rust
// In crates/aptos/src/move_tool/mod.rs, in PublishPackage::execute()
if self.chunked_publish_option.chunked_publish 
    && self.txn_options.replay_protection_type == ReplayProtectionType::Nonce {
    return Err(CliError::CommandArgumentError(
        "Chunked publish is not supported with nonce-based replay protection. \
         Use sequence number-based replay protection (default) for chunked publishing."
            .to_string(),
    ));
}
```

**Option 2: Implement proper orderless chunked publishing**
Modify the Move module to include sequence metadata with each chunk and validate ordering during assembly, as indicated by the TODO comments.

## Proof of Concept

```rust
// Test demonstrating out-of-order chunk execution with nonces
// Add to: aptos-move/e2e-move-tests/src/tests/large_package_publishing.rs

#[test]
fn test_orderless_chunked_publish_corruption() {
    let mut context = LargePackageTestContext::new();
    let account = context.account.clone();
    
    // Create chunked payloads
    let payloads = context.create_publish_large_package_from_path(
        &common::test_dir_path("../../../move-examples/large_packages/large_package_example"),
        None,
        |_| {},
        PublishType::AccountDeploy,
    );
    
    assert!(payloads.len() >= 2, "Need multiple chunks for this test");
    
    // Submit transactions OUT OF ORDER with nonces (simulating orderless execution)
    // In practice, nonce transactions could execute in any order
    let mut tx_statuses = vec![];
    
    // Submit LAST chunk first (simulating out-of-order execution)
    for i in (0..payloads.len()).rev() {
        let payload = payloads[i].clone();
        // Note: In real scenario, these would have nonces and could execute in any order
        let signed_tx = context
            .harness
            .create_transaction_without_sign(&account, payload)
            .sign();
        tx_statuses.push(context.harness.run(signed_tx));
    }
    
    // Expect: Final transaction should FAIL due to corrupted chunk assembly
    // The metadata and code chunks were staged in wrong order
    assert!(!tx_statuses.last().unwrap().status().is_success());
}
```

## Notes

After thorough analysis, while this represents a legitimate design issue where the system allows an unsupported configuration, **it does not constitute a Critical or High severity security vulnerability** per the Aptos bug bounty criteria because:

1. The impact is limited to failed package deployments (self-inflicted)
2. No funds are at risk, no consensus violations occur
3. The corrupted bytecode/metadata fails validation and doesn't deploy
4. Developers are aware (TODO comments indicate planned fixes)

The proper characterization is: **Missing validation for an unsupported feature combination** rather than an exploitable security vulnerability. The fix should prevent users from selecting this combination until proper orderless chunked publishing support is implemented.

However, given the strict interpretation of the security question asking whether validation exists for transaction ordering, the answer is: **Validation exists via sequence numbers (default), but is bypassed when users opt into nonce-based replay protection, creating a footgun that should be prevented via input validation.**

### Citations

**File:** aptos-move/framework/src/chunked_publish.rs (L36-110)
```rust
pub fn chunk_package_and_create_payloads(
    metadata: Vec<u8>,
    package_code: Vec<Vec<u8>>,
    publish_type: PublishType,
    object_address: Option<AccountAddress>,
    large_packages_module_address: AccountAddress,
    chunk_size: usize,
) -> Vec<TransactionPayload> {
    // Chunk the metadata
    let mut metadata_chunks = create_chunks(metadata, chunk_size);
    // Separate last chunk for special handling
    let mut metadata_chunk = metadata_chunks.pop().expect("Metadata is required");

    let mut taken_size = metadata_chunk.len();
    let mut payloads = metadata_chunks
        .into_iter()
        .map(|chunk| {
            large_packages_stage_code_chunk(chunk, vec![], vec![], large_packages_module_address)
        })
        .collect::<Vec<_>>();

    let mut code_indices: Vec<u16> = vec![];
    let mut code_chunks: Vec<Vec<u8>> = vec![];

    for (idx, module_code) in package_code.into_iter().enumerate() {
        let chunked_module = create_chunks(module_code, chunk_size);
        for chunk in chunked_module {
            if taken_size + chunk.len() > chunk_size {
                // Create a payload and reset accumulators
                let payload = large_packages_stage_code_chunk(
                    metadata_chunk,
                    code_indices.clone(),
                    code_chunks.clone(),
                    large_packages_module_address,
                );
                payloads.push(payload);

                metadata_chunk = vec![];
                code_indices.clear();
                code_chunks.clear();
                taken_size = 0;
            }

            code_indices.push(idx as u16);
            taken_size += chunk.len();
            code_chunks.push(chunk);
        }
    }

    // The final call includes staging the last metadata and code chunk, and then publishing or upgrading the package on-chain.
    let payload = match publish_type {
        PublishType::AccountDeploy => large_packages_stage_code_chunk_and_publish_to_account(
            metadata_chunk,
            code_indices,
            code_chunks,
            large_packages_module_address,
        ),
        PublishType::ObjectDeploy => large_packages_stage_code_chunk_and_publish_to_object(
            metadata_chunk,
            code_indices,
            code_chunks,
            large_packages_module_address,
        ),
        PublishType::ObjectUpgrade => large_packages_stage_code_chunk_and_upgrade_object_code(
            metadata_chunk,
            code_indices,
            code_chunks,
            object_address.expect("ObjectAddress is missing"),
            large_packages_module_address,
        ),
    };
    payloads.push(payload);

    payloads
}
```

**File:** aptos-move/framework/src/chunked_publish.rs (L148-148)
```rust
    // TODO[Orderless]: Change this to payload v2 format.
```

**File:** aptos-move/framework/aptos-experimental/sources/large_packages.move (L132-181)
```text
    inline fun stage_code_chunk_internal(
        owner: &signer,
        metadata_chunk: vector<u8>,
        code_indices: vector<u16>,
        code_chunks: vector<vector<u8>>
    ): &mut StagingArea {
        assert!(
            vector::length(&code_indices) == vector::length(&code_chunks),
            error::invalid_argument(ECODE_MISMATCH)
        );

        let owner_address = signer::address_of(owner);

        if (!exists<StagingArea>(owner_address)) {
            move_to(
                owner,
                StagingArea {
                    metadata_serialized: vector[],
                    code: smart_table::new(),
                    last_module_idx: 0
                }
            );
        };

        let staging_area = borrow_global_mut<StagingArea>(owner_address);

        if (!vector::is_empty(&metadata_chunk)) {
            vector::append(&mut staging_area.metadata_serialized, metadata_chunk);
        };

        let i = 0;
        while (i < vector::length(&code_chunks)) {
            let inner_code = *vector::borrow(&code_chunks, i);
            let idx = (*vector::borrow(&code_indices, i) as u64);

            if (smart_table::contains(&staging_area.code, idx)) {
                vector::append(
                    smart_table::borrow_mut(&mut staging_area.code, idx), inner_code
                );
            } else {
                smart_table::add(&mut staging_area.code, idx, inner_code);
                if (idx > staging_area.last_module_idx) {
                    staging_area.last_module_idx = idx;
                }
            };
            i = i + 1;
        };

        staging_area
    }
```

**File:** crates/aptos/src/common/types.rs (L1820-1826)
```rust
    /// Replay protection mechanism to use when generating the transaction.
    ///
    /// When "nonce" is chosen, the transaction will be an orderless transaction and contains a replay protection nonce.
    ///
    /// When "seqnum" is chosen, the transaction will contain a sequence number that matches with the sender's onchain sequence number.
    #[clap(long, default_value_t = ReplayProtectionType::Seqnum)]
    pub(crate) replay_protection_type: ReplayProtectionType,
```

**File:** crates/aptos/src/common/types.rs (L1996-2004)
```rust
            let unsigned_transaction = if self.replay_protection_type == ReplayProtectionType::Nonce
            {
                let mut rng = rand::thread_rng();
                txn_builder
                    .upgrade_payload_with_rng(&mut rng, true, true)
                    .build()
            } else {
                txn_builder.build()
            };
```

**File:** mempool/src/core_mempool/mempool.rs (L459-498)
```rust
                ReplayProtector::SequenceNumber(txn_seq) => {
                    let txn_in_sequence = txn_seq > 0
                        && Self::txn_was_chosen(
                            txn.address,
                            txn_seq - 1,
                            &inserted,
                            &exclude_transactions,
                        );
                    let account_sequence_number =
                        self.transactions.get_account_sequence_number(&txn.address);
                    // include transaction if it's "next" for given account or
                    // we've already sent its ancestor to Consensus.
                    if txn_in_sequence || account_sequence_number == Some(&txn_seq) {
                        inserted.insert((txn.address, txn_replay_protector));
                        result.push((txn.address, txn_replay_protector));
                        if (result.len() as u64) == max_txns {
                            break;
                        }
                        // check if we can now include some transactions
                        // that were skipped before for given account
                        let (skipped_txn_sender, mut skipped_txn_seq_num) =
                            (txn.address, txn_seq + 1);
                        while skipped.remove(&(skipped_txn_sender, skipped_txn_seq_num)) {
                            inserted.insert((
                                skipped_txn_sender,
                                ReplayProtector::SequenceNumber(skipped_txn_seq_num),
                            ));
                            result.push((
                                skipped_txn_sender,
                                ReplayProtector::SequenceNumber(skipped_txn_seq_num),
                            ));
                            if (result.len() as u64) == max_txns {
                                break 'main;
                            }
                            skipped_txn_seq_num += 1;
                        }
                    } else {
                        skipped.insert((txn.address, txn_seq));
                    }
                },
```

**File:** crates/aptos/src/move_tool/mod.rs (L1417-1417)
```rust
    // TODO[Ordereless]: Update this code to support stateless accounts that don't have a sequence number
```
