# Audit Report

## Title
Unbounded Channel Memory Exhaustion in Cross-Shard Message Handling

## Summary
The `RemoteCrossShardClient::receive_cross_shard_msg()` function uses unbounded channels to receive cross-shard messages, with no rate limiting or backpressure mechanism. This allows resource exhaustion through excessive message queuing, potentially leading to memory exhaustion and bandwidth consumption in sharded execution scenarios.

## Finding Description

The cross-shard messaging system in the remote executor service contains multiple resource exhaustion vectors:

**1. Unbounded Channel Usage**

The `NetworkController` creates unbounded channels for message passing: [1](#0-0) [2](#0-1) 

**2. No Rate Limiting in Message Reception**

The `receive_cross_shard_msg()` function directly receives from the unbounded channel without any rate limiting: [3](#0-2) 

**3. Large Message Size Allowance**

Messages can be up to 80MB each: [4](#0-3) 

**4. High Message Volume Potential**

Each transaction can perform up to 8,192 write operations: [5](#0-4) 

When a transaction with cross-shard dependencies commits, it sends a message to each dependent shard for each write operation that has dependencies: [6](#0-5) 

**5. No Message Authentication**

Messages are sent without authentication or sender validation: [7](#0-6) 

**Attack Scenario:**

While cross-shard dependencies are determined by the centralized partitioner (preventing arbitrary dependency creation), the system still has vulnerabilities:

1. **Legitimate High-Dependency Workload**: An attacker submits transactions designed to maximize cross-shard dependencies (up to 8,192 writes per transaction, each potentially triggering messages to multiple dependent shards)
2. **Message Queuing**: Messages queue in unbounded channels at receiving shards
3. **Memory Exhaustion**: With no backpressure mechanism, the receiver's memory grows unbounded as messages accumulate faster than they can be processed
4. **Bandwidth Consumption**: High message volume (up to 80MB per message) consumes available network bandwidth

## Impact Explanation

This vulnerability breaks the **Resource Limits** invariant (#9: "All operations must respect gas, storage, and computational limits") and constitutes a **Medium Severity** issue per Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: Memory exhaustion could force shard restarts, disrupting execution
- **Validator node slowdowns**: Resource exhaustion degrades performance
- Does not directly compromise funds or consensus safety, but impacts availability

The impact is limited to sharded execution scenarios and does not affect the main consensus protocol.

## Likelihood Explanation

**Likelihood: Low to Medium**

**Factors Reducing Likelihood:**
- Requires sharded execution mode to be enabled (appears to be experimental/benchmarking feature)
- Per-transaction write limits (8,192 ops) and gas costs constrain individual transaction impact
- Partitioner controls dependency creation based on actual conflicts
- The comment in code suggests sharded executor is "only for benchmark purpose right now" [8](#0-7) 

**Factors Increasing Likelihood:**
- No rate limiting or backpressure mechanisms exist
- Unbounded channels allow unlimited message accumulation
- An attacker could craft workloads designed to maximize cross-shard conflicts

## Recommendation

Implement multiple defensive layers:

**1. Use Bounded Channels**
Replace unbounded channels with bounded channels to provide backpressure:

```rust
// In NetworkController::create_outbound_channel and create_inbound_channel
const MAX_CROSS_SHARD_MESSAGES: usize = 10000;
let (sender, receiver) = crossbeam_channel::bounded(MAX_CROSS_SHARD_MESSAGES);
```

**2. Add Rate Limiting**
Implement per-shard message rate limiting in `receive_cross_shard_msg()`:

```rust
fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
    let rx = self.message_rxs[current_round].lock().unwrap();
    // Add timeout to prevent indefinite blocking
    let message = rx.recv_timeout(Duration::from_secs(30))
        .expect("Timeout waiting for cross-shard message");
    let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
    msg
}
```

**3. Add Message Authentication**
Implement cryptographic authentication for cross-shard messages to prevent arbitrary message injection by compromised shards.

**4. Monitor and Alert**
Add metrics tracking channel queue depths and message rates to detect potential attacks early.

## Proof of Concept

```rust
// Theoretical PoC - would require full remote executor setup
use crossbeam_channel::unbounded;
use std::thread;
use std::time::Duration;

fn simulate_message_flood() {
    let (tx, rx) = unbounded(); // Same as production code
    
    // Simulate malicious shard flooding messages
    thread::spawn(move || {
        loop {
            // Send 80MB messages as fast as possible
            let large_message = vec![0u8; 80 * 1024 * 1024];
            tx.send(large_message).unwrap();
        }
    });
    
    // Simulate slow receiver processing
    thread::spawn(move || {
        loop {
            let msg = rx.recv().unwrap();
            // Simulate processing delay
            thread::sleep(Duration::from_millis(100));
            drop(msg);
        }
    });
    
    // Memory grows unbounded as messages queue faster than processing
    thread::sleep(Duration::from_secs(60));
}
```

## Notes

**Important Limitations:**

This vulnerability has significant scope limitations that reduce its practical exploitability:

1. **Experimental Feature**: The sharded block executor appears to be for benchmarking/testing, not production use
2. **Trust Model Mismatch**: Exploiting this requires either:
   - A compromised shard (insider threat - trusted component compromise)
   - OR carefully crafted legitimate transactions (limited by gas and partitioner logic)
3. **Out of Scope per Bug Bounty**: Network-level DoS attacks are explicitly excluded from the Aptos bug bounty program

The technical vulnerability exists in the code, but its practical exploitability by unprivileged attackers is limited. The issue is more relevant as a defense-in-depth improvement for future production use of sharded execution rather than an immediately exploitable security flaw in current production systems.

### Citations

**File:** secure/net/src/network_controller/mod.rs (L115-126)
```rust
    pub fn create_outbound_channel(
        &mut self,
        remote_peer_addr: SocketAddr,
        message_type: String,
    ) -> Sender<Message> {
        let (outbound_sender, outbound_receiver) = unbounded();

        self.outbound_handler
            .register_handler(message_type, remote_peer_addr, outbound_receiver);

        outbound_sender
    }
```

**File:** secure/net/src/network_controller/mod.rs (L128-137)
```rust
    pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
        let (inbound_sender, inbound_receiver) = unbounded();

        self.inbound_handler
            .lock()
            .unwrap()
            .register_handler(message_type, inbound_sender);

        inbound_receiver
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-59)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L61-66)
```rust
    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L173-177)
```rust
        [
            max_write_ops_per_transaction: NumSlots,
            { 11.. => "max_write_ops_per_transaction" },
            8192,
        ],
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L114-133)
```rust
        for (state_key, write_op) in write_set.expect_write_op_iter() {
            if let Some(dependent_shard_ids) = edges.get(state_key) {
                for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                    trace!("Sending remote update for success for shard id {:?} and txn_idx: {:?}, state_key: {:?}, dependent shard id: {:?}", self.shard_id, txn_idx, state_key, dependent_shard_id);
                    let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                        state_key.clone(),
                        Some(write_op.clone()),
                    ));
                    if *round_id == GLOBAL_ROUND_ID {
                        self.cross_shard_client.send_global_msg(message);
                    } else {
                        self.cross_shard_client.send_cross_shard_msg(
                            *dependent_shard_id,
                            *round_id,
                            message,
                        );
                    }
                }
            }
        }
```

**File:** types/src/block_executor/partitioner.rs (L449-454)
```rust
            ExecutableTransactions::Sharded(_) => {
                // Not supporting auxiliary info here because the sharded executor is only for
                // benchmark purpose right now.
                // TODO: Revisit when we need it.
                assert!(auxiliary_info.is_empty());
            },
```
