# Audit Report

## Title
Scheme Constant Synchronization Vulnerability Between Rust and Move Framework

## Summary
The resource account address derivation scheme constant (`DERIVE_RESOURCE_ACCOUNT_SCHEME = 0xFF`) exists independently in both Rust (`Scheme::DeriveResourceAccountAddress`) and Move framework code with no validation mechanism to ensure they remain synchronized across network upgrades. This creates a risk that framework upgrades via governance could change the Move constant while off-chain tooling continues using the outdated Rust constant, breaking resource account address derivation across the entire ecosystem.

## Finding Description

The Aptos codebase maintains two separate definitions of the scheme constant used for resource account address derivation:

**Rust Definition:** [1](#0-0) 

**Move Definition:** [2](#0-1) 

These constants are used in their respective implementations of `create_resource_address`:

**Rust Implementation (used by CLI/SDK):** [3](#0-2) 

**Move Implementation (used during on-chain execution):** [4](#0-3) 

The CLI implementation directly invokes the Rust function: [5](#0-4) 

**The Critical Issue:**

1. **No Validation Exists**: There are no compile-time checks, runtime assertions, or integration tests that verify these constants match.

2. **Independent Upgrade Paths**: The Aptos framework can be upgraded through governance proposals independently of node binary releases, as documented in the release process. [6](#0-5) 

3. **Attack Vector**: A governance proposal could (accidentally or maliciously) modify the Move constant to a different value. The proposal would go through normal governance voting and execution, but there's no technical barrier preventing this change.

4. **Widespread Breakage**: Since validators execute Move code during transaction processing but CLI/SDK tools use the Rust constant, any divergence would cause:
   - All off-chain address derivations to be incorrect
   - CLI commands like `derive-resource-account` to produce wrong addresses
   - SDK integrations to fail when creating resource accounts
   - User confusion and potential loss of access to expected addresses

This breaks the fundamental invariant that off-chain tooling must produce identical results to on-chain execution for deterministic address derivation.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program criteria for "Significant protocol violations" because:

1. **Ecosystem-Wide Impact**: The CLI and SDK are critical infrastructure used by all developers, validators, and users. Breaking these tools disrupts the entire network's usability.

2. **Protocol Violation**: Resource account addresses must be deterministically derivable both off-chain (for planning) and on-chain (for execution). This is a core protocol guarantee.

3. **User Experience Failure**: Users would receive incorrect addresses from CLI tools, leading to failed transactions, confusion, and potential operational failures for applications relying on resource accounts.

4. **Attack Surface**: A malicious governance proposal could weaponize this to deliberately disrupt the network's tooling ecosystem.

While this doesn't directly cause consensus failures (validators only execute Move code), it creates a severe protocol-level inconsistency that breaks the deterministic execution guarantee between off-chain and on-chain environments.

## Likelihood Explanation

**Likelihood: MEDIUM**

This vulnerability could manifest in two scenarios:

1. **Accidental Change**: During a legitimate framework upgrade, a developer could inadvertently modify the constant value without realizing the dependency on the Rust implementation. The lack of validation tests means this would not be caught during review.

2. **Malicious Governance Proposal**: An attacker with sufficient stake to create governance proposals could deliberately submit a proposal to change this constant, causing widespread disruption.

The framework upgrade testing process validates functionality but has no specific checks for scheme constant consistency across languages, making this a realistic failure mode. [7](#0-6) 

## Recommendation

**Immediate Fix**: Add integration tests that verify Rust and Move produce identical addresses:

```rust
#[test]
fn test_resource_address_rust_move_consistency() {
    // This test should be added to ensure constants stay in sync
    let test_address = AccountAddress::from_hex_literal("0xcafe").unwrap();
    let test_seed = b"test_seed";
    
    // Compute using Rust
    let rust_address = create_resource_address(test_address, test_seed);
    
    // Compute using Move (via MoveVM execution)
    let move_address = execute_move_create_resource_address(test_address, test_seed);
    
    // These must always match
    assert_eq!(rust_address, move_address, 
        "Rust and Move resource address derivation diverged!");
}
```

**Long-term Fix**: Add compile-time validation:

1. Generate the Rust `Scheme` enum from Move constants during build
2. Add a const assertion in Rust that verifies the value:
```rust
const _: () = assert!(
    Scheme::DeriveResourceAccountAddress as u8 == 255,
    "DeriveResourceAccountAddress must be 255 to match Move DERIVE_RESOURCE_ACCOUNT_SCHEME"
);
```

3. Add pre-upgrade validation in the framework upgrade test suite to check scheme constant consistency

4. Document the dependency relationship in both codebases with explicit warnings

## Proof of Concept

```move
// PoC: Malicious Framework Upgrade Proposal
// File: malicious_upgrade.move

script {
    fun change_scheme_constant(framework_signer: &signer) {
        // This is a simplified representation
        // An actual proposal would modify the account.move source
        // and recompile the framework with DERIVE_RESOURCE_ACCOUNT_SCHEME = 254
        
        // After this governance proposal executes:
        // 1. On-chain Move code uses 254
        // 2. Off-chain Rust code still uses 255
        // 3. All CLI-derived addresses become incorrect
        // 4. User transactions fail or create accounts at wrong addresses
    }
}
```

**Test to demonstrate the vulnerability:**

```rust
// Add to: aptos-move/e2e-move-tests/src/tests/resource_account_tests.rs
#[test]
fn test_scheme_constant_divergence_impact() {
    let mut harness = MoveHarness::new();
    let account = harness.new_account_at(AccountAddress::from_hex_literal("0xcafe").unwrap());
    let seed = b"test";
    
    // Derive address using Rust (what CLI would do)
    let rust_derived = create_resource_address(*account.address(), seed);
    
    // Simulate framework upgrade changing the constant
    // This would require modifying the Move source and recompiling
    // In practice, this test would fail if constants diverge
    
    // Create resource account on-chain
    let result = harness.run_transaction_payload(
        &account,
        aptos_stdlib::resource_account_create_resource_account(seed.to_vec()),
    );
    
    // Verify the on-chain address matches CLI-derived address
    assert!(result.success(), "Resource account creation failed");
    
    // If constants diverge, this would fail:
    // - CLI thinks address is rust_derived
    // - But actual on-chain address would be different
    // - User's application breaks
}
```

## Notes

- The Rust constant is only used in off-chain tooling (CLI, SDK), not during validator consensus
- This is NOT a consensus vulnerability - validators only execute Move code
- The vulnerability is in the ecosystem consistency, not the core protocol
- Similar issues may exist for other scheme constants (ED25519_SCHEME, MULTI_ED25519_SCHEME, etc.)

### Citations

**File:** types/src/transaction/authenticator.rs (L495-495)
```rust
    DeriveResourceAccountAddress = 255,
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L167-167)
```text
    const DERIVE_RESOURCE_ACCOUNT_SCHEME: u8 = 255;
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1109-1114)
```text
    public fun create_resource_address(source: &address, seed: vector<u8>): address {
        let bytes = bcs::to_bytes(source);
        bytes.append(seed);
        bytes.push_back(DERIVE_RESOURCE_ACCOUNT_SCHEME);
        from_bcs::to_address(hash::sha3_256(bytes))
    }
```

**File:** types/src/account_address.rs (L230-236)
```rust
pub fn create_resource_address(address: AccountAddress, seed: &[u8]) -> AccountAddress {
    let mut input = bcs::to_bytes(&address).unwrap();
    input.extend(seed);
    input.push(Scheme::DeriveResourceAccountAddress as u8);
    let hash = HashValue::sha3_256_of(&input);
    AccountAddress::from_bytes(hash.as_ref()).unwrap()
}
```

**File:** crates/aptos/src/account/derive_resource_account.rs (L105-108)
```rust
    async fn execute(self) -> CliTypedResult<AccountAddress> {
        let seed = self.seed_args.seed()?;
        Ok(create_resource_address(self.address, &seed))
    }
```

**File:** RELEASE.md (L43-48)
```markdown
* [day 10] After the binary release stabilized on testnet, testnet framework will be upgraded.
* Hot-fixes release will be created as needed when a release version is soaking in testnet, and we will only promote a release from testnet to Mainnet after confirming a release version is stable.
* [day 14] Once confirmed that both binary upgrade and framework upgrade stabilized on testnet, a release tag `aptos-node-vx.y.z` will be created, the release version will be deployed to 1% of the stake on **Mainnet**.
* [day 16] Wider announcement will be made for the community to upgrade the binary, `aptos-node-vx.y.z` will be updated with "[Mainnet]" in the release page, Mainnet validators will be slowly upgrading.
* [day 17] A list of framework upgrade proposals will be submitted to Mainnet for voting.
* [day 24] Proposals executed on-chain if passed voting.
```

**File:** RELEASE.md (L60-65)
```markdown
### Framework
* Unit tests
* Continuous replay-verify tests perform reconciliations in testnet and mainnet by executing all transactions and verifying the transaction results are correct and in agreement with state snapshots.
* Smoke tests run end-to-end tests on a single machine and verify node operations work as intended. Examples of tests include peer-to-peer transfer and module publish.
* Compatibility tests run multiple nodes with different versions to assert different framework versions can perform normal operations and participate in consensus.
* Framework upgrade tests run on each PR to validate new versions of the framework can be applied on top of the new binary version.
```
