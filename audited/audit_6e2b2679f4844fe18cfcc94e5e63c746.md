# Audit Report

## Title
Direct Coin Transfer Opt-Out Bypass via Fungible Asset Migration

## Summary
The migration from CoinStore to FungibleAsset has broken the `can_receive_direct_coin_transfers` protection mechanism. Users who explicitly opt out of receiving arbitrary coin types can still receive them, violating user consent and enabling token spam attacks.

## Finding Description

The Aptos Framework provides a mechanism for users to opt out of receiving unsolicited coin transfers via `set_allow_direct_coin_transfers(account, false)`. However, this protection is completely bypassed due to the fungible asset migration.

**The Root Cause:**

The `coin::is_account_registered<CoinType>` function has been modified to always return `true` (after verifying coin initialization) as part of the CoinStore to FungibleAsset migration: [1](#0-0) 

This breaks the protection logic in `aptos_account::deposit_coins`: [2](#0-1) 

Since `is_account_registered` always returns `true`, the condition `!coin::is_account_registered<CoinType>(to)` is always `false`, so the `can_receive_direct_coin_transfers` check never executes. The transfer proceeds directly to the deposit operation: [3](#0-2) 

**Execution Flow to Non-Existent Accounts:**

When transferring to a non-existent account via SDK: [4](#0-3) 

The account is auto-created: [5](#0-4) 

Then the primary fungible store is auto-created during deposit: [6](#0-5) 

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria ("State inconsistencies requiring intervention"):

1. **User Consent Violation**: The documented opt-out mechanism (`DirectTransferConfig`) is completely ineffective
2. **Token Spam Attack Vector**: Attackers can force any account to receive arbitrary tokens, including scam tokens or unwanted airdrops
3. **Privacy Breach**: Users cannot control their token exposure, potentially revealing on-chain relationships
4. **Regulatory Risk**: Users may unknowingly receive prohibited tokens in their jurisdiction

While this doesn't cause direct loss of funds, it creates a state where user-configured security preferences are ignored, requiring manual intervention to manage unwanted tokens.

## Likelihood Explanation

**Likelihood: HIGH**

- The vulnerability affects ALL coin transfers in the current codebase
- No special privileges required to exploit
- Trivial to execute via standard SDK functions
- Users who have opted out are completely unprotected
- The feature is documented and users rely on it for privacy

## Recommendation

Restore the opt-out protection by checking `DirectTransferConfig` in the fungible asset deposit path:

```move
public fun deposit_coins<CoinType>(
    to: address, coins: Coin<CoinType>
) acquires DirectTransferConfig {
    if (!account::exists_at(to)) {
        create_account(to);
    };
    
    // Always check opt-out preference for non-APT coins
    if (!is_aptos_coin<CoinType>()) {
        assert!(
            can_receive_direct_coin_transfers(to),
            error::permission_denied(EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS)
        );
    };
    
    coin::deposit<CoinType>(to, coins)
}
```

Alternatively, implement the check at the fungible asset layer to catch all deposit paths.

## Proof of Concept

```move
#[test(attacker = @0x123, victim = @0x456, framework = @0x1)]
#[expected_failure(abort_code = 0x50003, location = aptos_framework::aptos_account)]
public fun test_bypass_opt_out_protection(
    attacker: &signer, 
    victim: &signer,
    framework: &signer
) acquires DirectTransferConfig {
    use aptos_framework::coin;
    use aptos_framework::account::create_account_for_test;
    use std::string::utf8;
    
    // Initialize test coin
    coin::create_coin_conversion_map(framework);
    let (burn_cap, freeze_cap, mint_cap) = 
        coin::initialize<FakeCoin>(framework, utf8(b"FC"), utf8(b"FC"), 8, true);
    
    // Setup accounts
    create_account_for_test(signer::address_of(attacker));
    create_account_for_test(signer::address_of(victim));
    
    // Victim opts out of receiving unsolicited tokens
    set_allow_direct_coin_transfers(victim, false);
    assert!(!can_receive_direct_coin_transfers(signer::address_of(victim)), 0);
    
    // Attacker mints tokens
    deposit_coins(signer::address_of(attacker), coin::mint(1000, &mint_cap));
    
    // Attacker sends tokens to victim - SHOULD FAIL but SUCCEEDS
    transfer_coins<FakeCoin>(attacker, signer::address_of(victim), 100);
    
    // Victim now has unwanted tokens despite opting out
    assert!(coin::balance<FakeCoin>(signer::address_of(victim)) == 100, 1);
    
    coin::destroy_burn_cap(burn_cap);
    coin::destroy_mint_cap(mint_cap);
    coin::destroy_freeze_cap(freeze_cap);
}
```

**Note:** This test will currently PASS (showing the vulnerability), but should FAIL with `EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS` when the protection is working correctly.

## Notes

- The issue specifically affects custom coin types; APT transfers may have different behavior
- The fungible asset migration is ongoing, indicated by feature flags [7](#0-6) 
- No existing tests validate the opt-out protection after migration
- The `DirectTransferConfig` resource still functions correctly for getting/setting preferences, but enforcement is broken
- Answer to original question: Transfers to non-existent accounts **auto-create** the account and succeed (not undefined state)

### Citations

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L4-4)
```text
    use std::features;
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L808-814)
```text
    public fun is_account_registered<CoinType>(_account_addr: address): bool {
        assert!(
            is_coin_initialized<CoinType>(),
            error::invalid_argument(ECOIN_INFO_NOT_PUBLISHED)
        );
        true
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L131-138)
```text
        if (!account::exists_at(to)) {
            create_account(to);
            spec {
                // TODO(fa_migration)
                // assert coin::spec_is_account_registered<AptosCoin>(to);
                // assume aptos_std::type_info::type_of<CoinType>() == aptos_std::type_info::type_of<AptosCoin>() ==>
                //     coin::spec_is_account_registered<CoinType>(to);
            };
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L140-146)
```text
        if (!coin::is_account_registered<CoinType>(to)) {
            assert!(
                can_receive_direct_coin_transfers(to),
                error::permission_denied(EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS)
            );
            coin::register<CoinType>(&create_signer(to));
        };
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L147-147)
```text
        coin::deposit<CoinType>(to, coins)
```

**File:** sdk/src/coin_client.rs (L73-84)
```rust
            TransactionPayload::EntryFunction(EntryFunction::new(
                ModuleId::new(
                    AccountAddress::ONE,
                    Identifier::new("aptos_account").unwrap(),
                ),
                Identifier::new("transfer_coins").unwrap(),
                vec![TypeTag::from_str(options.coin_type).unwrap()],
                vec![
                    bcs::to_bytes(&to_account).unwrap(),
                    bcs::to_bytes(&amount).unwrap(),
                ],
            )),
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L195-199)
```text
    public fun deposit(owner: address, fa: FungibleAsset) acquires DeriveRefPod {
        let metadata = fa.asset_metadata();
        let store = ensure_primary_store_exists(owner, metadata);
        dispatchable_fungible_asset::deposit(store, fa);
    }
```
