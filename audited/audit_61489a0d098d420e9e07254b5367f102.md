# Audit Report

## Title
PeerId-to-PublicKey Mismatch Vulnerability in Seed Address Validation Enables Network Identity Confusion

## Summary
The `verify_seeds()` function validates seed addresses but fails to verify that each PeerId matches the x25519 public key embedded in the corresponding NetworkAddress. This allows misconfigurations where a node believes it's connected to a legitimate validator but is actually connected to a different peer, leading to network partition and denial of service.

## Finding Description

The vulnerability exists in the seed address validation logic. When a node configures `seed_addrs` (a `HashMap<PeerId, Vec<NetworkAddress>>`), the system should ensure that each PeerId correctly corresponds to the public key embedded in the NetworkAddress. [1](#0-0) 

The validation only calls `verify_address()` which checks address formatting, but never validates PeerId consistency: [2](#0-1) 

The PeerId is derived from an x25519 public key using: [3](#0-2) 

**Attack Flow:**

1. A misconfigured (or maliciously modified) `seed_addrs` maps `legitimate_validator_peer_id` to `attacker_network_address` containing `attacker_public_key`

2. During network initialization, `merge_seeds()` processes this configuration without validation: [4](#0-3) 

3. When the node attempts to dial the legitimate validator, it extracts `attacker_public_key` from the address: [5](#0-4) 

4. The outbound Noise handshake completes using `attacker_public_key`, but the ConnectionMetadata stores `legitimate_validator_peer_id`: [6](#0-5) 

5. The node believes it's connected to the legitimate validator but is actually connected to the attacker. Since PeerManager only allows one connection per PeerId: [7](#0-6) 

The node cannot establish a genuine connection to the legitimate validator, even if it later discovers the correct address through on-chain discovery.

## Impact Explanation

**High Severity** - This qualifies as "Significant protocol violations" under the bug bounty criteria:

1. **Network Partition/DoS**: A validator node with misconfigured seeds will be unable to connect to legitimate validators, preventing participation in consensus and causing liveness degradation for the network

2. **Information Disclosure**: All messages intended for legitimate validators (consensus votes, proposals, block requests) are routed to incorrect peers who can observe network topology and timing information

3. **Persistent Compromise**: The simultaneous dial tie-breaking mechanism uses PeerId comparison, meaning the misconfigured connection may persist even after correct addresses are discovered

While consensus messages have Ed25519 signatures preventing direct forgery, the network partition and DoS impacts are serious for validator availability.

## Likelihood Explanation

**Medium-High Likelihood** in specific deployment scenarios:

- Automated configuration generation tools could introduce this bug
- Copy-paste errors during manual configuration
- Compromised configuration management systems
- Malicious insiders with configuration access

The vulnerability is particularly concerning because the `verify_seeds()` function explicitly exists to prevent such issues but fails to do so.

## Recommendation

Add PeerId-to-PublicKey validation in `verify_seeds()`:

```rust
pub fn verify_seeds(&self) -> Result<(), Error> {
    for (peer_id, addrs) in self.seed_addrs.iter() {
        for addr in addrs {
            Self::verify_address(peer_id, addr)?;
            
            // Validate PeerId matches the public key in the address
            if let Some(pubkey) = addr.find_noise_proto() {
                let derived_peer_id = aptos_types::account_address::from_identity_public_key(pubkey);
                if derived_peer_id != *peer_id {
                    return Err(Error::InvariantViolation(format!(
                        "PeerId {} does not match public key in address {}. Derived PeerId from pubkey: {}",
                        peer_id.short_str(),
                        addr,
                        derived_peer_id.short_str()
                    )));
                }
            }
        }
    }

    // Existing validation for seeds...
    for (peer_id, seed) in self.seeds.iter() {
        for addr in seed.addresses.iter() {
            Self::verify_address(peer_id, addr)?;
        }

        // Validate PeerId matches public keys
        for pubkey in seed.keys.iter() {
            let derived_peer_id = aptos_types::account_address::from_identity_public_key(*pubkey);
            if derived_peer_id != *peer_id {
                return Err(Error::InvariantViolation(format!(
                    "PeerId {} does not match public key {}. Derived PeerId: {}",
                    peer_id.short_str(),
                    pubkey.to_string(),
                    derived_peer_id.short_str()
                )));
            }
        }

        if seed.keys.is_empty() && seed.addresses.is_empty() {
            return Err(Error::InvariantViolation(format!(
                "Seed peer {} has no pubkeys",
                peer_id.short_str(),
            )));
        }
    }
    Ok(())
}
```

## Proof of Concept

```rust
use aptos_config::config::{NetworkConfig, Peer, PeerRole};
use aptos_crypto::{x25519, Uniform};
use aptos_types::{account_address::from_identity_public_key, network_address::NetworkAddress, PeerId};
use std::collections::HashMap;

#[test]
fn test_seed_addrs_peerid_mismatch() {
    let mut rng = rand::thread_rng();
    
    // Generate two different key pairs
    let legitimate_key = x25519::PrivateKey::generate(&mut rng);
    let legitimate_pubkey = legitimate_key.public_key();
    let legitimate_peer_id = from_identity_public_key(legitimate_pubkey);
    
    let attacker_key = x25519::PrivateKey::generate(&mut rng);
    let attacker_pubkey = attacker_key.public_key();
    
    // Create a network address with attacker's public key
    let attacker_addr: NetworkAddress = format!(
        "/ip4/1.2.3.4/tcp/6180/noise-ik/{}/handshake/0",
        hex::encode(attacker_pubkey.as_slice())
    ).parse().unwrap();
    
    // Map legitimate validator's PeerId to attacker's address
    let mut seed_addrs = HashMap::new();
    seed_addrs.insert(legitimate_peer_id, vec![attacker_addr]);
    
    let mut config = NetworkConfig::default();
    config.seed_addrs = seed_addrs;
    
    // This should fail but currently succeeds!
    let result = config.verify_seeds();
    
    // Current behavior: verification passes (BUG)
    assert!(result.is_ok(), "Verification incorrectly passed for mismatched PeerId");
    
    // Expected behavior: should fail with PeerId mismatch error
    // assert!(result.is_err(), "Should reject mismatched PeerId");
}
```

## Notes

This vulnerability represents a critical failure in defense-in-depth. While higher-layer signature verification prevents direct consensus attacks, the network partition and DoS impacts are significant for validator availability. The validation function exists explicitly to prevent such misconfigurations but is insufficient, creating a false sense of security for operators.

### Citations

**File:** config/src/config/network_config.rs (L306-316)
```rust
    fn verify_address(peer_id: &PeerId, addr: &NetworkAddress) -> Result<(), Error> {
        if !addr.is_aptosnet_addr() {
            return Err(Error::InvariantViolation(format!(
                "Unexpected seed peer address format: peer_id: {}, addr: '{}'",
                peer_id.short_str(),
                addr,
            )));
        }

        Ok(())
    }
```

**File:** config/src/config/network_config.rs (L319-340)
```rust
    pub fn verify_seeds(&self) -> Result<(), Error> {
        for (peer_id, addrs) in self.seed_addrs.iter() {
            for addr in addrs {
                Self::verify_address(peer_id, addr)?;
            }
        }

        for (peer_id, seed) in self.seeds.iter() {
            for addr in seed.addresses.iter() {
                Self::verify_address(peer_id, addr)?;
            }

            // Require there to be a pubkey somewhere, either in the address (assumed by `is_aptosnet_addr`)
            if seed.keys.is_empty() && seed.addresses.is_empty() {
                return Err(Error::InvariantViolation(format!(
                    "Seed peer {} has no pubkeys",
                    peer_id.short_str(),
                )));
            }
        }
        Ok(())
    }
```

**File:** types/src/account_address.rs (L140-146)
```rust
pub fn from_identity_public_key(identity_public_key: x25519::PublicKey) -> AccountAddress {
    let mut array = [0u8; AccountAddress::LENGTH];
    let pubkey_slice = identity_public_key.as_slice();
    // keep only the last 16 bytes
    array.copy_from_slice(&pubkey_slice[x25519::PUBLIC_KEY_SIZE - AccountAddress::LENGTH..]);
    AccountAddress::new(array)
}
```

**File:** network/builder/src/builder.rs (L473-510)
```rust
fn merge_seeds(config: &NetworkConfig) -> PeerSet {
    config.verify_seeds().expect("Seeds must be well formed");
    let mut seeds = config.seeds.clone();

    // Merge old seed configuration with new seed configuration
    // TODO(gnazario): Once fully migrated, remove `seed_addrs`
    config
        .seed_addrs
        .iter()
        .map(|(peer_id, addrs)| {
            (
                peer_id,
                Peer::from_addrs(PeerRole::ValidatorFullNode, addrs.clone()),
            )
        })
        .for_each(|(peer_id, peer)| {
            seeds
                .entry(*peer_id)
                // Sad clone due to Rust not realizing these are two distinct paths
                .and_modify(|seed| seed.extend(peer.clone()).unwrap())
                .or_insert(peer);
        });

    // Pull public keys out of addresses
    seeds.values_mut().for_each(
        |Peer {
             addresses, keys, ..
         }| {
            addresses
                .iter()
                .filter_map(NetworkAddress::find_noise_proto)
                .for_each(|pubkey| {
                    keys.insert(pubkey);
                });
        },
    );
    seeds
}
```

**File:** network/framework/src/transport/mod.rs (L336-407)
```rust
pub async fn upgrade_outbound<T: TSocket>(
    ctxt: Arc<UpgradeContext>,
    fut_socket: impl Future<Output = io::Result<T>>,
    addr: NetworkAddress,
    remote_peer_id: PeerId,
    remote_pubkey: x25519::PublicKey,
) -> io::Result<Connection<NoiseStream<T>>> {
    let origin = ConnectionOrigin::Outbound;
    let socket = fut_socket.await?;

    // noise handshake
    let (mut socket, peer_role) = ctxt
        .noise
        .upgrade_outbound(
            socket,
            remote_peer_id,
            remote_pubkey,
            AntiReplayTimestamps::now,
        )
        .await
        .map_err(|err| {
            if err.should_security_log() {
                sample!(
                    SampleRate::Duration(Duration::from_secs(15)),
                    warn!(
                        SecurityEvent::NoiseHandshake,
                        NetworkSchema::new(&ctxt.noise.network_context)
                            .network_address(&addr)
                            .connection_origin(&origin),
                        error = %err,
                    )
                );
            }
            io::Error::other(err)
        })?;

    // sanity check: Noise IK should always guarantee this is true
    debug_assert_eq!(remote_pubkey, socket.get_remote_static());

    // exchange HandshakeMsg
    let handshake_msg = HandshakeMsg {
        supported_protocols: ctxt.supported_protocols.clone(),
        chain_id: ctxt.chain_id,
        network_id: ctxt.network_id,
    };
    let remote_handshake = exchange_handshake(&handshake_msg, &mut socket).await?;

    // try to negotiate common aptosnet version and supported application protocols
    let (messaging_protocol, application_protocols) = handshake_msg
        .perform_handshake(&remote_handshake)
        .map_err(|e| {
            let e = format!(
                "handshake negotiation with peer {} failed: {}",
                remote_peer_id, e
            );
            io::Error::other(e)
        })?;

    // return successful connection
    Ok(Connection {
        socket,
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
    })
}
```

**File:** network/framework/src/transport/mod.rs (L537-569)
```rust
    pub fn dial(
        &self,
        peer_id: PeerId,
        addr: NetworkAddress,
    ) -> io::Result<
        impl Future<Output = io::Result<Connection<NoiseStream<TTransport::Output>>>>
            + Send
            + 'static
            + use<TTransport>,
    > {
        // parse aptosnet protocols
        // TODO(philiphayes): `Transport` trait should include parsing in `dial`?
        let (base_addr, pubkey, handshake_version) = Self::parse_dial_addr(&addr)?;

        // Check that the parsed handshake version from the dial addr is supported.
        if self.ctxt.handshake_version != handshake_version {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!(
                    "Attempting to dial remote with unsupported handshake version: {}, expected: {}",
                    handshake_version, self.ctxt.handshake_version,
                ),
            ));
        }

        // try to connect socket
        let fut_socket = self.base_transport.dial(peer_id, base_addr)?;

        // outbound dial upgrade task
        let upgrade_fut = upgrade_outbound(self.ctxt.clone(), fut_socket, addr, peer_id, pubkey);
        let upgrade_fut = timeout_io(self.time_service.clone(), TRANSPORT_TIMEOUT, upgrade_fut);
        Ok(upgrade_fut)
    }
```

**File:** network/framework/src/peer_manager/mod.rs (L607-655)
```rust
    fn add_peer(&mut self, connection: Connection<TSocket>) -> Result<(), Error> {
        let conn_meta = connection.metadata.clone();
        let peer_id = conn_meta.remote_peer_id;

        // Make a disconnect if you've connected to yourself
        if self.network_context.peer_id() == peer_id {
            debug_assert!(false, "Self dials shouldn't happen");
            warn!(
                NetworkSchema::new(&self.network_context)
                    .connection_metadata_with_address(&conn_meta),
                "Received self-dial, disconnecting it"
            );
            self.disconnect(connection);
            return Ok(());
        }

        let mut send_new_peer_notification = true;

        // Check for and handle simultaneous dialing
        if let Entry::Occupied(active_entry) = self.active_peers.entry(peer_id) {
            let (curr_conn_metadata, _) = active_entry.get();
            if Self::simultaneous_dial_tie_breaking(
                self.network_context.peer_id(),
                peer_id,
                curr_conn_metadata.origin,
                conn_meta.origin,
            ) {
                let (_, peer_handle) = active_entry.remove();
                // Drop the existing connection and replace it with the new connection
                drop(peer_handle);
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    "{} Closing existing connection with Peer {} to mitigate simultaneous dial",
                    self.network_context,
                    peer_id.short_str()
                );
                send_new_peer_notification = false;
            } else {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    "{} Closing incoming connection with Peer {} to mitigate simultaneous dial",
                    self.network_context,
                    peer_id.short_str()
                );
                // Drop the new connection and keep the one already stored in active_peers
                self.disconnect(connection);
                return Ok(());
            }
        }
```
