# Audit Report

## Title
Missing `end_version` Boundary Check in Forward Pagination Allows Unauthorized Transaction Data Access

## Summary
The `AccountTransactionSummariesIter` implementation fails to enforce the `end_version` boundary when performing forward pagination scans. When a user specifies both `start_version` and `end_version` parameters via the REST API, the `end_version` is silently ignored, allowing attackers to retrieve transaction summaries beyond the intended range up to the `limit` or `ledger_version`.

## Finding Description
The vulnerability exists in the pagination logic of `AccountTransactionSummariesIter::next_impl()`. When forward scanning is initiated (triggered by providing `start_version`), the iterator stores the `end_version` parameter but never validates transaction versions against it. [1](#0-0) 

The iterator performs several boundary checks: count limit (line 335), address matching (line 342), defensive version checks (lines 347-352), and ledger_version (line 363). However, there is no check for `version > end_version` when `direction == ScanDirection::Forward`.

The iterator creation logic in `TransactionStore::get_account_transaction_summaries_iter()` passes both `start_version` and `end_version` to the iterator constructor when forward scanning is selected: [2](#0-1) 

The REST API endpoint allows users to specify both parameters simultaneously: [3](#0-2) 

Other parts of the codebase (e.g., `storage/db-tool/src/replay_on_archive.rs`) correctly interpret both `start_version` and `end_version` together as defining a range [start, end], calculating `limit = end - start + 1`. This establishes the expected behavior that both parameters should work together. [4](#0-3) 

The storage interface documentation indicates that when `start_version` is provided, transactions should start from that version, but it doesn't explicitly state that `end_version` is ignored: [5](#0-4) 

**Attack Scenario:**
1. Attacker calls `/accounts/:address/transaction_summaries?start_version=100&end_version=200&limit=1000`
2. Expecting transactions 100-200 (101 transactions maximum)
3. The iterator performs forward scan from version 100 but ignores end_version=200
4. Returns up to 1000 transactions (versions 100-1099) instead of the intended 100-200 range
5. Attacker gains access to 900+ extra transaction summaries beyond the requested range

This violates the **Resource Limits** invariant (invariant #9) by allowing users to access more data than specified in their query parameters, and breaks the API contract by returning results that don't match the documented behavior.

## Impact Explanation
**Medium Severity** - This issue qualifies as Medium severity under the Aptos bug bounty categories for the following reasons:

1. **Information Disclosure**: Attackers can read transaction summaries beyond the intended version range, potentially accessing sensitive transaction metadata that should be outside their query scope.

2. **API Contract Violation**: The API endpoint accepts both `start_version` and `end_version` parameters but silently ignores one of them, violating user expectations and the principle of least surprise.

3. **Performance Impact**: Forces the database to scan and return more records than requested, potentially causing unnecessary load on validator nodes when multiple attackers exploit this simultaneously.

4. **Limited by Safeguards**: The `limit` parameter still caps the maximum results, preventing unbounded queries. The `ledger_version` also provides an upper bound. This prevents this from being High severity.

The vulnerability doesn't directly affect consensus, state consistency, or funds, but represents a state inconsistency in query results that could be exploited for reconnaissance or DoS purposes.

## Likelihood Explanation
**High Likelihood** - This vulnerability is highly likely to be exploited because:

1. **Trivial to Execute**: Any user can trigger it with a simple API call requiring no special permissions or setup
2. **Public Attack Surface**: The REST API endpoint is publicly accessible on all full nodes
3. **No Detection**: The silent parameter ignorance makes exploitation undetectable in logs
4. **Clear Benefit**: Attackers gain access to more transaction data than intended, useful for chain analysis or identifying targets
5. **Zero Cost**: No transaction fees or resource expenditure required

The only reason this might not be widely exploited currently is that the behavior may appear to be working "correctly" if users don't carefully verify the version ranges in responses.

## Recommendation
Add an explicit check for `end_version` in the forward scanning path of `AccountTransactionSummariesIter::next_impl()`. The fix should be added after line 353 and before line 355:

```rust
fn next_impl(&mut self) -> Result<Option<(Version, IndexedTransactionSummary)>> {
    // If already iterated over `limit` transactions, return None.
    if self.count >= self.limit {
        return Ok(None);
    }

    Ok(match self.inner.next().transpose()? {
        Some(((address, version), txn_summary)) => {
            // No more transactions sent by this account.
            if address != self.address {
                return Ok(None);
            }

            // This case ideally shouldn't occur if the iterator is initiated properly.
            if (self.direction == ScanDirection::Backward
                && version > self.end_version.unwrap())
                || (self.direction == ScanDirection::Forward
                    && version < self.start_version.unwrap())
            {
                return Ok(None);
            }

            // ADD THIS CHECK: Stop if we've exceeded end_version in forward scanning
            if self.direction == ScanDirection::Forward 
                && self.end_version.is_some() 
                && version > self.end_version.unwrap() 
            {
                return Ok(None);
            }

            ensure!(
                version == txn_summary.version(),
                "DB corruption: version mismatch: version in key: {}, version in txn summary: {}",
                version,
                txn_summary.version(),
            );

            // ... rest of the function
        }
    })
}
```

Additionally, consider validating at the API layer that when both `start_version` and `end_version` are provided, `start_version <= end_version`, and reject malformed requests early.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::account_address::AccountAddress;
    
    #[test]
    fn test_forward_scan_ignores_end_version() {
        // Setup: Create test database with transactions at versions 100, 200, 300, 400, 500
        let tmpdir = aptos_temppath::TempPath::new();
        let db = create_test_db(&tmpdir);
        let address = AccountAddress::random();
        
        // Insert 5 transaction summaries
        for version in [100u64, 200, 300, 400, 500] {
            let summary = create_test_summary(address, version);
            db.put(&(address, version), &summary).unwrap();
        }
        
        let transaction_store = TransactionStore::new(Arc::new(db));
        
        // Request: start_version=100, end_version=300, limit=10
        // Expected: versions 100, 200, 300 (3 results)
        // Actual: versions 100, 200, 300, 400, 500 (5 results) - BUG!
        let iter = transaction_store
            .get_account_transaction_summaries_iter(
                address,
                Some(100),  // start_version
                Some(300),  // end_version - THIS IS IGNORED
                10,         // limit
                500,        // ledger_version
            )
            .unwrap();
        
        let results: Vec<_> = iter.collect::<Result<Vec<_>>>().unwrap();
        
        // This assertion FAILS, proving the bug
        assert_eq!(results.len(), 3, "Should return only 3 summaries (100, 200, 300)");
        // Actually returns 5 summaries because end_version is ignored
        
        // Verify versions are beyond end_version
        for (version, _) in &results {
            if *version > 300 {
                panic!("Found version {} which exceeds end_version=300", version);
            }
        }
    }
}
```

To reproduce via API:
```bash
# Request transactions 100-200 for an account with transactions at versions 100, 200, 300, 400, 500
curl "http://localhost:8080/v1/accounts/0x1/transaction_summaries?start_version=100&end_version=200&limit=100"

# Expected: Returns 3 transactions (versions 100, 200)
# Actual: Returns 5 transactions (versions 100, 200, 300, 400, 500)
# The end_version=200 parameter is silently ignored
```

## Notes
This vulnerability has been present since the `AccountTransactionSummariesIter` was introduced to support orderless transactions. The code comments at [6](#0-5)  suggest the developers were aware of design issues with the forward/backward scanning logic but may not have identified this specific boundary check omission.

The defensive checks at lines 347-352 only validate that the iterator position hasn't gone backwards relative to the seek position, but they don't enforce the user-specified end boundary. The comment "This case ideally shouldn't occur if the iterator is initiated properly" confirms these are sanity checks, not user input validation.

### Citations

**File:** storage/aptosdb/src/utils/iterators.rs (L333-373)
```rust
    fn next_impl(&mut self) -> Result<Option<(Version, IndexedTransactionSummary)>> {
        // If already iterated over `limit` transactions, return None.
        if self.count >= self.limit {
            return Ok(None);
        }

        Ok(match self.inner.next().transpose()? {
            Some(((address, version), txn_summary)) => {
                // No more transactions sent by this account.
                if address != self.address {
                    return Ok(None);
                }

                // This case ideally shouldn't occur if the iterator is initiated properly.
                if (self.direction == ScanDirection::Backward
                    && version > self.end_version.unwrap())
                    || (self.direction == ScanDirection::Forward
                        && version < self.start_version.unwrap())
                {
                    return Ok(None);
                }

                ensure!(
                    version == txn_summary.version(),
                    "DB corruption: version mismatch: version in key: {}, version in txn summary: {}",
                    version,
                    txn_summary.version(),
                );

                // No more transactions (in this view of the ledger).
                if version > self.ledger_version {
                    return Ok(None);
                }

                self.prev_version = Some(version);
                self.count += 1;
                Some((version, txn_summary))
            },
            None => None,
        })
    }
```

**File:** storage/aptosdb/src/transaction_store/mod.rs (L91-93)
```rust
        // Question[Orderless]: When start version is specified, we are current scanning forward from start version.
        // When start version is not specified we are scanning backward, so as to return the most recent transactions.
        // This doesn't seem to be a good design. Should we instead let the API take scan direction as input?
```

**File:** storage/aptosdb/src/transaction_store/mod.rs (L94-108)
```rust
        if start_version.is_some() {
            let mut iter = self
                .ledger_db
                .transaction_db_raw()
                .iter::<TransactionSummariesByAccountSchema>()?;
            iter.seek(&(address, start_version.unwrap()))?;
            Ok(AccountTransactionSummariesIter::new(
                iter,
                address,
                start_version,
                end_version,
                limit,
                ScanDirection::Forward,
                ledger_version,
            ))
```

**File:** api/src/transactions.rs (L412-429)
```rust
    async fn get_accounts_transaction_summaries(
        &self,
        accept_type: AcceptType,
        /// Address of account with or without a `0x` prefix
        address: Path<Address>,
        /// Transaction version to start list of transactions
        ///
        /// If not provided, defaults to showing the latest transactions
        start_version: Query<Option<U64>>,
        /// Transaction version to end list of transactions
        ///
        /// If not provided, defaults to showing the latest transactions
        end_version: Query<Option<U64>>,
        /// Max number of transactions to retrieve.
        ///
        /// If not provided, defaults to default page size
        limit: Query<Option<u16>>,
    ) -> BasicResultWith404<Vec<TransactionSummary>> {
```

**File:** storage/db-tool/src/replay_on_archive.rs (L318-345)
```rust
    fn get_start_and_limit(
        aptos_db: &Arc<dyn DbReader>,
        start_version: Version,
        end_version: Version,
    ) -> Result<(Version, u64)> {
        let db_start = aptos_db
            .get_first_txn_version()?
            .ok_or(AptosDbError::NotFound(
                "First txn version is None".to_string(),
            ))?;
        let start = std::cmp::max(db_start, start_version);

        let db_end = aptos_db
            .get_synced_version()?
            .ok_or(AptosDbError::NotFound("Synced version is None".to_string()))?;
        let end = std::cmp::min(end_version, db_end);

        let limit = if start <= end {
            end - start + 1
        } else {
            warn!(
                start = start_version,
                db_start = db_start,
                end = end_version,
                db_end = db_end,
                "No transactions to verify in requested range."
            );
            0
```

**File:** storage/storage-interface/src/lib.rs (L340-351)
```rust
        /// If `start_version` is provided, the returned list contains transactions starting from `start_version`.
        /// Or else if `end_version` is provided, the returned list contains transactions ending at `end_version`.
        /// The returned list contains at most `limit` transactions.
        /// The returned list is always sorted by version in ascending order.
        fn get_account_transaction_summaries(
            &self,
            address: AccountAddress,
            start_version: Option<u64>,
            end_version: Option<u64>,
            limit: u64,
            ledger_version: Version,
        ) -> Result<Vec<IndexedTransactionSummary>>;
```
