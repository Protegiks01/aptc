# Audit Report

## Title
Error Silencing in OnChainConfig::fetch_config() Prevents Detection of State Corruption Leading to Consensus Splits

## Summary
The `OnChainConfig::fetch_config()` method silently converts deserialization errors to `None`, causing validators to fall back to hardcoded default configurations when the on-chain config cannot be deserialized. This masks state corruption attacks and can lead to different validators using different feature configurations, breaking deterministic execution and causing consensus splits.

## Finding Description

The vulnerability exists in the config fetching mechanism used throughout the Aptos blockchain: [1](#0-0) 

The critical issue is on line 191 where `.ok()?` converts any deserialization error into `None`, completely discarding error information. The deserialization itself can fail with meaningful error messages: [2](#0-1) 

This `None` value then propagates to critical blockchain initialization code: [3](#0-2) 

When deserialization fails, validators silently fall back to hardcoded defaults: [4](#0-3) 

These defaults contain a hardcoded list of enabled features that may diverge from the actual on-chain configuration: [5](#0-4) 

**Attack Scenarios:**

1. **State Corruption During Epoch Change**: If the Features config bytes become corrupted in storage (due to disk errors, state sync issues, or other storage layer vulnerabilities), some validators may successfully deserialize while others fail. Those that fail will use default configs.

2. **Non-Deterministic Failure**: If deserialization fails intermittently due to race conditions, memory issues, or bugs, different validators may end up with different configurations for the same block.

3. **Feature Flag Divergence**: The on-chain Features config may have certain flags disabled that are enabled in the hardcoded default (or vice versa). Validators with deserialization failures will use the defaults, creating inconsistent execution behavior.

**Consensus Impact:**

Different Features configurations directly affect transaction execution through multiple critical code paths: [6](#0-5) 

This determines the maximum bytecode version validators will accept: [7](#0-6) 

Additionally, the Features config controls critical execution behaviors like lazy loading, session continuation, aggregator v2 semantics, and more, all of which can lead to different transaction execution results.

**Lack of Observability:**

The error is completely silent - no logging, no metrics, no way for operators to detect the problem. Even worse, error messages are misleading: [8](#0-7) 

The error message claims "ValidatorSet not touched on epoch change" when the actual problem could be a deserialization failure - a completely different class of error requiring different remediation.

## Impact Explanation

This vulnerability breaks **Invariant #1: Deterministic Execution** - "All validators must produce identical state roots for identical blocks."

**Critical Severity** - Consensus Safety Violation:
- Validators with different Features configurations will execute the same transaction differently
- Different bytecode version acceptance leads to transaction inclusion/rejection disagreements
- Different feature behaviors (lazy loading, aggregator parallelism, session handling) produce different execution results
- Results in different state roots for the same block, causing consensus to fail
- Could lead to chain splits requiring hard fork intervention

While the attack path requires an underlying state corruption or storage layer vulnerability, the error silencing **amplifies the impact** by:
1. Preventing detection and early intervention
2. Converting what should be a loud failure into silent wrong behavior
3. Making diagnosis extremely difficult due to misleading error messages

This meets the criteria for **Critical Severity** under "Consensus/Safety violations" in the Aptos bug bounty program.

## Likelihood Explanation

**Medium to High Likelihood:**

The codebase already contains explicit corruption detection mechanisms, indicating that state corruption is a recognized threat: [9](#0-8) 

Conditions that could trigger this vulnerability:
1. **Storage layer bugs** leading to corrupted state values
2. **State sync issues** causing inconsistent data across validators  
3. **Database failures** (disk corruption, incomplete writes)
4. **Race conditions** during config updates at epoch boundaries
5. **Version mismatches** between Move framework updates and Rust struct definitions

The fact that the codebase has a TODO comment acknowledging problems with default fallback behavior indicates developers are aware this is fragile: [10](#0-9) 

## Recommendation

**Immediate Fix:** Change the return type from `Option<Self>` to `Result<Self, anyhow::Error>` and propagate errors properly.

```rust
// In types/src/on_chain_config/mod.rs
fn fetch_config<T>(storage: &T) -> Result<Self>
where
    T: ConfigStorage + ?Sized,
{
    let (config, _bytes) = Self::fetch_config_and_bytes(storage)?;
    Ok(config)
}

fn fetch_config_and_bytes<T>(storage: &T) -> Result<(Self, Bytes)>
where
    T: ConfigStorage + ?Sized,
{
    let state_key = StateKey::on_chain_config::<Self>()?;
    let bytes = storage
        .fetch_config_bytes(&state_key)
        .ok_or_else(|| format_err!("[on-chain config] Config not found in storage for {}", 
                                   std::any::type_name::<Self>()))?;
    let config = Self::deserialize_into_config(&bytes)?;
    Ok((config, bytes))
}
```

**In Environment::new():**
```rust
// In aptos-move/aptos-vm-environment/src/environment.rs
let features = fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view)
    .context("Failed to fetch Features config - possible state corruption")?;
```

**Add logging:**
```rust
fn fetch_config_and_bytes<T>(storage: &T) -> Result<(Self, Bytes)>
where
    T: ConfigStorage + ?Sized,
{
    let state_key = StateKey::on_chain_config::<Self>()?;
    let bytes = storage.fetch_config_bytes(&state_key)
        .ok_or_else(|| {
            error!("Config not found in storage for {}", std::any::type_name::<Self>());
            format_err!("[on-chain config] Config not found")
        })?;
    
    let config = Self::deserialize_into_config(&bytes)
        .map_err(|e| {
            error!("Failed to deserialize config {}: {}", std::any::type_name::<Self>(), e);
            e
        })?;
    Ok((config, bytes))
}
```

This ensures:
1. Deserialization errors are surfaced immediately
2. Validators halt rather than using incorrect configs
3. Operators can diagnose the root cause
4. Consensus safety is preserved through fail-stop behavior

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_corrupted_features_config_causes_silent_fallback() {
    use aptos_types::on_chain_config::{Features, OnChainConfig};
    use aptos_types::state_store::MockStateView;
    use std::collections::HashMap;
    
    // Scenario: On-chain Features config has corrupted bytes
    let mut state_view = MockStateView::new(HashMap::new());
    
    // Insert corrupted BCS bytes for Features config
    let state_key = StateKey::on_chain_config::<Features>().unwrap();
    let corrupted_bytes = vec![0xFF, 0xFF, 0xFF]; // Invalid BCS encoding
    state_view.set(state_key, StateValue::new(corrupted_bytes.into()));
    
    // This should fail loudly but instead returns None silently
    let features_opt = Features::fetch_config(&state_view);
    assert!(features_opt.is_none()); // Silently converted error to None!
    
    // Validator falls back to defaults
    let default_features = Features::default();
    
    // Demonstrates the problem: Cannot distinguish between:
    // 1. Config genuinely not present (expected during genesis)
    // 2. Config present but corrupted (CRITICAL ERROR)
    
    // In production, Environment::new() would use unwrap_or_default(),
    // causing validator to execute with wrong configuration
}

// Test showing consensus split scenario
#[test] 
fn test_consensus_split_from_config_mismatch() {
    // Validator A: Successfully deserializes on-chain config with V9 max
    let mut features_v9 = Features::default();
    features_v9.disable(FeatureFlag::VM_BINARY_FORMAT_V10);
    assert_eq!(features_v9.get_max_binary_format_version(), VERSION_9);
    
    // Validator B: Deserialization fails, uses default with V10 max  
    let features_default = Features::default();
    assert_eq!(features_default.get_max_binary_format_version(), VERSION_10);
    
    // Transaction using V10 bytecode:
    // - Validator A rejects (max version is V9)
    // - Validator B accepts (max version is V10)
    // Result: Different transaction sets in blocks â†’ consensus split!
}
```

## Notes

This vulnerability demonstrates a critical failure in defensive programming. The silent error conversion prevents the system from failing safely when encountering corrupted state. Instead of halting execution and alerting operators to investigate, validators continue with potentially incorrect configurations, amplifying the impact of any underlying state corruption vulnerabilities.

The issue is particularly insidious because:
1. It affects ALL on-chain configs (ValidatorSet, GasSchedule, etc.), not just Features
2. The error messages actively mislead operators about the root cause
3. There's no telemetry or monitoring to detect when it occurs
4. The hardcoded defaults may drift from on-chain reality over time

This pattern violates the principle of "fail-stop" behavior that distributed consensus systems rely on for safety guarantees.

### Citations

**File:** types/src/on_chain_config/mod.rs (L162-165)
```rust
    fn deserialize_default_impl(bytes: &[u8]) -> Result<Self> {
        bcs::from_bytes::<Self>(bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }
```

**File:** types/src/on_chain_config/mod.rs (L185-193)
```rust
    fn fetch_config_and_bytes<T>(storage: &T) -> Option<(Self, Bytes)>
    where
        T: ConfigStorage + ?Sized,
    {
        let state_key = StateKey::on_chain_config::<Self>().ok()?;
        let bytes = storage.fetch_config_bytes(&state_key)?;
        let config = Self::deserialize_into_config(&bytes).ok()?;
        Some((config, bytes))
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L217-220)
```rust
        // We compute and store a hash of configs in order to distinguish different environments.
        let mut sha3_256 = Sha3_256::new();
        let features =
            fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view).unwrap_or_default();
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L241-245)
```rust
        // TODO(Gas):
        //   Right now, we have to use some dummy values for gas parameters if they are not found
        //   on-chain. This only happens in a edge case that is probably related to write set
        //   transactions or genesis, which logically speaking, shouldn't be handled by the VM at
        //   all. We should clean up the logic here once we get that refactored.
```

**File:** types/src/on_chain_config/aptos_features.rs (L171-277)
```rust
    pub fn default_features() -> Vec<Self> {
        vec![
            FeatureFlag::CODE_DEPENDENCY_CHECK,
            FeatureFlag::TREAT_FRIEND_AS_PRIVATE,
            FeatureFlag::SHA_512_AND_RIPEMD_160_NATIVES,
            FeatureFlag::APTOS_STD_CHAIN_ID_NATIVES,
            // Feature flag V6 is used to enable metadata v1 format and needs to stay on, even
            // if we enable a higher version.
            FeatureFlag::VM_BINARY_FORMAT_V6,
            FeatureFlag::VM_BINARY_FORMAT_V7,
            FeatureFlag::MULTI_ED25519_PK_VALIDATE_V2_NATIVES,
            FeatureFlag::BLAKE2B_256_NATIVE,
            FeatureFlag::RESOURCE_GROUPS,
            FeatureFlag::MULTISIG_ACCOUNTS,
            FeatureFlag::DELEGATION_POOLS,
            FeatureFlag::CRYPTOGRAPHY_ALGEBRA_NATIVES,
            FeatureFlag::BLS12_381_STRUCTURES,
            FeatureFlag::ED25519_PUBKEY_VALIDATE_RETURN_FALSE_WRONG_LENGTH,
            FeatureFlag::STRUCT_CONSTRUCTORS,
            FeatureFlag::PERIODICAL_REWARD_RATE_DECREASE,
            FeatureFlag::PARTIAL_GOVERNANCE_VOTING,
            FeatureFlag::_SIGNATURE_CHECKER_V2,
            FeatureFlag::STORAGE_SLOT_METADATA,
            FeatureFlag::CHARGE_INVARIANT_VIOLATION,
            FeatureFlag::DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING,
            FeatureFlag::APTOS_UNIQUE_IDENTIFIERS,
            FeatureFlag::GAS_PAYER_ENABLED,
            FeatureFlag::BULLETPROOFS_NATIVES,
            FeatureFlag::SIGNER_NATIVE_FORMAT_FIX,
            FeatureFlag::MODULE_EVENT,
            FeatureFlag::EMIT_FEE_STATEMENT,
            FeatureFlag::STORAGE_DELETION_REFUND,
            FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX,
            FeatureFlag::AGGREGATOR_V2_API,
            FeatureFlag::SAFER_RESOURCE_GROUPS,
            FeatureFlag::SAFER_METADATA,
            FeatureFlag::SINGLE_SENDER_AUTHENTICATOR,
            FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION,
            FeatureFlag::FEE_PAYER_ACCOUNT_OPTIONAL,
            FeatureFlag::AGGREGATOR_V2_DELAYED_FIELDS,
            FeatureFlag::CONCURRENT_TOKEN_V2,
            FeatureFlag::LIMIT_MAX_IDENTIFIER_LENGTH,
            FeatureFlag::OPERATOR_BENEFICIARY_CHANGE,
            FeatureFlag::BN254_STRUCTURES,
            FeatureFlag::RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET,
            FeatureFlag::COMMISSION_CHANGE_DELEGATION_POOL,
            FeatureFlag::WEBAUTHN_SIGNATURE,
            FeatureFlag::KEYLESS_ACCOUNTS,
            FeatureFlag::FEDERATED_KEYLESS,
            FeatureFlag::KEYLESS_BUT_ZKLESS_ACCOUNTS,
            FeatureFlag::JWK_CONSENSUS,
            FeatureFlag::REFUNDABLE_BYTES,
            FeatureFlag::OBJECT_CODE_DEPLOYMENT,
            FeatureFlag::MAX_OBJECT_NESTING_CHECK,
            FeatureFlag::KEYLESS_ACCOUNTS_WITH_PASSKEYS,
            FeatureFlag::MULTISIG_V2_ENHANCEMENT,
            FeatureFlag::DELEGATION_POOL_ALLOWLISTING,
            FeatureFlag::MODULE_EVENT_MIGRATION,
            FeatureFlag::_REJECT_UNSTABLE_BYTECODE,
            FeatureFlag::TRANSACTION_CONTEXT_EXTENSION,
            FeatureFlag::COIN_TO_FUNGIBLE_ASSET_MIGRATION,
            FeatureFlag::_OBJECT_NATIVE_DERIVED_ADDRESS,
            FeatureFlag::DISPATCHABLE_FUNGIBLE_ASSET,
            FeatureFlag::NEW_ACCOUNTS_DEFAULT_TO_FA_APT_STORE,
            FeatureFlag::OPERATIONS_DEFAULT_TO_FA_APT_STORE,
            FeatureFlag::CONCURRENT_FUNGIBLE_ASSETS,
            FeatureFlag::_AGGREGATOR_V2_IS_AT_LEAST_API,
            FeatureFlag::CONCURRENT_FUNGIBLE_BALANCE,
            FeatureFlag::_LIMIT_VM_TYPE_SIZE,
            FeatureFlag::ABORT_IF_MULTISIG_PAYLOAD_MISMATCH,
            FeatureFlag::_DISALLOW_USER_NATIVES,
            FeatureFlag::ALLOW_SERIALIZED_SCRIPT_ARGS,
            FeatureFlag::_USE_COMPATIBILITY_CHECKER_V2,
            FeatureFlag::ENABLE_ENUM_TYPES,
            FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL,
            FeatureFlag::_REJECT_UNSTABLE_BYTECODE_FOR_SCRIPT,
            FeatureFlag::TRANSACTION_SIMULATION_ENHANCEMENT,
            FeatureFlag::_NATIVE_MEMORY_OPERATIONS,
            FeatureFlag::_ENABLE_LOADER_V2,
            FeatureFlag::_DISALLOW_INIT_MODULE_TO_PUBLISH_MODULES,
            FeatureFlag::COLLECTION_OWNER,
            FeatureFlag::PERMISSIONED_SIGNER,
            FeatureFlag::ENABLE_CALL_TREE_AND_INSTRUCTION_VM_CACHE,
            FeatureFlag::ACCOUNT_ABSTRACTION,
            FeatureFlag::BULLETPROOFS_BATCH_NATIVES,
            FeatureFlag::DERIVABLE_ACCOUNT_ABSTRACTION,
            FeatureFlag::VM_BINARY_FORMAT_V8,
            FeatureFlag::ENABLE_FUNCTION_VALUES,
            FeatureFlag::NEW_ACCOUNTS_DEFAULT_TO_FA_STORE,
            FeatureFlag::DEFAULT_ACCOUNT_RESOURCE,
            FeatureFlag::JWK_CONSENSUS_PER_KEY_MODE,
            FeatureFlag::TRANSACTION_PAYLOAD_V2,
            FeatureFlag::ORDERLESS_TRANSACTIONS,
            FeatureFlag::CALCULATE_TRANSACTION_FEE_FOR_DISTRIBUTION,
            FeatureFlag::DISTRIBUTE_TRANSACTION_FEE,
            FeatureFlag::ENABLE_LAZY_LOADING,
            FeatureFlag::MONOTONICALLY_INCREASING_COUNTER,
            FeatureFlag::ENABLE_CAPTURE_OPTION,
            FeatureFlag::ENABLE_TRUSTED_CODE,
            FeatureFlag::ENABLE_ENUM_OPTION,
            FeatureFlag::VM_BINARY_FORMAT_V9,
            FeatureFlag::ENABLE_FRAMEWORK_FOR_OPTION,
            FeatureFlag::ENABLE_FUNCTION_REFLECTION,
            FeatureFlag::VM_BINARY_FORMAT_V10,
            FeatureFlag::SLH_DSA_SHA2_128S_SIGNATURE,
        ]
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L287-298)
```rust
impl Default for Features {
    fn default() -> Self {
        let mut features = Features {
            features: vec![0; 5],
        };

        for feature in FeatureFlag::default_features() {
            features.enable(feature);
        }
        features
    }
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L485-499)
```rust
    pub fn get_max_binary_format_version(&self) -> u32 {
        if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10) {
            file_format_common::VERSION_10
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V9) {
            file_format_common::VERSION_9
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V8) {
            file_format_common::VERSION_8
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V7) {
            file_format_common::VERSION_7
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V6) {
            file_format_common::VERSION_6
        } else {
            file_format_common::VERSION_5
        }
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L137-142)
```rust
pub fn aptos_prod_deserializer_config(features: &Features) -> DeserializerConfig {
    DeserializerConfig::new(
        features.get_max_binary_format_version(),
        features.get_max_identifier_size(),
    )
}
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L531-534)
```rust
        let validator_set = ValidatorSet::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("ValidatorSet not touched on epoch change"))?;
        let configuration = ConfigurationResource::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("Configuration resource not touched on epoch change"))?;
```

**File:** storage/storage-interface/src/state_store/state_summary.rs (L92-93)
```rust
        assert_ne!(self.hot_state_summary.root_hash(), *CORRUPTION_SENTINEL);
        assert_ne!(self.global_state_summary.root_hash(), *CORRUPTION_SENTINEL);
```
