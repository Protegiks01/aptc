# Audit Report

## Title
Missing On-Chain Expiration Horizon Validation for ZK Keyless Signatures Allows Arbitrarily Long-Lived Ephemeral Keys

## Summary
The on-chain validation for ZeroKnowledgeSig (ZK keyless) signatures does not enforce that `exp_date_secs` is within `max_exp_horizon_secs` from the JWT's issued-at time (`iat`). While this constraint is enforced in the off-chain pepper service, attackers can bypass it by reusing a previously-obtained pepper with a new JWT that has a far-future expiration date, creating ephemeral keys that remain valid for years or decades instead of the intended short lifespan. [1](#0-0) 

## Finding Description
The keyless authentication system is designed to limit ephemeral public key (EPK) validity periods through the `max_exp_horizon_secs` configuration parameter. For zkless keyless (OpenIdSig), this constraint is properly enforced on-chain. However, for ZK keyless (ZeroKnowledgeSig), a critical validation gap exists.

**How the vulnerability works:**

1. The pepper service validates `exp_date_secs <= iat + max_exp_horizon_secs` when users request peppers [2](#0-1) 

2. However, peppers are deterministically derived from `(iss, aud, uid_key, uid_val)` and can be reused across multiple transactions with the same identity [3](#0-2) 

3. On-chain validation for ZK keyless only checks:
   - `current_time <= exp_date_secs` (signature not expired)
   - `exp_horizon_secs <= max_exp_horizon_secs` (horizon limit) [4](#0-3) 

4. The on-chain code does NOT validate `exp_date_secs <= iat + exp_horizon_secs` for ZK signatures, unlike OpenIdSig which has this check [5](#0-4) 

5. The ZK circuit includes both `exp_timestamp_secs` and `exp_horizon_secs` as public inputs, but the circuit does NOT have access to `iat` to enforce the relationship between them [6](#0-5) 

**Attack scenario:**
1. User legitimately obtains pepper at time T with `exp_date = T + 7 days`
2. At time T+1year, user creates new EPK with `exp_date = T + 1year + 100years`
3. User computes nonce with this far-future date and obtains JWT from OIDC provider with `iat = T+1year`
4. User reuses the pepper from step 1 (bypassing pepper service validation)
5. User generates ZK proof with `exp_horizon_secs = 7 days` (to pass on-chain limit check)
6. User submits transaction with `exp_date_secs = T + 1year + 100years`

The on-chain validation passes because:
- `exp_horizon_secs` (7 days) ≤ `max_exp_horizon_secs` ✓
- Current time ≤ `exp_date_secs` ✓ (for decades)
- ZK proof verifies ✓ (nonce matches, public inputs hash correct)

But nobody checks that `exp_date_secs ≤ iat + exp_horizon_secs` (which would be `T+1year + 7 days`).

## Impact Explanation
**Severity: High**

This vulnerability allows attackers to create keyless accounts with ephemeral keys that remain valid for arbitrarily long periods, violating the fundamental security model of keyless authentication where ephemeral keys should be short-lived.

**Security Impact:**
- **Extended Attack Window**: If an ephemeral private key is compromised (e.g., through device theft, malware, or backup exposure), the attacker has years instead of days to exploit it
- **Circumvents Security Controls**: The `max_exp_horizon_secs` parameter (intended to limit risk) can be completely bypassed
- **Affects Protocol Integrity**: This violates the documented security guarantee that ephemeral keys have bounded lifespans

While this doesn't directly lead to fund theft, it significantly degrades the security posture of keyless accounts and could enable prolonged unauthorized access if an EPK is compromised. This qualifies as a **significant protocol violation** per the Aptos bug bounty criteria for High severity.

## Likelihood Explanation
**Likelihood: Medium-High**

The attack is highly feasible:
- **No special privileges required**: Any user can execute this attack
- **Simple to exploit**: Requires only obtaining a pepper once, then reusing it with new JWTs
- **Difficult to detect**: Transactions appear valid to on-chain validators
- **Long-term value**: Attackers gain persistent access potential

The main barrier is that users must still obtain legitimate JWTs from OIDC providers, but this is a normal part of keyless authentication usage.

## Recommendation
Add on-chain validation for ZeroKnowledgeSig to ensure `exp_date_secs` is within the allowed horizon from the JWT's `iat` time. Since the circuit doesn't extract `iat`, the validation should check the relationship between `exp_date_secs` and `exp_horizon_secs` more strictly.

**Option 1: Circuit-level fix** (Preferred)
Modify the ZK circuit to:
1. Extract and constrain the `iat` field from the JWT
2. Add a circuit constraint: `exp_timestamp_secs < iat + exp_horizon_secs`
3. Include `iat` as a public input

**Option 2: On-chain approximation** (Simpler, but less precise)
Add validation in `verify_keyless_signature_without_ephemeral_signature_check`:

```rust
// For ZeroKnowledgeSig, verify that exp_date_secs is reasonable given exp_horizon_secs
// Since we can't access iat directly, we check against current time as a proxy
match &signature.cert {
    EphemeralCertificate::ZeroKnowledgeSig(zksig) => {
        // exp_date_secs should be at most current_time + exp_horizon_secs
        let max_allowed_exp = onchain_timestamp_microseconds / 1_000_000 + zksig.exp_horizon_secs;
        if signature.exp_date_secs > max_allowed_exp {
            return Err(invalid_signature!(
                "exp_date_secs exceeds current_time + exp_horizon_secs"
            ));
        }
        // ... rest of validation
    }
}
```

Add this check around line 291 in `keyless_validation.rs`, right after the existing `verify_expiry` call.

## Proof of Concept
The vulnerability can be demonstrated with the following scenario:

```rust
// This PoC would be added as a test in aptos-move/aptos-vm/src/keyless_validation.rs

#[test]
fn test_zk_keyless_far_future_expiry_bypass() {
    // 1. Setup: Create a valid ZK keyless signature at time T
    let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
    let valid_exp_date = now + (7 * 86400); // 7 days
    
    // 2. User obtains pepper legitimately with valid exp_date
    // (pepper service validation passes)
    
    // 3. Later, user creates new JWT with far-future nonce
    let far_future_exp_date = now + (100 * 365 * 86400); // 100 years
    
    // 4. User generates ZK proof with:
    //    - exp_timestamp_secs = far_future_exp_date (in nonce)
    //    - exp_horizon_secs = 7 days (to pass max check)
    let sig = create_zk_signature(
        far_future_exp_date,  // exp_date_secs  
        7 * 86400,            // exp_horizon_secs
        // ... other params
    );
    
    // 5. On-chain validation incorrectly passes
    let result = validate_authenticators(
        Some(&pvk),
        Some(&config),
        &vec![(public_key, sig)],
        &features,
        &resolver,
        &module_storage,
    );
    
    // This should FAIL but currently PASSES
    assert!(result.is_ok()); // Vulnerability: this passes when it shouldn't!
}
```

The test would demonstrate that a signature with `exp_date_secs = now + 100 years` and `exp_horizon_secs = 7 days` incorrectly passes validation, despite violating the invariant that `exp_date_secs` should be within `exp_horizon_secs` of the JWT's `iat`.

## Notes
- This vulnerability only affects ZeroKnowledgeSig (ZK keyless), not OpenIdSig (zkless keyless), which has the proper on-chain validation
- The root cause is that the ZK circuit doesn't extract or constrain the JWT's `iat` field
- A complete fix requires either modifying the circuit or implementing a reasonable approximation on-chain

### Citations

**File:** sdk/src/types.rs (L92-113)
```rust
    fn build_keyless_signature(
        &self,
        txn: RawTransaction,
        account: &impl CommonKeylessAccount,
    ) -> KeylessSignature {
        let proof = account.zk_sig().proof;
        let txn_and_zkp = keyless::TransactionAndProof {
            message: txn,
            proof: Some(proof),
        };

        let esk = account.ephem_private_key();
        let ephemeral_signature = esk.sign(&txn_and_zkp).unwrap();

        KeylessSignature {
            cert: EphemeralCertificate::ZeroKnowledgeSig(account.zk_sig().clone()),
            jwt_header_json: account.jwt_header_json().clone(),
            exp_date_secs: account.expiry_date_secs(),
            ephemeral_pubkey: account.ephem_public_key().clone(),
            ephemeral_signature,
        }
    }
```

**File:** keyless/pepper/service/src/dedicated_handlers/pepper_request.rs (L125-146)
```rust
/// Creates the account address using the pepper input and the derived pepper
fn create_account_address(
    pepper_input: &PepperInput,
    derived_pepper: &Pepper,
) -> Result<AccountAddress, PepperServiceError> {
    let id_commitment = IdCommitment::new_from_preimage(
        derived_pepper,
        &pepper_input.aud,
        &pepper_input.uid_key,
        &pepper_input.uid_val,
    )
    .map_err(|error| {
        PepperServiceError::InternalError(format!("Failed to create id commitment: {}", error))
    })?;
    let public_key = KeylessPublicKey {
        iss_val: pepper_input.iss.clone(),
        idc: id_commitment,
    };
    let address = AuthenticationKey::any_key(AnyPublicKey::keyless(public_key)).account_address();

    Ok(address)
}
```

**File:** keyless/pepper/service/src/dedicated_handlers/pepper_request.rs (L430-468)
```rust
fn verify_public_key_expiry_date_secs(
    exp_date_secs: u64,
    claims: &TokenData<Claims>,
    keyless_configuration: &Configuration,
) -> Result<(), PepperServiceError> {
    // Get the current time
    let time_now_secs = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();

    // Verify that the expiry date is in the future
    if exp_date_secs <= time_now_secs {
        return Err(PepperServiceError::BadRequest(format!(
            "The ephemeral public key expiry date has passed: exp_date_secs = {}, time_now_secs = {}",
            exp_date_secs, time_now_secs
        )));
    }

    // Get the maximum allowed expiry date
    let (max_exp_date_secs, overflowed) = claims
        .claims
        .iat
        .overflowing_add(keyless_configuration.max_exp_horizon_secs);
    if overflowed {
        return Err(PepperServiceError::BadRequest(
            "The maximum allowed expiry date overflowed".to_string(),
        ));
    }

    // Verify that the expiry date is within the allowed horizon
    if exp_date_secs >= max_exp_date_secs {
        Err(PepperServiceError::BadRequest(
            "The ephemeral public key expiry date is too far in the future (and beyond the max allowed horizon)".into()
        ))
    } else {
        Ok(())
    }
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L284-297)
```rust
    signature
        .verify_expiry(onchain_timestamp_microseconds)
        .map_err(|_| {
            // println!("[aptos-vm][groth16] ZKP expired");

            invalid_signature!("The ephemeral keypair has expired")
        })?;
    match &signature.cert {
        EphemeralCertificate::ZeroKnowledgeSig(zksig) => match jwk {
            JWK::RSA(rsa_jwk) => {
                if zksig.exp_horizon_secs > config.max_exp_horizon_secs {
                    // println!("[aptos-vm][groth16] Expiration horizon is too long");
                    return Err(invalid_signature!("The expiration horizon is too long"));
                }
```

**File:** types/src/keyless/openid_sig.rs (L64-78)
```rust
        let max_expiration_date = seconds_from_epoch(
            claims
                .oidc_claims
                .iat
                .checked_add(config.max_exp_horizon_secs)
                .ok_or_else(|| {
                    anyhow::anyhow!("Overflow when adding iat and max_exp_horizon_secs")
                })?,
        )?;
        let expiration_date = seconds_from_epoch(exp_timestamp_secs)?;

        ensure!(
            expiration_date < max_expiration_date,
            "The ephemeral public key's expiration date is too far into the future"
        );
```

**File:** types/src/keyless/bn254_circom.rs (L279-369)
```rust
pub fn hash_public_inputs(
    config: &Configuration,
    epk: &EphemeralPublicKey,
    idc: &IdCommitment,
    exp_timestamp_secs: u64,
    exp_horizon_secs: u64,
    iss: &str,
    extra_field: Option<&str>,
    jwt_header_json: &str,
    jwk: &RSA_JWK,
    override_aud_val: Option<&str>,
) -> anyhow::Result<Fr> {
    let (has_extra_field, extra_field_hash) = match extra_field {
        None => (Fr::zero(), *EMPTY_EXTRA_FIELD_HASH),
        Some(extra_field) => (
            Fr::one(),
            poseidon_bn254::keyless::pad_and_hash_string(
                extra_field,
                config.max_extra_field_bytes as usize,
            )?,
        ),
    };

    let (override_aud_val_hash, use_override_aud) = match override_aud_val {
        Some(override_aud_val) => (
            cached_pad_and_hash_string(override_aud_val, IdCommitment::MAX_AUD_VAL_BYTES)?,
            ark_bn254::Fr::from(1),
        ),
        None => (*EMPTY_OVERRIDE_AUD_FIELD_HASH, ark_bn254::Fr::from(0)),
    };

    // Add the hash of the jwt_header with the "." separator appended
    let jwt_header_b64_with_separator = format!("{}.", base64url_encode_str(jwt_header_json));
    let jwt_header_hash = cached_pad_and_hash_string(
        &jwt_header_b64_with_separator,
        config.max_jwt_header_b64_bytes as usize,
    )?;

    let jwk_hash = cached_jwk_hash(jwk)?;

    // Add the hash of the value of the `iss` field
    let iss_field_hash = cached_pad_and_hash_string(iss, config.max_iss_val_bytes as usize)?;

    // Add the id_commitment as a scalar
    let idc = Fr::from_le_bytes_mod_order(&idc.0);

    // Add the exp_timestamp_secs as a scalar
    let exp_timestamp_secs = Fr::from(exp_timestamp_secs);

    // Add the epk lifespan as a scalar
    let exp_horizon_secs = Fr::from(exp_horizon_secs);

    let mut epk_frs = poseidon_bn254::keyless::pad_and_pack_bytes_to_scalars_with_len(
        epk.to_bytes().as_slice(),
        config.max_commited_epk_bytes as usize,
    )?;

    // println!("Num EPK scalars:    {}", epk_frs.len());
    // for (i, e) in epk_frs.iter().enumerate() {
    //     println!("EPK Fr[{}]:          {}", i, e.to_string())
    // }
    // println!("IDC:                {}", idc);
    // println!("exp_timestamp_secs: {}", exp_timestamp_secs);
    // println!("exp_horizon_secs:   {}", exp_horizon_secs);
    // println!("iss field:          {}", pk.iss_val);
    // println!("iss field hash:     {}", iss_field_hash);
    // println!("Has extra field:    {}", has_extra_field);
    // println!("Extra field val:    {:?}", proof.extra_field);
    // println!("Extra field hash:   {}", extra_field_hash);
    // println!("JWT header val:     {}", jwt_header_b64_with_separator);
    // println!("JWT header hash:    {}", jwt_header_hash);
    // println!("JWK hash:           {}", jwk_hash);
    // println!("Override aud hash:  {}", override_aud_val_hash);
    // println!("Use override aud:   {}", use_override_aud.to_string());

    let mut frs = vec![];
    frs.append(&mut epk_frs);
    frs.push(idc);
    frs.push(exp_timestamp_secs);
    frs.push(exp_horizon_secs);
    frs.push(iss_field_hash);
    frs.push(has_extra_field);
    frs.push(extra_field_hash);
    frs.push(jwt_header_hash);
    frs.push(jwk_hash);
    frs.push(override_aud_val_hash);
    frs.push(use_override_aud);
    // TODO(keyless): If we plan on avoiding verifying the same PIH twice, there should be no
    //  need for caching here. If we do not, we should cache the result here too.
    poseidon_bn254::hash_scalars(frs)
}
```
