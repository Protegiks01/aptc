# Audit Report

## Title
Symlink Following Vulnerability in OnDiskStorage Initialization Enables Denial of Service

## Summary
The `OnDiskStorage::new()` function in `secure/storage/src/on_disk.rs` uses `File::create()` without symlink protection, allowing an attacker with filesystem access to cause validator node startup failures through symlink attacks. While this does not lead to cryptographic key theft due to subsequent `fs::rename()` protection, it enables denial of service attacks against validator nodes. [1](#0-0) 

## Finding Description

The `OnDiskStorage` implementation is used by validators to store critical consensus keys, including BLS12-381 private keys for signing blocks and votes: [2](#0-1) 

During initialization, the code performs a check-then-create pattern that is vulnerable to both symlink following and Time-Of-Check-Time-Of-Use (TOCTOU) attacks: [3](#0-2) 

In Rust's standard library, both `Path::exists()` and `File::create()` follow symlinks by default. This creates two attack vectors:

**Attack Vector 1: TOCTOU Race Condition**
An attacker with filesystem access could create a symlink after the `exists()` check passes but before `File::create()` executes, redirecting the file creation to an unwritable location and causing a panic that prevents validator startup.

**Attack Vector 2: Pre-placed Dangling Symlink**
If an attacker creates a dangling symlink (pointing to a non-existent file) at the storage path before the validator starts:
- `exists()` returns `false` (symlink target doesn't exist)
- `File::create()` follows the symlink and attempts to create the file at the target location
- If the target is unwritable or in a protected location, the validator panics with "Unable to create storage at path"
- Validator fails to start, causing denial of service

**Key Data Safety**: Importantly, cryptographic keys are NOT leaked to the symlink target because subsequent write operations use `fs::rename()`, which replaces the symlink rather than following it: [4](#0-3) 

However, the initialization vulnerability still allows an attacker to prevent validator operation.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Validator Node Availability**: An attacker can prevent validator nodes from starting, directly impacting network consensus participation and liveness. This falls under "Validator node slowdowns" and "Significant protocol violations" (High severity).

2. **No Key Theft**: The vulnerability does NOT lead to "Loss of Funds" or consensus key theft because the `fs::rename()` operation replaces symlinks atomically. This prevents elevation to Critical severity.

3. **Attack Prerequisites**: While the attack requires filesystem access to the validator's data directory, this is realistic in scenarios where:
   - Multiple services/users share a system
   - Container escape vulnerabilities exist
   - Misconfigured permissions allow directory access

## Likelihood Explanation

**Likelihood: MEDIUM**

The attack is moderately likely to occur because:

1. **Access Requirements**: Attackers need write access to the validator's data directory (typically `/opt/aptos/data`). While this requires elevated access, it's not uncommon in:
   - Multi-tenant systems
   - Compromised infrastructure
   - Misconfigured deployments

2. **Timing Window**: The TOCTOU race has a narrow window (nanoseconds between lines 35-36), but a pre-placed symlink attack has unlimited preparation time.

3. **Attack Complexity**: LOW - Creating a symlink requires a single command: `ln -s /dev/null /opt/aptos/data/secure_storage.json`

4. **Detection Difficulty**: The attack is subtle and may appear as a legitimate storage configuration error.

5. **Mitigation Note**: The code explicitly warns "should not be used in production" (line 22), suggesting production validators should use Vault storage instead. However, OnDiskStorage remains available in production builds: [5](#0-4) 

## Recommendation

**Fix**: Use the `O_NOFOLLOW` flag on Unix systems to prevent symlink following during file creation:

```rust
fn new_with_time_service(file_path: PathBuf, time_service: TimeService) -> Self {
    if !file_path.exists() {
        // Use OpenOptions with O_NOFOLLOW to prevent symlink following
        #[cfg(unix)]
        {
            use std::os::unix::fs::OpenOptionsExt;
            std::fs::OpenOptions::new()
                .write(true)
                .create_new(true)  // Fail if file exists, preventing TOCTOU
                .mode(0o600)       // User-only permissions for security
                .custom_flags(libc::O_NOFOLLOW)  // Don't follow symlinks
                .open(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
        }
        
        #[cfg(not(unix))]
        {
            File::create(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
        }
    }
    
    // ... rest of function
}
```

**Additional Recommendations**:
1. Add explicit documentation warning against using OnDiskStorage in production
2. Consider removing OnDiskStorage from production builds entirely
3. Add filesystem permission checks during initialization
4. Implement file ownership and permission validation before use

## Proof of Concept

```rust
#[cfg(test)]
mod symlink_attack_test {
    use super::*;
    use std::os::unix::fs::symlink;
    use aptos_temppath::TempPath;
    
    #[test]
    #[should_panic(expected = "Unable to create storage")]
    fn test_symlink_denial_of_service() {
        // Setup: Create a directory for our test
        let temp_dir = TempPath::new();
        let storage_path = temp_dir.path().join("secure_storage.json");
        let unwritable_target = PathBuf::from("/dev/null");
        
        // Attack: Create a symlink pointing to an unwritable location
        // before OnDiskStorage initialization
        symlink(&unwritable_target, &storage_path)
            .expect("Failed to create symlink");
        
        // Trigger: When validator tries to initialize storage,
        // it will panic due to symlink following
        let _storage = OnDiskStorage::new(storage_path);
        
        // Expected: Panic with "Unable to create storage at path"
        // This prevents the validator from starting
    }
    
    #[test]
    fn test_dangling_symlink_creates_file_at_target() {
        let temp_dir = TempPath::new();
        let storage_path = temp_dir.path().join("secure_storage.json");
        let target_path = temp_dir.path().join("attacker_controlled.json");
        
        // Ensure target doesn't exist (dangling symlink)
        assert!(!target_path.exists());
        
        // Create dangling symlink
        symlink(&target_path, &storage_path)
            .expect("Failed to create symlink");
        
        // Initialize storage - this follows the symlink
        let _storage = OnDiskStorage::new(storage_path.clone());
        
        // Verify: File was created at symlink target, not at storage_path
        assert!(target_path.exists(), "File should exist at symlink target");
    }
}
```

## Notes

This vulnerability demonstrates a **symlink following attack** combined with a **TOCTOU race condition** in the secure storage initialization code. While the subsequent use of `fs::rename()` prevents cryptographic key leakage, the vulnerability still enables denial of service attacks against validator nodes by preventing their startup. The fix requires platform-specific APIs (`O_NOFOLLOW`) and atomic file creation (`create_new`) to prevent both symlink following and race conditions.

The security impact is mitigated by the fact that production deployments should use Vault storage rather than OnDiskStorage, as indicated in the code comments. However, since OnDiskStorage remains available in the production codebase and can be configured for use, this vulnerability warrants remediation.

### Citations

**File:** secure/storage/src/on_disk.rs (L16-23)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
pub struct OnDiskStorage {
```

**File:** secure/storage/src/on_disk.rs (L34-38)
```rust
    fn new_with_time_service(file_path: PathBuf, time_service: TimeService) -> Self {
        if !file_path.exists() {
            File::create(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
        }
```

**File:** secure/storage/src/on_disk.rs (L64-69)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-81)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }

        internal_store.set(OWNER_ACCOUNT, author)?;
        Ok(())
    }
```
