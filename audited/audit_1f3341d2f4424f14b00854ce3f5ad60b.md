# Audit Report

## Title
Missing Validation in Groth16 Verification Key Setting Enables DoS Against All Keyless Accounts

## Summary
The `set_groth16_verification_key_for_next_epoch` function in the keyless account module accepts verification keys without validating that the elliptic curve point encodings are canonical and deserializable. This allows governance proposals to accidentally (or maliciously) set verification keys with non-canonical or invalid byte encodings, which causes all validators to fail VK deserialization, permanently bricking all keyless accounts until another governance proposal fixes the issue.

## Finding Description
The Groth16 verification key (VK) is stored on-chain and used by validators to verify zero-knowledge proofs in keyless transactions. The VK contains serialized BN254 elliptic curve points in compressed format.

**The Vulnerability Path:**

1. **VK Construction Without Validation**: The Move function `new_groth16_verification_key` constructs a VK from raw byte vectors without any validation. [1](#0-0) 

2. **Setting VK Without Validation**: When a governance proposal calls `set_groth16_verification_key_for_next_epoch`, the VK is accepted without validation. [2](#0-1) 

3. **Unused Validation Function**: A validation function `validate_groth16_vk` exists that checks if points can be deserialized, but it is NEVER called anywhere in the codebase. [3](#0-2) 

4. **Deserialization Failure at Runtime**: When validators load the environment, they fetch the VK and attempt to convert it to `PreparedVerifyingKey` using `try_into()`, which validates the points during deserialization. [4](#0-3) 

5. **Conversion Enforces Canonical Validation**: The `TryFrom` implementation calls `deserialize_compressed` which rejects non-canonical encodings. [5](#0-4) 

6. **All Keyless Transactions Fail**: When a ZK keyless transaction arrives, if `pvk.is_none()` (because deserialization failed), the validator returns an error. [6](#0-5) 

**The Serialization Question**: The `From<&PreparedVerifyingKey<Bn254>>` implementation uses `serialize_compressed` which IS deterministic and canonical. [7](#0-6) [8](#0-7) 

However, this canonical path can be bypassed by directly constructing a VK with arbitrary bytes, which is the vulnerability.

## Impact Explanation
**Severity: HIGH** - This qualifies as "Significant protocol violations" and causes "Validator node slowdowns" under the Aptos bug bounty criteria.

**Impact:**
- **Complete DoS of keyless accounts**: All keyless accounts using zero-knowledge proofs become unable to transact
- **Network-wide effect**: Affects all validators simultaneously since they all load the same on-chain VK
- **Recovery requires governance**: Fixing the issue requires another governance proposal to pass and an epoch change, which takes time
- **No funds loss**: Accounts are not drained, but become temporarily unusable

The issue doesn't reach CRITICAL severity because:
- Funds are not permanently lost (accounts can recover after VK fix)
- Network continues operating for non-keyless accounts
- No consensus safety violation

## Likelihood Explanation
**Likelihood: MEDIUM**

This could occur through:
1. **Accidental misconfiguration**: A governance proposal script with bugs that generates invalid VK bytes
2. **Copy-paste errors**: Manually constructing VK bytes with typos or wrong hex encoding
3. **Tooling issues**: External tools generating VKs incorrectly
4. **Malicious governance proposal**: Though governance participants are trusted, a single compromised participant could submit this

The likelihood is not LOW because:
- The validation function exists but is unused, suggesting developers intended to use it
- No safeguards exist to catch this error before the VK goes on-chain
- Governance proposals are complex and errors can happen

The likelihood is not HIGH because:
- Requires governance approval (not an unprivileged attack)
- The normal path through `From<PreparedVerifyingKey>` produces valid encodings

## Recommendation
**Add validation before storing the VK on-chain:**

```move
public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    // ADD THIS LINE:
    validate_groth16_vk(&vk);
    config_buffer::upsert<Groth16VerificationKey>(vk);
}
```

Also add validation to genesis initialization:
```move
public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    chain_status::assert_genesis();
    // ADD THIS LINE:
    validate_groth16_vk(&vk);
    move_to(fx, vk);
}
```

This ensures that any VK stored on-chain can be successfully deserialized by validators, preventing the DoS scenario.

## Proof of Concept

```move
#[test(fx = @aptos_framework)]
#[expected_failure(abort_code = 2, location = aptos_framework::keyless_account)]
fun test_invalid_vk_rejected(fx: &signer) {
    use aptos_framework::keyless_account;
    
    // Construct a VK with invalid G1 point bytes (all zeros)
    let invalid_vk = keyless_account::new_groth16_verification_key(
        vector[0u8; 32],  // Invalid alpha_g1
        vector[0u8; 64],  // Invalid beta_g2
        vector[0u8; 64],  // Invalid gamma_g2
        vector[0u8; 64],  // Invalid delta_g2
        vector[vector[0u8; 32], vector[0u8; 32]]  // Invalid gamma_abc_g1
    );
    
    // Without the fix, this would succeed and brick all keyless accounts
    // With the fix (calling validate_groth16_vk), this should abort with E_INVALID_BN254_G1_SERIALIZATION
    keyless_account::set_groth16_verification_key_for_next_epoch(fx, invalid_vk);
}
```

This test demonstrates that invalid VK bytes can currently be set without validation, which would cause validator deserialization to fail at runtime.

## Notes
- The serialization used in the `From<PreparedVerifyingKey>` implementation (lines 115-118) IS deterministic due to `serialize_compressed` being canonical
- The vulnerability is not in the serialization determinism itself, but in the ability to bypass canonical serialization by directly constructing VKs with arbitrary bytes
- The unused `validate_groth16_vk` function suggests this was a known concern that was not properly addressed

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L145-158)
```text
    public fun new_groth16_verification_key(alpha_g1: vector<u8>,
                                            beta_g2: vector<u8>,
                                            gamma_g2: vector<u8>,
                                            delta_g2: vector<u8>,
                                            gamma_abc_g1: vector<vector<u8>>
    ): Groth16VerificationKey {
        Groth16VerificationKey {
            alpha_g1,
            beta_g2,
            gamma_g2,
            delta_g2,
            gamma_abc_g1,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L289-293)
```rust
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```

**File:** types/src/keyless/groth16_vk.rs (L62-90)
```rust
impl TryFrom<&Groth16VerificationKey> for PreparedVerifyingKey<Bn254> {
    type Error = CryptoMaterialError;

    fn try_from(vk: &Groth16VerificationKey) -> Result<Self, Self::Error> {
        if vk.gamma_abc_g1.len() != 2 {
            return Err(CryptoMaterialError::DeserializationError);
        }

        // NOTE: Technically, we already validate the points when we set the VK in Move, so we could
        // make this 2x faster by avoiding the point validation checks  via
        // `deserialize_with_mode(..., Compress::Yes, Validate::No)`. Due to paranoia, will not
        // optimize this for now.
        Ok(Self::from(VerifyingKey {
            alpha_g1: G1Affine::deserialize_compressed(vk.alpha_g1.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            beta_g2: G2Affine::deserialize_compressed(vk.beta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_g2: G2Affine::deserialize_compressed(vk.gamma_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            delta_g2: G2Affine::deserialize_compressed(vk.delta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_abc_g1: vec![
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[0].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[1].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
            ],
        }))
    }
```

**File:** types/src/keyless/groth16_vk.rs (L115-118)
```rust
        let mut gamma_abc_g1_bytes = Vec::with_capacity(gamma_abc_g1.len());
        for e in gamma_abc_g1.iter() {
            gamma_abc_g1_bytes.push(serialize!(e));
        }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L188-191)
```rust
    // If there are ZK authenticators, the Groth16 VK must have been set on-chain.
    if with_zk && pvk.is_none() {
        return Err(invalid_signature!("Groth16 VK has not been set on-chain"));
    }
```

**File:** types/src/keyless/mod.rs (L116-124)
```rust
/// Useful macro for arkworks serialization!
#[macro_export]
macro_rules! serialize {
    ($obj:expr) => {{
        let mut buf = vec![];
        $obj.serialize_compressed(&mut buf).unwrap();
        buf
    }};
}
```
