# Audit Report

## Title
Out-of-Bounds Array Access in Script Composer Due to Unchecked Signer Index

## Summary
The `CallArgument::Signer` enum variant in the script-composer module accepts an arbitrary `u16` signer index without validation. When this index exceeds the actual number of signers in a multi-agent transaction, it causes an out-of-bounds array access during argument type checking, resulting in a panic.

## Finding Description

The vulnerability exists in the transaction composition flow where `CallArgument::Signer` indices are not validated against the actual signer count. [1](#0-0) 

When processing arguments in `add_batched_call`, the code directly uses the signer index without bounds checking: [2](#0-1) 

This creates an `AllocatedLocal` with `local_idx` set to the unchecked signer index. Later, when `check_argument_compatibility` is invoked to validate argument types, it performs direct array indexing: [3](#0-2) 

The array access at line 181 will panic if `argument.local_idx` (the signer index) is greater than or equal to `self.parameters_ty.len()`.

**Attack Scenario:**
1. Attacker creates `TransactionComposer::multi_signer(2)` - initializes with 2 signers
2. The `parameters_ty` vector contains 2 entries: `[Signer_Ref_0, Signer_Ref_1]`
3. Attacker calls `add_batched_call` with `CallArgument::Signer(5)` in the arguments
4. The code creates `AllocatedLocal { local_idx: 5, is_parameter: true, ... }`
5. When `check_argument_compatibility` executes, it attempts `self.parameters_ty[5]`
6. Since `parameters_ty.len() == 2`, this causes: `panic: index out of bounds: the len is 2 but the index is 5`

The script-composer is exposed via WebAssembly bindings: [4](#0-3) [5](#0-4) 

This makes it callable from JavaScript/web contexts, expanding the attack surface to any service or application using these bindings.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria for "API crashes." 

The impact includes:
- **Denial of Service**: Any application or service using the script-composer library (especially via WASM bindings) can be crashed by providing an invalid signer index
- **Application Availability**: Web applications using the WASM interface become vulnerable to client-side DoS attacks
- **Service Disruption**: Backend services that use this library to compose transactions on behalf of users can be crashed with malicious input

While this is a client-side library, the panic occurs during transaction composition, which could affect:
- SDKs and tooling that use this library
- Web applications using the WASM bindings
- Any middleware services composing batched transactions

The vulnerability breaks the invariant that all input validation should be performed before array indexing operations to prevent panics.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is:
- **Easy to trigger**: Requires only a single API call with an invalid signer index
- **No special privileges**: Any user of the TransactionComposer API can exploit it
- **Deterministic**: Always causes a panic when the signer index exceeds the parameter count
- **Accessible**: Exposed through WASM bindings, making it accessible from web contexts

The only requirement is that an attacker can call `TransactionComposer.multi_signer()` followed by `add_batched_call()` with a `CallArgument::Signer` containing an out-of-bounds index.

## Recommendation

Add bounds validation when creating or processing `CallArgument::Signer` to ensure the index is within the valid range:

**Option 1: Validate at construction**
Add validation in `CallArgument::new_signer()`:
```rust
pub fn new_signer(signer_idx: u16) -> Result<Self, String> {
    // Validation would need to be added by caller
    Ok(CallArgument::Signer(signer_idx))
}
```

**Option 2: Validate in add_batched_call (Recommended)**
Add validation when processing the signer argument:

```rust
CallArgument::Signer(i) => {
    // Validate signer index is within bounds
    let signer_count = self.parameters_ty.iter()
        .take_while(|ty| matches!(ty, SignatureToken::Reference(inner) if matches!(**inner, SignatureToken::Signer)))
        .count();
    
    if (*i as usize) >= signer_count {
        bail!("Signer index {} exceeds available signers (count: {})", i, signer_count);
    }
    
    arguments.push(AllocatedLocal {
        op_type: ArgumentOperation::Copy,
        is_parameter: true,
        local_idx: *i,
    })
}
```

**Option 3: Store signer count explicitly**
Track signer count in `TransactionComposer` struct and validate against it: [6](#0-5) 

Add validation in the `CallArgument::Signer` case using `self.signer_count` (which currently only exists in test builds).

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_signer_index_oob() {
    use aptos_types::state_store::state_key::StateKey;
    use e2e_move_tests::MoveHarness;
    use move_binary_format::CompiledModule;
    use move_core_types::{account_address::AccountAddress, language_storage::ModuleId};
    use std::str::FromStr;
    
    let mut h = MoveHarness::new();
    
    // Create a multi-signer composer with only 2 signers
    let mut builder = TransactionComposer::multi_signer(2);
    
    // Load a module
    let module = ModuleId::from_str("0x1::aptos_account").unwrap();
    let bytes = h.read_state_value_bytes(&StateKey::module_id(&module)).unwrap();
    builder.insert_module(CompiledModule::deserialize(&bytes).unwrap());
    
    // Attempt to use signer index 5 (out of bounds - only 0 and 1 are valid)
    // This will panic with "index out of bounds" when check_argument_compatibility
    // tries to access self.parameters_ty[5]
    builder
        .add_batched_call(
            "0x1::aptos_account".to_string(),
            "transfer".to_string(),
            vec![],
            vec![
                CallArgument::Signer(5),  // INVALID: only indices 0-1 are valid
                CallArgument::new_bytes(vec![0u8; 32]),  // dummy address
                CallArgument::new_bytes(bcs::to_bytes(&100u64).unwrap()),
            ],
        )
        .unwrap();  // This will panic before unwrap is reached
}
```

This test demonstrates that calling `add_batched_call` with `CallArgument::Signer(5)` on a 2-signer transaction composer causes a panic due to out-of-bounds array access.

## Notes

The vulnerability is present in the core transaction composition logic and affects any code path using `CallArgument::Signer` with an invalid index. The signer count is properly initialized via `multi_signer()` constructor, but there is no corresponding validation when signer arguments are actually used. This represents a missing input validation check that should be added to prevent client-side crashes and potential service disruptions.

### Citations

**File:** aptos-move/script-composer/src/lib.rs (L40-51)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub enum CallArgument {
    /// Passing raw bytes to the function. The bytes must follows the existing constraints for
    /// transaction arguments.
    Raw(Vec<u8>),
    /// Refering to signer of the transaction. If it's a single signer transaction you will only
    /// be able to access `Signer(0)`. You will be able to access other signers if it's a multi
    /// agent transaction.
    Signer(u16),
    /// The arugment came from the returned value of a previous `MoveFunctionCall`.
    PreviousResult(PreviousResult),
}
```

**File:** aptos-move/script-composer/src/builder.rs (L70-81)
```rust
pub struct TransactionComposer {
    builder: CompiledScriptBuilder,
    calls: Vec<BuilderCall>,
    parameters: Vec<Vec<u8>>,
    locals_availability: Vec<bool>,

    locals_ty: Vec<SignatureToken>,
    parameters_ty: Vec<SignatureToken>,

    #[cfg(test)]
    signer_count: u16,
}
```

**File:** aptos-move/script-composer/src/builder.rs (L83-102)
```rust
#[wasm_bindgen]
impl TransactionComposer {
    /// Create a builder with one distinct signer available. This should be the default configuration.
    pub fn single_signer() -> Self {
        let mut script = empty_script();
        script.code.code = vec![];

        let builder = CompiledScriptBuilder::new(script);
        Self {
            builder,
            calls: vec![],
            parameters: vec![],
            locals_availability: vec![],
            locals_ty: vec![],
            parameters_ty: vec![SignatureToken::Reference(Box::new(SignatureToken::Signer))],

            #[cfg(test)]
            signer_count: 1,
        }
    }
```

**File:** aptos-move/script-composer/src/builder.rs (L151-168)
```rust
    #[wasm_bindgen(js_name = add_batched_call)]
    pub fn add_batched_call_wasm(
        &mut self,
        module: String,
        function: String,
        ty_args: Vec<String>,
        args: Vec<CallArgumentWasm>,
    ) -> Result<Vec<CallArgumentWasm>, JsValue> {
        self.add_batched_call(
            module,
            function,
            ty_args,
            args.into_iter().map(|a| a.into()).collect(),
        )
        .map_err(|err| JsValue::from(format!("{:?}", err)))
        .map(|results| results.into_iter().map(|a| a.into()).collect())
    }
}
```

**File:** aptos-move/script-composer/src/builder.rs (L175-184)
```rust
    fn check_argument_compatibility(
        &mut self,
        argument: &AllocatedLocal,
        expected_ty: &SignatureToken,
    ) -> anyhow::Result<()> {
        let local_ty = if argument.is_parameter {
            self.parameters_ty[argument.local_idx as usize].clone()
        } else {
            self.locals_ty[argument.local_idx as usize].clone()
        };
```

**File:** aptos-move/script-composer/src/builder.rs (L274-278)
```rust
                CallArgument::Signer(i) => arguments.push(AllocatedLocal {
                    op_type: ArgumentOperation::Copy,
                    is_parameter: true,
                    local_idx: i,
                }),
```
