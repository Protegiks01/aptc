# Audit Report

## Title
Lack of Message Content Validation in CrossShardClient Trait Enables Shard Crash and Non-Deterministic Execution

## Summary
The `CrossShardClient` trait provides no validation interface for message contents in `send_global_msg()`, allowing implementations to send malformed messages that cause receiving shards to panic or exhibit non-deterministic behavior, breaking consensus safety invariants.

## Finding Description

The `CrossShardClient` trait defines the interface for cross-shard communication in the sharded block executor without enforcing any validation requirements on message contents: [1](#0-0) 

When messages are received, they are processed without validation and directly applied to the `CrossShardStateView`: [2](#0-1) 

The `set_value()` method performs an unchecked HashMap lookup that panics if the `state_key` is not in the expected dependency set: [3](#0-2) 

The expected keys are populated only from declared cross-shard dependencies: [4](#0-3) 

Additionally, `RemoteStateValue::set_value()` allows multiple invocations without validation, enabling race conditions: [5](#0-4) 

In remote execution mode, deserialization failures also cause panics: [6](#0-5) 

The sharded executor is used in production when remote addresses are configured: [7](#0-6) 

**Attack Vectors:**

1. **Panic-based DoS**: Sending `RemoteTxnWriteMsg` with a `StateKey` not in the expected dependency set causes `unwrap()` to panic, crashing the shard
2. **Deserialization Panic**: Malformed BCS-encoded bytes cause deserialization failures and panics
3. **Race Condition Non-determinism**: Multiple messages for the same key with different values create race conditions, causing different shards to see different values and compute different state roots

## Impact Explanation

This vulnerability achieves **Critical Severity** because it enables:

1. **Consensus Safety Violation**: Race conditions cause non-deterministic execution across shards. Different validators may commit different state roots for identical blocks, violating the critical invariant: "All validators must produce identical state roots for identical blocks." This is a consensus-breaking bug that can cause chain splits.

2. **Total Loss of Liveness**: Panics crash executor shards, halting block execution. With sharded execution enabled across the validator network, coordinated recovery becomes difficult, potentially causing prolonged network outages.

3. **Non-recoverable Network Partition**: If some validators' shards crash while others continue, the network enters an inconsistent state where validators have divergent state roots, potentially requiring a hard fork to recover.

## Likelihood Explanation

**Likelihood: Low-to-Medium** depending on deployment configuration.

**Attacker Requirements:**
- Sharded execution must be enabled via `remote_executor_addresses` configuration
- Attacker needs to either:
  - Compromise one executor shard process, OR  
  - Perform network-level man-in-the-middle attack on cross-shard communication channels

While the `NetworkController` provides transport, there is no application-level cryptographic authentication of cross-shard messages: [8](#0-7) 

The network uses GRPC without mandatory message signing, making MITM attacks feasible if network security is compromised.

## Recommendation

Implement validation at multiple layers:

```rust
// In CrossShardClient trait, add validation method:
pub trait CrossShardClient: Send + Sync {
    fn send_global_msg(&self, msg: CrossShardMsg) {
        self.validate_msg(&msg).expect("Invalid cross-shard message");
        self.send_global_msg_unchecked(msg);
    }
    
    fn validate_msg(&self, msg: &CrossShardMsg) -> Result<(), ValidationError>;
    fn send_global_msg_unchecked(&self, msg: CrossShardMsg);
    // ... other methods
}

// In CrossShardStateView::set_value(), add defensive check:
pub fn set_value(&self, state_key: &StateKey, state_value: Option<StateValue>) {
    if let Some(remote_value) = self.cross_shard_data.get(state_key) {
        remote_value.set_value(state_value);
    } else {
        // Log error instead of panicking
        error!("Received unexpected cross-shard update for key: {:?}", state_key);
    }
}

// In RemoteStateValue::set_value(), prevent duplicate sets:
pub fn set_value(&self, value: Option<StateValue>) {
    let (lock, cvar) = &*self.value_condition;
    let mut status = lock.lock().unwrap();
    match *status {
        RemoteValueStatus::Waiting => {
            *status = RemoteValueStatus::Ready(value);
            cvar.notify_all();
        }
        RemoteValueStatus::Ready(_) => {
            panic!("Attempted to set value twice on RemoteStateValue");
        }
    }
}
```

Additionally, implement cryptographic message authentication using validator keys to prevent MITM attacks on cross-shard channels.

## Proof of Concept

```rust
// Compile and run with: cargo test --package aptos-vm --lib sharded_block_executor::cross_shard_client
#[cfg(test)]
mod poc {
    use super::*;
    use aptos_types::state_store::state_key::StateKey;
    
    #[test]
    #[should_panic(expected = "called `Option::unwrap()` on a `None` value")]
    fn test_malicious_state_key_causes_panic() {
        // Create CrossShardStateView with empty dependency set
        let cross_shard_state_view = CrossShardStateView::new(
            HashSet::new(), // No expected dependencies
            &EmptyStateView,
        );
        
        // Malicious message with unexpected StateKey
        let malicious_key = StateKey::raw(b"malicious_key");
        let malicious_msg = RemoteTxnWriteMsg(RemoteTxnWrite::new(
            malicious_key.clone(),
            None,
        ));
        
        // This will panic due to unwrap() on None
        let (state_key, write_op) = malicious_msg.take();
        cross_shard_state_view.set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
    }
    
    #[test]
    fn test_race_condition_non_determinism() {
        use std::sync::Arc;
        use std::thread;
        
        let state_key = StateKey::raw(b"shared_key");
        let mut keys = HashSet::new();
        keys.insert(state_key.clone());
        
        let view = Arc::new(CrossShardStateView::new(keys, &EmptyStateView));
        
        // Two threads racing to set different values
        let view1 = view.clone();
        let key1 = state_key.clone();
        let handle1 = thread::spawn(move || {
            view1.set_value(&key1, Some(StateValue::from(vec![1u8])));
        });
        
        let view2 = view.clone();
        let key2 = state_key.clone();
        let handle2 = thread::spawn(move || {
            view2.set_value(&key2, Some(StateValue::from(vec![2u8])));
        });
        
        handle1.join().unwrap();
        handle2.join().unwrap();
        
        // Result is non-deterministic - could be [1] or [2]
        // This breaks consensus invariant!
    }
}
```

**Notes:**

This vulnerability requires either compromised shard processes or network-level attacks to exploit, which places it in a gray area regarding the trust model. However, the lack of defensive validation violates defense-in-depth principles critical for consensus systems. The trait interface should enforce validation regardless of whether current implementations are trusted, as a single compromised shard can break consensus safety for the entire network.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L32-43)
```rust
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L156-162)
```rust
pub trait CrossShardClient: Send + Sync {
    fn send_global_msg(&self, msg: CrossShardMsg);

    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg);

    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg;
}
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L49-56)
```rust
    pub fn set_value(&self, state_key: &StateKey, state_value: Option<StateValue>) {
        self.cross_shard_data
            .get(state_key)
            .unwrap()
            .set_value(state_value);
        // uncomment the following line to debug waiting count
        // trace!("waiting count for shard id {} is {}", self.shard_id, self.waiting_count());
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L58-71)
```rust
    pub fn create_cross_shard_state_view(
        base_view: &'a S,
        transactions: &[TransactionWithDependencies<AnalyzedTransaction>],
    ) -> CrossShardStateView<'a, S> {
        let mut cross_shard_state_key = HashSet::new();
        for txn in transactions {
            for (_, storage_locations) in txn.cross_shard_dependencies.required_edges_iter() {
                for storage_location in storage_locations {
                    cross_shard_state_key.insert(storage_location.clone().into_state_key());
                }
            }
        }
        CrossShardStateView::new(cross_shard_state_key, base_view)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L22-27)
```rust
    pub fn set_value(&self, value: Option<StateValue>) {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        *status = RemoteValueStatus::Ready(value);
        cvar.notify_all();
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L61-66)
```rust
    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-276)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```

**File:** secure/net/src/network_controller/mod.rs (L22-70)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[allow(dead_code)]
pub struct NetworkMessage {
    pub sender: SocketAddr,
    pub message: Message,
    pub message_type: MessageType,
}

#[derive(Clone, Debug, Deserialize, Serialize, Eq, Hash, PartialEq)]
#[allow(dead_code)]
pub struct MessageType {
    message_type: String,
}

impl MessageType {
    pub fn new(message_type: String) -> Self {
        Self { message_type }
    }

    pub fn get_type(&self) -> String {
        self.message_type.clone()
    }
}

impl NetworkMessage {
    pub fn new(sender: SocketAddr, message: Message, message_type: MessageType) -> Self {
        Self {
            sender,
            message,
            message_type,
        }
    }
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[allow(dead_code)]
pub struct Message {
    pub data: Vec<u8>,
}

impl Message {
    pub fn new(data: Vec<u8>) -> Self {
        Self { data }
    }

    pub fn to_bytes(self) -> Vec<u8> {
        self.data
    }
}
```
