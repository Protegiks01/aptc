# Audit Report

## Title
State Restore Mode Switching Vulnerability Allows Creation of Inconsistent KV and Merkle Tree State

## Summary
The state snapshot restore system allows switching between restore modes (`TreeOnly`, `KvOnly`, `Default`) across resume sessions without validation. This enables an attacker to create a state where some chunks exist only in the Merkle tree while others exist only in the KV store, breaking the fundamental invariant that these two data structures must remain synchronized.

## Finding Description

The `StateSnapshotRestore` system supports three restore modes defined in the `StateSnapshotRestoreMode` enum: `Default` (restores both KV and tree), `KvOnly` (restores only KV store), and `TreeOnly` (restores only Merkle tree). [1](#0-0) 

The restore mode is passed as a command-line argument when running the backup-cli tool: [2](#0-1) 

When a restore is interrupted and later resumed, the system tracks progress by persisting `StateSnapshotProgress` which contains only `key_hash` and `usage`: [3](#0-2) 

**Critical Issue: The restore mode is NOT persisted in the progress metadata.**

During chunk processing, the restore mode controls which components get updated: [4](#0-3) 

When resuming, the system determines which chunks to skip by calling `previous_key_hash()`, which combines progress from both KV and tree restores: [5](#0-4) 

**Attack Scenario:**

1. **Initial Restore with `TreeOnly` mode:**
   - Process chunks 1-5 with `--restore-mode tree_only`
   - Only `tree_fn()` executes, writing data to StateMerkleDb
   - `kv_fn()` is never called, so KV data is NOT written
   - Tree progress is saved to disk via written nodes
   - Process is interrupted

2. **Resume with `KvOnly` mode:**
   - Restart with `--restore-mode kv_only`
   - New `StateSnapshotRestore` instance created with different mode
   - `previous_key_hash()` returns the minimum of KV progress (None) and tree progress (last key from chunk 5)
   - Since tree has progress, chunks 1-5 are skipped
   - Chunks 6-10 processed with `KvOnly` mode
   - Only `kv_fn()` executes, writing to StateKvDb
   - Tree is NOT updated for these chunks

**Result:**
- State keys from chunks 1-5: exist in Merkle tree but NOT in KV store
- State keys from chunks 6-10: exist in KV store but NOT in Merkle tree
- **Fundamental state consistency violated**

## Impact Explanation

This vulnerability breaks the **State Consistency** critical invariant: "State transitions must be atomic and verifiable via Merkle proofs."

**Severity: Medium** (State inconsistencies requiring intervention)

**Consequences:**
1. **Merkle Proof Verification Failures**: Proofs generated from the tree won't match actual KV data
2. **State Query Inconsistencies**: Reads may fail or return incorrect results depending on which storage layer is queried
3. **Potential Consensus Divergence**: Different nodes restoring with different mode sequences could end up with different effective states
4. **State Root Hash Corruption**: The computed state root will not accurately reflect the KV store contents

The system cannot function correctly with this inconsistency. While it doesn't directly cause immediate fund loss, it requires manual intervention to fix and could lead to consensus issues if multiple nodes are affected differently.

## Likelihood Explanation

**Likelihood: Medium**

**Requirements for exploitation:**
- Access to run the backup-cli restore tool on a node
- Ability to interrupt and restart the restore process
- Ability to modify command-line arguments between runs

**Realistic scenarios:**
1. **Operational Error**: Node operators legitimately changing restore modes between attempts due to misunderstanding or troubleshooting
2. **Malicious Operator**: A compromised or malicious node operator intentionally creating inconsistent state
3. **Automated System Exploitation**: An attacker who gains access to automated restore scripts could modify the restore mode parameter

The attack is straightforward to execute once access is obtained. No complex timing or race conditions are required.

## Recommendation

**Solution: Persist and validate the restore mode across resume sessions.**

Add restore mode tracking to `StateSnapshotProgress`:

```rust
// In storage/indexer_schemas/src/metadata.rs
#[derive(Clone, Copy, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct StateSnapshotProgress {
    pub key_hash: HashValue,
    pub usage: StateStorageUsage,
    pub restore_mode: Option<StateSnapshotRestoreMode>, // New field
}
```

Add validation in `StateSnapshotRestore::new()`:

```rust
// In storage/aptosdb/src/state_restore/mod.rs
pub fn new<T: 'static + TreeReader<K> + TreeWriter<K>, S: 'static + StateValueWriter<K, V>>(
    tree_store: &Arc<T>,
    value_store: &Arc<S>,
    version: Version,
    expected_root_hash: HashValue,
    async_commit: bool,
    restore_mode: StateSnapshotRestoreMode,
) -> Result<Self> {
    // Check for existing progress and validate mode consistency
    if let Some(progress) = value_store.get_progress(version)? {
        if let Some(previous_mode) = progress.restore_mode {
            ensure!(
                previous_mode == restore_mode,
                "Cannot switch restore mode from {:?} to {:?} during resume. \
                 Either complete the restore with the original mode or reset progress.",
                previous_mode,
                restore_mode
            );
        }
    }
    
    // ... rest of initialization
}
```

Update progress writes to include the mode:

```rust
// When calling write_kv_batch, include the current restore_mode
StateSnapshotProgress::new(last_key_hash, usage, Some(self.restore_mode))
```

## Proof of Concept

```rust
#[test]
fn test_mode_switching_vulnerability() {
    use crate::state_restore::{StateSnapshotRestore, StateSnapshotRestoreMode};
    use std::sync::Arc;
    
    // Setup mock data with 10 key-value pairs
    let all_kvs: BTreeMap<HashValue, (ValueBlob, ValueBlob)> = 
        (0..10).map(|i| {
            let k = ValueBlob(vec![i]);
            let v = ValueBlob(vec![i + 100]);
            (CryptoHash::hash(&k), (k, v))
        }).collect();
    
    let (source_db, version) = init_mock_store(&all_kvs.clone().into_values().collect());
    let tree = JellyfishMerkleTree::new(&source_db);
    let expected_root_hash = tree.get_root_hash(version).unwrap();
    
    // Split into two batches
    let batch1: Vec<_> = all_kvs.clone().into_iter().take(5).collect();
    let batch2: Vec<_> = all_kvs.clone().into_iter().skip(5).collect();
    
    let restore_db = Arc::new(MockSnapshotStore::default());
    
    // Phase 1: Restore first 5 items with TreeOnly mode
    {
        let mut restore = StateSnapshotRestore::new(
            &restore_db, 
            &restore_db,
            version, 
            expected_root_hash,
            false,
            StateSnapshotRestoreMode::TreeOnly  // Tree ONLY
        ).unwrap();
        
        let proof = tree.get_range_proof(batch1.last().map(|(k, _)| *k).unwrap(), version).unwrap();
        restore.add_chunk(batch1.into_iter().map(|(_, kv)| kv).collect(), proof).unwrap();
        // Simulate interruption - don't call finish()
    }
    
    // Phase 2: Resume with remaining items using KvOnly mode (MODE SWITCH!)
    {
        let mut restore = StateSnapshotRestore::new(
            &restore_db,
            &restore_db, 
            version,
            expected_root_hash,
            false,
            StateSnapshotRestoreMode::KvOnly  // KV ONLY - DIFFERENT MODE!
        ).unwrap();
        
        let proof = tree.get_range_proof(batch2.last().map(|(k, _)| *k).unwrap(), version).unwrap();
        restore.add_chunk(batch2.into_iter().map(|(_, kv)| kv).collect(), proof).unwrap();
        restore.finish().unwrap();
    }
    
    // Verify the vulnerability: inconsistent state
    // First 5 keys should be in tree but NOT in KV
    for (i, (hash, (key, value))) in all_kvs.iter().take(5).enumerate() {
        // Check tree has it
        let tree = JellyfishMerkleTree::new(&*restore_db);
        let tree_result = tree.get_with_proof(CryptoHash::hash(key), version);
        assert!(tree_result.is_ok(), "Key {} should exist in tree", i);
        
        // Check KV does NOT have it
        let kv_result = restore_db.get_value_at_version(&(key.clone(), version));
        assert!(kv_result.is_none(), "Key {} should NOT exist in KV store", i);
    }
    
    // Last 5 keys should be in KV but NOT in tree
    for (i, (hash, (key, value))) in all_kvs.iter().skip(5).enumerate() {
        // Check KV has it
        let kv_result = restore_db.get_value_at_version(&(key.clone(), version));
        assert!(kv_result.is_some(), "Key {} should exist in KV store", i + 5);
        
        // Check tree does NOT have it (or has incorrect state)
        // This would fail merkle proof verification
    }
    
    println!("VULNERABILITY CONFIRMED: State is inconsistent between KV and Tree!");
}
```

## Notes

This vulnerability requires access to the node's restore process but does not require validator privileges. The issue stems from the design decision to track progress separately for KV and tree components while allowing the restore mode to be freely changed between resume sessions. The fix requires coordinating the mode tracking with the progress persistence mechanism to ensure consistency is maintained throughout the entire restore operation.

### Citations

**File:** storage/aptosdb/src/state_restore/mod.rs (L49-57)
```rust
#[derive(Clone, Copy, Deserialize, Serialize, PartialEq, Eq)]
pub enum StateSnapshotRestoreMode {
    /// Restore both KV and Tree by default
    Default,
    /// Only restore the state KV
    KvOnly,
    /// Only restore the state tree
    TreeOnly,
}
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L196-213)
```rust
    pub fn previous_key_hash(&self) -> Result<Option<HashValue>> {
        let hash_opt = match (
            self.kv_restore
                .lock()
                .as_ref()
                .unwrap()
                .previous_key_hash()?,
            self.tree_restore
                .lock()
                .as_ref()
                .unwrap()
                .previous_key_hash(),
        ) {
            (None, hash_opt) => hash_opt,
            (hash_opt, None) => hash_opt,
            (Some(hash1), Some(hash2)) => Some(std::cmp::min(hash1, hash2)),
        };
        Ok(hash_opt)
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L246-255)
```rust
        match self.restore_mode {
            StateSnapshotRestoreMode::KvOnly => kv_fn()?,
            StateSnapshotRestoreMode::TreeOnly => tree_fn()?,
            StateSnapshotRestoreMode::Default => {
                // We run kv_fn with TreeOnly to restore the usage of DB
                let (r1, r2) = IO_POOL.join(kv_fn, tree_fn);
                r1?;
                r2?;
            },
        }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L57-58)
```rust
    #[clap(long)]
    pub restore_mode: StateSnapshotRestoreMode,
```

**File:** storage/indexer_schemas/src/metadata.rs (L46-49)
```rust
pub struct StateSnapshotProgress {
    pub key_hash: HashValue,
    pub usage: StateStorageUsage,
}
```
