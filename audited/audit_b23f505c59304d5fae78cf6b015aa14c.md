# Audit Report

## Title
Race Condition in Resource Group Base Value Initialization Causes State Inconsistency

## Summary
The `set_raw_base_values()` function in `versioned_group_data.rs` performs non-atomic initialization of resource group data structures, allowing concurrent readers to observe a partially initialized state where the group appears initialized but values are missing, resulting in incorrect `TagNotFound` errors and potential state corruption.

## Finding Description

The vulnerability exists in the `set_raw_base_values()` function which initializes resource group base values from storage into the multi-versioned data structure used during parallel block execution. [1](#0-0) 

The critical flaw is that the function creates an entry in the `group_sizes` DashMap at line 155, which immediately makes the group appear "initialized" to concurrent readers, but doesn't write the actual tag values until lines 176-181. This creates a race window where:

1. Writer thread calls `self.group_sizes.entry(group_key.clone()).or_default()` which creates/gets the DashMap entry
2. The group is now considered initialized because `group_sizes.contains_key(group_key)` returns true
3. Writer inserts the size entry (line 173)
4. **RACE WINDOW OPENS** 
5. Reader thread checks initialization via `self.group_sizes.contains_key(group_key)` and sees `true`
6. Reader attempts to fetch tag data but values haven't been written yet
7. Reader receives `MVDataError::Uninitialized` which gets converted to `MVGroupError::TagNotFound` because the group appears initialized [2](#0-1) 

The reader-side logic explicitly checks if the group is initialized before fetching data: [3](#0-2) 

When a reader observes `initialized=true` but gets `MVDataError::Uninitialized`, the `convert_tagged_data` function incorrectly returns `MVGroupError::TagNotFound` instead of `MVGroupError::Uninitialized`.

This error propagates to the view layer where `TagNotFound` is interpreted as a legitimate missing tag, causing the system to record an empty base value: [4](#0-3) 

The comments in the code acknowledge this ordering issue but incorrectly state "we always write size after data": [5](#0-4) 

However, in `set_raw_base_values()`, the actual implementation writes size BEFORE data, contradicting the assumption.

## Impact Explanation

**Severity: Medium**

This vulnerability causes **state inconsistencies requiring intervention**, matching the Medium severity category:

1. **Non-Deterministic Execution**: Different validators may observe different states depending on race timing, potentially causing consensus divergence
2. **Incorrect State Reads**: Valid base values can be incorrectly overwritten with empty values, causing transactions to read incorrect resource states
3. **Transaction Execution Failures**: Transactions expecting valid resource group data may fail or behave incorrectly when they encounter empty values
4. **Validation Failures**: Block-STM validation may detect inconsistencies and force re-execution, degrading performance

While this doesn't directly cause fund loss or permanent consensus failure, it violates the **State Consistency** and **Deterministic Execution** invariants, requiring manual intervention to detect and resolve the inconsistency.

## Likelihood Explanation

**Likelihood: High**

The race condition occurs during normal parallel block execution whenever:
1. Multiple transactions concurrently access the same resource group
2. One transaction initializes the group from storage via `initialize_mvhashmap_base_group_contents()`
3. Another transaction attempts to read from that group during the initialization window [6](#0-5) 

Given that:
- Parallel execution is the default mode for block processing
- Resource groups are commonly used in Aptos (e.g., for account resources)
- The race window spans multiple operations (size computation, tag insertion, value writes)
- High transaction throughput increases concurrent access probability

This race condition is highly likely to occur in production environments processing blocks with high parallelism.

## Recommendation

**Fix: Ensure atomic initialization by holding the lock throughout the entire initialization**

The issue can be resolved by ensuring that the group is not visible as "initialized" to readers until ALL data structures (size, tags, and values) have been written. This can be achieved by:

1. Write values FIRST while holding the sizes lock (as the comments claim)
2. Only mark the group as initialized AFTER all values are written
3. Consider using a separate initialization flag that's set atomically at the end

**Proposed fix:**

```rust
pub fn set_raw_base_values(
    &self,
    group_key: K,
    base_values: Vec<(T, V)>,
) -> anyhow::Result<()> {
    // Acquire lock on group_sizes entry
    let mut group_sizes = self.group_sizes.entry(group_key.clone()).or_default();

    if let Vacant(entry) = group_sizes.size_entries.entry(ShiftedTxnIndex::zero_idx()) {
        // Compute group size
        let group_size = group_size_as_sum::<T>(
            base_values
                .iter()
                .flat_map(|(tag, value)| value.bytes().map(|b| (tag.clone(), b.len()))),
        )
        .map_err(|e| {
            anyhow!(
                "Tag serialization error in resource group at {:?}: {:?}",
                group_key.clone(),
                e
            )
        })?;

        // CRITICAL: Write values AND tags FIRST while holding the sizes lock
        let mut superset_tags = self.group_tags.entry(group_key.clone()).or_default();
        for (tag, value) in base_values.into_iter() {
            superset_tags.insert(tag.clone());
            self.values.set_base_value(
                (group_key.clone(), tag),
                ValueWithLayout::RawFromStorage(Arc::new(value)),
            );
        }
        
        // ONLY THEN insert size entry, making the group "initialized"
        // This ensures readers never see initialized=true without values
        entry.insert(SizeEntry::new(SizeAndDependencies::from_size(group_size)));
    }

    Ok(())
}
```

The key change is moving the size entry insertion (line 173 in original) to be the LAST operation after all values and tags are written. This ensures readers checking `group_sizes.contains_key()` will only see the group as initialized after all data is ready.

## Proof of Concept

```rust
// Rust concurrent test demonstrating the race condition
#[cfg(test)]
mod race_condition_test {
    use super::*;
    use std::sync::{Arc, Barrier};
    use std::thread;
    
    #[test]
    fn test_initialization_race() {
        let group_data = Arc::new(VersionedGroupData::<KeyType, usize, TestValue>::empty());
        let group_key = KeyType(b"/test/group".to_vec());
        let tag = 1usize;
        let base_value = TestValue::creation_with_len(100);
        
        // Barrier to synchronize threads at the race window
        let barrier = Arc::new(Barrier::new(2));
        let group_data_clone = Arc::clone(&group_data);
        let group_key_clone = group_key.clone();
        let barrier_clone = Arc::clone(&barrier);
        
        // Writer thread: Initialize the group
        let writer = thread::spawn(move || {
            // Wait at barrier before writing values
            barrier_clone.wait();
            group_data_clone.set_raw_base_values(
                group_key_clone,
                vec![(tag, base_value.clone())]
            ).unwrap();
        });
        
        // Reader thread: Try to read immediately after initialization starts
        let reader = thread::spawn(move || {
            barrier.wait();
            // Small delay to hit the race window
            std::thread::sleep(std::time::Duration::from_micros(1));
            
            // Attempt to read - should get either Uninitialized OR valid data
            // But may incorrectly get TagNotFound due to race
            let result = group_data.fetch_tagged_data_no_record(
                &group_key,
                &tag,
                0  // txn_idx 0 reads from storage
            );
            
            result
        });
        
        writer.join().unwrap();
        let read_result = reader.join().unwrap();
        
        // The race condition manifests as TagNotFound when it should be
        // either Uninitialized (if before init) or Ok with data (if after init)
        match read_result {
            Err(MVGroupError::TagNotFound) => {
                panic!("RACE CONDITION DETECTED: Got TagNotFound for valid base value!");
            },
            Ok(_) | Err(MVGroupError::Uninitialized) => {
                // These are acceptable outcomes
            },
            _ => {}
        }
    }
}
```

## Notes

The vulnerability is exacerbated by the fact that the code comments explicitly state the opposite of what the implementation does. The comments claim "we always write size after data" but the code writes size before data, creating confusion and making the bug harder to spot during code review.

This issue affects the core parallel execution engine (Block-STM) and could impact consensus if different validators observe different race outcomes, though the validation phase should catch most discrepancies. However, the performance impact of forced re-executions and the potential for transient state inconsistencies make this a legitimate Medium severity issue requiring a fix.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L150-186)
```rust
    pub fn set_raw_base_values(
        &self,
        group_key: K,
        base_values: Vec<(T, V)>,
    ) -> anyhow::Result<()> {
        let mut group_sizes = self.group_sizes.entry(group_key.clone()).or_default();

        // Currently the size & value are written while holding the sizes lock.
        if let Vacant(entry) = group_sizes.size_entries.entry(ShiftedTxnIndex::zero_idx()) {
            // Perform group size computation if base not already provided.
            let group_size = group_size_as_sum::<T>(
                base_values
                    .iter()
                    .flat_map(|(tag, value)| value.bytes().map(|b| (tag.clone(), b.len()))),
            )
            .map_err(|e| {
                anyhow!(
                    "Tag serialization error in resource group at {:?}: {:?}",
                    group_key.clone(),
                    e
                )
            })?;

            entry.insert(SizeEntry::new(SizeAndDependencies::from_size(group_size)));

            let mut superset_tags = self.group_tags.entry(group_key.clone()).or_default();
            for (tag, value) in base_values.into_iter() {
                superset_tags.insert(tag.clone());
                self.values.set_base_value(
                    (group_key.clone(), tag),
                    ValueWithLayout::RawFromStorage(Arc::new(value)),
                );
            }
        }

        Ok(())
    }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L415-433)
```rust
    pub fn fetch_tagged_data_no_record(
        &self,
        group_key: &K,
        tag: &T,
        txn_idx: TxnIndex,
    ) -> Result<(Version, ValueWithLayout<V>), MVGroupError> {
        let key_ref = GroupKeyRef { group_key, tag };

        // We are accessing group_sizes and values non-atomically, hence the order matters.
        // It is important that initialization check happens before fetch data below. O.w.
        // we could incorrectly get a TagNotFound error (do not find data, but then find
        // size initialized in between the calls). In fact, we always write size after data,
        // and sometimes (e.g. during initialization) even hold the sizes lock during writes.
        // It is fine to observe initialized = false, but find data, in convert_tagged_data.
        let initialized = self.group_sizes.contains_key(group_key);

        let data_value = self.values.fetch_data_no_record(&key_ref, txn_idx);
        self.convert_tagged_data(data_value, initialized)
    }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L676-695)
```rust
    fn convert_tagged_data(
        &self,
        data_value: anyhow::Result<MVDataOutput<V>, MVDataError>,
        initialized: bool,
    ) -> Result<(Version, ValueWithLayout<V>), MVGroupError> {
        match data_value {
            Ok(MVDataOutput::Versioned(version, value)) => Ok((version, value)),
            Err(MVDataError::Uninitialized) => Err(if initialized {
                MVGroupError::TagNotFound
            } else {
                MVGroupError::Uninitialized
            }),
            Err(MVDataError::Dependency(dep_idx)) => Err(MVGroupError::Dependency(dep_idx)),
            Ok(MVDataOutput::Resolved(_))
            | Err(MVDataError::Unresolved(_))
            | Err(MVDataError::DeltaApplicationFailure) => {
                unreachable!("Not using aggregatorV1")
            },
        }
    }
```

**File:** aptos-move/block-executor/src/view.rs (L815-828)
```rust
                Err(TagNotFound) => {
                    // TagNotFound means group was initialized (o.w. Uninitialized branch
                    // would be visited), but the tag didn't exist. So record an empty resource
                    // as a base value, and do continue to retry the read.
                    self.versioned_map
                        .group_data()
                        .update_tagged_base_value_with_layout(
                            group_key.clone(),
                            resource_tag.clone(),
                            TransactionWrite::from_state_value(None),
                            None,
                        );
                    continue;
                },
```

**File:** aptos-move/block-executor/src/view.rs (L1586-1619)
```rust
    fn initialize_mvhashmap_base_group_contents(&self, group_key: &T::Key) -> PartialVMResult<()> {
        let (base_group, metadata_op): (BTreeMap<T::Tag, Bytes>, _) =
            match self.get_raw_base_value(group_key)? {
                Some(state_value) => (
                    bcs::from_bytes(state_value.bytes()).map_err(|e| {
                        PartialVMError::new(StatusCode::UNEXPECTED_DESERIALIZATION_ERROR)
                            .with_message(format!(
                                "Failed to deserialize the resource group at {:?}: {:?}",
                                group_key, e
                            ))
                    })?,
                    TransactionWrite::from_state_value(Some(state_value)),
                ),
                None => (BTreeMap::new(), TransactionWrite::from_state_value(None)),
            };
        let base_group_sentinel_ops = base_group
            .into_iter()
            .map(|(t, bytes)| {
                (
                    t,
                    TransactionWrite::from_state_value(Some(StateValue::new_legacy(bytes))),
                )
            })
            .collect();

        self.latest_view
            .get_resource_group_state()
            .set_raw_group_base_values(group_key.clone(), base_group_sentinel_ops)?;
        self.latest_view.get_resource_state().set_base_value(
            group_key.clone(),
            ValueWithLayout::RawFromStorage(TriompheArc::new(metadata_op)),
        );
        Ok(())
    }
```
