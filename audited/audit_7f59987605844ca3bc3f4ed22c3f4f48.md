# Audit Report

## Title
Paranoid Type Check Failures Commit Invalid State Due to CHARGE_INVARIANT_VIOLATION Feature Flag

## Summary
The `paranoid_failure!` macro creates errors with `EPARANOID_FAILURE` sub-status that should halt execution when type safety invariants are violated. However, when the `CHARGE_INVARIANT_VIOLATION` feature flag is enabled (which is the default), these critical failures result in transactions being **kept and committed** to the blockchain rather than discarded, allowing invalid state transitions that violate Move's type safety guarantees. [1](#0-0) 

## Finding Description

The vulnerability chain consists of the following components:

**1. Paranoid Failure Macro Definition:**
The `paranoid_failure!` macro creates a `PartialVMError` with `UNKNOWN_INVARIANT_VIOLATION_ERROR` status and `EPARANOID_FAILURE` sub-status (value 0x1). [2](#0-1) 

**2. Paranoid Checks Throughout the VM:**
These checks are used extensively to validate type safety at runtime, including `paranoid_check_assignable`, `paranoid_check_eq`, `paranoid_check_is_bool_ty`, and others. When these checks fail, they call the `paranoid_failure!` macro. [3](#0-2) 

**3. Error Propagation:**
Paranoid failures propagate through the VM execution stack using the `?` operator, eventually becoming a `VMStatus` error. [4](#0-3) 

**4. Transaction Status Conversion with CHARGE_INVARIANT_VIOLATION:**
When converting `VMStatus` to `TransactionStatus`, if the status is an `InvariantViolation` AND the `CHARGE_INVARIANT_VIOLATION` feature flag is enabled, the transaction is **kept** rather than discarded: [5](#0-4) 

**5. Feature Flag Enabled by Default:**
The `CHARGE_INVARIANT_VIOLATION` flag is in the default features list and enabled at genesis: [6](#0-5) 

**6. Kept Transactions Are Committed:**
Transactions with `TransactionStatus::Keep` status have their state changes committed to the blockchain: [7](#0-6) 

**7. Test Confirmation:**
The test suite explicitly confirms this behavior - with `CHARGE_INVARIANT_VIOLATION` enabled, invariant violations are kept: [8](#0-7) 

## Impact Explanation

This is a **Critical Severity** vulnerability for multiple reasons:

**1. Violates Deterministic Execution Invariant:**
Paranoid checks are designed to catch conditions that should be impossible in correct execution. When they fail, it indicates memory corruption, bytecode verifier bugs, or other serious issues. Different validators may encounter these failures under different conditions (timing, memory state, JIT compilation state), leading to non-deterministic execution where some validators commit the transaction while others might not, causing **consensus splits**.

**2. Type Safety Violations Committed to Chain:**
Move's type safety is a fundamental security guarantee. By allowing transactions that fail paranoid type checks to commit, the blockchain can enter states that violate Move's type system invariants, potentially enabling:
- Invalid memory access patterns
- Type confusion attacks
- Bypassing access control checks that depend on type safety

**3. State Corruption:**
Once invalid state is committed, subsequent transactions may behave unpredictably when interacting with the corrupted state, cascading the damage.

**4. Attack Surface:**
An attacker who discovers a way to craft bytecode that passes the verifier but triggers paranoid runtime checks can exploit this to:
- Commit invalid state transitions
- Bypass Move's safety guarantees
- Potentially steal or manipulate funds if the type confusion enables unauthorized resource access [9](#0-8) 

## Likelihood Explanation

**Likelihood: High**

1. **Feature Enabled by Default:** The `CHARGE_INVARIANT_VIOLATION` flag is enabled on all networks including mainnet
2. **Multiple Attack Vectors:** There are numerous paranoid checks throughout the codebase (27+ in runtime_types.rs alone) that could potentially be triggered
3. **Bytecode Complexity:** The Move verifier is complex, and there may be edge cases where bytecode passes verification but triggers paranoid runtime checks
4. **JIT Compilation:** With different execution modes (interpreted vs JIT), subtle differences could cause paranoid checks to fail non-deterministically

While crafting specific bytecode to trigger this requires deep VM knowledge, the impact is severe enough that even low-probability exploitation is critical.

## Recommendation

**Immediate Fix:**
The `CHARGE_INVARIANT_VIOLATION` feature flag should be disabled by default, or paranoid failures should be explicitly excluded from the "keep" logic:

```rust
// In types/src/transaction/mod.rs, modify from_vm_status function:

pub fn from_vm_status(
    vm_status: VMStatus,
    features: &Features,
    memory_limit_exceeded_as_miscellaneous_error: bool,
) -> Self {
    let status_code = vm_status.status_code();
    match vm_status.keep_or_discard(
        features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES),
        memory_limit_exceeded_as_miscellaneous_error,
        features.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10),
    ) {
        Ok(recorded) => match recorded {
            KeptVMStatus::MiscellaneousError => {
                Self::Keep(ExecutionStatus::MiscellaneousError(Some(status_code)))
            },
            _ => Self::Keep(recorded.into()),
        },
        Err(code) => {
            // SECURITY FIX: Never keep transactions with paranoid failures
            if code.status_type() == StatusType::InvariantViolation {
                // Check if this is a paranoid failure specifically
                if matches!(
                    vm_status.sub_status(),
                    Some(unknown_invariant_violation::EPARANOID_FAILURE
                        | unknown_invariant_violation::EREFERENCE_COUNTING_FAILURE
                        | unknown_invariant_violation::EREFERENCE_SAFETY_FAILURE
                        | unknown_invariant_violation::EINDEXED_REF_TAG_MISMATCH)
                ) {
                    // Always discard paranoid failures regardless of feature flag
                    return Self::Discard(code);
                }
                
                if features.is_enabled(FeatureFlag::CHARGE_INVARIANT_VIOLATION) {
                    Self::Keep(ExecutionStatus::MiscellaneousError(Some(code)))
                } else {
                    Self::Discard(code)
                }
            } else {
                Self::Discard(code)
            }
        },
    }
}
```

**Long-term Fix:**
1. Conduct thorough audit of all paranoid checks to ensure they represent true invariants
2. Add determinism tests to ensure paranoid checks behave identically across all validator configurations
3. Consider adding a separate feature flag specifically for paranoid checks
4. Implement consensus-level verification that all validators agree on paranoid check outcomes

## Proof of Concept

```rust
// This PoC demonstrates that paranoid failures are kept when 
// CHARGE_INVARIANT_VIOLATION is enabled

use aptos_language_e2e_tests::{executor::FakeExecutor};
use aptos_types::{
    on_chain_config::FeatureFlag,
    transaction::{ExecutionStatus, TransactionStatus},
};
use move_core_types::vm_status::StatusCode;

#[test]
fn test_paranoid_failure_committed_with_charge_flag() {
    let _scenario = fail::FailScenario::setup();
    
    // This fail point injects a paranoid failure with EPARANOID_FAILURE sub-status
    fail::cfg("aptos_vm::execute_script_or_entry_function", "100%return").unwrap();

    let mut executor = FakeExecutor::from_head_genesis();
    let sender = executor.create_raw_account_data(1_000_000, 10);
    let receiver = executor.create_raw_account_data(100_000, 10);
    executor.add_account_data(&sender);
    executor.add_account_data(&receiver);

    let txn = create_transfer_transaction(&sender, &receiver);
    let output = executor.execute_transaction(txn);

    // VULNERABILITY: With CHARGE_INVARIANT_VIOLATION enabled (default),
    // paranoid failures result in Keep status, committing invalid state
    assert_eq!(
        output.status(),
        &TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(Some(
            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
        ))),
    );
    
    // The transaction's state changes are committed despite the paranoid failure!
    assert!(!output.write_set().is_empty());
}
```

## Notes

The logging in `aptos_vm.rs` shows awareness of this issue with the comment "Paranoid mode failure. We need to be alerted about this ASAP" but only logs the error without preventing the transaction from being committed. This suggests the original intent may have been to detect rare edge cases, but the implementation allows potentially exploitable conditions to persist on-chain, violating the fundamental deterministic execution invariant of the blockchain.

### Citations

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L424-432)
```rust
macro_rules! paranoid_failure {
    ($msg:ident) => {
        Err(
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message($msg)
                .with_sub_status(EPARANOID_FAILURE),
        )
    };
}
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L487-493)
```rust
    pub fn paranoid_check_is_no_ref(&self, msg: &str) -> PartialVMResult<()> {
        if matches!(self, Type::Reference(_) | Type::MutableReference(_)) {
            let msg = format!("{} `{}` cannot be a reference", msg, self);
            return paranoid_failure!(msg);
        }
        Ok(())
    }
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L1119-1121)
```rust
    pub mod unknown_invariant_violation {
        /// Paranoid Type checking returns an error
        pub const EPARANOID_FAILURE: u64 = 0x1;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L976-980)
```rust
                    ty.paranoid_check_assignable(&expected_ty)?;
                } else {
                    // Directly check against the expected type to save a clone here.
                    ty.paranoid_check_assignable(expected_ty)?;
                }
```

**File:** types/src/transaction/mod.rs (L1640-1646)
```rust
                if code.status_type() == StatusType::InvariantViolation
                    && features.is_enabled(FeatureFlag::CHARGE_INVARIANT_VIOLATION)
                {
                    Self::Keep(ExecutionStatus::MiscellaneousError(Some(code)))
                } else {
                    Self::Discard(code)
                }
```

**File:** types/src/on_chain_config/aptos_features.rs (L194-194)
```rust
            FeatureFlag::CHARGE_INVARIANT_VIOLATION,
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L473-481)
```rust
            match transaction_outputs[idx].status() {
                TransactionStatus::Keep(_) => {
                    if num_keep_txns != idx {
                        transactions[num_keep_txns] = transactions[idx].clone();
                        transaction_outputs[num_keep_txns] = transaction_outputs[idx].clone();
                        persisted_auxiliary_infos[num_keep_txns] = persisted_auxiliary_infos[idx];
                    }
                    num_keep_txns += 1;
                },
```

**File:** aptos-move/e2e-testsuite/src/tests/invariant_violation.rs (L33-39)
```rust
    // CHARGE_INVARIANT_VIOLATION enabled at genesis so this txn is kept.
    assert_eq!(
        output.status(),
        &TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(Some(
            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
        ))),
    );
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2946-2957)
```rust
                        // Paranoid mode failure. We need to be alerted about this ASAP.
                        StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                        if vm_status.sub_status()
                            == Some(unknown_invariant_violation::EPARANOID_FAILURE) =>
                            {
                                error!(
                                *log_context,
                                "[aptos_vm] Transaction breaking paranoid mode: {:?}\ntxn: {:?}",
                                vm_status,
                                bcs::to_bytes::<SignedTransaction>(txn),
                            );
                            },
```
