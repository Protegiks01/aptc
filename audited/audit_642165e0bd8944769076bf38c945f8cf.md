# Audit Report

## Title
Currency Confusion in Lazy Account Creation Fee Validation Allows Underpayment for Storage Fees

## Summary
A critical currency confusion bug in the failed transaction cleanup path double-counts storage fees when validating minimum account creation fees. The validation check incorrectly adds storage fees (in Octa) on top of gas_used (which already includes storage fees converted to gas units), allowing transactions to bypass minimum fee requirements and create accounts while paying approximately half the required storage fees.

## Finding Description

The vulnerability exists in the `finish_aborted_transaction` function where lazy account creation is performed during transaction abort. The fee validation check uses an incorrect formula that mixes Fee (Octa-denominated) and Gas (gas-unit-denominated) values: [1](#0-0) 

The check computes:
```
actual = gas_used * gas_unit_price + storage_fee - storage_refund
```

However, according to the FeeStatement documentation, `gas_used` (also called `total_charge_gas_units`) **already includes** storage fees converted to gas units: [2](#0-1) 

This is confirmed by the gas algebra consistency check, which shows that total gas consumed equals execution + io + storage_fee_in_internal_units: [3](#0-2) 

The storage fee conversion logic converts Fee (Octa) to InternalGas using the gas_unit_price: [4](#0-3) 

**Exploitation Path:**

1. Attacker submits a transaction from a new account (sequence number 0) that will abort
2. The transaction enters `finish_aborted_transaction` and triggers lazy account creation
3. The `charge_change_set` call charges storage fees, updating both:
   - `storage_fee_used` (in Octa)
   - `storage_fee_in_internal_units` (in InternalGas, approximately `storage_fee_used / gas_unit_price`)
4. `gas_used` is calculated as `max_gas_amount - balance`, which includes the converted storage fees
5. The buggy validation check at line 767 computes:
   ```
   actual = gas_used * gas_unit_price + storage_fee - storage_refund
          ≈ (exec + io + storage_fee/price) * price + storage_fee - refund
          ≈ exec*price + io*price + storage_fee + storage_fee - refund
          = exec*price + io*price + 2*storage_fee - refund
   ```
6. The check compares `actual >= expected`, where `expected` is the minimum account creation fee
7. Due to double-counting, the check passes even when only ~50% of the required storage fee was actually charged

**Concrete Example:**
- Expected minimum account creation fee: 2000 Octa
- Gas unit price: 100 Octa/gas
- Attacker sets max_gas_amount to charge only 1300 Octa (13 gas units)
- Of this, suppose 1000 Octa is storage fee, 300 Octa is execution/IO
- gas_used = 3 (exec/io) + 10 (storage converted) = 13 gas units
- Buggy check: 13 * 100 + 1000 - 0 = 2300 Octa >= 2000 ✓ (PASSES)
- Actual charged: 13 * 100 = 1300 Octa < 2000 ✗ (SHOULD FAIL)

The attacker creates an account while paying only 1300 Octa instead of the required 2000 Octa minimum.

## Impact Explanation

This vulnerability qualifies as **Medium to High Severity**:

**Medium Severity** (per Aptos Bug Bounty):
- **Limited funds loss**: The protocol loses expected storage fees. Each exploited account creation saves the attacker approximately 50% of the minimum storage fee (currently ~50,000-100,000 Octa or 0.0005-0.001 APT per account based on gas parameters)
- **State inconsistencies**: Allows creation of account resources without proper economic deterrence, potentially enabling storage spam attacks

**Potentially High Severity**:
- **Significant protocol violation**: Breaks the fundamental invariant that "all operations must respect gas, storage, and computational limits"
- **Economic attack vector**: An attacker could create thousands of accounts at half-price, potentially:
  - Bloating state size while underpaying for storage
  - Conducting spam attacks more economically
  - Undermining the economic security model of storage pricing

The impact is limited by:
- Only affects lazy account creation in failed transactions
- Attacker still pays some fee (approximately 50% instead of 100%)
- Each account creation has a base cost even with the exploit

## Likelihood Explanation

**High Likelihood**:

The vulnerability is **easily exploitable** because:
1. **Common trigger condition**: Lazy account creation occurs whenever a new user submits their first transaction, which is a normal operation
2. **No special privileges required**: Any user can trigger this by sending a transaction from a new address
3. **Deterministic exploit**: Attacker can precisely calculate the required max_gas_amount to underpay while passing the check
4. **No rate limiting**: An attacker can create multiple accounts to exploit this repeatedly

The exploitation is straightforward:
1. Create new account addresses
2. Calculate minimum gas required to pass the buggy check (approximately 50% of true minimum)
3. Submit transactions that will abort (e.g., invalid script, division by zero)
4. Accounts get created at half price

## Recommendation

Fix the fee validation formula to remove the double-counted storage fee. The correct formula should be:

```rust
let actual = gas_used * gas_unit_price - storage_refund;
```

Since `gas_used` already includes storage fees converted to gas units, there's no need to add `storage_fee` again. The correct net fee charged is simply `gas_used * gas_unit_price - storage_refund`, which matches the epilogue calculation: [5](#0-4) 

**Recommended Fix:**

Change line 767 in `aptos-move/aptos-vm/src/aptos_vm.rs` from:
```rust
let actual = gas_used * gas_unit_price + storage_fee - storage_refund;
```

To:
```rust
let actual = gas_used * gas_unit_price - storage_refund;
```

This aligns the validation check with the documented FeeStatement semantics and prevents the double-counting of storage fees.

## Proof of Concept

The following Rust test demonstrates the vulnerability by showing that the buggy check would pass with insufficient fees:

```rust
#[test]
fn test_lazy_account_creation_fee_double_counting() {
    // Scenario: Expected minimum fee is 2000 Octa
    let expected_min_fee_octas = 2000_u64;
    let gas_unit_price = 100_u64; // 100 Octa per gas unit
    
    // Attacker crafts transaction to pay only 1300 Octa
    let execution_gas_units = 3_u64;
    let io_gas_units = 0_u64;
    let storage_fee_octas = 1000_u64;
    
    // Storage fee converted to gas units (rounded up)
    let storage_fee_gas_units = (storage_fee_octas + gas_unit_price - 1) / gas_unit_price; // ceil(1000/100) = 10
    
    // Total gas used includes storage fee
    let gas_used = execution_gas_units + io_gas_units + storage_fee_gas_units; // 3 + 0 + 10 = 13
    
    // Actual fee charged to user
    let actual_charged = gas_used * gas_unit_price; // 13 * 100 = 1300 Octa
    
    // Correct validation (should fail)
    let correct_check = actual_charged; // 1300 Octa
    assert!(correct_check < expected_min_fee_octas, "Should fail: only paid 1300 < 2000");
    
    // Buggy validation (incorrectly passes)
    let buggy_check = gas_used * gas_unit_price + storage_fee_octas; // 1300 + 1000 = 2300 Octa
    assert!(buggy_check >= expected_min_fee_octas, "Bug: passes with 2300 >= 2000 despite only charging 1300");
    
    println!("Exploit successful: Account created with {} Octa instead of required {} Octa", 
             actual_charged, expected_min_fee_octas);
}
```

To exploit this in practice, an attacker would:
1. Calculate `expected_min_fee` from `hack_account_creation_fee_lower_bound()`
2. Set `max_gas_amount` such that `(max_gas_amount * gas_unit_price + expected_storage_fee) >= expected_min_fee` while `max_gas_amount * gas_unit_price < expected_min_fee`
3. Submit a transaction from a new address (sequence 0) that will abort
4. The account gets created despite underpaying for storage

## Notes

This vulnerability is a textbook example of currency confusion between denominated units. The Aptos codebase uses strong type safety with `Fee = GasQuantity<Octa>` and `Gas = GasQuantity<GasUnit>` to prevent such errors, but the conversion between these units in the validation check was implemented incorrectly.

The bug has existed since the lazy account creation feature was introduced and affects all transactions that trigger account creation during abort. Given that creating new accounts is a common operation and the exploit is trivial to execute, this should be patched urgently.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L767-767)
```rust
                let actual = gas_used * gas_unit_price + storage_fee - storage_refund;
```

**File:** types/src/fee_statement.rs (L19-21)
```rust
///        - storage fee charge (storage space): `storage_fee_octas`, to be included in
///          `total_charge_gas_unit`, this number is converted to gas units according to the user
///          specified `gas_unit_price` on the transaction.
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L152-153)
```rust
        let total_calculated =
            self.execution_gas_used + self.io_gas_used + self.storage_fee_in_internal_units;
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L260-263)
```rust
        let gas_consumed_internal = div_ceil(
            (u64::from(amount) as u128) * (u64::from(txn_params.gas_unit_scaling_factor) as u128),
            u64::from(gas_unit_price) as u128,
        );
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L813-819)
```text
        let gas_used = txn_max_gas_units - gas_units_remaining;

        assert!(
            (txn_gas_price as u128) * (gas_used as u128) <= MAX_U64,
            error::out_of_range(EOUT_OF_GAS)
        );
        let transaction_fee_amount = txn_gas_price * gas_used;
```
