# Audit Report

## Title
Event V2 Translation TOCTOU Vulnerability Causes Silent Event Loss During Indexer Catchup

## Summary
The `DBIndexer::translate_event_v2_to_v1()` function contains a Time-of-Check-Time-of-Use (TOCTOU) vulnerability that causes event data loss when the indexer processes historical transactions. The translator reads the **current** blockchain state to translate events from the **past**, causing translation failures when required resources have been deleted between event emission and indexer processing. [1](#0-0) 

## Finding Description
The event V2 translation system has a fundamental timing flaw. When translating V2 events to V1 format, the translator must read on-chain resources (like `CoinStore`, `TokenStore`, `CollectionResource`) to determine the event key and sequence number. However, it reads these resources from the **latest state checkpoint**, not from the historical state when the event was emitted. [2](#0-1) [3](#0-2) 

The vulnerability manifests in these scenarios:

1. **Protocol Migrations**: When the Aptos framework migrates from old resource types (e.g., `CoinStore`) to new ones (e.g., fungible assets), historical events that depend on the old resources fail to translate when the indexer reprocesses them. [4](#0-3) 

2. **Resource Lifecycle Events**: Many translators expect resources to exist but return errors when they don't. For example, `TokenMutationTranslator` fails if the token has been burned, `CollectionMutationTranslator` fails if the collection resource is deleted. [5](#0-4) [6](#0-5) 

3. **Indexer Restart/Catchup**: When the indexer restarts or a new node syncs, it processes old transactions (version V) while reading state from the current checkpoint (version V+N where N could be thousands or millions). If resources were deleted in the interim, events are lost. [7](#0-6) 

**Attack Path:**

1. Attacker performs actions that emit V2 events (e.g., token transfers, NFT minting) at version V
2. Events are initially indexed successfully if the indexer is caught up
3. Attacker or protocol evolution causes the required resources to be deleted at version V+1000
4. Indexer restarts or new node syncs, attempting to reindex from version V
5. Translator reads current state (version V+1000) which lacks the required resources
6. Translation fails, errors are logged with `warn!` but converted to `Ok(None)`
7. Events are permanently lost from the indexer without halting or alerting [8](#0-7) 

## Impact Explanation
This vulnerability causes **High Severity** impact under the Aptos bug bounty criteria for "Significant protocol violations":

1. **Data Integrity Violation**: The indexer provides incomplete and incorrect event history. Applications relying on the indexer for audit trails, transaction history, or balance calculations will receive missing or incorrect data.

2. **Hiding Malicious Activity**: An attacker can structure transactions to emit events that will fail translation upon indexer restart, effectively hiding their actions from indexer-based monitoring, forensics, and compliance systems.

3. **State Inconsistency**: Different nodes may have different indexed events depending on when their indexers were running, breaking the deterministic state invariant for indexed data.

4. **Silent Failures**: The errors are logged with `warn!` but don't halt indexing or trigger alerts. Operators may not realize event data is being lost until users report missing transactions or incorrect balances.

The impact is particularly severe during:
- Node bootstrapping (all historical events at risk)
- Protocol upgrades that delete old resource types
- Indexer database rebuilds or migrations

While this doesn't directly affect consensus or fund safety, it undermines the reliability of the entire indexing subsystem, which many ecosystem applications depend on.

## Likelihood Explanation
**Likelihood: High**

This vulnerability **will** manifest in normal operations:

1. **Guaranteed Trigger Events**: Node restarts, indexer crashes, database corruption recovery, and new node synchronization are routine operational events that trigger the vulnerability.

2. **Protocol Evolution**: The Aptos framework is actively evolving (as evidenced by the coin-to-fungible-asset migration). Each protocol upgrade that deletes or migrates resources will cause historical events to fail translation.

3. **No Special Permissions Required**: While individual users may not intentionally exploit this, the vulnerability is triggered by normal protocol operations and doesn't require attacker privileges.

4. **Already Happening**: The code comments acknowledge that MINT/BURN events with `ConcurrentSupply` are expected to fail translation, showing this is an active issue. [9](#0-8) 

## Recommendation

**Fix the TOCTOU vulnerability by reading historical state instead of current state:**

1. **Pass version context to translators**: Modify `translate_event_v2_to_v1()` to accept the transaction version being processed and pass it to the translation engine.

2. **Use versioned state views**: Replace `latest_state_checkpoint_view()` with `state_view_at_version(Some(transaction_version))` to read state as it existed when the event was emitted. [10](#0-9) 

3. **Handle legitimately missing resources**: For cases where resources genuinely don't exist (e.g., events emitted before resource creation), implement proper fallback logic with deterministic event keys rather than silently dropping events.

4. **Add monitoring**: Track translation failures in metrics and alert operators when failure rates exceed thresholds.

**Proposed Code Fix:**

Modify the signature and implementation to accept and use the transaction version for state lookups, ensuring translators read historical state that matches when events were emitted.

## Proof of Concept

```rust
// Rust reproduction test demonstrating the vulnerability
// Add to storage/indexer/src/db_indexer.rs

#[cfg(test)]
mod event_translation_toctou_tests {
    use super::*;
    
    #[tokio::test]
    async fn test_event_lost_after_resource_deletion() {
        // 1. Setup: Create a test database with a CoinStore resource
        // 2. Emit a CoinDeposit V2 event at version 100
        // 3. Delete the CoinStore at version 200 (simulate migration)
        // 4. Reset indexer to process from version 100
        // 5. Attempt to translate the event using current state (version 200)
        // 6. Assert: Translation fails, event is lost, only warning logged
        
        // Expected behavior: Event should translate successfully using historical state
        // Actual behavior: Event translation fails because CoinStore doesn't exist in current state
        
        // This test would demonstrate:
        // - The translator reads from latest_state_checkpoint_view() 
        // - This returns state at version 200 (no CoinStore)
        // - Translation fails for event at version 100
        // - Error is converted to Ok(None), event is lost
    }
    
    #[tokio::test]
    async fn test_token_mutation_event_lost_after_burn() {
        // Similar test for TokenMutation events:
        // 1. Mint NFT with mutation event at version 50
        // 2. Burn NFT at version 150
        // 3. Reindex from version 50 when current version is 150
        // 4. Assert: Mutation event at version 50 fails to translate
    }
}
```

**Move Test Scenario:**

```move
// Move test demonstrating event loss scenario
// Add to aptos-move/framework/aptos-framework/sources/coin.move

#[test(account = @0x1)]
fun test_deposit_event_lost_after_migration(account: &signer) {
    // 1. Create CoinStore and emit deposit event
    // 2. Migrate to fungible asset (deletes CoinStore)
    // 3. Query indexer for historical deposit events
    // Expected: Event should be present
    // Actual: Event is missing due to translation failure
}
```

## Notes

The vulnerability is exacerbated by the fact that V2 events lack inherent event keys and sequence numbers, requiring resource lookups for translation. The fundamental design assumes resources will exist when events are translated, which is violated during indexer catchup scenarios.

The special handling for `ConcurrentSupply` MINT/BURN events indicates this issue is known but only partially addressed. A comprehensive fix requires redesigning the translation system to use historical state or storing V2 event metadata alongside the events themselves.

### Citations

**File:** storage/indexer/src/db_indexer.rs (L552-584)
```rust
    pub fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
    ) -> Result<Option<ContractEventV1>> {
        let _timer = TIMER.timer_with(&["translate_event_v2_to_v1"]);
        if let Some(translator) = self
            .event_v2_translation_engine
            .translators
            .get(v2.type_tag())
        {
            let result = translator.translate_event_v2_to_v1(v2, &self.event_v2_translation_engine);
            match result {
                Ok(v1) => Ok(Some(v1)),
                Err(e) => {
                    // If the token object collection uses ConcurrentSupply, skip the translation and ignore the error.
                    // This is expected, as the event handle won't be found in either FixedSupply or UnlimitedSupply.
                    let is_ignored_error = (v2.type_tag() == &*MINT_TYPE
                        || v2.type_tag() == &*BURN_TYPE)
                        && e.to_string().contains("resource not found");
                    if !is_ignored_error {
                        warn!(
                            "Failed to translate event: {:?}. Error: {}",
                            v2,
                            e.to_string()
                        );
                    }
                    Ok(None)
                },
            }
        } else {
            Ok(None)
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L202-214)
```rust
    pub fn get_state_value_bytes_for_resource(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
    ) -> Result<Option<Bytes>> {
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        let state_key = StateKey::resource(address, struct_tag)?;
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L430-468)
```rust
struct TokenMutationTranslator;
impl EventV2Translator for TokenMutationTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let token_mutation = TokenMutation::try_from_bytes(v2.event_data())?;
        let struct_tag_str = "0x4::token::Token".to_string();
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) = engine
            .get_state_value_bytes_for_object_group_resource(
                token_mutation.token_address(),
                &struct_tag,
            )? {
            let token_resource: TokenResource = bcs::from_bytes(&state_value_bytes)?;
            let key = *token_resource.mutation_events().key();
            let sequence_number =
                engine.get_next_sequence_number(&key, token_resource.mutation_events().count())?;
            (key, sequence_number)
        } else {
            // If the token resource is not found, we skip the event translation to avoid panic
            // because the creation number cannot be decided. The token may have been burned.
            return Err(AptosDbError::from(anyhow::format_err!(
                "Token resource not found"
            )));
        };
        let token_mutation_event = TokenMutationEvent::new(
            token_mutation.mutated_field_name().clone(),
            token_mutation.old_value().clone(),
            token_mutation.new_value().clone(),
        );
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            TOKEN_MUTATION_EVENT_TYPE.clone(),
            bcs::to_bytes(&token_mutation_event)?,
        )?)
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L471-506)
```rust
struct CollectionMutationTranslator;
impl EventV2Translator for CollectionMutationTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let collection_mutation = CollectionMutation::try_from_bytes(v2.event_data())?;
        let struct_tag_str = "0x4::collection::Collection".to_string();
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) = engine
            .get_state_value_bytes_for_object_group_resource(
                collection_mutation.collection().inner(),
                &struct_tag,
            )? {
            let collection_resource: CollectionResource = bcs::from_bytes(&state_value_bytes)?;
            let key = *collection_resource.mutation_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, collection_resource.mutation_events().count())?;
            (key, sequence_number)
        } else {
            // If the token resource is not found, we skip the event translation to avoid panic
            // because the creation number cannot be decided.
            return Err(AptosDbError::from(anyhow::format_err!(
                "Collection resource not found"
            )));
        };
        let collection_mutation_event =
            CollectionMutationEvent::new(collection_mutation.mutated_field_name().clone());
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            COLLECTION_MUTATION_EVENT_TYPE.clone(),
            bcs::to_bytes(&collection_mutation_event)?,
        )?)
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L82-90)
```rust
    fn latest_state_checkpoint_view(&self) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version: self
                .get_latest_state_checkpoint_version()
                .map_err(Into::<StateViewError>::into)?,
            maybe_verify_against_state_root_hash: None,
        })
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L93-105)
```rust
pub trait DbStateViewAtVersion {
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView>;
}

impl DbStateViewAtVersion for Arc<dyn DbReader> {
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version,
            maybe_verify_against_state_root_hash: None,
        })
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L650-680)
```text
    fun maybe_convert_to_fungible_store<CoinType>(
        account: address
    ) acquires CoinStore, CoinConversionMap, CoinInfo {
        if (exists<CoinStore<CoinType>>(account)) {
            let CoinStore<CoinType> { coin, frozen, deposit_events, withdraw_events } =
                move_from<CoinStore<CoinType>>(account);
            if (is_coin_initialized<CoinType>() && coin.value > 0) {
                let metadata = ensure_paired_metadata<CoinType>();
                let store =
                    primary_fungible_store::ensure_primary_store_exists(
                        account, metadata
                    );

                event::emit(
                    CoinStoreDeletion {
                        coin_type: type_info::type_name<CoinType>(),
                        event_handle_creation_address: guid::creator_address(
                            event::guid(&deposit_events)
                        ),
                        deleted_deposit_event_handle_creation_number: guid::creation_num(
                            event::guid(&deposit_events)
                        ),
                        deleted_withdraw_event_handle_creation_number: guid::creation_num(
                            event::guid(&withdraw_events)
                        )
                    }
                );

                if (coin.value == 0) {
                    destroy_zero(coin);
                } else {
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L167-199)
```rust
    pub async fn run(&mut self, node_config: &NodeConfig) -> Result<()> {
        let mut start_version = self.get_start_version(node_config).await?;
        let mut target_version = self.db_indexer.main_db_reader.ensure_synced_version()?;
        let mut step_timer = std::time::Instant::now();

        loop {
            if target_version <= start_version {
                match self.update_receiver.changed().await {
                    Ok(_) => {
                        (step_timer, target_version) = *self.update_receiver.borrow();
                    },
                    Err(e) => {
                        panic!("Failed to get update from update_receiver: {}", e);
                    },
                }
            }
            let next_version = self.db_indexer.process(start_version, target_version)?;
            INDEXER_DB_LATENCY.set(step_timer.elapsed().as_millis() as i64);
            log_grpc_step(
                SERVICE_TYPE,
                IndexerGrpcStep::InternalIndexerDBProcessed,
                Some(start_version as i64),
                Some(next_version as i64),
                None,
                None,
                Some(step_timer.elapsed().as_secs_f64()),
                None,
                Some((next_version - start_version) as i64),
                None,
            );
            start_version = next_version;
        }
    }
```
