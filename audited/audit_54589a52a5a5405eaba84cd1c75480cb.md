# Audit Report

## Title
Validator Transaction JWK Updates Bypass Gas and Storage Fee Charging for Unbounded Payloads

## Summary
When validators submit JWK updates via `ValidatorTransaction::ObservedJWKUpdate`, the system uses `UnmeteredGasMeter` and returns `FeeStatement::zero()`, resulting in zero gas and storage fees charged regardless of the `UnsupportedJWK` payload size. This allows unbounded storage at the `@aptos_framework` address without economic cost.

## Finding Description

The `UnsupportedJWK` struct contains an unbounded `payload: Vec<u8>` field that is converted to Move values and stored on-chain through validator transactions. [1](#0-0) 

When processing JWK updates in `process_jwk_update_inner`, the code explicitly uses an unmetered gas meter: [2](#0-1) 

This `UnmeteredGasMeter` returns `Ok(())` for all charging operations without tracking any gas consumption: [3](#0-2) 

Upon completion, the transaction uses `get_system_transaction_output` which returns a zero fee statement: [4](#0-3) 

The `FeeStatement::zero()` creates a statement with all gas and storage fees set to zero: [5](#0-4) 

The Move function `upsert_into_observed_jwks` performs no size validation on the payload: [6](#0-5) 

Unlike `FederatedJWKs` which has a 2 KiB size limit, `ObservedJWKs` has no such restriction: [7](#0-6) 

While per-block validator transaction limits exist (2MB total per block), individual payloads could theoretically reach ~1MB: [8](#0-7) 

**Exploitation Path:**
1. OIDC provider publishes a large JWK (or validators observe/create large payloads)
2. Validators reach consensus on a `QuorumCertifiedUpdate` containing `UnsupportedJWK` with large payload
3. Update submitted as `ValidatorTransaction::ObservedJWKUpdate`
4. VM executes with `UnmeteredGasMeter` - zero gas charged
5. Output uses `FeeStatement::zero()` - zero storage fees charged
6. Large payload stored permanently in `ObservedJWKs` resource at `@aptos_framework`
7. Process repeatable across multiple blocks, accumulating unbounded state bloat

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**High Severity** - This qualifies as a significant protocol violation under the Aptos bug bounty program. The vulnerability enables:

- **Free On-Chain Storage**: Arbitrary data can be stored without paying storage fees
- **State Bloat**: Permanent accumulation of data degrading blockchain performance
- **Validator Performance Impact**: Larger state increases read/write costs for all validators
- **Economic Model Bypass**: Circumvents the storage fee mechanism designed to limit state growth

While the impact doesn't reach Critical severity (no direct fund loss or consensus safety violation), it constitutes a significant protocol violation affecting the economic sustainability and performance of the network.

## Likelihood Explanation

**Likelihood: Medium-Low** (with important caveats)

The exploitation requires >2/3 validator voting power to sign the `QuorumCertifiedUpdate`. However, there are legitimate scenarios where this occurs naturally:

1. **Legitimate Large JWKs**: OIDC providers may publish large JWKs (e.g., post-quantum cryptography keys), which validators would legitimately observe and store
2. **Protocol Design**: Even without malicious intent, the lack of fee charging creates an economic externality
3. **Validator Collusion**: In adversarial scenarios with compromised validators, deliberate exploitation is possible

The key issue is that even in non-malicious scenarios, the system permits unbounded free storage through validator transactions, creating a systemic vulnerability rather than requiring explicit attack intent.

## Recommendation

Implement gas and storage fee charging for validator transactions, or add explicit size limits:

**Option 1: Add Size Validation (Immediate Fix)**

```move
// In jwks.move, add constant:
const MAX_OBSERVED_JWK_PAYLOAD_SIZE: u64 = 10 * 1024; // 10 KiB

// In upsert_into_observed_jwks function, add validation:
public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) acquires ObservedJWKs, PatchedJWKs, Patches {
    system_addresses::assert_aptos_framework(fx);
    
    // Validate payload sizes
    vector::for_each_ref(&provider_jwks_vec, |provider_jwks|{
        let p: &ProviderJWKs = provider_jwks;
        vector::for_each_ref(&p.jwks, |jwk|{
            let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
            if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                assert!(
                    vector::length(&repr.payload) <= MAX_OBSERVED_JWK_PAYLOAD_SIZE,
                    error::invalid_argument(EUNSUPPORTED_JWK_TOO_LARGE)
                );
            }
        });
    });
    
    // ... rest of function
}
```

**Option 2: Charge Storage Fees (Long-term Fix)**

Modify validator transaction processing to use a proper gas meter and charge storage fees proportional to the data size, or account validator transaction storage costs through a different mechanism (e.g., validator stake penalties).

## Proof of Concept

```rust
// Test in Rust demonstrating zero-cost storage
// File: aptos-move/aptos-vm/src/validator_txns/jwk_test.rs

#[test]
fn test_large_unsupported_jwk_no_gas_charged() {
    // Create a large payload (1MB)
    let large_payload = vec![0u8; 1024 * 1024]; 
    
    let unsupported_jwk = UnsupportedJWK {
        id: b"test_key".to_vec(),
        payload: large_payload,
    };
    
    let provider_jwks = ProviderJWKs {
        issuer: b"test_issuer".to_vec(),
        version: 1,
        jwks: vec![JWKMoveStruct::from(JWK::Unsupported(unsupported_jwk))],
    };
    
    let update = QuorumCertifiedUpdate {
        update: provider_jwks,
        multi_sig: create_valid_multisig(), // Helper to create valid sig
    };
    
    // Process the update
    let (vm_status, vm_output) = process_jwk_update(...);
    
    // Assert: No gas charged despite 1MB payload
    assert_eq!(vm_output.fee_statement().gas_used(), 0);
    assert_eq!(vm_output.fee_statement().storage_fee_used(), 0);
    
    // Assert: State was modified (data written)
    assert!(!vm_output.change_set().write_set().is_empty());
}
```

## Notes

This vulnerability exists by design for validator/system transactions, which typically don't charge fees. However, the lack of size bounds on user-controlled data (`UnsupportedJWK` payloads observed from external OIDC providers) creates an exploitable gap. The fix should either bound the payload size or implement a storage cost accounting mechanism specific to validator transactions.

### Citations

**File:** types/src/jwks/unsupported/mod.rs (L14-17)
```rust
pub struct UnsupportedJWK {
    pub id: Vec<u8>,
    pub payload: Vec<u8>,
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L145-145)
```rust
        let mut gas_meter = UnmeteredGasMeter;
```

**File:** third_party/move/move-vm/types/src/gas.rs (L394-422)
```rust
/// A dummy gas meter that does not meter anything.
/// Charge operations will always succeed.
pub struct UnmeteredGasMeter;

impl DependencyGasMeter for UnmeteredGasMeter {
    fn charge_dependency(
        &mut self,
        _kind: DependencyKind,
        _addr: &AccountAddress,
        _name: &IdentStr,
        _size: NumBytes,
    ) -> PartialVMResult<()> {
        Ok(())
    }
}

impl NativeGasMeter for UnmeteredGasMeter {
    fn legacy_gas_budget_in_native_context(&self) -> InternalGas {
        u64::MAX.into()
    }

    fn charge_native_execution(&mut self, _amount: InternalGas) -> PartialVMResult<()> {
        Ok(())
    }

    fn use_heap_memory_in_native_context(&mut self, _amount: u64) -> PartialVMResult<()> {
        Ok(())
    }
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L258-270)
```rust
pub(crate) fn get_system_transaction_output(
    session: SessionExt<impl AptosMoveResolver>,
    module_storage: &impl AptosModuleStorage,
    change_set_configs: &ChangeSetConfigs,
) -> Result<VMOutput, VMStatus> {
    let change_set = session.finish(change_set_configs, module_storage)?;

    Ok(VMOutput::new(
        change_set,
        ModuleWriteSet::empty(),
        FeeStatement::zero(),
        TransactionStatus::Keep(ExecutionStatus::Success),
    ))
```

**File:** types/src/fee_statement.rs (L44-52)
```rust
    pub fn zero() -> Self {
        Self {
            total_charge_gas_units: 0,
            execution_gas_units: 0,
            io_gas_units: 0,
            storage_fee_octas: 0,
            storage_fee_refund_octas: 0,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L31-33)
```text
    /// We limit the size of a `PatchedJWKs` resource installed by a dapp owner for federated keyless accounts.
    /// Note: If too large, validators waste work reading it for invalid TXN signatures.
    const MAX_FEDERATED_JWKS_SIZE_BYTES: u64 = 2 * 1024; // 2 KiB
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L462-505)
```text
    public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);

        if (features::is_jwk_consensus_per_key_mode_enabled()) {
            vector::for_each(provider_jwks_vec, |proposed_provider_jwks|{
                let maybe_cur_issuer_jwks = remove_issuer(&mut observed_jwks.jwks, proposed_provider_jwks.issuer);
                let cur_issuer_jwks = if (option::is_some(&maybe_cur_issuer_jwks)) {
                    option::extract(&mut maybe_cur_issuer_jwks)
                } else {
                    ProviderJWKs {
                        issuer: proposed_provider_jwks.issuer,
                        version: 0,
                        jwks: vector[],
                    }
                };
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
                    }
                });
                cur_issuer_jwks.version = cur_issuer_jwks.version + 1;
                upsert_provider_jwks(&mut observed_jwks.jwks, cur_issuer_jwks);
            });
        } else {
            vector::for_each(provider_jwks_vec, |provider_jwks| {
                upsert_provider_jwks(&mut observed_jwks.jwks, provider_jwks);
            });
        };

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L125-126)
```rust
const VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT: u64 = 2;
const VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT: u64 = 2097152; //2MB
```
