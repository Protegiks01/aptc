# Audit Report

## Title
DKG Player ID Forgery via Missing Duplicate Validation in VM Transcript Verification

## Summary
The `verify_transcript` function used by the VM to validate DKG (Distributed Key Generation) transcripts lacks validation for duplicate Player IDs, allowing a malicious validator to submit multiple contributions under the same Player ID. This bypasses the fundamental DKG assumption that each validator contributes exactly once, potentially enabling manipulation of on-chain randomness generation.

## Finding Description

The vulnerability exists in the DKG transcript verification flow within the Aptos VM. The core issue is that the `Player` struct has a public `id` field that can be directly instantiated, and the VM's verification path does not check for duplicate Player IDs. [1](#0-0) 

Despite the intent stated in comments that "only the SecretSharingConfig trait is allowed to create" Player instances, the public `id` field allows unrestricted construction via struct literal syntax.

The vulnerability manifests in the verification flow:

1. **In `batch_verify_soks`**, Player IDs from SoKs (Signatures of Knowledge) are used directly in Contribution messages without validation: [2](#0-1) 

2. **In `verify_transcript`** (used by the VM), the public key array is constructed based on Player IDs claimed in the transcript: [3](#0-2) 

3. **Critical missing check**: The function validates that Player IDs are within bounds but does NOT check for duplicates: [4](#0-3) 

4. **In contrast, `verify_transcript_extra`** has the duplicate check but is NOT used by the VM: [5](#0-4) 

5. **The VM uses the vulnerable path**: [6](#0-5) 

**Attack Scenario:**

A malicious validator can exploit this by:
1. Generating their legitimate transcript with Player{id: N}
2. Aggregating it with itself using the public `aggregate_with` method, or directly modifying the transcript to duplicate SoKs
3. Submitting a transcript containing: `soks = [(Player{id:N}, comm1, sig1, pok1), (Player{id:N}, comm2, sig2, pok2), ...]`
4. During verification:
   - `dealers = [N, N, N, ...]` (duplicate Player IDs)
   - `spks = [pk[N], pk[N], pk[N], ...]` (same public key repeated)
   - Each SoK validates correctly because all signatures verify against pk[N]
   - No duplicate check is performed
5. The validator has contributed multiple times to the DKG, gaining disproportionate influence

This breaks the DKG protocol's security assumption that each of the n validators contributes exactly once to generate the shared secret.

## Impact Explanation

**Critical Severity** - This vulnerability meets the Critical category under Aptos Bug Bounty criteria:

1. **Consensus/Safety Violation**: DKG is fundamental to Aptos's on-chain randomness generation, which is used for validator selection and consensus operations. Allowing validators to contribute multiple times breaks the cryptographic security assumptions of the distributed key generation protocol.

2. **Randomness Manipulation**: With multiple contributions, a malicious validator can bias the generated randomness in their favor, potentially enabling:
   - Predictable leader selection
   - MEV (Maximal Extractable Value) extraction
   - Consensus manipulation

3. **Threshold Security Compromise**: DKG security depends on having at least t-of-n honest contributions. If one validator can submit k contributions, the effective threshold becomes (t-of-(n-1+k)), weakening the security guarantee.

4. **Protocol Invariant Violation**: Violates the fundamental invariant that "each validator contributes exactly once" to the DKG ceremony.

## Likelihood Explanation

**High Likelihood** for the following reasons:

1. **Low Attack Complexity**: A malicious validator only needs to modify their own transcript before submission - no coordination with other validators required.

2. **No Detection Mechanism**: The VM verification path has no safeguards to detect or prevent this attack.

3. **Feasible Execution**: The attack can be executed by:
   - Calling `aggregate_with` to self-aggregate
   - Directly manipulating the public `Transcript` struct
   - Using the public Player struct constructor

4. **Motivated Attackers**: Validators have strong economic incentives to manipulate randomness for MEV extraction or favorable leader selection.

## Recommendation

Add duplicate Player ID validation to `verify_transcript`:

```rust
fn verify_transcript(
    params: &Self::PublicParams,
    trx: &Self::Transcript,
) -> anyhow::Result<()> {
    // Verify dealer indices are valid.
    let dealers = trx
        .main
        .get_dealers()
        .iter()
        .map(|player| player.id)
        .collect::<Vec<usize>>();
    let num_validators = params.session_metadata.dealer_validator_set.len();
    ensure!(
        dealers.iter().all(|id| *id < num_validators),
        "real_dkg::verify_transcript failed with invalid dealer index."
    );

    // ADD THIS CHECK: Verify no duplicate Player IDs
    let dealer_set: std::collections::HashSet<usize> = dealers.iter().cloned().collect();
    ensure!(
        dealers.len() == dealer_set.len(),
        "real_dkg::verify_transcript failed with duplicate dealer IDs."
    );

    // ... rest of verification ...
}
```

Additionally, make the Player struct's `id` field private and enforce creation only through `SecretSharingConfig`:

```rust
pub struct Player {
    /// A number from 0 to n-1.
    id: usize,  // Remove 'pub' keyword
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_player_id_forgery {
    use super::*;
    use aptos_dkg::pvss::{Player, das::weighted_protocol::Transcript};
    use aptos_crypto::bls12381::PrivateKey;
    
    #[test]
    fn test_duplicate_player_id_bypasses_vm_verification() {
        // Setup DKG parameters for 4 validators
        let validator_count = 4;
        let attacker_index = 0;
        
        // Attacker generates legitimate transcript
        let mut rng = rand::thread_rng();
        let sk = PrivateKey::generate(&mut rng);
        let pk = sk.public_key();
        
        // Generate one legitimate transcript
        let transcript1 = generate_legitimate_transcript(
            &mut rng, 
            &pub_params, 
            attacker_index, 
            &sk, 
            &pk
        );
        
        // Attacker duplicates their contribution by aggregating with self
        let mut malicious_transcript = transcript1.clone();
        malicious_transcript.aggregate_with(&config, &transcript1).unwrap();
        
        // Now malicious_transcript has duplicate SoKs with Player{id: attacker_index}
        let dealers = malicious_transcript.main.get_dealers();
        assert_eq!(dealers.len(), 2); // Two contributions
        assert_eq!(dealers[0].id, attacker_index); // Both same Player ID
        assert_eq!(dealers[1].id, attacker_index);
        
        // VM verification PASSES (vulnerable)
        assert!(RealDKG::verify_transcript(&pub_params, &malicious_transcript).is_ok());
        
        // But verify_transcript_extra FAILS (has duplicate check)
        assert!(RealDKG::verify_transcript_extra(
            &malicious_transcript, 
            &verifier, 
            false, 
            None
        ).is_err());
        
        // Attacker has now contributed twice, breaking DKG security
    }
}
```

## Notes

This vulnerability specifically affects the VM validation path used when processing DKG result transactions. The `verify_transcript_extra` function (used in other contexts) already contains the proper duplicate check at line 311, but the VM explicitly calls `verify_transcript` which omits this critical validation. This represents a dangerous inconsistency in the verification logic where the stricter validation is not applied at the most critical point - transaction execution in the VM.

The impact is particularly severe because DKG is used to generate shared randomness for consensus, and the ability to submit multiple contributions fundamentally breaks the cryptographic security guarantees of the protocol.

### Citations

**File:** crates/aptos-crypto/src/player.rs (L21-24)
```rust
pub struct Player {
    /// A number from 0 to n-1.
    pub id: usize,
}
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L79-87)
```rust
    let msgs = soks
        .iter()
        .zip(aux)
        .map(|((player, comm, _, _), aux)| Contribution::<Gr, A> {
            comm: *comm,
            player: *player,
            aux: aux.clone(),
        })
        .collect::<Vec<Contribution<Gr, A>>>();
```

**File:** types/src/dkg/real_dkg/mod.rs (L301-311)
```rust
        let all_validator_addrs = verifier.get_ordered_account_addresses();
        let main_trx_dealers = trx.main.get_dealers();
        let mut dealer_set = HashSet::with_capacity(main_trx_dealers.len());
        for dealer in main_trx_dealers.iter() {
            if let Some(dealer_addr) = all_validator_addrs.get(dealer.id) {
                dealer_set.insert(*dealer_addr);
            } else {
                bail!("invalid dealer idx");
            }
        }
        ensure!(main_trx_dealers.len() == dealer_set.len());
```

**File:** types/src/dkg/real_dkg/mod.rs (L337-361)
```rust
        let dealers = trx
            .main
            .get_dealers()
            .iter()
            .map(|player| player.id)
            .collect::<Vec<usize>>();
        let num_validators = params.session_metadata.dealer_validator_set.len();
        ensure!(
            dealers.iter().all(|id| *id < num_validators),
            "real_dkg::verify_transcript failed with invalid dealer index."
        );

        let all_eks = params.pvss_config.eks.clone();

        let addresses = params.verifier.get_ordered_account_addresses();
        let dealers_addresses = dealers
            .iter()
            .filter_map(|&pos| addresses.get(pos))
            .cloned()
            .collect::<Vec<_>>();

        let spks = dealers_addresses
            .iter()
            .filter_map(|author| params.verifier.get_public_key(author))
            .collect::<Vec<_>>();
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```
