# Audit Report

## Title
Move Unit Test Runner Fails to Set Exit Codes on Test Failures Allowing CI/CD Bypass

## Summary
The standalone `move-unit-test` binary does not properly set exit codes when tests fail. The `main()` function discards the test result boolean returned by `run_and_report_unit_tests()`, causing the process to always exit with code 0 (success) regardless of test outcomes. This allows CI/CD pipelines using this tool to incorrectly pass when security-critical tests fail.

## Finding Description

The vulnerability exists in the `main()` function of the Move unit test runner. [1](#0-0) 

The `run_and_report_unit_tests()` method returns `Result<(W, bool)>` where the boolean indicates whether all tests passed. [2](#0-1) 

The function correctly determines test success/failure and returns the `ok` boolean at line 244. [3](#0-2) 

However, the `main()` function only calls `.unwrap()` on line 22, which succeeds as long as there's no I/O error, completely ignoring whether tests passed or failed. The process then exits normally with code 0.

In contrast, the Move CLI properly handles this by checking the boolean result and explicitly calling `std::process::exit(1)` when tests fail. [4](#0-3) 

The Aptos CLI similarly checks the `UnitTestResult` enum and returns appropriate errors. [5](#0-4) 

**Attack Scenario:**
1. Developer writes Move code containing security vulnerabilities (e.g., missing access control checks)
2. Developer writes unit tests that properly detect these vulnerabilities and fail
3. CI/CD pipeline is configured to run `move-unit-test` binary directly
4. Tests execute and fail, but exit code remains 0
5. CI/CD interprets exit code 0 as success and allows deployment
6. Vulnerable code is deployed to mainnet/testnet
7. Attacker exploits the undetected vulnerability

## Impact Explanation

This is correctly classified as **Low Severity** ($1,000 range) under "Non-critical implementation bugs" per the Aptos bug bounty program.

While this bug doesn't directly compromise consensus, the Move VM, or on-chain state, it creates a gap in the security development lifecycle. Specifically:

- **No Direct Protocol Impact**: This doesn't break consensus safety, state consistency, or any protocol invariants
- **Tooling Layer Issue**: The vulnerability exists in developer tooling, not the blockchain itself  
- **Indirect Security Risk**: Requires vulnerable code to already exist and specific CI/CD misconfiguration
- **Limited Scope**: Only affects users of the standalone `move-unit-test` binary; users of `aptos move test` or `move test` are unaffected

The impact is indirect: it undermines the reliability of automated security testing, potentially allowing vulnerable Move modules to reach production.

## Likelihood Explanation

**Medium-Low Likelihood:**

- Most Aptos developers use higher-level commands (`aptos move test`, `move test`) which handle exit codes correctly
- The standalone `move-unit-test` binary would need to be explicitly chosen for CI/CD
- Vulnerable code with failing security tests would need to already exist
- The deployment process would need to rely solely on exit codes without manual review

However, for teams that do use the standalone binary in automated pipelines, this bug **will** cause security test failures to be silently ignored, making exploitation likely in those specific configurations.

## Recommendation

Modify the `main()` function to check the boolean result and set the exit code appropriately:

```rust
pub fn main() {
    let args = UnitTestingConfig::parse();

    let test_plan = args.build_test_plan();
    if let Some(test_plan) = test_plan {
        let (_writer, test_success) = args.run_and_report_unit_tests(
            test_plan,
            None,
            None,
            std::io::stdout(),
            UnitTestFactoryWithCostTable::new(None, None),
            false,
            args.fail_fast,
        )
        .unwrap();
        
        if !test_success {
            std::process::exit(1);
        }
    }
}
```

This matches the pattern used by the Move CLI and ensures proper exit code behavior.

## Proof of Concept

**Step 1:** Create a failing Move test:

```move
// sources/test.move
module 0x1::test_module {
    #[test]
    fun test_security_violation() {
        assert!(false, 1); // This test will fail
    }
}
```

**Step 2:** Create a Move.toml:

```toml
[package]
name = "TestPackage"
version = "1.0.0"

[addresses]
std = "0x1"
```

**Step 3:** Run with the move-unit-test binary:

```bash
$ move-unit-test --package-path . ; echo "Exit code: $?"
```

**Expected Result:** Despite test failure output, the exit code will be 0.

**Verification:**

```bash
$ echo $?
0  # Should be 1 for test failure
```

Compare with the correct behavior using `aptos move test`:

```bash
$ aptos move test --package-dir . ; echo "Exit code: $?"
# Exit code: 1 (correct)
```

This demonstrates that the standalone `move-unit-test` binary fails to set proper exit codes, allowing CI/CD systems to miss test failures.

---

## Notes

- This bug only affects the standalone `move-unit-test` binary in `third_party/move/tools/move-unit-test/`
- The `aptos move test` and `move test` commands correctly handle exit codes via their respective CLI wrappers
- The security impact is limited to CI/CD pipeline configurations that use the standalone binary
- The fix is straightforward and follows existing patterns in the codebase

### Citations

**File:** third_party/move/tools/move-unit-test/src/main.rs (L8-24)
```rust
pub fn main() {
    let args = UnitTestingConfig::parse();

    let test_plan = args.build_test_plan();
    if let Some(test_plan) = test_plan {
        args.run_and_report_unit_tests(
            test_plan,
            None,
            None,
            std::io::stdout(),
            UnitTestFactoryWithCostTable::new(None, None),
            false,
            args.fail_fast,
        )
        .unwrap();
    }
}
```

**File:** third_party/move/tools/move-unit-test/src/lib.rs (L185-196)
```rust
    /// Public entry point to Move unit testing as a library
    /// Returns `true` if all unit tests passed. Otherwise, returns `false`.
    pub fn run_and_report_unit_tests<W: Write + Send, F: UnitTestFactory + Send>(
        &self,
        test_plan: TestPlan,
        native_function_table: Option<NativeFunctionTable>,
        genesis_state: Option<ChangeSet>,
        writer: W,
        factory: F,
        enable_enum_option: bool,
        fail_fast: bool,
    ) -> Result<(W, bool)> {
```

**File:** third_party/move/tools/move-unit-test/src/lib.rs (L241-244)
```rust
        let ok = test_results.summarize(&shared_writer)?;

        let writer = shared_writer.into_inner().unwrap();
        Ok((writer, ok))
```

**File:** third_party/move/tools/move-cli/src/base/test.rs (L131-134)
```rust
        // Return a non-zero exit code if any test failed
        if let UnitTestResult::Failure = result {
            std::process::exit(1)
        }
```

**File:** crates/aptos/src/move_tool/mod.rs (L664-667)
```rust
        match result {
            UnitTestResult::Success => Ok("Success"),
            UnitTestResult::Failure => Err(CliError::MoveTestError),
        }
```
