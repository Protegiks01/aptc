# Audit Report

## Title
TOCTOU Vulnerability in ValidateProposals Command Allows Ed25519 Private Key Write to Arbitrary Filesystem Locations

## Summary
The `ValidateProposals` command handler contains a Time-of-Check-Time-of-Use (TOCTOU) vulnerability where sensitive Ed25519 private keys are written to a filesystem path without proper validation. An attacker with local filesystem access can exploit this race condition by creating a symlink between file creation and file write operations, redirecting the private key material to attacker-controlled or privileged locations.

## Finding Description

The vulnerability exists in the `ValidateProposals` command handler where the root private key is written to a temporary file. The code creates a secure temporary file but then writes to a different path with a modified extension without revalidating file properties. [1](#0-0) 

The vulnerable code path executes as follows:

1. **Line 284**: Creates a `TempPath` object with a random name (e.g., `/tmp/abc123...`)
2. **Line 285**: Securely creates the file using `create_as_file()` which uses `OpenOptions::create_new(true)`
3. **Line 303**: Shadows the `TempPath` variable by extracting the path as a `PathBuf`
4. **Line 304**: Modifies the path by adding `.key` extension (e.g., `/tmp/abc123....key`)
5. **Line 306**: Writes the Ed25519 private key to the modified path using `std::fs::write()`

The critical issue is that the path at line 306 (`/tmp/abc123....key`) is **different** from the securely created path at line 285 (`/tmp/abc123...`). The `std::fs::write()` function does not validate that the target is a regular file and follows symlinks by default on Unix systems. [2](#0-1) 

The `TempPath::create_as_file()` method uses `create_new(true)` which provides atomicity, but this protection is lost when writing to the path with the added extension.

**Attack Scenario:**

1. Attacker monitors `/tmp` directory using `inotify` or similar filesystem monitoring
2. When `TempPath::create_as_file()` creates `/tmp/abc123...`, the attacker observes this
3. Attacker immediately creates a symlink: `/tmp/abc123....key` â†’ `/tmp/stolen_keys/root.key` (or any privileged location)
4. When `std::fs::write()` executes at line 306, it follows the symlink and writes the Ed25519 private key to the attacker's target location

The root key is used for privileged operations throughout the codebase: [3](#0-2) [4](#0-3) [5](#0-4) 

This same vulnerable pattern also exists in the `set_fast_resolve()` method: [6](#0-5) 

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria for validator node compromise)

This vulnerability breaks the **Cryptographic Correctness** and **Access Control** invariants:

1. **Private Key Exposure**: The root/mint Ed25519 private key can be written to attacker-controlled locations, allowing key theft
2. **Governance Compromise**: The stolen root key can execute governance proposals with root signer authority (account `0xa550c18`)
3. **Token Minting**: The root key can call `0x1::aptos_coin::mint` to create arbitrary token amounts
4. **Proposal Manipulation**: The root key can add proposals to allow lists and modify governance configurations

While this doesn't directly cause consensus violations, it enables:
- **Potential Critical Impact**: Theft of root keys could lead to "Loss of Funds" through unauthorized minting
- **Protocol Violations**: Unauthorized governance proposal execution
- **Validator Node Compromise**: If the process runs with elevated permissions, arbitrary files could be overwritten

This meets **High Severity** criteria: "Validator node slowdowns, API crashes, Significant protocol violations" and potentially escalates to **Critical** if exploited for fund theft.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Attacker Requirements:**
- Local filesystem access to the system running `aptos-release-builder`
- Ability to monitor `/tmp` directory (standard on Unix systems)
- Ability to create symlinks in `/tmp` (standard user permissions)
- Fast reaction time (but the timing window includes CPU-intensive operations)

**Timing Window:**
The window between file creation (line 285) and file write (line 306) includes:
- Ed25519PrivateKey parsing from hex string
- AccountAddress parsing from hex
- Variable allocations and path manipulations

This provides a feasible window for exploitation using standard filesystem monitoring tools.

**Exploitation Complexity:** LOW to MEDIUM
- Standard Unix tools (`inotify_wait`, custom monitoring scripts) can detect file creation
- Symlink creation is instantaneous
- Attack can be automated and requires no special privileges

The `ValidateProposals` command is invoked during release validation and governance testing, making this a realistic attack vector during development and deployment workflows.

## Recommendation

**Fix: Use atomic file creation with the final path**

Replace the vulnerable pattern with secure file creation at the final path:

```rust
// SECURE VERSION
let root_key_path = aptos_temppath::TempPath::new();
let mut final_path = root_key_path.path().to_path_buf();
final_path.set_extension("key");

// Create the file with the .key extension atomically
let mut file = std::fs::OpenOptions::new()
    .write(true)
    .create_new(true)  // Fail if file exists, prevents symlink following
    .open(&final_path)?;

// Write to the file handle directly
use std::io::Write;
file.write_all(&bcs::to_bytes(&root_key)?)?;

aptos_release_builder::validate::NetworkConfig {
    root_key_path: final_path,
    validator_account,
    validator_key,
    framework_git_rev: None,
    endpoint: endpoint.clone(),
}
```

**Key improvements:**
1. Use `OpenOptions::create_new(true)` on the final path with the `.key` extension
2. Write to the file handle directly instead of using `std::fs::write()`
3. Eliminates the TOCTOU window by atomically creating and writing to the correct path

**Apply the same fix to validate.rs line 136-153:**
```rust
let fast_resolve_script = aptos_temppath::TempPath::new();
let mut fas_script_path = fast_resolve_script.path().to_path_buf();
fas_script_path.set_extension("move");

let mut file = std::fs::OpenOptions::new()
    .write(true)
    .create_new(true)
    .open(&fas_script_path)?;

use std::io::Write;
file.write_all(format!(/* ... */).as_bytes())?;
```

## Proof of Concept

```rust
// PROOF OF CONCEPT - Demonstrates the vulnerability
// Compile with: cargo test --package aptos-release-builder

#[cfg(test)]
mod toctou_exploit_poc {
    use aptos_temppath::TempPath;
    use std::fs;
    use std::path::PathBuf;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn demonstrate_toctou_vulnerability() {
        // Simulate the vulnerable code pattern
        let root_key_path = TempPath::new();
        root_key_path.create_as_file().unwrap();
        
        // Attacker observes the created file
        let observed_path = root_key_path.path().to_path_buf();
        println!("Attacker observes file creation: {:?}", observed_path);
        
        // Attacker creates symlink with .key extension
        let mut symlink_path = observed_path.clone();
        symlink_path.set_extension("key");
        let target_path = PathBuf::from("/tmp/stolen_key.txt");
        
        // Clean up any previous test artifacts
        let _ = fs::remove_file(&symlink_path);
        let _ = fs::remove_file(&target_path);
        
        // Attacker creates symlink (simulating race condition)
        #[cfg(unix)]
        std::os::unix::fs::symlink(&target_path, &symlink_path).unwrap();
        
        // Vulnerable code writes to the path (follows symlink)
        let mut root_key_path_buf = root_key_path.path().to_path_buf();
        root_key_path_buf.set_extension("key");
        
        let sensitive_data = b"SENSITIVE_ED25519_PRIVATE_KEY_MATERIAL";
        std::fs::write(root_key_path_buf.as_path(), sensitive_data).unwrap();
        
        // Verify key was written to attacker's target
        let stolen_contents = fs::read(&target_path).unwrap();
        assert_eq!(stolen_contents, sensitive_data);
        
        println!("SUCCESS: Private key written to attacker-controlled location: {:?}", target_path);
        
        // Cleanup
        let _ = fs::remove_file(&symlink_path);
        let _ = fs::remove_file(&target_path);
    }
}
```

**Expected Output:**
```
Attacker observes file creation: "/tmp/abc123def456..."
SUCCESS: Private key written to attacker-controlled location: "/tmp/stolen_key.txt"
```

This PoC demonstrates that `std::fs::write()` follows symlinks, allowing an attacker to redirect the private key write operation to arbitrary filesystem locations.

## Notes

This vulnerability requires local filesystem access, which is typically available to:
- Users on shared validator infrastructure
- Compromised local accounts on the same system
- Container escape scenarios in multi-tenant environments

The impact is amplified because the root/mint key has privileged access to:
- Execute governance proposals with root signer authority
- Mint tokens via `aptos_coin::mint`
- Modify governance configurations
- Add proposals to allow lists

While the primary instance is in production code (`main.rs`), the same pattern exists in `validate.rs` for writing Move scripts, though with lower impact since script contents are less sensitive than private keys.

### Citations

**File:** aptos-move/aptos-release-builder/src/main.rs (L284-306)
```rust
            let root_key_path = aptos_temppath::TempPath::new();
            root_key_path.create_as_file()?;

            let mut network_config = match input_option {
                InputOptions::FromDirectory { test_dir } => {
                    aptos_release_builder::validate::NetworkConfig::new_from_dir(
                        endpoint.clone(),
                        test_dir.as_path(),
                    )?
                },
                InputOptions::FromArgs {
                    root_key,
                    validator_address,
                    validator_key,
                } => {
                    let root_key = Ed25519PrivateKey::from_encoded_string(&root_key)?;
                    let validator_key = Ed25519PrivateKey::from_encoded_string(&validator_key)?;
                    let validator_account = AccountAddress::from_hex(validator_address.as_bytes())?;

                    let mut root_key_path = root_key_path.path().to_path_buf();
                    root_key_path.set_extension("key");

                    std::fs::write(root_key_path.as_path(), bcs::to_bytes(&root_key)?)?;
```

**File:** crates/aptos-temppath/src/lib.rs (L60-65)
```rust
    pub fn create_as_file(&self) -> io::Result<()> {
        let mut builder = fs::OpenOptions::new();
        builder.write(true).create_new(true);
        builder.open(self.path())?;
        Ok(())
    }
```

**File:** aptos-move/aptos-release-builder/src/validate.rs (L136-153)
```rust
        let fast_resolve_script = aptos_temppath::TempPath::new();
        fast_resolve_script.create_as_file()?;
        let mut fas_script_path = fast_resolve_script.path().to_path_buf();
        fas_script_path.set_extension("move");

        std::fs::write(fas_script_path.as_path(), format!(r#"
        script {{
            use aptos_framework::aptos_governance;

            fun main(core_resources: &signer) {{
                let core_signer = aptos_governance::get_signer_testnet_only(core_resources, @0000000000000000000000000000000000000000000000000000000000000001);

                let framework_signer = &core_signer;

                aptos_governance::update_governance_config(framework_signer, 0, 0, {});
            }}
        }}
        "#, resolution_time).as_bytes())?;
```

**File:** aptos-move/aptos-release-builder/src/validate.rs (L161-162)
```rust
            "--private-key-file",
            self.root_key_path.as_path().to_str().unwrap(),
```

**File:** aptos-move/aptos-release-builder/src/validate.rs (L296-297)
```rust
            "--private-key-file",
            self.root_key_path.as_path().to_str().unwrap(),
```

**File:** aptos-move/aptos-release-builder/src/validate.rs (L329-330)
```rust
            "--private-key-file",
            self.root_key_path.as_path().to_str().unwrap(),
```
