# Audit Report

## Title
Unvalidated JWK URI Allows Keyless Account Takeover via OIDC Provider Compromise

## Summary
The `fetch_jwks_from_jwks_uri()` function in `crates/jwk-utils/src/lib.rs` accepts arbitrary URLs without validation, allowing compromised or malicious OIDC providers to redirect validators to attacker-controlled endpoints for JWK fetching. This enables complete takeover of keyless accounts using the affected provider through malicious JWK injection.

## Finding Description

The JWK consensus system fetches JSON Web Keys from OIDC providers to verify keyless account signatures. The process involves two HTTP requests:

1. Fetch OpenID configuration from governance-approved `config_url` [1](#0-0) 

2. Extract `jwks_uri` from the configuration response and fetch JWKs from that URI [2](#0-1) 

**Critical Flaw**: The `jwks_uri` extracted from step 1 is passed directly to `reqwest::Client::get()` without ANY validation of scheme, domain, path, or content [3](#0-2) 

This breaks the **Cryptographic Correctness** invariant because JWKs used for signature verification can be attacker-controlled.

**Attack Path**:

1. Governance adds legitimate provider (e.g., `https://accounts.google.com/.well-known/openid-configuration/`)
2. Provider's OpenID configuration endpoint is compromised via DNS hijacking, server breach, or BGP attack
3. Compromised endpoint returns malicious response:
   ```json
   {"issuer": "https://accounts.google.com", "jwks_uri": "https://evil.com/fake-jwks"}
   ```
4. All validators fetch JWKs from attacker's server `https://evil.com/fake-jwks`
5. Attacker supplies their own RSA public keys
6. Through JWK consensus, malicious keys are stored on-chain [4](#0-3) 
7. Keyless transaction validation fetches JWKs from on-chain storage [5](#0-4) 
8. Attacker creates JWT tokens signed with their private keys
9. Signature verification succeeds using attacker's JWKs
10. Attacker drains all keyless accounts using the compromised provider

**URL Bypass Examples** (if validation existed):
- **User info in URL**: `https://accounts.google.com@evil.com/` → connects to `evil.com`
- **Percent encoding**: `https://evil.com/%67oogle.com/` → encodes 'g'
- **Unicode homoglyphs**: `https://gооgle.com/` → Cyrillic 'о' instead of Latin 'o'

**Contrast with Pepper Service**: The pepper service explicitly avoids this vulnerability by hardcoding trusted JWK URLs, citing security concerns about governance-controlled URLs [6](#0-5) 

## Impact Explanation

**Severity: CRITICAL** (Loss of Funds - up to $1,000,000 per Aptos Bug Bounty)

- **Complete account takeover**: All keyless accounts using the compromised OIDC provider become controllable by the attacker
- **Direct fund theft**: Attacker can sign arbitrary transactions draining victim accounts
- **Scale**: A single provider compromise (e.g., Google, Facebook) affects potentially millions of keyless accounts
- **Undetectable forgery**: Malicious signatures are cryptographically valid using on-chain JWKs
- **Consensus-validated attack**: All validators participate in storing malicious JWKs on-chain

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attack Requirements**:
- Compromise an OIDC provider's OpenID configuration endpoint (DNS, server, or network level)
- OR convince governance to add a malicious provider (social engineering)

**Feasibility**:
- DNS hijacking of major providers has occurred historically (e.g., BGP attacks on major DNS providers)
- Server breaches affect major companies regularly
- No technical sophistication required once provider access is gained
- Attack is entirely off-chain (no validator collusion needed)
- Attack persists until governance removes the provider and patches JWKs

**Real-world precedent**: The SolarWinds and Okta breaches demonstrate that trusted authentication infrastructure can be compromised.

## Recommendation

Implement strict validation of `jwks_uri` before fetching:

```rust
// In crates/jwk-utils/src/lib.rs
use url::Url;

pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
    expected_issuer: &str, // Pass issuer from config for validation
) -> Result<Vec<JWK>> {
    // Parse and validate URL
    let parsed_url = Url::parse(jwks_uri)
        .context("Invalid jwks_uri")?;
    
    // Require HTTPS
    if parsed_url.scheme() != "https" {
        bail!("jwks_uri must use HTTPS scheme");
    }
    
    // Validate domain matches expected issuer domain
    let issuer_url = Url::parse(expected_issuer)
        .context("Invalid issuer URL")?;
    if parsed_url.host_str() != issuer_url.host_str() {
        bail!("jwks_uri domain must match issuer domain");
    }
    
    // Reject URLs with user info
    if parsed_url.username() != "" || parsed_url.password().is_some() {
        bail!("jwks_uri must not contain user credentials");
    }
    
    // Validate no internationalized domain (IDN) homograph attacks
    if let Some(host) = parsed_url.host_str() {
        if host.contains("xn--") {
            bail!("jwks_uri must not use punycode domains");
        }
    }
    
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**Additional Hardening**:
1. Implement certificate pinning for known providers
2. Add governance-controlled allowlist of valid JWK URI patterns
3. Implement rate limiting and anomaly detection for JWK changes
4. Require manual governance approval for new JWK sets that differ significantly from previous versions

## Proof of Concept

```rust
// Add to testsuite/smoke-test/src/jwks/
#[tokio::test]
async fn test_malicious_jwks_uri_redirect() {
    use crate::jwks::dummy_provider::{DummyHttpServer, StaticContentServer};
    use aptos_jwk_utils::{fetch_jwks_uri_from_openid_config, fetch_jwks_from_jwks_uri};
    
    // Setup: Legitimate config server
    let config_server = DummyHttpServer::spawn().await;
    
    // Setup: Attacker's malicious JWK server
    let evil_jwk_server = DummyHttpServer::spawn().await;
    evil_jwk_server.update_request_handler(Some(Arc::new(
        StaticContentServer::new_str(
            r#"{"keys": [
                {"kid":"evil_key", "kty":"RSA", "e":"AQAB", 
                 "n":"attacker_controlled_modulus", "alg":"RS256"}
            ]}"#
        )
    )));
    
    // Attack: Config server returns evil jwks_uri
    config_server.update_request_handler(Some(Arc::new(
        StaticContentServer::new_str(&format!(
            r#"{{"issuer": "https://accounts.google.com", 
                "jwks_uri": "{}"}}"#,
            evil_jwk_server.url() // Redirects to attacker!
        ))
    )));
    
    // Vulnerability: Validators fetch from attacker's server
    let jwks_uri = fetch_jwks_uri_from_openid_config(
        config_server.url().as_str()
    ).await.unwrap();
    
    assert_eq!(jwks_uri, evil_jwk_server.url());
    
    let jwks = fetch_jwks_from_jwks_uri(None, jwks_uri.as_str())
        .await.unwrap();
    
    // Attacker's JWK is now fetched by validators
    assert_eq!(jwks[0].kid(), "evil_key");
    
    // These malicious JWKs would be stored on-chain through consensus,
    // enabling signature forgery for all Google-based keyless accounts
}
```

**Notes**:
- The vulnerability exists because `config_url` points to a trusted location, but the response content (specifically `jwks_uri`) is not validated
- Even though governance controls which providers are trusted, they cannot prevent a legitimate provider from being compromised post-addition
- The pepper service recognized this risk and hardcodes URLs instead of using on-chain configs
- URL parsing tricks (user info, encoding, homoglyphs) are irrelevant because NO validation exists to bypass
- The real issue is the trust placed in the HTTP response content without domain/pattern validation

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L102-110)
```rust
async fn fetch_jwks(open_id_config_url: &str, my_addr: Option<AccountAddress>) -> Result<Vec<JWK>> {
    let jwks_uri = fetch_jwks_uri_from_openid_config(open_id_config_url)
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with open-id config request: {e}"))?;
    let jwks = fetch_jwks_from_jwks_uri(my_addr, jwks_uri.as_str())
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with jwks uri request: {e}"))?;
    Ok(jwks)
}
```

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** crates/jwk-utils/src/lib.rs (L40-44)
```rust
pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L462-505)
```text
    public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);

        if (features::is_jwk_consensus_per_key_mode_enabled()) {
            vector::for_each(provider_jwks_vec, |proposed_provider_jwks|{
                let maybe_cur_issuer_jwks = remove_issuer(&mut observed_jwks.jwks, proposed_provider_jwks.issuer);
                let cur_issuer_jwks = if (option::is_some(&maybe_cur_issuer_jwks)) {
                    option::extract(&mut maybe_cur_issuer_jwks)
                } else {
                    ProviderJWKs {
                        issuer: proposed_provider_jwks.issuer,
                        version: 0,
                        jwks: vector[],
                    }
                };
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
                    }
                });
                cur_issuer_jwks.version = cur_issuer_jwks.version + 1;
                upsert_provider_jwks(&mut observed_jwks.jwks, cur_issuer_jwks);
            });
        } else {
            vector::for_each(provider_jwks_vec, |provider_jwks| {
                upsert_provider_jwks(&mut observed_jwks.jwks, provider_jwks);
            });
        };

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L220-260)
```rust
    let patched_jwks = get_jwks_onchain(resolver)?;

    let training_wheels_pk = match &config.training_wheels_pubkey {
        None => None,
        // This takes ~4.4 microseconds, so we are not too concerned about speed here.
        // (Run `cargo bench -- ed25519/pk_deserialize` in `crates/aptos-crypto`.)
        Some(bytes) => Some(EphemeralPublicKey::ed25519(
            Ed25519PublicKey::try_from(bytes.as_slice()).map_err(|_| {
                // println!("[aptos-vm][groth16] On chain TW PK is invalid");

                invalid_signature!("The training wheels PK set on chain is not a valid PK")
            })?,
        )),
    };

    for (pk, sig) in authenticators {
        // Try looking up the jwk in 0x1.
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
            // 1: If found in 0x1, then we consider that the ground truth & we are done.
            Ok(jwk) => jwk,
            // 2: If not found in 0x1, we check the Keyless PK type.
            Err(e) => {
                match pk {
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
        };
```

**File:** keyless/pepper/service/src/external_resources/jwk_fetcher.rs (L204-210)
```rust
/// Starts the JWK refresh loops for known issuers. Note: we currently
/// hardcode the known issuers here, instead of fetching them from on-chain
/// configs. This is a security measure to ensure the pepper service only
/// trusts a small set of known issuers, with deterministic and immutable
/// JWK URLs. Otherwise, if these values were fetched from on-chain configs,
/// an attacker who compromises governance could change these values to
/// point to a malicious issuer (or JWK URL).
```
