# Audit Report

## Title
Missing Shareholder Limit Validation During State Deserialization Leading to Staking Contract DoS

## Summary
The `DistributionPool` structure in the Rust type system lacks validation of the shareholder count against `shareholders_limit` during BCS deserialization, creating a critical invariant violation gap. While the Move VM enforces this constraint during runtime operations, corrupted or maliciously crafted state that bypasses normal execution paths could violate this invariant, causing permanent denial-of-service on staking contract operations.

## Finding Description

The staking contract system maintains a critical invariant that the number of shareholders in a distribution pool must not exceed `shareholders_limit`. This invariant is enforced in two layers:

**Move Layer Enforcement:** [1](#0-0) 

The Move code properly validates this constraint during the `add_shares` operation, preventing new shareholders from being added when the limit would be exceeded.

**Rust Layer - Missing Validation:** [2](#0-1) 

The Rust `DistributionPool` structure uses standard serde deserialization without any custom validation logic. When state is read from storage and deserialized, there is no check to ensure `shareholders.len() <= shareholders_limit`.

**Deserialization Path:** [3](#0-2) 

Resources are deserialized using `bcs::from_bytes` which relies purely on the serde `Deserialize` trait implementation, performing no semantic validation of Move-level invariants.

**Attack Scenario:**

If state becomes corrupted through any of the following paths:
1. State sync from a compromised or buggy validator node
2. Serialization bugs in the storage layer  
3. Direct write set manipulation via compromised governance
4. Storage corruption during crash recovery

Then a `DistributionPool` could exist with `shareholders.len() > shareholders_limit`. When the Move VM subsequently attempts operations on this pool: [4](#0-3) 

The `add_shares` function will always abort with `ETOO_MANY_SHAREHOLDERS` when attempting to add new shareholders, even though the pool already exceeds the limit. This causes:
- Permanent inability to add new shareholders to the pool
- Permanent inability to transfer shares to new recipients
- The staking contract becomes partially frozen
- Distribution operations may exceed expected gas limits due to iterating through more shareholders than intended [5](#0-4) 

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: The invalid state would require manual intervention or a hard fork to resolve
- **Limited DoS impact**: Existing shareholders can still operate, but new participants cannot join the pool
- **Not direct fund theft**: Funds are not stolen, but staking contract functionality is impaired
- **Validator impact**: Affected staking contracts cannot accept new delegations

This matches the "State inconsistencies requiring intervention" category for Medium severity.

## Likelihood Explanation

**Low to Medium Likelihood:**

**Prerequisites:**
- Requires pre-existing state corruption from another bug or compromise
- Cannot be directly exploited by unprivileged attackers
- Requires one of:
  - Storage layer bug causing data corruption
  - State sync vulnerability accepting invalid state
  - Compromised validator sending malicious state
  - Governance compromise allowing direct write sets

**Realistic Scenarios:**
1. Bug in state sync that accepts state without Move-level validation
2. Storage corruption during node crashes
3. Serialization/deserialization mismatch between Move VM and Rust code
4. Edge case in resource group handling

While the attack requires specific conditions, the lack of defense-in-depth validation at the deserialization layer removes an important safety check.

## Recommendation

Add custom deserialization validation for `DistributionPool` to enforce the shareholder limit invariant:

```rust
use serde::{Deserialize, Deserializer, Serialize};
use std::fmt;

#[derive(Debug, Serialize)]
pub struct DistributionPool {
    shareholders_limit: u64,
    total_coins: u64,
    total_shares: u64,
    shares: Vec<DistributionPoolShare>,
    shareholders: Vec<AccountAddress>,
    scaling_factor: u64,
}

impl<'de> Deserialize<'de> for DistributionPool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct DistributionPoolRaw {
            shareholders_limit: u64,
            total_coins: u64,
            total_shares: u64,
            shares: Vec<DistributionPoolShare>,
            shareholders: Vec<AccountAddress>,
            scaling_factor: u64,
        }
        
        let raw = DistributionPoolRaw::deserialize(deserializer)?;
        
        // Validate shareholder limit invariant
        if raw.shareholders.len() as u64 > raw.shareholders_limit {
            return Err(serde::de::Error::custom(format!(
                "Shareholder count {} exceeds limit {}",
                raw.shareholders.len(),
                raw.shareholders_limit
            )));
        }
        
        Ok(DistributionPool {
            shareholders_limit: raw.shareholders_limit,
            total_coins: raw.total_coins,
            total_shares: raw.total_shares,
            shares: raw.shares,
            shareholders: raw.shareholders,
            scaling_factor: raw.scaling_factor,
        })
    }
}
```

Apply the same validation to the `Pool` structure in `aptos-rosetta`: [6](#0-5) 

## Proof of Concept

```rust
#[test]
fn test_distribution_pool_invariant_violation_detection() {
    use aptos_types::staking_contract::DistributionPool;
    use bcs;
    
    // Manually construct invalid state with shareholders > limit
    #[derive(Serialize)]
    struct InvalidPool {
        shareholders_limit: u64,
        total_coins: u64,
        total_shares: u64,
        shares: Vec<DistributionPoolShare>,
        shareholders: Vec<AccountAddress>,
        scaling_factor: u64,
    }
    
    let invalid = InvalidPool {
        shareholders_limit: 20, // Limit is 20
        total_coins: 1000,
        total_shares: 1000,
        shares: vec![],
        shareholders: vec![AccountAddress::random(); 25], // But we have 25 shareholders
        scaling_factor: 1,
    };
    
    let serialized = bcs::to_bytes(&invalid).unwrap();
    
    // Current implementation: deserialization succeeds despite invariant violation
    let result = bcs::from_bytes::<DistributionPool>(&serialized);
    
    // With fix: deserialization should fail
    assert!(result.is_err(), "Deserialization should fail for invalid state");
}
```

## Notes

This is a defense-in-depth issue where the lack of validation creates a security gap. While the Move VM prevents creation of invalid state during normal execution, the absence of validation during deserialization means that if invalid state enters the system through any alternate path (storage corruption, state sync bugs, etc.), it will not be detected and rejected, allowing the invariant violation to persist and cause operational issues.

### Citations

**File:** aptos-move/framework/aptos-stdlib/sources/pool_u64.move (L149-168)
```text
    fun add_shares(self: &mut Pool, shareholder: address, new_shares: u64): u64 {
        if (self.contains(shareholder)) {
            let existing_shares = self.shares.borrow_mut(&shareholder);
            let current_shares = *existing_shares;
            assert!(MAX_U64 - current_shares >= new_shares, error::invalid_argument(ESHAREHOLDER_SHARES_OVERFLOW));

            *existing_shares = current_shares + new_shares;
            *existing_shares
        } else if (new_shares > 0) {
            assert!(
                self.shareholders.length() < self.shareholders_limit,
                error::invalid_state(ETOO_MANY_SHAREHOLDERS),
            );

            self.shareholders.push_back(shareholder);
            self.shares.add(shareholder, new_shares);
            new_shares
        } else {
            new_shares
        }
```

**File:** types/src/staking_contract.rs (L13-21)
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct DistributionPool {
    shareholders_limit: u64,
    total_coins: u64,
    total_shares: u64,
    shares: Vec<DistributionPoolShare>,
    shareholders: Vec<AccountAddress>,
    scaling_factor: u64,
}
```

**File:** aptos-move/e2e-move-tests/src/harness.rs (L846-855)
```rust
    pub fn read_resource<T: DeserializeOwned>(
        &self,
        addr: &AccountAddress,
        struct_tag: StructTag,
    ) -> Option<T> {
        Some(
            bcs::from_bytes::<T>(&self.read_resource_raw(addr, struct_tag)?).expect(
                "serialization expected to succeed (Rust type incompatible with Move type?)",
            ),
        )
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L966-999)
```text
        while (pool_u64::shareholders_count(distribution_pool) > 0) {
            let recipients = pool_u64::shareholders(distribution_pool);
            let recipient = *vector::borrow(&recipients, 0);
            let current_shares = pool_u64::shares(distribution_pool, recipient);
            let amount_to_distribute =
                pool_u64::redeem_shares(distribution_pool, recipient, current_shares);
            // If the recipient is the operator, send the commission to the beneficiary instead.
            if (recipient == operator) {
                recipient = beneficiary_for_operator(operator);
            };
            aptos_account::deposit_coins(
                recipient, coin::extract(&mut coins, amount_to_distribute)
            );

            if (std::features::module_event_migration_enabled()) {
                emit(
                    Distribute {
                        operator,
                        pool_address,
                        recipient,
                        amount: amount_to_distribute
                    }
                );
            } else {
                emit_event(
                    distribute_events,
                    DistributeEvent {
                        operator,
                        pool_address,
                        recipient,
                        amount: amount_to_distribute
                    }
                );
            };
```

**File:** crates/aptos-rosetta/src/types/move_types.rs (L184-191)
```rust
pub struct Pool {
    pub shareholders_limit: u64,
    pub total_coins: u64,
    pub total_shares: u64,
    pub shares: Vec<(AccountAddress, u64)>,
    pub shareholders: Vec<AccountAddress>,
    pub scaling_factor: u64,
}
```
