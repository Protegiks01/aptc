# Audit Report

## Title
Configuration Sanitizer Bypass Allows Netbench Execution on Production Networks via skip_config_sanitizer Flag

## Summary
The `skip_config_sanitizer` configuration flag allows operators to completely bypass all configuration validators, including the NetbenchConfig sanitizer that explicitly prevents netbench from running on mainnet/testnet networks. This enables netbench to be activated on production networks despite safety checks designed to prevent this.

## Finding Description
The NetbenchConfig sanitizer explicitly checks whether netbench is enabled on mainnet or testnet and returns an error if so: [1](#0-0) 

However, the global configuration sanitization system checks `node_config.node_startup.skip_config_sanitizer` before running any sanitizers and returns early if this flag is true: [2](#0-1) 

The `skip_config_sanitizer` flag is publicly accessible in the configuration structure with no restrictions: [3](#0-2) 

An operator can set this configuration to bypass sanitization at node startup, before the netbench service initializes: [4](#0-3) 

The attack path is:
1. Operator creates a node config file with `node_startup.skip_config_sanitizer: true`
2. Operator enables netbench with `netbench.enabled: true` and desired parameters
3. Node loads config via `load_from_path()` which calls sanitization
4. Sanitization exits early without checking any validators due to the flag
5. Netbench service starts and runs on mainnet/testnet

**Important Note**: This is not runtime modification after sanitization - it's a bypass of sanitization at configuration-time. The original question asks about runtime modification, which I found no evidence of. Services receive cloned configs and there's no mechanism to modify NodeConfig at runtime after the node starts.

## Impact Explanation
This qualifies as **High Severity** under the bug bounty program as it allows:
- Validator node performance degradation (netbench generates network traffic)
- Significant protocol violation (running testing tools on production)
- Network resource exhaustion affecting consensus performance

While netbench itself is a benchmarking tool, running it on production networks with `direct_send_per_second` and `rpc_per_second` parameters can:
- Generate sustained network traffic affecting validator communication
- Consume CPU and bandwidth resources
- Create potential DoS conditions during critical consensus operations

## Likelihood Explanation
**Likelihood: Medium-Low**

This requires:
- Operator-level access to modify the node configuration file
- Knowledge of the bypass mechanism
- Deliberate configuration to enable both flags

However, operators are considered trusted roles per the security model, reducing the severity. The vulnerability primarily affects scenarios where:
- Operator account is compromised
- Misconfiguration by operators unaware of security implications
- Malicious insider with operator access

## Recommendation
1. **Remove or restrict the flag**: Consider removing `skip_config_sanitizer` from production builds or restricting it to debug/test builds only.

2. **Add critical warnings**: If the flag must remain, log a critical warning that cannot be suppressed:

```rust
if node_config.node_startup.skip_config_sanitizer {
    error!("CRITICAL: Config sanitizer is disabled! This should NEVER be used in production.");
    if chain_id.is_mainnet() || chain_id.is_testnet() {
        return Err(Error::ConfigSanitizerFailed(
            "NodeConfig".to_string(),
            "Cannot skip config sanitizer on production networks!".to_string(),
        ));
    }
    return Ok(());
}
```

3. **Add runtime checks**: Implement independent chain_id verification in netbench service initialization that cannot be bypassed via config flags.

4. **Configuration validation**: Add external validation tooling that audits node configs before deployment to detect dangerous flag combinations.

## Proof of Concept

Create a mainnet node configuration file `mainnet_node.yaml`:

```yaml
base:
  role: "validator"
  
node_startup:
  skip_config_sanitizer: true  # Bypass all safety checks
  
netbench:
  enabled: true  # Enable netbench on mainnet
  max_network_channel_size: 1000
  enable_direct_send_testing: true
  direct_send_data_size: 102400  # 100KB
  direct_send_per_second: 1000   # 1000 messages/sec
  
# ... other required mainnet config ...
```

Start the node:
```bash
cargo run --release -- -f mainnet_node.yaml
```

Expected behavior: Node should reject netbench on mainnet
Actual behavior: Node starts with netbench enabled, bypassing the sanitizer check

The test case demonstrating the bypass exists in the codebase: [5](#0-4) 

---

**Notes**: While this is a real security concern, it does not directly answer the original question about "runtime modification after sanitize() has been called." I found no evidence that NodeConfig can be modified at runtime after the node starts. Services receive cloned configurations, and there are no APIs or mechanisms to modify the running configuration. The vulnerability described here is a configuration-time bypass, not runtime modification.

### Citations

**File:** config/src/config/netbench_config.rs (L65-74)
```rust
        // Otherwise, verify that netbench is not enabled in testnet or mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_testnet() || chain_id.is_mainnet() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The netbench application should not be enabled in testnet or mainnet!"
                        .to_string(),
                ));
            }
        }
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L225-238)
```rust
        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
```

**File:** config/src/config/node_startup_config.rs (L6-11)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** aptos-node/src/network.rs (L391-400)
```rust
        if let Some(app_config) = netbench_network_configuration(node_config) {
            let netbench_handle = register_client_and_service_with_network(
                &mut network_builder,
                network_id,
                &network_config,
                app_config,
                true,
            );
            netbench_handles.push(netbench_handle);
        }
```
