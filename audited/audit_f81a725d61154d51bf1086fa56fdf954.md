# Audit Report

## Title
Silent Error Suppression in Rosetta Stake Balance API Causes Incorrect Zero-Balance Reporting to Exchanges

## Summary
The `get_stake_balances()` function in the Rosetta API implementation incorrectly returns `Ok(None)` for ALL error types when retrieving StakePool resources, including network failures, timeouts, and API errors. [1](#0-0)  This silent error suppression causes the calling code to report empty balances to exchanges when transient errors occur, leading exchanges to incorrectly interpret accounts with actual staked funds as having zero balance.

## Finding Description

The vulnerability exists in the error handling pattern of `get_stake_balances()` function. [2](#0-1) 

The function uses an `if let Ok(response)` pattern that catches ALL error types and returns `Ok(None)` in the else branch. This includes legitimate errors like:
- Network connection failures (`RestError::Http`)
- Request timeouts (`RestError::Timeout`) 
- API server errors (500, 503 status codes)
- BCS deserialization errors (`RestError::Bcs`)
- JSON parsing errors (`RestError::Json`) [3](#0-2) 

The correct pattern is demonstrated by `get_sequence_number()` in the same codebase, which explicitly checks for `AccountNotFound` and `ResourceNotFound` error codes before returning default values, and propagates all other errors. [4](#0-3) 

The calling code in `get_staking_info()` treats `Ok(None)` as a non-error condition, only logging a warning. [5](#0-4)  When all stake pool retrievals fail due to transient errors, the `has_staking` flag remains false, and no balance is added to the response. [6](#0-5) 

**Attack Scenario:**
1. Exchange uses Rosetta API to check user's staking balance (user has 1000 APT staked)
2. During API call, REST API node experiences high load and returns HTTP 503 error
3. `get_stake_balances()` catches error and returns `Ok(None)`
4. Calling code logs warning but continues with empty balances
5. Exchange receives `AccountBalanceResponse` with empty `balances` array [7](#0-6) 
6. Exchange interprets empty array as zero balance
7. Exchange may incorrectly report zero balance to user, affect accounting, or make wrong financial decisions

## Impact Explanation

**Medium Severity** - This vulnerability meets the Medium severity criteria for:
- **"State inconsistencies requiring intervention"**: The API returns inconsistent state (empty balances) when actual balances exist but cannot be retrieved due to errors
- **"Limited funds loss or manipulation"**: While no direct on-chain fund loss occurs, incorrect balance reporting can lead to off-chain financial impacts for exchanges and users

The impact is not Critical or High because:
- Does not violate on-chain consensus or cause direct fund theft
- Requires transient error condition to trigger
- Affects off-chain integration layer (Rosetta API), not core protocol

However, for exchanges using Rosetta API for balance tracking, this can cause:
- Incorrect user balance displays
- Wrong accounting and reconciliation
- Potential incorrect business logic decisions based on balance data
- User confusion and support burden

## Likelihood Explanation

**High Likelihood** - This vulnerability will occur naturally during normal operations:

1. **Common Trigger Conditions:**
   - Network instability between Rosetta server and REST API node
   - API node under high load returning 503 errors
   - API node restarts or maintenance windows
   - Network timeouts during peak usage
   - BCS deserialization failures due to state inconsistencies

2. **No Attacker Action Required:**
   - Vulnerability triggers automatically during error conditions
   - No special permissions or attack sophistication needed
   - Affects all exchanges using Rosetta API for stake balance queries

3. **Production Environment Factors:**
   - Distributed systems commonly experience transient failures
   - Load balancers, network congestion, service restarts all create error conditions
   - Multi-region deployments increase network error probability

## Recommendation

Implement proper error handling by distinguishing between "resource not found" (legitimate zero balance) and actual errors (should propagate): [8](#0-7) 

Replace the current error handling with explicit error code checking:

```rust
match rest_client
    .get_account_resource_at_version_bcs::<StakePool>(pool_address, STAKE_POOL, version)
    .await
{
    Ok(response) => {
        let stake_pool = response.into_inner();
        // ... existing processing logic ...
    }
    Err(RestError::Api(AptosErrorResponse {
        error:
            AptosError {
                error_code: AptosErrorCode::ResourceNotFound,
                ..
            },
        ..
    }))
    | Err(RestError::Api(AptosErrorResponse {
        error:
            AptosError {
                error_code: AptosErrorCode::AccountNotFound,
                ..
            },
        ..
    })) => {
        // Resource legitimately doesn't exist
        Ok(None)
    }
    Err(e) => {
        // Propagate all other errors
        Err(ApiError::InternalError(Some(format!(
            "Failed to retrieve StakePool for address {}: {}",
            pool_address, e
        ))))
    }
}
```

This pattern matches the correct implementation in `get_sequence_number()`. [9](#0-8) 

## Proof of Concept

Create a Rust integration test that simulates the vulnerability:

```rust
#[tokio::test]
async fn test_stake_balance_error_handling() {
    // Setup: Create account with staking contract
    let mut context = new_test_context().await;
    let account = context.create_account().await;
    let stake_amount = 1_000_000_000; // 1000 APT
    
    // Setup staking contract with actual stake
    context.setup_staking_contract(&account, stake_amount).await;
    
    // Verify balance retrieval works normally
    let request = AccountBalanceRequest {
        network_identifier: context.network_id(),
        account_identifier: account.staking_identifier(),
        block_identifier: None,
        currencies: Some(vec![native_coin()]),
    };
    
    let response = account_balance(request.clone(), context.server_context())
        .await
        .unwrap();
    assert_eq!(response.balances.len(), 1);
    assert_eq!(response.balances[0].value, stake_amount.to_string());
    
    // Simulate REST API node failure by stopping the backend
    context.stop_rest_api_node().await;
    
    // Bug: This should return an error, but instead returns empty balances
    let response_during_error = account_balance(request, context.server_context())
        .await
        .unwrap();
    
    // VULNERABILITY: Empty balances returned when error occurred
    assert_eq!(response_during_error.balances.len(), 0); // Should fail but passes
    
    // Exchange would interpret this as zero balance when user has 1000 APT staked
}
```

This demonstrates that during API failures, the function returns success with empty balances rather than propagating the error, causing exchanges to see zero balance for accounts with actual stake.

## Notes

**Additional Context:**
- The same issue may exist in `get_delegation_stake_balances()` but with different behavior - it returns `InternalError` when `parse_requested_balance` returns `None`. [10](#0-9) 
- The vulnerability specifically affects exchanges and integrations using the Rosetta API `/account/balance` endpoint
- Regular REST API clients are not affected as they receive proper errors
- The Rosetta API specification expects errors to be returned when data cannot be retrieved, not silent None values

### Citations

**File:** crates/aptos-rosetta/src/types/misc.rs (L288-381)
```rust
pub async fn get_stake_balances(
    rest_client: &aptos_rest_client::Client,
    owner_account: &AccountIdentifier,
    pool_address: AccountAddress,
    version: u64,
) -> ApiResult<Option<BalanceResult>> {
    const STAKE_POOL: &str = "0x1::stake::StakePool";

    // Retreive the pool resource
    if let Ok(response) = rest_client
        .get_account_resource_at_version_bcs::<StakePool>(pool_address, STAKE_POOL, version)
        .await
    {
        let stake_pool = response.into_inner();

        // Stake isn't allowed for base accounts
        if owner_account.is_base_account() {
            return Err(ApiError::InvalidInput(Some(
                "Stake pool not supported for base account".to_string(),
            )));
        }

        // If the operator address is different, skip
        if owner_account.is_operator_stake()
            && owner_account.operator_address()? != stake_pool.operator_address
        {
            return Err(ApiError::InvalidInput(Some(
                "Stake pool not for matching operator".to_string(),
            )));
        }

        // Any stake pools that match, retrieve that.
        let mut requested_balance: Option<String> = None;
        let lockup_expiration = stake_pool.locked_until_secs;
        let owner_address = owner_account.account_address()?;
        let operator_address = stake_pool.operator_address;

        let staking_contract_amounts_response = view::<Vec<u64>>(
            rest_client,
            version,
            AccountAddress::ONE,
            ident_str!(STAKING_CONTRACT_MODULE),
            ident_str!("staking_contract_amounts"),
            vec![],
            vec![
                bcs::to_bytes(&owner_address)?,
                bcs::to_bytes(&operator_address)?,
            ],
        )
        .await?;
        let total_active_stake = staking_contract_amounts_response[0];
        let accumulated_rewards = staking_contract_amounts_response[1];
        let commission_amount = staking_contract_amounts_response[2];

        // TODO: I think all of these are off, probably need to recalculate all of them
        // see the get_staking_contract_amounts_internal function in staking_contract.move for more
        // information on why commission is only subtracted from active and total stake
        if owner_account.is_active_stake() {
            // active stake is principal and rewards (including commission) so subtract the commission
            requested_balance = Some((total_active_stake - commission_amount).to_string());
        } else if owner_account.is_pending_active_stake() {
            // pending_active cannot have commission because it is new principal
            requested_balance = Some(stake_pool.pending_active.to_string());
        } else if owner_account.is_inactive_stake() {
            // inactive will not have commission because commission has already been extracted
            requested_balance = Some(stake_pool.inactive.to_string());
        } else if owner_account.is_pending_inactive_stake() {
            // pending_inactive will not have commission because commission has already been extracted
            requested_balance = Some(stake_pool.pending_inactive.to_string());
        } else if owner_account.is_total_stake() {
            // total stake includes commission since it includes active stake, which includes commission
            requested_balance =
                Some((stake_pool.get_total_staked_amount() - commission_amount).to_string());
        } else if owner_account.is_commission() {
            requested_balance = Some(commission_amount.to_string());
        } else if owner_account.is_rewards() {
            requested_balance = Some(accumulated_rewards.to_string());
        }

        if let Some(balance) = requested_balance {
            Ok(Some(BalanceResult {
                balance: Some(Amount {
                    value: balance,
                    currency: native_coin(),
                }),
                lockup_expiration,
            }))
        } else {
            Ok(None)
        }
    } else {
        Ok(None)
    }
}
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L431-434)
```rust
        Err(ApiError::InternalError(Some(
            "Unable to construct BalanceResult instance".to_string(),
        )))
    }
```

**File:** crates/aptos-rest-client/src/error.rs (L147-162)
```rust
pub enum RestError {
    #[error("API error {0}")]
    Api(AptosErrorResponse),
    #[error("BCS ser/de error {0}")]
    Bcs(bcs::Error),
    #[error("JSON er/de error {0}")]
    Json(serde_json::Error),
    #[error("URL Parse error {0}")]
    UrlParse(url::ParseError),
    #[error("Timeout waiting for transaction {0}")]
    Timeout(&'static str),
    #[error("Unknown error {0}")]
    Unknown(anyhow::Error),
    #[error("HTTP error {0}: {1}")]
    Http(StatusCode, reqwest::Error),
}
```

**File:** crates/aptos-rosetta/src/account.rs (L162-204)
```rust
async fn get_sequence_number(
    rest_client: &Client,
    owner_address: AccountAddress,
    version: u64,
) -> ApiResult<u64> {
    // Retrieve sequence number
    let sequence_number = match rest_client
        .get_account_resource_at_version_bcs(owner_address, "0x1::account::Account", version)
        .await
    {
        Ok(response) => {
            let account: AccountResource = response.into_inner();
            account.sequence_number()
        },
        Err(RestError::Api(AptosErrorResponse {
            error:
                AptosError {
                    error_code: AptosErrorCode::AccountNotFound,
                    ..
                },
            ..
        }))
        | Err(RestError::Api(AptosErrorResponse {
            error:
                AptosError {
                    error_code: AptosErrorCode::ResourceNotFound,
                    ..
                },
            ..
        })) => {
            // If the account or resource doesn't exist, set the sequence number to 0
            0
        },
        _ => {
            // Any other error we can't retrieve the sequence number
            return Err(ApiError::InternalError(Some(
                "Failed to retrieve account sequence number".to_string(),
            )));
        },
    };

    Ok(sequence_number)
}
```

**File:** crates/aptos-rosetta/src/account.rs (L227-242)
```rust
            match get_stake_balances(rest_client, account, contract.pool_address, version).await {
                Ok(Some(balance_result)) => {
                    if let Some(balance) = balance_result.balance {
                        has_staking = true;
                        total_balance += u64::from_str(&balance.value).unwrap_or_default();
                    }
                    // TODO: This seems like it only works if there's only one staking contract (hopefully it stays that way)
                    lockup_expiration = balance_result.lockup_expiration;
                },
                result => {
                    warn!(
                        "Failed to retrieve requested balance for account: {}, address: {}: {:?}",
                        owner_address, contract.pool_address, result
                    )
                },
            }
```

**File:** crates/aptos-rosetta/src/account.rs (L244-249)
```rust
        if has_staking {
            balances.push(Amount {
                value: total_balance.to_string(),
                currency: native_coin(),
            })
        }
```

**File:** crates/aptos-rosetta/src/types/requests.rs (L43-51)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct AccountBalanceResponse {
    /// Block containing the balance
    pub block_identifier: BlockIdentifier,
    /// Balances of all known currencies
    pub balances: Vec<Amount>,
    /// Metadata of account, must have sequence number
    pub metadata: AccountBalanceMetadata,
}
```
