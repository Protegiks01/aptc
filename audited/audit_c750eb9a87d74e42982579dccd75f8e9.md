# Audit Report

## Title
Protocol Negotiation Bypass Allowing Forced Decompression DoS Attack

## Summary
The network layer fails to validate that incoming message protocol IDs were negotiated during the handshake. An attacker can send messages using compressed protocol variants (e.g., `ConsensusRpcCompressed`) even when only uncompressed variants (e.g., `ConsensusRpcBcs`) were negotiated, forcing validators to perform CPU-intensive decompression operations they did not agree to support.

## Finding Description

The Aptos network protocol performs a handshake where peers negotiate which application protocols they mutually support. [1](#0-0) 

However, when receiving messages, the node only validates that a local handler exists for the protocol ID, without checking if that protocol was actually negotiated during the handshake. [2](#0-1) 

Each `ProtocolId` has a fixed encoding type that determines whether messages are compressed. [3](#0-2) 

When decoding messages, the protocol ID from the wire determines the encoding method used. [4](#0-3) 

**Attack Path:**
1. Attacker connects to victim validator
2. During handshake, they negotiate to support only `ConsensusRpcBcs` (uncompressed, protocol ID 0)
3. After handshake, attacker sends `RpcRequest` messages with `protocol_id = ConsensusRpcCompressed` (compressed, protocol ID 11)
4. Victim's `handle_inbound_network_message()` checks if `upstream_handlers` contains a handler for protocol ID 11 (it does, because the node supports it locally)
5. No validation occurs to check if protocol ID 11 was negotiated during handshake
6. The message is forwarded to the handler, which calls `from_bytes()` with `ConsensusRpcCompressed`
7. Decompression is performed even though compression was never agreed upon [5](#0-4) 
8. The attacker successfully forces the victim to waste CPU cycles on decompression

The sender-side properly validates protocols against negotiated sets, [6](#0-5)  but the receiver-side lacks this validation.

## Impact Explanation

This qualifies as **HIGH severity** under the Aptos bug bounty program for multiple reasons:

1. **Validator Node Slowdowns**: Decompression using LZ4 is CPU-intensive. [7](#0-6)  An attacker can flood a validator with compressed messages, forcing continuous decompression and degrading consensus performance.

2. **Significant Protocol Violations**: The handshake negotiation is a fundamental security mechanism. Bypassing it undermines the entire protocol's trust model and violates the assumption that negotiated protocols are binding.

3. **Defense Bypass**: If a validator operator explicitly disables compression support to reduce attack surface or CPU load during an ongoing attack, this vulnerability allows attackers to re-enable it unilaterally.

## Likelihood Explanation

**Likelihood: HIGH**

- **No special privileges required**: Any peer that can establish a network connection can exploit this
- **Simple to execute**: Requires only crafting a `NetworkMessage` with a different protocol ID
- **Difficult to detect**: Normal monitoring wouldn't distinguish between legitimate compressed messages and forced compressed messages
- **Affects all validators**: Every validator node accepts incoming network messages and is vulnerable
- **No rate limiting**: Attacker can send unlimited malicious messages to maximize CPU consumption

## Recommendation

Add validation in `handle_inbound_network_message()` to verify that the protocol ID in received messages was negotiated during handshake:

```rust
fn handle_inbound_network_message(
    &mut self,
    message: NetworkMessage,
) -> Result<(), PeerManagerError> {
    match &message {
        NetworkMessage::DirectSendMsg(direct) => {
            // ADD: Validate protocol was negotiated
            if !self.connection_metadata.application_protocols.contains(direct.protocol_id) {
                warn!(
                    "Received DirectSendMsg with non-negotiated protocol: {:?}",
                    direct.protocol_id
                );
                return Ok(()); // Drop the message
            }
            
            // Existing handler lookup code...
        },
        NetworkMessage::RpcRequest(request) => {
            // ADD: Validate protocol was negotiated
            if !self.connection_metadata.application_protocols.contains(request.protocol_id) {
                warn!(
                    "Received RpcRequest with non-negotiated protocol: {:?}",
                    request.protocol_id
                );
                return Ok(()); // Drop the message
            }
            
            // Existing handler lookup code...
        },
        // ... rest of match
    }
}
```

The `connection_metadata.application_protocols` field contains the negotiated protocols from the handshake and should be used as the authoritative source.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// File: network/framework/src/peer/test_protocol_bypass.rs

use crate::{
    protocols::wire::{
        handshake::v1::{HandshakeMsg, MessagingProtocolVersion, ProtocolId, ProtocolIdSet},
        messaging::v1::{NetworkMessage, RpcRequest},
    },
};

#[test]
fn test_protocol_negotiation_bypass() {
    // Setup: Two peers negotiate only uncompressed protocols
    let mut supported_protocols = ProtocolIdSet::empty();
    supported_protocols.insert(ProtocolId::ConsensusRpcBcs); // Uncompressed
    
    let handshake_msg = HandshakeMsg {
        supported_protocols: [(MessagingProtocolVersion::V1, supported_protocols)]
            .iter()
            .cloned()
            .collect(),
        chain_id: ChainId::test(),
        network_id: NetworkId::Validator,
    };
    
    // After handshake, only ConsensusRpcBcs is negotiated
    let (_, negotiated) = handshake_msg.perform_handshake(&handshake_msg).unwrap();
    assert!(negotiated.contains(ProtocolId::ConsensusRpcBcs));
    assert!(!negotiated.contains(ProtocolId::ConsensusRpcCompressed));
    
    // Attack: Create message claiming to use compressed protocol
    let malicious_message = NetworkMessage::RpcRequest(RpcRequest {
        protocol_id: ProtocolId::ConsensusRpcCompressed, // NOT negotiated!
        request_id: 1,
        priority: 0,
        raw_request: vec![/* compressed data */],
    });
    
    // The message would be accepted by handle_inbound_network_message()
    // because it only checks upstream_handlers, not negotiated protocols
    // This forces the victim to decompress data they didn't agree to handle
}
```

## Notes

The vulnerability exists because the receiver-side message handling assumes that peers will only send messages using negotiated protocols, but this assumption is not enforced by code. The sender-side properly validates against negotiated protocols, creating an asymmetry that attackers can exploit. This breaks the protocol negotiation security guarantee and can be used for denial-of-service attacks against validators.

### Citations

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L156-172)
```rust
    fn encoding(self) -> Encoding {
        match self {
            ProtocolId::ConsensusDirectSendJson | ProtocolId::ConsensusRpcJson => Encoding::Json,
            ProtocolId::ConsensusDirectSendCompressed | ProtocolId::ConsensusRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
            ProtocolId::ConsensusObserver => Encoding::CompressedBcs(RECURSION_LIMIT),
            ProtocolId::DKGDirectSendCompressed | ProtocolId::DKGRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
            ProtocolId::JWKConsensusDirectSendCompressed
            | ProtocolId::JWKConsensusRpcCompressed => Encoding::CompressedBcs(RECURSION_LIMIT),
            ProtocolId::MempoolDirectSend => Encoding::CompressedBcs(USER_INPUT_RECURSION_LIMIT),
            ProtocolId::MempoolRpc => Encoding::Bcs(USER_INPUT_RECURSION_LIMIT),
            _ => Encoding::Bcs(RECURSION_LIMIT),
        }
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L226-252)
```rust
    pub fn from_bytes<T: DeserializeOwned>(&self, bytes: &[u8]) -> anyhow::Result<T> {
        // Start the deserialization timer
        let deserialization_timer = start_serialization_timer(*self, DESERIALIZATION_LABEL);

        // Deserialize the message
        let result = match self.encoding() {
            Encoding::Bcs(limit) => self.bcs_decode(bytes, limit),
            Encoding::CompressedBcs(limit) => {
                let compression_client = self.get_compression_client();
                let raw_bytes = aptos_compression::decompress(
                    &bytes.to_vec(),
                    compression_client,
                    MAX_APPLICATION_MESSAGE_SIZE,
                )
                .map_err(|e| anyhow! {"{:?}", e})?;
                self.bcs_decode(&raw_bytes, limit)
            },
            Encoding::Json => serde_json::from_slice(bytes).map_err(|e| anyhow!("{:?}", e)),
        };

        // Only record the duration if deserialization was successful
        if result.is_ok() {
            deserialization_timer.observe_duration();
        }

        result
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L431-465)
```rust
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/peer/mod.rs (L447-492)
```rust
    fn handle_inbound_network_message(
        &mut self,
        message: NetworkMessage,
    ) -> Result<(), PeerManagerError> {
        match &message {
            NetworkMessage::DirectSendMsg(direct) => {
                let data_len = direct.raw_msg.len();
                network_application_inbound_traffic(
                    self.network_context,
                    direct.protocol_id,
                    data_len as u64,
                );
                match self.upstream_handlers.get(&direct.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(data_len as u64);
                    },
                    Some(handler) => {
                        let key = (self.connection_metadata.remote_peer_id, direct.protocol_id);
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        match handler.push(key, ReceivedMessage::new(message, sender)) {
                            Err(_err) => {
                                // NOTE: aptos_channel never returns other than Ok(()), but we might switch to tokio::sync::mpsc and then this would work
                                counters::direct_send_messages(
                                    &self.network_context,
                                    DECLINED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, DECLINED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                            Ok(_) => {
                                counters::direct_send_messages(
                                    &self.network_context,
                                    RECEIVED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, RECEIVED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                        }
                    },
                }
```

**File:** network/framework/src/application/interface.rs (L142-158)
```rust
    fn get_preferred_protocol_for_peer(
        &self,
        peer: &PeerNetworkId,
        preferred_protocols: &[ProtocolId],
    ) -> Result<ProtocolId, Error> {
        let protocols_supported_by_peer = self.get_supported_protocols(peer)?;
        for protocol in preferred_protocols {
            if protocols_supported_by_peer.contains(*protocol) {
                return Ok(*protocol);
            }
        }
        Err(Error::NetworkError(format!(
            "None of the preferred protocols are supported by this peer! \
            Peer: {:?}, supported protocols: {:?}",
            peer, protocols_supported_by_peer
        )))
    }
```

**File:** crates/aptos-compression/src/lib.rs (L44-89)
```rust
pub fn compress(
    raw_data: Vec<u8>,
    client: CompressionClient,
    max_bytes: usize,
) -> Result<CompressedData, Error> {
    // Start the compression timer
    let start_time = Instant::now();

    // Ensure that the raw data size is not greater than the max bytes limit
    if raw_data.len() > max_bytes {
        let error_string = format!(
            "Raw data size greater than max bytes limit: {}, max: {}",
            raw_data.len(),
            max_bytes
        );
        return create_compression_error(&client, error_string);
    }

    // Compress the data
    let compression_mode = CompressionMode::FAST(ACCELERATION_PARAMETER);
    let compressed_data = match lz4::block::compress(&raw_data, Some(compression_mode), true) {
        Ok(compressed_data) => compressed_data,
        Err(error) => {
            let error_string = format!("Failed to compress the data: {}", error);
            return create_compression_error(&client, error_string);
        },
    };

    // Ensure that the compressed data size is not greater than the max byte
    // limit. This can happen in the case of uncompressible data, where the
    // compressed data is larger than the uncompressed data.
    if compressed_data.len() > max_bytes {
        let error_string = format!(
            "Compressed size greater than max bytes limit: {}, max: {}",
            compressed_data.len(),
            max_bytes
        );
        return create_compression_error(&client, error_string);
    }

    // Stop the timer and update the metrics
    metrics::observe_compression_operation_time(&client, start_time);
    metrics::update_compression_metrics(&client, &raw_data, &compressed_data);

    Ok(compressed_data)
}
```
