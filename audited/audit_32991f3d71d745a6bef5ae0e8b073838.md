# Audit Report

## Title
Byzantine Validators Can Inject Invalid Transactions Into Quorum Store Batches Due to Missing Transaction-Level Validation

## Summary
The quorum store batch coordinator accepts and persists batches from Byzantine validators without validating individual transaction signatures or semantic validity. Honest validators sign batch metadata (`BatchInfo`) for batches containing invalid transactions, enabling Byzantine validators to waste network bandwidth, storage, and CPU resources while making honest validators complicit in propagating malicious batches.

## Finding Description

When batches are forwarded to batch coordinators in `NetworkListener::start()`, the coordinator does NOT re-validate individual transactions within the batches. The validation flow has a critical gap:

**Upstream Verification (Insufficient):**

The `BatchMsg::verify()` function only validates structural properties: [1](#0-0) 

The `Batch::verify()` function only checks metadata consistency: [2](#0-1) 

**Neither function validates:**
- Transaction signatures
- Sequence numbers
- Account balances
- Transaction expiration times
- Any semantic transaction validity

**Batch Forwarding Without Validation:**

The `NetworkListener` forwards batches to coordinators without transaction validation: [3](#0-2) 

**Batch Coordinator Persists Without Validation:**

The `BatchCoordinator::handle_batches_msg()` only checks limits and applies filtering, but does NOT validate transaction signatures: [4](#0-3) 

**Critical Issue - Honest Validators Sign Unvalidated Batches:**

When batches are persisted, honest validators immediately generate `SignedBatchInfo` by signing the batch metadata WITHOUT validating the transactions: [5](#0-4) 

**Transaction Validation Happens Too Late:**

Transaction signature verification only occurs during the block preparation phase, AFTER batches have been persisted and signed: [6](#0-5) 

Invalid transactions are handled during execution, but by then resources have already been wasted: [7](#0-6) 

**Attack Flow:**

1. Byzantine validator creates a batch with transactions containing invalid signatures
2. Batch passes `BatchMsg::verify()` and `Batch::verify()` (only structural checks)
3. `NetworkListener` forwards batch to `BatchCoordinator`
4. `BatchCoordinator` persists batch without validating transactions
5. `BatchStore` generates `SignedBatchInfo`, causing honest validator to sign the batch metadata
6. Byzantine validator collects signatures from honest validators
7. `ProofOfStore` is created with aggregated signatures from honest validators
8. Batch is included in a block proposal
9. During execution, invalid transactions are finally detected and discarded
10. Resources wasted: bandwidth (broadcasting), storage (persisting), CPU (signature verification)

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per Aptos bug bounty criteria:

**Validator Node Slowdowns:**
- Byzantine validators can fill their quorum store quota with batches containing invalid transactions
- Honest validators waste CPU cycles on signature verification during block execution
- The parallel signature verification pool processes invalid transactions that should have been rejected earlier

**Significant Protocol Violation:**
- Honest validators sign `BatchInfo` for batches they have not fully validated
- This makes honest validators complicit in propagating malicious batches
- Violates the security assumption that signed batch info indicates validated content
- Undermines the trust model of the quorum store proof-of-store mechanism

**Resource Exhaustion:**
- Network bandwidth wasted broadcasting invalid batches
- Storage consumed persisting invalid batches (both in-memory cache and database)
- Quorum store quota consumed by invalid batches, potentially crowding out legitimate transactions
- CPU wasted on signature verification during execution

While this does not break consensus safety (all validators deterministically reject the same invalid transactions), it represents a significant protocol weakness exploitable by Byzantine validators to degrade network performance.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Low Barrier to Entry**: Any validator in the active validator set (up to 1/3 Byzantine) can execute this attack
2. **Sustained Attack**: Byzantine validators can continuously generate batches with invalid transactions
3. **No Detection**: There is no mechanism to detect or penalize validators who submit batches with invalid transactions
4. **Bounded but Repeatable**: While per-batch limits exist, attackers can create multiple batches within their quota
5. **Amplification**: One Byzantine validator can cause multiple honest validators to waste resources signing and storing invalid batches

The attack requires only:
- Being in the active validator set
- Creating transactions with invalid signatures (trivial)
- Following the normal batch creation and broadcast protocol

## Recommendation

**Implement transaction-level validation before signing batch metadata:**

Add transaction signature verification in `BatchCoordinator::handle_batches_msg()` before persisting batches:

```rust
pub(crate) async fn handle_batches_msg(
    &mut self,
    author: PeerId,
    batches: Vec<Batch<BatchInfoExt>>,
) {
    if let Err(e) = self.ensure_max_limits(&batches) {
        error!("Batch from {}: {}", author, e);
        counters::RECEIVED_BATCH_MAX_LIMIT_FAILED.inc();
        return;
    }

    // ADD: Validate transaction signatures before persisting
    for batch in batches.iter() {
        for txn in batch.txns() {
            if let Err(e) = txn.verify_signature() {
                error!(
                    "Invalid transaction signature in batch {} from {}: {}",
                    batch.digest(),
                    author.short_str().as_str(),
                    e
                );
                counters::RECEIVED_BATCH_INVALID_SIGNATURE.inc();
                return; // Reject entire batch
            }
        }
    }

    // ... rest of function
}
```

**Alternative (Less Strict)**: Add sampling-based validation to detect malicious batches probabilistically while minimizing performance impact.

**Additional Measures:**
- Track and penalize validators who repeatedly submit batches with invalid transactions
- Add metrics to monitor invalid transaction rates per validator
- Consider slashing or reputation penalties for repeated violations

## Proof of Concept

```rust
// Proof of Concept: Byzantine validator creates batch with invalid transactions

use aptos_crypto::{ed25519::{Ed25519PrivateKey, Ed25519PublicKey}, PrivateKey, Uniform};
use aptos_types::transaction::{RawTransaction, SignedTransaction, TransactionPayload};
use aptos_types::chain_id::ChainId;
use rand::thread_rng;

fn create_invalid_batch() -> Vec<SignedTransaction> {
    let mut rng = thread_rng();
    let mut invalid_txns = vec![];
    
    for _ in 0..100 {
        // Create a valid raw transaction
        let sender_private_key = Ed25519PrivateKey::generate(&mut rng);
        let sender = aptos_types::account_address::AccountAddress::from_public_key(
            &sender_private_key.public_key()
        );
        
        let raw_txn = RawTransaction::new(
            sender,
            0, // sequence number
            TransactionPayload::Script(aptos_types::transaction::Script::new(vec![], vec![], vec![])),
            1000, // max_gas_amount
            1, // gas_unit_price
            u64::MAX, // expiration_timestamp_secs
            ChainId::test(),
        );
        
        // Sign with WRONG private key to create invalid signature
        let wrong_private_key = Ed25519PrivateKey::generate(&mut rng);
        let signature = wrong_private_key.sign(&raw_txn).unwrap();
        
        // Create SignedTransaction with mismatched signature
        let signed_txn = SignedTransaction::new(
            raw_txn,
            sender_private_key.public_key(),
            signature,
        );
        
        // This transaction will pass structural checks but fail signature verification
        invalid_txns.push(signed_txn);
    }
    
    invalid_txns
}

// Byzantine validator creates batch with these invalid transactions
// Batch passes BatchMsg::verify() and Batch::verify() (only structural checks)
// Honest validators sign the BatchInfo without validating signatures
// Resources wasted when transactions are rejected during execution
```

## Notes

This vulnerability exploits a validation gap in the quorum store's batch processing pipeline. While the system eventually detects and rejects invalid transactions during execution, this occurs too lateâ€”after honest validators have already signed batch metadata and wasted resources processing malicious batches. The attack is particularly concerning because it undermines the security guarantees of the proof-of-store mechanism by making honest validators unknowingly attest to batches containing invalid data.

### Citations

**File:** consensus/src/quorum_store/types.rs (L262-290)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        ensure!(
            self.payload.author() == self.author(),
            "Payload author doesn't match the info"
        );
        ensure!(
            self.payload.hash() == *self.digest(),
            "Payload hash doesn't match the digest"
        );
        ensure!(
            self.payload.num_txns() as u64 == self.num_txns(),
            "Payload num txns doesn't match batch info"
        );
        ensure!(
            self.payload.num_bytes() as u64 == self.num_bytes(),
            "Payload num bytes doesn't match batch info"
        );
        for txn in self.payload.txns() {
            ensure!(
                txn.gas_unit_price() >= self.gas_bucket_start(),
                "Payload gas unit price doesn't match batch info"
            );
            ensure!(
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/types.rs (L433-461)
```rust
    pub fn verify(
        &self,
        peer_id: PeerId,
        max_num_batches: usize,
        verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(!self.batches.is_empty(), "Empty message");
        ensure!(
            self.batches.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.batches.len(),
            max_num_batches
        );
        let epoch_authors = verifier.address_to_validator_index();
        for batch in self.batches.iter() {
            ensure!(
                epoch_authors.contains_key(&batch.author()),
                "Invalid author {} for batch {} in current epoch",
                batch.author(),
                batch.digest()
            );
            ensure!(
                batch.author() == peer_id,
                "Batch author doesn't match sender"
            );
            batch.verify()?
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/network_listener.rs (L68-94)
```rust
                    VerifiedEvent::BatchMsg(batch_msg) => {
                        counters::QUORUM_STORE_MSG_COUNT
                            .with_label_values(&["NetworkListener::batchmsg"])
                            .inc();
                        // Batch msg verify function alreay ensures that the batch_msg is not empty.
                        let author = batch_msg.author().expect("Empty batch message");
                        let batches = batch_msg.take();
                        counters::RECEIVED_BATCH_MSG_COUNT.inc();

                        // Round-robin assignment to batch coordinator.
                        let idx = next_batch_coordinator_idx;
                        next_batch_coordinator_idx = (next_batch_coordinator_idx + 1)
                            % self.remote_batch_coordinator_tx.len();
                        trace!(
                            "QS: peer_id {:?},  # network_worker {}, hashed to idx {}",
                            author,
                            self.remote_batch_coordinator_tx.len(),
                            idx
                        );
                        counters::BATCH_COORDINATOR_NUM_BATCH_REQS
                            .with_label_values(&[&idx.to_string()])
                            .inc();
                        self.remote_batch_coordinator_tx[idx]
                            .send(BatchCoordinatorCommand::NewBatches(author, batches))
                            .await
                            .expect("Could not send remote batch");
                    },
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L173-245)
```rust
    pub(crate) async fn handle_batches_msg(
        &mut self,
        author: PeerId,
        batches: Vec<Batch<BatchInfoExt>>,
    ) {
        if let Err(e) = self.ensure_max_limits(&batches) {
            error!("Batch from {}: {}", author, e);
            counters::RECEIVED_BATCH_MAX_LIMIT_FAILED.inc();
            return;
        }

        let Some(batch) = batches.first() else {
            error!("Empty batch received from {}", author.short_str().as_str());
            return;
        };

        // Filter the transactions in the batches. If any transaction is rejected,
        // the message will be dropped, and all batches will be rejected.
        if self.transaction_filter_config.is_enabled() {
            let transaction_filter = &self.transaction_filter_config.batch_transaction_filter();
            for batch in batches.iter() {
                for transaction in batch.txns() {
                    if !transaction_filter.allows_transaction(
                        batch.batch_info().batch_id(),
                        batch.author(),
                        batch.digest(),
                        transaction,
                    ) {
                        error!(
                            "Transaction {}, in batch {}, from {}, was rejected by the filter. Dropping {} batches!",
                            transaction.committed_hash(),
                            batch.batch_info().batch_id(),
                            author.short_str().as_str(),
                            batches.len()
                        );
                        counters::RECEIVED_BATCH_REJECTED_BY_FILTER.inc();
                        return;
                    }
                }
            }
        }

        let approx_created_ts_usecs = batch
            .info()
            .expiration()
            .saturating_sub(self.batch_expiry_gap_when_init_usecs);

        if approx_created_ts_usecs > 0 {
            observe_batch(
                approx_created_ts_usecs,
                batch.author(),
                BatchStage::RECEIVED,
            );
        }

        let mut persist_requests = vec![];
        for batch in batches.into_iter() {
            // TODO: maybe don't message batch generator if the persist is unsuccessful?
            if let Err(e) = self
                .sender_to_batch_generator
                .send(BatchGeneratorCommand::RemoteBatch(batch.clone()))
                .await
            {
                warn!("Failed to send batch to batch generator: {}", e);
            }
            persist_requests.push(batch.into());
        }
        counters::RECEIVED_BATCH_COUNT.inc_by(persist_requests.len() as u64);
        if author != self.my_peer_id {
            counters::RECEIVED_REMOTE_BATCH_COUNT.inc_by(persist_requests.len() as u64);
        }
        self.persist_and_send_digests(persist_requests, approx_created_ts_usecs);
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L474-486)
```rust
    fn generate_signed_batch_info<T: TBatchInfo>(
        &self,
        batch_info: T,
    ) -> Result<SignedBatchInfo<T>, CryptoMaterialError> {
        fail_point!("quorum_store::create_invalid_signed_batch_info", |_| {
            Ok(SignedBatchInfo::new_with_signature(
                batch_info.clone(),
                self.validator_signer.author(),
                aptos_crypto::bls12381::Signature::dummy_signature(),
            ))
        });
        SignedBatchInfo::new(batch_info, &self.validator_signer)
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L669-680)
```rust
        let sig_verification_start = Instant::now();
        let sig_verified_txns: Vec<SignatureVerifiedTransaction> = SIG_VERIFY_POOL.install(|| {
            let num_txns = input_txns.len();
            input_txns
                .into_par_iter()
                .with_min_len(optimal_min_len(num_txns, 32))
                .map(|t| Transaction::UserTransaction(t).into())
                .collect::<Vec<_>>()
        });
        counters::PREPARE_BLOCK_SIG_VERIFICATION_TIME
            .observe_duration(sig_verification_start.elapsed());
        Ok((Arc::new(sig_verified_txns), block_gas_limit))
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2881-2885)
```rust
        if let SignatureVerifiedTransaction::Invalid(_) = txn {
            let vm_status = VMStatus::error(StatusCode::INVALID_SIGNATURE, None);
            let discarded_output = discarded_output(vm_status.status_code());
            return Ok((vm_status, discarded_output));
        }
```
