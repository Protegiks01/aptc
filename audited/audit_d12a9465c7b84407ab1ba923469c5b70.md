# Audit Report

## Title
Stale Sequence Number in Local Transaction Simulation Causes Incorrect Validation Results

## Summary
The `simulate_using_debugger()` function uses a sequence number fetched from the latest ledger version but simulates against state from one version earlier, causing incorrect simulation results when the account has recent transactions. This breaks the state consistency invariant and can mislead users about transaction validity.

## Finding Description
The vulnerability exists in the interaction between three components:

1. **Sequence Number Retrieval**: [1](#0-0) 
   The function fetches the account state at the latest ledger version V and extracts the sequence number from this state.

2. **Transaction Construction**: [2](#0-1) 
   A `LocalAccount` is created with the fetched sequence number, then `sign_with_transaction_builder` is called, which increments the sequence number: [3](#0-2) 

3. **State View Creation**: [4](#0-3) 
   The simulation creates a state view at version V, but the `DebuggerStateView` implementation fetches state at version V-1: [5](#0-4) 

**The Issue**: When the REST API is called, it returns the account's sequence number from state at version V (after all transactions through version V have been executed). However, the simulation runs against state at version V-1 (before transaction at version V was executed). If transaction at version V was from the same account, the sequence numbers will differ by 1, causing the simulation to produce incorrect results.

**Attack Scenario**:
1. Account has sequence number 99 at version 999
2. User submits transaction with sequence number 100 at version 1000, which gets committed
3. User immediately calls `simulate_using_debugger()` for a new transaction:
   - `get_account_with_state()` returns: sequence_number = 100, version = 1000
   - New transaction is constructed with sequence_number = 101
   - Simulation runs at version 1000, which uses state at version 999
   - State view shows sequence_number = 99
   - Transaction prologue validation expects sequence_number = 100, sees 101
   - **Simulation incorrectly rejects the transaction as invalid**
4. If the user submits the transaction to the network:
   - Current on-chain state has sequence_number = 100
   - Transaction with sequence_number = 101 is valid (100 + 1)
   - **Transaction succeeds despite simulation showing failure**

This violates the state consistency invariant where simulations must accurately reflect on-chain execution behavior.

## Impact Explanation
This is a **Medium Severity** issue per the Aptos bug bounty criteria:

- **State Inconsistencies**: The simulation provides incorrect validation results that don't match actual on-chain behavior
- **User Impact**: Developers and users rely on simulations to test transactions before submission. Incorrect results can lead to:
  - Valid transactions being rejected based on false simulation failures
  - Gas estimation errors
  - Failed integration tests that should pass
  - User confusion and lost productivity

The impact is limited to the CLI/SDK simulation tools and doesn't affect consensus, on-chain execution, or validator operations. No funds are directly at risk, but incorrect simulations undermine trust in the development tooling.

## Likelihood Explanation
**Likelihood: High** 

This issue occurs whenever:
1. A user makes multiple transactions from the same account in quick succession
2. The second transaction's simulation is called while the first transaction is at the latest version

This is a common pattern in:
- Batch transaction workflows
- Automated testing scenarios  
- DApp operations that submit multiple transactions
- Any scenario where users interact with the network frequently

The issue requires no special privileges or insider access - any user calling the simulation API can encounter this bug during normal operations.

## Recommendation
**Fix Option 1 (Recommended)**: Adjust the version passed to the debugger to account for the off-by-one:

```rust
// In simulate_using_debugger() around line 302-309
let debugger = AptosDebugger::rest_client(client)?;
let (vm_status, vm_output) = execute(
    &debugger,
    version + 1,  // Changed from 'version' to 'version + 1'
    transaction,
    hash,
    PersistedAuxiliaryInfo::None,
)?;
```

This ensures the state view at version V+1 fetches state at version V (via the V+1-1 logic), matching the state from which the sequence number was extracted.

**Fix Option 2**: Modify the account fetching to explicitly request version V-1 to match the simulation's state view, though this is less intuitive for users who expect simulations against current state.

**Fix Option 3**: Document this behavior and add a parameter to allow users to specify whether they want simulation against current state or next-block state.

## Proof of Concept

```rust
// Rust test to demonstrate the issue
#[tokio::test]
async fn test_stale_sequence_number_simulation() {
    // Setup: Create account and submit transaction at version 1000
    let account_addr = AccountAddress::random();
    let private_key = Ed25519PrivateKey::generate_for_testing();
    
    // Submit first transaction (sequence number 100) at version 1000
    // This increments account sequence number from 99 to 100
    
    // Immediately try to simulate second transaction
    let client = setup_test_client().await;
    
    // This will fetch sequence_number = 100 from version 1000
    let (account, state) = get_account_with_state(&client, account_addr).await.unwrap();
    assert_eq!(account.sequence_number, 100);
    assert_eq!(state.version, 1000);
    
    // Create transaction with sequence number 101 (100 + 1)
    let txn_options = TxnOptions::default();
    let payload = create_test_payload();
    
    // Simulate at version 1000
    let result = txn_options.simulate_locally(payload).await;
    
    // BUG: Simulation uses state at version 999 where sequence_number = 99
    // Transaction with sequence_number = 101 is rejected (expected 100)
    // But on-chain execution against version 1000 state would succeed
    
    assert!(result.is_err()); // Simulation incorrectly fails
    
    // If we submit to actual network:
    let on_chain_result = submit_transaction(&client, txn).await;
    assert!(on_chain_result.is_ok()); // Would succeed on-chain
    
    // Demonstrates simulation != on-chain behavior
}
```

**Notes**

The root cause is the semantic mismatch between:
- The REST API returning state at version V (post-execution state)  
- The DebuggerStateView fetching at version V-1 (pre-execution state for transaction at version V)
- The simulation intending to show what would happen for a NEW transaction (should use post-execution state at version V)

This is an off-by-one error in version handling that manifests as stale sequence numbers when accounts have recent transactions. The fix requires careful consideration of whether simulations should represent "what would happen if this transaction executed at version V" versus "what would happen if this transaction executed next (at version V+1)". The current implementation is inconsistent and produces incorrect results.

### Citations

**File:** crates/aptos/src/common/transactions.rs (L274-277)
```rust
        let (account, state) = get_account_with_state(&client, sender_address).await?;
        let version = state.version;
        let chain_id = ChainId::new(state.chain_id);
        let sequence_number = account.sequence_number;
```

**File:** crates/aptos/src/common/transactions.rs (L297-299)
```rust
        let sender_account = &mut LocalAccount::new(sender_address, sender_key, sequence_number);
        let transaction =
            sender_account.sign_with_transaction_builder(transaction_factory.payload(payload));
```

**File:** sdk/src/types.rs (L354-368)
```rust
    pub fn sign_with_transaction_builder(&self, builder: TransactionBuilder) -> SignedTransaction {
        let raw_txn = if builder.has_nonce() {
            // Do not increment sequence number for orderless transactions.
            builder
                .sender(self.address())
                .sequence_number(u64::MAX)
                .build()
        } else {
            builder
                .sender(self.address())
                .sequence_number(self.increment_sequence_number())
                .build()
        };
        self.sign_transaction(raw_txn)
    }
```

**File:** crates/aptos/src/common/local_simulation.rs (L25-25)
```rust
    let state_view = debugger.state_view_at_version(version);
```

**File:** aptos-move/aptos-validator-interface/src/lib.rs (L133-133)
```rust
                let res = db.get_state_value_by_version(&key, version - 1).await;
```
