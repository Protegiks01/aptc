# Audit Report

## Title
Missing Content-Length Limit on Custom Event Ingestion Endpoints Enables Memory Exhaustion DoS

## Summary
The `custom_event_ingest` endpoint and `custom_contract_ingest::custom_event_ingest` endpoint in the telemetry service use `warp::body::json()` without an explicit `content_length_limit`, allowing attackers to send arbitrarily large JSON payloads with extremely long strings in the `TelemetryDump` struct fields, potentially exhausting heap memory and causing service disruption.

## Finding Description

The `TelemetryDump` struct contains unbounded `String` fields: `client_id`, `user_id`, and `timestamp_micros`. [1](#0-0) 

The custom event ingestion endpoint uses `warp::body::json()` directly without setting a content-length limit. [2](#0-1) 

Similarly, the custom contract custom event endpoint also lacks this protection. [3](#0-2) 

In contrast, other endpoints in the same service explicitly set `MAX_CONTENT_LENGTH` (1 MB) as a limit. The log ingestion endpoint includes this protection: [4](#0-3) 

And the metrics ingestion endpoint also uses it: [5](#0-4) 

The constant is defined as 1 MB: [6](#0-5) 

Without an explicit `content_length_limit()`, warp's `body::json()` filter will attempt to aggregate and deserialize the entire request body into memory. An authenticated attacker can exploit this by sending extremely large JSON payloads with multi-megabyte strings in the `client_id`, `user_id`, `timestamp_micros` fields, or in the `events` array with long `name` fields and large `params` maps.

## Impact Explanation

This is a **Medium severity** issue under the "State inconsistencies requiring intervention" category. While the telemetry service is not part of the core blockchain consensus, its disruption affects the operational monitoring and observability of validator nodes. A successful attack would:

1. Cause memory exhaustion on the telemetry service pod/container
2. Trigger OOM (Out of Memory) killer, crashing the service
3. Disrupt collection of metrics, logs, and custom events from all validators
4. Require manual intervention to restart the service
5. Create blind spots in monitoring during the outage

The vulnerability does not directly affect consensus, transaction execution, or validator operations, but degrades the operational security posture by preventing anomaly detection and performance monitoring.

## Likelihood Explanation

The likelihood is **High** because:

1. **Authentication Required but Accessible**: The endpoints require JWT authentication, but legitimate validators and nodes have these tokens by design [7](#0-6) 

2. **Simple Exploitation**: An attacker with a valid JWT token can trivially craft a large JSON payload with multi-megabyte strings

3. **Inconsistent Implementation**: The missing protection is an obvious oversight since other endpoints in the same codebase correctly use `content_length_limit`

4. **No Rate Limiting Visible**: Multiple concurrent large requests from different authenticated nodes could quickly exhaust available memory

## Recommendation

Add explicit `content_length_limit` before `warp::body::json()` to match the pattern used by other endpoints in the telemetry service:

```rust
// In custom_event.rs, line 37:
pub fn custom_event_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("ingest" / "custom-event")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_auth(context, vec![
            NodeType::Validator,
            NodeType::ValidatorFullNode,
            NodeType::PublicFullNode,
            NodeType::Unknown,
            NodeType::UnknownValidator,
            NodeType::UnknownFullNode,
        ]))
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))  // ADD THIS LINE
        .and(warp::body::json())
        .and(warp::header::optional("X-Forwarded-For"))
        .and_then(handle_custom_event)
        .boxed()
}

// In custom_contract_ingest.rs, line 304:
pub fn custom_event_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("custom-contract" / String / "ingest" / "custom-event")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_custom_contract_auth(context.clone()))
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))  // ADD THIS LINE
        .and(warp::body::json())
        .and_then(handle_custom_event_ingest)
        .boxed()
}
```

Ensure the constant is imported: `use crate::constants::MAX_CONTENT_LENGTH;`

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_custom_event_ingest_memory_exhaustion() {
    use warp::test::request;
    
    // Create a TelemetryDump with extremely large strings
    let large_string = "A".repeat(10 * 1024 * 1024); // 10 MB string
    
    let payload = serde_json::json!({
        "client_id": large_string,
        "user_id": "0x1234",
        "timestamp_micros": "1234567890",
        "events": [{
            "name": "test_event",
            "params": {}
        }]
    });
    
    // Without content_length_limit, this request will be accepted and
    // cause memory allocation of 10+ MB for just the client_id field
    let response = request()
        .method("POST")
        .path("/api/v1/ingest/custom-event")
        .header("content-type", "application/json")
        .header("authorization", "Bearer <valid_jwt_token>")
        .json(&payload)
        .reply(&routes)
        .await;
    
    // Current behavior: Accepts and processes large payload (memory exhaustion)
    // Expected behavior: Should reject with 413 Payload Too Large
    
    // Multiple concurrent requests like this will exhaust heap memory
}
```

**Notes**

This vulnerability demonstrates an inconsistent security posture within the telemetry service codebase. While the impact is limited to auxiliary monitoring infrastructure rather than core blockchain operations, the ease of exploitation and operational disruption warrant attention. The fix is straightforward and follows established patterns already present in the codebase.

### Citations

**File:** crates/aptos-telemetry-service/src/types/telemetry.rs (L17-22)
```rust
pub struct TelemetryDump {
    pub client_id: String,
    pub user_id: String,
    pub timestamp_micros: String,
    pub events: Vec<TelemetryEvent>,
}
```

**File:** crates/aptos-telemetry-service/src/custom_event.rs (L25-41)
```rust
pub fn custom_event_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("ingest" / "custom-event")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_auth(context, vec![
            NodeType::Validator,
            NodeType::ValidatorFullNode,
            NodeType::PublicFullNode,
            NodeType::Unknown,
            NodeType::UnknownValidator,
            NodeType::UnknownFullNode,
        ]))
        .and(warp::body::json())
        .and(warp::header::optional("X-Forwarded-For"))
        .and_then(handle_custom_event)
        .boxed()
}
```

**File:** crates/aptos-telemetry-service/src/custom_contract_ingest.rs (L299-307)
```rust
pub fn custom_event_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("custom-contract" / String / "ingest" / "custom-event")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_custom_contract_auth(context.clone()))
        .and(warp::body::json())
        .and_then(handle_custom_event_ingest)
        .boxed()
}
```

**File:** crates/aptos-telemetry-service/src/log_ingest.rs (L35-35)
```rust
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))
```

**File:** crates/aptos-telemetry-service/src/prometheus_push_metrics.rs (L34-34)
```rust
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))
```

**File:** crates/aptos-telemetry-service/src/constants.rs (L5-5)
```rust
pub const MAX_CONTENT_LENGTH: u64 = 1024 * 1024;
```
