# Audit Report

## Title
Consensus Observer Peer Optimality Manipulation via Insufficient Distance Validation

## Summary
Malicious peers can provide false `distance_from_validators` values in their `NetworkInformationResponse` that bypass validation checks, causing consensus observers to subscribe to suboptimal or malicious peers. The validation only enforces role-based checks for distances 0-1 but allows any distance ≥2 up to MAX_DISTANCE_FROM_VALIDATORS (100), enabling peers to misrepresent their network position and manipulate subscription priority.

## Finding Description

The vulnerability exists in how peer monitoring metadata is validated and used for consensus observer subscription decisions. The attack flow is:

1. **False Metadata Injection**: A malicious peer (e.g., a PFN at true distance 10+ from validators) responds to `GetNetworkInformation` requests with a falsified `distance_from_validators` value (e.g., claiming distance = 2). [1](#0-0) 

2. **Insufficient Validation**: The client-side validation performs role-based checks only for distances 0 and 1, but for any distance ≥2, it only validates that the value doesn't exceed `MAX_DISTANCE_FROM_VALIDATORS` (100). There is no verification that the claimed distance matches the peer's actual network topology position. [2](#0-1) 

Specifically, the validation at distance ≥2 only checks: [3](#0-2) 

3. **Metadata Storage**: The false distance is accepted and stored in `PeerMonitoringMetadata` without further validation: [4](#0-3) 

4. **Subscription Sorting Manipulation**: When the consensus observer evaluates peer optimality, it retrieves peer metadata and sorts peers primarily by distance (ascending), then by latency: [5](#0-4) 

The distance is extracted directly from the stored (and potentially false) metadata: [6](#0-5) 

5. **Subscription Decision Impact**: The sorted peer list determines which peers are considered "optimal" for subscriptions. Only the top N peers (where N = `max_concurrent_subscriptions`) are kept: [7](#0-6) 

**Attack Scenario:**
- Honest PFN at true distance 5 reports distance = 5
- Malicious PFN at true distance 10 reports distance = 2 (passes validation)
- Consensus observer sorts peers and ranks malicious peer higher
- Observer terminates subscription to honest peer, subscribes to malicious peer
- Malicious peer can provide stale data, slow responses, or no consensus data at all

## Impact Explanation

This qualifies as **High Severity** under the Aptos Bug Bounty program because:

1. **Validator Node Slowdowns**: Consensus observers subscribing to slow or malicious peers experience degraded performance as they receive stale or delayed consensus information.

2. **Consensus Observer Liveness Issues**: If malicious peers stop sending valid consensus data after being subscribed to, observers lose liveness until the subscription times out and is replaced. [8](#0-7) 

3. **Resource Exhaustion**: Observers waste network bandwidth and processing cycles on suboptimal peers, and undergo repeated subscription churn as they detect and terminate unhealthy subscriptions.

4. **Denial of Availability**: While not a complete network partition, this significantly impacts the availability and reliability of consensus observer nodes, which are critical for full nodes to stay synchronized with the network.

The impact aligns with "Validator node slowdowns" and "Significant protocol violations" (High severity) rather than Critical severity, as it does not cause permanent consensus safety violations or fund loss.

## Likelihood Explanation

This vulnerability is **highly likely** to be exploited:

- **Low Barrier to Entry**: Any peer that can connect to the network can exploit this by simply lying in their peer monitoring responses
- **No Authentication Required**: No special credentials or validator privileges needed
- **Difficult to Detect**: The false metadata appears legitimate and passes all validation checks
- **High Attacker Motivation**: Adversaries can use this to:
  - Disrupt consensus observer networks
  - Gain unfair advantage by being preferentially selected for subscriptions
  - Perform targeted DoS against specific observers
  - Position themselves as man-in-the-middle for consensus data

The vulnerability has been present since the peer monitoring and consensus observer systems were implemented, making it exploitable immediately.

## Recommendation

Implement stricter validation for peer-reported distances by cross-verifying with network topology:

1. **Add Role-Based Distance Validation**: Extend the distance validation to verify that claimed distances match expected ranges for each peer role:

```rust
// In peer-monitoring-service/client/src/peer_states/network_info.rs
let is_valid_depth = match network_info_response.distance_from_validators {
    0 => {
        // Existing validator check
        ...
    },
    1 => {
        // Existing VFN check
        ...
    },
    2 => {
        // New: Verify peer is PFN on public network
        let peer_is_pfn = peer_metadata.get_connection_metadata().role.is_public();
        let peer_has_correct_network = network_id.is_public_network();
        peer_is_pfn && peer_has_correct_network
    },
    distance_from_validators => {
        // New: Only allow distances 3+ for PFNs on public network
        // AND enforce maximum reasonable distance (e.g., 10 instead of 100)
        let peer_is_pfn = peer_metadata.get_connection_metadata().role.is_public();
        let peer_has_correct_network = network_id.is_public_network();
        let reasonable_distance = distance_from_validators <= 10;
        peer_is_pfn && peer_has_correct_network && reasonable_distance
    },
};
```

2. **Implement Distance Verification via Graph Analysis**: Cross-check claimed distances against the transitive closure of peer connections. If a peer claims distance=2 but all its connected peers report distances ≥3, flag the response as suspicious.

3. **Add Trust Scoring**: Implement a reputation system that tracks peer honesty over time and deprioritizes peers that provide inconsistent or suspicious metadata.

4. **Reduce MAX_DISTANCE_FROM_VALIDATORS**: Lower the maximum from 100 to a more realistic value like 10, reducing the attack surface.

## Proof of Concept

```rust
#[cfg(test)]
mod test_peer_distance_manipulation {
    use super::*;
    use aptos_config::network_id::NetworkId;
    use aptos_network::application::metadata::PeerMetadata;
    use aptos_peer_monitoring_service_types::response::NetworkInformationResponse;
    
    #[test]
    fn test_malicious_peer_false_distance() {
        // Setup: Create a malicious PFN peer that claims distance=2 when actual distance is 10
        let network_id = NetworkId::Public;
        let malicious_peer = PeerNetworkId::random();
        
        // Create connection metadata showing this is a PFN (not VFN or Validator)
        let connection_metadata = ConnectionMetadata::new(
            malicious_peer.peer_id(),
            ConnectionId::default(),
            NetworkAddress::mock(),
            ConnectionOrigin::Inbound,
            MessagingProtocolVersion::V1,
            ProtocolIdSet::all_known_protocols(),
            PeerRole::Unknown, // PFN role
        );
        
        // Malicious peer reports false distance=2 (actual distance is 10+)
        let false_network_info = NetworkInformationResponse {
            connected_peers: BTreeMap::new(),
            distance_from_validators: 2, // FALSE CLAIM
        };
        
        // Create network info state and attempt to record the false response
        let mut network_info_state = create_network_info_state(RoleType::FullNode);
        let peer_metadata = PeerMetadata::new(connection_metadata);
        
        // The malicious response passes validation!
        network_info_state.handle_monitoring_service_response(
            &malicious_peer,
            peer_metadata.clone(),
            PeerMonitoringServiceRequest::GetNetworkInformation,
            PeerMonitoringServiceResponse::NetworkInformation(false_network_info.clone()),
            0.1,
        );
        
        // Verify the false distance was stored
        let stored_response = network_info_state.get_latest_network_info_response();
        assert_eq!(stored_response.unwrap().distance_from_validators, 2);
        
        // Now simulate consensus observer sorting peers
        let mut peers_and_metadata = HashMap::new();
        
        // Add honest peer at true distance 5
        let honest_peer = PeerNetworkId::random();
        let honest_metadata = create_peer_with_distance(honest_peer, 5);
        peers_and_metadata.insert(honest_peer, honest_metadata);
        
        // Add malicious peer with false distance 2
        let malicious_metadata = create_peer_with_distance(malicious_peer, 2);
        peers_and_metadata.insert(malicious_peer, malicious_metadata);
        
        // Sort peers - malicious peer ranks higher due to false distance
        let sorted_peers = sort_peers_by_subscription_optimality(&peers_and_metadata);
        
        // VULNERABILITY: Malicious peer with false distance=2 is ranked before honest peer
        assert_eq!(sorted_peers[0], malicious_peer); // Malicious peer first
        assert_eq!(sorted_peers[1], honest_peer);   // Honest peer second
        
        println!("VULNERABILITY CONFIRMED: Malicious peer with false distance ranked higher!");
    }
}
```

## Notes

The vulnerability stems from an architectural assumption that peer-reported metrics are trustworthy for distances beyond direct validator connections. While validators and VFNs have strict role-based validation, PFNs can claim any distance from 2 to 100 without verification. This creates a significant attack vector for consensus observer manipulation.

The fix requires implementing transitive trust verification or significantly tightening the acceptable distance ranges based on peer roles and network topology.

### Citations

**File:** peer-monitoring-service/types/src/response.rs (L51-55)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L54-64)
```rust
    /// Records the new network info response for the peer
    pub fn record_network_info_response(
        &mut self,
        network_info_response: NetworkInformationResponse,
    ) {
        // Update the request tracker with a successful response
        self.request_tracker.write().record_response_success();

        // Save the network info
        self.recorded_network_info_response = Some(network_info_response);
    }
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L118-154)
```rust
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L196-218)
```rust
fn get_distance_for_peer(
    peer_network_id: &PeerNetworkId,
    peer_metadata: &PeerMetadata,
) -> Option<u64> {
    // Get the distance for the peer
    let peer_monitoring_metadata = peer_metadata.get_peer_monitoring_metadata();
    let distance = peer_monitoring_metadata
        .latest_network_info_response
        .as_ref()
        .map(|response| response.distance_from_validators);

    // If the distance is missing, log a warning
    if distance.is_none() {
        warn!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Unable to get distance for peer! Peer: {:?}",
                peer_network_id
            ))
        );
    }

    distance
}
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L283-312)
```rust
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```

**File:** consensus/src/consensus_observer/observer/subscription.rs (L143-159)
```rust
        // Sort the peers by subscription optimality
        let sorted_peers =
            subscription_utils::sort_peers_by_subscription_optimality(peers_and_metadata);

        // Verify that this peer is one of the most optimal peers
        let max_concurrent_subscriptions =
            self.consensus_observer_config.max_concurrent_subscriptions as usize;
        if !sorted_peers
            .iter()
            .take(max_concurrent_subscriptions)
            .any(|peer| peer == &self.peer_network_id)
        {
            return Err(Error::SubscriptionSuboptimal(format!(
                "Subscription to peer: {} is no longer optimal! New optimal peers: {:?}",
                self.peer_network_id, sorted_peers
            )));
        }
```

**File:** consensus/src/consensus_observer/observer/subscription.rs (L166-182)
```rust
    fn check_subscription_timeout(&self) -> Result<(), Error> {
        // Calculate the duration since the last message
        let time_now = self.time_service.now();
        let duration_since_last_message = time_now.duration_since(self.last_message_receive_time);

        // Check if the subscription has timed out
        if duration_since_last_message
            > Duration::from_millis(self.consensus_observer_config.max_subscription_timeout_ms)
        {
            return Err(Error::SubscriptionTimeout(format!(
                "Subscription to peer: {} has timed out! No message received for: {:?}",
                self.peer_network_id, duration_since_last_message
            )));
        }

        Ok(())
    }
```
