# Audit Report

## Title
Capability::Sign Lacks Rate Limiting, Enabling DoS Attacks on Validator Cryptographic Operations

## Summary
The `Capability::Sign` permission in the secure storage system has no rate limiting or throttling mechanisms. A malicious or compromised service with Sign capability can perform unbounded signature requests to the Vault backend, potentially exhausting cryptographic operation quotas, degrading validator performance, and disrupting consensus operations.

## Finding Description

The Aptos secure storage architecture uses HashiCorp Vault as a backend for cryptographic operations, with a policy-based access control system that grants different capabilities to different services. The `Capability::Sign` enum variant grants services the ability to request Ed25519 signatures from Vault's transit engine. [1](#0-0) 

The policy system is designed to support multiple services (e.g., safety_rules, key_manager) with different vault tokens and capabilities: [2](#0-1) 

However, when a service with `Capability::Sign` calls the sign operation, there are no rate limiting checks in the execution path:

**VaultStorage::sign()** directly forwards to the vault client without any throttling: [3](#0-2) 

**Vault Client::sign_ed25519()** makes unbounded HTTP POST requests to Vault's transit/sign endpoint: [4](#0-3) 

A compromised or malicious service with a valid Vault token containing `Capability::Sign` can:

1. Repeatedly call `storage.sign(key_name, &message)` in a tight loop
2. Generate thousands or millions of signature requests per second
3. Exhaust Vault's cryptographic operation capacity (CPU, quotas, or I/O)
4. Degrade or block legitimate signing operations needed by SafetyRules for consensus (signing votes, proposals, timeout certificates)
5. Cause validator performance degradation or consensus participation failures

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Medium Severity** per Aptos Bug Bounty categories:

This vulnerability can cause **validator node slowdowns** (High severity threshold) and **state inconsistencies requiring intervention** (Medium severity threshold). Specifically:

- **Consensus Disruption**: SafetyRules loads the private key once during initialization but could be affected if key rotation occurs or if new epoch initialization requires signing operations through Vault
- **Service Degradation**: Legitimate services requiring Sign capability would experience delays or failures
- **Quota Exhaustion**: Cloud-deployed Vault instances often have API rate limits or operation quotas; exhausting these blocks all vault operations
- **Resource Starvation**: Vault server CPU and I/O resources consumed by signature operations could impact all connected validators

While not a direct consensus safety violation, this creates availability issues that degrade validator performance and could prevent timely block signing during critical consensus operations.

## Likelihood Explanation

**Medium to High Likelihood** given the right conditions:

- Requires a compromised service with `Capability::Sign` permission (not any external attacker)
- Services like key_manager or operational tooling might have Sign capability for legitimate key management operations
- If such a service has a vulnerability (RCE, command injection, etc.), the attacker gains ability to abuse Sign capability
- No authentication or authorization checks beyond the initial token validation
- No monitoring or alerting on abnormal signature request patterns
- The attack is trivial to execute once service compromise is achieved (simple loop calling sign)

This is a realistic threat in production deployments where defense-in-depth is critical.

## Recommendation

Implement rate limiting for cryptographic operations at multiple layers:

**1. Application-Level Rate Limiting in VaultStorage:**

```rust
// In VaultStorage struct, add rate limiting state
pub struct VaultStorage {
    client: Client,
    time_service: TimeService,
    renew_ttl_secs: Option<u32>,
    next_renewal: AtomicU64,
    use_cas: bool,
    secret_versions: RwLock<HashMap<String, u32>>,
    // Add rate limiting
    sign_rate_limiter: Arc<RwLock<RateLimiter>>,
}

// Implement rate limiting in sign method
impl CryptoStorage for VaultStorage {
    fn sign<T: CryptoHash + Serialize>(
        &self,
        name: &str,
        message: &T,
    ) -> Result<Ed25519Signature, Error> {
        // Check rate limit before signing
        if !self.sign_rate_limiter.write().check_limit() {
            return Err(Error::RateLimitExceeded);
        }
        
        let name = self.crypto_name(name);
        // ... rest of implementation
    }
}
```

**2. Policy-Level Controls:**

Add rate limit metadata to `Capability` enum:
```rust
pub enum Capability {
    Export,
    Read,
    Rotate,
    Sign { max_requests_per_minute: Option<u32> },
    Write,
}
```

**3. Monitoring and Alerting:**

- Log all sign operations with caller identity
- Alert on abnormal signature request rates
- Implement circuit breakers to fail-safe when thresholds exceeded

**4. Vault-Side Configuration:**

Configure Vault's rate limiting policies at the transit engine level as defense-in-depth.

## Proof of Concept

```rust
#[cfg(test)]
mod dos_test {
    use super::*;
    use aptos_crypto::hash::CryptoHash;
    use serde::Serialize;
    
    #[derive(Serialize)]
    struct TestMessage {
        data: String,
    }
    
    impl CryptoHash for TestMessage {
        type Hasher = aptos_crypto::hash::DefaultHasher;
        
        fn hash(&self) -> aptos_crypto::hash::HashValue {
            let mut state = Self::Hasher::default();
            bcs::serialize_into(&mut state, self).unwrap();
            state.finish()
        }
    }
    
    #[test]
    fn test_sign_dos_no_rate_limit() {
        // Setup: Create VaultStorage with Sign capability
        let vault_storage = create_test_vault_storage_with_sign_capability();
        
        // Create a key
        let key_name = "test_consensus_key";
        vault_storage.create_key(key_name).unwrap();
        
        // Attack: Perform 10,000 signature requests without any rate limiting
        let message = TestMessage { 
            data: "malicious_signature_request".to_string() 
        };
        
        let start = std::time::Instant::now();
        let mut successful_signs = 0;
        
        for i in 0..10_000 {
            match vault_storage.sign(key_name, &message) {
                Ok(_) => successful_signs += 1,
                Err(e) => {
                    // Should hit rate limit, but won't
                    println!("Sign failed at iteration {}: {:?}", i, e);
                    break;
                }
            }
        }
        
        let duration = start.elapsed();
        
        println!("DoS Attack Results:");
        println!("- Successful signs: {}", successful_signs);
        println!("- Duration: {:?}", duration);
        println!("- Rate: {} signs/second", 
                 successful_signs as f64 / duration.as_secs_f64());
        
        // Vulnerability: All 10,000 requests succeed without rate limiting
        assert_eq!(successful_signs, 10_000, 
                   "Expected all signature requests to succeed due to missing rate limit");
    }
}
```

**Rust Reproduction Steps:**

1. Deploy Vault backend and configure transit engine
2. Create a service token with `Capability::Sign` for a test key
3. Initialize `VaultStorage` with the token
4. Execute the PoC test showing unbounded signature requests
5. Monitor Vault server metrics to observe CPU/operation quota consumption
6. Attempt legitimate consensus signing operations and observe degradation

## Notes

While consensus operations (SafetyRules) load the private key into memory during initialization and sign locally, this vulnerability still poses significant risks:

1. **Key Rotation Scenarios**: New epoch initialization or key rotation events may require Vault signing operations
2. **Operational Services**: Key management services legitimately need Sign capability but could be compromised
3. **Defense-in-Depth**: Even if SafetyRules doesn't use Vault signing in steady-state, the lack of rate limiting violates security principles
4. **Quota Exhaustion Impact**: Cloud Vault deployments have API quotas that affect ALL vault operations, not just signing

The question explicitly mentions "malicious services," indicating this insider threat scenario is in scope. The vulnerability exists in the Aptos Core codebase's failure to implement rate limiting for cryptographic operations accessible through the policy system.

### Citations

**File:** secure/storage/src/policy.rs (L38-43)
```rust
/// Id represents an internal identifier for a given process. For example, safety_rules or
/// key_manager. It is up to the Storage and its deployment to translate these identifiers into
/// verifiable material. For example, the process running safety_rules may have a token that is
/// intended for only safety_rules to own. The specifics are left to the implementation of the
/// storage backend interface layer.
#[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]
```

**File:** secure/storage/src/policy.rs (L50-58)
```rust
/// Represents actions
#[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum Capability {
    Export,
    Read,
    Rotate,
    Sign,
    Write,
}
```

**File:** secure/storage/src/vault.rs (L274-288)
```rust
    fn sign<T: CryptoHash + Serialize>(
        &self,
        name: &str,
        message: &T,
    ) -> Result<Ed25519Signature, Error> {
        let name = self.crypto_name(name);
        let mut bytes = <T::Hasher as aptos_crypto::hash::CryptoHasher>::seed().to_vec();
        bcs::serialize_into(&mut bytes, &message).map_err(|e| {
            Error::InternalError(format!(
                "Serialization of signable material should not fail, yet returned Error:{}",
                e
            ))
        })?;
        Ok(self.client().sign_ed25519(&name, &bytes, None)?)
    }
```

**File:** secure/storage/vault/src/lib.rs (L425-443)
```rust
    pub fn sign_ed25519(
        &self,
        name: &str,
        data: &[u8],
        version: Option<u32>,
    ) -> Result<Ed25519Signature, Error> {
        let data = if let Some(version) = version {
            json!({ "input": base64::encode(data), "key_version": version })
        } else {
            json!({ "input": base64::encode(data) })
        };

        let request = self
            .agent
            .post(&format!("{}/v1/transit/sign/{}", self.host, name));
        let resp = self.upgrade_request(request).send_json(data);

        process_transit_sign_response(resp)
    }
```
