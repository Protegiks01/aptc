# Audit Report

## Title
CLI Injection Vulnerability in Executor-Benchmark Partitioning Configuration Allows Node Crashes via Out-of-Bounds Array Access

## Summary
While `PartitionerV1Config` mentioned in the security question is dead code (unused in the codebase), the same CLI injection vulnerability exists in the actively-used `PartitionerV2Config` via the executor-benchmark tool. The `max_partitioning_rounds` parameter can be set via CLI arguments to exceed the hardcoded `MAX_ALLOWED_PARTITIONING_ROUNDS` constant (8), causing out-of-bounds array access and node crashes during cross-shard message handling.

## Finding Description

The security question asks about `PartitionerV1Config`, which derives `clap::Parser` but is not actually used anywhere in the codebase. [1](#0-0) 

However, the executor-benchmark uses a similar configuration pattern via `ShardingOpt`, which also derives `clap::Parser` and exposes `max_partitioning_rounds` as a CLI parameter with default value 4 but no upper bound validation. [2](#0-1) 

The vulnerability chain:

1. **No validation on max_partitioning_rounds**: The `ShardingOpt` struct accepts any value via `--max-partitioning-rounds` CLI flag without checking against `MAX_ALLOWED_PARTITIONING_ROUNDS` (hardcoded to 8). [3](#0-2) 

2. **Array initialization bounded by constant**: Cross-shard message channels are initialized only for rounds 0 through `MAX_ALLOWED_PARTITIONING_ROUNDS-1` (indices 0-7) in both remote and local executor services. [4](#0-3) 

3. **Unchecked array access during execution**: When sending cross-shard messages, the code directly accesses `message_txs[shard_id][round]` without bounds checking. [5](#0-4) 

4. **Same issue in local executor**: The local executor service has identical array initialization and access patterns. [6](#0-5) 

**Attack Path:**
```
attacker runs: aptos-executor-benchmark --max-partitioning-rounds 10 ...
→ PartitionerV2Config created with max_partitioning_rounds=10
→ Partitioner creates sub-blocks for rounds 0-9
→ Cross-shard messages sent for round 8 or 9
→ RemoteCrossShardClient::send_cross_shard_msg tries to access message_txs[shard_id][8]
→ Out-of-bounds panic: arrays only sized for indices 0-7
→ Node crashes
```

## Impact Explanation

**Severity: High** (Validator node crashes)

This vulnerability allows denial-of-service attacks against nodes running the executor-benchmark tool with malicious CLI parameters. While executor-benchmark is primarily a benchmarking tool rather than production validator code, it still represents a High severity issue because:

1. **Node crashes**: Any process crash represents a availability failure
2. **No authentication required**: Anyone with access to run the tool can exploit this
3. **Trivial exploitation**: Single CLI flag is sufficient
4. **Breaks resource limits invariant**: The system should handle invalid configurations gracefully rather than panicking

Per Aptos bug bounty criteria, this falls under "High Severity: Validator node slowdowns / API crashes / Significant protocol violations."

## Likelihood Explanation

**Likelihood: Medium**

- **Exploitation complexity**: Trivial - single CLI argument
- **Attacker requirements**: Ability to run executor-benchmark tool
- **Scope**: Limited to benchmark tool, not production validator binaries
- **Default configuration**: Safe (default is 4, which is < 8)

The likelihood is medium rather than high because:
1. The vulnerability only affects the executor-benchmark tool, not production validator nodes
2. The default configuration (max_partitioning_rounds=4) is safe
3. Attackers would need execution privileges to run the benchmark tool

However, if the benchmark tool is ever deployed in production environments or CI/CD pipelines with user-controlled parameters, the vulnerability becomes immediately exploitable.

## Recommendation

Add validation to ensure `max_partitioning_rounds` never exceeds `MAX_ALLOWED_PARTITIONING_ROUNDS`:

```rust
// In execution/executor-benchmark/src/main.rs, ShardingOpt impl
impl ShardingOpt {
    fn partitioner_config(&self) -> PartitionerV2Config {
        // Add validation
        assert!(
            self.max_partitioning_rounds < MAX_ALLOWED_PARTITIONING_ROUNDS,
            "max_partitioning_rounds ({}) must be less than MAX_ALLOWED_PARTITIONING_ROUNDS ({})",
            self.max_partitioning_rounds,
            MAX_ALLOWED_PARTITIONING_ROUNDS
        );
        
        match self.partitioner_version.as_deref() {
            // ... rest of implementation
        }
    }
}
```

Additionally, consider:
1. Using clap's `value_parser` with range validation: `#[clap(long, default_value = "4", value_parser = clap::value_parser!(u64).range(0..8))]`
2. Adding runtime checks in `RemoteCrossShardClient::send_cross_shard_msg` and similar functions
3. Removing the unused `PartitionerV1Config` code to reduce attack surface

## Proof of Concept

```bash
# Build the executor-benchmark
cd aptos-core/execution/executor-benchmark
cargo build --release

# Run with malicious max-partitioning-rounds value
./target/release/aptos-executor-benchmark \
  --max-partitioning-rounds 10 \
  --num-executor-shards 2 \
  --block-size 1000 \
  --blocks 1 \
  run-executor \
  --main-signer-accounts 1000 \
  --data-dir /tmp/test-data \
  --checkpoint-dir /tmp/test-checkpoint

# Expected result: Panic with index out of bounds error when
# cross-shard messages are sent for round >= 8
```

**Notes:**
- The specific file mentioned in the security question (`PartitionerV1Config`) is dead code and not actually used
- The vulnerability exists in the actively-used `PartitionerV2Config` via executor-benchmark's `ShardingOpt`
- This represents a CLI injection vulnerability where lack of input validation leads to memory safety violations (out-of-bounds access)
- The issue demonstrates how seemingly innocent benchmarking tools can introduce security vulnerabilities if deployed with untrusted inputs

### Citations

**File:** execution/block-partitioner/src/sharded_block_partitioner/config.rs (L12-18)
```rust
#[derive(Clone, Copy, Debug, Parser)]
pub struct PartitionerV1Config {
    pub num_shards: usize,
    pub max_partitioning_rounds: RoundId,
    pub cross_shard_dep_avoid_threshold: f32,
    pub partition_last_round: bool,
}
```

**File:** execution/executor-benchmark/src/main.rs (L203-230)
```rust
#[derive(Debug, Parser)]
struct ShardingOpt {
    #[clap(long, default_value = "0")]
    num_executor_shards: usize,
    #[clap(long)]
    use_global_executor: bool,
    /// Gives an option to specify remote shard addresses. If specified, then we expect the number
    /// of remote addresses to be equal to 'num_executor_shards', and one coordinator address
    /// Address is specified as <IP>:<PORT>
    #[clap(long, num_args = 1..)]
    remote_executor_addresses: Option<Vec<SocketAddr>>,
    #[clap(long)]
    coordinator_address: Option<SocketAddr>,
    #[clap(long, default_value = "4")]
    max_partitioning_rounds: usize,
    #[clap(long, default_value = "0.90")]
    partitioner_cross_shard_dep_avoid_threshold: f32,
    #[clap(long)]
    partitioner_version: Option<String>,
    #[clap(long)]
    pre_partitioner: Option<String>,
    #[clap(long, default_value = "2.0")]
    load_imbalance_tolerance: f32,
    #[clap(long, default_value = "8")]
    partitioner_v2_num_threads: usize,
    #[clap(long, default_value = "64")]
    partitioner_v2_dashmap_num_shards: usize,
}
```

**File:** types/src/block_executor/partitioner.rs (L20-22)
```rust
pub static MAX_ALLOWED_PARTITIONING_ROUNDS: usize = 8;
pub static GLOBAL_ROUND_ID: usize = MAX_ALLOWED_PARTITIONING_ROUNDS + 1;
pub static GLOBAL_SHARD_ID: usize = usize::MAX;
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L26-33)
```rust
        for remote_address in shard_addresses.iter() {
            let mut txs = vec![];
            for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
                let message_type = format!("cross_shard_{}", round);
                let tx = controller.create_outbound_channel(*remote_address, message_type);
                txs.push(Mutex::new(tx));
            }
            message_txs.push(txs);
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-58)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L95-104)
```rust
        let (cross_shard_msg_txs, cross_shard_msg_rxs): (
            Vec<Vec<Sender<CrossShardMsg>>>,
            Vec<Vec<Receiver<CrossShardMsg>>>,
        ) = (0..num_shards)
            .map(|_| {
                (0..MAX_ALLOWED_PARTITIONING_ROUNDS)
                    .map(|_| unbounded())
                    .unzip()
            })
            .unzip();
```
