# Audit Report

## Title
Missing Overflow Protection in Type Interner ID Assignment Allows Configuration-Dependent Type Confusion

## Summary
The `TypeVecInterner::intern_vec()` function performs an unchecked `as u32` cast when assigning type vector IDs, and the configuration system does not validate that `max_interned_ty_vecs` stays within `u32::MAX`. While default protections prevent exploitation, misconfiguration could enable type system violations.

## Finding Description

The Move VM's type interning system uses `u32`-based identifiers (`TypeVecId`) to compactly represent vectors of type arguments. Three critical functions perform unchecked casts from `usize` to `u32`: [1](#0-0) [2](#0-1) [3](#0-2) 

If `inner.data.len()` exceeds `u32::MAX` (4,294,967,295), the cast silently wraps to 0, causing ID collision where new type vectors receive IDs that point to previously interned, different type vectors. This violates Move's type system guarantee that distinct generic instantiations have distinct representations.

The configuration system defines `max_interned_ty_vecs` as a `usize` without validation: [4](#0-3) [5](#0-4) 

The flush mechanism checks this limit and clears the pool when exceeded: [6](#0-5) 

However, **no validation exists** to ensure `config.max_interned_ty_vecs <= u32::MAX as usize`.

## Impact Explanation

**IF exploited**, this would cause:
- **Type Confusion**: Different generic instantiations (e.g., `Struct<u8>` vs `Struct<u64>`) receive identical `TypeVecId` values
- **Consensus Divergence**: Nodes with different pool states would interpret types differently, breaking deterministic execution
- **Type Safety Violations**: Move's guarantees about distinct types being distinguishable are violated

This qualifies as **Critical Severity** under the bug bounty (Consensus/Safety violations).

## Likelihood Explanation

**EXTREMELY LOW** under production conditions:

1. **Default Protection**: The default `max_interned_ty_vecs = 4,194,304` is ~1000x smaller than `u32::MAX`
2. **Automatic Flush**: Pool is cleared when limit is reached, preventing unbounded growth
3. **Economic Infeasibility**: Creating 4+ billion distinct type vectors would require billions of transactions with maximum type complexity, costing astronomical gas fees
4. **Requires Misconfiguration**: Node operator must explicitly set `max_interned_ty_vecs > u32::MAX` (privileged operation)

**This is NOT exploitable by unprivileged attackers under default configuration.**

## Recommendation

Add defensive validation at two levels:

**1. Configuration Validation:**
```rust
impl BlockExecutorModuleCacheLocalConfig {
    pub fn validate(&self) -> Result<(), String> {
        if self.max_interned_ty_vecs > u32::MAX as usize {
            return Err(format!(
                "max_interned_ty_vecs ({}) exceeds u32::MAX ({})",
                self.max_interned_ty_vecs, u32::MAX
            ));
        }
        // Similar checks for max_interned_tys
        Ok(())
    }
}
```

**2. Runtime Assertion:**
```rust
fn intern_vec(&self, tys: Vec<TypeId>) -> TypeVecId {
    // ... existing code ...
    let mut inner = self.inner.write();
    if let Some(id) = inner.interned.get(&tys) {
        return *id;
    }
    
    let len = inner.data.len();
    assert!(
        len <= u32::MAX as usize,
        "Type interner overflow: {} entries exceeds u32::MAX",
        len
    );
    let id = TypeVecId(len as u32);
    // ... rest of function ...
}
```

## Proof of Concept

**Cannot provide a valid PoC** because:
1. Default configuration prevents reaching the overflow condition
2. Exploitation requires privileged access to modify node configuration to dangerous values
3. Cannot demonstrate in a Move test without first compromising the node operator

A theoretical PoC would require:
```rust
// This would only work if config.max_interned_ty_vecs is set > u32::MAX
// which requires privileged node operator access
let config = BlockExecutorModuleCacheLocalConfig {
    max_interned_ty_vecs: u64::MAX as usize, // Invalid config!
    // ... other fields ...
};

// Then create 4,294,967,296+ distinct type vectors
// Economically infeasible even if config allowed it
```

---

**FINAL ASSESSMENT**: While the code lacks defensive checks, this is **NOT a directly exploitable vulnerability** under normal operation because:
- Default configuration provides effective protection
- Requires privileged access to misconfigure
- No realistic attack path for unprivileged actors

This is a **hardening opportunity** rather than an exploitable bug per the bounty program's criteria requiring unprivileged exploitability.

### Citations

**File:** third_party/move/move-vm/types/src/ty_interner.rs (L102-102)
```rust
        let id = TypeId(inner.data.len() as u32);
```

**File:** third_party/move/move-vm/types/src/ty_interner.rs (L136-136)
```rust
        let id = TypeVecId(inner.data.len() as u32);
```

**File:** third_party/move/move-vm/types/src/ty_interner.rs (L155-155)
```rust
        let id = TypeVecId(inner.data.len() as u32);
```

**File:** types/src/block_executor/config.rs (L24-24)
```rust
    pub max_interned_ty_vecs: usize,
```

**File:** types/src/block_executor/config.rs (L42-42)
```rust
            max_interned_ty_vecs: 4 * 1024 * 1024,
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L155-159)
```rust
        if num_interned_tys > config.max_interned_tys
            || num_interned_ty_vecs > config.max_interned_ty_vecs
        {
            runtime_environment.ty_pool().flush();
            self.module_cache.flush();
```
