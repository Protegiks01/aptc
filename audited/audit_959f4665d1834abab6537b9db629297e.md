# Audit Report

## Title
Consensus Safety Check Bypass in Decoupled Pipeline Signing Phase

## Summary
The `SigningPhase::process()` function in the decoupled consensus pipeline bypasses critical SafetyRules validation when using pre-computed commit vote signatures from `commit_vote_fut`. This allows validators to sign local execution results without verifying consistency with the ordered proof, and converts all execution errors to `InternalError`, masking potential safety violations.

## Finding Description

The signing phase has two distinct code paths for obtaining commit vote signatures:

**Path A (Pipeline Path - VULNERABLE):** [1](#0-0) 

This path retrieves a pre-computed signature from `commit_vote_fut`, which was created during pipeline construction. The commit vote is generated by `sign_and_broadcast_commit_vote()`: [2](#0-1) 

This function signs the local execution result directly using `ValidatorSigner` without invoking SafetyRules checks.

**Path B (Fallback Path - SAFE):** [3](#0-2) 

This path properly invokes SafetyRules, which performs the critical consistency check: [4](#0-3) 

This check uses `match_ordered_only()` to validate that the ordered BlockInfo matches the executed BlockInfo: [5](#0-4) 

### The Vulnerability

1. **Safety Check Bypass:** In Path A (normal pipeline execution), validators sign their local execution results without verifying they match the ordered proof. The `ordered_ledger_info` parameter in `SigningRequest` is completely unused when `pipeline_futs()` exists.

2. **Error Misclassification:** All errors from `commit_vote_fut` are converted to `Error::InternalError`, masking their true nature and preventing proper error handling downstream: [6](#0-5) 

3. **Deterministic Execution Invariant Violation:** This breaks the critical invariant that "All validators must produce identical state roots for identical blocks." Without the SafetyRules check:
   - If execution diverges between validators (due to VM bugs, non-determinism, or attacks)
   - Each validator signs their divergent local result
   - No validation detects the inconsistency
   - Different validators vote for different state roots

4. **Defense-in-Depth Failure:** The SafetyRules check serves as a critical defense layer that should catch execution inconsistencies. Bypassing it means the system relies entirely on execution being bug-free.

## Impact Explanation

**Severity: HIGH (Consensus Safety Violation)**

This vulnerability meets the High severity criteria under the Aptos Bug Bounty program:

1. **Consensus Safety Violations:** If execution becomes non-deterministic (through VM bugs, crafted transactions exploiting edge cases, or race conditions), validators would sign different state roots without detection. This could lead to:
   - Chain splits if different validator subsets commit different states
   - Loss of consensus liveness if no quorum forms
   - State divergence requiring manual intervention

2. **Protocol Violation:** The bypass directly violates the safety guarantees that SafetyRules is designed to provide. The system loses its second line of defense against execution bugs.

3. **Error Masking:** Converting specific execution errors to `InternalError` makes debugging failures difficult and could hide critical safety violations that should trigger alerts or recovery mechanisms.

The impact would affect all validators in the network and could lead to consensus failure or state divergence.

## Likelihood Explanation

**Likelihood: MEDIUM**

The exploitability depends on the existence of execution non-determinism:

**Factors Increasing Likelihood:**
- Complex VM implementations can have subtle non-determinism bugs
- Parallel execution features may introduce race conditions
- Native function implementations could have platform-specific behavior
- External oracles or randomness sources could cause divergence
- Future VM changes may accidentally introduce non-determinism

**Factors Decreasing Likelihood:**
- Move VM is designed to be deterministic
- Extensive testing should catch obvious non-determinism
- The execution engine has checks to prevent divergence

**Historical Context:**
Other blockchain systems (Ethereum, Solana) have experienced consensus issues due to execution non-determinism, demonstrating this is not purely theoretical.

Even without active exploitation, this represents a serious defense-in-depth failure that weakens consensus safety guarantees.

## Recommendation

**Fix 1: Always Invoke SafetyRules for Commit Vote Signing**

Modify `SigningPhase::process()` to always perform the SafetyRules check, even when using pre-computed signatures:

```rust
async fn process(&self, req: SigningRequest) -> SigningResponse {
    let SigningRequest {
        ordered_ledger_info,
        commit_ledger_info,
        blocks,
    } = req;

    let signature_result = if let Some(fut) = blocks
        .last()
        .expect("Blocks can't be empty")
        .pipeline_futs()
    {
        // Get pre-computed vote but validate with SafetyRules
        match fut.commit_vote_fut.clone().await {
            Ok(vote) => {
                // Validate consistency before accepting the signature
                if let Err(e) = self.safety_rule_handle.sign_commit_vote(
                    ordered_ledger_info.clone(),
                    commit_ledger_info.clone(),
                ) {
                    error!("SafetyRules validation failed for pre-computed vote: {:?}", e);
                    Err(e)
                } else {
                    Ok(vote.signature().clone())
                }
            },
            Err(e) => Err(Error::InternalError(e.to_string()))
        }
    } else {
        self.safety_rule_handle
            .sign_commit_vote(ordered_ledger_info, commit_ledger_info.clone())
    };

    SigningResponse {
        signature_result,
        commit_ledger_info,
    }
}
```

**Fix 2: Preserve Error Type Information**

Define a proper error conversion that preserves execution error semantics:

```rust
.map_err(|e| {
    // Preserve execution error type for proper handling
    match e {
        TaskError::InternalError(err) => {
            if err.to_string().contains("inconsistent") {
                Error::InconsistentExecutionResult(
                    "ordered".to_string(),
                    err.to_string()
                )
            } else {
                Error::InternalError(err.to_string())
            }
        },
        _ => Error::InternalError(e.to_string())
    }
})
```

**Fix 3: Add Execution Consistency Assertions**

Add runtime checks in the execution pipeline to verify deterministic execution: [7](#0-6) 

Enhance this assertion to check state roots match across execution attempts.

## Proof of Concept

While a complete exploit requires demonstrating execution non-determinism (which is system-specific), the bypass can be verified through code inspection:

**Step 1: Verify Pipeline Path is Used** [8](#0-7) 

The pipeline always creates `commit_vote_fut` for non-observer nodes.

**Step 2: Verify SafetyRules is Bypassed** [9](#0-8) 

Direct signing without SafetyRules invocation.

**Step 3: Verify ordered_ledger_info is Unused**
In Path A of `SigningPhase::process()`, the `ordered_ledger_info` parameter is extracted but never usedâ€”the signature comes entirely from `commit_vote_fut`.

**Hypothetical Exploitation Scenario:**
If an attacker discovers a Move VM bug causing non-deterministic execution (e.g., through specific transaction patterns), they could:
1. Submit transactions that trigger the non-determinism
2. Different validators execute to different states
3. Each validator signs their local result via the bypass
4. No SafetyRules check detects the inconsistency
5. Consensus either fails (no quorum) or commits wrong state (if Byzantine validators coordinate)

**Notes**
This is a genuine defense-in-depth weakness in the consensus safety implementation. While full exploitation requires finding execution non-determinism bugs (which are outside the scope of this specific analysis), the safety check bypass is confirmed and weakens the protocol's security guarantees. The error conversion issue further compounds the problem by masking execution failures.

### Citations

**File:** consensus/src/pipeline/signing_phase.rs (L79-88)
```rust
        let signature_result = if let Some(fut) = blocks
            .last()
            .expect("Blocks can't be empty")
            .pipeline_futs()
        {
            fut.commit_vote_fut
                .clone()
                .await
                .map(|vote| vote.signature().clone())
                .map_err(|e| Error::InternalError(e.to_string()))
```

**File:** consensus/src/pipeline/signing_phase.rs (L90-91)
```rust
            self.safety_rule_handle
                .sign_commit_vote(ordered_ledger_info, commit_ledger_info.clone())
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L512-534)
```rust
        let commit_vote_fut = if !observer_enabled {
            spawn_shared_fut(
                Self::sign_and_broadcast_commit_vote(
                    ledger_update_fut.clone(),
                    order_vote_rx,
                    order_proof_fut.clone(),
                    commit_proof_fut.clone(),
                    self.signer.clone(),
                    block.clone(),
                    self.order_vote_enabled,
                    self.network_sender.clone(),
                ),
                Some(&mut abort_handles),
            )
        } else {
            spawn_ready_fut(CommitVote::new_with_signature(
                Author::ONE,
                LedgerInfo::dummy(),
                self.signer
                    .sign(&LedgerInfo::dummy())
                    .expect("Signing should succeed"),
            ))
        };
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L978-1030)
```rust
    async fn sign_and_broadcast_commit_vote(
        ledger_update_fut: TaskFuture<LedgerUpdateResult>,
        order_vote_rx: oneshot::Receiver<()>,
        order_proof_fut: TaskFuture<WrappedLedgerInfo>,
        commit_proof_fut: TaskFuture<LedgerInfoWithSignatures>,
        signer: Arc<ValidatorSigner>,
        block: Arc<Block>,
        order_vote_enabled: bool,
        network_sender: Arc<NetworkSender>,
    ) -> TaskResult<CommitVoteResult> {
        let mut tracker = Tracker::start_waiting("sign_commit_vote", &block);
        let (compute_result, _, epoch_end_timestamp) = ledger_update_fut.await?;
        let mut consensus_data_hash = select! {
            Ok(_) = order_vote_rx => {
                HashValue::zero()
            }
            Ok(li) = order_proof_fut => {
                li.ledger_info().ledger_info().consensus_data_hash()
            }
            Ok(li) = commit_proof_fut => {
                li.ledger_info().consensus_data_hash()
            }
            else => {
                return Err(anyhow!("all receivers dropped"))?;
            }
        };
        if order_vote_enabled {
            consensus_data_hash = HashValue::zero();
        }
        tracker.start_working();

        let mut block_info = block.gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        );
        if let Some(timestamp) = epoch_end_timestamp {
            info!(
                "[Pipeline] update block timestamp from {} to epoch end timestamp {}",
                block_info.timestamp_usecs(),
                timestamp
            );
            block_info.change_timestamp(timestamp);
        }
        let ledger_info = LedgerInfo::new(block_info, consensus_data_hash);
        info!("[Pipeline] Signed ledger info {ledger_info}");
        let signature = signer.sign(&ledger_info).expect("Signing should succeed");
        let commit_vote = CommitVote::new_with_signature(signer.author(), ledger_info, signature);
        network_sender
            .broadcast_commit_vote(commit_vote.clone())
            .await;
        Ok(commit_vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L395-402)
```rust
        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L129-131)
```rust
                for (b1, b2) in zip_eq(ordered_blocks.iter(), executed_blocks.iter()) {
                    assert_eq!(b1.id(), b2.id());
                }
```
