# Audit Report

## Title
Transaction Execution Failure in Sharded Block Executor Due to Missing Auxiliary Info

## Summary
Transactions calling `transaction_context::monotonically_increasing_counter()` systematically fail during sharded block execution because auxiliary information (specifically `transaction_index`) is not properly propagated through the sharded execution path. This causes all such transactions to abort with `ETRANSACTION_INDEX_NOT_AVAILABLE`.

## Finding Description

The vulnerability stems from a missing auxiliary info propagation in the sharded block execution path:

1. **Root Cause in DefaultTxnProvider**: When `auxiliary_info.is_empty()` at line 69, the `get_auxiliary_info()` method returns `A::new_empty()` which creates `PersistedAuxiliaryInfo::None` without a transaction index. [1](#0-0) 

2. **Sharded Executor Creates Empty Auxiliary Info**: The sharded executor service uses `DefaultTxnProvider::new_without_info()`, which initializes an empty auxiliary_info vector. [2](#0-1) 

3. **Block Preparation Confirms Empty Vector**: During block preparation for sharded execution, auxiliary_info is explicitly set to an empty vector. [3](#0-2) 

4. **Acknowledged but Unfixed**: The executor workflow contains a TODO comment acknowledging this issue. [4](#0-3) 

5. **Native Function Aborts**: When `PersistedAuxiliaryInfo::None` is used, it maps to `TransactionIndexKind::NotAvailable`, causing the monotonically increasing counter native function to abort. [5](#0-4) 

6. **Feature Enabled by Default**: The `MONOTONICALLY_INCREASING_COUNTER` feature flag is enabled by default in production. [6](#0-5) 

**Attack Path:**
1. Attacker submits a transaction containing a call to `transaction_context::monotonically_increasing_counter()`
2. If the block is executed via the sharded executor path, the transaction receives empty auxiliary info
3. The native function detects `TransactionIndexKind::NotAvailable` and aborts with error code `ETRANSACTION_INDEX_NOT_AVAILABLE`
4. The transaction fails deterministically, denying service to users relying on monotonic counters

## Impact Explanation

**Severity: Medium**

This vulnerability causes:
- **Denial of Service**: Legitimate transactions using `monotonically_increasing_counter()` systematically fail when executed through sharded path
- **Feature Incompatibility**: Despite the feature being enabled by default, it's unusable with sharded execution
- **State Inconsistency Risk**: If different validators use different execution paths (sharded vs unsharded), this could lead to consensus divergence, though current evidence suggests execution path is uniform across validators

According to Aptos bug bounty criteria, this qualifies as **Medium Severity** due to limited transaction type impact (only affects transactions calling the monotonic counter) and state inconsistency requiring intervention.

## Likelihood Explanation

**Likelihood: Medium-High if sharded execution is enabled**

The likelihood depends on operational deployment:
- Sharded execution infrastructure exists in production code (not test-only)
- The `MONOTONICALLY_INCREASING_COUNTER` feature is enabled by default
- Any Move contract or transaction can call `monotonically_increasing_counter()`
- The issue occurs deterministically when both conditions are met (sharded execution + counter call)

The vulnerability is acknowledged by developers (TODO comment) but remains unfixed, suggesting it may affect future deployments when sharded execution is fully rolled out.

## Recommendation

**Fix: Propagate auxiliary info through sharded execution path**

1. **Modify ShardedExecutorService** to accept and pass auxiliary_info:
   - Update `execute_transactions_with_dependencies` to accept auxiliary_info parameter
   - Create proper `AuxiliaryInfo` for each transaction based on its index
   - Pass auxiliary_info to `DefaultTxnProvider::new()` instead of using `new_without_info()`

2. **Update Block Preparation** to generate auxiliary_info for sharded execution:
   - In `block_preparation.rs`, create proper auxiliary_info vector even for sharded path
   - Map transaction indices correctly after partitioning

3. **Propagate through execution workflow**:
   - Update `by_transaction_execution_sharded` to pass auxiliary_infos to actual execution
   - Ensure auxiliary_info is correctly mapped across shard boundaries

**Alternative**: If sharded execution with auxiliary info is not immediately feasible, add runtime validation to reject transactions calling `monotonically_increasing_counter()` when sharded execution is active, providing clear error messaging.

## Proof of Concept

```move
// Move module that triggers the vulnerability
module test_addr::counter_test {
    use aptos_framework::transaction_context;
    
    public entry fun trigger_abort() {
        // This call will abort with ETRANSACTION_INDEX_NOT_AVAILABLE (code 5)
        // when executed through sharded block executor
        let _counter = transaction_context::monotonically_increasing_counter();
    }
}
```

**Reproduction Steps:**
1. Deploy the above module to a testnet with sharded execution enabled
2. Submit a transaction calling `trigger_abort()`
3. When executed through sharded path, transaction aborts with error code 0x050000 (ETRANSACTION_INDEX_NOT_AVAILABLE)
4. Same transaction succeeds when executed through unsharded path

**Verification:**
Check `DefaultTxnProvider::get_auxiliary_info()` behavior:
- When `auxiliary_info.is_empty()` returns true, `A::new_empty()` is called
- This creates `PersistedAuxiliaryInfo::None`
- Native function validation at line 199-203 of `transaction_context.rs` rejects this
- Transaction aborts with deterministic error code

## Notes

While this vulnerability exists in production code, its actual impact depends on whether sharded block execution is currently enabled in mainnet validators. The existence of the TODO comment suggests this is a known limitation that developers are aware of, but the fact that the `MONOTONICALLY_INCREASING_COUNTER` feature is enabled by default while the infrastructure doesn't support it represents a dangerous incompatibility. This issue should be resolved before sharded execution is widely deployed to prevent unexpected transaction failures.

### Citations

**File:** aptos-move/block-executor/src/txn_provider/default.rs (L69-72)
```rust
            } else {
                // Fallback if no existing auxiliary infos
                A::new_empty()
            }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L143-144)
```rust
                let txn_provider =
                    DefaultTxnProvider::new_without_info(signature_verified_transactions);
```

**File:** execution/executor-benchmark/src/block_preparation.rs (L106-110)
```rust
                ExecutableBlock::new(
                    block_id,
                    ExecutableTransactions::Sharded(partitioned_txns),
                    vec![],
                )
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L80-81)
```rust
            // TODO: Execution with auxiliary info is yet to be supported properly here for sharded transactions
            ExecutableTransactions::Sharded(txns) => Self::by_transaction_execution_sharded::<V>(
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L192-204)
```rust
        let (reserved_byte, transaction_index) = match transaction_index_kind {
            TransactionIndexKind::BlockExecution { transaction_index } => {
                (0u128, transaction_index)
            },
            TransactionIndexKind::ValidationOrSimulation { transaction_index } => {
                (1u128, transaction_index)
            },
            TransactionIndexKind::NotAvailable => {
                return Err(SafeNativeError::Abort {
                    abort_code: error::invalid_state(abort_codes::ETRANSACTION_INDEX_NOT_AVAILABLE),
                });
            },
        };
```

**File:** types/src/on_chain_config/aptos_features.rs (L267-267)
```rust
            FeatureFlag::MONOTONICALLY_INCREASING_COUNTER,
```
