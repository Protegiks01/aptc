# Audit Report

## Title
Lack of Domain Separation in Noise Protocol Session Key Derivation Across Network Contexts

## Summary
The HKDF `expand()` function allows empty `info` parameters, and the Noise protocol implementation uses `None` for the info parameter during final session key derivation. Combined with the absence of NetworkId in the handshake prologue, this creates a theoretical cross-network key reuse vulnerability if ephemeral key generation fails or is compromised.

## Finding Description

The security issue exists across multiple layers:

**HKDF Implementation** - The `expand()` function explicitly allows empty info parameters: [1](#0-0) 

**Noise Protocol Key Derivation** - The final session key split uses `None` for info: [2](#0-1) [3](#0-2) [4](#0-3) 

**Missing NetworkId in Prologue** - The handshake prologue only includes peer_id and public key, NOT NetworkId: [5](#0-4) [6](#0-5) 

**Multiple Network Contexts** - Aptos operates three distinct networks without cryptographic separation: [7](#0-6) 

While application-layer validation checks NetworkId after the Noise handshake: [8](#0-7) 

This check occurs AFTER session keys are already derived, meaning the cryptographic layer provides no domain separation between networks.

## Impact Explanation

This represents a **defense-in-depth violation** rather than a directly exploitable vulnerability. The impact would be HIGH if exploited, but exploitation requires compromising the random number generator:

- If ephemeral keys could be predicted or replayed across networks, identical session keys would be derived
- An attacker could potentially decrypt Validator network traffic using keys from Public network
- Cross-network impersonation attacks would become possible

However, this requires defeating `OsRng` (cryptographically secure RNG): [9](#0-8) 

## Likelihood Explanation

**Current Likelihood: Very Low** - Exploitation requires:
1. RNG compromise or weakness allowing ephemeral key prediction/reuse
2. Bypass of application-layer network_id validation
3. Same static keys used across different network contexts

The use of `OsRng` makes direct exploitation infeasible under normal conditions.

## Recommendation

Add NetworkId to the HKDF info parameter for domain separation:

```rust
// In noise.rs hkdf() function, modify to accept network context
fn hkdf(ck: &[u8], dh_output: Option<&[u8]>, network_info: Option<&[u8]>) -> Result<(Vec<u8>, Vec<u8>), NoiseError> {
    let dh_output = dh_output.unwrap_or(&[]);
    let hkdf_output = if dh_output.is_empty() {
        Hkdf::<sha2::Sha256>::extract_then_expand_no_ikm(Some(ck), network_info, 64)
    } else {
        Hkdf::<sha2::Sha256>::extract_then_expand(Some(ck), dh_output, network_info, 64)
    };
    // ...
}
```

And pass NetworkId as info parameter during final key derivation.

## Proof of Concept

A PoC cannot be constructed without first compromising the RNG, which is out of scope per security model. The vulnerability is theoretical without additional bugs.

---

**Notes:**

While the HKDF implementation correctly allows empty info parameters per RFC 5869, and the Noise protocol implementation follows the specification, the lack of NetworkId binding in session key derivation violates cryptographic best practices for domain separation. However, this alone does not constitute an exploitable vulnerability under the strict validation criteria - it requires an additional RNG weakness to exploit. The application-layer network_id validation provides adequate protection under normal operating conditions.

### Citations

**File:** crates/aptos-crypto/src/hkdf.rs (L129-144)
```rust
    pub fn expand(prk: &[u8], info: Option<&[u8]>, length: usize) -> Result<Vec<u8>, HkdfError> {
        // According to RFC5869, MAX_OUTPUT_LENGTH <= 255 * HashLen â€” which is
        // checked below.
        // We specifically exclude a zero size length as well.
        if length == 0 {
            return Err(HkdfError::InvalidOutputLengthError);
        }

        let hkdf =
            hkdf::Hkdf::<D>::from_prk(prk).map_err(|_| HkdfError::WrongPseudorandomKeyError)?;
        let mut okm = vec![0u8; length];
        hkdf.expand(info.unwrap_or(&[]), &mut okm)
            // length > D::OutputSize::to_usize() * 255
            .map_err(|_| HkdfError::InvalidOutputLengthError)?;
        Ok(okm)
    }
```

**File:** crates/aptos-crypto/src/noise.rs (L192-203)
```rust
fn hkdf(ck: &[u8], dh_output: Option<&[u8]>) -> Result<(Vec<u8>, Vec<u8>), NoiseError> {
    let dh_output = dh_output.unwrap_or(&[]);
    let hkdf_output = if dh_output.is_empty() {
        Hkdf::<sha2::Sha256>::extract_then_expand_no_ikm(Some(ck), None, 64)
    } else {
        Hkdf::<sha2::Sha256>::extract_then_expand(Some(ck), dh_output, None, 64)
    };

    let hkdf_output = hkdf_output.map_err(|_| NoiseError::Hkdf)?;
    let (k1, k2) = hkdf_output.split_at(32);
    Ok((k1.to_vec(), k2.to_vec()))
}
```

**File:** crates/aptos-crypto/src/noise.rs (L300-300)
```rust
        let e = x25519::PrivateKey::generate(rng);
```

**File:** crates/aptos-crypto/src/noise.rs (L395-395)
```rust
        let (k1, k2) = hkdf(&ck, None)?;
```

**File:** crates/aptos-crypto/src/noise.rs (L548-548)
```rust
        let (k1, k2) = hkdf(&ck, None)?;
```

**File:** network/framework/src/noise/handshake.rs (L158-159)
```rust
    /// The prologue is the client's peer_id and the remote's expected public key.
    const PROLOGUE_SIZE: usize = PeerId::LENGTH + x25519::PUBLIC_KEY_SIZE;
```

**File:** network/framework/src/noise/handshake.rs (L197-200)
```rust
        // craft prologue = self_peer_id | expected_public_key
        client_message[..PeerId::LENGTH].copy_from_slice(self.network_context.peer_id().as_ref());
        client_message[PeerId::LENGTH..Self::PROLOGUE_SIZE]
            .copy_from_slice(remote_public_key.as_slice());
```

**File:** config/src/network_id.rs (L77-83)
```rust
#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord, EnumIter)]
#[repr(u8)]
pub enum NetworkId {
    Validator = 0,
    Vfn = 3,
    Public = 4,
}
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L443-449)
```rust
        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }
```
