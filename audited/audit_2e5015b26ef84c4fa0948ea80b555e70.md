# Audit Report

## Title
Incomplete Bind Address Override Exposes P2P Networking Ports on Local Testnet

## Summary
The `NodeManager::new_with_config()` function fails to override the `listen_address` for `validator_network` and `full_node_networks` when the `bind_to` parameter specifies localhost binding. This causes P2P networking ports (6180, 6181) to remain bound to 0.0.0.0 (all interfaces) even when the user intends localhost-only operation, exposing the test node to network-based attacks.

## Finding Description
When a user runs `aptos node run-local-testnet` without the `--bind-to` flag on a non-containerized system, the CLI correctly determines that services should bind to 127.0.0.1 (localhost only). [1](#0-0) 

The `bind_to` parameter is then passed to `NodeManager::new()`, which calls `NodeManager::new_with_config()`. This function overrides the bind addresses for the REST API, Indexer gRPC, Admin Service, and Inspection Service to use the specified `bind_to` address. [2](#0-1) 

However, the validator network and full node networks listen addresses are never overridden. The default validator configuration sets these networks to bind to all interfaces (0.0.0.0) on their respective ports. [3](#0-2) [4](#0-3) 

This creates a security gap where:
1. User expects localhost-only binding (implicitly, by not running in a container)
2. HTTP APIs bind correctly to 127.0.0.1
3. P2P networking ports (TCP 6180, 6181) remain exposed on 0.0.0.0
4. Network attackers can connect to these P2P ports

The NetworkBuilder uses the `listen_address` directly from the config to bind the network socket. [5](#0-4) 

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:

- **API crashes**: An attacker can send malicious P2P protocol messages to cause node crashes or resource exhaustion
- **Validator node slowdowns**: Connection flooding or protocol exploitation can degrade performance
- **Significant protocol violations**: Exposes internal P2P networking layer intended for trusted peers only

The exposed P2P ports allow network-level attackers to:
- Attempt peer connections with malicious intent
- Exploit vulnerabilities in P2P message handling
- Perform DoS attacks via connection flooding
- Gather information about the node and network topology
- Interfere with consensus messaging in test environments

## Likelihood Explanation
**Likelihood: High**

This vulnerability will occur in the following common scenario:
1. Developer runs `aptos node run-local-testnet` on their workstation (not in a container)
2. Developer is on a shared network (office, university, coffee shop, home router)
3. Ports 6180 and 6181 are automatically exposed to the local network
4. Attacker on same network can scan and discover these ports
5. No authentication or explicit user action required for exposure

The attack requires:
- Attacker on same network (common in shared environments)
- No special privileges or insider access
- Standard network scanning tools (nmap, etc.)
- Knowledge of Aptos P2P protocol (publicly documented)

## Recommendation
The `NodeManager::new_with_config()` function must override the listen addresses for validator and full node networks to respect the `bind_to` parameter:

```rust
// In NodeManager::new_with_config(), after line 166, add:

// Bind validator network to the requested address
if let Some(validator_network) = node_config.validator_network.as_mut() {
    let current_port = validator_network.listen_address.as_slice()
        .iter()
        .find_map(|protocol| match protocol {
            aptos_types::network_address::Protocol::Tcp(port) => Some(*port),
            _ => None,
        })
        .unwrap_or(6180);
    validator_network.listen_address = format!("/ip4/{}/tcp/{}", bind_to, current_port)
        .parse()
        .expect("Unable to set validator network listen address");
}

// Bind full node networks to the requested address
for full_node_network in node_config.full_node_networks.iter_mut() {
    let current_port = full_node_network.listen_address.as_slice()
        .iter()
        .find_map(|protocol| match protocol {
            aptos_types::network_address::Protocol::Tcp(port) => Some(*port),
            _ => None,
        })
        .unwrap_or(6181);
    full_node_network.listen_address = format!("/ip4/{}/tcp/{}", bind_to, current_port)
        .parse()
        .expect("Unable to set full node network listen address");
}
```

## Proof of Concept

**Step 1**: Run the local testnet without bind-to flag on a non-containerized system:
```bash
aptos node run-local-testnet
```

**Step 2**: Check listening ports with netstat:
```bash
netstat -an | grep LISTEN
```

**Expected (Incorrect) Behavior**: Shows ports 6180 and 6181 listening on 0.0.0.0:
```
tcp        0      0 0.0.0.0:6180            0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:6181            0.0.0.0:*               LISTEN
tcp        0      0 127.0.0.1:8080          0.0.0.0:*               LISTEN
```

**Step 3**: From another machine on the same network, attempt connection:
```bash
telnet <target_ip> 6180
# Connection succeeds, exposing P2P networking
```

**Expected (Correct) Behavior After Fix**: Ports 6180 and 6181 should bind to 127.0.0.1 only:
```
tcp        0      0 127.0.0.1:6180          0.0.0.0:*               LISTEN
tcp        0      0 127.0.0.1:6181          0.0.0.0:*               LISTEN
tcp        0      0 127.0.0.1:8080          0.0.0.0:*               LISTEN
```

## Notes
This vulnerability specifically affects local testnet deployments where developers expect localhost-only binding. The issue does not affect production deployments where binding to 0.0.0.0 is intentional. The security impact is amplified in shared network environments (offices, universities, co-working spaces) where multiple untrusted parties share the same network segment.

### Citations

**File:** crates/aptos/src/node/local_testnet/mod.rs (L273-283)
```rust
        let running_inside_container = Path::new(".dockerenv").exists();
        let bind_to = match self.bind_to {
            Some(bind_to) => bind_to,
            None => {
                if running_inside_container {
                    Ipv4Addr::new(0, 0, 0, 0)
                } else {
                    Ipv4Addr::new(127, 0, 0, 1)
                }
            },
        };
```

**File:** crates/aptos/src/node/local_testnet/node.rs (L163-166)
```rust
        node_config.api.address.set_ip(IpAddr::V4(bind_to));
        node_config.indexer_grpc.address.set_ip(IpAddr::V4(bind_to));
        node_config.admin_service.address = bind_to.to_string();
        node_config.inspection_service.address = bind_to.to_string();
```

**File:** config/src/config/test_data/validator.yaml (L24-25)
```yaml
full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
```

**File:** config/src/config/test_data/validator.yaml (L40-42)
```yaml
validator_network:
    discovery_method: "onchain"
    listen_address: "/ip4/0.0.0.0/tcp/6180"
```

**File:** network/builder/src/builder.rs (L79-94)
```rust
        listen_address: NetworkAddress,
        authentication_mode: AuthenticationMode,
        max_frame_size: usize,
        max_message_size: usize,
        enable_proxy_protocol: bool,
        network_channel_size: usize,
        inbound_connection_limit: usize,
        tcp_buffer_cfg: TCPBufferCfg,
    ) -> Self {
        // A network cannot exist without a PeerManager
        // TODO:  construct this in create and pass it to new() as a parameter. The complication is manual construction of NetworkBuilder in various tests.
        let peer_manager_builder = PeerManagerBuilder::create(
            chain_id,
            network_context,
            time_service.clone(),
            listen_address,
```
