# Audit Report

## Title
Memory Exhaustion DoS via Oversized Transaction Payloads in P2P Mempool Propagation

## Summary
The P2P network path for transaction propagation lacks pre-deserialization size validation, allowing malicious peers to send transactions with extremely large code vectors (up to ~60MB) that get fully deserialized into memory before being rejected by the 64KB transaction size limit. This creates a memory exhaustion denial-of-service vector against validator nodes.

## Finding Description

The `object_code_deployment_upgrade()` function in the Aptos stdlib allows callers to provide arbitrarily large `code: Vec<Vec<u8>>` parameters. [1](#0-0) 

When a transaction calling this function is created, the code vector is BCS-serialized into the transaction payload. The transaction can be propagated through two paths:

**API Path (Protected):**
The REST API enforces a `content_length_limit` of 8MB that checks the Content-Length header BEFORE deserialization. [2](#0-1) [3](#0-2) 

**P2P Network Path (Vulnerable):**
The P2P network layer allows messages up to 64MB. [4](#0-3)  When a MempoolSyncMsg containing SignedTransaction objects is received, it is fully deserialized BEFORE any transaction size validation occurs. [5](#0-4) 

The transaction size validation only happens during gas checks in the VM, which occurs AFTER full deserialization. [6](#0-5)  The limit is 64KB for regular transactions. [7](#0-6) 

**Attack Flow:**
1. Attacker creates a transaction with `code` vector containing millions of bytes
2. Transaction is BCS-serialized (~50-60MB total)
3. Attacker sends via P2P as MempoolSyncMsg::BroadcastTransactionsRequest
4. Victim node receives and fully deserializes the message (allocates ~50-60MB memory)
5. Transaction validation checks size and rejects it (exceeds 64KB limit)
6. Memory is freed, but allocation/deallocation occurred
7. Attacker repeats with multiple connections or transactions

The vulnerability exists because the transaction_size check calculates size from the already-deserialized RawTransaction object, not from raw bytes before deserialization. [8](#0-7) 

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria: "Validator node slowdowns")

This vulnerability enables memory exhaustion attacks against validator nodes:

- Each oversized transaction forces allocation of up to ~60MB during deserialization
- Multiple malicious peers can amplify the attack (limited by `max_broadcasts_per_peer = 20` per peer)
- Repeated memory allocation/deallocation causes memory pressure and potential OOM conditions
- Could degrade validator performance or cause crashes during consensus-critical operations
- Unlike API path which has pre-deserialization protection, P2P path is completely exposed

The argument validation limit of 1MB [9](#0-8)  only applies during Move function execution, not during initial transaction deserialization.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The attack is feasible because:
- P2P network allows transaction propagation between nodes
- No pre-deserialization size checks exist on the network path (unlike API)
- Network layer permits up to 64MB messages
- Attackers can establish multiple peer connections to amplify the attack
- Transaction creation is straightforward using the provided SDK functions

The main limiting factor is whether untrusted peers can connect to the validator P2P network, which depends on network configuration and firewall rules.

## Recommendation

**Add pre-deserialization size validation at the network layer for mempool messages:**

1. Implement a size check before deserializing MempoolSyncMsg in the network layer, similar to the API's Content-Length validation
2. Set a reasonable limit (e.g., 1MB) for individual transactions within mempool broadcast messages
3. Reject oversized messages before allocating memory for deserialization
4. Add metrics to track rejected oversized messages for monitoring

**Example Fix Location:**
Add validation in the network message handler before deserializing DirectSendMsg payloads containing MempoolSyncMsg. Check the raw message size against `max_transaction_size_in_bytes` (64KB) before calling BCS deserialization.

Alternatively, enforce the transaction size limit at the network serialization level by failing to serialize transactions that exceed the limit, preventing them from ever being sent.

## Proof of Concept

```rust
// PoC: Create oversized transaction via object_code_deployment_upgrade
use aptos_cached_packages::aptos_stdlib::object_code_deployment_upgrade;
use aptos_types::account_address::AccountAddress;

fn create_dos_transaction() -> TransactionPayload {
    // Create a huge code vector (50MB)
    let huge_module = vec![0u8; 50 * 1024 * 1024];
    let code = vec![huge_module];
    
    let metadata = vec![]; // Empty metadata for simplicity
    let code_object = AccountAddress::random();
    
    // This creates a transaction with ~50MB payload
    object_code_deployment_upgrade(metadata, code, code_object)
}

// Steps to exploit:
// 1. Establish P2P connection to target validator node
// 2. Create multiple oversized transactions using create_dos_transaction()
// 3. Send via MempoolSyncMsg::BroadcastTransactionsRequest
// 4. Target node will deserialize all ~50MB before rejecting
// 5. Repeat to cause sustained memory pressure
// 6. Monitor target node for performance degradation or OOM
```

## Notes

The API submission path is properly protected with pre-deserialization Content-Length checks, but the P2P network path lacks this critical validation. This asymmetry creates an exploitable attack surface where the same transaction that would be rejected at the API layer (for being > 8MB) can be propagated through the network layer (which allows up to ~60MB) and force memory allocation before validation.

### Citations

**File:** aptos-move/framework/cached-packages/src/aptos_stdlib.rs (L41-62)
```rust
pub fn object_code_deployment_upgrade(
    metadata_serialized: Vec<u8>,
    code: Vec<Vec<u8>>,
    code_object: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("object_code_deployment").to_owned(),
        ),
        ident_str!("upgrade").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&metadata_serialized).unwrap(),
            bcs::to_bytes(&code).unwrap(),
            bcs::to_bytes(&code_object).unwrap(),
        ],
    ))
}
```

**File:** api/src/check_size.rs (L1-100)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use poem::{
    error::SizedLimitError,
    http::Method,
    web::headers::{self, HeaderMapExt},
    Endpoint, Middleware, Request, Result,
};

/// This middleware confirms that the Content-Length header is set and the
/// value is within the acceptable range. It only applies to POST requests.
pub struct PostSizeLimit {
    max_size: u64,
}

impl PostSizeLimit {
    pub fn new(max_size: u64) -> Self {
        Self { max_size }
    }
}

impl<E: Endpoint> Middleware<E> for PostSizeLimit {
    type Output = PostSizeLimitEndpoint<E>;

    fn transform(&self, ep: E) -> Self::Output {
        PostSizeLimitEndpoint {
            inner: ep,
            max_size: self.max_size,
        }
    }
}

/// Endpoint for PostSizeLimit middleware.
pub struct PostSizeLimitEndpoint<E> {
    inner: E,
    max_size: u64,
}

impl<E: Endpoint> Endpoint for PostSizeLimitEndpoint<E> {
    type Output = E::Output;

    async fn call(&self, req: Request) -> Result<Self::Output> {
        if req.method() != Method::POST {
            return self.inner.call(req).await;
        }

        let content_length = req
            .headers()
            .typed_get::<headers::ContentLength>()
            .ok_or(SizedLimitError::MissingContentLength)?;

        if content_length.0 > self.max_size {
            return Err(SizedLimitError::PayloadTooLarge.into());
        }

        self.inner.call(req).await
    }
}


```

**File:** config/src/config/api_config.rs (L1-100)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{
    config::{
        config_sanitizer::ConfigSanitizer, gas_estimation_config::GasEstimationConfig,
        node_config_loader::NodeType, Error, NodeConfig, MAX_RECEIVING_BLOCK_TXNS,
    },
    utils,
};
use aptos_types::{account_address::AccountAddress, chain_id::ChainId};
use serde::{Deserialize, Serialize};
use std::net::SocketAddr;

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct ApiConfig {
    /// Enables the REST API endpoint
    #[serde(default = "default_enabled")]
    pub enabled: bool,
    /// Address for the REST API to listen on. Set to 0.0.0.0:port to allow all inbound connections.
    pub address: SocketAddr,
    /// Path to a local TLS certificate to enable HTTPS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_cert_path: Option<String>,
    /// Path to a local TLS key to enable HTTPS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_key_path: Option<String>,
    /// A maximum limit to the body of a POST request in bytes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_length_limit: Option<u64>,
    /// Enables failpoints for error testing
    #[serde(default = "default_disabled")]
    pub failpoints_enabled: bool,
    /// Enables JSON output of APIs that support it
    #[serde(default = "default_enabled")]
    pub json_output_enabled: bool,
    /// Enables BCS output of APIs that support it
    #[serde(default = "default_enabled")]
    pub bcs_output_enabled: bool,
    /// Enables compression middleware for API responses
    #[serde(default = "default_enabled")]
    pub compression_enabled: bool,
    /// Enables encode submission API
    #[serde(default = "default_enabled")]
    pub encode_submission_enabled: bool,
    /// Enables transaction submission APIs
    #[serde(default = "default_enabled")]
    pub transaction_submission_enabled: bool,
    /// Enables transaction simulation
    #[serde(default = "default_enabled")]
    pub transaction_simulation_enabled: bool,
    /// Maximum number of transactions that can be sent with the Batch submit API
    pub max_submit_transaction_batch_size: usize,
    /// Maximum page size for transaction paginated APIs
    pub max_transactions_page_size: u16,
    /// Maximum page size for block transaction APIs
    pub max_block_transactions_page_size: u16,
    /// Maximum page size for event paginated APIs
    pub max_events_page_size: u16,
    /// Maximum page size for resource paginated APIs
    pub max_account_resources_page_size: u16,
    /// Maximum page size for module paginated APIs
    pub max_account_modules_page_size: u16,
    /// Maximum gas unit limit for view functions
    ///
    /// This limits the execution length of a view function to the given gas used.
    pub max_gas_view_function: u64,
    /// Optional: Maximum number of worker threads for the API.
    ///
    /// If not set, `runtime_worker_multiplier` will multiply times the number of CPU cores on the machine
    pub max_runtime_workers: Option<usize>,
    /// Multiplier for number of worker threads with number of CPU cores
    ///
    /// If `max_runtime_workers` is set, this is ignored
    pub runtime_worker_multiplier: usize,
    /// Configs for computing unit gas price estimation
    pub gas_estimation: GasEstimationConfig,
    /// Periodically call gas estimation
    pub periodic_gas_estimation_ms: Option<u64>,
    /// Configuration to filter view function requests.
    pub view_filter: ViewFilter,
    /// Periodically log stats for view function and simulate transaction usage
    pub periodic_function_stats_sec: Option<u64>,
    /// The time wait_by_hash will wait before returning 404.
    pub wait_by_hash_timeout_ms: u64,
    /// The interval at which wait_by_hash will poll the storage for the transaction.
    pub wait_by_hash_poll_interval_ms: u64,
    /// The number of active wait_by_hash requests that can be active at any given time.
    pub wait_by_hash_max_active_connections: usize,
    /// Allow submission of encrypted transactions via the API
    pub allow_encrypted_txns_submission: bool,
}

const DEFAULT_ADDRESS: &str = "127.0.0.1";
const DEFAULT_PORT: u16 = 8080;
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
pub const DEFAULT_MAX_SUBMIT_TRANSACTION_BATCH_SIZE: usize = 10;
pub const DEFAULT_MAX_PAGE_SIZE: u16 = 100;
const DEFAULT_MAX_ACCOUNT_RESOURCES_PAGE_SIZE: u16 = 9999;
```

**File:** config/src/config/network_config.rs (L1-100)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{
    config::{
        identity_config::{Identity, IdentityFromStorage},
        Error, IdentityBlob,
    },
    network_id::NetworkId,
    utils,
};
use aptos_crypto::{x25519, Uniform};
use aptos_secure_storage::{CryptoStorage, KVStorage, Storage};
use aptos_short_hex_str::AsShortHexStr;
use aptos_types::{
    account_address::from_identity_public_key, network_address::NetworkAddress,
    transaction::authenticator::AuthenticationKey, PeerId,
};
use rand::{
    rngs::{OsRng, StdRng},
    Rng, SeedableRng,
};
use serde::{Deserialize, Serialize};
use std::{
    collections::{HashMap, HashSet},
    convert::TryFrom,
    fmt,
    path::PathBuf,
    string::ToString,
};

// TODO: We could possibly move these constants somewhere else, but since they are defaults for the
//   configurations of the system, we'll leave it here for now.
/// Current supported protocol negotiation handshake version. See
/// [`aptos_network::protocols::wire::v1`](../../network/protocols/wire/handshake/v1/index.html).
pub const HANDSHAKE_VERSION: u8 = 0;
pub const NETWORK_CHANNEL_SIZE: usize = 1024;
pub const PING_INTERVAL_MS: u64 = 10_000;
pub const PING_TIMEOUT_MS: u64 = 20_000;
pub const PING_FAILURES_TOLERATED: u64 = 3;
pub const CONNECTIVITY_CHECK_INTERVAL_MS: u64 = 5000;
pub const MAX_CONNECTION_DELAY_MS: u64 = 60_000; /* 1 minute */
pub const MAX_FULLNODE_OUTBOUND_CONNECTIONS: usize = 6;
pub const MAX_INBOUND_CONNECTIONS: usize = 100;
pub const MAX_MESSAGE_METADATA_SIZE: usize = 128 * 1024; /* 128 KiB: a buffer for metadata that might be added to messages by networking */
pub const MESSAGE_PADDING_SIZE: usize = 2 * 1024 * 1024; /* 2 MiB: a safety buffer to allow messages to get larger during serialization */
pub const MAX_APPLICATION_MESSAGE_SIZE: usize =
    (MAX_MESSAGE_SIZE - MAX_MESSAGE_METADATA_SIZE) - MESSAGE_PADDING_SIZE; /* The message size that applications should check against */
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
pub const CONNECTION_BACKOFF_BASE: u64 = 2;
pub const IP_BYTE_BUCKET_RATE: usize = 102400 /* 100 KiB */;
pub const IP_BYTE_BUCKET_SIZE: usize = IP_BYTE_BUCKET_RATE;

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NetworkConfig {
    /// Maximum backoff delay for connecting outbound to peers
    pub max_connection_delay_ms: u64,
    /// Base for outbound connection backoff
    pub connection_backoff_base: u64,
    /// Rate to check connectivity to connected peers
    pub connectivity_check_interval_ms: u64,
    /// Size of all network channels
    pub network_channel_size: usize,
    /// Choose a protocol to discover and dial out to other peers on this network.
    /// `DiscoveryMethod::None` disables discovery and dialing out (unless you have
    /// seed peers configured).
    pub discovery_method: DiscoveryMethod,
    /// Same as `discovery_method` but allows for multiple
    pub discovery_methods: Vec<DiscoveryMethod>,
    /// Identity of this network
    pub identity: Identity,
    // TODO: Add support for multiple listen/advertised addresses in config.
    /// The address that this node is listening on for new connections.
    pub listen_address: NetworkAddress,
    /// Select this to enforce that both peers should authenticate each other, otherwise
    /// authentication only occurs for outgoing connections.
    pub mutual_authentication: bool,
    /// ID of the network to differentiate between networks
    pub network_id: NetworkId,
    /// Number of threads to run for networking
    pub runtime_threads: Option<usize>,
    /// Overrides for the size of the inbound and outbound buffers for each peer.
    /// NOTE: The defaults are None, so socket options are not called. Change to Some values with
    /// caution. Experiments have shown that relying on Linux's default tcp auto-tuning can perform
    /// better than setting these. In particular, for larger values to take effect, the
    /// `net.core.rmem_max` and `net.core.wmem_max` sysctl values may need to be increased. On a
    /// vanilla GCP machine, these are set to 212992. Without increasing the sysctl values and
    /// setting a value will constrain the buffer size to the sysctl value. (In contrast, default
    /// auto-tuning can increase beyond these values.)
    pub inbound_rx_buffer_size_bytes: Option<u32>,
    pub inbound_tx_buffer_size_bytes: Option<u32>,
    pub outbound_rx_buffer_size_bytes: Option<u32>,
    pub outbound_tx_buffer_size_bytes: Option<u32>,
    /// Addresses of initial peers to connect to. In a mutual_authentication network,
    /// we will extract the public keys from these addresses to set our initial
    /// trusted peers set.  TODO: Replace usage in configs with `seeds` this is for backwards compatibility
    pub seed_addrs: HashMap<PeerId, Vec<NetworkAddress>>,
    /// The initial peers to connect to prior to onchain discovery
```

**File:** mempool/src/shared_mempool/coordinator.rs (L360-372)
```rust
                MempoolSyncMsg::BroadcastTransactionsRequest {
                    message_id,
                    transactions,
                } => {
                    process_received_txns(
                        bounded_executor,
                        smp,
                        network_id,
                        message_id,
                        transactions.into_iter().map(|t| (t, None, None)).collect(),
                        peer_id,
                    )
                    .await;
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-121)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** types/src/transaction/mod.rs (L1294-1298)
```rust
    pub fn raw_txn_bytes_len(&self) -> usize {
        *self.raw_txn_size.get_or_init(|| {
            bcs::serialized_size(&self.raw_txn).expect("Unable to serialize RawTransaction")
        })
    }
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L557-562)
```rust
    const MAX_NUM_BYTES: usize = 1_000_000;
    if len.checked_add(n).is_none_or(|s| s > MAX_NUM_BYTES) {
        return Err(deserialization_error(&format!(
            "Couldn't read bytes: maximum limit of {} bytes exceeded",
            MAX_NUM_BYTES
        )));
```
