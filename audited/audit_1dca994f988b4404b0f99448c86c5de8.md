# Audit Report

## Title
Empty ValidatorSet Causes Complete Network Halt via Reconfiguration Filtering

## Summary
The ValidatorSet can become empty during epoch reconfiguration when all validators are filtered out due to insufficient stake, causing a complete consensus halt with no validators able to propose blocks. This occurs because the `on_new_epoch` function filters validators below the minimum stake requirement without checking if the resulting set is empty, and the consensus layer panics when attempting to select a proposer from an empty validator list.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Staking Module - Validator Filtering Without Empty Check** [1](#0-0) 

During `on_new_epoch()`, validators are filtered based on minimum stake requirements. The code creates an empty `next_epoch_validators` vector and only adds validators meeting the threshold. Critically, there is **no validation** that at least one validator remains after filtering.

2. **Missing Validation During Deserialization** [2](#0-1) 

The `ValidatorSet` struct uses standard serde deserialization without custom validation to ensure `active_validators` is non-empty. The `empty()` method explicitly allows creating empty validator sets.

3. **Consensus Panic on Empty Validator Set** [3](#0-2) 

When consensus attempts to select a proposer from an empty validator list, `RotatingProposer::get_valid_proposer()` performs a modulo operation with `proposers.len()` which causes a **division by zero panic** when the list is empty.

**Attack Vector - Governance Manipulation:**

The minimum stake requirement can be updated via governance: [4](#0-3) 

The validation only checks that `minimum_stake <= maximum_stake`, but **does not verify** that current validators meet the new minimum: [5](#0-4) 

**Exploitation Steps:**

1. Malicious governance proposal passes that sets `minimum_stake` to a value higher than all current validators' stakes (e.g., through a coordinated attack or governance compromise)
2. Next reconfiguration triggers `stake::on_new_epoch()`
3. All validators are filtered out in the filtering loop (lines 1377-1399) because none meet the new minimum
4. Empty `next_epoch_validators` vector is assigned to `validator_set.active_validators`
5. Empty ValidatorSet is serialized and stored on-chain
6. Consensus epoch manager calls `start_new_epoch()` and creates ValidatorVerifier from empty set: [6](#0-5) 
7. ValidatorVerifier is created with zero validators and `quorum_voting_power = 0`: [7](#0-6) 
8. Proposer election is created with empty proposers list: [8](#0-7) 
9. When consensus attempts to propose a block, `get_valid_proposer()` panics with division by zero

**Alternative Scenario - Validator Unlocking:**

All validators could theoretically unlock their stake simultaneously: [9](#0-8) 

The unlock function has no check preventing validators from unlocking all active stake, which would cause filtering in the next epoch.

## Impact Explanation

**Critical Severity - Total Loss of Network Liveness**

This vulnerability causes **complete network halt** requiring a hard fork to recover, meeting the Critical severity criteria:

- **Total loss of liveness/network availability**: With zero validators, no blocks can be proposed or committed
- **Non-recoverable without hardfork**: The empty ValidatorSet persists in on-chain state and cannot be corrected through normal transactions since no validator can propose blocks
- **Consensus Safety**: While not technically a safety violation, it breaks the liveness guarantee that is fundamental to blockchain operation

The network becomes completely frozen with no mechanism for recovery without coordinated off-chain intervention (hard fork).

## Likelihood Explanation

**Medium-High Likelihood**

The vulnerability can manifest through:

1. **Malicious Governance Proposal** (Medium likelihood):
   - Requires governance compromise or coordination
   - But governance is permissionless - anyone can submit proposals
   - If attackers accumulate sufficient voting power, they can pass malicious configuration changes
   - No validation prevents setting unrealistic minimum stake values

2. **Legitimate Configuration Error** (Low-Medium likelihood):
   - Well-intentioned governance proposal raises minimum stake without checking current validator stakes
   - No warning mechanism alerts that all validators would be filtered out
   - Human error in governance is a realistic threat vector

3. **Coordinated Validator Unlocking** (Low likelihood):
   - Requires all validators to collude or make identical mistakes
   - Less realistic but theoretically possible

The lack of any validation at multiple layers (governance proposal, reconfiguration, consensus initialization) makes this vulnerability more likely to be exploited than if protections existed at any single point.

## Recommendation

**Implement Multi-Layer Validation:**

**1. Add validation in `on_new_epoch` to prevent empty validator set:**

```move
// In stake.move, after line 1401:
validator_set.active_validators = next_epoch_validators;

// ADD THIS CHECK:
assert!(
    !vector::is_empty(&validator_set.active_validators),
    error::invalid_state(EEMPTY_VALIDATOR_SET) // New error code
);

validator_set.total_voting_power = total_voting_power;
```

**2. Add validation in `update_required_stake` to prevent filtering all validators:**

```move
// In staking_config.move, in update_required_stake function:
public fun update_required_stake(
    aptos_framework: &signer,
    minimum_stake: u64,
    maximum_stake: u64,
) acquires StakingConfig {
    system_addresses::assert_aptos_framework(aptos_framework);
    validate_required_stake(minimum_stake, maximum_stake);
    
    // ADD: Verify at least one current validator meets new minimum
    let validator_set = borrow_global<stake::ValidatorSet>(@aptos_framework);
    let has_valid_validator = false;
    vector::for_each_ref(&validator_set.active_validators, |v| {
        let stake_pool = borrow_global<stake::StakePool>(v.addr);
        if (stake_pool.active_stake >= minimum_stake) {
            has_valid_validator = true;
        }
    });
    assert!(has_valid_validator, error::invalid_argument(EWOULD_EMPTY_VALIDATOR_SET));
    
    let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
    staking_config.minimum_stake = minimum_stake;
    staking_config.maximum_stake = maximum_stake;
}
```

**3. Add runtime check in consensus initialization:**

```rust
// In consensus/src/epoch_manager.rs, start_new_epoch:
let validator_set: ValidatorSet = payload
    .get()
    .expect("failed to get ValidatorSet from payload");

// ADD THIS CHECK:
if validator_set.active_validators.is_empty() {
    panic!("Cannot start epoch with empty validator set - network would halt");
}

let mut verifier: ValidatorVerifier = (&validator_set).into();
```

## Proof of Concept

```move
#[test_only]
module aptos_framework::validator_set_empty_test {
    use aptos_framework::stake;
    use aptos_framework::staking_config;
    use aptos_framework::reconfiguration;
    use std::vector;
    
    #[test(aptos_framework = @aptos_framework, validator1 = @0x123)]
    #[expected_failure(abort_code = 0x60006)] // Should fail with EEMPTY_VALIDATOR_SET if fix applied
    public entry fun test_empty_validator_set_via_minimum_stake(
        aptos_framework: &signer,
        validator1: &signer,
    ) {
        // Setup: Initialize with one validator having 1000 stake
        stake::initialize_for_test(aptos_framework);
        staking_config::initialize_for_test(
            aptos_framework,
            100,  // minimum_stake = 100
            10000, // maximum_stake
            86400, // lockup duration
            true,  // allow validator set change
            1, 1, 10
        );
        
        // Add validator with 1000 stake
        stake::create_test_validator(validator1, 1000);
        
        // Verify validator is active
        let validator_set = stake::get_validator_set();
        assert!(vector::length(&validator_set.active_validators) == 1, 0);
        
        // ATTACK: Governance proposal raises minimum stake to 50000
        // (higher than any validator's stake)
        staking_config::update_required_stake(aptos_framework, 50000, 100000);
        
        // Trigger reconfiguration - this will filter out all validators
        reconfiguration::reconfigure();
        
        // POST-CONDITION: Validator set is now EMPTY
        let validator_set = stake::get_validator_set();
        assert!(vector::length(&validator_set.active_validators) == 0, 1);
        
        // At this point, consensus would panic when trying to select proposer
        // Network is completely halted with no recovery mechanism
    }
}
```

The PoC demonstrates that a governance proposal can set minimum stake requirements that filter out all validators, resulting in an empty ValidatorSet and complete network halt.

## Notes

This vulnerability is particularly severe because:

1. **No circuit breakers exist** at any layer to prevent empty validator sets
2. **Governance validation is insufficient** - only checks mathematical constraints, not operational viability
3. **Consensus assumes non-empty sets** - panics rather than gracefully handling edge case
4. **Recovery requires hard fork** - no in-protocol mechanism to restore validators once set is empty

The fix requires defense-in-depth with validation at multiple layers: governance proposal validation, reconfiguration validation, and consensus initialization validation.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1117-1132)
```text
    public fun unlock_with_cap(amount: u64, owner_cap: &OwnerCapability) acquires StakePool {
        assert_reconfig_not_in_progress();
        // Short-circuit if amount to unlock is 0 so we don't emit events.
        if (amount == 0) {
            return
        };

        // Unlocked coins are moved to pending_inactive. When the current lockup cycle expires, they will be moved into
        // inactive in the earliest possible epoch transition.
        let pool_address = owner_cap.pool_address;
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        // Cap amount to unlock by maximum active stake.
        let amount = min(amount, coin::value(&stake_pool.active));
        let unlocked_stake = coin::extract(&mut stake_pool.active, amount);
        coin::merge<AptosCoin>(&mut stake_pool.pending_inactive, unlocked_stake);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1401)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** types/src/on_chain_config/validator_set.rs (L23-32)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct ValidatorSet {
    pub scheme: ConsensusScheme,
    pub active_validators: Vec<ValidatorInfo>,
    pub pending_inactive: Vec<ValidatorInfo>,
    pub pending_active: Vec<ValidatorInfo>,
    pub total_voting_power: u128,
    pub total_joining_power: u128,
}
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L274-285)
```text
    public fun update_required_stake(
        aptos_framework: &signer,
        minimum_stake: u64,
        maximum_stake: u64,
    ) acquires StakingConfig {
        system_addresses::assert_aptos_framework(aptos_framework);
        validate_required_stake(minimum_stake, maximum_stake);

        let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
        staking_config.minimum_stake = minimum_stake;
        staking_config.maximum_stake = maximum_stake;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** consensus/src/epoch_manager.rs (L287-303)
```rust
    fn create_proposer_election(
        &self,
        epoch_state: &EpochState,
        onchain_config: &OnChainConsensusConfig,
    ) -> Arc<dyn ProposerElection + Send + Sync> {
        let proposers = epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .collect::<Vec<_>>();
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
            },
            // We don't really have a fixed proposer!
            ProposerElectionType::FixedProposer(contiguous_rounds) => {
                let proposer = choose_leader(proposers);
                Arc::new(RotatingProposer::new(vec![proposer], *contiguous_rounds))
```

**File:** consensus/src/epoch_manager.rs (L1164-1174)
```rust
    async fn start_new_epoch(&mut self, payload: OnChainConfigPayload<P>) {
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
        let mut verifier: ValidatorVerifier = (&validator_set).into();
        verifier.set_optimistic_sig_verification_flag(self.config.optimistic_sig_verification);

        let epoch_state = Arc::new(EpochState {
            epoch: payload.epoch(),
            verifier: verifier.into(),
        });
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```
