# Audit Report

## Title
Script Cache Not Invalidated on Module Publishing - Time-of-Check Time-of-Use (TOCTOU) Vulnerability

## Summary
The Move VM's script cache is not invalidated when modules are published during block execution, allowing cached scripts that were verified against old module versions to execute against newly published module versions. This creates a Time-of-Check Time-of-Use (TOCTOU) vulnerability where bytecode verification invariants can be violated.

## Finding Description

The `LazyLoader::metered_verify_and_cache_script()` function verifies scripts against their immediate module dependencies and caches them in a block-scoped `SyncScriptCache` keyed by the script's SHA3-256 hash. [1](#0-0) 

The verification process loads immediate dependencies and performs dependency verification: [2](#0-1) 

However, the script cache is stored in `MVHashMap`, which is block-scoped and shared across all transactions: [3](#0-2) 

When modules are published within a block, only the layout cache is flushed - the script cache remains unchanged: [4](#0-3) 

**Attack Scenario:**

1. **Transaction T1** (block index 0): Submits script S that imports function `foo` from module M v1
   - Script S is deserialized, verified against M v1 (which has signature `foo(u64) -> u64`)
   - Verified script cached with key = SHA3-256(S's bytecode)

2. **Transaction T2** (block index 1): Publishes module M v2 that upgrades `foo` to signature `foo(u128) -> u128`
   - Module cache marks M v1 as overridden
   - **Layout cache flushed** (only struct layouts)
   - **Script cache NOT touched**

3. **Transaction T3** (block index 2): Submits the same script S
   - Cache lookup finds cached script from T1
   - Returns immediately without re-verification (line 138 of lazy.rs)
   - Executes script verified against M v1 but using M v2
   - Type mismatch: script passes u64 but M v2 expects u128
   - **Bytecode verification invariants violated**

The cached script's function references only contain `ModuleId` (address + name) without version information: [5](#0-4) 

## Impact Explanation

**Severity: Medium**

This vulnerability breaks the **Move VM Safety** invariant that bytecode execution must respect verification constraints. When a script verified against module version N executes against module version N+1, the following issues can occur:

1. **Type Safety Violations**: Parameters and return types may have changed, causing type confusion
2. **Memory Safety Issues**: If struct layouts changed, field access patterns become invalid  
3. **VM Crashes**: Runtime type checking may catch the mismatch and abort execution
4. **State Inconsistencies**: If the script partially executes before detecting the mismatch

This is classified as **Medium Severity** because:
- It requires specific timing (module publish and script execution in same block)
- Does not directly lead to fund theft but can cause state inconsistencies requiring intervention
- May cause transaction failures and validator disagreements

It does NOT reach **High/Critical** severity because:
- Modern Move VM has runtime type checking that would catch severe mismatches
- Most module upgrades maintain signature compatibility
- The issue is contained within a single block's execution

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability can occur whenever:
1. A module is upgraded within a block
2. A script that depends on that module is executed later in the same block
3. The upgrade changes function signatures or type definitions

Module publishing happens relatively frequently on Aptos mainnet during protocol upgrades, framework updates, and dApp deployments. The likelihood is reduced by:
- Most upgrades follow Move's compatibility rules
- Scripts are less common than entry function calls
- The timing window is one block (~1 second on Aptos)

However, an attacker could deliberately trigger this by:
1. Deploying a module with a public function
2. Creating a script that imports this function
3. In a single block, submitting: (a) script execution, (b) module upgrade, (c) script execution again

## Recommendation

**Fix: Clear script cache when modules are published**

Modify the module publishing code to flush the script cache alongside the layout cache:

```rust
// In txn_last_input_output.rs, line 572-576
if published {
    // Record validation requirements after the modules are published.
    global_module_cache.flush_layout_cache();
    versioned_cache.script_cache().clear();  // ADD THIS LINE
    scheduler.record_validation_requirements(txn_idx, module_ids_for_v2)?;
}
```

However, `SyncScriptCache` does not currently have a `clear()` method. You'll need to add it to the `ScriptCache` trait: [6](#0-5) 

Add a new method to the trait and implement it for both `UnsyncScriptCache` and `SyncScriptCache`:

```rust
pub trait ScriptCache {
    // ... existing methods ...
    
    /// Clears all cached scripts. Should be called when module state changes.
    fn clear_scripts(&self);
}
```

**Alternative Fix: Include dependency versions in cache key**

Instead of keying scripts only by bytecode hash, include module version information in the cache key. However, this is more complex as it requires tracking module versions/hashes.

## Proof of Concept

```rust
// Pseudo-code demonstrating the vulnerability
// This would need to be adapted to Aptos's test framework

#[test]
fn test_script_cache_toctou() {
    let mut harness = MoveHarness::new();
    let account = harness.new_account_with_balance(1_000_000);
    
    // Step 1: Publish module M v1
    let module_v1 = compile_module("
        module 0xCAFE::M {
            public fun foo(x: u64): u64 { x + 1 }
        }
    ");
    harness.publish_module(&account, module_v1);
    
    // Step 2: Execute script S that calls M::foo
    let script = compile_script("
        script {
            use 0xCAFE::M;
            fun main() {
                M::foo(42u64);  // Verified against M v1
            }
        }
    ");
    assert_success!(harness.run_script(&account, script.clone()));
    
    // Step 3: In the SAME BLOCK, upgrade module M to v2
    let module_v2 = compile_module("
        module 0xCAFE::M {
            public fun foo(x: u128): u128 { x + 1 }  // Changed signature!
        }
    ");
    
    let txns = vec![
        harness.create_publish_txn(&account, module_v2),
        harness.create_script_txn(&account, script),  // Same script, cached
    ];
    
    let results = harness.run_block(txns);
    
    // Expected: Second script should fail or re-verify
    // Actual: Script executes with stale verification, type mismatch
    assert!(results[1].status().is_error());  // Should fail but may not!
}
```

## Notes

The root cause is that script caching was designed for performance optimization without considering the interaction with module upgrades. The module cache has proper invalidation logic via the "overridden" flag, but this protection was not extended to scripts.

A historical comment confirms this was a known issue class for modules: [7](#0-6) 

The same TOCTOU issue exists for scripts but was not addressed. The script cache should either:
1. Be invalidated when any module is published (conservative, impacts performance)
2. Track script-module dependencies and selectively invalidate (complex but optimal)
3. Store dependency versions in cache key to detect mismatches (moderate complexity)

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L120-166)
```rust
    fn metered_verify_and_cache_script(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        serialized_script: &[u8],
    ) -> VMResult<Arc<Script>> {
        use Code::*;

        let hash = sha3_256(serialized_script);
        let deserialized_script = match self.module_storage.get_script(&hash) {
            Some(Verified(script)) => {
                // Before returning early, meter modules because script might have been cached by
                // other thread.
                for (addr, name) in script.immediate_dependencies_iter() {
                    let module_id = ModuleId::new(*addr, name.to_owned());
                    self.charge_module(gas_meter, traversal_context, &module_id)
                        .map_err(|err| err.finish(Location::Undefined))?;
                }
                return Ok(script);
            },
            Some(Deserialized(deserialized_script)) => deserialized_script,
            None => self
                .runtime_environment()
                .deserialize_into_script(serialized_script)
                .map(Arc::new)?,
        };

        let locally_verified_script = self
            .runtime_environment()
            .build_locally_verified_script(deserialized_script)?;

        let immediate_dependencies = locally_verified_script
            .immediate_dependencies_iter()
            .map(|(addr, name)| {
                let module_id = ModuleId::new(*addr, name.to_owned());
                self.metered_load_module(gas_meter, traversal_context, &module_id)
            })
            .collect::<VMResult<Vec<_>>>()?;

        let verified_script = self
            .runtime_environment()
            .build_verified_script(locally_verified_script, &immediate_dependencies)?;

        Ok(self
            .module_storage
            .insert_verified_script(hash, verified_script))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L154-173)
```rust
    pub fn build_verified_script(
        &self,
        locally_verified_script: LocallyVerifiedScript,
        immediate_dependencies: &[Arc<Module>],
    ) -> VMResult<Script> {
        dependencies::verify_script(
            &self.vm_config.verifier_config,
            locally_verified_script.0.as_ref(),
            immediate_dependencies
                .iter()
                .map(|module| module.as_ref().as_ref()),
        )?;
        Script::new(
            locally_verified_script.0,
            self.struct_name_index_map(),
            self.ty_pool(),
            self.module_id_pool(),
        )
        .map_err(|err| err.finish(Location::Script))
    }
```

**File:** aptos-move/mvhashmap/src/lib.rs (L41-49)
```rust
pub struct MVHashMap<K, T, V: TransactionWrite, I: Clone> {
    data: VersionedData<K, V>,
    group_data: VersionedGroupData<K, T, V>,
    delayed_fields: VersionedDelayedFields<I>,

    module_cache:
        SyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, Option<TxnIndex>>,
    script_cache: SyncScriptCache<[u8; 32], CompiledScript, Script>,
}
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L572-576)
```rust
        if published {
            // Record validation requirements after the modules are published.
            global_module_cache.flush_layout_cache();
            scheduler.record_validation_requirements(txn_idx, module_ids_for_v2)?;
        }
```

**File:** third_party/move/move-vm/runtime/src/loader/script.rs (L34-51)
```rust
#[derive(Clone, Debug)]
pub struct Script {
    pub(crate) interned_id: InternedModuleId,

    // primitive pools
    pub(crate) script: Arc<CompiledScript>,

    // functions as indexes into the Loader function list
    pub(crate) function_refs: Vec<FunctionHandle>,
    // materialized instantiations, whether partial or not
    pub(crate) function_instantiations: Vec<FunctionInstantiation>,

    // entry point
    pub(crate) main: Arc<Function>,

    // a map of single-token signature indices to type
    pub(crate) single_signature_token_map: BTreeMap<SignatureIndex, Type>,
}
```

**File:** third_party/move/move-vm/types/src/code/cache/script_cache.rs (L11-41)
```rust
/// Interface used by any script cache implementation.
#[delegatable_trait]
pub trait ScriptCache {
    type Key: Eq + Hash + Clone;
    type Deserialized;
    type Verified;

    /// If the entry associated with the key is vacant, inserts the script and returns its copy.
    /// Otherwise, there is no insertion and the copy of existing entry is returned.
    fn insert_deserialized_script(
        &self,
        key: Self::Key,
        deserialized_script: Self::Deserialized,
    ) -> Arc<Self::Deserialized>;

    /// If the entry associated with the key is vacant, inserts the script and returns its copy.
    /// If the entry associated with the key is occupied, but the entry is not verified, inserts
    /// the script returning the copy. Otherwise, there is no insertion and the copy of existing
    /// (verified) entry is returned.
    fn insert_verified_script(
        &self,
        key: Self::Key,
        verified_script: Self::Verified,
    ) -> Arc<Self::Verified>;

    /// Returns the script if it has been cached before, or [None] otherwise.
    fn get_script(&self, key: &Self::Key) -> Option<Code<Self::Deserialized, Self::Verified>>;

    /// Returns the number of scripts stored in cache.
    fn num_scripts(&self) -> usize;
}
```

**File:** aptos-move/e2e-move-tests/src/tests/code_publishing.rs (L215-219)
```rust
/// This test verifies that the cache incoherence bug on module upgrade is fixed. This bug
/// exposes itself by that after module upgrade the old version of the module stays
/// active until the MoveVM terminates. In order to workaround this until there is a better
/// fix, we flush the cache in `MoveVmExt::new_session`. One can verify the fix by commenting
/// the flush operation out, then this test fails.
```
