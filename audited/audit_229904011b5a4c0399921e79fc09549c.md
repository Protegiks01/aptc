# Audit Report

## Title
Dangling Event Indices After Ledger Truncation Cause Node Startup Failure

## Summary
The ledger truncation process (`truncate_ledger_db`) deletes events from `EventSchema` but intentionally skips deletion of corresponding `EventByVersionSchema` and `EventByKeySchema` indices when the internal indexer is enabled. This creates dangling indices that reference non-existent events. On node restart, the version mismatch between the main ledger and internal indexer databases causes a panic, preventing node startup and requiring manual intervention.

## Finding Description

The vulnerability exists in the event truncation logic where events are deleted without cleaning up their corresponding indices in the internal indexer database. [1](#0-0) 

The `delete_event_data` function calls `prune_event_indices` with `None` for the `indices_batch` parameter, explicitly avoiding index deletion. The comment acknowledges this gap: "TODO: prune data from internal indices". [2](#0-1) 

When `indices_batch` is `None`, the conditional block that deletes `EventByKeySchema` and `EventByVersionSchema` entries is skipped entirely, leaving the indices intact. [3](#0-2) 

However, `prune_events` proceeds to delete all `EventSchema` entries for the truncated version range, creating the inconsistency.

The critical failure occurs on restart when the internal indexer service validates version consistency: [4](#0-3) 

The startup check panics if the event indexer version doesn't match the main ledger version, preventing the node from starting.

**Attack Path:**
1. Node runs with internal indexer enabled (`enable_event = true`)
2. Events are committed to version N (e.g., 1000)
3. A crash occurs causing `ledger_commit_progress > overall_commit_progress`
4. Recovery triggers `truncate_ledger_db` to roll back to `overall_commit_progress` (e.g., 900)
5. Events 901-1000 are deleted from `EventSchema` in main DB
6. `EventByVersionSchema` entries 901-1000 remain in internal indexer DB (dangling indices)
7. Main DB version progress is updated to 900
8. Internal indexer DB version remains at 1000
9. Node restart attempts to initialize internal indexer service
10. Version mismatch check (`start_version != event_start_version`) fails
11. **Node panics and cannot start**

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria:

1. **Node Liveness Failure**: The panic prevents affected nodes from restarting, requiring manual database intervention to recover. This meets the "Validator node slowdowns" and "API crashes" criteria, though in this case it's complete node unavailability rather than just slowdown.

2. **Data Integrity Violation**: The dangling indices violate the **State Consistency** invariant (#4) that state transitions must be atomic and verifiable. The event indices and actual events are in an inconsistent state.

3. **Operational Impact**: Nodes with internal indexer enabled cannot recover automatically from ledger truncation scenarios. Operators must either:
   - Manually delete the internal indexer database and rebuild from scratch
   - Perform complex manual surgery to align version markers
   - Restore from backup

4. **Affects Production Configurations**: The internal indexer is commonly enabled on full nodes serving API queries, making this a realistic production scenario.

While this doesn't reach Critical severity (no fund loss or consensus break), it's clearly High severity due to the complete loss of node availability requiring manual intervention.

## Likelihood Explanation

**Moderate to High Likelihood:**

1. **Triggering Condition**: Truncation occurs during crash recovery when ledger commit progress exceeds overall commit progress by more than the allowed threshold. This can happen due to:
   - Process crashes during commit operations
   - Power failures
   - Disk I/O errors
   - OOM kills during transaction processing [5](#0-4) 

2. **Common Configuration**: Internal indexer is widely deployed on full nodes that serve API requests, as it provides the indices needed for efficient event queries.

3. **No Attacker Control Required**: This is a reliability bug that occurs naturally during system failures, not requiring any malicious action to trigger.

4. **Acknowledged Technical Debt**: The TODO comment indicates the development team is aware this cleanup is missing but hasn't implemented it, suggesting it's a known gap.

## Recommendation

**Immediate Fix**: Extend truncation to clean up internal indexer indices when the internal indexer is enabled.

**Implementation approach:**

1. Modify `delete_event_data` to accept an optional `InternalIndexerDB` parameter
2. When internal indexer is present and event indexing is enabled, create a batch for index deletions
3. Pass this batch to `prune_event_indices` instead of `None`
4. Write the indexer batch to the internal indexer DB
5. Update internal indexer progress markers to match the truncated version

**Alternative approach** (more robust):

1. On startup, before the version mismatch check, detect truncation scenarios
2. If main ledger version < internal indexer version, trigger automatic index cleanup
3. Delete all `EventByVersionSchema` and `EventByKeySchema` entries for versions > main ledger version
4. Reset internal indexer version markers to match main ledger version
5. Then proceed with normal indexer catch-up

This would make recovery fully automatic without operator intervention.

**Code location to fix:** [6](#0-5) 

## Proof of Concept

```rust
// Reproduction Steps (Rust integration test):
//
// 1. Setup: Start a node with internal indexer enabled
//    - Set enable_event = true in IndexerDBConfig
//    - Commit transactions generating events to version 1000
//
// 2. Simulate incomplete commit:
//    - Write events to EventSchema for versions 901-1000
//    - Write EventByVersionSchema indices for versions 901-1000
//    - Update ledger_commit_progress to 1000
//    - Update internal indexer event progress to 1000
//    - Simulate crash: only update overall_commit_progress to 900
//
// 3. Trigger recovery:
//    - Call truncate_ledger_db(ledger_db, 900)
//    - Verify EventSchema entries for 901-1000 are deleted
//    - Verify EventByVersionSchema entries for 901-1000 still exist
//    - Verify main DB progress is 900
//    - Verify indexer DB progress is still 1000
//
// 4. Attempt restart:
//    - Call InternalIndexerDBService::get_start_version()
//    - Expected: Panic with message "Cannot start event indexer because 
//      the progress doesn't match"
//
// 5. Verify dangling indices:
//    - Query internal indexer for events 901-1000 using EventByVersionSchema
//    - Indices return results
//    - Query main DB for same events using EventSchema
//    - Events are missing (NotFound errors)
//
// This demonstrates the inconsistency and the resulting node startup failure.
```

**Manual verification on test cluster:**

```bash
# 1. Enable internal indexer on a test node
# Edit node config to set:
#   indexer_db_config.enable_event = true

# 2. Let the node sync and commit events

# 3. Simulate crash by killing process mid-commit
kill -9 <node_pid>

# 4. Manually edit progress markers to create mismatch
# (In production this happens naturally during certain crash scenarios)

# 5. Restart node - observe panic:
# "Cannot start event indexer because the progress doesn't match."

# 6. Verify dangling indices remain in indexer DB using db-debugger:
aptos-db-debugger validate-internal-indexer --db-path <path>
```

## Notes

- The vulnerability affects nodes with `enable_event = true` in internal indexer configuration
- The TODO comment at line 537 explicitly acknowledges this missing cleanup
- The panic-on-mismatch design choice prioritizes data integrity over availability, but provides no recovery mechanism
- Production deployments using internal indexer for API serving are at risk of extended downtime during crash recovery scenarios
- The issue doesn't affect consensus or validator operations directly, but impacts full node availability for API users

### Citations

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L520-548)
```rust
fn delete_event_data(
    ledger_db: &LedgerDb,
    start_version: Version,
    batch: &mut SchemaBatch,
) -> Result<()> {
    if let Some(latest_version) = ledger_db.event_db().latest_version()? {
        if latest_version >= start_version {
            info!(
                start_version = start_version,
                latest_version = latest_version,
                "Truncate event data."
            );
            let num_events_per_version = ledger_db.event_db().prune_event_indices(
                start_version,
                latest_version + 1,
                // Assuming same data will be overwritten into indices, we don't bother to deal
                // with the existence or placement of indices
                // TODO: prune data from internal indices
                None,
            )?;
            ledger_db.event_db().prune_events(
                num_events_per_version,
                start_version,
                latest_version + 1,
                batch,
            )?;
        }
    }
    Ok(())
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L206-217)
```rust
            if let Some(ref mut batch) = indices_batch {
                for event in events {
                    if let ContractEvent::V1(v1) = event {
                        batch.delete::<EventByKeySchema>(&(*v1.key(), v1.sequence_number()))?;
                        batch.delete::<EventByVersionSchema>(&(
                            *v1.key(),
                            current_version,
                            v1.sequence_number(),
                        ))?;
                    }
                }
            }
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L234-237)
```rust
        for num_events in num_events_per_version {
            for idx in 0..num_events {
                db_batch.delete::<EventSchema>(&(current_version, idx as u64))?;
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L130-138)
```rust
        if node_config.indexer_db_config.enable_event() {
            let event_start_version = self
                .db_indexer
                .indexer_db
                .get_event_version()?
                .map_or(0, |v| v + 1);
            if start_version != event_start_version {
                panic!("Cannot start event indexer because the progress doesn't match.");
            }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L440-449)
```rust
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");
```
