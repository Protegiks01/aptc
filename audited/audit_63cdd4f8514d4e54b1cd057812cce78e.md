# Audit Report

## Title
Resource Group Member Attribute Removal Bypass via Version 5 Bytecode Metadata Inconsistency

## Summary
An attacker can publish bytecode version 5 modules with V1 metadata containing `resource_group_member` attributes, then later remove these attributes during module upgrades without triggering validation errors. This bypasses critical resource group upgrade safety checks and violates state consistency invariants.

## Finding Description

The vulnerability exists in the interaction between metadata validation during module publishing and upgrade validation for resource groups.

**Root Cause**: The `check_metadata_format()` function validates that metadata can be deserialized but does not enforce that V1 metadata (which includes `struct_attributes` containing resource group information) requires bytecode version â‰¥ 6 as specified by `METADATA_V1_MIN_FILE_FORMAT_VERSION`. [1](#0-0) 

Meanwhile, `get_metadata_from_compiled_code()` silently clears `struct_attributes` and `fun_attributes` for version 5 modules as a defensive measure. [2](#0-1) 

**Attack Flow**:

1. **Initial Publishing**: Attacker manually crafts a bytecode version 5 module with `APTOS_METADATA_KEY_V1` metadata containing `resource_group_member` attributes in `struct_attributes`

2. **Validation Bypass**: During `verify_module_metadata_for_module_publishing()`, the metadata is extracted via `get_metadata_from_compiled_code()` which clears `struct_attributes` for version 5, causing validation to see empty attributes and accept the module [3](#0-2) 

3. **Storage**: The **original bytecode** with intact metadata is serialized and stored on-chain (the clearing only affected the in-memory validation object)

4. **Upgrade Attack**: When upgrading the module, `validate_module_and_extract_new_entries()` loads the old module from storage and calls `extract_resource_group_metadata_from_module()` [4](#0-3) 

5. **Validation Failure**: This function calls `get_metadata_from_compiled_code(old_module)` which again clears `struct_attributes` for the version 5 module, resulting in `original_members` being empty [5](#0-4) 

6. **Bypass Complete**: The validation loop that checks for attribute removal never executes because `original_members` is empty, allowing the attacker to publish an upgraded module without the `resource_group_member` attributes [6](#0-5) 

**Invariant Violation**: This breaks the documented invariant that "each member has a membership and it does not change" during module upgrades. [7](#0-6) 

## Impact Explanation

**Severity: Medium to High**

This vulnerability enables attackers to violate critical resource group invariants, leading to:

1. **State Inconsistency**: Resources that were part of resource groups can be orphaned, breaking the resource group storage model and potentially causing data corruption

2. **Consensus Impact**: Different validators may handle resource group operations differently if attributes are inconsistently applied, potentially leading to divergent state transitions

3. **Protocol Violation**: Bypassing upgrade validation checks undermines the security guarantees of the Move module system

Per the Aptos bug bounty criteria, this qualifies as at least **Medium Severity** (state inconsistencies requiring intervention) and potentially **High Severity** (significant protocol violations).

## Likelihood Explanation

**Likelihood: Medium**

While the attack requires technical sophistication to manually craft bytecode version 5 modules with V1 metadata, it is feasible:

- The attacker needs knowledge of Move binary format and BCS serialization
- Tools exist to construct and serialize `CompiledModule` structures
- No privileged access is required - any account can call `code::publish_package_txn`
- The vulnerability has existed since metadata was introduced but may not be widely known

The comment in the code ("this should have been gated in the verify module metadata") suggests developers were aware of the issue but the proper validation gate was never implemented.

## Recommendation

Add explicit validation in `check_metadata_format()` to reject V1 metadata for modules with bytecode version < 6:

```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                // NEW VALIDATION: Reject V1 metadata for version < 6
                if module.version < METADATA_V1_MIN_FILE_FORMAT_VERSION {
                    return Err(MalformedError::Malformed(format!(
                        "V1 metadata requires bytecode version >= {}, found version {}",
                        METADATA_V1_MIN_FILE_FORMAT_VERSION,
                        module.version
                    )));
                }
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        }
        // ... rest of function
    }
    Ok(())
}
```

Alternatively, remove the silent clearing in `get_metadata_from_compiled_code()` and make it return an error for version 5 with V1 metadata.

## Proof of Concept

```rust
use move_binary_format::{CompiledModule, file_format::*};
use move_core_types::{identifier::Identifier, metadata::Metadata, language_storage::ModuleId};
use aptos_types::vm::module_metadata::{RuntimeModuleMetadataV1, KnownAttribute, APTOS_METADATA_KEY_V1};

// Craft a malicious version 5 module with V1 metadata
fn create_malicious_module() -> CompiledModule {
    let mut module = CompiledModule {
        version: 5, // Version 5 should not have V1 metadata
        module_handles: vec![],
        struct_handles: vec![],
        function_handles: vec![],
        field_handles: vec![],
        friend_decls: vec![],
        struct_defs: vec![/* define a struct */],
        function_defs: vec![],
        function_instantiations: vec![],
        signatures: vec![],
        identifiers: vec![Identifier::new("TestStruct").unwrap()],
        address_identifiers: vec![],
        constant_pool: vec![],
        metadata: vec![],
        struct_def_instantiations: vec![],
        field_instantiations: vec![],
    };

    // Create V1 metadata with resource_group_member attribute
    let mut metadata_v1 = RuntimeModuleMetadataV1::default();
    metadata_v1.struct_attributes.insert(
        "TestStruct".to_string(),
        vec![KnownAttribute::resource_group_member(/* group tag */)]
    );

    // Serialize and add to module
    let serialized = bcs::to_bytes(&metadata_v1).unwrap();
    module.metadata.push(Metadata {
        key: APTOS_METADATA_KEY_V1.to_vec(),
        value: serialized,
    });

    module
}

// Publish the malicious module via transaction
// Then upgrade it to remove the resource_group_member attribute
// Validation will not detect the removal due to the clearing logic
```

## Notes

The vulnerability stems from an architectural inconsistency where validation logic and defensive clearing logic interact in unexpected ways. The comment "this should have been gated in the verify module metadata" confirms that proper validation was intended but not implemented. This creates a window for attackers to bypass critical upgrade safety checks that are fundamental to resource group integrity.

### Citations

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** types/src/vm/module_metadata.rs (L287-308)
```rust
pub fn get_metadata_from_compiled_code(
    code: &impl CompiledCodeMetadata,
) -> Option<RuntimeModuleMetadataV1> {
    if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY_V1) {
        let mut metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value).ok();
        // Clear out metadata for v5, since it shouldn't have existed in the first place and isn't
        // being used. Note, this should have been gated in the verify module metadata.
        if code.version() == 5 {
            if let Some(metadata) = metadata.as_mut() {
                metadata.struct_attributes.clear();
                metadata.fun_attributes.clear();
            }
        }
        metadata
    } else if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY) {
        // Old format available, upgrade to new one on the fly
        let data_v0 = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value).ok()?;
        Some(data_v0.upgrade())
    } else {
        None
    }
}
```

**File:** types/src/vm/module_metadata.rs (L441-456)
```rust
pub fn verify_module_metadata_for_module_publishing(
    module: &CompiledModule,
    features: &Features,
) -> Result<(), MetaDataValidationError> {
    if features.is_enabled(FeatureFlag::SAFER_METADATA) {
        check_module_complexity(module)?;
    }

    if features.are_resource_groups_enabled() {
        check_metadata_format(module)?;
    }
    let metadata = if let Some(metadata) = get_metadata_from_compiled_code(module) {
        metadata
    } else {
        return Ok(());
    };
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L30-35)
```rust
/// Perform validation and upgrade checks on resource groups
/// * Acquire all relevant pieces of metadata
/// * Verify that there are no duplicate attributes.
/// * Ensure that each member has a membership and it does not change
/// * Ensure that each group has a scope and that it does not become more restrictive
/// * For any new members, verify that they are in a valid resource group
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L136-141)
```rust
    let (original_groups, original_members, mut structs) = module_storage
        .unmetered_get_deserialized_module(new_module.address(), new_module.name())?
        .map_or_else(
            || Ok((BTreeMap::new(), BTreeMap::new(), BTreeSet::new())),
            |old_module| extract_resource_group_metadata_from_module(&old_module),
        )?;
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L143-151)
```rust
    for (member, group) in original_members {
        // We don't need to re-validate new_members above.
        if Some(group) != new_members.remove(&member) {
            metadata_validation_err("Invalid removal of resource_group_member attribute")?;
        }

        // For this to fail is an invariant violation, it means we allow for arbitrary upgrades.
        structs.remove(&member);
    }
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L192-213)
```rust
pub(crate) fn extract_resource_group_metadata_from_module(
    old_module: &CompiledModule,
) -> VMResult<(
    BTreeMap<String, ResourceGroupScope>,
    BTreeMap<String, StructTag>,
    BTreeSet<String>,
)> {
    if let Some(metadata) = get_metadata_from_compiled_code(old_module) {
        let (groups, members) = extract_resource_group_metadata(&metadata)?;
        let structs = old_module
            .struct_defs()
            .iter()
            .map(|struct_def| {
                let struct_handle = old_module.struct_handle_at(struct_def.struct_handle);
                old_module.identifier_at(struct_handle.name).to_string()
            })
            .collect::<BTreeSet<_>>();
        Ok((groups, members, structs))
    } else {
        Ok((BTreeMap::new(), BTreeMap::new(), BTreeSet::new()))
    }
}
```
