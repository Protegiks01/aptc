# Audit Report

## Title
Zombie Connection Attack via Unverified ValidatorFullNode Role Assignment on VFN Networks

## Summary
Attackers can establish and maintain persistent zombie connections to validator nodes by exploiting the automatic assignment of `PeerRole::ValidatorFullNode` to inbound connections on VFN networks, combined with a stale connection detection exemption that prevents these connections from ever being closed, even when the peer is not in the trusted peers set.

## Finding Description

The vulnerability exists through the interaction of three components:

**1. Automatic Role Assignment Without Verification**

When a validator node receives an inbound connection on its VFN network, the handshake code automatically assigns `PeerRole::ValidatorFullNode` to any peer that provides a valid peer ID derived from their public key, without verifying that the peer is actually an authorized ValidatorFullNode. [1](#0-0) 

The code assumes "Inbound connections to validators on the VFN network must be VFNs" (comment at line 409), but this assumption is not enforced through authentication.

**2. VFN Networks Lack Mutual Authentication**

VFN networks are configured with `mutual_authentication = false` because the configuration only sets it to `true` for the validator network specifically: [2](#0-1) 

The `is_validator_network()` check only returns true for `NetworkId::Validator`, not for `NetworkId::Vfn`: [3](#0-2) 

**3. Stale Connection Detection Exemption**

The `close_stale_connections()` method contains an exemption that prevents disconnecting inbound connections from ValidatorFullNode or Unknown peers on networks without mutual authentication: [4](#0-3) 

This exemption is applied even when the peer is NOT in the trusted peers set (identified as stale at line 490).

**Attack Flow:**

1. Attacker connects inbound to a validator's VFN port (publicly accessible)
2. During handshake, attacker provides valid peer ID derived from their public key
3. Handshake assigns `PeerRole::ValidatorFullNode` (line 410 of handshake.rs)
4. Connection bypasses `max_inbound_connections` limit because the limit only applies to `PeerRole::Unknown`: [5](#0-4) 

5. Connection is established and tracked in ConnectivityManager
6. On periodic connectivity checks, the peer is identified as not in `trusted_peers` (stale)
7. However, the exemption at lines 493-502 prevents disconnection because all three conditions are met:
   - `!mutual_authentication` (VFN network)
   - `origin == ConnectionOrigin::Inbound`
   - `role == PeerRole::ValidatorFullNode`
8. **Zombie connection persists indefinitely** - never cleaned up by stale connection detection or health checks

The stale connection detection runs periodically based on the connectivity check interval: [6](#0-5) 

## Impact Explanation

**High Severity** - This meets the criteria for High severity under the Aptos bug bounty program:

1. **Resource Exhaustion / DoS**: Multiple attackers can establish unlimited zombie connections, bypassing the `max_inbound_connections` limit (which only applies to Unknown roles). This exhausts connection slots and prevents legitimate ValidatorFullNodes from connecting to the validator.

2. **Validator Service Disruption**: When connection limits are exhausted, the validator cannot serve its downstream VFN nodes, impacting the validator's ability to participate in consensus and serve clients.

3. **Information Leakage**: Zombie connections continue receiving network gossip, state sync data, and other protocol messages intended only for trusted peers, allowing attackers to monitor validator operations.

4. **Persistence**: Unlike temporary connection issues, these zombie connections never timeout or get cleaned up, providing attackers with permanent access until the validator is restarted.

This vulnerability affects validator nodes' ability to maintain proper network connectivity, which can impact liveness and network health.

## Likelihood Explanation

**High Likelihood** - This attack is highly likely to be exploited:

1. **No Authentication Required**: VFN networks use `mutual_authentication = false`, so attackers need no special credentials or insider access
2. **Simple Execution**: Attack only requires establishing a TCP connection and completing a basic handshake with a valid peer ID
3. **Publicly Accessible**: VFN ports are intended to be publicly reachable to serve downstream nodes
4. **No Special Resources**: No computational power, stake, or validator access required
5. **Hard to Detect**: Zombie connections appear as legitimate ValidatorFullNode connections in logs and metrics
6. **Scalable**: Multiple attackers (or one attacker with multiple identities) can exploit this simultaneously

The only requirement is generating a valid x25519 keypair and deriving a peer ID, which is trivial.

## Recommendation

**Primary Fix**: Remove the automatic ValidatorFullNode role assignment for unauthenticated peers. On VFN networks, inbound connections that are not in the trusted peers set should be assigned `PeerRole::Unknown`:

```rust
// In network/framework/src/noise/handshake.rs around line 410
if self.network_context.role().is_validator() {
    if network_id.is_vfn_network() {
        // Don't automatically trust inbound VFN connections
        // They must be explicitly in trusted_peers to get VFN role
        Ok(PeerRole::Unknown)
    } else {
        Ok(PeerRole::Unknown)
    }
} else {
    Ok(PeerRole::Unknown)
}
```

**Alternative Fix**: Apply `max_inbound_connections` limit to all non-trusted inbound connections regardless of role:

```rust
// In network/framework/src/peer_manager/mod.rs around line 355
if conn.metadata.origin == ConnectionOrigin::Inbound {
    let is_trusted = trusted_peers.contains_key(&conn.metadata.remote_peer_id);
    if !is_trusted {
        // Count ALL non-trusted inbound connections
        let unknown_inbound_conns = self
            .active_peers
            .iter()
            .filter(|(peer_id, (metadata, _))| {
                metadata.origin == ConnectionOrigin::Inbound
                    && !trusted_peers.contains_key(peer_id)
            })
            .count();
        
        if !self.active_peers.contains_key(&conn.metadata.remote_peer_id)
            && unknown_inbound_conns + 1 > self.inbound_connection_limit
        {
            // Reject connection
        }
    }
}
```

**Defense in Depth**: Remove or narrow the stale connection exemption to only apply to truly necessary cases, not all ValidatorFullNode connections.

## Proof of Concept

```rust
// Proof of Concept - Zombie Connection Attack on VFN Network
// This demonstrates establishing a zombie connection that bypasses limits

use aptos_crypto::x25519;
use aptos_types::PeerId;

#[tokio::test]
async fn test_zombie_vfn_connection() {
    // 1. Setup: Create validator with VFN network
    let validator = create_test_validator_with_vfn_network();
    let vfn_address = validator.get_vfn_listen_address();
    
    // 2. Attacker generates multiple keypairs (no auth required)
    let mut attacker_connections = vec![];
    
    for i in 0..150 {  // Exceed typical max_inbound_connections (100)
        let attacker_keypair = x25519::PrivateKey::generate_for_testing();
        let attacker_peer_id = PeerId::from_identity_public_key(
            attacker_keypair.public_key()
        );
        
        // 3. Connect to VFN port
        let connection = establish_connection_to_vfn(
            vfn_address.clone(),
            attacker_keypair,
            attacker_peer_id,
        ).await;
        
        // 4. Verify connection assigned ValidatorFullNode role
        assert_eq!(connection.peer_role, PeerRole::ValidatorFullNode);
        
        attacker_connections.push(connection);
    }
    
    // 5. Wait for multiple connectivity check intervals
    tokio::time::sleep(Duration::from_secs(300)).await;
    
    // 6. Verify all zombie connections still active
    for conn in &attacker_connections {
        assert!(conn.is_connected(), "Zombie connection should persist");
    }
    
    // 7. Verify legitimate VFN cannot connect (slots exhausted)
    let legitimate_vfn = create_trusted_vfn();
    let result = legitimate_vfn.connect_to_validator(vfn_address).await;
    assert!(result.is_err(), "Legitimate VFN blocked by zombie connections");
    
    // 8. Verify attacker receiving network messages
    for conn in &attacker_connections {
        let messages = conn.received_messages();
        assert!(!messages.is_empty(), "Zombie connection receiving gossip");
    }
}
```

## Notes

- The TODO comment at line 493 acknowledges this is problematic: "We should prevent `Unknown` from discovery sources", indicating developers were aware of related issues
- The exemption was likely intended to allow VFNs to maintain connections during validator set transitions, but it's overly permissive
- Health checks (`NetworkHealthCheckFailure`) are separate and won't close these connections either, as they only trigger on ping timeouts, not stale peer detection
- The discovery mechanism updates trusted peers based on on-chain validator set changes, but the exemption prevents acting on this information for VFN connections

### Citations

**File:** network/framework/src/noise/handshake.rs (L406-422)
```rust
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
```

**File:** config/src/config/network_config.rs (L135-142)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
```

**File:** config/src/network_id.rs (L168-170)
```rust
    pub fn is_validator_network(&self) -> bool {
        self == &NetworkId::Validator
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L484-531)
```rust
    async fn close_stale_connections(&mut self) {
        if let Some(trusted_peers) = self.get_trusted_peers() {
            // Identify stale peer connections
            let stale_peers = self
                .connected
                .iter()
                .filter(|(peer_id, _)| !trusted_peers.contains_key(peer_id))
                .filter_map(|(peer_id, metadata)| {
                    // If we're using server only auth, we need to not evict unknown peers
                    // TODO: We should prevent `Unknown` from discovery sources
                    if !self.mutual_authentication
                        && metadata.origin == ConnectionOrigin::Inbound
                        && (metadata.role == PeerRole::ValidatorFullNode
                            || metadata.role == PeerRole::Unknown)
                    {
                        None
                    } else {
                        Some(*peer_id) // The peer is stale
                    }
                });

            // Close existing connections to stale peers
            for stale_peer in stale_peers {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&stale_peer),
                    "{} Closing stale connection to peer {}",
                    self.network_context,
                    stale_peer.short_str()
                );

                if let Err(disconnect_error) = self
                    .connection_reqs_tx
                    .disconnect_peer(stale_peer, DisconnectReason::StaleConnection)
                    .await
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .remote_peer(&stale_peer),
                        error = %disconnect_error,
                        "{} Failed to close stale connection to peer {}, error: {}",
                        self.network_context,
                        stale_peer.short_str(),
                        disconnect_error
                    );
                }
            }
        }
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L807-836)
```rust
    async fn check_connectivity<'a>(
        &'a mut self,
        pending_dials: &'a mut FuturesUnordered<BoxFuture<'static, PeerId>>,
    ) {
        trace!(
            NetworkSchema::new(&self.network_context),
            "{} Checking connectivity",
            self.network_context
        );

        // Log the eligible peers with addresses from discovery
        sample!(SampleRate::Duration(Duration::from_secs(60)), {
            info!(
                NetworkSchema::new(&self.network_context),
                discovered_peers = ?self.discovered_peers,
                "Active discovered peers"
            )
        });

        // Cancel dials to peers that are no longer eligible.
        self.cancel_stale_dials().await;
        // Disconnect from connected peers that are no longer eligible.
        self.close_stale_connections().await;
        // Dial peers which are eligible but are neither connected nor queued for dialing in the
        // future.
        self.dial_eligible_peers(pending_dials).await;

        // Update the metrics for any peer ping latencies
        self.update_ping_latency_metrics();
    }
```

**File:** network/framework/src/peer_manager/mod.rs (L352-390)
```rust
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
        }
```
