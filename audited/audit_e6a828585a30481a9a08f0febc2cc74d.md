# Audit Report

## Title
Mutual Authentication Bypass in Outbound Noise Handshake Allows Unauthorized Peer Connections

## Summary
In Mutual authentication mode, validators can establish outbound connections to peers not in their `trusted_peers` set. The `extract_peer_role_from_trusted_peers()` function returns `PeerRole::Unknown` instead of rejecting such connections, violating the documented mutual authentication guarantee and creating a window for network-layer attacks.

## Finding Description

The Aptos network layer implements two authentication modes for the Noise handshake protocol: `Mutual` and `MaybeMutual`. According to the documentation, Mutual mode requires "both sides will authenticate each other with their `trusted_peers` set." [1](#0-0) 

However, there is an asymmetry in how authentication is enforced:

**INBOUND connections (server side):** In Mutual mode, when a peer is not found in `trusted_peers`, the handshake fails with `UnauthenticatedClient` error, correctly rejecting the connection. [2](#0-1) 

**OUTBOUND connections (client side):** When a validator in Mutual mode connects to a peer not in its `trusted_peers` set, the `extract_peer_role_from_trusted_peers()` function merely logs an error and returns `PeerRole::Unknown`, allowing the connection to succeed. [3](#0-2) 

The outbound handshake completes successfully and returns the connection with the untrusted peer role. [4](#0-3) 

This unauthorized connection is eventually closed by the connectivity manager's periodic stale connection cleanup (default: every 5 seconds), but only if `mutual_authentication` is enabled. [5](#0-4) 

**Attack Scenario:**
1. Validator A operates in Mutual mode with a specific `trusted_peers` set
2. Malicious Node M (not in A's trusted peers) operates a listener node
3. Through misconfiguration, discovery bug, or targeted social engineering, A attempts to dial M
4. A's `upgrade_outbound()` completes successfully with `peer_role = PeerRole::Unknown`
5. If M is in MaybeMutual mode, it accepts A's connection
6. The connection remains active for up to 5 seconds before cleanup
7. During this window, M can launch targeted network-layer attacks

## Impact Explanation

**Severity: High** (Significant Protocol Violation)

This vulnerability breaks the documented security invariant of Mutual authentication. While consensus messages are separately validated via `ValidatorVerifier`, the unauthorized connection window enables:

1. **Man-in-the-Middle Positioning:** If the validator intended to connect to a legitimate peer but reached a malicious node (e.g., via DNS poisoning, BGP hijacking), the attacker gains network access
2. **Resource Exhaustion:** Malicious peers can send expensive network requests during the connection window
3. **State Sync Poisoning:** Untrusted peers may send malicious state sync data before validation
4. **Information Leakage:** The validator may send requests revealing internal state or configuration
5. **Protocol-Level Attacks:** Various network protocols (mempool, state sync) may have vulnerabilities exploitable through this unauthorized channel

The 5-second connection window, combined with the violation of a fundamental security guarantee, qualifies this as a High severity issue under the "Significant protocol violations" category.

## Likelihood Explanation

**Likelihood: Medium-High**

While validators should normally only connect to peers in their `trusted_peers` set via the connectivity manager, this vulnerability can be triggered by:

- Configuration errors in discovery or seed peer settings
- Bugs in connectivity management logic  
- Manual operator intervention or debugging tools
- Targeted attacks exploiting other discovery/routing vulnerabilities
- Edge cases during epoch transitions or validator set updates

The vulnerability is deterministic once triggeredâ€”any outbound connection attempt to an untrusted peer in Mutual mode will succeed when it should fail.

## Recommendation

The `extract_peer_role_from_trusted_peers()` function should enforce mutual authentication by returning an error when operating in Mutual mode and the peer is not found in `trusted_peers`.

**Recommended Fix:**

```rust
fn extract_peer_role_from_trusted_peers(&self, remote_peer_id: PeerId) -> Result<PeerRole, NoiseHandshakeError> {
    // Get the peers and metadata struct
    let peers_and_metadata = match &self.auth_mode {
        HandshakeAuthMode::Mutual { peers_and_metadata, .. } => peers_and_metadata.clone(),
        HandshakeAuthMode::MaybeMutual(peers_and_metadata) => peers_and_metadata.clone(),
    };

    // Determine the peer role
    match peers_and_metadata.get_trusted_peers(&self.network_context.network_id()) {
        Ok(trusted_peers) => {
            match trusted_peers.get(&remote_peer_id) {
                Some(trusted_peer) => Ok(trusted_peer.role),
                None => {
                    // In Mutual mode, reject connections to untrusted peers
                    if matches!(self.auth_mode, HandshakeAuthMode::Mutual { .. }) {
                        Err(NoiseHandshakeError::UntrustedOutboundPeer(
                            remote_peer_id.short_str(),
                            remote_peer_id,
                        ))
                    } else {
                        // In MaybeMutual mode, allow unknown peers
                        error!(NetworkSchema::new(&self.network_context).message(format!(
                            "{} Outbound connection made with unknown peer (not in the trusted peers set)! Missing peer: {:?}",
                            self.network_context, remote_peer_id
                        )));
                        Ok(PeerRole::Unknown)
                    }
                }
            }
        },
        Err(error) => {
            error!(NetworkSchema::new(&self.network_context).message(format!(
                "Failed to get trusted peers for network context: {:?}, error: {:?}",
                self.network_context, error
            )));
            Err(NoiseHandshakeError::TrustedPeersUnavailable)
        },
    }
}
```

Then update the call site to handle the Result: [4](#0-3) 

Additionally, add a new error variant to `NoiseHandshakeError` for untrusted outbound peers.

## Proof of Concept

```rust
#[test]
fn test_mutual_auth_rejects_untrusted_outbound_peer() {
    ::aptos_logger::Logger::init_for_testing();

    // Create client and server with mutual auth enabled
    let network_ids = vec![NetworkId::Validator];
    let peers_and_metadata = PeersAndMetadata::new(&network_ids);

    // Create client in Mutual mode
    let mut rng = ::rand::rngs::StdRng::from_seed(TEST_SEED);
    let (client_private_key, client_public_key) = create_key_pair(&mut rng);
    let client_peer_id = PeerId::random();
    let client = NoiseUpgrader::new(
        NetworkContext::mock_with_peer_id(client_peer_id),
        client_private_key,
        HandshakeAuthMode::mutual(peers_and_metadata.clone()),
    );

    // Create server that is NOT in client's trusted_peers
    let (server_private_key, server_public_key) = create_key_pair(&mut rng);
    let server_peer_id = PeerId::random();
    let server = NoiseUpgrader::new(
        NetworkContext::mock_with_peer_id(server_peer_id),
        server_private_key,
        HandshakeAuthMode::mutual(peers_and_metadata.clone()),
    );

    // Note: Server is NOT added to trusted_peers for client

    // Attempt handshake
    let (dialer_socket, listener_socket) = MemorySocket::new_pair();
    let (client_res, server_res) = block_on(join(
        client.upgrade_outbound(
            dialer_socket,
            server_peer_id,
            server_public_key,
            AntiReplayTimestamps::now,
        ),
        server.upgrade_inbound(listener_socket),
    ));

    // EXPECTED: Both should fail because server not in client's trusted_peers
    // ACTUAL: Only server fails, client succeeds with PeerRole::Unknown
    assert!(client_res.is_err(), "Client should reject untrusted outbound peer in Mutual mode");
    assert!(server_res.is_err(), "Server should reject untrusted inbound peer in Mutual mode");
}
```

This test demonstrates that when a client in Mutual mode connects to a server not in its `trusted_peers`, the connection currently succeeds (returning `PeerRole::Unknown`) when it should fail, violating the mutual authentication guarantee.

## Notes

The vulnerability exists specifically in the asymmetric handling between inbound and outbound authentication in Mutual mode. While the connectivity manager eventually cleans up these unauthorized connections, the security invariant is violated during the connection establishment phase, creating an exploitable window. The fix ensures immediate rejection at the handshake layer, consistent with the documented Mutual authentication behavior.

### Citations

**File:** network/framework/src/noise/handshake.rs (L78-84)
```rust
    /// In `Mutual` mode, both sides will authenticate each other with their
    /// `trusted_peers` set. We also include replay attack mitigation in this mode.
    ///
    /// For example, in the Aptos validator network, validator peers will only
    /// allow connections from other validator peers. They will use this mode to
    /// check that inbound connections authenticate to a network public key
    /// actually contained in the current validator set.
```

**File:** network/framework/src/noise/handshake.rs (L259-262)
```rust
        let noise_stream = NoiseStream::new(socket, session);
        let peer_role = self.extract_peer_role_from_trusted_peers(remote_peer_id);

        Ok((noise_stream, peer_role))
```

**File:** network/framework/src/noise/handshake.rs (L268-303)
```rust
    fn extract_peer_role_from_trusted_peers(&self, remote_peer_id: PeerId) -> PeerRole {
        // Get the peers and metadata struct
        let peers_and_metadata = match &self.auth_mode {
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => peers_and_metadata.clone(),
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => peers_and_metadata.clone(),
        };

        // Determine the peer role
        match peers_and_metadata.get_trusted_peers(&self.network_context.network_id()) {
            Ok(trusted_peers) => {
                match trusted_peers.get(&remote_peer_id) {
                    Some(trusted_peer) => {
                        return trusted_peer.role; // We've found the peer!
                    },
                    None => {
                        error!(NetworkSchema::new(&self.network_context).message(format!(
                            "{} Outbound connection made with unknown peer (not in the trusted peers set)! Missing peer: {:?}",
                            self.network_context, remote_peer_id

                        )));
                    },
                }
            },
            Err(error) => {
                error!(NetworkSchema::new(&self.network_context).message(format!(
                    "Failed to get trusted peers for network context: {:?}, error: {:?}",
                    self.network_context, error
                )));
            },
        };

        // If we couldn't determine the peer role, return an unknown peer role
        PeerRole::Unknown
    }
```

**File:** network/framework/src/noise/handshake.rs (L368-382)
```rust
        let peer_role = match &self.auth_mode {
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L484-503)
```rust
    async fn close_stale_connections(&mut self) {
        if let Some(trusted_peers) = self.get_trusted_peers() {
            // Identify stale peer connections
            let stale_peers = self
                .connected
                .iter()
                .filter(|(peer_id, _)| !trusted_peers.contains_key(peer_id))
                .filter_map(|(peer_id, metadata)| {
                    // If we're using server only auth, we need to not evict unknown peers
                    // TODO: We should prevent `Unknown` from discovery sources
                    if !self.mutual_authentication
                        && metadata.origin == ConnectionOrigin::Inbound
                        && (metadata.role == PeerRole::ValidatorFullNode
                            || metadata.role == PeerRole::Unknown)
                    {
                        None
                    } else {
                        Some(*peer_id) // The peer is stale
                    }
                });
```
