# Audit Report

## Title
Integer Overflow in Transaction Index Arithmetic Operations Leading to Validator Crash

## Summary
The block executor performs unsafe arithmetic operations on transaction indices without overflow checks. When `num_txns` equals or approaches `u32::MAX`, operations like `num_txns + 1` silently overflow in release builds, causing out-of-bounds array accesses and validator crashes. While consensus validation currently limits blocks to ~10,000 transactions, the lack of defensive checks violates defense-in-depth principles.

## Finding Description

The vulnerability exists in multiple locations where transaction indices undergo arithmetic operations without overflow protection:

**1. Unsafe Type Casting:** [1](#0-0) 

The executor casts `num_txns` from `usize` to `u32` using a truncating cast that silently wraps values exceeding `u32::MAX` (4,294,967,295).

**2. Critical Overflow in Array Allocation:** [2](#0-1) 

When `num_txns = u32::MAX`, the expression `num_txns + 1` overflows to 0 in release builds, causing `TxnLastInputOutput::new(0)` to allocate zero-sized arrays. [3](#0-2) 

These arrays are later accessed with transaction indices: [4](#0-3) 

**3. Unchecked Arithmetic in Scheduler:** [5](#0-4) [6](#0-5) [7](#0-6) 

When `txn_idx` approaches `u32::MAX`, `txn_idx + 1` overflows, passing incorrect indices to validation logic.

**4. Tracking Index Overflow:** [8](#0-7) 

**5. Storage Index Confusion:** [9](#0-8) 

When `real_idx = u32::MAX`, overflow makes it indistinguishable from the storage version marker.

## Impact Explanation

**Severity: HIGH**

The vulnerability causes:
1. **Validator Crashes (DoS)**: Out-of-bounds array access causes panics, crashing validator nodes
2. **Consensus Divergence Risk**: Different overflow handling across nodes could produce different execution results, breaking **Deterministic Execution** invariant
3. **Storage Corruption**: ShiftedTxnIndex overflow confuses transaction data with storage base values

While consensus validation currently limits blocks to 10,000 transactions, this vulnerability:
- Violates defense-in-depth principles (no executor-layer validation)
- Creates risk if consensus limits are increased
- Could be triggered by bugs in validation logic
- Affects test environments and non-standard execution paths

## Likelihood Explanation

**Current Likelihood: Low**
Consensus validation prevents blocks exceeding 10,000 transactions: [10](#0-9) 

**Risk Factors:**
1. Future configuration changes increasing transaction limits
2. Bugs bypassing consensus validation
3. Version mismatches between consensus and executor
4. Direct executor invocation in testing or special scenarios
5. Unsafe cast pattern could be replicated elsewhere

The code assumes consensus-layer protection but provides no executor-layer safety checks.

## Recommendation

**1. Add Overflow-Safe Casting:**
```rust
let num_txns = u32::try_from(num_txns)
    .map_err(|_| code_invariant_error(
        format!("Block has {} transactions, exceeds u32::MAX", num_txns)
    ))?;
```

**2. Use Checked Arithmetic:**
```rust
let last_input_output = TxnLastInputOutput::new(
    num_txns.checked_add(1)
        .ok_or_else(|| code_invariant_error("num_txns overflow"))?
);
```

**3. Add Assertions in Scheduler Methods:**
```rust
fn decrease_validation_idx(&self, target_idx: TxnIndex) -> Option<Wave> {
    let target_idx = txn_idx.checked_add(1)?;
    assert!(target_idx <= self.num_txns, "target_idx overflow");
    // ... rest of implementation
}
```

**4. Fix ShiftedTxnIndex:**
```rust
pub fn new(real_idx: TxnIndex) -> Result<Self, PanicError> {
    let idx = real_idx.checked_add(1)
        .ok_or_else(|| code_invariant_error("ShiftedTxnIndex overflow"))?;
    Ok(Self { idx })
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_overflow_causes_crash() {
    use aptos_types::transaction::Transaction;
    
    // Simulate num_txns = u32::MAX after unsafe cast
    let num_txns: u32 = u32::MAX;
    
    // This overflows to 0 in release builds
    let last_input_output = TxnLastInputOutput::<Transaction, _>::new(num_txns + 1);
    
    // Attempting to record any transaction panics with out-of-bounds
    let dummy_input = TxnInput::default();
    let dummy_output = ExecutionStatus::Success(/* ... */);
    
    // This will panic: arrays have size 0 but we're accessing index 0
    last_input_output.record(0, dummy_input, dummy_output, &block_gas_limit_type, 0)
        .expect("Should panic before this");
}
```

**Notes:**
- The vulnerability exists but is mitigated by consensus-layer validation
- Represents a defensive programming failure violating Rust safety principles
- Should be fixed to prevent future exploitation if constraints change
- Impact is real (validator crash) but current exploitability is low

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L1732-1732)
```rust
        let num_txns = num_txns as u32;
```

**File:** aptos-move/block-executor/src/executor.rs (L1740-1740)
```rust
        let last_input_output = TxnLastInputOutput::new(num_txns + 1);
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L224-239)
```rust
    pub fn new(num_txns: TxnIndex) -> Self {
        Self {
            inputs: (0..num_txns)
                .map(|_| CachePadded::new(ArcSwapOption::empty()))
                .collect(),
            output_wrappers: (0..num_txns)
                .map(|_| {
                    CachePadded::new(Mutex::new(OutputWrapper::empty_with_status(
                        OutputStatusKind::None,
                    )))
                })
                .collect(),
            speculative_failures: (0..num_txns)
                .map(|_| CachePadded::new(AtomicBool::new(false)))
                .collect(),
        }
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L250-257)
```rust
        self.speculative_failures[txn_idx as usize].store(false, Ordering::Relaxed);
        *self.output_wrappers[txn_idx as usize].lock() = OutputWrapper::from_execution_status(
            output,
            &input,
            block_gas_limit_type,
            user_txn_bytes_len,
        )?;
        self.inputs[txn_idx as usize].store(Some(Arc::new(input)));
```

**File:** aptos-move/block-executor/src/scheduler.rs (L580-580)
```rust
                if let Some(wave) = self.decrease_validation_idx(txn_idx + 1) {
```

**File:** aptos-move/block-executor/src/scheduler.rs (L607-607)
```rust
        self.decrease_validation_idx(txn_idx + 1);
```

**File:** aptos-move/block-executor/src/scheduler.rs (L635-635)
```rust
            self.decrease_validation_idx(txn_idx + 1);
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L395-395)
```rust
                .fetch_max(idx + 1, Ordering::Relaxed);
```

**File:** aptos-move/mvhashmap/src/types.rs (L112-112)
```rust
        Self { idx: real_idx + 1 }
```

**File:** config/src/config/consensus_config.rs (L20-24)
```rust
const MAX_SENDING_BLOCK_TXNS_AFTER_FILTERING: u64 = 1800;
const MAX_SENDING_OPT_BLOCK_TXNS_AFTER_FILTERING: u64 = 1000;
const MAX_SENDING_BLOCK_TXNS: u64 = 5000;
pub(crate) static MAX_RECEIVING_BLOCK_TXNS: Lazy<u64> =
    Lazy::new(|| 10000.max(2 * MAX_SENDING_BLOCK_TXNS));
```
