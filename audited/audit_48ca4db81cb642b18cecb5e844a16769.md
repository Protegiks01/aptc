# Audit Report

## Title
Infinite Retry Loop in Single-Validator CommitVote Aggregation Due to Clone-Before-Filter Pattern

## Summary
In single-validator mode, the `try_advance_to_aggregated` method in the Signed state clones the signature aggregator before verification, causing invalid signatures to persist in the original buffer item. This creates an infinite retry loop that wastes CPU resources when the single validator produces an invalid signature.

## Finding Description

The CommitVote verification flow uses optimistic signature verification, deferring cryptographic checks until aggregation time. [1](#0-0) 

When advancing from Signed to Aggregated state, the code exhibits different behavior than the Executed state due to a clone operation:

**Signed State (vulnerable):** [2](#0-1) 

The signature aggregator is **cloned** before calling `aggregate_and_verify`. When verification fails, `filter_invalid_signatures` removes bad signatures from the **clone only**. [3](#0-2) 

The original `signed_item.partial_commit_proof` retains the invalid signature, causing the next invocation to repeat the same verification attempt indefinitely.

**Executed State (correct):** [4](#0-3) 

No clone is used - `aggregate_and_verify` modifies the original aggregator directly, so filtered signatures persist.

**Single-Validator Impact:**
In single-validator mode with quorum=1, if an invalid signature enters the system:
1. Optimistic verification accepts it without cryptographic checks [5](#0-4) 
2. Buffer advances to Signed state
3. `check_voting_power` passes (quorum met with 1 vote)
4. `aggregate_and_verify` is called on a clone
5. Verification fails, clone is filtered, but original remains unchanged
6. Returns to Signed state with unmodified signatures
7. Steps 3-6 repeat infinitely

## Impact Explanation
This is classified as **Low Severity** per the bug bounty criteria as it constitutes a "non-critical implementation bug":

- **Limited Scope**: Only affects single-validator deployments (local development/testing environments)
- **No Production Impact**: Multi-validator networks are unaffected
- **Liveness Only**: Does not compromise consensus safety or state integrity
- **Self-DoS**: Requires the validator to attack itself with invalid signatures
- **Resource Waste**: Consumes CPU cycles but doesn't corrupt state or freeze funds

## Likelihood Explanation
**Very Low Likelihood** - This scenario requires:
1. Single-validator mode deployment (non-production)
2. Creation of cryptographically invalid signature (should never occur with correct `ValidatorSigner::sign()` implementation)
3. No mechanism for external attacker to inject invalid signatures without validator cooperation

In normal operation, validators produce valid signatures through proper cryptographic APIs. Invalid signatures would only arise from:
- Critical bugs in signature generation code
- Memory corruption
- Deliberate self-sabotage

## Recommendation
Remove the clone operation in the Signed state to match the Executed state behavior, allowing `filter_invalid_signatures` to persist changes to the original aggregator:

Change line 305-311 in `consensus/src/pipeline/buffer_item.rs` from:
```rust
if let Ok(commit_proof) = signed_item
    .partial_commit_proof
    .clone()  // Remove this
    .aggregate_and_verify(validator)
```

To:
```rust
if let Ok(commit_proof) = signed_item
    .partial_commit_proof
    .aggregate_and_verify(validator)
```

However, this requires refactoring ownership since `signed_item` must be returned on failure. Alternative: Mark `signed_item` as `mut` and update it after filtering failures.

## Proof of Concept
```rust
#[test]
fn test_single_validator_invalid_signature_loop() {
    // Create single validator setup
    let validator_signer = ValidatorSigner::random([0; 32]);
    let validator_verifier = ValidatorVerifier::new_single(
        validator_signer.author(),
        validator_signer.public_key(),
    );
    validator_verifier.set_optimistic_sig_verification_flag(true);
    
    let pipelined_block = create_pipelined_block();
    let ledger_info = LedgerInfo::new(
        pipelined_block.block_info(),
        HashValue::zero(),
    );
    
    // Create CommitVote with INVALID signature
    let invalid_commit_vote = CommitVote::new_with_signature(
        validator_signer.author(),
        ledger_info.clone(),
        bls12381::Signature::dummy_signature(), // Invalid!
    );
    
    // Advance to Signed state with invalid signature
    let mut buffer_item = /* ... create signed buffer item ... */;
    buffer_item.add_signature_if_matched(invalid_commit_vote).unwrap();
    
    // Call try_advance_to_aggregated repeatedly
    for i in 0..100 {
        let result = buffer_item.try_advance_to_aggregated(&validator_verifier);
        // Assert it remains in Signed state (never progresses)
        assert!(result.is_signed());
        buffer_item = result;
    }
    // Demonstrates infinite loop - would continue forever
}
```

## Notes

While this represents a genuine code quality issue, it **fails the validation checklist** for a valid security vulnerability because:
- Not exploitable by unprivileged attackers
- Attack path is unrealistic (requires self-sabotage)  
- Impact is LOW, below Medium threshold
- Only affects non-production single-validator deployments

The bug is a defensive programming flaw rather than an exploitable security vulnerability in production consensus systems.

### Citations

**File:** consensus/consensus-types/src/pipeline/commit_vote.rs (L103-113)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.author() == sender,
            "Commit vote author {:?} doesn't match with the sender {:?}",
            self.author(),
            sender
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify Commit Vote")
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L296-320)
```rust
            Self::Signed(signed_item) => {
                if signed_item
                    .partial_commit_proof
                    .check_voting_power(validator, true)
                    .is_ok()
                {
                    let _time = counters::VERIFY_MSG
                        .with_label_values(&["commit_vote_aggregate_and_verify"])
                        .start_timer();
                    if let Ok(commit_proof) = signed_item
                        .partial_commit_proof
                        .clone()
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
                        return Self::Aggregated(Box::new(AggregatedItem {
                            executed_blocks: signed_item.executed_blocks,
                            commit_proof,
                        }));
                    }
                }
                Self::Signed(signed_item)
            },
```

**File:** consensus/src/pipeline/buffer_item.rs (L321-345)
```rust
            Self::Executed(mut executed_item) => {
                if executed_item
                    .partial_commit_proof
                    .check_voting_power(validator, true)
                    .is_ok()
                {
                    let _time = counters::VERIFY_MSG
                        .with_label_values(&["commit_vote_aggregate_and_verify"])
                        .start_timer();

                    if let Ok(commit_proof) = executed_item
                        .partial_commit_proof
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
                        return Self::Aggregated(Box::new(AggregatedItem {
                            executed_blocks: executed_item.executed_blocks,
                            commit_proof,
                        }));
                    }
                }
                Self::Executed(executed_item)
            },
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```
