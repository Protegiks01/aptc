# Audit Report

## Title
Private Key Exposure Through Configuration Serialization and Logging

## Summary
The `ConfigKey` struct implements `Serialize`, enabling validator private keys (network and consensus keys) to be serialized to human-readable formats (JSON, YAML, TOML). When validators use `Identity::FromConfig` with embedded keys instead of secure storage backends, these private keys are automatically logged at node startup via `log_all_configs()` and written to configuration files in plaintext hex format, creating multiple exposure vectors through logs, version control commits, and configuration backups.

## Finding Description

The vulnerability exists across multiple code paths:

**Path 1: Startup Logging Exposure** [1](#0-0) 

The `ConfigKey` struct derives `Serialize`, which delegates to the underlying `PrivateKey`'s serialization. [2](#0-1) 

The `SerializeKey` macro implementation shows that when serializing with human-readable formats (JSON, YAML, TOML), it calls `to_encoded_string()`, which produces a plaintext hex representation of the private key. [3](#0-2) 

At node startup, `log_all_configs()` serializes the entire `NodeConfig` to JSON using `serde_json::to_value()` and `serde_json::to_string()`, then logs each section. This uses the Serialize trait, NOT Debug formatting. [4](#0-3) 

This logging happens automatically when every validator node starts.

**Path 2: Configuration File Persistence** [5](#0-4) 

When configurations are saved using `save_config()`, they are serialized to YAML using `serde_yaml::to_vec()`, which will encode private keys in plaintext hex format.

**Path 3: Identity Configuration** [6](#0-5) 

Validators can use `IdentityFromConfig` with an embedded `ConfigKey<x25519::PrivateKey>` for their network identity. The `#[serde(flatten)]` attribute causes the key to be serialized at the top level of the identity configuration. [7](#0-6) 

Additionally, `IdentityBlob` directly contains optional `Ed25519PrivateKey` and `bls12381::PrivateKey` fields without `ConfigKey` wrappers, which are also serialized when saving to YAML.

**Exploitation Scenario:**

1. A validator operator uses the `from_config` identity type (shown as a commented example in default configs) during initial setup or for convenience
2. The private key is embedded in the YAML configuration file in plaintext hex
3. At node startup, `log_all_configs()` serializes and logs the private key to stdout/log files
4. The configuration file or logs are:
   - Committed to version control (public or private repositories)
   - Included in log aggregation systems
   - Captured in system backups
   - Exposed through configuration management tools
5. An attacker gains access to these artifacts and extracts the validator's network or consensus private keys

**Lack of Protection:**

While the inspection service endpoint correctly uses Debug formatting to prevent exposure (protected by `SilentDebug`), the serialization paths are unprotected: [8](#0-7) 

The comment claims "all secret keys are marked with SilentDisplay and SilentDebug," but this only protects the Debug formatting path. The Serialize trait implementation is NOT protected and produces plaintext hex output.

## Impact Explanation

**Severity: High**

This vulnerability enables multiple attack vectors:

1. **Consensus Safety Violation**: If a validator's BLS consensus private key is exposed, an attacker could:
   - Sign malicious blocks or votes
   - Cause equivocation by signing conflicting blocks
   - Violate the Byzantine fault tolerance assumptions

2. **Network Security Compromise**: If the x25519 network private key is exposed:
   - Attacker can impersonate the validator on the network
   - Decrypt validator network communications
   - Perform man-in-the-middle attacks on consensus messages

3. **Validator Operations Disruption**: Exposure of validator keys could force:
   - Emergency validator rotation procedures
   - Potential slashing if key misuse is detected
   - Network-wide security incidents requiring coordinated response

This meets the **High Severity** criteria ($50,000) for "Significant protocol violations" as it compromises validator security infrastructure and could lead to consensus safety violations.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is likely to occur because:

1. **Default Configuration Templates**: The default validator configuration includes commented examples showing `from_config` usage, which operators might enable for convenience [9](#0-8) 

2. **No Mainnet Sanitizer**: While there are sanitizers for other configurations (inspection service, safety rules backend), there is NO sanitizer preventing `Identity::FromConfig` usage on mainnet validators

3. **Automatic Logging**: The `log_all_configs()` call happens automatically at every node startup without operator intervention

4. **Developer Workflows**: During development, testing, and initial deployment, operators often use simpler configurations before transitioning to production-grade secure storage, creating a window of exposure

5. **Historical Precedent**: Similar vulnerabilities have occurred in other blockchain projects where private keys were accidentally committed to version control

The only mitigating factor is that the documentation and default configs recommend using `from_storage` with secure backends like Vault, but this is insufficient protection against operational errors.

## Recommendation

**Immediate Fix**: Add a configuration sanitizer that prevents `Identity::FromConfig` on mainnet validators, forcing the use of secure storage backends.

**Implementation**:

1. Add a sanitizer in `identity_config.rs`:
```rust
impl ConfigSanitizer for Identity {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        
        // Check validator network identity
        if let Some(validator_network) = &node_config.validator_network {
            if let Some(chain_id) = chain_id {
                if node_type.is_validator() && chain_id.is_mainnet() {
                    if matches!(validator_network.identity, Identity::FromConfig(_)) {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            "Mainnet validators must not use from_config identity! Use from_storage with secure backend.".to_string(),
                        ));
                    }
                }
            }
        }
        
        // Check full node networks
        for network in &node_config.full_node_networks {
            if let Some(chain_id) = chain_id {
                if node_type.is_validator() && chain_id.is_mainnet() {
                    if matches!(network.identity, Identity::FromConfig(_)) {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            "Mainnet validators must not use from_config identity! Use from_storage with secure backend.".to_string(),
                        ));
                    }
                }
            }
        }
        
        Ok(())
    }
}
```

2. Mark private key fields with `#[serde(skip_serializing)]` in `SafetyRulesTestConfig` and ensure it's never used outside test contexts

3. Modify `log_all_configs()` to use Debug formatting instead of JSON serialization, or filter out sensitive fields:
```rust
pub fn log_all_configs(&self) {
    // Use Debug formatting which respects SilentDebug
    info!("Node configuration: {:?}", self);
}
```

4. Add warnings to configuration documentation explicitly stating that `from_config` should NEVER be used in production

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use aptos_config::config::{Identity, NodeConfig};
    use aptos_crypto::{x25519, Uniform};
    use aptos_types::account_address::AccountAddress;
    
    #[test]
    fn test_private_key_serialization_exposure() {
        // Generate a test private key
        let private_key = x25519::PrivateKey::generate(&mut rand::thread_rng());
        let peer_id = AccountAddress::random();
        
        // Create identity with embedded key (vulnerable configuration)
        let identity = Identity::from_config(private_key.clone(), peer_id);
        
        // Create a minimal node config
        let mut node_config = NodeConfig::default();
        if let Some(ref mut validator_network) = node_config.validator_network {
            validator_network.identity = identity;
        }
        
        // Demonstrate exposure via JSON serialization (as used in log_all_configs)
        let config_json = serde_json::to_string_pretty(&node_config)
            .expect("Failed to serialize config");
        
        // The private key appears in plaintext hex in the JSON output
        let private_key_hex = hex::encode(private_key.to_bytes());
        assert!(
            config_json.contains(&private_key_hex),
            "Private key is exposed in serialized configuration!\n{}",
            config_json
        );
        
        // Demonstrate exposure via YAML serialization (as used in save_config)
        let config_yaml = serde_yaml::to_string(&node_config)
            .expect("Failed to serialize config to YAML");
        
        assert!(
            config_yaml.contains(&private_key_hex),
            "Private key is exposed in YAML configuration!\n{}",
            config_yaml
        );
        
        println!("VULNERABILITY CONFIRMED: Private key {} appears in:", private_key_hex);
        println!("JSON output: {}", config_json.contains(&private_key_hex));
        println!("YAML output: {}", config_yaml.contains(&private_key_hex));
    }
}
```

## Notes

While the codebase uses `SilentDebug` and `SilentDisplay` to protect Debug/Display formatting of private keys, it fails to protect the Serialize trait implementation. The `SerializeKey` derive macro explicitly encodes private keys as human-readable hex strings when using JSON/YAML serializers, creating a critical gap in the security model. The vulnerability is exacerbated by the lack of mainnet-specific sanitizers preventing dangerous configuration patterns and the automatic logging of full configurations at node startup.

### Citations

**File:** config/src/keys.rs (L25-29)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct ConfigKey<T: PrivateKey + Serialize> {
    #[serde(bound(deserialize = "T: Deserialize<'de>"))]
    key: T,
}
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L185-211)
```rust
#[proc_macro_derive(SerializeKey)]
pub fn serialize_key(source: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(source).expect("Incorrect macro input");
    let name = &ast.ident;
    let name_string = find_key_name(&ast, name.to_string());
    quote! {
        impl ::serde::Serialize for #name {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: ::serde::Serializer,
            {
                if serializer.is_human_readable() {
                    self.to_encoded_string()
                        .map_err(<S::Error as ::serde::ser::Error>::custom)
                        .and_then(|str| serializer.serialize_str(&str[..]))
                } else {
                    // See comment in deserialize_key.
                    serializer.serialize_newtype_struct(
                        #name_string,
                        serde_bytes::Bytes::new(&ValidCryptoMaterial::to_bytes(self).as_slice()),
                    )
                }
            }
        }
    }
    .into()
}
```

**File:** config/src/config/node_config.rs (L97-110)
```rust
    pub fn log_all_configs(&self) {
        // Parse the node config as serde JSON
        let config_value =
            serde_json::to_value(self).expect("Failed to serialize the node config!");
        let config_map = config_value
            .as_object()
            .expect("Failed to get the config map!");

        // Log each config entry
        for (config_name, config_value) in config_map {
            let config_string =
                serde_json::to_string(config_value).expect("Failed to parse the config value!");
            info!("Using {} config: {}", config_name, config_string);
        }
```

**File:** aptos-node/src/lib.rs (L697-698)
```rust
    // Log the node config at node startup
    node_config.log_all_configs();
```

**File:** config/src/config/persistable_config.rs (L23-29)
```rust
    fn save_config<P: AsRef<Path>>(&self, output_file: P) -> Result<(), Error> {
        // Serialize the config to a string
        let serialized_config = serde_yaml::to_vec(&self)
            .map_err(|e| Error::Yaml(output_file.as_ref().to_str().unwrap().to_string(), e))?;

        Self::write_file(serialized_config, output_file)
    }
```

**File:** config/src/config/identity_config.rs (L24-37)
```rust
#[derive(Deserialize, Serialize)]
pub struct IdentityBlob {
    /// Optional account address. Used for validators and validator full nodes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_address: Option<AccountAddress>,
    /// Optional account key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_private_key: Option<Ed25519PrivateKey>,
    /// Optional consensus key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consensus_private_key: Option<bls12381::PrivateKey>,
    /// Network private key. Peer id is derived from this if account address is not present
    pub network_private_key: x25519::PrivateKey,
}
```

**File:** config/src/config/identity_config.rs (L130-139)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IdentityFromConfig {
    #[serde(flatten)]
    pub key: ConfigKey<x25519::PrivateKey>,
    pub peer_id: PeerId,

    #[serde(skip)]
    pub source: IdentitySource,
}
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-26)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };
```

**File:** config/src/config/test_data/validator.yaml (L72-77)
```yaml
    ### Load keys directly from config
    #
    # identity:
    #     type: "from_config"
    #     key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
    #     peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"
```
