# Audit Report

## Title
Genesis Waypoint Validation Bypass via Pre-populated Fast Sync Temporary Database

## Summary
A critical validation bypass exists in the fast sync bootstrap path that allows an attacker with filesystem access to inject arbitrary genesis state and validator set by pre-populating the temporary database, completely bypassing waypoint-based genesis verification.

## Finding Description

The vulnerability exists in the fast sync initialization flow where the temporary database (`fast_sync_secondary`) is opened without cleaning or validation. When this database contains pre-existing data (version > 0), the genesis validation logic is completely bypassed, including the critical waypoint verification that ensures nodes bootstrap to the correct genesis state. [1](#0-0) 

The attack flow:

1. **Temporary DB Creation**: When fast sync is enabled and the main DB is empty, a secondary database is created at `{config.storage.dir()}/fast_sync_secondary/`. [2](#0-1) 

2. **No Directory Cleanup**: The code opens this directory without cleaning it first, trusting whatever database exists there. [3](#0-2) 

3. **Genesis Validation Skip**: When `maybe_apply_genesis()` is called on the temporary DB, it invokes `maybe_bootstrap()`, which checks if `ledger_summary.version() + 1 == waypoint.version()`. [4](#0-3) 

   If the temporary DB has version > 0, this condition fails, and **genesis validation is completely skipped** without any waypoint verification, returning `Ok(None)` with no error.

4. **Unvalidated Ledger Info Retrieval**: The code then retrieves the ledger info at epoch 0 from the unvalidated temporary DB. [5](#0-4) 

5. **Weak Validation on Commit**: The retrieved ledger info is committed to the fast sync DB via `commit_genesis_ledger_info()`, which only validates that `epoch == 0`. [6](#0-5) 

   **It does NOT validate**:
   - The cryptographic correctness of the ledger info
   - The state root hash
   - The transaction accumulator root
   - The next_epoch_state (validator set)
   - The waypoint correspondence

6. **Validator Set Compromise**: The bootstrapper then reads this malicious epoch state as the trusted validator set for all future consensus verification. [7](#0-6) 

**Attack Prerequisites:**
- Filesystem write access to the node's data directory before node startup
- Fast sync enabled in configuration
- Main database empty (synced_version == 0)

**Attack Execution:**
An attacker creates a malicious AptosDB with:
- Version â‰¥ 1 (to trigger validation skip)
- Crafted ledger info at epoch 0 with attacker-controlled `next_epoch_state` (validator set)
- Malicious state root

When the node starts, it trusts this malicious database without any cryptographic validation, establishing an attacker-controlled validator set for all future consensus operations.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability enables:

1. **Complete Validator Set Control**: The attacker controls the `next_epoch_state` in the genesis ledger info, determining which validators participate in consensus. This allows the attacker to:
   - Set themselves as the sole validator
   - Control block production and transaction inclusion
   - Execute arbitrary state transitions

2. **Consensus Safety Violation**: By controlling the validator set, the attacker can produce blocks that honest nodes will accept as valid, breaking the fundamental safety guarantee that < 1/3 Byzantine validators cannot compromise consensus. [8](#0-7) 

3. **Arbitrary State Injection**: The attacker controls the genesis state root, allowing them to define the initial state of all accounts and resources, including:
   - Token supplies and balances  
   - Governance configurations
   - Staking and validator configurations

4. **Network-Wide Impact**: All nodes bootstrapping via fast sync from a compromised infrastructure will adopt the attacker's chain, potentially causing a permanent network partition requiring a hard fork to resolve.

This qualifies as **Critical** under Aptos bug bounty criteria:
- Consensus/Safety violations
- Non-recoverable network partition (requires hardfork)  
- Loss of Funds (arbitrary state control)

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH** in targeted infrastructure compromise scenarios

**Attack Requirements:**
- Filesystem write access before node startup
- Knowledge of Aptos fast sync implementation

**Realistic Attack Scenarios:**

1. **Compromised Cloud Infrastructure**: Attacker gains access to VM instances or container images used to deploy Aptos nodes
2. **Supply Chain Attack**: Malicious disk images or deployment scripts that pre-populate the database directory
3. **Insider Threat**: Malicious operator with access to node infrastructure
4. **Configuration Vulnerability**: Misconfigured directory permissions allowing unauthorized writes

**Factors Increasing Likelihood:**
- No directory cleanup on startup (production code only cleans in tests)
- No integrity verification of database directories
- Fast sync is commonly used for new node deployment
- Cloud infrastructure commonly targeted in blockchain attacks

**Factors Decreasing Likelihood:**
- Requires infrastructure-level compromise (not remote exploit)
- Requires precise timing (before node first starts)
- Requires knowledge of Aptos fast sync internals

## Recommendation

**Immediate Fix**: Always validate the temporary database against the genesis waypoint, regardless of its current version state.

**Code Changes Required:**

1. **In `aptos-node/src/storage.rs`** - Validate the temporary DB before trusting its contents:

```rust
Either::Right(fast_sync_db_wrapper) => {
    let temp_db = fast_sync_db_wrapper.get_temporary_db_with_genesis();
    let temp_db_rw = DbReaderWriter::from_arc(temp_db.clone());
    
    // ALWAYS apply and validate genesis, even if DB has data
    maybe_apply_genesis(&temp_db_rw, node_config)?;
    
    // Verify the resulting state matches the expected genesis waypoint
    let genesis_waypoint = node_config
        .execution
        .genesis_waypoint
        .as_ref()
        .unwrap_or(&node_config.base.waypoint)
        .genesis_waypoint();
    
    let ledger_info = temp_db
        .get_epoch_ending_ledger_info(0)
        .expect("Genesis ledger info must exist after validation");
    
    // Verify waypoint matches
    ensure!(
        genesis_waypoint.verify(ledger_info.ledger_info()).is_ok(),
        "Temporary DB genesis state does not match expected waypoint"
    );
    
    // ... rest of the code
}
```

2. **In `execution/executor/src/db_bootstrapper/mod.rs`** - Remove the early return that skips validation:

```rust
pub fn maybe_bootstrap<V: VMBlockExecutor>(
    db: &DbReaderWriter,
    genesis_txn: &Transaction,
    waypoint: Waypoint,
) -> Result<Option<LedgerInfoWithSignatures>> {
    let ledger_summary = db.reader.get_pre_committed_ledger_summary()?;
    
    // If DB already has genesis at the waypoint version, verify it matches
    if ledger_summary.version().map_or(0, |v| v + 1) == waypoint.version() {
        let committer = calculate_genesis::<V>(db, ledger_summary, genesis_txn)?;
        ensure!(
            waypoint == committer.waypoint(),
            "Waypoint verification failed. Expected {:?}, got {:?}.",
            waypoint,
            committer.waypoint(),
        );
        let ledger_info = committer.output.ledger_info_opt.clone();
        committer.commit()?;
        Ok(ledger_info)
    } else if ledger_summary.version().map_or(0, |v| v) >= waypoint.version() {
        // If DB version is already past waypoint, verify the waypoint was correct
        let epoch_ending_li = db.reader.get_epoch_ending_ledger_info(waypoint.version())?;
        ensure!(
            waypoint.verify(epoch_ending_li.ledger_info()).is_ok(),
            "Existing DB state does not match expected waypoint at version {}",
            waypoint.version()
        );
        info!(waypoint = %waypoint, "Waypoint verified for existing DB.");
        Ok(None)
    } else {
        info!(waypoint = %waypoint, "Skip genesis txn - target version not reached.");
        Ok(None)
    }
}
```

3. **Additional Hardening**: Clean the temporary database directory on startup in production code (currently only done in tests).

## Proof of Concept

**Setup:**
1. Create a malicious AptosDB with crafted genesis state
2. Place it at `{node_data_dir}/fast_sync_secondary/`
3. Configure node for fast sync with empty main DB
4. Start node and observe genesis validation bypass

**Rust Test Pseudocode:**

```rust
#[test]
fn test_malicious_temp_db_bypass() {
    // 1. Create malicious DB with version 1 and custom validator set
    let malicious_db = create_malicious_db_with_version_1();
    
    // 2. Place in fast_sync_secondary directory
    let temp_db_path = format!("{}/fast_sync_secondary", test_data_dir);
    std::fs::create_dir_all(&temp_db_path).unwrap();
    copy_db(malicious_db, &temp_db_path);
    
    // 3. Initialize fast sync wrapper
    let config = create_fast_sync_config();
    let wrapper = FastSyncStorageWrapper::initialize_dbs(&config, None, None).unwrap();
    
    // 4. Bootstrap - should validate but currently doesn't
    let (_, db_rw, _, _, _) = bootstrap_db(&config).unwrap();
    
    // 5. Verify the malicious epoch state was accepted
    let epoch_state = db_rw.reader.get_latest_epoch_state().unwrap();
    assert!(epoch_state_is_malicious(epoch_state)); // This should fail but passes
}
```

**Verification Steps:**
1. Check that `maybe_apply_genesis()` returns `Ok(None)` without error
2. Verify the malicious ledger info is committed to fast_sync_db
3. Confirm the bootstrapper uses the malicious validator set
4. Show that consensus signatures from the malicious validators are accepted

**Notes**

This vulnerability represents a critical failure in defense-in-depth principles. Even though the filesystem is generally considered trusted, cryptographic validation of persistent data should never be bypassed, especially for security-critical operations like genesis validation that establish the trust root for the entire blockchain.

The vulnerability is particularly concerning because:
1. It completely bypasses the waypoint mechanism designed to prevent exactly this type of attack
2. The attack surface includes any scenario where node infrastructure is compromised before initial startup
3. Detection would be extremely difficult as the node appears to bootstrap normally
4. Recovery requires network-wide coordination and potentially a hard fork

### Citations

**File:** aptos-node/src/storage.rs (L75-98)
```rust
        Either::Right(fast_sync_db_wrapper) => {
            let temp_db = fast_sync_db_wrapper.get_temporary_db_with_genesis();
            maybe_apply_genesis(&DbReaderWriter::from_arc(temp_db), node_config)?;
            let (db_arc, db_rw) = DbReaderWriter::wrap(fast_sync_db_wrapper);
            let fast_sync_db = db_arc.get_fast_sync_db();
            // FastSyncDB requires ledger info at epoch 0 to establish provenance to genesis
            let ledger_info = db_arc
                .get_temporary_db_with_genesis()
                .get_epoch_ending_ledger_info(0)
                .expect("Genesis ledger info must exist");

            if fast_sync_db
                .get_latest_ledger_info_option()
                .expect("should returns Ok results")
                .is_none()
            {
                // it means the DB is empty and we need to
                // commit the genesis ledger info to the DB.
                fast_sync_db.commit_genesis_ledger_info(&ledger_info)?;
            }
            let db_backup_service =
                start_backup_service(node_config.storage.backup_service_address, fast_sync_db);
            (db_arc as Arc<dyn DbReader>, db_rw, Some(db_backup_service))
        },
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L78-90)
```rust
            db_dir.push(SECONDARY_DB_DIR);
            let secondary_db = AptosDB::open(
                StorageDirPaths::from_path(db_dir.as_path()),
                /*readonly=*/ false,
                config.storage.storage_pruner_config,
                config.storage.rocksdb_configs,
                config.storage.enable_indexer,
                config.storage.buffered_state_target_items,
                config.storage.max_num_nodes_per_lru_cache_shard,
                None,
                config.storage.hot_state_config,
            )
            .map_err(|err| anyhow!("Secondary DB failed to open {}", err))?;
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L56-59)
```rust
    if ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version() {
        info!(waypoint = %waypoint, "Skip genesis txn.");
        return Ok(None);
    }
```

**File:** storage/aptosdb/src/db/mod.rs (L207-219)
```rust
    pub fn commit_genesis_ledger_info(&self, genesis_li: &LedgerInfoWithSignatures) -> Result<()> {
        let ledger_metadata_db = self.ledger_db.metadata_db();
        let current_epoch = ledger_metadata_db
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            genesis_li.ledger_info().epoch() == current_epoch && current_epoch == 0,
            "Genesis ledger info epoch is not 0"
        );
        let mut ledger_batch = SchemaBatch::new();
        ledger_metadata_db.put_ledger_info(genesis_li, &mut ledger_batch)?;
        ledger_metadata_db.write_schemas(ledger_batch)
    }
```

**File:** state-sync/state-sync-driver/src/utils.rs (L258-265)
```rust
pub fn fetch_latest_epoch_state(storage: Arc<dyn DbReader>) -> Result<EpochState, Error> {
    storage.get_latest_epoch_state().map_err(|error| {
        Error::StorageError(format!(
            "Failed to get the latest epoch state from storage: {:?}",
            error
        ))
    })
}
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L103-108)
```rust
        // Verify the ledger info against the latest epoch state
        self.latest_epoch_state
            .verify(epoch_ending_ledger_info)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })?;
```
