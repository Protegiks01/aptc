# Audit Report

## Title
Unvalidated Nanosecond Field in Timestamp Causes Incorrect Throughput Calculations in Indexer Status Page

## Summary
The `timestamp.nanos` field from external protobuf messages is not validated to be in the range [0, 999,999,999] before being used in time calculations. This allows malicious data services to send invalid timestamps that cause incorrect throughput metrics in the indexer-grpc-manager status page.

## Finding Description

The Aptos indexer-grpc infrastructure uses protobuf `Timestamp` messages that specify `nanos` must be in [0, 999,999,999], but this constraint is not enforced in code. [1](#0-0) 

The `timestamp_to_unixtime` function performs arithmetic conversion without validation: [2](#0-1) 

This function is called in `get_throughput_from_samples` to calculate time differences for throughput metrics: [3](#0-2) [4](#0-3) 

External data services send `StreamProgress` samples via heartbeat messages without validation: [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. Malicious data service sends `LiveDataServiceInfo` with `StreamProgress` samples containing invalid timestamps (e.g., `nanos = 2000000000` or `nanos = -1000000000`)
2. These timestamps are stored without validation
3. Status page calls `get_throughput_from_samples` which uses `timestamp_to_unixtime`
4. Invalid `nanos` values cause incorrect time calculations:
   - Negative nanos: `timestamp.seconds - 1.0 + (remaining fraction)`
   - Large positive nanos: `timestamp.seconds + 2.0 + (remaining fraction)`
5. This produces incorrect `time_diff` values, leading to wildly inaccurate TPS/BPS metrics

## Impact Explanation

This issue is classified as **Low Severity** (not Medium as suggested in the question) because:

1. **Limited Scope**: Only affects indexer-grpc monitoring infrastructure, not blockchain consensus, state, or funds
2. **Display-Only Impact**: Causes incorrect throughput metrics in status page HTML output
3. **No Chain Impact**: Does not affect block production, validation, transaction processing, or any core blockchain operations
4. **Indexer Infrastructure**: The affected component is off-chain query infrastructure, not consensus-critical code

Per Aptos bug bounty criteria, this does not meet Medium severity thresholds:
- No "Limited funds loss or manipulation"
- No "State inconsistencies requiring intervention" (blockchain state is unaffected)

## Likelihood Explanation

**Likelihood: Low to Medium**

- Requires attacker to control a data service or compromise the heartbeat endpoint
- gRPC endpoints may have network-level access controls (not visible in code)
- Malformed timestamps would be immediately obvious in status page display
- Limited operational impact makes exploitation less attractive

## Recommendation

Add validation for the `nanos` field when processing external timestamps:

```rust
pub fn timestamp_to_unixtime(timestamp: &Timestamp) -> Result<f64, &'static str> {
    if timestamp.nanos < 0 || timestamp.nanos > 999_999_999 {
        return Err("Invalid nanoseconds value: must be in range [0, 999999999]");
    }
    Ok(timestamp.seconds as f64 + timestamp.nanos as f64 * 1e-9)
}
```

Apply validation in `handle_live_data_service_info` and `handle_historical_data_service_info` before storing timestamps:

```rust
fn validate_stream_progress(progress: &StreamProgress) -> Result<()> {
    for sample in &progress.samples {
        if let Some(ts) = &sample.timestamp {
            if ts.nanos < 0 || ts.nanos > 999_999_999 {
                bail!("Invalid timestamp nanoseconds: {}", ts.nanos);
            }
        }
    }
    Ok(())
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_protos::util::timestamp::Timestamp;
    
    #[test]
    fn test_invalid_nanos_causes_incorrect_calculation() {
        // Valid timestamp: 1000.5 seconds
        let valid = Timestamp { seconds: 1000, nanos: 500_000_000 };
        assert_eq!(timestamp_to_unixtime(&valid), 1000.5);
        
        // Invalid large nanos: Should be 1000.5, but calculates as 1002.0
        let invalid_large = Timestamp { seconds: 1000, nanos: 2_000_000_000 };
        assert_eq!(timestamp_to_unixtime(&invalid_large), 1002.0); // WRONG!
        
        // Invalid negative nanos: Should be 1000.5, but calculates as 999.0
        let invalid_negative = Timestamp { seconds: 1000, nanos: -1_000_000_000 };
        assert_eq!(timestamp_to_unixtime(&invalid_negative), 999.0); // WRONG!
    }
}
```

## Notes

While a validation issue exists, the security impact is minimal as this only affects off-chain indexer monitoring displays, not blockchain consensus, state, or funds. The issue does not meet the threshold for Medium severity per Aptos bug bounty criteria, though it represents a technical correctness issue that should be fixed for data integrity.

A more severe related issue exists in `is_stale_timestamp` where negative nanos values cast to u32 could cause panics, but that was not the focus of this specific security question. [7](#0-6)

### Citations

**File:** protos/proto/aptos/util/timestamp/timestamp.proto (L14-18)
```text
  // Non-negative fractions of a second at nanosecond resolution. Negative
  // second values with fractions must still have non-negative nanos values
  // that count forward in time. Must be from 0 to 999,999,999
  // inclusive.
  int32 nanos = 2;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/lib.rs (L131-133)
```rust
pub fn timestamp_to_unixtime(timestamp: &Timestamp) -> f64 {
    timestamp.seconds as f64 + timestamp.nanos as f64 * 1e-9
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/status_page/mod.rs (L94-96)
```rust
        let index = progress.samples.partition_point(|p| {
            let diff = now - timestamp_to_unixtime(p.timestamp.as_ref().unwrap());
            diff > duration.as_secs_f64()
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/status_page/mod.rs (L104-106)
```rust
            let time_diff = timestamp_to_unixtime(sample_b.timestamp.as_ref().unwrap())
                - timestamp_to_unixtime(sample_a.timestamp.as_ref().unwrap());
            let tps = (sample_b.version - sample_a.version) as f64 / time_diff;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L167-173)
```rust
    fn is_stale_timestamp(timestamp: Timestamp, threshold: Duration) -> bool {
        let timestamp_since_epoch = Duration::new(timestamp.seconds as u64, timestamp.nanos as u32);
        let now_since_epoch = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
        let staleness = now_since_epoch.saturating_sub(timestamp_since_epoch);

        staleness >= threshold
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```
