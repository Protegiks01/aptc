# Audit Report

## Title
Byzantine Peer Manipulation of HIGHEST_ADVERTISED_DATA Metric Causes Honest Nodes to Reject Valid State-Sync Data

## Summary
Byzantine peers can advertise arbitrarily high version numbers in their `StorageServerSummary` without cryptographic validation, causing the `HIGHEST_ADVERTISED_DATA` metric to be inflated. This inflated metric is used by honest nodes to validate subscription stream lag, leading to premature termination of valid state-sync streams and denial of service on state synchronization.

## Finding Description

The vulnerability exists in the state-sync data client's handling of peer storage advertisements across multiple components:

**Step 1: Unvalidated Advertisement Ingestion**

When peers are polled for their storage summaries, the `StorageServerSummary` response is accepted without signature verification of the contained `LedgerInfoWithSignatures`: [1](#0-0) 

The storage summary contains a `synced_ledger_info` field that claims the highest version the peer has synced. This field is of type `LedgerInfoWithSignatures`, but despite containing signatures, these are never verified when the summary is received from untrusted peers.

**Step 2: Unchecked Aggregation into Global Summary**

The unvalidated peer advertisements are aggregated into a global data summary without any sanity checks or bounds validation: [2](#0-1) 

**Step 3: Metric Update with Unvalidated Data**

The `HIGHEST_ADVERTISED_DATA` metric is set based on the highest version from all peer advertisements: [3](#0-2) 

The highest advertised version is determined by finding the maximum version across all advertised `synced_ledger_infos`: [4](#0-3) 

**Step 4: Invalid Validation Against Inflated Metric**

When honest nodes process subscription stream responses, they check if the stream is lagging behind the highest advertised version: [5](#0-4) 

If the honest node's received data version is lower than the Byzantine-inflated advertised version, a lag is detected: [6](#0-5) 

**Step 5: Stream Termination**

If the lag persists for longer than the configured threshold (default 10 seconds) and the lag has increased, the subscription stream is terminated as "beyond recovery": [7](#0-6) 

The default maximum lag tolerance is only 10 seconds: [8](#0-7) 

**Attack Scenario:**

1. Byzantine peer connects to the network
2. Byzantine peer advertises `StorageServerSummary` with `synced_ledger_info.version = u64::MAX` (or any arbitrarily high value)
3. Honest nodes poll this peer and accept the summary without validation
4. The global data summary now shows `highest_advertised_version = u64::MAX`
5. Honest nodes receiving valid subscription responses from other honest peers (e.g., at version 1000) detect a massive lag
6. After 10 seconds of persistent lag, subscription streams are terminated with error "The subscription stream is beyond recovery!"
7. Honest nodes cannot sync state via subscription streams, causing state-sync denial of service

This breaks the **State Consistency** invariant, as nodes cannot properly synchronize state, and could escalate to break **Consensus Safety** if nodes fall too far behind to participate in consensus.

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria due to:

1. **Significant Protocol Violations**: The state-sync protocol is fundamentally compromised, as honest nodes reject valid data based on false information from Byzantine peers.

2. **Validator Node Disruption**: Nodes relying on subscription streams for state sync will repeatedly fail to sync, causing degraded performance and potential liveness issues.

3. **Network-Wide Impact**: A single Byzantine peer can affect all honest nodes that poll it, potentially causing cascading failures across the network.

4. **Low Attack Complexity**: The attack requires only network connectivity and the ability to send a single malformed `StorageServerSummary` message - no validator privileges, stake, or complex coordination required.

While this does not directly cause fund loss, it could escalate to **Critical Severity** if:
- Enough nodes are affected to cause "Total loss of liveness/network availability"
- The disruption persists long enough to require manual intervention or a hardfork

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely to succeed because:

1. **No Cryptographic Validation**: The `LedgerInfoWithSignatures` in peer advertisements is never verified, despite containing signatures that should be checked.

2. **No Bounds Checking**: There are no sanity checks on advertised versions (e.g., comparing against the node's own synced version or checking if the advertised version is reasonably close to other peers).

3. **Automatic Trust**: The system automatically trusts and aggregates all peer advertisements into the global summary.

4. **Low Detection Probability**: The peer scoring system may eventually downgrade the Byzantine peer, but only after it has already caused damage to subscription streams.

5. **Simple Exploitation**: Any network peer can execute this attack with a single crafted message.

## Recommendation

Implement the following defense-in-depth mitigations:

**1. Validate LedgerInfoWithSignatures Signatures**

When receiving a `StorageServerSummary`, verify the signatures on the `synced_ledger_info` before accepting the advertisement. This ensures the advertised version is backed by valid validator signatures:

```rust
// In state-sync/aptos-data-client/src/poller.rs, after receiving storage_summary
if let Some(synced_ledger_info) = &storage_summary.data_summary.synced_ledger_info {
    if let Err(e) = synced_ledger_info.verify_signatures(&validator_verifier) {
        warn!("Peer advertised invalid synced_ledger_info signatures: {:?}", e);
        data_summary_poller.data_client.update_score_error(
            peer, 
            ErrorType::Malicious
        );
        return; // Reject the entire summary
    }
}
```

**2. Implement Advertised Version Bounds Checking**

Add sanity checks to reject advertisements that are unreasonably far ahead of the node's current state:

```rust
// In state-sync/aptos-data-client/src/peer_states.rs
const MAX_REASONABLE_VERSION_LAG: u64 = 1_000_000; // Configurable

pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
    if let Some(synced_ledger_info) = &storage_summary.data_summary.synced_ledger_info {
        let advertised_version = synced_ledger_info.ledger_info().version();
        let local_version = self.get_local_synced_version();
        
        if advertised_version > local_version + MAX_REASONABLE_VERSION_LAG {
            warn!("Peer {} advertised suspiciously high version: {}, local: {}", 
                  peer, advertised_version, local_version);
            // Downgrade peer score or ignore this advertisement
            return;
        }
    }
    
    // Proceed with update...
}
```

**3. Use Median/Percentile Instead of Maximum**

When calculating the global data summary, use the median or 90th percentile of advertised versions instead of the maximum. This prevents a single Byzantine peer from skewing the metric:

```rust
// In state-sync/aptos-data-client/src/global_summary.rs
pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
    if self.synced_ledger_infos.is_empty() {
        return None;
    }
    
    // Sort by version and take the median or 90th percentile
    let mut sorted_infos = self.synced_ledger_infos.clone();
    sorted_infos.sort_by_key(|info| info.ledger_info().version());
    
    // Use 90th percentile to be robust against Byzantine outliers
    let index = (sorted_infos.len() * 9) / 10;
    sorted_infos.get(index).cloned()
}
```

**4. Make Subscription Lag Check More Lenient**

Increase the `max_subscription_stream_lag_secs` or use a percentage-based threshold instead of absolute version comparison to tolerate temporary spikes in advertised versions.

## Proof of Concept

```rust
// Pseudo-code PoC demonstrating the attack

#[tokio::test]
async fn test_byzantine_peer_inflated_advertisement_attack() {
    // Setup: Create a network with honest nodes and one Byzantine peer
    let mut test_env = setup_test_environment().await;
    let byzantine_peer = test_env.add_byzantine_peer();
    let honest_node = test_env.get_honest_node(0);
    
    // Step 1: Byzantine peer advertises inflated version
    let malicious_summary = StorageServerSummary {
        protocol_metadata: ProtocolMetadata::default(),
        data_summary: DataSummary {
            synced_ledger_info: Some(create_fake_ledger_info_with_version(u64::MAX)),
            epoch_ending_ledger_infos: None,
            states: None,
            transactions: None,
            transaction_outputs: None,
        },
    };
    
    // Byzantine peer sends this when polled
    byzantine_peer.set_advertised_summary(malicious_summary);
    
    // Step 2: Honest node polls the Byzantine peer
    test_env.poll_all_peers().await;
    
    // Step 3: Verify the global data summary is poisoned
    let global_summary = honest_node.get_global_data_summary();
    assert_eq!(
        global_summary.advertised_data.highest_synced_ledger_info()
            .unwrap().ledger_info().version(),
        u64::MAX
    );
    
    // Step 4: Honest node tries to sync via subscription stream from another honest peer
    let subscription_stream = honest_node.create_subscription_stream().await;
    
    // Step 5: Honest peer sends valid data at version 1000
    let valid_response = create_valid_subscription_response(1000);
    subscription_stream.process_response(valid_response).await;
    
    // Step 6: Verify the stream detects massive lag
    // (u64::MAX - 1000 = huge lag)
    
    // Step 7: Wait for max_subscription_stream_lag_secs (10 seconds)
    tokio::time::sleep(Duration::from_secs(11)).await;
    
    // Step 8: Verify the stream is terminated with "beyond recovery" error
    let stream_result = subscription_stream.poll_next().await;
    assert!(matches!(
        stream_result,
        Err(Error::SubscriptionStreamIsLagging(_))
    ));
    
    // Attack successful: Honest node cannot sync valid data!
}

fn create_fake_ledger_info_with_version(version: u64) -> LedgerInfoWithSignatures {
    // Create a LedgerInfo with fake/invalid signatures
    // (the vulnerability is that these are never verified)
    LedgerInfoWithSignatures::new(
        LedgerInfo::new(
            BlockInfo::new(/* ... */, version, /* ... */),
            HashValue::zero(),
        ),
        AggregateSignature::empty(), // Invalid signature - but never checked!
    )
}
```

**Notes:**

This vulnerability demonstrates a critical failure in the trust model: the system trusts peer advertisements without cryptographic verification, enabling Byzantine peers to manipulate critical metrics used for data validation. The fix requires implementing proper signature verification and defensive bounds checking on all untrusted peer inputs.

### Citations

**File:** state-sync/aptos-data-client/src/poller.rs (L422-439)
```rust
        let storage_summary = match result {
            Ok(storage_summary) => storage_summary,
            Err(error) => {
                warn!(
                    (LogSchema::new(LogEntry::StorageSummaryResponse)
                        .event(LogEvent::PeerPollingError)
                        .message("Error encountered when polling peer!")
                        .error(&error)
                        .peer(&peer))
                );
                return;
            },
        };

        // Update the summary for the peer
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```

**File:** state-sync/aptos-data-client/src/poller.rs (L513-524)
```rust
    let highest_advertised_version = advertised_data
        .highest_synced_ledger_info()
        .map(|ledger_info| ledger_info.ledger_info().version());
    if let Some(highest_advertised_version) = highest_advertised_version {
        for data_type in DataType::get_all_types() {
            set_gauge(
                &metrics::HIGHEST_ADVERTISED_DATA,
                data_type.as_str(),
                highest_advertised_version,
            );
        }
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L374-378)
```rust
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L184-198)
```rust
    pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
        let highest_synced_position = self
            .synced_ledger_infos
            .iter()
            .map(|ledger_info_with_sigs| ledger_info_with_sigs.ledger_info().version())
            .position_max();

        if let Some(highest_synced_position) = highest_synced_position {
            self.synced_ledger_infos
                .get(highest_synced_position)
                .cloned()
        } else {
            None
        }
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L586-596)
```rust
        // Get the highest advertised version
        let highest_advertised_version = global_data_summary
            .advertised_data
            .highest_synced_ledger_info()
            .map(|ledger_info| ledger_info.ledger_info().version())
            .ok_or_else(|| {
                aptos_data_client::error::Error::UnexpectedErrorEncountered(
                    "The highest synced ledger info is missing from the global data summary!"
                        .into(),
                )
            })?;
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L598-631)
```rust
        // If the stream is not lagging behind, reset the lag and return
        if highest_response_version >= highest_advertised_version {
            self.reset_subscription_stream_lag();
            return Ok(());
        }

        // Otherwise, the stream is lagging behind the advertised version.
        // Check if the stream is beyond recovery (i.e., has failed).
        let current_stream_lag =
            highest_advertised_version.saturating_sub(highest_response_version);
        if let Some(mut subscription_stream_lag) = self.subscription_stream_lag.take() {
            // Check if the stream lag is beyond recovery
            if subscription_stream_lag
                .is_beyond_recovery(self.streaming_service_config, current_stream_lag)
            {
                return Err(
                    aptos_data_client::error::Error::SubscriptionStreamIsLagging(format!(
                        "The subscription stream is beyond recovery! Current lag: {:?}, last lag: {:?},",
                        current_stream_lag, subscription_stream_lag.version_lag
                    )),
                );
            }

            // The stream is lagging, but it's not yet beyond recovery
            self.set_subscription_stream_lag(subscription_stream_lag);
        } else {
            // The stream was not previously lagging, but it is now!
            let subscription_stream_lag =
                SubscriptionStreamLag::new(current_stream_lag, self.time_service.clone());
            self.set_subscription_stream_lag(subscription_stream_lag);
        }

        Ok(())
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L967-992)
```rust
    fn is_beyond_recovery(
        &mut self,
        streaming_service_config: DataStreamingServiceConfig,
        current_stream_lag: u64,
    ) -> bool {
        // Calculate the total duration the stream has been lagging
        let current_time = self.time_service.now();
        let stream_lag_duration = current_time.duration_since(self.start_time);
        let max_stream_lag_duration =
            Duration::from_secs(streaming_service_config.max_subscription_stream_lag_secs);

        // If the lag is further behind and enough time has passed, the stream has failed
        let lag_has_increased = current_stream_lag > self.version_lag;
        let lag_duration_exceeded = stream_lag_duration >= max_stream_lag_duration;
        if lag_has_increased && lag_duration_exceeded {
            return true; // The stream is beyond recovery
        }

        // Otherwise, update the stream lag if we've caught up.
        // This will ensure the lag can only improve.
        if current_stream_lag < self.version_lag {
            self.version_lag = current_stream_lag;
        }

        false // The stream is not yet beyond recovery
    }
```

**File:** config/src/config/state_sync_config.rs (L278-278)
```rust
            max_subscription_stream_lag_secs: 10, // 10 seconds
```
