# Audit Report

## Title
Stale Cache Vulnerability in Custom Package Dependencies Prevents Security Updates

## Summary
The `maybe_download_package()` function in the Aptos CLI lacks cache invalidation for custom on-chain package dependencies. Once a package is downloaded and compiled, it is never updated even when newer versions with security fixes are published on-chain, allowing vulnerable dependencies to persist indefinitely.

## Finding Description

The custom dependency resolution system in Aptos allows developers to declare dependencies on on-chain packages using the `aptos` key in their `Move.toml` manifest. When resolving these dependencies, the `maybe_download_package()` function checks if a package has been previously downloaded by testing for the existence of a `BuildInfo.yaml` file. [1](#0-0) 

The vulnerability exists in the caching logic: the function returns immediately without any action if `BuildInfo.yaml` exists, never checking whether the on-chain package has been upgraded. This is in stark contrast to git dependencies, which have explicit update mechanisms. [2](#0-1) 

The on-chain `PackageMetadata` structure includes both `upgrade_number` (incremented on each upgrade) and `source_digest` (hash of package sources) that could be used for cache validation, but these are never consulted. [3](#0-2) 

**Attack Scenario:**
1. A popular DeFi library package is published on-chain at address `0xABC`
2. Developer Alice adds it as a custom dependency: `aptos = "https://node.url"`, `address = "0xABC"`
3. First build downloads the package; compilation creates `BuildInfo.yaml`
4. A critical vulnerability is discovered in the library
5. Package maintainers publish an upgraded version on-chain (`upgrade_number` increases)
6. Alice rebuilds her project to get the fix
7. **Vulnerability**: `maybe_download_package()` sees `BuildInfo.yaml` exists and returns without updating
8. Alice compiles and deploys with the vulnerable dependency, unaware she's using an outdated version
9. Her deployed contract can be exploited through the known library vulnerability

## Impact Explanation

This vulnerability creates a **supply chain security issue** that fits the **Medium Severity** category per the Aptos bug bounty program:

- **State inconsistencies requiring intervention**: Vulnerable contracts deployed due to stale dependencies create inconsistent security postures across the blockchain state, requiring manual intervention to identify and upgrade affected contracts
- **Limited funds loss or manipulation**: While not directly causing fund loss, this enables deployment of vulnerable contracts that can later be exploited for funds theft
- **Developer tooling security**: Breaks the security guarantee that developers can obtain latest dependencies by rebuilding

The impact is Medium rather than High because:
- It requires developers to have previously built the dependency
- It doesn't affect already-deployed contracts or the blockchain consensus
- The vulnerability is in developer tooling, not the runtime execution layer
- Mitigation exists (manually deleting cache), though undiscovered by most developers

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability occurs in normal development workflows:
- Developers commonly add on-chain packages as dependencies
- Once cached, packages are never automatically refreshed
- No warning or notification system exists for upstream updates
- Developers expect dependency updates to work like git dependencies (which auto-update)
- The `skip_fetch_latest_git_deps` flag explicitly controls git updates but has no equivalent for custom dependencies

The vulnerability becomes more likely over time as:
- More packages are published and upgraded on-chain
- Security fixes become more common as the ecosystem matures  
- Developers build long-lived projects with multiple dependency upgrades

## Recommendation

Implement cache invalidation for custom dependencies by checking on-chain version metadata before using cached packages:

```rust
async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    let buildinfo_path = info
        .download_to
        .join(CompiledPackageLayout::BuildInfo.path());
    
    // Always fetch current on-chain metadata to check for updates
    let registry = CachedPackageRegistry::create(
        Url::parse(info.node_url.as_str())?,
        load_account_arg(info.package_address.as_str())?,
        false,
    )
    .await?;
    let package = registry.get_package(info.package_name).await?;
    
    if buildinfo_path.exists() {
        // Load cached package metadata
        let cached_manifest_path = info.download_to.join("Move.toml");
        if cached_manifest_path.exists() {
            // Compare upgrade_number and source_digest
            // If on-chain version is newer, re-download
            // Otherwise, use cache
        }
    }
    
    // Download if no cache or cache is stale
    package.save_package_to_disk(info.download_to.as_path())
}
```

Additionally, consider:
1. Adding a `--force-update-deps` flag to force cache refresh
2. Storing `upgrade_number` in the cached package metadata for comparison
3. Displaying warnings when on-chain packages have been upgraded since caching
4. Implementing TTL-based cache expiration
5. Documenting the cache behavior clearly for developers

## Proof of Concept

**Setup Steps:**

1. **Publish initial vulnerable package:**
```move
// vulnerable_lib v1 with vulnerability
module 0xABC::vulnerable_lib {
    public fun unsafe_transfer(amount: u64) {
        // Vulnerable: missing access control
        // ...
    }
}
```

2. **Create dependent package with Move.toml:**
```toml
[package]
name = "MyDApp"

[dependencies]
vulnerable_lib = { aptos = "https://fullnode.devnet.aptoslabs.com", address = "0xABC" }
```

3. **First build - caches vulnerable version:**
```bash
$ aptos move compile
# Downloads vulnerable_lib, creates BuildInfo.yaml
# Compilation succeeds with v1
```

4. **Publish fixed package on-chain:**
```move
// vulnerable_lib v2 with fix
module 0xABC::vulnerable_lib {
    public fun unsafe_transfer(sender: &signer, amount: u64) {
        // Fixed: added access control
        // ...
    }
}
```

5. **Rebuild - demonstrates stale cache:**
```bash
$ aptos move compile
# BuildInfo.yaml exists, no update occurs
# Still compiling against vulnerable v1
# No error, no warning - silent use of stale dependency
```

6. **Verification:**
```bash
# Check cached package still has v1 code
$ cat ~/.move/devnet_0xABC_vulnerable_lib/sources/vulnerable_lib.move
# Shows old vulnerable code without access control

# On-chain package shows v2
$ aptos move view --function-id 0xABC::vulnerable_lib::get_upgrade_number
# Returns 2 (upgraded)
```

**Expected vs Actual Behavior:**
- **Expected**: Rebuild fetches upgraded package v2 with security fix
- **Actual**: Rebuild uses cached v1, developer unknowingly deploys vulnerable contract

## Notes

This vulnerability highlights a critical gap between git dependency handling (which has auto-update logic) and custom on-chain dependency handling (which has none). The `download_and_update_if_remote()` function explicitly updates git dependencies but only calls `resolve_custom_dependency()` for custom dependencies without any update logic. [4](#0-3) 

The compilation system creates `BuildInfo.yaml` after successful compilation, which is then used as the cache existence check: [5](#0-4) 

This creates a permanent cache without any invalidation mechanism tied to on-chain package upgrades.

### Citations

**File:** crates/aptos/src/move_tool/package_hooks.rs (L38-55)
```rust
async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    if !info
        .download_to
        .join(CompiledPackageLayout::BuildInfo.path())
        .exists()
    {
        let registry = CachedPackageRegistry::create(
            Url::parse(info.node_url.as_str())?,
            load_account_arg(info.package_address.as_str())?,
            false,
        )
        .await?;
        let package = registry.get_package(info.package_name).await?;
        package.save_package_to_disk(info.download_to.as_path())
    } else {
        Ok(())
    }
}
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L577-610)
```rust
            } else if !skip_fetch_latest_git_deps {
                // Confirm git is available.
                git::confirm_git_available()?;

                // Update the git dependency
                // Check first that it isn't a git rev (if it doesn't work, just continue with the fetch)
                if let Ok(parsed_rev) = git::find_rev(git_path, git_rev) {
                    // If it's exactly the same, then it's a git rev
                    if parsed_rev.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                if let Ok(tag) = git::find_tag(git_path, git_rev) {
                    // If it's exactly the same, then it's a git tag, for now tags won't be updated
                    // Tags don't easily update locally and you can't use reset --hard to cleanup
                    // any extra files
                    if tag.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                writeln!(
                    writer,
                    "{} {}",
                    "UPDATING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;
                // If the current folder exists, do a fetch and reset to ensure that the branch
                // is up to date
                // NOTE: this means that you must run the package system with a working network connection
                git::fetch_origin(git_path, dep_name)?;
                git::reset_hard(git_path, git_rev, dep_name)?;
            }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L612-614)
```rust
        if let Some(node_info) = &dep.node_info {
            package_hooks::resolve_custom_dependency(dep_name, node_info)?
        }
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L122-143)
```rust
impl CachedPackageMetadata<'_> {
    pub fn name(&self) -> &str {
        &self.metadata.name
    }

    pub fn upgrade_policy(&self) -> UpgradePolicy {
        self.metadata.upgrade_policy
    }

    pub fn upgrade_number(&self) -> u64 {
        self.metadata.upgrade_number
    }

    pub fn source_digest(&self) -> &str {
        &self.metadata.source_digest
    }

    pub fn manifest(&self) -> anyhow::Result<String> {
        unzip_metadata_str(&self.metadata.manifest)
    }

    pub fn module_names(&self) -> Vec<&str> {
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L900-903)
```rust
        on_disk_package.save_under(
            CompiledPackageLayout::BuildInfo.path(),
            serde_yaml::to_string(&on_disk_package.package)?.as_bytes(),
        )?;
```
