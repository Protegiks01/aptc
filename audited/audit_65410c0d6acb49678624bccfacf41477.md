# Audit Report

## Title
WebAuthn Authenticator Data Validation Bypass - Protocol Security Guarantees Not Enforced

## Summary
The WebAuthn signature verification implementation in Aptos Core fails to validate the authenticator data structure according to the W3C WebAuthn specification. This allows transactions to be submitted with malformed or empty authenticator data, completely bypassing the user presence and user verification checks that are fundamental to WebAuthn's security model.

## Finding Description

The WebAuthn implementation has two validation layers that both fail to properly validate authenticator data:

**API Layer Validation Failure:** [1](#0-0) 

This verification only checks length bounds (public key must be exactly `PUBLIC_KEY_LENGTH`, signature must not exceed `MAX_WEBAUTHN_SIGNATURE_BYTES`). Critically, there is no minimum length check and no structural validation. The TODO comment explicitly acknowledges this gap: "Check if they match / parse correctly?"

**Core Verification Failure:** [2](#0-1) 

The `generate_verification_data` function blindly concatenates raw authenticator data bytes without any validation of the WebAuthn authenticator data structure. [3](#0-2) 

The verification process validates the cryptographic signature and challenge but never parses or validates the authenticator data structure defined by the WebAuthn specification.

**WebAuthn Specification Requirements (Not Enforced):**

According to W3C WebAuthn specification, authenticator data must contain:
- Bytes 0-31: RP ID hash (32 bytes)
- Byte 32: Flags byte containing:
  - Bit 0: User Present (UP) flag
  - Bit 2: User Verified (UV) flag  
  - Bit 6: Attested Credential Data (AT) flag
  - Bit 7: Extension Data (ED) flag
- Bytes 33-36: Signature counter (4 bytes)
- Bytes 37+: Optional extensions

**Minimum length: 37 bytes**

**Attack Scenario:**

An attacker with access to a Secp256r1 private key (either through key extraction, malware, or compromise) can:

1. Create a `PartialAuthenticatorAssertionResponse` with:
   - `authenticator_data`: Empty vector or minimal bytes with flags=0x00 (no user present/verified)
   - `client_data_json`: Valid JSON with correct challenge
   - `signature`: Valid Secp256r1 ECDSA signature over the malformed verification data

2. BCS-encode this structure
3. Submit as a WebAuthn transaction

The transaction will be accepted because:
- API validation only checks maximum length, not structure
- BCS deserialization accepts any valid byte vector
- Core verification only validates the cryptographic signature, not authenticator data structure
- No flags are checked, no signature counter is validated

This completely defeats WebAuthn's security model where:
- User presence must be confirmed by the authenticator
- User verification (biometric/PIN) can be required
- Signature counters detect cloned authenticators

## Impact Explanation

**Severity: HIGH** - This qualifies as a "Significant protocol violation" under the Aptos bug bounty program.

**Security Guarantees Violated:**

1. **User Presence Bypass**: WebAuthn requires proof that the user was present during signing. Without validating the UP flag in authenticator data, an attacker with a compromised key can sign transactions without user interaction.

2. **User Verification Bypass**: Applications may require user verification (biometric/PIN). Without validating the UV flag, this requirement is meaningless.

3. **Cloned Authenticator Detection Failure**: The signature counter is designed to detect cloned authenticators. Without validation, cloned authenticators cannot be detected.

4. **Misleading Security Model**: Users and applications believe WebAuthn provides strong security guarantees, but the implementation provides no more security than a plain Secp256r1 signature.

**Invariant Broken:**
- **Transaction Validation Invariant**: "Prologue/epilogue checks must enforce all invariants"
- **Cryptographic Correctness Invariant**: WebAuthn signatures must be validated according to specification

While this doesn't directly cause consensus splits (all nodes use the same broken validation), it violates the protocol's security contract with users.

## Likelihood Explanation

**Likelihood: Medium-High**

**Exploitation Requirements:**
- Attacker needs access to a Secp256r1 private key (through malware, key extraction, or compromise)
- Ability to submit transactions to the network
- Knowledge of the missing validation (now disclosed)

**Realistic Attack Scenarios:**

1. **Malware on User Device**: Malware with access to wallet private keys can create and submit transactions without user confirmation via authenticator, bypassing the intended security model.

2. **Compromised Key Recovery**: If an attacker extracts a private key from secure hardware, they can use it without needing physical access to the authenticator or user interaction.

3. **Automated Transaction Signing**: Applications expecting WebAuthn's user interaction guarantees can be bypassed, enabling automated transaction signing where user confirmation should be required.

The attack is technically straightforward once the vulnerability is known - it requires only basic knowledge of the WebAuthn structure and BCS encoding.

## Recommendation

Implement proper WebAuthn authenticator data validation in the verification flow:

**Minimum Required Fixes:**

1. **Add structural validation** in `types/src/transaction/webauthn.rs`:
   - Parse authenticator data according to WebAuthn spec
   - Validate minimum length (37 bytes)
   - Extract and verify flags byte
   - Optionally validate RP ID hash and signature counter

2. **Remove the TODO** in `api/types/src/transaction.rs` and implement proper parsing:
   - Attempt to BCS-deserialize the signature into `PartialAuthenticatorAssertionResponse`
   - Validate authenticator data meets minimum WebAuthn requirements

3. **Add flag validation** - at minimum, verify:
   - User Present (UP) flag is set (bit 0 of flags byte = 1)
   - For high-security transactions, require User Verified (UV) flag (bit 2 = 1)

4. **Consider signature counter tracking** for clone detection (stored in account resource)

**Code Fix Example:**

```rust
// In types/src/transaction/webauthn.rs
const MIN_AUTHENTICATOR_DATA_LEN: usize = 37;
const FLAGS_BYTE_OFFSET: usize = 32;
const USER_PRESENT_FLAG: u8 = 0x01;
const USER_VERIFIED_FLAG: u8 = 0x04;

fn validate_authenticator_data(authenticator_data: &[u8]) -> Result<()> {
    if authenticator_data.len() < MIN_AUTHENTICATOR_DATA_LEN {
        bail!("Authenticator data too short: {} bytes, minimum {} bytes required",
              authenticator_data.len(), MIN_AUTHENTICATOR_DATA_LEN);
    }
    
    let flags = authenticator_data[FLAGS_BYTE_OFFSET];
    
    // Require User Present flag
    if flags & USER_PRESENT_FLAG == 0 {
        bail!("User Present flag not set in authenticator data");
    }
    
    // Optionally require User Verified flag for enhanced security
    // if flags & USER_VERIFIED_FLAG == 0 {
    //     bail!("User Verified flag not set in authenticator data");
    // }
    
    Ok(())
}

// Call this in PartialAuthenticatorAssertionResponse::verify()
pub fn verify<T: Serialize + CryptoHash>(&self, message: &T, public_key: &AnyPublicKey) -> Result<()> {
    // Add validation at the start
    validate_authenticator_data(&self.authenticator_data)?;
    
    // ... rest of existing verification
}
```

## Proof of Concept

```rust
#[test]
fn test_webauthn_malformed_authenticator_data_bypass() {
    use aptos_crypto::{secp256r1_ecdsa::{PrivateKey, PublicKey}, Uniform};
    use rand::{rngs::StdRng, SeedableRng};
    
    let mut rng: StdRng = SeedableRng::from_seed([0; 32]);
    let private_key = PrivateKey::generate(&mut rng);
    let public_key = private_key.public_key();
    
    // Create valid client_data_json with challenge
    let client_data_json = br#"{"type":"webauthn.get","challenge":"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA","origin":"http://localhost:4000","crossOrigin":false}"#;
    
    // Create MALFORMED authenticator data - empty vector (should fail but doesn't!)
    let malformed_authenticator_data: Vec<u8> = vec![];
    
    // Alternative: Minimal authenticator data with all flags = 0x00 (no user present/verified)
    // let malformed_authenticator_data: Vec<u8> = vec![0u8; 37]; // 37 zero bytes
    
    // Generate verification data from malformed authenticator data
    let client_data_hash = sha256(client_data_json);
    let verification_data = [malformed_authenticator_data.as_slice(), &client_data_hash].concat();
    
    // Sign with private key - this WILL succeed
    let signature = private_key.sign_arbitrary_message(&verification_data);
    
    // Create PartialAuthenticatorAssertionResponse
    let paar = PartialAuthenticatorAssertionResponse::new(
        AssertionSignature::Secp256r1Ecdsa { signature },
        malformed_authenticator_data,
        client_data_json.to_vec(),
    );
    
    // BCS encode as the signature field
    let signature_bytes = paar.to_bytes();
    
    // Create API WebAuthnSignature
    let webauthn_sig = WebAuthnSignature {
        public_key: HexEncodedBytes::from(public_key.to_bytes().to_vec()),
        signature: HexEncodedBytes::from(signature_bytes),
    };
    
    // API validation - SHOULD FAIL but PASSES
    assert!(webauthn_sig.verify().is_ok(), "API validation should catch malformed authenticator data but doesn't!");
    
    // Core verification would also pass because signature is cryptographically valid
    // This demonstrates the vulnerability: empty/malformed authenticator data is accepted
}
```

**Notes:**
- This vulnerability affects all WebAuthn transactions on the Aptos network
- The issue exists in both API-layer validation and core verification logic  
- While cryptographic signatures remain valid, the WebAuthn security model is completely bypassed
- Users and applications relying on WebAuthn's user presence/verification guarantees are at risk
- The TODO comment in the code suggests this was a known incomplete implementation

### Citations

**File:** api/types/src/transaction.rs (L1488-1507)
```rust
    fn verify(&self) -> anyhow::Result<()> {
        let public_key_len = self.public_key.inner().len();
        let signature_len = self.signature.inner().len();

        // Currently only takes Secp256r1Ecdsa. If other signature schemes are introduced, modify this to accommodate them
        if public_key_len != PUBLIC_KEY_LENGTH {
            bail!(
                "The public key provided is an invalid number of bytes, should be {} bytes but found {}. Note WebAuthn signatures only support Secp256r1Ecdsa at this time.",
                secp256r1_ecdsa::PUBLIC_KEY_LENGTH, public_key_len
            )
        } else if signature_len > MAX_WEBAUTHN_SIGNATURE_BYTES {
            bail!(
                "The WebAuthn signature length is greater than the maximum number of {} bytes: found {} bytes.",
                MAX_WEBAUTHN_SIGNATURE_BYTES, signature_len
            )
        } else {
            // TODO: Check if they match / parse correctly?
            Ok(())
        }
    }
```

**File:** types/src/transaction/webauthn.rs (L14-29)
```rust
/// Returns the binary concatenation of
/// 1. [`authenticator_data_bytes`](PartialAuthenticatorAssertionResponse) and
/// 2. SHA-256 hash of [`client_data_json`](PartialAuthenticatorAssertionResponse),
///
/// See <https://www.w3.org/TR/webauthn-3/#sctn-verifying-assertion>
fn generate_verification_data(authenticator_data_bytes: &[u8], client_data_json: &[u8]) -> Vec<u8> {
    // Let hash be the result of computing a hash over the clientData using SHA-256.
    let client_data_json_hash = sha256(client_data_json);
    // Binary concatenation of authData and hash.
    // Note: This is compatible with signatures generated by FIDO U2F
    // authenticators. See ยง6.1.2 FIDO U2F Signature Format Compatibility
    // See <https://www.w3.org/TR/webauthn-3/#sctn-fido-u2f-sig-format-compat>
    [authenticator_data_bytes, &client_data_json_hash]
        .concat()
        .to_vec()
}
```

**File:** types/src/transaction/webauthn.rs (L134-165)
```rust
    pub fn verify<T: Serialize + CryptoHash>(
        &self,
        message: &T,
        public_key: &AnyPublicKey,
    ) -> Result<()> {
        let collected_client_data: CollectedClientData =
            serde_json::from_slice(self.client_data_json.as_slice())?;
        let challenge_bytes = Bytes::try_from(collected_client_data.challenge.as_str())
            .map_err(|e| anyhow!("Failed to decode challenge bytes {:?}", e))?;

        // Check if expected challenge and actual challenge match. If there's no match, throw error
        verify_expected_challenge_from_message_matches_actual(message, challenge_bytes.as_slice())?;

        // Generates binary concatenation of authenticator_data and hash(client_data_json)
        let verification_data = generate_verification_data(
            self.authenticator_data.as_slice(),
            self.client_data_json.as_slice(),
        );

        // Note: We must call verify_arbitrary_msg instead of verify here. We do NOT want to
        // use verify because it BCS serializes and prefixes the message with a hash
        // via the signing_message function invocation
        match (&public_key, &self.signature) {
            (
                AnyPublicKey::Secp256r1Ecdsa { public_key },
                AssertionSignature::Secp256r1Ecdsa { signature },
            ) => signature.verify_arbitrary_msg(&verification_data, public_key),
            _ => Err(anyhow!(
                "WebAuthn verification failure, invalid key, signature pairing"
            )),
        }
    }
```
