# Audit Report

## Title
Missing Runtime Validation for Duplicate Consensus Public Keys Causes BLS Signature Verification Failures

## Summary
The Aptos validator system lacks runtime validation to prevent duplicate `consensus_public_key` values across multiple validators. When duplicate consensus keys exist (with validators using different private keys), BLS signature aggregation verification fails for legitimate votes, potentially causing consensus liveness failures and network partition.

## Finding Description

The staking system allows validators to update their consensus public keys via `rotate_consensus_key()` without checking if another validator already uses the same public key. [1](#0-0) 

Similarly, when validators join the validator set, no duplicate key validation occurs. [2](#0-1) 

During epoch transitions, the system processes pending validators without checking for duplicate consensus keys. [3](#0-2) 

While genesis validation checks for duplicate consensus keys, [4](#0-3)  this invariant is not enforced during runtime operations.

**BLS Signature Aggregation Failure Mechanism:**

When `ValidatorVerifier` aggregates signatures from validators with duplicate public keys but different private keys:

1. The aggregation function collects all signatures: [5](#0-4) 

2. During verification, public keys are extracted based on the signer bitmask: [6](#0-5) 

3. If Validator A has keypair (sk_A, pk_A) and Validator B has keypair (sk_B, pk_B) but ValidatorSet records both with pk_A:
   - B's signature σ_B = sk_B * H(m) is created with sk_B
   - But the verifier aggregates pk_A for both validators: pk_agg = pk_A + pk_A + ...
   - Verification fails because e(σ_B, g) = e(H(m), pk_B) ≠ e(H(m), pk_A)

The BLS signature aggregation implementation assumes all public keys in the validator set are unique: [7](#0-6) 

## Impact Explanation

**Severity: High** - This constitutes a significant protocol violation under the Aptos bug bounty program.

When duplicate consensus keys exist:
- **Consensus Safety Violation**: Legitimate votes from honest validators fail cryptographic verification
- **Liveness Risk**: If validators with duplicate keys represent significant voting power, the network may fail to reach quorum
- **Breaks Invariant**: Violates "Cryptographic Correctness: BLS signatures, VRF, and hash operations must be secure"

However, this does not reach Critical severity because:
- It requires validator operator access to create the duplicate key condition
- It does not directly cause fund loss or permanent network partition (can be recovered by key rotation)

## Likelihood Explanation

**Likelihood: Low to Medium**

This can occur through:
1. **Operator Error**: Copy-paste mistakes when configuring consensus keys
2. **Key Recovery Issues**: Operators accidentally using another validator's key during key rotation
3. **Configuration Management Bugs**: Automated systems setting duplicate keys

The likelihood is reduced by:
- Validator operators are typically sophisticated entities with operational procedures
- Genesis validation catches duplicates during initial setup
- Requires specific error patterns in key management

However, the complete absence of runtime validation creates a significant gap, especially as the validator set grows and operational complexity increases.

## Recommendation

Add duplicate consensus key validation in three locations:

**1. In `rotate_consensus_key()`:**
```move
public entry fun rotate_consensus_key(
    operator: &signer,
    pool_address: address,
    new_consensus_pubkey: vector<u8>,
    proof_of_possession: vector<u8>,
) acquires StakePool, ValidatorConfig, ValidatorSet {
    // ... existing checks ...
    
    // Add validation before line 932
    let validator_set = borrow_global<ValidatorSet>(@aptos_framework);
    assert!(
        !consensus_key_exists_in_validator_set(validator_set, &new_consensus_pubkey, pool_address),
        error::invalid_argument(EDUPLICATE_CONSENSUS_KEY)
    );
    
    validator_info.consensus_pubkey = new_consensus_pubkey;
    // ... rest of function ...
}

fun consensus_key_exists_in_validator_set(
    validator_set: &ValidatorSet, 
    consensus_pubkey: &vector<u8>,
    excluding_address: address
): bool {
    // Check active, pending_active, and pending_inactive validators
    // Return true if any validator (except excluding_address) has the same key
}
```

**2. In `join_validator_set_internal()`** - Add check at line 1083 before adding to pending_active

**3. Add error constant:**
```move
const EDUPLICATE_CONSENSUS_KEY: u64 = 30;
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, validator_1 = @0x123, validator_2 = @0x234)]
fun test_duplicate_consensus_keys_cause_verification_failure(
    aptos_framework: &signer,
    validator_1: &signer,
    validator_2: &signer,
) acquires ValidatorSet, StakePool, ValidatorConfig, ... {
    // Initialize framework
    initialize_for_test(aptos_framework);
    
    // Validator 1 joins with key pk_1
    let (sk_1, pk_1, pop_1) = generate_identity();
    initialize_test_validator(&pk_1, &pop_1, validator_1, 100, true, true);
    
    // Validator 2 joins with key pk_2
    let (sk_2, pk_2, pop_2) = generate_identity();  
    initialize_test_validator(&pk_2, &pop_2, validator_2, 100, true, true);
    
    // Validator 2's operator accidentally rotates to pk_1 (duplicate!)
    // This currently succeeds but shouldn't
    rotate_consensus_key(validator_2, signer::address_of(validator_2), 
                        bls12381::public_key_to_bytes(&pk_1), 
                        bls12381::proof_of_possession_to_bytes(&pop_1));
    
    // Move to next epoch to activate the duplicate key
    end_epoch();
    
    // Now both validators have pk_1 in ValidatorSet
    // But validator_2 still has sk_2, validator_1 has sk_1
    // Any signature from validator_2 will fail verification
    // because the system expects it to be signed with sk_1
}
```

**Note:** This vulnerability requires validator operator access to create duplicate keys, which does not meet the strict criterion of being "exploitable by unprivileged attacker." However, it represents a critical gap in invariant enforcement that should be addressed.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L910-952)
```text
    public entry fun rotate_consensus_key(
        operator: &signer,
        pool_address: address,
        new_consensus_pubkey: vector<u8>,
        proof_of_possession: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);

        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));

        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_consensus_pubkey = validator_info.consensus_pubkey;
        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            new_consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));
        validator_info.consensus_pubkey = new_consensus_pubkey;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                RotateConsensusKey {
                    pool_address,
                    old_consensus_pubkey,
                    new_consensus_pubkey,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.rotate_consensus_key_events,
                RotateConsensusKeyEvent {
                    pool_address,
                    old_consensus_pubkey,
                    new_consensus_pubkey,
                },
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1059-1104)
```text
    public(friend) fun join_validator_set_internal(
        operator: &signer,
        pool_address: address
    ) acquires StakePool, ValidatorConfig, ValidatorSet {
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(
            get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE,
            error::invalid_state(EALREADY_ACTIVE_VALIDATOR),
        );

        let config = staking_config::get();
        let (minimum_stake, maximum_stake) = staking_config::get_required_stake(&config);
        let voting_power = get_next_epoch_voting_power(stake_pool);
        assert!(voting_power >= minimum_stake, error::invalid_argument(ESTAKE_TOO_LOW));
        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_TOO_HIGH));

        // Track and validate voting power increase.
        update_voting_power_increase(voting_power);

        // Add validator to pending_active, to be activated in the next epoch.
        let validator_config = borrow_global<ValidatorConfig>(pool_address);
        assert!(!vector::is_empty(&validator_config.consensus_pubkey), error::invalid_argument(EINVALID_PUBLIC_KEY));

        // Validate the current validator set size has not exceeded the limit.
        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
        vector::push_back(
            &mut validator_set.pending_active,
            generate_validator_info(pool_address, stake_pool, *validator_config)
        );
        let validator_set_size = vector::length(&validator_set.active_validators) + vector::length(
            &validator_set.pending_active
        );
        assert!(validator_set_size <= MAX_VALIDATOR_SET_SIZE, error::invalid_argument(EVALIDATOR_SET_TOO_LARGE));

        if (std::features::module_event_migration_enabled()) {
            event::emit(JoinValidatorSet { pool_address });
        } else {
            event::emit_event(
                &mut stake_pool.join_validator_set_events,
                JoinValidatorSetEvent { pool_address },
            );
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1364-1401)
```text
        append(&mut validator_set.active_validators, &mut validator_set.pending_active);

        // Officially deactivate all pending_inactive validators. They will now no longer receive rewards.
        validator_set.pending_inactive = vector::empty();

        // Update active validator set so that network address/public key change takes effect.
        // Moreover, recalculate the total voting power, and deactivate the validator whose
        // voting power is less than the minimum required stake.
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** crates/aptos/src/genesis/mod.rs (L750-758)
```rust
            if !unique_consensus_keys
                .insert(validator.consensus_public_key.as_ref().unwrap().clone())
            {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a repeated a consensus public key {}",
                    name,
                    validator.consensus_public_key.as_ref().unwrap()
                )));
            }
```

**File:** types/src/validator_verifier.rs (L316-335)
```rust
    pub fn aggregate_signatures<'a>(
        &self,
        signatures: impl Iterator<Item = (&'a AccountAddress, &'a bls12381::Signature)>,
    ) -> Result<AggregateSignature, VerifyError> {
        let mut sigs = vec![];
        let mut masks = BitVec::with_num_bits(self.len() as u16);
        for (addr, sig) in signatures {
            let index = *self
                .address_to_validator_index
                .get(addr)
                .ok_or(VerifyError::UnknownAuthor)?;
            masks.set(index as u16);
            sigs.push(sig.clone());
        }
        // Perform an optimistic aggregation of the signatures without verification.
        let aggregated_sig = bls12381::Signature::aggregate(sigs)
            .map_err(|_| VerifyError::FailedToAggregateSignature)?;

        Ok(AggregateSignature::new(masks, Some(aggregated_sig)))
    }
```

**File:** types/src/validator_verifier.rs (L352-361)
```rust
        let mut pub_keys = vec![];
        let mut authors = vec![];
        for index in multi_signature.get_signers_bitvec().iter_ones() {
            let validator = self
                .validator_infos
                .get(index)
                .ok_or(VerifyError::UnknownAuthor)?;
            authors.push(validator.address);
            pub_keys.push(validator.public_key());
        }
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_sigs.rs (L64-76)
```rust
    /// Optimistically-aggregate signatures shares into either (1) a multisignature or (2) an aggregate
    /// signature. The individual signature shares could be adversarial. Nonetheless, for performance
    /// reasons, we do not subgroup-check the signature shares here, since the verification of the
    /// returned multi-or-aggregate signature includes such a subgroup check. As a result, adversarial
    /// signature shares cannot lead to forgeries.
    pub fn aggregate(sigs: Vec<Self>) -> Result<Signature> {
        let sigs: Vec<_> = sigs.iter().map(|s| &s.sig).collect();
        let agg_sig = blst::min_pk::AggregateSignature::aggregate(&sigs[..], false)
            .map_err(|e| anyhow!("{:?}", e))?;
        Ok(Signature {
            sig: agg_sig.to_signature(),
        })
    }
```
