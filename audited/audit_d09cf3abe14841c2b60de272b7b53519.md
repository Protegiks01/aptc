# Audit Report

## Title
RPC Flood Attack Enables Single Byzantine Validator to Cause Liveness Degradation Through Concurrent Request Exhaustion

## Summary
A Byzantine validator can flood a target validator with small RPC requests to exhaust the per-connection concurrent RPC limit (100 requests), preventing legitimate consensus messages from being processed and causing validator liveness degradation.

## Finding Description

The network layer implements RPC handling with a fixed concurrency limit but lacks per-message rate limiting. The vulnerability exists in how inbound RPC requests are processed:

**Concurrent RPC Limit**: Each peer connection enforces a hard limit on concurrent inbound RPCs: [1](#0-0) 

When this limit is reached, new inbound RPC requests are immediately dropped: [2](#0-1) 

**Missing Per-Message Rate Limiting**: The system only implements byte-level rate limiting (optional, default 100 KiB/s), not per-RPC-message count limiting: [3](#0-2) 

**Attack Vector**: A Byzantine validator can exploit this by:
1. Sending continuous small RPC requests (e.g., 1 KB each) to a target validator
2. Each request occupies one of the 100 concurrent RPC slots for up to 10 seconds (timeout): [4](#0-3) 
3. By sending ~10 small RPCs per second (10 KB/s total), the attacker stays well under the byte rate limit (100 KiB/s) but maintains all 100 concurrent slots occupied
4. When legitimate consensus RPCs (proposals, votes, block retrieval) arrive, they are dropped because the concurrent limit is exhausted
5. This prevents the target validator from participating effectively in consensus

**Consensus Protocol Impact**: Consensus messages use the same RPC mechanism: [5](#0-4) 

The `send_rpc()` function creates outbound RPC requests that rely on the peer's ability to receive them: [6](#0-5) 

## Impact Explanation

**Severity: High** - Validator node slowdowns and significant protocol violations.

This vulnerability allows a single Byzantine validator to degrade the liveness of honest validators by preventing them from receiving critical consensus messages. While AptosBFT is designed to tolerate up to 1/3 Byzantine validators, this attack enables disproportionate impact:

- A single malicious validator can target multiple honest validators simultaneously
- Affected validators miss proposals, cannot vote, and fail to retrieve blocks
- If enough validators are targeted (even if < 1/3 are malicious), chain progress can be severely degraded
- The attack is stealthy and difficult to distinguish from network issues

This falls under "Validator node slowdowns" and "Significant protocol violations" in the High Severity category.

## Likelihood Explanation

**Likelihood: Medium-High**

**Requirements for attack:**
- Attacker must be a validator (or compromise a validator) in the validator network
- Attack is simple: continuously send small RPC requests
- Low resource cost: 10 KB/s bandwidth per target, minimal computation
- High impact: Can effectively silence targeted validators

**Detection difficulty:**
- Attack traffic looks like legitimate RPCs (small, valid protocol messages)
- Byte-level rate limiting won't trigger (10 KB/s << 100 KiB/s limit)
- Metrics show high RPC volume but within normal parameters
- Difficult to distinguish from network congestion or slow peer

**Practical feasibility:**
- No coordination required (single attacker)
- Can target multiple validators in parallel
- Sustainable indefinitely with minimal resources
- No requirement for sophisticated attack tools

## Recommendation

Implement per-protocol per-peer RPC message rate limiting:

```rust
// In constants.rs
pub const MAX_INBOUND_RPC_RATE_PER_SECOND: u32 = 50;  // Max RPC messages per second per peer

// In InboundRpcs struct
struct InboundRpcs {
    // ... existing fields ...
    /// Token bucket for rate limiting RPC messages per second
    rpc_rate_limiter: TokenBucket,
}

impl InboundRpcs {
    pub fn handle_inbound_request(&mut self, ...) -> Result<(), RpcError> {
        // Check rate limit before checking concurrent limit
        if !self.rpc_rate_limiter.try_consume(1) {
            counters::rpc_messages(network_context, REQUEST_LABEL, INBOUND_LABEL, "rate_limited").inc();
            return Err(RpcError::RateLimitExceeded);
        }
        
        // Existing concurrent limit check
        if self.inbound_rpc_tasks.len() as u32 == self.max_concurrent_inbound_rpcs {
            // ... existing code ...
        }
        // ... rest of function ...
    }
}
```

**Additional recommendations:**
1. Add separate, higher rate limits for critical consensus protocols
2. Implement adaptive rate limiting based on peer behavior patterns
3. Add metrics for per-peer RPC rates to detect flood attempts
4. Consider implementing backpressure signals to upstream protocol handlers
5. Separate critical consensus RPC channels from general-purpose RPCs

## Proof of Concept

```rust
// Proof of Concept: Byzantine validator flooding honest validator with RPCs
// This would be implemented as a test in network/framework/src/protocols/rpc/mod.rs

#[tokio::test]
async fn test_rpc_flood_exhausts_concurrent_slots() {
    // Setup: Create two connected peers (attacker and victim)
    let (attacker_peer, victim_peer) = create_test_peer_pair().await;
    
    // Attacker: Send 100 small RPC requests without waiting for responses
    let mut flood_tasks = vec![];
    for i in 0..100 {
        let req = create_small_rpc_request(i); // 1 KB payload
        let task = attacker_peer.send_rpc(victim_peer.id(), CONSENSUS_PROTOCOL, req, Duration::from_secs(10));
        flood_tasks.push(task);
    }
    
    // Wait for all flood RPCs to be enqueued (but not completed)
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // Victim now has 100 concurrent inbound RPCs pending
    // Try to send a legitimate consensus RPC
    let legitimate_rpc = create_consensus_proposal();
    let result = attacker_peer.send_rpc(
        victim_peer.id(),
        CONSENSUS_PROTOCOL,
        legitimate_rpc,
        Duration::from_secs(1)
    ).await;
    
    // Assert: The legitimate RPC is dropped due to concurrent limit
    assert!(matches!(result, Err(RpcError::TooManyPending(100))));
    
    // Victim validator cannot receive consensus messages while flooded
    // This demonstrates liveness degradation
}
```

## Notes

The vulnerability is particularly concerning because:

1. **Stealthiness**: The attack uses valid protocol messages at rates that don't trigger byte-level limits
2. **Asymmetric cost**: Attacker spends minimal resources (10 KB/s) to block significant validator functionality
3. **Cascading effects**: If multiple validators are targeted, overall chain liveness degrades
4. **Byzantine fault amplification**: A single Byzantine validator can effectively silence multiple honest validators, exceeding the 1/3 fault tolerance threshold in practice

The current rate limiting focuses on bandwidth (bytes/second) rather than message frequency, which is insufficient for protecting against small, high-frequency message floods. The 100 concurrent RPC limit provides some protection but is too high to prevent effective flooding with the 10-second timeout window.

### Citations

**File:** network/framework/src/constants.rs (L10-11)
```rust
/// The timeout for any inbound RPC call before it's cut off
pub const INBOUND_RPC_TIMEOUT_MS: u64 = 10_000;
```

**File:** network/framework/src/constants.rs (L14-15)
```rust
/// Limit on concurrent Inbound RPC requests before backpressure is applied
pub const MAX_CONCURRENT_INBOUND_RPCS: u32 = 100;
```

**File:** network/framework/src/protocols/rpc/mod.rs (L212-223)
```rust
        // Drop new inbound requests if our completion queue is at capacity.
        if self.inbound_rpc_tasks.len() as u32 == self.max_concurrent_inbound_rpcs {
            // Increase counter of declined requests
            counters::rpc_messages(
                network_context,
                REQUEST_LABEL,
                INBOUND_LABEL,
                DECLINED_LABEL,
            )
            .inc();
            return Err(RpcError::TooManyPending(self.max_concurrent_inbound_rpcs));
        }
```

**File:** config/src/config/network_config.rs (L368-377)
```rust
pub struct RateLimitConfig {
    /// Maximum number of bytes/s for an IP
    pub ip_byte_bucket_rate: usize,
    /// Maximum burst of bytes for an IP
    pub ip_byte_bucket_size: usize,
    /// Initial amount of tokens initially in the bucket
    pub initial_bucket_fill_percentage: u8,
    /// Allow for disabling the throttles
    pub enabled: bool,
}
```

**File:** consensus/src/network_interface.rs (L158-160)
```rust
    ProtocolId::ConsensusRpcCompressed,
    ProtocolId::ConsensusRpcBcs,
    ProtocolId::ConsensusRpcJson,
```

**File:** network/framework/src/peer_manager/senders.rs (L89-108)
```rust
    pub async fn send_rpc(
        &self,
        peer_id: PeerId,
        protocol_id: ProtocolId,
        req: Bytes,
        timeout: Duration,
    ) -> Result<Bytes, RpcError> {
        let (res_tx, res_rx) = oneshot::channel();
        let request = OutboundRpcRequest {
            protocol_id,
            data: req,
            res_tx,
            timeout,
        };
        self.inner.push(
            (peer_id, protocol_id),
            PeerManagerRequest::SendRpc(peer_id, request),
        )?;
        res_rx.await?
    }
```
