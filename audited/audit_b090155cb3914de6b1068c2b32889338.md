# Audit Report

## Title
Failpoint Namespace Isolation Bypass Allows Cross-Component Failure Injection via API Endpoint

## Summary
The `/v1/set_failpoint` API endpoint accepts arbitrary failpoint names without namespace validation, allowing external callers to configure failpoints in consensus, execution, and other critical components beyond the intended API layer scope. While limited to nodes with failpoints explicitly enabled, this violates the namespace isolation principle suggested by the `fail_point_poem()` function design.

## Finding Description

The `fail_point_poem()` function is designed to scope failpoints to the API layer by prepending the "api::" namespace prefix to all failpoint names: [1](#0-0) 

This design suggests that API-layer failpoints should be isolated from other components. However, the `/v1/set_failpoint` endpoint directly calls `fail::cfg()` with the user-supplied name parameter without any validation or namespace restriction: [2](#0-1) 

The endpoint is publicly registered in the API routes without authentication: [3](#0-2) 

This allows callers to configure failpoints in critical system components including consensus and execution layers, such as:

**Consensus Layer Failpoints:**
- [4](#0-3) 
- [5](#0-4) 
- [6](#0-5) 

**Execution Layer Failpoints:**
- [7](#0-6) 
- [8](#0-7) 

An attacker can directly invoke these critical component failpoints by calling:
```
GET /v1/set_failpoint?name=consensus::process_proposal_msg&actions=return
GET /v1/set_failpoint?name=executor::block_executor_execute_block&actions=return
```

## Impact Explanation

This issue is classified as **Medium Severity** per the Aptos bug bounty criteria for the following reasons:

**Positive Impact Factors:**
- Enables targeted disruption of consensus proposal processing on affected nodes
- Allows crashing of execution engine operations
- Can cause determinism failures between validators if selectively applied
- May create temporary network liveness issues if multiple validators are affected

**Mitigating Factors:**
- Only affects nodes where failpoints are explicitly enabled in configuration ( [9](#0-8) )
- Failpoints are prohibited on mainnet by the config sanitizer ( [10](#0-9) )
- Primarily impacts testnet/devnet environments where failpoints are enabled for testing
- Requires network access to the node's API endpoint

The impact aligns with "API crashes" and "validator node slowdowns" under High Severity, but is downgraded to Medium due to the requirement that operators must explicitly enable failpoints.

## Likelihood Explanation

**Likelihood: Low-to-Medium**

The vulnerability is exploitable when:
1. A node runs with the `failpoints` Cargo feature enabled (compile-time requirement)
2. The node configuration has `api.failpoints_enabled = true` (runtime requirement)
3. The API endpoint is network-accessible to the attacker
4. The node is not on mainnet (enforced by sanitizer)

This configuration is common on testnet and devnet validator nodes used for fault tolerance testing, making exploitation feasible in these environments. However, the explicit opt-in nature and testnet-only applicability reduces overall likelihood in production-critical scenarios.

## Recommendation

Implement namespace validation in the `set_failpoint_poem()` function to enforce the "api::" prefix isolation:

```rust
#[cfg(feature = "failpoints")]
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        // Validate that only API-layer failpoints can be configured via this endpoint
        if !failpoint_conf.name.starts_with("api::") {
            return Err(poem::Error::from(anyhow::anyhow!(
                "Only API-layer failpoints (api::*) can be configured via this endpoint. Got: {}",
                failpoint_conf.name
            )));
        }
        
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

Alternatively, if cross-component failpoint configuration is intentionally desired for comprehensive testing, add authentication/authorization requirements to the endpoint and document this capability explicitly.

## Proof of Concept

**Setup Requirements:**
1. Build Aptos node with `failpoints` feature enabled
2. Configure `api.failpoints_enabled = true` in node config
3. Start the node on testnet/devnet

**Attack Steps:**

```bash
# Step 1: Configure a consensus failpoint to inject errors in proposal processing
curl "http://localhost:8080/v1/set_failpoint?name=consensus::process_proposal_msg&actions=return"

# Expected response: "Set failpoint consensus::process_proposal_msg"

# Step 2: The consensus layer will now fail when processing proposals
# Verify by checking node logs for injected errors:
# "Injected error in process_proposal_msg"

# Step 3: Configure an execution failpoint to crash block execution
curl "http://localhost:8080/v1/set_failpoint?name=executor::block_executor_execute_block&actions=return"

# Expected response: "Set failpoint executor::block_executor_execute_block"

# Result: Node becomes unable to execute blocks and process transactions
```

**Expected Behavior:**
- The node should reject failpoint names outside the "api::" namespace
- Only failpoints explicitly defined in the API layer should be configurable

**Actual Behavior:**
- Any failpoint in the codebase can be configured, including critical consensus and execution layer failpoints
- This bypasses the namespace isolation suggested by the `fail_point_poem()` design

## Notes

This finding addresses the specific security question about namespace isolation in failpoint configuration. While failpoints are intentionally designed as a testing feature and protected from mainnet deployment, the lack of namespace validation in the API endpoint violates the isolation principle suggested by the `fail_point_poem()` implementation and allows broader system impact than the API layer design implies.

### Citations

**File:** api/src/failpoint.rs (L14-23)
```rust
pub fn fail_point_poem<E: InternalError>(name: &str) -> Result<(), E> {
    fail::fail_point!(format!("api::{}", name).as_str(), |_| {
        Err(E::internal_with_code_no_info(
            format!("Failpoint unexpected internal error for {}", name),
            AptosErrorCode::InternalError,
        ))
    });

    Ok(())
}
```

**File:** api/src/set_failpoints.rs (L22-40)
```rust
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** api/src/runtime.rs (L248-251)
```rust
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
```

**File:** consensus/src/round_manager.rs (L727-729)
```rust
        fail_point!("consensus::process_proposal_msg", |_| {
            Err(anyhow::anyhow!("Injected error in process_proposal_msg"))
        });
```

**File:** consensus/src/round_manager.rs (L791-795)
```rust
        fail_point!("consensus::process_opt_proposal_msg", |_| {
            Err(anyhow::anyhow!(
                "Injected error in process_opt_proposal_msg"
            ))
        });
```

**File:** consensus/src/round_manager.rs (L1369-1378)
```rust
        fail_point!("consensus::create_invalid_vote", |_| {
            use aptos_crypto::bls12381;
            let faulty_vote = Vote::new_with_signature(
                vote.vote_data().clone(),
                vote.author(),
                vote.ledger_info().clone(),
                bls12381::Signature::dummy_signature(),
            );
            Ok(faulty_vote)
        });
```

**File:** execution/executor/src/block_executor/mod.rs (L236-240)
```rust
                fail_point!("executor::block_executor_execute_block", |_| {
                    Err(ExecutorError::from(anyhow::anyhow!(
                        "Injected error in block_executor_execute_block"
                    )))
                });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1032-1038)
```rust
        fail_point!("aptos_vm::execute_script_or_entry_function", |_| {
            Err(VMStatus::Error {
                status_code: StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                sub_status: Some(move_core_types::vm_status::sub_status::unknown_invariant_violation::EPARANOID_FAILURE),
                message: None,
            })
        });
```

**File:** config/src/config/config_sanitizer.rs (L82-91)
```rust
    // Verify that failpoints are not enabled in mainnet
    let failpoints_enabled = are_failpoints_enabled();
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
    }
```
