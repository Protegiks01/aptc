# Audit Report

## Title
Unauthorized Consensus Observer Subscription via Missing Peer Authentication

## Summary
The consensus observer publisher accepts subscription requests from any connected peer without verifying node authorization or role, allowing public fullnodes to bypass intended access restrictions and receive real-time consensus messages containing validator voting patterns.

## Finding Description

The consensus observer system is designed to allow authorized nodes (validators and validator fullnodes) to follow consensus in real-time. The configuration explicitly disables consensus observer for public fullnodes by default: [1](#0-0) 

However, the configuration optimizer respects manually set values and will not override them: [2](#0-1) 

This allows a malicious actor to enable consensus observer on a public fullnode by setting `observer_enabled: true` in their local configuration file.

**The Critical Flaw: Missing Authorization Check**

When a Subscribe request is received, the consensus publisher accepts it without any verification of the peer's node type or role: [3](#0-2) 

The network handler only verifies that the publisher is enabled, not whether the requesting peer is authorized: [4](#0-3) 

**Available but Unused Authorization Mechanism**

The system DOES have the capability to check peer roles. The publisher accesses peer metadata during garbage collection: [5](#0-4) 

The PeerMetadata structure contains role information with a method to identify validators and VFNs: [6](#0-5) [7](#0-6) 

However, this authorization check is never performed during subscription handling.

**Attack Path**

1. Validator fullnodes enable both observer and publisher by default: [8](#0-7) 

2. When enabled, consensus observer protocols are registered on ALL network types: [9](#0-8) 

3. The publisher broadcasts messages to ALL active subscribers: [10](#0-9) 

4. These messages contain LedgerInfoWithSignatures with validator voting patterns: [11](#0-10) [12](#0-11) 

5. The AggregateSignature structure contains the validator_bitmask revealing which validators signed: [13](#0-12) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty criteria as an authorization bypass enabling unauthorized information disclosure.

**Authorization Bypass**: The explicit default configuration (`ENABLE_ON_PUBLIC_FULLNODES = false`) demonstrates clear intent to restrict access to consensus observer for public fullnodes. However, this restriction is not enforced by the subscription handler, allowing trivial bypass.

**Information Disclosure**: Real-time access to validator voting patterns through the `validator_bitmask` enables:
- Analysis of validator liveness and participation patterns
- Identification of specific validators for targeted attacks
- Timing analysis correlating validators with consensus decisions
- Potential front-running or market manipulation based on predicted consensus outcomes

**Systemic Issue**: Any number of unauthorized nodes can exploit this vulnerability simultaneously, making it a network-wide rather than isolated security concern.

The publisher has the necessary infrastructure to verify peer roles (via `PeerMetadata.is_validator_or_vfn()`) but fails to use it, making this a clear missing authorization check rather than a design limitation.

## Likelihood Explanation

**High Likelihood** - The attack is trivially executable:

1. **No Prerequisites**: Requires only a standard public fullnode deployment
2. **Single Configuration Change**: Edit local config to set `observer_enabled: true`
3. **No Special Access**: Uses standard network connectivity to VFNs
4. **Simple Exploitation**: Single RPC call to subscribe
5. **No Detection**: Appears as legitimate consensus observer traffic

Any motivated actor with basic system administration knowledge can exploit this vulnerability.

## Recommendation

Add peer role verification in the subscription handler before accepting subscriptions:

```rust
ConsensusObserverRequest::Subscribe => {
    // Get the peer metadata and verify the peer is authorized
    let peers_and_metadata = self.consensus_observer_client.get_peers_and_metadata();
    if let Ok(connected_peers) = peers_and_metadata.get_connected_peers_and_metadata() {
        if let Some(peer_metadata) = connected_peers.get(&peer_network_id) {
            // Only allow validators and VFNs to subscribe
            if !peer_metadata.is_validator_or_vfn() {
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "Rejected subscription from unauthorized peer role: {:?}",
                        peer_network_id
                    )));
                response_sender.send(ConsensusObserverResponse::UnsubscribeAck);
                return;
            }
        }
    }
    
    // Add the peer to the set of active subscribers
    self.add_active_subscriber(peer_network_id);
    // ... rest of existing code
}
```

## Proof of Concept

```rust
// On a public fullnode, modify the configuration:
// config.yaml:
// consensus_observer:
//   observer_enabled: true

// The node will then be able to:
// 1. Register consensus observer protocols on the Public network
// 2. Connect to a VFN via the Public network
// 3. Send a Subscribe RPC request
// 4. Receive OrderedBlock and CommitDecision messages
// 5. Extract validator_bitmask from LedgerInfoWithSignatures
// 6. Analyze real-time validator voting patterns

// This can be verified by:
// 1. Setting up a public fullnode with observer_enabled: true
// 2. Monitoring network traffic to confirm subscription acceptance
// 3. Logging received consensus observer messages
// 4. Extracting and displaying validator_bitmask values from received messages
```

## Notes

This vulnerability exists because the intended access control (configuration defaults) is not enforced at the authorization point (subscription handler). The publisher has all the necessary information to verify peer authorization through the existing `PeerMetadata` infrastructure but fails to perform this check. This makes it a clear security vulnerability rather than a configuration issue.

### Citations

**File:** config/src/config/consensus_observer_config.rs (L14-14)
```rust
const ENABLE_ON_PUBLIC_FULLNODES: bool = false;
```

**File:** config/src/config/consensus_observer_config.rs (L106-107)
```rust
        let observer_manually_set = !local_observer_config_yaml["observer_enabled"].is_null();
        let publisher_manually_set = !local_observer_config_yaml["publisher_enabled"].is_null();
```

**File:** config/src/config/consensus_observer_config.rs (L119-128)
```rust
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L104-107)
```rust
        let peers_and_metadata = self.consensus_observer_client.get_peers_and_metadata();
        let connected_peers_and_metadata =
            match peers_and_metadata.get_connected_peers_and_metadata() {
                Ok(connected_peers_and_metadata) => connected_peers_and_metadata,
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L181-193)
```rust
            ConsensusObserverRequest::Subscribe => {
                // Add the peer to the set of active subscribers
                self.add_active_subscriber(peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "New peer subscribed to consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple subscription ACK
                response_sender.send(ConsensusObserverResponse::SubscribeAck);
            },
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L212-232)
```rust
    pub fn publish_message(&self, message: ConsensusObserverDirectSend) {
        // Get the active subscribers
        let active_subscribers = self.get_active_subscribers();

        // Send the message to all active subscribers
        for peer_network_id in &active_subscribers {
            // Send the message to the outbound receiver for publishing
            let mut outbound_message_sender = self.outbound_message_sender.clone();
            if let Err(error) =
                outbound_message_sender.try_send((*peer_network_id, message.clone()))
            {
                // The message send failed
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                        .event(LogEvent::SendDirectSendMessage)
                        .message(&format!(
                            "Failed to send outbound message to the receiver for peer {:?}! Error: {:?}",
                            peer_network_id, error
                    )));
            }
        }
    }
```

**File:** consensus/src/consensus_observer/network/network_handler.rs (L200-203)
```rust
        // Drop the message if the publisher is not enabled
        if !self.consensus_observer_config.publisher_enabled {
            return;
        }
```

**File:** network/framework/src/application/metadata.rs (L38-43)
```rust
    #[cfg(any(test, feature = "fuzzing"))]
    pub fn new_for_test(
        connection_metadata: ConnectionMetadata,
        peer_monitoring_metadata: PeerMonitoringMetadata,
    ) -> Self {
        PeerMetadata {
```

**File:** network/framework/src/application/metadata.rs (L121-123)
```rust

```

**File:** aptos-node/src/network.rs (L336-358)
```rust
        // Register consensus observer (both client and server) with the network
        if node_config
            .consensus_observer
            .is_observer_or_publisher_enabled()
        {
            // Create the network handle for this network type
            let network_handle = register_client_and_service_with_network(
                &mut network_builder,
                network_id,
                &network_config,
                consensus_observer_network_configuration(node_config),
                false,
            );

            // Add the network handle to the set of handles
            if let Some(consensus_observer_network_handles) =
                &mut consensus_observer_network_handles
            {
                consensus_observer_network_handles.push(network_handle);
            } else {
                consensus_observer_network_handles = Some(vec![network_handle]);
            }
        }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L179-184)
```rust
/// OrderedBlock message contains the ordered blocks and the proof of the ordering
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct OrderedBlock {
    blocks: Vec<Arc<PipelinedBlock>>,
    ordered_proof: LedgerInfoWithSignatures,
}
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L335-339)
```rust
/// CommitDecision message contains the commit decision proof
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct CommitDecision {
    commit_proof: LedgerInfoWithSignatures,
}
```

**File:** types/src/aggregate_signature.rs (L11-19)
```rust
/// This struct represents a BLS multi-signature or aggregated signature:
/// it stores a bit mask representing the set of validators participating in the signing process
/// and the multi-signature/aggregated signature itself,
/// which was aggregated from these validators' partial BLS signatures.
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct AggregateSignature {
    validator_bitmask: BitVec,
    sig: Option<bls12381::Signature>,
}
```
