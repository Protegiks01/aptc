# Audit Report

## Title
Internal Implementation Details Leaked Through Storage Service Error Serialization

## Summary
The storage service server serializes internal error messages containing sensitive implementation details (database pruning states, column family names, version information) and transmits them to untrusted network peers, enabling reconnaissance attacks against validator nodes.

## Finding Description

The storage service error handling chain converts internal database errors to strings and transmits them over the network without sanitization. The vulnerability exists in the error conversion pipeline: [1](#0-0) 

These server-side errors are converted to `StorageServiceError` which is serialized and sent to network peers: [2](#0-1) 

The error conversion in the handler exposes internal error details: [3](#0-2) 

Internal database errors like `AptosDbError` are converted to strings via multiple layers: [4](#0-3) 

And transmitted over the network: [5](#0-4) 

**Specific Information Leakage Examples:**

1. **Pruning State Information** - When requesting pruned versions, the error reveals internal pruning configuration: [6](#0-5) 

2. **Column Family Names** - Database schema details are exposed: [7](#0-6) 

3. **Database Properties**: [8](#0-7) 

**Attack Path:**
1. Attacker sends `GetStateValuesWithProof` request for a pruned version (e.g., version 1000 when min_readable_version is 50000)
2. Server calls `error_if_state_merkle_pruned` which generates detailed error message
3. Error propagates through: `anyhow::Error` → `AptosDbError::Other` → `Error::StorageErrorEncountered` → `StorageServiceError::InternalError`
4. Error is serialized with BCS and transmitted to attacker
5. Attacker receives message like: "Storage error encountered: AptosDB Other Error: State merkle at version 1000 is pruned. snapshots are available at >= 50000, epoch snapshots are available at >= 45000"

## Impact Explanation

This qualifies as **Medium severity** under the Aptos bug bounty program because:

1. **Information Disclosure**: While not directly causing "state inconsistencies requiring intervention," the leaked information includes:
   - Database pruning configuration (min_readable_version values)
   - Internal database schema (column family names)
   - Node storage state and configuration
   - Potentially file system paths from RocksDB errors

2. **Reconnaissance Value**: This information aids attackers in:
   - Understanding node synchronization state
   - Planning targeted attacks on specific database components
   - Identifying nodes with different pruning configurations
   - Mapping internal database architecture

3. **Network-Wide Impact**: All storage service endpoints are vulnerable, affecting validator and fullnode communications

While this doesn't directly compromise funds or consensus, it violates information hiding principles and provides actionable intelligence for further attacks, placing it above "Low severity" (minor information leaks) but below "High severity" (direct protocol violations).

## Likelihood Explanation

**Likelihood: High**

1. **No Authentication Required**: Any network peer can send storage service requests
2. **Easy to Trigger**: Simply request pruned data or send malformed requests
3. **Widespread Exposure**: All nodes running storage service are vulnerable
4. **Deterministic**: The error messages are consistently generated and transmitted

## Recommendation

Implement error sanitization that strips internal implementation details before network transmission:

```rust
// In state-sync/storage-service/server/src/handler.rs
process_result.map_err(|error| match error {
    Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
    Error::TooManyInvalidRequests(error) => {
        StorageServiceError::TooManyInvalidRequests(error)
    },
    Error::StorageErrorEncountered(_) => {
        // Sanitize: don't leak internal details
        StorageServiceError::InternalError(
            "Internal storage error occurred".to_string()
        )
    },
    Error::UnexpectedErrorEncountered(_) => {
        // Sanitize: generic error message
        StorageServiceError::InternalError(
            "Unexpected error occurred".to_string()
        )
    },
})
```

Additionally, audit error messages throughout the storage layer to ensure they don't contain sensitive paths or configuration details in logging, only exposing sanitized versions to network peers.

## Proof of Concept

```rust
// Test demonstrating information leakage
#[tokio::test]
async fn test_storage_error_information_leak() {
    // Setup: Create storage service with pruned data
    let (mut mock_client, service) = setup_storage_service().await;
    
    // Attack: Request a version that's been pruned
    let pruned_version = 1000;
    let request = StorageServiceRequest {
        data_request: DataRequest::GetStateValuesWithProof(
            StateValuesWithProofRequest {
                version: pruned_version,
                start_index: 0,
                end_index: 100,
            }
        ),
        use_compression: false,
    };
    
    // Send request
    let response = mock_client.send_request(request).await;
    
    // Verify: Error message contains internal implementation details
    match response {
        Err(Error::StorageServiceError(
            StorageServiceError::InternalError(msg)
        )) => {
            // Error message reveals internal pruning state
            assert!(msg.contains("is pruned"));
            assert!(msg.contains("snapshots are available at"));
            assert!(msg.contains("epoch snapshots are available at"));
            
            // Extract the min_readable_version from error (information leak!)
            println!("Leaked pruning config: {}", msg);
        },
        _ => panic!("Expected InternalError with detailed message"),
    }
}
```

**Notes:**

This vulnerability affects the entire storage service network communication layer. The root cause is the lack of error sanitization before network transmission, combined with overly detailed internal error messages that expose database configuration and structure. While deserialization is safe (BCS with simple String types), the serialization of unsanitized error content creates an information disclosure vulnerability exploitable by any network peer.

### Citations

**File:** state-sync/storage-service/server/src/error.rs (L7-17)
```rust
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
pub enum Error {
    #[error("Invalid request received: {0}")]
    InvalidRequest(String),
    #[error("Storage error encountered: {0}")]
    StorageErrorEncountered(String),
    #[error("Too many invalid requests: {0}")]
    TooManyInvalidRequests(String),
    #[error("Unexpected error encountered: {0}")]
    UnexpectedErrorEncountered(String),
}
```

**File:** state-sync/storage-service/types/src/lib.rs (L29-37)
```rust
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
pub enum StorageServiceError {
    #[error("Internal service error: {0}")]
    InternalError(String),
    #[error("Invalid storage request: {0}")]
    InvalidRequest(String),
    #[error("Too many invalid requests! Back off required: {0}")]
    TooManyInvalidRequests(String),
}
```

**File:** state-sync/storage-service/server/src/handler.rs (L195-203)
```rust
        // Transform the request error into a storage service error (for the client)
        process_result.map_err(|error| match error {
            Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
            Error::TooManyInvalidRequests(error) => {
                StorageServiceError::TooManyInvalidRequests(error)
            },
            error => StorageServiceError::InternalError(error.to_string()),
        })
    }
```

**File:** storage/storage-interface/src/errors.rs (L39-47)
```rust
impl From<anyhow::Error> for AptosDbError {
    fn from(error: anyhow::Error) -> Self {
        Self::Other(format!("{}", error))
    }
}

impl From<bcs::Error> for AptosDbError {
    fn from(error: bcs::Error) -> Self {
        Self::BcsError(format!("{}", error))
```

**File:** state-sync/storage-service/server/src/network.rs (L106-112)
```rust
    pub fn send(self, response: Result<StorageServiceResponse>) {
        let msg = StorageServiceMessage::Response(response);
        let result = bcs::to_bytes(&msg)
            .map(Bytes::from)
            .map_err(RpcError::BcsError);
        let _ = self.response_tx.send(result);
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L295-302)
```rust
            bail!(
                "{} at version {} is pruned. snapshots are available at >= {}, epoch snapshots are available at >= {}",
                data_type,
                version,
                min_readable_version,
                min_readable_epoch_snapshot_version,
            )
        }
```

**File:** storage/schemadb/src/lib.rs (L320-329)
```rust
    fn get_cf_handle(&self, cf_name: &str) -> DbResult<&rocksdb::ColumnFamily> {
        self.inner
            .cf_handle(cf_name)
            .ok_or_else(|| {
                format_err!(
                    "DB::cf_handle not found for column family name: {}",
                    cf_name
                )
            })
            .map_err(Into::into)
```

**File:** storage/schemadb/src/lib.rs (L344-350)
```rust
            .ok_or_else(|| {
                aptos_storage_interface::AptosDbError::Other(
                    format!(
                        "Unable to get property \"{}\" of  column family \"{}\".",
                        property_name, cf_name,
                    )
                    .to_string(),
```
