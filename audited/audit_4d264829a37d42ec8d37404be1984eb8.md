# Audit Report

## Title
Epoch Transition Deadlock via Unresponsive OIDC Provider in JWK Consensus Shutdown

## Summary
The JWK consensus manager's shutdown mechanism can deadlock indefinitely during epoch transitions when a `JWKObserver` is blocked waiting for an HTTP response from an unresponsive OIDC provider. This prevents the acknowledgment signal from being sent, causing the epoch manager to hang and blocking consensus participation.

## Finding Description

The vulnerability exists in the interaction between three components during epoch transitions:

1. **EpochManager shutdown flow**: When transitioning to a new epoch, `shutdown_current_processor()` creates a oneshot channel pair `(ack_tx, ack_rx)`, sends `ack_tx` to the JWK consensus manager, and waits on `ack_rx.await` for acknowledgment. [1](#0-0) 

2. **JWK Manager teardown**: The `tear_down()` function shuts down all JWK observers by calling `join_all(futures).await`, then sends the acknowledgment. If any observer hangs, this function never reaches the acknowledgment send. [2](#0-1) 

3. **JWKObserver shutdown**: Each observer's `shutdown()` method sends a close signal and awaits the observer task's completion. However, if the observer task is blocked in an HTTP request, it cannot process the close signal. [3](#0-2) 

The **root cause** is that HTTP requests to OIDC providers have no timeout configured. The `reqwest::Client` is created without timeout settings: [4](#0-3) [5](#0-4) 

When an observer task is awaiting `fetch_jwks()` inside the `tokio::select!` loop, it cannot process the close signal because tokio's select macro only polls branches before selecting one—it does not interrupt an executing future. [6](#0-5) 

**Attack Path:**
1. A validator's `JWKObserver` initiates an HTTP request to an OIDC provider
2. The provider becomes unresponsive (network partition, server crash, DDoS, or malicious behavior)
3. The HTTP request hangs indefinitely (no timeout configured)
4. An epoch transition occurs
5. `shutdown_current_processor()` attempts to shutdown the JWK manager
6. The manager's `tear_down()` calls `JWKObserver::shutdown()` for all observers
7. The stuck observer's `shutdown()` sends the close signal but awaits `join_handle` which never completes
8. `join_all(futures).await` hangs in `tear_down()`
9. The acknowledgment `ack_tx.send(())` is never reached
10. `ack_rx.await` in `shutdown_current_processor()` hangs indefinitely
11. The validator cannot complete the epoch transition and becomes stuck

This vulnerability affects both `IssuerLevelConsensusManager` and `KeyLevelConsensusManager` as they share the same pattern. [7](#0-6) 

## Impact Explanation

**Severity: High to Critical**

This vulnerability causes validator nodes to hang during epoch transitions, which has severe implications:

- **Single Validator Impact (High)**: An affected validator becomes unresponsive and cannot participate in consensus, matching the "Validator node slowdowns" category
- **Multiple Validator Impact (Critical)**: If multiple validators are affected simultaneously (e.g., a widely-used OIDC provider like Google or Auth0 experiences an outage), this could cause network-wide liveness failure, matching the "Total loss of liveness/network availability" category
- **Consensus Liveness**: Epoch transitions are critical consensus operations—failure to complete them prevents the network from adapting to validator set changes and other epoch-based reconfigurations

The vulnerability breaks the liveness invariant during epoch transitions, which is a fundamental consensus requirement.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability can be triggered through multiple realistic scenarios:

1. **Accidental Triggers**:
   - Network partitions between validators and OIDC providers
   - OIDC provider server crashes or maintenance
   - DDoS attacks on legitimate OIDC providers
   - Slow network connections causing prolonged HTTP hangs

2. **Malicious Triggers**:
   - An attacker operates a malicious OIDC provider added via governance
   - The malicious provider accepts TCP connections but never responds to HTTP requests
   - All validators attempting to fetch JWKs from this provider become vulnerable during the next epoch transition

The likelihood is increased because:
- HTTP requests to external services are inherently unreliable
- No timeout mechanism exists to bound the wait time
- Epoch transitions occur regularly in Aptos (governance-driven)
- Multiple OIDC providers are typically configured, increasing exposure surface

## Recommendation

**Immediate Fix**: Add timeouts to all HTTP requests in the JWK fetching logic:

```rust
// In crates/jwk-utils/src/lib.rs
const JWK_FETCH_TIMEOUT_SECS: u64 = 10;

pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(JWK_FETCH_TIMEOUT_SECS))
        .build()?;
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}

pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(JWK_FETCH_TIMEOUT_SECS))
        .build()?;
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

**Additional Hardening**:
1. Add a timeout mechanism in `JWKObserver::shutdown()` to force-kill hung observers after a reasonable grace period
2. Add timeout in `tear_down()` with force-abort of observers after grace period
3. Implement circuit breaker pattern for repeatedly failing OIDC providers
4. Add monitoring/alerting for stuck epoch transitions

## Proof of Concept

```rust
#[tokio::test]
async fn test_epoch_transition_deadlock_with_unresponsive_oidc() {
    use tokio::time::{timeout, Duration};
    use tokio::net::TcpListener;
    use tokio::sync::oneshot;
    
    // Setup: Create a mock OIDC server that accepts connections but never responds
    let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
    let addr = listener.local_addr().unwrap();
    
    // Spawn server that accepts but never responds
    tokio::spawn(async move {
        loop {
            if let Ok((mut socket, _)) = listener.accept().await {
                // Accept connection but never send response - simulates hanging HTTP server
                tokio::spawn(async move {
                    let _ = tokio::time::sleep(Duration::from_secs(3600)).await;
                });
            }
        }
    });
    
    // Create JWKObserver pointing to the unresponsive server
    let (obs_tx, _obs_rx) = aptos_channel::new(QueueStyle::KLAST, 10, None);
    let observer = JWKObserver::spawn(
        1, // epoch
        AccountAddress::random(),
        "test_issuer".to_string(),
        format!("http://{}/openid-config", addr),
        Duration::from_millis(100), // fast fetch interval
        obs_tx,
    );
    
    // Wait for observer to start fetching (and get stuck)
    tokio::time::sleep(Duration::from_millis(200)).await;
    
    // Simulate epoch transition shutdown
    let (ack_tx, ack_rx) = oneshot::channel();
    
    // Attempt to shutdown - this should complete quickly but will hang
    let shutdown_result = timeout(
        Duration::from_secs(2), // Should complete in 2 seconds
        async move {
            observer.shutdown().await;
            ack_tx.send(()).unwrap();
        }
    ).await;
    
    // Verify: The shutdown hangs and times out
    assert!(
        shutdown_result.is_err(),
        "Expected shutdown to hang due to unresponsive OIDC provider"
    );
    
    // Verify: The acknowledgment was never received
    let ack_result = timeout(Duration::from_millis(100), ack_rx).await;
    assert!(
        ack_result.is_err() || ack_result.unwrap().is_err(),
        "Expected no acknowledgment due to hung shutdown"
    );
}
```

This PoC demonstrates that when an OIDC provider accepts TCP connections but never responds to HTTP requests, the observer's shutdown hangs indefinitely, preventing the acknowledgment from being sent during epoch transitions.

## Notes

The vulnerability is particularly severe because:
1. It affects a critical consensus operation (epoch transitions)
2. It can be triggered by external dependencies (OIDC providers) outside validator control
3. The same pattern exists in both consensus manager implementations (`IssuerLevelConsensusManager` and `KeyLevelConsensusManager`)
4. No timeout or circuit breaker mechanisms exist to bound the failure domain
5. The error result from `ack_tx.send(())` is explicitly ignored with `let _`, meaning even if the design intended to handle failures, the current implementation would not recover properly

### Citations

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L266-274)
```rust
    async fn shutdown_current_processor(&mut self) {
        if let Some(tx) = self.jwk_manager_close_tx.take() {
            let (ack_tx, ack_rx) = oneshot::channel();
            let _ = tx.send(ack_tx);
            let _ = ack_rx.await;
        }

        self.jwk_updated_event_txs = None;
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L170-181)
```rust
    async fn tear_down(&mut self, ack_tx: Option<oneshot::Sender<()>>) -> Result<()> {
        self.stopped = true;
        let futures = std::mem::take(&mut self.jwk_observers)
            .into_iter()
            .map(JWKObserver::shutdown)
            .collect::<Vec<_>>();
        join_all(futures).await;
        if let Some(tx) = ack_tx {
            let _ = tx.send(());
        }
        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L70-89)
```rust
        loop {
            tokio::select! {
                _ = interval.tick().fuse() => {
                    let timer = Instant::now();
                    let result = fetch_jwks(open_id_config_url.as_str(), my_addr).await;
                    debug!(issuer = issuer, "observe_result={:?}", result);
                    let secs = timer.elapsed().as_secs_f64();
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
                    } else {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "err"]).observe(secs);
                    }
                },
                _ = close_rx.select_next_some() => {
                    break;
                }
            }
        }
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L92-99)
```rust
    pub async fn shutdown(self) {
        let Self {
            close_tx,
            join_handle,
        } = self;
        let _ = close_tx.send(());
        let _ = join_handle.await;
    }
```

**File:** crates/jwk-utils/src/lib.rs (L29-36)
```rust
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
```

**File:** crates/jwk-utils/src/lib.rs (L40-43)
```rust
pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L95-106)
```rust
    async fn tear_down(&mut self, ack_tx: Option<oneshot::Sender<()>>) -> Result<()> {
        self.stopped = true;
        let futures = std::mem::take(&mut self.jwk_observers)
            .into_iter()
            .map(JWKObserver::shutdown)
            .collect::<Vec<_>>();
        join_all(futures).await;
        if let Some(tx) = ack_tx {
            let _ = tx.send(());
        }
        Ok(())
    }
```
