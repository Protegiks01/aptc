# Audit Report

## Title
Chain ID Substitution Vulnerability in TPS Checker Allowing Cross-Chain Transaction Signing

## Summary
The `TpsChecker::check()` function retrieves the chain ID from the untrusted target node being tested instead of the trusted baseline node, contradicting its own code comments. This allows a malicious target node to trick the TPS checker into signing transactions for an unintended blockchain, potentially enabling fund theft if the mint key has balances on multiple chains.

## Finding Description

The TPS checker is designed to validate that a target node meets minimum transaction processing requirements. The function includes a comment stating it uses the baseline chain ID, yet the implementation fetches the chain ID from the target node being tested: [1](#0-0) 

However, the actual implementation retrieves the chain ID from the target node: [2](#0-1) 

This retrieved chain ID is then used when creating the transaction cluster: [3](#0-2) 

The cluster uses this chain ID to construct a `TransactionFactory` that signs all emitted transactions: [4](#0-3) 

**Attack Flow:**

1. Attacker runs a malicious node that reports `chain_id = 1` (mainnet) in its API responses instead of the actual testnet chain ID
2. Node operator configures TPS checker to test this malicious node
3. TPS checker queries the malicious node's `/` endpoint and receives `chain_id = 1`
4. TPS checker creates and signs transactions using the mint key with `chain_id = 1`
5. Malicious node receives these validly signed mainnet transactions
6. If the malicious node is connected to mainnet (or proxies to it), it can broadcast these transactions
7. If the mint key has any balance on mainnet, those funds can be drained

The vulnerability exists because the TPS checker trusts the target node (which is untrusted and under test) to provide the chain ID, rather than using the baseline node's chain ID, which is the trusted reference point. The baseline provider is available but unused: [5](#0-4) 

Other checkers correctly use the baseline to validate the target's chain ID: [6](#0-5) 

## Impact Explanation

This vulnerability falls under **Medium Severity** ("Limited funds loss or manipulation" - up to $10,000) with potential escalation to **Critical Severity** depending on operational practices:

**Medium Impact:**
- Requires the mint key to have funds on the chain reported by the malicious node
- Typical deployments use isolated test keys, limiting exposure
- Affects node checker operators, not the blockchain itself

**Potential Critical Impact:**
- If organizations reuse mint keys across mainnet and testnet (poor operational security)
- Direct fund theft becomes possible
- No blockchain-level defenses can prevent this at the application layer

While the Move VM's transaction validation will reject mismatched chain IDs: [7](#0-6) 

This protection only applies if transactions reach an honest validator. The malicious target node can act as a proxy, forwarding signed transactions to any chain matching the reported chain ID before they undergo validation.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- Node operator testing an untrusted/malicious node (common use case for node checker)
- Mint key with funds on multiple chains (uncommon but possible misconfiguration)
- No prior chain ID validation via `NodeIdentityChecker` (if not configured as required)

The code comment explicitly states a false assumption, suggesting this design flaw was unintentional. Operators may trust the tool to validate chain IDs correctly based on the documentation, making exploitation more likely than if the limitation were clearly documented.

## Recommendation

**Immediate Fix:** Retrieve chain ID from the trusted baseline node instead of the target node:

```rust
async fn check(
    &self,
    providers: &ProviderCollection,
) -> Result<Vec<CheckResult>, CheckerError> {
    // Get baseline chain ID (trusted)
    let baseline_api_index_provider = get_provider!(
        providers.baseline_api_index_provider,
        self.config.common.required,
        ApiIndexProvider
    );
    
    let baseline_response = baseline_api_index_provider.provide().await?;
    let chain_id = ChainId::new(baseline_response.chain_id);
    
    // Get target URL for TPS testing
    let target_api_index_provider = get_provider!(
        providers.target_api_index_provider,
        self.config.common.required,
        ApiIndexProvider
    );
    
    let target_url = target_api_index_provider.client.build_path("/").unwrap();
    
    // Optionally validate target reports same chain ID
    if let Ok(target_response) = target_api_index_provider.provide().await {
        if target_response.chain_id != baseline_response.chain_id {
            return Ok(vec![Self::build_result(
                "Chain ID mismatch".to_string(),
                0,
                format!(
                    "Target node reports chain ID {} but baseline reports {}. Cannot perform TPS test.",
                    target_response.chain_id, baseline_response.chain_id
                ),
            )]);
        }
    }
    
    // Continue with cluster creation using baseline chain_id...
}
```

**Additional Hardening:**
1. Make `NodeIdentityChecker` a required prerequisite for `TpsChecker`
2. Add explicit warnings in documentation about mint key isolation
3. Consider validating that mint key addresses match between chains before signing

## Proof of Concept

**Rust Test Scenario:**

```rust
#[tokio::test]
async fn test_chain_id_substitution_attack() {
    // Setup malicious node reporting wrong chain ID
    let mut malicious_server = mockito::Server::new_async().await;
    
    // Malicious node claims to be mainnet (chain_id = 1)
    let malicious_response = json!({
        "chain_id": 1,  // Mainnet
        "epoch": "1",
        "ledger_version": "1000",
        "oldest_ledger_version": "0",
        "ledger_timestamp": "1234567890",
        "node_role": "full_node",
        "oldest_block_height": "0",
        "block_height": "100",
    });
    
    malicious_server
        .mock("GET", "/v1/")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(malicious_response.to_string())
        .create_async()
        .await;
    
    // Configure TPS checker with testnet mint key (chain_id = 2)
    let testnet_mint_key = generate_test_key();
    let config = TpsCheckerConfig {
        coin_source_args: CoinSourceArgs {
            mint_key: Some(testnet_mint_key),
            ..Default::default()
        },
        minimum_tps: 100,
        ..Default::default()
    };
    
    let checker = TpsChecker::new(config).unwrap();
    
    // Create provider collection pointing to malicious node
    let providers = create_providers_for_url(&malicious_server.url());
    
    // Execute TPS check
    let result = checker.check(&providers).await;
    
    // Vulnerability: Checker will create and sign transactions with chain_id=1
    // even though the mint key is for chain_id=2
    // A real attack would capture these signed transactions and broadcast to mainnet
    
    assert!(result.is_ok(), "TPS checker should proceed with wrong chain ID");
}
```

**Notes:**
- The vulnerability violates the trust boundary between the node checker and target nodes under test
- While the blockchain's transaction validation provides defense-in-depth, it cannot prevent signed transactions from being captured and replayed on the reported chain
- The discrepancy between code comments and implementation suggests this was an oversight rather than intentional design

### Citations

**File:** ecosystem/node-checker/src/checker/tps.rs (L102-104)
```rust
    // You'll see that we're using the baseline chain ID here. This is okay
    // because at this point we've already asserted the baseline and target
    // have the same chain id.
```

**File:** ecosystem/node-checker/src/checker/tps.rs (L119-128)
```rust
        let chain_id = match target_api_index_provider.provide().await {
            Ok(response) => ChainId::new(response.chain_id),
            Err(err) => {
                return Ok(vec![Self::build_result(
                    "Failed to get chain ID of your node".to_string(),
                    0,
                    format!("There was an error querying your node's API: {:#}", err),
                )]);
            },
        };
```

**File:** ecosystem/node-checker/src/checker/tps.rs (L130-136)
```rust
        let cluster_config = ClusterArgs {
            targets: Some(vec![target_url; self.config.repeat_target_count]),
            targets_file: None,
            coin_source_args: self.config.coin_source_args.clone(),
            chain_id: Some(chain_id),
            node_api_key: None,
        };
```

**File:** crates/transaction-emitter-lib/src/wrappers.rs (L92-98)
```rust
    let emitter = TxnEmitter::new(
        TransactionFactory::new(cluster.chain_id)
            .with_transaction_expiration_time(args.txn_expiration_time_secs)
            .with_gas_unit_price(aptos_global_constants::GAS_UNIT_PRICE),
        StdRng::from_entropy(),
        client,
    );
```

**File:** ecosystem/node-checker/src/checker/node_identity.rs (L72-86)
```rust
        let baseline_api_index_provider = get_provider!(
            providers.baseline_api_index_provider,
            self.config.common.required,
            ApiIndexProvider
        );

        let target_api_index_provider = get_provider!(
            providers.target_api_index_provider,
            self.config.common.required,
            ApiIndexProvider
        );

        // We just let this error turn into a CheckerError since we want to
        // return actual errors in the case of a failure in querying the baseline.
        let baseline_response = baseline_api_index_provider.provide().await?;
```

**File:** ecosystem/node-checker/src/checker/node_identity.rs (L100-105)
```rust
        let check_results = vec![
            self.help_build_check_result(
                baseline_response.chain_id,
                target_response.chain_id,
                "Chain ID",
            ),
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L143-143)
```text
        assert!(chain_id::get() == chain_id, error::invalid_argument(PROLOGUE_EBAD_CHAIN_ID));
```
