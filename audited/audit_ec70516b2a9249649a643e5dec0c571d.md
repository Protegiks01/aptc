# Audit Report

## Title
State Sync Bootstrapping Denial of Service via Unverified NumberOfStates Response

## Summary
The bootstrapper's `fetch_missing_state_values()` function trusts `NumberOfStates` responses from remote peers without cryptographic verification. A malicious peer can report an inflated state count, causing the client to request non-existent state values, leading to repeated failures and preventing successful node bootstrapping.

## Finding Description
At lines 721-726 in `bootstrapper.rs`, the `get_all_state_values()` call initiates a state sync stream that first requests the total number of states at a given version from a remote peer. [1](#0-0) 

This creates a `StateStreamEngine` that requests `NumberOfStates` from a peer without any cryptographic proof or cross-validation. [2](#0-1) 

The peer's response is stored and used to calculate the range of state values to request: [3](#0-2) 

The only validation is checking if `number_of_states < next_request_index`, which does not verify the number against actual storage: [4](#0-3) 

**Attack Flow:**
1. Malicious peer reports `number_of_states = 15000` when only 10000 states exist at the version
2. Client creates requests for state chunks from index 0 to 14999
3. When requesting indices 10000-14999, the peer's storage layer returns empty results because the Jellyfish Merkle iterator detects out-of-bounds access: [5](#0-4) 

4. The storage layer's `ensure!` check fails on empty state values: [6](#0-5) 

5. These errors cause the stream to retry up to `max_request_retry` (default 5) times before terminating: [7](#0-6) [8](#0-7) 

6. After stream termination, the bootstrapper resets and retries with potentially another malicious peer, creating an endless loop if enough peers are compromised. [9](#0-8) 

## Impact Explanation
This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program:
- **State inconsistencies requiring intervention**: A bootstrapping node becomes stuck and cannot complete state sync, requiring manual intervention to diagnose and resolve
- **Limited availability impact**: While individual nodes are affected, the existing network continues operating. However, if coordinated across multiple malicious peers, this could prevent new nodes from joining the network

The attack does not directly lead to fund loss or consensus violations, but it breaks the **State Consistency** invariant by preventing nodes from achieving a consistent view of the blockchain state during initial sync.

## Likelihood Explanation
**Moderate Likelihood:**
- **Attack Simplicity**: The attack is trivial to executeâ€”a malicious peer simply returns an incorrect number in the `NumberOfStates` response
- **Peer Reputation Mitigation**: The system has peer scoring that eventually ignores bad peers, but this requires multiple retry cycles
- **Network Conditions**: If a significant portion (e.g., >30%) of available peers are malicious or experiencing database corruption, a new node could be effectively prevented from bootstrapping
- **No Cryptographic Barrier**: Unlike most other state sync operations that use Merkle proofs, the `NumberOfStates` response has no cryptographic verification

## Recommendation
Implement cryptographic verification of the `NumberOfStates` response. Options include:

1. **Cross-validate with multiple peers**: Request `NumberOfStates` from multiple peers and use majority consensus before proceeding
2. **Include in Merkle proof**: Extend the state value chunk proof to include a field proving the total state count
3. **Add bounds checking**: After receiving the first state chunk, validate that subsequent chunks don't exceed reasonable bounds relative to the first chunk's metadata
4. **Fallback mechanism**: If state value requests consistently fail beyond a certain index, retry the `NumberOfStates` query from a different peer

**Proposed Fix:**
```rust
// In StateStreamEngine::transform_client_response_into_notification
NumberOfStates(request) => {
    if let ResponsePayload::NumberOfStates(number_of_states) = client_response_payload {
        // Existing check
        if number_of_states < self.next_request_index {
            return Err(Error::NoDataToFetch(...));
        }
        
        // NEW: Add sanity check for unreasonably large state counts
        let max_reasonable_states = self.data_streaming_config.max_reasonable_state_count;
        if number_of_states > max_reasonable_states {
            warn!("Peer reported suspiciously large state count: {}, rejecting", number_of_states);
            return Err(Error::InvalidStateCount(...));
        }
        
        self.number_of_states = Some(number_of_states);
    }
}
```

Additionally, track cumulative errors and switch peers more aggressively when state value requests fail at high indices.

## Proof of Concept
```rust
// Simulated attack scenario demonstrating the vulnerability
// This would be implemented as a test in bootstrapper.rs tests

#[tokio::test]
async fn test_malicious_number_of_states_attack() {
    // Setup: Create a bootstrapper with a mock storage that has 10000 states
    let actual_state_count = 10000;
    let malicious_advertised_count = 15000;
    
    // Mock peer that reports inflated NumberOfStates
    let mut mock_peer = MockStreamingClient::new();
    mock_peer.set_number_of_states(malicious_advertised_count);
    
    // The peer's storage only has 10000 states
    mock_peer.set_actual_states(actual_state_count);
    
    // Create bootstrapper
    let mut bootstrapper = create_bootstrapper_with_mock(mock_peer);
    
    // Attempt to bootstrap
    for _ in 0..10 {
        let result = bootstrapper.drive_progress(&global_summary).await;
        
        // The bootstrapper will keep failing and resetting streams
        // because it's requesting indices 10000-14999 which don't exist
    }
    
    // Assert: After multiple attempts, bootstrapper is still not complete
    assert!(!bootstrapper.is_bootstrapped());
    
    // Assert: The stream was reset multiple times due to errors
    assert!(mock_peer.get_stream_reset_count() >= 5);
}
```

## Notes
While the peer reputation system provides some mitigation by eventually ignoring problematic peers, this defense is insufficient when:
1. Multiple malicious peers coordinate the attack
2. The network has a high percentage of peers with corrupted databases
3. A sophisticated attacker rotates through many malicious peer identities

The root cause is the lack of cryptographic binding between the `NumberOfStates` response and the actual state data served. The Jellyfish Merkle tree provides proofs for individual state values but not for the total count, creating this verification gap.

### Citations

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L720-726)
```rust
            self.streaming_client
                .get_all_state_values(
                    target_ledger_info_version,
                    Some(next_state_index_to_process),
                )
                .await?
        };
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1478-1486)
```rust
        // Reset the stream
        self.reset_active_stream(Some(notification_and_feedback))
            .await?;

        // Return an error if the payload was invalid
        match data_notification.data_payload {
            DataPayload::EndOfStream => Ok(()),
            _ => Err(Error::InvalidPayload("Unexpected payload type!".into())),
        }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L241-265)
```rust
        if let Some(number_of_states) = self.number_of_states {
            // Calculate the number of requests to send
            let num_requests_to_send = calculate_num_requests_to_send(
                max_number_of_requests,
                max_in_flight_requests,
                num_in_flight_requests,
            );

            // Calculate the end index
            let end_state_index = number_of_states
                .checked_sub(1)
                .ok_or_else(|| Error::IntegerOverflow("End state index has overflown!".into()))?;

            // Create the client requests
            let client_requests = create_data_client_request_batch(
                self.next_request_index,
                end_state_index,
                num_requests_to_send,
                global_data_summary.optimal_chunk_sizes.state_chunk_size,
                self.clone().into(),
            )?;

            // Return the requests
            self.update_request_tracking(&client_requests)?;
            return Ok(client_requests);
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L268-284)
```rust
        // Otherwise, we need to request the number of states
        info!(
            (LogSchema::new(LogEntry::AptosDataClient)
                .event(LogEvent::Pending)
                .message(&format!(
                    "Requested the number of states at version: {:?}",
                    self.request.version
                )))
        );

        // Return the request
        self.state_num_requested = true;
        Ok(vec![DataClientRequest::NumberOfStates(
            NumberOfStatesRequest {
                version: self.request.version,
            },
        )])
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L373-379)
```rust
                    if number_of_states < self.next_request_index {
                        return Err(Error::NoDataToFetch(format!(
                            "The next state index to fetch is higher than the \
                            total number of states. Next index: {:?}, total states: {:?}",
                            self.next_request_index, number_of_states
                        )));
                    } else {
```

**File:** storage/jellyfish-merkle/src/iterator/mod.rs (L212-220)
```rust
        if start_idx >= current_node.leaf_count() {
            return Ok(Self {
                reader,
                version,
                parent_stack,
                done: true,
                phantom_value: PhantomData,
            });
        }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1123-1127)
```rust
        ensure!(
            !state_key_values.is_empty(),
            "State chunk starting at {}",
            first_index,
        );
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L447-453)
```rust
            || self.request_failure_count >= self.streaming_service_config.max_request_retry
            || self.send_failure
        {
            if !self.send_failure && self.stream_end_notification_id.is_none() {
                self.send_end_of_stream_notification().await?;
            }
            return Ok(()); // There's nothing left to do
```

**File:** config/src/config/state_sync_config.rs (L277-277)
```rust
            max_request_retry: 5,
```
