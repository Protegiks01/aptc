# Audit Report

## Title
Missing Peer ID Validation in Outbound Network Connections Allows Identity Mismatch

## Summary
The outbound connection establishment in the network transport layer fails to validate that the expected `remote_peer_id` parameter correctly matches the cryptographically verified `remote_pubkey`. This allows connections to be established with incorrect peer identity metadata, causing consensus message verification failures and network routing errors.

## Finding Description

The network transport layer establishes outbound connections through the `upgrade_outbound()` function, which receives both an expected `remote_peer_id` and `remote_pubkey` as parameters: [1](#0-0) 

The function performs a Noise IK handshake that cryptographically validates the `remote_pubkey`, but crucially, it never validates that the `remote_peer_id` parameter is correctly derived from that public key. The only check present is a `debug_assert_eq!` on line 373, which is compiled out in release builds: [2](#0-1) 

The Aptos codebase defines a deterministic mapping between x25519 public keys and peer IDs using `from_identity_public_key()`, which takes the last 16 bytes of the 32-byte public key: [3](#0-2) 

In contrast, for **inbound** connections from non-trusted peers, the code correctly validates this relationship in `MaybeMutual` authentication mode: [4](#0-3) 

However, this validation is **completely absent** for outbound connections in the `upgrade_outbound()` function: [5](#0-4) 

The vulnerability can be triggered through two paths:

1. **Malicious Onchain Validator Registration**: The `update_network_and_fullnode_addresses()` function in the staking module accepts arbitrary network addresses without validating the relationship between the validator's account address and their network public key: [6](#0-5) 

2. **Configuration Validation Gap**: The seed peer verification function only checks that addresses are valid and that public keys exist, but does not validate the peer_id-to-pubkey relationship: [7](#0-6) 

**Attack Scenario:**

A malicious validator registers on-chain with account address `A` and network public key `K`, where `A â‰  from_identity_public_key(K)`. When honest nodes discover this validator through onchain discovery, they attempt to dial with `peer_id=A` and `pubkey=K`. The outbound connection succeeds with `ConnectionMetadata.remote_peer_id=A`, but the actual peer's identity is `from_identity_public_key(K)`.

This identity mismatch causes critical failures:

1. **Consensus Message Verification Failure**: When the malicious validator sends a vote, the consensus layer validates that the sender matches the vote author. The check in `VoteMsg::verify()` compares the vote's author against the sender (which is the incorrect peer_id from ConnectionMetadata): [8](#0-7) 

Since `vote.author() = from_identity_public_key(K)` but `sender = A`, the verification fails and the vote is rejected.

2. **Message Routing Errors**: The peer manager stores connections indexed by peer_id and routes messages using this index: [9](#0-8) 

Messages intended for the real peer `from_identity_public_key(K)` cannot be delivered because the connection is stored under the wrong peer_id `A`.

## Impact Explanation

This vulnerability represents a **Medium Severity** issue under the Aptos bug bounty program criteria. While it does not directly cause consensus safety violations or fund theft, it creates significant operational disruptions:

- **Network Liveness Degradation**: Validators with mismatched identities cannot participate in consensus because their votes are systematically rejected
- **Message Routing Failures**: Critical consensus messages cannot reach their intended recipients
- **Partial Network Partition**: If multiple validators are affected, consensus can stall
- **Denial of Service**: The attack effectively makes both the misconfigured peer_id and the actual peer unreachable

The issue does not reach Critical severity because:
- Cryptographic signatures on consensus messages prevent vote forgery
- The malicious validator cannot impersonate other validators or steal funds
- The attack causes availability problems, not consensus safety breaks
- Recovery is possible through validator reconfiguration

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires either:
1. A malicious validator successfully registering on-chain with a mismatched identity
2. An honest configuration error by node operators

The onchain registration path is feasible because the `update_network_and_fullnode_addresses()` function performs no validation. A determined attacker who gains validator status could exploit this.

The configuration error path is less likely but possible during manual setup or if configuration generation tools have bugs.

The impact is immediate once triggered, as all subsequent outbound connections to the affected peer will have incorrect metadata.

## Recommendation

Add explicit validation that the `remote_peer_id` parameter matches the `remote_pubkey` in the `upgrade_outbound()` function:

```rust
// In network/framework/src/transport/mod.rs::upgrade_outbound()
// After line 344, add validation:

// Validate that remote_peer_id matches the public key
let derived_peer_id = aptos_types::account_address::from_identity_public_key(remote_pubkey);
if remote_peer_id != derived_peer_id {
    return Err(io::Error::new(
        io::ErrorKind::InvalidInput,
        format!(
            "Peer ID mismatch: expected {} (derived from pubkey), got {}",
            derived_peer_id, remote_peer_id
        ),
    ));
}
```

Additionally, add validation in the onchain staking module to prevent malicious registrations:

```move
// In aptos-move/framework/aptos-framework/sources/stake.move
// In update_network_and_fullnode_addresses(), validate addresses contain
// a public key that matches the pool_address
```

And strengthen configuration validation:

```rust
// In config/src/config/network_config.rs::verify_seeds()
// Validate peer_id matches at least one public key:
for (peer_id, seed) in self.seeds.iter() {
    let keys_match = seed.keys.iter().any(|key| {
        aptos_types::account_address::from_identity_public_key(*key) == *peer_id
    });
    if !keys_match && !seed.keys.is_empty() {
        return Err(Error::InvariantViolation(format!(
            "Seed peer {} has public keys that don't match the peer_id",
            peer_id.short_str()
        )));
    }
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// File: network/framework/src/transport/test_identity_mismatch.rs

#[cfg(test)]
mod test_identity_mismatch {
    use super::*;
    use aptos_types::account_address::from_identity_public_key;
    use aptos_crypto::x25519;
    use aptos_crypto::traits::Uniform;
    
    #[tokio::test]
    async fn test_outbound_peer_id_mismatch() {
        // Generate a legitimate public key
        let mut rng = rand::thread_rng();
        let remote_privkey = x25519::PrivateKey::generate(&mut rng);
        let remote_pubkey = remote_privkey.public_key();
        
        // Derive the correct peer_id from the public key
        let correct_peer_id = from_identity_public_key(remote_pubkey);
        
        // Use a WRONG peer_id (a random account address)
        let wrong_peer_id = PeerId::random();
        
        // Ensure they're different
        assert_ne!(correct_peer_id, wrong_peer_id);
        
        // Build a network address with the public key
        let addr = format!("/ip4/127.0.0.1/tcp/6180/noise-ik/{}/handshake/0", 
                          remote_pubkey)
            .parse::<NetworkAddress>()
            .unwrap();
        
        // Attempt to dial with mismatched peer_id and pubkey
        // This should fail but currently succeeds
        let result = transport.dial(wrong_peer_id, addr);
        
        // In current implementation: This succeeds (BUG)
        // After fix: This should return an error
        assert!(result.is_err(), 
                "Dial should fail when peer_id doesn't match pubkey");
    }
}
```

**Notes**

The vulnerability exists because outbound connections trust the caller-provided `remote_peer_id` parameter without verifying it matches the cryptographically validated public key. This breaks the identity verification invariant that peer IDs must be deterministically derived from public keys, allowing connections with incorrect identity metadata that cause consensus and routing failures.

### Citations

**File:** network/framework/src/transport/mod.rs (L336-407)
```rust
pub async fn upgrade_outbound<T: TSocket>(
    ctxt: Arc<UpgradeContext>,
    fut_socket: impl Future<Output = io::Result<T>>,
    addr: NetworkAddress,
    remote_peer_id: PeerId,
    remote_pubkey: x25519::PublicKey,
) -> io::Result<Connection<NoiseStream<T>>> {
    let origin = ConnectionOrigin::Outbound;
    let socket = fut_socket.await?;

    // noise handshake
    let (mut socket, peer_role) = ctxt
        .noise
        .upgrade_outbound(
            socket,
            remote_peer_id,
            remote_pubkey,
            AntiReplayTimestamps::now,
        )
        .await
        .map_err(|err| {
            if err.should_security_log() {
                sample!(
                    SampleRate::Duration(Duration::from_secs(15)),
                    warn!(
                        SecurityEvent::NoiseHandshake,
                        NetworkSchema::new(&ctxt.noise.network_context)
                            .network_address(&addr)
                            .connection_origin(&origin),
                        error = %err,
                    )
                );
            }
            io::Error::other(err)
        })?;

    // sanity check: Noise IK should always guarantee this is true
    debug_assert_eq!(remote_pubkey, socket.get_remote_static());

    // exchange HandshakeMsg
    let handshake_msg = HandshakeMsg {
        supported_protocols: ctxt.supported_protocols.clone(),
        chain_id: ctxt.chain_id,
        network_id: ctxt.network_id,
    };
    let remote_handshake = exchange_handshake(&handshake_msg, &mut socket).await?;

    // try to negotiate common aptosnet version and supported application protocols
    let (messaging_protocol, application_protocols) = handshake_msg
        .perform_handshake(&remote_handshake)
        .map_err(|e| {
            let e = format!(
                "handshake negotiation with peer {} failed: {}",
                remote_peer_id, e
            );
            io::Error::other(e)
        })?;

    // return successful connection
    Ok(Connection {
        socket,
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
    })
}
```

**File:** types/src/account_address.rs (L140-146)
```rust
pub fn from_identity_public_key(identity_public_key: x25519::PublicKey) -> AccountAddress {
    let mut array = [0u8; AccountAddress::LENGTH];
    let pubkey_slice = identity_public_key.as_slice();
    // keep only the last 16 bytes
    array.copy_from_slice(&pubkey_slice[x25519::PUBLIC_KEY_SIZE - AccountAddress::LENGTH..]);
    AccountAddress::new(array)
}
```

**File:** network/framework/src/noise/handshake.rs (L183-263)
```rust
    pub async fn upgrade_outbound<TSocket, F>(
        &self,
        mut socket: TSocket,
        remote_peer_id: PeerId,
        remote_public_key: x25519::PublicKey,
        time_provider: F,
    ) -> Result<(NoiseStream<TSocket>, PeerRole), NoiseHandshakeError>
    where
        TSocket: AsyncRead + AsyncWrite + Debug + Unpin,
        F: Fn() -> [u8; AntiReplayTimestamps::TIMESTAMP_SIZE],
    {
        // buffer to hold prologue + first noise handshake message
        let mut client_message = [0; Self::CLIENT_MESSAGE_SIZE];

        // craft prologue = self_peer_id | expected_public_key
        client_message[..PeerId::LENGTH].copy_from_slice(self.network_context.peer_id().as_ref());
        client_message[PeerId::LENGTH..Self::PROLOGUE_SIZE]
            .copy_from_slice(remote_public_key.as_slice());

        let (prologue_msg, client_noise_msg) = client_message.split_at_mut(Self::PROLOGUE_SIZE);

        // craft 8-byte payload as current timestamp (in milliseconds)
        let payload = time_provider();

        // craft first handshake message  (-> e, es, s, ss)
        let mut rng = rand::rngs::OsRng;
        let initiator_state = self
            .noise_config
            .initiate_connection(
                &mut rng,
                prologue_msg,
                remote_public_key,
                Some(&payload),
                client_noise_msg,
            )
            .map_err(NoiseHandshakeError::BuildClientHandshakeMessageFailed)?;

        // send the first handshake message
        trace!(
            "{} noise client: handshake write: remote_public_key: {}",
            self.network_context,
            remote_public_key,
        );
        socket
            .write_all(&client_message)
            .await
            .map_err(NoiseHandshakeError::ClientWriteFailed)?;
        socket
            .flush()
            .await
            .map_err(NoiseHandshakeError::ClientFlushFailed)?;

        // receive the server's response (<- e, ee, se)
        trace!(
            "{} noise client: handshake read: remote_public_key: {}",
            self.network_context,
            remote_public_key,
        );
        let mut server_response = [0u8; Self::SERVER_MESSAGE_SIZE];
        socket
            .read_exact(&mut server_response)
            .await
            .map_err(NoiseHandshakeError::ClientReadFailed)?;

        // parse the server's response
        trace!(
            "{} noise client: handshake finalize: remote_public_key: {}",
            self.network_context,
            remote_public_key,
        );
        let (_, session) = self
            .noise_config
            .finalize_connection(initiator_state, &server_response)
            .map_err(NoiseHandshakeError::ClientFinalizeFailed)?;

        // finalize the connection
        let noise_stream = NoiseStream::new(socket, session);
        let peer_role = self.extract_peer_role_from_trusted_peers(remote_peer_id);

        Ok((noise_stream, peer_role))
    }
```

**File:** network/framework/src/noise/handshake.rs (L391-405)
```rust
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L954-995)
```text
    /// Update the network and full node addresses of the validator. This only takes effect in the next epoch.
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** config/src/config/network_config.rs (L318-340)
```rust
    // Verifies both the `seed_addrs` and `seeds` before they're merged
    pub fn verify_seeds(&self) -> Result<(), Error> {
        for (peer_id, addrs) in self.seed_addrs.iter() {
            for addr in addrs {
                Self::verify_address(peer_id, addr)?;
            }
        }

        for (peer_id, seed) in self.seeds.iter() {
            for addr in seed.addresses.iter() {
                Self::verify_address(peer_id, addr)?;
            }

            // Require there to be a pubkey somewhere, either in the address (assumed by `is_aptosnet_addr`)
            if seed.keys.is_empty() && seed.addresses.is_empty() {
                return Err(Error::InvariantViolation(format!(
                    "Seed peer {} has no pubkeys",
                    peer_id.short_str(),
                )));
            }
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/vote_msg.rs (L56-81)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.vote().author() == sender,
            "Vote author {:?} is different from the sender {:?}",
            self.vote().author(),
            sender,
        );
        ensure!(
            self.vote().epoch() == self.sync_info.epoch(),
            "VoteMsg has different epoch"
        );
        ensure!(
            self.vote().vote_data().proposed().round() > self.sync_info.highest_round(),
            "Vote Round should be higher than SyncInfo"
        );
        if let Some((timeout, _)) = self.vote().two_chain_timeout() {
            ensure!(
                timeout.hqc_round() <= self.sync_info.highest_certified_round(),
                "2-chain Timeout hqc should be less or equal than the sync info hqc"
            );
        }
        // We're not verifying SyncInfo here yet: we are going to verify it only in case we need
        // it. This way we avoid verifying O(n) SyncInfo messages while aggregating the votes
        // (O(n^2) signature verifications).
        self.vote().verify(validator)
    }
```

**File:** network/framework/src/peer_manager/mod.rs (L332-405)
```rust
    fn handle_new_connection_event(&mut self, conn: Connection<TSocket>) {
        // Get the trusted peers
        let trusted_peers = match self
            .peers_and_metadata
            .get_trusted_peers(&self.network_context.network_id())
        {
            Ok(trusted_peers) => trusted_peers,
            Err(error) => {
                error!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata_with_address(&conn.metadata),
                    "Failed to get trusted peers for network context: {:?}, error: {:?}",
                    self.network_context,
                    error
                );
                return;
            },
        };

        // Verify that we have not reached the max connection limit for unknown inbound peers
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
        }

        // Add the new peer and update the metric counters
        info!(
            NetworkSchema::new(&self.network_context)
                .connection_metadata_with_address(&conn.metadata),
            "{} New connection established: {}", self.network_context, conn.metadata
        );
        if let Err(error) = self.add_peer(conn) {
            warn!(
                NetworkSchema::new(&self.network_context),
                "Failed to add peer. Error: {:?}", error
            )
        }
        self.update_connected_peers_metrics();
    }
```
