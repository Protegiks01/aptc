# Audit Report

## Title
Backward Incompatibility Risk During `ENABLE_FUNCTION_VALUES` Feature Flag Activation

## Summary
When the `ENABLE_FUNCTION_VALUES` feature flag is activated via governance, the Move bytecode verifier's `max_type_nodes` limit decreases from 256 to 128. This stricter limit causes previously valid modules with type node counts between 129-256 to fail re-verification when loaded, resulting in `UNEXPECTED_VERIFIER_ERROR` and transaction failures for legitimate users. [1](#0-0) 

## Finding Description

The vulnerability manifests through the following code path:

**1. Configuration Change:** When `enable_function_values` is enabled, the verifier config changes: [2](#0-1) 

**2. Cache Invalidation:** The cache manager detects verifier config changes and flushes the verified modules cache: [3](#0-2) 

**3. Re-verification Failure:** When modules are re-loaded, they undergo verification with the new stricter limit. The type node counting logic weights structs and type parameters heavily: [4](#0-3) 

**4. Error Propagation:** Verification failures are converted to invariant violations: [5](#0-4) [6](#0-5) 

**Exploitation Scenario:**
1. Before activation: User publishes module with 200 type nodes (valid under limit=256)
2. Governance activates `ENABLE_FUNCTION_VALUES` flag
3. Config changes: `max_type_nodes: Some(256)` â†’ `Some(128)`
4. Verification cache flushed at epoch/block boundary
5. User transaction calls entry function in their module
6. Module re-verification fails: 200 > 128
7. Transaction aborts with `UNEXPECTED_VERIFIER_ERROR` (StatusCode)

## Impact Explanation

**Severity: Medium** - Meets "State inconsistencies requiring intervention" criteria.

**Impact:**
- Denial of service for legitimately published modules with 129-256 type nodes
- Users cannot execute transactions calling entry functions in affected modules
- Cascading failures for modules depending on affected modules
- Requires manual republishing with simplified type structures
- Module compatibility issues if simplification changes public APIs
- Not a consensus violation (all validators agree on the failure)
- No direct fund loss or theft

**Affected Systems:**
- Any module with complex generic types, nested structures, or heavy parameterization
- Particularly impacts DeFi protocols, NFT contracts, and complex application logic

## Likelihood Explanation

**Likelihood: Medium to High** depending on deployment context

**Factors:**

1. **Pre-existing modules:** Depends on whether modules with 129-256 type nodes exist on the network before activation

2. **Feature flag status:** The flag is included in default features, suggesting it may have been enabled from genesis: [7](#0-6) 

3. **Testing infrastructure:** Module verification workflow exists but may not catch all cases: [8](#0-7) 

4. **Mitigation:** If the feature was genesis-enabled or pre-deployment verification was performed, likelihood is low. If activated on existing networks without checks, likelihood is high.

## Recommendation

**Immediate Fix:**

1. **Add pre-activation validation:** Before enabling `ENABLE_FUNCTION_VALUES`, scan all on-chain modules and verify none exceed the new 128 type node limit.

2. **Provide migration period:** Implement a grace period where both limits are accepted, warning module owners to update.

3. **Better error handling:** Instead of `UNEXPECTED_VERIFIER_ERROR`, return a more informative error indicating the module needs updating for new verification rules.

**Long-term Fix:**

```rust
// In aptos-move/aptos-vm-environment/src/prod_configs.rs
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    // ... existing code ...
    
    // Use a separate feature flag for stricter limits to decouple from function values
    let use_strict_type_limits = features.is_enabled(FeatureFlag::STRICT_TYPE_LIMITS);
    
    VerifierConfig {
        // ... other fields ...
        max_type_nodes: if use_strict_type_limits {
            Some(128)
        } else {
            Some(256)
        },
        // ...
    }
}
```

**Deployment Process:**
1. Add `STRICT_TYPE_LIMITS` flag (disabled by default)
2. Deploy code update
3. Run full module verification against new limit
4. If issues found, notify module owners
5. After migration period, enable flag via governance

## Proof of Concept

```rust
// Rust test demonstrating the issue
#[test]
fn test_type_node_limit_breaking_change() {
    use move_binary_format::CompiledModule;
    use move_bytecode_verifier::VerifierConfig;
    
    // Create a module with 200 type nodes (within old limit)
    let module = create_module_with_type_nodes(200);
    
    // Verify with old config (max_type_nodes = 256)
    let old_config = VerifierConfig {
        max_type_nodes: Some(256),
        // ... other fields with defaults
    };
    
    let result_old = move_bytecode_verifier::verify_module_with_config(
        &old_config,
        &module
    );
    assert!(result_old.is_ok(), "Module should pass with limit=256");
    
    // Verify with new config (max_type_nodes = 128) 
    let new_config = VerifierConfig {
        max_type_nodes: Some(128),
        // ... other fields same as above
    };
    
    let result_new = move_bytecode_verifier::verify_module_with_config(
        &new_config,
        &module
    );
    assert!(result_new.is_err(), "Module should fail with limit=128");
    assert_eq!(
        result_new.unwrap_err().major_status(),
        StatusCode::TOO_MANY_TYPE_NODES
    );
}
```

**Notes:**
- This issue may have been mitigated if `ENABLE_FUNCTION_VALUES` was enabled from genesis
- The module-verify workflow provides infrastructure for pre-deployment checks
- Impact is limited to networks where the feature flag is activated after modules are published
- Proper deployment planning with pre-activation verification can prevent this issue

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-194)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    // Note: we reuse the `enable_function_values` flag to set various stricter limits on types.

    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
        _use_signature_checker_v2: true,
        sig_checker_v2_fix_script_ty_param_count,
        sig_checker_v2_fix_function_signatures,
        enable_enum_types,
        enable_resource_access_control,
        enable_function_values,
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
    }
}
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L117-126)
```rust
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
            }
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L127-195)
```rust
    fn verify_type_node(
        &self,
        config: &VerifierConfig,
        ty: &SignatureToken,
    ) -> PartialVMResult<()> {
        if config.max_type_nodes.is_none()
            && config.max_function_parameters.is_none()
            && config.max_function_return_values.is_none()
            && config.max_type_depth.is_none()
        {
            // If no type-related limits are set, we do not need to verify the type nodes.
            return Ok(());
        }
        // Structs and Parameters can expand to an unknown number of nodes, therefore
        // we give them a higher size weight here.
        const STRUCT_SIZE_WEIGHT: usize = 4;
        const PARAM_SIZE_WEIGHT: usize = 4;
        let mut type_size = 0;
        for (token, depth) in ty.preorder_traversal_with_depth() {
            if let Some(limit) = config.max_type_depth {
                if depth > limit {
                    return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES));
                }
            }
            match token {
                SignatureToken::Struct(..) | SignatureToken::StructInstantiation(..) => {
                    type_size += STRUCT_SIZE_WEIGHT
                },
                SignatureToken::TypeParameter(..) => type_size += PARAM_SIZE_WEIGHT,
                SignatureToken::Function(params, ret, _) => {
                    if let Some(limit) = config.max_function_parameters {
                        if params.len() > limit {
                            return Err(PartialVMError::new(StatusCode::TOO_MANY_PARAMETERS));
                        }
                    }
                    if let Some(limit) = config.max_function_return_values {
                        if ret.len() > limit {
                            return Err(PartialVMError::new(StatusCode::TOO_MANY_PARAMETERS));
                        }
                    }
                    type_size += 1;
                },
                SignatureToken::Bool
                | SignatureToken::U8
                | SignatureToken::U16
                | SignatureToken::U32
                | SignatureToken::U64
                | SignatureToken::U128
                | SignatureToken::U256
                | SignatureToken::I8
                | SignatureToken::I16
                | SignatureToken::I32
                | SignatureToken::I64
                | SignatureToken::I128
                | SignatureToken::I256
                | SignatureToken::Address
                | SignatureToken::Signer
                | SignatureToken::Vector(_)
                | SignatureToken::Reference(_)
                | SignatureToken::MutableReference(_) => type_size += 1,
            }
        }
        if let Some(limit) = config.max_type_nodes {
            if type_size > limit {
                return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES));
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/logging.rs (L11-42)
```rust
pub fn expect_no_verification_errors(err: VMError) -> VMError {
    match err.status_type() {
        status_type @ StatusType::Deserialization | status_type @ StatusType::Verification => {
            let message = format!(
                "Unexpected verifier/deserialization error! This likely means there is code \
                stored on chain that is unverifiable!\nError: {:?}",
                &err
            );
            let (
                _old_status,
                _old_sub_status,
                _old_message,
                _stacktrace,
                location,
                indices,
                offsets,
            ) = err.all_data();
            let major_status = match status_type {
                StatusType::Deserialization => StatusCode::UNEXPECTED_DESERIALIZATION_ERROR,
                StatusType::Verification => StatusCode::UNEXPECTED_VERIFIER_ERROR,
                _ => unreachable!(),
            };

            PartialVMError::new(major_status)
                .with_message(message)
                .at_indices(indices)
                .at_code_offsets(offsets)
                .finish(location)
        },
        _ => err,
    }
}
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L125-133)
```rust
    fn unmetered_get_existing_eagerly_verified_module(
        &self,
        address: &AccountAddress,
        module_name: &IdentStr,
    ) -> VMResult<Arc<Module>> {
        self.unmetered_get_eagerly_verified_module(address, module_name)
            .map_err(expect_no_verification_errors)?
            .ok_or_else(|| module_linker_error!(address, module_name))
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L258-258)
```rust
            FeatureFlag::ENABLE_FUNCTION_VALUES,
```

**File:** .github/workflows/module-verify.yaml (L1-1)
```yaml
# This defines a workflow to verify all modules that have been published on chain with the latest aptos node software.
```
