# Audit Report

## Title
Rosetta API Silent Operation Drop for Unsupported Fungible Assets Causes State Desynchronization

## Summary
The Rosetta API's `Transaction::from_transaction()` function silently drops withdraw and deposit operations for fungible assets that are not in the server's static currency configuration. This causes the Rosetta representation to desynchronize from actual on-chain state, leading to incomplete transaction histories and incorrect balance tracking for external systems relying on the API.

## Finding Description

The vulnerability exists in the Rosetta API's transaction preprocessing logic. When processing fungible asset (FA) transfers, the system maintains two critical hashmaps:
- `object_to_owner`: Maps fungible store addresses to their owners
- `store_to_currency`: Maps fungible store addresses to their currency types [1](#0-0) 

During the preprocessing phase, when a FungibleStore resource is encountered, the system attempts to identify its associated currency: [2](#0-1) 

The critical flaw is that if the fungible asset's metadata address is not in the server's static `currencies` set, the `store_to_currency` map is never populated (line 2149-2151 only insert if currency is found).

Later, when generating operations, the system attempts to retrieve the currency: [3](#0-2) 

If the currency is not found in the map (lines 2167-2170), the function returns empty operations without any error. This silently drops all withdraw and deposit operations for that fungible asset.

The currency list is loaded statically at server initialization: [4](#0-3) [5](#0-4) 

There is no mechanism to dynamically update this list after startup.

**Attack Scenario:**
1. Rosetta server starts with a static currency list (APT, USDC, and currencies from config file)
2. A new fungible asset is deployed on-chain with metadata address `0xNEW_FA`
3. User transfers 1000 units of the new FA from Alice to Bob
4. On-chain: Transaction succeeds, FungibleStore balances update, Withdraw/Deposit events emit
5. Rosetta API: During preprocessing, `parse_fungible_store_metadata` cannot find `0xNEW_FA` in currencies list
6. `store_to_currency` map remains empty for this store
7. `parse_fungible_store_changes` returns empty operations (no withdraw, no deposit shown)
8. Rosetta API shows the transaction with gas fees but no asset transfers
9. External systems querying Rosetta see incomplete transaction data

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty program: "State inconsistencies requiring intervention."

The impact includes:
- **Incorrect Balance Tracking**: Exchanges and wallets relying on Rosetta for balance queries will show incorrect amounts for new fungible assets
- **Silent Data Loss**: Operations are dropped without error, making the issue difficult to detect
- **Accounting Errors**: Systems using Rosetta for financial reconciliation will have mismatched records
- **Requires Manual Intervention**: The only fix is to update the currency config file and restart the Rosetta server

While this does not affect blockchain consensus or on-chain state (which remains correct), it breaks the Rosetta API's fundamental guarantee of accurately representing on-chain transactions. This is particularly severe because the failure is silent rather than returning an error.

## Likelihood Explanation

**Likelihood: High**

This vulnerability will trigger automatically whenever:
1. A new fungible asset is deployed on mainnet (common occurrence as ecosystem grows)
2. The Rosetta server's currency configuration is not updated
3. Transactions involving that asset occur

No malicious intent is required - this is a natural consequence of normal blockchain operation. Given Aptos's growing ecosystem, new fungible assets are deployed regularly, making this a frequently occurring issue.

The vulnerability affects all Rosetta deployments that don't proactively update their currency configurations for every new FA deployment.

## Recommendation

Implement dynamic currency discovery instead of relying on static configuration:

1. **Query On-Demand**: When encountering an unknown fungible asset metadata address during transaction processing, query the blockchain to retrieve the asset's metadata (name, symbol, decimals) and cache it.

2. **Add Warning Logs**: When a fungible asset is encountered that's not in the currency list, log a warning (don't just silently drop operations).

3. **Return Errors**: Instead of returning empty operations, return an error that the transaction contains unsupported currencies, allowing clients to know data is incomplete.

4. **Periodic Currency Sync**: Implement a background task that periodically scans for new fungible assets and updates the currency list.

Example fix for `parse_fungible_store_metadata`:

```rust
fn parse_fungible_store_metadata(
    currencies: &HashSet<Currency>,
    version: u64,
    address: AccountAddress,
    data: &[u8],
    store_to_currency: &mut HashMap<AccountAddress, Currency>,
    rest_client: &Arc<aptos_rest_client::Client>, // Add client parameter
) {
    // ... existing parsing code ...
    
    let metadata_address = fungible_store.metadata();
    let maybe_currency = find_fa_currency(currencies, metadata_address);
    if let Some(currency) = maybe_currency {
        store_to_currency.insert(address, currency);
    } else {
        // NEW: Query metadata on-demand and cache it
        warn!(
            "Fungible asset at {} not in supported currencies, attempting dynamic lookup at version {}",
            metadata_address, version
        );
        // Query FA metadata from blockchain and create Currency object
        // Then insert into store_to_currency
    }
}
```

## Proof of Concept

**Reproduction Steps:**

1. Deploy a new fungible asset on Aptos testnet with metadata address `0xTEST_FA`
2. Start Rosetta server with default currency configuration (does not include `0xTEST_FA`)
3. Execute a transfer transaction: Alice sends 1000 units of `0xTEST_FA` to Bob
4. Query the transaction via Rosetta API `/block/transaction` endpoint
5. Observe that the returned transaction operations list is empty or only contains gas fees
6. Compare with on-chain data via REST API - the FungibleStore balances are correctly updated
7. Verify Withdraw/Deposit events were emitted on-chain
8. Confirm Rosetta API shows incomplete data

**Expected Result**: Rosetta should show withdraw and deposit operations matching on-chain events.

**Actual Result**: Rosetta silently drops the operations, showing an incomplete transaction.

This can be tested programmatically by:
```rust
#[tokio::test]
async fn test_unsupported_fa_operations_dropped() {
    // 1. Set up Rosetta context with limited currency list
    let currencies = HashSet::from([native_coin()]);
    let context = RosettaContext::new(client, chain_id, cache, currencies).await;
    
    // 2. Create a transaction with FungibleStore changes for unsupported FA
    // 3. Call Transaction::from_transaction()
    // 4. Assert that operations list is empty despite on-chain changes
    // 5. Verify store_to_currency map is empty for the FA store address
}
```

---

**Notes:**

This vulnerability specifically affects the Rosetta API's ability to accurately represent fungible asset transfers for assets not in its static configuration. While the blockchain state remains correct and secure, external systems relying on Rosetta for transaction indexing and balance tracking will receive incomplete data, potentially leading to accounting discrepancies and user confusion. The silent nature of the failure (no errors returned) makes it particularly problematic as it can go undetected until users report balance mismatches.

### Citations

**File:** crates/aptos-rosetta/src/types/objects.rs (L942-943)
```rust
            let mut object_to_owner = HashMap::new();
            let mut store_to_currency = HashMap::new();
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L2128-2152)
```rust
fn parse_fungible_store_metadata(
    currencies: &HashSet<Currency>,
    version: u64,
    address: AccountAddress,
    data: &[u8],
    store_to_currency: &mut HashMap<AccountAddress, Currency>,
) {
    let fungible_store: FungibleStoreResource = if let Ok(fungible_store) = bcs::from_bytes(data) {
        fungible_store
    } else {
        warn!(
            "Fungible store failed to parse for address {} at version {} : {}",
            address,
            version,
            hex::encode(data)
        );
        return;
    };

    let metadata_address = fungible_store.metadata();
    let maybe_currency = find_fa_currency(currencies, metadata_address);
    if let Some(currency) = maybe_currency {
        store_to_currency.insert(address, currency);
    }
}
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L2157-2182)
```rust
fn parse_fungible_store_changes(
    object_to_owner: &HashMap<AccountAddress, AccountAddress>,
    store_to_currency: &HashMap<AccountAddress, Currency>,
    address: AccountAddress,
    events: &[ContractEvent],
    mut operation_index: u64,
) -> ApiResult<Vec<Operation>> {
    let mut operations = vec![];

    // Find the fungible asset currency association
    let maybe_currency = store_to_currency.get(&address);
    if maybe_currency.is_none() {
        return Ok(operations);
    }
    let currency = maybe_currency.unwrap();

    // If there's a currency, let's fill in operations
    // If we don't have an owner here, there's missing data on the writeset
    let maybe_owner = object_to_owner.get(&address);
    if maybe_owner.is_none() {
        warn!(
            "First pass did not catch owner for fungible store \"{}\", returning no operations",
            address
        );
        return Ok(operations);
    }
```

**File:** crates/aptos-rosetta/src/lib.rs (L54-77)
```rust
impl RosettaContext {
    pub async fn new(
        rest_client: Option<Arc<aptos_rest_client::Client>>,
        chain_id: ChainId,
        block_cache: Option<Arc<BlockRetriever>>,
        mut currencies: HashSet<Currency>,
    ) -> Self {
        // Always add APT
        currencies.insert(native_coin());

        // Depending on the chain add appropriate USDC
        if chain_id.is_mainnet() {
            currencies.insert(usdc_currency());
        } else if chain_id.is_testnet() {
            currencies.insert(usdc_testnet_currency());
        }

        RosettaContext {
            rest_client,
            chain_id,
            block_cache,
            currencies,
        }
    }
```

**File:** crates/aptos-rosetta/src/main.rs (L241-269)
```rust
    fn supported_currencies(&self) -> HashSet<Currency> {
        let mut supported_currencies = HashSet::new();
        supported_currencies.insert(native_coin());

        if let Some(ref filepath) = self.currency_config_file {
            let file = File::open(filepath).unwrap();
            let currencies: Vec<Currency> = serde_json::from_reader(file).unwrap();
            for item in currencies.into_iter() {
                // Do a safety check on possible currencies on startup
                if item.symbol.as_str() == "" {
                    warn!(
                        "Currency {:?} has an empty symbol, and is being skipped",
                        item
                    );
                } else if let Some(metadata) = item.metadata.as_ref() {
                    if let Some(move_type) = metadata.move_type.as_ref() {
                        if StructTag::from_str(move_type).is_ok() {
                            supported_currencies.insert(item);
                            continue;
                        }
                    }
                    warn!(
                        "Currency {:?} has an invalid metadata coin type, and is being skipped",
                        item
                    );
                } else {
                    supported_currencies.insert(item);
                }
            }
```
