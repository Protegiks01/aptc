# Audit Report

## Title
Buffer Overflow Panic in Transaction Filter Address Standardization Causes Indexer API Crash

## Summary
The `standardize_address()` function in the transaction filter utility lacks input validation for address length, allowing attackers to trigger a panic via buffer overflow when processing user-supplied filter addresses. This causes the indexer-grpc API service to crash when handling malicious `GetTransactionsRequest` messages.

## Finding Description

The vulnerability exists in the address standardization logic used by transaction filters. [1](#0-0) 

The critical issue occurs at line 33, where the function attempts to pad an address with leading zeros without validating the input length: [2](#0-1) 

When `trimmed.len() > 64`, the expression `64 - trimmed.len()` causes:
- **Debug mode**: Panic with "attempt to subtract with overflow"  
- **Release mode**: Integer wraparound to a massive value (e.g., `usize::MAX - 35`), then panic on `ZEROS[..huge_number]` with "index out of bounds"

The vulnerability is triggered during filter creation from protobuf messages. When a `UserTransactionFilter` is constructed from a protobuf message, the `From` trait implementation immediately calls `standardize_address()`: [3](#0-2) 

This occurs during request parsing before any filter matching happens: [4](#0-3) 

The `validate_state()` method for filters does not check address format or length: [5](#0-4) 

**Attack Path:**
1. Attacker sends `GetTransactionsRequest` with `transaction_filter` containing a malicious address (e.g., `"0x" + "1" * 100`)
2. `parse_transaction_filter()` calls `BooleanTransactionFilter::new_from_proto()` [6](#0-5) 
3. Filter conversion invokes `UserTransactionFilter::from()` which calls `standardize_address()` in `OnceCell::with_value()`
4. `standardize_address()` panics with buffer overflow
5. Panic propagates through gRPC handler, crashing the service task

The same vulnerability affects `EntryFunctionFilter` and `MoveStructTagFilter` which also use `standardize_address()`: [7](#0-6) [8](#0-7) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria (API crashes). The indexer-grpc services are critical infrastructure that:
- Stream transaction data to indexers and applications
- Enable real-time blockchain data access
- Support the entire Aptos ecosystem

A successful attack causes:
- **API Denial of Service**: Indexer-grpc services crash or become unavailable
- **Ecosystem Disruption**: Applications and indexers cannot sync blockchain data
- **Resource Exhaustion**: Repeated malicious requests waste server resources and fill logs
- **No Authentication Required**: Any client can send malicious gRPC requests

The vulnerability affects all indexer-grpc service implementations: [9](#0-8) 

Note: Transaction addresses from the blockchain are safe because they're converted using `AccountAddress::to_string()` which always produces valid 3-66 character strings. [10](#0-9) 

## Likelihood Explanation

**Likelihood: High**

- **Trivial to Exploit**: Single malformed gRPC request triggers crash
- **No Authentication**: Anyone can send `GetTransactionsRequest` messages  
- **No Special Privileges**: Attacker needs no validator access or special permissions
- **Multiple Attack Vectors**: Affects `UserTransactionFilter`, `EntryFunctionFilter`, and `MoveStructTagFilter`
- **Immediate Impact**: Panic occurs during request parsing, not requiring specific blockchain state

## Recommendation

Add input validation to `standardize_address()` or in the filter's `validate_state()` method:

**Option 1: Validate in `standardize_address()`**
```rust
pub fn standardize_address(address: &str) -> Result<String, String> {
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    // Validate address length (max 64 hex chars for 32-byte address)
    if trimmed.len() > 64 {
        return Err(format!("Address too long: {} characters (max 64)", trimmed.len()));
    }
    
    // Existing logic...
}
```

**Option 2: Validate in filter construction**
```rust
impl From<aptos_protos::indexer::v1::UserTransactionFilter> for UserTransactionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::UserTransactionFilter) -> Self {
        let standardized_sender = proto_filter.sender.as_ref().and_then(|address| {
            // Validate before standardization
            let trimmed = address.strip_prefix("0x").unwrap_or(address);
            if trimmed.len() <= 64 {
                Some(standardize_address(address))
            } else {
                None // Invalid address, will fail validation
            }
        });
        // Return filter, validation happens in validate_state()
    }
}
```

**Option 3: Add validation to `validate_state()`**
```rust
fn validate_state(&self) -> Result<(), FilterError> {
    if let Some(sender) = &self.sender {
        let trimmed = sender.strip_prefix("0x").unwrap_or(sender);
        if trimmed.len() > 64 {
            return Err(Error::msg("Sender address exceeds maximum length of 64 hex characters").into());
        }
    }
    // Existing validation...
}
```

The recommended approach is **Option 3** because it keeps validation in the designated validation method and provides clear error messages to clients.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_standardize_address_buffer_overflow() {
    use aptos_transaction_filter::utils::standardize_address;
    
    // Create an address string longer than 64 hex characters
    let malicious_address = format!("0x{}", "1".repeat(100));
    
    // This will panic due to buffer overflow
    let _ = standardize_address(&malicious_address);
}

#[test]
fn test_malicious_filter_creation() {
    use aptos_transaction_filter::filters::UserTransactionFilterBuilder;
    
    // Create filter with overly long address
    let malicious_address = format!("0x{}", "a".repeat(100));
    
    // This will panic when filter tries to standardize the address
    let filter = UserTransactionFilterBuilder::default()
        .sender(malicious_address)
        .build()
        .unwrap();
        
    // Converting to proto format will also trigger standardization
    let _proto = aptos_protos::indexer::v1::UserTransactionFilter::from(filter);
}
```

To reproduce the full attack:
```rust
// Construct malicious GetTransactionsRequest
let malicious_request = GetTransactionsRequest {
    starting_version: Some(0),
    transactions_count: Some(100),
    transaction_filter: Some(BooleanTransactionFilter {
        filter: Some(boolean_transaction_filter::Filter::ApiFilter(
            ApiFilter {
                filter: Some(api_filter::Filter::UserTransactionFilter(
                    UserTransactionFilter {
                        sender: Some("0x".to_string() + &"1".repeat(100)),
                        payload_filter: None,
                    }
                ))
            }
        ))
    }),
    ..Default::default()
};

// Send to indexer-grpc service - will crash on parse_transaction_filter()
```

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L48-60)
```rust
impl From<aptos_protos::indexer::v1::UserTransactionFilter> for UserTransactionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::UserTransactionFilter) -> Self {
        Self {
            standardized_sender: OnceCell::with_value(
                proto_filter
                    .sender
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            sender: proto_filter.sender,
            payload: proto_filter.payload_filter.map(|f| f.into()),
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L73-80)
```rust
    #[inline]
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.sender.is_none() && self.payload.is_none() {
            return Err(Error::msg("At least one of sender or payload must be set").into());
        };
        self.payload.is_valid()?;
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L145-152)
```rust
impl EntryFunctionFilter {
    fn get_standardized_address(&self) -> &Option<String> {
        self.standardized_address.get_or_init(|| {
            self.address
                .clone()
                .map(|address| standardize_address(&address))
        })
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/localnet_data_service.rs (L63-71)
```rust
        // Parse transaction filter if present.
        let filter = if let Some(proto_filter) = r.transaction_filter {
            Some(parse_transaction_filter(
                proto_filter,
                self.service_context.max_transaction_filter_size_bytes,
            )?)
        } else {
            None
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-15)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs (L37-45)
```rust
impl MoveStructTagFilter {
    /// Returns a memoized standardized address, if an address is provided.
    fn get_standardized_address(&self) -> &Option<String> {
        self.standardized_address.get_or_init(|| {
            self.address
                .as_ref()
                .map(|address| standardize_address(address))
        })
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L861-861)
```rust
                    sender: ut.request.sender.to_string(),
```
