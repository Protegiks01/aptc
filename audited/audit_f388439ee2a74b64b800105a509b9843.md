# Audit Report

## Title
Improper Error Handling in Resource Viewer Bypasses Memory Limit Protection via Panic

## Summary
The move-resource-viewer's `annotate_value` function improperly handles errors from `type_tag()` by using `.unwrap()` instead of propagating errors, causing panics when memory limits are exceeded. This bypasses the Limiter security mechanism and can lead to API service disruption.

## Finding Description
The `Limiter` in [1](#0-0)  is designed to prevent resource exhaustion by enforcing a 100MB limit on annotation operations. The `charge()` method returns `PartialVMResult<()>` to signal limit violations.

However, in the `annotate_value` function, when processing non-U8 vectors, the code calls `ty.type_tag(limit).unwrap()` [2](#0-1) . The `type_tag()` method internally calls `struct_tag()` which invokes `charge()` multiple times [3](#0-2) .

When an attacker crafts a request containing vectors of deeply nested structs with many type arguments, the cumulative `charge()` calls can exceed the limit. Instead of returning a proper error, the `.unwrap()` causes a panic, bypassing the intended security mechanism.

**Attack Flow:**
1. Attacker calls a view function endpoint via the REST API that returns complex data structures
2. The API uses `MoveConverter` which wraps `AptosValueAnnotator` [4](#0-3) 
3. For JSON responses, `try_into_move_value()` calls `view_value()` which invokes `annotate_value()` [5](#0-4) 
4. When processing vectors of complex types at line 911, if the limiter budget is exhausted, the panic occurs

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty program criteria for the following reasons:

1. **Service Availability Impact**: While modern web frameworks catch panics at the thread boundary (preventing complete node crashes), repeated exploitation can cause sustained API unavailability by triggering continuous 500 errors. This degrades service quality for legitimate users.

2. **Security Mechanism Bypass**: The Limiter is a defensive security control designed to prevent resource exhaustion attacks. By panicking instead of returning errors, the code defeats this protection mechanism, allowing attackers to trigger exceptional conditions that should be gracefully handled.

3. **Scope**: This affects the public REST API endpoints (`/view` and resource queries), which are exposed to all external users without authentication requirements.

The impact does not reach High or Critical severity because:
- It does not affect consensus, validator operations, or blockchain state
- It does not lead to fund loss or theft
- It only impacts API availability, not core node functionality
- The panic is contained to the API thread, not the entire process

## Likelihood Explanation
**Likelihood: High**

Exploitation is straightforward because:
1. The vulnerable code path is directly reachable via public REST API endpoints
2. No authentication or special privileges are required
3. Attackers can craft Move structs with arbitrary nesting depth and type parameters
4. The 100MB limit can be reached by accumulating many small charges across deeply nested structures
5. The attack can be automated and repeated

The only requirement is understanding Move type structures and the REST API format, both of which are publicly documented.

## Recommendation
Replace the `.unwrap()` call with proper error propagation using the `?` operator:

**File**: `third_party/move/tools/move-resource-viewer/src/lib.rs`, line 911

**Current code**: [6](#0-5) 

**Fixed code**:
```rust
_ => AnnotatedMoveValue::Vector(
    ty.type_tag(limit)?,  // Changed from .unwrap() to ?
    a.iter()
        .map(|v| self.annotate_value(v, ty.as_ref(), limit))
        .collect::<anyhow::Result<_>>()?,
),
```

This change ensures that limit violations are properly propagated as errors through the call stack, allowing the REST API layer to return appropriate HTTP 400/413 responses to clients instead of panicking.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_limiter_bypass_via_unwrap() {
    use move_resource_viewer::{Limiter, MoveValueAnnotator};
    use move_core_types::value::{MoveValue, MoveStruct};
    
    // Create a deeply nested struct type that will exceed the limit
    // when type_tag() is called during annotation
    let deeply_nested_struct = create_struct_with_many_type_args(100);
    
    // Create a vector containing many instances
    let vector_value = MoveValue::Vector(
        vec![MoveValue::Struct(deeply_nested_struct); 1000]
    );
    
    let mut limiter = Limiter::default();
    let annotator = MoveValueAnnotator::new(test_module_view);
    
    // This should return an error when limit is exceeded,
    // but instead it panics due to .unwrap() at line 911
    let result = annotator.annotate_value(
        &vector_value,
        &FatType::Vector(Box::new(complex_fat_type)),
        &mut limiter
    );
    
    // Expected: result.is_err() == true
    // Actual: panics with "called `Result::unwrap()` on an `Err` value"
}
```

**Notes**

The vulnerability specifically affects the JSON response path for view functions and resource queries exposed through the Aptos REST API. While BCS-encoded responses bypass this code path [7](#0-6) , JSON is the default and most commonly used format.

The issue demonstrates a broader pattern where security mechanisms can be inadvertently bypassed through improper error handling. All similar `.unwrap()` patterns on Limiter-related operations should be audited for the same issue.

### Citations

**File:** third_party/move/tools/move-resource-viewer/src/limit.rs (L10-20)
```rust
pub struct Limiter(usize);

impl Limiter {
    pub fn charge(&mut self, cost: usize) -> PartialVMResult<()> {
        if self.0 < cost {
            return Err(PartialVMError::new(StatusCode::ABORTED)
                .with_message("Query exceeds size limit".to_string()));
        }
        self.0 -= cost;
        Ok(())
    }
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L910-915)
```rust
                _ => AnnotatedMoveValue::Vector(
                    ty.type_tag(limit).unwrap(),
                    a.iter()
                        .map(|v| self.annotate_value(v, ty.as_ref(), limit))
                        .collect::<anyhow::Result<_>>()?,
                ),
```

**File:** third_party/move/tools/move-resource-viewer/src/fat_type.rs (L239-241)
```rust
        limiter.charge(std::mem::size_of::<AccountAddress>())?;
        limiter.charge(self.module.as_bytes().len())?;
        limiter.charge(self.name.as_bytes().len())?;
```

**File:** api/types/src/convert.rs (L66-79)
```rust
pub struct MoveConverter<'a, S> {
    inner: AptosValueAnnotator<'a, S>,
    db: Arc<dyn DbReader>,
    indexer_reader: Option<Arc<dyn IndexerReader>>,
}

impl<'a, S: StateView> MoveConverter<'a, S> {
    pub fn new(
        inner: &'a S,
        db: Arc<dyn DbReader>,
        indexer_reader: Option<Arc<dyn IndexerReader>>,
    ) -> Self {
        Self {
            inner: AptosValueAnnotator::new(inner),
```

**File:** api/types/src/convert.rs (L1011-1012)
```rust
    pub fn try_into_move_value(&self, typ: &TypeTag, bytes: &[u8]) -> Result<MoveValue> {
        self.inner.view_value(typ, bytes)?.try_into()
```

**File:** api/src/view_function.rs (L174-193)
```rust
        AcceptType::Bcs => {
            // The return values are already BCS encoded, but we still need to encode the outside
            // vector without re-encoding the inside values
            let num_vals = values.len();

            // Push the length of the return values
            let mut length = vec![];
            serialize_uleb128(&mut length, num_vals as u64).map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?;

            // Combine all of the return values
            let values = values.into_iter().concat();
            let ret = [length, values].concat();

            BasicResponse::try_from_encoded((ret, &ledger_info, BasicResponseStatus::Ok))
```
