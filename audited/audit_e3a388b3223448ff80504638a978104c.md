# Audit Report

## Title
Lack of DKG Transcript Verification During Epoch Initialization Enables State Inconsistency Attacks on Randomness Protocol

## Summary
The `try_get_rand_config_for_new_epoch()` function in `consensus/src/epoch_manager.rs` explicitly skips cryptographic verification of DKG transcripts when reading them from on-chain storage, relying solely on the assumption that transcripts were verified during initial storage. This missing defense-in-depth check makes the randomness protocol vulnerable to state inconsistency attacks, where Byzantine state sync peers or database corruption could cause validators to accept different transcripts and derive incompatible cryptographic parameters, breaking randomness generation and verification.

## Finding Description

When validators initialize a new epoch and set up randomness generation parameters, they retrieve the DKG transcript from on-chain storage and use it to derive public key shares for all validators: [1](#0-0) 

The critical issue is on line 1063: `// No need to verify the transcript.` The code explicitly skips cryptographic verification of the transcript, which would normally be performed via: [2](#0-1) 

The `get_public_key_share()` function then deterministically extracts public key shares by indexing into the transcript's array without any integrity checks: [3](#0-2) [4](#0-3) 

**Attack Scenario:**

While transcripts ARE verified when initially written to the chain: [5](#0-4) 

The lack of re-verification when reading creates a vulnerability window:

1. **State Sync Attack**: A malicious or compromised state sync peer could serve different validators different versions of the DKGState resource during epoch transitions
2. **Database Corruption**: Local database corruption could cause a validator to read corrupted transcript data
3. **State Inconsistency**: Race conditions or bugs in state sync could cause validators to have temporarily inconsistent views of on-chain state

In any of these scenarios:
- Each validator would deserialize their version of the transcript
- Each validator would derive `pk_shares` arrays based on their different transcripts
- Without verification, no validator would detect the inconsistency
- Validators would proceed to use incompatible cryptographic parameters

This breaks the fundamental invariant that all validators must have identical cryptographic parameters for the randomness protocol to function correctly.

## Impact Explanation

**Critical Severity** - This vulnerability enables consensus violations on randomness:

1. **Randomness Protocol Failure**: If validators derive different `pk_shares`, they cannot verify each other's randomness contributions. Honest validators will reject valid shares or accept invalid ones, preventing randomness generation.

2. **Consensus Split Risk**: Validators using incompatible randomness parameters cannot reach agreement on randomness-dependent operations, potentially causing liveness failures or chain splits.

3. **Silent Failure**: Without verification, the attack goes undetected until randomness generation fails, with no clear indication of the root cause.

4. **Defense-in-Depth Violation**: The system relies on a single verification point (initial write) without defense-in-depth, making it vulnerable to any state consistency issues.

Per the Aptos bug bounty criteria, this qualifies as **Critical Severity** due to consensus/safety violations and potential network availability impact.

## Likelihood Explanation

**Moderate to High Likelihood**:

1. **State Sync Complexity**: State sync is a complex distributed protocol with multiple implementations (fast sync, chunk-based sync), each potentially vulnerable to serving inconsistent data

2. **No Attacker Privilege Required**: A Byzantine actor running a state sync peer can attempt to serve different data to different validators without needing validator privileges

3. **Epoch Transition Window**: The attack window occurs during every epoch transition when validators fetch new DKG configuration

4. **Silent Acceptance**: Without verification, corrupted or malicious data is accepted silently, making the attack difficult to detect

5. **Real-World Precedent**: State sync attacks have affected other blockchain systems, and database corruption is a known operational issue

## Recommendation

Add cryptographic verification of the DKG transcript when reading it from on-chain storage, even though it was verified during initial write. This provides defense-in-depth against state inconsistency:

```rust
// In epoch_manager.rs, replace line 1063 with:
let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
    dkg_session.transcript.as_slice(),
)
.map_err(NoRandomnessReason::TranscriptDeserializationError)?;

// Verify the transcript to ensure consistency
DefaultDKG::verify_transcript(&dkg_pub_params, &transcript)
    .map_err(|e| {
        error!("DKG transcript verification failed during epoch initialization: {:?}", e);
        NoRandomnessReason::TranscriptVerificationFailed(e)
    })?;
```

Add the new error variant:

```rust
pub enum NoRandomnessReason {
    // ... existing variants ...
    TranscriptVerificationFailed(anyhow::Error),
}
```

This ensures that any state inconsistency causing validators to receive different or corrupted transcripts is immediately detected, preventing silent failures in the randomness protocol.

## Proof of Concept

The following scenario demonstrates the vulnerability:

1. **Setup**: Network with 4 validators entering a new epoch
2. **Attack**: Malicious state sync peer serves `validator_0` and `validator_1` transcript version A, while serving `validator_2` and `validator_3` transcript version B (both deserialize successfully but have different `Vs` arrays)
3. **Execution**: 
   - All validators call `try_get_rand_config_for_new_epoch()`
   - Line 1063 skips verification
   - Each group derives different `pk_shares` arrays
   - All validators start randomness generation with incompatible parameters
4. **Result**: 
   - When validators try to verify randomness shares, verification fails
   - Network cannot generate randomness
   - Validators cannot determine the root cause without deep debugging
   - Potential liveness failure for randomness-dependent operations

This demonstrates a **Critical** security gap: the lack of verification transforms what should be a detectable byzantine behavior into a silent protocol failure.

**Notes**

The vulnerability is subtle because under normal operation with honest state sync and no corruption, all validators receive identical transcripts and the system functions correctly. However, security-critical systems must assume byzantine behavior and implement defense-in-depth. The explicit comment "No need to verify the transcript" indicates a conscious decision to skip verification based on the assumption of prior verification, but this violates the principle that cryptographic parameters fetched from external sources (even "trusted" on-chain storage) should be verified at point-of-use to detect any inconsistencies or corruption.

### Citations

**File:** consensus/src/epoch_manager.rs (L1056-1063)
```rust
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_session.transcript.as_slice(),
        )
        .map_err(NoRandomnessReason::TranscriptDeserializationError)?;

        let vuf_pp = WvufPP::from(&dkg_pub_params.pvss_config.pp);

        // No need to verify the transcript.
```

**File:** consensus/src/epoch_manager.rs (L1080-1086)
```rust
        let pk_shares = (0..new_epoch_state.verifier.len())
            .map(|id| {
                transcript
                    .main
                    .get_public_key_share(&dkg_pub_params.pvss_config.wconfig, &Player { id })
            })
            .collect::<Vec<_>>();
```

**File:** types/src/dkg/real_dkg/mod.rs (L332-401)
```rust
    fn verify_transcript(
        params: &Self::PublicParams,
        trx: &Self::Transcript,
    ) -> anyhow::Result<()> {
        // Verify dealer indices are valid.
        let dealers = trx
            .main
            .get_dealers()
            .iter()
            .map(|player| player.id)
            .collect::<Vec<usize>>();
        let num_validators = params.session_metadata.dealer_validator_set.len();
        ensure!(
            dealers.iter().all(|id| *id < num_validators),
            "real_dkg::verify_transcript failed with invalid dealer index."
        );

        let all_eks = params.pvss_config.eks.clone();

        let addresses = params.verifier.get_ordered_account_addresses();
        let dealers_addresses = dealers
            .iter()
            .filter_map(|&pos| addresses.get(pos))
            .cloned()
            .collect::<Vec<_>>();

        let spks = dealers_addresses
            .iter()
            .filter_map(|author| params.verifier.get_public_key(author))
            .collect::<Vec<_>>();

        let aux = dealers_addresses
            .iter()
            .map(|address| (params.pvss_config.epoch, address))
            .collect::<Vec<_>>();

        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;

        // Verify fast path is present if and only if fast_wconfig is present.
        ensure!(
            trx.fast.is_some() == params.pvss_config.fast_wconfig.is_some(),
            "real_dkg::verify_transcript failed with mismatched fast path flag in trx and params."
        );

        if let Some(fast_trx) = trx.fast.as_ref() {
            let fast_dealers = fast_trx
                .get_dealers()
                .iter()
                .map(|player| player.id)
                .collect::<Vec<usize>>();
            ensure!(
                dealers == fast_dealers,
                "real_dkg::verify_transcript failed with inconsistent dealer index."
            );
        }

        if let (Some(fast_trx), Some(fast_wconfig)) =
            (trx.fast.as_ref(), params.pvss_config.fast_wconfig.as_ref())
        {
            fast_trx.verify(fast_wconfig, &params.pvss_config.pp, &spks, &all_eks, &aux)?;
        }

        Ok(())
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L550-563)
```rust
    fn get_public_key_share(
        &self,
        _sc: &Self::SecretSharingConfig,
        player: &Player,
    ) -> Self::DealtPubKeyShare {
        self.subtrs.Vs[player.id]
            .iter()
            .map(|V_i| {
                let affine = V_i.into_affine();

                keys::DealtPubKeyShare::<E>::new(keys::DealtPubKey::new(affine))
            })
            .collect()
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L104-112)
```rust
        // Deserialize transcript and verify it.
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```
