# Audit Report

## Title
Consensus Config Validation Bypass Leading to Network-Wide Downgrade Attack via Silent Deserialization Failure

## Summary
Multiple components use `unwrap_or_default()` when failing to deserialize `OnChainConsensusConfig`, combined with insufficient Move-side validation, allowing malformed consensus config bytes to be stored on-chain. This creates a persistent state corruption where all validators fall back to default consensus parameters (disabling validator transactions and randomness), requiring manual governance intervention to recover.

## Finding Description

The vulnerability exists in the consensus configuration validation and error handling across three critical layers:

**Layer 1: Insufficient Move Validation**
The Move function `consensus_config::set_for_next_epoch()` only validates that config bytes are non-empty, without verifying they can be properly deserialized: [1](#0-0) 

**Layer 2: Silent Native Function Failure**
The native function `validator_txn_enabled_internal()` silently falls back to default when deserialization fails: [2](#0-1) 

**Layer 3: Validator-Side Silent Failure**
Both DKG and consensus epoch managers log errors but continue with default configuration: [3](#0-2) [4](#0-3) [5](#0-4) 

**Attack Flow:**

1. A governance proposal containing malformed consensus config bytes (e.g., `vec![0x99, 0x99, 0x99]`) that are non-empty but not valid BCS-serialized `OnChainConsensusConfig` is created
2. The proposal passes Move validation (line 54 check succeeds)
3. During `aptos_governance::reconfigure()`, the system calls `consensus_config::validator_txn_enabled()`: [6](#0-5) 

4. The native function deserializes the config, fails, returns default (with `is_vtxn_enabled() == false`)
5. The condition at line 687 fails, so `reconfiguration_with_dkg::finish()` is called instead of `try_start()`
6. The `finish()` function applies buffered configs including the malformed bytes: [7](#0-6) 

7. In `consensus_config::on_new_epoch()`, the malformed bytes are written to global storage: [8](#0-7) 

8. At the next epoch, all validators attempt to deserialize the config and fail
9. All validators fall back to default `OnChainConsensusConfig` which has `ValidatorTxnConfig::V0` (disabled): [9](#0-8) 

10. The default config causes `is_vtxn_enabled()` to return `false`, disabling validator transactions and randomness network-wide

**Broken Invariant:** This violates the **State Consistency** invariant - the on-chain config state becomes corrupted with malformed bytes that cannot be properly read by validators, yet the system continues operating with degraded security parameters without explicit acknowledgment or rejection.

## Impact Explanation

**Severity: High** - Significant Protocol Violation

This vulnerability enables a persistent network-wide downgrade attack with the following impacts:

1. **Randomness Disablement**: The default config has `ValidatorTxnConfig::V0`, causing all validators to disable randomness features even if randomness was previously enabled and relied upon for security-critical operations (fair leader election, unpredictable ordering)

2. **Consensus Optimization Degradation**: The default has `order_vote_enabled=false`, degrading consensus performance

3. **Persistent State Corruption**: The malformed bytes remain in on-chain storage indefinitely, requiring another governance proposal to repair

4. **TOCTOU Vulnerability**: The native function check during reconfiguration returns default (making the system think validator transactions are disabled), but still allows the malformed bytes to be stored on-chain, creating a mismatch between expected and actual state

This meets **High Severity** criteria per Aptos bug bounty as it constitutes a "Significant protocol violation" that requires governance intervention to remediate and can disable critical security features.

## Likelihood Explanation

**Likelihood: Medium**

While exploitation requires governance involvement, this is not unrealistic because:

1. **Governance Attacks Are Valid**: Historical DAO exploits demonstrate governance systems can be compromised through economic attacks, flash loans, or social engineering
2. **No Defense-in-Depth**: The system lacks proper validation layers - Move only checks non-empty, native function silently fails, validators silently fall back
3. **Silent Failure**: The use of `unwrap_or_default()` masks the problem during proposal execution, potentially allowing malformed configs to pass unnoticed
4. **Persistent Impact**: Once deployed, the corruption persists indefinitely

The attack requires sufficient governance stake and proposal approval, but the lack of proper validation makes it possible for malformed configs to be accepted if governance participants don't manually verify the config bytes are properly formatted.

## Recommendation

Implement multi-layer validation to reject malformed consensus configs:

**1. Add Move-side deserialization validation:**
```rust
// In consensus_config.move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    // Add validation that config can be deserialized
    assert!(validator_txn_enabled_internal(config), error::invalid_argument(EINVALID_CONFIG));
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

**2. Change native function to return Result instead of using unwrap_or_default:**
```rust
// In natives/consensus_config.rs
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes)
        .map_err(|e| SafeNativeError::InvariantViolation(e.into()))?;
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

**3. In epoch managers, fail hard instead of falling back to default:**
```rust
// In dkg/src/epoch_manager.rs and consensus/src/epoch_manager.rs
let consensus_config = onchain_consensus_config
    .expect("Failed to deserialize consensus config - this should never happen after validation");
```

This ensures malformed configs are rejected during proposal execution rather than silently accepted and causing persistent corruption.

## Proof of Concept

```move
// Governance proposal script that would trigger the vulnerability
script {
    use aptos_framework::aptos_governance;
    use aptos_framework::consensus_config;
    
    fun malformed_config_attack(framework_signer: &signer) {
        // Malformed bytes: non-empty but invalid BCS format
        let malformed_bytes = vector[0x99, 0x99, 0x99, 0x99, 0x99];
        
        // Passes Move validation (non-empty check)
        consensus_config::set_for_next_epoch(framework_signer, malformed_bytes);
        
        // During reconfigure(), native function returns default (false)
        // so finish() is called instead of try_start()
        // But malformed bytes are still stored on-chain
        aptos_governance::reconfigure(framework_signer);
        
        // Result: All validators will fail to deserialize and use default config
        // Randomness is disabled network-wide despite on-chain state suggesting it's configured
    }
}
```

The vulnerability can be demonstrated by:
1. Creating a governance proposal with the above script
2. Observing that `validator_txn_enabled()` returns `false` due to native function fallback
3. Confirming the malformed bytes are stored via `on_new_epoch()`
4. At next epoch, all validators log "Failed to read on-chain consensus config" and operate with default parameters
5. Randomness features remain disabled until manual governance fix

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L59-69)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires ConsensusConfig {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<ConsensusConfig>()) {
            let new_config = config_buffer::extract_v2<ConsensusConfig>();
            if (exists<ConsensusConfig>(@aptos_framework)) {
                *borrow_global_mut<ConsensusConfig>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            };
        }
    }
```

**File:** aptos-move/framework/src/natives/consensus_config.rs (L13-21)
```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).unwrap_or_default();
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

**File:** dkg/src/epoch_manager.rs (L192-196)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        if let Err(error) = &onchain_consensus_config {
            error!("Failed to read on-chain consensus config {}", error);
        }
        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** consensus/src/epoch_manager.rs (L1187-1189)
```rust
        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }
```

**File:** consensus/src/epoch_manager.rs (L1201-1201)
```rust
        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```
