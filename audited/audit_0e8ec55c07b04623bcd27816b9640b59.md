# Audit Report

## Title
Zero-Voting-Power Validators Can Contribute to DKG Transcript Aggregation Under Misconfigured Minimum Stake

## Summary
The DKG transcript aggregation logic in `dkg/src/transcript_aggregation/mod.rs` only verifies that a validator exists in the validator set but does not check if their voting power is greater than zero. If the `minimum_stake` is set to 0 via governance, validators with zero voting power can contribute to DKG transcript aggregation, potentially influencing randomness generation without economic stake.

## Finding Description

The vulnerability exists in the `add()` function of `TranscriptAggregationState`: [1](#0-0) 

The code checks `peer_power.is_some()` which only verifies the validator exists in the validator set, not that they have non-zero voting power. The `get_voting_power()` method returns: [2](#0-1) 

This returns `Some(0)` for a validator with zero voting power if they are in the validator set. The validation function for staking configuration allows `minimum_stake` to be 0: [3](#0-2) 

During epoch transitions, validators are filtered based on `minimum_stake`: [4](#0-3) 

If `minimum_stake == 0`, validators with `voting_power == 0` pass this check and are included in the next epoch's validator set. These zero-voting-power validators can then contribute transcripts that get aggregated: [5](#0-4) 

The voting power is calculated from stake amounts which can all be zero: [6](#0-5) 

## Impact Explanation

**Severity: High** (conditional on governance misconfiguration)

This violates the **Governance Integrity** and **Cryptographic Correctness** invariants. A validator with zero economic stake has no incentive to behave honestly, yet their contribution affects the DKG output (randomness generation or shared key derivation). This could enable:

- Manipulation of on-chain randomness used by applications
- Biased shared secret generation for validator operations
- Undermining the security assumption that DKG participants have economic skin in the game

However, this requires governance to set `minimum_stake = 0`, which is not the default configuration (default is 1M APTOS).

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires:
1. Governance proposal to set `minimum_stake = 0` (allowed but non-default)
2. A validator reducing their stake to exactly 0 through withdrawals
3. DKG running during an epoch where this validator is active

While possible, this scenario requires governance action and is not the default state. However, the code should be defensive and not rely on configuration to prevent security issues.

## Recommendation

Change the validation to explicitly check for non-zero voting power:

```rust
let peer_power = self.epoch_state.verifier.get_voting_power(&sender);
let peer_power_value = peer_power.unwrap_or(0);
ensure!(
    peer_power_value > 0,
    "[DKG] adding peer transcript failed with zero or invalid voting power"
);
```

Alternatively, strengthen the staking configuration validation to prevent `minimum_stake = 0`:

```move
fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
    assert!(
        minimum_stake > 0 && minimum_stake <= maximum_stake && maximum_stake > 0, 
        error::invalid_argument(EINVALID_STAKE_RANGE)
    );
}
```

## Proof of Concept

This PoC demonstrates the validation weakness:

```rust
// Test case for dkg/src/transcript_aggregation/mod.rs
#[test]
fn test_zero_voting_power_validator_contribution() {
    // Setup: Create a validator set with one validator having 0 voting power
    let mut validator_infos = vec![];
    
    // Validator with 0 voting power (would only exist if minimum_stake = 0)
    let zero_power_validator = ValidatorConsensusInfo {
        address: AccountAddress::random(),
        public_key: bls12381::PublicKey::genesis(),
        voting_power: 0, // Zero voting power
    };
    validator_infos.push(zero_power_validator.clone());
    
    // Create ValidatorVerifier
    let verifier = ValidatorVerifier::new(validator_infos);
    
    // Verify that get_voting_power returns Some(0)
    let voting_power = verifier.get_voting_power(&zero_power_validator.address);
    assert_eq!(voting_power, Some(0)); // Returns Some(0), not None
    
    // This would pass the current is_some() check but shouldn't be allowed
    assert!(voting_power.is_some()); // PASSES - but validator has no stake!
}
```

## Notes

This vulnerability represents a **defense-in-depth** issue. While it requires non-default governance configuration to be exploitable, the code should not assume `minimum_stake > 0` and should explicitly verify voting power. The fix is simple and eliminates the dependency on correct governance configuration for security.

### Citations

**File:** dkg/src/transcript_aggregation/mod.rs (L79-83)
```rust
        let peer_power = self.epoch_state.verifier.get_voting_power(&sender);
        ensure!(
            peer_power.is_some(),
            "[DKG] adding peer transcript failed with illegal dealer"
        );
```

**File:** dkg/src/transcript_aggregation/mod.rs (L116-121)
```rust
        trx_aggregator.contributors.insert(metadata.author);
        if let Some(agg_trx) = trx_aggregator.trx.as_mut() {
            S::aggregate_transcripts(&self.dkg_pub_params, agg_trx, transcript);
        } else {
            trx_aggregator.trx = Some(transcript);
        }
```

**File:** types/src/validator_verifier.rs (L503-507)
```rust
    pub fn get_voting_power(&self, author: &AccountAddress) -> Option<u64> {
        self.address_to_validator_index
            .get(author)
            .map(|index| self.validator_infos[*index].voting_power)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1390-1397)
```text
            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1847-1855)
```text
    fun get_next_epoch_voting_power(stake_pool: &StakePool): u64 {
        let value_pending_active = coin::value(&stake_pool.pending_active);
        let value_active = coin::value(&stake_pool.active);
        let value_pending_inactive = coin::value(&stake_pool.pending_inactive);
        spec {
            assume value_pending_active + value_active + value_pending_inactive <= MAX_U64;
        };
        value_pending_active + value_active + value_pending_inactive
    }
```
