# Audit Report

## Title
Distance Spoofing Vulnerability in Peer Network Information Validation Allows Preferential Selection of Malicious Peers

## Summary
The peer monitoring service client insufficiently validates the `distance_from_validators` field for distance values ≥2, allowing malicious peers to spoof their network distance and gain preferential selection for state synchronization requests. This enables resource exhaustion attacks against state sync operations.

## Finding Description

The vulnerability exists in the network information response validation logic. When a peer reports its `distance_from_validators` (the number of network hops from the validator set), the client-side validation performs tiered checks based on the distance value. [1](#0-0) 

For distance values of 0 and 1, the validation correctly enforces that the peer must have the appropriate `PeerRole` (Validator or ValidatorFullNode respectively) based on their authenticated role from the connection handshake. However, for distance values ≥2, the validation only checks that the distance is below the maximum allowed value (100), with **no verification of the peer's role or network topology**.

This means any untrusted peer (including those with `PeerRole::Unknown` on the public network) can claim an artificially low distance value (e.g., distance=2) even if their actual distance is much higher. The test suite explicitly confirms this behavior: [2](#0-1) 

**Attack Flow:**

1. **Malicious node crafts fake response**: A malicious Public Fullnode (PFN) operator runs modified peer monitoring service code that returns a fake `distance_from_validators` value of 2 instead of the honestly calculated distance.

2. **Victim stores spoofed distance**: The victim node receives this response and stores it in the peer metadata because it passes the insufficient validation at lines 137-140.

3. **Preferential selection occurs**: When the state sync data client selects peers for optimistic fetch requests, it uses distance-weighted selection: [3](#0-2) [4](#0-3) 

The selection algorithm groups peers by distance using a BTreeMap (sorted ascending) and selects from lower distance groups first. The malicious peer at spoofed distance=2 is selected before honest peers at true distance=5+, violating fair peer selection.

4. **Attack impact**: The malicious peer can then provide slow/no responses or return data that fails cryptographic verification, causing resource exhaustion.

While a peer scoring mechanism exists, it takes multiple failures before malicious peers are excluded: [5](#0-4) 

Starting from score 50.0 with a malicious multiplier of 0.8, it takes 4 failed responses to drop below the ignore threshold of 25.0 (50 → 40 → 32 → 25.6 → 20.48), during which the malicious peer causes disruption.

## Impact Explanation

This vulnerability qualifies as **High Severity** according to the Aptos bug bounty criteria under "Validator Node Slowdowns (High): DoS through resource exhaustion."

**Why High Severity:**

1. **Resource exhaustion through protocol bug**: The insufficient validation allows malicious peers to manipulate the peer selection protocol, forcing victims to waste resources on failed requests before the scoring mechanism excludes them.

2. **State sync disruption**: Multiple malicious peers can coordinate to persistently occupy the "closest peer" slots, causing delays in state synchronization operations. State sync is critical for validators catching up or new nodes joining the network.

3. **Protocol-level attack**: This exploits a validation bug in the peer monitoring protocol, not a pure network-level attack. The root cause is insufficient validation logic.

**Why NOT Critical:**
- No funds can be stolen or minted
- Consensus safety is preserved (data verification via cryptographic proofs remains intact)
- The network can eventually recover as malicious peers receive low scores
- No permanent network partition occurs

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Low barrier to entry**: Any operator of a Public Fullnode can exploit this by running modified peer monitoring service code. No special privileges, validator access, or stake is required.

2. **Simple exploitation**: The attack requires only returning a fake distance value in a single response field—no complex cryptographic attacks or timing manipulations needed.

3. **High impact-to-effort ratio**: An attacker can cause disruption to state sync operations with minimal resources.

4. **Scalability**: Multiple malicious nodes can be deployed to increase the attack's effectiveness, and they will all pass validation until their scores drop.

5. **Detection difficulty**: The spoofed distance values appear valid and are stored as legitimate peer metadata, making detection non-trivial without topology cross-validation.

## Recommendation

Add role-based validation for all distance values, not just 0 and 1. For distance ≥2, verify that:

1. The peer's role is consistent with the claimed distance (e.g., `PeerRole::Unknown` should have higher minimum distances)
2. Implement cross-validation with other peers' reported distances to detect topology inconsistencies
3. Consider requiring cryptographic proofs of distance (e.g., signed distance certificates from intermediate hops)

Example fix for the validation logic:

```rust
distance_from_validators => {
    // Verify the distance is within bounds
    if distance_from_validators > MAX_DISTANCE_FROM_VALIDATORS {
        return false;
    }
    
    // Additional validation: Unknown peers should have minimum distance
    if peer_metadata.get_connection_metadata().role == PeerRole::Unknown 
        && distance_from_validators < MIN_DISTANCE_FOR_UNKNOWN_PEERS {
        return false;
    }
    
    true
}
```

## Proof of Concept

The existing test code demonstrates the vulnerability: [2](#0-1) 

This test explicitly shows that `PeerRole::Unknown` peers on the public network can successfully claim `distance_from_validators` of 2 or 3, and these values are accepted and stored without any role-based validation.

## Notes

This is a **protocol validation bug** that enables resource exhaustion, not a pure network DoS attack (which would be out of scope). The vulnerability exploits insufficient validation logic in the peer monitoring protocol to manipulate peer selection, falling under the "Validator Node Slowdowns (High): DoS through resource exhaustion" category in the Aptos bug bounty program. The technical claims are verified through direct code inspection and existing test cases that explicitly demonstrate the behavior.

### Citations

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L118-141)
```rust
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L417-426)
```rust
        // Handle two valid responses from a PFN
        for distance_from_validators in [2, 3] {
            handle_response_and_verify_distance(
                &mut network_info_state,
                NetworkId::Public,
                PeerRole::Unknown,
                distance_from_validators,
                Some(distance_from_validators),
            );
        }
```

**File:** state-sync/aptos-data-client/src/client.rs (L349-383)
```rust
    fn choose_peers_for_optimistic_fetch(
        &self,
        request: &StorageServiceRequest,
        serviceable_peers_by_priorities: Vec<HashSet<PeerNetworkId>>,
        num_peers_for_request: usize,
    ) -> crate::error::Result<HashSet<PeerNetworkId>, Error> {
        // Select peers by priority (starting with the highest priority first)
        let mut selected_peers = HashSet::new();
        for serviceable_peers in serviceable_peers_by_priorities {
            // Select peers by distance and latency
            let num_peers_remaining = num_peers_for_request.saturating_sub(selected_peers.len());
            let peers = self.choose_random_peers_by_distance_and_latency(
                serviceable_peers,
                num_peers_remaining,
            );

            // Add the peers to the entire set
            selected_peers.extend(peers);

            // If we have selected enough peers, return early
            if selected_peers.len() >= num_peers_for_request {
                return Ok(selected_peers);
            }
        }

        // If selected peers is empty, return an error
        if !selected_peers.is_empty() {
            Ok(selected_peers)
        } else {
            Err(Error::DataIsUnavailable(format!(
                "Unable to select peers for optimistic fetch request: {:?}",
                request
            )))
        }
    }
```

**File:** state-sync/aptos-data-client/src/utils.rs (L26-64)
```rust
pub fn choose_random_peers_by_distance_and_latency(
    peers: HashSet<PeerNetworkId>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    num_peers_to_choose: usize,
) -> HashSet<PeerNetworkId> {
    // Group peers and latency weights by validator distance, i.e., distance -> [(peer, latency weight)]
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for peer in peers {
        if let Some((distance, latency)) =
            get_distance_and_latency_for_peer(&peers_and_metadata, peer)
        {
            let latency_weight = convert_latency_to_weight(latency);
            peers_and_latencies_by_distance
                .entry(distance)
                .or_insert_with(Vec::new)
                .push((peer, latency_weight));
        }
    }

    // Select the peers by distance and latency weights. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut selected_peers = HashSet::new();
    for (_, peers_and_latencies) in peers_and_latencies_by_distance {
        // Select the peers by latency weights
        let num_peers_remaining = num_peers_to_choose.saturating_sub(selected_peers.len()) as u64;
        let peers = choose_random_peers_by_weight(num_peers_remaining, peers_and_latencies);

        // Add the peers to the entire set
        selected_peers.extend(peers);

        // If we have selected enough peers, return early
        if selected_peers.len() >= num_peers_to_choose {
            return selected_peers;
        }
    }

    // Return the selected peers
    selected_peers
}
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L32-43)
```rust
/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```
