# Audit Report

## Title
Division by Zero in `get_valid_proposer()` Causes Total Network Halt When `contiguous_rounds = 0`

## Summary
The `RotatingProposer::get_valid_proposer()` function performs division by `contiguous_rounds` without validating that this value is non-zero. When a governance proposal sets `ProposerElectionType::RotatingProposer(0)` through on-chain consensus configuration, all validator nodes will crash simultaneously upon attempting to route votes, causing complete network liveness failure.

## Finding Description

The `RotatingProposer` struct accepts a `contiguous_rounds` parameter without validation [1](#0-0) , which is then used in a division operation within `get_valid_proposer()` [2](#0-1) .

When votes are cast, the round manager uses `get_valid_proposer(proposal_round + 1)` to determine the vote recipient [3](#0-2) . If `contiguous_rounds` is 0, the expression `round / u64::from(self.contiguous_rounds)` triggers a division-by-zero panic.

**Attack Propagation Path:**

1. A governance proposal calls `consensus_config::set_for_next_epoch()` with serialized `ProposerElectionType::RotatingProposer(0)` [4](#0-3) 

2. The Move validation only checks that the config bytes are non-empty, not the actual field values [5](#0-4) 

3. On epoch transition via `on_new_epoch()`, the malformed config is applied [6](#0-5) 

4. The epoch manager's `create_proposer_election()` deserializes this config and instantiates `RotatingProposer::new(proposers, 0)` [7](#0-6) 

5. When the first proposal is processed and validators attempt to vote, `get_valid_proposer()` is called, triggering a division-by-zero panic

6. All validator nodes crash simultaneously, halting the network entirely

This breaks the **Consensus Safety** invariant by preventing any consensus progress and the **Deterministic Execution** invariant as the network cannot process any blocks.

## Impact Explanation

This vulnerability meets **Critical Severity** criteria under the Aptos Bug Bounty program:

- **Total loss of liveness/network availability**: All validator nodes crash simultaneously when attempting to process the first proposal after the malicious config is applied. No new blocks can be proposed or voted on.

- **Non-recoverable network partition (requires hardfork)**: Recovery requires coordinated manual intervention across all validator operators to either (a) manually fix the on-chain config before restarting nodes, or (b) deploy a patched binary with input validation that prevents the panic, effectively requiring a coordinated upgrade similar to a hardfork.

The network remains completely halted until remediation, affecting all users and preventing any transactions from being processed.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can manifest in two scenarios:

1. **Malicious Governance Proposal**: An attacker with sufficient stake to submit governance proposals could intentionally craft a proposal with `contiguous_rounds = 0`. Given that governance participants may not thoroughly audit serialized config bytes, such a proposal could pass voting.

2. **Accidental Misconfiguration**: A well-intentioned governance proposal to modify consensus parameters could accidentally set `contiguous_rounds = 0` due to a coding error or misconfiguration. Since there is no validation on the Move side or during Rust deserialization, this error would not be caught.

The likelihood is elevated because:
- No validation exists at any layer (Move, deserialization, or instantiation)
- The consensus config type definition permits `u32` values including 0 [8](#0-7) 
- Governance proposals can be submitted by any participant with minimum stake requirements
- The impact is catastrophic, making this an attractive target for attacks

## Recommendation

Add validation in multiple defensive layers:

**Layer 1 - Constructor Validation:**
```rust
impl RotatingProposer {
    pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Result<Self, anyhow::Error> {
        ensure!(
            contiguous_rounds > 0,
            "contiguous_rounds must be greater than 0"
        );
        ensure!(
            !proposers.is_empty(),
            "proposers list cannot be empty"
        );
        Ok(Self {
            proposers,
            contiguous_rounds,
        })
    }
}
```

**Layer 2 - Deserialization Validation:**

Add a custom deserializer or post-deserialization validation in `OnChainConsensusConfig::deserialize_into_config()` to validate all `ProposerElectionType` variants ensure `contiguous_rounds > 0`.

**Layer 3 - Move-side Validation:**

Add native function validation in `consensus_config.move` to check serialized config validity before accepting the proposal:
```move
native fun validate_consensus_config(config_bytes: vector<u8>): bool;

public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    assert!(validate_consensus_config(config), error::invalid_argument(EINVALID_CONFIG));
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "divide by zero")]
fn test_rotating_proposer_zero_contiguous_rounds_panic() {
    use crate::liveness::{
        proposer_election::ProposerElection,
        rotating_proposer_election::RotatingProposer,
    };
    use aptos_types::account_address::AccountAddress;

    // Create a RotatingProposer with contiguous_rounds = 0
    let proposers = vec![
        AccountAddress::random(),
        AccountAddress::random(),
    ];
    let pe = RotatingProposer::new(proposers, 0);

    // This call will panic with division by zero
    // Simulating what happens when a node tries to determine
    // where to send a vote after processing a proposal
    let _recipient = pe.get_valid_proposer(1);
}

#[test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
fn test_rotating_proposer_empty_proposers_panic() {
    use crate::liveness::{
        proposer_election::ProposerElection,
        rotating_proposer_election::RotatingProposer,
    };

    // Create a RotatingProposer with empty proposers list
    let pe = RotatingProposer::new(vec![], 1);

    // This call will panic with modulo by zero
    let _recipient = pe.get_valid_proposer(1);
}
```

Add these tests to `consensus/src/liveness/rotating_proposer_test.rs` to demonstrate both panic scenarios. Both tests will fail (panic) with the current implementation, confirming the vulnerability.

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L27-32)
```rust
    pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
        Self {
            proposers,
            contiguous_rounds,
        }
    }
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** consensus/src/round_manager.rs (L1411-1418)
```rust
            let recipient = self
                .proposer_election
                .get_valid_proposer(proposal_round + 1);
            info!(
                self.new_log(LogEvent::Vote).remote_peer(recipient),
                "{}", vote
            );
            self.network.send_vote(vote_msg, vec![recipient]).await;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L59-68)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires ConsensusConfig {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<ConsensusConfig>()) {
            let new_config = config_buffer::extract_v2<ConsensusConfig>();
            if (exists<ConsensusConfig>(@aptos_framework)) {
                *borrow_global_mut<ConsensusConfig>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            };
        }
```

**File:** consensus/src/epoch_manager.rs (L297-299)
```rust
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
            },
```

**File:** types/src/on_chain_config/consensus_config.rs (L510-516)
```rust
pub enum ProposerElectionType {
    // Choose the smallest PeerId as the proposer
    // with specified param contiguous_rounds
    FixedProposer(u32),
    // Round robin rotation of proposers
    // with specified param contiguous_rounds
    RotatingProposer(u32),
```
