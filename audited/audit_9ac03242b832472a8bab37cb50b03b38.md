# Audit Report

## Title
Reserved Byte Differentiation Conditionally Disabled: Consensus Divergence Risk During Config Upgrades

## Summary
The `reserved_byte` differentiation for block/chunk execution vs validation/simulation is correctly implemented in `native_monotonically_increasing_counter_internal()`, but is **conditionally disabled** based on `OnChainExecutionConfig` version. Networks running ExecutionConfig V1-V6 use `persisted_auxiliary_info_version = 0`, causing all block execution transactions to abort when calling `monotonically_increasing_counter()`. This creates a consensus safety risk during config upgrade windows and breaks documented native function behavior.

## Finding Description

The native function correctly implements the reserved_byte logic: [1](#0-0) 

However, the actual behavior depends on `persisted_auxiliary_info_version` from the on-chain execution config: [2](#0-1) 

For ExecutionConfig V1-V6 or Missing, this returns **0**, which causes the consensus pipeline to create `PersistedAuxiliaryInfo::None`: [3](#0-2) 

This propagates through the transaction metadata system: [4](#0-3) 

Resulting in `TransactionIndexKind::NotAvailable`, which causes the native function to **abort**: [5](#0-4) 

**Attack Scenario:**
1. Network runs on ExecutionConfig V6 (persisted_auxiliary_info_version = 0)
2. User deploys a contract calling `0x1::transaction_context::monotonically_increasing_counter()`
3. Transaction executes during block processing
4. Native function receives `TransactionIndexKind::NotAvailable`
5. Transaction aborts with `ETRANSACTION_INDEX_NOT_AVAILABLE`

**Consensus Divergence Risk:**
During the upgrade window from V6 to V7, if validators have inconsistent configs:
- Validators on V6: Transaction aborts (NotAvailable)
- Validators on V7: Transaction succeeds (BlockExecution with reserved_byte=0)
- **Result:** Different execution outcomes = consensus divergence violating invariant #1 (Deterministic Execution)

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:
- **Consensus Safety Violation**: During config upgrade periods, validators running different ExecutionConfig versions will produce different execution results for transactions calling this native function, breaking deterministic execution guarantees
- **Significant Protocol Violation**: A documented native function silently fails on networks not upgraded to V7, breaking the API contract

The impact is mitigated only if:
1. All validators upgrade atomically (unlikely)
2. No transactions use this native function (defeats its purpose)
3. The function is considered "not production-ready" (not documented as such)

## Likelihood Explanation

**High Likelihood** because:
1. The native function exists in the framework and is callable by any Move contract
2. Networks not on ExecutionConfig V7 will exhibit this behavior by default
3. The execution config version check happens at line 569 of execution_client.rs during epoch initialization: [6](#0-5) 

4. Default for older networks is `Missing`, which returns version 0: [7](#0-6) 

## Recommendation

**Option 1: Fail-Safe Default**
Change the version 0 behavior to use `PersistedAuxiliaryInfo::TimestampNotYetAssignedV1` instead of `None` for safety:

```rust
// In consensus/src/pipeline/pipeline_builder.rs
let persisted_auxiliary_info = match persisted_auxiliary_info_version {
    0 => PersistedAuxiliaryInfo::TimestampNotYetAssignedV1 { 
        transaction_index: txn_index as u32 
    }, // Safe default
    1 => PersistedAuxiliaryInfo::V1 { 
        transaction_index: txn_index as u32 
    },
    _ => unimplemented!("Unsupported persisted auxiliary info version"),
};
```

**Option 2: Feature Gating**
Add a feature flag check in the native function to gracefully handle unavailable context:

```rust
// In native_monotonically_increasing_counter_internal
TransactionIndexKind::NotAvailable => {
    // For backwards compatibility, use simulation mode
    let reserved_byte = 1u128;
    let transaction_index = 0u32;
    // Continue with counter generation...
}
```

**Option 3: Documentation**
If this is intentional, add Move-level documentation warning that the function requires ExecutionConfig V7+.

## Proof of Concept

**Move Module (deploy on network with ExecutionConfig < V7):**

```move
module 0x1::counter_test {
    use std::transaction_context;
    
    public entry fun test_monotonic_counter() {
        // This will abort with ETRANSACTION_INDEX_NOT_AVAILABLE (code 0x50005)
        // on networks not running ExecutionConfig V7
        let _counter = transaction_context::monotonically_increasing_counter();
    }
}
```

**Reproduction Steps:**
1. Deploy on testnet/devnet with ExecutionConfig V6 or earlier
2. Call `counter_test::test_monotonic_counter()`
3. Observe abort with code `0x50005` (ETRANSACTION_INDEX_NOT_AVAILABLE)

**Consensus Divergence Test:**
1. Set up two validators in same epoch
2. Validator A: ExecutionConfig V6 (persisted_auxiliary_info_version=0)
3. Validator B: ExecutionConfig V7 (persisted_auxiliary_info_version=1)  
4. Submit transaction calling `monotonically_increasing_counter()`
5. Observe: Validator A aborts transaction, Validator B executes successfully
6. Result: Different state roots = consensus fork

## Notes

The comment at line 187-188 correctly describes the intended behavior: [8](#0-7) 

The implementation matches the comment, but the **activation mechanism** via on-chain config was not mentioned, creating a deployment footgun where the feature appears available but is silently disabled on older configs.

### Citations

**File:** aptos-move/framework/src/natives/transaction_context.rs (L187-188)
```rust
        // monotonically_increasing_counter (128 bits) = `<reserved_byte (8 bits)> || timestamp_us (64 bits) || transaction_index (32 bits) || session counter (8 bits) || local_counter (16 bits)`
        // reserved_byte: 0 for block/chunk execution (V1), 1 for validation/simulation (TimestampNotYetAssignedV1)
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L192-204)
```rust
        let (reserved_byte, transaction_index) = match transaction_index_kind {
            TransactionIndexKind::BlockExecution { transaction_index } => {
                (0u128, transaction_index)
            },
            TransactionIndexKind::ValidationOrSimulation { transaction_index } => {
                (1u128, transaction_index)
            },
            TransactionIndexKind::NotAvailable => {
                return Err(SafeNativeError::Abort {
                    abort_code: error::invalid_state(abort_codes::ETRANSACTION_INDEX_NOT_AVAILABLE),
                });
            },
        };
```

**File:** types/src/on_chain_config/execution_config.rs (L86-97)
```rust
    pub fn persisted_auxiliary_info_version(&self) -> u8 {
        match self {
            OnChainExecutionConfig::Missing
            | OnChainExecutionConfig::V1(_)
            | OnChainExecutionConfig::V2(_)
            | OnChainExecutionConfig::V3(_)
            | OnChainExecutionConfig::V4(_)
            | OnChainExecutionConfig::V5(_)
            | OnChainExecutionConfig::V6(_) => 0,
            OnChainExecutionConfig::V7(config) => config.persisted_auxiliary_info_version,
        }
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L137-140)
```rust
    pub fn default_if_missing() -> Self {
        OnChainExecutionConfig::Missing
    }
}
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L835-841)
```rust
                let persisted_auxiliary_info = match persisted_auxiliary_info_version {
                    0 => PersistedAuxiliaryInfo::None,
                    1 => PersistedAuxiliaryInfo::V1 {
                        transaction_index: txn_index as u32,
                    },
                    _ => unimplemented!("Unsupported persisted auxiliary info version"),
                };
```

**File:** types/src/transaction/mod.rs (L3254-3267)
```rust
    pub fn transaction_index_kind(
        &self,
    ) -> crate::transaction::user_transaction_context::TransactionIndexKind {
        use crate::transaction::user_transaction_context::TransactionIndexKind;
        match self.persisted_info {
            PersistedAuxiliaryInfo::V1 { transaction_index } => {
                TransactionIndexKind::BlockExecution { transaction_index }
            },
            PersistedAuxiliaryInfo::TimestampNotYetAssignedV1 { transaction_index } => {
                TransactionIndexKind::ValidationOrSimulation { transaction_index }
            },
            PersistedAuxiliaryInfo::None => TransactionIndexKind::NotAvailable,
        }
    }
```

**File:** consensus/src/pipeline/execution_client.rs (L569-569)
```rust
        let aux_version = onchain_execution_config.persisted_auxiliary_info_version();
```
