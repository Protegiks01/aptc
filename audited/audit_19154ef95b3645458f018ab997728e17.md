# Audit Report

## Title
Byzantine Validator Can Block All Consensus RPC Processing via Shared BoundedExecutor Exhaustion

## Summary
A Byzantine validator can monopolize the shared consensus BoundedExecutor (default 16 threads) by sending slow-to-verify RPC requests, causing all RPC verification tasks to block indefinitely. This prevents honest validators' RPC requests from being processed, resulting in TooManyPending errors and effectively censoring their participation in consensus.

## Finding Description

The Aptos consensus system uses a single shared `BoundedExecutor` with limited capacity (default 16 concurrent tasks) for verifying all incoming consensus RPC messages across multiple subsystems (randomness generation, secret sharing, DAG, etc.). [1](#0-0) [2](#0-1) 

Each RPC verification task processes incoming requests in a loop by calling `bounded_executor.spawn().await` to verify messages: [3](#0-2) [4](#0-3) 

The critical vulnerability lies in the blocking behavior of `BoundedExecutor::spawn()`. When at capacity, this method **blocks** until a permit becomes available: [5](#0-4) [6](#0-5) 

**Attack Execution:**

1. Byzantine validator sends 16 RandGenMessage or SecretShareMessage RPCs containing requests that pass initial validation but are slow to verify (e.g., messages with expensive cryptographic operations)

2. The victim validator's `verification_task` spawns these 16 verification tasks on the shared BoundedExecutor, occupying all 16 slots

3. When the verification_task attempts to process the next RPC (potentially from an honest validator), it calls `bounded_executor.spawn().await` which **blocks** waiting for a free executor slot

4. While the verification_task is blocked on `spawn().await`, it cannot pull any new RPC requests from its channel, including legitimate requests from honest validators

5. Other verification tasks (SecretShare, DAG, etc.) that share the same BoundedExecutor will also block when trying to spawn, creating a cascading failure

6. RPC requests from honest validators accumulate in the per-peer network queues until they hit the limit: [7](#0-6) 

7. Once 100 pending RPCs accumulate, new RPC requests from honest validators receive `RpcError::TooManyPending`: [8](#0-7) 

This breaks consensus fairness guarantees, as honest validators cannot participate in randomness generation, secret sharing, or other consensus protocols requiring RPC communication.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:
- **Validator node slowdowns**: The victim validator cannot process consensus RPCs, severely degrading its ability to participate in consensus
- **Significant protocol violations**: Breaks fairness assumptions that all validators can communicate via RPC
- **Liveness implications**: If enough validators are targeted, consensus liveness could be compromised

The attack targets a fundamental shared resource (the BoundedExecutor) that all consensus RPC types depend on, making it a single point of failure. Unlike per-peer RPC limits at the network layer, this bottleneck affects processing of RPCs from ALL peers simultaneously.

## Likelihood Explanation

**High likelihood:**
- Requires only Byzantine validator status (â‰¥1 Byzantine validator assumed in BFT threat model)
- No special permissions or collusion needed beyond validator set membership
- Attack is deterministic and repeatable
- Default configuration (16 threads) is easily exhaustible with just 16 malicious RPCs
- No existing defense mechanism isolates BoundedExecutor usage per-peer or per-RPC-type

The attacker only needs to craft messages that pass basic validation but are computationally expensive to fully verify (e.g., messages with valid structure but requiring extensive cryptographic checks).

## Recommendation

**Immediate Fix:**
Implement per-peer BoundedExecutor limits or per-RPC-type isolation to prevent a single Byzantine peer from monopolizing shared resources:

```rust
// Option 1: Per-peer bounded executors in verification tasks
// Create separate executor instance with smaller capacity per peer

// Option 2: Use try_spawn() instead of spawn() to avoid blocking
bounded_executor
    .try_spawn(async move { /* verification */ })
    .unwrap_or_else(|_| {
        warn!("Dropped RPC due to executor capacity");
        // Send error response or drop
    });

// Option 3: Increase BoundedExecutor capacity significantly
// and implement per-peer rate limiting before verification
```

**Comprehensive Solution:**
1. Replace blocking `spawn().await` with non-blocking `try_spawn()` that drops messages when at capacity
2. Add per-peer rate limiting before spawning verification tasks
3. Implement separate BoundedExecutor pools per RPC type to isolate failures
4. Add monitoring/alerting when executor capacity is consistently saturated
5. Consider adaptive capacity based on validator set size

## Proof of Concept

**Conceptual Rust Test:**

```rust
// Reproduction steps (conceptual - would need full test harness):

#[tokio::test]
async fn test_bounded_executor_exhaustion() {
    // 1. Create BoundedExecutor with capacity 16
    let executor = BoundedExecutor::new(16, Handle::current());
    
    // 2. Spawn 16 slow verification tasks that block for extended period
    for _ in 0..16 {
        executor.spawn(async {
            // Simulate slow verification (e.g., expensive crypto)
            tokio::time::sleep(Duration::from_secs(60)).await;
        }).await;
    }
    
    // 3. Attempt to spawn 17th task (from honest validator)
    let start = Instant::now();
    executor.spawn(async { /* legitimate RPC */ }).await;
    let elapsed = start.elapsed();
    
    // 4. Verify that spawn blocked for significant time
    assert!(elapsed > Duration::from_secs(50)); // Blocked until slot available
    
    // This demonstrates that while Byzantine validator's 16 tasks occupy
    // the executor, legitimate RPCs cannot be processed
}
```

**Real-world exploitation:**
1. Deploy Byzantine validator node in network
2. Modify `RandGenMessage` or `SecretShareMessage` to include valid but computation-intensive verification payloads
3. Send 16 such messages to target honest validator
4. Observe that target validator stops processing RPC requests from all peers
5. Monitor target validator logs for `TooManyPending` errors on incoming RPCs

### Citations

**File:** consensus/src/consensus_provider.rs (L81-84)
```rust
    let bounded_executor = BoundedExecutor::new(
        node_config.consensus.num_bounded_executor_tasks as usize,
        runtime.handle().clone(),
    );
```

**File:** config/src/config/consensus_config.rs (L379-379)
```rust
            num_bounded_executor_tasks: 16,
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L221-260)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingRandGenRequest>,
        verified_msg_tx: UnboundedSender<RpcRequest<S, D>>,
        rand_config: RandConfig,
        fast_rand_config: Option<RandConfig>,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(rand_gen_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = rand_config.clone();
            let fast_config_clone = fast_rand_config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
                        Ok(msg) => {
                            if msg
                                .verify(
                                    &epoch_state_clone,
                                    &config_clone,
                                    &fast_config_clone,
                                    rand_gen_msg.sender,
                                )
                                .is_ok()
                            {
                                let _ = tx.unbounded_send(RpcRequest {
                                    req: msg,
                                    protocol: rand_gen_msg.protocol,
                                    response_sender: rand_gen_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid rand gen message: {}", e);
                        },
                    }
                })
                .await;
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-234)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
```

**File:** crates/bounded-executor/src/executor.rs (L33-35)
```rust
    async fn acquire_permit(&self) -> OwnedSemaphorePermit {
        self.semaphore.clone().acquire_owned().await.unwrap()
    }
```

**File:** crates/bounded-executor/src/executor.rs (L41-52)
```rust
    /// Spawn a [`Future`] on the `BoundedExecutor`. This function is async and
    /// will block if the executor is at capacity until one of the other spawned
    /// futures completes. This function returns a [`JoinHandle`] that the caller
    /// can `.await` on for the results of the [`Future`].
    pub async fn spawn<F>(&self, future: F) -> JoinHandle<F::Output>
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
    {
        let permit = self.acquire_permit().await;
        self.executor.spawn(future_with_permit(future, permit))
    }
```

**File:** network/framework/src/constants.rs (L15-15)
```rust
pub const MAX_CONCURRENT_INBOUND_RPCS: u32 = 100;
```

**File:** network/framework/src/protocols/rpc/mod.rs (L213-222)
```rust
        if self.inbound_rpc_tasks.len() as u32 == self.max_concurrent_inbound_rpcs {
            // Increase counter of declined requests
            counters::rpc_messages(
                network_context,
                REQUEST_LABEL,
                INBOUND_LABEL,
                DECLINED_LABEL,
            )
            .inc();
            return Err(RpcError::TooManyPending(self.max_concurrent_inbound_rpcs));
```
