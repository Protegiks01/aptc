# Audit Report

## Title
Consensus Database Deletion Creates Orphaned QuorumCert References to Deleted Blocks

## Summary
The `delete_blocks_and_quorum_certificates()` function in `consensus/src/consensusdb/mod.rs` does not check referential integrity before deleting blocks, allowing standalone QuorumCerts to retain references to deleted parent blocks through their `parent_block()` field. This creates orphaned references that violate database consistency invariants.

## Finding Description

The consensus database stores two types of data structures that reference blocks:

1. **Blocks** (stored in `BlockSchema`): Each block contains an embedded QuorumCert
2. **Standalone QuorumCerts** (stored in `QCSchema`): Indexed by the block they certify

Each `QuorumCert` contains a `VoteData` structure with **two** block references:
- `proposed` (accessed via `certified_block()`) - the block being certified
- `parent` (accessed via `parent_block()`) - the parent of the certified block [1](#0-0) 

When blocks are pruned, the `find_blocks_to_prune()` function determines which standalone QCs to retain by checking only if `qc.certified_block().id()` is in the valid tree: [2](#0-1) 

**Critical Issue**: This logic does NOT verify that `qc.parent_block().id()` references a block that will remain in the database.

When `delete_blocks_and_quorum_certificates()` executes, it blindly deletes the specified blocks without any referential integrity checks: [3](#0-2) 

**Exploitation Scenario**:

1. Initial state:
   - Block B0 (round 1, current root)
   - Block B1 (round 2, parent: B0)
   - Block B2 (round 3, parent: B1)
   - QC_B1 stored in QCSchema: `certified_block = B1`, `parent_block = B0`

2. Consensus advances root to B1 (B0 becomes prunable)

3. Pruning logic executes:
   - Valid tree: {B1, B2}
   - QC_B1: `certified_block().id()` = B1.id() (in tree) → **KEEP QC_B1**
   - QC_B1.parent_block().id() = B0.id() (NOT in tree) → **NOT CHECKED**
   - `to_remove = {B0.id()}`

4. `delete_blocks_and_quorum_certificates([B0.id()])` deletes B0

5. **Result**: QC_B1 remains in QCSchema but references deleted block B0 via `parent_block()`

The QuorumCert structure proves this parent reference exists: [4](#0-3) 

## Impact Explanation

This violates the **State Consistency** invariant: database references must remain valid. The impact includes:

**Medium Severity** (State inconsistencies requiring intervention):
- Database integrity violations where QCs reference non-existent blocks
- Potential consensus node crashes when code attempts to traverse QC chains expecting parent blocks to exist
- Recovery failures during node restart if validation logic checks parent block existence
- Inability to verify QC provenance chains required for consensus safety proofs

**Potential for Higher Severity**:
- If consensus logic assumes parent blocks are always retrievable from QC references, this could cause validator node crashes (High severity)
- Cascading failures across multiple nodes encountering the same inconsistent state could impact liveness

The storage schema shows both blocks and QCs are stored separately, enabling this inconsistency: [5](#0-4) 

## Likelihood Explanation

**High Likelihood**: This vulnerability triggers automatically during normal consensus operation:

- Block pruning occurs regularly as the consensus root advances
- Every pruning operation that removes blocks while keeping their child blocks' QCs will create orphaned references
- No attacker action required - this is a deterministic bug in the pruning logic
- Affects all validators running consensus

The pruning flow is invoked during standard operation: [6](#0-5) 

## Recommendation

Modify `find_blocks_to_prune()` to validate that retained QCs do not reference blocks being deleted through their `parent_block()` field:

```rust
fn find_blocks_to_prune(
    root_id: HashValue,
    blocks: &mut Vec<Block>,
    quorum_certs: &mut Vec<QuorumCert>,
) -> Vec<HashValue> {
    let mut tree = HashSet::new();
    let mut to_remove = HashSet::new();
    tree.insert(root_id);
    
    blocks.retain(|block| {
        if tree.contains(&block.parent_id()) {
            tree.insert(block.id());
            true
        } else {
            to_remove.insert(block.id());
            false
        }
    });
    
    quorum_certs.retain(|qc| {
        // Check both certified block AND parent block are in valid tree
        if tree.contains(&qc.certified_block().id()) && 
           tree.contains(&qc.parent_block().id()) {
            true
        } else {
            to_remove.insert(qc.certified_block().id());
            false
        }
    });
    
    to_remove.into_iter().collect()
}
```

Alternatively, add explicit validation in `delete_blocks_and_quorum_certificates()`:

```rust
pub fn delete_blocks_and_quorum_certificates(
    &self,
    block_ids: Vec<HashValue>,
) -> Result<(), DbError> {
    if block_ids.is_empty() {
        return Err(anyhow::anyhow!("Consensus block ids is empty!").into());
    }
    
    // Validate no remaining QCs reference blocks being deleted
    let all_qcs = self.get_all::<QCSchema>()?;
    for (_, qc) in &all_qcs {
        if !block_ids.contains(&qc.certified_block().id()) &&
           block_ids.contains(&qc.parent_block().id()) {
            return Err(anyhow::anyhow!(
                "Cannot delete block {} - QC {} references it as parent",
                qc.parent_block().id(),
                qc.certified_block().id()
            ).into());
        }
    }
    
    let mut batch = SchemaBatch::new();
    block_ids.iter().try_for_each(|hash| {
        batch.delete::<BlockSchema>(hash)?;
        batch.delete::<QCSchema>(hash)
    })?;
    self.commit(batch)
}
```

## Proof of Concept

```rust
#[test]
fn test_orphaned_qc_parent_reference() {
    use aptos_consensus_types::{
        block::Block,
        quorum_cert::QuorumCert,
        vote_data::VoteData,
    };
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        aggregate_signature::AggregateSignature,
    };
    use aptos_crypto::HashValue;
    use aptos_temppath::TempPath;

    let tmp_dir = TempPath::new();
    let db = ConsensusDB::new(&tmp_dir);

    // Create block chain: B0 -> B1 -> B2
    let b0 = Block::make_genesis_block();
    let b0_info = b0.gen_block_info(HashValue::zero(), 0, None);
    
    let qc_b0 = QuorumCert::new(
        VoteData::new(b0_info.clone(), b0_info.clone()),
        LedgerInfoWithSignatures::new(
            LedgerInfo::new(b0_info.clone(), HashValue::zero()),
            AggregateSignature::empty(),
        ),
    );
    
    // B1 with QC to B0 (parent reference)
    let b1_info = BlockInfo::new(1, 1, HashValue::random(), HashValue::zero(), 0, 1, None);
    let qc_b1 = QuorumCert::new(
        VoteData::new(b1_info.clone(), b0_info.clone()), // parent = b0_info
        LedgerInfoWithSignatures::new(
            LedgerInfo::new(b1_info.clone(), HashValue::zero()),
            AggregateSignature::empty(),
        ),
    );

    // Save blocks and QCs
    db.save_blocks_and_quorum_certificates(
        vec![b0.clone()],
        vec![qc_b0.clone(), qc_b1.clone()],
    ).unwrap();

    // Delete B0 (simulating pruning when B1 becomes root)
    db.delete_blocks_and_quorum_certificates(vec![b0.id()]).unwrap();

    // Verify B0 is deleted
    assert!(db.get::<BlockSchema>(&b0.id()).unwrap().is_none());

    // Verify QC_B1 still exists
    let qc_b1_retrieved = db.get::<QCSchema>(&b1_info.id()).unwrap();
    assert!(qc_b1_retrieved.is_some());

    // BUG: QC_B1's parent_block() references deleted B0
    let qc = qc_b1_retrieved.unwrap();
    assert_eq!(qc.parent_block().id(), b0.id());
    
    // Try to retrieve the parent block - FAILS (orphaned reference)
    assert!(db.get::<BlockSchema>(&qc.parent_block().id()).unwrap().is_none());
    
    println!("VULNERABILITY: QC references deleted parent block!");
}
```

## Notes

This vulnerability affects the core consensus database integrity. The issue is particularly insidious because:

1. It occurs during normal operation (not malicious input)
2. The orphaned references accumulate over time as blocks are pruned
3. Recovery logic may fail when encountering these inconsistent states
4. The bug is deterministic and affects all nodes running the code

The fix must ensure that before any block is deleted, all QCs in the database are checked to ensure neither their `certified_block()` nor `parent_block()` references point to blocks being deleted.

### Citations

**File:** consensus/consensus-types/src/vote_data.rs (L9-16)
```rust
/// VoteData keeps the information about the block, and its parent.
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, CryptoHasher, BCSCryptoHash)]
pub struct VoteData {
    /// Contains all the block information needed for voting for the proposed round.
    proposed: BlockInfo,
    /// Contains all the block information for the block the proposal is extending.
    parent: BlockInfo,
}
```

**File:** consensus/src/persistent_liveness_storage.rs (L467-474)
```rust
        quorum_certs.retain(|qc| {
            if tree.contains(&qc.certified_block().id()) {
                true
            } else {
                to_remove.insert(qc.certified_block().id());
                false
            }
        });
```

**File:** consensus/src/persistent_liveness_storage.rs (L499-505)
```rust
    fn prune_tree(&self, block_ids: Vec<HashValue>) -> Result<()> {
        if !block_ids.is_empty() {
            // quorum certs that certified the block_ids will get removed
            self.db.delete_blocks_and_quorum_certificates(block_ids)?;
        }
        Ok(())
    }
```

**File:** consensus/src/consensusdb/mod.rs (L139-152)
```rust
    pub fn delete_blocks_and_quorum_certificates(
        &self,
        block_ids: Vec<HashValue>,
    ) -> Result<(), DbError> {
        if block_ids.is_empty() {
            return Err(anyhow::anyhow!("Consensus block ids is empty!").into());
        }
        let mut batch = SchemaBatch::new();
        block_ids.iter().try_for_each(|hash| {
            batch.delete::<BlockSchema>(hash)?;
            batch.delete::<QCSchema>(hash)
        })?;
        self.commit(batch)
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L58-64)
```rust
    pub fn certified_block(&self) -> &BlockInfo {
        self.vote_data().proposed()
    }

    pub fn parent_block(&self) -> &BlockInfo {
        self.vote_data().parent()
    }
```

**File:** consensus/src/consensusdb/schema/quorum_certificate/mod.rs (L4-10)
```rust
//! This module defines physical storage schema for consensus quorum certificate (of a block).
//!
//! Serialized quorum certificate bytes identified by block_hash.
//! ```text
//! |<---key---->|<----value--->|
//! | block_hash |  QuorumCert  |
//! ```
```
