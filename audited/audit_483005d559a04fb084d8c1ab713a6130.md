# Audit Report

## Title
State View Version Mismatch Causes API Failures for Historical Transactions After Module Upgrades

## Summary
The `try_into_onchain_transaction()` function in the API layer uses a state view at the latest ledger version to convert historical transactions. When Move modules are upgraded and struct definitions change or are removed, the API fails to deserialize events from old transactions, returning 500 Internal Server Errors and making valid committed transactions permanently inaccessible through the API.

## Finding Description

The vulnerability exists in the transaction conversion flow within `get_transaction_inner()`. When retrieving a historical transaction, the code creates a state view at the **latest** committed version rather than at the transaction's original version. [1](#0-0) 

The state view is created using `latest_state_view_poem(ledger_info)`, which retrieves the current state: [2](#0-1) 

This state view is then used to convert transaction events, which requires resolving struct type definitions from the state view: [3](#0-2) 

The `try_into_events()` function deserializes each event using the struct definitions from the state view: [4](#0-3) 

Unlike entry function payload conversion which has a fallback to hex encoding when type resolution fails, event conversion has **no fallback mechanism** and propagates errors directly via the `?` operator. [5](#0-4) 

The event deserialization calls `view_value()` which attempts to resolve struct types: [6](#0-5) 

When resolving struct types, the code must load the module from the state view: [7](#0-6) 

If the module has been upgraded and the struct definition has changed or been removed, `view_existing_module()` will fail or `find_struct_def_in_module()` will return an error, causing the entire conversion to fail.

The codebase even contains TODO comments acknowledging this issue: [8](#0-7) 

**Attack Scenario:**
1. A module `0x1::Events` is published with struct `MyEvent { data: u64 }`
2. Transaction T1 at version 1000 emits an event of type `0x1::Events::MyEvent`
3. Module is upgraded at version 2000, removing `MyEvent` or changing its fields
4. User queries transaction T1 via API at current version 3000
5. API creates state view at version 3000 (latest)
6. Tries to deserialize event using struct definition from version 3000
7. Struct not found or incompatible â†’ error propagates
8. API returns 500 Internal Server Error
9. Transaction T1 is now permanently inaccessible through the API

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria for the following reasons:

1. **API Crashes**: The bounty explicitly lists "API crashes" as High Severity. This vulnerability causes the API to return 500 Internal Server Errors for valid historical transactions.

2. **Data Availability Loss**: Once a module is upgraded, all historical transactions that emitted events using the old struct definitions become inaccessible through the API. This is permanent and cannot be recovered without reverting the module upgrade.

3. **Affects Multiple Nodes**: All API nodes in the network are affected simultaneously when a module is upgraded, as they all use the latest state view.

4. **No Mitigation Available**: Users cannot work around this issue - the only access to historical transaction data is through the API, and it permanently fails for affected transactions.

5. **Breaks State Consistency Invariant**: The invariant that "committed transactions are always readable" is violated. While the transaction data exists in storage, it's inaccessible through the standard API interface.

## Likelihood Explanation

This vulnerability is **highly likely** to occur in production:

1. **Normal Protocol Evolution**: Module upgrades are a standard part of blockchain evolution. The Aptos Framework itself undergoes periodic upgrades, making this a routine occurrence rather than an attack scenario.

2. **No Malicious Intent Required**: This bug triggers through normal operations - any module upgrade that modifies struct definitions will cause historical transactions to become unreadable.

3. **Already Acknowledged**: The presence of TODO comments in the codebase indicates the developers are aware of this architectural limitation but have not yet addressed it.

4. **Low Complexity**: No special privileges or complex attack setup required - simply publish a module, emit events, upgrade the module, and query old transactions.

5. **Observable Impact**: Users will immediately notice when they cannot retrieve historical transactions, leading to support requests and reputation damage.

## Recommendation

The fix requires using a state view at the transaction's version instead of the latest version. The `Context` struct already provides the necessary method: [9](#0-8) 

**Recommended Fix:**

Modify `get_transaction_inner()` to create a state view at the transaction's version when the transaction data contains version information:

```rust
fn get_transaction_inner(
    &self,
    accept_type: &AcceptType,
    transaction_data: TransactionData,
    ledger_info: &LedgerInfo,
) -> BasicResultWith404<Transaction> {
    match accept_type {
        AcceptType::Json => {
            // Create state view at transaction version, not latest
            let state_view = match &transaction_data {
                TransactionData::OnChain(txn) => {
                    self.context.state_view_at_version(txn.version)
                        .map_err(|err| {
                            BasicErrorWith404::internal_with_code(
                                err,
                                AptosErrorCode::InternalError,
                                ledger_info,
                            )
                        })?
                },
                TransactionData::Pending(_) => {
                    self.context.latest_state_view_poem(ledger_info)?
                },
            };
            // ... rest of conversion logic
        }
        // ... BCS handling
    }
}
```

This ensures that historical transactions are always converted using the struct/module definitions that existed at the time of their execution.

## Proof of Concept

**Rust Reproduction Steps:**

1. Create a test module in Move:
```move
module 0x1::EventTest {
    use std::signer;
    
    struct OldEvent has drop, store {
        value: u64
    }
    
    public entry fun emit_old_event(account: &signer) {
        0x1::event::emit(OldEvent { value: 42 });
    }
}
```

2. Execute transaction emitting the event:
```rust
// Submit and execute transaction calling emit_old_event
let txn_hash = submit_transaction(emit_old_event_txn).await;
let txn_version = wait_for_transaction(txn_hash).version;
```

3. Upgrade module removing the struct:
```move
module 0x1::EventTest {
    // OldEvent removed - only new code remains
    public entry fun new_function() {
        // different implementation
    }
}
```

4. Query the old transaction:
```rust
// This will now fail with 500 Internal Server Error
let result = api_client.get_transaction_by_version(txn_version).await;
assert!(result.is_err()); // Fails due to missing struct definition
```

**Expected Result:** API returns 500 Internal Server Error with message containing "Struct OldEvent not found" or similar error.

**With Fix:** API successfully returns the transaction with events properly deserialized using the module definition from the transaction's version.

## Notes

This vulnerability demonstrates a fundamental architectural flaw in how the API layer handles versioned state. The issue is exacerbated by:

1. The lack of fallback mechanisms for event deserialization (unlike entry function arguments)
2. The absence of version-aware state views in the conversion pipeline
3. The silent acknowledgment of the issue via TODO comments without resolution

The fix is straightforward but requires careful testing to ensure that state views at historical versions maintain all necessary module definitions and don't introduce performance regressions from loading old state snapshots.

### Citations

**File:** api/src/transactions.rs (L1009-1036)
```rust
    fn get_transaction_inner(
        &self,
        accept_type: &AcceptType,
        transaction_data: TransactionData,
        ledger_info: &LedgerInfo,
    ) -> BasicResultWith404<Transaction> {
        match accept_type {
            AcceptType::Json => {
                let state_view = self.context.latest_state_view_poem(ledger_info)?;
                let transaction = match transaction_data {
                    TransactionData::OnChain(txn) => {
                        let timestamp =
                            self.context.get_block_timestamp(ledger_info, txn.version)?;
                        state_view
                            .as_converter(
                                self.context.db.clone(),
                                self.context.indexer_reader.clone(),
                            )
                            .try_into_onchain_transaction(timestamp, txn)
                            .context("Failed to convert on chain transaction to Transaction")
                            .map_err(|err| {
                                BasicErrorWith404::internal_with_code(
                                    err,
                                    AptosErrorCode::InternalError,
                                    ledger_info,
                                )
                            })?
                    },
```

**File:** api/src/context.rs (L160-168)
```rust
    pub fn latest_state_view_poem<E: InternalError>(
        &self,
        ledger_info: &LedgerInfo,
    ) -> Result<DbStateView, E> {
        self.db
            .latest_state_checkpoint_view()
            .context("Failed to read latest state checkpoint from DB")
            .map_err(|e| E::internal_with_code(e, AptosErrorCode::InternalError, ledger_info))
    }
```

**File:** api/src/context.rs (L193-195)
```rust
    pub fn state_view_at_version(&self, version: Version) -> Result<DbStateView> {
        Ok(self.db.state_view_at_version(Some(version))?)
    }
```

**File:** api/types/src/convert.rs (L173-192)
```rust
    pub fn try_into_onchain_transaction(
        &self,
        timestamp: u64,
        data: TransactionOnChainData,
    ) -> Result<Transaction> {
        use aptos_types::transaction::Transaction::{
            BlockEpilogue, BlockMetadata, BlockMetadataExt, GenesisTransaction, StateCheckpoint,
            UserTransaction,
        };
        let aux_data = self
            .db
            .get_transaction_auxiliary_data_by_version(data.version)?;
        let info = self.into_transaction_info(
            data.version,
            &data.info,
            data.accumulator_root_hash,
            data.changes,
            aux_data,
        );
        let events = self.try_into_events(&data.events)?;
```

**File:** api/types/src/convert.rs (L262-262)
```rust
            // TODO: the resource value is interpreted by the type definition at the version of the converter, not the version of the tx: must be fixed before we allow module updates
```

**File:** api/types/src/convert.rs (L301-316)
```rust
        let try_into_entry_function_payload = |fun: EntryFunction| -> Result<EntryFunctionPayload> {
            let (module, function, ty_args, args) = fun.into_inner();
            let func_args = self
                .inner
                .view_function_arguments(&module, &function, &ty_args, &args);

            let json_args = match func_args {
                Ok(values) => values
                    .into_iter()
                    .map(|v| MoveValue::try_from(v)?.json())
                    .collect::<Result<_>>()?,
                Err(_e) => args
                    .into_iter()
                    .map(|arg| HexEncodedBytes::from(arg).json())
                    .collect::<Result<_>>()?,
            };
```

**File:** api/types/src/convert.rs (L601-610)
```rust
    pub fn try_into_events(&self, events: &[ContractEvent]) -> Result<Vec<Event>> {
        let mut ret = vec![];
        for event in events {
            let data = self
                .inner
                .view_value(event.type_tag(), event.event_data())?;
            ret.push((event, MoveValue::try_from(data)?.json()?).into());
        }
        Ok(ret)
    }
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L434-450)
```rust
    fn resolve_basic_struct(
        &self,
        struct_name: &StructName,
        limit: &mut Limiter,
    ) -> anyhow::Result<FatStructRef> {
        if let Some(fat_ty) = self.fat_struct_def_cache.borrow().get(struct_name) {
            return Ok(fat_ty.clone());
        }

        let module_id = ModuleId::new(struct_name.address, struct_name.module.clone());
        let module = self.view_existing_module(&module_id)?;
        let module = module.borrow();

        let struct_def = find_struct_def_in_module(module, struct_name.name.as_ident_str())?;
        let base_type =
            FatStructRef::new(self.resolve_struct_definition(module, struct_def, limit)?);
        self.fat_struct_def_cache
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L685-689)
```rust
    pub fn view_value(&self, ty_tag: &TypeTag, blob: &[u8]) -> anyhow::Result<AnnotatedMoveValue> {
        let mut limit = Limiter::default();
        let ty = self.resolve_type_impl(ty_tag, &mut limit)?;
        self.view_value_by_fat_type(&ty, blob, &mut limit)
    }
```
