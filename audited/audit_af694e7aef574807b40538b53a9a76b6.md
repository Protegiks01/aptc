# Audit Report

## Title
Missing Child Version Validation in Jellyfish Merkle Tree Iterator Causes Potential State Inconsistency

## Summary
The Jellyfish Merkle Tree iterator does not validate that child node versions are less than or equal to the iterator's version when traversing the tree. This missing validation check could allow reading state from incorrect versions if database corruption or bugs cause child nodes to have versions greater than expected, potentially breaking deterministic execution guarantees across validators.

## Finding Description

The `JellyfishMerkleIterator` maintains a `version` field representing the tree version being read. [1](#0-0)  When traversing to child nodes, the iterator uses the child's stored version to generate the node key without validating that `child.version <= iterator.version`. [2](#0-1) [3](#0-2) 

The same pattern appears in proof generation code: [4](#0-3) [5](#0-4) 

When internal nodes are deserialized from storage, child versions are read directly without validation: [6](#0-5) [7](#0-6) 

In a correctly functioning Jellyfish Merkle tree, child nodes may have versions less than or equal to the parent version (due to unchanged nodes being reused across versions), but should **never** have versions greater than the parent or the version being queried.

If through database corruption, storage errors, or bugs in tree update logic, a node ends up with `child.version > iterator.version`, the iterator would attempt to read state from a future version that should not be visible at the requested version. This breaks the fundamental guarantee of versioned data structures: readers at version V should only observe state as it existed at version V.

**Broken Invariants:**
1. **Deterministic Execution**: If different validators have different corruption patterns, they could read different states at the same version
2. **State Consistency**: Versioned state guarantees are violated

## Impact Explanation

This qualifies as **HIGH severity** under "Significant protocol violations" because:

1. **State Consistency Violation**: The core guarantee that queries at version V return state from version V is broken
2. **Potential Consensus Impact**: If validators have different database corruption patterns, they could compute different state roots for identical blocks
3. **Silent Failure**: The system provides no detection or alerting when this invariant is violated

However, the impact is limited by the requirement that corrupted data must first enter the database through corruption, bugs, or other failure modes.

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

This vulnerability requires data corruption or bugs to manifest:

1. **Database Corruption**: Storage errors, disk failures, or memory corruption could cause invalid child versions to be written
2. **Bugs in Tree Update Logic**: A bug in batch update code could assign incorrect versions to children
3. **State Sync Issues**: Malformed state sync data could potentially introduce invalid versions, though proof verification provides some protection

While the missing validation creates exposure to these scenarios, direct exploitation by an unprivileged external attacker is not straightforward. The vulnerability primarily serves as a defensive gap that could allow corrupted data to propagate and cause hard-to-diagnose consensus issues.

## Recommendation

Add validation at multiple layers:

**1. In InternalNode deserialization** - Validate on read from storage:
```rust
pub fn deserialize(data: &[u8]) -> Result<Self> {
    // ... existing code ...
    let version = deserialize_u64_varint(&mut reader)?;
    // Add validation here if context available
    // ...
}
```

**2. In JellyfishMerkleIterator traversal** - Validate before using child version:
```rust
// In new() method around line 142:
match internal_node.child(child_index) {
    Some(child) => {
        ensure!(
            child.version <= version,
            "Invalid child version: child.version {} > iterator.version {}",
            child.version,
            version
        );
        parent_stack.push(NodeVisitInfo::new_next_child_to_visit(
            current_node_key.clone(),
            internal_node.clone(),
            child_index,
        ));
        current_node_key = current_node_key.gen_child_node_key(child.version, child_index);
    },
    // ...
}

// In next() method around line 326:
let child = last_visited_node_info
    .node
    .child(child_index)
    .expect("Child should exist.");
ensure!(
    child.version <= self.version,
    "Invalid child version: child.version {} > iterator.version {}",
    child.version,
    self.version
);
let node_key = last_visited_node_info.node_key.gen_child_node_key(
    child.version,
    child_index,
);
```

**3. In get_with_proof_ext** - Add similar validation when using child versions.

## Proof of Concept

```rust
#[test]
fn test_invalid_child_version_detection() {
    use crate::mock_tree_store::MockTreeStore;
    use crate::node_type::{Child, Children, InternalNode, Node, NodeKey, NodeType};
    use aptos_crypto::HashValue;
    use std::sync::Arc;

    // Create a tree at version 100
    let tree_store = MockTreeStore::default();
    let reader = Arc::new(tree_store);
    
    // Manually construct a corrupted internal node at version 100
    // with a child that claims to be from version 150 (future)
    let corrupted_child = Child::new(
        HashValue::random(),
        150, // Invalid: version > parent version
        NodeType::Leaf,
    );
    
    let root_key = NodeKey::new_empty_path(100);
    let internal = InternalNode::new(Children::from_sorted(vec![
        (Nibble::from(0), corrupted_child)
    ]));
    
    // Write corrupted node to storage
    tree_store.put_node(root_key.clone(), Node::Internal(internal)).unwrap();
    
    // Try to create iterator - should fail with validation
    let result = JellyfishMerkleIterator::new(
        reader.clone(),
        100,
        HashValue::zero(),
    );
    
    // Currently this would NOT fail, demonstrating the vulnerability
    // With the fix, this should return an error about invalid child version
    assert!(result.is_err()); // This assertion would fail without the fix
}
```

## Notes

**Important Context:**

This is fundamentally a **data integrity validation issue** rather than a direct attack vector. The missing validation creates a defensive gap that could allow corrupted data to cause incorrect behavior, but requires preconditions (corruption, bugs) that are not directly under attacker control.

**Why This Matters:**
- Provides early detection of database corruption
- Prevents propagation of invalid state across the system  
- Helps maintain deterministic execution guarantees
- Aligns with defense-in-depth principles

The validation should be added as a protective measure, even though direct exploitation scenarios are limited.

### Citations

**File:** storage/jellyfish-merkle/src/iterator/mod.rs (L102-102)
```rust
    version: Version,
```

**File:** storage/jellyfish-merkle/src/iterator/mod.rs (L141-142)
```rust
                    current_node_key =
                        current_node_key.gen_child_node_key(child.version, child_index);
```

**File:** storage/jellyfish-merkle/src/iterator/mod.rs (L321-328)
```rust
            let node_key = last_visited_node_info.node_key.gen_child_node_key(
                last_visited_node_info
                    .node
                    .child(child_index)
                    .expect("Child should exist.")
                    .version,
                child_index,
            );
```

**File:** storage/jellyfish-merkle/src/lib.rs (L747-750)
```rust
                        let (only_child_nibble, Child { version, .. }) =
                            internal_node.children_sorted().next().unwrap();
                        next_node_key =
                            next_node_key.gen_child_node_key(*version, *only_child_nibble);
```

**File:** storage/jellyfish-merkle/src/node_type/mod.rs (L411-411)
```rust
            let version = deserialize_u64_varint(&mut reader)?;
```

**File:** storage/jellyfish-merkle/src/node_type/mod.rs (L434-434)
```rust
                Child::new(hash, version, node_type),
```

**File:** storage/jellyfish-merkle/src/node_type/mod.rs (L659-661)
```rust
                    .version;
                return Ok(Some(
                    node_key.gen_child_node_key(only_child_version, only_child_index),
```
