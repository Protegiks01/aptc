# Audit Report

## Title
View Function API Lacks Cryptographic Verification - Clients Accept Forged Ledger Info as Authentic

## Summary
The Aptos view function API returns ledger metadata (chain_id, version, epoch, timestamp, block_height) in HTTP headers without including cryptographic signatures. The REST client SDK accepts these headers without any verification, allowing malicious or compromised API servers to forge arbitrary blockchain state information that clients will accept as authentic.

## Finding Description

The vulnerability exists in the trust boundary between the API server and REST clients when executing view functions.

**Server-side flow:** [1](#0-0) 

The API retrieves `LedgerInfo` from the context, which is constructed from `LedgerInfoWithSignatures` containing BLS signatures from validators: [2](#0-1) 

However, the API response type `LedgerInfo` (defined in api/types) does NOT include signatures: [3](#0-2) 

The BasicResponse macro includes only plain ledger_info fields in HTTP headers: [4](#0-3) 

**Client-side flow:**

The REST client calls view functions and parses responses: [5](#0-4) 

Response parsing extracts ledger_info from headers without verification: [6](#0-5) [7](#0-6) 

The State::from_headers method only parses header values without cryptographic verification: [8](#0-7) 

**Attack scenario:**
1. Attacker runs a malicious API server or compromises an existing one
2. Client connects to this server and calls a view function (e.g., checking account balance)
3. Server returns forged ledger_info headers (arbitrary version, epoch, chain_id) and fabricated view function results
4. Client accepts the response because State::from_headers() performs no verification

While the codebase has verification mechanisms (`LedgerInfoWithSignatures::verify_signatures` and `TrustedState`), they are NOT integrated with the view function API: [9](#0-8) 

## Impact Explanation

**Severity: HIGH** (Significant Protocol Violation per Aptos Bug Bounty)

This vulnerability allows attackers to deceive clients about blockchain state:

1. **Financial Loss**: Malicious servers can display inflated account balances, leading users to believe they have funds they don't actually possess
2. **Fraudulent Transactions**: DApps making decisions based on forged view function results could authorize incorrect operations
3. **Governance Manipulation**: Voting power or proposal status could be misrepresented
4. **NFT/Asset Fraud**: Fake ownership claims could be presented to marketplaces or wallets
5. **Wide Impact**: Affects ALL clients using the REST API for view functions - wallets, explorers, DApps, indexers

The lack of cryptographic verification breaks the **Cryptographic Correctness** invariant: clients cannot distinguish authentic blockchain state from fabricated data.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

Attack requirements:
- Attacker must operate a malicious API server OR compromise an existing one
- Client must connect to the malicious server
- No special permissions or validator access required

This is realistic because:
1. Many users/DApps connect to third-party API servers for convenience
2. Man-in-the-middle attacks can redirect API requests
3. Compromised infrastructure (DNS, hosting) can serve malicious responses
4. Users often don't verify which API endpoint their wallet/DApp is using

The attack is **low complexity** - simply return forged HTTP headers with any desired values.

## Recommendation

**Solution 1: Include signatures in API responses**

Modify the API to include `LedgerInfoWithSignatures` or at minimum include aggregated BLS signatures in response headers. Update the client SDK to verify signatures against known validator sets.

**Solution 2: Provide state proof endpoint**

Implement an endpoint that returns `StateProof` (which includes `LedgerInfoWithSignatures`): [10](#0-9) 

Allow clients to request proofs alongside view function results and verify them using `TrustedState::verify_and_ratchet`.

**Solution 3: Add SDK warnings**

At minimum, add clear warnings in the REST client documentation and code that view function responses are **unauthenticated** and should not be trusted for security-critical decisions without independent verification.

**Recommended approach: Combination of Solutions 1 and 2**
- Add optional `?include_proof=true` parameter to view function endpoint
- Return `LedgerInfoWithSignatures` in response when requested
- Update SDK to verify signatures when proofs are provided
- Document trust model clearly for users

## Proof of Concept

```rust
// Malicious API server simulation
use axum::{Router, routing::post, Json};
use aptos_api_types::{MoveValue, ViewRequest};

#[tokio::main]
async fn malicious_api_server() {
    let app = Router::new()
        .route("/v1/view", post(malicious_view_handler));
    
    axum::Server::bind(&"0.0.0.0:8080".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn malicious_view_handler(
    Json(request): Json<ViewRequest>
) -> impl axum::response::IntoResponse {
    // Return forged ledger info headers
    let headers = [
        ("X-Aptos-Chain-Id", "1"),  // Mainnet chain ID
        ("X-Aptos-Ledger-Version", "999999999"),  // Fake version
        ("X-Aptos-Epoch", "12345"),  // Fake epoch
        ("X-Aptos-Ledger-TimestampUsec", "1234567890000000"),
        ("X-Aptos-Block-Height", "888888888"),
        ("X-Aptos-Ledger-Oldest-Version", "0"),
        ("X-Aptos-Oldest-Block-Height", "0"),
    ];
    
    // Return fabricated view function result
    // E.g., if checking balance, return inflated amount
    let forged_result = vec![
        serde_json::json!("1000000000000000")  // Fake balance
    ];
    
    (headers, Json(forged_result))
}

// Client code - will accept forged response
#[tokio::test]
async fn test_client_accepts_forged_response() {
    // Client connects to malicious server
    let client = aptos_rest_client::Client::new(
        "http://localhost:8080".parse().unwrap()
    );
    
    let request = ViewRequest {
        function: "0x1::coin::balance".parse().unwrap(),
        type_arguments: vec![],
        arguments: vec![serde_json::json!("0x1234")],
    };
    
    // Client accepts forged response without verification
    let response = client.view(&request, None).await.unwrap();
    
    // Client believes the forged ledger info is authentic
    assert_eq!(response.state().version, 999999999);  // Forged!
    assert_eq!(response.state().epoch, 12345);  // Forged!
    
    // Client believes the forged balance is real
    // This could lead to financial loss or fraud
}
```

## Notes

While Aptos provides `TrustedState` and signature verification mechanisms for trustless verification, these are not integrated with the view function API. The current design forces clients to either: (1) trust the API server operator, or (2) run their own full node. This creates a security gap for users relying on third-party API providers.

The issue is particularly concerning because the API **does** return ledger_info metadata, suggesting it should be trustworthy, but provides no cryptographic proof to verify authenticity.

### Citations

**File:** api/src/view_function.rs (L102-103)
```rust
    let (ledger_info, requested_version) = context
        .get_latest_ledger_info_and_verify_lookup_version(ledger_version.map(|inner| inner.0))?;
```

**File:** api/src/context.rs (L243-268)
```rust
    pub fn get_latest_storage_ledger_info<E: ServiceUnavailableError>(
        &self,
    ) -> Result<LedgerInfo, E> {
        let ledger_info = self
            .get_latest_ledger_info_with_signatures()
            .context("Failed to retrieve latest ledger info")
            .map_err(|e| {
                E::service_unavailable_with_code_no_info(e, AptosErrorCode::InternalError)
            })?;

        let (oldest_version, oldest_block_height) = self.get_oldest_version_and_block_height()?;
        let (_, _, newest_block_event) = self
            .db
            .get_block_info_by_version(ledger_info.ledger_info().version())
            .context("Failed to retrieve latest block information")
            .map_err(|e| {
                E::service_unavailable_with_code_no_info(e, AptosErrorCode::InternalError)
            })?;

        Ok(LedgerInfo::new(
            &self.chain_id(),
            &ledger_info,
            oldest_version,
            oldest_block_height,
            newest_block_event.height(),
        ))
```

**File:** api/types/src/ledger_info.rs (L10-20)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq, Eq, PoemObject)]
pub struct LedgerInfo {
    /// Chain ID of the current chain
    pub chain_id: u8,
    pub epoch: U64,
    pub ledger_version: U64,
    pub oldest_ledger_version: U64,
    pub block_height: U64,
    pub oldest_block_height: U64,
    pub ledger_timestamp: U64,
}
```

**File:** api/src/response.rs (L329-342)
```rust
                /// Chain ID of the current chain
                #[oai(header = "X-Aptos-Chain-Id")] u8,
                /// Current ledger version of the chain
                #[oai(header = "X-Aptos-Ledger-Version")] u64,
                /// Oldest non-pruned ledger version of the chain
                #[oai(header = "X-Aptos-Ledger-Oldest-Version")] u64,
                /// Current timestamp of the chain
                #[oai(header = "X-Aptos-Ledger-TimestampUsec")] u64,
                /// Current epoch of the chain
                #[oai(header = "X-Aptos-Epoch")] u64,
                /// Current block height of the chain
                #[oai(header = "X-Aptos-Block-Height")] u64,
                /// Oldest non-pruned block height of the chain
                #[oai(header = "X-Aptos-Oldest-Block-Height")] u64,
```

**File:** crates/aptos-rest-client/src/lib.rs (L416-436)
```rust
    pub async fn view(
        &self,
        request: &ViewRequest,
        version: Option<u64>,
    ) -> AptosResult<Response<Vec<serde_json::Value>>> {
        let request = serde_json::to_string(request)?;
        let mut url = self.build_path("view")?;
        if let Some(version) = version {
            url.set_query(Some(format!("ledger_version={}", version).as_str()));
        }

        let response = self
            .inner
            .post(url)
            .header(CONTENT_TYPE, JSON)
            .body(request)
            .send()
            .await?;

        self.json(response).await
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1645-1656)
```rust
    async fn check_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<(reqwest::Response, State)> {
        if !response.status().is_success() {
            Err(parse_error(response).await)
        } else {
            let state = parse_state(&response)?;

            Ok((response, state))
        }
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1976-1978)
```rust
fn parse_state(response: &reqwest::Response) -> AptosResult<State> {
    Ok(State::from_headers(response.headers())?)
}
```

**File:** crates/aptos-rest-client/src/state.rs (L23-102)
```rust
    pub fn from_headers(headers: &reqwest::header::HeaderMap) -> anyhow::Result<Self> {
        let maybe_chain_id = headers
            .get(X_APTOS_CHAIN_ID)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_version = headers
            .get(X_APTOS_LEDGER_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_timestamp = headers
            .get(X_APTOS_LEDGER_TIMESTAMP)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_epoch = headers
            .get(X_APTOS_EPOCH)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_ledger_version = headers
            .get(X_APTOS_LEDGER_OLDEST_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_block_height = headers
            .get(X_APTOS_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_block_height = headers
            .get(X_APTOS_OLDEST_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let cursor = headers
            .get(X_APTOS_CURSOR)
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string());

        let state = if let (
            Some(chain_id),
            Some(version),
            Some(timestamp_usecs),
            Some(epoch),
            Some(oldest_ledger_version),
            Some(block_height),
            Some(oldest_block_height),
            cursor,
        ) = (
            maybe_chain_id,
            maybe_version,
            maybe_timestamp,
            maybe_epoch,
            maybe_oldest_ledger_version,
            maybe_block_height,
            maybe_oldest_block_height,
            cursor,
        ) {
            Self {
                chain_id,
                epoch,
                version,
                timestamp_usecs,
                oldest_ledger_version,
                block_height,
                oldest_block_height,
                cursor,
            }
        } else {
            anyhow::bail!(
                "Failed to build State from headers due to missing values in response. \
                Chain ID: {:?}, Version: {:?}, Timestamp: {:?}, Epoch: {:?}, \
                Oldest Ledger Version: {:?}, Block Height: {:?} Oldest Block Height: {:?}",
                maybe_chain_id,
                maybe_version,
                maybe_timestamp,
                maybe_epoch,
                maybe_oldest_ledger_version,
                maybe_block_height,
                maybe_oldest_block_height,
            )
        };

        Ok(state)
    }
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```

**File:** types/src/state_proof.rs (L23-26)
```rust
pub struct StateProof {
    latest_li_w_sigs: LedgerInfoWithSignatures,
    epoch_changes: EpochChangeProof,
}
```
