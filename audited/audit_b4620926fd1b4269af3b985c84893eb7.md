# Audit Report

## Title
Signature Verification Bypass in Transaction Restore Allows Storage of Unvalidated Gas Values

## Summary
The `save_transactions()` function in the restore handler does not validate that `gas_used` in `TransactionInfo` matches actual transaction operations. When restoring from backups with `epoch_history=None`, signature verification is completely bypassed, allowing arbitrary gas values to be stored in the database without cryptographic validation.

## Finding Description

The vulnerability exists in the backup restore flow where `TransactionInfo` objects (containing `gas_used` values) are loaded from backup files and stored in the database without proper validation. [1](#0-0) 

The `save_transactions()` method delegates to `restore_utils::save_transactions()`, which stores transaction data including `TransactionInfo` objects: [2](#0-1) 

During normal execution, `gas_used` is computed by the VM and stored in `TransactionInfo`: [3](#0-2) 

However, during backup restore, `TransactionInfo` objects are deserialized from backup files: [4](#0-3) 

**Critical Vulnerability:** When `epoch_history` is `None`, signature verification is skipped: [5](#0-4) 

The `TransactionListWithProof::verify()` only validates transaction hashes and accumulator proofs, **not** the `gas_used` values: [6](#0-5) 

In contrast, `TransactionOutputListWithProof::verify()` DOES validate gas_used, but this is not used in the restore flow: [7](#0-6) 

**Attack Vectors:**

1. **Oneoff Transaction Restore** - Always bypasses signature verification: [8](#0-7) 

2. **--skip-epoch-endings Flag** - Documented as "for debugging" but bypasses security: [9](#0-8) [10](#0-9) 

## Impact Explanation

This vulnerability breaks the **State Consistency** invariant - different nodes could have different `gas_used` values if restored from different sources.

**High Severity** per Aptos Bug Bounty criteria:
- **Significant protocol violations**: Bypass of cryptographic signature verification
- **State inconsistencies requiring intervention**: Database contains unvalidated gas values that don't match actual execution
- **API corruption**: Historical queries return incorrect gas usage data
- **Consensus divergence risk**: Different nodes with different restored data could have state mismatches

The vulnerability allows storing arbitrary gas values without validator signatures, corrupting the audit trail and economic accounting of the blockchain.

## Likelihood Explanation

**Moderate likelihood** - Requires operator-level access to run db-tool restore commands with either:
1. The oneoff transaction restore subcommand (always vulnerable)
2. The restore coordinator with `--skip-epoch-endings` flag (debugging flag with security implications)

While this requires privileged access, operators routinely perform restore operations for disaster recovery, node bootstrapping, and testing scenarios. The `--skip-epoch-endings` flag is documented for debugging but its security implications are not clearly warned.

## Recommendation

**Fix 1: Require epoch_history for all restore operations**

In `storage/backup/backup-cli/src/backup_types/transaction/restore.rs`, make epoch_history mandatory and enforce signature verification:

```rust
// LoadedChunk::load() - line 152
let epoch_history = epoch_history.ok_or_else(|| 
    anyhow!("epoch_history is required for secure restore - signature verification cannot be skipped")
)?;
epoch_history.verify_ledger_info(&ledger_info)?;
```

**Fix 2: Add validation warning for oneoff restore**

In `storage/db-tool/src/restore.rs`, add explicit security warning:

```rust
// Line 102 - before TransactionRestoreController::new()
warn!("WARNING: Oneoff transaction restore bypasses signature verification. Only use with trusted backup sources.");
```

**Fix 3: Remove or restrict --skip-epoch-endings flag**

Either remove the flag entirely or require an additional confirmation flag like `--i-understand-security-risks`.

**Fix 4: Re-execute transactions to validate gas_used**

For critical restore operations, add an option to re-execute transactions and verify that computed gas_used matches the stored values, similar to the replay functionality.

## Proof of Concept

```bash
# Step 1: Operator prepares malicious backup with modified TransactionInfo
# (Create backup with fake gas_used values in transaction_infos)

# Step 2: Run oneoff restore that bypasses signature verification
aptos-db-tool restore oneoff transaction \
  --transaction-manifest /path/to/malicious/manifest.json \
  --target-db-dir /var/aptos/db

# Result: Database now contains TransactionInfo with arbitrary gas_used values
# No signature verification was performed
# Queries to the node will return incorrect gas usage data

# Step 3: Verify the corruption
# Query transaction info via API - will show fake gas_used values
# Different nodes restored from different sources will have divergent states
```

**Notes:**

The vulnerability requires operator-level access to execute, but represents a significant bypass of the cryptographic security model. The `--skip-epoch-endings` flag and oneoff restore command create a footgun where operators can accidentally or intentionally bypass validator signature verification, violating the assumption that all committed data has been validated by the consensus protocol.

### Citations

**File:** storage/aptosdb/src/backup/restore_handler.rs (L78-99)
```rust
    pub fn save_transactions(
        &self,
        first_version: Version,
        txns: &[Transaction],
        persisted_aux_info: &[PersistedAuxiliaryInfo],
        txn_infos: &[TransactionInfo],
        events: &[Vec<ContractEvent>],
        write_sets: Vec<WriteSet>,
    ) -> Result<()> {
        restore_utils::save_transactions(
            self.state_store.clone(),
            self.ledger_db.clone(),
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets,
            None,
            false,
        )
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L193-229)
```rust
pub(crate) fn save_transactions_impl(
    state_store: Arc<StateStore>,
    ledger_db: Arc<LedgerDb>,
    first_version: Version,
    txns: &[Transaction],
    persisted_aux_info: &[PersistedAuxiliaryInfo],
    txn_infos: &[TransactionInfo],
    events: &[Vec<ContractEvent>],
    write_sets: &[WriteSet],
    ledger_db_batch: &mut LedgerDbSchemaBatches,
    state_kv_batches: &mut ShardedStateKvSchemaBatch,
    kv_replay: bool,
) -> Result<()> {
    for (idx, txn) in txns.iter().enumerate() {
        ledger_db.transaction_db().put_transaction(
            first_version + idx as Version,
            txn,
            /*skip_index=*/ false,
            &mut ledger_db_batch.transaction_db_batches,
        )?;
    }

    for (idx, aux_info) in persisted_aux_info.iter().enumerate() {
        PersistedAuxiliaryInfoDb::put_persisted_auxiliary_info(
            first_version + idx as Version,
            aux_info,
            &mut ledger_db_batch.persisted_auxiliary_info_db_batches,
        )?;
    }

    for (idx, txn_info) in txn_infos.iter().enumerate() {
        TransactionInfoDb::put_transaction_info(
            first_version + idx as Version,
            txn_info,
            &mut ledger_db_batch.transaction_info_db_batches,
        )?;
    }
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L77-88)
```rust
                let txn_info = TransactionInfo::new(
                    txn.hash(),
                    write_set_hash,
                    event_root_hash,
                    state_checkpoint_hash,
                    txn_output.gas_used(),
                    txn_output
                        .status()
                        .as_kept_status()
                        .expect("Already sorted."),
                    auxiliary_info_hash,
                );
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L112-136)
```rust
        while let Some(record_bytes) = file.read_record_bytes().await? {
            let (txn, aux_info, txn_info, events, write_set): (
                _,
                PersistedAuxiliaryInfo,
                _,
                _,
                WriteSet,
            ) = match manifest.format {
                TransactionChunkFormat::V0 => {
                    let (txn, txn_info, events, write_set) = bcs::from_bytes(&record_bytes)?;
                    (
                        txn,
                        PersistedAuxiliaryInfo::None,
                        txn_info,
                        events,
                        write_set,
                    )
                },
                TransactionChunkFormat::V1 => bcs::from_bytes(&record_bytes)?,
            };
            txns.push(txn);
            persisted_aux_info.push(aux_info);
            txn_infos.push(txn_info);
            event_vecs.push(events);
            write_sets.push(write_set);
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L147-167)
```rust
        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }

        // make a `TransactionListWithProof` to reuse its verification code.
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** types/src/transaction/mod.rs (L2288-2354)
```rust
    /// Verifies the transaction list with proof using the given `ledger_info`.
    /// This method will ensure:
    /// 1. All transactions exist on the given `ledger_info`.
    /// 2. All transactions in the list have consecutive versions.
    /// 3. If `first_transaction_version` is None, the transaction list is empty.
    ///    Otherwise, the transaction list starts at `first_transaction_version`.
    /// 4. If events exist, they match the expected event root hashes in the proof.
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_version: Option<Version>,
    ) -> Result<()> {
        // Verify the first transaction versions match
        ensure!(
            self.get_first_transaction_version() == first_transaction_version,
            "First transaction version ({:?}) doesn't match given version ({:?}).",
            self.get_first_transaction_version(),
            first_transaction_version,
        );

        // Verify the lengths of the transactions and transaction infos match
        ensure!(
            self.proof.transaction_infos.len() == self.get_num_transactions(),
            "The number of TransactionInfo objects ({}) does not match the number of \
             transactions ({}).",
            self.proof.transaction_infos.len(),
            self.get_num_transactions(),
        );

        // Verify the transaction hashes match those of the transaction infos
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;

        // Verify the events if they exist.
        if let Some(event_lists) = &self.events {
            ensure!(
                event_lists.len() == self.get_num_transactions(),
                "The length of event_lists ({}) does not match the number of transactions ({}).",
                event_lists.len(),
                self.get_num_transactions(),
            );
            event_lists
                .into_par_iter()
                .zip_eq(self.proof.transaction_infos.par_iter())
                .map(|(events, txn_info)| verify_events_against_root_hash(events, txn_info))
                .collect::<Result<Vec<_>>>()?;
        }

        Ok(())
    }
```

**File:** types/src/transaction/mod.rs (L2573-2595)
```rust
        self.transactions_and_outputs.par_iter().zip_eq(self.proof.transaction_infos.par_iter())
        .map(|((txn, txn_output), txn_info)| {
            // Check the events against the expected events root hash
            verify_events_against_root_hash(&txn_output.events, txn_info)?;

            // Verify the write set matches for both the transaction info and output
            let write_set_hash = CryptoHash::hash(&txn_output.write_set);
            ensure!(
                txn_info.state_change_hash() == write_set_hash,
                "The write set in transaction output does not match the transaction info \
                     in proof. Hash of write set in transaction output: {}. Write set hash in txn_info: {}.",
                write_set_hash,
                txn_info.state_change_hash(),
            );

            // Verify the gas matches for both the transaction info and output
            ensure!(
                txn_output.gas_used() == txn_info.gas_used(),
                "The gas used in transaction output does not match the transaction info \
                     in proof. Gas used in transaction output: {}. Gas used in txn_info: {}.",
                txn_output.gas_used(),
                txn_info.gas_used(),
            );
```

**File:** storage/db-tool/src/restore.rs (L97-111)
```rust
                    Oneoff::Transaction {
                        storage,
                        opt,
                        global,
                    } => {
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
                    },
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L42-43)
```rust
    #[clap(long, help = "Skip restoring epoch ending info, used for debugging.")]
    pub skip_epoch_endings: bool,
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```
