# Audit Report

## Title
Critical RNG State Predictability in Genesis Ceremony - Entire Validator Set Compromise via Weak Default Seed

## Summary
The genesis deployment script uses bash's `$RANDOM` (15-bit entropy) as the default seed for deterministically generating all validator keys during the genesis ceremony. An attacker can brute-force all 32,768 possible seeds in seconds, recover the correct seed by matching against observed public keys, and then derive all validator private keys, completely compromising the validator set.

## Finding Description

The genesis ceremony script contains a critical vulnerability in its random seed initialization that breaks the **Cryptographic Correctness** invariant. [1](#0-0) 

When `RANDOM_SEED` is not explicitly set by the operator, it defaults to bash's built-in `$RANDOM` variable, which only produces values between 0-32767 (15 bits of entropy). This weak seed is then used to deterministically generate keys for ALL validators in the genesis set: [2](#0-1) 

For each validator `i`, the script calculates `seed = RANDOM_SEED + i` and passes it to the key generation command: [3](#0-2) 

This seed flows through the CLI to create a deterministic `KeyGen` instance: [4](#0-3) 

Which then generates all four validator key types deterministically: [5](#0-4) 

The underlying RNG uses `StdRng` which is completely deterministic given a seed: [6](#0-5) 

### Attack Path

1. **Observe public keys**: Attacker reads any validator's account public key from the blockchain (publicly available on-chain data)

2. **Brute-force seed space**: For each possible `RANDOM_SEED` value (0 to 32767):
   - Calculate `seed_0 = RANDOM_SEED`
   - Create `KeyGen::from_seed(seed_0)` 
   - Generate the account Ed25519 key
   - Compare against the observed public key

3. **Seed recovery**: When a match is found, the attacker has recovered the genesis `RANDOM_SEED`

4. **Full compromise**: For each validator index `i` (0 to N-1):
   - Calculate `seed_i = RANDOM_SEED + i`
   - Create `KeyGen::from_seed(seed_i)`
   - Generate all four private keys (account, consensus, validator network, full node network)

5. **Validator set takeover**: With all validator private keys, the attacker can:
   - Sign consensus messages as any validator
   - Execute Byzantine attacks with >1/3 voting power
   - Steal staked funds
   - Fork the chain
   - Execute double-spend attacks

## Impact Explanation

**Critical Severity** - This vulnerability enables complete compromise of the validator set, meeting multiple critical impact categories from the Aptos bug bounty:

1. **Consensus/Safety violations**: With control of all validator keys, an attacker can violate AptosBFT safety guarantees and create chain splits

2. **Loss of Funds**: Attacker can steal all staked validator funds and manipulate on-chain balances through consensus control

3. **Network partition**: Attacker can partition the network by signing conflicting blocks, potentially requiring a hard fork to recover

4. **Total loss of liveness**: Attacker can halt the network by refusing to sign blocks with >1/3 voting power

The vulnerability breaks the **Cryptographic Correctness** invariant which states "BLS signatures, VRF, and hash operations must be secure" - the key generation process itself uses cryptographically weak entropy.

## Likelihood Explanation

**Very High Likelihood** of exploitation:

- **Default behavior**: Any genesis ceremony executed without explicitly setting `RANDOM_SEED=""` (empty string) will use the weak default
- **Production deployment**: The genesis.sh script is the standard deployment mechanism for Aptos networks (testnets, devnets, potentially mainnet-like environments)
- **Trivial exploitation**: Brute-forcing 32,768 seeds takes seconds on commodity hardware
- **No special access required**: Attacker only needs to read public blockchain data
- **Discoverable**: Public keys are visible on-chain immediately after genesis

The only requirement is that the genesis ceremony was run using the default script without explicitly overriding the random seed, which is the expected default deployment path.

## Recommendation

**Immediate Fix**: Change line 26 to NOT provide a default value:

```bash
# Before (VULNERABLE):
RANDOM_SEED=${RANDOM_SEED:-$RANDOM}

# After (SECURE):
RANDOM_SEED=${RANDOM_SEED:-}
```

This ensures that when `RANDOM_SEED` is not set, it remains empty, causing the script to use cryptographically secure OS randomness instead of deterministic seeds.

**Additional Hardening**:

1. Add explicit validation to reject weak seeds:
```bash
if [ ! -z "${RANDOM_SEED}" ] && [ "${#RANDOM_SEED}" -lt 64 ]; then
    echo "ERROR: RANDOM_SEED must be at least 64 hex characters or unset for secure random generation"
    exit 1
fi
```

2. Add a warning when using deterministic seeds:
```bash
if [ ! -z "${RANDOM_SEED}" ]; then
    echo "WARNING: Using deterministic seed - ONLY for testing! Production deployments should leave RANDOM_SEED unset."
fi
```

3. Document the security implications in the script comments and deployment documentation

## Proof of Concept

**Brute-force attack script** (Python pseudocode):

```python
#!/usr/bin/env python3
from aptos_sdk.ed25519 import PrivateKey
import hashlib

# Observed public key from blockchain (validator 0)
target_public_key = "0xabcd..."  # From on-chain ValidatorSet

# Brute-force all possible bash $RANDOM values
for random_seed in range(0, 32768):
    # Compute seed for validator 0
    seed_hex = f"{random_seed:064x}"
    seed_bytes = bytes.fromhex(seed_hex)
    
    # Simulate KeyGen::from_seed + generate_ed25519_private_key
    # (using same ChaCha20 RNG as Rust StdRng)
    private_key = generate_with_stdrng(seed_bytes)
    public_key = private_key.public_key()
    
    if public_key == target_public_key:
        print(f"[+] Found RANDOM_SEED: {random_seed}")
        
        # Now recover ALL validator keys
        for validator_idx in range(NUM_VALIDATORS):
            seed = random_seed + validator_idx
            seed_hex = f"{seed:064x}"
            validator_keys = generate_all_keys(bytes.fromhex(seed_hex))
            print(f"[+] Validator {validator_idx} private keys:")
            print(f"    Account: {validator_keys.account_key}")
            print(f"    Consensus: {validator_keys.consensus_key}")
            print(f"    Network: {validator_keys.network_key}")
        
        break
```

**Expected runtime**: <1 minute on standard hardware to brute-force 32,768 seeds and recover all validator private keys.

## Notes

This vulnerability is particularly dangerous because:

1. **Silent failure**: The script runs successfully and generates valid keys - there's no indication to operators that weak entropy was used

2. **Wide deployment**: The genesis.sh script is the canonical deployment method for Aptos networks, meaning many testnets and development networks are likely affected

3. **Retroactive compromise**: Even if the script is fixed now, any networks already deployed using the default RANDOM_SEED remain permanently compromised until a new genesis ceremony is performed with secure randomness

4. **Configuration subtlety**: The bash variable expansion syntax `${RANDOM_SEED:-$RANDOM}` is easy to overlook and appears reasonable at first glance, making this a subtle but critical misconfiguration

The fix is simple but critical for network security. All existing networks deployed with the default script should be assumed compromised and require redeployment with secure key generation.

### Citations

**File:** terraform/helm/genesis/files/genesis.sh (L26-26)
```shellscript
RANDOM_SEED=${RANDOM_SEED:-$RANDOM}
```

**File:** terraform/helm/genesis/files/genesis.sh (L112-118)
```shellscript
  if [[ -z "${RANDOM_SEED}" ]]; then
    aptos genesis generate-keys --output-dir $user_dir
  else
    seed=$(printf "%064x" "$((${RANDOM_SEED_IN_DECIMAL} + i))")
    echo "seed=$seed for ${i}th validator"
    aptos genesis generate-keys --random-seed $seed --output-dir $user_dir
  fi
```

**File:** crates/aptos/src/common/types.rs (L593-604)
```rust
    pub fn key_generator(&self) -> CliTypedResult<KeyGen> {
        if let Some(ref seed) = self.random_seed {
            // Strip 0x
            let seed = seed.strip_prefix("0x").unwrap_or(seed);
            let mut seed_slice = [0u8; 32];

            hex::decode_to_slice(seed, &mut seed_slice)?;
            Ok(KeyGen::from_seed(seed_slice))
        } else {
            Ok(KeyGen::from_os_rng())
        }
    }
```

**File:** crates/aptos-genesis/src/keys.rs (L36-80)
```rust
pub fn generate_key_objects(
    keygen: &mut KeyGen,
) -> anyhow::Result<(IdentityBlob, IdentityBlob, PrivateIdentity, PublicIdentity)> {
    let account_key = ConfigKey::new(keygen.generate_ed25519_private_key());
    let consensus_key = ConfigKey::new(keygen.generate_bls12381_private_key());
    let validator_network_key = ConfigKey::new(keygen.generate_x25519_private_key()?);
    let full_node_network_key = ConfigKey::new(keygen.generate_x25519_private_key()?);

    let account_address = AuthenticationKey::ed25519(&account_key.public_key()).account_address();

    // Build these for use later as node identity
    let validator_blob = IdentityBlob {
        account_address: Some(account_address),
        account_private_key: Some(account_key.private_key()),
        consensus_private_key: Some(consensus_key.private_key()),
        network_private_key: validator_network_key.private_key(),
    };
    let vfn_blob = IdentityBlob {
        account_address: Some(account_address),
        account_private_key: None,
        consensus_private_key: None,
        network_private_key: full_node_network_key.private_key(),
    };

    let private_identity = PrivateIdentity {
        account_address,
        account_private_key: account_key.private_key(),
        consensus_private_key: consensus_key.private_key(),
        full_node_network_private_key: full_node_network_key.private_key(),
        validator_network_private_key: validator_network_key.private_key(),
    };

    let public_identity = PublicIdentity {
        account_address,
        account_public_key: account_key.public_key(),
        consensus_public_key: Some(private_identity.consensus_private_key.public_key()),
        consensus_proof_of_possession: Some(bls12381::ProofOfPossession::create(
            &private_identity.consensus_private_key,
        )),
        full_node_network_public_key: Some(full_node_network_key.public_key()),
        validator_network_public_key: Some(validator_network_key.public_key()),
    };

    Ok((validator_blob, vfn_blob, private_identity, public_identity))
}
```

**File:** crates/aptos-keygen/src/lib.rs (L15-23)
```rust
/// Ed25519 key generator.
#[derive(Debug)]
pub struct KeyGen(StdRng);

impl KeyGen {
    /// Constructs a key generator with a specific seed.
    pub fn from_seed(seed: [u8; 32]) -> Self {
        Self(StdRng::from_seed(seed))
    }
```
