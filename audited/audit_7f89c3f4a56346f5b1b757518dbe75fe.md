# Audit Report

## Title
Protocol Capability Bypass via Unauthenticated RPC Protocol_ID Manipulation

## Summary
The network layer fails to validate that incoming RPC requests use a `protocol_id` that was negotiated during the handshake phase. A malicious peer can advertise support for only a subset of protocols during connection establishment, then send RPC requests for unadvertised protocols, bypassing protocol capability checks and potentially causing resource exhaustion, unexpected behavior, or protocol confusion attacks.

## Finding Description

During the network handshake, peers exchange `HandshakeMsg` structures and negotiate common supported protocols through `perform_handshake()`. The intersection of supported protocols is stored in `ConnectionMetadata.application_protocols` for each established connection. [1](#0-0) 

However, when processing inbound RPC requests, the `Peer::handle_inbound_network_message()` function only checks if a local upstream handler exists for the requested protocol, without validating that the protocol was actually negotiated during handshake: [2](#0-1) 

The code checks `self.upstream_handlers.get(&request.protocol_id)` but never validates against `self.connection_metadata.application_protocols`. The `upstream_handlers` map contains **all protocols the local node supports**, not just those negotiated with this specific peer. [3](#0-2) 

A helper method exists to check protocol support but is never used during message processing: [4](#0-3) 

**Attack Path:**

1. Malicious peer connects and during handshake advertises support for only `ConsensusObserver` (protocol ID 27)
2. Handshake succeeds, `ConnectionMetadata.application_protocols` contains only `ConsensusObserver`
3. Peer sends RPC request with `protocol_id = ConsensusObserverRpc` (protocol ID 28)
4. The `RpcRequest` is deserialized from network with attacker-controlled `protocol_id`: [5](#0-4) 

5. Local node processes the request because it has an upstream handler for `ConsensusObserverRpc`, despite never negotiating support for it
6. The consensus observer publisher processes the unauthorized subscription request [6](#0-5) 

This violates the security invariant that protocol capabilities must be validated during handshake and enforced throughout the connection lifetime.

## Impact Explanation

**Severity: High** (up to $50,000)

This constitutes a **significant protocol violation** under the Aptos bug bounty program. Specific impacts include:

1. **Protocol Capability Bypass**: Peers can access protocols they didn't advertise support for, violating capability-based access control
2. **Resource Exhaustion**: Malicious peers can send RPC requests to expensive handlers (e.g., `ConsensusObserverRpc::Subscribe`) without proper negotiation
3. **Consensus Observer Manipulation**: Unauthorized peers can subscribe to consensus data streams, potentially causing state synchronization issues or DoS
4. **Attack Surface Expansion**: Opens all RPC handlers to unauthenticated access from any peer that completes initial handshake with minimal protocol support

While this doesn't directly enable fund theft or consensus safety violations, it significantly weakens the network's defense-in-depth architecture by allowing protocol capability checks to be bypassed.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Low Attack Complexity**: Attacker only needs to modify the `protocol_id` field in RPC requests after handshake
2. **No Special Privileges Required**: Any peer that can complete the initial handshake can exploit this
3. **Difficult to Detect**: The code currently logs unknown protocols with `UNKNOWN_LABEL` but processes requests for known protocols without validation
4. **Wide Attack Surface**: Affects all RPC-based protocols in Aptos networking (consensus, storage service, peer monitoring, etc.)

## Recommendation

Add protocol capability validation in `Peer::handle_inbound_network_message()` before processing RPC requests:

```rust
NetworkMessage::RpcRequest(request) => {
    // Validate that the protocol was negotiated during handshake
    if !self.connection_metadata.application_protocols.contains(request.protocol_id) {
        warn!(
            NetworkSchema::new(&self.network_context)
                .connection_metadata(&self.connection_metadata),
            protocol_id = ?request.protocol_id,
            "Peer {} attempted to use non-negotiated protocol {:?}",
            self.remote_peer_id().short_str(),
            request.protocol_id
        );
        
        // Send error response and increment metrics
        counters::direct_send_messages(&self.network_context, "not_negotiated").inc();
        
        // Optionally disconnect the peer for protocol violation
        self.shutdown(DisconnectReason::RequestedByPeerManager);
        return Ok(());
    }
    
    match self.upstream_handlers.get(&request.protocol_id) {
        // ... existing handler logic
    }
}
```

The same validation should be added for `DirectSendMsg` to ensure complete protection.

## Proof of Concept

```rust
#[test]
fn test_protocol_capability_bypass() {
    use aptos_network::protocols::wire::handshake::v1::{ProtocolId, ProtocolIdSet};
    use aptos_network::transport::ConnectionMetadata;
    
    // Peer negotiates only ConsensusObserver during handshake
    let mut negotiated_protocols = ProtocolIdSet::empty();
    negotiated_protocols.insert(ProtocolId::ConsensusObserver);
    
    let connection_metadata = ConnectionMetadata::new(
        PeerId::random(),
        ConnectionId::from(1),
        NetworkAddress::mock(),
        ConnectionOrigin::Inbound,
        MessagingProtocolVersion::V1,
        negotiated_protocols.clone(), // Only ConsensusObserver
        PeerRole::Unknown,
    );
    
    // Verify ConsensusObserverRpc was NOT negotiated
    assert!(!negotiated_protocols.contains(ProtocolId::ConsensusObserverRpc));
    
    // Attacker crafts RPC request with ConsensusObserverRpc protocol_id
    let malicious_request = NetworkMessage::RpcRequest(RpcRequest {
        protocol_id: ProtocolId::ConsensusObserverRpc, // Not negotiated!
        request_id: 1,
        priority: 0,
        raw_request: bcs::to_bytes(&ConsensusObserverRequest::Subscribe).unwrap(),
    });
    
    // Current implementation processes this request if upstream handler exists
    // Expected: Should reject with protocol capability error
    // Actual: Request is processed, bypassing capability checks
}
```

## Notes

This vulnerability affects the core network security model where protocol capabilities are supposed to be negotiated and enforced. The fix requires adding a single validation check but has significant security benefits by restoring the intended capability-based access control for network protocols. The similar issue may exist for `DirectSendMsg` handling and should also be audited.

### Citations

**File:** network/framework/src/transport/mod.rs (L100-108)
```rust
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** network/framework/src/peer/mod.rs (L126-127)
```rust
    upstream_handlers:
        Arc<HashMap<ProtocolId, aptos_channel::Sender<(PeerId, ProtocolId), ReceivedMessage>>>,
```

**File:** network/framework/src/peer/mod.rs (L505-530)
```rust
            NetworkMessage::RpcRequest(request) => {
                match self.upstream_handlers.get(&request.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(request.raw_request.len() as u64);
                    },
                    Some(handler) => {
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        if let Err(err) = self
                            .inbound_rpcs
                            .handle_inbound_request(handler, ReceivedMessage::new(message, sender))
                        {
                            warn!(
                                NetworkSchema::new(&self.network_context)
                                    .connection_metadata(&self.connection_metadata),
                                error = %err,
                                "{} Error handling inbound rpc request: {}",
                                self.network_context,
                                err
                            );
                        }
                    },
                }
```

**File:** network/framework/src/application/metadata.rs (L55-60)
```rust
    /// Returns true iff the peer has advertised support for the given protocol
    pub fn supports_protocol(&self, protocol_id: ProtocolId) -> bool {
        self.connection_metadata
            .application_protocols
            .contains(protocol_id)
    }
```

**File:** network/framework/src/protocols/wire/messaging/v1/mod.rs (L116-128)
```rust
#[derive(Clone, Debug, PartialEq, Eq, Deserialize, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct RpcRequest {
    /// `protocol_id` is a variant of the ProtocolId enum.
    pub protocol_id: ProtocolId,
    /// RequestId for the RPC Request.
    pub request_id: RequestId,
    /// Request priority in the range 0..=255.
    pub priority: Priority,
    /// Request payload. This will be parsed by the application-level handler.
    #[serde(with = "serde_bytes")]
    pub raw_request: Vec<u8>,
}
```

**File:** consensus/src/consensus_observer/network/network_handler.rs (L132-137)
```rust
                    let NetworkMessage {
                        peer_network_id,
                        protocol_id: _,
                        consensus_observer_message,
                        response_sender,
                    } = network_message;
```
