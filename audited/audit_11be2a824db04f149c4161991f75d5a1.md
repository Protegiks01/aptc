# Audit Report

## Title
Replay Mode Fails to Store Epoch-Ending Ledger Infos, Causing Permanent Epoch State Inconsistency

## Summary
The `ReplayChunkVerifier::maybe_select_chunk_ending_ledger_info()` function always returns `None`, completely ignoring epoch changes during transaction replay. This causes epoch-ending ledger infos to never be saved to the database, resulting in permanent storage inconsistency where epoch boundaries are not tracked and epoch state queries fail. [1](#0-0) 

## Finding Description
When transactions are replayed using the `TransactionReplayer` interface, the system uses `ReplayChunkVerifier` which implements the `ChunkResultVerifier` trait. During the ledger update phase, the executor calls `maybe_select_chunk_ending_ledger_info()` with the computed `next_epoch_state` parameter when an epoch change is detected from transaction execution. [2](#0-1) 

However, `ReplayChunkVerifier::maybe_select_chunk_ending_ledger_info()` unconditionally returns `Ok(None)`, ignoring both the `ledger_update_output` and the `next_epoch_state` parameters. This differs from `StateSyncChunkVerifier`, which properly handles epoch changes by returning epoch-ending ledger infos. [3](#0-2) 

When no ledger info is selected, the commit process proceeds without saving any epoch-ending ledger info to the database: [4](#0-3) 

The database's `put_ledger_info()` method only updates `EpochByVersionSchema` (which maps versions to epochs) when the ledger info has `ends_epoch() == true`: [5](#0-4) 

Without these critical database writes:
1. `EpochByVersionSchema` is never updated with epoch boundaries
2. `LedgerInfoSchema` never receives epoch-ending ledger infos
3. Subsequent queries to `get_epoch()`, `get_epoch_state()`, and `get_epoch_ending_ledger_info()` will fail or return incorrect data [6](#0-5) 

The system correctly detects epoch boundaries during replay by scanning for `new_epoch_event`: [7](#0-6) 

But when `remove_and_apply()` creates the `ReplayChunkVerifier`, it loses this epoch boundary information: [8](#0-7) 

## Impact Explanation
This issue causes **permanent storage inconsistency** and constitutes a **High severity** violation of the "State Consistency" invariant. After replaying transactions that cross epoch boundaries, the database lacks critical epoch state information required for:

1. **Consensus operations**: Validators need correct epoch state to verify validator set changes
2. **State synchronization**: Nodes cannot provide epoch change proofs (`get_epoch_ending_ledger_infos()`) to syncing peers
3. **Epoch verification**: Any component querying epoch information will fail, potentially causing node crashes
4. **Validator set transitions**: The system cannot determine which validator set was active at a given version

While backup restoration mitigates this by separately restoring epoch-ending ledger infos via `EpochEndingRestoreController`, any direct use of `TransactionReplayer` (such as in db-tool operations, testing frameworks, or custom recovery scripts) will produce a corrupted database state. [9](#0-8) 

## Likelihood Explanation
This issue manifests in several scenarios:

1. **db-tool operations**: When using transaction replay for verification across epoch boundaries
2. **Testing environments**: Tests using `TransactionReplayer` directly without mock epoch setup
3. **Custom recovery tools**: Any operational script using the replay interface
4. **Incomplete backup restoration**: If epoch-ending backup step is skipped or fails

The likelihood is **high** in operational and testing contexts, though somewhat mitigated by the standard backup restoration flow that handles epoch-ending ledger infos separately. However, the issue represents a fundamental design flaw where the replay mode silently produces an inconsistent database state.

## Recommendation
Modify `ReplayChunkVerifier::maybe_select_chunk_ending_ledger_info()` to construct and return epoch-ending ledger infos when `next_epoch_state` is present:

```rust
fn maybe_select_chunk_ending_ledger_info(
    &self,
    ledger_update_output: &LedgerUpdateOutput,
    next_epoch_state: Option<&EpochState>,
) -> Result<Option<LedgerInfoWithSignatures>> {
    if let Some(epoch_state) = next_epoch_state {
        // Construct minimal epoch-ending ledger info for replay mode
        let version = ledger_update_output.transaction_accumulator.num_leaves() - 1;
        let accumulator_root_hash = ledger_update_output.transaction_accumulator.root_hash();
        
        // Create a ledger info with next_epoch_state
        let ledger_info = LedgerInfo::new(
            BlockInfo::new(
                epoch_state.epoch,
                0, // round - not relevant for replay
                HashValue::zero(), // id - not relevant for replay
                accumulator_root_hash,
                version,
                0, // timestamp_usecs
                Some(epoch_state.clone()),
            ),
            HashValue::zero(), // consensus_data_hash
        );
        
        // Create unsigned ledger info (signatures not needed for replay)
        Ok(Some(LedgerInfoWithSignatures::new(
            ledger_info,
            BTreeMap::new(), // empty signatures for replay
        )))
    } else {
        Ok(None)
    }
}
```

Alternatively, enhance the replay interface to accept epoch-ending ledger infos as input parameters when they're available from the source data.

## Proof of Concept
```rust
use aptos_executor::chunk_executor::ChunkExecutor;
use aptos_executor_types::{TransactionReplayer, VerifyExecutionMode};
use aptos_storage_interface::DbReaderWriter;
use aptos_types::transaction::{Transaction, TransactionInfo, Version};
use aptos_vm::AptosVMBlockExecutor;

#[test]
fn test_replay_epoch_change_inconsistency() {
    // Setup: Create a test database and executor
    let db = setup_test_db();
    let replayer = ChunkExecutor::<AptosVMBlockExecutor>::new(db.clone());
    
    // Create transactions including an epoch change
    let (txns, aux_info, txn_infos, write_sets, events) = 
        create_transactions_with_epoch_change();
    
    // Replay transactions across epoch boundary
    replayer.enqueue_chunks(
        txns,
        aux_info,
        txn_infos,
        write_sets,
        events,
        &VerifyExecutionMode::verify_all()
    ).unwrap();
    
    replayer.update_ledger().unwrap();
    let final_version = replayer.commit().unwrap();
    
    // Attempt to query epoch state - THIS WILL FAIL
    let epoch_result = db.reader.get_epoch(final_version);
    
    // Assertion: The database lacks epoch boundary information
    assert!(epoch_result.is_err() || epoch_is_incorrect(epoch_result.unwrap()));
    
    // Attempt to get epoch-ending ledger info - THIS WILL ALSO FAIL
    let ledger_info_result = db.reader.get_epoch_ending_ledger_info(
        epoch_change_version
    );
    assert!(ledger_info_result.is_err());
}
```

**Notes**
This vulnerability violates the "State Consistency" invariant by creating a database where epoch boundaries exist in the transaction history (marked by `NewEpochEvent`s) but are not tracked in the storage schema (`EpochByVersionSchema` and `LedgerInfoSchema`). Any component attempting to query epoch information after replay will encounter failures, potentially causing node crashes or consensus issues. The issue is exacerbated by the silent failure modeâ€”replay completes successfully while leaving the database in an inconsistent state.

### Citations

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L89-117)
```rust
        } else if let Some(epoch_change_li) = &self.epoch_change_li {
            // If the epoch change LI is present, it must match the version of the chunk:
            let li = epoch_change_li.ledger_info();

            // Verify that the given ledger info corresponds to the new accumulator.
            ensure!(
                li.transaction_accumulator_hash() == txn_accumulator.root_hash(),
                "Root hash of a given epoch LI does not match local computation. {:?} vs {:?}",
                li,
                txn_accumulator,
            );
            ensure!(
                li.version() + 1 == txn_accumulator.num_leaves(),
                "Version of a given epoch LI does not match local computation. {:?} vs {:?}",
                li,
                txn_accumulator,
            );
            ensure!(
                li.ends_epoch(),
                "Epoch change LI does not carry validator set. version:{}",
                li.version(),
            );
            ensure!(
                li.next_epoch_state() == next_epoch_state,
                "New validator set of a given epoch LI does not match local computation. {:?} vs {:?}",
                li.next_epoch_state(),
                next_epoch_state,
            );
            Ok(Some(epoch_change_li.clone()))
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L146-152)
```rust
    fn maybe_select_chunk_ending_ledger_info(
        &self,
        _ledger_update_output: &LedgerUpdateOutput,
        _next_epoch_state: Option<&EpochState>,
    ) -> Result<Option<LedgerInfoWithSignatures>> {
        Ok(None)
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L271-281)
```rust
        if chunk.ledger_info_opt.is_some() || num_txns != 0 {
            let _timer = CHUNK_OTHER_TIMERS.timer_with(&["commit_chunk_impl__save_txns"]);
            // TODO(aldenhu): remove since there's no practical strategy to recover from this error.
            fail_point!("executor::commit_chunk", |_| {
                Err(anyhow::anyhow!("Injected error in commit_chunk"))
            });
            self.db.writer.save_transactions(
                output.as_chunk_to_commit(),
                chunk.ledger_info_opt.as_ref(),
                false, // sync_commit
            )?;
```

**File:** execution/executor/src/chunk_executor/mod.rs (L367-370)
```rust
        let ledger_info_opt = chunk_verifier.maybe_select_chunk_ending_ledger_info(
            &ledger_update_output,
            output.execution_output.next_epoch_state.as_ref(),
        )?;
```

**File:** execution/executor/src/chunk_executor/mod.rs (L461-473)
```rust
        // Find epoch boundaries.
        let mut epochs = Vec::new();
        let mut epoch_begin = chunk_begin; // epoch begin version
        for (version, events) in multizip((chunk_begin..chunk_end, event_vecs.iter())) {
            let is_epoch_ending = events.iter().any(ContractEvent::is_new_epoch_event);
            if is_epoch_ending {
                epochs.push((epoch_begin, version + 1));
                epoch_begin = version + 1;
            }
        }
        if epoch_begin < chunk_end {
            epochs.push((epoch_begin, chunk_end));
        }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L696-699)
```rust
        let chunk_verifier = Arc::new(ReplayChunkVerifier {
            transaction_infos: txn_infos,
        });
        self.enqueue_chunk(chunk, chunk_verifier, "replay")?;
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L186-198)
```rust
    pub(crate) fn put_ledger_info(
        &self,
        ledger_info_with_sigs: &LedgerInfoWithSignatures,
        batch: &mut SchemaBatch,
    ) -> Result<()> {
        let ledger_info = ledger_info_with_sigs.ledger_info();

        if ledger_info.ends_epoch() {
            // This is the last version of the current epoch, update the epoch by version index.
            batch.put::<EpochByVersionSchema>(&ledger_info.version(), &ledger_info.epoch())?;
        }
        batch.put::<LedgerInfoSchema>(&ledger_info.epoch(), ledger_info_with_sigs)
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L203-231)
```rust
    /// Returns the epoch at the given version.
    pub(crate) fn get_epoch(&self, version: Version) -> Result<u64> {
        let mut iter = self.db.iter::<EpochByVersionSchema>()?;
        // Search for the end of the previous epoch.
        iter.seek_for_prev(&version)?;
        let (epoch_end_version, epoch) = match iter.next().transpose()? {
            Some(x) => x,
            None => {
                // There should be a genesis LedgerInfo at version 0 (genesis only consists of one
                // transaction), so this normally doesn't happen. However this part of
                // implementation doesn't need to rely on this assumption.
                return Ok(0);
            },
        };
        ensure!(
            epoch_end_version <= version,
            "DB corruption: looking for epoch for version {}, got epoch {} ends at version {}",
            version,
            epoch,
            epoch_end_version
        );
        // If the obtained epoch ended before the given version, return epoch+1, otherwise
        // the given version is exactly the last version of the found epoch.
        Ok(if epoch_end_version < version {
            epoch + 1
        } else {
            epoch
        })
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L247-253)
```rust
        match self.controller.run_mode.as_ref() {
            RestoreRunMode::Restore { restore_handler } => {
                restore_handler.save_ledger_infos(&preheat_data.ledger_infos)?;

                EPOCH_ENDING_EPOCH.set(last_li.epoch() as i64);
                EPOCH_ENDING_VERSION.set(last_li.version() as i64);
            },
```
