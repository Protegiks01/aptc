# Audit Report

## Title
Consensus Safety Violation Through NewBlockEvent Schema Mismatch During Framework Upgrades

## Summary
A critical consensus safety vulnerability exists due to insufficient synchronization validation between the Move `NewBlockEvent` struct and its Rust counterpart. If the Move framework is upgraded to modify the `NewBlockEvent` schema (e.g., removing `failed_proposer_indices`), nodes running with mismatched Rust code will fail to deserialize events, causing different leader election results and network partition.

## Finding Description

The Aptos consensus protocol uses reputation-based leader election that relies on historical `NewBlockEvent` data. This event struct is defined in both Move and Rust, with explicit comments stating they "should be kept in-sync" but no enforcement mechanism. [1](#0-0) [2](#0-1) 

When Move code emits `NewBlockEvent` through the `emit_new_block_event()` function, the event data is BCS-serialized according to the Move struct layout: [3](#0-2) 

The serialized event bytes are later deserialized by Rust consensus code: [4](#0-3) 

**The vulnerability occurs during framework upgrades:**

1. A governance proposal modifies the Move `NewBlockEvent` struct (e.g., removes `failed_proposer_indices`)
2. The proposal passes and the framework is upgraded on-chain
3. Move code now emits events with the new schema (7 fields instead of 8)
4. Some validator nodes have updated Rust binaries (expecting 7 fields), others have old binaries (expecting 8 fields)
5. Old nodes: BCS deserialization fails at the line above, `refresh_db_result()` returns error
6. Error handling returns empty history with `HashValue::zero()` as root hash: [5](#0-4) 

7. The leader election algorithm uses this root hash in the seed calculation: [6](#0-5) 

8. **Critical Issue**: Different nodes compute different `state` values:
   - Nodes with old Rust code: `root_hash = HashValue::zero()`
   - Nodes with new Rust code: `root_hash = actual hash from successful deserialization`
   
9. Different `state` values → different `chosen_index` from `choose_index()` → **different leaders elected for the same round**

The default consensus configuration uses `ProposerAndVoterV2` which sets `use_root_hash_for_seed() = true`: [7](#0-6) 

This violates the fundamental consensus safety invariant: **All validators must agree on the valid proposer for each round**.

## Impact Explanation

**Severity: CRITICAL** - This meets the "Consensus/Safety violations" category in the Aptos bug bounty program, eligible for up to $1,000,000.

**Impact:**
1. **Consensus Divergence**: Different nodes elect different leaders, causing vote fragmentation and inability to form quorum certificates
2. **Network Partition**: The network splits into incompatible factions based on Rust binary version
3. **Chain Halt**: Without consensus on leadership, no new blocks can be committed
4. **Requires Hard Fork**: Recovery requires coordinated intervention and potentially rolling back framework changes

This breaks Critical Invariant #2: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine"

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attack Prerequisites:**
1. Malicious or careless governance proposal to modify `NewBlockEvent` schema
2. Proposal passes through voting (requires majority governance support)
3. Node operators have not all upgraded their Rust binaries to match

**Feasibility:**
- Governance proposals are a standard mechanism for framework upgrades
- The attack requires no special validator privileges
- The vulnerability exists during every framework upgrade window
- No automated checks prevent this mismatch

**Why it could happen:**
- Framework developers may not realize event schema changes affect Rust code
- CI/CD may not catch cross-language struct incompatibilities
- Upgrade coordination between framework and node binaries is manual
- The "should be kept in-sync" comment is not enforced

## Recommendation

**Immediate Mitigation:**
1. Add compile-time or integration tests that validate Move and Rust struct layouts match for all system events
2. Implement runtime version checking that validates event schema compatibility
3. Document critical event structs as immutable in framework upgrade policies

**Long-term Fix:**
1. Add BCS schema validation to framework upgrade compatibility checks
2. Generate Rust event structs from Move definitions (or vice versa) to ensure synchronization
3. Implement graceful degradation when event deserialization fails (use previous epoch's data)
4. Add monitoring/alerts when event deserialization failures occur

**Code Fix Example:**

```rust
// In leader_reputation.rs, add schema version validation
impl AptosDBBackend {
    fn refresh_db_result(&self, ...) -> Result<...> {
        let events = self.aptos_db.get_latest_block_events(limit)?;
        
        let new_block_events = events
            .into_iter()
            .map(|event| {
                // Add version tag validation
                bcs::from_bytes::<NewBlockEvent>(event.event.event_data())
                    .or_else(|e| {
                        // Log critical error - this indicates schema mismatch
                        error!("CRITICAL: NewBlockEvent schema mismatch: {:?}", e);
                        // Instead of failing silently, trigger node health alert
                        self.trigger_schema_mismatch_alert();
                        Err(e)
                    })
            })
            .collect::<Result<Vec<_>, _>>()?;
        // ...
    }
}
```

Additionally, add to framework upgrade validation:

```rust
// In code.move compatibility checking
public fun check_event_schema_compatibility(
    old_metadata: &PackageMetadata, 
    new_metadata: &PackageMetadata
) {
    // Validate that system event structs (NewBlockEvent, etc.) 
    // have not changed in incompatible ways
    assert!(
        event_schemas_compatible(old_metadata, new_metadata),
        error::invalid_argument(EEVENT_SCHEMA_INCOMPATIBLE)
    );
}
```

## Proof of Concept

**Scenario: Framework Upgrade Removes failed_proposer_indices**

1. **Initial State**: All nodes run with matching Move/Rust code (8-field `NewBlockEvent`)

2. **Malicious Governance Proposal**:
```move
// Modified block.move - removes failed_proposer_indices
struct NewBlockEvent has copy, drop, store {
    hash: address,
    epoch: u64,
    round: u64,
    height: u64,
    previous_block_votes_bitvec: vector<u8>,
    proposer: address,
    // REMOVED: failed_proposer_indices: vector<u64>,
    time_microseconds: u64,
}
```

3. **Proposal executes**, framework upgraded on-chain

4. **Node State After Upgrade**:
   - 50% of nodes: Updated Rust binaries (expect 7 fields)
   - 50% of nodes: Old Rust binaries (expect 8 fields)

5. **New Block Event Emitted** (7 fields in BCS)

6. **Leader Election for Round 100**:
   - Old nodes: `bcs::from_bytes` fails → `root_hash = 0x000...`
   - New nodes: `bcs::from_bytes` succeeds → `root_hash = 0xabc...`
   - Old nodes compute: `state = concat(0x000..., epoch, round)` → elect Validator A
   - New nodes compute: `state = concat(0xabc..., epoch, round)` → elect Validator B
   
7. **Result**: Network cannot reach consensus on round 100, chain halts

**Reproduction Steps**:
1. Deploy modified `block.move` via governance proposal
2. Wait for proposal execution
3. Observe event deserialization failures in old node logs
4. Monitor consensus metrics: vote fragmentation, QC formation failures
5. Confirm different nodes elect different leaders for same round

## Notes

This vulnerability represents a fundamental cross-language synchronization issue in Aptos's architecture. The reliance on manual synchronization between Move and Rust for critical consensus data structures creates a systemic risk during framework upgrades. The issue is particularly severe because:

1. It affects the consensus layer directly
2. It can be triggered through legitimate governance mechanisms
3. No automated validation catches this mismatch
4. The failure mode is silent (logging only) rather than fail-safe

The `failed_proposer_indices` field is specifically concerning because it's actively used in consensus reputation calculations, making any schema change to this struct immediately consensus-critical.

### Citations

**File:** types/src/account_config/events/new_block.rs (L18-31)
```rust
/// Struct that represents a NewBlockEvent.
/// Should be kept in-sync with NewBlockEvent move struct in block.move.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct NewBlockEvent {
    pub hash: AccountAddress,
    pub epoch: u64,
    pub round: u64,
    pub height: u64,
    pub previous_block_votes_bitvec: Vec<u8>,
    pub proposer: AccountAddress,
    pub failed_proposer_indices: Vec<u64>,
    // usecs (microseconds)
    pub timestamp: u64,
}
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L41-52)
```text
    /// Should be in-sync with NewBlockEvent rust struct in new_block.rs
    struct NewBlockEvent has copy, drop, store {
        hash: address,
        epoch: u64,
        round: u64,
        height: u64,
        previous_block_votes_bitvec: vector<u8>,
        proposer: address,
        failed_proposer_indices: vector<u64>,
        /// On-chain time during the block at the given height
        time_microseconds: u64,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L181-191)
```text
        let new_block_event = NewBlockEvent {
            hash,
            epoch,
            round,
            height: block_metadata_ref.height,
            previous_block_votes_bitvec,
            proposer,
            failed_proposer_indices,
            time_microseconds: timestamp,
        };
        emit_new_block_event(vm, &mut block_metadata_ref.new_block_events, new_block_event);
```

**File:** consensus/src/liveness/leader_reputation.rs (L82-90)
```rust
        let new_block_events = events
            .into_iter()
            .map(|event| {
                Ok(VersionedNewBlockEvent {
                    event: bcs::from_bytes::<NewBlockEvent>(event.event.event_data())?,
                    version: event.transaction_version,
                })
            })
            .collect::<Result<Vec<VersionedNewBlockEvent>, bcs::Error>>()?;
```

**File:** consensus/src/liveness/leader_reputation.rs (L198-210)
```rust
            let fresh_db_result = self.refresh_db_result(&mut locked, latest_db_version);
            match fresh_db_result {
                Ok((events, _version, hit_end)) => {
                    self.get_from_db_result(target_epoch, target_round, &events, hit_end)
                },
                Err(e) => {
                    // fails if requested events were pruned / or we never backfil them.
                    warn!(
                        error = ?e, "[leader reputation] Fail to refresh window",
                    );
                    (vec![], HashValue::zero())
                },
            }
```

**File:** consensus/src/liveness/leader_reputation.rs (L700-733)
```rust
        let target_round = round.saturating_sub(self.exclude_round);
        let (sliding_window, root_hash) = self.backend.get_block_metadata(self.epoch, target_round);
        let voting_power_participation_ratio =
            self.compute_chain_health_and_add_metrics(&sliding_window, round);
        let mut weights =
            self.heuristic
                .get_weights(self.epoch, &self.epoch_to_proposers, &sliding_window);
        let proposers = &self.epoch_to_proposers[&self.epoch];
        assert_eq!(weights.len(), proposers.len());

        // Multiply weights by voting power:
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();

        let state = if self.use_root_hash {
            [
                root_hash.to_vec(),
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        } else {
            [
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        };

        let chosen_index = choose_index(stake_weights, state);
        (proposers[chosen_index], voting_power_participation_ratio)
```

**File:** types/src/on_chain_config/consensus_config.rs (L540-544)
```rust
impl LeaderReputationType {
    pub fn use_root_hash_for_seed(&self) -> bool {
        // all versions after V1 should use root hash
        !matches!(self, Self::ProposerAndVoter(_))
    }
```
