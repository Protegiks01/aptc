# Audit Report

## Title
Consensus Node Denial of Service via Malicious SecretShare Messages with Invalid Author

## Summary
A malicious validator can cause complete validator node crashes by sending `SecretShare` messages with author addresses not in the current validator set. The lack of sender validation in the direct RPC path allows these messages to reach verification code where an unchecked `.expect()` call triggers a panic, causing the global panic handler to exit the entire validator process.

## Finding Description

The consensus secret sharing protocol lacks defense-in-depth validation when processing incoming `SecretShare` messages via direct RPC. While the reliable broadcast response path properly validates that `share.author() == peer`, [1](#0-0)  the direct RPC message handling path does not perform this critical check.

When a `SecretShare` message arrives via RPC, the `verification_task` deserializes it and calls `msg.verify()` without validating that the claimed author matches the network sender. [2](#0-1)  The network sender information is captured in `IncomingSecretShareRequest.sender` but explicitly marked as unused. [3](#0-2) 

Inside `SecretShare::verify()`, the code calls `config.get_id(self.author())` to retrieve the validator index. [4](#0-3)  The `get_id()` method uses `.expect("Peer should be in the index!")` which panics if the author is not in the validator set. [5](#0-4) 

**Critical Discovery:** The panic does not merely terminate the spawned task - Aptos validators use a global panic handler that calls `process::exit(12)` on any panic (except VM verifier panics), causing the entire validator process to crash. [6](#0-5)  This panic handler is explicitly configured during validator node startup. [7](#0-6) 

**Attack Scenario:**
1. Malicious validator V1 (authenticated on validator network, in current validator set) crafts a `SecretShare` with `author` field set to address 0xDEADBEEF (not in current validator set) or an address from a previous epoch
2. Sends this message to victim validators via consensus network RPC with correct epoch number (passes epoch validation) [8](#0-7) 
3. Victim's `verification_task` receives and deserializes the message
4. Calls `msg.verify()` → `share.verify()` → `config.get_id(0xDEADBEEF)`
5. The `.expect()` panics because 0xDEADBEEF is not in the validator set
6. Global panic handler triggers `process::exit(12)`
7. **Entire validator process crashes and goes offline**

This violates the **Consensus Liveness** invariant and breaks defense-in-depth principles. A TODO comment at line 78 indicates developers were aware of missing bounds checking but have not addressed it. [9](#0-8) 

## Impact Explanation

**High Severity** - This qualifies as a validator node crash attack under "Validator Node Slowdowns" category:

- A single malicious validator (well below Byzantine threshold of 1/3) can crash all other validators in the network
- This is NOT just task termination or slowdown - it's a complete validator process exit requiring manual restart
- The attack is sustainable and can be repeated indefinitely with minimal cost
- Consensus liveness is severely degraded as secret shares are required for randomness generation
- Validators cannot distinguish malicious messages until verification occurs, at which point the panic has already triggered

This does NOT reach **Critical** severity because:
- It does not cause permanent network partition requiring hardfork (validators can restart)
- It does not result in consensus safety violations or fund loss
- Block production may continue if randomness beacon is not strictly required for progress

However, the actual impact is more severe than originally claimed in the report - it causes complete process crashes, not just task panics.

## Likelihood Explanation

**HIGH** - This vulnerability is trivially exploitable:

- Only requires a single malicious validator (any validator in current set can attack)
- Attack execution is trivial: craft a `SecretShare` with any invalid `author` field (random address or old validator from previous epoch)
- No cryptographic knowledge required - just BCS serialization
- Attack can be fully automated and sustained
- No special timing or state requirements beyond having validator network access
- Victim nodes have no prevention mechanism before the crash occurs

## Recommendation

Implement sender validation in the direct RPC path to match the defense-in-depth check present in the reliable broadcast path:

```rust
// In verification_task, before calling msg.verify():
match &msg {
    SecretShareMessage::Share(share) => {
        ensure!(share.author() == &dec_msg.sender, 
                "Share author does not match network sender");
    },
    SecretShareMessage::RequestShare(_) => {}, // No validation needed for requests
}
```

Additionally, replace the `.expect()` with proper error handling:

```rust
// In SecretShareConfig::get_id():
pub fn get_id(&self, peer: &Author) -> anyhow::Result<usize> {
    self.validator
        .address_to_validator_index()
        .get(peer)
        .copied()
        .ok_or_else(|| anyhow!("Author {} not in current validator set", peer))
}
```

This prevents the panic and allows graceful error handling throughout the verification chain.

## Proof of Concept

```rust
// Mock test demonstrating the vulnerability
#[tokio::test]
async fn test_secret_share_invalid_author_panic() {
    // Setup: Create a SecretShareConfig with validators V1, V2, V3
    let validators = vec![validator1_address, validator2_address, validator3_address];
    let config = create_test_config(validators);
    
    // Attack: Create SecretShare with author NOT in validator set
    let malicious_share = SecretShare::new(
        AccountAddress::from_hex_literal("0xDEADBEEF").unwrap(), // Invalid author
        test_metadata,
        test_share,
    );
    
    // This call will panic with "Peer should be in the index!"
    // In production, this panic triggers process::exit(12) via crash handler
    let result = malicious_share.verify(&config);
    
    // Expected: Should return Err, but instead panics
    // Actual: Panics and crashes the validator process
}
```

The PoC demonstrates that any `SecretShare` with an author not in the validator set will trigger the panic. In a production validator node with the crash handler configured, this causes immediate process termination.

## Notes

This vulnerability represents a serious defense-in-depth failure where the reliable broadcast path correctly validates sender identity, but the direct RPC path does not. The severity is elevated because Aptos uses a fail-fast crash handler that converts panics into process exits. While individual validators can restart, a sustained attack prevents normal consensus operation and degrades network liveness. The attack requires only validator network access (any current validator) and can target all other validators simultaneously.

### Citations

**File:** consensus/src/rand/secret_sharing/reliable_broadcast_state.rs (L45-45)
```rust
        ensure!(share.author() == &peer, "Author does not match");
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L218-220)
```rust
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
```

**File:** consensus/src/network.rs (L157-158)
```rust
    #[allow(unused)]
    pub sender: Author,
```

**File:** types/src/secret_sharing.rs (L76-76)
```rust
        let index = config.get_id(self.author());
```

**File:** types/src/secret_sharing.rs (L78-78)
```rust
        // TODO(ibalajiarun): Check index out of bounds
```

**File:** types/src/secret_sharing.rs (L172-178)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** crates/crash-handler/src/lib.rs (L52-57)
```rust
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** aptos-node/src/lib.rs (L234-234)
```rust
    aptos_crash_handler::setup_panic_handler();
```

**File:** consensus/src/epoch_manager.rs (L1815-1822)
```rust
        match request.epoch() {
            Some(epoch) if epoch != self.epoch() => {
                monitor!(
                    "process_different_epoch_rpc_request",
                    self.process_different_epoch(epoch, peer_id)
                )?;
                return Ok(());
            },
```
