# Audit Report

## Title
Critical Epoch Boundary Validation Bypass in ExecutedChunk Creation Allowing Consensus Confusion and Chain Splits

## Summary
The `StateSyncChunkVerifier::maybe_select_chunk_ending_ledger_info` method fails to validate that the `verified_target_li` matches the execution's epoch-ending status when the target version matches. This allows Byzantine validators or malicious state sync peers to provide a non-epoch-ending LedgerInfo for chunks that actually end an epoch (or vice versa), bypassing critical safety checks and potentially causing consensus confusion and chain splits.

## Finding Description
The vulnerability exists in the epoch boundary validation logic within the chunk executor's verification system. The system has three code paths for determining which LedgerInfo to attach to an ExecutedChunk: [1](#0-0) 

**Path 1 (Vulnerable)**: When `verified_target_li.version()` matches the chunk end version, the code only validates the accumulator hash but **does not check** whether the LedgerInfo's epoch-ending status matches the execution result. It immediately returns the target LedgerInfo without comparing `li.next_epoch_state()` to the computed `next_epoch_state` parameter.

**Path 2 (Correct)**: When `epoch_change_li` is provided, the code properly validates both `li.ends_epoch()` and `li.next_epoch_state() == next_epoch_state`.

**Path 3 (Correct)**: When neither matches, it ensures `next_epoch_state.is_none()`.

The critical flaw is that Path 1 bypasses the safety check in Path 3. When the verified_target_li version matches, the function returns early at line 88, never reaching the epoch state validation that should occur.

**Attack Scenario:**

1. A malicious state sync peer (or Byzantine validators) provides a `verified_target_li` for version V that:
   - Has correct version and accumulator hash (passes basic checks)
   - Is properly signed by validators (passes signature verification)
   - Claims `ends_epoch() = false` and `next_epoch_state() = None`

2. The honest node executes the chunk containing a reconfiguration transaction at version V

3. Execution produces `next_epoch_state = Some(EpochState)` because the reconfiguration occurred [2](#0-1) 

4. In `maybe_select_chunk_ending_ledger_info`:
   - Line 80 condition passes (versions match: `li.version() + 1 == txn_accumulator.num_leaves()`)
   - Lines 82-87 accumulator hash check passes
   - Line 88 returns `Some(verified_target_li)` with **no epoch-ending validation**
   - The safety check at line 119-123 is never executed

5. The ExecutedChunk is created with contradictory state: [3](#0-2) 

   - `output.execution_output.next_epoch_state = Some(EpochState)` (execution says epoch ended)
   - `ledger_info_opt = Some(non-epoch-ending LedgerInfo)` (ledger info says epoch didn't end)

6. This mismatched state is committed to storage without detection: [4](#0-3) 

7. The database validation only checks if the LedgerInfo is internally consistent, not if it matches the execution state: [5](#0-4) 

The `check_and_put_ledger_info` validates version, accumulator hash, epoch continuity, and state snapshot persistence (if epoch-ending), but **never validates that the epoch-ending claim matches the actual execution result**.

## Impact Explanation
This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program for the following reasons:

1. **Consensus Safety Violation**: Different nodes may disagree on whether an epoch change occurred, directly violating the fundamental consensus safety guarantee. This breaks Invariant #2: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine."

2. **Potential Chain Split**: If some nodes receive the correct epoch_change_li while others receive only the malicious verified_target_li, they will have different views of the epoch boundary:
   - Nodes with correct info will proceed to the next epoch with the new validator set
   - Nodes with incorrect info will remain in the current epoch
   - This causes permanent divergence requiring a hardfork to resolve

3. **Validator Set Mismatch**: The next block may be produced with the wrong validator set, causing subsequent blocks to be rejected by nodes that correctly tracked the epoch change.

4. **Deterministic Execution Violation**: The system fails to maintain the critical invariant that "all validators must produce identical state roots for identical blocks" (Invariant #1), as different nodes will record different epoch boundaries for the same transactions.

5. **Non-Recoverable Network Partition**: Once nodes diverge on epoch boundaries, automatic recovery is impossible without manual intervention or a hardfork.

## Likelihood Explanation
The likelihood is **MEDIUM to HIGH** due to:

**Enablers:**
- Requires Byzantine validators to sign an incorrect LedgerInfo OR a malicious state sync peer to provide one
- Does not require > 1/3 Byzantine validators (system should tolerate up to 1/3)
- The vulnerability is in the normal state sync path, not an edge case
- No special timing or race conditions required

**Mitigators:**
- Requires coordination to produce a signature-valid but content-incorrect LedgerInfo
- Most state sync scenarios may have epoch_change_li provided, taking the correct Path 2
- Honest validators would not sign incorrect LedgerInfos

However, during network partitions, disagreements, or implementation bugs in validator software, incorrect LedgerInfos could naturally arise. The system should be robust against such scenarios.

## Recommendation
Add the same epoch state validation in Path 1 that exists in Path 2. Immediately after line 87, add:

```rust
// Verify epoch state consistency
ensure!(
    li.next_epoch_state() == next_epoch_state,
    "Next epoch state in target ledger info does not match execution: {:?} vs {:?}",
    li.next_epoch_state(),
    next_epoch_state,
);
```

**Complete Fix:** [6](#0-5) 

Should become:

```rust
if li.version() + 1 == txn_accumulator.num_leaves() {
    // If the chunk corresponds to the target LI, the target LI can be added to storage.
    ensure!(
        li.transaction_accumulator_hash() == txn_accumulator.root_hash(),
        "Root hash in target ledger info does not match local computation. {:?} != {:?}",
        li,
        txn_accumulator,
    );
    // CRITICAL FIX: Validate epoch state consistency
    ensure!(
        li.next_epoch_state() == next_epoch_state,
        "Next epoch state in target ledger info does not match execution: {:?} vs {:?}",
        li.next_epoch_state(),
        next_epoch_state,
    );
    Ok(Some(self.verified_target_li.clone()))
}
```

This ensures that regardless of which code path is taken, the epoch-ending status in the LedgerInfo always matches the execution result.

## Proof of Concept
```rust
// Test case demonstrating the vulnerability
#[test]
fn test_epoch_boundary_validation_bypass() {
    // Setup: Create a chunk that ends at version 100 and includes a reconfiguration
    let first_version = 95;
    let last_version = 100;
    let transactions = create_test_transactions_with_reconfig_at(100);
    
    // Execute the chunk - this will produce next_epoch_state
    let execution_output = execute_chunk(transactions, first_version);
    assert!(execution_output.next_epoch_state.is_some(), "Reconfig should produce epoch state");
    
    // Attack: Create a verified_target_li that claims no epoch change
    let malicious_li = create_ledger_info(
        version: 100,
        accumulator_hash: execution_output.accumulator_root, // Correct hash
        ends_epoch: false,  // INCORRECT - claims no epoch change
        next_epoch_state: None,  // INCORRECT - should have epoch state
    );
    
    // Sign with validators (simulating Byzantine validators)
    let signed_malicious_li = sign_ledger_info(malicious_li, &validator_signers);
    
    // Create verifier with malicious LI and no epoch_change_li
    let verifier = StateSyncChunkVerifier {
        txn_infos_with_proof: create_proof(first_version, last_version),
        verified_target_li: signed_malicious_li,
        epoch_change_li: None,  // No separate epoch change LI provided
    };
    
    // Call maybe_select_chunk_ending_ledger_info
    let result = verifier.maybe_select_chunk_ending_ledger_info(
        &ledger_update_output,
        execution_output.next_epoch_state.as_ref(),  // Some(EpochState) from execution
    );
    
    // VULNERABILITY: This should FAIL but currently SUCCEEDS
    assert!(result.is_ok(), "Current implementation incorrectly accepts mismatched epoch state");
    let ledger_info_opt = result.unwrap();
    assert!(ledger_info_opt.is_some());
    
    // The returned LI claims no epoch change despite execution producing one
    let returned_li = ledger_info_opt.unwrap();
    assert!(!returned_li.ledger_info().ends_epoch(), "Mismatch: execution ended epoch but LI says no");
    
    // This creates an ExecutedChunk with contradictory state:
    // - execution_output.next_epoch_state = Some(...)
    // - ledger_info_opt contains non-epoch-ending LI
    // Leading to consensus confusion when committed
}
```

**Notes:**
- The vulnerability exists because Path 1 (verified_target_li version match) does not validate `next_epoch_state` consistency
- The fix requires adding a single `ensure!` check comparing `li.next_epoch_state()` to the computed `next_epoch_state`
- This is a critical consensus safety issue that can cause chain splits and requires a hardfork to resolve
- The system should never commit a LedgerInfo whose epoch-ending status contradicts the execution result

### Citations

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L72-126)
```rust
    fn maybe_select_chunk_ending_ledger_info(
        &self,
        ledger_update_output: &LedgerUpdateOutput,
        next_epoch_state: Option<&EpochState>,
    ) -> Result<Option<LedgerInfoWithSignatures>> {
        let li = self.verified_target_li.ledger_info();
        let txn_accumulator = &ledger_update_output.transaction_accumulator;

        if li.version() + 1 == txn_accumulator.num_leaves() {
            // If the chunk corresponds to the target LI, the target LI can be added to storage.
            ensure!(
                li.transaction_accumulator_hash() == txn_accumulator.root_hash(),
                "Root hash in target ledger info does not match local computation. {:?} != {:?}",
                li,
                txn_accumulator,
            );
            Ok(Some(self.verified_target_li.clone()))
        } else if let Some(epoch_change_li) = &self.epoch_change_li {
            // If the epoch change LI is present, it must match the version of the chunk:
            let li = epoch_change_li.ledger_info();

            // Verify that the given ledger info corresponds to the new accumulator.
            ensure!(
                li.transaction_accumulator_hash() == txn_accumulator.root_hash(),
                "Root hash of a given epoch LI does not match local computation. {:?} vs {:?}",
                li,
                txn_accumulator,
            );
            ensure!(
                li.version() + 1 == txn_accumulator.num_leaves(),
                "Version of a given epoch LI does not match local computation. {:?} vs {:?}",
                li,
                txn_accumulator,
            );
            ensure!(
                li.ends_epoch(),
                "Epoch change LI does not carry validator set. version:{}",
                li.version(),
            );
            ensure!(
                li.next_epoch_state() == next_epoch_state,
                "New validator set of a given epoch LI does not match local computation. {:?} vs {:?}",
                li.next_epoch_state(),
                next_epoch_state,
            );
            Ok(Some(epoch_change_li.clone()))
        } else {
            ensure!(
                next_epoch_state.is_none(),
                "End of epoch chunk based on local computation but no EoE LedgerInfo provided. version: {:?}",
                txn_accumulator.num_leaves().checked_sub(1),
            );
            Ok(None)
        }
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L520-540)
```rust
    fn ensure_next_epoch_state(to_commit: &TransactionsWithOutput) -> Result<EpochState> {
        let last_write_set = to_commit
            .transaction_outputs
            .last()
            .ok_or_else(|| anyhow!("to_commit is empty."))?
            .write_set();

        let write_set_view = WriteSetStateView {
            write_set: last_write_set,
        };

        let validator_set = ValidatorSet::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("ValidatorSet not touched on epoch change"))?;
        let configuration = ConfigurationResource::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("Configuration resource not touched on epoch change"))?;

        Ok(EpochState::new(
            configuration.epoch(),
            (&validator_set).into(),
        ))
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L277-281)
```rust
            self.db.writer.save_transactions(
                output.as_chunk_to_commit(),
                chunk.ledger_info_opt.as_ref(),
                false, // sync_commit
            )?;
```

**File:** execution/executor/src/chunk_executor/mod.rs (L376-379)
```rust
        let executed_chunk = ExecutedChunk {
            output,
            ledger_info_opt,
        };
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L540-600)
```rust
    fn check_and_put_ledger_info(
        &self,
        version: Version,
        ledger_info_with_sig: &LedgerInfoWithSignatures,
        ledger_batch: &mut SchemaBatch,
    ) -> Result<(), AptosDbError> {
        let ledger_info = ledger_info_with_sig.ledger_info();

        // Verify the version.
        ensure!(
            ledger_info.version() == version,
            "Version in LedgerInfo doesn't match last version. {:?} vs {:?}",
            ledger_info.version(),
            version,
        );

        // Verify the root hash.
        let db_root_hash = self
            .ledger_db
            .transaction_accumulator_db()
            .get_root_hash(version)?;
        let li_root_hash = ledger_info_with_sig
            .ledger_info()
            .transaction_accumulator_hash();
        ensure!(
            db_root_hash == li_root_hash,
            "Root hash pre-committed doesn't match LedgerInfo. pre-commited: {:?} vs in LedgerInfo: {:?}",
            db_root_hash,
            li_root_hash,
        );

        // Verify epoch continuity.
        let current_epoch = self
            .ledger_db
            .metadata_db()
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            ledger_info_with_sig.ledger_info().epoch() == current_epoch,
            "Gap in epoch history. Trying to put in LedgerInfo in epoch: {}, current epoch: {}",
            ledger_info_with_sig.ledger_info().epoch(),
            current_epoch,
        );

        // Ensure that state tree at the end of the epoch is persisted.
        if ledger_info_with_sig.ledger_info().ends_epoch() {
            let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
            ensure!(
                state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
                "State checkpoint not persisted at the end of the epoch, version {}, next_epoch {}, snapshot in db: {:?}",
                version,
                ledger_info_with_sig.ledger_info().next_block_epoch(),
                state_snapshot,
            );
        }

        // Put write to batch.
        self.ledger_db
            .metadata_db()
            .put_ledger_info(ledger_info_with_sig, ledger_batch)?;
        Ok(())
```
