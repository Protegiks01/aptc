# Audit Report

## Title
Missing Cryptographic Proof Verification in Account Transaction History API

## Summary
The `get_account_ordered_transactions()` API endpoint returns `AccountOrderedTransactionsWithProof` objects containing cryptographic proofs, but never verifies these proofs before serving data to clients. This creates a trust boundary violation where the API blindly trusts the internal indexer database's account-to-transaction mappings without cryptographic validation.

## Finding Description

The vulnerability exists in the transaction history query flow involving the `IndexerReader` trait and its usage in the API layer.

**The Issue:**

The `AccountOrderedTransactionsWithProof` type includes a `verify()` method that cryptographically validates:
1. All transactions are consistent with the ledger info
2. All transactions were sent by the requested account
3. The transactions are contiguous by sequence number
4. The sender address and sequence numbers match expectations [1](#0-0) 

However, the API layer never invokes this verification method: [2](#0-1) 

**The Data Flow:**

1. The indexer database stores mappings: `(account_address, sequence_number) â†’ version` [3](#0-2) 

2. When queried, the indexer retrieves these mappings and fetches transactions from the main database: [4](#0-3) 

3. The transactions include cryptographic proofs (`TransactionInfoWithProof`) linking them to the ledger: [5](#0-4) 

4. These proofs are constructed from the transaction accumulator Merkle tree: [6](#0-5) 

**The Vulnerability:**

The API layer converts the `TransactionWithProof` objects to `TransactionOnChainData` without verification: [7](#0-6) 

This creates a trust assumption that the indexer database mappings are correct. If these mappings are corrupted or manipulated:
- Transactions from Account A could be returned when querying Account B
- Validator transaction history could be fabricated
- The cryptographic proofs would still be valid (proving those transactions exist in the ledger), but they would be the wrong transactions for the queried account

## Impact Explanation

**Severity: Medium to High**

While this qualifies as a **State Consistency** issue requiring intervention, the practical exploitability is limited:

**Potential Attack Scenarios:**

1. **Database Corruption**: Software bugs, race conditions, or disk failures could corrupt the indexer database, causing incorrect account-to-version mappings to be served with valid proofs from wrong accounts.

2. **Indexer Population Bug**: A bug in the indexer population logic could create incorrect mappings that persist and are served to API clients.

3. **Trust Boundary Violation**: The architectural design assumes the indexer database is as trustworthy as the main database, but they are separate data stores with separate corruption vectors.

**Impact:**
- API clients receive transaction history that appears cryptographically valid but is for the wrong account
- Violation of **State Consistency** invariant: transaction history queries should be deterministic and correct
- Could affect consensus if validators query incorrect transaction data via API
- Breaks **Cryptographic Correctness** invariant: proofs should guarantee correctness, not just existence

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires one of the following conditions:
1. Software bug in indexer population logic (medium likelihood during development/upgrades)
2. Database corruption affecting the indexer but not main database (low likelihood)
3. Race conditions during synchronization (low likelihood with current implementation)

While direct attacker exploitation is difficult (requires node compromise), the vulnerability could manifest through:
- Normal operational failures (disk corruption, crashes during writes)
- Software bugs introduced during updates
- Race conditions under high load

The lack of defense-in-depth is concerning: even though the proofs exist and could catch errors, they are never checked.

## Recommendation

Add proof verification to the API layer before serving transaction data:

```rust
// In api/src/context.rs, modify get_account_ordered_transactions:

pub fn get_account_ordered_transactions<E: NotFoundError + InternalError>(
    &self,
    address: AccountAddress,
    start_seq_number: Option<u64>,
    limit: u16,
    ledger_version: u64,
    ledger_info: &LedgerInfo,
) -> Result<Vec<TransactionOnChainData>, E> {
    let start_seq_number = if let Some(start_seq_number) = start_seq_number {
        start_seq_number
    } else {
        self.get_resource_poem::<AccountResource, E>(
            address,
            ledger_info.version(),
            ledger_info,
        )?
        .map(|r| r.sequence_number())
        .unwrap_or(0)
        .saturating_sub(limit as u64)
    };

    let txns_res = if !db_sharding_enabled(&self.node_config) {
        self.db.get_account_ordered_transactions(
            address,
            start_seq_number,
            limit as u64,
            true,
            ledger_version,
        )
    } else {
        self.indexer_reader
            .as_ref()
            .ok_or_else(|| anyhow!("Indexer reader is None"))
            .map_err(|err| {
                E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
            })?
            .get_account_ordered_transactions(
                address,
                start_seq_number,
                limit as u64,
                true,
                ledger_version,
            )
            .map_err(|e| AptosDbError::Other(e.to_string()))
    };
    
    let txns = txns_res
        .context("Failed to retrieve account transactions")
        .map_err(|err| {
            E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
        })?;
    
    // ADD PROOF VERIFICATION HERE
    txns.verify(
        ledger_info,
        address,
        start_seq_number,
        limit as u64,
        true, // include_events
        ledger_version,
    )
    .context("Transaction proof verification failed")
    .map_err(|err| {
        E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
    })?;
    
    txns.into_inner()
        .into_iter()
        .map(|t| -> Result<TransactionOnChainData> {
            let txn = self.convert_into_transaction_on_chain_data(t)?;
            Ok(self.maybe_translate_v2_to_v1_events(txn))
        })
        .collect::<Result<Vec<_>>>()
        .context("Failed to parse account transactions")
        .map_err(|err| E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info))
}
```

This adds a defense-in-depth layer that will catch any inconsistencies between the indexer database mappings and the actual transaction data, preventing the serving of incorrect account history.

## Proof of Concept

A Rust integration test demonstrating the vulnerability:

```rust
#[test]
fn test_unverified_account_transactions() {
    // Setup: Create two accounts with transactions
    let account_a = AccountAddress::random();
    let account_b = AccountAddress::random();
    
    // Populate main database with transactions from account_a
    let txn_a = create_user_transaction(account_a, 0, /* ... */);
    let version_a = store_transaction(&db, txn_a);
    
    // Corrupt indexer database: map account_b -> version_a
    // This simulates indexer corruption or bug
    indexer_db.put((account_b, 0), version_a);
    
    // Query account_b transactions via API
    let result = api_context.get_account_ordered_transactions(
        account_b, // querying account B
        Some(0),
        10,
        ledger_version,
        &ledger_info,
    );
    
    // BUG: API returns account_a's transaction when queried for account_b
    // The cryptographic proof is valid (proves the transaction exists in ledger)
    // but it doesn't prove it's from account_b
    assert!(result.is_ok());
    let txns = result.unwrap();
    
    // This should fail but doesn't - transaction is from account_a, not account_b
    assert_eq!(txns[0].sender(), account_a); // WRONG ACCOUNT!
}
```

**Notes:**

This vulnerability represents a **defense-in-depth failure** rather than a direct exploit vector. The cryptographic proofs exist and could prevent serving incorrect data, but are never checked. While practical exploitation requires additional conditions (indexer corruption, bugs, etc.), the lack of verification violates security best practices and the principle that cryptographic guarantees should be enforced, not assumed.

### Citations

**File:** types/src/transaction/mod.rs (L1393-1415)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct TransactionWithProof {
    pub version: Version,
    pub transaction: Transaction,
    pub events: Option<Vec<ContractEvent>>,
    pub proof: TransactionInfoWithProof,
}

impl TransactionWithProof {
    pub fn new(
        version: Version,
        transaction: Transaction,
        events: Option<Vec<ContractEvent>>,
        proof: TransactionInfoWithProof,
    ) -> Self {
        Self {
            version,
            transaction,
            events,
            proof,
        }
    }
```

**File:** types/src/transaction/mod.rs (L2888-2935)
```rust
    /// 1. Verify all transactions are consistent with the given ledger info.
    /// 2. All transactions were sent by `account`.
    /// 3. The transactions are contiguous by sequence number, starting at `start_seq_num`.
    /// 4. No more transactions than limit.
    /// 5. Events are present when requested (and not present when not requested).
    /// 6. Transactions are not newer than requested ledger version.
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        account: AccountAddress,
        start_seq_num: u64,
        limit: u64,
        include_events: bool,
        ledger_version: Version,
    ) -> Result<()> {
        ensure!(
            self.len() as u64 <= limit,
            "number of account transactions ({}) exceeded limit ({})",
            self.len(),
            limit,
        );

        self.0
            .iter()
            .enumerate()
            .try_for_each(|(seq_num_offset, txn_with_proof)| {
                let expected_seq_num = start_seq_num.saturating_add(seq_num_offset as u64);
                let txn_version = txn_with_proof.version;

                ensure!(
                    include_events == txn_with_proof.events.is_some(),
                    "unexpected events or missing events"
                );
                ensure!(
                    txn_version <= ledger_version,
                    "transaction with version ({}) greater than requested ledger version ({})",
                    txn_version,
                    ledger_version,
                );

                txn_with_proof.verify_user_txn(
                    ledger_info,
                    txn_version,
                    account,
                    ReplayProtector::SequenceNumber(expected_seq_num),
                )
            })
    }
```

**File:** api/src/context.rs (L879-938)
```rust
    pub fn get_account_ordered_transactions<E: NotFoundError + InternalError>(
        &self,
        address: AccountAddress,
        start_seq_number: Option<u64>,
        limit: u16,
        ledger_version: u64,
        ledger_info: &LedgerInfo,
    ) -> Result<Vec<TransactionOnChainData>, E> {
        let start_seq_number = if let Some(start_seq_number) = start_seq_number {
            start_seq_number
        } else {
            self.get_resource_poem::<AccountResource, E>(
                address,
                ledger_info.version(),
                ledger_info,
            )?
            .map(|r| r.sequence_number())
            .unwrap_or(0)
            .saturating_sub(limit as u64)
        };

        let txns_res = if !db_sharding_enabled(&self.node_config) {
            self.db.get_account_ordered_transactions(
                address,
                start_seq_number,
                limit as u64,
                true,
                ledger_version,
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| anyhow!("Indexer reader is None"))
                .map_err(|err| {
                    E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
                })?
                .get_account_ordered_transactions(
                    address,
                    start_seq_number,
                    limit as u64,
                    true,
                    ledger_version,
                )
                .map_err(|e| AptosDbError::Other(e.to_string()))
        };
        let txns = txns_res
            .context("Failed to retrieve account transactions")
            .map_err(|err| {
                E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
            })?;
        txns.into_inner()
            .into_iter()
            .map(|t| -> Result<TransactionOnChainData> {
                let txn = self.convert_into_transaction_on_chain_data(t)?;
                Ok(self.maybe_translate_v2_to_v1_events(txn))
            })
            .collect::<Result<Vec<_>>>()
            .context("Failed to parse account transactions")
            .map_err(|err| E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info))
    }
```

**File:** api/src/context.rs (L1070-1082)
```rust
    fn convert_into_transaction_on_chain_data(
        &self,
        txn: TransactionWithProof,
    ) -> Result<TransactionOnChainData> {
        // the type is Vec<(Transaction, TransactionOutput)> - given we have one transaction here, there should only ever be one value in this array
        let (_, txn_output) = &self
            .db
            .get_transaction_outputs(txn.version, 1, txn.version)?
            .consume_output_list_with_proof()
            .transactions_and_outputs[0];
        self.get_accumulator_root_hash(txn.version)
            .map(|h| (txn, h, txn_output).into())
    }
```

**File:** storage/indexer/src/db_indexer.rs (L422-428)
```rust
                    if let ReplayProtector::SequenceNumber(seq_num) = signed_txn.replay_protector()
                    {
                        batch.put::<OrderedTransactionByAccountSchema>(
                            &(signed_txn.sender(), seq_num),
                            &version,
                        )?;
                    }
```

**File:** storage/indexer/src/db_indexer.rs (L598-611)
```rust
        let txns_with_proofs = self
            .indexer_db
            .get_account_ordered_transactions_iter(address, start_seq_num, limit, ledger_version)?
            .map(|result| {
                let (_seq_num, txn_version) = result?;
                self.main_db_reader.get_transaction_by_version(
                    txn_version,
                    ledger_version,
                    include_events,
                )
            })
            .collect::<Result<Vec<_>>>()?;

        Ok(AccountOrderedTransactionsWithProof::new(txns_with_proofs))
```

**File:** storage/aptosdb/src/ledger_db/transaction_accumulator_db.rs (L66-73)
```rust
    pub fn get_transaction_proof(
        &self,
        version: Version,
        ledger_version: Version,
    ) -> Result<TransactionAccumulatorProof> {
        Accumulator::get_proof(self, ledger_version + 1 /* num_leaves */, version)
            .map_err(Into::into)
    }
```
