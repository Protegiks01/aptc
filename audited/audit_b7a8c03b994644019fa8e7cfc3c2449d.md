# Audit Report

## Title
Integer Overflow Risk in StateStorageUsage Update Due to Unchecked Cast Operations

## Summary
The `State::update_usage()` function performs unchecked integer conversions when updating storage usage counters, violating Rust coding standards and potentially allowing integer wraparound that could corrupt usage accounting and gas parameters.

## Finding Description

The vulnerability exists in the state storage usage tracking system. [1](#0-0) 

The function performs unchecked arithmetic by:
1. Casting `usize` values to `i64`
2. Adding signed deltas
3. Casting back to `usize` without overflow checks

This violates the codebase's explicit coding guidelines. [2](#0-1) 

**Vulnerability Mechanism:**
If the intermediate value `(items as i64 + items_delta)` becomes negative (when `items_delta` is more negative than the current count), the cast to `usize` causes wraparound. In Rust's two's complement representation, `-100 as usize` becomes `18446744073709551516` on 64-bit systems.

**Attack Surface:**
The usage deltas are calculated per-shard and summed. [3](#0-2) 

The delta calculation relies on cache accuracy. [4](#0-3) 

**Critical Impact Path:**
Corrupted usage values flow to the Move framework's storage gas module. [5](#0-4) 

This would cause gas parameters to be calculated from wraparound values, potentially:
- Causing extremely high/low gas costs
- Creating non-determinism if nodes diverge
- Corrupting economic incentives

**Defensive Check:**
A consistency check exists that compares usage with actual tree leaf count. [6](#0-5) 

This check would detect wraparound and halt the node with an error, preventing consensus but causing availability issues.

## Impact Explanation

**High Severity** - This meets the "Validator node slowdowns" and "API crashes" criteria because:

1. **Network Liveness Impact**: If the overflow occurs, the consistency check would fail, causing all nodes to halt block production simultaneously. This creates a network-wide liveness failure requiring manual intervention.

2. **Gas Parameter Corruption**: If the overflow somehow bypasses checks (e.g., during state sync, restoration, or due to race conditions), corrupted usage values would propagate to on-chain gas calculations, affecting all transaction costs network-wide.

3. **State Inconsistency Risk**: The wraparound would create a massive discrepancy between tracked usage and actual state, violating the State Consistency invariant.

## Likelihood Explanation

**Medium-Low Likelihood** - While the coding violation is clear, exploitation requires specific conditions:

**Triggering Scenarios:**
- Cache corruption or inconsistency during state updates
- State synchronization bugs causing incorrect delta calculations
- Concurrent modification race conditions
- State restoration with malformed data
- Edge cases during epoch transitions

The likelihood is reduced by:
- The consistency check providing a safety net
- Cache validation logic preventing most incorrect deltas
- The extreme values needed for practical overflow

However, the lack of checked arithmetic means any future bug in state tracking, caching, or synchronization could trigger this issue.

## Recommendation

Replace unchecked casts with checked arithmetic throughout the usage tracking code:

**For State::update_usage():**
```rust
fn update_usage(&self, usage_delta_per_shard: Vec<(i64, i64)>) -> Result<StateStorageUsage> {
    assert_eq!(usage_delta_per_shard.len(), NUM_STATE_SHARDS);

    let (items_delta, bytes_delta) = usage_delta_per_shard
        .into_iter()
        .fold((0, 0), |(i1, b1), (i2, b2)| (i1 + i2, b1 + b2));
    
    let new_items = (self.usage().items() as i64)
        .checked_add(items_delta)
        .and_then(|v| usize::try_from(v).ok())
        .ok_or_else(|| anyhow!("State storage usage items overflow"))?;
    
    let new_bytes = (self.usage().bytes() as i64)
        .checked_add(bytes_delta)
        .and_then(|v| usize::try_from(v).ok())
        .ok_or_else(|| anyhow!("State storage usage bytes overflow"))?;
    
    Ok(StateStorageUsage::new(new_items, new_bytes))
}
```

**For StateStorageUsage methods:** [7](#0-6) 

Use checked arithmetic:
```rust
pub fn add_item(&mut self, bytes_delta: usize) -> Result<()> {
    match self {
        Self::Tracked { items, bytes } => {
            *items = items.checked_add(1)
                .ok_or_else(|| anyhow!("Items counter overflow"))?;
            *bytes = bytes.checked_add(bytes_delta)
                .ok_or_else(|| anyhow!("Bytes counter overflow"))?;
            Ok(())
        },
        Self::Untracked => Ok(()),
    }
}
```

## Proof of Concept

Due to the defensive checks in place, a complete PoC would require reproducing cache corruption or state sync bugs, which are beyond the scope of this report. However, the vulnerability can be demonstrated conceptually:

```rust
#[test]
fn test_usage_underflow_wraparound() {
    // Simulate current state with low usage
    let current_items: usize = 100;
    let current_bytes: usize = 10000;
    
    // Simulate incorrect delta (e.g., from cache corruption)
    let items_delta: i64 = -200;  // More negative than current
    let bytes_delta: i64 = -20000;
    
    // Current code (vulnerable)
    let wrapped_items = (current_items as i64 + items_delta) as usize;
    let wrapped_bytes = (current_bytes as i64 + bytes_delta) as usize;
    
    // On 64-bit: wrapped_items = 18446744073709551516
    // On 64-bit: wrapped_bytes = 18446744073709551606
    assert!(wrapped_items > usize::MAX / 2);  // Massive wraparound
    assert!(wrapped_bytes > usize::MAX / 2);  // Massive wraparound
    
    // This would fail the consistency check later
    // but if it reached gas calculation, would corrupt parameters
}
```

The PoC demonstrates that the cast pattern allows wraparound. In production, this would be caught by the consistency check, but represents a dangerous code pattern that violates defense-in-depth principles.

---

**Notes:**

While defensive checks prevent this from causing immediate consensus divergence, the unchecked arithmetic violates critical coding standards and creates a latent vulnerability. Any future bug in state tracking could trigger wraparound, and the lack of proper error handling means the failure mode would be node halt rather than graceful degradation. The proper fix is to use checked arithmetic as mandated by coding guidelines throughout the storage usage tracking system.

### Citations

**File:** storage/storage-interface/src/state_store/state.rs (L328-333)
```rust
    fn update_usage(&self, usage_delta_per_shard: Vec<(i64, i64)>) -> StateStorageUsage {
        assert_eq!(usage_delta_per_shard.len(), NUM_STATE_SHARDS);

        let (items_delta, bytes_delta) = usage_delta_per_shard
            .into_iter()
            .fold((0, 0), |(i1, b1), (i2, b2)| (i1 + i2, b1 + b2));
```

**File:** storage/storage-interface/src/state_store/state.rs (L334-337)
```rust
        StateStorageUsage::new(
            (self.usage().items() as i64 + items_delta) as usize,
            (self.usage().bytes() as i64 + bytes_delta) as usize,
        )
```

**File:** storage/storage-interface/src/state_store/state.rs (L340-368)
```rust
    fn usage_delta_for_shard<'kv>(
        cache: &StateCacheShard,
        overlay: &LayeredMap<StateKey, StateSlot>,
        updates: &HashMap<&'kv StateKey, StateUpdateRef<'kv>>,
    ) -> (i64, i64) {
        let mut items_delta: i64 = 0;
        let mut bytes_delta: i64 = 0;
        for (k, v) in updates {
            let state_value_opt = match v.state_op.as_state_value_opt() {
                Some(value_opt) => value_opt,
                None => continue,
            };

            let key_size = k.size();
            if let Some(value) = state_value_opt {
                items_delta += 1;
                bytes_delta += (key_size + value.size()) as i64;
            }

            // n.b. all updated state items must be read and recorded in the state cache,
            // otherwise we can't calculate the correct usage.
            let old_slot = Self::expect_old_slot(overlay, cache, k);
            if old_slot.is_occupied() {
                items_delta -= 1;
                bytes_delta -= (key_size + old_slot.size()) as i64;
            }
        }
        (items_delta, bytes_delta)
    }
```

**File:** RUST_CODING_STYLE.md (L220-231)
```markdown
### Integer Arithmetic

As every integer operation (`+`, `-`, `/`, `*`, etc.) implies edge-cases (e.g. overflow `u64::MAX + 1`, underflow `0u64 -1`, division by zero, etc.),
we use checked arithmetic instead of directly using math symbols.
It forces us to think of edge-cases, and handle them explicitly.
This is a brief and simplified mini guide of the different functions that exist to handle integer arithmetic:

- [checked\_](https://doc.rust-lang.org/std/primitive.u32.html#method.checked_add): use this function if you want to handle overflow and underflow as a special edge-case. It returns `None` if an underflow or overflow has happened, and `Some(operation_result)` otherwise.
- [overflowing\_](https://doc.rust-lang.org/std/primitive.u32.html#method.overflowing_add): use this function if you want the result of an overflow to potentially wrap around (e.g. `u64::MAX.overflow_add(10) == (9, true)`). It returns the underflowed or overflowed result as well as a flag indicating if an overflow has occurred or not.
- [wrapping\_](https://doc.rust-lang.org/std/primitive.u32.html#method.wrapping_add): this is similar to overflowing operations, except that it returns the result directly. Use this function if you are sure that you want to handle underflow and overflow by wrapping around.
- [saturating\_](https://doc.rust-lang.org/std/primitive.u32.html#method.saturating_add): if an overflow occurs, the result is kept within the boundary of the type (e.g. `u64::MAX.saturating_add(1) == u64::MAX`).

```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L524-532)
```text
        let (items, bytes) = state_storage::current_items_and_bytes();
        let gas_config = borrow_global<StorageGasConfig>(@aptos_framework);
        let gas = borrow_global_mut<StorageGas>(@aptos_framework);
        gas.per_item_read = calculate_read_gas(&gas_config.item_config, items);
        gas.per_item_create = calculate_create_gas(&gas_config.item_config, items);
        gas.per_item_write = calculate_write_gas(&gas_config.item_config, items);
        gas.per_byte_read = calculate_read_gas(&gas_config.byte_config, bytes);
        gas.per_byte_create = calculate_create_gas(&gas_config.byte_config, bytes);
        gas.per_byte_write = calculate_write_gas(&gas_config.byte_config, bytes);
```

**File:** storage/aptosdb/src/state_store/state_merkle_batch_committer.rs (L150-155)
```rust
        ensure!(
            usage_from_ledger_db.items() == leaf_count_from_jmt,
            "State item count inconsistent, {} from ledger db and {} from state tree.",
            usage_from_ledger_db.items(),
            leaf_count_from_jmt,
        );
```

**File:** types/src/state_store/state_storage_usage.rs (L44-62)
```rust
    pub fn add_item(&mut self, bytes_delta: usize) {
        match self {
            Self::Tracked { items, bytes } => {
                *items += 1;
                *bytes += bytes_delta;
            },
            Self::Untracked => (),
        }
    }

    pub fn remove_item(&mut self, bytes_delta: usize) {
        match self {
            Self::Tracked { items, bytes } => {
                *items -= 1;
                *bytes -= bytes_delta;
            },
            Self::Untracked => (),
        }
    }
```
