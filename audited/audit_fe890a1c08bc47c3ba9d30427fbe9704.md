# Audit Report

## Title
Consensus Node Panic via Cross-Fork SyncInfo Attack When Order Votes Disabled

## Summary
A malicious validator can crash honest validators by sending a `SyncInfo` message containing a `highest_ordered_cert` from a minority blockchain fork. When `order_vote_enabled` is false, the honest validator attempts to execute blocks from a different fork than its current `ordered_root`, causing a panic in `send_for_execution` due to an empty path assertion failure.

## Finding Description
The vulnerability exists in how consensus nodes process `SyncInfo` messages containing certificates from different blockchain forks. The attack exploits a validation gap and unsafe path resolution:

**Step 1: Insufficient SyncInfo Validation** [1](#0-0) 

The `SyncInfo::verify()` method validates that all certificates have correct signatures and round ordering, but **does not verify that the certificates reference blocks on the same blockchain fork**. It only checks:
- All certificates are from the same epoch
- Round ordering: `HQC.round >= HOC.round >= HCC.round`  
- All have valid 2f+1 signatures
- Block info is non-empty

**Step 2: Cross-Fork Block Insertion** [2](#0-1) 

When `order_vote_enabled` is false, the code converts `highest_ordered_cert` to a `QuorumCert` and calls `insert_quorum_cert`, which fetches and inserts blocks from the peerâ€”even if those blocks are from a completely different fork than the honest validator's current chain.

**Step 3: Panic on Path Resolution** [3](#0-2) 

The `send_for_execution` function attempts to find a path from `ordered_root` to the commit block using `path_from_ordered_root`. When the commit block is from a different fork, this function returns `None`: [4](#0-3) 

The path traversal walks backwards from the target block via parent links. When it reaches a block at or below the root round, it checks if the current block ID matches the root ID. **If they don't match (different forks), it returns `None`**.

The `unwrap_or_default()` converts `None` to an empty `Vec`, and the subsequent `assert!(!blocks_to_commit.is_empty())` causes a **panic**, crashing the validator node.

## Impact Explanation
**Severity: CRITICAL**

This vulnerability enables a single malicious validator to crash any honest validator by sending a single crafted `SyncInfo` message, causing:

1. **Immediate validator crash** - The panic terminates the consensus process
2. **Consensus liveness failure** - If enough validators are crashed simultaneously, the network cannot make progress
3. **Repeated attacks** - The attacker can continuously crash validators as they restart
4. **No recovery mechanism** - Standard restart procedures won't prevent re-exploitation

This qualifies as **Critical Severity** under Aptos bug bounty rules as it causes:
- "Total loss of liveness/network availability" (if multiple validators targeted)
- "Consensus/Safety violations" (consensus process crashes)
- Requires no privileged access beyond being a network peer

The attack requires only:
- Access to a legitimate `WrappedLedgerInfo` from any minority fork (obtainable during normal consensus operations)
- Ability to send consensus messages (available to any validator)
- `order_vote_enabled` set to false on target validators

## Likelihood Explanation
**Likelihood: HIGH**

The attack is highly likely to succeed because:

1. **Low attack complexity** - Requires sending a single crafted network message
2. **No special privileges needed** - Any validator can send `SyncInfo` messages
3. **Minority fork certificates are common** - During network partitions or timing issues, validators create valid certificates on minority forks that don't become canonical
4. **Configuration dependency** - The vulnerability is active when `order_vote_enabled` is false, which may be common in certain deployment configurations
5. **No rate limiting** - Attacker can repeatedly crash validators
6. **Difficult to detect** - The panic appears as a node crash without clear indication of malicious input

The attack path is straightforward:
1. Malicious validator obtains a valid `WrappedLedgerInfo` from a minority fork (happens naturally during consensus)
2. Crafts a `SyncInfo` with this certificate as `highest_ordered_cert`
3. Sends it to target honest validators
4. Target validators verify signatures (pass), fetch blocks (succeed), attempt execution (panic)

## Recommendation
**Fix 1: Add fork consistency validation to SyncInfo.verify()**

Add validation that `highest_ordered_cert` and `highest_commit_cert` are ancestors of `highest_quorum_cert`:

```rust
pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
    // ... existing checks ...
    
    // NEW: Verify fork consistency
    // HOC must be an ancestor of HQC (or HQC itself)
    ensure!(
        self.highest_ordered_cert().commit_info().round() <= self.highest_quorum_cert.certified_block().round(),
        "HOC must not be at a higher round than HQC's certified block"
    );
    
    // HCC must be an ancestor of HOC
    ensure!(
        self.highest_commit_cert().commit_info().round() <= self.highest_ordered_cert().commit_info().round(),
        "HCC must not be at a higher round than HOC"
    );
    
    // ... rest of verification ...
}
```

**Fix 2: Replace assertion with error handling in send_for_execution** [5](#0-4) 

Replace the panic-inducing assertion with proper error handling:

```rust
let blocks_to_commit = self
    .path_from_ordered_root(block_id_to_commit)
    .ok_or_else(|| {
        format_err!(
            "Cannot find path from ordered_root (round {}) to commit block {} (round {}). Blocks may be on different forks.",
            self.ordered_root().round(),
            block_id_to_commit,
            block_to_commit.round()
        )
    })?;

ensure!(
    !blocks_to_commit.is_empty(),
    "Path from ordered_root to commit block is empty"
);
```

**Fix 3: Add fork validation before calling send_for_execution**

In `insert_quorum_cert`, verify the commit block is a descendant of `ordered_root` before attempting execution:

```rust
if self.ordered_root().round() < qc.commit_info().round() {
    // NEW: Check if path exists before attempting execution
    if self.path_from_ordered_root(qc.commit_info().id()).is_none() {
        bail!(
            "Cannot execute cert for block {} - not a descendant of ordered_root",
            qc.commit_info().id()
        );
    }
    SUCCESSFUL_EXECUTED_WITH_REGULAR_QC.inc();
    self.send_for_execution(qc.into_wrapped_ledger_info()).await?;
    // ...
}
```

## Proof of Concept

```rust
// Consensus module test demonstrating the vulnerability
#[tokio::test]
async fn test_cross_fork_syncinfo_panic() {
    // Setup: Create honest validator with ordered_root on fork A
    let mut test_env = TestEnvironment::new(4, order_vote_enabled: false);
    let honest_validator = test_env.get_validator(0);
    
    // Honest validator has ordered_root at block A (round 50, fork A)
    let block_a = test_env.create_block_on_fork_a(round: 50);
    honest_validator.commit_block(block_a);
    assert_eq!(honest_validator.ordered_root().round(), 50);
    
    // Malicious validator creates a valid certificate on fork B
    // This can happen legitimately during network partition
    let block_b = test_env.create_block_on_fork_b(round: 70);
    let qc_b = test_env.create_qc_with_2f_plus_1_sigs(block_b);
    let wrapped_li_b = WrappedLedgerInfo::from(qc_b);
    
    // Attacker crafts SyncInfo with certificate from different fork
    let malicious_sync_info = SyncInfo::new_decoupled(
        test_env.get_latest_qc_on_fork_a(), // HQC from main chain
        wrapped_li_b.clone(),                 // HOC from fork B!
        wrapped_li_b,                         // HCC from fork B
        None,
    );
    
    // Verify passes (signatures are valid, rounds are ordered)
    assert!(malicious_sync_info.verify(&test_env.validator_verifier).is_ok());
    
    // Honest validator processes the SyncInfo
    let result = honest_validator
        .round_manager
        .process_sync_info_msg(malicious_sync_info, malicious_peer_id)
        .await;
    
    // Expected: Honest validator panics in send_for_execution
    // due to empty path from ordered_root (fork A) to commit block (fork B)
    // Actual: Test will panic with "assertion failed: !blocks_to_commit.is_empty()"
}
```

The test demonstrates that when an honest validator with `ordered_root` on fork A receives a `SyncInfo` containing a valid certificate from fork B, the validator will panic when attempting to execute the cross-fork commit, causing a consensus crash.

**Notes**

The vulnerability is particularly dangerous because:
1. It bypasses all signature verifications (certificates are legitimately signed)
2. The panic occurs deep in the execution path, after blocks have been fetched and inserted
3. The error manifests as a node crash rather than a handled error, making debugging difficult
4. The configuration dependency (`order_vote_enabled = false`) may not be immediately obvious to operators

The recommended fixes address the root cause by ensuring fork consistency is validated before any blocks are processed, and replacing panic-inducing assertions with proper error handling to maintain consensus liveness even when receiving malicious inputs.

### Citations

**File:** consensus/consensus-types/src/sync_info.rs (L138-212)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let epoch = self.highest_quorum_cert.certified_block().epoch();
        ensure!(
            epoch == self.highest_ordered_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HQC"
        );
        ensure!(
            epoch == self.highest_commit_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HCC"
        );
        if let Some(tc) = &self.highest_2chain_timeout_cert {
            ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
        }

        ensure!(
            self.highest_quorum_cert.certified_block().round()
                >= self.highest_ordered_cert().commit_info().round(),
            "HQC has lower round than HOC"
        );

        ensure!(
            self.highest_ordered_round() >= self.highest_commit_round(),
            format!(
                "HOC {} has lower round than HLI {}",
                self.highest_ordered_cert(),
                self.highest_commit_cert()
            )
        );

        ensure!(
            *self.highest_ordered_cert().commit_info() != BlockInfo::empty(),
            "HOC has no committed block"
        );

        ensure!(
            *self.highest_commit_cert().commit_info() != BlockInfo::empty(),
            "HLI has empty commit info"
        );

        // we don't have execution in unit tests, so this check would fail
        #[cfg(not(any(test, feature = "fuzzing")))]
        {
            ensure!(
                !self.highest_commit_cert().commit_info().is_ordered_only(),
                "HLI {} has ordered only commit info",
                self.highest_commit_cert().commit_info()
            );
        }

        self.highest_quorum_cert
            .verify(validator)
            .and_then(|_| {
                self.highest_ordered_cert
                    .as_ref()
                    .map_or(Ok(()), |cert| cert.verify(validator))
                    .context("Fail to verify ordered certificate")
            })
            .and_then(|_| {
                // we do not verify genesis ledger info
                if self.highest_commit_cert.commit_info().round() > 0 {
                    self.highest_commit_cert
                        .verify(validator)
                        .context("Fail to verify commit certificate")?
                }
                Ok(())
            })
            .and_then(|_| {
                if let Some(tc) = &self.highest_2chain_timeout_cert {
                    tc.verify(validator)?;
                }
                Ok(())
            })
            .context("Fail to verify SyncInfo")?;
        Ok(())
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L150-167)
```rust
        if self.order_vote_enabled {
            self.insert_ordered_cert(&sync_info.highest_ordered_cert())
                .await?;
        } else {
            // When order votes are disabled, the highest_ordered_cert().certified_block().id() need not be
            // one of the ancestors of highest_quorum_cert.certified_block().id() due to forks. So, we call
            // insert_quorum_cert instead of insert_ordered_cert as in the above case. This will ensure that
            // highest_ordered_cert().certified_block().id() is inserted the block store.
            self.insert_quorum_cert(
                &self
                    .highest_ordered_cert()
                    .as_ref()
                    .clone()
                    .into_quorum_cert(self.order_vote_enabled)?,
                &mut retriever,
            )
            .await?;
        }
```

**File:** consensus/src/block_storage/block_store.rs (L312-331)
```rust
    pub async fn send_for_execution(
        &self,
        finality_proof: WrappedLedgerInfo,
    ) -> anyhow::Result<()> {
        let block_id_to_commit = finality_proof.commit_info().id();
        let block_to_commit = self
            .get_block(block_id_to_commit)
            .ok_or_else(|| format_err!("Committed block id not found"))?;

        // First make sure that this commit is new.
        ensure!(
            block_to_commit.round() > self.ordered_root().round(),
            "Committed block round lower than root"
        );

        let blocks_to_commit = self
            .path_from_ordered_root(block_id_to_commit)
            .unwrap_or_default();

        assert!(!blocks_to_commit.is_empty());
```

**File:** consensus/src/block_storage/block_tree.rs (L519-546)
```rust
    pub(super) fn path_from_root_to_block(
        &self,
        block_id: HashValue,
        root_id: HashValue,
        root_round: u64,
    ) -> Option<Vec<Arc<PipelinedBlock>>> {
        let mut res = vec![];
        let mut cur_block_id = block_id;
        loop {
            match self.get_block(&cur_block_id) {
                Some(ref block) if block.round() <= root_round => {
                    break;
                },
                Some(block) => {
                    cur_block_id = block.parent_id();
                    res.push(block);
                },
                None => return None,
            }
        }
        // At this point cur_block.round() <= self.root.round()
        if cur_block_id != root_id {
            return None;
        }
        // Called `.reverse()` to get the chronically increased order.
        res.reverse();
        Some(res)
    }
```
