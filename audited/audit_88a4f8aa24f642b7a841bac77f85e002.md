# Audit Report

## Title
NetworkAddress Layer Ordering Bypass via Memory Protocol in Production

## Summary
The `from_protocols()` validation function incorrectly accepts `Memory` protocol addresses in production builds due to a known bug at line 234, creating a critical validation inconsistency with `parse_aptosnet_protos()`. This allows validators to register invalid network addresses on-chain that violate the protocol's layer ordering invariant, potentially causing network connectivity issues. [1](#0-0) 

## Finding Description

The `is_network_layer()` helper function unconditionally includes `Memory(_)` as a valid network layer protocol in all builds, despite an explicit comment indicating this is incorrect. [2](#0-1) 

This creates a validation inconsistency between two critical functions:

1. **`from_protocols()` validation** (lines 263-310) - Used during deserialization and direct construction, accepts `Memory` addresses unconditionally and allows them to bypass TCP transport layer requirements. [3](#0-2) 

2. **`parse_aptosnet_protos()` validation** (lines 862-892) - Used by `is_aptosnet_addr()` for production address validation, correctly rejects `Memory` addresses in production builds using `cfg!(test)`. [4](#0-3) 

The attack path:
1. A validator operator calls `stake::update_network_and_fullnode_addresses()` with BCS-encoded bytes representing `[Memory(port), NoiseIK(pubkey), Handshake(version)]`
2. The Move framework stores this on-chain without validation [5](#0-4) 
3. Other validators read this via `ValidatorSet` and deserialize using `bcs::from_bytes()` → `TryFrom` → `from_protocols()`, which accepts the Memory address
4. The validator network address discovery system accepts this invalid address [6](#0-5) 
5. When attempting to dial, `parse_dial_addr()` accepts Memory addresses unconditionally [7](#0-6) 
6. However, production nodes use `TcpTransport` which cannot establish Memory connections, causing dial failures

## Impact Explanation

This constitutes a **Medium Severity** issue under the Aptos bug bounty criteria. While it does not directly cause consensus failure or fund loss, it creates:

1. **State inconsistencies requiring intervention**: Invalid validator addresses stored on-chain that are accepted during deserialization but fail during actual use
2. **Validator network degradation**: Affected validators become unreachable, reducing network robustness
3. **Protocol invariant violation**: The layer ordering invariant (production addresses must be IP/DNS+TCP based) can be bypassed

The impact is limited because:
- It requires validator operator access (not exploitable by fully unprivileged attackers)
- The "attack" primarily harms the validator setting the invalid address
- Consensus safety is maintained as long as < 1/3 of validators are affected
- The issue is contained to network connectivity rather than state or fund security

## Likelihood Explanation

**Likelihood: Medium**

This could occur through:
1. **Operator error**: Validator operators accidentally using test configurations in production
2. **Configuration management bugs**: Automated tools generating invalid addresses
3. **Compromised operator accounts**: Attackers with access to validator operator keys
4. **Malicious validators**: Though less incentivized as it harms their own participation

The validation inconsistency makes the issue more likely because there are no safeguards preventing invalid addresses from being stored on-chain.

## Recommendation

Fix the `is_network_layer()` function to correctly exclude `Memory` protocol in production builds:

```rust
fn is_network_layer(p: Option<&Protocol>) -> bool {
    use Protocol::*;

    matches!(
        p,
        Some(Ip4(_))
            | Some(Ip6(_))
            | Some(Dns(_))
            | Some(Dns4(_))
            | Some(Dns6(_))
    ) || (cfg!(test) && matches!(p, Some(Memory(_))))
}
```

Additionally, add validation in the Move framework to verify network addresses conform to production requirements before storage:
- Implement a native function that validates addresses using `is_aptosnet_addr()`
- Call this validation in `update_network_and_fullnode_addresses()` before updating state
- Reject addresses that don't meet production standards

## Proof of Concept

```rust
#[test]
fn test_memory_address_validation_inconsistency() {
    use aptos_types::network_address::{NetworkAddress, Protocol};
    use aptos_crypto::x25519;
    use std::str::FromStr;
    
    // Create a Memory-based address that violates production invariant
    let pubkey = x25519::PublicKey::from_encoded_string(
        "080e287879c918794170e258bfaddd75acac5b3e350419044655e4983a487120"
    ).unwrap();
    
    let memory_protocols = vec![
        Protocol::Memory(6180),
        Protocol::NoiseIK(pubkey),
        Protocol::Handshake(0),
    ];
    
    // from_protocols accepts Memory address (BUG)
    let addr = NetworkAddress::from_protocols(memory_protocols).unwrap();
    println!("Memory address accepted by from_protocols: {}", addr);
    
    // But is_aptosnet_addr rejects it in production (CORRECT)
    #[cfg(not(test))]
    assert!(!addr.is_aptosnet_addr(), 
        "Memory address should be rejected in production");
    
    // This inconsistency allows invalid addresses to be stored on-chain
    let serialized = bcs::to_bytes(&vec![addr]).unwrap();
    println!("Can be serialized and stored on-chain: {} bytes", serialized.len());
}
```

## Notes

While this represents a genuine bug with the explicit comment acknowledging it's incorrect, the practical exploitability is limited by requiring validator operator access. The primary risk is operational (network degradation) rather than catastrophic (consensus failure or fund theft). However, the validation inconsistency is a protocol violation that should be corrected to maintain system integrity and prevent potential future exploitation vectors.

### Citations

**File:** types/src/network_address/mod.rs (L223-236)
```rust
fn is_network_layer(p: Option<&Protocol>) -> bool {
    use Protocol::*;

    matches!(
        p,
        Some(Ip4(_))
            | Some(Ip6(_))
            | Some(Dns(_))
            | Some(Dns4(_))
            | Some(Dns6(_))
            /* cfg!(test) is the correct value rather than true, but this doesnt propagate properly from external tests */
            | Some(Memory(_))
    )
}
```

**File:** types/src/network_address/mod.rs (L263-310)
```rust
    pub fn from_protocols(protocols: Vec<Protocol>) -> Result<Self, ParseError> {
        use Protocol::*;

        let mut iter = protocols.iter();

        let mut p = iter.next();

        if p.is_none() {
            return Ok(Self(protocols));
        }

        if !is_network_layer(p) {
            return Err(ParseError::NetworkLayerMissing);
        }

        if !matches!(p, Some(Memory(_))) {
            p = iter.next();
            if p.is_none() {
                return Ok(Self(protocols));
            }
            if !is_transport_layer(p) {
                return Err(ParseError::TransportLayerMissing);
            }
        }

        p = iter.next();
        if p.is_none() {
            return Ok(Self(protocols));
        }
        if !is_session_layer(p, true) {
            return Err(ParseError::SessionLayerMissing);
        }

        p = iter.next();
        if p.is_none() {
            return Ok(Self(protocols));
        }
        if !is_handshake_layer(p, true) {
            return Err(ParseError::HandshakeLayerMissing);
        }

        p = iter.next();
        if p.is_none() {
            Ok(Self(protocols))
        } else {
            Err(ParseError::RedundantLayer)
        }
    }
```

**File:** types/src/network_address/mod.rs (L862-892)
```rust
fn parse_aptosnet_protos(protos: &[Protocol]) -> Option<&[Protocol]> {
    // parse base transport layer
    // ---
    // parse_ip_tcp
    // <or> parse_dns_tcp
    // <or> cfg!(test) parse_memory

    let transport_suffix = parse_ip_tcp(protos)
        .map(|x| x.1)
        .or_else(|| parse_dns_tcp(protos).map(|x| x.1))
        .or_else(|| {
            if cfg!(test) {
                parse_memory(protos).map(|x| x.1)
            } else {
                None
            }
        })?;

    // parse authentication layer
    // ---
    // parse_noise_ik

    let auth_suffix = parse_noise_ik(transport_suffix).map(|x| x.1)?;

    // parse handshake layer

    // also ensures there are no trailing protos after handshake
    parse_handshake(auth_suffix)?;

    Some(protos)
}
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-995)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** network/discovery/src/validator_set.rs (L108-150)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```

**File:** network/framework/src/transport/mod.rs (L471-513)
```rust
    fn parse_dial_addr(
        addr: &NetworkAddress,
    ) -> io::Result<(NetworkAddress, x25519::PublicKey, u8)> {
        use aptos_types::network_address::Protocol::*;

        let protos = addr.as_slice();

        // parse out the base transport protocol(s), which we will just ignore
        // and leave for the base_transport to actually parse and dial.
        // TODO(philiphayes): protos[..X] is kinda hacky. `Transport` trait
        // should handle this.
        let (base_transport_protos, base_transport_suffix) = parse_ip_tcp(protos)
            .map(|x| (&protos[..2], x.1))
            .or_else(|| parse_dns_tcp(protos).map(|x| (&protos[..2], x.1)))
            .or_else(|| parse_memory(protos).map(|x| (&protos[..1], x.1)))
            .ok_or_else(|| {
                io::Error::new(
                    io::ErrorKind::InvalidInput,
                    format!(
                        "Unexpected dialing network address: '{}', expected: \
                         memory, ip+tcp, or dns+tcp",
                        addr
                    ),
                )
            })?;

        // parse out the aptosnet protocols (noise ik and handshake)
        match base_transport_suffix {
            [NoiseIK(pubkey), Handshake(version)] => {
                let base_addr = NetworkAddress::try_from(base_transport_protos.to_vec())
                    .expect("base_transport_protos is always non-empty");
                Ok((base_addr, *pubkey, *version))
            },
            _ => Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!(
                    "Unexpected dialing network address: '{}', expected: \
                     '/../noise-ik/<pubkey>/handshake/<version>'",
                    addr
                ),
            )),
        }
    }
```
