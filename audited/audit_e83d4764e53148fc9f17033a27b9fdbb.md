# Audit Report

## Title
Incomplete Side Effect Detection in Move Pureness Checker Allows State-Modifying Operations in Specifications

## Summary
The Move pureness checker in `pureness_checker.rs` fails to detect several critical side-effect operations (`move_to`, `move_from`, event emission), allowing them to be incorrectly classified as pure and potentially called from specification expressions, which violates the fundamental invariant that specifications must be side-effect free.

## Finding Description

The pureness checker's `check_exp()` function is responsible for ensuring that expressions used in Move specifications are pure (free of side effects). The checker currently detects: [1](#0-0) 

However, the checker has critical gaps in side effect coverage:

**1. Missing `move_to` operation detection**: The `Operation::MoveTo` operation publishes resources to global storage, which is a clear side effect, but is not checked: [2](#0-1) 

**2. Missing `move_from` operation detection**: The `Operation::MoveFrom` operation removes resources from global storage: [3](#0-2) 

**3. Incorrect native function classification**: The checker considers native functions pure if they don't take or return mutable references: [4](#0-3) 

However, event-emitting natives like `write_module_event_to_store` don't take mutable references but have side effects: [5](#0-4) 

The native implementation clearly writes to the event store: [6](#0-5) 

The pureness checker is used by the specification checker to validate purity: [7](#0-6) 

## Impact Explanation

This issue has **High** severity impact, though the exploitation path is indirect:

1. **Verification Unsoundness**: The Move Prover relies on the pureness checker to determine which functions can be called from specifications. If side-effecting functions are incorrectly classified as pure, the prover may generate unsound proofs that fail to account for state modifications.

2. **Specification Violation**: Specifications are meant to be pure mathematical descriptions of program behavior. Allowing side effects in specifications violates this fundamental design principle and could lead to confusing or incorrect verification results.

3. **Developer Trust Breach**: Developers relying on formal verification for security-critical contracts could deploy vulnerable code if the prover gives false assurances based on incorrectly-classified pure functions.

While this doesn't directly cause runtime consensus violations or fund loss (since specifications don't execute at runtime), it undermines the formal verification guarantees that are critical for Move's security model.

## Likelihood Explanation

**Likelihood: Medium**

- The bug is always present in the current implementation
- Any Move developer could inadvertently or intentionally call `move_to`, `move_from`, or event-emitting functions from specifications
- The impact manifests when developers rely on Move Prover verification for security guarantees
- The indirect nature (affecting verification rather than runtime) reduces immediate exploitability

## Recommendation

Add explicit checks for all side-effecting operations in `check_exp()`:

```rust
// Add after line 121 in pureness_checker.rs
Call(id, MoveTo, ..) => {
    (self.impure_action)(
        *id,
        "publishes resource to global storage",
        &self.visiting,
    );
    self.is_impure = true;
},
Call(id, MoveFrom, ..) => {
    (self.impure_action)(
        *id,
        "removes resource from global storage",
        &self.visiting,
    );
    self.is_impure = true;
},
Call(id, Abort(_), ..) => {
    (self.impure_action)(
        *id,
        "aborts execution",
        &self.visiting,
    );
    self.is_impure = true;
},
```

For native functions, maintain a whitelist of known pure natives or a blacklist of known impure natives (event emission, I/O operations) rather than relying solely on reference analysis.

## Proof of Concept

```move
module 0x42::vulnerable_spec {
    use std::signer;
    use aptos_framework::event;

    struct MyResource has key {
        value: u64
    }

    struct MyEvent has drop, store {
        msg: u64
    }

    // This function has side effects but would be incorrectly classified as pure
    public fun impure_function(account: &signer, val: u64) {
        move_to(account, MyResource { value: val });
        event::emit(MyEvent { msg: val });
    }

    spec impure_function {
        // This should fail but currently passes due to the bug
        // Calling a side-effecting function from a spec expression
        ensures exists<MyResource>(signer::address_of(account));
    }

    // This function incorrectly calls impure_function in its spec
    public fun caller(account: &signer) {
        // Some operation
    }

    spec caller {
        // This should be rejected but isn't due to incomplete side effect detection
        // In theory, if specs could execute, this would modify state
        requires impure_function(account, 42) == (); // Would modify global state!
    }
}
```

Compile this module with the Move Prover enabled. The pureness checker should reject the specification in `caller` because `impure_function` modifies global state via `move_to` and emits events, but it doesn't due to the incomplete side effect detection.

## Notes

This vulnerability is significant for the Move ecosystem's formal verification guarantees. While it doesn't directly cause runtime exploits, it undermines the soundness of the Move Prover, which is a critical security tool for Aptos smart contract developers. The fix should be prioritized to maintain the integrity of formal verification results.

### Citations

**File:** third_party/move/move-model/src/pureness_checker.rs (L79-149)
```rust
    pub fn check_exp(&mut self, env: &GlobalEnv, exp: &Exp) -> bool {
        // Reset before start of traversal
        self.is_impure = false;
        exp.visit_post_order(&mut |e| {
            use ExpData::*;
            use Operation::*;
            match e {
                Assign(id, ..) if self.mode == FunctionPurenessCheckerMode::Specification => {
                    (self.impure_action)(*id, "assigns variable", &self.visiting);
                    self.is_impure = true
                },
                Mutate(id, ..) => {
                    (self.impure_action)(*id, "mutates reference", &self.visiting);
                    self.is_impure = true;
                },
                Return(id, ..) if self.mode == FunctionPurenessCheckerMode::Specification => {
                    (self.impure_action)(
                        *id,
                        "return not allowed in specifications",
                        &self.visiting,
                    );
                },
                Block(id, _, None, _)
                    if self.mode == FunctionPurenessCheckerMode::Specification =>
                {
                    (self.impure_action)(
                        *id,
                        "uninitialized let not allowed in specifications",
                        &self.visiting,
                    );
                },
                Call(id, Borrow(ReferenceKind::Mutable), ..) => {
                    (self.impure_action)(*id, "mutably borrows value", &self.visiting);
                    self.is_impure = true;
                },
                Call(id, BorrowGlobal(ReferenceKind::Mutable), ..) => {
                    (self.impure_action)(
                        *id,
                        "mutably borrows from global storage",
                        &self.visiting,
                    );
                    self.is_impure = true;
                },
                Call(id, MoveFunction(mid, sid), ..) => {
                    let qid = mid.qualified(*sid);
                    // false positive: can't use entry because of borrow conflict
                    #[allow(clippy::map_entry)]
                    if !self.pureness.contains_key(&qid) {
                        self.visiting.push((qid, *id));
                        let old_impure = mem::take(&mut self.is_impure);
                        self.check_function(env, qid);
                        self.pureness.insert(qid, !self.is_impure);
                        self.visiting.pop();
                        self.is_impure |= old_impure;
                    }
                    if !self.pureness.get(&qid).unwrap() {
                        (self.impure_action)(
                            *id,
                            "calls a function which modifies state",
                            &self.visiting,
                        );
                        self.is_impure = true
                    }
                },
                _ => {},
            }
            // Stop traversal if we have shown the expression is impure
            !self.is_impure
        });
        !self.is_impure
    }
```

**File:** third_party/move/move-model/src/pureness_checker.rs (L168-177)
```rust
            self.is_impure = fun
                .get_parameters()
                .iter()
                .any(|Parameter(_, ty, _)| ty.is_mutable_reference())
                || fun
                    .get_result_type()
                    .flatten()
                    .iter()
                    .any(|ty| ty.is_mutable_reference());
        }
```

**File:** third_party/move/move-model/src/builder/builtins.rs (L907-928)
```rust
        trans.define_spec_or_builtin_fun(
            trans.builtin_qualified_symbol("move_to"),
            SpecOrBuiltinFunEntry {
                loc: loc.clone(),
                oper: Operation::MoveTo,
                type_params: vec![param_t_with_key_decl.clone()],
                type_param_constraints: BTreeMap::new(),
                params: vec![
                    mk_param(
                        trans,
                        1,
                        Type::Reference(
                            ReferenceKind::Immutable,
                            Box::new(Type::new_prim(PrimitiveType::Signer)),
                        ),
                    ),
                    mk_param(trans, 2, param_t.clone()),
                ],
                result_type: Type::unit(),
                visibility: Impl,
            },
        );
```

**File:** third_party/move/move-model/src/builder/builtins.rs (L929-940)
```rust
        trans.define_spec_or_builtin_fun(
            trans.builtin_qualified_symbol("move_from"),
            SpecOrBuiltinFunEntry {
                loc: loc.clone(),
                oper: Operation::MoveFrom,
                type_params: vec![param_t_with_key_decl.clone()],
                type_param_constraints: BTreeMap::new(),
                params: vec![mk_param(trans, 1, address_t.clone())],
                result_type: param_t.clone(),
                visibility: Impl,
            },
        );
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L21-22)
```text
    /// Log `msg` with the event stream identified by `T`
    native fun write_module_event_to_store<T: drop + store>(msg: T);
```

**File:** aptos-move/framework/src/natives/event.rs (L140-149)
```rust
    let ctx = context.extensions_mut().get_mut::<NativeEventContext>();
    let event =
        ContractEvent::new_v1(key, seq_num, ty_tag, blob).map_err(|_| SafeNativeError::Abort {
            abort_code: ECANNOT_CREATE_EVENT,
        })?;
    // TODO(layouts): avoid cloning layouts for events with delayed fields.
    ctx.events.push((
        event,
        contains_delayed_fields.then(|| layout.as_ref().clone()),
    ));
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs (L50-56)
```rust
fn check_exp(env: &GlobalEnv, exp: &Exp) {
    let mut error_reported = false;
    let mut checker = FunctionPurenessChecker::new(
        FunctionPurenessCheckerMode::Specification,
        |node_id, msg, call_chain| report_error(env, &mut error_reported, node_id, msg, call_chain),
    );
    checker.check_exp(env, exp);
```
