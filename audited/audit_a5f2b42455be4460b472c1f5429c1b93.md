# Audit Report

## Title
Resource Group Write Operation Count Bypass Allows Exceeding Transaction Write Limits

## Summary
The `num_write_ops()` function counts resource group writes as single operations regardless of the number of individual resource updates (`inner_ops`) they contain. This allows attackers to bypass the `max_write_ops_per_transaction` limit (8192) by batching multiple resource writes within resource groups, potentially performing 10x-100x more write operations than intended.

## Finding Description

The vulnerability exists in how write operations are counted when validating change sets against the transaction limit.

**The Vulnerable Check:**
In `check_change_set()`, the validation compares `num_write_ops()` against `max_write_ops_per_transaction`: [1](#0-0) 

**The Undercount:**
The `VMChangeSet::num_write_ops()` implementation only counts the number of entries in the BTreeMap, not the actual number of write operations: [2](#0-1) 

**The Root Cause:**
Resource groups contain multiple individual resource writes in their `inner_ops` field, but are stored as single BTreeMap entries: [3](#0-2) 

**How Grouping Occurs:**
When converting resource group changes, all resources within a group are bundled into a single `GroupWrite` that gets inserted as one entry: [4](#0-3) 

**The Consolidation:**
These resource group writes are then combined into the main resource write set as single entries: [5](#0-4) 

**Attack Scenario:**
1. Attacker deploys a Move module defining 100 `#[resource_group_member]` types within a single resource group
2. Attacker creates transactions that modify all 100 resources across 100 different accounts
3. This creates 100 resource groups × 100 `inner_ops` each = **10,000 actual write operations**
4. However, `num_write_ops()` counts only **100 operations** (one per resource group)
5. The transaction passes the 8192 limit check but validators must process 10,000 writes
6. Repeated attacks cause validator slowdowns and unfair resource consumption

## Impact Explanation

**High Severity** - This qualifies as "Validator node slowdowns" under the Aptos Bug Bounty program.

**Direct Impacts:**
- **Resource Exhaustion:** Validators process significantly more write operations than the limit intended to prevent, consuming excessive CPU, memory, and I/O
- **Network Performance Degradation:** Blocks containing such transactions take longer to execute and validate, affecting overall network throughput
- **Unfair Resource Usage:** Attackers consume more computational resources than they pay for in gas fees
- **State Growth Acceleration:** More writes can be committed per transaction, accelerating state bloat beyond designed parameters

**Why Not Critical:**
- Does not directly cause loss of funds or consensus safety violations
- Does not require a hardfork to resolve
- Network remains operational, though degraded

**Why High:**
- Directly causes validator node slowdowns when processing transactions
- Can be repeatedly exploited to sustain performance degradation
- Bypasses a critical resource limit designed to prevent DoS
- Affects all validators processing these transactions

## Likelihood Explanation

**High Likelihood:**

**Attacker Requirements:**
- Deploy a Move module with many resource group member types (straightforward, no special privileges needed)
- Submit transactions that modify these resources (normal transaction submission)
- No validator collusion or privileged access required

**Complexity:**
- Low technical barrier: resource groups are a documented Move feature
- Attack vector is straightforward once the counting discrepancy is understood
- Can be automated and repeated

**Detection Difficulty:**
- Transactions appear legitimate and pass all validation checks
- No immediate error or alarm triggered
- Performance degradation may be attributed to normal network load

**Feasibility:**
- Move compiler allows arbitrary numbers of resource group members
- No runtime restrictions prevent creating modules with many group members
- Gas costs are based on byte sizes, not operation counts, making the attack economically viable

## Recommendation

Modify `num_write_ops()` to count all individual write operations, including those within resource groups: [2](#0-1) 

**Recommended Fix:**
```rust
fn num_write_ops(&self) -> usize {
    let resource_ops = self.resource_write_set()
        .iter()
        .map(|(_, op)| {
            match op {
                AbstractResourceWriteOp::WriteResourceGroup(group_write) => {
                    // Count metadata op + all inner ops
                    1 + group_write.inner_ops().len()
                },
                _ => 1,
            }
        })
        .sum::<usize>();
    
    resource_ops + self.aggregator_v1_write_set().len()
}
```

**Alternative Approach:**
Add a separate limit specifically for resource group inner operations to prevent abuse while maintaining backward compatibility.

## Proof of Concept

```move
// exploit_module.move
module attacker::exploit {
    use std::signer;

    #[resource_group(scope = global)]
    struct ExploitGroup {}

    // Define 100 resource group members (showing 5 for brevity)
    #[resource_group_member(group = attacker::exploit::ExploitGroup)]
    struct Resource1 has key { value: u64 }
    
    #[resource_group_member(group = attacker::exploit::ExploitGroup)]
    struct Resource2 has key { value: u64 }
    
    #[resource_group_member(group = attacker::exploit::ExploitGroup)]
    struct Resource3 has key { value: u64 }
    
    // ... define Resource4 through Resource100 ...

    // Single transaction that modifies all resources
    public entry fun exploit_write_limit(account: &signer) acquires 
        Resource1, Resource2, Resource3 /* ... Resource100 */ 
    {
        let addr = signer::address_of(account);
        
        // Modify or create all 100 resources in one transaction
        if (exists<Resource1>(addr)) {
            borrow_global_mut<Resource1>(addr).value = 1;
        } else {
            move_to(account, Resource1 { value: 1 });
        };
        
        if (exists<Resource2>(addr)) {
            borrow_global_mut<Resource2>(addr).value = 2;
        } else {
            move_to(account, Resource2 { value: 2 });
        };
        
        // ... repeat for Resource3 through Resource100 ...
        
        // This transaction performs 100 write operations
        // but num_write_ops() counts it as only 1
    }
}
```

**Verification Steps:**
1. Deploy the module with 100 resource group members
2. Call `exploit_write_limit` from 100 different accounts
3. The transaction creates 100 × 100 = 10,000 write operations
4. Observe that `num_write_ops()` returns 100 (passes 8192 limit)
5. Measure validator CPU/memory usage during transaction processing
6. Compare with equivalent transaction doing 100 non-grouped writes (would be rejected)

## Notes

The vulnerability fundamentally stems from a semantic mismatch: resource groups optimize storage and conflict detection by treating grouped resources as a unit, but the write operation limit was designed to constrain computational work, which scales with the number of individual resource operations, not the number of groups.

The current gas charging mechanism may partially mitigate exploitation by charging for total byte sizes, but this does not prevent the write operation count bypass or the associated computational overhead on validators.

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L95-99)
```rust
        if self.max_write_ops_per_transaction != 0
            && change_set.num_write_ops() as u64 > self.max_write_ops_per_transaction
        {
            return storage_write_limit_reached(Some("Too many write ops."));
        }
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L158-162)
```rust
                .chain(
                    resource_group_write_set
                        .into_iter()
                        .map(|(k, w)| Ok((k, AbstractResourceWriteOp::WriteResourceGroup(w)))),
                )
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L856-860)
```rust
    fn num_write_ops(&self) -> usize {
        // Note: we only use resources and aggregators because they use write ops directly,
        // and deltas & events are not part of these.
        self.resource_write_set().len() + self.aggregator_v1_write_set().len()
    }
```

**File:** aptos-move/aptos-vm-types/src/abstract_write_op.rs (L148-172)
```rust
/// Describes an update to a resource group granularly, with WriteOps to affected
/// member resources of the group, as well as a separate WriteOp for metadata and size.
#[derive(PartialEq, Eq, Clone, Debug)]
pub struct GroupWrite {
    /// Op of the correct kind (creation / modification / deletion) and metadata, and
    /// the size of the group after the updates encoded in the bytes (no bytes for
    /// deletion). Relevant during block execution, where the information read to
    /// derive metadata_op will be validated during parallel execution to make sure
    /// it is correct, and the bytes will be replaced after the transaction is committed
    /// with correct serialized group update to obtain storage WriteOp.
    pub metadata_op: WriteOp,
    /// Updates to individual group members. WriteOps are 'legacy', i.e. no metadata.
    /// If the metadata_op is a deletion, all (correct) inner_ops should be deletions,
    /// and if metadata_op is a creation, then there may not be a creation inner op.
    /// Not vice versa, e.g. for deleted inner ops, other untouched resources may still
    /// exist in the group. Note: During parallel block execution, due to speculative
    /// reads, this invariant may be violated (and lead to speculation error if observed)
    /// but guaranteed to fail validation and lead to correct re-execution in that case.
    pub(crate) inner_ops: BTreeMap<StructTag, (WriteOp, Option<TriompheArc<MoveTypeLayout>>)>,
    /// Group size as used for gas charging, None if (metadata_)op is Deletion.
    pub(crate) maybe_group_op_size: Option<ResourceGroupSize>,
    // TODO: consider Option<u64> to be able to represent a previously non-existent group,
    //       if useful
    pub(crate) prev_group_size: u64,
}
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L471-476)
```rust
            ResourceGroupChangeSet::V1(v1_changes) => {
                for (state_key, resources) in v1_changes {
                    let group_write = woc.convert_resource_group_v1(&state_key, resources)?;
                    resource_group_write_set.insert(state_key, group_write);
                }
            },
```
