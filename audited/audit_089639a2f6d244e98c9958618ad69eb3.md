# Audit Report

## Title
Event Attribute Removal Bypass in Version 5 Module Upgrades Due to Metadata Clearing

## Summary
A module upgrade validation bypass exists that allows removal of event attributes from version 5 bytecode modules, violating the documented upgrade compatibility invariant. When upgrading a version 5 module that has V1 metadata with event attributes, the validation logic clears these attributes before comparison, allowing an attacker to remove event markers that should be immutable.

## Finding Description

The vulnerability exists in the interaction between two functions:

1. `get_metadata_from_compiled_code()` in `types/src/vm/module_metadata.rs` [1](#0-0) 

2. `validate_module_events()` in `aptos-move/aptos-vm/src/verifier/event_validation.rs` [2](#0-1) 

**The documented invariant** states that module upgrades must be compatible, specifically: "Verify all changes are compatible upgrades (existing event attributes cannot be removed)" [3](#0-2) 

**The bypass mechanism:**

When validating module upgrades, the code retrieves the old module's metadata to ensure event attributes are not removed [4](#0-3) 

However, for version 5 bytecode, `get_metadata_from_compiled_code()` explicitly clears `struct_attributes` and `fun_attributes` before returning the metadata [5](#0-4) 

The comment acknowledges this is a workaround: "Clear out metadata for v5, since it shouldn't have existed in the first place and isn't being used. Note, this should have been gated in the verify module metadata." [6](#0-5) 

**Attack Path:**

1. A version 5 module exists with V1 metadata containing event attributes (historical modules that slipped through validation)
2. Attacker submits an upgrade removing the `#[event]` attribute from structs
3. During validation, `validate_module_events()` retrieves the old module
4. `get_metadata_from_compiled_code()` clears the `struct_attributes` from the old module's metadata
5. `extract_event_metadata()` returns an empty set for the original module [7](#0-6) 
6. The loop checking for attribute removal doesn't iterate (empty set), bypassing the validation [8](#0-7) 
7. The upgrade succeeds, removing event attributes that should be immutable

## Impact Explanation

**Severity: MEDIUM** (per Aptos Bug Bounty criteria: "State inconsistencies requiring intervention")

This vulnerability breaks the upgrade compatibility guarantee for event attributes, which has several impacts:

1. **Invariant Violation**: Explicitly violates the documented requirement that event attributes cannot be removed during upgrades
2. **API Inconsistency**: The `struct_is_event()` API function would return different values pre- and post-upgrade for the same struct [9](#0-8) 
3. **Indexer Breakage**: Off-chain indexers expecting specific event types would fail to process events correctly
4. **State Inconsistency**: Event metadata becomes inconsistent with the module's actual behavior

While this does not directly cause loss of funds or consensus violations, it creates state inconsistencies requiring manual intervention and breaks documented upgrade guarantees.

## Likelihood Explanation

**Likelihood: MEDIUM** (conditional on existence of affected modules)

The exploit requires:
- Version 5 modules with V1 metadata containing event attributes must exist on-chain
- The attacker must own/control such a module
- MODULE_EVENT feature must be enabled (it is by default) [10](#0-9) 

The defensive clearing logic and explicit comment in the codebase strongly suggest that version 5 modules with V1 metadata did exist historically. Version 5 remains the minimum supported bytecode version [11](#0-10) 

The exploit itself is straightforward once the preconditions are met - simply submit a module upgrade removing event attributes.

## Recommendation

Add version validation to prevent the bypass. Before clearing attributes, check if the old module is being compared for upgrade validation and preserve the original attributes for that purpose:

```rust
// In get_metadata_from_compiled_code()
pub fn get_metadata_from_compiled_code_for_validation(
    code: &impl CompiledCodeMetadata,
    preserve_v5_attributes: bool,
) -> Option<RuntimeModuleMetadataV1> {
    if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY_V1) {
        let mut metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value).ok();
        // Only clear v5 metadata when NOT being used for upgrade validation
        if code.version() == 5 && !preserve_v5_attributes {
            if let Some(metadata) = metadata.as_mut() {
                metadata.struct_attributes.clear();
                metadata.fun_attributes.clear();
            }
        }
        metadata
    } else if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY) {
        let data_v0 = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value).ok()?;
        Some(data_v0.upgrade())
    } else {
        None
    }
}
```

Alternatively, add explicit version checking in `validate_module_events()` to reject upgrades from version 5 modules with V1 metadata, or gate V1 metadata validation during module publishing based on bytecode version [12](#0-11) 

## Proof of Concept

```rust
// Rust test demonstrating the bypass
#[test]
fn test_event_attribute_removal_bypass_v5() {
    use move_binary_format::file_format::*;
    use aptos_types::vm::module_metadata::*;
    
    // Create a version 5 module with V1 metadata containing event attributes
    let mut module = CompiledModule::default();
    module.version = 5; // VERSION_5
    
    // Add V1 metadata with event attribute on "MyStruct"
    let mut metadata = RuntimeModuleMetadataV1::default();
    metadata.struct_attributes.insert(
        "MyStruct".to_string(),
        vec![KnownAttribute::event()],
    );
    
    let serialized = bcs::to_bytes(&metadata).unwrap();
    module.metadata.push(Metadata {
        key: APTOS_METADATA_KEY_V1.to_vec(),
        value: serialized,
    });
    
    // When retrieving metadata for upgrade validation
    let retrieved_metadata = get_metadata_from_compiled_code(&module);
    
    // The struct_attributes are cleared due to version 5
    assert!(retrieved_metadata.is_some());
    let metadata = retrieved_metadata.unwrap();
    assert!(metadata.struct_attributes.is_empty()); // Attributes cleared!
    
    // This means extract_event_metadata returns empty set
    let event_structs = extract_event_metadata(&metadata).unwrap();
    assert!(event_structs.is_empty());
    
    // Therefore, upgrade validation doesn't detect removal of event attributes
    // Exploit: Attacker can upgrade to version 6+ without the event attribute
    // and validation passes because original_event_structs is empty
}
```

## Notes

The vulnerability is contingent on version 5 modules with V1 metadata existing in the blockchain state. The defensive clearing logic and code comments provide strong evidence these modules exist, but without access to on-chain state, this cannot be definitively confirmed. The minimum bytecode version remains 5, and the clearing logic would be unnecessary if such modules had never existed.

### Citations

**File:** types/src/vm/module_metadata.rs (L40-40)
```rust
pub const METADATA_V1_MIN_FILE_FORMAT_VERSION: u32 = 6;
```

**File:** types/src/vm/module_metadata.rs (L287-308)
```rust
pub fn get_metadata_from_compiled_code(
    code: &impl CompiledCodeMetadata,
) -> Option<RuntimeModuleMetadataV1> {
    if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY_V1) {
        let mut metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value).ok();
        // Clear out metadata for v5, since it shouldn't have existed in the first place and isn't
        // being used. Note, this should have been gated in the verify module metadata.
        if code.version() == 5 {
            if let Some(metadata) = metadata.as_mut() {
                metadata.struct_attributes.clear();
                metadata.fun_attributes.clear();
            }
        }
        metadata
    } else if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY) {
        // Old format available, upgrade to new one on the fly
        let data_v0 = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value).ok()?;
        Some(data_v0.upgrade())
    } else {
        None
    }
}
```

**File:** aptos-move/aptos-vm/src/verifier/event_validation.rs (L35-37)
```rust
/// Validate event metadata on modules one by one:
/// * Extract the event metadata
/// * Verify all changes are compatible upgrades (existing event attributes cannot be removed)
```

**File:** aptos-move/aptos-vm/src/verifier/event_validation.rs (L38-80)
```rust
pub(crate) fn validate_module_events(
    features: &Features,
    module_storage: &impl ModuleStorage,
    traversal_context: &TraversalContext,
    new_modules: &[CompiledModule],
) -> VMResult<()> {
    for new_module in new_modules {
        let mut new_event_structs = get_metadata_from_compiled_code(new_module).map_or_else(
            || Ok(HashSet::new()),
            |metadata| extract_event_metadata(&metadata),
        )?;

        // Check all the emit calls have the correct struct with event attribute.
        validate_emit_calls(&new_event_structs, new_module)?;

        // INVARIANT:
        //   No need to charge gas for module access: this function fetches the old version of the
        //   module which has been already charged when publish request was processed first (if
        //   such old version exists).
        if features.is_lazy_loading_enabled() {
            traversal_context
                .check_is_special_or_visited(new_module.address(), new_module.name())
                .map_err(|err| err.finish(Location::Undefined))?;
        }

        let old_module_metadata_if_exists = module_storage
            .unmetered_get_deserialized_module(new_module.address(), new_module.name())?
            .and_then(|module| {
                // TODO(loader_v2): We can optimize this to fetch metadata directly.
                get_metadata_from_compiled_code(module.as_ref())
            });
        if let Some(metadata) = old_module_metadata_if_exists {
            let original_event_structs = extract_event_metadata(&metadata)?;
            for member in original_event_structs {
                // Fail if we see a removal of an event attribute.
                if !new_event_structs.remove(&member) {
                    metadata_validation_err("Invalid change in event attributes")?;
                }
            }
        }
    }
    Ok(())
}
```

**File:** api/types/src/bytecode.rs (L50-58)
```rust
    fn struct_is_event(&self, name: &IdentStr) -> bool {
        match self.metadata() {
            Some(m) => match m.struct_attributes.get(name.as_str()) {
                Some(attrs) => attrs.iter().any(|attr| attr.is_event()),
                None => false,
            },
            None => false,
        }
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L200-200)
```rust
            FeatureFlag::MODULE_EVENT,
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L562-562)
```rust
pub const VERSION_MIN: u32 = VERSION_5;
```
