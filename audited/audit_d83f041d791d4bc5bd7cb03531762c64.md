# Audit Report

## Title
VaultRunner Missing Drop Implementation Leaves Orphaned Vault Processes with Root Access Running Indefinitely

## Summary
The `VaultRunner` struct in `secure/storage/vault/src/dev.rs` does not implement the `Drop` trait to properly terminate its spawned Vault child process. This allows Vault dev servers with hardcoded root credentials to remain running indefinitely after test completion or panic, exposing cryptographic keys to unauthorized local access.

## Finding Description

The `VaultRunner` struct spawns a HashiCorp Vault dev server process with a hardcoded `ROOT_TOKEN` for testing purposes. [1](#0-0) 

The struct stores the child process in the `_child` field of type `std::process::Child`, but critically, **does not implement the `Drop` trait** to ensure proper cleanup. When `VaultRunner` is dropped (during program exit, test completion, or panic), Rust's default `Child::drop()` behavior does **not** kill the child process—it only closes stdin/stdout/stderr handles and detaches from the process.

This contrasts with the correct implementation pattern used elsewhere in the codebase. The `Process` struct in the test infrastructure properly implements `Drop` to kill child processes: [2](#0-1) 

The `APTOS_VAULT` static creates a global `VaultRunner` instance: [3](#0-2) 

When tests use this infrastructure to store cryptographic keys for validators and consensus (as seen in the comprehensive test suite), these keys remain accessible in the orphaned Vault process after test completion. [4](#0-3) 

The Vault secure storage implementation is explicitly documented as "the one primarily used in production environments by nodes in the blockchain" for storing sensitive data including "cryptographic keys and consensus safety rules." [5](#0-4) 

**Attack Scenario:**
1. Test suite runs and initializes `APTOS_VAULT` static, spawning Vault dev server on random port with `ROOT_TOKEN="root_token"`
2. Tests store validator cryptographic keys, consensus safety keys, or other sensitive material
3. Test completes normally or panics during execution
4. `VaultRunner` is dropped but child Vault process continues running
5. Attacker with local machine access scans for listening Vault processes
6. Attacker connects using the well-known hardcoded `ROOT_TOKEN`
7. Attacker extracts all cryptographic keys stored in the orphaned Vault process memory

This breaks the **Cryptographic Correctness** invariant (#10) requiring secure handling of cryptographic keys and the **Access Control** invariant (#8) for protecting sensitive system data.

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos Bug Bounty criteria for the following reasons:

1. **Cryptographic Key Exposure**: The orphaned Vault process contains validator identity keys, consensus safety keys, and other cryptographic material used in testing that may mirror production key types.

2. **Persistent Attack Surface**: The Vault process runs indefinitely with root-level access to all stored secrets until manually terminated. In CI/CD environments or shared development machines, this creates a persistent attack window.

3. **Known Credential**: The hardcoded `ROOT_TOKEN="root_token"` makes exploitation trivial for any attacker with local access.

4. **Production-Grade Storage System**: While this occurs in the "dev.rs" file, Vault is the primary production storage backend. Test keys often have similar security properties to production keys.

While not Critical severity (which requires remote exploitation or direct fund loss), this represents a significant protocol violation enabling potential validator compromise in test/CI environments.

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability occurs automatically in several common scenarios:
- Any test using `VaultRunner` that completes normally
- Any test panic after `VaultRunner` initialization
- Normal program termination after initializing `APTOS_VAULT` static
- CI/CD pipeline executions that run the test suite

The conditions for exploitation are:
- Attacker has local machine access (common in shared CI/CD, development environments)
- Test suite has run at least once (standard development workflow)
- Attacker can scan localhost ports and connect with known credentials (trivial)

No special privileges, timing windows, or race conditions are required. The vulnerability is deterministic and occurs every time `VaultRunner` is dropped without proper cleanup.

## Recommendation

Implement the `Drop` trait for `VaultRunner` to explicitly kill the child Vault process before the struct is destroyed:

```rust
impl Drop for VaultRunner {
    fn drop(&mut self) {
        // Check if the process has already terminated
        match self._child.try_wait() {
            // Process already exited
            Ok(Some(_)) => {},
            // Process still running - kill it
            _ => {
                if let Err(e) = self._child.kill() {
                    eprintln!("Failed to kill Vault process: {}", e);
                }
                let _ = self._child.wait();
            },
        }
    }
}
```

This ensures the Vault dev server is properly terminated whenever `VaultRunner` goes out of scope, preventing orphaned processes with exposed credentials.

Additionally, consider:
1. Using randomly generated tokens instead of hardcoded `ROOT_TOKEN` even for dev mode
2. Adding a warning log when `VaultRunner` is dropped to aid debugging
3. Implementing a process monitor to detect and terminate orphaned Vault processes in CI

## Proof of Concept

```rust
#[cfg(test)]
mod test_vault_orphan {
    use super::*;
    use std::process::Command;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn demonstrate_orphaned_vault_process() {
        // Start VaultRunner - spawns child Vault process
        let vault = VaultRunner::run().expect("Failed to start Vault");
        let host = vault.host().to_string();
        let port = host.split(':').last().unwrap();
        
        // Store a test secret
        let client = vault.client();
        client.set("test_key", "sensitive_data").unwrap();
        
        // Get the child process PID before dropping
        let pid = vault._child.id();
        println!("Vault process PID: {}", pid);
        
        // Drop VaultRunner - this should kill the process but doesn't
        drop(vault);
        
        // Wait a moment for potential cleanup
        thread::sleep(Duration::from_secs(1));
        
        // Verify the process is still running
        let is_running = Command::new("ps")
            .arg("-p")
            .arg(pid.to_string())
            .output()
            .map(|output| output.status.success())
            .unwrap_or(false);
        
        assert!(is_running, "VULNERABILITY: Vault process still running after VaultRunner dropped");
        
        // Demonstrate unauthorized access with known ROOT_TOKEN
        let malicious_client = aptos_vault_client::Client::new(
            format!("http://localhost:{}", port),
            ROOT_TOKEN.to_string(),
            None, None, None
        );
        
        // Attacker can read the sensitive data
        let stolen_secret = malicious_client.get::<String>("test_key").unwrap();
        assert_eq!(stolen_secret.value, "sensitive_data");
        
        println!("VULNERABILITY CONFIRMED: Extracted secret from orphaned Vault process");
        
        // Cleanup for test - manually kill the process
        Command::new("kill").arg(pid.to_string()).output().ok();
    }
}
```

**Notes**

The vulnerability specifically affects the development/testing infrastructure but has security implications because:

1. The Vault storage system is explicitly the "primary production storage backend" used for validator cryptographic keys and consensus safety data in production environments.

2. Test environments often run in shared CI/CD infrastructure where multiple users or jobs have local access, making the orphaned processes accessible to unauthorized parties.

3. The hardcoded `ROOT_TOKEN` credential makes exploitation trivial—no credential extraction or brute-forcing required.

4. While the file is named `dev.rs`, it implements critical security infrastructure for the testing of production-grade cryptographic key management, and leaked test keys could provide attackers with valuable information about production key formats, usage patterns, or even actual key material if developers accidentally use similar keys in testing.

The fix is straightforward and follows the established pattern already used correctly elsewhere in the Aptos codebase for managing child processes.

### Citations

**File:** secure/storage/vault/src/dev.rs (L11-22)
```rust
static APTOS_VAULT: Lazy<Option<VaultRunner>> = Lazy::new(|| match VaultRunner::run() {
    Err(err) => {
        assert!(
            std::env::var("APTOS_REQUIRE_VAULT_TESTS").is_err(),
            "Vault is not running: {}",
            err
        );
        println!("Vault is not running: {}", err);
        None
    },
    Ok(vr) => Some(vr),
});
```

**File:** secure/storage/vault/src/dev.rs (L41-73)
```rust
pub struct VaultRunner {
    _child: Child,
    host: String,
}

impl VaultRunner {
    /// Instantiates a new instance of Vault if one is available or returns a String error stating
    /// where it was unable to make progress.
    pub fn run() -> Result<Self, String> {
        let port = Self::_port()?;

        let mut vault_run = Command::new(BINARY);
        vault_run
            .arg("server")
            .arg("-dev")
            .arg(format!("-dev-root-token-id={}", ROOT_TOKEN).as_str())
            .arg(format!("-dev-listen-address=127.0.0.1:{}", port).as_str());

        let child = vault_run
            .stderr(Stdio::null())
            .stdin(Stdio::null())
            .stdout(Stdio::null())
            .spawn()
            .map_err(|e| e.to_string())?;

        let host = format!("{}:{}", HOST, port);
        Self::_transit(&host)?;

        Ok(Self {
            _child: child,
            host,
        })
    }
```

**File:** testsuite/forge/src/backend/local/node.rs (L29-47)
```rust
#[derive(Debug)]
struct Process(Child);

impl Drop for Process {
    // When the Process struct goes out of scope we need to kill the child process
    fn drop(&mut self) {
        // check if the process has already been terminated
        match self.0.try_wait() {
            // The child process has already terminated, perhaps due to a crash
            Ok(Some(_)) => {},

            // The process is still running so we need to attempt to kill it
            _ => {
                self.0.kill().expect("Process wasn't running");
                self.0.wait().unwrap();
            },
        }
    }
}
```

**File:** secure/storage/src/tests/vault.rs (L54-66)
```rust
#[test]
fn execute_storage_tests_vault() {
    if dev::test_host_safe().is_none() {
        return;
    }
    let mut storage = create_vault();
    storage.reset_and_clear().unwrap();

    for test in VAULT_TESTS.iter() {
        test();
        storage.reset_and_clear().unwrap();
    }
}
```

**File:** secure/storage/README.md (L31-33)
```markdown
- `Vault`: The Vault secure storage implementation uses the Vault Storage Engine (an engine
offered by HashiCorp: https://www.vaultproject.io/). The Vault secure storage implementation
is the one primarily used in production environments by nodes in the blockchain.
```
