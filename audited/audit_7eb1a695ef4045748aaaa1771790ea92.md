# Audit Report

## Title
Proof Verification DoS via Late Validation of Sibling Vector Sizes

## Summary
The `AccumulatorProof` and `AccumulatorRangeProof` verification functions check proof size constraints AFTER expensive deserialization and during the verification process, allowing attackers to force nodes to waste significant CPU and memory resources on maliciously oversized proofs before they are rejected.

## Finding Description
The vulnerability exists in the proof verification logic for Merkle accumulator proofs used in state synchronization. When a node receives transaction proofs from peers during state sync, the proof data structures (`AccumulatorProof` and `AccumulatorRangeProof`) are deserialized before any size validation occurs. [1](#0-0) 

The `AccumulatorProof` struct contains a `siblings: Vec<HashValue>` field that should be bounded by `MAX_ACCUMULATOR_PROOF_DEPTH` (63 elements). However, this constraint is only enforced inside the `verify()` method: [2](#0-1) 

This means the validation happens AFTER:
1. Network bandwidth is consumed receiving the proof (up to 64 MiB message limit)
2. BCS deserialization allocates memory for all siblings
3. The `verify()` function is called

Similarly, `AccumulatorRangeProof` has the same issue with both `left_siblings` and `right_siblings` vectors: [3](#0-2) 

**Attack Flow:**
1. Attacker connects to victim node via state sync protocol
2. Attacker crafts a `TransactionInfoListWithProof` containing an `AccumulatorRangeProof` with ~2 million siblings (within the 64 MiB network message limit)
3. Victim node receives and deserializes the entire proof structure (~64 MB memory allocation)
4. Victim calls `verify()` which only then checks the sibling count and rejects it
5. Request is marked as invalid and peer is throttled (but damage is already done)
6. Attacker can repeat from multiple peer identities

The network message size limit allows approximately 2 million HashValues (64 MiB / 32 bytes) to be sent: [4](#0-3) 

**Broken Invariant:** This violates the documented invariant "Resource Limits: All operations must respect gas, storage, and computational limits" because nodes are forced to perform expensive deserialization operations on invalid data before validation occurs.

## Impact Explanation
This is a **High Severity** vulnerability per the Aptos bug bounty criteria: "Validator node slowdowns."

**Impact Details:**
- **CPU Exhaustion:** Deserializing 2 million HashValues requires significant CPU time. Multiple concurrent attacks can overwhelm node resources.
- **Memory Exhaustion:** Each oversized proof allocates 64 MB. With concurrent requests, this can exhaust node memory.
- **Amplification Factor:** Legitimate proofs have ≤63 siblings, but attackers can send proofs with ~2 million siblings—a 31,746x amplification.
- **Persistent Attack:** Existing rate limiting and peer throttling only activate AFTER the expensive work is done, providing inadequate protection.
- **Validator Impact:** This affects validator nodes during state sync, potentially causing them to fall behind or become unavailable.

The vulnerability does not directly affect consensus safety but significantly impacts node availability and performance, which can indirectly affect network liveness.

## Likelihood Explanation
**Likelihood: High**

The attack is highly likely to succeed because:
1. **No Authentication Required:** Any network peer can trigger state sync requests
2. **Public Attack Surface:** State sync is a public-facing protocol that nodes must expose
3. **Low Attack Cost:** Crafting oversized proofs is trivial—just serialize a Vec with 2 million elements
4. **Multiple Vectors:** The vulnerability affects multiple proof types (`AccumulatorProof`, `AccumulatorRangeProof`)
5. **Insufficient Mitigations:** Rate limiting and peer scoring only work reactively, after resources are wasted

The attack can be executed by any adversary with basic network access to Aptos nodes, requires no privileged access, and is difficult to distinguish from legitimate traffic until the proof is verified.

## Recommendation
**Immediate Fix:** Validate proof size constraints during or immediately after deserialization, before any expensive operations.

**Option 1 - Add Custom Deserialize Implementation:**
```rust
impl<H> serde::Deserialize<'_> for AccumulatorProof<H> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'_>,
    {
        let siblings = Vec::<HashValue>::deserialize(deserializer)?;
        if siblings.len() > MAX_ACCUMULATOR_PROOF_DEPTH {
            return Err(serde::de::Error::custom(format!(
                "Accumulator proof has too many siblings: {} > {}",
                siblings.len(),
                MAX_ACCUMULATOR_PROOF_DEPTH
            )));
        }
        Ok(AccumulatorProof {
            siblings,
            phantom: PhantomData,
        })
    }
}
```

**Option 2 - Add Validation in State Sync Layer:**
Before calling `verify()` on any proof, add:
```rust
ensure!(
    proof.siblings().len() <= MAX_ACCUMULATOR_PROOF_DEPTH,
    "Proof has too many siblings: {}",
    proof.siblings().len()
);
```

Similar fixes should be applied to `AccumulatorRangeProof` for both `left_siblings` and `right_siblings` fields.

**Additional Hardening:**
- Consider lowering the network message size limit for state sync messages
- Add metrics to track oversized proof attempts
- Implement progressive penalties for peers sending oversized proofs

## Proof of Concept
```rust
#[cfg(test)]
mod proof_dos_test {
    use super::*;
    use aptos_crypto::{hash::CryptoHash, HashValue};
    use aptos_types::proof::TransactionAccumulatorProof;
    
    #[test]
    fn test_oversized_proof_resource_exhaustion() {
        // Create an oversized proof with 2 million siblings
        // (within 64 MiB network limit: 2M * 32 bytes = 64 MB)
        let oversized_sibling_count = 2_000_000;
        let mut siblings = Vec::with_capacity(oversized_sibling_count);
        for _ in 0..oversized_sibling_count {
            siblings.push(HashValue::random());
        }
        
        // Create the proof
        let malicious_proof = TransactionAccumulatorProof::new(siblings);
        
        // Serialize it (this would be sent over the network)
        let serialized = bcs::to_bytes(&malicious_proof).unwrap();
        println!("Serialized proof size: {} bytes", serialized.len());
        assert!(serialized.len() <= 64 * 1024 * 1024); // Within network limit
        
        // Deserialize it (victim node does this)
        let start = std::time::Instant::now();
        let deserialized: TransactionAccumulatorProof = 
            bcs::from_bytes(&serialized).unwrap();
        let deser_time = start.elapsed();
        println!("Deserialization took: {:?}", deser_time);
        
        // Only now does verification fail with size check
        let result = deserialized.verify(
            HashValue::random(),
            HashValue::random(),
            0,
        );
        
        // Verification fails, but resources were already wasted
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("more than"));
        
        // Demonstrate resource waste: deserialization of 2M elements is expensive
        // compared to legitimate 63-element proofs (31,746x amplification)
    }
}
```

**Notes:**
- The vulnerability is particularly severe because state sync is critical for node operation
- The fix is straightforward but requires careful implementation to maintain compatibility
- Consider this finding in conjunction with any other network protocol attack surfaces

### Citations

**File:** types/src/proof/definition.rs (L33-40)
```rust
#[derive(Clone, Serialize, Deserialize)]
pub struct AccumulatorProof<H> {
    /// All siblings in this proof, including the default ones. Siblings are ordered from the bottom
    /// level to the root level.
    siblings: Vec<HashValue>,

    phantom: PhantomData<H>,
}
```

**File:** types/src/proof/definition.rs (L74-79)
```rust
        ensure!(
            self.siblings.len() <= MAX_ACCUMULATOR_PROOF_DEPTH,
            "Accumulator proof has more than {} ({}) siblings.",
            MAX_ACCUMULATOR_PROOF_DEPTH,
            self.siblings.len()
        );
```

**File:** types/src/proof/definition.rs (L636-647)
```rust
        ensure!(
            self.left_siblings.len() <= MAX_ACCUMULATOR_PROOF_DEPTH,
            "Proof has more than {} ({}) left siblings.",
            MAX_ACCUMULATOR_PROOF_DEPTH,
            self.left_siblings.len(),
        );
        ensure!(
            self.right_siblings.len() <= MAX_ACCUMULATOR_PROOF_DEPTH,
            "Proof has more than {} ({}) right siblings.",
            MAX_ACCUMULATOR_PROOF_DEPTH,
            self.right_siblings.len(),
        );
```

**File:** config/src/config/network_config.rs (L23-48)
```rust
use serde::{Deserialize, Serialize};
use std::{
    collections::{HashMap, HashSet},
    convert::TryFrom,
    fmt,
    path::PathBuf,
    string::ToString,
};

// TODO: We could possibly move these constants somewhere else, but since they are defaults for the
//   configurations of the system, we'll leave it here for now.
/// Current supported protocol negotiation handshake version. See
/// [`aptos_network::protocols::wire::v1`](../../network/protocols/wire/handshake/v1/index.html).
pub const HANDSHAKE_VERSION: u8 = 0;
pub const NETWORK_CHANNEL_SIZE: usize = 1024;
pub const PING_INTERVAL_MS: u64 = 10_000;
pub const PING_TIMEOUT_MS: u64 = 20_000;
pub const PING_FAILURES_TOLERATED: u64 = 3;
pub const CONNECTIVITY_CHECK_INTERVAL_MS: u64 = 5000;
pub const MAX_CONNECTION_DELAY_MS: u64 = 60_000; /* 1 minute */
pub const MAX_FULLNODE_OUTBOUND_CONNECTIONS: usize = 6;
pub const MAX_INBOUND_CONNECTIONS: usize = 100;
pub const MAX_MESSAGE_METADATA_SIZE: usize = 128 * 1024; /* 128 KiB: a buffer for metadata that might be added to messages by networking */
pub const MESSAGE_PADDING_SIZE: usize = 2 * 1024 * 1024; /* 2 MiB: a safety buffer to allow messages to get larger during serialization */
pub const MAX_APPLICATION_MESSAGE_SIZE: usize =
    (MAX_MESSAGE_SIZE - MAX_MESSAGE_METADATA_SIZE) - MESSAGE_PADDING_SIZE; /* The message size that applications should check against */
```
