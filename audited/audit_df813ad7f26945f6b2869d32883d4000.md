# Audit Report

## Title
Missing Per-Player Share Length Validation in Weighted PVSS Transcript Verification Allows Malformed Shares Leading to Reconstruction Panic

## Summary
The weighted PVSS transcript verification in `weighted_transcript.rs` only validates the total flattened length of encrypted shares but does not verify that each player's share array matches their assigned weight. This allows malicious transcripts to pass verification with incorrectly-sized per-player share arrays, which later causes a panic in the `reconstruct()` function when attempting secret reconstruction.

## Finding Description

The vulnerability exists in the verification logic for weighted PVSS transcripts used in Aptos DKG (Distributed Key Generation). The `verify()` function validates that the total number of encrypted shares equals the total weight, but fails to check that each individual player's share array has length equal to their weight. [1](#0-0) 

The verification only checks: `Cs_flat.len() == sc.get_total_weight()`, where `Cs_flat` is the flattened concatenation of all per-player share arrays. This allows an attacker to create a transcript where `Cs[i].len() != weight[i]` for individual players, as long as the total remains correct.

When such a malformed transcript is decrypted, the `decrypt_own_share()` function has only a debug assertion (removed in release builds): [2](#0-1) 

The function proceeds to decrypt whatever length is present in `Cs[player.id]`, returning a share vector with incorrect length. When these shares are later passed to `reconstruct()`, the code attempts to map each share to a virtual player: [3](#0-2) 

The `get_virtual_player()` call includes an assertion that panics if the share position exceeds the player's weight: [4](#0-3) 

**Attack Path:**
1. Malicious DKG dealer creates transcript where `Cs[0].len() = 3` and `Cs[1].len() = 2` for players with weights `[2, 3]`
2. Total flattened length is still 5, so verification passes at line 248-252
3. When player 0 decrypts shares, they receive 3 shares instead of expected 2
4. If `reconstruct_secret_from_shares()` is called with these shares, iteration reaches `pos=2` for player 0
5. `get_virtual_player(player_0, 2)` triggers `assert_lt!(2, 2)` which panics
6. Node crashes with panic, causing denial of service

## Impact Explanation

This is a **Medium severity** vulnerability based on the following factors:

**State Inconsistency:** The flaw allows malformed DKG state to be created and persisted, violating the protocol's type safety invariants. Validators will have shares with incorrect vector lengths that don't match the weighted configuration.

**Limited Denial of Service:** While `reconstruct_secret_from_shares()` is marked as test-only in the current codebase, the presence of malformed shares creates a latent failure mode. Any future code path attempting reconstruction (for recovery, debugging, or protocol changes) would immediately panic. [5](#0-4) 

**Consensus Impact:** If reconstruction is attempted during consensus (e.g., epoch transitions or randomness generation recovery), different nodes might panic at different times depending on which shares they attempt to reconstruct, potentially causing consensus liveness issues.

The impact is Medium rather than High because the direct reconstruction path is currently test-only, limiting immediate exploitability. However, the verification bypass is a real correctness bug that allows malformed protocol state.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires:
1. A malicious or compromised validator acting as DKG dealer
2. Ability to construct a PVSS transcript with specific malformed share arrays
3. Other validators accepting the transcript (which they will, due to the verification flaw)

The attack is feasible because:
- Any validator participating in DKG can act as a dealer
- Creating the malformed transcript requires only manipulating array lengths while maintaining the correct total
- No cryptographic breaking or complex exploitation is needed
- The verification flaw will accept such transcripts

The likelihood is Medium rather than High because:
- Reconstruction is not currently performed in production consensus paths
- The attacker must be a validator (untrusted but not arbitrary network peer)
- Impact requires specific conditions where reconstruction is attempted

## Recommendation

Add per-player share length validation in the `verify()` function:

```rust
// In weighted_transcript.rs verify() function, after line 153:

// Validate that each player's share array matches their weight
for (player_idx, Cs_player) in self.subtrs.Cs.iter().enumerate() {
    let expected_weight = sc.get_player_weight(&sc.get_player(player_idx));
    if Cs_player.len() != expected_weight {
        bail!(
            "Player {} has {} encrypted shares but weight is {}",
            player_idx,
            Cs_player.len(),
            expected_weight
        );
    }
}

// Similarly validate Vs arrays
for (player_idx, Vs_player) in self.subtrs.Vs.iter().enumerate() {
    let expected_weight = sc.get_player_weight(&sc.get_player(player_idx));
    if Vs_player.len() != expected_weight {
        bail!(
            "Player {} has {} commitment elements but weight is {}",
            player_idx,
            Vs_player.len(),
            expected_weight
        );
    }
}
```

Additionally, change the debug assertion in `decrypt_own_share()` to a production check:

```rust
// In weighted_transcript.rs decrypt_own_share(), replace line 578:
if Cs.len() != sc.get_player_weight(player) {
    return Err(anyhow::anyhow!(
        "Player {} has {} encrypted shares but expected {}",
        player.id,
        Cs.len(),
        sc.get_player_weight(player)
    ));
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod weighted_config_vulnerability_test {
    use aptos_crypto::weighted_config::WeightedConfigBlstrs;
    use aptos_dkg::pvss::chunky::weighted_transcript::Transcript;
    use aptos_dkg::pvss::Player;
    use blstrs::Scalar;
    
    #[test]
    #[should_panic(expected = "assertion failed")]
    fn test_mismatched_share_lengths_cause_panic() {
        // Create weighted config with players of weights [2, 3]
        let wconfig = WeightedConfigBlstrs::new(3, vec![2, 3]).unwrap();
        
        // Simulate malicious transcript that passes total length check
        // but has wrong per-player lengths: [3, 2] instead of [2, 3]
        // Total is still 5, so verification would pass
        
        // Create malformed shares: player 0 gets 3 shares (should be 2)
        let malformed_shares = vec![
            (Player { id: 0 }, vec![Scalar::from(1u64), Scalar::from(2u64), Scalar::from(3u64)]),
            (Player { id: 1 }, vec![Scalar::from(4u64), Scalar::from(5u64)]),
        ];
        
        // Attempt reconstruction - this will panic when processing player 0's 3rd share
        // because get_virtual_player(player_0, 2) will assert_lt!(2, 2)
        let _result = Scalar::reconstruct(&wconfig, &malformed_shares);
        
        // If we reach here, the vulnerability is fixed
        // If we panic, the vulnerability is present
    }
}
```

## Notes

While the immediate production impact is limited by the test-only status of `reconstruct_secret_from_shares()`, this represents a fundamental verification bypass that allows malformed protocol state. The fix should be implemented to ensure type safety invariants are maintained throughout the DKG protocol, preventing future issues if reconstruction is added to production code paths or if the malformed shares cause unexpected behavior in other components that assume correct share structure.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L247-252)
```rust
        let Cs_flat: Vec<_> = self.subtrs.Cs.iter().flatten().cloned().collect();
        assert_eq!(
            Cs_flat.len(),
            sc.get_total_weight(),
            "Number of ciphertexts does not equal number of weights"
        ); // TODO what if zero weight?
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L577-578)
```rust
        let Cs = &self.subtrs.Cs[player.id];
        debug_assert_eq!(Cs.len(), sc.get_player_weight(player));
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L177-184)
```rust
    pub fn get_virtual_player(&self, player: &Player, j: usize) -> Player {
        // println!("WeightedConfig::get_virtual_player({player}, {i})");
        assert_lt!(j, self.weights[player.id]);

        let id = self.get_share_index(player.id, j).unwrap();

        Player { id }
    }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L394-410)
```rust
        for (player, sub_shares) in shares {
            // println!(
            //     "Flattening {} share(s) for player {player}",
            //     sub_shares.len()
            // );
            for (pos, share) in sub_shares.iter().enumerate() {
                let virtual_player = sc.get_virtual_player(player, pos);

                // println!(
                //     " + Adding share {pos} as virtual player {virtual_player}: {:?}",
                //     share
                // );
                // TODO(Performance): Avoiding the cloning here might be nice
                let tuple = (virtual_player, share.clone());
                flattened_shares.push(tuple);
            }
        }
```

**File:** types/src/dkg/real_dkg/mod.rs (L469-483)
```rust
    // Test-only function
    fn reconstruct_secret_from_shares(
        pub_params: &Self::PublicParams,
        input_player_share_pairs: Vec<(u64, Self::DealtSecretShare)>,
    ) -> anyhow::Result<Self::DealtSecret> {
        let player_share_pairs: Vec<_> = input_player_share_pairs
            .clone()
            .into_iter()
            .map(|(x, y)| (Player { id: x as usize }, y.main))
            .collect();
        let reconstructed_secret = <WTrx as Transcript>::DealtSecretKey::reconstruct(
            &pub_params.pvss_config.wconfig,
            &player_share_pairs,
        )
        .unwrap();
```
