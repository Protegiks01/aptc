# Audit Report

## Title
Transitive Dependency Validation Bypass Allows Supply Chain Attacks

## Summary
The Aptos package publishing system only validates direct dependencies but fails to check transitive dependencies, allowing malicious code to be introduced indirectly through benign intermediary packages. This creates a supply chain attack vector where developers unknowingly include malicious code by depending on packages that themselves depend on malicious packages.

## Finding Description

The package dependency validation in Aptos performs only shallow validation of direct dependencies without recursively checking transitive dependencies. This occurs in the `check_dependencies` function which validates packages being published on-chain. [1](#0-0) 

The function iterates only through the package's declared direct dependencies (`pack.deps`) and validates their upgrade policies, but does not recursively examine what those dependencies themselves depend on. This allows the following attack:

1. **Attacker Setup**: Attacker publishes malicious Package C at address `0xMALICIOUS` containing functions that steal funds or manipulate state
2. **Trojan Horse**: Either the attacker or an unknowing developer publishes Package B at address `0xUTIL` that declares a dependency on Package C
3. **Victim Package**: Victim publishes Package A that declares only Package B as a dependency
4. **Validation Bypass**: When Package A is published, `check_dependencies` only validates Package B exists and has an appropriate upgrade policy, but never examines Package C
5. **Execution Chain**: When users interact with Package A, the execution chain `A → B → C` causes the malicious code in C to execute with the transaction signer's authority

The validation in `aptos_vm.rs` only checks immediate module imports: [2](#0-1) 

This validates that Package A's modules only import from Package B (their declared dependency), but does not validate what Package B imports from its own dependencies.

Additionally, the dependency resolver has an acknowledged TODO for on-chain packages: [3](#0-2) 

This indicates transitive dependencies are not fetched for on-chain packages during local builds, compounding the issue.

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Loss of Funds**: Malicious transitive dependencies can contain functions that steal user tokens, drain liquidity pools, or manipulate DeFi protocols. When victims' packages call seemingly benign functions that internally invoke malicious code, user funds are at risk.

2. **Supply Chain Attack**: A single malicious package deep in a dependency tree can compromise multiple packages that depend on it (directly or transitively), amplifying the attack surface across the ecosystem.

3. **False Security Guarantee**: The existence of `check_dependencies` validation creates an expectation that dependencies are safe. The incomplete validation provides false assurance to developers who assume published packages have been properly vetted.

This meets **Critical Severity** criteria under "Loss of Funds (theft or minting)" in the Aptos bug bounty program, as malicious transitive dependencies can directly steal user assets during transaction execution.

## Likelihood Explanation

**High Likelihood** - The attack is highly feasible because:

1. **Easy Execution**: An attacker only needs to publish packages and convince developers to add them to dependency chains. No special privileges or validator access required.

2. **Difficult Detection**: Developers typically audit only their direct dependencies, not the complete transitive dependency tree. Without tooling to visualize or validate transitive dependencies, malicious packages can remain undetected.

3. **Trust Propagation**: Once a package is published and gains some usage, other developers may trust it without deep auditing, especially if it's a transitive (not direct) dependency they're unaware of.

4. **No Transitive Scanning**: The codebase confirms transitive dependencies are not validated during publishing: [4](#0-3) 

## Recommendation

Implement recursive transitive dependency validation in the `check_dependencies` function:

```move
fun check_dependencies(publish_address: address, pack: &PackageMetadata): vector<AllowedDep>
acquires PackageRegistry {
    let allowed_module_deps = vector::empty();
    let validated_packages = vector::empty(); // Track visited packages to prevent cycles
    
    // Recursively validate dependencies
    check_dependencies_recursive(
        publish_address,
        &pack.deps,
        pack.upgrade_policy,
        &mut allowed_module_deps,
        &mut validated_packages
    );
    
    allowed_module_deps
}

fun check_dependencies_recursive(
    publish_address: address,
    deps: &vector<PackageDep>,
    parent_policy: UpgradePolicy,
    allowed_module_deps: &mut vector<AllowedDep>,
    validated_packages: &mut vector<PackageDep>
) acquires PackageRegistry {
    vector::for_each_ref(deps, |dep| {
        let dep: &PackageDep = dep;
        
        // Prevent infinite recursion on circular deps
        if (vector::contains(validated_packages, dep)) {
            return
        };
        vector::push_back(validated_packages, *dep);
        
        // Validate this dependency
        assert!(exists<PackageRegistry>(dep.account), error::not_found(EPACKAGE_DEP_MISSING));
        
        if (!is_policy_exempted_address(dep.account)) {
            let registry = borrow_global<PackageRegistry>(dep.account);
            let found = vector::any(&registry.packages, |dep_pack| {
                let dep_pack: &PackageMetadata = dep_pack;
                if (dep_pack.name == dep.package_name) {
                    // Check policy
                    assert!(
                        dep_pack.upgrade_policy.policy >= parent_policy.policy,
                        error::invalid_argument(EDEP_WEAKER_POLICY)
                    );
                    
                    // Add allowed deps for this package
                    // ... (add modules to allowed_module_deps)
                    
                    // RECURSIVE CALL: Check this package's dependencies
                    check_dependencies_recursive(
                        publish_address,
                        &dep_pack.deps,
                        parent_policy,
                        allowed_module_deps,
                        validated_packages
                    );
                    
                    true
                } else {
                    false
                }
            });
            assert!(found, error::not_found(EPACKAGE_DEP_MISSING));
        };
    });
}
```

Additionally, provide CLI tooling to visualize the complete dependency tree:
```bash
aptos move show-dependencies --transitive --package-path <path>
```

## Proof of Concept

```move
// Step 1: Attacker publishes MaliciousLib
module 0xAttacker::MaliciousLib {
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    
    // Appears to be a utility function
    public fun process_payment(sender: &signer, amount: u64) {
        // Malicious: steals to attacker instead of processing legitimately
        let attacker = @0xAttacker;
        coin::transfer<AptosCoin>(sender, attacker, amount);
    }
}

// Step 2: Unwitting developer or attacker publishes UtilityLib
// Move.toml declares: dependencies = { MaliciousLib = { ... } }
module 0xUtil::UtilityLib {
    use 0xAttacker::MaliciousLib;
    
    // Looks benign but calls malicious code
    public fun make_payment(sender: &signer, recipient: address, amount: u64) {
        // Developer thinks this processes payment safely
        MaliciousLib::process_payment(sender, amount);
    }
}

// Step 3: Victim publishes DeFiApp
// Move.toml declares: dependencies = { UtilityLib = { ... } }
// Does NOT declare MaliciousLib (only transitive dependency)
module 0xVictim::DeFiApp {
    use 0xUtil::UtilityLib;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    
    public entry fun deposit(user: &signer, amount: u64) {
        // Victim believes this deposits to DeFiApp
        UtilityLib::make_payment(user, @0xVictim, amount);
        // But funds actually go to 0xAttacker!
    }
}

// When DeFiApp is published:
// - check_dependencies() only validates UtilityLib exists and has compatible policy ✓
// - Does NOT check that UtilityLib depends on MaliciousLib ✗
// - Does NOT validate MaliciousLib's code ✗
// - Publishing succeeds despite malicious transitive dependency

// When user calls deposit():
// - Execution chain: DeFiApp::deposit → UtilityLib::make_payment → MaliciousLib::process_payment
// - User's funds are stolen by attacker
// - Critical invariant violated: User assets compromised through supply chain attack
```

**Notes**:
- The vulnerability exists because dependency validation is non-recursive, checking only the immediate `deps` field of the package being published
- The formal specification Requirement #5 only mandates direct dependency policy checking, not transitive validation
- This is a systemic design issue rather than an implementation bug, but has critical security implications
- Without recursive validation or transitive dependency inspection tooling, developers have no practical way to audit their complete dependency tree before publishing

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L295-344)
```text
    /// Check that the upgrade policies of all packages are equal or higher quality than this package. Also
    /// compute the list of module dependencies which are allowed by the package metadata. The later
    /// is passed on to the native layer to verify that bytecode dependencies are actually what is pretended here.
    fun check_dependencies(publish_address: address, pack: &PackageMetadata): vector<AllowedDep>
    acquires PackageRegistry {
        let allowed_module_deps = vector::empty();
        let deps = &pack.deps;
        vector::for_each_ref(deps, |dep| {
            let dep: &PackageDep = dep;
            assert!(exists<PackageRegistry>(dep.account), error::not_found(EPACKAGE_DEP_MISSING));
            if (is_policy_exempted_address(dep.account)) {
                // Allow all modules from this address, by using "" as a wildcard in the AllowedDep
                let account: address = dep.account;
                let module_name = string::utf8(b"");
                vector::push_back(&mut allowed_module_deps, AllowedDep { account, module_name });
            } else {
                let registry = borrow_global<PackageRegistry>(dep.account);
                let found = vector::any(&registry.packages, |dep_pack| {
                    let dep_pack: &PackageMetadata = dep_pack;
                    if (dep_pack.name == dep.package_name) {
                        // Check policy
                        assert!(
                            dep_pack.upgrade_policy.policy >= pack.upgrade_policy.policy,
                            error::invalid_argument(EDEP_WEAKER_POLICY)
                        );
                        if (dep_pack.upgrade_policy == upgrade_policy_arbitrary()) {
                            assert!(
                                dep.account == publish_address,
                                error::invalid_argument(EDEP_ARBITRARY_NOT_SAME_ADDRESS)
                            )
                        };
                        // Add allowed deps
                        let account = dep.account;
                        let k = 0;
                        let r = vector::length(&dep_pack.modules);
                        while (k < r) {
                            let module_name = vector::borrow(&dep_pack.modules, k).name;
                            vector::push_back(&mut allowed_module_deps, AllowedDep { account, module_name });
                            k = k + 1;
                        };
                        true
                    } else {
                        false
                    }
                });
                assert!(found, error::not_found(EPACKAGE_DEP_MISSING));
            };
        });
        allowed_module_deps
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1699-1714)
```rust
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L243-243)
```rust
            // TODO: fetch transitive deps
```
