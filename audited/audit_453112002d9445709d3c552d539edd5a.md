# Audit Report

## Title
Integer Overflow in script_into_module() Signature Table Index Creation

## Summary
The `script_into_module()` function contains an integer overflow vulnerability at line 153 where casting `signatures.len()` to `u16` can wrap around when the signature table has 65536 or more entries, causing the function to reference an incorrect signature index instead of the newly pushed empty signature. [1](#0-0) 

## Finding Description

The vulnerability occurs in the signature table handling when no empty signature exists in the pool. The code attempts to create a new `SignatureIndex` from the current length, then push an empty signature: [2](#0-1) 

Since `SignatureIndex` is a wrapper around `u16` (TableIndex), when `script.signatures.len()` equals or exceeds 65536:
- The cast `as u16` causes integer overflow wraparound (65536 → 0, 65537 → 1, etc.)
- The created index points to the wrong signature (e.g., `signatures[0]` instead of the newly pushed signature at position 65536)
- The function handle's `return_` field receives this corrupted index [3](#0-2) 

**Root Cause - Missing Validation:**

1. **Deserializer does not enforce table size limits**: The `Table::load` method accepts any number of entries without checking against `TABLE_INDEX_MAX` (65535): [4](#0-3) 

2. **BoundsChecker does not validate table counts**: Only validates individual signature contents, not the total count: [5](#0-4) 

3. **Builder has protection but deserializer does not**: While `CompiledScriptBuilder` checks pool size limits: [6](#0-5) 

The deserializer path bypasses this check entirely.

**Attack Vector:**
1. Attacker crafts malicious bytecode with exactly 65536 signatures (none empty)
2. Binary passes deserialization (no table count validation)
3. Binary passes BoundsChecker (no table size verification)
4. When processed by `script_into_module()`, line 153 wraps 65536 to 0
5. Resulting module has corrupted return signature pointing to wrong type

## Impact Explanation

**Severity: LOW - Does Not Meet Exploitability Criteria**

Despite the technical correctness of the bug, this vulnerability **does not qualify** for the bug bounty program because:

**Critical Limitation: No On-Chain Attack Path**

The `script_into_module()` function is only called in **tooling contexts**, not during transaction execution: [7](#0-6) 

This call occurs:
- During compilation with experimental flag `ATTACH_COMPILED_MODULE`
- In disassembler/decompiler tools
- NOT during on-chain script execution

**Why This Fails Security Criteria:**
- ❌ **No consensus impact**: Scripts execute directly, not converted to modules on-chain
- ❌ **No state corruption**: Conversion happens in compilation, not execution
- ❌ **No fund risk**: Cannot be triggered by transaction submission
- ❌ **No validator impact**: Tools run off-chain, not on validators

The bug affects **developer tooling quality**, not blockchain security.

## Likelihood Explanation

**Likelihood: NONE (Not Exploitable in Security Context)**

While technically possible to trigger in tooling:
- Requires malicious developer using compromised compiler
- Would fail to produce valid modules (caught by later validation)
- Cannot be weaponized against the network
- No realistic attack scenario affecting consensus or state

The TABLE_INDEX_MAX constant is well-documented: [8](#0-7) 

## Recommendation

Despite not being security-critical, this should be fixed for code robustness:

**Add table size validation in deserializer:**
```rust
// In Table::load method
fn load<T>(
    &self,
    binary: &VersionedBinary,
    result: &mut Vec<T>,
    deserializer: impl Fn(&mut VersionedCursor) -> BinaryLoaderResult<T>,
) -> BinaryLoaderResult<()> {
    let start = self.offset as usize;
    let end = start + self.count as usize;
    let mut cursor = binary.new_cursor(start, end);
    while cursor.position() < self.count as u64 {
        if result.len() >= TABLE_INDEX_MAX as usize {
            return Err(PartialVMError::new(StatusCode::INDEX_OUT_OF_BOUNDS)
                .with_message(format!("Table size exceeds maximum of {}", TABLE_INDEX_MAX)));
        }
        result.push(deserializer(&mut cursor)?)
    }
    Ok(())
}
```

**Add defensive check in script_into_module:**
```rust
// Before line 153
if script.signatures.len() >= TableIndex::MAX as usize {
    panic!("Signature table size exceeds maximum indexable limit");
}
```

## Proof of Concept

Not applicable - the function is not reachable through any on-chain attack vector. A PoC would only demonstrate a developer tooling bug, not a security vulnerability.

---

**Validation Checklist Result:**
- [❌] Exploitable by unprivileged attacker - **FAILS**: Not reachable via transaction
- [❌] Impact meets severity criteria - **FAILS**: No consensus/state/fund impact  
- [❌] Clear security harm demonstrated - **FAILS**: Only affects off-chain tooling

**Final Assessment: This is a code quality issue in tooling, not a security vulnerability qualifying for the bug bounty program.**

### Citations

**File:** third_party/move/move-binary-format/src/module_script_conversion.rs (L150-157)
```rust
    let return_sig_idx = match script.signatures.iter().position(|sig| sig.0.is_empty()) {
        Some(idx) => SignatureIndex::new(idx as u16),
        None => {
            let idx = SignatureIndex::new(script.signatures.len() as u16);
            script.signatures.push(Signature(vec![]));
            idx
        },
    };
```

**File:** third_party/move/move-binary-format/src/module_script_conversion.rs (L165-165)
```rust
        return_: return_sig_idx,
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L573-588)
```rust
impl Table {
    /// Generic function to deserialize a table into a vector of given type.
    fn load<T>(
        &self,
        binary: &VersionedBinary,
        result: &mut Vec<T>,
        deserializer: impl Fn(&mut VersionedCursor) -> BinaryLoaderResult<T>,
    ) -> BinaryLoaderResult<()> {
        let start = self.offset as usize;
        let end = start + self.count as usize;
        let mut cursor = binary.new_cursor(start, end);
        while cursor.position() < self.count as u64 {
            result.push(deserializer(&mut cursor)?)
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/check_bounds.rs (L132-137)
```rust
    fn check_signatures(&self) -> PartialVMResult<()> {
        for signature in self.view.signatures() {
            self.check_signature(signature)?
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/builders.rs (L45-48)
```rust
            let idx = pool.len();
            if pool.len() >= TableIndex::MAX as usize {
                return Err(PartialVMError::new(StatusCode::INDEX_OUT_OF_BOUNDS));
            }
```

**File:** third_party/move/move-compiler-v2/src/file_format_generator/mod.rs (L84-87)
```rust
                    let module = module_script_conversion::script_into_module(
                        script.clone(),
                        &module_name.name().display(env.symbol_pool()).to_string(),
                    );
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L43-44)
```rust
pub const TABLE_INDEX_MAX: u64 = 65535;
pub const SIGNATURE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
```
