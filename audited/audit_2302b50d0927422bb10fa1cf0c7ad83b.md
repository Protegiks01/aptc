# Audit Report

## Title
Client-Side Panic Due to Unchecked Array Access in FaucetClient

## Summary
The `FaucetClient` in `crates/aptos-rest-client/src/faucet.rs` deserializes untrusted network data into a `Vec<SignedTransaction>` and immediately accesses index 0 without verifying the vector is non-empty, causing a panic when a malicious or misconfigured faucet server returns an empty transaction list.

## Finding Description
The vulnerability exists in two functions within the FaucetClient:

**In `create_account()` function:** [1](#0-0) 

The code deserializes network data into a transaction vector, then immediately accesses the first element without bounds checking: [2](#0-1) 

**The same pattern exists in `fund()` function:** [3](#0-2) [4](#0-3) 

**Attack Vector:**
The faucet URL is user-configurable via the constructor: [5](#0-4) 

While the legitimate Aptos faucet server returns at least one transaction (as seen in the server implementation where `check_only=true` returns empty but `check_only=false` returns transactions): [6](#0-5) 

However, the client accepts untrusted data from any configured faucet URL. A malicious actor can:
1. Set up a rogue faucet server that returns hex-encoded BCS serialization of `Vec::<SignedTransaction>::new()`
2. Configure FaucetClient to use this malicious URL
3. Trigger a panic when the client attempts `txns[0]` access

## Impact Explanation
This vulnerability causes a **denial of service** against applications using the FaucetClient. The impact severity is **Medium** rather than High because:

- It only affects client-side applications, not the blockchain protocol itself
- It does not impact validators, consensus, or on-chain state
- It requires the victim to explicitly configure their client to use a malicious faucet URL
- Each affected application can independently mitigate by validating their faucet URL configuration

However, it could disrupt:
- Automated account provisioning systems in production environments
- CI/CD pipelines that depend on faucet functionality
- Developer tooling and onboarding experiences

Per the Aptos bug bounty criteria, this qualifies as a **non-critical implementation bug** that could cause service disruption for applications relying on the SDK.

## Likelihood Explanation
**Likelihood: Medium**

The vulnerability requires:
- A user configuring FaucetClient with a malicious URL (either through social engineering, misconfiguration, or compromised infrastructure)
- The malicious server returning specifically crafted empty transaction vectors
- No technical barriers or authentication requirements

While exploitation is straightforward, it requires the victim to actively use a non-standard faucet URL, reducing the likelihood compared to vulnerabilities in default configurations.

## Recommendation
Add bounds checking before accessing the transaction vector. The fix should validate that at least one transaction was returned:

```rust
// In create_account() function, after line 73:
let txns: Vec<SignedTransaction> =
    bcs::from_bytes(&bytes).map_err(FaucetClientError::decode)?;

if txns.is_empty() {
    return Err(anyhow::anyhow!(
        "Faucet returned empty transaction list"
    ));
}

self.rest_client
    .wait_for_signed_transaction(&txns[0])
    // ... rest of code
```

Apply the same fix to the `fund()` function. Additionally, consider adding validation to ensure the faucet URL points to trusted endpoints, or provide clear warnings in documentation about the risks of using untrusted faucet servers.

## Proof of Concept

```rust
use aptos_rest_client::faucet::FaucetClient;
use aptos_types::transaction::SignedTransaction;
use reqwest::Url;
use std::net::TcpListener;
use warp::Filter;

#[tokio::test]
async fn test_empty_transaction_vector_panic() {
    // Start malicious faucet server that returns empty vector
    let malicious_server = tokio::spawn(async {
        let empty_txns: Vec<SignedTransaction> = vec![];
        let bytes = bcs::to_bytes(&empty_txns).unwrap();
        let hex_response = hex::encode(bytes);
        
        let route = warp::path("mint")
            .and(warp::query::<std::collections::HashMap<String, String>>())
            .map(move |_params: std::collections::HashMap<String, String>| {
                warp::reply::with_status(
                    hex_response.clone(),
                    warp::http::StatusCode::OK
                )
            });
        
        warp::serve(route).run(([127, 0, 0, 1], 9999)).await;
    });

    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    
    // Create client pointing to malicious server
    let faucet_url = Url::parse("http://127.0.0.1:9999").unwrap();
    let rest_url = Url::parse("http://127.0.0.1:8080").unwrap();
    let client = FaucetClient::new(faucet_url, rest_url);
    
    // This will panic with "index out of bounds" 
    let result = client.create_account(
        aptos_types::account_address::AccountAddress::random()
    ).await;
    
    // Expected: Should return error instead of panicking
    assert!(result.is_err());
}
```

## Notes
This is a client-side input validation vulnerability rather than a blockchain protocol issue. While it can cause denial of service for applications using the SDK, it does not affect the Aptos blockchain's consensus, state integrity, or validator operations. The vulnerability demonstrates the importance of defensive programming when handling untrusted network data, even in client libraries.

### Citations

**File:** crates/aptos-rest-client/src/faucet.rs (L18-20)
```rust
    pub fn new(faucet_url: Url, rest_url: Url) -> Self {
        Self::new_from_rest_client(faucet_url, Client::new(rest_url))
    }
```

**File:** crates/aptos-rest-client/src/faucet.rs (L71-73)
```rust
        let bytes = hex::decode(body).map_err(FaucetClientError::decode)?;
        let txns: Vec<SignedTransaction> =
            bcs::from_bytes(&bytes).map_err(FaucetClientError::decode)?;
```

**File:** crates/aptos-rest-client/src/faucet.rs (L75-77)
```rust
        self.rest_client
            .wait_for_signed_transaction(&txns[0])
            .await
```

**File:** crates/aptos-rest-client/src/faucet.rs (L99-101)
```rust
        let bytes = hex::decode(body).map_err(FaucetClientError::decode)?;
        let txns: Vec<SignedTransaction> =
            bcs::from_bytes(&bytes).map_err(FaucetClientError::decode)?;
```

**File:** crates/aptos-rest-client/src/faucet.rs (L103-105)
```rust
        self.rest_client
            .wait_for_signed_transaction(&txns[0])
            .await
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L426-428)
```rust
        if check_only {
            return Ok(vec![]);
        }
```
