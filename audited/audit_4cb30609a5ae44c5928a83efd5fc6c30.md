# Audit Report

## Title
Indexer-gRPC Cache Operator Missing Empty Vector Validation Leads to Invalid Transaction Deserialization

## Summary
The cache operator's `get_transactions_with_durations` and `batch_get_encoded_proto_data_with_length` methods fail to validate that Redis `mget` responses contain non-empty byte vectors before deserialization. When Redis returns empty vectors for missing keys, the code either creates invalid Transaction objects with default values (Base64UncompressedProto format) or panics during LZ4 decompression (Lz4CompressedProto format), causing data corruption or service crashes in the indexer-gRPC API.

## Finding Description

When the cache operator retrieves transaction data from Redis, it uses `mget` to fetch multiple keys at once. Redis returns an empty `Vec<u8>` for keys that don't exist (due to eviction, race conditions, or cache misses). The code at lines 384-388 processes these results without checking if the byte vectors are empty: [1](#0-0) 

This pattern appears in two functions: [2](#0-1) [3](#0-2) 

The `CacheEntry::new()` method simply wraps the bytes without validation: [4](#0-3) 

When `into_transaction()` is called on an empty vector: [5](#0-4) 

**For Base64UncompressedProto format:**
- `base64::decode(&[])` succeeds and returns empty vector
- `Transaction::decode(&[])` succeeds per protobuf v3 spec, returning a Transaction with default values (version=0, timestamp=None, all fields default)
- This semantically invalid transaction is added to the results
- The `ensure!` check passes because it only validates length, not transaction validity

**For Lz4CompressedProto format:**
- `Decoder::new(&[])` fails because LZ4 expects a valid header
- The `.expect()` call panics with "Lz4 decompression failed"
- The entire indexer-gRPC service crashes

The codebase shows the correct pattern in `in_memory_cache.rs` which explicitly checks for empty vectors: [6](#0-5) 

## Impact Explanation

**Severity: High** - API crashes and data integrity violations

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program because it causes:

1. **API crashes**: When using Lz4CompressedProto format (the default with compression enabled per the cache worker configuration), empty vectors cause immediate service panics, resulting in API unavailability. [7](#0-6) 

2. **Data corruption**: When using Base64UncompressedProto format, invalid Transaction objects with version=0 corrupt the indexer data stream, breaking downstream processing that expects sequential, valid transactions.

The vulnerability affects the indexer-gRPC data service which is a critical API component serving transaction data to indexer clients and downstream applications.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can be triggered through several realistic scenarios:

1. **Active cache eviction**: The system actively evicts old cache entries. If a read occurs during/after eviction but before the coverage status check, empty vectors are returned. [8](#0-7) 

2. **Race conditions**: Between `check_cache_coverage_status` and the actual `mget`, keys can be evicted, leading to empty vectors.

3. **Redis connection issues**: Transient Redis failures or network issues can result in partial data loss where some keys return empty.

4. **High load scenarios**: During periods of high transaction throughput, cache misses and evictions become more frequent, increasing the probability of encountering empty vectors.

The vulnerability is exploitable without any privileged access - it occurs naturally during normal operations under load or timing-sensitive conditions.

## Recommendation

Add explicit validation for empty vectors before deserialization, matching the pattern used in `in_memory_cache.rs`:

```rust
pub async fn get_transactions_with_durations(
    &mut self,
    start_version: u64,
    transaction_count: u64,
) -> anyhow::Result<(Vec<Transaction>, f64, f64)> {
    let start_time = std::time::Instant::now();
    let versions = (start_version..start_version + transaction_count)
        .map(|e| CacheEntry::build_key(e, self.storage_format))
        .collect::<Vec<String>>();
    let encoded_transactions: Vec<Vec<u8>> = self
        .conn
        .mget(versions)
        .await
        .context("Failed to mget from Redis")?;
    
    // ADD THIS VALIDATION
    if encoded_transactions.iter().any(|v| v.is_empty()) {
        return Err(anyhow::anyhow!(
            "Failed to fetch all transactions from cache. Some keys returned empty vectors."
        ));
    }
    
    let io_duration = start_time.elapsed().as_secs_f64();
    let start_time = std::time::Instant::now();
    let mut transactions = vec![];
    for encoded_transaction in encoded_transactions {
        let cache_entry: CacheEntry = CacheEntry::new(encoded_transaction, self.storage_format);
        let transaction = cache_entry.into_transaction();
        transactions.push(transaction);
    }
    ensure!(
        transactions.len() == transaction_count as usize,
        "Failed to get all transactions from cache."
    );
    let decoding_duration = start_time.elapsed().as_secs_f64();
    Ok((transactions, io_duration, decoding_duration))
}
```

Apply the same fix to `batch_get_encoded_proto_data_with_length` at line 239.

## Proof of Concept

```rust
#[cfg(test)]
mod test_empty_vector_handling {
    use super::*;
    use redis_test::{MockCmd, MockRedisConnection};
    
    #[tokio::test]
    #[should_panic(expected = "proto deserialization failed")]
    async fn test_empty_vector_base64_format() {
        // Simulate Redis returning empty vector for missing key
        let cmds = vec![MockCmd::new(
            redis::cmd("MGET").arg("1").arg("2"),
            Ok(vec![vec![1, 2, 3], vec![]]), // Second key returns empty
        )];
        let mock_connection = MockRedisConnection::new(cmds);
        let mut cache_operator: CacheOperator<MockRedisConnection> =
            CacheOperator::new(mock_connection, StorageFormat::Base64UncompressedProto);
        
        // This should fail but currently creates invalid Transaction
        let result = cache_operator
            .get_transactions_with_durations(1, 2)
            .await;
        
        // With the bug, this would succeed with invalid transaction
        // After fix, this should return an error
    }
    
    #[tokio::test]
    #[should_panic(expected = "Lz4 decompression failed")]
    async fn test_empty_vector_lz4_format_panics() {
        // Simulate Redis returning empty vector for missing key
        let cmds = vec![MockCmd::new(
            redis::cmd("MGET").arg("l4:1"),
            Ok(vec![vec![]]), // Empty vector
        )];
        let mock_connection = MockRedisConnection::new(cmds);
        let mut cache_operator: CacheOperator<MockRedisConnection> =
            CacheOperator::new(mock_connection, StorageFormat::Lz4CompressedProto);
        
        // This panics with "Lz4 decompression failed"
        let _ = cache_operator
            .get_transactions_with_durations(1, 1)
            .await;
    }
}
```

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L221-250)
```rust
    /// Fail if not all transactions requested are returned
    pub async fn batch_get_encoded_proto_data_with_length(
        &mut self,
        start_version: u64,
        transaction_count: u64,
    ) -> anyhow::Result<(Vec<Transaction>, f64, f64)> {
        let start_time = std::time::Instant::now();
        let versions = (start_version..start_version + transaction_count)
            .map(|e| CacheEntry::build_key(e, self.storage_format).to_string())
            .collect::<Vec<String>>();
        let encoded_transactions: Vec<Vec<u8>> = self
            .conn
            .mget(versions)
            .await
            .context("Failed to mget from Redis")?;
        let io_duration = start_time.elapsed().as_secs_f64();
        let start_time = std::time::Instant::now();
        let mut transactions = vec![];
        for encoded_transaction in encoded_transactions {
            let cache_entry: CacheEntry = CacheEntry::new(encoded_transaction, self.storage_format);
            let transaction = cache_entry.into_transaction();
            transactions.push(transaction);
        }
        ensure!(
            transactions.len() == transaction_count as usize,
            "Failed to get all transactions from cache."
        );
        let decoding_duration = start_time.elapsed().as_secs_f64();
        Ok((transactions, io_duration, decoding_duration))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L282-289)
```rust
            if version >= CACHE_SIZE_EVICTION_LOWER_BOUND {
                let key = CacheEntry::build_key(
                    version - CACHE_SIZE_EVICTION_LOWER_BOUND,
                    self.storage_format,
                )
                .to_string();
                redis_pipeline.cmd("DEL").arg(key).ignore();
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L367-395)
```rust
    pub async fn get_transactions_with_durations(
        &mut self,
        start_version: u64,
        transaction_count: u64,
    ) -> anyhow::Result<(Vec<Transaction>, f64, f64)> {
        let start_time = std::time::Instant::now();
        let versions = (start_version..start_version + transaction_count)
            .map(|e| CacheEntry::build_key(e, self.storage_format))
            .collect::<Vec<String>>();
        let encoded_transactions: Vec<Vec<u8>> = self
            .conn
            .mget(versions)
            .await
            .context("Failed to mget from Redis")?;
        let io_duration = start_time.elapsed().as_secs_f64();
        let start_time = std::time::Instant::now();
        let mut transactions = vec![];
        for encoded_transaction in encoded_transactions {
            let cache_entry: CacheEntry = CacheEntry::new(encoded_transaction, self.storage_format);
            let transaction = cache_entry.into_transaction();
            transactions.push(transaction);
        }
        ensure!(
            transactions.len() == transaction_count as usize,
            "Failed to get all transactions from cache."
        );
        let decoding_duration = start_time.elapsed().as_secs_f64();
        Ok((transactions, io_duration, decoding_duration))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/compression_util.rs (L75-84)
```rust
    pub fn new(bytes: Vec<u8>, storage_format: StorageFormat) -> Self {
        match storage_format {
            StorageFormat::Lz4CompressedProto => Self::Lz4CompressionProto(bytes),
            // Legacy format.
            StorageFormat::Base64UncompressedProto => Self::Base64UncompressedProto(bytes),
            StorageFormat::JsonBase64UncompressedProto => {
                panic!("JsonBase64UncompressedProto is not supported.")
            },
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/compression_util.rs (L142-157)
```rust
    pub fn into_transaction(self) -> Transaction {
        match self {
            CacheEntry::Lz4CompressionProto(bytes) => {
                let mut decompressor = Decoder::new(&bytes[..]).expect("Lz4 decompression failed.");
                let mut decompressed = Vec::new();
                decompressor
                    .read_to_end(&mut decompressed)
                    .expect("Lz4 decompression failed.");
                Transaction::decode(decompressed.as_slice()).expect("proto deserialization failed.")
            },
            CacheEntry::Base64UncompressedProto(bytes) => {
                let bytes: Vec<u8> = base64::decode(bytes).expect("base64 decoding failed.");
                Transaction::decode(bytes.as_slice()).expect("proto deserialization failed.")
            },
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/in_memory_cache.rs (L357-364)
```rust
            let values = conn.mget::<Vec<String>, Vec<Vec<u8>>>(keys).await?;
            // If any of the values are empty, we return an error.
            if values.iter().any(|v| v.is_empty()) {
                return Err(anyhow::anyhow!(format!(
                    "Failed to fetch all the keys; fetch size {}",
                    values.len()
                )));
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L79-83)
```rust
        let cache_storage_format = if enable_cache_compression {
            StorageFormat::Lz4CompressedProto
        } else {
            StorageFormat::Base64UncompressedProto
        };
```
