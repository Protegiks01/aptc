# Audit Report

## Title
Block Gas Limit Bypass via Payload Version Mismatch Allowing Consensus Divergence

## Summary
The `PrepareResult` type's `Option<u64>` block gas limit field can be `None` when it should contain a value, allowing validators to bypass per-block gas limit enforcement by using legacy `QuorumStoreInlineHybrid` (V1) payloads even when the network expects V2 payloads with gas limits. This causes downstream code to fall back to global on-chain limits, breaking the "Resource Limits" invariant and potentially causing consensus divergence. [1](#0-0) 

## Finding Description
The vulnerability exists in the payload transformation logic where block gas limits are silently discarded for V1 payloads. When `transform_to_quorum_store_v2()` is called on a `QuorumStoreInlineHybrid` payload, it receives the `block_gas_limit_override` parameter but only sets the transaction limit, completely ignoring the gas limit: [2](#0-1) 

In contrast, the V2 variant correctly preserves both limits: [3](#0-2) 

This `None` value propagates through the execution pipeline:

1. The payload manager returns `None` for gas_limit() on V1 payloads: [4](#0-3) 

2. The `PrepareResult` contains `None`: [5](#0-4) 

3. The executor uses this to override the config: [6](#0-5) 

4. When `enable_per_block_gas_limit = true`, the system expects per-block limits but the override is `None`: [7](#0-6) 

5. The gas limit processor falls back to the global on-chain limit: [8](#0-7) 

**Attack Scenario**: During a network upgrade when `enable_per_block_gas_limit` is activated but some validators still use `enable_payload_v2 = false`, a malicious validator can:
1. Propose blocks using V1 payloads that don't include gas limits
2. Include more transactions than the intended per-block gas limit allows
3. Different validators execute with different gas limits (per-block vs global)
4. This causes state root divergence and consensus failure

The code explicitly acknowledges this is unfinished: [9](#0-8) 

## Impact Explanation
**High Severity** - This vulnerability breaks the "Deterministic Execution" critical invariant (#1) and "Resource Limits" invariant (#9):

1. **Consensus Divergence**: Validators with different payload version settings will compute different gas limits for identical blocks, potentially producing different state roots and breaking consensus safety.

2. **Gas Limit Bypass**: Malicious validators can exceed intended per-block gas limits by 100%+ of the allowed amount, as they can use the global on-chain limit which may be significantly higher than per-block restrictions.

3. **Upgrade Vulnerability**: During feature activation periods when `enable_per_block_gas_limit` transitions from false to true, the network is vulnerable to inconsistent block execution.

This meets the **High Severity** criteria per Aptos bug bounty: "Significant protocol violations" that can cause validator node divergence and potential network splits.

## Likelihood Explanation
**High Likelihood** during network upgrades:

1. The `enable_payload_v2` flag controls payload format at the validator level, not network-wide [10](#0-9) 

2. No validation enforces that V2 payloads must be used when `enable_per_block_gas_limit = true`

3. Payloads are created with `None` for gas limits initially and rely on transformation: [11](#0-10) 

4. The transformation silently drops gas limits for V1 payloads without error or warning

## Recommendation
Implement strict validation to ensure payload version compatibility with enabled features:

**1. Add validation in proposal acceptance:**
```rust
// In consensus block verification
if onchain_config.enable_per_block_gas_limit() {
    match payload {
        Payload::QuorumStoreInlineHybrid(_, _, gas_limit) => {
            ensure!(gas_limit.is_some(), 
                "Block gas limit required when enable_per_block_gas_limit is active");
        },
        Payload::QuorumStoreInlineHybridV2(_, _, PayloadExecutionLimit::None) => {
            ensure!(false, 
                "Execution limits required when enable_per_block_gas_limit is active");
        },
        _ => {}
    }
}
```

**2. Fix transform_to_quorum_store_v2 to preserve gas limits:**
```rust
Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _) => {
    // Upgrade to V2 when gas limit is provided
    if block_gas_limit_override.is_some() {
        Payload::QuorumStoreInlineHybridV2(
            inline_batches,
            proof_with_data,
            PayloadExecutionLimit::TxnAndGasLimits(TxnAndGasLimits {
                transaction_limit: max_txns_to_execute,
                gas_limit: block_gas_limit_override,
            }),
        )
    } else {
        Payload::QuorumStoreInlineHybrid(
            inline_batches,
            proof_with_data,
            max_txns_to_execute,
        )
    }
}
```

**3. Implement the TODO validation:** [9](#0-8) 

## Proof of Concept
```rust
// Reproduction steps showing the vulnerability:

// 1. Network has enable_per_block_gas_limit = true
let onchain_config = BlockExecutorConfigFromOnchain::new(
    BlockGasLimitType::Limit(10000),
    true,  // enable_per_block_gas_limit = true
    None,
);

// 2. Malicious validator uses enable_payload_v2 = false
let enable_payload_v2 = false;

// 3. Create payload with gas limit intended
let mut payload = if enable_payload_v2 {
    Payload::QuorumStoreInlineHybridV2(vec![], ProofWithData::new(vec![]), PayloadExecutionLimit::None)
} else {
    Payload::QuorumStoreInlineHybrid(vec![], ProofWithData::new(vec![]), None)
};

// 4. Transform with block_gas_limit_override = Some(5000)
payload = payload.transform_to_quorum_store_v2(Some(100), Some(5000));

// 5. For V1 payload, gas limit is lost:
match payload {
    Payload::QuorumStoreInlineHybrid(_, _, limit) => {
        assert_eq!(limit, Some(100));  // Only transaction limit preserved
        // Gas limit of 5000 was silently discarded!
    },
    _ => {}
}

// 6. During execution, PrepareResult will have None for gas limit
// 7. BlockGasLimitProcessor falls back to global limit (10000)
// 8. Validator can include double the intended gas (10000 vs 5000)
// 9. Other validators using V2 payloads enforce 5000 limit
// 10. State divergence occurs -> Consensus failure
```

**Notes**
This vulnerability is particularly dangerous because it's silent - there are no errors or warnings when gas limits are dropped for V1 payloads. The system appears to function normally while violating the intended per-block gas limit constraints. The TODO comment at line 697 confirms this validation gap is known but unimplemented.

### Citations

**File:** consensus/consensus-types/src/pipelined_block.rs (L73-73)
```rust
pub type PrepareResult = (Arc<Vec<SignatureVerifiedTransaction>>, Option<u64>);
```

**File:** consensus/consensus-types/src/common.rs (L236-242)
```rust
            Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _) => {
                Payload::QuorumStoreInlineHybrid(
                    inline_batches,
                    proof_with_data,
                    max_txns_to_execute,
                )
            },
```

**File:** consensus/consensus-types/src/common.rs (L258-267)
```rust
            Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _) => {
                Payload::QuorumStoreInlineHybridV2(
                    inline_batches,
                    proof_with_data,
                    PayloadExecutionLimit::TxnAndGasLimits(TxnAndGasLimits {
                        transaction_limit: max_txns_to_execute,
                        gas_limit: block_gas_limit_override,
                    }),
                )
            },
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L605-613)
```rust
    pub fn gas_limit(&self) -> Option<u64> {
        match self {
            BlockTransactionPayload::DeprecatedInQuorumStore(_)
            | BlockTransactionPayload::DeprecatedInQuorumStoreWithLimit(_)
            | BlockTransactionPayload::QuorumStoreInlineHybrid(_, _) => None,
            BlockTransactionPayload::QuorumStoreInlineHybridV2(payload, _)
            | BlockTransactionPayload::OptQuorumStore(payload, _) => payload.gas_limit(),
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L697-697)
```rust
                // TODO: verify the block gas limit?
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L680-680)
```rust
        Ok((Arc::new(sig_verified_txns), block_gas_limit))
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L799-801)
```rust
        let (user_txns, block_gas_limit) = prepare_fut.await?;
        let onchain_execution_config =
            onchain_execution_config.with_block_gas_limit_override(block_gas_limit);
```

**File:** types/src/block_executor/config.rs (L155-161)
```rust
    pub fn block_gas_limit_override(&self) -> Option<u64> {
        if self.enable_per_block_gas_limit {
            self.per_block_gas_limit
        } else {
            None
        }
    }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L119-125)
```rust
    fn block_gas_limit(&self) -> Option<u64> {
        if self.block_gas_limit_override.is_some() {
            self.block_gas_limit_override
        } else {
            self.block_gas_limit_type.block_gas_limit()
        }
    }
```

**File:** consensus/src/quorum_store/proof_manager.rs (L222-234)
```rust
            if self.enable_payload_v2 {
                Payload::QuorumStoreInlineHybridV2(
                    inline_block,
                    ProofWithData::new(proof_block),
                    PayloadExecutionLimit::None,
                )
            } else {
                Payload::QuorumStoreInlineHybrid(
                    inline_block,
                    ProofWithData::new(proof_block),
                    None,
                )
            }
```

**File:** consensus/src/liveness/proposal_generator.rs (L678-684)
```rust
            payload = payload.transform_to_quorum_store_v2(
                max_txns_from_block_to_execute,
                block_gas_limit_override,
            );
        } else if block_gas_limit_override.is_some() {
            payload = payload.transform_to_quorum_store_v2(None, block_gas_limit_override);
        }
```
