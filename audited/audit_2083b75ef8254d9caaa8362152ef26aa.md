# Audit Report

## Title
Redis Credential Exposure in Indexer GRPC Services Through Logging and Error Handling

## Summary
The `RedisUrl` type and its usage across the indexer-grpc services (file-store, cache-worker, data-service) exposes Redis credentials through multiple vectors: direct stdout logging during normal operation, error context messages when connection fails, Debug trait implementations, and potential crash dumps. Redis URLs can contain credentials in the standard format `redis://username:password@host:port/db`, and these are not redacted when logged or displayed.

## Finding Description
The vulnerability exists across three related issues:

**1. Direct Stdout Logging (CRITICAL)**: The data-service prints the Redis URL directly to stdout during startup: [1](#0-0) 

**2. Error Context Exposure (HIGH)**: When Redis connection fails, the full URL including credentials is included in error context messages that get logged: [2](#0-1) [3](#0-2) 

**3. Debug Trait Exposure (HIGH)**: The `RedisUrl` type derives `Debug` and implements `Display` without credential redaction: [4](#0-3) [5](#0-4) 

All configuration structs derive `Debug`, meaning any logging or panic will expose credentials: [6](#0-5) 

**Attack Scenarios**:
1. Attacker gains read access to application logs (common in cloud environments with centralized logging)
2. Attacker triggers Redis connection failure through network manipulation or firewall rules
3. Attacker causes service panic and retrieves crash dumps from monitoring systems
4. Developer accidentally logs configuration during debugging
5. CI/CD pipelines or deployment logs capture stdout containing credentials

If Redis is compromised, an attacker can:
- Manipulate cached transaction data served to users
- Cause denial of service by corrupting cache state
- Inject false blockchain data into the indexer pipeline

## Impact Explanation
This is **HIGH severity** according to Aptos bug bounty criteria:
- "API crashes" - Compromised Redis can crash the indexer services
- "Significant protocol violations" - Serving corrupted blockchain data violates data integrity guarantees

While the indexer infrastructure is off-chain and doesn't directly affect consensus or blockchain state, it's a critical component that users rely on for accessing blockchain data. Compromise could lead to widespread misinformation about blockchain state.

## Likelihood Explanation
**Very High Likelihood**: 
- Stdout logging happens on every service startup (100% exposure rate)
- Redis connection errors are common during deployments, network issues, or Redis restarts
- Cloud environments routinely collect and centralize logs from multiple sources
- Credential exposure is permanent once logged (credentials remain in log archives)

## Recommendation

**1. Implement credential redaction in `RedisUrl` type**:

```rust
use std::fmt::{Display, Formatter};

impl Display for RedisUrl {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        // Redact credentials from URL
        let mut sanitized = self.0.clone();
        if sanitized.password().is_some() {
            let _ = sanitized.set_password(Some("***REDACTED***"));
        }
        if sanitized.username() != "" {
            let _ = sanitized.set_username("***REDACTED***");
        }
        write!(f, "{}", sanitized)
    }
}

impl std::fmt::Debug for RedisUrl {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "RedisUrl({})", self) // Uses Display impl above
    }
}
```

**2. Remove direct stdout logging**:

Remove or sanitize the println statement in `config.rs`:
```rust
// Remove line 162-164, or use sanitized version:
tracing::info!("Starting Redis connection to redacted address");
```

**3. Use sanitized URLs in error contexts**:

```rust
let sanitized_url = format!("{}", redis_main_instance_address); // Uses redacted Display
let conn = redis::Client::open(redis_main_instance_address.0.clone())
    .with_context(|| {
        format!("Create redis client for {} failed", sanitized_url)
    })?
```

**4. Consider using Rust's `secrestr` or similar crates** for handling sensitive strings that automatically redact themselves in logs.

## Proof of Concept

```rust
#[cfg(test)]
mod credential_exposure_poc {
    use url::Url;
    
    #[test]
    fn test_redis_url_exposes_credentials() {
        // Simulate Redis URL with credentials
        let redis_url = Url::parse("redis://admin:secretpass123@localhost:6379/0").unwrap();
        
        // This would expose credentials in logs
        let debug_output = format!("{:?}", redis_url);
        let display_output = format!("{}", redis_url);
        
        // Verify credentials are present in output
        assert!(debug_output.contains("admin"));
        assert!(debug_output.contains("secretpass123"));
        assert!(display_output.contains("admin"));
        assert!(display_output.contains("secretpass123"));
        
        println!("Debug: {}", debug_output);
        println!("Display: {}", display_output);
        // Both would log: redis://admin:secretpass123@localhost:6379/0
    }
    
    #[test]
    fn test_error_context_exposure() {
        use anyhow::Context;
        
        let redis_url = "redis://admin:secretpass123@localhost:6379/0";
        
        // Simulate connection failure
        let result: Result<(), anyhow::Error> = Err(anyhow::anyhow!("Connection refused"))
            .with_context(|| {
                format!("Failed to connect to Redis at {}", redis_url)
            });
        
        // Error message contains credentials
        let error_msg = format!("{:?}", result.err().unwrap());
        assert!(error_msg.contains("secretpass123"));
        println!("Error would be logged as: {}", error_msg);
    }
}
```

## Notes

**Important Clarification**: This vulnerability affects the **indexer-grpc infrastructure**, which is an off-chain data serving layer, NOT the core blockchain protocol (consensus, execution, or state management). While compromising the indexer's Redis instance would not directly affect the blockchain's consensus or state integrity, it represents a significant security risk for the data serving infrastructure that applications depend on.

The indexer services are critical for ecosystem health as they provide the primary mechanism for applications to access historical blockchain data efficiently.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L162-165)
```rust
        println!(
            ">>>> Starting Redis connection: {:?}",
            &self.redis_read_replica_address.0
        );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/processor.rs (L44-58)
```rust
        let conn = redis::Client::open(redis_main_instance_address.0.clone())
            .with_context(|| {
                format!(
                    "Create redis client for {} failed",
                    redis_main_instance_address.0
                )
            })?
            .get_tokio_connection_manager()
            .await
            .with_context(|| {
                format!(
                    "Create redis connection to {} failed.",
                    redis_main_instance_address.0
                )
            })?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L84-90)
```rust
        let redis_client = redis::Client::open(redis_main_instance_address.0.clone())
            .with_context(|| {
                format!(
                    "[Indexer Cache] Failed to create redis client for {}",
                    redis_main_instance_address
                )
            })?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/types.rs (L13-14)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize)]
pub struct RedisUrl(pub Url);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/types.rs (L58-61)
```rust
impl Display for RedisUrl {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/lib.rs (L13-22)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcFileStoreWorkerConfig {
    pub file_store_config: IndexerGrpcFileStoreConfig,
    pub redis_main_instance_address: RedisUrl,
    pub enable_expensive_logging: Option<bool>,
    pub chain_id: u64,
    #[serde(default = "default_enable_cache_compression")]
    pub enable_cache_compression: bool,
}
```
