# Audit Report

## Title
Non-Deterministic Layout Validation in Change Set Squashing Breaks Consensus Safety

## Summary
The `randomly_check_layout_matches()` function uses non-deterministic random sampling (1% probability) to validate type layout consistency during change set squashing. When layout mismatches occur, different validators produce different outcomes based on their independent random number generation, directly violating the deterministic execution invariant and causing consensus failures.

## Finding Description

The `randomly_check_layout_matches()` function in `change_set.rs` is designed to validate that type layouts match during change set operations. However, the implementation uses `rand::thread_rng().gen_range(0, 100)` to perform validation only 1% of the time as a performance optimization. [1](#0-0) 

This function is called during `squash_additional_resource_writes()` when merging two `WriteWithDelayedFields` operations for the same state key: [2](#0-1) 

**The Critical Flaw:**

Each validator executes transactions independently and generates their own random number. When a layout mismatch exists (whether from a VM bug, cache inconsistency, or other cause):

1. **Validator A** generates random_number = 1 → detects mismatch → returns error → transaction fails
2. **Validator B** generates random_number = 50 → skips check → continues → transaction succeeds  
3. **Validator C** generates random_number = 99 → skips check → continues → transaction succeeds

This produces **different transaction outcomes across validators** for identical inputs, directly violating Aptos's deterministic execution invariant.

The squashed change sets are later used during delayed field materialization: [3](#0-2) 

If mismatched layouts pass through the random check, the materialization process will deserialize using the wrong layout, potentially causing:
- Deserialization failures (transaction fails on some validators, succeeds on others)
- Incorrect value interpretation (silent data corruption)
- State divergence across the network

## Impact Explanation

**Critical Severity - Consensus/Safety Violation**

This vulnerability directly breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

The non-deterministic behavior causes:

1. **Consensus Splits**: Different validators produce different state roots for the same block, preventing consensus from being reached
2. **Network Partition**: The network fragments into groups that validated the transaction differently, requiring manual intervention or hard fork to recover
3. **State Divergence**: Even if consensus is temporarily maintained through luck, accumulated state differences eventually cause irrecoverable inconsistencies

The vulnerability acts as a **bug amplifier** - any condition that causes layout mismatches (VM bugs, race conditions, cache issues) is immediately elevated from a potential correctness issue to a guaranteed consensus failure.

This meets the Critical Severity category: "Non-recoverable network partition (requires hardfork)" and "Consensus/Safety violations."

## Likelihood Explanation

**Likelihood: Medium-High**

The trigger condition requires layout mismatches during change set squashing. While layouts should theoretically always match for the same type, several scenarios could cause mismatches:

1. **Layout cache inconsistencies** - The VM uses caching for layouts when `enable_layout_caches` is true [4](#0-3) 

2. **Concurrent module upgrades** - Race conditions during module loading/upgrades

3. **VM configuration drift** - Delayed field optimization settings differing between code paths

4. **Future VM bugs** - Any bug in layout generation immediately becomes a consensus vulnerability

The function is called in critical paths including:
- Transaction output generation in respawned sessions [5](#0-4) 

- Resource group operations [6](#0-5) 

- Block executor materialization [7](#0-6) 

## Recommendation

**Replace non-deterministic random check with deterministic validation:**

```rust
/// Checks if the given two input type layouts match.
pub fn check_layout_matches(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
) -> Result<(), PanicError> {
    if layout_1.is_some() != layout_2.is_some() {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    if layout_1.is_some() && layout_1 != layout_2 {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    Ok(())
}
```

**If performance is a concern**, use one of these deterministic alternatives:

1. **Hash-based sampling**: Use a deterministic hash of the layouts to decide whether to check
2. **Periodic checking**: Check every Nth transaction based on transaction index (deterministic)
3. **Lazy validation**: Validate only when materializing delayed fields (where errors are already expected)
4. **Memoization**: Cache layout comparison results by layout pointer pairs

The current approach saves computation but sacrifices consensus safety - an unacceptable trade-off for blockchain systems.

## Proof of Concept

This PoC demonstrates the non-deterministic behavior:

```rust
use aptos_vm_types::change_set::randomly_check_layout_matches;
use move_core_types::value::MoveTypeLayout;
use std::sync::atomic::{AtomicU32, Ordering};

#[test]
fn test_non_deterministic_layout_check() {
    // Create two intentionally different layouts
    let layout1 = MoveTypeLayout::U64;
    let layout2 = MoveTypeLayout::U128;
    
    let pass_count = AtomicU32::new(0);
    let fail_count = AtomicU32::new(0);
    
    // Simulate 100 validators checking the same mismatched layouts
    for _ in 0..100 {
        match randomly_check_layout_matches(Some(&layout1), Some(&layout2)) {
            Ok(_) => pass_count.fetch_add(1, Ordering::Relaxed),
            Err(_) => fail_count.fetch_add(1, Ordering::Relaxed),
        };
    }
    
    let passes = pass_count.load(Ordering::Relaxed);
    let fails = fail_count.load(Ordering::Relaxed);
    
    println!("Validators that would accept mismatch: {}", passes);
    println!("Validators that would reject mismatch: {}", fails);
    
    // This demonstrates non-deterministic consensus failure
    // Different validators produce different outcomes for identical input
    assert!(passes > 0 && fails > 0, 
        "Non-deterministic validation causes consensus split");
}
```

**Expected output:** Approximately 99 validators pass the check and 1 validator fails, demonstrating that the same transaction would be accepted by some validators and rejected by others, causing a consensus failure.

## Notes

The comment in the code acknowledges that "layouts are supposed to match" and the check is meant as an optimization. However, in distributed consensus systems, **even sanity checks must be deterministic**. The current implementation prioritizes performance over correctness, violating the fundamental requirement that all validators must produce identical results for identical inputs.

This vulnerability is particularly insidious because it may remain dormant until triggered by unrelated VM bugs or race conditions, at which point it immediately escalates into a network-wide consensus failure requiring emergency intervention.

### Citations

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L48-74)
```rust
/// Sporadically checks if the given two input type layouts match.
pub fn randomly_check_layout_matches(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
) -> Result<(), PanicError> {
    if layout_1.is_some() != layout_2.is_some() {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    if layout_1.is_some() {
        // Checking if 2 layouts are equal is a recursive operation and is expensive.
        // We generally call this `randomly_check_layout_matches` function when we know
        // that the layouts are supposed to match. As an optimization, we only randomly
        // check if the layouts are matching.
        let mut rng = rand::thread_rng();
        let random_number: u32 = rng.gen_range(0, 100);
        if random_number == 1 && layout_1 != layout_2 {
            return Err(code_invariant_error(format!(
                "Layouts don't match when they are expected to: {:?} and {:?}",
                layout_1, layout_2
            )));
        }
    }
    Ok(())
}
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L576-598)
```rust
                        (
                            WriteWithDelayedFields(WriteWithDelayedFieldsOp {
                                write_op,
                                layout,
                                materialized_size,
                            }),
                            WriteWithDelayedFields(WriteWithDelayedFieldsOp {
                                write_op: additional_write_op,
                                layout: additional_layout,
                                materialized_size: additional_materialized_size,
                            }),
                        ) => {
                            randomly_check_layout_matches(Some(layout), Some(additional_layout))?;
                            let to_delete = !WriteOp::squash(write_op, additional_write_op.clone())
                                .map_err(|e| {
                                    code_invariant_error(format!(
                                        "Error while squashing two write ops: {}.",
                                        e
                                    ))
                                })?;
                            *materialized_size = *additional_materialized_size;
                            (to_delete, false)
                        },
```

**File:** aptos-move/block-executor/src/view.rs (L1269-1325)
```rust
    pub(crate) fn replace_identifiers_with_values(
        &self,
        bytes: &Bytes,
        layout: &MoveTypeLayout,
    ) -> anyhow::Result<(Bytes, HashSet<DelayedFieldID>)> {
        // Cfg due to deserialize_to_delayed_field_id use.
        #[cfg(test)]
        fail_point!("delayed_field_test", |_| {
            assert_eq!(
                layout,
                &mock_layout(),
                "Layout does not match expected mock layout"
            );

            // Replicate the logic of identifier_to_value.
            let (delayed_field_id, txn_idx) = deserialize_to_delayed_field_id(bytes)
                .expect("Mock deserialization failed in delayed field test.");
            let delayed_field = match &self.latest_view {
                ViewState::Sync(state) => state
                    .versioned_map
                    .delayed_fields()
                    .read_latest_predicted_value(
                        &delayed_field_id,
                        self.txn_idx,
                        ReadPosition::AfterCurrentTxn,
                    )
                    .expect("Committed value for ID must always exist"),
                ViewState::Unsync(state) => state
                    .read_delayed_field(delayed_field_id)
                    .expect("Delayed field value for ID must always exist in sequential execution"),
            };

            // Note: Test correctness relies on the fact that current proptests use the
            // same layout for all values ever stored at any key, given that some value
            // at the key contains a delayed field.
            Ok((
                serialize_from_delayed_field_u128(
                    delayed_field.into_aggregator_value().unwrap(),
                    txn_idx,
                ),
                HashSet::from([delayed_field_id]),
            ))
        });

        // This call will replace all occurrences of aggregator / snapshot
        // identifiers with values with the same type layout.
        let function_value_extension = self.as_function_value_extension();
        let value = ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
            .with_func_args_deserialization(&function_value_extension)
            .with_delayed_fields_serde()
            .deserialize(bytes, layout)
            .ok_or_else(|| {
                anyhow::anyhow!(
                    "Failed to deserialize resource during id replacement: {:?}",
                    bytes
                )
            })?;
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L88-130)
```rust
        let ty_pool = self.runtime_environment().ty_pool();
        if self.vm_config().enable_layout_caches {
            let key = match ty {
                Type::Struct { idx, .. } => {
                    let ty_args_id = ty_pool.intern_ty_args(&[]);
                    Some(StructKey {
                        idx: *idx,
                        ty_args_id,
                    })
                },
                Type::StructInstantiation { idx, ty_args, .. } => {
                    let ty_args_id = ty_pool.intern_ty_args(ty_args);
                    Some(StructKey {
                        idx: *idx,
                        ty_args_id,
                    })
                },
                _ => None,
            };

            if let Some(key) = key {
                if let Some(result) = self.struct_definition_loader.load_layout_from_cache(
                    gas_meter,
                    traversal_context,
                    &key,
                ) {
                    return result;
                }

                // Otherwise a cache miss, compute the result and store it.
                let mut modules = DefiningModules::new();
                let layout = self.type_to_type_layout_with_delayed_fields_impl::<false>(
                    gas_meter,
                    traversal_context,
                    &mut modules,
                    ty,
                    check_option_type,
                )?;
                let cache_entry = LayoutCacheEntry::new(layout.clone(), modules);
                self.struct_definition_loader
                    .store_layout_to_cache(&key, cache_entry)?;
                return Ok(layout);
            }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/respawned_session.rs (L99-108)
```rust
        let mut change_set = self.into_heads().executor_view.change_set;
        change_set
            .squash_additional_change_set(additional_change_set)
            .map_err(|_err| {
                VMStatus::error(
                    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                    err_msg("Failed to squash VMChangeSet"),
                )
            })?;
        Ok(change_set)
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/view_with_change_set.rs (L329-332)
```rust
                |(write_op, layout)| {
                    randomly_check_layout_matches(maybe_layout, layout.as_deref())?;
                    Ok(write_op.extract_raw_bytes())
                },
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L63-64)
```rust
	        let (value, existing_layout) = $data_source.fetch_exchanged_data(&key, $($txn_idx),*)?;
            randomly_check_layout_matches(Some(&existing_layout), Some(layout.as_ref()))?;
```
