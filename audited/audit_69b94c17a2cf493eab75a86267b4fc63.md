# Audit Report

## Title
Governance Metadata Hash Mismatch Vulnerability Allows Voter Deception

## Summary
The Aptos governance system does not enforce on-chain verification that `metadata_hash` corresponds to the content at `metadata_location`. This allows malicious proposers to provide mismatched values, potentially deceiving voters about proposal contents while executing different logic.

## Finding Description

The vulnerability exists in the governance proposal creation flow. When a proposal is created via `create_proposal_v2()`, the function accepts both `metadata_location` (a URL to proposal documentation) and `metadata_hash` (supposedly the hash of that documentation) as parameters. [1](#0-0) 

This Rust test helper calls the Move contract function which performs the actual on-chain validation: [2](#0-1) 

The implementation delegates to `create_proposal_v2_impl()`: [3](#0-2) 

At line 437, the metadata is created via `create_proposal_metadata()`, which only validates string lengths: [4](#0-3) 

**Critical Finding:** The function only checks that both strings are valid UTF-8 with length â‰¤ 256 bytes. There is NO cryptographic verification that `metadata_hash` actually equals `sha3_256(content_at_metadata_location)`.

The metadata verification is relegated to off-chain CLI tools: [5](#0-4) [6](#0-5) 

These off-chain tools fetch the content and verify the hash, but usage is voluntary. Voters who skip this verification step can be deceived.

Importantly, during proposal execution, only the `execution_hash` is verified: [7](#0-6) 

The `execution_hash` protects what script executes, but the `metadata` fields are purely informational and never cryptographically validated on-chain.

**Attack Scenario:**
1. Attacker creates proposal with malicious execution script (e.g., "transfer treasury to attacker address")
2. Provides correct `execution_hash` = SHA3-256(malicious_script) 
3. Provides `metadata_location` = URL to benign-looking description ("Increase validator rewards by 2%")
4. Provides `metadata_hash` = SHA3-256(benign_description) OR completely fabricated hash
5. Voters who don't run CLI verification tools see only the benign description at the URL
6. Proposal passes voting based on the deceptive metadata
7. Malicious script executes upon resolution

**Alternative Attack - TOCTOU:**
1. Attacker provides legitimate metadata initially with matching hash
2. Early voters verify and see everything matches
3. AFTER initial verification, attacker changes content at `metadata_location` URL
4. Later voters see different content but hash on-chain remains unchanged
5. Confusion among voters; some may vote based on outdated information

## Impact Explanation

This is **HIGH severity** per Aptos bug bounty criteria as it constitutes a "Significant protocol violation" that undermines governance integrity.

**Potential Impacts:**
- **Governance Manipulation**: Malicious proposals can be approved through voter deception
- **Loss of Funds**: If deceptive proposal transfers treasury funds or mints tokens
- **Protocol Corruption**: Unauthorized changes to consensus parameters, staking rules, or feature flags
- **Validator Set Manipulation**: Malicious proposals could alter the validator set
- **Trust Erosion**: Undermines the entire governance system if voters cannot trust proposal metadata

The vulnerability breaks the fundamental **Governance Integrity** invariant - voters must be able to accurately assess what they're voting for. The current design assumes all voters will manually verify metadata using CLI tools, which is unrealistic.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack is highly feasible because:

1. **Low Technical Barrier**: Attacker only needs sufficient stake to create proposals (no specialized exploits required)
2. **Voluntary Verification**: Many voters likely skip manual hash verification, especially for seemingly routine proposals
3. **Social Engineering Opportunities**: Legitimate proposers with good reputation could be compromised
4. **Time Pressure**: Voters may rush decisions during critical governance windows
5. **TOCTOU Window**: Content can be changed after initial verification but before voting completes

**Mitigating Factors:**
- Sophisticated voters and DAOs may have processes to verify all proposals
- Community discussion off-chain may expose discrepancies
- Execution still requires correct `execution_hash`, so the malicious script itself can be inspected

However, the lack of on-chain enforcement creates systemic risk that should not exist in a production blockchain governance system.

## Recommendation

**Immediate Fix:** Add on-chain verification that `metadata_hash` corresponds to `metadata_location` content. However, this is challenging because:
- Move contracts cannot make HTTP requests
- Fetching external URLs requires oracles or off-chain workers

**Practical Solutions:**

1. **Option A - Require On-Chain Metadata Storage:**
   Store the full proposal metadata on-chain instead of just a URL. This eliminates the mismatch possibility but increases storage costs.

2. **Option B - Oracle-Based Verification:**
   Implement a trusted oracle system that fetches `metadata_location` content, computes its hash, and attests on-chain that it matches `metadata_hash` before voting begins.

3. **Option C - Eliminate Redundant Hash (Recommended):**
   Remove `metadata_hash` parameter entirely. Voters should fetch content from `metadata_location` and compute the hash themselves. Document this as a mandatory voter responsibility.

**Code Fix Example (Option C):**

```move
fun create_proposal_metadata(
    metadata_location: vector<u8>,
): SimpleMap<String, vector<u8>> {
    assert!(string::length(&utf8(metadata_location)) <= 256, error::invalid_argument(EMETADATA_LOCATION_TOO_LONG));
    
    let metadata = simple_map::create<String, vector<u8>>();
    simple_map::add(&mut metadata, utf8(METADATA_LOCATION_KEY), metadata_location);
    // Remove metadata_hash - voters must compute it themselves from fetched content
    metadata
}
```

Update proposal creation to only accept `metadata_location`:

```move
public entry fun create_proposal_v2(
    proposer: &signer,
    stake_pool: address,
    execution_hash: vector<u8>,
    metadata_location: vector<u8>,
    // Remove metadata_hash parameter
    is_multi_step_proposal: bool,
) acquires GovernanceConfig, GovernanceEvents {
    create_proposal_v2_impl(
        proposer,
        stake_pool,
        execution_hash,
        metadata_location,
        is_multi_step_proposal
    );
}
```

**Additional Safeguards:**
- Require minimum voting period (e.g., 7 days) to allow thorough community review
- Implement mandatory proposal review checkpoints where metadata is re-verified
- Add proposal metadata change events to detect TOCTOU attacks
- Develop automated verification tools that community members can run

## Proof of Concept

```move
#[test(proposer = @0x123)]
public entry fun test_metadata_hash_mismatch_vulnerability(proposer: signer) {
    // Setup: Initialize governance with proposer having sufficient stake
    // ... (setup code omitted for brevity)
    
    let stake_pool = signer::address_of(&proposer);
    let execution_hash = vector[1, 2, 3, 4]; // Malicious script hash
    
    // Benign metadata location
    let metadata_location = b"https://example.com/proposal/benign-increase-rewards.json";
    
    // MISMATCHED hash - doesn't correspond to the content at metadata_location
    // This could be hash of completely different content or fabricated
    let fake_metadata_hash = b"0xDEADBEEF1234567890ABCDEF"; // Arbitrary fake hash
    
    // Create proposal with mismatched values - this SUCCEEDS despite mismatch
    aptos_governance::create_proposal_v2(
        &proposer,
        stake_pool,
        execution_hash,
        metadata_location,
        fake_metadata_hash, // MISMATCH: Not the actual hash of content at location
        false,
    );
    
    // Proposal is created successfully without any validation error
    // Voters who don't manually verify will be deceived
    
    // Verification: Fetch content at metadata_location off-chain
    // Expected: Content says "Increase validator rewards by 2%"
    // Compute: actual_hash = sha3_256(fetched_content)
    // Compare: actual_hash != fake_metadata_hash (MISMATCH DETECTED)
    
    // But on-chain, the proposal already exists and can receive votes
    // Voters who skip verification may approve the malicious proposal
}
```

**Notes:**
- The PoC demonstrates that `create_proposal_v2()` accepts mismatched `metadata_hash` and `metadata_location` without any on-chain verification
- Only off-chain CLI tools (`aptos governance show-proposal`) can detect the mismatch
- There is no on-chain enforcement preventing this attack
- The vulnerability is in the design: the protocol trusts proposers to provide matching values without verification

### Citations

**File:** aptos-move/e2e-move-tests/src/aptos_governance.rs (L12-31)
```rust
pub fn create_proposal_v2(
    harness: &mut MoveHarness,
    account: &Account,
    stake_pool: AccountAddress,
    execution_hash: Vec<u8>,
    metadata_location: Vec<u8>,
    metadata_hash: Vec<u8>,
    is_multi_step_proposal: bool,
) -> TransactionStatus {
    harness.run_transaction_payload(
        account,
        aptos_stdlib::aptos_governance_create_proposal_v2(
            stake_pool,
            execution_hash,
            metadata_location,
            metadata_hash,
            is_multi_step_proposal,
        ),
    )
}
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L383-399)
```text
    public entry fun create_proposal_v2(
        proposer: &signer,
        stake_pool: address,
        execution_hash: vector<u8>,
        metadata_location: vector<u8>,
        metadata_hash: vector<u8>,
        is_multi_step_proposal: bool,
    ) acquires GovernanceConfig, GovernanceEvents {
        create_proposal_v2_impl(
            proposer,
            stake_pool,
            execution_hash,
            metadata_location,
            metadata_hash,
            is_multi_step_proposal
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L405-437)
```text
    public fun create_proposal_v2_impl(
        proposer: &signer,
        stake_pool: address,
        execution_hash: vector<u8>,
        metadata_location: vector<u8>,
        metadata_hash: vector<u8>,
        is_multi_step_proposal: bool,
    ): u64 acquires GovernanceConfig, GovernanceEvents {
        check_governance_permission(proposer);
        let proposer_address = signer::address_of(proposer);
        assert!(
            stake::get_delegated_voter(stake_pool) == proposer_address,
            error::invalid_argument(ENOT_DELEGATED_VOTER)
        );

        // The proposer's stake needs to be at least the required bond amount.
        let governance_config = borrow_global<GovernanceConfig>(@aptos_framework);
        let stake_balance = get_voting_power(stake_pool);
        assert!(
            stake_balance >= governance_config.required_proposer_stake,
            error::invalid_argument(EINSUFFICIENT_PROPOSER_STAKE),
        );

        // The proposer's stake needs to be locked up at least as long as the proposal's voting period.
        let current_time = timestamp::now_seconds();
        let proposal_expiration = current_time + governance_config.voting_duration_secs;
        assert!(
            stake::get_lockup_secs(stake_pool) >= proposal_expiration,
            error::invalid_argument(EINSUFFICIENT_STAKE_LOCKUP),
        );

        // Create and validate proposal metadata.
        let proposal_metadata = create_proposal_metadata(metadata_location, metadata_hash);
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L751-762)
```text
    fun create_proposal_metadata(
        metadata_location: vector<u8>,
        metadata_hash: vector<u8>
    ): SimpleMap<String, vector<u8>> {
        assert!(string::length(&utf8(metadata_location)) <= 256, error::invalid_argument(EMETADATA_LOCATION_TOO_LONG));
        assert!(string::length(&utf8(metadata_hash)) <= 256, error::invalid_argument(EMETADATA_HASH_TOO_LONG));

        let metadata = simple_map::create<String, vector<u8>>();
        simple_map::add(&mut metadata, utf8(METADATA_LOCATION_KEY), metadata_location);
        simple_map::add(&mut metadata, utf8(METADATA_HASH_KEY), metadata_hash);
        metadata
    }
```

**File:** crates/aptos/src/governance/mod.rs (L118-159)
```rust
    async fn execute(mut self) -> CliTypedResult<VerifiedProposal> {
        // Get proposal
        let client = self.rest_options.client(&self.profile)?;
        let forum = client
            .get_account_resource_bcs::<VotingForum>(
                AccountAddress::ONE,
                "0x1::voting::VotingForum<0x1::governance_proposal::GovernanceProposal>",
            )
            .await?
            .into_inner();
        let voting_table = forum.table_handle.0;

        let proposal: Proposal = get_proposal(&client, voting_table, self.proposal_id)
            .await?
            .into();

        let metadata_hash = proposal.metadata.get("metadata_hash").unwrap();
        let metadata_url = proposal.metadata.get("metadata_location").unwrap();

        // Compute the hash and verify accordingly
        let mut metadata_verified = false;
        let mut actual_metadata_hash = "Unable to fetch metadata url".to_string();
        let mut actual_metadata = None;
        if let Ok(url) = Url::parse(metadata_url) {
            if let Ok(bytes) = get_metadata_from_url(&url).await {
                let hash = HashValue::sha3_256_of(&bytes);
                metadata_verified = metadata_hash == &hash.to_hex();
                actual_metadata_hash = hash.to_hex();
                if let Ok(metadata) = String::from_utf8(bytes) {
                    actual_metadata = Some(metadata);
                }
            }
        }

        Ok(VerifiedProposal {
            metadata_verified,
            actual_metadata_hash,
            actual_metadata,
            proposal,
        })
    }
}
```

**File:** crates/aptos/src/governance/mod.rs (L342-372)
```rust
    async fn get_metadata(&self) -> CliTypedResult<(ProposalMetadata, HashValue)> {
        #[cfg(feature = "no-upload-proposal")]
        let bytes = if let Some(ref path) = self.metadata_path {
            read_from_file(path)?
        } else {
            get_metadata_from_url(&self.metadata_url).await?
        };
        #[cfg(not(feature = "no-upload-proposal"))]
        let bytes = get_metadata_from_url(&self.metadata_url).await?;

        let metadata: ProposalMetadata = serde_json::from_slice(&bytes).map_err(|err| {
            CliError::CommandArgumentError(format!(
                "Metadata is not in a proper JSON format: {}",
                err
            ))
        })?;
        Url::parse(&metadata.source_code_url).map_err(|err| {
            CliError::CommandArgumentError(format!(
                "Source code URL {} is invalid {}",
                metadata.source_code_url, err
            ))
        })?;
        Url::parse(&metadata.discussion_url).map_err(|err| {
            CliError::CommandArgumentError(format!(
                "Discussion URL {} is invalid {}",
                metadata.discussion_url, err
            ))
        })?;
        let metadata_hash = HashValue::sha3_256_of(&bytes);
        Ok((metadata, metadata_hash))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L447-450)
```text
        assert!(
            transaction_context::get_script_hash() == proposal.execution_hash,
            error::invalid_argument(EPROPOSAL_EXECUTION_HASH_NOT_MATCHING),
        );
```
