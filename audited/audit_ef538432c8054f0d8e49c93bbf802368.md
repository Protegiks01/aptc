# Audit Report

## Title
Ledger Version Race Condition in Events API Violates Linearizability Guarantees

## Summary
The `get_events_by_event_handle()` endpoint in the Events API fetches events at one ledger version but uses a state view from a potentially different (later) ledger version for event conversion. This creates a race condition where concurrent blockchain state updates can cause events and their interpreting module definitions to come from inconsistent snapshots, violating linearizability guarantees and potentially causing deserialization failures or incorrect API responses.

## Finding Description

The vulnerability exists in the event conversion flow within `api/src/events.rs`. The issue occurs across two distinct phases:

**Phase 1: Event Fetching** [1](#0-0) 

When `Account::new()` is called, it invokes `get_latest_ledger_info_and_verify_lookup_version()` which captures the ledger info at version V1 at time T1. [2](#0-1) 

This method returns the latest ledger info and stores it in the `Account` struct. [3](#0-2) 

Events are then fetched using this captured ledger version V1.

**Phase 2: Event Conversion (The Race Window)** [4](#0-3) 

For JSON responses, the code calls `latest_state_view_poem(&latest_ledger_info)` which creates a state view at the CURRENT latest checkpoint version. [5](#0-4) 

This method calls `latest_state_checkpoint_view()` which fetches the latest state at time T2. [6](#0-5) 

The state view is created using `get_latest_state_checkpoint_version()` called at T2, which may return version V2 > V1 if blocks were committed between T1 and T2.

**The Vulnerability:**
During event-to-JSON conversion, the `MoveConverter` requires module bytecode to understand type layouts for deserializing event data. [7](#0-6) 

The conversion process calls `view_value()` which reads module definitions from the state view. [8](#0-7) 

This reads module bytecode from the state view, which is at version V2, while the events being converted are from version V1.

**Exploitation Scenario:**
1. Attacker or normal operations cause a module upgrade transaction to be committed during an API request
2. API request captures ledger info at V1 (before upgrade)
3. Events are fetched from V1 with old event struct definitions
4. Block containing module upgrade commits, advancing ledger to V2
5. `latest_state_view_poem()` returns state view at V2 (after upgrade)
6. Event conversion reads module definitions from V2 but applies them to event bytes from V1
7. Result: Deserialization using mismatched struct definitions, violating linearizability

## Impact Explanation

This vulnerability constitutes a **High Severity** issue under the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: The API violates linearizability guarantees by serving data from inconsistent snapshots. Linearizability is a fundamental correctness property that distributed systems depend on.

2. **Potential API Crashes**: If module struct definitions change between V1 and V2 (within Move's compatibility rules), BCS deserialization of event data using mismatched type layouts can cause panic or errors, crashing the API endpoint.

3. **Data Integrity Compromise**: Even without crashes, events may be deserialized with incorrect field interpretations, causing applications to receive semantically incorrect data.

4. **Trust in API Reliability**: The API is a critical interface for blockchain applications. Inconsistent snapshots undermine the reliability guarantees that applications depend on for correct operation.

## Likelihood Explanation

**Moderate to High Likelihood:**

1. **Frequent Occurrence Window**: The race window exists on every API request, spanning from `Account::new()` to `latest_state_view_poem()` - approximately milliseconds but occurring on every request.

2. **Module Upgrades Are Common**: Protocol upgrades, framework updates, and application deployments regularly involve module upgrades on Aptos.

3. **High Traffic Scenarios**: On high-throughput networks with frequent block commits, the probability of a block (potentially containing module upgrades) being committed during the API request window is non-negligible.

4. **No Attacker Privilege Required**: Any API user triggers this vulnerability through normal API usage - no special access or malicious intent needed.

5. **Timing is Probabilistic**: While an attacker cannot precisely control the timing, high API request volume combined with regular module upgrades makes triggering this condition statistically likely over time.

## Recommendation

**Fix: Use Versioned State View**

The correct approach is to use a state view at the SAME version as the events being converted. Replace the call to `latest_state_view_poem()` with `state_view_at_version()`: [4](#0-3) 

**Corrected code:**
```rust
match accept_type {
    AcceptType::Json => {
        // FIXED: Use state view at the same version as the events
        let state_view = self
            .context
            .state_view_at_version(ledger_version) // Use ledger_version from line 162
            .context("Failed to read state view at version")
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &latest_ledger_info,
                )
            })?;
        
        let events = state_view
            .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
            .try_into_versioned_events(&events)
            .context("Failed to convert events from storage into response")
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &latest_ledger_info,
                )
            })?;

        BasicResponse::try_from_json((events, &latest_ledger_info, BasicResponseStatus::Ok))
    },
    // ... rest unchanged
}
```

This ensures events and module definitions come from the same consistent snapshot at `ledger_version`.

**Note:** The same issue exists in `render_transactions_sequential()` and `render_transactions_non_sequential()` methods: [9](#0-8) [10](#0-9) 

These should also be fixed to use versioned state views consistent with the transaction data being rendered.

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the race condition scenario
// This would need to be integrated into the Aptos test framework

#[test]
fn test_event_version_race_condition() {
    // Setup: Deploy module with EventV1 struct
    // EventV1 { field_a: u64, field_b: bool }
    
    // Step 1: Transaction at V1 emits event with EventV1 data
    let event_v1 = emit_event_v1(100, true); // BCS: [100, 0, 0, 0, 0, 0, 0, 0, 1]
    
    // Step 2: API request starts - captures ledger info at V1
    let ledger_info_v1 = get_latest_ledger_info(); // Returns V1
    
    // Step 3: Module upgrade transaction commits - advances to V2
    // EventV1 becomes EventV2 { field_a: u64, field_c: vector<u8> }
    upgrade_module_to_v2();
    
    // Step 4: API continues - fetches events at V1
    let events = fetch_events_at_version(v1); // Gets event with EventV1 bytes
    
    // Step 5: API calls latest_state_view_poem() - gets V2
    let state_view = latest_state_view_poem(); // Returns state at V2
    
    // Step 6: Convert events using V2 module definition on V1 event bytes
    // VULNERABLE: Interprets bool field_b bytes as vector<u8> field_c
    let result = state_view.as_converter().try_into_versioned_events(&events);
    
    // Expected: Deserialization error or incorrect field_c value
    // This violates linearizability - event data from V1, module def from V2
    assert!(result.is_err() || result.unwrap()[0].data.field_c_is_wrong());
}
```

**Reproduction Steps:**
1. Deploy a Move module with an event struct
2. Emit events from that module
3. Start an API request to `get_events_by_event_handle()`
4. While the request is processing (between capturing ledger info and converting events), commit a block with a module upgrade
5. Observe the API response contains events interpreted with the wrong module version
6. The response violates linearizability as it mixes data from two different ledger versions

## Notes

This vulnerability affects all API endpoints that use `latest_state_view_poem()` for converting blockchain data while operating on a captured ledger version. The fix should be applied consistently across:
- `api/src/events.rs` (events API)
- `api/src/context.rs` (`render_transactions_*` methods)
- Any other endpoints following this pattern

The core issue is architectural: using "latest" state for conversion operations instead of version-consistent state views. All data conversion operations must use state views at the same version as the data being converted to maintain linearizability guarantees.

### Citations

**File:** api/src/accounts.rs (L243-246)
```rust
        let (latest_ledger_info, requested_version) = context
            .get_latest_ledger_info_and_verify_lookup_version(
                requested_ledger_version.map(|inner| inner.0),
            )?;
```

**File:** api/src/context.rs (L160-167)
```rust
    pub fn latest_state_view_poem<E: InternalError>(
        &self,
        ledger_info: &LedgerInfo,
    ) -> Result<DbStateView, E> {
        self.db
            .latest_state_checkpoint_view()
            .context("Failed to read latest state checkpoint from DB")
            .map_err(|e| E::internal_with_code(e, AptosErrorCode::InternalError, ledger_info))
```

**File:** api/src/context.rs (L294-317)
```rust
    pub fn get_latest_ledger_info_and_verify_lookup_version<E: StdApiError>(
        &self,
        requested_ledger_version: Option<Version>,
    ) -> Result<(LedgerInfo, Version), E> {
        let latest_ledger_info = self.get_latest_ledger_info()?;

        let requested_ledger_version =
            requested_ledger_version.unwrap_or_else(|| latest_ledger_info.version());

        // This is too far in the future, a retriable case
        if requested_ledger_version > latest_ledger_info.version() {
            return Err(version_not_found(
                requested_ledger_version,
                &latest_ledger_info,
            ));
        } else if requested_ledger_version < latest_ledger_info.oldest_ledger_version.0 {
            return Err(version_pruned(
                requested_ledger_version,
                &latest_ledger_info,
            ));
        }

        Ok((latest_ledger_info, requested_ledger_version))
    }
```

**File:** api/src/context.rs (L737-748)
```rust
    pub fn render_transactions_sequential<E: InternalError>(
        &self,
        ledger_info: &LedgerInfo,
        data: Vec<TransactionOnChainData>,
        mut timestamp: u64,
    ) -> Result<Vec<aptos_api_types::Transaction>, E> {
        if data.is_empty() {
            return Ok(vec![]);
        }

        let state_view = self.latest_state_view_poem(ledger_info)?;
        let converter = state_view.as_converter(self.db.clone(), self.indexer_reader.clone());
```

**File:** api/src/context.rs (L770-780)
```rust
    pub fn render_transactions_non_sequential<E: InternalError>(
        &self,
        ledger_info: &LedgerInfo,
        data: Vec<TransactionOnChainData>,
    ) -> Result<Vec<aptos_api_types::Transaction>, E> {
        if data.is_empty() {
            return Ok(vec![]);
        }

        let state_view = self.latest_state_view_poem(ledger_info)?;
        let converter = state_view.as_converter(self.db.clone(), self.indexer_reader.clone());
```

**File:** api/src/events.rs (L162-170)
```rust
        let ledger_version = latest_ledger_info.version();
        let events = self
            .context
            .get_events(
                &event_key,
                page.start_option(),
                page.limit(&latest_ledger_info)?,
                ledger_version,
            )
```

**File:** api/src/events.rs (L182-194)
```rust
                let events = self
                    .context
                    .latest_state_view_poem(&latest_ledger_info)?
                    .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
                    .try_into_versioned_events(&events)
                    .context("Failed to convert events from storage into response")
                    .map_err(|err| {
                        BasicErrorWith404::internal_with_code(
                            err,
                            AptosErrorCode::InternalError,
                            &latest_ledger_info,
                        )
                    })?;
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L82-90)
```rust
    fn latest_state_checkpoint_view(&self) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version: self
                .get_latest_state_checkpoint_version()
                .map_err(Into::<StateViewError>::into)?,
            maybe_verify_against_state_root_hash: None,
        })
    }
```

**File:** api/types/src/convert.rs (L612-624)
```rust
    pub fn try_into_versioned_events(
        &self,
        events: &[EventWithVersion],
    ) -> Result<Vec<VersionedEvent>> {
        let mut ret = vec![];
        for event in events {
            let data = self
                .inner
                .view_value(event.event.type_tag(), event.event.event_data())?;
            ret.push((event, MoveValue::try_from(data)?.json()?).into());
        }
        Ok(ret)
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L56-66)
```rust
    fn view_compiled_module(&self, module_id: &ModuleId) -> anyhow::Result<Option<Self::Item>> {
        let mut module_cache = self.module_cache.borrow_mut();
        if let Some(module) = module_cache.get(module_id) {
            return Ok(Some(module.clone()));
        }

        let state_key = StateKey::module_id(module_id);
        Ok(
            match self
                .state_view
                .get_state_value_bytes(&state_key)
```
