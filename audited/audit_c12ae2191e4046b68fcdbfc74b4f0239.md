# Audit Report

## Title
Memory Accounting Bypass via Persistent `should_leak_memory_for_native` Flag in Non-Generic Native Function Calls

## Summary
The `should_leak_memory_for_native` flag in `MemoryTrackedGasMeterImpl` is set only in `charge_call_generic()` but not in `charge_call()`, causing the flag to persist across function calls within a transaction. This allows an attacker to bypass memory accounting by calling non-generic native functions after calling generic functions from the `table` or `event` modules, as the stale flag prevents proper memory release. [1](#0-0) 

## Finding Description
The memory tracker implements special handling for native functions in the `table` and `event` modules, where argument memory is intentionally not released before execution (the "leak memory" behavior). However, the implementation contains a critical state management flaw:

The `should_leak_memory_for_native` flag is set in `charge_call_generic()` based on whether the called module is `table` or `event` at `CORE_CODE_ADDRESS`: [2](#0-1) 

However, `charge_call()` (used for non-generic function calls) is delegated to the base gas meter and does NOT modify this flag: [3](#0-2) 

This creates a state persistence vulnerability where:

1. When a generic function from `0x1::table` or `0x1::event` is called, the flag is set to `true`
2. If a subsequent non-generic native function is called (e.g., `signer::borrow_address()`), the flag remains `true` because `charge_call()` doesn't reset it
3. When `charge_native_function_before_execution()` executes, it incorrectly skips releasing argument memory for the non-table/event native function: [4](#0-3) 

The execution flow in the interpreter shows that both `Call` and `CallGeneric` bytecodes invoke their respective gas metering functions, then call native functions if applicable: [5](#0-4) [6](#0-5) 

Non-generic native functions like `signer::borrow_address()` exist throughout the framework: [7](#0-6) 

## Impact Explanation
This vulnerability allows bypassing memory accounting limits, which could enable:

1. **Resource Exhaustion DoS**: An attacker can craft transactions that consume excessive memory without proper tracking, potentially causing validator nodes to slow down or crash
2. **Memory Limit Bypass**: Transactions can exceed the intended memory quota by exploiting the incorrect flag state
3. **Deterministic but Exploitable**: While execution remains deterministic (no consensus divergence), the memory accounting bypass affects all nodes equally, making DoS attacks feasible

This meets **Medium Severity** criteria per Aptos bug bounty rules: "State inconsistencies requiring intervention" and resource limit violations that could lead to validator node degradation without causing direct fund loss or consensus failure.

## Likelihood Explanation
**High Likelihood**:

- The vulnerability is easily triggered by any transaction that calls a generic function from `table` or `event` modules followed by non-generic native functions
- No special privileges are required - any transaction sender can exploit this
- The `table` module is commonly used for storage operations in Aptos applications
- Many non-generic native functions exist (e.g., `signer::borrow_address`, `hash::sha2_256`, cryptographic operations) that could be targeted

The attack complexity is low: simply structure a transaction to invoke `table::new<K,V>()` or any other table/event generic function, then call non-generic native functions with large argument data.

## Recommendation
The flag must be explicitly reset in `charge_call()` to ensure it doesn't persist incorrectly across non-generic calls. Implement `charge_call()` directly instead of delegating it:

```rust
#[inline]
fn charge_call(
    &mut self,
    module_id: &ModuleId,
    func_name: &str,
    args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    num_locals: NumArgs,
) -> PartialVMResult<()> {
    // Reset the flag for non-generic calls to prevent state contamination
    self.should_leak_memory_for_native = false;
    
    self.base.charge_call(module_id, func_name, args, num_locals)
}
```

Alternatively, determine the correct leak behavior for each call independently rather than relying on persistent state.

## Proof of Concept

```move
// This Move script demonstrates the vulnerability
script {
    use std::signer;
    use aptos_std::table;
    use std::vector;
    
    fun exploit_memory_leak(account: &signer) {
        // Step 1: Call a generic function from table module
        // This sets should_leak_memory_for_native = true
        let t = table::new<u64, vector<u8>>();
        
        // Step 2: Call a non-generic native function with large arguments
        // The flag remains true, so argument memory is not released
        // Repeat this many times to exceed memory quota
        let i = 0;
        while (i < 1000) {
            let large_data = vector::empty<u8>();
            let j = 0;
            while (j < 10000) {
                vector::push_back(&mut large_data, 0xFF);
                j = j + 1;
            };
            
            // This non-generic native call incorrectly inherits the leak flag
            // Memory for large_data is not released before execution
            let _addr = signer::address_of(account);
            
            i = i + 1;
        };
        
        // Memory consumption exceeds intended limits due to accounting bypass
        table::drop_unchecked(t);
    }
}
```

The vulnerability can be traced through the VM execution:
1. `table::new<u64, vector<u8>>()` triggers `CallGeneric` → `charge_call_generic()` → flag set to `true`
2. `signer::address_of()` calls `signer::borrow_address()` which triggers `Call` → `charge_call()` → flag unchanged (remains `true`)
3. `borrow_address` is native → `charge_native_function_before_execution()` → skips memory release due to stale flag
4. Memory quota is bypassed for each iteration

## Notes
The TODO comment at line 327 references issue #5485, indicating awareness of the intentional memory leak behavior for table/event modules, but this does not address the cross-contamination issue where the flag affects unrelated native functions. The feature version check for the event module (line 313) adds complexity but doesn't mitigate this vulnerability since the flag persistence issue affects both table and event equally.

### Citations

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L239-245)
```rust
        fn charge_call(
            &mut self,
            module_id: &ModuleId,
            func_name: &str,
            args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
            num_locals: NumArgs,
        ) -> PartialVMResult<()>;
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L302-319)
```rust
    fn charge_call_generic(
        &mut self,
        module_id: &ModuleId,
        func_name: &str,
        ty_args: impl ExactSizeIterator<Item = impl TypeView> + Clone,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
        num_locals: NumArgs,
    ) -> PartialVMResult<()> {
        // Save the info for charge_native_function_before_execution.
        self.should_leak_memory_for_native = (*module_id.address() == CORE_CODE_ADDRESS
            && module_id.name().as_str() == "table")
            || (self.feature_version() >= 4
                && *module_id.address() == CORE_CODE_ADDRESS
                && module_id.name().as_str() == "event");

        self.base
            .charge_call_generic(module_id, func_name, ty_args, args, num_locals)
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L322-344)
```rust
    fn charge_native_function_before_execution(
        &mut self,
        ty_args: impl ExactSizeIterator<Item = impl TypeView> + Clone,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()> {
        // TODO(Gas): https://github.com/aptos-labs/aptos-core/issues/5485
        if !self.should_leak_memory_for_native {
            self.release_heap_memory(args.clone().try_fold(
                AbstractValueSize::zero(),
                |acc, val| {
                    let heap_size = self
                        .vm_gas_params()
                        .misc
                        .abs_val
                        .abstract_heap_size(val, self.feature_version())?;
                    Ok::<_, PartialVMError>(acc + heap_size)
                },
            )?);
        }

        self.base
            .charge_native_function_before_execution(ty_args, args)
    }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L510-520)
```rust
                    gas_meter
                        .charge_call(
                            function.owner_as_module()?.self_id(),
                            function.name(),
                            self.operand_stack
                                .last_n(function.param_tys().len())
                                .map_err(|e| set_err_info!(current_frame, e))?,
                            (function.local_tys().len() as u64).into(),
                        )
                        .map_err(|e| set_err_info!(current_frame, e))?;

```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L623-640)
```rust
                    gas_meter
                        .charge_call_generic(
                            function.owner_as_module()?.self_id(),
                            function.name(),
                            function
                                .ty_args()
                                .iter()
                                .map(|ty| TypeWithRuntimeEnvironment {
                                    ty,
                                    runtime_environment: self.loader.runtime_environment(),
                                }),
                            self.operand_stack
                                .last_n(function.param_tys().len())
                                .map_err(|e| set_err_info!(current_frame, e))?,
                            (function.local_tys().len() as u64).into(),
                        )
                        .map_err(|e| set_err_info!(current_frame, e))?;

```

**File:** aptos-move/framework/move-stdlib/sources/signer.move (L23-23)
```text
    native public fun borrow_address(s: &signer): &address;
```
