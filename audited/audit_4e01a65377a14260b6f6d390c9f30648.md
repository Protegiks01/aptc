# Audit Report

## Title
Indexer gRPC Service DoS via Zero Batch Size - Infinite Loop and Panic Vulnerabilities

## Summary
Setting `batch_size=0` in `GetTransactionsRequest` causes two distinct denial-of-service vulnerabilities in the Aptos indexer gRPC services: (1) an infinite loop in LiveDataService that consumes CPU resources indefinitely, and (2) a panic in HistoricalDataService that crashes the service thread. Both vulnerabilities can be triggered by any unauthenticated client.

## Finding Description
The `GetTransactionsRequest` message includes an optional `batch_size` parameter that controls the number of transactions returned per batch. When this parameter is set to 0, two different code paths exhibit critical failures:

**Vulnerability 1: Infinite Loop in LiveDataService**

In the live data service, `batch_size=0` is converted to `max_num_transactions_per_batch=0`. [1](#0-0) 

This value is passed to the cache's `get_data` method, where it controls a loop condition. [2](#0-1) 

When `max_num_transactions_per_batch=0`, the condition `result.len() < 0` is always false (since `0 < 0` is false), causing the loop to never execute. The function then returns an empty batch with `last_processed_version = starting_version - 1`. [3](#0-2) 

Back in the streaming loop, `next_version` is updated to `last_processed_version + 1 = starting_version`, meaning no progress is made. [4](#0-3) 

The outer loop continues indefinitely at the same version, consuming CPU resources without making any forward progress. [5](#0-4) 

**Vulnerability 2: Panic in HistoricalDataService**

In the historical data service, `batch_size=0` is similarly converted to `max_num_transactions_per_batch=0`. [6](#0-5) 

This value is later used in a call to Rust's `chunks()` method. [7](#0-6) 

According to Rust's standard library documentation, calling `chunks(0)` panics with the message "chunk size must be non-zero". This immediately crashes the service thread handling the request.

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "API crashes" category. The impact includes:

1. **Service Unavailability**: The LiveDataService infinite loop prevents the service from handling any requests for that client connection, consuming CPU resources. The HistoricalDataService panic crashes the service thread entirely.

2. **Resource Exhaustion**: An attacker can open multiple connections with `batch_size=0`, creating multiple infinite loops that collectively exhaust CPU resources and degrade service availability for legitimate users.

3. **Infrastructure Disruption**: While this doesn't directly affect validator nodes or consensus, the indexer gRPC service is critical infrastructure that applications and tooling depend on for reading blockchain data. Its disruption impacts the broader Aptos ecosystem.

## Likelihood Explanation
**Likelihood: Very High**

This vulnerability is trivially exploitable:
- No authentication is required to send gRPC requests
- The attack requires only setting a single parameter to 0
- The vulnerability is deterministic and reliably triggers
- No special timing or race conditions are needed
- An attacker can automate the attack to create sustained DoS

## Recommendation
Add validation to reject `batch_size=0` before processing the request. The fix should be applied in both services:

```rust
// In LiveDataService::run() and HistoricalDataService::run()
let max_num_transactions_per_batch = if let Some(batch_size) = request.batch_size {
    if batch_size == 0 {
        let err = Err(Status::invalid_argument(
            "batch_size must be greater than 0"
        ));
        let _ = response_sender.blocking_send(err);
        continue;
    }
    batch_size as usize
} else {
    DEFAULT_MAX_NUM_TRANSACTIONS_PER_BATCH
};
```

Alternatively, treat `batch_size=0` as equivalent to `None` and use the default value. The validation should occur at the request handling entry point before spawning any processing tasks.

## Proof of Concept
```rust
// PoC: Client code to trigger the vulnerability
use aptos_protos::indexer::v1::{
    raw_data_client::RawDataClient,
    GetTransactionsRequest,
};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to the indexer gRPC service
    let mut client = RawDataClient::connect("http://[indexer_address]:50051").await?;
    
    // Create request with batch_size=0
    let request = Request::new(GetTransactionsRequest {
        starting_version: Some(1000),
        transactions_count: None, // Infinite stream
        batch_size: Some(0),      // VULNERABILITY: Zero batch size
        transaction_filter: None,
    });
    
    // Send request - this will cause:
    // - LiveDataService: infinite loop consuming CPU
    // - HistoricalDataService: panic crash
    let mut stream = client.get_transactions(request).await?.into_inner();
    
    // The service will hang indefinitely or crash
    while let Some(response) = stream.message().await? {
        println!("Received batch: {:?}", response.transactions.len());
    }
    
    Ok(())
}
```

To reproduce:
1. Set up an Aptos indexer gRPC service (either live or historical)
2. Run the above client code connecting to the service
3. Observe either: (a) the service enters an infinite loop with 100% CPU usage on one core, or (b) the service panics and crashes
4. The service remains unavailable until restarted

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L117-121)
```rust
                let max_num_transactions_per_batch = if let Some(batch_size) = request.batch_size {
                    batch_size as usize
                } else {
                    10000
                };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L172-174)
```rust
        loop {
            if next_version >= ending_version {
                break;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L216-216)
```rust
                next_version = last_processed_version + 1;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/in_memory_cache.rs (L84-87)
```rust
            while version < ending_version
                && total_bytes < max_bytes_per_batch
                && result.len() < max_num_transactions_per_batch
            {
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/in_memory_cache.rs (L100-100)
```rust
            return Some((result, total_bytes, version - 1));
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/historical_data_service.rs (L102-106)
```rust
                let max_num_transactions_per_batch = if let Some(batch_size) = request.batch_size {
                    batch_size as usize
                } else {
                    DEFAULT_MAX_NUM_TRANSACTIONS_PER_BATCH
                };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/historical_data_service.rs (L205-205)
```rust
                        .chunks(max_num_transactions_per_batch)
```
