# Audit Report

## Title
Health Checker Protocol Mismatch Causes False Positive Failures and Unnecessary Peer Disconnections

## Summary
The health checker service does not verify protocol support before attempting to ping peers, causing nodes with HealthCheckerRpc support to repeatedly fail health checks against peers without this protocol support, eventually leading to unnecessary disconnections even though the peers are healthy and functional for other network operations.

## Finding Description

The health checker implements a backward compatibility vulnerability where protocol version mismatches result in false positive health failures. The issue occurs through the following code path:

1. When a peer connects, the handshake negotiates common protocols and stores them in `ConnectionMetadata.application_protocols`. [1](#0-0) 

2. The health checker receives a `NewPeer` connection notification and unconditionally adds the peer to its internal tracking without checking if the peer supports HealthCheckerRpc. [2](#0-1) 

3. On each health check interval, the health checker retrieves all tracked peers and attempts to ping them. [3](#0-2) 

4. When sending the ping RPC, the `NetworkClient` checks if the peer supports HealthCheckerRpc via `get_preferred_protocol_for_peer()`. [4](#0-3) 

5. If the peer doesn't support HealthCheckerRpc, an error is returned: "None of the preferred protocols are supported by this peer!" [5](#0-4) 

6. This error is treated as a ping failure, incrementing the failure counter. [6](#0-5) 

7. After `ping_failures_tolerated` consecutive failures, the health checker disconnects the peer. [7](#0-6) 

The root cause is that the health checker maintains its own peer list without filtering by protocol support, unlike other network clients that use `get_connected_supported_peers()`. [8](#0-7) 

## Impact Explanation

This issue is classified as **Low Severity** per the Aptos bug bounty program as it represents a "Non-critical implementation bug" that causes operational degradation but does not result in:
- Loss or theft of funds
- Consensus safety violations  
- Permanent network partition
- State corruption or manipulation

The impact is limited to:
- Unnecessary peer disconnections during version upgrades
- Temporary network connectivity degradation
- Increased reconnection overhead
- Potential network fragmentation during mixed-version deployments

Peers can reconnect after disconnection, and critical protocols (consensus, mempool, state sync) continue functioning if they were successfully negotiated during the handshake.

## Likelihood Explanation

This issue has **high likelihood** of occurrence during:
- Network upgrades where nodes run different Aptos versions
- Mixed deployment scenarios with custom node configurations
- Development/testing environments with varied protocol support

The issue triggers automatically without any malicious action required - it's a natural consequence of the current design when protocol version mismatches exist.

## Recommendation

Implement protocol support validation before attempting health checks. The health checker should filter peers to only track those supporting HealthCheckerRpc:

**Option 1 - Filter on NewPeer notification:** [2](#0-1) 

Add protocol support check:
```rust
ConnectionNotification::NewPeer(metadata, network_id) => {
    if network_id == self_network_id {
        // Only track peers that support HealthCheckerRpc
        let peer_network_id = PeerNetworkId::new(network_id, metadata.remote_peer_id);
        if let Ok(peer_metadata) = self.network_interface
            .get_peers_and_metadata()
            .get_metadata_for_peer(peer_network_id) 
        {
            if peer_metadata.supports_protocol(ProtocolId::HealthCheckerRpc) {
                self.network_interface.create_peer_and_health_data(
                    metadata.remote_peer_id, self.round
                );
            }
        }
    }
}
```

**Option 2 - Use NetworkClient.get_available_peers():** [8](#0-7) 

Replace the internal `connected_peers()` method with the NetworkClient's protocol-aware `get_available_peers()` method which already filters by protocol support. [9](#0-8) 

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_health_checker_protocol_mismatch() {
    // Setup Node A with HealthCheckerRpc support
    let node_a_protocols = ProtocolIdSet::from_iter([
        ProtocolId::HealthCheckerRpc,
        ProtocolId::ConsensusRpcBcs,
    ]);
    
    // Setup Node B without HealthCheckerRpc (older version)
    let node_b_protocols = ProtocolIdSet::from_iter([
        ProtocolId::ConsensusRpcBcs,  // Only consensus, no health checker
    ]);
    
    // Handshake succeeds with common protocol (ConsensusRpcBcs)
    let handshake_a = HandshakeMsg::from_supported(node_a_protocols);
    let handshake_b = HandshakeMsg::from_supported(node_b_protocols);
    let (_, common_protocols) = handshake_a.perform_handshake(&handshake_b).unwrap();
    
    // Verify HealthCheckerRpc is NOT in common protocols
    assert!(!common_protocols.contains(ProtocolId::HealthCheckerRpc));
    
    // Node A's health checker receives NewPeer for Node B
    // It will add Node B to tracking without checking protocol support
    
    // When Node A tries to ping Node B:
    // 1. health_checker calls send_to_peer_rpc()
    // 2. NetworkClient.get_preferred_protocol_for_peer() is called
    // 3. It checks if Node B supports HealthCheckerRpc
    // 4. Returns error: "None of the preferred protocols are supported"
    // 5. Error counted as health check failure
    // 6. After ping_failures_tolerated failures, Node B is disconnected
    
    // Result: Healthy peer Node B is disconnected due to protocol mismatch,
    // not actual health issues
}
```

## Notes

While this is a valid implementation issue, it is classified as **Low Severity** and primarily affects operational robustness rather than security. The disconnected peers can reconnect, and critical blockchain operations continue if other protocols were successfully negotiated. This issue should be addressed in routine maintenance but does not represent an exploitable security vulnerability meeting the Medium+ severity threshold required for bounty consideration.

### Citations

**File:** network/framework/src/transport/mod.rs (L308-317)
```rust
    let (messaging_protocol, application_protocols) = handshake_msg
        .perform_handshake(&remote_handshake)
        .map_err(|err| {
            let err = format!(
                "handshake negotiation with peer {} failed: {}",
                remote_peer_id.short_str(),
                err
            );
            add_pp_addr(proxy_protocol_enabled, io::Error::other(err), &addr)
        })?;
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L211-217)
```rust
                        ConnectionNotification::NewPeer(metadata, network_id) => {
                            // PeersAndMetadata is a global singleton across all networks; filter connect/disconnect events to the NetworkId that this HealthChecker instance is watching
                            if network_id == self_network_id {
                                self.network_interface.create_peer_and_health_data(
                                    metadata.remote_peer_id, self.round
                                );
                            }
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L229-263)
```rust
                _ = ticker.select_next_some() => {
                    self.round += 1;
                    let connected = self.network_interface.connected_peers();
                    if connected.is_empty() {
                        trace!(
                            NetworkSchema::new(&self.network_context),
                            round = self.round,
                            "{} No connected peer to ping round: {}",
                            self.network_context,
                            self.round
                        );
                        continue
                    }

                    for peer_id in connected {
                        let nonce = self.rng.r#gen::<u32>();
                        trace!(
                            NetworkSchema::new(&self.network_context),
                            round = self.round,
                            "{} Will ping: {} for round: {} nonce: {}",
                            self.network_context,
                            peer_id.short_str(),
                            self.round,
                            nonce
                        );

                        tick_handlers.push(Self::ping_peer(
                            self.network_context,
                            self.network_interface.network_client(),
                            peer_id,
                            self.round,
                            nonce,
                            self.ping_timeout,
                        ));
                    }
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L343-354)
```rust
            Err(err) => {
                warn!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    round = round,
                    "{} Ping failed for peer: {} round: {} with error: {:#}",
                    self.network_context,
                    peer_id.short_str(),
                    round,
                    err
                );
                self.network_interface
                    .increment_peer_round_failure(peer_id, round);
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L364-391)
```rust
                if failures > self.ping_failures_tolerated {
                    info!(
                        NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                        "{} Disconnecting from peer: {}",
                        self.network_context,
                        peer_id.short_str()
                    );
                    let peer_network_id =
                        PeerNetworkId::new(self.network_context.network_id(), peer_id);
                    if let Err(err) = timeout(
                        Duration::from_millis(50),
                        self.network_interface.disconnect_peer(
                            peer_network_id,
                            DisconnectReason::NetworkHealthCheckFailure,
                        ),
                    )
                    .await
                    {
                        warn!(
                            NetworkSchema::new(&self.network_context)
                                .remote_peer(&peer_id),
                            error = ?err,
                            "{} Failed to disconnect from peer: {} with error: {:?}",
                            self.network_context,
                            peer_id.short_str(),
                            err
                        );
                    }
```

**File:** network/framework/src/application/interface.rs (L146-158)
```rust
    ) -> Result<ProtocolId, Error> {
        let protocols_supported_by_peer = self.get_supported_protocols(peer)?;
        for protocol in preferred_protocols {
            if protocols_supported_by_peer.contains(*protocol) {
                return Ok(*protocol);
            }
        }
        Err(Error::NetworkError(format!(
            "None of the preferred protocols are supported by this peer! \
            Peer: {:?}, supported protocols: {:?}",
            peer, protocols_supported_by_peer
        )))
    }
```

**File:** network/framework/src/application/interface.rs (L214-223)
```rust
    fn get_available_peers(&self) -> Result<Vec<PeerNetworkId>, Error> {
        let supported_protocol_ids: Vec<ProtocolId> = self
            .direct_send_protocols_and_preferences
            .iter()
            .chain(self.rpc_protocols_and_preferences.iter())
            .cloned()
            .collect();
        self.peers_and_metadata
            .get_connected_supported_peers(&supported_protocol_ids)
    }
```

**File:** network/framework/src/application/interface.rs (L266-271)
```rust
        let network_sender = self.get_sender_for_network_id(&peer.network_id())?;
        let rpc_protocol_id =
            self.get_preferred_protocol_for_peer(&peer, &self.rpc_protocols_and_preferences)?;
        Ok(network_sender
            .send_rpc(peer.peer_id(), rpc_protocol_id, message, rpc_timeout)
            .await?)
```

**File:** network/framework/src/protocols/health_checker/interface.rs (L59-61)
```rust
    pub fn connected_peers(&self) -> Vec<PeerId> {
        self.health_check_data.read().keys().cloned().collect()
    }
```
