# Audit Report

## Title
Race Condition in Indexer-GRPC Cache Causes Node Crashes and Data Availability Issues

## Summary
A race condition exists between `fetch_add` and `fetch_max` operations on the `file_store_version` AtomicU64 in the indexer-grpc cache. Both operations execute concurrently while holding READ locks, allowing the cached version to diverge from the actual file store version. This leads to premature garbage collection, node crashes on version mismatches, and temporary data unavailability. [1](#0-0) 

## Finding Description

The `Cache` struct uses an `AtomicU64` field `file_store_version` to track which transactions have been persisted to file storage. Two operations modify this field:

1. **fetch_add** (optimistic increment): Called by FileStoreUploader when reading transactions from cache for upload [2](#0-1) 

2. **fetch_max** (ground truth sync): Called periodically to sync with actual file store version [3](#0-2) 

**Critical Issue**: Both operations execute while holding only READ locks on the cache, allowing concurrent execution without coordination. [4](#0-3) [5](#0-4) 

**Race Scenario**:
1. Cache `file_store_version` = 100, actual file store has version 100
2. FileStoreUploader reads 50 transactions [100, 150) and calls `fetch_add(50)` â†’ version becomes 150
3. Before upload completes, `update_file_store_version_in_cache` reads actual file store (still 100) and calls `fetch_max(100)`
4. Since 150 > 100, `fetch_max` doesn't change the value, version stays at 150
5. Cache now incorrectly believes file store has version 150 when it actually has 100
6. Garbage collection uses this version to remove transactions from cache [6](#0-5) 

7. If upload fails (network error), the node crashes due to `.unwrap()` [7](#0-6) 

8. Alternatively, if `update_file_store_version_in_cache` is later called with `version_can_go_backward=false`, it detects the mismatch and panics [8](#0-7) 

## Impact Explanation

**High Severity** - API Crashes and Service Unavailability:

1. **Node Crashes**: Upload failures or version mismatches cause panic, crashing the indexer-grpc service
2. **Data Unavailability**: Premature GC removes transactions from cache before they're uploaded. Clients requesting these transactions receive empty results
3. **Service Interruption**: The indexer-grpc service must be manually restarted after crashes

This qualifies as **High Severity** under the Aptos bug bounty category "API crashes" and "Validator node slowdowns" (if running on validator infrastructure).

## Likelihood Explanation

**High Likelihood** during normal operation:

1. **Concurrent Execution by Design**: The master node runs both FileStoreUploader (calling `fetch_add`) and DataManager (potentially calling `fetch_max`) concurrently [9](#0-8) 

2. **No Synchronization**: READ locks don't provide mutual exclusion between readers, and AtomicU64 operations are individually atomic but not coordinated

3. **High Frequency**: FileStoreUploader continuously processes transactions in a tight loop [10](#0-9) 

4. **Upload Failures**: Network issues, file store unavailability, or storage errors can trigger the crash path

## Recommendation

**Solution**: Use proper synchronization to coordinate updates to `file_store_version`:

1. **Option A - Write Lock for Updates**: Require WRITE lock when calling `get_transactions` with `update_file_store_version=true`:

```rust
pub(crate) async fn get_transactions_from_cache(
    &self,
    start_version: u64,
    max_size: usize,
    update_file_store_version: bool,
) -> Vec<Transaction> {
    if update_file_store_version {
        // Require write lock for updates
        self.cache
            .write()
            .await
            .get_transactions(start_version, max_size, update_file_store_version)
    } else {
        self.cache
            .read()
            .await
            .get_transactions(start_version, max_size, update_file_store_version)
    }
}
```

2. **Option B - Post-Upload Update**: Move `fetch_add` to AFTER successful upload, not before:

```rust
// In FileStoreUploader, update version only after successful upload
let transactions = data_manager
    .get_transactions_from_cache(next_version, MAX_SIZE_PER_FILE, false)
    .await;
    
// Upload transactions...
self.do_upload(transactions, batch_metadata, end_batch).await?;

// Now update version with write lock
data_manager.increment_file_store_version(transactions.len()).await;
```

3. **Option C - Remove Optimistic Update**: Only use `fetch_max` for updates based on actual file store state, eliminating the optimistic `fetch_add` entirely.

## Proof of Concept

```rust
#[tokio::test]
async fn test_file_store_version_race_condition() {
    use std::sync::Arc;
    use tokio::time::Duration;
    
    // Setup cache with initial version 100
    let config = CacheConfig { max_cache_size: 1000000, target_cache_size: 500000 };
    let cache = Arc::new(RwLock::new(Cache::new(config, 100)));
    
    // Spawn task 1: Simulate FileStoreUploader doing fetch_add
    let cache1 = cache.clone();
    let task1 = tokio::spawn(async move {
        for _ in 0..10 {
            let c = cache1.read().await;
            // Simulate fetch_add(50)
            c.file_store_version.fetch_add(50, Ordering::SeqCst);
            tokio::time::sleep(Duration::from_millis(10)).await;
        }
    });
    
    // Spawn task 2: Simulate update_file_store_version_in_cache doing fetch_max
    let cache2 = cache.clone();
    let task2 = tokio::spawn(async move {
        for _ in 0..10 {
            let c = cache2.read().await;
            // Simulate fetch_max with actual file store version (always 100)
            let before = c.file_store_version.fetch_max(100, Ordering::SeqCst);
            tokio::time::sleep(Duration::from_millis(10)).await;
            
            // Check if version went backward (would trigger panic in real code)
            let after = c.file_store_version.load(Ordering::SeqCst);
            if before > 100 && after > before {
                println!("Race detected: version jumped from {} to {}", before, after);
            }
        }
    });
    
    task1.await.unwrap();
    task2.await.unwrap();
    
    // Final version will be inconsistent with actual file store
    let final_version = cache.read().await.file_store_version.load(Ordering::SeqCst);
    assert!(final_version > 100, "Version incorrectly advanced to {}", final_version);
    println!("Cache believes file store is at version {}, but it's actually at 100", final_version);
}
```

## Notes

This vulnerability is specific to the indexer-grpc service architecture where concurrent readers can modify shared atomic state. While the indexer is not part of the core consensus protocol, its crashes affect data availability for applications relying on the indexer API. The issue is exacerbated by the lack of error handling (`.unwrap()` calls) in the upload path, turning transient errors into permanent crashes.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L62-80)
```rust
    // NOTE: This will only gc data up to the file store version.
    fn maybe_gc(&mut self) -> bool {
        if self.cache_size <= self.max_cache_size {
            return true;
        }

        while self.start_version < self.file_store_version.load(Ordering::SeqCst)
            && self.cache_size > self.target_cache_size
        {
            let transaction = self.transactions.pop_front().unwrap();
            self.cache_size -= transaction.encoded_len();
            self.start_version += 1;
        }

        CACHE_SIZE.set(self.cache_size as i64);
        CACHE_START_VERSION.set(self.start_version as i64);

        self.cache_size <= self.max_cache_size
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L127-135)
```rust
        if update_file_store_version {
            if !transactions.is_empty() {
                let old_version = self
                    .file_store_version
                    .fetch_add(transactions.len() as u64, Ordering::SeqCst);
                let new_version = old_version + transactions.len() as u64;
                FILE_STORE_VERSION_IN_CACHE.set(new_version as i64);
                info!("Updated file_store_version in cache to {new_version}.");
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L374-384)
```rust
    pub(crate) async fn get_transactions_from_cache(
        &self,
        start_version: u64,
        max_size: usize,
        update_file_store_version: bool,
    ) -> Vec<Transaction> {
        self.cache
            .read()
            .await
            .get_transactions(start_version, max_size, update_file_store_version)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L403-407)
```rust
    async fn update_file_store_version_in_cache(
        &self,
        cache: &RwLockReadGuard<'_, Cache>,
        version_can_go_backward: bool,
    ) {
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L410-414)
```rust
            let file_store_version_before_update = cache
                .file_store_version
                .fetch_max(file_store_version, Ordering::SeqCst);
            FILE_STORE_VERSION_IN_CACHE.set(file_store_version as i64);
            info!("Updated file_store_version in cache to {file_store_version}.");
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L415-418)
```rust
            if !version_can_go_backward && file_store_version_before_update > file_store_version {
                panic!("File store version is going backward, data might be corrupted. {file_store_version_before_update} v.s. {file_store_version}");
            };
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L148-176)
```rust
                loop {
                    let _timer = TIMER
                        .with_label_values(&["file_store_uploader_main_loop"])
                        .start_timer();
                    let next_version = file_store_operator.version();
                    let transactions = {
                        let _timer = TIMER
                            .with_label_values(&["get_transactions_from_cache"])
                            .start_timer();
                        data_manager
                            .get_transactions_from_cache(
                                next_version,
                                MAX_SIZE_PER_FILE,
                                /*update_file_store_version=*/ true,
                            )
                            .await
                    };
                    let len = transactions.len();
                    for transaction in transactions {
                        file_store_operator
                            .buffer_and_maybe_dump_transactions_to_file(transaction, tx.clone())
                            .await
                            .unwrap();
                    }
                    if len == 0 {
                        info!("No transaction was returned from cache, requested version: {next_version}.");
                        tokio::time::sleep(Duration::from_millis(200)).await;
                    }
                }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L111-121)
```rust
            s.spawn(async move { self.data_manager.start(self.is_master, rx).await });
            if self.is_master {
                s.spawn(async move {
                    self.file_store_uploader
                        .lock()
                        .await
                        .start(self.data_manager.clone(), tx)
                        .await
                        .unwrap();
                });
            }
```
