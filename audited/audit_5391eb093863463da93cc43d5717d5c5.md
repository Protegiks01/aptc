# Audit Report

## Title
Stale Connection State Due to Failed Disconnect Notification in Peer Shutdown

## Summary
When a `Peer` actor terminates and attempts to notify `PeerManager` of disconnection, the notification send can fail, resulting in `PeerManager` retaining stale connection state. This causes `ConnectivityManager` to believe it maintains connections that no longer exist, temporarily violating the full-mesh connectivity requirement for validators until `HealthChecker` detects the issue.

## Finding Description

In the `do_shutdown()` function, when a Peer terminates, it attempts to send a `TransportNotification::Disconnected` event to `PeerManager`: [1](#0-0) 

If this async send fails (returns `Err`), only a warning is logged and the Peer actor terminates. The failure occurs when the receiver is dropped, which happens if `PeerManager` terminates before the `Peer` actors during node shutdown.

**Consequence Chain:**

1. **PeerManager State**: The peer remains in the `active_peers` HashMap because no disconnection event was received. [2](#0-1) 

2. **ConnectivityManager State**: The `LostPeer` notification is never sent to upstream handlers because `PeerManager` never removes the peer. [3](#0-2) 

3. **ConnectivityManager cannot re-dial**: When `ConnectivityManager` checks connectivity, it filters out peers already in the `connected` map from dialing attempts: [4](#0-3) 

This means `ConnectivityManager` believes it has a connection to the peer and will not attempt to re-establish it, **violating the full-mesh connectivity invariant** required for validator networks.

4. **Detection Delay**: The stale state persists until `HealthChecker` detects the dead connection through ping failures (default: 3 failures Ã— 10 second interval = ~30 seconds): [5](#0-4) 

5. **Memory Leak**: When `HealthChecker` eventually calls `disconnect_peer()`, it adds an entry to `outstanding_disconnect_requests` expecting a disconnect acknowledgment: [6](#0-5) 

However, since the Peer actor already terminated, it cannot send the acknowledgment. This entry is **never removed**, creating a memory leak as there is no timeout mechanism for cleanup.

## Impact Explanation

**Severity: Medium** (per Aptos bug bounty criteria: "State inconsistencies requiring intervention")

While this issue exists, it does NOT meet **High or Critical** severity because:

1. **Not exploitable by unprivileged attackers**: The send fails only when `PeerManager` terminates (receiver dropped), which occurs during node shutdown and is not attacker-controlled.

2. **Self-healing within 30 seconds**: `HealthChecker` detects the stale connection and triggers cleanup automatically.

3. **No consensus safety violation**: Consensus messages to dead peers fail (logged), but AptosBFT handles timeouts and retries. Other validator connections remain functional.

4. **No fund loss or permanent damage**: This is a transient state inconsistency, not a critical security failure.

The issue affects validator network reliability during the detection window but does not break consensus safety guarantees.

## Likelihood Explanation

**Likelihood: Low in production, High during node operations**

The failure occurs primarily during:
- Graceful node shutdown when `PeerManager` terminates before all `Peer` actors
- Node crashes where the notification channel is disrupted
- Concurrent mass disconnections saturating the channel (unlikely with 1024 capacity) [7](#0-6) 

The async send blocks if the channel is full rather than failing, so the primary failure mode is receiver termination during shutdown sequences.

## Recommendation

**Fix 1: Add timeout to disconnect notification send**

Add a timeout to prevent indefinite blocking and handle failures gracefully:

```rust
async fn do_shutdown(
    mut self,
    write_req_tx: aptos_channel::Sender<(), NetworkMessage>,
    writer_close_tx: oneshot::Sender<()>,
    reason: DisconnectReason,
) {
    // ... existing code ...
    
    let remote_peer_id = self.remote_peer_id();
    // Send with timeout to prevent hanging
    match self.time_service.timeout(
        Duration::from_secs(5),
        self.connection_notifs_tx.send(TransportNotification::Disconnected(
            self.connection_metadata.clone(),
            reason,
        ))
    ).await {
        Ok(Ok(())) => {
            trace!("Successfully notified PeerManager of disconnection");
        },
        Ok(Err(e)) | Err(_) => {
            warn!(
                NetworkSchema::new(&self.network_context)
                    .connection_metadata(&self.connection_metadata),
                error = ?e,
                "{} Failed to notify upstream about disconnection of peer: {}",
                self.network_context,
                remote_peer_id.short_str(),
            );
        }
    }
}
```

**Fix 2: Add timeout cleanup for outstanding_disconnect_requests**

Implement periodic cleanup of stale entries in `outstanding_disconnect_requests`:

```rust
// In PeerManager::start() event loop, add timeout check
if let Some(stale_entries) = self.check_stale_disconnect_requests() {
    for (connection_id, resp_tx) in stale_entries {
        let _ = resp_tx.send(Ok(())); // ACK even if late
    }
}
```

**Fix 3: Make HealthChecker detection more aggressive for validators**

Reduce ping interval and tolerance for validator networks to detect failures faster.

## Proof of Concept

This issue occurs during node shutdown and cannot be exploited by external attackers. A reproduction would require:

```rust
#[tokio::test]
async fn test_disconnect_notification_failure_during_shutdown() {
    // 1. Create PeerManager and Peer actors
    // 2. Terminate PeerManager (dropping notification receiver)
    // 3. Trigger Peer shutdown
    // 4. Verify Peer logs warning about failed notification
    // 5. Verify PeerManager (if restarted) still has stale entry
    
    // This is a node implementation test, not an exploit PoC
    // as external attackers cannot force PeerManager termination
}
```

The issue is a **robustness concern** during operational scenarios (node restarts, crashes) rather than an exploitable security vulnerability.

---

**Notes:**

This finding validates that the stale connection state issue exists as described, but it does **not** constitute a high-severity exploitable vulnerability per bug bounty criteria. The issue should be fixed for improved robustness and to prevent memory leaks during operational events, but it does not present an immediate security risk to consensus safety or fund security. The temporary connectivity degradation (~30 seconds) and automatic self-healing via `HealthChecker` limit the practical impact.

### Citations

**File:** network/framework/src/peer/mod.rs (L707-724)
```rust
        if let Err(e) = self
            .connection_notifs_tx
            .send(TransportNotification::Disconnected(
                self.connection_metadata.clone(),
                reason,
            ))
            .await
        {
            warn!(
                NetworkSchema::new(&self.network_context)
                    .connection_metadata(&self.connection_metadata),
                error = ?e,
                "{} Failed to notify upstream about disconnection of peer: {}; error: {:?}",
                self.network_context,
                remote_peer_id.short_str(),
                e
            );
        }
```

**File:** network/framework/src/peer_manager/mod.rs (L81-87)
```rust
    active_peers: HashMap<
        PeerId,
        (
            ConnectionMetadata,
            aptos_channel::Sender<ProtocolId, PeerRequest>,
        ),
    >,
```

**File:** network/framework/src/peer_manager/mod.rs (L147-150)
```rust
        let (transport_notifs_tx, transport_notifs_rx) = aptos_channels::new(
            channel_size,
            &counters::PENDING_CONNECTION_HANDLER_NOTIFICATIONS,
        );
```

**File:** network/framework/src/peer_manager/mod.rs (L320-326)
```rust
                if !self.active_peers.contains_key(&peer_id) {
                    let notif = ConnectionNotification::LostPeer(
                        lost_conn_metadata,
                        self.network_context.network_id(),
                    );
                    self.send_conn_notification(peer_id, notif);
                }
```

**File:** network/framework/src/peer_manager/mod.rs (L485-486)
```rust
                    self.outstanding_disconnect_requests
                        .insert(connection_id, resp_tx);
```

**File:** network/framework/src/connectivity_manager/mod.rs (L1022-1038)
```rust
                if let Some(stored_metadata) = self.connected.get(&peer_id) {
                    // Remove node from connected peers list.

                    counters::peer_connected(&self.network_context, &peer_id, 0);

                    info!(
                        NetworkSchema::new(&self.network_context)
                            .remote_peer(&peer_id)
                            .connection_metadata(&metadata),
                        stored_metadata = stored_metadata,
                        "{} Removing peer '{}' metadata: {}, vs event metadata: {}",
                        self.network_context,
                        peer_id.short_str(),
                        stored_metadata,
                        metadata
                    );
                    self.connected.remove(&peer_id);
```

**File:** config/src/config/network_config.rs (L38-40)
```rust
pub const PING_INTERVAL_MS: u64 = 10_000;
pub const PING_TIMEOUT_MS: u64 = 20_000;
pub const PING_FAILURES_TOLERATED: u64 = 3;
```
