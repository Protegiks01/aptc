# Audit Report

## Title
Critical Configuration Bypass Allows Mainnet Validators to Disable All Security Checks

## Summary
The `skip_config_sanitizer` flag in `NodeStartupConfig` allows node operators to completely bypass all configuration security validation in production, including critical consensus safety checks, VM runtime verifications, and network security requirements. This flag is accessible via YAML configuration files with no warnings, documentation, or safeguards preventing its use on mainnet validators.

## Finding Description

The configuration sanitizer is responsible for enforcing critical security invariants before a node starts. When `skip_config_sanitizer` is set to `true` in the node's YAML configuration file, the sanitizer returns immediately without performing any validation checks. [1](#0-0) 

The `skip_config_sanitizer` field is defined as a deserializable boolean in `NodeStartupConfig`: [2](#0-1) [3](#0-2) 

This field is part of the main `NodeConfig` struct that is loaded from YAML files: [4](#0-3) 

In production, the config is loaded via `NodeConfig::load_from_path()`, which calls the sanitizer: [5](#0-4) [6](#0-5) 

**Critical Security Checks That Get Bypassed:**

1. **ExecutionConfig Sanitizer** - Mainnet validators must have paranoid VM verification enabled: [7](#0-6) 

2. **SafetyRulesConfig Sanitizer** - Mainnet validators must use persistent storage (not in-memory) for safety data: [8](#0-7) 

3. **Failpoints Sanitizer** - Failpoints must be disabled on mainnet: [9](#0-8) 

4. **Validator Network Sanitizer** - Mutual authentication must be enabled: [10](#0-9) 

5. **Consensus Sanitizer** - Various consensus and quorum store validations: [11](#0-10) 

**Attack Scenario:**

A validator operator (maliciously or through system compromise) could add the following to their mainnet validator configuration:

```yaml
node_startup:
  skip_config_sanitizer: true
consensus:
  safety_rules:
    backend: InMemoryStorage  # Loses safety data on restart
    test: # Enable test config
      author: "0x1"
execution:
  paranoid_hot_potato_verification: false  # Disable VM checks
  paranoid_type_verification: false
```

The node would start successfully and participate in consensus, but:
- **Safety Rules with in-memory storage**: On node restart, the validator loses its voting history (last voted round, highest QC). This can lead to **double voting** and **equivocation**, violating AptosBFT safety guarantees.
- **Disabled VM paranoid checks**: Different validators may execute Move bytecode differently, causing **consensus splits** and breaking deterministic execution invariants.
- **Test configurations on mainnet**: Undefined behavior that could compromise network security.

The test explicitly demonstrates this bypass working with invalid mainnet configuration: [12](#0-11) 

## Impact Explanation

This is a **CRITICAL** severity vulnerability per Aptos bug bounty criteria because it enables:

1. **Consensus/Safety Violations**: Using in-memory safety rules storage allows a validator to double-vote after restart, which can lead to chain splits and violates the fundamental safety guarantee that fewer than 1/3 Byzantine validators cannot cause consensus failures. This directly breaks Critical Invariant #2: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine".

2. **Deterministic Execution Violations**: Disabling `paranoid_hot_potato_verification` and `paranoid_type_verification` removes runtime VM checks that ensure all validators execute Move bytecode identically. This can cause validators to produce different state roots for the same block, breaking Critical Invariant #1: "Deterministic Execution: All validators must produce identical state roots for identical blocks".

3. **No Detection Mechanism**: There is no logging, monitoring, or on-chain indicator when a validator uses this bypass, making it impossible for the network to detect compromised validators.

The impact matches the **Critical Severity** category: "Consensus/Safety violations" (up to $1,000,000).

## Likelihood Explanation

**Likelihood: Medium**

While this vulnerability requires validator operator access to the configuration file, several factors increase the likelihood:

1. **No Documentation**: The flag has no indication it is test-only, leading to potential accidental use.
2. **No Warnings**: The system provides no alerts when this flag is enabled, even on mainnet.
3. **Simple to Exploit**: Adding two lines to a YAML configuration file is trivial.
4. **Compromised Systems**: If a validator's operational system is compromised, this provides an easy way to weaken security without modifying binaries.
5. **Insider Threat**: Malicious or negligent operators could intentionally use this to avoid security restrictions.

The design flaw is that this bypass exists in production code at all - it provides an authorized but dangerous capability with no safeguards.

## Recommendation

**Option 1 (Strongest): Remove the feature entirely from production builds**

Compile-time disable this flag for production:

```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool,
    #[cfg(test)]  // Only available in test builds
    pub skip_config_sanitizer: bool,
}

impl Default for NodeStartupConfig {
    fn default() -> Self {
        Self {
            skip_config_optimizer: false,
            #[cfg(test)]
            skip_config_sanitizer: false,
        }
    }
}
```

**Option 2: Add runtime checks and warnings**

If the feature must exist, add strong safeguards:

```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // Check if sanitizer is being bypassed
        if node_config.node_startup.skip_config_sanitizer {
            // NEVER allow on mainnet
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet() {
                    return Err(Error::ConfigSanitizerFailed(
                        "NodeConfig".to_string(),
                        "skip_config_sanitizer cannot be enabled on mainnet! This bypasses critical security checks.".to_string(),
                    ));
                }
            }
            
            // Log loud warning
            eprintln!("WARNING: Configuration sanitizer is DISABLED! This bypasses all security validation.");
            eprintln!("WARNING: This should ONLY be used for testing purposes.");
            eprintln!("WARNING: Running in production with this flag is DANGEROUS and can compromise consensus safety.");
            
            return Ok(());
        }
        
        // ... rest of sanitization
    }
}
```

**Option 3: Require explicit chain ID allowlist**

Only allow bypassing on explicitly allowed test chains:

```rust
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool,
    pub skip_config_sanitizer: bool,
    pub skip_config_sanitizer_allowed_chains: Vec<u8>,  // Chain IDs where bypass is allowed
}
```

## Proof of Concept

**Rust Test Demonstrating the Bypass:**

```rust
#[test]
fn test_mainnet_validator_can_bypass_safety_checks() {
    use crate::config::{
        NodeConfig, NodeStartupConfig, ConsensusConfig, SafetyRulesConfig,
        ExecutionConfig, SecureBackend, node_config_loader::NodeType,
        config_sanitizer::ConfigSanitizer,
    };
    use aptos_types::chain_id::ChainId;

    // Create a mainnet validator config with DANGEROUS settings
    let mut dangerous_config = NodeConfig::default();
    
    // Set skip_config_sanitizer to bypass all checks
    dangerous_config.node_startup = NodeStartupConfig {
        skip_config_sanitizer: true,
        skip_config_optimizer: false,
    };
    
    // Use in-memory safety rules (loses data on restart -> double voting risk)
    dangerous_config.consensus.safety_rules.backend = SecureBackend::InMemoryStorage;
    
    // Disable paranoid VM verification
    dangerous_config.execution.paranoid_hot_potato_verification = false;
    dangerous_config.execution.paranoid_type_verification = false;
    
    // This should FAIL on mainnet, but it PASSES due to the bypass
    let result = NodeConfig::sanitize(
        &dangerous_config,
        NodeType::Validator,
        Some(ChainId::mainnet())
    );
    
    // VULNERABILITY: This succeeds when it should fail!
    assert!(result.is_ok(), "Dangerous config bypassed all safety checks!");
    
    // Verify the same config FAILS without the bypass
    dangerous_config.node_startup.skip_config_sanitizer = false;
    let result = NodeConfig::sanitize(
        &dangerous_config,
        NodeType::Validator,
        Some(ChainId::mainnet())
    );
    assert!(result.is_err(), "Config should fail validation without bypass");
}
```

**YAML Configuration Attack:**

A validator operator could create `validator.yaml`:

```yaml
base:
  role: Validator
  
node_startup:
  skip_config_sanitizer: true  # CRITICAL BYPASS

consensus:
  safety_rules:
    backend:
      type: InMemoryStorage  # Loses voting history on restart
    service: Local
    test:  # Enable test config on mainnet
      author: "0xcafe"

execution:
  paranoid_hot_potato_verification: false  # Disable VM safety
  paranoid_type_verification: false

# ... rest of valid config
```

This configuration would start a mainnet validator that:
1. Loses consensus safety data on every restart
2. Can double-vote after crashes
3. May execute Move bytecode differently than other validators
4. Operates with test configurations on production network

## Notes

This vulnerability represents a **fundamental design flaw** where critical security checks can be bypassed through a configuration flag with no safeguards. While exploitation requires validator operator access, the existence of such a bypass in production code violates security-by-design principles. The flag should either be removed entirely from production builds or protected by strong runtime checks that prevent its use on mainnet. The lack of documentation, warnings, or restrictions makes accidental or malicious exploitation likely.

### Citations

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L74-109)
```rust
fn sanitize_failpoints_config(
    node_config: &NodeConfig,
    _node_type: NodeType,
    chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = FAILPOINTS_SANITIZER_NAME.to_string();
    let failpoints = &node_config.failpoints;

    // Verify that failpoints are not enabled in mainnet
    let failpoints_enabled = are_failpoints_enabled();
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
    }

    // Ensure that the failpoints config is populated appropriately
    if let Some(failpoints) = failpoints {
        if failpoints_enabled && failpoints.is_empty() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are enabled, but the failpoints config is empty?".into(),
            ));
        } else if !failpoints_enabled && !failpoints.is_empty() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are disabled, but the failpoints config is not empty!".into(),
            ));
        }
    }

    Ok(())
}
```

**File:** config/src/config/config_sanitizer.rs (L156-201)
```rust
/// Sanitize the validator network config according to the node role and chain ID
fn sanitize_validator_network_config(
    node_config: &NodeConfig,
    node_type: NodeType,
    _chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = VALIDATOR_NETWORK_SANITIZER_NAME.to_string();
    let validator_network = &node_config.validator_network;

    // Verify that the validator network config is not empty for validators
    if validator_network.is_none() && node_type.is_validator() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Validator network config cannot be empty for validators!".into(),
        ));
    }

    // Check the validator network config
    if let Some(validator_network_config) = validator_network {
        let network_id = validator_network_config.network_id;
        if !network_id.is_validator_network() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The validator network config must have a validator network ID!".into(),
            ));
        }

        // Verify that the node is a validator
        if !node_type.is_validator() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The validator network config cannot be set for non-validators!".into(),
            ));
        }

        // Ensure that mutual authentication is enabled
        if !validator_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for the validator network!".into(),
            ));
        }
    }

    Ok(())
}
```

**File:** config/src/config/config_sanitizer.rs (L211-239)
```rust
    #[test]
    fn test_disable_config_sanitizer() {
        // Create a default node config (with sanitization enabled)
        let mut node_config = NodeConfig::default();

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer fails
        let error =
            NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
                .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
    }
```

**File:** config/src/config/node_startup_config.rs (L6-11)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** config/src/config/node_startup_config.rs (L14-20)
```rust
impl Default for NodeStartupConfig {
    fn default() -> Self {
        Self {
            skip_config_optimizer: false,
            skip_config_sanitizer: false,
        }
    }
```

**File:** config/src/config/node_config.rs (L75-75)
```rust
    pub node_startup: NodeStartupConfig,
```

**File:** config/src/config/node_config.rs (L140-143)
```rust
    pub fn load_from_path<P: AsRef<Path>>(input_path: P) -> Result<Self, Error> {
        let node_config_loader = NodeConfigLoader::new(input_path);
        node_config_loader.load_and_sanitize_config()
    }
```

**File:** config/src/config/node_config_loader.rs (L126-145)
```rust
/// Optimize and sanitize the node config for the current environment
fn optimize_and_sanitize_node_config(
    node_config: &mut NodeConfig,
    local_config_yaml: Value,
) -> Result<(), Error> {
    // Extract the node type and chain ID from the node config
    let (node_type, chain_id) = extract_node_type_and_chain_id(node_config);

    // Print the extracted node type and chain ID
    println!(
        "Identified node type ({:?}) and chain ID ({:?}) from node config!",
        node_type, chain_id
    );

    // Optimize the node config
    NodeConfig::optimize(node_config, &local_config_yaml, node_type, chain_id)?;

    // Sanitize the node config
    NodeConfig::sanitize(node_config, node_type, chain_id)
}
```

**File:** config/src/config/execution_config.rs (L157-186)
```rust
impl ConfigSanitizer for ExecutionConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let execution_config = &node_config.execution;

        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }

        Ok(())
    }
```

**File:** config/src/config/safety_rules_config.rs (L71-117)
```rust
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        // If the node is not a validator, there's nothing to be done
        if !node_type.is_validator() {
            return Ok(());
        }

        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }

            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }

            // Verify that the safety rules test config is not enabled in mainnet
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/consensus_config.rs (L503-533)
```rust
impl ConfigSanitizer for ConsensusConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        // Verify that the safety rules and quorum store configs are valid
        SafetyRulesConfig::sanitize(node_config, node_type, chain_id)?;
        QuorumStoreConfig::sanitize(node_config, node_type, chain_id)?;

        // Verify that the consensus-only feature is not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && is_consensus_only_perf_test_enabled() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "consensus-only-perf-test should not be enabled in mainnet!".to_string(),
                ));
            }
        }

        // Sender block limits must be <= receiver block limits
        Self::sanitize_send_recv_block_limits(&sanitizer_name, &node_config.consensus)?;

        // Quorum store batches must be <= consensus blocks
        Self::sanitize_batch_block_limits(&sanitizer_name, &node_config.consensus)?;

        Ok(())
    }
}
```
