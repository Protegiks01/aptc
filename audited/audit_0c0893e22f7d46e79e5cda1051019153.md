# Audit Report

## Title
Missing Chain ID Validation in REST Client Allows Network Substitution Attack

## Summary
The `State::from_headers()` function in the Aptos REST client does not validate that the parsed `chain_id` matches the expected network. A compromised or malicious API server can silently provide an incorrect `chain_id`, causing clients to unknowingly sign and submit transactions to a different network than intended. While on-chain validation prevents direct cross-chain transaction replay, this vulnerability enables network substitution attacks where users are tricked into transacting on the wrong blockchain entirely. [1](#0-0) 

## Finding Description
The REST client's `State::from_headers()` function extracts the `chain_id` from HTTP response headers without any validation against the expected network. When a client is created with a specific network intent (e.g., `AptosBaseUrl::Mainnet`), there is no verification that the API server's returned `chain_id` matches the expected value (chain_id=1 for mainnet). [2](#0-1) 

The client builder allows specifying network URLs for Mainnet, Testnet, Devnet, or Custom endpoints, but the built client has no stored expectation of what `chain_id` should be returned. The `chain_id` from API responses is then used directly for transaction signing via `TransactionFactory`: [3](#0-2) 

**Attack Scenario:**
1. User intends to connect to mainnet by using `AptosBaseUrl::Mainnet` 
2. Compromised API at mainnet URL returns `X_APTOS_CHAIN_ID: 2` (testnet) instead of `1`
3. Client accepts `chain_id=2` without validation
4. User signs transactions with `chain_id=2` thinking they're for mainnet
5. Transactions are submitted to testnet (or attacker-controlled chain with chain_id=2)
6. User believes transactions are on mainnet but they execute on testnet

While on-chain validation prevents transactions signed for one chain from executing on another (via the prologue check): [4](#0-3) 

This protection doesn't help if the user is tricked into signing transactions for the wrong chain in the first place. The transactions will successfully execute on the wrong network, and the user will be unaware.

**Contrast with Rosetta API:**
The Rosetta API implementation in the same codebase demonstrates proper validation by explicitly checking that incoming network identifiers match the server's expected chain_id: [5](#0-4) 

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria as a "Significant protocol violation." 

**Potential Harms:**
1. **Fund Confusion**: Users believing they're using testnet tokens could actually be spending real mainnet funds, or vice versa
2. **Malicious Chain Substitution**: An attacker could redirect users to a private blockchain under attacker control while claiming to be mainnet
3. **Business Logic Failures**: Applications that assume they're on mainnet for critical operations could unknowingly execute on testnet
4. **Loss of Transaction History**: Transactions intended for mainnet execute on testnet, becoming invisible to mainnet-monitoring infrastructure

The known chain IDs are: [6](#0-5) 

An attacker who compromises any API endpoint can substitute any of these chain IDs, redirecting user transactions to unintended networks.

## Likelihood Explanation
**Likelihood: Medium to High**

**Attack Requirements:**
- Compromise of an API endpoint (via DNS poisoning, server breach, or MITM attack), OR
- Users connecting to malicious custom API endpoints

**Factors Increasing Likelihood:**
1. No cryptographic binding between URL and expected chain_id
2. Many users rely on third-party API providers
3. Custom API endpoints are supported, making it easy to set up malicious servers
4. No warning is shown to users when chain_id doesn't match expected network

## Recommendation
Add chain_id validation to the REST client. The client should store an expected `chain_id` when created and validate API responses match this expectation.

**Recommended Fix:**

1. Extend `ClientBuilder` to accept or infer expected `chain_id`:
```rust
pub struct ClientBuilder {
    reqwest_builder: ReqwestClientBuilder,
    version_path_base: String,
    base_url: Url,
    timeout: Duration,
    headers: HeaderMap,
    expected_chain_id: Option<ChainId>,  // Add this field
}

impl ClientBuilder {
    pub fn new(aptos_base_url: AptosBaseUrl) -> Self {
        let expected_chain_id = match &aptos_base_url {
            AptosBaseUrl::Mainnet => Some(ChainId::mainnet()),
            AptosBaseUrl::Testnet => Some(ChainId::testnet()),
            AptosBaseUrl::Devnet => None, // Devnet chain_id varies
            AptosBaseUrl::Custom(_) => None, // Cannot infer
        };
        // ... rest of initialization
    }
    
    pub fn expected_chain_id(mut self, chain_id: ChainId) -> Self {
        self.expected_chain_id = Some(chain_id);
        self
    }
}
```

2. Store expected chain_id in `Client` and validate in `State::from_headers()`:
```rust
pub struct Client {
    inner: ReqwestClient,
    base_url: Url,
    version_path_base: String,
    expected_chain_id: Option<ChainId>,  // Add this field
}

impl State {
    pub fn from_headers(
        headers: &reqwest::header::HeaderMap,
        expected_chain_id: Option<ChainId>
    ) -> anyhow::Result<Self> {
        // ... existing parsing code ...
        
        // Add validation after parsing
        if let Some(expected) = expected_chain_id {
            if chain_id != expected.id() {
                anyhow::bail!(
                    "Chain ID mismatch: expected {}, got {} from API server",
                    expected.id(),
                    chain_id
                );
            }
        }
        
        // ... rest of function
    }
}
```

## Proof of Concept

```rust
use aptos_rest_client::{Client, ClientBuilder, AptosBaseUrl};
use aptos_types::chain_id::ChainId;

#[tokio::test]
async fn test_chain_id_substitution_attack() {
    // Step 1: Create client expecting mainnet
    let client = ClientBuilder::new(AptosBaseUrl::Mainnet).build();
    
    // Step 2: Malicious API at mainnet URL returns testnet chain_id
    // In real attack, this would be a compromised or MITM'd API server
    // For PoC, we demonstrate the client blindly accepts wrong chain_id
    
    // Step 3: Get ledger info (which includes chain_id from headers)
    let state = client.get_ledger_information().await.unwrap().into_inner();
    
    // Step 4: Client uses whatever chain_id the API provided
    let chain_id_from_api = ChainId::new(state.chain_id);
    
    // Step 5: If API returned wrong chain_id, client will sign transactions
    // for wrong network without any warning or validation
    // Current behavior: NO VALIDATION - client blindly trusts API
    
    // Expected behavior: Client should validate chain_id=1 for mainnet
    assert_eq!(
        chain_id_from_api,
        ChainId::mainnet(),
        "Chain ID should match expected mainnet value, but no validation exists"
    );
}

#[tokio::test] 
async fn test_missing_validation_demonstration() {
    use reqwest::header::HeaderMap;
    
    // Simulate API headers with WRONG chain_id
    let mut headers = HeaderMap::new();
    headers.insert("X-Aptos-Chain-Id", "2".parse().unwrap()); // Testnet
    headers.insert("X-Aptos-Ledger-Version", "1000".parse().unwrap());
    headers.insert("X-Aptos-Ledger-Timestamp", "1234567890".parse().unwrap());
    headers.insert("X-Aptos-Epoch", "10".parse().unwrap());
    headers.insert("X-Aptos-Ledger-Oldest-Version", "0".parse().unwrap());
    headers.insert("X-Aptos-Block-Height", "100".parse().unwrap());
    headers.insert("X-Aptos-Oldest-Block-Height", "0".parse().unwrap());
    
    // Current implementation: from_headers accepts ANY chain_id
    let state = aptos_rest_client::State::from_headers(&headers).unwrap();
    
    // Proof: Wrong chain_id accepted without validation
    assert_eq!(state.chain_id, 2); // Testnet chain_id accepted
    
    // No error thrown, no validation performed
    // Client would proceed to sign transactions for testnet
    // while user believes they're on mainnet
}
```

## Notes

The vulnerability does **not** enable direct cross-chain transaction replay due to robust on-chain validation in the transaction prologue. However, it enables a more insidious attack: network substitution, where users unknowingly transact on an entirely different blockchain than intended. This can lead to fund loss, business logic failures, and user confusion about transaction status and asset locations.

### Citations

**File:** crates/aptos-rest-client/src/state.rs (L23-102)
```rust
    pub fn from_headers(headers: &reqwest::header::HeaderMap) -> anyhow::Result<Self> {
        let maybe_chain_id = headers
            .get(X_APTOS_CHAIN_ID)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_version = headers
            .get(X_APTOS_LEDGER_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_timestamp = headers
            .get(X_APTOS_LEDGER_TIMESTAMP)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_epoch = headers
            .get(X_APTOS_EPOCH)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_ledger_version = headers
            .get(X_APTOS_LEDGER_OLDEST_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_block_height = headers
            .get(X_APTOS_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_block_height = headers
            .get(X_APTOS_OLDEST_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let cursor = headers
            .get(X_APTOS_CURSOR)
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string());

        let state = if let (
            Some(chain_id),
            Some(version),
            Some(timestamp_usecs),
            Some(epoch),
            Some(oldest_ledger_version),
            Some(block_height),
            Some(oldest_block_height),
            cursor,
        ) = (
            maybe_chain_id,
            maybe_version,
            maybe_timestamp,
            maybe_epoch,
            maybe_oldest_ledger_version,
            maybe_block_height,
            maybe_oldest_block_height,
            cursor,
        ) {
            Self {
                chain_id,
                epoch,
                version,
                timestamp_usecs,
                oldest_ledger_version,
                block_height,
                oldest_block_height,
                cursor,
            }
        } else {
            anyhow::bail!(
                "Failed to build State from headers due to missing values in response. \
                Chain ID: {:?}, Version: {:?}, Timestamp: {:?}, Epoch: {:?}, \
                Oldest Ledger Version: {:?}, Block Height: {:?} Oldest Block Height: {:?}",
                maybe_chain_id,
                maybe_version,
                maybe_timestamp,
                maybe_epoch,
                maybe_oldest_ledger_version,
                maybe_block_height,
                maybe_oldest_block_height,
            )
        };

        Ok(state)
    }
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L16-32)
```rust
pub enum AptosBaseUrl {
    Mainnet,
    Devnet,
    Testnet,
    Custom(Url),
}

impl AptosBaseUrl {
    pub fn to_url(&self) -> Url {
        match self {
            AptosBaseUrl::Mainnet => Url::from_str("https://api.mainnet.aptoslabs.com").unwrap(),
            AptosBaseUrl::Devnet => Url::from_str("https://api.devnet.aptoslabs.com").unwrap(),
            AptosBaseUrl::Testnet => Url::from_str("https://api.testnet.aptoslabs.com").unwrap(),
            AptosBaseUrl::Custom(url) => url.to_owned(),
        }
    }
}
```

**File:** crates/aptos/src/common/transactions.rs (L197-200)
```rust
        let chain_id = ChainId::new(state.chain_id);

        let transaction_factory =
            TransactionFactory::new(chain_id).with_gas_unit_price(gas_unit_price);
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L143-143)
```text
        assert!(chain_id::get() == chain_id, error::invalid_argument(PROLOGUE_EBAD_CHAIN_ID));
```

**File:** crates/aptos-rosetta/src/common.rs (L33-46)
```rust
pub fn check_network(
    network_identifier: NetworkIdentifier,
    server_context: &RosettaContext,
) -> ApiResult<()> {
    if network_identifier.blockchain == BLOCKCHAIN
        && ChainId::from_str(network_identifier.network.trim())
            .map_err(|_| ApiError::NetworkIdentifierMismatch)?
            == server_context.chain_id
    {
        Ok(())
    } else {
        Err(ApiError::NetworkIdentifierMismatch)
    }
}
```

**File:** types/src/chain_id.rs (L11-24)
```rust
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum NamedChain {
    /// Users might accidentally initialize the ChainId field to 0, hence reserving ChainId 0 for accidental
    /// initialization.
    /// MAINNET is the Aptos mainnet production chain and is reserved for 1
    MAINNET = 1,
    // Even though these CHAIN IDs do not correspond to MAINNET, changing them should be avoided since they
    // can break test environments for various organisations.
    TESTNET = 2,
    DEVNET = 3,
    TESTING = 4,
    PREMAINNET = 5,
}
```
