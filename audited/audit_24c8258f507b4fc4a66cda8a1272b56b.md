# Audit Report

## Title
Panic in Transaction Filter Causes Service-Wide Crash via Invalid Transaction Type

## Summary
The `TransactionRootFilter::matches()` function uses `.expect()` when converting transaction type values, causing a panic if the protobuf data contains invalid enum values. This can crash the entire LiveDataService, terminating all active client streams.

## Finding Description

The vulnerability exists in the transaction filtering logic used by the indexer-grpc-data-service-v2. When a client requests transactions with a `TransactionRootFilter` that filters by transaction type, the filter matching code performs an unsafe enum conversion that can panic. [1](#0-0) 

The code uses `.expect()` to unwrap the result of `TransactionType::try_from()`, which will panic if the i32 value doesn't correspond to a valid TransactionType enum variant. The valid values are 0, 1, 2, 3, 4, 20, and 21, leaving gaps at 5-19 and 22+. [2](#0-1) 

Protobuf deserialization via prost does NOT validate enum values - any i32 is accepted and stored in the `r#type` field. [3](#0-2) 

The call chain is:
1. Client sends GetTransactionsRequest with TransactionRootFilter
2. `LiveDataService::start_streaming()` spawned as scoped async task [4](#0-3) 
3. Calls `in_memory_cache.get_data()` with filter [5](#0-4) 
4. `get_data()` calls `filter.matches(transaction)` [6](#0-5) 
5. Panic occurs in TransactionRootFilter::matches()

Since `LiveDataService::run()` uses `tokio_scoped::scope()` [7](#0-6) , a panic in any scoped task can propagate and terminate the entire service handler, affecting all clients.

## Impact Explanation

This qualifies as **High Severity** under "API crashes" category. When triggered, it causes:
- Immediate termination of the affected client stream
- Potential crash of entire LiveDataService affecting all connected clients
- No graceful error handling or client notification
- Service unavailability requiring restart

However, this is NOT a core blockchain vulnerability - it affects the indexer ecosystem component, not consensus, execution, or state management.

## Likelihood Explanation

**Low to Medium Likelihood**. Exploitation requires:
- Transactions with invalid type field values (5-19, 22-23, etc.) to exist in the cache
- Client must use TransactionRootFilter with txn_type filter
- Normal operation uses `convert_transaction()` which always sets valid types [8](#0-7) 

Possible scenarios:
- Compromised/buggy upstream gRPC data source
- Data corruption during transmission
- Future protocol changes adding new transaction types without updating this service
- Network protocol version mismatches

## Recommendation

Replace `.expect()` with proper error handling to gracefully skip invalid transactions:

```rust
if let Some(txn_type) = &self.txn_type {
    match TransactionType::try_from(item.r#type) {
        Ok(actual_type) => {
            if txn_type != &actual_type {
                return false;
            }
        }
        Err(_) => {
            // Log warning about invalid transaction type and skip
            tracing::warn!(
                "Encountered transaction with invalid type value: {}",
                item.r#type
            );
            return false;
        }
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_protos::transaction::v1::{Transaction, TransactionInfo};
    
    #[test]
    #[should_panic(expected = "Invalid transaction type")]
    fn test_invalid_transaction_type_panics() {
        let filter = TransactionRootFilterBuilder::default()
            .txn_type(TransactionType::User)
            .build()
            .unwrap();
        
        let mut txn = Transaction::default();
        txn.r#type = 5; // Invalid type value (gap in enum)
        txn.info = Some(TransactionInfo {
            success: true,
            ..Default::default()
        });
        
        // This will panic
        filter.matches(&txn);
    }
}
```

**Notes:**
While this is a valid defensive programming issue, its security impact is limited because:
1. It affects an ecosystem indexer service, not core blockchain components
2. It requires abnormal conditions (invalid transaction types) that shouldn't occur in normal operation
3. The official transaction conversion logic always produces valid types
4. It's primarily an availability/reliability issue rather than a funds/consensus security vulnerability

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/transaction_root.rs (L67-73)
```rust
        if let Some(txn_type) = &self.txn_type {
            if txn_type
                != &TransactionType::try_from(item.r#type).expect("Invalid transaction type")
            {
                return false;
            }
        }
```

**File:** protos/proto/aptos/transaction/v1/transaction.proto (L47-56)
```text
  enum TransactionType {
    TRANSACTION_TYPE_UNSPECIFIED = 0;
    TRANSACTION_TYPE_GENESIS = 1;
    TRANSACTION_TYPE_BLOCK_METADATA = 2;
    TRANSACTION_TYPE_STATE_CHECKPOINT = 3;
    TRANSACTION_TYPE_USER = 4;
    // values 5-19 skipped for no reason
    TRANSACTION_TYPE_VALIDATOR = 20;
    TRANSACTION_TYPE_BLOCK_EPILOGUE = 21;
  }
```

**File:** protos/rust/src/pb/aptos.transaction.v1.rs (L51-52)
```rust
    #[prost(enumeration="transaction::TransactionType", tag="6")]
    pub r#type: i32,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L66-66)
```rust
        tokio_scoped::scope(|scope| {
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L127-139)
```rust
                scope.spawn(async move {
                    self.start_streaming(
                        id,
                        starting_version,
                        ending_version,
                        max_num_transactions_per_batch,
                        MAX_BYTES_PER_BATCH,
                        filter,
                        request_metadata,
                        response_sender,
                    )
                    .await
                });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L185-194)
```rust
            if let Some((transactions, batch_size_bytes, last_processed_version)) = self
                .in_memory_cache
                .get_data(
                    next_version,
                    ending_version,
                    max_num_transactions_per_batch,
                    max_bytes_per_batch,
                    &filter,
                )
                .await
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/in_memory_cache.rs (L90-90)
```rust
                    if filter.is_none() || filter.as_ref().unwrap().matches(transaction) {
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L835-851)
```rust
    let txn_type = match transaction {
        Transaction::UserTransaction(_) => transaction::transaction::TransactionType::User,
        Transaction::GenesisTransaction(_) => transaction::transaction::TransactionType::Genesis,
        Transaction::BlockMetadataTransaction(_) => {
            transaction::transaction::TransactionType::BlockMetadata
        },
        Transaction::StateCheckpointTransaction(_) => {
            transaction::transaction::TransactionType::StateCheckpoint
        },
        Transaction::BlockEpilogueTransaction(_) => {
            transaction::transaction::TransactionType::BlockEpilogue
        },
        Transaction::PendingTransaction(_) => panic!("PendingTransaction is not supported"),
        Transaction::ValidatorTransaction(_) => {
            transaction::transaction::TransactionType::Validator
        },
    };
```
