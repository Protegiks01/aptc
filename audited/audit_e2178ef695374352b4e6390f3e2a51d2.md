# Audit Report

## Title
Out-of-Order Proposal Processing Allows Equivocation Detection Evasion in UnequivocalProposerElection

## Summary

The `is_valid_proposal()` function in `UnequivocalProposerElection` updates its internal state to track the highest round seen, causing equivocating proposals from lower rounds to be silently rejected without logging security events when proposals arrive out of order. This allows malicious proposers to evade equivocation detection by strategically timing their proposal broadcasts.

## Finding Description

The `UnequivocalProposerElection` wrapper is designed to detect when a leader proposes multiple different blocks for the same round (equivocation). It maintains an `already_proposed` state tracking the highest round and block ID seen. [1](#0-0) 

When `is_valid_proposal()` processes a proposal, it compares the proposal's round against the stored round: [2](#0-1) 

The vulnerability occurs when proposals arrive out of order:

1. A proposal for round 7 arrives and updates state to `(7, block_id_7)` via the `Ordering::Greater` branch
2. Subsequently, an equivocating proposal for round 5 (second different block for that round) arrives
3. The comparison yields `Ordering::Less` (5 < 7), causing immediate rejection without equivocation logging
4. The security event at lines 71-78 is never triggered because that code only executes for `Ordering::Equal`

The RoundManager explicitly handles out-of-order proposals by sorting buffered proposals and processing them: [3](#0-2) 

This proves that out-of-order arrival is an expected scenario in the system design.

**Attack Path:**
1. Malicious proposer L creates two different blocks (A and B) for round R
2. L immediately broadcasts Block A to some validators  
3. L delays broadcasting Block B to other validators
4. Honest proposers for rounds R+1, R+2, etc. create valid proposals
5. Due to network delays or the malicious timing, validators process proposals for round R+2 or higher before receiving Block B
6. When Block B arrives, it's rejected with `Ordering::Less` without logging the equivocation attempt
7. The malicious proposer evades detection and can repeat the attack

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program as a "significant protocol violation." 

The impact includes:
- **Equivocation detection evasion**: Malicious validators can propose multiple blocks for the same round without detection
- **No accountability**: Missing security event logs mean no evidence for slashing or reputation penalties
- **Undermined security monitoring**: The consensus layer's equivocation detection mechanism can be bypassed
- **Repeated attacks**: Without detection, malicious validators can repeatedly equivocate

While this doesn't directly break consensus safety (the equivocating proposals are still rejected and not voted on), it severely undermines the protocol's ability to detect and punish Byzantine behavior, which is critical for long-term network security.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploitable because:

1. **Expected behavior**: The RoundManager code explicitly handles out-of-order proposals, showing this is a normal operational scenario
2. **Network realities**: In distributed systems, messages naturally arrive out of order due to varying network latencies, routing paths, and congestion
3. **Low attacker cost**: A malicious proposer needs only to strategically delay one proposal broadcast while others propagate normally
4. **No special access required**: Any validator elected as proposer can attempt this attack
5. **Difficult to detect**: Without security event logging, the attack leaves no trace

The attack requires no collusion, no majority stake, and no special network positionâ€”just normal proposer duties and basic control over broadcast timing.

## Recommendation

Maintain a fixed-size buffer (e.g., last 10-20 rounds) of proposals per round to enable equivocation detection even when proposals arrive out of order. Alternatively, implement separate logging for old proposals to preserve forensic evidence:

```rust
pub fn is_valid_proposal(&self, block: &Block) -> bool {
    block.author().is_some_and(|author| {
        let valid_author = self.is_valid_proposer(author, block.round());
        if !valid_author {
            // ... existing logging ...
            return false;
        }
        
        let mut already_proposed = self.already_proposed.lock();
        match block.round().cmp(&already_proposed.0) {
            Ordering::Greater => {
                already_proposed.0 = block.round();
                already_proposed.1 = block.id();
                true
            },
            Ordering::Equal => {
                if already_proposed.1 != block.id() {
                    error!(
                        SecurityEvent::InvalidConsensusProposal,
                        "Multiple proposals from {} for round {}: {} and {}",
                        author, block.round(), already_proposed.1, block.id()
                    );
                    false
                } else {
                    true
                }
            },
            Ordering::Less => {
                // NEW: Log old proposals separately for forensic analysis
                warn!(
                    SecurityEvent::InvalidConsensusProposal,
                    "Late proposal from {} for old round {}, current tracking round {}. Possible delayed equivocation attempt. Block ID: {}",
                    author, block.round(), already_proposed.0, block.id()
                );
                false
            }
        }
    })
}
```

A more robust solution would maintain a `HashMap<Round, HashValue>` for recent rounds (with bounded size) to properly detect equivocation regardless of arrival order.

## Proof of Concept

```rust
#[test]
fn test_out_of_order_equivocation_evasion() {
    use crate::liveness::unequivocal_proposer_election::UnequivocalProposerElection;
    use aptos_consensus_types::{
        block::{block_test_utils::certificate_for_genesis, Block},
        common::Payload,
    };
    use aptos_types::validator_signer::ValidatorSigner;
    use std::{collections::HashMap, sync::Arc};
    
    // Setup
    let signer = ValidatorSigner::random([0u8; 32]);
    let author = signer.author();
    let qc = certificate_for_genesis();
    
    let proposers = HashMap::from([
        (5, author),
        (7, author),
    ]);
    let pe = UnequivocalProposerElection::new(
        Arc::new(MockProposerElection::new(proposers))
    );
    
    // Create two different blocks for round 5 (equivocation)
    let block_5_a = Block::new_proposal(
        Payload::empty(false, true),
        5, 100, qc.clone(), &signer, Vec::new()
    ).unwrap();
    
    let block_5_b = Block::new_proposal(
        Payload::empty(false, true),
        5, 200, qc.clone(), &signer, Vec::new()
    ).unwrap();
    
    // Create block for round 7
    let block_7 = Block::new_proposal(
        Payload::empty(false, true),
        7, 300, qc.clone(), &signer, Vec::new()
    ).unwrap();
    
    // Process round 5 block A first
    assert!(pe.is_valid_proposal(&block_5_a));
    
    // Process round 7 (updates state to round 7)
    assert!(pe.is_valid_proposal(&block_7));
    
    // Now process the equivocating round 5 block B
    // This should detect equivocation but doesn't - it's silently rejected
    // Expected: Security event logged
    // Actual: Returns false with no security logging
    assert!(!pe.is_valid_proposal(&block_5_b));
    
    // The equivocation went undetected because the state
    // already advanced to round 7, so round 5 proposals
    // are rejected as "old" via Ordering::Less branch
}
```

## Notes

The security question mentions "multiple threads processing proposals," but the actual implementation processes proposals sequentially in the RoundManager's event loop. [4](#0-3)  However, the logical vulnerability exists even in single-threaded sequential processing when proposals arrive out of order, which is explicitly handled by the system. The core issue is that the `is_valid_proposal` function's state management assumes in-order processing but operates in a context where out-of-order arrival is normal.

### Citations

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L20-20)
```rust
    already_proposed: Mutex<(Round, HashValue)>,
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L63-85)
```rust
            match block.round().cmp(&already_proposed.0) {
                Ordering::Greater => {
                    already_proposed.0 = block.round();
                    already_proposed.1 = block.id();
                    true
                },
                Ordering::Equal => {
                    if already_proposed.1 != block.id() {
                        error!(
                            SecurityEvent::InvalidConsensusProposal,
                            "Multiple proposals from {} for round {}: {} and {}",
                            author,
                            block.round(),
                            already_proposed.1,
                            block.id()
                        );
                        false
                    } else {
                        true
                    }
                },
                Ordering::Less => false,
            }
```

**File:** consensus/src/round_manager.rs (L2107-2112)
```rust
                    proposals.sort_by_key(get_round);
                    // If the first proposal is not for the next round, we only process the last proposal.
                    // to avoid going through block retrieval of many garbage collected rounds.
                    if self.round_state.current_round() + 1 < get_round(&proposals[0]) {
                        proposals = vec![proposals.pop().unwrap()];
                    }
```

**File:** consensus/src/round_manager.rs (L2113-2143)
```rust
                    for proposal in proposals {
                        let result = match proposal {
                            VerifiedEvent::ProposalMsg(proposal_msg) => {
                                monitor!(
                                    "process_proposal",
                                    self.process_proposal_msg(*proposal_msg).await
                                )
                            }
                            VerifiedEvent::VerifiedProposalMsg(proposal_msg) => {
                                monitor!(
                                    "process_verified_proposal",
                                    self.process_delayed_proposal_msg(*proposal_msg).await
                                )
                            }
                            VerifiedEvent::OptProposalMsg(proposal_msg) => {
                                monitor!(
                                    "process_opt_proposal",
                                    self.process_opt_proposal_msg(*proposal_msg).await
                                )
                            }
                            unexpected_event => unreachable!("Unexpected event: {:?}", unexpected_event),
                        };
                        let round_state = self.round_state();
                        match result {
                            Ok(_) => trace!(RoundStateLogSchema::new(round_state)),
                            Err(e) => {
                                counters::ERROR_COUNT.inc();
                                warn!(kind = error_kind(&e), RoundStateLogSchema::new(round_state), "Error: {:#}", e);
                            }
                        }
                    }
```
