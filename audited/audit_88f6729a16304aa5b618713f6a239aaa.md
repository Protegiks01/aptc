# Audit Report

## Title
Missing Bounds Validation in DKG Public Key Share Retrieval Causes Potential Validator Node Crash

## Summary
The `get_public_key_share()` function in the DKG PVSS transcript implementation does not validate that the requested player ID is within valid bounds, despite receiving a `SecretSharingConfig` parameter (`sc`) that contains this information. This missing validation allows out-of-bounds array access that will panic and crash validator nodes during epoch transitions when the validator set size exceeds the DKG transcript's expected size.

## Finding Description

The `get_public_key_share()` function receives a `SecretSharingConfig` parameter but ignores it completely: [1](#0-0) 

The function directly accesses `self.V[player.id]` without validating that `player.id < sc.n`. The `V` array contains `sc.n` public key shares (indices 0 to n-1) plus one dealt public key at index `n`, as verified during transcript validation: [2](#0-1) 

The vulnerability is exploitable during epoch transitions. In the consensus epoch manager, public key shares are retrieved for all validators in the new epoch: [3](#0-2) 

**Critical Issue**: There is no validation that `new_epoch_state.verifier.len()` equals `dkg_pub_params.pvss_config.wconfig.n` (the number of validators the DKG transcript was created for). The code comment explicitly states "No need to verify the transcript": [4](#0-3) 

**Root Cause**: The DKG transcript is created for a projected validator set captured when DKG starts: [5](#0-4) 

However, when the new epoch actually starts, the validator set is **recalculated** dynamically by `on_new_epoch()`: [6](#0-5) 

These two calculations can produce different validator set sizes if:
1. Reward distributions change validator stakes between DKG start and epoch start
2. Validators fall below minimum stake thresholds after reward calculations
3. Pending validators are activated with different timing than projected

**Player ID Validation Gap**: The `Player` struct has a public `id` field, allowing arbitrary Player instances to be created: [7](#0-6) 

Despite comments indicating only `SecretSharingConfig` should create Players, the public field allows direct instantiation: [8](#0-7) 

## Impact Explanation

**Severity: Critical** - This vulnerability causes **total loss of liveness/network availability** when triggered.

When `new_epoch_state.verifier.len() > dkg_pub_params.pvss_config.wconfig.n`, the iteration in epoch_manager creates Player instances with IDs beyond the transcript's valid range. Calling `get_public_key_share()` with these IDs triggers an array index out-of-bounds panic in Rust, immediately crashing the validator node.

**Network-Wide Impact**: Since all validator nodes execute the same code path when transitioning to a new epoch, **every validator in the network will crash simultaneously** when this condition occurs. This results in:
- Complete network halt - no blocks can be produced
- Loss of consensus - no validator can participate
- Requires emergency intervention (hard fork or manual fixes) to recover

This meets the Critical Severity criteria: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: Medium-Low**

The vulnerability triggers when the projected validator set size (at DKG start) differs from the actual validator set size (at epoch start). While validator set changes are blocked during reconfiguration: [9](#0-8) 

The `on_new_epoch()` function still recalculates the validator set dynamically, which could produce different results than the initial projection. This is more likely during:
- Periods of high validator churn (many joining/leaving)
- Borderline stake situations where validators hover near minimum stake
- Reward calculation edge cases affecting validator eligibility

The likelihood is reduced by:
- Validator set blocking during reconfiguration providing some consistency
- Most epoch transitions having stable validator sets
- Testing typically catching obvious mismatches

However, the complete absence of a size validation check means this is a **latent bug** waiting for the right edge case to trigger catastrophic failure.

## Recommendation

**Fix 1: Add bounds validation in `get_public_key_share()`**

The unused `sc` parameter should be used to validate player ID bounds:

```rust
fn get_public_key_share(
    &self,
    sc: &Self::SecretSharingConfig,  // Remove underscore prefix
    player: &Player,
) -> Self::DealtPubKeyShare {
    assert!(
        player.id < sc.n,
        "Player ID {} exceeds valid range [0, {})",
        player.id,
        sc.n
    );
    Self::DealtPubKeyShare::new(Self::DealtPubKey::new(self.V[player.id]))
}
```

**Fix 2: Add validator set size validation in epoch_manager**

Before retrieving public key shares, validate the sizes match:

```rust
// After line 1079 in consensus/src/epoch_manager.rs
ensure!(
    new_epoch_state.verifier.len() == dkg_pub_params.pvss_config.wconfig.n,
    "Validator set size mismatch: epoch has {} validators but DKG transcript created for {}",
    new_epoch_state.verifier.len(),
    dkg_pub_params.pvss_config.wconfig.n
);

let pk_shares = (0..new_epoch_state.verifier.len())
    .map(|id| {
        transcript
            .main
            .get_public_key_share(&dkg_pub_params.pvss_config.wconfig, &Player { id })
    })
    .collect::<Vec<_>>();
```

**Fix 3: Make Player construction safer**

Make the `id` field private and require construction through `SecretSharingConfig`:

```rust
pub struct Player {
    id: usize,  // Remove 'pub'
}
```

All three fixes should be applied for defense-in-depth.

## Proof of Concept

This vulnerability is triggered through normal protocol execution when validator set size mismatches occur. A reproduction would require:

1. **Setup**: Initialize a validator set with N validators
2. **DKG Start**: Begin DKG for epoch transition with N validators projected
3. **State Change**: Between DKG start and epoch finalization, cause validator state changes that result in N+M validators after `on_new_epoch()` recalculation (e.g., through reward distributions causing previously ineligible validators to meet minimum stake)
4. **Epoch Transition**: When the new epoch starts, all validators execute the code path that attempts to retrieve N+M public key shares from a transcript containing only N shares
5. **Crash**: All validators panic on array index out of bounds when accessing `V[N], V[N+1], ..., V[N+M-1]`

The exact reproduction requires manipulating on-chain state to create the validator set size mismatch, which would be done through Move tests simulating epoch transitions with carefully crafted validator stake distributions.

---

**Notes**

The vulnerability exists in the actual DKG implementation used by weighted transcripts as well: [10](#0-9) 

This shows the pattern is repeated across multiple transcript implementations, indicating a systemic design issue where bounds validation was overlooked throughout the DKG codebase.

### Citations

**File:** crates/aptos-dkg/src/pvss/insecure_field/transcript.rs (L117-123)
```rust
    fn get_public_key_share(
        &self,
        _sc: &Self::SecretSharingConfig,
        player: &Player,
    ) -> Self::DealtPubKeyShare {
        Self::DealtPubKeyShare::new(Self::DealtPubKey::new(self.V[player.id]))
    }
```

**File:** crates/aptos-dkg/src/pvss/insecure_field/transcript.rs (L173-179)
```rust
        if self.V.len() != sc.n + 1 {
            bail!(
                "Expected {} (polynomial) commitment elements, but got {}",
                sc.n + 1,
                self.V.len()
            );
        }
```

**File:** consensus/src/epoch_manager.rs (L1063-1063)
```rust
        // No need to verify the transcript.
```

**File:** consensus/src/epoch_manager.rs (L1080-1086)
```rust
        let pk_shares = (0..new_epoch_state.verifier.len())
            .map(|id| {
                transcript
                    .main
                    .get_public_key_share(&dkg_pub_params.pvss_config.wconfig, &Player { id })
            })
            .collect::<Vec<_>>();
```

**File:** types/src/dkg/real_dkg/mod.rs (L211-217)
```rust
        let pvss_config = build_dkg_pvss_config(
            dkg_session_metadata.dealer_epoch,
            secrecy_threshold,
            reconstruct_threshold,
            maybe_fast_path_secrecy_threshold,
            &dkg_session_metadata.target_validator_consensus_infos_cloned(),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1402)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
        validator_set.total_voting_power = total_voting_power;
```

**File:** crates/aptos-crypto/src/player.rs (L21-24)
```rust
pub struct Player {
    /// A number from 0 to n-1.
    pub id: usize,
}
```

**File:** crates/aptos-crypto/src/player.rs (L26-28)
```rust
/// The point of Player is to provide type-safety: ensure nobody creates out-of-range player IDs.
/// So there is no `new()` method; only the SecretSharingConfig trait is allowed to create them.
// TODO: AFAIK the only way to really enforce this is to put both traits inside the same module (or use unsafe Rust)
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L32-32)
```text
        reconfiguration_state::on_reconfig_start();
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L550-563)
```rust
    fn get_public_key_share(
        &self,
        _sc: &Self::SecretSharingConfig,
        player: &Player,
    ) -> Self::DealtPubKeyShare {
        self.subtrs.Vs[player.id]
            .iter()
            .map(|V_i| {
                let affine = V_i.into_affine();

                keys::DealtPubKeyShare::<E>::new(keys::DealtPubKey::new(affine))
            })
            .collect()
    }
```
