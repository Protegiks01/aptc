# Audit Report

## Title
Missing Validation in Groth16 Verification Key Setting Enables DoS Against All Keyless Accounts

## Summary
The `set_groth16_verification_key_for_next_epoch` function accepts Groth16 verification keys without validating that the elliptic curve point encodings are canonical and deserializable. A validation function exists but is never called. This allows governance proposals to accidentally set verification keys with invalid byte encodings, causing all validators to fail VK deserialization and permanently disabling all keyless accounts using zero-knowledge proofs until another governance proposal fixes the issue.

## Finding Description

The Groth16 verification key (VK) is stored on-chain and used by validators to verify zero-knowledge proofs in keyless transactions. The VK contains serialized BN254 elliptic curve points in compressed format.

**The Vulnerability Path:**

1. **VK Construction Without Validation**: The Move function `new_groth16_verification_key` constructs a VK from raw byte vectors without any validation. [1](#0-0) 

2. **Setting VK Without Validation**: When a governance proposal calls `set_groth16_verification_key_for_next_epoch`, the VK is accepted without validation and directly queued for the next epoch. [2](#0-1) 

3. **Unused Validation Function**: A validation function `validate_groth16_vk` exists that checks if all BN254 curve points can be deserialized correctly, but it is NEVER called anywhere in the codebase. [3](#0-2) 

4. **False Assumption in Comments**: The code contains a comment stating "although, currently, we do check for that in `keyless_account.move`" which is demonstrably false. [4](#0-3) 

5. **Deserialization Failure at Runtime**: When validators load the environment, they fetch the VK and attempt to convert it to `PreparedVerifyingKey` using `try_into().ok()`, which returns `None` if deserialization fails due to invalid point encodings. [5](#0-4) 

6. **Conversion Enforces Canonical Validation**: The `TryFrom` implementation calls `deserialize_compressed` on each elliptic curve point, which validates canonical encoding and rejects non-canonical or invalid byte sequences. [6](#0-5) 

7. **All ZK Keyless Transactions Fail**: When a ZK keyless transaction arrives, if `pvk.is_none()` (because deserialization failed), the validator returns an error "Groth16 VK has not been set on-chain". [7](#0-6) 

**How Governance Proposals Set VKs**: Governance scripts construct VKs by calling `new_groth16_verification_key` with hex-encoded byte vectors, then passing the result directly to `set_groth16_verification_key_for_next_epoch`. [8](#0-7) 

This creates a vulnerability where invalid bytes can bypass all validation layers and reach on-chain storage, only to fail during validator runtime when actual cryptographic operations are attempted.

## Impact Explanation

**Severity: HIGH** - This qualifies as "Validator node slowdowns" and causes "Significant protocol violations" under the Aptos bug bounty criteria.

**Impact:**
- **Complete DoS of keyless accounts**: All keyless accounts using zero-knowledge proofs become unable to transact because validators cannot deserialize the VK
- **Network-wide effect**: Affects all validators simultaneously since they all load the same on-chain VK
- **Recovery requires governance**: Fixing the issue requires another governance proposal to pass and an epoch change, which takes time and coordination
- **No funds loss**: Accounts are not drained, funds remain safe, but accounts become temporarily unusable

The issue reaches HIGH severity but not CRITICAL because:
- Funds are not permanently lost (accounts can recover after VK fix)
- Network continues operating normally for non-keyless accounts
- No consensus safety violation occurs
- No permanent state corruption

## Likelihood Explanation

**Likelihood: MEDIUM**

This vulnerability represents a **logic bug** - missing defensive validation that was clearly intended to exist. The evidence for developer intent includes:
- The validation function exists but is unused
- Code comments claim validation happens but it doesn't
- The validation function's own comment suggests it should be used to enable optimization

The vulnerability could be triggered through:
1. **Accidental misconfiguration**: A governance proposal script with bugs that generates invalid VK bytes
2. **Copy-paste errors**: Manually constructing VK bytes with typos or incorrect hex encoding
3. **Tooling issues**: External tools generating VKs incorrectly from circuit parameters
4. **Encoding mistakes**: Using wrong byte lengths or non-compressed formats

The likelihood is MEDIUM (not LOW) because:
- The validation function exists but is unused, indicating an unintentional gap
- No safeguards exist to catch this error before the VK goes on-chain
- Governance proposals involve complex hex-encoded cryptographic parameters where errors can occur
- The normal path through `From<PreparedVerifyingKey>` produces valid encodings, but can be bypassed

The likelihood is not HIGH because:
- Requires governance approval (not an unprivileged attack)
- Governance participants are generally careful with critical operations

## Recommendation

Add validation by calling `validate_groth16_vk` in both VK-setting functions:

```move
public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk);  // ADD THIS LINE
    config_buffer::upsert<Groth16VerificationKey>(vk);
}

public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    chain_status::assert_genesis();
    validate_groth16_vk(&vk);  // ADD THIS LINE
    move_to(fx, vk);
}
```

This ensures that all VKs are validated before being stored on-chain, preventing invalid encodings from causing runtime failures.

## Proof of Concept

While a full PoC requires generating intentionally malformed BN254 curve points, the vulnerability can be demonstrated by tracing the code paths:

1. Create a governance script that calls `new_groth16_verification_key` with malformed hex bytes (e.g., wrong length or invalid point encoding)
2. The VK is constructed without validation [1](#0-0) 
3. The VK is set without validation [2](#0-1) 
4. On epoch change, validators load the VK [5](#0-4) 
5. Deserialization fails, `pvk` becomes `None`
6. All ZK keyless transactions fail [7](#0-6) 

The unused validation function that should prevent this: [3](#0-2) 

## Notes

This vulnerability is a **logic bug** rather than an assumption of malicious governance. The validation function exists and was clearly intended to be used (based on code comments and function documentation), but was never actually called. This represents a missing defensive check that should exist regardless of caller trust level, as proper defensive programming requires validation even of inputs from trusted sources.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L145-158)
```text
    public fun new_groth16_verification_key(alpha_g1: vector<u8>,
                                            beta_g2: vector<u8>,
                                            gamma_g2: vector<u8>,
                                            delta_g2: vector<u8>,
                                            gamma_abc_g1: vector<vector<u8>>
    ): Groth16VerificationKey {
        Groth16VerificationKey {
            alpha_g1,
            beta_g2,
            gamma_g2,
            delta_g2,
            gamma_abc_g1,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L287-293)
```rust
        // We use an `Option` to handle the VK not being set on-chain, or an incorrect VK being set
        // via governance (although, currently, we do check for that in `keyless_account.move`).
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```

**File:** types/src/keyless/groth16_vk.rs (L75-87)
```rust
            alpha_g1: G1Affine::deserialize_compressed(vk.alpha_g1.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            beta_g2: G2Affine::deserialize_compressed(vk.beta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_g2: G2Affine::deserialize_compressed(vk.gamma_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            delta_g2: G2Affine::deserialize_compressed(vk.delta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_abc_g1: vec![
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[0].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[1].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L188-191)
```rust
    // If there are ZK authenticators, the Groth16 VK must have been set on-chain.
    if with_zk && pvk.is_none() {
        return Err(invalid_signature!("Groth16 VK has not been set on-chain"));
    }
```

**File:** testsuite/smoke-test/src/keyless.rs (L1026-1027)
```rust
        let vk = {}::new_groth16_verification_key(x"{}", x"{}", x"{}", x"{}", vector[x"{}", x"{}"]);
        {}::set_groth16_verification_key_for_next_epoch(&framework_signer, vk);
```
