# Audit Report

## Title
Man-in-the-Middle Attack Enabling chain_id Tampering in Fullnode gRPC Stream Without TLS

## Summary
The `GetTransactionsFromNode` gRPC service transmits the `chain_id` separately from the cryptographically signed transaction data in the protobuf schema. Without TLS, a MITM attacker can modify the `chain_id` field in `TransactionsFromNodeResponse` messages, and receiving clients have no cryptographic mechanism to verify that the tampered `chain_id` matches the value originally embedded in the signed `RawTransaction`.

## Finding Description

The vulnerability exists in the protobuf schema design for transaction transmission via the `GetTransactionsFromNode` gRPC service.

**Root Cause - Protobuf Schema Design Flaw:**

The `UserTransactionRequest` protobuf message does not include a `chain_id` field: [1](#0-0) 

Instead, the `chain_id` is transmitted separately in the `TransactionsFromNodeResponse`: [2](#0-1) 

However, the `RawTransaction` that was originally signed DOES include `chain_id`: [3](#0-2) 

The signature verification validates the signature against the entire `RawTransaction` including its embedded `chain_id`: [4](#0-3) 

**The Attack:**

1. Client connects to fullnode via `GetTransactionsFromNode` without TLS (configurable option): [5](#0-4) 

2. MITM attacker intercepts the stream and modifies the `chain_id` field in `TransactionsFromNodeResponse` messages

3. Client receives transactions with tampered `chain_id` and stores/processes them

4. Client verification only checks against cached metadata, NOT cryptographically: [6](#0-5) 

5. If the client's cached metadata is also compromised or unavailable (first connection), the attack succeeds undetected

**Why Cryptographic Verification is Impossible:**

When converting protobuf back to `RawTransaction`, the `chain_id` must be provided externally as a parameter - it cannot be extracted from the signed transaction data: [7](#0-6) 

## Impact Explanation

**Severity: Medium**

This vulnerability enables:

1. **Chain Confusion Attacks**: Indexers and data processors could be tricked into believing mainnet transactions are from testnet (or vice versa), causing incorrect data routing and storage

2. **Metadata Poisoning**: Services that cache chain_id metadata could be poisoned on first connection, perpetuating the incorrect chain_id for subsequent operations

3. **Cross-Chain Replay Confusion**: While the transactions themselves remain cryptographically valid for their original chain (due to the signed chain_id), monitoring systems could be confused about which chain they're observing

**Limitations preventing Critical severity:**
- Does not allow modification of actual transaction data (signature protection)
- Does not enable direct fund theft
- Requires active MITM position
- Many deployments use TLS
- Clients typically verify against stored metadata

This qualifies as **Medium Severity** under Aptos bug bounty criteria: "State inconsistencies requiring intervention" - incorrect chain_id can cause data pipeline inconsistencies.

## Likelihood Explanation

**Likelihood: Medium-Low**

**Factors increasing likelihood:**
- Non-TLS configuration is explicitly supported as a deployment option
- MITM position is achievable on unencrypted connections
- Attack requires no special privileges
- No cryptographic verification exists to detect tampering

**Factors decreasing likelihood:**
- TLS is available and recommended
- Most production deployments likely use TLS
- Clients verify against cached metadata as defense-in-depth
- Primary use case (indexing) has some resilience

## Recommendation

**Option 1: Include chain_id in Signed Transaction Protobuf (Recommended)**

Modify the `UserTransactionRequest` protobuf to include the `chain_id` field so it's part of the serialized signed data:

```protobuf
message UserTransactionRequest {
  string sender = 1;
  uint64 sequence_number = 2 [jstype = JS_STRING];
  uint64 max_gas_amount = 3 [jstype = JS_STRING];
  uint64 gas_unit_price = 4 [jstype = JS_STRING];
  aptos.util.timestamp.Timestamp expiration_timestamp_secs = 5;
  TransactionPayload payload = 6;
  Signature signature = 7;
  uint32 chain_id = 8;  // ADD THIS FIELD
}
```

Clients can then cryptographically verify that the `chain_id` in the response matches the `chain_id` in the signed transaction.

**Option 2: Enforce TLS Requirement**

Make TLS mandatory for the `GetTransactionsFromNode` service:

```rust
// In IndexerGrpcDataServiceConfig validation
fn validate(&self) -> Result<()> {
    if self.data_service_grpc_non_tls_config.is_some() {
        bail!("Non-TLS configuration is no longer supported for security reasons");
    }
    // ... rest of validation
}
```

**Option 3: Add Cryptographic Chain Binding**

Include a chain-specific signature or commitment in the response that binds transactions to the chain_id.

## Proof of Concept

```rust
// Demonstration of chain_id tampering vulnerability
// This shows how a MITM can modify chain_id without detection

use aptos_protos::internal::fullnode::v1::{
    TransactionsFromNodeResponse, 
    transactions_from_node_response,
    TransactionsOutput
};

// Simulated MITM interceptor
fn mitm_tamper_chain_id(mut response: TransactionsFromNodeResponse) -> TransactionsFromNodeResponse {
    // Attacker changes mainnet (chain_id=1) to testnet (chain_id=2)
    response.chain_id = 2;  // TAMPERING - no cryptographic protection!
    
    // The transaction data inside remains validly signed for chain_id=1,
    // but the response-level chain_id now claims it's chain_id=2
    response
}

// Client receives tampered response
fn client_process(response: TransactionsFromNodeResponse) {
    // Client sees chain_id = 2 (tampered)
    let received_chain_id = response.chain_id;
    
    // But the embedded signed transaction was actually for chain_id = 1
    // Client has NO WAY to cryptographically verify this mismatch
    // because chain_id is not in the protobuf UserTransactionRequest
    
    println!("Client believes transactions are for chain_id: {}", received_chain_id);
    println!("Actual chain_id in signed RawTransaction: 1 (unverifiable from protobuf)");
}
```

**Attack Flow:**
1. Fullnode streams transactions with `chain_id = 1` (mainnet)
2. MITM intercepts and changes response `chain_id` to `2` (testnet)  
3. Indexer receives data, stores it as testnet data
4. Indexer's mainnet pipeline receives no data, testnet pipeline receives mainnet data
5. Data inconsistency persists until manual intervention

**Notes:**
- The transaction signatures remain valid (they protect transaction content)
- The `chain_id` field in the response is NOT cryptographically protected
- Without TLS, this field can be silently modified
- Clients cannot verify the tampering without external metadata sources

### Citations

**File:** protos/proto/aptos/transaction/v1/transaction.proto (L186-194)
```text
message UserTransactionRequest {
  string sender = 1;
  uint64 sequence_number = 2 [jstype = JS_STRING];
  uint64 max_gas_amount = 3 [jstype = JS_STRING];
  uint64 gas_unit_price = 4 [jstype = JS_STRING];
  aptos.util.timestamp.Timestamp expiration_timestamp_secs = 5;
  TransactionPayload payload = 6;
  Signature signature = 7;
}
```

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L47-54)
```text
message TransactionsFromNodeResponse {
  oneof response {
    StreamStatus status = 1;
    TransactionsOutput data = 2;
  }
  // Making sure that all the responses include a chain id
  uint32 chain_id = 3;
}
```

**File:** types/src/transaction/mod.rs (L179-205)
```rust
pub struct RawTransaction {
    /// Sender's address.
    sender: AccountAddress,

    /// Sequence number of this transaction. This must match the sequence number
    /// stored in the sender's account at the time the transaction executes.
    sequence_number: u64,

    /// The transaction payload, e.g., a script to execute.
    payload: TransactionPayload,

    /// Maximal total gas to spend for this transaction.
    max_gas_amount: u64,

    /// Price to be paid per gas unit.
    gas_unit_price: u64,

    /// Expiration timestamp for this transaction, represented
    /// as seconds from the Unix Epoch. If the current blockchain timestamp
    /// is greater than or equal to this time, then the transaction has
    /// expired and will be discarded. This can be set to a large value far
    /// in the future to indicate that a transaction does not expire.
    expiration_timestamp_secs: u64,

    /// Chain ID of the Aptos network this transaction is intended for.
    chain_id: ChainId,
}
```

**File:** types/src/transaction/authenticator.rs (L160-174)
```rust
    pub fn verify(&self, raw_txn: &RawTransaction) -> Result<()> {
        let num_sigs: usize = self.sender().number_of_signatures()
            + self
                .secondary_signers()
                .iter()
                .map(|auth| auth.number_of_signatures())
                .sum::<usize>();
        if num_sigs > MAX_NUM_OF_SIGS {
            return Err(Error::new(AuthenticationError::MaxSignaturesExceeded));
        }
        match self {
            Self::Ed25519 {
                public_key,
                signature,
            } => signature.verify(raw_txn, public_key),
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L48-54)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcDataServiceConfig {
    /// If given, we will run a server that uses TLS.
    pub data_service_grpc_tls_config: Option<TlsConfig>,
    /// If given, we will run a server that does not use TLS.
    pub data_service_grpc_non_tls_config: Option<NonTlsConfig>,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L310-323)
```rust
    // Guaranteed that chain id is here at this point because we already ensure that fileworker did the set up
    let chain_id = cache_operator.get_chain_id().await?.unwrap();
    if chain_id != fullnode_chain_id as u64 {
        bail!("[Indexer Cache] Chain ID mismatch between fullnode init signal and cache.");
    }

    // It's required to start the worker with the same version as file store.
    if file_store_metadata.version != starting_version {
        bail!("[Indexer Cache] Starting version mismatch between filestore metadata and fullnode init signal.");
    }
    if file_store_metadata.chain_id != fullnode_chain_id as u64 {
        bail!("[Indexer Cache] Chain id mismatch between filestore metadata and fullnode.");
    }

```

**File:** api/types/src/convert.rs (L645-678)
```rust
    pub fn try_into_raw_transaction_poem(
        &self,
        user_transaction_request: UserTransactionRequestInner,
        chain_id: ChainId,
    ) -> Result<RawTransaction> {
        let UserTransactionRequestInner {
            sender,
            sequence_number,
            max_gas_amount,
            gas_unit_price,
            expiration_timestamp_secs,
            payload,
            replay_protection_nonce,
        } = user_transaction_request;
        Ok(RawTransaction::new(
            sender.into(),
            // The `sequence_number` field is not used for processing orderless transactions.
            // However, the `SignedTransaction` strucut has a mandatory sequence_number field.
            // So, for orderless transactions, we chose to set the sequence_number to u64::MAX.
            if replay_protection_nonce.is_none() {
                sequence_number.into()
            } else {
                u64::MAX
            },
            self.try_into_aptos_core_transaction_payload(
                payload,
                replay_protection_nonce.map(|nonce| nonce.into()),
            )
            .context("Failed to parse transaction payload")?,
            max_gas_amount.into(),
            gas_unit_price.into(),
            expiration_timestamp_secs.into(),
            chain_id,
        ))
```
