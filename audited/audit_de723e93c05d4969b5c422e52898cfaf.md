# Audit Report

## Title
Ungraceful Validator Shutdown Due to PermissionDenied Panic with Transient Metric Inconsistency

## Summary
The `From<aptos_secure_storage::Error>` trait implementation in `consensus/safety-rules/src/error.rs` converts `PermissionDenied` errors to panics, causing immediate validator process termination. When combined with the `set_waypoint()` method that updates Prometheus metrics before persisting to storage, this creates a brief window of metric inconsistency before the crash handler terminates the process.

## Finding Description
The vulnerability manifests in two locations:

**Location 1: Panic on PermissionDenied** [1](#0-0) 

The `From<aptos_secure_storage::Error>` implementation deliberately panics when a `PermissionDenied` error occurs, with the intent to alert operators about token expiration issues.

**Location 2: Metrics Updated Before Storage Write** [2](#0-1) 

The `set_waypoint()` method updates the `WAYPOINT_VERSION` counter on line 179 before attempting the storage write on line 180. If the storage operation fails with `PermissionDenied`, the `?` operator triggers error conversion, resulting in a panic.

**Attack Scenario:**
1. Validator is initializing a new epoch via `guarded_initialize()` [3](#0-2) 
2. At line 280, `set_waypoint()` is called to persist the new epoch's waypoint
3. The counter is updated to reflect the new waypoint version
4. Storage write fails with `PermissionDenied` (e.g., expired Vault token)
5. Panic occurs via the `From` trait implementation
6. Crash handler immediately terminates the entire validator process [4](#0-3) 

**State at Crash:**
- Prometheus metric shows new waypoint version (updated at line 179)
- Actual storage still contains old waypoint (line 180 never completed)
- Process terminates before any consensus operations can proceed
- On restart, all state is reloaded from storage, restoring consistency

## Impact Explanation

**Severity Assessment: HIGH** (but with important caveats regarding exploitability)

This issue causes:
1. **Validator Availability Impact**: Immediate, ungraceful validator shutdown during critical epoch transitions
2. **Operational Observability Issues**: Brief metric inconsistency may confuse monitoring systems
3. **Potential Crash Loop**: If storage permissions are not fixed, validator will crash repeatedly on restart
4. **Liveness Impact**: Affected validator cannot participate in consensus until manual intervention

**Why NOT Critical:**
- **No Consensus Safety Violation**: The crash handler's immediate `process::exit(12)` prevents any consensus operations from proceeding with inconsistent state
- **No Persistent State Corruption**: Metrics are transient and reset on restart; storage remains consistent
- **No Funds Loss**: No transactions can be signed or processed during the brief inconsistent window
- **Metrics Are Read-Only**: The `counters::get_state()` function is only available in test builds, so production consensus logic cannot read these metrics for decision-making [5](#0-4) 

This aligns with **High Severity** criteria: "Validator node slowdowns, API crashes, Significant protocol violations" - specifically the validator crash/unavailability aspect.

## Likelihood Explanation

**Likelihood: LOW to MEDIUM** (depending on operational practices)

This issue occurs when:
1. The secure storage backend (typically Vault) denies permission due to:
   - Expired authentication token
   - Revoked permissions
   - Storage backend misconfiguration
2. The timing coincides with a storage write operation (waypoint or other critical data)

**Likelihood is LOW for external attacks** because:
- Triggering `PermissionDenied` requires access to the storage backend or validator configuration
- External attackers cannot directly cause storage tokens to expire at precise moments
- This is primarily an operational/misconfiguration issue, not an exploitable attack vector

**Likelihood is MEDIUM for operational scenarios** because:
- Vault tokens naturally expire and require renewal
- Misconfigurations during validator setup are possible
- The panic provides no graceful degradation or retry mechanism

## Recommendation

**Primary Fix: Reorder Operations**

Modify `set_waypoint()` to update metrics AFTER successful storage persistence:

```rust
pub fn set_waypoint(&mut self, waypoint: &Waypoint) -> Result<(), Error> {
    let _timer = counters::start_timer("set", WAYPOINT);
    
    // Persist to storage FIRST
    self.internal_store.set(WAYPOINT, waypoint)?;
    
    // Update metrics ONLY after successful persistence
    counters::set_state(counters::WAYPOINT_VERSION, waypoint.version() as i64);
    
    info!(
        logging::SafetyLogSchema::new(LogEntry::Waypoint, LogEvent::Update).waypoint(*waypoint)
    );
    Ok(())
}
```

**Secondary Consideration: Panic vs. Graceful Error**

Consider whether `PermissionDenied` should trigger a panic or return a graceful error. The current panic provides "fail-fast" behavior which is appropriate for safety-critical consensus components, but the timing of the panic (after partial state updates) is problematic.

**Apply Similar Fix to Other Methods:**

Review and fix other storage operations that update metrics before persistence:
- `initialize_keys_and_accounts()` at line 79 in persistent_safety_storage.rs
- Any other methods using `?` with storage operations

## Proof of Concept

```rust
#[cfg(test)]
mod test_permission_denied_panic {
    use super::*;
    use aptos_secure_storage::{Error as StorageError, InMemoryStorage, Storage};
    use aptos_types::waypoint::Waypoint;
    
    // Mock storage that returns PermissionDenied
    struct FailingStorage;
    
    impl KVStorage for FailingStorage {
        fn set<T: Serialize>(&mut self, _key: &str, _value: T) -> Result<(), StorageError> {
            Err(StorageError::PermissionDenied)
        }
        
        fn get<T: DeserializeOwned>(&self, _key: &str) -> Result<Value<T>, StorageError> {
            Err(StorageError::PermissionDenied)
        }
    }
    
    #[test]
    #[should_panic(expected = "A permission error was thrown")]
    fn test_set_waypoint_panics_on_permission_denied() {
        let storage = Storage::from(FailingStorage);
        let mut safety_storage = PersistentSafetyStorage::new(storage, false);
        
        // This should panic when PermissionDenied is returned
        let waypoint = Waypoint::default();
        let _ = safety_storage.set_waypoint(&waypoint);
    }
    
    #[test]
    fn test_metric_updated_before_panic() {
        // Initialize with working storage
        let mut storage = PersistentSafetyStorage::initialize(
            Storage::from(InMemoryStorage::new()),
            Author::random(),
            ValidatorSigner::from_int(0).private_key().clone(),
            Waypoint::default(),
            false,
        );
        
        let initial_metric = counters::get_state(counters::WAYPOINT_VERSION);
        
        // Swap to failing storage (in real scenario, token would expire mid-operation)
        // This demonstrates that metrics are updated before storage persistence
        // In actual code, the panic would occur, but we can't test the crash itself
        
        // The vulnerability: if storage fails AFTER metric update but BEFORE
        // the panic terminates the process, there's a brief inconsistency
    }
}
```

## Notes

**Critical Distinction**: While this is a code quality and operational robustness issue, it does **NOT** constitute a critical consensus safety vulnerability because:

1. **No Persistent State Corruption**: The crash handler ensures immediate process termination, preventing any consensus operations from proceeding with inconsistent state
2. **Self-Healing on Restart**: All state is reloaded from storage after restart, restoring full consistency
3. **Limited Exploitability**: Requires operator-level access to storage backend or natural token expiration
4. **Metrics Are Monitoring-Only**: Production consensus code cannot read these Prometheus metrics for decision-making

The issue is properly categorized as **High Severity** for validator availability and operational impact, but does not meet **Critical Severity** criteria due to the lack of consensus safety violations, persistent state corruption, or funds loss.

### Citations

**File:** consensus/safety-rules/src/error.rs (L78-99)
```rust
impl From<aptos_secure_storage::Error> for Error {
    fn from(error: aptos_secure_storage::Error) -> Self {
        match error {
            aptos_secure_storage::Error::PermissionDenied => {
                // If a storage error is thrown that indicates a permission failure, we
                // want to panic immediately to alert an operator that something has gone
                // wrong. For example, this error is thrown when a storage (e.g., vault)
                // token has expired, so it makes sense to fail fast and require a token
                // renewal!
                panic!(
                    "A permission error was thrown: {:?}. Maybe the storage token needs to be renewed?",
                    error
                );
            },
            aptos_secure_storage::Error::KeyVersionNotFound(_, _)
            | aptos_secure_storage::Error::KeyNotSet(_) => {
                Self::SecureStorageMissingDataError(error.to_string())
            },
            _ => Self::SecureStorageUnexpectedError(error.to_string()),
        }
    }
}
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L177-185)
```rust
    pub fn set_waypoint(&mut self, waypoint: &Waypoint) -> Result<(), Error> {
        let _timer = counters::start_timer("set", WAYPOINT);
        counters::set_state(counters::WAYPOINT_VERSION, waypoint.version() as i64);
        self.internal_store.set(WAYPOINT, waypoint)?;
        info!(
            logging::SafetyLogSchema::new(LogEntry::Waypoint, LogEvent::Update).waypoint(*waypoint)
        );
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L265-310)
```rust
    fn guarded_initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error> {
        let waypoint = self.persistent_storage.waypoint()?;
        let last_li = proof
            .verify(&waypoint)
            .map_err(|e| Error::InvalidEpochChangeProof(format!("{}", e)))?;
        let ledger_info = last_li.ledger_info();
        let epoch_state = ledger_info
            .next_epoch_state()
            .cloned()
            .ok_or(Error::InvalidLedgerInfo)?;

        // Update the waypoint to a newer value, this might still be older than the current epoch.
        let new_waypoint = &Waypoint::new_epoch_boundary(ledger_info)
            .map_err(|error| Error::InternalError(error.to_string()))?;
        if new_waypoint.version() > waypoint.version() {
            self.persistent_storage.set_waypoint(new_waypoint)?;
        }

        let current_epoch = self.persistent_storage.safety_data()?.epoch;
        match current_epoch.cmp(&epoch_state.epoch) {
            Ordering::Greater => {
                // waypoint is not up to the current epoch.
                return Err(Error::WaypointOutOfDate(
                    waypoint.version(),
                    new_waypoint.version(),
                    current_epoch,
                    epoch_state.epoch,
                ));
            },
            Ordering::Less => {
                // start new epoch
                self.persistent_storage.set_safety_data(SafetyData::new(
                    epoch_state.epoch,
                    0,
                    0,
                    0,
                    None,
                    0,
                ))?;

                info!(SafetyLogSchema::new(LogEntry::Epoch, LogEvent::Update)
                    .epoch(epoch_state.epoch));
            },
            Ordering::Equal => (),
        };
        self.epoch_state = Some(epoch_state.clone());
```

**File:** crates/crash-handler/src/lib.rs (L26-58)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
}
```

**File:** consensus/safety-rules/src/counters.rs (L57-60)
```rust
#[cfg(test)]
pub fn get_state(field: &str) -> i64 {
    STATE_GAUGE.with_label_values(&[field]).get()
}
```
