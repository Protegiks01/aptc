# Audit Report

## Title
Unauthenticated Network Topology Disclosure via Inspection Service Exposes All Peers for Targeted Attacks and Censorship

## Summary
The Aptos inspection service exposes comprehensive network topology information including all connected peers, their IP addresses, network classifications, and connection metadata through an unauthenticated HTTP endpoint enabled by default. This allows attackers to map the entire network, identify non-validator nodes, and facilitate targeted attacks or censorship.

## Finding Description

The inspection service endpoint `/peer_information` at `crates/aptos-inspection-service/src/server/peer_information.rs` exposes sensitive network topology information without authentication. The vulnerability manifests through multiple information disclosure vectors within the same endpoint:

**Primary Exposure (Lines 224-225):** [1](#0-0) 

This exposes both `priority_peers` and `regular_peers` classifications, revealing:
- All connected peer identifiers (PeerNetworkId)
- Network type classification (Validator, VFN, Public)
- Priority categorization (high/medium/low priority)

**Secondary Exposure (Connection Metadata):** [2](#0-1) 

This exposes `ConnectionMetadata` for each peer, which includes: [3](#0-2) 

The `addr: NetworkAddress` field contains IP addresses, DNS names, and TCP ports through the Protocol enum: [4](#0-3) 

**Default Configuration Weakness:** [5](#0-4) 

The endpoint is:
- Enabled by default (`expose_peer_information: true`)
- Bound to all interfaces (`0.0.0.0:9101`)
- Accessible without authentication [6](#0-5) 

**Peer Classification Logic:** [7](#0-6) 

This classification exposes:
- For validators: All VFN and PFN connections
- For VFNs: All trusted validators and PFN connections  
- For PFNs: All peer connections

**Attack Scenario:**

1. Attacker queries `http://<any-node>:9101/peer_information`
2. Receives complete list of connected peers with IP addresses
3. Identifies node types via NetworkId (Validator/Vfn/Public)
4. Maps network topology by recursively querying discovered nodes
5. Launches targeted attacks:
   - DDoS specific validator VFNs to isolate validators
   - Identify and compromise PFN nodes running public APIs
   - Block connections at ISP/national firewall level for censorship
   - Correlate on-chain activity with specific node operators

## Impact Explanation

This qualifies as **HIGH severity** per Aptos bug bounty criteria for multiple reasons:

1. **Enables Validator Node Slowdowns**: By identifying all VFN connections to validators and their IP addresses, attackers can launch targeted attacks to slow down or isolate validators from the network, potentially affecting consensus liveness.

2. **Significant Protocol Violations**: The Aptos network relies on peer-to-peer connectivity for state synchronization and consensus. Exposing the complete network topology with IP addresses violates reasonable privacy expectations and enables systematic network-level attacks.

3. **Network Censorship Risk**: Nation-states or ISPs can use this information to:
   - Discover all Aptos nodes in their jurisdiction
   - Implement comprehensive blocking at network borders
   - Target specific node operators

4. **API Infrastructure Targeting**: Public fullnodes running APIs can be identified and targeted for attacks, affecting ecosystem services.

5. **Cascading Network Discovery**: A single compromised or accessible node exposes information about the entire network through recursive queries, creating a complete topology map.

The comprehensive nature of the exposure—combining peer classification, IP addresses, connection metadata, and network topology—elevates this beyond a "minor information leak" to a significant security vulnerability.

## Likelihood Explanation

**Likelihood: HIGH**

1. **No Prerequisites**: Any attacker with network connectivity to any Aptos node can exploit this
2. **Default Configuration**: The vulnerability is present out-of-the-box on all nodes unless explicitly disabled
3. **Public Accessibility**: The endpoint binds to `0.0.0.0` making it accessible from any network interface
4. **Simple Exploitation**: Requires only HTTP GET requests, no special tools or expertise
5. **Current Deployment**: The default configuration shows this is likely exposed on testnet, devnet, and potentially mainnet nodes

The only barrier is the configuration flag, but since it defaults to `true` and there's no sanitizer preventing it on mainnet (unlike `expose_configuration`), this is actively exploitable on deployed networks.

## Recommendation

Implement multiple layers of defense:

**1. Disable by Default for Production:**
```rust
// In config/src/config/inspection_service_config.rs
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(), // Changed from "0.0.0.0"
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false, // Changed from true
            expose_peer_information: false,     // Changed from true
            expose_system_information: false,   // Changed from true
        }
    }
}
```

**2. Add Authentication:**
```rust
// Add authentication check before exposing peer information
fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
    auth_token: Option<String>, // Add authentication
) -> (StatusCode, Body, String) {
    // Verify authentication token
    if !verify_admin_token(auth_token, &node_config) {
        return (
            StatusCode::UNAUTHORIZED,
            Body::from("Authentication required"),
            CONTENT_TYPE_TEXT.into(),
        );
    }
    // Rest of implementation...
}
```

**3. Sanitize for Mainnet:**
```rust
// In config/src/config/inspection_service_config.rs
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                // Block peer information exposure on mainnet
                if inspection_service_config.expose_peer_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet nodes should not expose peer information!".to_string(),
                    ));
                }
            }
        }
        // existing checks...
    }
}
```

**4. Redact Sensitive Information:**
If peer information must be exposed for debugging, redact IP addresses and only show peer IDs:
```rust
// Redact ConnectionMetadata IP addresses
let redacted_metadata = ConnectionMetadata {
    remote_peer_id: metadata.remote_peer_id,
    connection_id: metadata.connection_id,
    addr: NetworkAddress::from_str("/redacted").unwrap(),
    origin: metadata.origin,
    messaging_protocol: metadata.messaging_protocol,
    application_protocols: metadata.application_protocols.clone(),
    role: metadata.role,
};
```

## Proof of Concept

**Exploitation Steps:**

1. Start any Aptos node with default configuration
2. Execute reconnaissance:
```bash
# Query peer information endpoint
curl http://<node-ip>:9101/peer_information

# Expected output includes:
# - Priority peers: [Validator:abc123, Validator:def456, ...]
# - Regular peers: [Public:xyz789, Public:uvw012, ...]
# - Connection metadata for each peer:
#   - Peer: Public:xyz789, connection metadata: {"addr":"/ip4/1.2.3.4/tcp/6180/...", ...}
```

3. Parse response to extract:
   - All peer IDs and their network classifications
   - IP addresses from ConnectionMetadata
   - Connection directions (inbound/outbound)

4. Build network topology map by recursively querying discovered nodes

5. Launch targeted attack:
   - Identify validator VFNs (high-priority VFN network peers)
   - Target their IP addresses for network-level blocking or DDoS
   - Isolate validators from state sync data sources

**Verification:**
```rust
#[test]
fn test_peer_information_exposure() {
    // Start inspection service with default config
    let config = NodeConfig::default();
    assert!(config.inspection_service.expose_peer_information); // Enabled by default
    assert_eq!(config.inspection_service.address, "0.0.0.0"); // Publicly accessible
    
    // Simulate HTTP request (no auth required)
    let response = handle_peer_information_request(
        &config,
        aptos_data_client,
        peers_and_metadata,
    );
    
    // Verify sensitive information is exposed
    assert_eq!(response.0, StatusCode::OK);
    let body = response.1;
    assert!(body.contains("Regular peers:")); // Peer classification exposed
    assert!(body.contains("connection metadata:")); // IP addresses exposed
}
```

## Notes

The vulnerability exists at the intersection of multiple design decisions:
1. The debugging endpoint was designed for operator convenience
2. Default configuration prioritizes ease-of-use over security
3. No authentication mechanism was implemented
4. No sanitizer blocks this on mainnet (unlike `expose_configuration`)

While individual peer discovery is possible through P2P protocols, this endpoint provides comprehensive, instantaneous network mapping including IP addresses, classifications, and topology—significantly lowering the barrier for network-wide attacks and censorship.

### Citations

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L159-165)
```rust
            let connection_metadata = peer_metadata.get_connection_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, connection state: {:?}, connection metadata: {}",
                peer,
                peer_metadata.get_connection_state(),
                serde_json::to_string(&connection_metadata).unwrap_or_default()
            ));
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L223-226)
```rust
        peer_information_output.push(format!(
            "\t- Priority peers: {:?}, regular peers: {:?}",
            priority_peers, regular_peers
        ));
```

**File:** network/framework/src/transport/mod.rs (L99-108)
```rust
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** types/src/network_address/mod.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

#![allow(clippy::arc_with_non_send_sync)]

use aptos_crypto::{
    traits::{CryptoMaterialError, ValidCryptoMaterialStringExt},
    x25519,
};
#[cfg(any(test, feature = "fuzzing"))]
use proptest::prelude::*;
#[cfg(any(test, feature = "fuzzing"))]
use proptest_derive::Arbitrary;
use serde::{de, Deserialize, Deserializer, Serialize, Serializer};
use std::{
    convert::{Into, TryFrom},
    fmt,
    iter::IntoIterator,
    net::{self, IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, ToSocketAddrs},
    num,
    str::FromStr,
    string::ToString,
};
use thiserror::Error;

const MAX_DNS_NAME_SIZE: usize = 255;

/// ## Overview
///
/// Aptos `NetworkAddress` is a compact, efficient, self-describing and
/// future-proof network address represented as a stack of protocols. Essentially
/// libp2p's [multiaddr] but using [`bcs`] to describe the binary format.
///
/// Most validators will advertise a network address like:
///
/// `/dns/example.com/tcp/6180/noise-ik/<x25519-pubkey>/handshake/1`
///
/// Unpacking, the above effectively means:
///
/// 1. Resolve the DNS name "example.com" to an ip address, `addr`.
/// 2. Open a TCP connection to `(addr, 6180)`.
/// 3. Perform a Noise IK handshake and assume the peer's static pubkey is
///    `<x25519-pubkey>`. After this step, we will have a secure, authenticated
///    connection with the peer.
/// 4. Perform a AptosNet version negotiation handshake (version 1).
///
/// ## Self-describing, Upgradable
///
/// One key concept behind `NetworkAddress` is that it is fully self-describing,
/// which allows us to easily "pre-negotiate" protocols while also allowing for
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-169)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };
```

**File:** state-sync/aptos-data-client/src/priority.rs (L53-122)
```rust
pub fn get_peer_priority(
    base_config: Arc<BaseConfig>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    peer: &PeerNetworkId,
) -> PeerPriority {
    // Handle the case that this node is a validator
    let peer_network_id = peer.network_id();
    if base_config.role.is_validator() {
        // Validators should highly prioritize other validators
        if peer_network_id.is_validator_network() {
            return PeerPriority::HighPriority;
        }

        // VFNs should be prioritized over PFNs. Note: having PFNs
        // connected to a validator is a rare (but possible) scenario.
        return if peer_network_id.is_vfn_network() {
            PeerPriority::MediumPriority
        } else {
            PeerPriority::LowPriority
        };
    }

    // Handle the case that this node is a VFN
    if peers_and_metadata
        .get_registered_networks()
        .contains(&NetworkId::Vfn)
    {
        // VFNs should highly prioritize validators
        if peer_network_id.is_vfn_network() {
            return PeerPriority::HighPriority;
        }

        // Trusted peers should be prioritized over untrusted peers.
        // This prioritizes other VFNs/seed peers over regular PFNs.
        if is_trusted_peer(peers_and_metadata.clone(), peer) {
            return PeerPriority::MediumPriority;
        }

        // Outbound connections should be prioritized over inbound connections.
        // This prioritizes other VFNs/seed peers over regular PFNs.
        return if let Some(metadata) = utils::get_metadata_for_peer(&peers_and_metadata, *peer) {
            if metadata.get_connection_metadata().is_outbound_connection() {
                PeerPriority::MediumPriority
            } else {
                PeerPriority::LowPriority
            }
        } else {
            PeerPriority::LowPriority // We don't have connection metadata
        };
    }

    // Otherwise, this node is a PFN. PFNs should highly
    // prioritize trusted peers (i.e., VFNs and seed peers).
    if is_trusted_peer(peers_and_metadata.clone(), peer) {
        return PeerPriority::HighPriority;
    }

    // Outbound connections should be prioritized. This prioritizes
    // other VFNs/seed peers over regular PFNs. Inbound connections
    // are always low priority (as they are generally unreliable).
    if let Some(metadata) = utils::get_metadata_for_peer(&peers_and_metadata, *peer) {
        if metadata.get_connection_metadata().is_outbound_connection() {
            PeerPriority::HighPriority
        } else {
            PeerPriority::LowPriority
        }
    } else {
        PeerPriority::LowPriority // We don't have connection metadata
    }
}
```
