# Audit Report

## Title
Stack Overflow Panic in File-Based Discovery Causes Complete Node Crash

## Summary
The file-based peer discovery system in `network/discovery/src/file.rs` uses `serde_yaml::from_str()` to parse YAML configuration files without any recursion depth limits or panic handling. When parsing deeply nested YAML structures, `serde_yaml` can trigger a stack overflow panic that propagates through the Stream implementation and is caught by the global panic handler in `crates/crash-handler/src/lib.rs`, which terminates the entire node process with `process::exit(12)`. This is significantly worse than merely crashing the discovery subsystem—it causes total loss of node availability.

## Finding Description

The vulnerability exists in the file-based peer discovery mechanism. [1](#0-0) 

The `load_file()` function uses `serde_yaml::from_str()` to deserialize a `PeerSet` (which is `HashMap<PeerId, Peer>`) from YAML. [2](#0-1) 

While `serde_yaml::from_str()` returns a `Result` under normal circumstances, it performs **recursive parsing** without depth limits. When presented with deeply nested YAML structures (e.g., hundreds of levels of nested mappings), the parser will overflow the stack and **panic** rather than returning an error.

The panic propagation path is as follows:

1. `load_file()` panics during `serde_yaml::from_str()` - no panic handler present [1](#0-0) 

2. Panic propagates through `FileStream::poll_next()` - no panic handler [3](#0-2) 

3. Panic propagates through `DiscoveryChangeStream::poll_next()` - no panic handler [4](#0-3) 

4. Panic propagates to the async task spawned by `spawn_named!("DiscoveryChangeListener", ...)` [5](#0-4) 

5. The global panic handler catches all panics and **terminates the entire process** [6](#0-5) 

The panic handler explicitly kills the process with `process::exit(12)` for all panics except those occurring in the Move VM verifier/deserializer. [7](#0-6) 

**Attack Scenario:**

An attacker who gains write access to the discovery file (through system compromise, misconfiguration, supply chain attack, or compromised orchestration) can inject a malicious YAML file with deeply nested structures. When the discovery subsystem polls this file, the stack overflow panic will crash the entire node.

Example malicious YAML structure:
```yaml
peer_id_1:
  addresses: []
  keys: []
  role:
    nested1:
      nested2:
        nested3:
          # ... repeat nesting 500+ times ...
```

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria: "Validator node slowdowns, API crashes, Significant protocol violations")

This vulnerability causes **complete node unavailability** by crashing the entire process, which is actually more severe than the typical "API crashes" category:

1. **Validator Impact**: A crashed validator cannot participate in consensus, leading to:
   - Loss of staking rewards
   - Potential slashing if downtime exceeds thresholds
   - Degraded network performance if multiple validators are affected
   - Consensus liveness issues if enough validators crash

2. **Fullnode Impact**: Crashed fullnodes lose all services:
   - API unavailability
   - State sync interruption
   - Transaction submission failures
   - Network connectivity loss

3. **No Graceful Recovery**: Unlike an error that logs and continues, `process::exit(12)` requires manual intervention to restart the node.

The vulnerability violates critical invariants:
- **Liveness**: Nodes must remain operational
- **Fault Tolerance**: Config parsing errors should not terminate the process
- **Availability**: Discovery failures should degrade gracefully, not crash

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH** (conditional on specific deployment scenarios)

The vulnerability requires an attacker to have write access to the file specified in `FileDiscovery.path`. [8](#0-7) 

While this is not achievable by an unprivileged network attacker, several realistic scenarios enable exploitation:

1. **Misconfiguration**: Discovery file in world-writable directory (e.g., `/tmp`)
2. **Shared Storage**: File on network-mounted filesystem with weak permissions
3. **Supply Chain**: Malicious YAML injected during deployment automation
4. **Compromised Orchestration**: Kubernetes ConfigMaps, Ansible playbooks, or other automation tools that manage the discovery file
5. **Insider Threat**: Malicious operator or compromised credentials

The attack itself is trivial once file access is obtained—generating deeply nested YAML takes seconds. The lack of any recursion depth checking in the codebase (unlike the extensive depth limits in Move VM) [9](#0-8)  suggests this attack vector was not considered.

## Recommendation

Implement **multi-layered protection** against stack overflow panics in YAML parsing:

**1. Add panic recovery with `catch_unwind` in `load_file()`:**

```rust
fn load_file(path: &Path) -> Result<PeerSet, DiscoveryError> {
    use std::panic::catch_unwind;
    use std::panic::AssertUnwindSafe;
    
    let contents = std::fs::read_to_string(path).map_err(DiscoveryError::IO)?;
    
    // Wrap serde_yaml parsing in catch_unwind to prevent process termination
    catch_unwind(AssertUnwindSafe(|| {
        serde_yaml::from_str(&contents)
    }))
    .unwrap_or_else(|_| Err(serde_yaml::Error::custom("YAML parsing panicked (possible stack overflow)")))
    .map_err(|err| DiscoveryError::Parsing(err.to_string()))
}
```

**2. Implement pre-validation with depth checking:**

```rust
fn validate_yaml_depth(value: &serde_yaml::Value, current_depth: usize, max_depth: usize) -> Result<(), String> {
    if current_depth > max_depth {
        return Err(format!("YAML exceeds maximum nesting depth of {}", max_depth));
    }
    
    match value {
        serde_yaml::Value::Mapping(m) => {
            for (k, v) in m {
                validate_yaml_depth(k, current_depth + 1, max_depth)?;
                validate_yaml_depth(v, current_depth + 1, max_depth)?;
            }
        }
        serde_yaml::Value::Sequence(s) => {
            for item in s {
                validate_yaml_depth(item, current_depth + 1, max_depth)?;
            }
        }
        _ => {}
    }
    Ok(())
}

fn load_file(path: &Path) -> Result<PeerSet, DiscoveryError> {
    const MAX_YAML_DEPTH: usize = 32; // Similar to Move VM depth limits
    
    let contents = std::fs::read_to_string(path).map_err(DiscoveryError::IO)?;
    
    // Parse to generic Value first for depth validation
    let yaml_value: serde_yaml::Value = serde_yaml::from_str(&contents)
        .map_err(|err| DiscoveryError::Parsing(err.to_string()))?;
    
    validate_yaml_depth(&yaml_value, 0, MAX_YAML_DEPTH)
        .map_err(DiscoveryError::Parsing)?;
    
    // Now deserialize to PeerSet
    serde_yaml::from_value(yaml_value)
        .map_err(|err| DiscoveryError::Parsing(err.to_string()))
}
```

**3. Consider migrating to safer YAML parsers** that have built-in recursion limits, or use structured config formats like TOML that are less prone to deep nesting.

## Proof of Concept

Create a malicious discovery file that triggers stack overflow:

```rust
use std::fs::File;
use std::io::Write;

fn generate_deeply_nested_yaml(depth: usize) -> String {
    let mut yaml = String::new();
    yaml.push_str("00000000000000000000000000000000:\n");
    yaml.push_str("  addresses: []\n");
    yaml.push_str("  keys: []\n");
    yaml.push_str("  role:\n");
    
    for i in 0..depth {
        yaml.push_str(&format!("{}nested{}: \n", "  ".repeat(i + 2), i));
    }
    yaml.push_str(&format!("{}value\n", "  ".repeat(depth + 2)));
    
    yaml
}

fn main() {
    // Generate YAML with 1000 levels of nesting (will cause stack overflow)
    let malicious_yaml = generate_deeply_nested_yaml(1000);
    
    let mut file = File::create("/tmp/malicious_discovery.yaml").unwrap();
    file.write_all(malicious_yaml.as_bytes()).unwrap();
    
    println!("Malicious discovery file created at /tmp/malicious_discovery.yaml");
    println!("Configure FileDiscovery to point to this file to trigger the crash");
}
```

To test, configure a node with file-based discovery:
```yaml
discovery_methods:
  - file:
      path: /tmp/malicious_discovery.yaml
      interval_secs: 5
```

Upon the next discovery poll, the node will crash with exit code 12.

---

**Notes:**

This vulnerability demonstrates a critical gap in error handling philosophy: while the Move VM extensively protects against deeply nested structures through constants like `DEFAULT_MAX_VM_VALUE_NESTED_DEPTH` (128) and `MAX_TYPE_TAG_NESTING` (8), the configuration parsing layer has no such protections. The global panic handler's unconditional `process::exit(12)` amplifies what should be a recoverable parsing error into a complete node failure, violating the principle of defense in depth.

### Citations

**File:** network/discovery/src/file.rs (L38-46)
```rust
    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        // Wait for delay, or add the delay for next call
        futures::ready!(self.interval.as_mut().poll_next(cx));

        Poll::Ready(Some(match load_file(self.file_path.as_path()) {
            Ok(peers) => Ok(peers),
            Err(error) => Err(error),
        }))
    }
```

**File:** network/discovery/src/file.rs (L50-53)
```rust
fn load_file(path: &Path) -> Result<PeerSet, DiscoveryError> {
    let contents = std::fs::read_to_string(path).map_err(DiscoveryError::IO)?;
    serde_yaml::from_str(&contents).map_err(|err| DiscoveryError::Parsing(err.to_string()))
}
```

**File:** config/src/config/network_config.rs (L352-357)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "snake_case")]
pub struct FileDiscovery {
    pub path: PathBuf,
    pub interval_secs: u64,
}
```

**File:** config/src/config/network_config.rs (L390-390)
```rust
pub type PeerSet = HashMap<PeerId, Peer>;
```

**File:** network/discovery/src/lib.rs (L54-64)
```rust
impl<P: OnChainConfigProvider> Stream for DiscoveryChangeStream<P> {
    type Item = Result<PeerSet, DiscoveryError>;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        match self.get_mut() {
            Self::ValidatorSet(stream) => Pin::new(stream).poll_next(cx),
            Self::File(stream) => Pin::new(stream).poll_next(cx),
            Self::Rest(stream) => Pin::new(stream).poll_next(cx),
        }
    }
}
```

**File:** network/discovery/src/lib.rs (L127-129)
```rust
    pub fn start(self, executor: &Handle) {
        spawn_named!("DiscoveryChangeListener", executor, Box::pin(self).run());
    }
```

**File:** crates/crash-handler/src/lib.rs (L26-58)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
}
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L1-1)
```rust
// Copyright (c) The Diem Core Contributors
```
