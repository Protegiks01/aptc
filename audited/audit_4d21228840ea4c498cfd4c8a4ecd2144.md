# Audit Report

## Title
Retroactive Modification of `first_transaction_version` During Indexer Gap Filling Causes Historical Data Inconsistency

## Summary
The Aptos indexer's `delegated_staking_pools` table uses an upsert operation that allows `first_transaction_version` to be retroactively updated to earlier (lower) transaction versions when the indexer fills gaps or reprocesses historical transactions. This violates the immutability expectation for historical blockchain data and creates inconsistent query results over time.

## Finding Description

The vulnerability exists in the database upsert logic for delegator pool tracking. When a delegator pool is first encountered at transaction version X and later the indexer discovers and processes an earlier transaction version Y (where Y < X) that also references the same pool, the `first_transaction_version` field gets retroactively updated from X to Y.

**Root Cause:** [1](#0-0) 

The SQL WHERE clause on line 252 uses the condition `>= EXCLUDED.first_transaction_version`, which means "update if the existing value is greater than or equal to the new value." This allows earlier transaction versions to overwrite later ones.

**Trigger Mechanism:**

The indexer has automatic gap detection and filling capabilities: [2](#0-1) 

The `get_start_version_long()` function searches for gaps in processed transactions (line 261: `WHERE version + 1 <> next_version`) and automatically restarts processing from the first gap within a configurable lookback window (default 1.5M versions). [3](#0-2) 

**Attack Scenario:**
1. Indexer processes transaction version 10000 that creates/touches pool address `0xABC...`
2. `delegated_staking_pools` table gets entry: `(0xABC..., 10000)`
3. Indexer experiences downtime or network issues
4. Gap detection finds missing transaction at version 5000
5. Transaction version 5000 also references pool `0xABC...` (could be the actual pool creation)
6. Indexer reprocesses version 5000
7. Database UPDATE occurs: `first_transaction_version` changes from 10000 → 5000
8. API consumers querying historical pool data now get different results than before
9. Any analytics, reporting, or downstream systems tracking pool creation timing become unreliable

## Impact Explanation

**Severity: Medium** - State inconsistencies requiring intervention

While this vulnerability does **not** affect consensus, validator operations, or on-chain state (the blockchain itself remains secure), it creates **persistent data inconsistency** in the indexer database that impacts:

1. **API Reliability**: Historical queries return different results over time for the same pool
2. **Analytics Integrity**: Pool lifecycle tracking and metrics become unreliable  
3. **Downstream Systems**: Applications relying on immutable historical data receive inconsistent information
4. **Audit Trail Violations**: The "first seen" timestamp becomes mutable, violating audit expectations

This qualifies as "State inconsistencies requiring intervention" per the Medium severity criteria, as the indexer database state becomes corrupted and requires manual investigation or re-indexing to resolve.

## Likelihood Explanation

**Likelihood: High** - This occurs automatically during normal indexer operations

Gap filling is a standard operational procedure that happens:
- On every indexer restart (searches back 1.5M versions by default)
- During network interruptions or node sync delays
- When running backfill operations
- After any indexer downtime

No attacker action is required—this is an inherent flaw in the update logic that triggers during routine operations. Given that blockchain networks experience transient issues regularly, this vulnerability will manifest in production environments.

## Recommendation

Change the update condition to only allow updates when the new version is **later** (higher), never earlier:

**Current (vulnerable) code:**
```sql
WHERE delegated_staking_pools.first_transaction_version >= EXCLUDED.first_transaction_version
```

**Fixed code:**
```sql
WHERE delegated_staking_pools.first_transaction_version < EXCLUDED.first_transaction_version
```

Or better yet, make `first_transaction_version` truly immutable by using `DO NOTHING` on conflict:

```rust
fn insert_delegator_pools(
    conn: &mut PgConnection,
    item_to_insert: &[DelegatorPool],
) -> Result<(), diesel::result::Error> {
    use schema::delegated_staking_pools::dsl::*;

    let chunks = get_chunks(item_to_insert.len(), DelegatorPool::field_count());
    for (start_ind, end_ind) in chunks {
        execute_with_better_error(
            conn,
            diesel::insert_into(schema::delegated_staking_pools::table)
                .values(&item_to_insert[start_ind..end_ind])
                .on_conflict(staking_pool_address)
                .do_nothing(),  // Never update first_transaction_version
            None,
        )?;
    }
    Ok(())
}
```

This ensures that once a pool is recorded, its `first_transaction_version` remains immutable regardless of gap filling or reprocessing operations.

## Proof of Concept

```rust
// PoC: Demonstrating retroactive update during gap filling
// Run this test in the indexer crate after setting INDEXER_DATABASE_URL

#[tokio::test]
async fn test_first_transaction_version_retroactive_change() {
    use crate::processors::stake_processor::*;
    use crate::models::stake_models::delegator_pools::DelegatorPool;
    
    let pool_address = "0xabcdef1234567890".to_string();
    
    // Step 1: Insert pool at version 10000
    let pool_v10000 = DelegatorPool {
        staking_pool_address: pool_address.clone(),
        first_transaction_version: 10000,
    };
    
    let mut conn = get_test_db_connection();
    insert_delegator_pools(&mut conn, &[pool_v10000]).unwrap();
    
    // Verify initial state
    let result = get_pool_from_db(&mut conn, &pool_address);
    assert_eq!(result.first_transaction_version, 10000);
    
    // Step 2: Simulate gap filling - process earlier version 5000
    let pool_v5000 = DelegatorPool {
        staking_pool_address: pool_address.clone(),
        first_transaction_version: 5000,
    };
    
    insert_delegator_pools(&mut conn, &[pool_v5000]).unwrap();
    
    // Vulnerability: first_transaction_version retroactively changed
    let result = get_pool_from_db(&mut conn, &pool_address);
    assert_eq!(result.first_transaction_version, 5000); // Changed from 10000!
    
    // This demonstrates historical data inconsistency:
    // API consumers would have seen 10000 initially, now see 5000
}
```

## Notes

This vulnerability affects the **indexer database integrity** but does not compromise the Aptos blockchain's consensus, security, or on-chain state. The blockchain itself remains fully secure. However, it creates significant operational and data quality issues for applications consuming indexer API data, as historical records become mutable when they should be immutable.

The issue is specific to the `delegated_staking_pools` table but could potentially affect other tables with similar upsert patterns if they use comparable update logic during gap filling operations.

### Citations

**File:** crates/indexer/src/processors/stake_processor.rs (L233-257)
```rust
fn insert_delegator_pools(
    conn: &mut PgConnection,
    item_to_insert: &[DelegatorPool],
) -> Result<(), diesel::result::Error> {
    use schema::delegated_staking_pools::dsl::*;

    let chunks = get_chunks(item_to_insert.len(), DelegatorPool::field_count());
    for (start_ind, end_ind) in chunks {
        execute_with_better_error(
            conn,
            diesel::insert_into(schema::delegated_staking_pools::table)
                .values(&item_to_insert[start_ind..end_ind])
                .on_conflict(staking_pool_address)
                .do_update()
                .set((
                    first_transaction_version.eq(excluded(first_transaction_version)),
                    inserted_at.eq(excluded(inserted_at)),
                )),
            Some(
                " WHERE delegated_staking_pools.first_transaction_version >= EXCLUDED.first_transaction_version ",
            ),
        )?;
    }
    Ok(())
}
```

**File:** crates/indexer/src/indexer/tailer.rs (L203-288)
```rust
    /// Get starting version from database. Starting version is defined as the first version that's either
    /// not successful or missing from the DB.
    pub fn get_start_version_long(
        &self,
        processor_name: &String,
        lookback_versions: i64,
    ) -> Option<i64> {
        let mut conn = self
            .connection_pool
            .get()
            .expect("DB connection should be available to get starting version");

        // This query gets the first version that isn't equal to the next version (versions would be sorted of course).
        // There's also special handling if the gap happens in the beginning.
        let sql = "
        WITH raw_boundaries AS
        (
            SELECT
                MAX(version) AS MAX_V,
                MIN(version) AS MIN_V
            FROM
                processor_statuses
            WHERE
                name = $1
                AND success = TRUE
        ),
        boundaries AS
        (
            SELECT
                MAX(version) AS MAX_V,
                MIN(version) AS MIN_V
            FROM
                processor_statuses, raw_boundaries
            WHERE
                name = $1
                AND success = true
                and version >= GREATEST(MAX_V - $2, 0)
        ),
        gap AS
        (
            SELECT
                MIN(version) + 1 AS maybe_gap
            FROM
                (
                    SELECT
                        version,
                        LEAD(version) OVER (
                    ORDER BY
                        version ASC) AS next_version
                    FROM
                        processor_statuses,
                        boundaries
                    WHERE
                        name = $1
                        AND success = TRUE
                        AND version >= GREATEST(MAX_V - $2, 0)
                ) a
            WHERE
                version + 1 <> next_version
        )
        SELECT
            CASE
                WHEN
                    MIN_V <> GREATEST(MAX_V - $2, 0)
                THEN
                    GREATEST(MAX_V - $2, 0)
                ELSE
                    COALESCE(maybe_gap, MAX_V + 1)
            END
            AS version
        FROM
            gap, boundaries
        ";
        #[derive(Debug, QueryableByName)]
        pub struct Gap {
            #[diesel(sql_type = BigInt)]
            pub version: i64,
        }
        let mut res: Vec<Option<Gap>> = sql_query(sql)
            .bind::<Text, _>(processor_name)
            // This is the number used to determine how far we look back for gaps. Increasing it may result in slower startup
            .bind::<BigInt, _>(lookback_versions)
            .get_results(&mut conn)
            .unwrap();
        res.pop().unwrap().map(|g| g.version)
    }
```

**File:** crates/indexer/README.md (L5-7)
```markdown
A fullnode can run an indexer with the proper configs. If enabled, the indexer will tail
transactions in the fullnode with business logic from  each registered `TransactionProcessor`. On
startup, by default, will restart from the first gap (e.g. version 5 if versions succeeded are 0, 1, 2, 3, 4, 6). 
```
