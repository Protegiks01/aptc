# Audit Report

## Title
gRPC Network Service Panic-Induced Process Crash via Dropped Channel Receivers

## Summary
The gRPC network service in `secure/net/src/grpc_network_service/mod.rs` uses `.unwrap()` when sending messages through crossbeam channels, causing a panic when receivers are dropped during normal operations (e.g., component restarts). With Aptos's custom panic handler, this terminates the entire process, resulting in service unavailability and potential node crashes.

## Finding Description

The vulnerability exists in the `simple_msg_exchange()` gRPC handler method: [1](#0-0) 

When a gRPC message arrives, the handler looks up the corresponding channel sender from the `inbound_handlers` HashMap and calls `send(msg).unwrap()`. If the receiver has been dropped (which can occur during component shutdowns or restarts), the `send()` operation returns an error, and the `.unwrap()` causes a panic.

The same vulnerability exists in the local message routing: [2](#0-1) 

**Component Lifecycle Issue:** When services create inbound channels, they receive the receiver end: [3](#0-2) 

Components like `RemoteCoordinatorClient` store these receivers and use them to receive messages: [4](#0-3) 

When these components are dropped or shut down during normal operation, their receivers are dropped. However, the sender remains registered in the `inbound_handlers` HashMap. The `NetworkController::shutdown()` method does not remove handler registrations: [5](#0-4) 

**Panic Handler Impact:** Aptos uses a custom panic handler that terminates the entire process: [6](#0-5) [7](#0-6) 

The panic handler explicitly overrides Tokio's default behavior of catching and ignoring panics, ensuring that any panic in a Tokio task (including gRPC handlers) terminates the process with exit code 12.

**Attack Scenario:**
1. Component creates inbound channel and registers handler
2. Component undergoes normal shutdown/restart (e.g., executor service maintenance)
3. Receiver is dropped, but sender remains in HashMap
4. New gRPC message arrives for that message type
5. `handler.send(msg).unwrap()` panics
6. Panic handler invokes `process::exit(12)`
7. Entire service/node process crashes

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

- **Service Crash:** Causes immediate termination of executor services, potentially affecting validator nodes
- **Availability Impact:** Results in denial of service for affected components
- **Protocol Violations:** Can disrupt block execution pipeline if executor service crashes
- **No Recovery:** Process termination requires manual restart, affecting network liveness

While this doesn't directly violate consensus safety or cause fund loss, it impacts validator node availability and service reliability, which aligns with "Validator node slowdowns" and "API crashes" under High Severity ($50,000 tier).

## Likelihood Explanation

**Likelihood: Medium-High**

This can occur during:
- Component lifecycle events (restart, reconfiguration)
- Service maintenance operations
- Graceful shutdowns followed by message arrival
- Race conditions between shutdown and incoming messages

The vulnerability requires:
1. Normal operational events (component restart) - **Common**
2. Message arrival after receiver drop but before server shutdown - **Timing-dependent but feasible**
3. No special attacker privileges required - messages can arrive naturally

The lack of handler cleanup mechanisms makes this a persistent vulnerability across all component restart scenarios.

## Recommendation

Replace `.unwrap()` with proper error handling in both locations:

**In `grpc_network_service/mod.rs`:**
```rust
if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
    // Send the message to the registered handler
    if let Err(e) = handler.send(msg) {
        error!(
            "Failed to send message from {:?} for type {:?}: {}",
            remote_addr, message_type, e
        );
    }
} else {
    error!(
        "No handler registered for sender: {:?} and msg type {:?}",
        remote_addr, message_type
    );
}
```

**In `inbound_handler.rs`:**
```rust
if let Some(handler) = self.inbound_handlers.lock().unwrap().get(message_type) {
    if let Err(e) = handler.send(message) {
        warn!("Failed to send message for type {:?}: {}", message_type, e);
    }
} else {
    warn!("No handler registered for message type: {:?}", message_type);
}
```

**Additional hardening:**
- Implement handler cleanup during `NetworkController::shutdown()`
- Add health checks to detect stale handlers
- Consider using bounded channels with timeout for sends

## Proof of Concept

```rust
#[test]
fn test_panic_on_dropped_receiver() {
    use aptos_config::utils;
    use std::{
        net::{IpAddr, Ipv4Addr},
        thread,
        time::Duration,
    };

    let server_addr = SocketAddr::new(
        IpAddr::V4(Ipv4Addr::LOCALHOST), 
        utils::get_available_port()
    );
    let message_type = "test_panic".to_string();
    let server_handlers: Arc<Mutex<HashMap<MessageType, Sender<Message>>>> =
        Arc::new(Mutex::new(HashMap::new()));

    // Create channel and register handler
    let (msg_tx, msg_rx) = crossbeam_channel::unbounded();
    server_handlers
        .lock()
        .unwrap()
        .insert(MessageType::new(message_type.clone()), msg_tx);
    
    let server = GRPCNetworkMessageServiceServerWrapper::new(
        server_handlers.clone(), 
        server_addr
    );

    let rt = Runtime::new().unwrap();
    let (server_shutdown_tx, server_shutdown_rx) = oneshot::channel();
    server.start(&rt, "test".to_string(), server_addr, 1000, server_shutdown_rx);

    // Drop the receiver (simulates component shutdown)
    drop(msg_rx);
    
    thread::sleep(Duration::from_millis(50));

    // Create client and send message
    let mut client = GRPCNetworkMessageServiceClientWrapper::new(&rt, server_addr);
    let client_addr = SocketAddr::new(
        IpAddr::V4(Ipv4Addr::LOCALHOST), 
        utils::get_available_port()
    );

    // This will cause the server to panic because receiver is dropped
    // In production with panic handler, this would crash the process
    rt.block_on(async {
        client.send_message(
            client_addr,
            Message::new("test".as_bytes().to_vec()),
            &MessageType::new(message_type),
        ).await;
    });
    
    server_shutdown_tx.send(()).unwrap();
}
```

This test demonstrates that sending a message to a handler whose receiver has been dropped causes a panic. In a production environment with `setup_panic_handler()` enabled, this would terminate the entire process.

## Notes

This vulnerability is particularly concerning because:

1. **Silent Registration**: Handlers remain registered indefinitely after receivers are dropped
2. **No Validation**: No mechanism to detect stale/invalid handlers before attempting sends
3. **Process-Level Impact**: Due to custom panic handler, affects entire service not just the gRPC task
4. **Operational Concern**: Normal maintenance operations (restarts, reconfigurations) trigger the vulnerability

The fix is straightforward but requires careful error handling to maintain service reliability during component lifecycle events.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L105-107)
```rust
        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
```

**File:** secure/net/src/network_controller/inbound_handler.rs (L68-70)
```rust
        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(message_type) {
            // Send the message to the registered handler
            handler.send(message).unwrap();
```

**File:** secure/net/src/network_controller/mod.rs (L128-137)
```rust
    pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
        let (inbound_sender, inbound_receiver) = unbounded();

        self.inbound_handler
            .lock()
            .unwrap()
            .register_handler(message_type, inbound_sender);

        inbound_receiver
    }
```

**File:** secure/net/src/network_controller/mod.rs (L155-166)
```rust
    pub fn shutdown(&mut self) {
        info!("Shutting down network controller at {}", self.listen_addr);
        if let Some(shutdown_signal) = self.inbound_server_shutdown_tx.take() {
            shutdown_signal.send(()).unwrap();
        }

        if let Some(shutdown_signal) = self.outbound_task_shutdown_tx.take() {
            shutdown_signal.send(Message::new(vec![])).unwrap_or_else(|_| {
                warn!("Failed to send shutdown signal to outbound task; probably already shutdown");
            })
        }
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L21-34)
```rust
    command_rx: Receiver<Message>,
    result_tx: Sender<Message>,
    shard_id: ShardId,
}

impl RemoteCoordinatorClient {
    pub fn new(
        shard_id: ShardId,
        controller: &mut NetworkController,
        coordinator_address: SocketAddr,
    ) -> Self {
        let execute_command_type = format!("execute_command_{}", shard_id);
        let execute_result_type = format!("execute_result_{}", shard_id);
        let command_rx = controller.create_inbound_channel(execute_command_type);
```

**File:** crates/crash-handler/src/lib.rs (L26-30)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}
```

**File:** crates/crash-handler/src/lib.rs (L52-57)
```rust
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```
