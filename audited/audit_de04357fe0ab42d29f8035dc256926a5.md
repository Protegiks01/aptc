# Audit Report

## Title
Non-Deterministic Code Invariant Error Handling Breaks Consensus Determinism

## Summary
The `CodeInvariantError` mechanism, intended to represent errors that "should never happen" and would "generally just panic," fails to accurately reflect its intended semantics. Instead of halting execution, these critical invariant violations are suppressed and handled as regular errors, particularly when the `CHARGE_INVARIANT_VIOLATION` feature flag is enabled (default). Combined with non-deterministic random checking in `randomly_check_layout_matches`, this creates a consensus-breaking vulnerability where different validators may produce different state roots for identical blocks.

## Finding Description

The comment at lines 9-11 of `types/src/error.rs` states: [1](#0-0) 

However, the implementation violates this semantic intent through multiple mechanisms:

**1. Suppression Instead of Halting:**

CodeInvariantErrors are converted to `VMStatus::Error` with `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR` status code: [2](#0-1) 

When the `CHARGE_INVARIANT_VIOLATION` feature flag is enabled (which is in the default features list): [3](#0-2) 

These invariant violations are **kept and charged** as `MiscellaneousError` instead of being discarded: [4](#0-3) 

This allows execution to continue rather than halting the node, directly contradicting the semantic that these errors "should never happen."

**2. Non-Deterministic Detection:**

The `randomly_check_layout_matches` function performs invariant checking only 1% of the time using an unseeded random number generator: [5](#0-4) 

This function is called during critical write set squashing operations: [6](#0-5) 

**3. Consensus Divergence Attack Path:**

When a code bug causes layout mismatches during transaction execution:

1. Validator A executes transaction → random check triggers (1% probability) → detects layout mismatch → returns `CodeInvariantError` → converted to `MiscellaneousError` with `CHARGE_INVARIANT_VIOLATION` enabled → transaction kept and charged
2. Validator B executes same transaction → random check doesn't trigger (99% probability) → layout mismatch undetected → transaction executes successfully
3. **Different transaction outputs and state roots**
4. Consensus cannot reach 2f+1 agreement on state root
5. **Liveness failure or chain fork**

**4. Block-Level Suppression:**

The `discard_failed_blocks` configuration further enables suppression of fatal block executor errors: [7](#0-6) 

When enabled, entire blocks containing `CodeInvariantError` are discarded without halting execution, allowing the chain to continue despite fundamental code bugs.

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple Critical impact categories:

1. **Consensus/Safety Violations**: The non-deterministic execution breaks the fundamental "Deterministic Execution" invariant, where all validators must produce identical state roots for identical blocks. Different validators computing different state roots prevents consensus from being reached.

2. **Loss of Liveness/Network Availability**: When validators cannot agree on state roots due to random detection differences, the network cannot make progress on committing new blocks, resulting in a liveness failure.

3. **Potential Chain Fork**: If exactly 2f+1 validators happen to align on the same random outcome (either all detecting or all not detecting the invariant violation), they could commit a block that the remaining validators reject, creating a non-recoverable network partition requiring a hardfork.

The vulnerability fundamentally violates the semantic contract of `CodeInvariantError` - errors that "should never happen" are being silently suppressed and handled as regular execution errors rather than causing immediate halt and investigation.

## Likelihood Explanation

**High Likelihood of Occurrence:**

1. **Random checking executes on every write set squash operation** - this is a frequent operation during transaction execution involving resource updates.

2. **1% detection probability** means that in a network with multiple validators, the probability that different validators get different outcomes increases significantly. With 100 validators, the expected outcome is that ~1 validator detects the invariant violation while ~99 do not.

3. **Feature flag enabled by default** - `CHARGE_INVARIANT_VIOLATION` is in the default features list, meaning this behavior is active on mainnet.

4. **Any code bug causing layout mismatches triggers the vulnerability** - this doesn't require an attacker to craft special transactions; any framework bug, VM bug, or module incompatibility that causes type layout mismatches will trigger non-deterministic behavior.

The vulnerability is not theoretical - it's already present in the live code path and will manifest whenever layout mismatches occur, whether due to bugs or potential attack vectors.

## Recommendation

**Immediate Fixes:**

1. **Remove Random Checking** - Replace probabilistic checking with deterministic behavior:

```rust
pub fn randomly_check_layout_matches(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
) -> Result<(), PanicError> {
    if layout_1.is_some() != layout_2.is_some() {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    if layout_1.is_some() && layout_1 != layout_2 {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    Ok(())
}
```

2. **Halt on Code Invariant Errors** - When `CodeInvariantError` occurs, the node should panic/halt rather than continuing execution. This preserves the semantic intent:

```rust
pub fn code_invariant_error<M: std::fmt::Debug>(message: M) -> PanicError {
    let msg = format!(
        "Code invariant broken (there is a bug in the code), {:?}",
        message
    );
    error!("{}", msg);
    panic!("CRITICAL: {}", msg); // Add immediate halt
}
```

3. **Disable CHARGE_INVARIANT_VIOLATION by default** - Remove this flag from `default_features()` to ensure invariant violations are discarded rather than charged, preventing them from entering consensus.

4. **Add deterministic fallback** - If performance concerns prevent always checking layouts, use a deterministic mechanism (e.g., check based on transaction hash) rather than random checking.

## Proof of Concept

The existing test demonstrates the suppression behavior: [8](#0-7) 

To demonstrate the non-determinism vulnerability:

```rust
// Test demonstrating non-deterministic behavior
#[test]
fn test_nondeterministic_invariant_detection() {
    let mut outcomes = vec![];
    
    // Execute same transaction multiple times
    for _ in 0..100 {
        let mut executor = FakeExecutor::from_head_genesis();
        let sender = executor.create_raw_account_data(1_000_000, 10);
        executor.add_account_data(&sender);
        
        // Transaction that causes layout mismatch during write set squashing
        let txn = create_transaction_with_layout_mismatch();
        let output = executor.execute_transaction(txn);
        
        outcomes.push(output.status().clone());
    }
    
    // Due to random checking, we expect different outcomes
    let success_count = outcomes.iter()
        .filter(|s| matches!(s, TransactionStatus::Keep(ExecutionStatus::Success)))
        .count();
    let error_count = outcomes.iter()
        .filter(|s| matches!(s, TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(_))))
        .count();
    
    // With 1% probability, expect ~1 error detection in 100 runs
    assert!(error_count > 0, "Should detect some errors");
    assert!(success_count > 0, "Should have some successes");
    
    // This proves non-determinism: same transaction, different outcomes
    println!("Non-deterministic execution: {} errors, {} successes", 
             error_count, success_count);
}
```

The test would show that the same transaction produces different results across executions, proving the consensus-breaking non-determinism.

## Notes

This vulnerability exists at the intersection of three design decisions:
1. Using probabilistic checking for performance optimization
2. Converting CodeInvariantErrors to recoverable VMStatus errors
3. Enabling CHARGE_INVARIANT_VIOLATION by default

The most critical aspect is that the implementation directly contradicts its documented semantics. The comment clearly states these errors "should never happen" and would "generally just panic," but the actual behavior allows them to be suppressed and execution to continue, breaking the fundamental deterministic execution guarantee required for blockchain consensus.

### Citations

**File:** types/src/error.rs (L9-11)
```rust
/// Wrapping other errors, to add a variant that represents something that should never
/// happen - i.e. a code invariant error, which we would generally just panic, but since
/// we are inside of the VM, we cannot do that.
```

**File:** types/src/error.rs (L45-54)
```rust
impl From<PanicError> for PartialVMError {
    fn from(err: PanicError) -> Self {
        match err {
            PanicError::CodeInvariantError(msg) => {
                PartialVMError::new(StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR)
                    .with_message(msg)
            },
        }
    }
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L194-194)
```rust
            FeatureFlag::CHARGE_INVARIANT_VIOLATION,
```

**File:** types/src/transaction/mod.rs (L1640-1646)
```rust
                if code.status_type() == StatusType::InvariantViolation
                    && features.is_enabled(FeatureFlag::CHARGE_INVARIANT_VIOLATION)
                {
                    Self::Keep(ExecutionStatus::MiscellaneousError(Some(code)))
                } else {
                    Self::Discard(code)
                }
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L64-71)
```rust
        let mut rng = rand::thread_rng();
        let random_number: u32 = rng.gen_range(0, 100);
        if random_number == 1 && layout_1 != layout_2 {
            return Err(code_invariant_error(format!(
                "Layouts don't match when they are expected to: {:?} and {:?}",
                layout_1, layout_2
            )));
        }
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L534-537)
```rust
                    randomly_check_layout_matches(
                        type_layout.as_deref(),
                        additional_type_layout.as_deref(),
                    )?;
```

**File:** aptos-move/block-executor/src/executor.rs (L2648-2665)
```rust
        if self.config.local.discard_failed_blocks {
            // We cannot execute block, discard everything (including block metadata and validator transactions)
            // (TODO: maybe we should add fallback here to first try BlockMetadataTransaction alone)
            let error_code = match sequential_error {
                BlockExecutionError::FatalBlockExecutorError(_) => {
                    StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
                },
                BlockExecutionError::FatalVMError(_) => {
                    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                },
            };
            let ret = (0..signature_verified_block.num_txns())
                .map(|_| E::Output::discard_output(error_code))
                .collect();
            return Ok(BlockOutput::new(ret, None));
        }

        Err(sequential_error)
```

**File:** aptos-move/e2e-testsuite/src/tests/invariant_violation.rs (L33-39)
```rust
    // CHARGE_INVARIANT_VIOLATION enabled at genesis so this txn is kept.
    assert_eq!(
        output.status(),
        &TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(Some(
            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
        ))),
    );
```
