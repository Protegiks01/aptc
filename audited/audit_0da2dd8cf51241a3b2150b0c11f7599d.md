# Audit Report

## Title
Ungraceful Shutdown in ProcessExecutorService Causes Loss of Transaction Execution Results

## Summary
The `shutdown()` method in `ProcessExecutorService` does not ensure graceful shutdown of the executor service thread, leading to potential loss of transaction execution results. During shutdown, the network controller is terminated immediately without waiting for in-flight block executions to complete or ensuring results are transmitted to the coordinator.

## Finding Description

The vulnerability exists in the shutdown flow of the remote executor service architecture: [1](#0-0) 

The `ProcessExecutorService::shutdown()` method delegates to `ExecutorService::shutdown()`: [2](#0-1) 

This only shuts down the network controller without any coordination with the executor thread. The executor service thread was spawned during startup: [3](#0-2) 

This thread runs `ShardedExecutorService::start()` which processes execution commands in a loop: [4](#0-3) 

When a block execution completes, results are sent via: [5](#0-4) 

The `RemoteCoordinatorClient::send_execution_result()` implementation sends results over network channels: [6](#0-5) 

**The Race Condition:**

1. Executor service receives an execution command and begins processing
2. `shutdown()` is called (via Ctrl-C handler in main): [7](#0-6) 

3. Network controller shuts down, stopping outbound message handlers: [8](#0-7) 

4. The executor thread completes execution and tries to send results
5. Either the `send().unwrap()` panics (if channel is closed) or the message is dropped (if outbound handler already exited)
6. The coordinator waits indefinitely for results: [9](#0-8) 

**Contrast with Correct Implementation:**

The local executor implementation properly handles shutdown by sending Stop commands and waiting for threads: [10](#0-9) 

The remote implementation lacks this graceful shutdown mechanism entirely.

## Impact Explanation

**High Severity** - This vulnerability causes:

1. **Loss of Transaction Outputs**: Execution results can be lost if shutdown occurs during block execution
2. **State Inconsistency**: The coordinator expects results that never arrive, potentially causing the node to diverge from the network
3. **Validator Desynchronization**: If a validator's executor service shuts down ungracefully during block execution, it may fail to commit the correct state root
4. **Thread Panic**: The `.unwrap()` on closed channels can cause the executor thread to panic unexpectedly

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." If transaction outputs are lost, state transitions are incomplete and validators may compute different state roots for the same block.

## Likelihood Explanation

**Medium to High Likelihood:**

- Occurs whenever the process is shut down (Ctrl-C, SIGTERM, crashes) during active block execution
- Common operational scenarios:
  - Validator operators performing maintenance/restarts
  - Graceful node shutdowns during upgrades
  - Process crashes or OOM kills
  - Container orchestration systems (Kubernetes) sending SIGTERM
- The executor service processes blocks continuously, so there's a high probability of in-flight execution during any shutdown event
- No special privileges or insider access required

## Recommendation

Implement graceful shutdown similar to `LocalExecutorClient`:

1. **Send Stop Command**: Before shutting down the network controller, send `ExecutorShardCommand::Stop` to the executor thread via the command channel
2. **Wait for Completion**: Join the executor thread to ensure it completes all in-flight work
3. **Ensure Results Transmitted**: Only shut down network after confirming results are sent

**Recommended Fix:**

```rust
// In remote_executor_service.rs
pub struct ExecutorService {
    shard_id: ShardId,
    controller: NetworkController,
    executor_service: Arc<ShardedExecutorService<RemoteStateViewClient>>,
    executor_thread: Option<thread::JoinHandle<()>>, // Add this field
}

impl ExecutorService {
    pub fn start(&mut self) {
        self.controller.start();
        let thread_name = format!("ExecutorService-{}", self.shard_id);
        let builder = thread::Builder::new().name(thread_name);
        let executor_service_clone = self.executor_service.clone();
        let handle = builder
            .spawn(move || {
                executor_service_clone.start();
            })
            .expect("Failed to spawn thread");
        self.executor_thread = Some(handle); // Store the handle
    }

    pub fn shutdown(&mut self) {
        // First, send Stop command via coordinator client
        // (requires extending RemoteCoordinatorClient with a stop method)
        
        // Wait for executor thread to complete
        if let Some(handle) = self.executor_thread.take() {
            let _ = handle.join();
        }
        
        // Only then shut down network controller
        self.controller.shutdown();
    }
}
```

Additionally, modify `RemoteCoordinatorClient` to support sending the Stop command gracefully, and handle potential send failures without panicking.

## Proof of Concept

```rust
#[test]
fn test_shutdown_race_condition() {
    use std::sync::{Arc, Mutex};
    use std::thread;
    use std::time::Duration;
    
    // Setup: Create coordinator and executor service
    let coordinator_addr = get_available_socket_addr();
    let executor_addr = get_available_socket_addr();
    
    let mut executor_service = ProcessExecutorService::new(
        0, // shard_id
        1, // num_shards
        4, // num_threads
        coordinator_addr,
        vec![executor_addr],
    );
    
    // Create a flag to track if results were lost
    let results_received = Arc::new(Mutex::new(false));
    let results_flag = results_received.clone();
    
    // Spawn a thread that sends an execution command and waits for results
    let coordinator_thread = thread::spawn(move || {
        // Send execution command to executor service
        // ... (send ExecuteBlock command)
        
        // Try to receive results (this will block)
        match result_rx.recv_timeout(Duration::from_secs(5)) {
            Ok(_) => {
                *results_flag.lock().unwrap() = true;
            },
            Err(_) => {
                // Results were lost!
            }
        }
    });
    
    // Give executor time to start processing
    thread::sleep(Duration::from_millis(100));
    
    // Trigger shutdown while execution is in progress
    executor_service.shutdown();
    
    // Wait for coordinator thread
    coordinator_thread.join().unwrap();
    
    // Assert that results were NOT received (demonstrating the bug)
    assert!(!*results_received.lock().unwrap(), 
            "Results should be lost due to ungraceful shutdown");
}
```

## Notes

This vulnerability is particularly concerning because:

1. The code already has the correct pattern implemented in `LocalExecutorClient`, but the remote implementation doesn't follow it
2. The network controller's own comments acknowledge the shutdown is "not very clean" and doesn't wait for completion
3. The issue affects production deployments where executor services run as separate processes
4. Silent data loss is more dangerous than explicit failures, as it may go unnoticed until state divergence occurs

The fix should be prioritized as it affects data integrity in the execution layer, which is critical for blockchain consistency.

### Citations

**File:** execution/executor-service/src/process_executor_service.rs (L47-49)
```rust
    pub fn shutdown(&mut self) {
        self.executor_service.shutdown()
    }
```

**File:** execution/executor-service/src/remote_executor_service.rs (L57-67)
```rust
    pub fn start(&mut self) {
        self.controller.start();
        let thread_name = format!("ExecutorService-{}", self.shard_id);
        let builder = thread::Builder::new().name(thread_name);
        let executor_service_clone = self.executor_service.clone();
        builder
            .spawn(move || {
                executor_service_clone.start();
            })
            .expect("Failed to spawn thread");
    }
```

**File:** execution/executor-service/src/remote_executor_service.rs (L69-71)
```rust
    pub fn shutdown(&mut self) {
        self.controller.shutdown();
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L215-260)
```rust
    pub fn start(&self) {
        trace!(
            "Shard starting, shard_id={}, num_shards={}.",
            self.shard_id,
            self.num_shards
        );
        let mut num_txns = 0;
        loop {
            let command = self.coordinator_client.receive_execute_command();
            match command {
                ExecutorShardCommand::ExecuteSubBlocks(
                    state_view,
                    transactions,
                    concurrency_level_per_shard,
                    onchain_config,
                ) => {
                    num_txns += transactions.num_txns();
                    trace!(
                        "Shard {} received ExecuteBlock command of block size {} ",
                        self.shard_id,
                        num_txns
                    );
                    let exe_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "execute_block"]);
                    let ret = self.execute_block(
                        transactions,
                        state_view.as_ref(),
                        BlockExecutorConfig {
                            local: BlockExecutorLocalConfig::default_with_concurrency_level(
                                concurrency_level_per_shard,
                            ),
                            onchain: onchain_config,
                        },
                    );
                    drop(state_view);
                    drop(exe_timer);

                    let _result_tx_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "result_tx"]);
                    self.coordinator_client.send_execution_result(ret);
                },
                ExecutorShardCommand::Stop => {
                    break;
                },
            }
        }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L115-119)
```rust
    fn send_execution_result(&self, result: Result<Vec<Vec<TransactionOutput>>, VMStatus>) {
        let remote_execution_result = RemoteExecutionResult::new(result);
        let output_message = bcs::to_bytes(&remote_execution_result).unwrap();
        self.result_tx.send(Message::new(output_message)).unwrap();
    }
```

**File:** execution/executor-service/src/main.rs (L31-48)
```rust
    let (tx, rx) = crossbeam_channel::unbounded();
    ctrlc::set_handler(move || {
        tx.send(()).unwrap();
    })
    .expect("Error setting Ctrl-C handler");

    let _exe_service = ProcessExecutorService::new(
        args.shard_id,
        args.num_shards,
        args.num_executor_threads,
        args.coordinator_address,
        args.remote_executor_addresses,
    );

    rx.recv()
        .expect("Could not receive Ctrl-C msg from channel.");
    info!("Process executor service shutdown successfully.");
}
```

**File:** secure/net/src/network_controller/mod.rs (L155-166)
```rust
    pub fn shutdown(&mut self) {
        info!("Shutting down network controller at {}", self.listen_addr);
        if let Some(shutdown_signal) = self.inbound_server_shutdown_tx.take() {
            shutdown_signal.send(()).unwrap();
        }

        if let Some(shutdown_signal) = self.outbound_task_shutdown_tx.take() {
            shutdown_signal.send(Message::new(vec![])).unwrap_or_else(|_| {
                warn!("Failed to send shutdown signal to outbound task; probably already shutdown");
            })
        }
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L228-239)
```rust
impl<S: StateView + Sync + Send + 'static> Drop for LocalExecutorClient<S> {
    fn drop(&mut self) {
        for command_tx in self.command_txs.iter() {
            let _ = command_tx.send(ExecutorShardCommand::Stop);
        }

        // wait for join handles to finish
        for executor_service in self.executor_services.iter_mut() {
            let _ = executor_service.join_handle.take().unwrap().join();
        }
    }
}
```
