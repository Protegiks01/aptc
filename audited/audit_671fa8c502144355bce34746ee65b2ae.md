# Audit Report

## Title
Duplicate Transaction Detection Failure in CONSENSUS_PULL_NUM_UNIQUE_TXNS Metric When Batch Summaries Are Missing

## Summary
The `CONSENSUS_PULL_NUM_UNIQUE_TXNS` metric overcounts unique transactions when batches lack transaction summaries (`txn_summaries`), failing to detect duplicates across batches. This causes the complementary `KNOWN_DUPLICATE_TXNS_WHEN_PULL` metric to underreport duplicates, hiding potential consensus issues from monitoring systems.

## Finding Description
The `pull_internal` function in `BatchProofQueue` is responsible for selecting batches to include in block proposals and calculating unique transaction counts. When a batch has transaction summaries available, it properly tracks duplicates using a `filtered_txns` HashSet. However, when `txn_summaries` is `None`, the code assumes all transactions in the batch are unique. [1](#0-0) 

The vulnerability occurs in two locations:

**First issue** - When checking if a batch can be added (lines 638-650), if `txn_summaries` is absent, it adds `batch.num_txns()` without checking for duplicates against already-selected batches.

**Second issue** - When actually updating the unique transaction count (lines 661-673), if `txn_summaries` is `None`, it uses `map_or(batch.num_txns(), ...)` which adds all transactions as unique WITHOUT inserting them into `filtered_txns`, breaking duplicate detection for subsequent batches. [2](#0-1) 

**When txn_summaries can be None:**
Proofs and batch summaries are received independently through the network. A `ProofOfStore` can arrive before the corresponding batch data and transaction summaries, resulting in a `QueueItem` with a proof but no `txn_summaries`. [3](#0-2) 

**Exploitation scenario:**
1. Transaction T appears in both Batch A (from Validator 1) and Batch B (from Validator 2)
2. Batch A has `txn_summaries` available, Batch B doesn't (proof arrived first)
3. When pulling proofs, Batch A adds T to `filtered_txns` and increments unique count by 1
4. Batch B doesn't check `filtered_txns`, adds all its transactions as unique, incrementing count by `num_txns()`
5. Transaction T is counted twice in `cur_unique_txns`
6. `CONSENSUS_PULL_NUM_UNIQUE_TXNS` records the overcounted value [4](#0-3) 

7. `KNOWN_DUPLICATE_TXNS_WHEN_PULL` = `all_txns.count() - unique_txns` undercounts duplicates [5](#0-4) 

The system explicitly tracks transactions appearing in multiple batches via `txn_summary_num_occurrences`, indicating this is an expected scenario that should be properly monitored. [6](#0-5) 

## Impact Explanation
This is a **Low severity** monitoring/observability bug as indicated in the security question. The impact is limited to:

1. **Incorrect Metrics**: `CONSENSUS_PULL_NUM_UNIQUE_TXNS` overcounts and `KNOWN_DUPLICATE_TXNS_WHEN_PULL` undercounts, hiding duplicate transaction issues from operators
2. **Conservative Resource Limiting**: The overcounted `cur_unique_txns` is used to calculate remaining capacity for additional batches, making the system artificially conservative (pulling fewer transactions than allowed) [7](#0-6) [8](#0-7) 

3. **Hidden Protocol Issues**: If duplicate transactions across batches indicate a bug or attack, monitoring systems won't detect it

**Why not higher severity:**
- Does NOT affect consensus safety (duplicate transactions in blocks are handled correctly by execution - only executed once due to sequence numbers)
- Does NOT cause fund loss
- Does NOT create exploitable resource exhaustion (makes system more conservative)
- Only affects observability and monitoring accuracy

## Likelihood Explanation
**High likelihood** of occurrence in normal operation:
- Proofs propagate through gossip independently from batch data
- Network latency variations mean proofs can arrive before batch summaries
- Multiple validators creating batches with overlapping transaction sets is a documented normal case
- The system already tracks this via `TXNS_WITH_DUPLICATE_BATCHES` metric [9](#0-8) 

## Recommendation
Modify `pull_internal` to track transactions from batches without summaries to prevent double-counting. When `txn_summaries` is `None`, use the batch's `num_txns()` conservatively but don't add to `filtered_txns` (current behavior), OR estimate based on the proof metadata if available.

**Better fix**: Always wait for `txn_summaries` before allowing a batch to be pulled, or implement a conservative duplicate estimation based on transaction count overlap probabilities.

**Immediate fix** - Update the duplicate counting logic:
```rust
// At line 661-673, when txn_summaries is None, 
// don't increment cur_unique_txns by full batch.num_txns()
// Instead, use a conservative estimate or mark as unknown
```

## Proof of Concept
```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::transaction::SignedTransaction;
    
    #[test]
    fn test_duplicate_counting_without_summaries() {
        // Setup: Create two batches with the same transaction
        let mut queue = BatchProofQueue::new(
            PeerId::random(),
            Arc::new(BatchStore::new(...)),
            1000000,
        );
        
        // Create transaction T1
        let txn = create_test_transaction();
        let txn_summary = TxnSummaryWithExpiration::new(
            txn.sender(),
            txn.replay_protector(),
            expiration,
            txn.committed_hash(),
        );
        
        // Insert Batch A with txn_summaries containing T1
        let batch_a_info = create_batch_info(1, vec![txn.clone()]);
        queue.insert_batches(vec![(batch_a_info.clone(), vec![txn_summary])]);
        
        // Insert proof for Batch A
        let proof_a = create_proof(batch_a_info);
        queue.insert_proof(proof_a);
        
        // Insert proof for Batch B (with same transaction) but NO summaries
        let batch_b_info = create_batch_info(2, vec![txn.clone()]);
        let proof_b = create_proof(batch_b_info);
        queue.insert_proof(proof_b); // No insert_batches for B
        
        // Pull proofs
        let (proofs, all_txns, unique_txns, _) = queue.pull_proofs(
            &HashSet::new(),
            PayloadTxnsSize::new(1000, 100000),
            100,
            100,
            true,
            Duration::from_secs(1000),
        );
        
        // Bug: unique_txns == 2, but should be 1 (T1 is duplicate)
        assert_eq!(proofs.len(), 2);
        assert_eq!(all_txns.count(), 2); // Correct: 2 transaction instances
        assert_eq!(unique_txns, 2); // BUG: Should be 1!
    }
}
```

## Notes
This vulnerability aligns with the "Low" severity classification in the security question. While it doesn't compromise consensus safety or cause fund loss, it degrades the observability and monitoring capabilities of the Quorum Store, potentially hiding issues that operators should be aware of. The system design explicitly anticipates duplicate transactions across batches, making accurate tracking essential for operational health monitoring.

### Citations

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L62-64)
```rust
    // Number of unexpired and uncommitted proofs in which the txn_summary = (sender, replay protector, hash, expiration)
    // has been included. We only count those batches that are in both author_to_batches and items along with proofs.
    txn_summary_num_occurrences: HashMap<TxnSummaryWithExpiration, u64>,
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L229-243)
```rust
        match self.items.entry(batch_key) {
            Entry::Occupied(mut entry) => {
                let item = entry.get_mut();
                item.proof = Some(proof);
                item.proof_insertion_time = Some(Instant::now());
            },
            Entry::Vacant(entry) => {
                entry.insert(QueueItem {
                    info: proof.info().clone(),
                    proof: Some(proof),
                    proof_insertion_time: Some(Instant::now()),
                    txn_summaries: None,
                });
            },
        }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L437-437)
```rust
            counters::CONSENSUS_PULL_NUM_UNIQUE_TXNS.observe_with(&["proof"], unique_txns as f64);
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L444-445)
```rust
            counters::KNOWN_DUPLICATE_TXNS_WHEN_PULL
                .observe((all_txns.count().saturating_sub(unique_txns)) as f64);
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L638-650)
```rust
                        let unique_txns = if let Some(ref txn_summaries) = item.txn_summaries {
                            cur_unique_txns
                                + txn_summaries
                                    .iter()
                                    .filter(|txn_summary| {
                                        !filtered_txns.contains(txn_summary)
                                            && block_timestamp.as_secs()
                                                < txn_summary.expiration_timestamp_secs
                                    })
                                    .count() as u64
                        } else {
                            cur_unique_txns + batch.num_txns()
                        };
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L661-673)
```rust
                        cur_unique_txns +=
                            item.txn_summaries
                                .as_ref()
                                .map_or(batch.num_txns(), |summaries| {
                                    summaries
                                        .iter()
                                        .filter(|summary| {
                                            filtered_txns.insert(**summary)
                                                && block_timestamp.as_secs()
                                                    < summary.expiration_timestamp_secs
                                        })
                                        .count() as u64
                                });
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L817-825)
```rust
        sample!(
            SampleRate::Duration(Duration::from_secs(3)),
            counters::TXNS_WITH_DUPLICATE_BATCHES.observe(
                self.txn_summary_num_occurrences
                    .iter()
                    .filter(|(_, count)| **count > 1)
                    .count() as f64,
            );
        );
```

**File:** consensus/src/quorum_store/proof_manager.rs (L133-133)
```rust
                let max_opt_batch_txns_after_filtering = request.max_txns_after_filtering - cur_unique_txns;
```

**File:** consensus/src/quorum_store/proof_manager.rs (L161-166)
```rust
                max_inline_txns_to_pull.set_count(min(
                    max_inline_txns_to_pull.count(),
                    request
                        .max_txns_after_filtering
                        .saturating_sub(cur_unique_txns),
                ));
```
