# Audit Report

## Title
TreeOnly State Restore Mode Creates Persistent State Inconsistency - Merkle Tree Without KV Data

## Summary
The `StateSnapshotRestoreMode::TreeOnly` restore mode can create a dangerous inconsistent state where the Jellyfish Merkle tree exists with valid proofs, but the corresponding key-value data is missing from the state KV database. This violates the fundamental state consistency invariant that if a key exists in the Merkle tree, its value must be queryable from storage.

## Finding Description
The state restore implementation in AptosDB supports three modes: `Default`, `KvOnly`, and `TreeOnly`. The `TreeOnly` mode is designed to restore only the Merkle tree structure without writing actual key-value data. [1](#0-0) 

When `TreeOnly` mode is active, the restore process only calls `tree_fn()` and completely skips `kv_fn()`, which means no KV data is written to the database: [2](#0-1) 

Similarly, during the finish phase, `TreeOnly` mode only finalizes the tree restoration without calling the KV finish method that would write usage statistics: [3](#0-2) 

The backup restore coordinator can use `TreeOnly` mode under specific conditions: [4](#0-3) 

**The State Inconsistency:**

When a state snapshot is restored with `TreeOnly` mode at version V:
1. The Jellyfish Merkle tree structure is fully restored with all internal nodes and leaf references
2. Merkle proofs can be generated and will verify correctly against the root hash
3. However, the actual state values are missing from the KV database

When state queries are executed, the system retrieves values from the KV database which returns `None` even though the Merkle tree indicates the key exists: [5](#0-4) 

This creates a severe state inconsistency where:
- `get_state_proof_by_version_ext` succeeds and returns valid Merkle proofs
- `get_state_value_by_version` returns `None` for keys that the tree claims exist
- Database consistency tools expect values to exist and will panic: [6](#0-5) 

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty program criteria for "State inconsistencies requiring intervention."

**Broken Invariant:** State Consistency - "State transitions must be atomic and verifiable via Merkle proofs" (Critical Invariant #4)

**Specific Impacts:**
1. **Node Malfunction**: Nodes with TreeOnly-restored snapshots cannot serve state queries at the restored version, causing API failures and state sync issues
2. **Data Availability Loss**: Critical state data becomes inaccessible despite having valid Merkle proofs, breaking the fundamental storage guarantee
3. **Consensus Divergence Risk**: If different nodes have inconsistent state (some with KV data, some without), they may diverge when processing transactions that depend on that state
4. **Database Corruption Detection**: The `scan_snapshot` debugging tool will panic, indicating the database is in an invalid state

However, this does NOT qualify for higher severity because:
- It requires operator access to trigger (running backup-cli restore operations)
- It does not directly cause consensus safety violations or fund loss
- It is detectable and potentially recoverable through re-restoration

## Likelihood Explanation
**Likelihood: Low to Medium**

The vulnerability can manifest in several scenarios:

1. **Resume After Interruption**: If a restore operation is interrupted after Phase 1 completes (KV restored to version V) but before Phase 2 completes (tree restore), and the operator resumes with different parameters, TreeOnly mode may be used inappropriately.

2. **Manual Configuration Error**: Operators manually specifying `StateSnapshotRestoreMode::TreeOnly` without ensuring KV data exists.

3. **Logic Error in Restore Coordinator**: The restore coordinator logic assumes Phase 1 always runs when needed, but the condition `do_phase_1 = do_phase_1 && !replay_all_mode` can skip Phase 1 inappropriately: [7](#0-6) 

**Mitigating Factors:**
- The restore coordinator is designed to prevent this scenario under normal operation
- Operators would notice state query failures quickly
- Only affects operator-controlled restore operations, not regular node operation

**Note on Exploitability:** This vulnerability does **not** meet the criterion "Exploitable by unprivileged attacker (no validator insider access required)" as it requires operator access to run restore operations. However, it represents a serious operational hazard that violates critical state consistency guarantees.

## Recommendation
Implement strict validation to prevent TreeOnly mode from creating inconsistent state:

1. **Add State Consistency Check**: Before allowing TreeOnly restore, verify that KV data already exists at the target version, or enforce that TreeOnly can only be used as part of a multi-phase restore where KV is guaranteed to be populated.

2. **Remove TreeOnly Public Access**: Make TreeOnly mode an internal implementation detail that can only be used within the carefully controlled restore coordinator logic, not as a user-selectable option.

3. **Add Post-Restore Validation**: After any restore operation completes, run a consistency check to verify that for every key in the Merkle tree, the corresponding value exists in the KV database.

4. **Improve Error Handling**: Instead of panicking, make state query methods return explicit errors when tree-KV inconsistency is detected, with clear guidance on how to recover.

## Proof of Concept
This vulnerability requires operator access and cannot be exploited by unprivileged attackers. A PoC would involve:

```rust
// Conceptual PoC - requires operator access to backup-cli

// Step 1: Create a state snapshot at version V with both tree and KV data
// Step 2: Restore to a new database using StateSnapshotRestoreMode::TreeOnly
// Step 3: Attempt to query state at version V
// Expected: Merkle proofs verify but get_state_value_by_version returns None
// Expected: scan_snapshot tool panics with "Value must exist"

// This demonstrates the inconsistent state but is not remotely exploitable
```

## Notes
While this represents a significant design flaw that can create invalid database states, it does not meet the strict exploitability criteria for a security vulnerability as defined by the audit requirements. It is an operational hazard that should be addressed to maintain system integrity, but requires trusted operator access to trigger.

The security question correctly identifies that TreeOnly mode **can** create a state where Merkle proofs verify but data is missing, confirming the premise. However, the exploitability is limited to operators with restore access, not unprivileged external attackers.

### Citations

**File:** storage/aptosdb/src/state_restore/mod.rs (L49-57)
```rust
#[derive(Clone, Copy, Deserialize, Serialize, PartialEq, Eq)]
pub enum StateSnapshotRestoreMode {
    /// Restore both KV and Tree by default
    Default,
    /// Only restore the state KV
    KvOnly,
    /// Only restore the state tree
    TreeOnly,
}
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L246-255)
```rust
        match self.restore_mode {
            StateSnapshotRestoreMode::KvOnly => kv_fn()?,
            StateSnapshotRestoreMode::TreeOnly => tree_fn()?,
            StateSnapshotRestoreMode::Default => {
                // We run kv_fn with TreeOnly to restore the usage of DB
                let (r1, r2) = IO_POOL.join(kv_fn, tree_fn);
                r1?;
                r2?;
            },
        }
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L261-271)
```rust
        match self.restore_mode {
            StateSnapshotRestoreMode::KvOnly => self.kv_restore.lock().take().unwrap().finish()?,
            StateSnapshotRestoreMode::TreeOnly => {
                self.tree_restore.lock().take().unwrap().finish_impl()?
            },
            StateSnapshotRestoreMode::Default => {
                // for tree only mode, we also need to write the usage to DB
                self.kv_restore.lock().take().unwrap().finish()?;
                self.tree_restore.lock().take().unwrap().finish_impl()?
            },
        }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L198-233)
```rust
        let mut do_phase_1 = if let Some(kv_snapshot) = kv_snapshot.as_ref() {
            // if we have a kv snapshot, we need to restore the state between lhs and rs
            // if the version are equal, we don't need to restore phase 1. we can directly restore a snapshot with both tree and KV, and then replay txn till the target_version
            kv_snapshot.version < tree_snapshot.version
        } else {
            // if we don't have a kv snapshot, we need to restore the state between db_next_version and rs
            db_next_version < tree_snapshot.version
        };
        let txn_start_version = if let Some(kv_snapshot) = kv_snapshot.as_ref() {
            kv_snapshot.version
        } else {
            db_next_version
        };
        let transaction_backups =
            metadata_view.select_transaction_backups(txn_start_version, target_version)?;
        let epoch_ending_backups = metadata_view.select_epoch_ending_backups(target_version)?;
        let epoch_handles = epoch_ending_backups
            .iter()
            .filter(|e| e.first_version <= target_version)
            .map(|backup| backup.manifest.clone())
            .collect();
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };

        do_phase_1 = do_phase_1 && !replay_all_mode;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L318-326)
```rust
                let restore_mode_opt = if db_next_version > 0 {
                    if replay_all_mode {
                        None // the restore should already been done in the replay_all mode
                    } else {
                        Some(StateSnapshotRestoreMode::TreeOnly)
                    }
                } else {
                    Some(StateSnapshotRestoreMode::Default)
                };
```

**File:** storage/aptosdb/src/state_kv_db.rs (L374-402)
```rust
    pub(crate) fn get_state_value_with_version_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<Option<(Version, StateValue)>> {
        let mut read_opts = ReadOptions::default();

        // We want `None` if the state_key changes in iteration.
        read_opts.set_prefix_same_as_start(true);
        if !self.enabled_sharding() {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueSchema>(read_opts)?;
            iter.seek(&(state_key.clone(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        } else {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueByKeyHashSchema>(read_opts)?;
            iter.seek(&(state_key.hash(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        }
    }
```

**File:** storage/aptosdb/src/db_debugger/state_kv/scan_snapshot.rs (L85-111)
```rust
                            let (value_version, value) = if enable_sharding {
                                let mut iter = state_kv_db
                                    .db_shard(key.get_shard_id())
                                    .iter::<StateValueByKeyHashSchema>()
                                    .unwrap();
                                iter.seek(&(key.hash(), key_version)).unwrap();
                                iter.next()
                                    .transpose()
                                    .unwrap()
                                    .and_then(|((_, version), value_opt)| {
                                        value_opt.map(|value| (version, value))
                                    })
                                    .expect("Value must exist.")
                            } else {
                                let mut iter = state_kv_db
                                    .db_shard(key.get_shard_id())
                                    .iter::<StateValueSchema>()
                                    .unwrap();
                                iter.seek(&(key.clone(), key_version)).unwrap();
                                iter.next()
                                    .transpose()
                                    .unwrap()
                                    .and_then(|((_, version), value_opt)| {
                                        value_opt.map(|value| (version, value))
                                    })
                                    .expect("Value must exist.")
                            };
```
