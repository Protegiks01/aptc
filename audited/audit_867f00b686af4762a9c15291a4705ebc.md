# Audit Report

## Title
Error Middleware Bypass in Aptos Faucet Allows Raw Framework Error Leakage

## Summary
The Aptos Faucet service incorrectly registers the `convert_error()` middleware, causing certain endpoints (`/mint`, `/spec.json`, `/spec.yaml`) to bypass error conversion and leak raw Poem framework errors instead of the standardized `AptosTapError` format specified in the OpenAPI specification.

## Finding Description

The Aptos Faucet's error converter middleware is designed to ensure all API responses conform to the documented `AptosTapError` format, preventing raw framework errors from being exposed to clients. [1](#0-0) 

However, the middleware is registered incorrectly in the route configuration. The `.catch_all_error(convert_error)` is only applied to the nested route containing the OpenAPI service endpoints, not to the root route level where `/mint`, `/spec.json`, and `/spec.yaml` are registered: [2](#0-1) 

This creates a middleware bypass where errors occurring on these root-level endpoints are never converted to the standardized format. The conversion function checks if errors have a source to distinguish framework errors from application errors: [3](#0-2) 

**Attack Path:**

1. Attacker sends malformed requests to the `/mint` endpoint:
   - `GET /mint` (method not allowed, only POST accepted)
   - `/mint?amount=invalid_string` (Query deserialization failure)
   - `/mint` with missing or invalid headers that break `RealIp` extraction

2. The Poem framework generates errors during request processing (before the handler executes)

3. These errors occur on routes outside the `.catch_all_error(convert_error)` scope

4. Raw framework errors are returned to the client, potentially containing:
   - Internal implementation details
   - Stack traces (in debug builds)
   - Rust type information
   - File paths and line numbers
   - Other debugging information

The `/mint` endpoint is particularly vulnerable as it uses `poem::web::Query<MintRequest>` for parameter extraction: [4](#0-3) 

In contrast, the main Aptos API correctly applies the error converter to the entire route tree: [5](#0-4) 

## Impact Explanation

This is a **Medium Severity** vulnerability (up to $10,000 per Aptos Bug Bounty) representing an information disclosure issue:

1. **API Contract Violation**: The OpenAPI specification promises all errors will be in `AptosTapError` format with specific error codes, but this is violated for affected endpoints

2. **Information Leakage**: Raw framework errors can expose internal implementation details, stack traces, file paths, and debugging information useful for reconnaissance

3. **Client Integration Failures**: Clients expecting the documented `AptosTapError` format will fail to parse raw Poem errors, potentially causing cascading failures in dependent systems

4. **Security Principle Violation**: Breaks the "fail securely" principle - all error paths should go through the same sanitization to prevent information leakage

While this doesn't directly lead to fund loss or consensus violations, it weakens the security posture by providing attackers with internal system information that could facilitate further attacks.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is trivially exploitable:

1. **No authentication required**: Any external user can send requests to the faucet service
2. **Simple exploitation**: Triggering framework errors requires only basic HTTP requests with invalid parameters
3. **Multiple attack vectors**: Various malformed requests can trigger different framework errors
4. **Always active**: The misconfiguration affects all deployments of the faucet service

The `/mint` endpoint is actively used in production for backwards compatibility with older faucet clients, making this a real-world exposure.

## Recommendation

Move the `.catch_all_error(convert_error)` call to apply to the entire root route, not just the nested OpenAPI service route. This matches the pattern used in the main Aptos API.

**Fixed Code:**
```rust
let api_server_future = Server::new_with_acceptor(TcpAcceptor::from_tokio(listener)?).run(
    Route::new()
        .nest(
            &self.server_config.api_path_base,
            Route::new()
                .nest("", api_service),
        )
        .at("/spec.json", spec_json)
        .at("/spec.yaml", spec_yaml)
        .at("/mint", poem::post(mint.data(fund_api_components)))
        .with(cors)
        .around(middleware_log)
        .catch_all_error(convert_error),  // Move here - applies to entire route tree
);
```

Remove the `.catch_all_error(convert_error)` from line 213 and add it after `.around(middleware_log)` at the root level.

## Proof of Concept

**Test Steps:**

1. Deploy the faucet service with current code
2. Send malformed requests to demonstrate error leakage:

```bash
# Test 1: Method not allowed on /mint
curl -X GET http://faucet-host:8081/mint
# Expected: Returns raw Poem "Method Not Allowed" error
# Should return: AptosTapError with WebFrameworkError code

# Test 2: Invalid query parameter type
curl -X POST "http://faucet-host:8081/mint?amount=invalid_string"
# Expected: Returns raw Poem deserialization error with Rust type info
# Should return: AptosTapError with WebFrameworkError code

# Test 3: Compare with /fund endpoint (which is properly protected)
curl -X POST http://faucet-host:8081/v1/fund \
  -H "Content-Type: application/json" \
  -d '{"invalid": "json"}'
# This correctly returns AptosTapError format due to middleware coverage
```

**Expected Raw Error Format (current behavior):**
```json
{
  "error": "failed to parse Query: invalid digit found in string",
  "status": 400
}
```

**Expected Standardized Error Format (after fix):**
```json
{
  "message": "failed to parse Query: invalid digit found in string",
  "error_code": 60,
  "rejection_reasons": [],
  "txn_hashes": []
}
```

The raw error exposes internal Rust/Poem implementation details, while the standardized format conforms to the documented API specification with the `WebFrameworkError` code (60).

## Notes

This vulnerability demonstrates the importance of middleware ordering and scope in web frameworks. The main Aptos API (in `api/src/runtime.rs`) implements this pattern correctly, but the faucet service has a configuration error. While the faucet is not a consensus-critical component, it's a public-facing service where information leakage can aid attackers in reconnaissance for more serious attacks.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/error_converter.rs (L8-12)
```rust
/// In the OpenAPI spec for this API, we say that every response we return will
/// be a JSON representation of AptosTapError. For our own errors, this is exactly
/// what we do. The problem is the Poem framework does not conform to this
/// format, it can return errors in a different format. The purpose of this
/// function is to catch those errors and convert them to the correct format.
```

**File:** crates/aptos-faucet/core/src/endpoints/error_converter.rs (L17-27)
```rust
    let is_framework_error = error.has_source();
    if is_framework_error {
        // Build an AptosTapErrorResponse and then reset its status code
        // to the originally intended status code in the error.
        let mut response = build_error_response(error.to_string()).into_response();
        response.set_status(error.status());
        response
    } else {
        error.into_response()
    }
}
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L207-220)
```rust
        let api_server_future = Server::new_with_acceptor(TcpAcceptor::from_tokio(listener)?).run(
            Route::new()
                .nest(
                    &self.server_config.api_path_base,
                    Route::new()
                        .nest("", api_service)
                        .catch_all_error(convert_error),
                )
                .at("/spec.json", spec_json)
                .at("/spec.yaml", spec_yaml)
                .at("/mint", poem::post(mint.data(fund_api_components)))
                .with(cors)
                .around(middleware_log),
        );
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L379-394)
```rust
#[poem::handler]
pub async fn mint(
    fund_api_components: poem::web::Data<&Arc<FundApiComponents>>,
    poem::web::Query(MintRequest {
        amount,
        auth_key,
        address,
        pub_key,
        return_txns,
    }): poem::web::Query<MintRequest>,
    // This automagically uses FromRequest to get this data from the request.
    // It takes into things like X-Forwarded-IP and X-Real-IP.
    source_ip: RealIp,
    // Same thing, this uses FromRequest.
    header_map: &HeaderMap,
) -> poem::Result<MintResponse> {
```

**File:** api/src/runtime.rs (L238-259)
```rust
        let route = Route::new()
            .at("/", poem::get(root_handler))
            .nest(
                "/v1",
                Route::new()
                    .nest("/", api_service)
                    .at("/spec.json", poem::get(spec_json))
                    .at("/spec.yaml", poem::get(spec_yaml))
                    // TODO: We add this manually outside of the OpenAPI spec for now.
                    // https://github.com/poem-web/poem/issues/364
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
            )
            .with(cors)
            .with_if(config.api.compression_enabled, Compression::new())
            .with(PostSizeLimit::new(size_limit))
            .with(CatchPanic::new().with_handler(panic_handler))
            // NOTE: Make sure to keep this after all the `with` middleware.
            .catch_all_error(convert_error)
            .around(middleware_log);
```
