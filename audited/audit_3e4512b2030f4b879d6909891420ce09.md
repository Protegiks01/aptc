# Audit Report

## Title
Data Exfiltration via Runtime Environment Variables in CLI Telemetry

## Summary
The Aptos CLI telemetry system reads user-controlled environment variables at runtime and transmits them to external telemetry backends without sanitization. An attacker with access to a compromised telemetry backend can exfiltrate sensitive data by convincing users to set malicious environment variables before running CLI commands.

## Finding Description

The `send_telemetry_event()` function collects build information via `cli_build_information()` every time a CLI command executes. This function invokes the `build_information!()` macro, which calls `get_build_information()` at runtime. [1](#0-0) 

The `get_build_information()` function reads four environment variables from the user's shell environment at runtime using `std::env::var()`: [2](#0-1) 

Despite the misleading comment stating "environment variables set during build-time", the code uses `std::env::var()` (not `std::env!()`), which performs runtime reads of the current process environment. These values are inserted directly into the telemetry parameters without any validation or sanitization: [3](#0-2) 

The telemetry data is then serialized to JSON and transmitted to external backends via HTTP POST: [4](#0-3) 

**Attack Scenario:**
1. Attacker convinces user to set malicious environment variables (e.g., `export GIT_SHA="$(cat ~/.ssh/id_rsa | base64)"`)
2. User runs any Aptos CLI command
3. The environment variables are read at runtime and included in telemetry
4. Data is transmitted to the telemetry backend
5. Attacker with access to the compromised backend retrieves the exfiltrated sensitive data

This breaks the security guarantee that only trusted build metadata should be transmitted to telemetry systems. User-controlled runtime data creates an information disclosure vector.

## Impact Explanation

This vulnerability allows **data exfiltration** when the telemetry backend is compromised, qualifying as **Medium Severity** per the Aptos bug bounty criteria:

- **Limited information disclosure**: Sensitive data (credentials, keys, proprietary information) can be exfiltrated through specific environment variable channels
- **Requires backend compromise**: The attack assumes the telemetry backend is already compromised or controlled by the attacker
- **User interaction required**: Users must be convinced to set specific environment variables

The impact is limited to data exfiltration and does not affect consensus, validator operations, or on-chain state. It does not cause loss of funds or network availability issues.

## Likelihood Explanation

**Likelihood: Low-Medium**

**Prerequisites:**
1. Social engineering to convince users to set GIT_SHA, GIT_BRANCH, GIT_TAG, or BUILD_DATE environment variables
2. Attacker access to the compromised telemetry backend (Google Analytics or Aptos telemetry service)
3. Telemetry must be enabled (not disabled via `APTOS_DISABLE_TELEMETRY`)

**Factors increasing likelihood:**
- Environment variables persist in shell sessions, so one-time social engineering could enable ongoing exfiltration
- Users working in CI/CD environments may already have these variables set legitimately
- The variable names (GIT_SHA, etc.) appear innocuous and build-related

**Factors decreasing likelihood:**
- Most end users don't set these specific environment variables in normal usage
- Requires both social engineering AND backend compromise
- Attack is detectable through monitoring telemetry data for anomalous values

## Recommendation

**Immediate Fix:** Remove runtime environment variable reading from the build information collection, or implement strict validation:

```rust
pub fn get_build_information() -> BTreeMap<String, String> {
    shadow!(build);
    let mut build_information = BTreeMap::new();

    // Use only compile-time build information from shadow_rs
    build_information.insert(BUILD_BRANCH.into(), build::BRANCH.into());
    build_information.insert(BUILD_CARGO_VERSION.into(), build::CARGO_VERSION.into());
    build_information.insert(BUILD_CLEAN_CHECKOUT.into(), build::GIT_CLEAN.to_string());
    build_information.insert(BUILD_COMMIT_HASH.into(), build::COMMIT_HASH.into());
    build_information.insert(BUILD_TAG.into(), build::TAG.into());
    build_information.insert(BUILD_TIME.into(), build::BUILD_TIME.into());
    build_information.insert(BUILD_OS.into(), build::BUILD_OS.into());
    build_information.insert(BUILD_RUST_CHANNEL.into(), build::RUST_CHANNEL.into());
    build_information.insert(BUILD_RUST_VERSION.into(), build::RUST_VERSION.into());

    // Compilation information
    build_information.insert(BUILD_IS_RELEASE_BUILD.into(), is_release().to_string());
    build_information.insert(BUILD_PROFILE_NAME.into(), get_build_profile_name());
    build_information.insert(
        BUILD_USING_TOKIO_UNSTABLE.into(),
        std::env!("USING_TOKIO_UNSTABLE").to_string(),
    );

    // REMOVED: Runtime environment variable reads that could leak user data
    
    build_information
}
```

**Alternative Fix (if runtime override is required):** Add strict validation and length limits:

```rust
fn sanitize_build_env_var(value: String) -> Option<String> {
    const MAX_LENGTH: usize = 64;
    const ALLOWED_CHARS_REGEX: &str = r"^[a-zA-Z0-9._\-/]+$";
    
    if value.len() > MAX_LENGTH {
        return None;
    }
    
    if !regex::Regex::new(ALLOWED_CHARS_REGEX).unwrap().is_match(&value) {
        return None;
    }
    
    Some(value)
}

// Then use sanitize_build_env_var() before inserting
if let Ok(git_sha) = std::env::var("GIT_SHA") {
    if let Some(sanitized) = sanitize_build_env_var(git_sha) {
        build_information.insert(BUILD_COMMIT_HASH.into(), sanitized);
    }
}
```

## Proof of Concept

**Setup:**
```bash
# Build the Aptos CLI from source
git clone https://github.com/aptos-labs/aptos-core
cd aptos-core
cargo build --release -p aptos

# Set malicious environment variable containing sensitive data
export GIT_SHA="EXFILTRATED_SECRET_DATA_$(whoami)_$(date +%s)"
export GIT_BRANCH="sensitive_token_abc123"

# Run any CLI command
./target/release/aptos init --network testnet --assume-yes

# The environment variables will be read at runtime and sent to telemetry
# An attacker with access to the telemetry backend can retrieve:
# - build_commit_hash: "EXFILTRATED_SECRET_DATA_username_1234567890"
# - build_branch: "sensitive_token_abc123"
```

**Verification:**
You can verify this by adding debug output to `get_build_information()`:
```rust
if let Ok(git_sha) = std::env::var("GIT_SHA") {
    eprintln!("DEBUG: Reading GIT_SHA from runtime env: {}", git_sha);
    build_information.insert(BUILD_COMMIT_HASH.into(), git_sha);
}
```

Run the CLI with the malicious environment variable set, and you'll see the debug output confirming runtime environment variable reading, followed by the data being transmitted to the telemetry endpoint.

## Notes

This vulnerability specifically addresses the security question about data exfiltration through the telemetry channel when the backend is compromised. While the attack requires both social engineering and backend access, it represents a genuine information disclosure risk that should be mitigated by removing or sanitizing runtime environment variable reads in the build information collection function.

### Citations

**File:** crates/aptos/src/common/utils.rs (L134-147)
```rust
async fn send_telemetry_event(command: &str, latency: Duration, error: Option<&str>) {
    // Collect the build information
    let build_information = cli_build_information();

    // Send the event
    aptos_telemetry::cli_metrics::send_cli_telemetry_event(
        build_information,
        command.into(),
        latency,
        error.is_none(),
        error,
    )
    .await;
}
```

**File:** crates/aptos-build-info/src/lib.rs (L85-104)
```rust
    // Get Git metadata from environment variables set during build-time.
    // This is applicable for docker based builds  where the cargo cannot
    // access the .git directory, or to override shadow_rs provided info.
    if let Ok(git_sha) = std::env::var("GIT_SHA") {
        build_information.insert(BUILD_COMMIT_HASH.into(), git_sha);
    }

    if let Ok(git_branch) = std::env::var("GIT_BRANCH") {
        build_information.insert(BUILD_BRANCH.into(), git_branch);
    }

    if let Ok(git_tag) = std::env::var("GIT_TAG") {
        build_information.insert(BUILD_TAG.into(), git_tag);
    }

    if let Ok(build_date) = std::env::var("BUILD_DATE") {
        build_information.insert(BUILD_TIME.into(), build_date);
    }

    build_information
```

**File:** crates/aptos-telemetry/src/cli_metrics.rs (L56-71)
```rust
pub(crate) fn collect_cli_info(
    command: String,
    latency: Duration,
    success: bool,
    error: Option<&str>,
    build_information: &mut BTreeMap<String, String>,
) {
    build_information.insert(COMMAND.into(), command);
    build_information.insert(LATENCY.into(), latency.as_millis().to_string());
    build_information.insert(SUCCESS.into(), success.to_string());
    utils::insert_optional_value(
        build_information,
        ERROR,
        error.map(|inner| inner.to_string()),
    );
}
```

**File:** crates/aptos-telemetry/src/service.rs (L501-520)
```rust
fn spawn_event_sender_to_google_analytics(
    api_secret: String,
    measurement_id: String,
    event_name: String,
    telemetry_dump: TelemetryDump,
) -> JoinHandle<()> {
    tokio::spawn(async move {
        // Create a request client
        let client = reqwest::Client::new();

        // Send the request and wait for a response
        let send_result = client
            .post(format!(
                "{}?&measurement_id={}&api_secret={}",
                GA4_URL, measurement_id, api_secret
            ))
            .json::<TelemetryDump>(&telemetry_dump)
            .send()
            .await;

```
