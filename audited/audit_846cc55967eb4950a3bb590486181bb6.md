# Audit Report

## Title
Silent Failure in Delegation Pool Balance Queries Due to Insufficient Error Propagation

## Summary
The Rosetta API's delegation pool balance query endpoint silently catches all errors and returns empty balances instead of propagating errors to users. This occurs due to insufficient testing of delegated stake variants (active, inactive, pending_inactive) with various pool addresses, which would have revealed this error handling flaw.

## Finding Description
When querying delegation pool balances through the Rosetta `/account/balance` endpoint, the system fails to properly handle error cases. The `get_delegation_info` function catches all errors from the underlying balance retrieval logic but only logs them as warnings, then returns success with empty balances. [1](#0-0) 

The issue manifests when:
1. A user queries a non-existent pool address
2. A user provides an invalid pool address format
3. Network/RPC errors occur during the view function call
4. The pool exists but is not a delegation pool

In all these cases, instead of receiving an error response, the API returns HTTP 200 with `balance: 0` and `lockup_expiration: 0`, indistinguishable from a legitimate zero balance.

The root cause is the catch-all match arm at line 291 that handles both `Ok(None)` and `Err(...)` cases identically - only logging a warning without propagating the error. [2](#0-1) 

## Impact Explanation
This issue qualifies as **Medium Severity** under the "State inconsistencies requiring intervention" category, though it's at the borderline. The impact includes:

1. **Incorrect Financial Information**: Users receive misleading balance information (0) when they should receive an error, potentially leading to incorrect financial decisions
2. **Poor User Experience**: Legitimate errors (typos in pool addresses, network issues) are masked as zero balances
3. **Debugging Difficulty**: Users and integrators cannot distinguish between genuine zero balances and error conditions
4. **API Contract Violation**: The API violates the principle of fail-fast error handling

However, this is NOT a Critical or High severity issue because:
- No blockchain state is corrupted
- No funds can be stolen or manipulated
- The blockchain core functionality remains unaffected
- It's limited to the Rosetta API layer (read-only interface)

## Likelihood Explanation
**Likelihood: High**

This issue will occur in several common scenarios:
1. **User Error**: Users frequently make typos in addresses (very common)
2. **Configuration Errors**: Integration tools may have incorrect pool address configurations
3. **Network Instability**: Temporary RPC failures will be masked as zero balances
4. **Lack of Testing**: The absence of comprehensive tests with various pool addresses (as noted in the security question) allowed this bug to persist

The issue is easily reproducible and affects all delegated stake balance queries with invalid inputs.

## Recommendation
Propagate errors properly instead of silently catching them. Modify `get_delegation_info` to return errors:

```rust
async fn get_delegation_info(
    rest_client: &Client,
    account: &AccountIdentifier,
    owner_address: AccountAddress,
    pool_address: AccountAddress,
    version: u64,
) -> ApiResult<(Vec<Amount>, u64)> {
    let balance_result = get_delegation_stake_balances(
        rest_client, 
        account, 
        owner_address, 
        pool_address, 
        version
    ).await?;
    
    match balance_result {
        Some(result) => {
            let balances = if let Some(balance) = result.balance {
                vec![Amount {
                    value: balance.value,
                    currency: native_coin(),
                }]
            } else {
                vec![]
            };
            Ok((balances, result.lockup_expiration))
        },
        None => Err(ApiError::InvalidInput(Some(
            format!("No delegation stake found for delegator {} at pool {}", 
                owner_address, pool_address)
        )))
    }
}
```

Additionally, add comprehensive integration tests covering:
- Valid pool addresses with all stake states (active, inactive, pending_inactive)
- Multiple different pool addresses
- Invalid pool address formats
- Non-existent pool addresses
- Non-delegation-pool addresses
- Network error scenarios

## Proof of Concept

```rust
#[tokio::test]
async fn test_delegated_stake_invalid_pool_should_error() {
    let (swarm, cli, _, rosetta_client) = setup_simple_test(1).await;
    let chain_id = swarm.chain_id();
    let account = cli.account_id(0);
    
    // Create AccountIdentifier with invalid pool address
    let invalid_pool = AccountAddress::from_hex_literal("0xDEADBEEF").unwrap();
    let account_identifier = AccountIdentifier {
        address: account.to_hex_literal(),
        sub_account: Some(SubAccountIdentifier {
            address: "active_stake".to_string(),
            metadata: Some(SubAccountIdentifierMetadata {
                pool_address: invalid_pool.to_hex_literal(),
            }),
        }),
    };
    
    // Query balance - should return error but currently returns 0
    let request = AccountBalanceRequest {
        network_identifier: chain_id.into(),
        account_identifier,
        block_identifier: None,
        currencies: Some(vec![native_coin()]),
    };
    
    let response = rosetta_client.account_balance(&request).await;
    
    // BUG: Currently succeeds with empty balance
    assert!(response.is_ok());
    assert_eq!(response.unwrap().balances, vec![]);
    
    // EXPECTED: Should return error
    // assert!(response.is_err());
}
```

**Notes:**
While this is a legitimate bug that should be fixed, it exists at the API layer and does not affect blockchain consensus, state integrity, or core protocol security. The lack of thorough testing with various pool addresses (as identified in the security question) allowed this error handling flaw to persist undetected.

### Citations

**File:** crates/aptos-rosetta/src/account.rs (L269-299)
```rust
async fn get_delegation_info(
    rest_client: &Client,
    account: &AccountIdentifier,
    owner_address: AccountAddress,
    pool_address: AccountAddress,
    version: u64,
) -> ApiResult<(Vec<Amount>, u64)> {
    let mut balances = vec![];
    let mut lockup_expiration: u64 = 0;

    match get_delegation_stake_balances(rest_client, account, owner_address, pool_address, version)
        .await
    {
        Ok(Some(balance_result)) => {
            if let Some(balance) = balance_result.balance {
                balances.push(Amount {
                    value: balance.value,
                    currency: native_coin(),
                });
            }
            lockup_expiration = balance_result.lockup_expiration;
        },
        result => {
            warn!(
                    "Failed to retrieve requested balance for delegator_address: {}, pool_address: {}: {:?}",
                    owner_address, pool_address, result
                )
        },
    }
    Ok((balances, lockup_expiration))
}
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L384-435)
```rust
pub async fn get_delegation_stake_balances(
    rest_client: &aptos_rest_client::Client,
    account_identifier: &AccountIdentifier,
    owner_address: AccountAddress,
    pool_address: AccountAddress,
    version: u64,
) -> ApiResult<Option<BalanceResult>> {
    // get requested_balance
    let balances_response = rest_client
        .view(
            &ViewRequest {
                function: DELEGATION_POOL_GET_STAKE_FUNCTION.clone(),
                type_arguments: vec![],
                arguments: vec![
                    serde_json::Value::String(pool_address.to_string()),
                    serde_json::Value::String(owner_address.to_string()),
                ],
            },
            Some(version),
        )
        .await?;

    let requested_balance =
        parse_requested_balance(account_identifier, balances_response.into_inner());

    // get lockup_secs
    let lockup_secs_response = rest_client
        .view(
            &ViewRequest {
                function: STAKE_GET_LOCKUP_SECS_FUNCTION.clone(),
                type_arguments: vec![],
                arguments: vec![serde_json::Value::String(pool_address.to_string())],
            },
            Some(version),
        )
        .await?;
    let lockup_expiration = parse_lockup_expiration(lockup_secs_response.into_inner());

    if let Some(balance) = requested_balance {
        Ok(Some(BalanceResult {
            balance: Some(Amount {
                value: balance,
                currency: native_coin(),
            }),
            lockup_expiration,
        }))
    } else {
        Err(ApiError::InternalError(Some(
            "Unable to construct BalanceResult instance".to_string(),
        )))
    }
}
```
