# Audit Report

## Title
Memory Exhaustion via Unbounded Queue Configuration in aptos_channel

## Summary
When `max_queue_size_per_key` is configured with an extremely large value (approaching `usize::MAX`), the per-key queue bounds become ineffective at preventing memory exhaustion. An attacker can exploit misconfigured nodes by flooding them with messages, causing out-of-memory (OOM) conditions before the theoretical queue limit provides any protection.

## Finding Description

The `PerKeyQueue` implementation in `message_queues.rs` enforces per-key message limits to prevent resource exhaustion. However, when `max_queue_size` is set to an extremely large value, this protection mechanism fails. [1](#0-0) 

The vulnerability exists because messages are only dropped AFTER the queue reaches `max_queue_size`. On a 64-bit system, `usize::MAX` equals 18,446,744,073,709,551,615. No practical system has enough memory to store that many messagesâ€”even small 100-byte messages would require approximately 1.8 exabytes of memory.

**Attack Flow:**
1. A validator node is configured (through misconfiguration or insider action) with `max_network_channel_size` or `internal_per_key_channel_size` set to an excessively large value
2. An external attacker identifies the misconfigured node
3. The attacker floods the node with consensus messages, block retrieval requests, or other network protocol messages
4. Each message is queued per the sender's key, consuming memory
5. The system exhausts available RAM (typically 64-256 GB on validator nodes) long before the queue limit triggers
6. The node crashes with an OOM error, causing validator unavailability [2](#0-1) 

The channel creation only validates that `max_queue_size_per_key` is non-zero, but places no upper bound validation on the value. [3](#0-2) 

While default configurations use reasonable values (1024 for network channels, 10 for internal channels), the configuration system lacks validation to prevent operators from setting dangerous values.

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty criteria)

This vulnerability enables a **Denial of Service attack** against misconfigured validator nodes:

- **Affected Scope**: Individual validator nodes with misconfigured queue sizes
- **Network Impact**: If multiple validators are affected, could reduce network participation and impact consensus liveness
- **Recovery**: Requires node restart and configuration fix
- **Not Critical because**: 
  - Does not cause consensus safety violations or chain splits
  - Does not enable fund theft or minting
  - Does not affect properly configured nodes
  - Requires pre-existing misconfiguration to exploit

The impact aligns with **Medium Severity** ($10,000): "State inconsistencies requiring intervention" - the affected node becomes unavailable and requires manual intervention to restore service.

## Likelihood Explanation

**Likelihood: Low-Medium**

**Factors increasing likelihood:**
- No validation exists to prevent extreme configuration values
- Configuration errors are common in production systems
- Default values in various places could be overridden by operators
- Attack is trivial once misconfiguration exists (just flood with messages)

**Factors decreasing likelihood:**
- Default configurations use safe, reasonable values
- Node operators would need to explicitly override defaults with extreme values
- Misconfiguration would likely be caught during node testing before production deployment
- Requires attacker to identify misconfigured nodes

## Recommendation

**Implement configuration validation with reasonable upper bounds:**

```rust
// In crates/channel/src/aptos_channel.rs
pub fn new<K: Eq + Hash + Clone, M>(
    queue_style: QueueStyle,
    max_queue_size_per_key: usize,
    counters: Option<&'static IntCounterVec>,
) -> (Sender<K, M>, Receiver<K, M>) {
    // Add maximum bound validation
    const MAX_REASONABLE_QUEUE_SIZE: usize = 100_000; // ~10MB with 100-byte messages
    
    if max_queue_size_per_key > MAX_REASONABLE_QUEUE_SIZE {
        panic!(
            "max_queue_size_per_key ({}) exceeds maximum allowed ({})",
            max_queue_size_per_key,
            MAX_REASONABLE_QUEUE_SIZE
        );
    }
    
    let max_queue_size_per_key =
        NonZeroUsize!(max_queue_size_per_key, "aptos_channel cannot be of size 0");
    // ... rest of function
}
```

**Add configuration sanitizer:**

```rust
// In config/src/config/consensus_config.rs
impl ConfigSanitizer for ConsensusConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        
        // Validate channel sizes
        const MAX_CHANNEL_SIZE: usize = 100_000;
        if node_config.consensus.max_network_channel_size > MAX_CHANNEL_SIZE {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "max_network_channel_size ({}) exceeds maximum ({})",
                    node_config.consensus.max_network_channel_size,
                    MAX_CHANNEL_SIZE
                ),
            ));
        }
        if node_config.consensus.internal_per_key_channel_size > MAX_CHANNEL_SIZE {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "internal_per_key_channel_size ({}) exceeds maximum ({})",
                    node_config.consensus.internal_per_key_channel_size,
                    MAX_CHANNEL_SIZE
                ),
            ));
        }
        
        // ... existing validation
    }
}
```

## Proof of Concept

```rust
// File: crates/channel/tests/memory_exhaustion_test.rs
use aptos_channel::{aptos_channel, message_queues::QueueStyle};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

#[test]
#[should_panic(expected = "memory allocation")]
fn test_memory_exhaustion_with_huge_queue_size() {
    // This test demonstrates that setting max_queue_size to a large value
    // allows memory exhaustion before the queue limit provides protection
    
    // Use a very large queue size (not usize::MAX to make test faster)
    const HUGE_QUEUE_SIZE: usize = 10_000_000; // 10 million
    
    let (sender, _receiver) = aptos_channel::new::<String, Vec<u8>>(
        QueueStyle::FIFO,
        HUGE_QUEUE_SIZE,
        None,
    );
    
    // Simulate attacker sending large messages with a single key
    let sender_clone = sender.clone();
    let attack_thread = thread::spawn(move || {
        let key = "attacker_key".to_string();
        let large_message = vec![0u8; 1024 * 1024]; // 1 MB message
        
        // Try to push messages until OOM
        // The per-key bound is 10 million, but we'll run out of memory
        // long before reaching that limit (after ~8-16 GB depending on system)
        for i in 0..HUGE_QUEUE_SIZE {
            if let Err(_) = sender_clone.push(key.clone(), large_message.clone()) {
                println!("Failed to push message {} - channel closed", i);
                break;
            }
            
            if i % 1000 == 0 {
                println!("Pushed {} messages, approx {} GB consumed", 
                    i, i / 1024);
            }
        }
    });
    
    // Wait for OOM or completion
    let _ = attack_thread.join();
    
    // If we reach here without OOM, the test fails
    // In practice, this will OOM on most systems after 8-16K messages (8-16 GB)
}

#[test]
fn test_safe_queue_size_configuration() {
    // This test shows that reasonable queue sizes work correctly
    const SAFE_QUEUE_SIZE: usize = 1024;
    
    let (sender, mut receiver) = aptos_channel::new::<String, String>(
        QueueStyle::FIFO,
        SAFE_QUEUE_SIZE,
        None,
    );
    
    let key = "test_key".to_string();
    
    // Fill the queue to capacity
    for i in 0..SAFE_QUEUE_SIZE {
        sender.push(key.clone(), format!("message_{}", i)).unwrap();
    }
    
    // Next message should be dropped (FIFO style drops newest)
    let dropped = sender.push(key.clone(), "this_will_be_dropped".to_string());
    assert!(dropped.is_ok()); // Push succeeds but message is dropped
    
    // Verify queue has exactly SAFE_QUEUE_SIZE messages
    let mut count = 0;
    while let Some(_) = futures::executor::block_on(
        futures::StreamExt::next(&mut receiver)
    ) {
        count += 1;
        if count >= SAFE_QUEUE_SIZE {
            break;
        }
    }
    assert_eq!(count, SAFE_QUEUE_SIZE);
}
```

**Notes:**
- This vulnerability requires misconfiguration to be exploitable, but once configured with extreme values, becomes trivially exploitable by external attackers
- The lack of upper bound validation violates defense-in-depth principles
- Production systems should enforce reasonable limits even if operators attempt to configure extreme values
- This issue affects node availability rather than consensus safety or fund security

### Citations

**File:** crates/channel/src/message_queues.rs (L134-147)
```rust
        if key_message_queue.len() >= self.max_queue_size.get() {
            if let Some(c) = self.counters.as_ref() {
                c.with_label_values(&["dropped"]).inc();
            }
            match self.queue_style {
                // Drop the newest message for FIFO
                QueueStyle::FIFO => Some(message),
                // Drop the oldest message for LIFO
                QueueStyle::LIFO | QueueStyle::KLAST => {
                    let oldest = key_message_queue.pop_front();
                    key_message_queue.push_back(message);
                    oldest
                },
            }
```

**File:** crates/channel/src/aptos_channel.rs (L235-241)
```rust
pub fn new<K: Eq + Hash + Clone, M>(
    queue_style: QueueStyle,
    max_queue_size_per_key: usize,
    counters: Option<&'static IntCounterVec>,
) -> (Sender<K, M>, Receiver<K, M>) {
    let max_queue_size_per_key =
        NonZeroUsize!(max_queue_size_per_key, "aptos_channel cannot be of size 0");
```

**File:** config/src/config/consensus_config.rs (L220-223)
```rust
impl Default for ConsensusConfig {
    fn default() -> ConsensusConfig {
        ConsensusConfig {
            max_network_channel_size: 1024,
```
