# Audit Report

## Title
Critical Batch Content Tampering via Unverified RPC Batch Responses

## Summary
The Aptos QuorumStore batch request/response mechanism fails to verify batch contents when receiving batches via RPC. Byzantine validators can respond to batch requests with arbitrary transaction data, causing different validators to execute different transactions for the same batch digest, leading to consensus safety violations and potential chain splits.

## Finding Description

When batches are received through `BatchMsg` broadcasts in `NetworkListener`, they undergo proper verification. [1](#0-0) 

However, the QuorumStore also supports an RPC-based batch retrieval mechanism where validators can request missing batches by digest. When batch responses are received via this RPC path, **no verification is performed**. [2](#0-1) 

The code immediately converts the batch to transactions and returns them without verifying that:
1. The batch's digest matches the requested digest
2. The payload hash matches the batch_info digest
3. The batch metadata is consistent

The codebase provides a `verify_with_digest()` method specifically for this purpose, which checks both conditions: [3](#0-2) 

But this method is **never called** in the RPC response path.

**Attack Scenario:**

1. Honest validator V1 creates a legitimate batch with transactions [T1, T2, T3] and digest D = hash([T1, T2, T3])
2. V1 broadcasts the batch, collects signatures from other validators
3. V1 creates a ProofOfStore{digest: D} and includes it in a block proposal
4. Byzantine validator V2 receives the block but doesn't have the batch payload for digest D in local storage
5. V2 sends `BatchRequest{digest: D}` to fetch the missing batch
6. Byzantine accomplice V3 (or any compromised validator) responds with `BatchResponse::Batch` containing:
   - batch_info claiming digest: D
   - payload: [T1', T2', T3'] where hash([T1', T2', T3']) â‰  D (malicious transactions)
7. V2 accepts this batch without verification and uses the malicious transactions [T1', T2', T3']
8. V2 executes different transactions than other validators who have the legitimate batch
9. **Result: Consensus safety violation** - different validators execute different transactions for the same batch digest, producing different state roots

This breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

The RPC server side simply retrieves batches from local storage and sends them without any additional safeguards: [4](#0-3) 

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Consensus Safety Violation**: Different validators execute different transactions for the same batch digest, producing divergent state roots. This directly violates Byzantine Fault Tolerance guarantees and can cause chain splits.

2. **State Divergence**: Validators with tampered batches will commit different state than honest validators, leading to permanent blockchain forks that require manual intervention or hard forks to resolve.

3. **Double-Spending**: Malicious transactions in tampered batches could enable double-spending if the Byzantine validator can influence which fork is considered canonical.

4. **Non-Recoverable Network Partition**: Once validators have committed different states, the network cannot automatically recover without a hard fork.

This meets the **Critical Severity** criteria per the Aptos bug bounty program:
- Consensus/Safety violations
- Non-recoverable network partition (requires hardfork)
- Loss of Funds (via double-spending in tampered batches)

## Likelihood Explanation

**High Likelihood** - This vulnerability is easily exploitable:

1. **Low Attacker Requirements**: Requires only a single Byzantine validator (or compromised node) to respond to batch requests. No validator collusion needed beyond the responding node.

2. **Natural Trigger**: The RPC batch request mechanism is used regularly during normal operation when validators miss batches or need to catch up.

3. **No Detection**: The missing verification means the attack is silent - validators accept tampered batches without any error or warning.

4. **Deterministic Exploitation**: The attack path is straightforward with no race conditions or timing dependencies.

The only requirement is that a validator requests a batch from a Byzantine node, which happens naturally in a network with any Byzantine participants.

## Recommendation

Add proper verification when receiving batch responses via RPC. The fix should be applied in `batch_requester.rs`:

```rust
Ok(BatchResponse::Batch(batch)) => {
    counters::RECEIVED_BATCH_RESPONSE_COUNT.inc();
    
    // CRITICAL FIX: Verify batch before using it
    if let Err(e) = batch.verify_with_digest(digest) {
        counters::RECEIVED_BATCH_RESPONSE_VERIFICATION_FAILED.inc();
        debug!("QS: batch response verification failed, digest:{}, error:{:?}", digest, e);
        continue; // Try next peer
    }
    
    let payload = batch.into_transactions();
    return Ok(payload);
}
```

The `verify_with_digest()` method already exists and performs all necessary checks:
- Ensures response digest matches request digest
- Ensures payload hash matches batch_info digest  
- Validates all batch metadata consistency

This should be applied wherever `BatchResponse::Batch` is processed from untrusted sources.

## Proof of Concept

```rust
#[tokio::test]
async fn test_batch_tampering_via_rpc_response() {
    use aptos_types::transaction::SignedTransaction;
    use aptos_crypto::HashValue;
    
    // Setup: Create legitimate batch
    let legitimate_txns = vec![/* create legitimate transactions */];
    let legitimate_batch = Batch::new(
        batch_id,
        legitimate_txns.clone(),
        epoch,
        expiration,
        author,
        gas_bucket_start,
    );
    let legitimate_digest = legitimate_batch.digest();
    
    // Attack: Create malicious batch with same digest claim but different transactions
    let malicious_txns = vec![/* create malicious transactions */];
    let malicious_payload = BatchPayload::new(author, malicious_txns);
    
    // Malicious batch claims the legitimate digest but contains different transactions
    let malicious_batch_info = BatchInfo::new(
        author,
        batch_id,
        epoch,
        expiration,
        *legitimate_digest, // Claim legitimate digest
        malicious_payload.num_txns() as u64,
        malicious_payload.num_bytes() as u64,
        gas_bucket_start,
    );
    
    let malicious_batch = Batch::new_generic(malicious_batch_info, malicious_payload);
    
    // Verify: This batch should fail verification
    assert!(malicious_batch.verify_with_digest(*legitimate_digest).is_err());
    
    // Current vulnerable code path in batch_requester.rs lines 136-139
    // would accept this batch without verification:
    let response = BatchResponse::Batch(malicious_batch);
    
    // The bug: into_transactions() is called without verify_with_digest()
    match response {
        BatchResponse::Batch(batch) => {
            // VULNERABLE: No verification here!
            let payload = batch.into_transactions();
            // payload now contains malicious transactions instead of legitimate ones
            assert_ne!(payload, legitimate_txns); // Different transactions!
        }
        _ => panic!("Expected Batch response"),
    }
}
```

## Notes

This vulnerability specifically affects the RPC batch retrieval path, not the broadcast path. The broadcast path properly verifies batches before accepting them. The asymmetry in verification between these two paths creates the security hole. All batch sources should undergo equivalent cryptographic verification regardless of delivery mechanism.

### Citations

**File:** consensus/src/round_manager.rs (L166-173)
```rust
            UnverifiedEvent::BatchMsg(b) => {
                if !self_message {
                    b.verify(peer_id, max_num_batches, validator)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["batch"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::BatchMsg(Box::new((*b).into()))
```

**File:** consensus/src/quorum_store/batch_requester.rs (L136-139)
```rust
                            Ok(BatchResponse::Batch(batch)) => {
                                counters::RECEIVED_BATCH_RESPONSE_COUNT.inc();
                                let payload = batch.into_transactions();
                                return Ok(payload);
```

**File:** consensus/src/quorum_store/types.rs (L292-300)
```rust
    /// Verify the batch, and that it matches the requested digest
    pub fn verify_with_digest(&self, requested_digest: HashValue) -> anyhow::Result<()> {
        ensure!(
            requested_digest == *self.digest(),
            "Response digest doesn't match the request"
        );
        self.verify()?;
        Ok(())
    }
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L408-425)
```rust
                let response = if let Ok(value) =
                    batch_store.get_batch_from_local(&rpc_request.req.digest())
                {
                    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
                    let batch: Batch<BatchInfo> = batch
                        .try_into()
                        .expect("Batch retieval requests must be for V1 batch");
                    BatchResponse::Batch(batch)
                } else {
                    match aptos_db_clone.get_latest_ledger_info() {
                        Ok(ledger_info) => BatchResponse::NotFound(ledger_info),
                        Err(e) => {
                            let e = anyhow::Error::from(e);
                            error!(epoch = epoch, error = ?e, kind = error_kind(&e));
                            continue;
                        },
                    }
                };
```
