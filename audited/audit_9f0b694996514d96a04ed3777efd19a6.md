# Audit Report

## Title
Consensus Observer Peer Selection Bypass via Distance Metadata Manipulation

## Summary
Malicious peers can falsely report their `distance_from_validators` in peer monitoring metadata to gain unauthorized priority for consensus observer subscriptions. The vulnerability arises because the distance value is self-reported via RPC and validation only checks role consistency, not cryptographic proof of actual distance. Any peer connecting on the VFN network is automatically assigned the `ValidatorFullNode` role, allowing them to claim `distance_from_validators = 1` and appear optimal for subscription selection.

## Finding Description

The consensus observer system selects peers for subscriptions based on "optimality," with `distance_from_validators` as the primary criterion (lower distance = higher priority). [1](#0-0) 

This distance value comes from peer-reported metadata via the peer monitoring service: [2](#0-1) 

The distance is computed by each peer's monitoring service by taking the minimum distance from connected peers and adding 1: [3](#0-2) 

**The Critical Flaw:** The system trusts peer-reported distance values with only role-based validation: [4](#0-3) 

For `distance = 1`, validation only requires the peer to be a VFN on the correct network. However, the `PeerRole` assignment on VFN networks is permissive: [5](#0-4) 

**Attack Steps:**
1. Malicious node connects to a validator on the VFN network
2. Validator automatically infers role as `ValidatorFullNode` (not in trusted peers, but on VFN network)
3. Malicious node responds to `GetNetworkInformation` requests with fabricated `distance_from_validators = 1`
4. Validation passes: `peer_is_vfn = true` && `peer_has_correct_network = true`
5. Consensus observers rank this peer as highly optimal (distance = 1)
6. Observers preferentially subscribe to the malicious peer
7. Malicious peer gains privileged relay position in consensus observer network

The vulnerability breaks the **peer selection optimality invariant** - the system assumes distance accurately reflects proximity to validators, but malicious peers can falsely claim low distances without cryptographic proof.

## Impact Explanation

**High Severity** - Significant Protocol Violation

This vulnerability enables multiple attack vectors:

1. **Eclipse Attacks on Consensus Observers**: By appearing optimal, malicious peers can become the primary subscription target for multiple observers, allowing them to:
   - Censor consensus blocks
   - Delay critical consensus updates
   - Feed incorrect consensus data to observers
   
2. **Relay Privilege Abuse**: Malicious peers gain trusted relay positions without authorization, undermining the security model of the consensus observer network

3. **Network-Wide Impact**: If multiple malicious peers exploit this, they can collectively dominate the consensus observer subscription landscape, affecting many non-validator nodes simultaneously

This meets the High Severity criteria per the Aptos bug bounty: "Significant protocol violations" and potential for "Validator node slowdowns" (observers may fail to sync properly, impacting overall network health).

## Likelihood Explanation

**High Likelihood**

The attack is highly feasible because:

1. **Low Barrier to Entry**: Any node can connect to validators on the VFN network
2. **Simple Exploitation**: Only requires modifying a single field in RPC responses
3. **No Detection Mechanism**: The validation logic accepts the false distance as legitimate
4. **Immediate Impact**: Observers will immediately begin preferring the malicious peer in their selection algorithm
5. **No Rate Limiting**: An attacker can operate multiple malicious nodes simultaneously

The attack requires:
- Running a network peer (standard node operation)
- Modifying peer monitoring service responses (simple code change)
- No validator access or cryptographic material needed

## Recommendation

Implement cryptographic attestation for distance claims:

**Option 1: Validator Signatures on Distance Claims**
- Validators sign statements about peers at distance 1
- VFNs include these signatures when reporting distance
- Observers verify signatures before accepting distance values

**Option 2: Multi-Peer Verification**
- Cross-validate distance claims against multiple peers
- Reject outliers or inconsistent reports
- Implement reputation scoring based on historical accuracy

**Option 3: Restrict VFN Network Role Inference**
- Require cryptographic proof (e.g., certificate signed by validator) for VFN role
- Mark peers without proof as `Unknown` rather than `ValidatorFullNode`
- Update validation to reject low distances from `Unknown` peers

**Immediate Mitigation (Option 3 implementation):** [6](#0-5) 

Change the permissive role inference to require additional authentication:

```rust
// Instead of automatically assigning ValidatorFullNode,
// require cryptographic proof or mark as Unknown
if network_id.is_vfn_network() {
    // Peer must provide proof they are a legitimate VFN
    // Without proof, mark as Unknown
    Ok(PeerRole::Unknown)
}
```

Update distance validation to reject low distances from Unknown peers:

```rust
1 => {
    // Verify the peer is a VFN with PROOF, not just network inference
    let peer_is_authenticated_vfn = peer_metadata
        .get_connection_metadata()
        .role == PeerRole::ValidatorFullNode
        && peer_has_vfn_authentication_proof();
    peer_is_authenticated_vfn && peer_has_correct_network
}
```

## Proof of Concept

**Attack Setup:**

1. Deploy a modified Aptos node that reports false distance:

```rust
// In peer-monitoring-service/server/src/lib.rs
fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
    // ... existing code ...
    
    // MALICIOUS: Always report distance = 1 instead of calculating
    let distance_from_validators = 1; // Instead of calling get_distance_from_validators()
    
    let network_information_response = NetworkInformationResponse {
        connected_peers,
        distance_from_validators, // Malicious low value
    };
    Ok(PeerMonitoringServiceResponse::NetworkInformation(
        network_information_response,
    ))
}
```

2. Connect this node to a validator on the VFN network
3. Monitor consensus observer subscription requests

**Expected Outcome:**
- Malicious node receives role `ValidatorFullNode`
- Distance validation passes (role matches distance claim)
- Consensus observers include this peer in their optimal peer list
- Observers subscribe to malicious node for consensus updates

**Verification:**
Check metrics showing subscription distribution:
- `OBSERVER_NUM_ACTIVE_SUBSCRIPTIONS` will include the malicious peer
- Observers will show low-distance peers in their sorted subscription lists
- The malicious peer gains relay privileges despite being arbitrarily far from actual validators

## Notes

This vulnerability is particularly concerning because:

1. The consensus observer feature is designed for high-availability and security
2. The attack undermines the trust model without requiring validator compromise  
3. Multiple malicious nodes can coordinate to dominate the observer network
4. Detection is difficult as the behavior appears legitimate to the validation logic

The root cause is the mismatch between **permissive role inference** and **strict distance validation** - the system assumes VFN role implies legitimate proximity, but role assignment on VFN networks is purely based on network topology, not cryptographic authentication.

### Citations

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L196-217)
```rust
fn get_distance_for_peer(
    peer_network_id: &PeerNetworkId,
    peer_metadata: &PeerMetadata,
) -> Option<u64> {
    // Get the distance for the peer
    let peer_monitoring_metadata = peer_metadata.get_peer_monitoring_metadata();
    let distance = peer_monitoring_metadata
        .latest_network_info_response
        .as_ref()
        .map(|response| response.distance_from_validators);

    // If the distance is missing, log a warning
    if distance.is_none() {
        warn!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Unable to get distance for peer! Peer: {:?}",
                peer_network_id
            ))
        );
    }

    distance
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L283-312)
```rust
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L298-340)
```rust
fn get_distance_from_validators(
    base_config: &BaseConfig,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> u64 {
    // Get the connected peers and metadata
    let connected_peers_and_metadata = match peers_and_metadata.get_connected_peers_and_metadata() {
        Ok(connected_peers_and_metadata) => connected_peers_and_metadata,
        Err(error) => {
            warn!(LogSchema::new(LogEntry::PeerMonitoringServiceError).error(&error.into()));
            return MAX_DISTANCE_FROM_VALIDATORS;
        },
    };

    // If we're a validator and we have active validator peers, we're in the validator set.
    // TODO: figure out if we need to deal with validator set forks here.
    if base_config.role.is_validator() {
        for peer_metadata in connected_peers_and_metadata.values() {
            if peer_metadata.get_connection_metadata().role.is_validator() {
                return 0;
            }
        }
    }

    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
}
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L118-154)
```rust
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```

**File:** network/framework/src/noise/handshake.rs (L406-416)
```rust
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
```
