# Audit Report

## Title
Missing Block Signature Validation in Sync Block Retrieval Allows Malicious Peers to Inject Invalid Blocks

## Summary
Blocks retrieved from peers during sync operations in `retrieve_blocks()` are not signature-validated before being accepted and inserted into the block store, creating a critical asymmetry with the normal proposal flow where signatures are strictly validated.

## Finding Description

The `retrieve_blocks()` function in the sync manager retrieves blocks from network peers to fill gaps during consensus synchronization. However, unlike the normal proposal flow, these retrieved blocks bypass signature validation entirely.

**Normal Proposal Flow (with validation):**
When blocks arrive via `ProposalMsg` during normal consensus, they undergo strict validation: [1](#0-0) 

This validation includes calling `Block::validate_signature()`: [2](#0-1) 

**Sync Retrieval Flow (missing validation):**
When blocks are retrieved during sync operations, the `retrieve_blocks()` function accepts blocks from peers without any signature validation: [3](#0-2) 

The only validation performed is structural (checking block IDs match): [4](#0-3) 

**Critical Evidence - Unused Verification Method:**
A `BlockRetrievalResponse::verify()` method exists that performs proper signature validation on retrieved blocks: [5](#0-4) 

However, this method is **never called** in the sync_manager retrieval flow. The blocks are directly cloned and used without invoking this validation.

**Attack Vector:**
1. Honest node A falls behind and needs to sync blocks
2. Node A sends block retrieval requests to peers via `fetch_quorum_cert()` or `fast_forward_sync()`
3. Malicious peer B responds with blocks containing:
   - Valid `block_data` matching the expected block ID hash
   - Invalid or forged BLS signatures in the `signature` field
4. Node A accepts these blocks without validation
5. Unvalidated blocks are inserted into the block store: [6](#0-5) 

6. These blocks may be persisted to storage: [7](#0-6) 

**Broken Invariant:**
This violates the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure." Blocks with invalid signatures should never enter the consensus system, yet they can bypass validation through the sync path.

## Impact Explanation

**Severity: High (potentially Critical)**

This vulnerability enables several attack scenarios:

1. **Consensus Safety Violation**: Malicious peers can inject blocks with invalid signatures into victim nodes' block stores. If these blocks participate in consensus decisions, different nodes may diverge on block validity, potentially causing safety violations.

2. **State Corruption**: Invalid blocks stored in the database can corrupt the node's view of the blockchain. When the node attempts to rebuild its state or perform recovery, invalid signatures may cause failures or inconsistent state.

3. **Liveness Attack**: If a victim node accepts and processes blocks with invalid signatures, other honest nodes will reject messages or proposals from the victim when it references these invalid blocks, causing the victim to be isolated from consensus.

4. **Chain of Trust Violation**: The signature validates that a block was legitimately proposed by its claimed author. Without this validation, an attacker can attribute arbitrary blocks to honest validators, undermining accountability and audit trails.

This qualifies as **High Severity** under Aptos bug bounty criteria as it enables "significant protocol violations" and could escalate to **Critical** if exploitation can cause consensus safety breaks or network partitions.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability is exploitable whenever:
- A node falls behind and initiates sync operations (common in network partitions, node restarts, or slow nodes)
- The node connects to at least one malicious peer who can respond to block retrieval requests
- No authentication or reputation system prevents malicious peers from participating

The attack requires:
- **Attacker capability**: Ability to run a network peer node and respond to RPC requests (low barrier)
- **Target condition**: Victim node performing sync operations (frequent occurrence)
- **No special privileges required**: Any peer can attempt this attack

The fact that the verification method exists but is unused suggests this is an unintentional security gap rather than a design decision, making it a clear implementation vulnerability.

## Recommendation

**Immediate Fix**: Call `BlockRetrievalResponse::verify()` on all block retrieval responses before accepting the blocks.

In `retrieve_block_chunk()`, add signature verification after receiving the response: [8](#0-7) 

Add after line 728:
```rust
match response {
    Ok(result) => {
        // ADDED: Verify block signatures before accepting
        result.verify(request.clone(), validator_verifier)?;
        return Ok(result)
    },
    // ... rest of error handling
}
```

This requires passing the `ValidatorVerifier` to the `BlockRetriever` struct and making it available in the retrieval methods.

**Complete Fix Requirements:**
1. Add `validator_verifier: &ValidatorVerifier` parameter to `BlockRetriever` constructor
2. Store validator verifier in the struct
3. Call `response.verify(request, self.validator_verifier)` before accepting any blocks
4. Add the same verification in all block retrieval code paths

This aligns the sync path with the normal proposal path, ensuring consistent security validation across all block ingestion mechanisms.

## Proof of Concept

```rust
// Test demonstrating missing signature validation in block retrieval
#[tokio::test]
async fn test_sync_accepts_invalid_signature_blocks() {
    // Setup: Create a valid block with correct block_data and hash
    let mut valid_block = create_test_block(...);
    let valid_block_id = valid_block.id();
    
    // Attack: Replace signature with invalid/forged signature
    let forged_signature = create_invalid_bls_signature();
    let malicious_block = Block::new_for_testing(
        valid_block_id,  // Correct hash
        valid_block.block_data().clone(),  // Valid block data
        Some(forged_signature),  // INVALID signature
    );
    
    // Create retrieval response with malicious block
    let response = BlockRetrievalResponse::new(
        BlockRetrievalStatus::SucceededWithTarget,
        vec![malicious_block],
    );
    
    // VULNERABILITY: retrieve_blocks() accepts this without validation
    // In production code, this malicious block would be accepted and inserted
    // into the block store without signature verification
    
    // Verification: Try to validate the response manually
    let validator_verifier = create_test_validator_verifier();
    let request = BlockRetrievalRequest::V1(...);
    
    // This SHOULD be called but ISN'T in the actual code:
    let validation_result = response.verify(request, &validator_verifier);
    
    // Assert that verification would catch the invalid signature
    assert!(validation_result.is_err());
    assert!(validation_result.unwrap_err().to_string().contains("signature"));
    
    // In production, the block would have been accepted by retrieve_blocks()
    // before this verification could occur, demonstrating the vulnerability
}
```

**Notes**

This vulnerability represents a critical security gap where the sync path lacks the same cryptographic validation as the normal consensus path. The existence of `BlockRetrievalResponse::verify()` indicates the developers intended this validation to occur, but it was never integrated into the actual retrieval flow. This is particularly concerning given that the DAG consensus implementation does use this verification method correctly, suggesting the regular consensus sync path was overlooked during implementation.

### Citations

**File:** consensus/consensus-types/src/proposal_msg.rs (L97-110)
```rust
        let (payload_result, sig_result) = rayon::join(
            || {
                self.proposal().payload().map_or(Ok(()), |p| {
                    p.verify(validator, proof_cache, quorum_store_enabled)
                })
            },
            || {
                self.proposal()
                    .validate_signature(validator)
                    .map_err(|e| format_err!("{:?}", e))
            },
        );
        payload_result?;
        sig_result?;
```

**File:** consensus/consensus-types/src/block.rs (L425-464)
```rust
    pub fn validate_signature(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        match self.block_data.block_type() {
            BlockType::Genesis => bail!("We should not accept genesis from others"),
            BlockType::NilBlock { .. } => self.quorum_cert().verify(validator),
            BlockType::Proposal { author, .. } => {
                let signature = self
                    .signature
                    .as_ref()
                    .ok_or_else(|| format_err!("Missing signature in Proposal"))?;
                let (res1, res2) = rayon::join(
                    || validator.verify(*author, &self.block_data, signature),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
            BlockType::ProposalExt(proposal_ext) => {
                let signature = self
                    .signature
                    .as_ref()
                    .ok_or_else(|| format_err!("Missing signature in Proposal"))?;
                let (res1, res2) = rayon::join(
                    || validator.verify(*proposal_ext.author(), &self.block_data, signature),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
            BlockType::OptimisticProposal(p) => {
                // Note: Optimistic proposal is not signed by proposer unlike normal proposal
                let (res1, res2) = rayon::join(
                    || p.grandparent_qc().verify(validator),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
            BlockType::DAGBlock { .. } => bail!("We should not accept DAG block from others"),
        }
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L264-267)
```rust
        while let Some(block) = pending.pop() {
            let block_qc = block.quorum_cert().clone();
            self.insert_single_quorum_cert(block_qc)?;
            self.insert_block(block).await?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L503-503)
```rust
        storage.save_tree(blocks.clone(), quorum_certs.clone())?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L726-738)
```rust
                    Some((peer, response)) = futures.next() => {
                        match response {
                            Ok(result) => return Ok(result),
                            e => {
                                warn!(
                                    remote_peer = peer,
                                    block_id = block_id,
                                    "{:?}, Failed to fetch block",
                                    e,
                                );
                                failed_attempt += 1;
                            },
                        }
```

**File:** consensus/src/block_storage/sync_manager.rs (L836-850)
```rust
            match response {
                Ok(result) if matches!(result.status(), BlockRetrievalStatus::Succeeded) => {
                    // extend the result blocks
                    let batch = result.blocks().clone();
                    progress += batch.len() as u64;
                    last_block_id = batch.last().expect("Batch should not be empty").parent_id();
                    result_blocks.extend(batch);
                },
                Ok(result)
                    if matches!(result.status(), BlockRetrievalStatus::SucceededWithTarget) =>
                {
                    // if we found the target, end the loop
                    let batch = result.blocks().clone();
                    result_blocks.extend(batch);
                    break;
```

**File:** consensus/src/block_storage/sync_manager.rs (L863-895)
```rust
        // Confirm retrieval hit the first block we care about
        assert_eq!(
            result_blocks.first().expect("blocks are empty").id(),
            block_id,
            "Expecting in the retrieval response, first block should be {}, but got {}",
            block_id,
            result_blocks.first().expect("blocks are empty").id(),
        );

        // Confirm retrieval hit the last block/round we care about
        // Slightly different logic if using execution pool and not
        match target_block_retrieval_payload {
            TargetBlockRetrieval::TargetBlockId(target_block_id) => {
                ensure!(
                    result_blocks
                        .last()
                        .expect("Expected at least a result_block")
                        .id()
                        == target_block_id
                );
            },
            TargetBlockRetrieval::TargetRound(target_round) => {
                let last_block = result_blocks.last().expect("blocks are empty");
                ensure!(
                    last_block.round() == target_round || last_block.quorum_cert().certified_block().round() < target_round,
                    "Expecting in the retrieval response, last block should be == {} or its parent should be < {}, but got {} and parent {}",
                    target_round,
                    target_round,
                    last_block.round(),
                    last_block.quorum_cert().certified_block().round(),
                );
            },
        }
```

**File:** consensus/consensus-types/src/block_retrieval.rs (L260-281)
```rust
    pub fn verify(
        &self,
        retrieval_request: BlockRetrievalRequest,
        sig_verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        self.verify_inner(&retrieval_request)?;

        self.blocks
            .iter()
            .try_fold(retrieval_request.block_id(), |expected_id, block| {
                block.validate_signature(sig_verifier)?;
                block.verify_well_formed()?;
                ensure!(
                    block.id() == expected_id,
                    "blocks doesn't form a chain: expect {}, get {}",
                    expected_id,
                    block.id()
                );
                Ok(block.parent_id())
            })
            .map(|_| ())
    }
```
