# Audit Report

## Title
Critical Division by Zero in Rotating Proposer Election Causes Network-Wide Validator Crash

## Summary
The `get_valid_proposer()` function in `RotatingProposer` performs division by `contiguous_rounds` without validating it is non-zero. If a governance proposal sets `contiguous_rounds=0` in the on-chain consensus config, all validators will panic when attempting to determine the next proposer, causing total network liveness failure.

## Finding Description

The vulnerability exists in the proposer election mechanism that determines which validator should propose blocks for each consensus round. [1](#0-0) 

The calculation divides `round` by `contiguous_rounds` without any validation that `contiguous_rounds` is non-zero. This value comes from on-chain governance configuration: [2](#0-1) 

The on-chain consensus config is updated through Move governance: [3](#0-2) 

The Move-level validation only checks that config bytes are non-empty, but does NOT validate the actual field values within the deserialized config: [4](#0-3) 

There is no validation in the Rust deserialization or construction of `RotatingProposer`: [5](#0-4) 

**Attack Path:**
1. Governance proposal sets `OnChainConsensusConfig` with `ProposerElectionType::RotatingProposer(0)` or `FixedProposer(0)`
2. Config passes Move validation (only checks bytes are non-empty)
3. Config is deserialized and applied at next epoch boundary
4. All validators create `RotatingProposer` with `contiguous_rounds=0`
5. When any validator calls `get_valid_proposer()` for proposer election, division by zero causes immediate panic
6. All validators crash simultaneously, causing total network halt
7. Network requires emergency hardfork or coordinated validator restart with fixed config

This breaks the **Consensus Liveness** invariant - validators must be able to determine the next proposer without crashing.

## Impact Explanation

**Severity: Critical** - This vulnerability causes **"Total loss of liveness/network availability"** as defined in the Aptos Bug Bounty program.

When triggered, ALL validators running the malformed config will crash simultaneously when attempting to compute the next proposer. This results in:
- Complete network halt (no blocks can be proposed or committed)
- Non-recoverable without emergency intervention (hardfork or coordinated restart)
- Affects 100% of validators in the network
- No automatic recovery mechanism exists

This meets the Critical severity threshold of "Total loss of liveness/network availability" worth up to $1,000,000 in the bug bounty program.

## Likelihood Explanation

**Likelihood: Medium**

While this requires a governance proposal to trigger, the likelihood is non-negligible because:

1. **Accidental Trigger**: A developer error when preparing a governance proposal could accidentally set `contiguous_rounds=0`
2. **Malicious Governance**: An attacker with sufficient voting power could intentionally propose this
3. **No Validation Barriers**: Neither the Move layer nor Rust layer validates this field
4. **Default is Safe**: The default value is 10, but governance can override

The lack of validation at ANY layer means a single mistake or malicious action can trigger network-wide failure. The complexity is LOW (requires only governance access), but the frequency is reduced by governance gatekeeping.

## Recommendation

Add validation at multiple layers:

**1. Rust-level validation in RotatingProposer::new():**

```rust
pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
    assert!(
        contiguous_rounds > 0,
        "contiguous_rounds must be greater than 0"
    );
    assert!(
        !proposers.is_empty(),
        "proposers list cannot be empty"
    );
    Self {
        proposers,
        contiguous_rounds,
    }
}
```

**2. Move-level validation in consensus_config.move:**

Add a native function to validate the deserialized config structure and call it in `set_for_next_epoch()`:

```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    assert!(validate_consensus_config_internal(config), error::invalid_argument(EINVALID_CONFIG));
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}

native fun validate_consensus_config_internal(config_bytes: vector<u8>): bool;
```

**3. Config deserialization validation:**

Add a `validate()` method to `OnChainConsensusConfig` that checks all field constraints and call it after deserialization.

## Proof of Concept

Add this test to `consensus/src/liveness/rotating_proposer_test.rs`:

```rust
#[test]
#[should_panic(expected = "attempt to divide by zero")]
fn test_division_by_zero_with_zero_contiguous_rounds() {
    use aptos_types::account_address::AccountAddress;
    
    let chosen_author = AccountAddress::random();
    let another_author = AccountAddress::random();
    let proposers = vec![chosen_author, another_author];
    
    // Create RotatingProposer with contiguous_rounds = 0
    // This simulates what would happen if governance sets this value
    let pe = RotatingProposer::new(proposers, 0);
    
    // This will panic with division by zero
    pe.get_valid_proposer(1);
}
```

Run with: `cargo test test_division_by_zero_with_zero_contiguous_rounds --package aptos-consensus`

This test demonstrates that calling `get_valid_proposer()` with `contiguous_rounds=0` causes an immediate panic, which would crash all validators network-wide if triggered through governance.

## Notes

While the security question asked about "incorrect failure attribution," the investigation revealed a more critical vulnerability: the proposer election mechanism can crash validators entirely before any failure attribution occurs. The division-by-zero issue prevents the system from even computing which proposers failed, as all validators crash when attempting to determine the valid proposer for any round.

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L27-32)
```rust
    pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
        Self {
            proposers,
            contiguous_rounds,
        }
    }
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** consensus/src/epoch_manager.rs (L296-299)
```rust
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
            },
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L23-27)
```text
    public(friend) fun initialize(aptos_framework: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        move_to(aptos_framework, ConsensusConfig { config });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```
