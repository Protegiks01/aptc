# Audit Report

## Title
Critical Node Liveness Failure: Indexer Metadata Version Desynchronization Causes Unrecoverable Startup Panic

## Summary
The DBIndexer's `process_a_batch()` function unconditionally updates `LatestVersion` while only conditionally updating feature-specific versions (`TransactionVersion`, `EventVersion`, `StateVersion`) based on feature flags. This creates a permanent desynchronization that causes validator nodes to panic on startup when feature configurations change, resulting in total loss of liveness with no automated recovery path.

## Finding Description

The vulnerability exists in the metadata update logic within `DBIndexer::process_a_batch()`. The function processes transactions in batches and updates version metadata to track indexing progress for different features (transactions, events, state keys). [1](#0-0) 

The critical flaw is that `LatestVersion` is **always** updated (line 542-545), but feature-specific versions are **conditionally** updated based on their respective feature flags (lines 524-540). When a feature is disabled, its version metadata stops advancing while `LatestVersion` continues forward.

The consequence manifests during node startup in the `get_start_version()` function: [2](#0-1) 

This function enforces strict version consistency: it retrieves `LatestVersion` as the baseline `start_version`, then verifies that each enabled feature's version matches. If any mismatch is detected, the node **panics with an unrecoverable error**.

**Attack Scenario:**

1. Node operates normally with all indexer features enabled: `enable_transaction=true`, `enable_event=true`, `enable_statekeys=true`
2. Node processes transactions from version 0 to 1000. All metadata versions reach 1000:
   - `LatestVersion = 1000`
   - `TransactionVersion = 1000`
   - `EventVersion = 1000`
   - `StateVersion = 1000`

3. Node configuration changes (operator disables some features to save storage): `enable_transaction=true`, `enable_event=false`, `enable_statekeys=false`

4. Node processes versions 1001-2000. Now metadata state becomes:
   - `LatestVersion = 2000` (always updated)
   - `TransactionVersion = 2000` (updated because enabled)
   - `EventVersion = 1000` (frozen - feature disabled)
   - `StateVersion = 1000` (frozen - feature disabled)

5. Node restarts with events re-enabled: `enable_event=true`

6. During startup, `get_start_version()` executes:
   - Retrieves `LatestVersion = 2000`, sets `start_version = 2001`
   - Checks `EventVersion = 1000`, calculates `event_start_version = 1001`
   - Comparison: `2001 != 1001`
   - **PANIC: "Cannot start event indexer because the progress doesn't match."**

7. Node is now **permanently unable to start**. Manual database intervention is required.

This breaks the **State Consistency** invariant and causes **Total Loss of Liveness** for the affected validator node.

## Impact Explanation

This is a **Critical Severity** vulnerability under the Aptos Bug Bounty program's classification of "Total loss of liveness/network availability."

**Impact Quantification:**
- **Single Validator Impact**: Complete inability to restart or recover the node without manual database manipulation
- **Network Impact**: If multiple validators encounter this issue during coordinated configuration changes, it could reduce network participation below safety thresholds
- **No Automated Recovery**: The panic occurs before any indexer processing begins, creating a deadlock state
- **Operational Risk**: Common operational practices (enabling/disabling indexer features to manage storage) directly trigger this bug

The vulnerability does not require any malicious actor - it occurs through legitimate operational changes. The lack of any graceful degradation or recovery mechanism elevates this to critical severity.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability has a high probability of occurrence because:

1. **Common Operational Pattern**: Disabling indexer features is a documented way to reduce storage requirements on resource-constrained nodes
2. **No Warning Mechanism**: The system provides no warnings when creating version desynchronization
3. **Silent Corruption**: The metadata inconsistency builds up silently during normal operation
4. **Irreversible Damage**: Once versions desynchronize, the node cannot self-recover
5. **Configuration Changes**: Node operators frequently adjust configurations during maintenance windows

The issue will manifest whenever:
- An operator disables an indexer feature, processes transactions, then re-enables it
- Node configurations differ between restarts
- Migration scenarios where indexer features are gradually rolled out

## Recommendation

Implement strict version consistency enforcement. There are two viable approaches:

**Option 1: Synchronous Version Updates (Recommended)**
Always update all version metadata together, regardless of feature flags. When features are disabled, their versions should still advance to maintain consistency:

```rust
// In process_a_batch(), lines 524-545
let final_version = version - 1;

// Always update all versions to maintain consistency
batch.put::<InternalIndexerMetadataSchema>(
    &MetadataKey::TransactionVersion,
    &MetadataValue::Version(final_version),
)?;
batch.put::<InternalIndexerMetadataSchema>(
    &MetadataKey::EventVersion,
    &MetadataValue::Version(final_version),
)?;
batch.put::<InternalIndexerMetadataSchema>(
    &MetadataKey::StateVersion,
    &MetadataValue::Version(final_version),
)?;
batch.put::<InternalIndexerMetadataSchema>(
    &MetadataKey::LatestVersion,
    &MetadataValue::Version(final_version),
)?;
```

**Option 2: Version Reconciliation on Startup**
Modify `get_start_version()` to automatically reconcile version mismatches by taking the minimum of all enabled feature versions:

```rust
// In get_start_version(), after line 106
let mut start_version = self
    .db_indexer
    .indexer_db
    .get_persisted_version()?
    .map_or(0, |v| v + 1);

// Reconcile with enabled feature versions
if node_config.indexer_db_config.enable_statekeys() {
    let state_version = self.db_indexer.indexer_db.get_state_version()?.map_or(0, |v| v + 1);
    start_version = start_version.min(state_version);
}
// Similar for other features...
```

**Option 1 is strongly recommended** as it maintains proper audit trails and prevents data gaps in the indexer.

## Proof of Concept

```rust
#[test]
fn test_indexer_version_desync_causes_startup_panic() {
    use aptos_config::config::InternalIndexerDBConfig;
    use aptos_db_indexer::db_indexer::{DBIndexer, InternalIndexerDB};
    use aptos_indexer_grpc_table_info::internal_indexer_db_service::InternalIndexerDBService;
    use std::sync::Arc;
    
    // Setup: Create test database with transactions
    let (aptos_db, _core_account) = create_test_db();
    let total_version = aptos_db.expect_synced_version();
    assert_eq!(total_version, 11);
    
    let temp_path = aptos_temppath::TempPath::new();
    let mut node_config = aptos_config::config::NodeConfig::default();
    node_config.storage.dir = temp_path.path().to_path_buf();
    
    // Phase 1: Enable all features, process all transactions
    node_config.indexer_db_config = InternalIndexerDBConfig::new(
        true,  // enable_event
        true,  // enable_transaction
        true,  // enable_statekeys
        0,
        false,
        10_000
    );
    
    let internal_indexer_db = InternalIndexerDBService::get_indexer_db(&node_config).unwrap();
    let db_indexer = DBIndexer::new(internal_indexer_db.clone(), aptos_db.clone());
    
    db_indexer.process_a_batch(0, total_version).unwrap();
    std::thread::sleep(std::time::Duration::from_millis(100));
    
    // Verify all versions are synchronized at version 11
    assert_eq!(internal_indexer_db.get_persisted_version().unwrap(), Some(11));
    assert_eq!(internal_indexer_db.get_event_version().unwrap(), Some(11));
    assert_eq!(internal_indexer_db.get_transaction_version().unwrap(), Some(11));
    assert_eq!(internal_indexer_db.get_state_version().unwrap(), Some(11));
    
    // Phase 2: Disable events, create more transactions (simulated by processing again)
    // In reality, new transactions would be added; here we demonstrate the version update
    drop(db_indexer);
    
    node_config.indexer_db_config = InternalIndexerDBConfig::new(
        false, // enable_event = FALSE
        true,  // enable_transaction
        true,  // enable_statekeys
        0,
        false,
        10_000
    );
    
    let internal_indexer_db2 = InternalIndexerDB::new(
        internal_indexer_db.get_inner_db_clone(),
        node_config.indexer_db_config
    );
    
    // Manually simulate what would happen if we processed more transactions
    // by directly updating LatestVersion while leaving EventVersion behind
    use aptos_db_indexer_schemas::metadata::{MetadataKey, MetadataValue};
    use aptos_db_indexer_schemas::schema::indexer_metadata::InternalIndexerMetadataSchema;
    use aptos_schemadb::SchemaBatch;
    
    let mut batch = SchemaBatch::new();
    batch.put::<InternalIndexerMetadataSchema>(
        &MetadataKey::LatestVersion,
        &MetadataValue::Version(20),
    ).unwrap();
    batch.put::<InternalIndexerMetadataSchema>(
        &MetadataKey::TransactionVersion,
        &MetadataValue::Version(20),
    ).unwrap();
    batch.put::<InternalIndexerMetadataSchema>(
        &MetadataKey::StateVersion,
        &MetadataValue::Version(20),
    ).unwrap();
    // EventVersion stays at 11
    
    internal_indexer_db2.get_inner_db_ref().write_schemas(batch).unwrap();
    
    // Verify desynchronization
    assert_eq!(internal_indexer_db2.get_persisted_version().unwrap(), Some(20));
    assert_eq!(internal_indexer_db2.get_event_version().unwrap(), Some(11)); // LAGGING!
    
    // Phase 3: Re-enable events and attempt to get start version
    node_config.indexer_db_config = InternalIndexerDBConfig::new(
        true,  // enable_event = TRUE again
        true,
        true,
        0,
        false,
        10_000
    );
    
    let internal_indexer_db3 = InternalIndexerDB::new(
        internal_indexer_db2.get_inner_db_clone(),
        node_config.indexer_db_config
    );
    
    let (sender, receiver) = std::sync::mpsc::channel();
    let db_indexer3 = DBIndexer::new(internal_indexer_db3.clone(), aptos_db.clone());
    drop(sender); // Close channel since we won't use it
    
    let service = InternalIndexerDBService::new(
        aptos_db.clone(),
        internal_indexer_db3,
        tokio::sync::watch::channel((std::time::Instant::now(), 20)).1
    );
    
    // This should PANIC with "Cannot start event indexer because the progress doesn't match."
    let result = std::panic::catch_unwind(|| {
        let runtime = tokio::runtime::Runtime::new().unwrap();
        runtime.block_on(async {
            service.get_start_version(&node_config).await
        })
    });
    
    assert!(result.is_err(), "Expected panic due to version mismatch but got Ok");
    
    // Verify the panic message contains the expected error
    if let Err(panic_info) = result {
        let panic_msg = panic_info.downcast_ref::<String>()
            .map(|s| s.as_str())
            .or_else(|| panic_info.downcast_ref::<&str>().copied())
            .unwrap_or("");
        assert!(
            panic_msg.contains("Cannot start event indexer") || 
            panic_msg.contains("progress doesn't match"),
            "Unexpected panic message: {}", panic_msg
        );
    }
}
```

## Notes

This vulnerability represents a fundamental architectural flaw in the indexer's version tracking system. The separation between `LatestVersion` and feature-specific versions creates an implicit assumption that features will remain consistently enabled, which is violated during normal operational changes.

The fix must ensure that version metadata remains consistent across all features to prevent permanent node unavailability. The recommended solution (Option 1) maintains all version pointers synchronized regardless of feature enablement, ensuring nodes can safely restart with any configuration.

### Citations

**File:** storage/indexer/src/db_indexer.rs (L524-545)
```rust
        if self.indexer_db.transaction_enabled() {
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::TransactionVersion,
                &MetadataValue::Version(version - 1),
            )?;
        }
        if self.indexer_db.event_enabled() {
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::EventVersion,
                &MetadataValue::Version(version - 1),
            )?;
        }
        if self.indexer_db.statekeys_enabled() {
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::StateVersion,
                &MetadataValue::Version(version - 1),
            )?;
        }
        batch.put::<InternalIndexerMetadataSchema>(
            &MetadataKey::LatestVersion,
            &MetadataValue::Version(version - 1),
        )?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L102-139)
```rust
        let start_version = self
            .db_indexer
            .indexer_db
            .get_persisted_version()?
            .map_or(0, |v| v + 1);

        if node_config.indexer_db_config.enable_statekeys() {
            let state_start_version = self
                .db_indexer
                .indexer_db
                .get_state_version()?
                .map_or(0, |v| v + 1);
            if start_version != state_start_version {
                panic!("Cannot start state indexer because the progress doesn't match.");
            }
        }

        if node_config.indexer_db_config.enable_transaction() {
            let transaction_start_version = self
                .db_indexer
                .indexer_db
                .get_transaction_version()?
                .map_or(0, |v| v + 1);
            if start_version != transaction_start_version {
                panic!("Cannot start transaction indexer because the progress doesn't match.");
            }
        }

        if node_config.indexer_db_config.enable_event() {
            let event_start_version = self
                .db_indexer
                .indexer_db
                .get_event_version()?
                .map_or(0, |v| v + 1);
            if start_version != event_start_version {
                panic!("Cannot start event indexer because the progress doesn't match.");
            }
        }
```
