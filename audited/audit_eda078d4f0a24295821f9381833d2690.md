# Audit Report

## Title
Unicode Normalization Bypass Allows Multiple Visually Identical Collections Under Same Creator

## Summary
The Aptos Token v1 framework and indexer do not normalize Unicode strings (NFC vs NFD) when handling collection names, allowing a single creator to bypass uniqueness constraints and create multiple collections with visually identical names that produce different hashes. This enables phishing attacks and breaks the expected uniqueness guarantee.

## Finding Description

The vulnerability exists across multiple components:

**On-Chain (Move Token Contract):**
The `create_collection` function validates collection name uniqueness using byte-for-byte string comparison without Unicode normalization. [1](#0-0) 

The `Collections` resource stores collection data in a `Table<String, CollectionData>` where the key is the raw collection name bytes: [2](#0-1) 

Move's `String` type only validates UTF-8 encoding but performs no Unicode normalization: [3](#0-2) 

**Indexer (Off-Chain):**
The indexer computes `collection_data_id_hash` by hashing the concatenation of creator address and collection name without normalization: [4](#0-3) [5](#0-4) 

The hash function uses raw UTF-8 bytes: [6](#0-5) 

**Attack Scenario:**
1. Creator creates collection named "Café Apes" using NFC normalization (é = U+00E9, single codepoint)
2. Same creator creates collection "Café Apes" using NFD normalization (e + combining acute accent = U+0065 U+0301, two codepoints)
3. On-chain: Both collections exist in the same Table under different keys (different byte sequences)
4. Indexer: Both get different `collection_data_id_hash` values and separate database entries
5. Users see two visually identical collections from the same creator
6. Phishing: Creator can selectively promote one collection while the other appears legitimate
7. User confusion: Buyers cannot distinguish which collection is the "real" one

The Move type system explicitly acknowledges this issue exists for identifiers but chose to restrict them to ASCII: [7](#0-6) 

However, collection names use the `String` type (not identifiers), so this restriction does not apply.

## Impact Explanation

**Medium Severity** per Aptos Bug Bounty criteria:
- **State inconsistencies requiring intervention**: The uniqueness guarantee expected for collection names is violated. Multiple visually identical collections can coexist under the same creator, breaking user expectations and requiring manual intervention to identify legitimate collections.
- **Limited funds loss or manipulation**: Users may purchase NFTs from unintended collections due to visual confusion, leading to value loss. While not direct theft, this enables sophisticated phishing attacks.

This does not qualify as High/Critical because:
- No consensus violation (deterministic execution is maintained)
- No validator impact or API crashes
- No direct fund theft mechanism (requires user error)
- Phishing requires attacker to own both collections (same creator address)

## Likelihood Explanation

**High likelihood** of occurrence:
- **No special privileges required**: Any user can create collections with Unicode names
- **Easy to exploit**: Simply use different normalization forms (NFC/NFD) when calling `create_collection`
- **Non-obvious to users**: Visually identical names appear as duplicates
- **No validation prevents it**: Neither Move nor the indexer check for normalization equivalence

The attack is trivial to execute and requires no technical sophistication beyond understanding Unicode normalization.

## Recommendation

**Short-term fix**: Normalize all collection names to NFC (Canonical Composition) before storage and hashing:

**Move Framework:**
Add a normalization step in `create_collection`:
```move
public fun create_collection(
    creator: &signer,
    name: String,
    description: String,
    uri: String,
    maximum: u64,
    mutate_setting: vector<bool>
) acquires Collections {
    // Normalize to NFC before validation
    let normalized_name = string::normalize_nfc(name);
    assert!(normalized_name.length() <= MAX_COLLECTION_NAME_LENGTH, ...);
    
    let collection_data = &mut Collections[account_addr].collection_data;
    assert!(!collection_data.contains(normalized_name), ...);
    
    // Use normalized_name throughout
    collection_data.add(normalized_name, collection);
}
```

Requires adding a native `normalize_nfc` function to Move stdlib that calls Rust's `unicode-normalization` crate.

**Indexer:**
Normalize before hashing in `CollectionDataIdType::to_string()`:
```rust
impl fmt::Display for CollectionDataIdType {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        use unicode_normalization::UnicodeNormalization;
        let normalized_name: String = self.name.nfc().collect();
        write!(
            f,
            "{}::{}",
            standardize_address(self.creator.as_str()),
            normalized_name
        )
    }
}
```

**Long-term**: Consider restricting collection names to ASCII-only (similar to identifiers) or implementing comprehensive Unicode handling with proper normalization, case-folding, and visual confusable detection.

## Proof of Concept

```move
#[test_only]
module test_addr::unicode_normalization_attack {
    use std::string;
    use aptos_framework::account;
    use aptos_token::token;
    
    #[test(creator = @0xcafe)]
    public fun test_duplicate_collections_different_normalization(creator: &signer) {
        account::create_account_for_test(@0xcafe);
        
        // Create collection with "Café" in NFC form (é = U+00E9)
        // Bytes: 0x43 0x61 0x66 0xC3 0xA9
        let name_nfc = string::utf8(b"Caf\xC3\xA9");
        token::create_collection(
            creator,
            name_nfc,
            string::utf8(b"Description 1"),
            string::utf8(b"https://example.com/1"),
            1000,
            vector[false, false, false]
        );
        
        // Create collection with "Café" in NFD form (e + combining acute = U+0065 U+0301)
        // Bytes: 0x43 0x61 0x66 0x65 0xCC 0x81
        let name_nfd = string::utf8(b"Cafe\xCC\x81");
        
        // This should fail if normalization is enforced, but currently succeeds
        token::create_collection(
            creator,
            name_nfd,
            string::utf8(b"Description 2"),
            string::utf8(b"https://example.com/2"),
            2000,
            vector[false, false, false]
        );
        
        // Both collections now exist under the same creator
        // They are visually identical but have different byte representations
        assert!(token::check_collection_exists(@0xcafe, name_nfc), 0);
        assert!(token::check_collection_exists(@0xcafe, name_nfd), 1);
        
        // Different hashes will be computed by the indexer
        // Leading to separate database entries for visually identical collections
    }
}
```

The test demonstrates that both NFC and NFD forms are accepted as distinct collections, violating the expected uniqueness constraint for visually identical names.

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L253-255)
```text
    struct Collections has key {
        collection_data: Table<String, CollectionData>,
        token_data: Table<TokenDataId, TokenData>,
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1187-1190)
```text
        assert!(
            !collection_data.contains(name),
            error::already_exists(ECOLLECTION_ALREADY_EXISTS),
        );
```

**File:** aptos-move/framework/move-stdlib/sources/string.move (L11-20)
```text
    /// A `String` holds a sequence of bytes which is guaranteed to be in utf8 format.
    struct String has copy, drop, store {
        bytes: vector<u8>,
    }

    /// Creates a new string from a sequence of bytes. Aborts if the bytes do not represent valid utf8.
    public fun utf8(bytes: vector<u8>): String {
        assert!(internal_check_utf8(&bytes), EINVALID_UTF8);
        String{bytes}
    }
```

**File:** crates/indexer/src/models/token_models/collection_datas.rs (L122-124)
```rust
            let collection_data_id =
                CollectionDataIdType::new(creator_address, collection_data.get_name().to_string());
            let collection_data_id_hash = collection_data_id.to_hash();
```

**File:** crates/indexer/src/models/token_models/token_utils.rs (L103-111)
```rust
impl fmt::Display for CollectionDataIdType {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        write!(
            f,
            "{}::{}",
            standardize_address(self.creator.as_str()),
            self.name
        )
    }
```

**File:** crates/indexer/src/util.rs (L19-21)
```rust
pub fn hash_str(val: &str) -> String {
    hex::encode(sha2::Sha256::digest(val.as_bytes()))
}
```

**File:** third_party/move/move-core/types/src/identifier.rs (L20-23)
```rust
//! Allowed identifiers are currently restricted to ASCII due to unresolved issues with Unicode
//! normalization. See [Rust issue #55467](https://github.com/rust-lang/rust/issues/55467) and the
//! associated RFC for some discussion. Unicode identifiers may eventually be supported once these
//! issues are worked out.
```
