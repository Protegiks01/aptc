# Audit Report

## Title
Missing Validation of Version-Epoch Correspondence in Subscription Streams Allows Generation of Unverifiable Proofs

## Summary
The storage service server does not validate that `known_version_at_stream_start` and `known_epoch_at_stream_start` in `SubscriptionStreamMetadata` correspond to the same ledger state. This allows malicious clients to provide mismatched values (e.g., a version from epoch N with an epoch number of N+1), causing the server to generate proofs with inconsistent epoch information that clients cannot verify, leading to state sync failures and resource exhaustion.

## Finding Description

The `SubscriptionStreamMetadata` struct contains two critical fields that must correspond to the same ledger state: [1](#0-0) 

When a client creates a new subscription stream, the server accepts these values without validating their correspondence: [2](#0-1) 

The server uses `known_epoch_at_stream_start` to determine which epoch ending ledger info to fetch, and `known_version_at_stream_start` to determine which transactions to send. When these values are mismatched, the server generates proofs anchored at the wrong epoch.

The validation logic only checks ONE direction of the mismatch: [3](#0-2) 

This check detects when a client claims to be in epoch N but has a version beyond epoch N's ending. However, it **fails to detect** when a client claims to be in epoch N+1 but has a version still in epoch N.

**Attack Scenario:**
1. Blockchain state: Epoch 4 ends at version 800, Epoch 5 ends at version 1200
2. Malicious client at version 750 (in epoch 4) creates subscription with:
   - `known_version_at_stream_start = 750`
   - `known_epoch_at_stream_start = 5` (incorrect - should be 4)
3. Server processing:
   - Fetches epoch 5 ending ledger info (version 1200)
   - Checks: `1200 <= 750`? **FALSE** → Not marked invalid
   - Marks subscription as ready with target = epoch 5 ending ledger info
4. Server generates proof request: [4](#0-3) 

5. Result: Server sends transactions starting from version 751 (which include the epoch 4→5 transition at version 801) with proofs anchored at epoch 5's ending (version 1200)

The client at epoch 4 cannot verify these proofs because:
- They need epoch 4's ending ledger info to transition to epoch 5
- The proof is from the END of epoch 5, signed by epoch 5's validators
- The client only has epoch 4's validator set and cannot verify epoch 5 signatures

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria ("Significant protocol violations"):

1. **State Sync Failure**: Clients receive proofs with epoch information that doesn't match their actual state, causing verification to fail and blocking state synchronization.

2. **Resource Exhaustion**: Servers waste computational resources generating cryptographically valid but semantically incorrect proofs that clients cannot use.

3. **Denial of Service Potential**: Malicious actors can repeatedly create subscriptions with mismatched values, causing continuous resource waste and preventing legitimate state sync operations.

4. **Protocol Invariant Violation**: Breaks the critical invariant that "State transitions must be atomic and verifiable via Merkle proofs" - the generated proofs are not properly verifiable by clients at the claimed state.

## Likelihood Explanation

**Likelihood: High**

- **No authentication required**: Any network peer can send subscription requests
- **Simple exploitation**: Attacker only needs to provide two mismatched integer values
- **No special privileges needed**: Requires no validator access or insider knowledge
- **Easily repeatable**: Attack can be executed continuously against multiple servers
- **Difficult to detect**: Server accepts requests without validation, making malicious requests indistinguishable from legitimate ones until proof generation

The attack is trivial to execute and requires minimal resources from the attacker while potentially causing significant disruption to state sync operations.

## Recommendation

Add validation when creating a subscription stream to ensure `known_version_at_stream_start` and `known_epoch_at_stream_start` correspond to the same ledger state. The fix should be implemented in `SubscriptionStreamRequests::new()`:

```rust
pub fn new(subscription_request: SubscriptionRequest, time_service: TimeService) -> Result<Self, Error> {
    // Extract the relevant information from the request
    let highest_known_version = subscription_request.highest_known_version_at_stream_start();
    let highest_known_epoch = subscription_request.highest_known_epoch_at_stream_start();
    let subscription_stream_metadata = subscription_request.subscription_stream_metadata();

    // VALIDATION: Verify that the known version is actually in the claimed epoch
    // This requires access to storage to call get_epoch(known_version)
    // Alternative: validate this in handle_subscription_request before creating the stream
    
    // Create pending subscription requests...
}
```

Alternatively, add validation in the handler before accepting the subscription: [5](#0-4) 

The validation should use the storage layer's `get_epoch()` function: [6](#0-5) 

## Proof of Concept

```rust
#[tokio::test]
async fn test_mismatched_version_epoch_in_subscription() {
    // Setup: Create a mock storage with multiple epochs
    // Epoch 4 ends at version 800
    // Epoch 5 ends at version 1200
    let storage = MockDbReaderWriter::new();
    let config = StorageServiceConfig::default();
    
    // Malicious client at version 750 (epoch 4) but claims epoch 5
    let known_version_at_stream_start = 750;
    let known_epoch_at_stream_start = 5; // INCORRECT - should be 4
    let subscription_stream_id = 100;
    
    // Create subscription metadata with mismatched values
    let subscription_stream_metadata = SubscriptionStreamMetadata {
        known_version_at_stream_start,
        known_epoch_at_stream_start,
        subscription_stream_id,
    };
    
    // Create subscription request
    let data_request = DataRequest::SubscribeTransactionsWithProof(
        SubscribeTransactionsWithProofRequest {
            subscription_stream_metadata,
            subscription_stream_index: 0,
            include_events: false,
        }
    );
    
    let request = StorageServiceRequest::new(data_request, false);
    
    // Server should validate but currently doesn't
    // The server will fetch epoch 5 ending ledger info
    // But the client is still in epoch 4 and can't verify it
    
    // Expected: Server should reject with InvalidRequest error
    // Actual: Server accepts and generates unverifiable proof
    
    // Process the subscription...
    // Verify that the server generates a proof anchored at epoch 5 ending
    // when the client is actually in epoch 4
    // This proof will fail client-side verification
}
```

**Notes**

The vulnerability exists due to incomplete validation in the subscription stream creation logic. While the server does perform some validation to detect clients claiming to be in an old epoch when they're actually ahead, it fails to detect the inverse case where clients claim a future epoch while still being in an earlier one. The storage layer provides the necessary `get_epoch()` function to perform proper validation, but it is not currently utilized during subscription stream initialization. This represents a significant gap in input validation that can be exploited to cause state sync disruption.

### Citations

**File:** state-sync/storage-service/types/src/requests.rs (L418-422)
```rust
pub struct SubscriptionStreamMetadata {
    pub known_version_at_stream_start: u64, // The highest known transaction version at stream start
    pub known_epoch_at_stream_start: u64,   // The highest known epoch at stream start
    pub subscription_stream_id: u64,        // The unique id of the subscription stream
}
```

**File:** state-sync/storage-service/server/src/subscription.rs (L89-106)
```rust
        // Calculate the start and end versions
        let start_version = known_version.checked_add(1).ok_or_else(|| {
            Error::UnexpectedErrorEncountered("Start version has overflown!".into())
        })?;
        let end_version = known_version
            .checked_add(num_versions_to_fetch)
            .ok_or_else(|| {
                Error::UnexpectedErrorEncountered("End version has overflown!".into())
            })?;

        // Create the storage request
        let data_request = match &self.request.data_request {
            DataRequest::SubscribeTransactionOutputsWithProof(_) => {
                DataRequest::GetTransactionOutputsWithProof(TransactionOutputsWithProofRequest {
                    proof_version: target_version,
                    start_version,
                    end_version,
                })
```

**File:** state-sync/storage-service/server/src/subscription.rs (L314-336)
```rust
    pub fn new(subscription_request: SubscriptionRequest, time_service: TimeService) -> Self {
        // Extract the relevant information from the request
        let highest_known_version = subscription_request.highest_known_version_at_stream_start();
        let highest_known_epoch = subscription_request.highest_known_epoch_at_stream_start();
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();

        // Create a new set of pending subscription requests using the first request
        let mut pending_subscription_requests = BTreeMap::new();
        pending_subscription_requests.insert(
            subscription_request.subscription_stream_index(),
            subscription_request,
        );

        Self {
            highest_known_version,
            highest_known_epoch,
            next_index_to_serve: 0,
            pending_subscription_requests,
            subscription_stream_metadata,
            last_stream_update_time: time_service.now(),
            time_service,
        }
    }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L949-959)
```rust
                    // Check that we haven't been sent an invalid subscription request
                    // (i.e., a request that does not respect an epoch boundary).
                    if epoch_ending_ledger_info.ledger_info().version() <= highest_known_version {
                        peers_with_invalid_subscriptions
                            .lock()
                            .push(peer_network_id);
                    } else {
                        peers_with_ready_subscriptions
                            .lock()
                            .push((peer_network_id, epoch_ending_ledger_info));
                    }
```

**File:** state-sync/storage-service/server/src/handler.rs (L284-295)
```rust
    pub fn handle_subscription_request(
        &self,
        storage_service_config: StorageServiceConfig,
        peer_network_id: PeerNetworkId,
        request: StorageServiceRequest,
        response_sender: ResponseSender,
    ) {
        // Create a new subscription request and get the stream ID
        let subscription_request =
            SubscriptionRequest::new(request.clone(), response_sender, self.time_service.clone());
        let request_stream_id = subscription_request.subscription_stream_id();

```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L203-231)
```rust
    /// Returns the epoch at the given version.
    pub(crate) fn get_epoch(&self, version: Version) -> Result<u64> {
        let mut iter = self.db.iter::<EpochByVersionSchema>()?;
        // Search for the end of the previous epoch.
        iter.seek_for_prev(&version)?;
        let (epoch_end_version, epoch) = match iter.next().transpose()? {
            Some(x) => x,
            None => {
                // There should be a genesis LedgerInfo at version 0 (genesis only consists of one
                // transaction), so this normally doesn't happen. However this part of
                // implementation doesn't need to rely on this assumption.
                return Ok(0);
            },
        };
        ensure!(
            epoch_end_version <= version,
            "DB corruption: looking for epoch for version {}, got epoch {} ends at version {}",
            version,
            epoch,
            epoch_end_version
        );
        // If the obtained epoch ended before the given version, return epoch+1, otherwise
        // the given version is exactly the last version of the found epoch.
        Ok(if epoch_end_version < version {
            epoch + 1
        } else {
            epoch
        })
    }
```
