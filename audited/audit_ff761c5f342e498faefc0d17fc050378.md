# Audit Report

## Title
Configuration Sanitizer Bypass Enables Failpoint APIs on Mainnet Nodes

## Summary
The `skip_config_sanitizer` configuration flag in `NodeStartupConfig` allows operators to bypass all configuration validation checks, including the critical mainnet failpoint protection. When combined with binaries compiled with the `failpoints` feature, this exposes dangerous failure injection APIs on production nodes.

## Finding Description

The Aptos node configuration system implements a multi-layered sanitization mechanism to prevent unsafe configurations on mainnet. Specifically, `ApiConfig::sanitize()` validates that failpoints are not enabled on mainnet nodes [1](#0-0) .

However, the `NodeConfig::sanitize()` implementation contains an unconditional early return when `skip_config_sanitizer` is set to true [2](#0-1) . This flag is a serializable configuration field [3](#0-2)  that can be set in the node's YAML configuration file, with a default value of `false` [4](#0-3) .

**Attack Flow:**
1. An operator creates a configuration with `skip_config_sanitizer: true` in the `node_startup` section
2. They also set `api.failpoints_enabled: true` 
3. The node loads this configuration via `NodeConfig::load_from_path()` [5](#0-4) 
4. During sanitization, the early return bypasses all validation including the mainnet failpoint check
5. If the binary was compiled with `--features failpoints` [6](#0-5) , the `/set_failpoint` API endpoint becomes active [7](#0-6) 
6. Attackers or malicious operators can inject arbitrary failures into consensus [8](#0-7) , execution [9](#0-8) , and VM operations [10](#0-9) 

**Invariants Broken:**
- **Consensus Safety**: Failpoints can block vote messages, causing safety violations
- **Deterministic Execution**: Selective failpoint triggering creates non-deterministic execution across validators
- **Defense-in-Depth**: Configuration validation is completely bypassable without any warnings or additional authentication

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: Selective failpoint activation across validators causes execution divergence
- **Limited availability impact**: Individual nodes can be forced offline via consensus/execution failpoints
- **Not Critical** because it requires: (1) operator configuration access, (2) debug build deployment

While the sanitizer bypass itself is a configuration issue, enabling failpoint APIs on mainnet nodes with this configuration could lead to:
- Consensus disruption (blocking proposals, votes)
- Transaction execution failures  
- Network partitioning
- State divergence if failures are inconsistently triggered

The test case explicitly demonstrates this bypass is intentional but dangerous [11](#0-10) .

## Likelihood Explanation

**Medium likelihood** in the following scenarios:
- **Debugging production issues**: Operators compile with failpoints to debug mainnet incidents and accidentally deploy
- **Configuration drift**: Test configurations with `skip_config_sanitizer: true` accidentally promoted to production
- **Compromised operator**: Malicious insider with configuration access

**Lower likelihood** because:
- Requires both configuration file modification (operator access) AND debug build
- Production builds should never include failpoints feature
- Operators should understand configuration semantics

However, no warnings, documentation, or additional protections exist around `skip_config_sanitizer`, making accidental misuse plausible.

## Recommendation

**1. Add explicit warnings and restrictions:**
```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // Warn loudly if sanitizer is disabled
        if node_config.node_startup.skip_config_sanitizer {
            warn!("⚠️ CONFIG SANITIZER DISABLED - ALL SAFETY CHECKS BYPASSED");
            
            // Forbid on mainnet entirely
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet() {
                    return Err(Error::ConfigSanitizerFailed(
                        "NodeConfig".to_string(),
                        "skip_config_sanitizer cannot be enabled on mainnet!".into(),
                    ));
                }
            }
            return Ok(());
        }
        // ... rest of sanitization
    }
}
```

**2. Remove or restrict the bypass capability:**
- Make `skip_config_sanitizer` only work when compiled with a `testing` feature flag
- Require environment variable confirmation (e.g., `UNSAFE_SKIP_SANITIZER=confirmed`)
- Log all bypasses to audit trails

**3. Add field-level documentation:**
```rust
pub struct NodeStartupConfig {
    /// DANGEROUS: Skips all configuration validation. 
    /// Should NEVER be enabled on mainnet.
    /// Only use for local testing.
    pub skip_config_sanitizer: bool,
}
```

## Proof of Concept

**Configuration that bypasses mainnet protection:**
```yaml
# mainnet-node.yaml
base:
  role: validator
  # ... other config

node_startup:
  skip_config_sanitizer: true  # Bypass all validation

api:
  enabled: true
  failpoints_enabled: true  # Would normally fail on mainnet
```

**Exploitation (assuming failpoints feature enabled):**
```bash
# Node starts successfully despite unsafe config
./aptos-node -f mainnet-node.yaml

# Inject consensus failure
curl -X POST "http://localhost:8080/set_failpoint?name=consensus::send::vote&actions=return"

# Result: Node stops sending votes, consensus disrupted
```

**Notes**

- This vulnerability requires **operator-level access** (ability to modify configuration files), which technically disqualifies it as an "unprivileged attacker" exploit per the strict validation criteria
- The issue is primarily a **defense-in-depth failure** - the sanitizer bypass is too broad and lacks protections
- Production mainnet nodes compiled without the `failpoints` feature are not affected by the failpoint API exposure, though other sanitizer checks (execution paranoid verification, etc.) are still bypassed
- The test case `test_disable_config_sanitizer` shows this bypass is intentional but lacks proper warnings [11](#0-10) 
- Even without failpoints, bypassing sanitizers like execution config validation [12](#0-11)  could allow unsafe mainnet configurations

Given the requirement for operator access, this may be better classified as an **operational security issue** rather than a directly exploitable vulnerability by external attackers.

### Citations

**File:** config/src/config/api_config.rs (L177-185)
```rust
        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L56-56)
```rust
        ExecutionConfig::sanitize(node_config, node_type, chain_id)?;
```

**File:** config/src/config/config_sanitizer.rs (L212-239)
```rust
    fn test_disable_config_sanitizer() {
        // Create a default node config (with sanitization enabled)
        let mut node_config = NodeConfig::default();

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer fails
        let error =
            NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
                .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
    }
```

**File:** config/src/config/node_startup_config.rs (L6-11)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** config/src/config/node_startup_config.rs (L14-20)
```rust
impl Default for NodeStartupConfig {
    fn default() -> Self {
        Self {
            skip_config_optimizer: false,
            skip_config_sanitizer: false,
        }
    }
```

**File:** config/src/config/node_config.rs (L140-143)
```rust
    pub fn load_from_path<P: AsRef<Path>>(input_path: P) -> Result<Self, Error> {
        let node_config_loader = NodeConfigLoader::new(input_path);
        node_config_loader.load_and_sanitize_config()
    }
```

**File:** aptos-node/Cargo.toml (L95-95)
```text
failpoints = ["fail/failpoints", "aptos-consensus/failpoints", "aptos-executor/failpoints", "aptos-mempool/failpoints", "aptos-api/failpoints", "aptos-config/failpoints"]
```

**File:** api/src/set_failpoints.rs (L21-40)
```rust
#[cfg(feature = "failpoints")]
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** consensus/src/network.rs (L520-524)
```rust
    pub async fn send_vote(&self, vote_msg: VoteMsg, recipients: Vec<Author>) {
        fail_point!("consensus::send::vote", |_| ());
        let msg = ConsensusMsg::VoteMsg(Box::new(vote_msg));
        self.send(msg, recipients).await
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L236-240)
```rust
                fail_point!("executor::block_executor_execute_block", |_| {
                    Err(ExecutorError::from(anyhow::anyhow!(
                        "Injected error in block_executor_execute_block"
                    )))
                });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1032-1038)
```rust
        fail_point!("aptos_vm::execute_script_or_entry_function", |_| {
            Err(VMStatus::Error {
                status_code: StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                sub_status: Some(move_core_types::vm_status::sub_status::unknown_invariant_violation::EPARANOID_FAILURE),
                message: None,
            })
        });
```
