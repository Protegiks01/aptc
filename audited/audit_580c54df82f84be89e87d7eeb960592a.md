# Audit Report

## Title
Indexer Crash Due to Unvalidated BigDecimal Deserialization in FixedSupply Processing

## Summary
The indexer's `FixedSupply::from_write_resource()` function deserializes `total_minted`, `current_supply`, and `max_supply` fields as `BigDecimal` without validating input constraints. When processing `WriteResource` data from untrusted sources, malformed numeric strings (e.g., with exponents exceeding i64 range) cause `BigDecimal::from_str()` to fail, triggering a panic via `.unwrap()` in the token processor, resulting in indexer crashes.

## Finding Description

The vulnerability exists in the token indexer's deserialization path: [1](#0-0) 

These fields use `deserialize_from_string`, which parses strings into `BigDecimal`: [2](#0-1) 

The on-chain Move contract defines these as `u64` values (maximum 18,446,744,073,709,551,615): [3](#0-2) 

However, the indexer processor calls these deserialization functions with `.unwrap()`: [4](#0-3) 

**Attack Path:**
1. Attacker controls a malicious data source (API endpoint, corrupted file replay)
2. Sends `WriteResource` with malformed `total_minted` value (e.g., `"1e99999999999999999999"` - exponent exceeds i64 range)
3. Deserialization path: `from_write_resource()` → `V2TokenResource::from_resource()` → `serde_json::from_value()` → `deserialize_from_string()` → `BigDecimal::from_str()`
4. `BigDecimal::from_str()` returns `Err` for invalid input
5. Error propagates through `.unwrap()` at line 1123
6. Indexer panics and crashes

The same pattern affects `UnlimitedSupply`, `FungibleAssetSupply`, and other resources processed with `.unwrap()`.

## Impact Explanation

**Severity: Low** (as specified in the security question)

This is a **denial-of-service vulnerability affecting only the indexer**, not core blockchain operations:

- **No consensus impact**: The indexer is a read-only auxiliary component; it does not participate in block production, validation, or state commitment
- **No funds at risk**: Cannot steal, freeze, or manipulate on-chain assets
- **No validator node impact**: Validator nodes are unaffected; they continue processing blocks normally
- **Limited scope**: Only affects indexers connecting to untrusted data sources

The impact is temporary service disruption requiring indexer restart. This meets the "Non-critical implementation bugs" category for Low severity per the bug bounty program.

## Likelihood Explanation

**Likelihood: Low**

Most production deployments run indexers alongside trusted full nodes with validated data. Attack requires:

1. **Untrusted data source**: Indexer must connect to malicious/compromised API endpoint or replay corrupted files
2. **Malformed input**: Attacker must craft specific invalid numeric strings that cause parsing failures
3. **Limited operational impact**: Indexer can be quickly restarted

The on-chain data is always validated (u64 constraints enforced by Move VM), so this only occurs when the indexer receives data from sources that bypass normal validation.

## Recommendation

Replace `.unwrap()` with proper error handling to prevent panics:

```rust
// In token_processor.rs, replace lines 1122-1126 with:
if let Ok(Some(fixed_supply)) = FixedSupply::from_write_resource(wr, txn_version) {
    aggregated_data.fixed_supply = Some(fixed_supply);
} else if let Err(e) = FixedSupply::from_write_resource(wr, txn_version) {
    tracing::warn!(
        "Failed to deserialize FixedSupply at version {}: {}",
        txn_version, e
    );
}
```

Additionally, add input validation in `deserialize_from_string` to ensure values fit within expected ranges:

```rust
pub fn deserialize_from_string<'de, D, T>(deserializer: D) -> Result<T, D::Error>
where
    D: Deserializer<'de>,
    T: FromStr,
    <T as FromStr>::Err: std::fmt::Display,
{
    use serde::de::Error;
    let s = <String>::deserialize(deserializer)?;
    
    // Add length validation to prevent pathological inputs
    if s.len() > 1024 {
        return Err(D::Error::custom("numeric string exceeds maximum length"));
    }
    
    s.parse::<T>().map_err(D::Error::custom)
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_bigdecimal_overflow {
    use bigdecimal::BigDecimal;
    use std::str::FromStr;
    
    #[test]
    #[should_panic(expected = "called `Result::unwrap()` on an `Err` value")]
    fn test_bigdecimal_exponent_overflow() {
        // Simulate malicious input with exponent exceeding i64 range
        let malformed_input = "1e99999999999999999999";
        
        // This will fail to parse
        let result = BigDecimal::from_str(malformed_input);
        assert!(result.is_err(), "Expected parse error for oversized exponent");
        
        // Simulating the .unwrap() pattern used in token_processor.rs:1123
        result.unwrap(); // This panics
    }
    
    #[test]
    fn test_valid_u64_parses_successfully() {
        let valid_u64_max = "18446744073709551615";
        let result = BigDecimal::from_str(valid_u64_max);
        assert!(result.is_ok(), "Valid u64 should parse successfully");
    }
}
```

**Notes**

This vulnerability is confirmed but rated **Low severity** because:
1. The indexer is **not a consensus-critical component** - it does not affect blockchain safety, liveness, or validator operations
2. Attack requires compromised data sources (untrusted API endpoints or corrupted file replay)
3. Impact is limited to temporary DoS of the indexer service, easily recoverable via restart
4. On-chain data validation (Move VM enforcing u64 constraints) prevents this in normal operations

The issue does NOT break any of the 10 critical invariants (Deterministic Execution, Consensus Safety, Move VM Safety, State Consistency, Governance Integrity, Staking Security, Transaction Validation, Access Control, Resource Limits, Cryptographic Correctness) because the indexer operates outside the critical blockchain execution path.

### Citations

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L246-254)
```rust
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FixedSupply {
    #[serde(deserialize_with = "deserialize_from_string")]
    pub current_supply: BigDecimal,
    #[serde(deserialize_with = "deserialize_from_string")]
    pub max_supply: BigDecimal,
    #[serde(deserialize_with = "deserialize_from_string")]
    pub total_minted: BigDecimal,
}
```

**File:** api/types/src/lib.rs (L63-73)
```rust
pub fn deserialize_from_string<'de, D, T>(deserializer: D) -> Result<T, D::Error>
where
    D: Deserializer<'de>,
    T: FromStr,
    <T as FromStr>::Err: std::fmt::Display,
{
    use serde::de::Error;

    let s = <String>::deserialize(deserializer)?;
    s.parse::<T>().map_err(D::Error::custom)
}
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L102-111)
```text
    struct FixedSupply has key {
        /// Total minted - total burned
        current_supply: u64,
        max_supply: u64,
        total_minted: u64,
        /// Emitted upon burning a Token.
        burn_events: event::EventHandle<BurnEvent>,
        /// Emitted upon minting an Token.
        mint_events: event::EventHandle<MintEvent>,
    }
```

**File:** crates/indexer/src/processors/token_processor.rs (L1122-1126)
```rust
                        if let Some(fixed_supply) =
                            FixedSupply::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.fixed_supply = Some(fixed_supply);
                        }
```
