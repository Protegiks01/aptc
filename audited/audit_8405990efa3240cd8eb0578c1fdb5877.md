# Audit Report

## Title
Lazy Loading Bypasses Transitive Dependency Verification Allowing Incorrect Ability Propagation Through Nested Struct Fields

## Summary
When lazy loading is enabled (production default), the Move bytecode verifier skips dependency verification for transitively loaded modules, allowing structs to incorrectly claim abilities (copy, drop, store, key) that their nested field types do not possess. This violates Move's fundamental type safety guarantees and can cause consensus divergence.

## Finding Description

The vulnerability exists in the module verification flow when lazy loading is enabled. The system performs two types of verification:

1. **Local verification** (`signature_v2::verify_module`) - checks struct field abilities using struct handles stored in the module's bytecode [1](#0-0) 

2. **Dependency verification** (`dependencies::verify_module`) - validates that imported struct handles match actual definitions in dependency modules [2](#0-1) 

The critical flaw is that when lazy loading is enabled, transitive dependencies are loaded WITHOUT dependency verification: [3](#0-2) 

When publishing a module with lazy loading enabled, dependencies are loaded lazily which skips linking checks: [4](#0-3) 

**Attack Scenario:**

1. **Module C v1** deployed: `struct Core has copy, drop { value: u64 }`
2. **Module B** compiled against C v1: `struct Inner has copy, drop { core: C::Core }`
3. **Module C v2** deployed (replacing v1): `struct Core { signer: Signer }` (NO abilities)
4. **Module A** is published: `struct Outer has copy, drop { inner: B::Inner }`

When Module A is published with lazy loading:
- Module B is loaded via `unmetered_get_lazily_verified_module()` 
- B's verification uses B's struct handles for C::Core (which claim `copy, drop` from compile time)
- NO dependency verification checks that C actually has these abilities
- A's linking check validates A→B but NOT B→C
- Module A is accepted despite violating the invariant that `Outer.copy` requires all nested fields to have `copy`

Lazy loading is enabled in production: [5](#0-4) [6](#0-5) 

## Impact Explanation

**Critical Severity** - This is a consensus safety violation and breaks Move VM type safety:

1. **Consensus Divergence**: Different validators may have different cached verification states for Module B. If some validators loaded B with full dependency checks while others used lazy loading, they will accept/reject Module A differently, causing a chain split.

2. **Type Safety Violation**: The system allows structs with `copy` to contain non-copyable nested fields, violating Move's ability semantics. This can lead to:
   - Copying of resources that should not be copyable (e.g., containing `Signer`)
   - Dropping of resources without proper cleanup
   - Storing non-storable types in global storage

3. **Resource Safety Compromise**: If a struct incorrectly claims `key` ability while nested fields lack `store`, resources can be improperly stored in global storage, breaking resource accounting.

This meets the **Critical** category criteria: "Consensus/Safety violations" and potentially "Loss of Funds" if resource accounting is compromised.

## Likelihood Explanation

**High Likelihood** - This vulnerability is easily triggered:

1. Lazy loading is **enabled by default** in production Aptos
2. No special privileges required - any user can publish modules
3. Attack requires only:
   - Publishing module C with abilities
   - Publishing module B depending on C
   - Updating module C to remove abilities (via republish or account rotation)
   - Publishing module A depending on B
4. The vulnerable code path is taken for every module publication with lazy loading enabled

The complexity is LOW - attacker only needs to coordinate module publications in the correct order.

## Recommendation

**Fix 1: Enforce transitive dependency verification for lazy loading**

In `publishing.rs`, when loading dependencies lazily, ensure they are also verified with linking checks:

```rust
// In publishing.rs, line 267:
let dependency = staged_module_storage
    .unmetered_get_existing_eagerly_verified_module(  // Change from lazily to eagerly
        &ModuleId::new(*dep_addr, dep_name.to_owned()),
    )?;
```

**Fix 2: Cache dependency verification status**

Track which modules have been fully verified (including dependencies) and only skip linking checks for modules with valid cached verification state that includes their dependencies.

**Fix 3: Recursive lazy verification**

Modify `unmetered_get_lazily_verified_module` to recursively verify dependencies: [7](#0-6) 

Change to call `build_verified_module_with_linking_checks` instead of `build_verified_module_skip_linking_checks`, loading immediate dependencies recursively.

## Proof of Concept

```move
// Module C - initially with abilities
module 0xCAFE::C {
    struct Core has copy, drop { value: u64 }
}

// Module B - compiled against C v1
module 0xCAFE::B {
    use 0xCAFE::C;
    struct Inner has copy, drop { core: C::Core }
}

// Update Module C - remove abilities (simulate via republish)
module 0xCAFE::C {
    struct Core { signer: signer }  // No copy, drop!
}

// Module A - will be accepted despite violation
module 0xCAFE::A {
    use 0xCAFE::B;
    struct Outer has copy, drop { inner: B::Inner }
    
    public fun test() {
        let outer = Outer { inner: B::Inner { core: ... } };
        let outer2 = copy outer;  // Incorrectly allowed! Copying Signer!
        drop outer;
        drop outer2;
    }
}
```

**Test Steps:**
1. Enable lazy loading feature flag
2. Publish module C with abilities
3. Publish module B depending on C
4. Republish module C without abilities (or replace via account key rotation)
5. Publish module A depending on B
6. Module A should be rejected but will be accepted
7. Calling `test()` violates Move's copy semantics for Signer

## Notes

This vulnerability demonstrates a critical gap between local module verification and global type safety when lazy loading is enabled. The verifier assumes struct handles accurately reflect current dependency abilities, but lazy loading breaks this assumption by skipping transitive dependency checks. This is particularly dangerous because it can cause validator disagreement on module acceptance, leading to consensus forks.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1103-1134)
```rust
    fn verify_fields_of_struct<'l>(
        &self,
        struct_handle: &StructHandle,
        context: &BitsetTypeParameterConstraints<{ N }>,
        required_abilities_conditional: AbilitySet,
        context_all_abilities: &BitsetTypeParameterConstraints<{ N }>,
        fields: impl Iterator<Item = &'l FieldDefinition>,
    ) -> Result<(), PartialVMError> {
        for field_def in fields {
            let field_ty = &field_def.signature.0;

            // Check if the field type itself is well-formed.
            self.check_ty_in_context(context, field_ty, false, AbilitySet::EMPTY)?;

            // Check if the field type satisfies the conditional ability requirements.
            self.check_ty_in_context(
                context_all_abilities,
                field_ty,
                false,
                required_abilities_conditional,
            )
            .map_err(|_err| PartialVMError::new(StatusCode::FIELD_MISSING_TYPE_ABILITY))?;

            check_phantom_params(
                self.resolver.struct_handles(),
                &struct_handle.type_parameters,
                false,
                field_ty,
            )?;
        }
        Ok(())
    }
```

**File:** third_party/move/move-bytecode-verifier/src/dependencies.rs (L237-279)
```rust
fn verify_imported_structs(context: &Context) -> PartialVMResult<()> {
    let self_module = context.resolver.self_handle_idx();
    for (idx, struct_handle) in context.resolver.struct_handles().iter().enumerate() {
        if Some(struct_handle.module) == self_module {
            continue;
        }
        let owner_module_id = context
            .resolver
            .module_id_for_handle(context.resolver.module_handle_at(struct_handle.module));
        // TODO: remove unwrap
        let owner_module = safe_unwrap!(context.dependency_map.get(&owner_module_id));
        let struct_name = context.resolver.identifier_at(struct_handle.name);
        match context
            .struct_id_to_handle_map
            .get(&(owner_module_id, struct_name.to_owned()))
        {
            Some(def_idx) => {
                let def_handle = owner_module.struct_handle_at(*def_idx);
                if !compatible_struct_abilities(struct_handle.abilities, def_handle.abilities)
                    || !compatible_struct_type_parameters(
                        &struct_handle.type_parameters,
                        &def_handle.type_parameters,
                    )
                {
                    return Err(verification_error(
                        StatusCode::TYPE_MISMATCH,
                        IndexKind::StructHandle,
                        idx as TableIndex,
                    )
                    .with_message("imported struct mismatches expectation"));
                }
            },
            None => {
                return Err(verification_error(
                    StatusCode::LOOKUP_FAILED,
                    IndexKind::StructHandle,
                    idx as TableIndex,
                ));
            },
        }
    }
    Ok(())
}
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L295-329)
```rust
    fn unmetered_get_lazily_verified_module(
        &self,
        module_id: &ModuleId,
    ) -> VMResult<Option<Arc<Module>>> {
        let (module, version) = match self.get_module_or_build_with(module_id, self)? {
            Some(module_and_version) => module_and_version,
            None => return Ok(None),
        };

        if module.code().is_verified() {
            return Ok(Some(module.code().verified().clone()));
        }

        let _timer = VM_TIMER.timer_with_label("unmetered_get_lazily_verified_module [cache miss]");
        let runtime_environment = self.runtime_environment();
        runtime_environment.paranoid_check_module_address_and_name(
            module.code().deserialized(),
            module_id.address(),
            module_id.name(),
        )?;
        let locally_verified_code = runtime_environment.build_locally_verified_module(
            module.code().deserialized().clone(),
            module.extension().size_in_bytes(),
            module.extension().hash(),
        )?;
        let verified_code =
            runtime_environment.build_verified_module_skip_linking_checks(locally_verified_code)?;
        let verified_module = self.insert_verified_module(
            module_id.clone(),
            verified_code,
            module.extension().clone(),
            version,
        )?;
        Ok(Some(verified_module.code().verified().clone()))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L245-275)
```rust
            if is_lazy_loading_enabled {
                // Local bytecode verification.
                staged_runtime_environment.paranoid_check_module_address_and_name(
                    compiled_module,
                    compiled_module.self_addr(),
                    compiled_module.self_name(),
                )?;
                let locally_verified_code = staged_runtime_environment
                    .build_locally_verified_module(
                        compiled_module.clone(),
                        bytes.len(),
                        &sha3_256(bytes),
                    )?;

                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
                let mut verified_dependencies = vec![];
                for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
                    // INVARIANT:
                    //   Immediate dependency of the module in a bundle must be metered at the
                    //   caller side.
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
                }
                staged_runtime_environment.build_verified_module_with_linking_checks(
                    locally_verified_code,
                    &verified_dependencies,
                )?;
```

**File:** types/src/on_chain_config/aptos_features.rs (L145-148)
```rust
    /// With lazy loading, modules are loaded lazily (as opposed to loading the transitive closure
    /// of dependencies). For more details, see:
    ///   AIP-127 (https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-127.md)
    ENABLE_LAZY_LOADING = 95,
```

**File:** types/src/on_chain_config/aptos_features.rs (L266-266)
```rust
            FeatureFlag::ENABLE_LAZY_LOADING,
```
