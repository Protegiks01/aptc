# Audit Report

## Title
Encrypted Transaction Filter Bypass via Time-of-Check Time-of-Use (TOCTOU) Vulnerability

## Summary
Attackers can craft encrypted transactions that systematically bypass both `mempool_filter` and `consensus_filter` validation checks, allowing transactions with explicitly denied entry functions or module addresses to execute on the blockchain. The vulnerability exploits a timing mismatch where filters inspect transactions while they remain encrypted, but decryption occurs only after all validation passes.

## Finding Description

The Aptos transaction filter system supports three filter types configured in `TransactionFiltersConfig`: `api_filter`, `mempool_filter`, and `consensus_filter`. These filters use `TransactionMatcher` implementations to evaluate transactions against configured rules (Allow/Deny based on sender, entry function, module address, etc.). [1](#0-0) 

The critical vulnerability arises from how these matchers handle `EncryptedPayload` transactions. When attempting to match entry functions or module addresses on encrypted transactions, the filter implementation attempts to access the transaction's executable content: [2](#0-1) [3](#0-2) 

However, the `executable_ref()` method only succeeds when the payload is in the `Decrypted` state: [4](#0-3) 

**The Attack Flow:**

1. **Mempool Submission**: When an encrypted transaction enters mempool, `filter_transactions` applies the `mempool_filter`: [5](#0-4) 
   
   At this point, the transaction payload is in `EncryptedPayload::Encrypted` state. The filter cannot inspect the actual entry function or module address, so matchers return `false` (no match), allowing the transaction through even if it should be denied.

2. **Consensus Validation**: When the block proposal is received, `check_denied_inline_transactions` applies the `consensus_filter`: [6](#0-5) 
   
   The transaction is **still encrypted** at this point (decryption happens later in the pipeline). The consensus filter also fails to inspect the content, returning `false` and allowing the block.

3. **Decryption**: Only after the block passes validation and is inserted into the block store does decryption occur: [7](#0-6) [8](#0-7) 

4. **Execution**: The now-decrypted transaction executes with its actual entry function/module address revealed, but all filter checks have already passed.

**Concrete Attack Scenario:**

Suppose a node operator configures filters to deny transactions calling `0xBAD::exploit::steal_funds` to protect against a known malicious contract:

```rust
// Deny rule configured
TransactionFilter::new(vec![
    TransactionRule::Deny(vec![
        TransactionMatcher::EntryFunction(
            AccountAddress::from_hex_literal("0xBAD").unwrap(),
            "exploit".to_string(),
            "steal_funds".to_string()
        )
    ])
])
```

An attacker:
1. Creates a `SignedTransaction` with `TransactionPayload::EncryptedPayload` containing the call to `0xBAD::exploit::steal_funds`
2. Submits it to mempool - passes `mempool_filter` (filter can't see encrypted content)
3. Transaction gets included in a block proposal
4. Block passes consensus validation - passes `consensus_filter` (still encrypted)
5. Block is accepted and added to block store
6. Transaction is decrypted in pipeline
7. Decrypted transaction executes `0xBAD::exploit::steal_funds` successfully

The filter rules are completely bypassed.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program as it represents a **significant protocol violation**:

1. **Security Control Bypass**: Transaction filters are a critical security mechanism for node operators to protect against malicious or unwanted transactions. This vulnerability completely undermines that protection for encrypted transactions.

2. **Consensus Safety Implications**: If filters are used to enforce consensus-critical invariants (e.g., blocking certain system operations during upgrades), bypassing them could lead to state divergence or consensus failures.

3. **Defense Evasion**: Malicious actors can use encryption as a cloaking mechanism to evade detection and filtering, executing arbitrary entry functions that operators explicitly configured to block.

4. **Wide Attack Surface**: Any transaction sender can create encrypted transactions without special privileges, making this vulnerability easily exploitable.

The impact is limited from Critical severity because:
- It requires encrypted transaction support to be enabled
- It doesn't directly cause fund loss or consensus breaks (unless filters are protecting against such issues)
- Node operators can disable encrypted transactions if needed

However, it fundamentally breaks the **Transaction Validation** invariant by allowing explicitly denied transactions to execute.

## Likelihood Explanation

**Likelihood: Medium-High**

**Factors Increasing Likelihood:**
- No special privileges required - any transaction sender can create encrypted transactions
- Attack is straightforward once encrypted transaction support is available
- Exploitation leaves no special traces - encrypted transactions are legitimate
- Attacker can test filter bypass offline before attacking

**Factors Decreasing Likelihood:**
- Encrypted transaction support may not be fully enabled in production
- Not all node operators configure granular entry function/module filters
- Attack requires knowledge of filter rules to be effective

However, the vulnerability exists regardless of current configuration. If Aptos promotes encrypted transactions for privacy, and node operators rely on filters for security, this becomes highly exploitable.

## Recommendation

**Immediate Fix:**

Implement filter checks on decrypted transactions before execution. Modify the pipeline to apply filters after decryption but before execution:

```rust
// In consensus/src/pipeline/decryption_pipeline_builder.rs
// After line 148, add filter check:

let decrypted_txns = encrypted_txns
    .into_par_iter()
    .zip(txn_ciphertexts)
    .map(|(mut txn, ciphertext)| {
        let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
        if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
            &decryption_key.key,
            &ciphertext,
            &digest,
            &eval_proof,
        ) {
            let (executable, nonce) = payload.unwrap();
            txn.payload_mut()
                .as_encrypted_payload_mut()
                .map(|p| {
                    p.into_decrypted(eval_proof, executable, nonce)
                        .expect("must happen")
                })
                .expect("must exist");
        } else {
            txn.payload_mut()
                .as_encrypted_payload_mut()
                .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                .expect("must exist");
        }
        txn
    })
    .collect();

// NEW: Apply filter after decryption
if let Some(block_txn_filter_config) = block_txn_filter_config {
    if block_txn_filter_config.is_enabled() {
        let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
        let denied_txns = block_transaction_filter.get_denied_block_transactions(
            block.id(),
            block.author(),
            block.epoch(),
            block.timestamp_usecs(),
            decrypted_txns.clone(),
        );
        if !denied_txns.is_empty() {
            return Err(anyhow::anyhow!(
                "Decrypted transactions denied by filter: {:?}",
                denied_txns
            ));
        }
    }
}
```

**Alternative Approaches:**

1. **Conservative Default**: Deny all encrypted transactions when entry function/module filters are configured
2. **Explicit Encryption Policy**: Require operators to explicitly allow encrypted transactions, with warnings about filter limitations
3. **Post-Execution Validation**: Add a post-execution filter check that reverts blocks containing denied transactions (requires consensus rule changes)

**Documentation Update:**

Prominently document in filter configuration that entry function and module address matchers **cannot inspect encrypted transactions** and will treat them as non-matching (effectively allowing them through Deny rules).

## Proof of Concept

```rust
// This PoC demonstrates the filter bypass
// Add to crates/aptos-transaction-filters/src/tests/

#[cfg(test)]
mod encrypted_filter_bypass_test {
    use super::*;
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
    use aptos_types::{
        chain_id::ChainId,
        transaction::{
            RawTransaction, SignedTransaction, TransactionPayload,
            encrypted_payload::EncryptedPayload,
        },
        secret_sharing::Ciphertext,
    };
    use move_core_types::account_address::AccountAddress;

    #[test]
    fn test_encrypted_transaction_bypasses_entry_function_filter() {
        // Create a filter that denies transactions calling 0x1::coin::transfer
        let filter = TransactionFilter::new(vec![
            TransactionRule::Deny(vec![
                TransactionMatcher::EntryFunction(
                    AccountAddress::ONE,
                    "coin".to_string(),
                    "transfer".to_string(),
                )
            ])
        ]);

        // Create a regular (non-encrypted) transaction calling 0x1::coin::transfer
        let sender = AccountAddress::random();
        let private_key = Ed25519PrivateKey::generate_for_testing();
        
        let entry_function = EntryFunction::new(
            ModuleId::new(AccountAddress::ONE, Identifier::new("coin").unwrap()),
            Identifier::new("transfer").unwrap(),
            vec![],
            vec![],
        );
        
        let raw_txn = RawTransaction::new(
            sender,
            0,
            TransactionPayload::EntryFunction(entry_function.clone()),
            100000,
            1,
            100000,
            ChainId::new(1),
        );
        
        let signed_txn = SignedTransaction::new(
            raw_txn.clone(),
            private_key.public_key(),
            private_key.sign(&raw_txn).unwrap(),
        );

        // Regular transaction is correctly DENIED by the filter
        assert!(!filter.allows_transaction(&signed_txn));
        
        // Now create an ENCRYPTED transaction with the same entry function
        // (In practice, this would contain the actual encrypted payload)
        let encrypted_payload = EncryptedPayload::Encrypted {
            ciphertext: Ciphertext::default(), // Placeholder
            extra_config: TransactionExtraConfig::default(),
            payload_hash: HashValue::zero(),
        };
        
        let raw_txn_encrypted = RawTransaction::new(
            sender,
            0,
            TransactionPayload::EncryptedPayload(encrypted_payload),
            100000,
            1,
            100000,
            ChainId::new(1),
        );
        
        let signed_txn_encrypted = SignedTransaction::new(
            raw_txn_encrypted.clone(),
            private_key.public_key(),
            private_key.sign(&raw_txn_encrypted).unwrap(),
        );

        // VULNERABILITY: Encrypted transaction BYPASSES the filter
        // Even though it contains the same denied entry function!
        assert!(filter.allows_transaction(&signed_txn_encrypted));
        
        // This demonstrates that encrypted transactions can evade
        // entry function and module address filters, allowing
        // explicitly denied operations to execute after decryption
    }
}
```

**Notes:**
- This PoC requires access to encrypted transaction construction utilities
- In a real attack, the encrypted payload would contain the actual entry function call
- The test demonstrates that identical operations are filtered differently based on encryption status
- Production exploitation would require proper encrypted transaction creation with valid ciphertexts

### Citations

**File:** config/src/config/transaction_filters_config.rs (L10-18)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L362-374)
```rust
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function(entry_function, address, module_name, function)
                    },
                }
            } else {
                false
            }
        },
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L405-417)
```rust
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function_module_address(entry_function, module_address)
                    },
                }
            } else {
                false
            }
        },
    }
```

**File:** types/src/transaction/encrypted_payload.rs (L82-87)
```rust
    pub fn executable_ref(&self) -> Result<TransactionExecutableRef<'_>> {
        let Self::Decrypted { executable, .. } = self else {
            bail!("Transaction is encrypted");
        };
        Ok(executable.as_ref())
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L318-326)
```rust
    // Filter out any disallowed transactions
    let mut statuses = vec![];
    let transactions =
        filter_transactions(&smp.transaction_filter_config, transactions, &mut statuses);

    // If there are no transactions left after filtering, return early
    if transactions.is_empty() {
        return statuses;
    }
```

**File:** consensus/src/round_manager.rs (L1202-1214)
```rust
        // If the proposal contains any inline transactions that need to be denied
        // (e.g., due to filtering) drop the message and do not vote for the block.
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L121-148)
```rust
        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```

**File:** consensus/src/block_storage/block_store.rs (L463-497)
```rust
        // build pipeline
        if let Some(pipeline_builder) = &self.pipeline_builder {
            let parent_block = self
                .get_block(pipelined_block.parent_id())
                .ok_or_else(|| anyhow::anyhow!("Parent block not found"))?;

            // need weak pointer to break the cycle between block tree -> pipeline block -> callback
            let block_tree = Arc::downgrade(&self.inner);
            let storage = self.storage.clone();
            let id = pipelined_block.id();
            let round = pipelined_block.round();
            let window_size = self.window_size;
            let callback = Box::new(
                move |finality_proof: WrappedLedgerInfo,
                      commit_decision: LedgerInfoWithSignatures| {
                    if let Some(tree) = block_tree.upgrade() {
                        tree.write().commit_callback(
                            storage,
                            id,
                            round,
                            finality_proof,
                            commit_decision,
                            window_size,
                        );
                    }
                },
            );
            pipeline_builder.build_for_consensus(
                &pipelined_block,
                parent_block.pipeline_futs().ok_or_else(|| {
                    anyhow::anyhow!("Parent future doesn't exist, potentially epoch ended")
                })?,
                callback,
            );
        }
```
