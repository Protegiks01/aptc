# Audit Report

## Title
Build Information Disclosure Enables Targeted DoS Against Debug-Build Validators via VM Invariant Violations

## Summary
The inspection service exposes build type information (`build_is_release_build` and `build_profile_name`) through an unauthenticated endpoint enabled by default. This allows attackers to identify validators running debug builds, which exhibit fundamentally different failure behavior in the Move VM—crashing on invariant violations instead of returning errors—enabling selective denial-of-service attacks against misconfigured production nodes.

## Finding Description

The vulnerability consists of two components that combine to create an exploitable attack surface:

**Component 1: Unauthenticated Build Information Exposure**

The inspection service exposes system and build information through the `/system_information` endpoint. [1](#0-0) 

This endpoint is enabled by default in the configuration. [2](#0-1) 

The build information includes whether the node is running a debug or release build. [3](#0-2) 

The inspection service binds to `0.0.0.0` by default with no authentication, making this information publicly accessible. [4](#0-3) 

**Component 2: Differential Failure Behavior in Move VM**

The Move VM uses special macros (`safe_unwrap!`, `safe_unwrap_err!`, `safe_assert!`) for invariant checking that behave drastically differently based on build type. [5](#0-4) 

In debug builds, these macros **panic and crash the node**. In release builds, they return errors gracefully. These macros are used extensively throughout critical VM paths including runtime reference safety checks. [6](#0-5) 

The runtime reference checker uses these macros in transaction execution paths. [7](#0-6) 

**Attack Scenario:**

1. **Reconnaissance**: Attacker queries `http://<validator-ip>:9101/system_information` for multiple validators to identify which are running debug builds
2. **Payload Crafting**: Attacker creates Move bytecode or transactions that trigger `safe_unwrap!` conditions (e.g., invalid type operations, reference safety violations that pass bytecode verification but fail at runtime)
3. **Targeted Execution**: Submit transactions to the network that will be executed by all validators
4. **Differential Impact**: Debug-build validators panic and crash; release-build validators handle the error gracefully and continue operating
5. **Consensus Disruption**: If sufficient validators are running debug builds, network liveness degrades or consensus stalls

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos Bug Bounty)

This vulnerability qualifies as **"Validator node crashes"** under the High Severity category. The impact includes:

- **Direct Impact**: Selective DoS against validators running debug builds, causing immediate node crashes
- **Consensus Impact**: If multiple validators are affected, could degrade network performance or cause temporary consensus failures
- **Network Availability**: Repeated attacks could maintain persistent DoS against misconfigured validators
- **Liveness Violation**: Breaks the critical invariant that all validators should behave deterministically for the same transactions

While debug builds in production represent a misconfiguration, the information disclosure directly enables exploitation that would otherwise require blind trial-and-error. The severity could escalate to **CRITICAL** if a significant portion of validators run debug builds, potentially causing "Total loss of liveness/network availability."

## Likelihood Explanation

**Likelihood: MEDIUM**

Factors increasing likelihood:
- Default configuration exposes the endpoint (`expose_system_information = true`)
- No authentication required for endpoint access
- Simple reconnaissance (HTTP GET requests)
- Crafting VM invariant violations is feasible for sophisticated attackers familiar with Move semantics
- Deployment errors (debug builds in production) do occur, especially in testnets or private networks

Factors decreasing likelihood:
- Production validators should use release builds (per best practices)
- Mainnet validators likely follow proper deployment procedures
- Requires attacker to understand Move VM internals to craft triggering bytecode
- The security guidelines explicitly warn against deploying debug builds [8](#0-7) 

## Recommendation

**Immediate Mitigation:**

1. **Disable by default for production**: Change the default value of `expose_system_information` to `false` for mainnet configurations, or add authentication requirements

2. **Sanitize build information**: Remove or redact `build_is_release_build` and `build_profile_name` from the exposed information, keeping only non-sensitive metadata

3. **Add access controls**: Implement authentication/authorization for the inspection service endpoints, restricting access to trusted operators only

**Long-term Fix:**

Unify the failure behavior across build types. The `safe_unwrap!` macros should not have different panic behaviors:

```rust
#[macro_export]
macro_rules! safe_unwrap {
    ($e:expr) => {{
        match $e {
            Some(x) => x,
            None => {
                let err = PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                    .with_message(format!("{}:{} (none)", file!(), line!()));
                // Always return error instead of panicking
                return Err(err);
            },
        }
    }};
}
```

**Configuration Change:**

```yaml
# config/src/config/inspection_service_config.rs
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(), // Bind to localhost only
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false,
            expose_peer_information: false,
            expose_system_information: false, // Disable by default
        }
    }
}
```

## Proof of Concept

**Step 1: Reconnaissance**

```bash
#!/bin/bash
# Identify validators running debug builds

for validator in validator1.example.com validator2.example.com validator3.example.com; do
    response=$(curl -s "http://${validator}:9101/system_information")
    build_type=$(echo "$response" | jq -r '.build_is_release_build')
    profile=$(echo "$response" | jq -r '.build_profile_name')
    
    if [ "$build_type" = "false" ] || [ "$profile" = "debug" ]; then
        echo "[!] DEBUG BUILD DETECTED: $validator (profile: $profile)"
    else
        echo "[✓] Release build: $validator"
    fi
done
```

**Step 2: Attack Payload (Conceptual Move Code)**

```move
// This would need to be crafted to trigger safe_unwrap! conditions
// Example: Create reference safety violations that pass verification but fail at runtime

module attacker::exploit {
    use std::vector;
    
    public entry fun trigger_invariant_violation() {
        // Craft operations that trigger runtime reference checks
        // This is conceptual - actual payload would need deep Move VM knowledge
        let v = vector::empty<u64>();
        // Operations that cause type safety or reference safety violations
        // triggering safe_unwrap! in runtime_ref_checks.rs
    }
}
```

**Step 3: Execution**

```bash
# Submit transaction to network
aptos move run \
    --function-id attacker::exploit::trigger_invariant_violation \
    --assume-yes

# Expected behavior:
# - Debug validators: Node crashes with panic
# - Release validators: Transaction fails gracefully with error
```

**Verification:**

Monitor validator logs and uptime:
- Debug validators will show panic traces and crash
- Release validators will log `UNKNOWN_INVARIANT_VIOLATION_ERROR` but continue operating

## Notes

This vulnerability demonstrates a critical failure in the defense-in-depth model. While deploying debug builds to production is operator error, the system should not amplify the impact by:
1. Advertising which nodes are misconfigured
2. Enabling targeted exploitation through differential failure modes

The root cause is the interaction between information disclosure and divergent error handling paths that violate the deterministic execution invariant fundamental to blockchain consensus.

### Citations

**File:** crates/aptos-inspection-service/src/server/system_information.rs (L32-42)
```rust
fn get_system_information_json() -> String {
    // Get the system and build information
    let mut system_information = aptos_telemetry::system_information::get_system_information();
    system_information.extend(build_information!());

    // Return the system information as a JSON string
    match serde_json::to_string(&system_information) {
        Ok(system_information) => system_information,
        Err(error) => format!("Failed to get system information! Error: {}", error),
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** crates/aptos-build-info/src/lib.rs (L77-79)
```rust
    // Compilation information
    build_information.insert(BUILD_IS_RELEASE_BUILD.into(), is_release().to_string());
    build_information.insert(BUILD_PROFILE_NAME.into(), get_build_profile_name());
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-169)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };
```

**File:** third_party/move/move-binary-format/src/lib.rs (L134-153)
```rust
/// A macro which should be preferred in critical runtime paths for unwrapping an option
/// if a `PartialVMError` is expected. In debug mode, this will panic. Otherwise
/// we return an Err.
#[macro_export]
macro_rules! safe_unwrap {
    ($e:expr) => {{
        match $e {
            Some(x) => x,
            None => {
                let err = PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                    .with_message(format!("{}:{} (none)", file!(), line!()));
                if cfg!(debug_assertions) {
                    panic!("{:?}", err);
                } else {
                    return Err(err);
                }
            },
        }
    }};
}
```

**File:** third_party/move/move-vm/runtime/src/runtime_ref_checks.rs (L88-97)
```rust
use crate::{
    frame::Frame, frame_type_cache::FrameTypeCache,
    native_models_for_runtime_ref_checks::NativeRuntimeRefChecksModel, LoadedFunction,
};
use fxhash::FxBuildHasher;
use hashbrown::HashMap;
use move_binary_format::{
    errors::{PartialVMError, PartialVMResult},
    safe_assert, safe_unwrap, safe_unwrap_err,
};
```

**File:** third_party/move/move-vm/runtime/src/runtime_ref_checks.rs (L688-691)
```rust
            VecPack(_, n) => {
                ref_state.pop_many_from_shadow_stack(safe_unwrap_err!((*n).try_into()))?;
                ref_state.push_non_refs_to_shadow_stack(1);
            },
```

**File:** RUST_SECURE_CODING.md (L15-21)
```markdown
### Cargo

Utilize Cargo for project management without overriding variables like `debug-assertions` and `overflow-checks`.

- **`debug-assertions`**: This variable controls whether debug assertions are enabled. Debug assertions are checks that are only present in debug builds. They are used to catch bugs during development by validating assumptions made in the code.
- **`overflow-checks`**: This variable determines whether arithmetic overflow checks are performed. In Rust, when overflow checks are enabled (which is the default in debug mode), an integer operation that overflows will cause a panic in debug builds, preventing potential security vulnerabilities like buffer overflows.

```
