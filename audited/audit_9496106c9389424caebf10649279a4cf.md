# Audit Report

## Title
Tautological First Version Verification in Transaction Backup Restore Allows Database Corruption

## Summary

The `LoadedChunk::load()` function in the transaction restore path contains a tautological verification check that compares `manifest.first_version` against itself, allowing an attacker to restore transactions at arbitrary incorrect versions, leading to database corruption. When `epoch_history` is `None` (which occurs in production db-tool operations), there is no independent validation that the manifest's claimed `first_version` matches the actual transaction version range in the cryptographic proof. [1](#0-0) 

## Finding Description

The vulnerability exists in the transaction backup restoration logic. The code constructs a `TransactionListWithProof` with `Some(manifest.first_version)` as the `first_transaction_version` parameter, then immediately verifies it using the same `Some(manifest.first_version)` value: [1](#0-0) 

The `TransactionListWithProof::verify()` method performs this check: [2](#0-1) 

This check compares `self.first_transaction_version` (which was set to `manifest.first_version` during construction) against the parameter `first_transaction_version` (also `manifest.first_version`), making it a tautology that always passes.

The cryptographic proof (`TransactionAccumulatorRangeProof`) itself does not encode version numbers—it only contains Merkle tree sibling hashes. The version number is used as an index during verification but is not independently validated. [3](#0-2) 

**Attack Path:**

1. When `epoch_history` is `None` (as in db-tool one-off restores), ledger info signature verification is skipped: [4](#0-3) [5](#0-4) 

2. An attacker provides malicious backup files containing:
   - A manifest claiming `first_version = 1000` (arbitrary incorrect version)
   - Transactions that should actually be at a different version (or fabricated transactions)
   - A crafted `LedgerInfoWithSignatures` and matching proof that are self-consistent

3. The tautological check passes, and the range proof verification uses the attacker's claimed version as the leaf index

4. Transactions are written to the database at the incorrect version without validation: [6](#0-5) 

5. The `put_transaction` method overwrites any existing data at that version without validation: [7](#0-6) 

The normal `pre_commit_validation` check that ensures version consistency is bypassed during restore operations: [8](#0-7) 

## Impact Explanation

This vulnerability breaks the **State Consistency** critical invariant: "State transitions must be atomic and verifiable via Merkle proofs."

**Severity: High to Critical**

- **Database Corruption**: An attacker can cause transactions to be restored at incorrect versions, corrupting the entire transaction accumulator and state tree
- **Consensus Impact**: If multiple validator nodes restore from malicious backups, they would have divergent database states, breaking consensus
- **Data Integrity**: Legitimate transactions could be overwritten with fabricated ones
- **Recovery Difficulty**: Database corruption from incorrect version assignments may require complex manual intervention or database rebuild

This qualifies as **High Severity** ("Significant protocol violations") or potentially **Critical Severity** if it leads to permanent state inconsistencies requiring hardfork recovery.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires:
1. Access to provide backup files to a restore operation (medium barrier)
2. The restore operation to use `epoch_history = None` (happens in production db-tool scenarios)
3. Ability to craft self-consistent ledger_info and proofs (medium complexity)

The vulnerability is **exploitable in production** through:
- Database recovery operations using db-tool
- State snapshot restoration without epoch history
- Disaster recovery scenarios where epoch history may not be available

The likelihood increases in scenarios where operators need to quickly restore from backups without full verification infrastructure.

## Recommendation

**Fix: Add independent version validation in proof verification**

The verification should not rely solely on the manifest's claimed version. Instead:

1. **Validate against database state**: Before accepting transactions, verify that `manifest.first_version` matches the expected next version in the database
2. **Require epoch history**: Make epoch history mandatory for transaction restores to ensure ledger info signatures are verified
3. **Add version range validation**: Independently verify that the proof's leaf count matches the manifest's claimed version range

**Proposed code fix for `LoadedChunk::load()`:**

```rust
// After line 167, add validation:
txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;

// NEW: Validate the proof's actual range matches manifest claims
let actual_num_txns = txn_list_with_proof.get_num_transactions() as u64;
ensure!(
    manifest.first_version + actual_num_txns == manifest.last_version + 1,
    "Proof range mismatch: manifest claims versions {}-{}, but proof contains {} transactions",
    manifest.first_version,
    manifest.last_version,
    actual_num_txns
);
```

Additionally, modify `TransactionRestoreController::new()` to require epoch history for production restores, or add a separate validation path that checks version continuity against existing database state.

## Proof of Concept

```rust
// Reproduction steps for the vulnerability:

// 1. Create a malicious backup manifest
let malicious_manifest = TransactionChunk {
    first_version: 1000,  // Claimed version (incorrect)
    last_version: 1010,   // Claimed range
    transactions: FileHandle::new(...),
    proof: FileHandle::new(...),
    format: TransactionChunkFormat::V1,
};

// 2. Provide transactions that don't belong at version 1000
let fake_transactions = vec![/* arbitrary transactions */];

// 3. Craft a self-consistent LedgerInfo and proof
// The proof will verify correctly because it uses manifest.first_version
// as the leaf index, creating circular validation

// 4. During restore with epoch_history = None:
let controller = TransactionRestoreController::new(
    opt,
    global_opt,
    storage,
    None,  // No epoch history = no signature verification
    VerifyExecutionMode::NoVerify,
);

// 5. The tautological check passes:
// self.first_transaction_version (1000) == first_transaction_version (1000) ✓

// 6. Transactions are written at version 1000 instead of their actual versions
// Database is now corrupted with incorrect version assignments
```

## Notes

The vulnerability is particularly dangerous because:
- It's subtle—the verification appears to check the version but actually doesn't
- It can be exploited without cryptographic breaks (just requires self-consistent proofs)
- It affects critical disaster recovery operations where database integrity is paramount
- The impact cascades: once one node has corrupted state, network consensus degrades

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L157-167)
```rust
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** types/src/transaction/mod.rs (L2300-2306)
```rust
        // Verify the first transaction versions match
        ensure!(
            self.get_first_transaction_version() == first_transaction_version,
            "First transaction version ({:?}) doesn't match given version ({:?}).",
            self.get_first_transaction_version(),
            first_transaction_version,
        );
```

**File:** types/src/proof/definition.rs (L575-614)
```rust
#[derive(Clone, Deserialize, Serialize)]
pub struct AccumulatorRangeProof<H> {
    /// The siblings on the left of the path from the first leaf to the root. Siblings are ordered
    /// from the bottom level to the root level.
    left_siblings: Vec<HashValue>,

    /// The sliblings on the right of the path from the last leaf to the root. Siblings are ordered
    /// from the bottom level to the root level.
    right_siblings: Vec<HashValue>,

    phantom: PhantomData<H>,
}

impl<H> AccumulatorRangeProof<H>
where
    H: CryptoHasher,
{
    /// Constructs a new `AccumulatorRangeProof` using `left_siblings` and `right_siblings`.
    pub fn new(left_siblings: Vec<HashValue>, right_siblings: Vec<HashValue>) -> Self {
        Self {
            left_siblings,
            right_siblings,
            phantom: PhantomData,
        }
    }

    /// Constructs a new `AccumulatorRangeProof` for an empty list of leaves.
    pub fn new_empty() -> Self {
        Self::new(vec![], vec![])
    }

    /// Get all the left siblngs.
    pub fn left_siblings(&self) -> &Vec<HashValue> {
        &self.left_siblings
    }

    /// Get all the right siblngs.
    pub fn right_siblings(&self) -> &Vec<HashValue> {
        &self.right_siblings
    }
```

**File:** storage/db-tool/src/restore.rs (L102-108)
```rust
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L193-228)
```rust
pub(crate) fn save_transactions_impl(
    state_store: Arc<StateStore>,
    ledger_db: Arc<LedgerDb>,
    first_version: Version,
    txns: &[Transaction],
    persisted_aux_info: &[PersistedAuxiliaryInfo],
    txn_infos: &[TransactionInfo],
    events: &[Vec<ContractEvent>],
    write_sets: &[WriteSet],
    ledger_db_batch: &mut LedgerDbSchemaBatches,
    state_kv_batches: &mut ShardedStateKvSchemaBatch,
    kv_replay: bool,
) -> Result<()> {
    for (idx, txn) in txns.iter().enumerate() {
        ledger_db.transaction_db().put_transaction(
            first_version + idx as Version,
            txn,
            /*skip_index=*/ false,
            &mut ledger_db_batch.transaction_db_batches,
        )?;
    }

    for (idx, aux_info) in persisted_aux_info.iter().enumerate() {
        PersistedAuxiliaryInfoDb::put_persisted_auxiliary_info(
            first_version + idx as Version,
            aux_info,
            &mut ledger_db_batch.persisted_auxiliary_info_db_batches,
        )?;
    }

    for (idx, txn_info) in txn_infos.iter().enumerate() {
        TransactionInfoDb::put_transaction_info(
            first_version + idx as Version,
            txn_info,
            &mut ledger_db_batch.transaction_info_db_batches,
        )?;
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L129-166)
```rust
    pub(crate) fn put_transaction(
        // TODO(grao): Consider remove &self.
        &self,
        version: Version,
        transaction: &Transaction,
        skip_index: bool,
        batch: &mut impl WriteBatch,
    ) -> Result<()> {
        if !skip_index {
            if let Some(txn) = transaction.try_as_signed_user_txn() {
                if let ReplayProtector::SequenceNumber(seq_num) = txn.replay_protector() {
                    batch.put::<OrderedTransactionByAccountSchema>(
                        &(txn.sender(), seq_num),
                        &version,
                    )?;
                }
            }
        }

        let transaction_hash = transaction.hash();

        if let Some(signed_txn) = transaction.try_as_signed_user_txn() {
            let txn_summary = IndexedTransactionSummary::V1 {
                sender: signed_txn.sender(),
                replay_protector: signed_txn.replay_protector(),
                version,
                transaction_hash,
            };
            batch.put::<TransactionSummariesByAccountSchema>(
                &(signed_txn.sender(), version),
                &txn_summary,
            )?;
        }
        batch.put::<TransactionByHashSchema>(&transaction_hash, &version)?;
        batch.put::<TransactionSchema>(&version, transaction)?;

        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L245-261)
```rust
    fn pre_commit_validation(&self, chunk: &ChunkToCommit) -> Result<()> {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["save_transactions_validation"]);

        ensure!(!chunk.is_empty(), "chunk is empty, nothing to save.");

        let next_version = self.state_store.current_state_locked().next_version();
        // Ensure the incoming committing requests are always consecutive and the version in
        // buffered state is consistent with that in db.
        ensure!(
            chunk.first_version == next_version,
            "The first version passed in ({}), and the next version expected by db ({}) are inconsistent.",
            chunk.first_version,
            next_version,
        );

        Ok(())
    }
```
