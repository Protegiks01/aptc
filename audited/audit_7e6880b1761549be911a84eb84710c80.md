# Audit Report

## Title
Invalid Configuration Propagation Leading to Runtime Panic in Local Testnet Node Initialization

## Summary
`NodeManager::new()` does not validate `NodeConfig` after `build_node_config()` returns Ok, allowing partially corrupted configurations to propagate when sanitization is bypassed. This results in runtime panics at unexpected locations during node startup.

## Finding Description

The error propagation vulnerability exists in the local testnet node initialization flow: [1](#0-0) 

When `build_node_config()` returns Ok, `NodeManager::new()` immediately passes the configuration to `new_with_config()` without any validation. The function only checks for Err variants via the `?` operator but does not verify the integrity of a successful result.

The configuration sanitization can be bypassed if `node_startup.skip_config_sanitizer` is set to true: [2](#0-1) 

This allows corrupted configurations to pass through the loading process: [3](#0-2) 

The `new_with_config()` function also performs no validation: [4](#0-3) 

Later, when the node attempts to start, it accesses configuration fields without bounds checking: [5](#0-4) 

**Attack Vector:**
1. Attacker creates malicious config file with `node_startup.skip_config_sanitizer: true` and empty `full_node_networks: []`
2. Config is loaded via `load_node_config` → `load_from_path` → `load_and_sanitize_config`
3. Sanitization is skipped, returning Ok(corrupted_config)
4. `NodeManager::new()` passes unsanitized config to `new_with_config()` without validation
5. `run_service()` calls `start_test_environment_node()` which panics accessing `full_node_networks[0]`

## Impact Explanation

This vulnerability results in **node crash on startup** (Denial of Service), qualifying as **Medium severity** under the Aptos bug bounty program's "State inconsistencies requiring intervention" category.

However, the impact is significantly limited by:
- Primary scope is local testnet environments (file path: `crates/aptos/src/node/local_testnet/node.rs`)
- Defense-in-depth exists for critical security issues (e.g., disabled mutual authentication triggers runtime panic)
- No impact on consensus, state integrity, or funds

## Likelihood Explanation

**Likelihood: Low**

Requirements for exploitation:
- Attacker must control the configuration file (filesystem access)
- Must explicitly set `skip_config_sanitizer: true` in the config
- Primarily affects local testnet/development environments
- Production deployments typically use validated configurations from trusted sources

## Recommendation

Add explicit validation in `NodeManager::new()` after `build_node_config()` returns:

```rust
pub fn new(args: &RunLocalnet, bind_to: Ipv4Addr, test_dir: PathBuf) -> Result<Self> {
    let rng = args
        .node_args
        .seed
        .map(StdRng::from_seed)
        .unwrap_or_else(StdRng::from_entropy);

    let node_config = build_node_config(
        rng,
        &args.node_args.config_path,
        &args.node_args.test_config_override,
        args.node_args.performance,
        test_dir.clone(),
    )?;
    
    // Add validation here
    validate_node_config(&node_config)?;
    
    Self::new_with_config(
        node_config,
        bind_to,
        test_dir,
        !args.node_args.no_txn_stream,
        args.node_args.txn_stream_port,
        args.node_args.no_node,
    )
}

fn validate_node_config(config: &NodeConfig) -> Result<()> {
    if config.full_node_networks.is_empty() && !config.base.role.is_validator() {
        return Err(anyhow!("Fullnode networks cannot be empty for non-validator nodes"));
    }
    // Additional validation as needed
    Ok(())
}
```

Alternatively, enforce that `skip_config_sanitizer` cannot be set to true for production configurations.

## Proof of Concept

Create a malicious `node.yaml` config file:

```yaml
node_startup:
  skip_config_sanitizer: true

base:
  role: FullNode
  
full_node_networks: []  # Empty - will cause panic

api:
  enabled: true
  address: "127.0.0.1:8080"
```

Run the local testnet with this config:
```bash
cargo run -p aptos-node -- --config-path malicious_node.yaml
```

Expected result: Panic at `start_test_environment_node` line 365 when accessing `config.full_node_networks[0].listen_address`.

**Notes:**
- This is a robustness issue rather than a critical security vulnerability
- The primary impact is on local development/testing environments
- Critical security misconfigurations (e.g., disabled mutual authentication) are caught by runtime checks that panic before the node becomes operational
- Production validator deployments should use properly validated configurations from trusted sources

### Citations

**File:** crates/aptos/src/node/local_testnet/node.rs (L117-139)
```rust
    pub fn new(args: &RunLocalnet, bind_to: Ipv4Addr, test_dir: PathBuf) -> Result<Self> {
        let rng = args
            .node_args
            .seed
            .map(StdRng::from_seed)
            .unwrap_or_else(StdRng::from_entropy);

        let node_config = build_node_config(
            rng,
            &args.node_args.config_path,
            &args.node_args.test_config_override,
            args.node_args.performance,
            test_dir.clone(),
        )?;
        Self::new_with_config(
            node_config,
            bind_to,
            test_dir,
            !args.node_args.no_txn_stream,
            args.node_args.txn_stream_port,
            args.node_args.no_node,
        )
    }
```

**File:** crates/aptos/src/node/local_testnet/node.rs (L141-176)
```rust
    pub fn new_with_config(
        mut node_config: NodeConfig,
        bind_to: Ipv4Addr,
        test_dir: PathBuf,
        run_txn_stream: bool,
        txn_stream_port: u16,
        no_node: bool,
    ) -> Result<Self> {
        eprintln!();

        // Enable the grpc stream on the node if we will run a txn stream service.
        node_config.indexer_grpc.enabled = run_txn_stream;
        node_config.indexer_grpc.use_data_service_interface = run_txn_stream;
        node_config.indexer_grpc.address.set_port(txn_stream_port);

        node_config.indexer_table_info.table_info_service_mode = match run_txn_stream {
            // Localnet should be responsible for backup or restore of table info tables.
            true => aptos_config::config::TableInfoServiceMode::IndexingOnly,
            false => aptos_config::config::TableInfoServiceMode::Disabled,
        };

        // Bind to the requested address.
        node_config.api.address.set_ip(IpAddr::V4(bind_to));
        node_config.indexer_grpc.address.set_ip(IpAddr::V4(bind_to));
        node_config.admin_service.address = bind_to.to_string();
        node_config.inspection_service.address = bind_to.to_string();
        node_config.indexer_db_config.enable_event = true;
        node_config.indexer_db_config.enable_statekeys = true;
        node_config.indexer_db_config.enable_transaction = true;

        Ok(NodeManager {
            config: node_config,
            test_dir,
            no_node,
        })
    }
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** aptos-node/src/lib.rs (L294-337)
```rust
pub fn load_node_config<R>(
    config_path: &Option<PathBuf>,
    test_config_override_path: &Option<PathBuf>,
    test_dir: &Path,
    random_ports: bool,
    enable_lazy_mode: bool,
    enable_performance_mode: bool,
    framework: &ReleaseBundle,
    rng: R,
) -> anyhow::Result<NodeConfig>
where
    R: rand::RngCore + rand::CryptoRng,
{
    // The validator builder puts the first node in the 0 directory
    let validator_config_path = test_dir.join("0").join("node.yaml");

    let config = if validator_config_path.exists() {
        NodeConfig::load_from_path(&validator_config_path)
            .map_err(|error| anyhow!("Unable to load config: {:?}", error))?
    } else {
        // Create a test only config for a single validator node.
        let config = create_single_node_test_config(
            config_path,
            test_config_override_path,
            test_dir,
            random_ports,
            enable_lazy_mode,
            enable_performance_mode,
            framework,
            rng,
        )?;
        if let Some(test_config_override_path) = test_config_override_path {
            println!(
                "\tMerged default config with override from path: {:?}",
                test_config_override_path
            );
        }
        if let Some(config_path) = config_path {
            println!("\tUsed user-provided config from path: {:?}", config_path);
        }
        config
    };

    Ok(config)
```

**File:** aptos-node/src/lib.rs (L363-366)
```rust
    println!(
        "\tAptosnet fullnode network endpoint: {}",
        &config.full_node_networks[0].listen_address
    );
```
