# Audit Report

## Title
Reserved Address as Royalty Payee Causes Permanent Token Sale Denial of Service

## Summary
The Token V1 module allows token creators to set reserved system addresses (0x0, 0x1, 0x3) as royalty payee addresses during token creation or mutation. This causes all marketplace sales to fail permanently when royalty payment is attempted, as account creation is forbidden for reserved addresses.

## Finding Description

The vulnerability exists in the royalty validation logic within the Token V1 framework. The `create_royalty` function has a commented-out validation check that would have prevented non-existent or invalid addresses from being set as royalty payees. [1](#0-0) 

The commented-out line at 1004 explicitly shows that validation for payee address existence was removed with a question about "stateless accounts". Without this check, any address—including reserved system addresses—can be set as the royalty payee.

When tokens are created, the `create_tokendata` function accepts a `royalty_payee_address` parameter and passes it directly to `create_royalty` without validation: [2](#0-1) 

Similarly, the `mutate_tokendata_royalty` function allows changing royalty configuration post-creation if royalty is mutable, also without validating the payee address: [3](#0-2) 

**Attack Propagation Path:**

1. A token creator calls `create_tokendata` or `mutate_tokendata_royalty` with `royalty_payee_address` set to a reserved address (@vm_reserved/0x0, @aptos_framework/0x1, or @aptos_token/0x3)

2. The token is successfully created/modified with the invalid royalty payee

3. When a buyer attempts to purchase the token through any marketplace implementation, the payment settlement process calls `aptos_account::deposit_coins` to pay royalties: [4](#0-3) 

4. The `deposit_coins` function attempts to auto-create the account if it doesn't exist: [5](#0-4) 

5. However, `create_account_if_does_not_exist` explicitly forbids creating accounts at reserved addresses: [6](#0-5) 

6. The same check exists in the friend function `create_account`: [7](#0-6) 

7. The transaction aborts with error code ECANNOT_RESERVED_ADDRESS (error code 5): [8](#0-7) 

8. **All subsequent sale attempts for this token will fail permanently** with no recovery mechanism if royalty mutability is disabled.

## Impact Explanation

This is a **Medium Severity** vulnerability per the Aptos bug bounty criteria:

**State Inconsistencies Requiring Intervention:** Tokens exist in an invalid state with reserved addresses as royalty payees. These addresses cannot receive payments by fundamental Aptos design, yet the framework allows them to be set. If `mutability_config.royalty = false`, this state cannot be corrected without governance intervention.

**Limited Funds Loss:** While no direct theft occurs, token holders cannot sell their assets through any marketplace, resulting in effective loss of economic value through denied liquidity. This constitutes "limited funds loss or manipulation" as the tokens become effectively illiquid.

**Denial of Service at Application Layer:** This completely blocks all marketplace sales for affected tokens. Unlike network DoS (which is out of scope), this is an application-layer vulnerability where the core framework allows invalid state that breaks ecosystem applications.

This vulnerability breaks the security guarantee that token metadata should maintain valid, functional configurations. The commented-out validation at line 1003-1004 indicates this was a known consideration that was not properly addressed.

## Likelihood Explanation

**Likelihood: Medium to High**

**Ease of Exploitation:**
- Requires only token creator privileges (available to any network participant)
- Single transaction to set malicious royalty payee
- Works on both token creation and mutation (if royalty is mutable)
- No special tooling or complex choreography required

**Attack Scenarios:**
1. **Malicious Creator:** Intentionally sabotages secondary market trading
2. **Griefing Attack:** Creator sets reserved address to deny liquidity to token holders
3. **Accidental Misconfiguration:** Developer mistakenly uses 0x0 or reserved test addresses

**Attacker Requirements:**
- Ability to create tokens (universally available)
- Knowledge of reserved addresses (publicly documented: 0x0, 0x1, 0x3)

The likelihood is elevated because the validation was explicitly removed (commented out) without proper replacement logic to handle reserved addresses specifically, and no client-side warnings exist to prevent this configuration.

## Recommendation

Restore validation in the `create_royalty` function to explicitly reject reserved addresses while still supporting stateless accounts:

```move
public fun create_royalty(royalty_points_numerator: u64, royalty_points_denominator: u64, payee_address: address): Royalty {
    assert!(royalty_points_numerator <= royalty_points_denominator, error::invalid_argument(EINVALID_ROYALTY_NUMERATOR_DENOMINATOR));
    
    // Explicitly forbid reserved addresses as royalty payees
    assert!(
        payee_address != @vm_reserved && payee_address != @aptos_framework && payee_address != @aptos_token,
        error::invalid_argument(ERESERVED_ADDRESS_NOT_ALLOWED_AS_ROYALTY_PAYEE)
    );
    
    Royalty {
        royalty_points_numerator,
        royalty_points_denominator,
        payee_address
    }
}
```

Add corresponding error constant:
```move
const ERESERVED_ADDRESS_NOT_ALLOWED_AS_ROYALTY_PAYEE: u64 = [next_available_error_code];
```

## Proof of Concept

```move
#[test(creator = @0xcafe, buyer = @0xbeef)]
fun test_reserved_address_royalty_dos(creator: &signer, buyer: &signer) {
    // Setup accounts
    account::create_account_for_test(signer::address_of(creator));
    account::create_account_for_test(signer::address_of(buyer));
    
    // Create collection
    create_collection(
        creator,
        string::utf8(b"Test Collection"),
        string::utf8(b"Description"),
        string::utf8(b"https://test.com"),
        1000,
        vector<bool>[false, false, false]
    );
    
    // Create token with reserved address as royalty payee (0x0)
    let token_data_id = create_tokendata(
        creator,
        string::utf8(b"Test Collection"),
        string::utf8(b"Test Token"),
        string::utf8(b"Description"),
        100,
        string::utf8(b"https://test.com/token"),
        @vm_reserved, // Reserved address as royalty payee
        100,
        10, // 10% royalty
        TokenMutabilityConfig {
            maximum: false,
            uri: false,
            royalty: false, // Cannot be changed
            description: false,
            properties: false
        },
        vector<String>[],
        vector<vector<u8>>[],
        vector<String>[]
    );
    
    // Mint token
    let token_id = mint_token(creator, token_data_id, 1);
    
    // Attempt marketplace sale - this will abort with ECANNOT_RESERVED_ADDRESS
    // when trying to deposit royalty to reserved address
    let price = 1000;
    let royalty_amount = (price * 10) / 100; // 10% royalty = 100
    
    // This call will fail when deposit_coins tries to create account at 0x0
    aptos_account::deposit_coins<AptosCoin>(@vm_reserved, coin::withdraw<AptosCoin>(buyer, royalty_amount));
}
```

**Notes:**

This vulnerability is in the core Aptos Framework (`aptos-move/framework/aptos-token/`), making it applicable to all marketplace implementations, not just the example code. Any marketplace or token sale mechanism that attempts to pay royalties to the configured payee address will experience this failure. The validation was explicitly removed (as evidenced by the comment) without proper replacement logic to reject reserved addresses that fundamentally cannot receive payments in Aptos.

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L831-849)
```text
    public fun mutate_tokendata_royalty(creator: &signer, token_data_id: TokenDataId, royalty: Royalty) acquires Collections {
        assert_tokendata_exists(creator, token_data_id);

        let all_token_data = &mut Collections[token_data_id.creator].token_data;
        let token_data = all_token_data.borrow_mut(token_data_id);
        assert!(token_data.mutability_config.royalty, error::permission_denied(EFIELD_NOT_MUTABLE));

        token_event_store::emit_token_royalty_mutate_event(
            creator,
            token_data_id.collection,
            token_data_id.name,
            token_data.royalty.royalty_points_numerator,
            token_data.royalty.royalty_points_denominator,
            token_data.royalty.payee_address,
            royalty.royalty_points_numerator,
            royalty.royalty_points_denominator,
            royalty.payee_address
        );
        token_data.royalty = royalty;
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1001-1009)
```text
    public fun create_royalty(royalty_points_numerator: u64, royalty_points_denominator: u64, payee_address: address): Royalty {
        assert!(royalty_points_numerator <= royalty_points_denominator, error::invalid_argument(EINVALID_ROYALTY_NUMERATOR_DENOMINATOR));
        // Question[Orderless]: Is it okay to remove this check to accommodate stateless accounts?
        // assert!(account::exists_at(payee_address), error::invalid_argument(EROYALTY_PAYEE_ACCOUNT_DOES_NOT_EXIST));
        Royalty {
            royalty_points_numerator,
            royalty_points_denominator,
            payee_address
        }
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1299-1309)
```text
        let token_data = TokenData {
            maximum,
            largest_property_version: 0,
            supply: 0,
            uri,
            royalty: create_royalty(royalty_points_numerator, royalty_points_denominator, royalty_payee_address),
            name,
            description,
            default_properties: property_map::new(property_keys, property_values, property_types),
            mutability_config: token_mutate_config,
        };
```

**File:** aptos-move/move-examples/marketplace/sources/coin_listing.move (L499-502)
```text
        if (royalty_charge != 0) {
            let royalty = coin::extract(&mut coins, royalty_charge);
            aptos_account::deposit_coins(royalty_addr, royalty);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L131-132)
```text
        if (!account::exists_at(to)) {
            create_account(to);
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L178-178)
```text
    const ECANNOT_RESERVED_ADDRESS: u64 = 5;
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L276-283)
```text
    public fun create_account_if_does_not_exist(account_address: address) {
        if (!resource_exists_at(account_address)) {
            assert!(
                account_address != @vm_reserved && account_address != @aptos_framework && account_address != @aptos_token,
                error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
            );
            create_account_unchecked(account_address);
        }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L289-296)
```text
    public(friend) fun create_account(new_address: address): signer {
        // there cannot be an Account resource under new_addr already.
        assert!(!exists<Account>(new_address), error::already_exists(EACCOUNT_ALREADY_EXISTS));
        // NOTE: @core_resources gets created via a `create_account` call, so we do not include it below.
        assert!(
            new_address != @vm_reserved && new_address != @aptos_framework && new_address != @aptos_token,
            error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
        );
```
