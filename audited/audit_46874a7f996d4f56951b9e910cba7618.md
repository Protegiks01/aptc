# Audit Report

## Title
Transaction Filter Validation Bypass: Module-Only EntryFunctionFilter Matches All Transactions

## Summary
A logic error in `EntryFunctionFilter::matches()` causes filters configured with only a module name to bypass validation and match ALL transactions instead of filtering by the specified module. This allows malicious filter configurations to exploit the discrepancy between validation (which passes) and execution (which skips the module check), leading to unintended transaction data stripping in the indexer-grpc service.

## Finding Description

The Aptos indexer-grpc transaction filter system uses a `Filterable` trait with two critical methods: `validate_state()` for configuration validation and `matches()` for execution-time filtering. A logic error creates a dangerous discrepancy between these two phases. [1](#0-0) 

The validation logic correctly requires at least one field (address, module, or function) to be set. However, the execution logic contains a critical flaw: [2](#0-1) 

At line 196, the condition `if self.address.is_some() || self.function.is_some()` determines whether to check the module. This is incorrect because:

1. **When only `module` is set** (address=None, function=None):
   - Line 192-194: Function check passes (Option<String> matches anything when None)
   - Line 196: Condition evaluates to `false || false = false`
   - Lines 197-207: Module validation block is **completely skipped**
   - Line 210: Returns `true` - **matches ALL transactions**

2. **Security Impact**: The indexer-grpc-data-service uses these filters to determine which transactions should have their sensitive data stripped (payload, signature, events, changes): [3](#0-2) 

When a filter incorrectly matches all transactions, it causes widespread data stripping of legitimate transactions that should not be filtered.

**Attack Scenario:**
1. Attacker creates `EntryFunctionFilter` with only `module: Some("target_module")`
2. Validation passes (at least one field is set)
3. Filter is deployed to indexer-grpc service
4. During execution, the module check is skipped (line 196 condition is false)
5. Filter matches ALL transactions regardless of their actual module
6. All matched transactions have their data stripped inappropriately
7. Downstream consumers receive incomplete transaction data, causing service degradation

**Root Cause:** Line 196 should check `self.address.is_some() || self.module.is_some()` instead of `self.address.is_some() || self.function.is_some()` to ensure the module validation block executes when a module filter is specified.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program as it represents a "Significant protocol violation":

1. **Transaction Filtering Bypass**: The core security guarantee of transaction filters—that they match only intended transactions—is violated. A filter meant to match specific modules matches everything.

2. **Data Integrity Violation**: Legitimate transactions have their payload, signatures, events, and state changes stripped when they should be preserved, violating the data integrity guarantee of the indexer service.

3. **Service Availability Impact**: Downstream indexer consumers relying on complete transaction data experience service degradation or failures when receiving stripped transactions.

4. **Wide Attack Surface**: The indexer-grpc service is a critical infrastructure component serving multiple external consumers. Any misconfigured filter affects all connected clients.

While this does not directly impact consensus or cause loss of funds, it violates the transaction filtering security policy and can cause significant operational disruption to the indexer infrastructure.

## Likelihood Explanation

**HIGH likelihood** of occurrence:

1. **Easy to Trigger**: Creating a filter with only a module name is a natural use case that developers might attempt when trying to filter transactions by module.

2. **Validation Passes**: The misconfigured filter passes validation checks, providing no warning to the operator that something is wrong.

3. **Silent Failure**: The bug causes over-matching rather than errors, making it difficult to detect until downstream systems complain about missing data.

4. **Existing Test Evidence**: The codebase contains a test case that exercises this exact scenario: [4](#0-3) 

This test creates a filter with only module set and expects it to match. The test likely passes for the wrong reason—the filter matches everything, not just the specified module.

## Recommendation

**Fix the condition at line 196** to check for module instead of function:

```rust
impl Filterable<EntryFunctionId> for EntryFunctionFilter {
    #[inline]
    fn matches(&self, module_id: &EntryFunctionId) -> bool {
        if !self.function.matches(&module_id.name) {
            return false;
        }

        // FIX: Changed from self.function.is_some() to self.module.is_some()
        if self.address.is_some() || self.module.is_some() {
            if let Some(module) = &module_id.module.as_ref() {
                if !(self
                    .get_standardized_address()
                    .matches(&standardize_address(&module.address))
                    && self.module.matches(&module.name))
                {
                    return false;
                }
            } else {
                return false;
            }
        }

        true
    }
}
```

**Additional Validation**: Add integration tests that verify module-only filters match only transactions with the specified module and reject transactions with different modules.

## Proof of Concept

```rust
#[cfg(test)]
mod vulnerability_poc {
    use super::*;
    use aptos_protos::transaction::v1::{EntryFunctionId, MoveModuleId};
    
    #[test]
    fn test_module_only_filter_bypass() {
        // Create a filter with ONLY module set to "malicious_module"
        let filter = EntryFunctionFilterBuilder::default()
            .module("malicious_module")
            .build()
            .unwrap();
        
        // Validation should pass (and does)
        assert!(filter.is_valid().is_ok());
        
        // Create an EntryFunctionId with a DIFFERENT module "legitimate_module"
        let entry_function = EntryFunctionId {
            module: Some(MoveModuleId {
                address: "0x1".to_string(),
                name: "legitimate_module".to_string(),
            }),
            name: "transfer".to_string(),
        };
        
        // BUG: Filter matches even though modules are different!
        // Expected: false (modules don't match)
        // Actual: true (module check is skipped entirely)
        assert_eq!(filter.matches(&entry_function), true);
        
        // This demonstrates the vulnerability: a filter configured to match
        // only "malicious_module" incorrectly matches "legitimate_module"
        // In the indexer service, this would cause legitimate_module transactions
        // to have their data stripped inappropriately
    }
    
    #[test]
    fn test_correct_behavior_with_address_and_module() {
        // When address is also set, the module check IS performed
        let filter = EntryFunctionFilterBuilder::default()
            .address("0x1")
            .module("specific_module")
            .build()
            .unwrap();
        
        let matching_entry = EntryFunctionId {
            module: Some(MoveModuleId {
                address: "0x1".to_string(),
                name: "specific_module".to_string(),
            }),
            name: "transfer".to_string(),
        };
        
        let non_matching_entry = EntryFunctionId {
            module: Some(MoveModuleId {
                address: "0x1".to_string(),
                name: "different_module".to_string(),
            }),
            name: "transfer".to_string(),
        };
        
        // These work correctly because address is set
        assert_eq!(filter.matches(&matching_entry), true);
        assert_eq!(filter.matches(&non_matching_entry), false);
    }
}
```

**Notes:**
This vulnerability exists in the indexer-grpc transaction filter subsystem, which is part of the Aptos ecosystem infrastructure for serving blockchain data to external consumers. While it does not directly impact consensus or on-chain execution, it violates the security policy that transaction filters should accurately match only intended transactions, causing incorrect data stripping and service disruption.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L183-188)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.address.is_none() && self.module.is_none() && self.function.is_none() {
            return Err(anyhow!("At least one of address, name or function must be set").into());
        };
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L190-211)
```rust
    #[inline]
    fn matches(&self, module_id: &EntryFunctionId) -> bool {
        if !self.function.matches(&module_id.name) {
            return false;
        }

        if self.address.is_some() || self.function.is_some() {
            if let Some(module) = &module_id.module.as_ref() {
                if !(self
                    .get_standardized_address()
                    .matches(&standardize_address(&module.address))
                    && self.module.matches(&module.name))
                {
                    return false;
                }
            } else {
                return false;
            }
        }

        true
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L924-954)
```rust
fn strip_transactions(
    transactions: Vec<Transaction>,
    txns_to_strip_filter: &BooleanTransactionFilter,
) -> (Vec<Transaction>, usize) {
    let mut stripped_count = 0;

    let stripped_transactions: Vec<Transaction> = transactions
        .into_iter()
        .map(|mut txn| {
            // Note: `is_allowed` means the txn matches the filter, in which case
            // we strip it.
            if txns_to_strip_filter.matches(&txn) {
                stripped_count += 1;
                if let Some(info) = txn.info.as_mut() {
                    info.changes = vec![];
                }
                if let Some(TxnData::User(user_transaction)) = txn.txn_data.as_mut() {
                    user_transaction.events = vec![];
                    if let Some(utr) = user_transaction.request.as_mut() {
                        // Wipe the payload and signature.
                        utr.payload = None;
                        utr.signature = None;
                    }
                }
            }
            txn
        })
        .collect();

    (stripped_transactions, stripped_count)
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L1160-1199)
```rust
    fn test_transactions_are_stripped_correctly_module_name(is_orderless_txn: bool) {
        let txn = create_test_transaction(
            MODULE_ADDRESS.to_string(),
            MODULE_NAME.to_string(),
            FUNCTION_NAME.to_string(),
            is_orderless_txn,
        );
        // Testing filter with only module set
        let filter = BooleanTransactionFilter::new_or(vec![BooleanTransactionFilter::from(
            APIFilter::UserTransactionFilter(
                UserTransactionFilterBuilder::default()
                    .payload(
                        UserTransactionPayloadFilterBuilder::default()
                            .function(
                                EntryFunctionFilterBuilder::default()
                                    .module(MODULE_NAME.to_string())
                                    .build()
                                    .unwrap(),
                            )
                            .build()
                            .unwrap(),
                    )
                    .build()
                    .unwrap(),
            ),
        )]);

        let (filtered_txns, num_stripped) = strip_transactions(vec![txn.clone()], &filter);
        assert_eq!(num_stripped, 1);
        assert_eq!(filtered_txns.len(), 1);
        let txn = filtered_txns.first().unwrap();
        let user_transaction = match &txn.txn_data {
            Some(TxnData::User(user_transaction)) => user_transaction,
            _ => panic!("Expected user transaction"),
        };
        assert_eq!(user_transaction.request.as_ref().unwrap().payload, None);
        assert_eq!(user_transaction.request.as_ref().unwrap().signature, None);
        assert_eq!(user_transaction.events.len(), 0);
        assert_eq!(txn.info.as_ref().unwrap().changes.len(), 0);
    }
```
