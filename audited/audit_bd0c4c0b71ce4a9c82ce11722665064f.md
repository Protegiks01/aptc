# Audit Report

## Title
Config Sanitizer Bypass via Missing Chain ID Allows Unsafe SafetyRulesConfig on Mainnet Validators

## Summary
When the genesis transaction cannot be loaded or parsed, the chain ID extraction fails and the config sanitizer continues with `chain_id = None`. This causes all mainnet-specific security checks in `SafetyRulesConfig::sanitize()` to be skipped, allowing validators to start with unsafe configurations such as InMemoryStorage backend or test configurations that would normally be blocked for mainnet validators.

## Finding Description

The vulnerability exists in the interaction between the config loading pipeline and the SafetyRulesConfig sanitizer. When a validator's configuration is loaded during node startup, the following flow occurs: [1](#0-0) 

The `parse_serialized_config()` function uses serde to deserialize YAML configs. SafetyRulesConfig is annotated with `#[serde(default)]`, which causes missing fields to be filled with default values: [2](#0-1) 

The default implementation provides unsafe values for production use: [3](#0-2) 

Critically, the default backend is `SecureBackend::InMemoryStorage`, which stores all safety rules data in RAM with no persistence. The sanitizer is supposed to catch this: [4](#0-3) 

However, ALL mainnet security checks are wrapped inside an `if let Some(chain_id) = chain_id` block: [5](#0-4) 

When the genesis transaction cannot be loaded, the chain ID extraction fails but the node startup continues with `chain_id = None`: [6](#0-5) 

With `chain_id = None`, the sanitizer skips all mainnet-specific checks, allowing:
1. InMemoryStorage backend (unsafe - data lost on restart)
2. Non-Local service types (slower performance)
3. Test configurations with attacker-controlled keys

**Attack Scenario:**

1. Attacker/operator creates a validator config with a minimal or missing `consensus.safety_rules` section
2. Serde injects default values including `backend: InMemoryStorage` and potentially a test config
3. Genesis file is missing, corrupted, or path misconfigured in the config
4. Node starts, `get_chain_id()` fails, continues with `chain_id = None`
5. `SafetyRulesConfig::sanitize()` skips all mainnet checks
6. If test config is provided, safety rules storage is initialized with test values: [7](#0-6) 

7. Validator runs with compromised safety rules (attacker-controlled keys if test config used, or volatile in-memory storage)

## Impact Explanation

This vulnerability has **Critical Severity** impact because it can lead to **Consensus Safety Violations**:

1. **InMemoryStorage Attack**: If a validator uses InMemoryStorage and the node crashes or restarts, all safety rules state is lost. This includes:
   - Last voted round
   - Highest timeout round  
   - Preferred round
   - Epoch information

   Without this state, the validator may double-vote on different blocks at the same round, violating consensus safety guarantees and potentially causing chain splits.

2. **Test Config Attack**: If an attacker provides a test configuration with their own consensus keys, they can:
   - Sign votes with arbitrary keys
   - Vote on malicious blocks
   - Participate in consensus with unauthorized credentials
   - Potentially cause consensus failures or safety violations

3. **Service Type Attack**: If a non-Local service type is used when InMemoryStorage is enabled, performance degradation could affect consensus liveness.

The genesis file being missing is not an unrealistic scenario - it can occur due to:
- Configuration errors during validator setup
- File system corruption
- Incorrect deployment scripts
- Deliberate manipulation by a compromised operator

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires two conditions:
1. Missing or minimal safety_rules config section (relies on operator error or deliberate manipulation)
2. Missing or corrupted genesis file (can occur through misconfiguration or filesystem issues)

While production validators should have proper configurations, the defense-in-depth principle requires that the sanitizer catch ALL unsafe configurations regardless of genesis file availability. The current implementation creates a silent bypass that could be exploited during:
- Initial validator setup with configuration errors
- Config updates that accidentally remove critical fields
- Disaster recovery scenarios where genesis files are lost
- Malicious insider attacks

## Recommendation

The SafetyRulesConfig sanitizer should fail explicitly when validating a validator configuration if the chain ID cannot be determined. For critical security checks, the absence of chain ID should be treated as an error, not silently bypassed.

**Recommended Fix:**

```rust
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        // If the node is not a validator, there's nothing to be done
        if !node_type.is_validator() {
            return Ok(());
        }

        // For validators, chain_id must be available for security checks
        let chain_id = chain_id.ok_or_else(|| {
            Error::ConfigSanitizerFailed(
                sanitizer_name.clone(),
                "Cannot validate SafetyRulesConfig for validator without chain ID. \
                 Ensure genesis file is properly configured.".to_string(),
            )
        })?;

        // Verify that the secure backend is appropriate for mainnet validators
        if chain_id.is_mainnet()
            && node_type.is_validator()
            && safety_rules_config.backend.is_in_memory()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The secure backend should not be set to in memory storage in mainnet!"
                    .to_string(),
            ));
        }

        // Verify that the safety rules service is set to local for optimal performance
        if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
            ));
        }

        // Verify that the safety rules test config is not enabled in mainnet
        if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The safety rules test config should not be used in mainnet!".to_string(),
            ));
        }

        Ok(())
    }
}
```

Additionally, consider adding validation for `initial_safety_rules_config` to ensure it's properly configured for validators.

## Proof of Concept

To reproduce this vulnerability:

1. Create a minimal validator config file (`vulnerable_validator.yaml`):
```yaml
base:
  role: validator
  waypoint:
    from_file: /nonexistent/waypoint.txt  # Intentionally wrong path

consensus:
  safety_rules:
    test:
      author: "0xdeadbeef"
      consensus_key:
        from_config: "test_key_data"
      waypoint: 
        from_config: "0:0000000000000000000000000000000000000000000000000000000000000000"
    # Note: backend field is MISSING, will default to InMemoryStorage
    # Note: service field is MISSING, will default to Local

execution:
  genesis_file_location: /nonexistent/genesis.blob  # Intentionally wrong path
```

2. Attempt to load this config through the NodeConfigLoader:

```rust
use aptos_config::config::{NodeConfigLoader, NodeType};
use aptos_types::chain_id::ChainId;

let loader = NodeConfigLoader::new("vulnerable_validator.yaml");
let result = loader.load_and_sanitize_config();

// Expected: Should fail with ConfigSanitizerFailed error
// Actual: Config loads successfully with unsafe defaults because chain_id = None
```

3. Verify that the sanitizer was bypassed by checking the resulting config has InMemoryStorage backend and test config despite being a "mainnet" validator (chain ID couldn't be determined).

## Notes

The vulnerability demonstrates a critical failure in defense-in-depth: when one validation mechanism (genesis file loading) fails, it should not cause downstream validation mechanisms (config sanitizer) to silently degrade. The current implementation treats missing chain ID as "don't validate" rather than "fail validation," which violates secure-by-default principles.

### Citations

**File:** config/src/config/persistable_config.rs (L53-55)
```rust
    fn parse_serialized_config(serialized_config: &str) -> Result<Self, Error> {
        serde_yaml::from_str(serialized_config).map_err(|e| Error::Yaml("config".to_string(), e))
    }
```

**File:** config/src/config/safety_rules_config.rs (L23-34)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct SafetyRulesConfig {
    pub backend: SecureBackend,
    pub logger: LoggerConfig,
    pub service: SafetyRulesService,
    pub test: Option<SafetyRulesTestConfig>,
    // Read/Write/Connect networking operation timeout in milliseconds.
    pub network_timeout_ms: u64,
    pub enable_cached_safety_data: bool,
    pub initial_safety_rules_config: InitialSafetyRulesConfig,
}
```

**File:** config/src/config/safety_rules_config.rs (L36-49)
```rust
impl Default for SafetyRulesConfig {
    fn default() -> Self {
        Self {
            backend: SecureBackend::InMemoryStorage,
            logger: LoggerConfig::default(),
            service: SafetyRulesService::Local,
            test: None,
            // Default value of 30 seconds for a timeout
            network_timeout_ms: 30_000,
            enable_cached_safety_data: true,
            initial_safety_rules_config: InitialSafetyRulesConfig::None,
        }
    }
}
```

**File:** config/src/config/safety_rules_config.rs (L85-113)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }

            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }

            // Verify that the safety rules test config is not enabled in mainnet
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
        }
```

**File:** config/src/config/node_config_loader.rs (L117-123)
```rust
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
    }
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L28-43)
```rust
    if let Some(test_config) = &config.test {
        let author = test_config.author;
        let consensus_private_key = test_config
            .consensus_key
            .as_ref()
            .expect("Missing consensus key in test config")
            .private_key();
        let waypoint = test_config.waypoint.expect("No waypoint in config");

        PersistentSafetyStorage::initialize(
            internal_storage,
            author,
            consensus_private_key,
            waypoint,
            config.enable_cached_safety_data,
        )
```
