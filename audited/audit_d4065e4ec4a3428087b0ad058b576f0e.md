# Audit Report

## Title
ConfigSanitizer Incomplete Validation Allows Identity and Peer Information Disclosure on Mainnet Validators

## Summary
The `ConfigSanitizer` for `InspectionServiceConfig` only validates that `expose_configuration` is disabled for mainnet validators, but fails to check `expose_identity_information`, `expose_peer_information`, and `expose_system_information` flags. Since these endpoints are enabled by default, mainnet validators inadvertently expose sensitive network topology and identity information that could be used for reconnaissance and targeted attacks.

## Finding Description

The vulnerability exists in the `ConfigSanitizer::sanitize()` implementation for `InspectionServiceConfig`. The sanitizer performs security validation to ensure mainnet validators don't expose sensitive operational information, but the implementation is incomplete. [1](#0-0) 

The sanitizer only checks the `expose_configuration` flag, while completely ignoring three other exposure flags. The default configuration sets these unchecked flags to `true`: [2](#0-1) 

This means mainnet validators using default configurations will expose:

**Identity Information Endpoint** - Exposes validator and fullnode network peer IDs: [3](#0-2) [4](#0-3) 

**Peer Information Endpoint** - Exposes comprehensive network topology data including connected peers, trusted validator set, connection metadata, state sync information, and internal client state: [5](#0-4) 

The existence of the sanitizer check for `expose_configuration` demonstrates the security requirement that mainnet validators should not expose operational information. However, the implementation inconsistently protects only one of four exposure vectors.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program for the following reasons:

1. **Information Disclosure**: Mainnet validators expose network topology, peer relationships, validator identities, and operational state that should remain protected.

2. **Attack Enablement**: The disclosed information enables:
   - **Targeted DDoS attacks**: Attackers can identify specific validator peer IDs and network addresses to target
   - **Network topology mapping**: Understanding validator connectivity patterns for sophisticated attacks
   - **Reconnaissance**: Gathering intelligence about validator infrastructure and configurations
   - **Validator set analysis**: Identifying trust relationships and network structure

3. **Default-Unsafe Configuration**: Since `expose_identity_information=true` and `expose_peer_information=true` by default, any mainnet validator that doesn't explicitly disable these flags is vulnerable. The sanitizer should enforce this automatically.

4. **Policy Violation**: The incomplete sanitizer represents a gap between intended security policy (protecting mainnet validator operational data) and actual enforcement.

While this doesn't directly compromise funds or consensus, it violates operational security best practices and enables attack vectors against critical network infrastructure.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to occur because:

1. **Default Configuration Issue**: The defaults expose the endpoints (`expose_identity_information=true`, `expose_peer_information=true`)
2. **Incomplete Validation**: The sanitizer fails to catch this configuration on mainnet validators
3. **No Warning**: Validators receive no error or warning that they're exposing sensitive information
4. **Easy Exploitation**: Attackers simply need to HTTP GET `http://validator-ip:9101/identity_information` or `/peer_information`
5. **Broad Attack Surface**: Any mainnet validator running with default or partially-configured inspection service settings is vulnerable

The ConfigOptimizer only enables all endpoints for non-mainnet chains, but it respects existing configuration and doesn't force-disable them on mainnet: [6](#0-5) 

## Recommendation

Extend the `ConfigSanitizer::sanitize()` method to validate all inspection service exposure flags for mainnet validators:

```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose sensitive information
        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                
                if inspection_service_config.expose_identity_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose identity information!".to_string(),
                    ));
                }
                
                if inspection_service_config.expose_peer_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose peer information!".to_string(),
                    ));
                }
                
                if inspection_service_config.expose_system_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose system information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

Additionally, consider changing the defaults for production deployments:
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false,  // Changed to false
            expose_peer_information: false,      // Changed to false
            expose_system_information: false,    // Changed to false
        }
    }
}
```

## Proof of Concept

**Test Case 1: Demonstrate Sanitizer Bypass**

```rust
#[test]
fn test_sanitize_identity_information_mainnet() {
    // Create an inspection service config with identity information exposed
    let node_config = NodeConfig {
        inspection_service: InspectionServiceConfig {
            expose_configuration: false,  // This passes sanitizer
            expose_identity_information: true,  // This should fail but doesn't!
            ..Default::default()
        },
        ..Default::default()
    };

    // This SHOULD fail but currently SUCCEEDS
    let result = InspectionServiceConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    );
    
    // Currently passes - this is the bug!
    assert!(result.is_ok());  
    
    // After fix, this should fail:
    // assert!(matches!(result, Err(Error::ConfigSanitizerFailed(_, _))));
}

#[test]
fn test_sanitize_peer_information_mainnet() {
    // Create an inspection service config with peer information exposed
    let node_config = NodeConfig {
        inspection_service: InspectionServiceConfig {
            expose_configuration: false,
            expose_peer_information: true,  // This should fail but doesn't!
            ..Default::default()
        },
        ..Default::default()
    };

    // This SHOULD fail for mainnet validators
    let result = InspectionServiceConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    );
    
    assert!(result.is_ok());  // Bug: Currently passes!
}
```

**Test Case 2: Demonstrate Information Leak**

```rust
#[tokio::test]
async fn test_identity_leak_on_mainnet_validator() {
    // Create a mainnet validator config with default inspection service
    let mut config = NodeConfig::get_default_validator_config();
    config.base.chain_id = ChainId::mainnet();
    
    // Sanitizer passes even though identity endpoint is exposed
    let sanitize_result = InspectionServiceConfig::sanitize(
        &config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    );
    assert!(sanitize_result.is_ok());
    
    // Query the identity information endpoint
    let response = send_get_request_to_path(&config, IDENTITY_INFORMATION_PATH).await;
    
    // Identity information is leaked!
    assert_eq!(response.status(), StatusCode::OK);
    let body_string = body::to_bytes(response.into_body())
        .await
        .unwrap();
    let body_text = String::from_utf8(body_string.to_vec()).unwrap();
    
    // Sensitive validator network peer ID is exposed
    assert!(body_text.contains("Validator network"));
    assert!(body_text.contains("peer ID"));
}
```

## Notes

The vulnerability exists due to incomplete validation logic in the config sanitizer. While the intention to protect mainnet validators from information exposure is clear (as evidenced by the `expose_configuration` check), the implementation only covers one of four exposure vectors. This represents a gap between security policy and enforcement that leaves mainnet validators vulnerable to reconnaissance and targeted attacks.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** config/src/config/inspection_service_config.rs (L71-109)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-26)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L29-51)
```rust
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L21-37)
```rust
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
```
