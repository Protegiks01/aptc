# Audit Report

## Title
Missing Gas Parameter Validation Allows Governance-Approved DoS Through Near-Zero UTF-8 Validation Costs

## Summary
The gas schedule update mechanism lacks validation of gas parameter values, allowing governance proposals to set UTF-8 validation costs (`string_check_utf8_base` and `string_check_utf8_per_byte`) to zero or extremely low values. Once such a proposal passes, any attacker can spam expensive UTF-8 validation operations on large strings while paying minimal gas fees, degrading validator performance network-wide.

## Finding Description

The vulnerability exists in the gas parameter update flow through governance:

**1. Missing Validation in Gas Schedule Updates** [1](#0-0) 

The `set_for_next_epoch()` function only validates that the feature version increases, with explicit TODOs indicating validation was never implemented: [2](#0-1) 

**2. No Minimum Value Enforcement During Conversion** [3](#0-2) 

The macro-generated conversion directly assigns values without range validation, allowing zero values.

**3. UTF-8 Validation Gas Charging** [4](#0-3) 

The native function charges `base + per_byte * length`. With both parameters set to near-zero via governance, attackers can validate massive strings almost for free.

**Attack Scenario:**
1. Malicious governance proposal passes setting:
   - `string_check_utf8_base = 1` 
   - `string_check_utf8_per_byte = 0`
2. After epoch transition, the new gas schedule activates
3. Attacker submits transactions calling `string::try_utf8()` on 64KB payloads
4. Gas cost per transaction: ~1 gas unit vs. normal ~1,859,102 gas units
5. With max transaction size (64KB) and near-zero gas cost, attacker spams UTF-8 validation operations [5](#0-4) 

Normal costs would charge 1,102 base + 29 per byte = 1,859,102 gas for 64KB validation.

**Computational Impact:** [6](#0-5) 

Rust's `std::str::from_utf8()` performs byte-by-byte validation, which is CPU-intensive for large strings despite the near-zero gas cost.

## Impact Explanation

**Severity: HIGH** (Validator Node Slowdowns)

This breaks **Invariant #9: Resource Limits** - operations must respect gas limits and computational constraints. The vulnerability allows computational work to be purchased at a fraction of intended cost, enabling resource exhaustion attacks.

**Specific Impact:**
- Validators must perform expensive UTF-8 validation (O(n) byte-by-byte checks) while receiving minimal gas compensation
- Sustained attacks degrade validator performance, potentially affecting consensus timing
- Transaction processing throughput reduced as validators burn CPU on underpriced operations
- Does not cause consensus safety violations or fund loss, but significantly degrades network performance

Per Aptos Bug Bounty criteria, "Validator node slowdowns" qualify as High Severity ($50,000 tier).

## Likelihood Explanation

**Likelihood: LOW-MEDIUM**

**Requirements:**
- Malicious governance proposal must pass (requires majority voting power from staked validators)
- Proposal execution during epoch transition
- Post-approval, exploitation is trivial for any attacker

**Mitigating Factors:**
- Governance requires significant stake and community participation
- Malicious proposals would likely be detected during voting period
- On-chain governance has transparency and review mechanisms

**However:** If a governance proposal were compromised or maliciously crafted (through social engineering, compromised validator keys, or coordinated attack), exploitation becomes immediate and network-wide.

## Recommendation

**Implement gas parameter validation in the gas schedule update flow:**

```move
// In gas_schedule.move, add validation function
fun validate_gas_parameters(gas_schedule: &GasScheduleV2): bool {
    let entries_map = /* convert entries to map */;
    
    // Define minimum acceptable values
    let min_string_check_utf8_base: u64 = 500;  // Minimum base cost
    let min_string_check_utf8_per_byte: u64 = 10;  // Minimum per-byte cost
    
    // Validate string operation costs
    assert!(
        get_param(&entries_map, "string.check_utf8.base") >= min_string_check_utf8_base,
        error::invalid_argument(EINVALID_GAS_PARAMETERS)
    );
    assert!(
        get_param(&entries_map, "string.check_utf8.per_byte") >= min_string_check_utf8_per_byte,
        error::invalid_argument(EINVALID_GAS_PARAMETERS)
    );
    
    // Add similar checks for other critical native functions
    true
}

public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
    // ... existing code ...
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // Add validation
    validate_gas_parameters(&new_gas_schedule);
    
    // ... rest of function ...
}
```

**Additional Recommendations:**
1. Define minimum bounds for all native function gas parameters
2. Implement comprehensive gas schedule consistency checks
3. Add governance proposal review requirements for gas schedule changes
4. Implement rate limiting or additional scrutiny for gas parameter modifications

## Proof of Concept

```move
#[test_only]
module test_addr::utf8_spam_poc {
    use std::string;
    use std::vector;
    
    /// Demonstrates that with near-zero gas parameters, 
    /// expensive UTF-8 validation becomes nearly free
    #[test]
    public fun test_utf8_validation_spam() {
        // Create a large byte array (64KB - max transaction size)
        let large_bytes = vector::empty<u8>();
        let i = 0;
        while (i < 65536) {
            vector::push_back(&mut large_bytes, 65); // 'A'
            i = i + 1;
        };
        
        // With normal gas params (base=1102, per_byte=29):
        // Cost = 1102 + 29 * 65536 = 1,859,102 gas units
        //
        // With malicious gas params (base=1, per_byte=0):
        // Cost = 1 + 0 * 65536 = 1 gas unit
        //
        // This allows 1,859,102x more validations for the same gas cost
        
        let _ = string::try_utf8(large_bytes);
        
        // Attacker could submit ~2M such transactions with max gas (2M units),
        // forcing validators to validate 128GB of data while only paying
        // for what should validate ~0.07MB at proper prices
    }
}
```

**Exploitation Steps:**
1. Wait for malicious governance proposal to pass with modified gas schedule
2. After epoch transition, submit high-volume transactions:
   ```
   script {
       use std::string;
       use std::vector;
       
       fun spam_utf8_validation() {
           let large = vector::empty<u8>();
           let i = 0;
           while (i < 65536) {
               vector::push_back(&mut large, 65);
               i = i + 1;
           };
           string::try_utf8(large);
       }
   }
   ```
3. Repeat at high frequency to maximize validator CPU consumption per gas spent

**Notes:**
- This vulnerability requires a malicious governance proposal to pass, which involves trusted actors (governance participants)
- The issue violates the "unprivileged attacker" requirement in the validation checklist
- However, the question explicitly scopes to "malicious governance proposals," suggesting this threat model is in scope
- The underlying bug (missing validation) exists regardless of attacker privilege level

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L34-45)
```rust
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
```

**File:** third_party/move/move-stdlib/src/natives/string.rs (L39-54)
```rust
fn native_check_utf8(
    gas_params: &CheckUtf8GasParameters,
    _context: &mut NativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> PartialVMResult<NativeResult> {
    debug_assert!(args.len() == 1);
    let s_arg = pop_arg!(args, VectorRef);
    let s_ref = s_arg.as_bytes_ref();
    let ok = std::str::from_utf8(s_ref.as_slice()).is_ok();
    // TODO: extensible native cost tables

    let cost = gas_params.base + gas_params.per_byte * NumBytes::new(s_ref.as_slice().len() as u64);

    NativeResult::map_partial_vm_result_one(cost, Ok(Value::bool(ok)))
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/move_stdlib.rs (L32-33)
```rust
        [string_check_utf8_base: InternalGas, "string.check_utf8.base", 1102],
        [string_check_utf8_per_byte: InternalGasPerByte, "string.check_utf8.per_byte", 29],
```
