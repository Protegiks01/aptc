# Audit Report

## Title
Unauthorized Coin Registration for Privileged Addresses via deposit_coins Function

## Summary
The `aptos_account::deposit_coins` function allows any user to force arbitrary addresses, including privileged system addresses like `0x1`, to register for malicious coin types without the account owner's authorization. This is achieved by exploiting the function's automatic registration mechanism that uses `create_signer` to register recipients who haven't opted out of direct transfers.

## Finding Description

The vulnerability exists in the interaction between three functions: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) 

The attack flow:

1. Attacker deploys a malicious coin type `MaliciousCoin` and obtains `MintCapability`
2. Attacker mints coins and calls `aptos_account::transfer_coins<MaliciousCoin>(attacker, 0x1, amount)` or directly `deposit_coins<MaliciousCoin>(0x1, coins)`
3. The function checks `can_receive_direct_coin_transfers(0x1)`, which returns `true` by default for addresses without `DirectTransferConfig` (including system addresses)
4. The function calls `coin::register<MaliciousCoin>(&create_signer(0x1))`, creating a signer for address `0x1` without authorization
5. This triggers `account::register_coin<MaliciousCoin>(0x1)`, which emits a `CoinRegister` event with `account: 0x1`
6. The event is committed to the blockchain, permanently recording that address `0x1` registered for the malicious coin type

This violates **Invariant #8: Access Control** - system addresses should be protected from unauthorized state modifications. While `create_signer` is correctly restricted to friend modules, the friend module `aptos_account` uses it with user-controlled addresses without validation.

## Impact Explanation

**High Severity** - This constitutes a significant protocol violation for several reasons:

1. **Event Spoofing**: Creates on-chain records falsely suggesting privileged addresses endorsed malicious coin types, enabling sophisticated social engineering attacks
2. **Storage Pollution**: Forces arbitrary state changes on system addresses without authorization
3. **Trust Model Violation**: Undermines the security model where system addresses (`@aptos_framework`, `@core_resources`) should be protected from external manipulation
4. **Indexer Manipulation**: Off-chain indexers and explorers will display these fake registrations, misleading users about which coins are "approved" by the framework

While not directly causing loss of funds or consensus violations, this breaks critical access control guarantees for privileged addresses and enables attacks that could indirectly lead to user losses through deception.

## Likelihood Explanation

**High Likelihood** - The attack requires only:
- Deploying a Move module with a coin type (permissionless)
- Calling a public entry function with standard parameters
- No privileged access, no complex setup, no race conditions
- System addresses like `0x1` likely lack `DirectTransferConfig`, making them vulnerable by default
- The attack succeeds deterministically once prerequisites are met

## Recommendation

Add explicit validation in `aptos_account::deposit_coins` to prevent registration of privileged system addresses:

```move
public fun deposit_coins<CoinType>(
    to: address, coins: Coin<CoinType>
) acquires DirectTransferConfig {
    // Prevent forcing registration on system addresses
    assert!(
        to != @aptos_framework && to != @core_resources && 
        to != @vm_reserved && to != @aptos_token,
        error::permission_denied(ECANNOT_REGISTER_SYSTEM_ADDRESSES)
    );
    
    if (!account::exists_at(to)) {
        create_account(to);
    };
    if (!coin::is_account_registered<CoinType>(to)) {
        assert!(
            can_receive_direct_coin_transfers(to),
            error::permission_denied(EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS)
        );
        coin::register<CoinType>(&create_signer(to));
    };
    coin::deposit<CoinType>(to, coins)
}
```

Alternatively, modify `can_receive_direct_coin_transfers` to return `false` for system addresses by default.

## Proof of Concept

```move
#[test_only]
module attacker::exploit {
    use std::signer;
    use aptos_framework::coin;
    use aptos_framework::aptos_account;
    use aptos_std::type_info;
    
    struct MaliciousCoin has key {}
    
    #[test(attacker = @0x123)]
    fun test_spoof_system_registration(attacker: &signer) {
        // Setup: Initialize malicious coin
        let (burn_cap, freeze_cap, mint_cap) = coin::initialize<MaliciousCoin>(
            attacker,
            b"Malicious",
            b"MAL",
            8,
            false,
        );
        
        // Mint coins
        let coins = coin::mint<MaliciousCoin>(100, &mint_cap);
        
        // Attack: Force system address 0x1 to register for malicious coin
        aptos_account::deposit_coins<MaliciousCoin>(@0x1, coins);
        
        // Verify: Check that 0x1 is now registered
        assert!(coin::is_account_registered<MaliciousCoin>(@0x1), 0);
        
        // The CoinRegister event has been emitted with account=0x1
        // Indexers and users will see that @aptos_framework "registered" for MaliciousCoin
        
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_freeze_cap(freeze_cap);
        coin::destroy_mint_cap(mint_cap);
    }
}
```

## Notes

This vulnerability specifically affects privileged system addresses that have not explicitly opted out of direct coin transfers. The default-allow behavior, while convenient for regular users, creates a security risk when applied to framework addresses that should be immutable and protected from external manipulation.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L128-148)
```text
    public fun deposit_coins<CoinType>(
        to: address, coins: Coin<CoinType>
    ) acquires DirectTransferConfig {
        if (!account::exists_at(to)) {
            create_account(to);
            spec {
                // TODO(fa_migration)
                // assert coin::spec_is_account_registered<AptosCoin>(to);
                // assume aptos_std::type_info::type_of<CoinType>() == aptos_std::type_info::type_of<AptosCoin>() ==>
                //     coin::spec_is_account_registered<CoinType>(to);
            };
        };
        if (!coin::is_account_registered<CoinType>(to)) {
            assert!(
                can_receive_direct_coin_transfers(to),
                error::permission_denied(EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS)
            );
            coin::register<CoinType>(&create_signer(to));
        };
        coin::deposit<CoinType>(to, coins)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L264-269)
```text
    public fun can_receive_direct_coin_transfers(
        account: address
    ): bool acquires DirectTransferConfig {
        !exists<DirectTransferConfig>(account)
            || borrow_global<DirectTransferConfig>(account).allow_arbitrary_coin_transfers
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1128-1135)
```text
    public fun register<CoinType>(account: &signer) acquires CoinInfo, CoinConversionMap {
        let account_addr = signer::address_of(account);
        assert_signer_has_permission<CoinType>(account);
        // Short-circuit and do nothing if account is already registered for CoinType.
        if (is_account_registered<CoinType>(account_addr)) { return };

        account::register_coin<CoinType>(account_addr);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1213-1231)
```text
    public(friend) fun register_coin<CoinType>(account_addr: address) acquires Account {
        if (std::features::module_event_migration_enabled()) {
            event::emit(
                CoinRegister {
                    account: account_addr,
                    type_info: type_info::type_of<CoinType>(),
                },
            );
        } else {
            ensure_resource_exists(account_addr);
            let account = &mut Account[account_addr];
            event::emit_event<CoinRegisterEvent>(
                &mut account.coin_register_events,
                CoinRegisterEvent {
                    type_info: type_info::type_of<CoinType>(),
                },
            );
        }
    }
```
