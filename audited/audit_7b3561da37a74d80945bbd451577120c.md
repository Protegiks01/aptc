# Audit Report

## Title
Configuration-Based Bypass of MAX_REQUEST_LIMIT in State Iterator Construction

## Summary
The `get_prefixed_state_value_iterator` API creates unbounded iterators without validating against `MAX_REQUEST_LIMIT`, unlike other iterator construction methods. While API endpoints apply consumer-level limits, the lack of storage-layer validation allows node operators to configure `max_account_resources_page_size` above the intended 10,000 item limit, enabling resource exhaustion attacks against misconfigured nodes.

## Finding Description

The `MAX_REQUEST_LIMIT` constant is defined as 10,000 to bound database iterator operations and prevent resource exhaustion: [1](#0-0) 

All iterator construction APIs consistently validate limit parameters against this constant using `error_if_too_many_requested`: [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

However, `get_prefixed_state_value_iterator` does NOT perform this validation at the storage layer: [6](#0-5) 

The API layer compensates by applying limits at the consumer level using `.take()`: [7](#0-6) 

The limit is determined from the `max_account_resources_page_size` configuration value: [8](#0-7) 

This configuration parameter has a default value of 9,999 (below MAX_REQUEST_LIMIT): [9](#0-8) 

However, the `ApiConfig::sanitize` method does NOT validate that this configuration value respects MAX_REQUEST_LIMIT: [10](#0-9) 

**Attack Scenario:**
1. Node operator sets `max_account_resources_page_size: 65535` in configuration file (maximum u16 value)
2. Attacker sends API request: `GET /v1/accounts/{address}/resources?limit=65535`
3. `determine_limit` caps the request at 65,535 (the configured maximum)
4. `get_resources_by_pagination` creates an iterator and applies `.take(65535 + 1)`
5. Up to 65,536 resources are fetched, processed, and returned - 6.5x above the intended MAX_REQUEST_LIMIT

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria:

- **Resource Exhaustion**: Fetching 65,536 resources (vs. intended 10,000 limit) can cause memory exhaustion, CPU overload, and network bandwidth saturation on affected nodes
- **State Inconsistency**: Different nodes with different configurations will have different maximum request limits, creating inconsistent API behavior across the network
- **Degraded Service**: Repeated large requests can degrade API responsiveness for legitimate users

The vulnerability breaks the **Resource Limits invariant** (#9): "All operations must respect gas, storage, and computational limits" - specifically, the MAX_REQUEST_LIMIT is designed as a hard limit but can be bypassed via configuration.

## Likelihood Explanation

**Likelihood: Medium-Low**

The vulnerability requires:
1. Node operator to explicitly configure `max_account_resources_page_size` above 10,000 (default is 9,999)
2. Attacker to discover the misconfigured node
3. Attacker to send requests with large limit values

While the default configuration is safe, node operators may increase limits without understanding the security implications, especially for nodes serving high-traffic applications. Once misconfigured, exploitation is trivial for any API user.

## Recommendation

Add validation in `ApiConfig::sanitize` to enforce that page size configurations respect MAX_REQUEST_LIMIT:

```rust
impl ConfigSanitizer for ApiConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let api_config = &node_config.api;

        if !api_config.enabled {
            return Ok(());
        }

        // Existing validations...

        // NEW: Validate page size limits
        const MAX_REQUEST_LIMIT: u16 = 10_000;
        if api_config.max_account_resources_page_size > MAX_REQUEST_LIMIT {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!("max_account_resources_page_size ({}) exceeds MAX_REQUEST_LIMIT ({})", 
                    api_config.max_account_resources_page_size, MAX_REQUEST_LIMIT),
            ));
        }
        if api_config.max_account_modules_page_size > MAX_REQUEST_LIMIT {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!("max_account_modules_page_size ({}) exceeds MAX_REQUEST_LIMIT ({})", 
                    api_config.max_account_modules_page_size, MAX_REQUEST_LIMIT),
            ));
        }

        Ok(())
    }
}
```

Additionally, consider adding storage-layer validation in `get_prefixed_state_value_iterator` for defense-in-depth, though this may require API changes.

## Proof of Concept

```rust
// File: config/src/config/api_config_exploit_test.rs
#[test]
fn test_bypass_max_request_limit() {
    // Create ApiConfig with excessive page size
    let mut config = ApiConfig::default();
    config.max_account_resources_page_size = 65535; // 6.5x MAX_REQUEST_LIMIT
    
    // This should fail sanitization but currently doesn't
    let node_config = NodeConfig {
        api: config,
        ..Default::default()
    };
    
    // Sanitization passes when it should fail
    assert!(ApiConfig::sanitize(&node_config, NodeType::Validator, None).is_ok());
    
    // Attacker can now request 65,535 resources via API
    // GET /v1/accounts/{address}/resources?limit=65535
    // This will be capped at 65,535 instead of 10,000
}
```

**Notes:**

This vulnerability represents an architectural inconsistency where `MAX_REQUEST_LIMIT` is enforced at the consumer layer (via `.take()`) rather than the storage layer (via `error_if_too_many_requested`). While the default configuration is secure, the lack of validation allows misconfiguration to bypass intended safety limits, creating resource exhaustion risks on affected nodes.

### Citations

**File:** storage/indexer_schemas/src/utils.rs (L21-21)
```rust
pub const MAX_REQUEST_LIMIT: u64 = 10_000;
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L78-96)
```rust
    fn get_prefixed_state_value_iterator(
        &self,
        key_prefix: &StateKeyPrefix,
        cursor: Option<&StateKey>,
        version: Version,
    ) -> Result<Box<dyn Iterator<Item = Result<(StateKey, StateValue)>> + '_>> {
        gauged_api("get_prefixed_state_value_iterator", || {
            ensure!(
                !self.state_kv_db.enabled_sharding(),
                "This API is not supported with sharded DB"
            );
            self.error_if_state_kv_pruned("StateValue", version)?;

            Ok(Box::new(
                self.state_store
                    .get_prefixed_state_value_iterator(key_prefix, cursor, version)?,
            )
                as Box<dyn Iterator<Item = Result<(StateKey, StateValue)>>>)
        })
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L483-483)
```rust
            error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L500-500)
```rust
            error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L517-517)
```rust
            error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L537-537)
```rust
            error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;
```

**File:** api/src/context.rs (L148-150)
```rust
    pub fn max_account_resources_page_size(&self) -> u16 {
        self.node_config.api.max_account_resources_page_size
    }
```

**File:** api/src/context.rs (L470-525)
```rust
    pub fn get_resources_by_pagination(
        &self,
        address: AccountAddress,
        prev_state_key: Option<&StateKey>,
        version: u64,
        limit: u64,
    ) -> Result<(Vec<(StructTag, Vec<u8>)>, Option<StateKey>)> {
        let account_iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        prev_state_key,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(
                    &StateKeyPrefix::from(address),
                    prev_state_key,
                    version,
                )?
        };
        // TODO: Consider rewriting this to consider resource groups:
        // * If a resource group is found, expand
        // * Return Option<Result<(PathType, StructTag, Vec<u8>)>>
        // * Count resources and only include a resource group if it can completely fit
        // * Get next_key as the first struct_tag not included
        let mut resource_iter = account_iter
            .filter_map(|res| match res {
                Ok((k, v)) => match k.inner() {
                    StateKeyInner::AccessPath(AccessPath { address: _, path }) => {
                        match Path::try_from(path.as_slice()) {
                            Ok(Path::Resource(struct_tag)) => {
                                Some(Ok((struct_tag, v.bytes().to_vec())))
                            }
                            // TODO: Consider expanding to Path::Resource
                            Ok(Path::ResourceGroup(struct_tag)) => {
                                Some(Ok((struct_tag, v.bytes().to_vec())))
                            }
                            Ok(Path::Code(_)) => None,
                            Err(e) => Some(Err(anyhow::Error::from(e))),
                        }
                    }
                    _ => {
                        error!("storage prefix scan return inconsistent key ({:?}) with expected key prefix ({:?}).", k, StateKeyPrefix::from(address));
                        Some(Err(format_err!( "storage prefix scan return inconsistent key ({:?})", k )))
                    }
                },
                Err(e) => Some(Err(e)),
            })
            .take(limit as usize + 1);
```

**File:** config/src/config/api_config.rs (L100-100)
```rust
const DEFAULT_MAX_ACCOUNT_RESOURCES_PAGE_SIZE: u16 = 9999;
```

**File:** config/src/config/api_config.rs (L163-199)
```rust
impl ConfigSanitizer for ApiConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let api_config = &node_config.api;

        // If the API is disabled, we don't need to do anything
        if !api_config.enabled {
            return Ok(());
        }

        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }

        // Validate basic runtime properties
        if api_config.max_runtime_workers.is_none() && api_config.runtime_worker_multiplier == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "runtime_worker_multiplier must be greater than 0!".into(),
            ));
        }

        // Sanitize the gas estimation config
        GasEstimationConfig::sanitize(node_config, node_type, chain_id)?;

        Ok(())
    }
```
