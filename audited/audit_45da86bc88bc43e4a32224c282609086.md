# Audit Report

## Title
Malicious Peers Can Abuse Optimistic Fetch Mechanism Due to Error Misclassification and Missing RequestModerator Integration

## Summary
During optimistic fetch processing, errors are misclassified and malicious peers sending invalid requests are not properly tracked through the RequestModerator system. This allows malicious public network peers to send unlimited invalid optimistic fetch requests without being throttled or ignored, enabling resource exhaustion attacks.

## Finding Description

The storage service implements a RequestModerator to track and throttle peers that send too many invalid requests. After `max_invalid_requests_per_peer` (default: 500) invalid requests, public network peers are ignored for an exponentially increasing duration. [1](#0-0) 

However, during optimistic fetch processing, there are multiple points where errors are misclassified or the RequestModerator is not notified:

**1. Epoch Boundary Violation Detection Without Moderator Notification:**

When an invalid optimistic fetch is detected (violating epoch boundaries), the peer is removed from the optimistic fetch map but the RequestModerator is never notified: [2](#0-1) 

The removal function only logs a warning without incrementing the invalid request count: [3](#0-2) 

**2. Error Misclassification in notify_peer_of_new_data:**

All non-Ok responses from the handler are converted to `UnexpectedErrorEncountered`, losing the original error classification: [4](#0-3) 

This means if the handler returned `InvalidRequest` due to malicious parameters, it gets misclassified as an unexpected error.

**3. Error Misclassification in get_epoch_ending_ledger_info:**

Similarly, all errors are converted to `StorageErrorEncountered`: [5](#0-4) 

**Attack Scenario:**

1. Malicious peer connects to a storage service node on the public network
2. Peer sends optimistic fetch request with `known_epoch=N`, `known_version=V`
3. Server has synced to epoch N+1, and epoch N ends at version V-100
4. Server detects epoch boundary violation at line 533 of optimistic_fetch.rs
5. Peer is removed from optimistic fetch map but RequestModerator is NOT notified
6. Peer's `invalid_request_count` remains at 0
7. Peer immediately sends another invalid optimistic fetch
8. Process repeats unlimited times without the peer being ignored

The RequestModerator's punishment mechanism is bypassed because `increment_invalid_request_count` is only called during request validation: [6](#0-5) 

But invalid requests detected AFTER validation (like epoch boundary violations) never trigger this increment.

## Impact Explanation

**Medium Severity** - This vulnerability enables resource exhaustion attacks but does not directly compromise consensus or funds:

- Malicious public network peers can send unlimited invalid optimistic fetch requests
- Each invalid request wastes server resources:
  - CPU cycles for validation and epoch ending ledger info lookups
  - Storage reads to fetch epoch ending ledger infos
  - Network bandwidth for peer communication
- Multiple colluding peers can amplify the attack
- However, this does not affect:
  - Consensus safety or liveness (validators use separate networks)
  - Fund security
  - State consistency

The attack enables DoS through resource exhaustion, which aligns with **Medium Severity** per the Aptos bug bounty criteria: "State inconsistencies requiring intervention" and resource exhaustion requiring manual intervention to block malicious peers.

## Likelihood Explanation

**High Likelihood:**

- Attack is trivially executable by any public network peer
- No special privileges or resources required
- No need to control validators or have stake
- Simple to automate and scale with multiple peers
- Current production code is vulnerable
- Public network peers are common and easy to establish

The only requirement is connecting to the public network and crafting optimistic fetch requests with invalid epoch/version combinations, which is straightforward.

## Recommendation

**Fix 1: Integrate RequestModerator with Invalid Optimistic Fetch Detection**

Modify `remove_invalid_optimistic_fetches` to notify the RequestModerator: [3](#0-2) 

The function should accept a `request_moderator` parameter and call it for each invalid peer:

```rust
fn remove_invalid_optimistic_fetches(
    optimistic_fetches: Arc<DashMap<PeerNetworkId, OptimisticFetchRequest>>,
    peers_with_invalid_optimistic_fetches: Vec<PeerNetworkId>,
    request_moderator: Arc<RequestModerator>,
) {
    for peer_network_id in peers_with_invalid_optimistic_fetches {
        if let Some((peer_network_id, optimistic_fetch)) =
            optimistic_fetches.remove(&peer_network_id)
        {
            // Notify the moderator of the invalid request
            if let Some(mut peer_state) = request_moderator.get_unhealthy_peer_states()
                .get_mut(&peer_network_id) 
            {
                peer_state.increment_invalid_request_count(&peer_network_id);
            }
            
            warn!(LogSchema::new(LogEntry::OptimisticFetchRefresh)
                .error(&Error::InvalidRequest(
                    "Mismatch between known version and epoch!".into()
                ))
                .request(&optimistic_fetch.request)
                .message(&format!(
                    "Dropping invalid optimistic fetch request for peer: {:?}!",
                    peer_network_id
                )));
        }
    }
}
```

**Fix 2: Preserve Error Classifications**

Modify error handling to preserve error types instead of blanket conversion: [4](#0-3) 

Should distinguish between error types:

```rust
Err(storage_error) => {
    return match storage_error {
        StorageServiceError::InvalidRequest(msg) => 
            Err(Error::InvalidRequest(msg)),
        StorageServiceError::TooManyInvalidRequests(msg) => 
            Err(Error::TooManyInvalidRequests(msg)),
        _ => Err(Error::UnexpectedErrorEncountered(format!(
            "Failed to fetch missing data for peer! {:?}",
            storage_error
        )))
    }
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_invalid_optimistic_fetch_bypasses_moderator() {
    use aptos_config::network_id::{NetworkId, PeerNetworkId};
    use aptos_types::PeerId;
    
    // Setup storage service with moderator
    let config = StorageServiceConfig {
        max_invalid_requests_per_peer: 5, // Low threshold for testing
        min_time_to_ignore_peers_secs: 60,
        ..Default::default()
    };
    
    let peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    
    // Send 10 invalid optimistic fetches with epoch boundary violations
    for i in 0..10 {
        let request = StorageServiceRequest::new(
            DataRequest::GetNewTransactionsWithProof(
                NewTransactionsWithProofRequest {
                    known_version: 1000, // Past the epoch ending
                    known_epoch: 5,      // But claim to be in epoch 5
                    include_events: false,
                }
            ),
            false
        );
        
        // Send request - it will be detected as invalid due to epoch boundary
        // But peer will NOT be punished via RequestModerator
        send_optimistic_fetch_request(peer_network_id, request).await;
    }
    
    // Verify: peer should be ignored after 5 invalid requests
    // But actually peer is NOT ignored because moderator was never notified
    let moderator = get_request_moderator();
    let peer_state = moderator.get_unhealthy_peer_states()
        .get(&peer_network_id);
    
    // BUG: invalid_request_count is still 0 instead of 10
    assert_eq!(peer_state.map(|s| s.invalid_request_count).unwrap_or(0), 0);
    
    // BUG: peer is NOT ignored despite 10 invalid requests
    assert!(!peer_state.map(|s| s.is_ignored()).unwrap_or(false));
    
    // Expected: After 5 invalid requests, peer should be ignored
    // assert_eq!(peer_state.unwrap().invalid_request_count, 10);
    // assert!(peer_state.unwrap().is_ignored());
}
```

## Notes

This vulnerability specifically affects public network peers, as the RequestModerator only ignores peers on the public network: [7](#0-6) 

Validator and VFN networks are not affected by the throttling mechanism, so the vulnerability's impact is limited to public network resource exhaustion. However, this still represents a concrete security issue requiring intervention to prevent abuse.

### Citations

**File:** config/src/config/state_sync_config.rs (L164-164)
```rust
    pub max_invalid_requests_per_peer: u64,
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L531-541)
```rust
                    // Check that we haven't been sent an invalid optimistic fetch request
                    // (i.e., a request that does not respect an epoch boundary).
                    if epoch_ending_ledger_info.ledger_info().version() <= highest_known_version {
                        peers_with_invalid_optimistic_fetches
                            .lock()
                            .push(peer_network_id);
                    } else {
                        peers_with_ready_optimistic_fetches
                            .lock()
                            .push((peer_network_id, epoch_ending_ledger_info));
                    }
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L585-605)
```rust
/// Removes the invalid optimistic fetches from the active map
fn remove_invalid_optimistic_fetches(
    optimistic_fetches: Arc<DashMap<PeerNetworkId, OptimisticFetchRequest>>,
    peers_with_invalid_optimistic_fetches: Vec<PeerNetworkId>,
) {
    for peer_network_id in peers_with_invalid_optimistic_fetches {
        if let Some((peer_network_id, optimistic_fetch)) =
            optimistic_fetches.remove(&peer_network_id)
        {
            warn!(LogSchema::new(LogEntry::OptimisticFetchRefresh)
                .error(&Error::InvalidRequest(
                    "Mismatch between known version and epoch!".into()
                ))
                .request(&optimistic_fetch.request)
                .message(&format!(
                    "Dropping invalid optimistic fetch request for peer: {:?}!",
                    peer_network_id
                )));
        }
    }
}
```

**File:** state-sync/storage-service/server/src/utils.rs (L77-80)
```rust
        Err(error) => Err(Error::StorageErrorEncountered(format!(
            "Failed to get epoch ending ledger info! Error: {:?}",
            error
        ))),
```

**File:** state-sync/storage-service/server/src/utils.rs (L169-175)
```rust
        response => {
            return Err(Error::UnexpectedErrorEncountered(format!(
                "Failed to fetch missing data for peer! {:?}",
                response
            )))
        },
    };
```

**File:** state-sync/storage-service/server/src/moderator.rs (L54-68)
```rust
        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L178-178)
```rust
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);
```
