# Audit Report

## Title
Multiple Signer Parameters Collapsed to Single Signer in Test Wrapper Script Generation

## Summary
The `generate_script_wrapper_for_non_entry_function()` function incorrectly handles Move functions with multiple signer parameters by generating wrapper scripts that pass the same signer value to all signer positions, breaking multi-signer authorization semantics in transactional tests.

## Finding Description

The vulnerability exists in the script wrapper generation logic for non-entry functions. When a Move function requires multiple distinct signer parameters (e.g., `transfer(sender: signer, receiver: signer, amount: u64)`), the generated wrapper script only declares a single signer parameter and reuses it for all signer positions. [1](#0-0) 

The code checks if ANY signer exists with `contains()`, then creates only ONE script signer parameter ("s: signer" or "s: &signer"). [2](#0-1) 

In the parameter processing loop, every signer parameter (whether by value or reference) is mapped to the same "s" variable, regardless of how many distinct signers the target function requires.

**Example Broken Scenario:**

For a function signature:
```move
public fun multi_sig_transfer(from: signer, to: signer, amount: u64)
```

The generated wrapper becomes:
```move
script {
    fun main(s: signer, arg2: u64) {
        module::multi_sig_transfer(s, s, arg2);  // Same signer for both!
    }
}
```

This is fundamentally wrong. According to Move's script execution model, scripts CAN have multiple signer parameters: [3](#0-2) 

The verification logic uses `skip_while` to allow multiple consecutive signer parameters at the beginning of the signature. [4](#0-3) 

The VM specification confirms that multiple addresses in the `senders` vector each become separate `Signer` values passed to the script.

## Impact Explanation

**Severity Assessment: High â†’ Medium (Testing Infrastructure)**

While the bug is real and breaks multi-signer semantics, this occurs in **testing infrastructure**, not the blockchain runtime. The direct impact is:

1. **Test Validation Bypass**: Smart contracts requiring multiple independent signers will have their tests pass incorrectly
2. **Authorization Logic Masking**: Multi-signature authorization checks will be tested with the same signer in all positions, hiding critical vulnerabilities
3. **Deployment of Vulnerable Contracts**: Developers may deploy contracts believing they are secure when multi-signer logic is fundamentally broken

The **indirect** security impact could be significant if vulnerable contracts are deployed to mainnet, potentially leading to:
- Unauthorized fund transfers
- Permission escalation attacks
- Governance manipulation

However, this does NOT directly compromise blockchain consensus, state consistency, or validator operations. The vulnerability exists in development/testing tooling, not in the blockchain execution engine itself.

## Likelihood Explanation

**Likelihood: Medium to High**

The bug will trigger whenever:
1. A developer writes a function with multiple signer parameters
2. The function is not an entry function (requires wrapper generation)
3. The transactional test runner is used for testing

This is a common pattern in Move smart contracts (e.g., escrow systems, multi-signature wallets, approval workflows). The bug is deterministic and will always occur for such functions.

However, the exploitation path is indirect:
- Developers must fail to notice the testing flaw
- The vulnerable contract must be deployed to production
- An attacker must then exploit the authorization bypass in the deployed contract

## Recommendation

Modify `generate_script_wrapper_for_non_entry_function()` to generate wrapper scripts with multiple distinct signer parameters matching the target function's signature.

**Fix approach:**

1. Count the number of signer parameters in the function signature
2. Generate unique signer parameter names (s1, s2, s3...) for each
3. Map each signer position to its corresponding unique parameter [5](#0-4) 

The fix should track signer indices and generate:
```rust
let mut signer_count = 0;
for param_token in parameters_sig.0.iter() {
    match param_token {
        SignatureToken::Signer => {
            signer_count += 1;
            script_params_str_parts.push(format!("s{}: signer", signer_count));
            call_args_str_parts.push(format!("s{}", signer_count));
        },
        // Handle other cases...
    }
}
```

## Proof of Concept

Create a Move module with a multi-signer function:

```move
module test_addr::multi_sig {
    public fun transfer(from: signer, to: signer, amount: u64) {
        assert!(std::signer::address_of(&from) != std::signer::address_of(&to), 1);
        // Transfer logic requiring distinct signers
    }
}
```

Write a transactional test:
```
//# run --signers 0xA 0xB -- test_addr::multi_sig::transfer 100
```

The current implementation generates a wrapper that passes the same signer to both positions, causing the assertion to fail incorrectly or allowing the test to pass when it should fail for authorization checks.

## Notes

**Critical Clarification**: This vulnerability exists in **testing infrastructure** (`testing-infra/transactional-test-runner`), not in the Aptos blockchain runtime. While it can lead to vulnerable contracts being deployed through inadequate testing, it does NOT directly compromise blockchain consensus, validator operations, or state management.

The MinimalAdapter in this file explicitly states it's "only used for compilation, not execution." [6](#0-5) 

The security impact is **indirect**: vulnerable contracts may pass tests and be deployed, where they can then be exploited. This makes it a **development/testing security issue** rather than a direct blockchain vulnerability.

### Citations

**File:** third_party/move/testing-infra/transactional-test-runner/src/transactional_ops.rs (L112-113)
```rust
        unimplemented!("MinimalAdapter is only used for compilation, not execution")
    }
```

**File:** third_party/move/testing-infra/transactional-test-runner/src/transactional_ops.rs (L523-553)
```rust
    let has_signer_by_value = parameters_sig.0.contains(&SignatureToken::Signer);
    let script_signer_param = if has_signer_by_value {
        "s: signer"
    } else {
        "s: &signer"
    };
    let mut script_params_str_parts = vec![script_signer_param.to_string()];
    let mut call_args_str_parts = vec![];

    for (i, param_token) in parameters_sig.0.iter().enumerate() {
        match param_token {
            SignatureToken::Signer => {
                call_args_str_parts.push("s".to_string());
            },
            SignatureToken::Reference(inner_token)
                if matches!(**inner_token, SignatureToken::Signer) =>
            {
                if has_signer_by_value {
                    call_args_str_parts.push("&s".to_string());
                } else {
                    call_args_str_parts.push("s".to_string());
                }
            },
            _ => {
                let type_str =
                    signature_token_to_move_type_string_for_wrapper(param_token, target_module)?;
                script_params_str_parts.push(format!("arg{}: {}", i, type_str));
                call_args_str_parts.push(format!("arg{}", i));
            },
        }
    }
```

**File:** third_party/move/move-bytecode-verifier/src/script_signature.rs (L168-172)
```rust
        parameters
            .iter()
            .skip_while(|typ| matches!(typ, S::Signer))
            .all(|typ| typ.is_valid_for_constant())
    };
```

**File:** third_party/move/documentation/spec/vm.md (L146-149)
```markdown
* Build the argument list: The first arguments are `Signer` values created by
the VM for the account addresses in the `senders` vector. Any other arguments
from the `args` vector are then checked against a whitelisted set of permitted
types and added to the arguments for the script.
```
