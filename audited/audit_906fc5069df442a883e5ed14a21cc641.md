# Audit Report

## Title
Lack of TLS Certificate Pinning in Binary Update Mechanism Could Enable MITM Attacks

## Summary
The Aptos CLI update mechanism uses the `self_update` crate to download binaries from GitHub releases without implementing TLS certificate pinning or post-download integrity verification. While the underlying HTTP client likely validates certificates against system trust stores, the absence of certificate pinning and checksum verification creates a potential attack surface for certificate substitution attacks.

## Finding Description

The `UpdateTool` enum and its implementations rely on the `self_update` crate for downloading CLI binaries and dependency tools. [1](#0-0) 

The update process occurs through the `self_update` crate's `Update::configure()` builder pattern, which internally handles HTTP requests for downloading binaries from GitHub releases. [2](#0-1) 

Critically, the Aptos codebase does not:
1. Configure custom TLS certificate validation for the self_update HTTP client
2. Implement certificate pinning for GitHub release downloads  
3. Verify downloaded binary hashes or signatures post-download

The update mechanism trusts the `self_update` crate's default HTTP client behavior without additional security controls. [3](#0-2) 

In contrast, other parts of the codebase explicitly configure TLS validation. The governance module demonstrates proper TLS configuration: [4](#0-3) 

Similarly, the Vault client implementation shows defense-in-depth with custom certificate validation: [5](#0-4) 

**Attack Scenario:**
An attacker with MITM capabilities (compromised network, rogue CA certificate, or system trust store manipulation) could potentially:
1. Intercept update requests to GitHub releases
2. Present a valid but attacker-controlled certificate
3. Serve malicious binaries disguised as legitimate updates
4. Achieve code execution on systems running `aptos update`

## Impact Explanation

This falls into **High Severity** category with potential for **Critical** impact:

- **Remote Code Execution**: Successful exploitation delivers arbitrary code to CLI users
- **Validator Node Compromise**: If validator operators use the CLI for updates, malicious binaries could compromise validator nodes
- **Supply Chain Attack**: Affects all users trusting the update mechanism

While not a direct consensus or on-chain protocol vulnerability, compromise of the CLI tool could lead to:
- Manipulation of governance proposals
- Unauthorized transaction submission
- Credential theft from node operators

The impact is somewhat mitigated because:
- Requires MITM position or CA compromise
- Targets CLI users, not the blockchain protocol directly
- System-level certificate validation likely still occurs via reqwest defaults

## Likelihood Explanation

**Likelihood: Medium to Low**

The attack requires:
- Network MITM position OR compromised Certificate Authority OR system trust store manipulation
- User initiating an update during the attack window
- No verification of downloaded binary post-download

Factors reducing likelihood:
- Modern TLS clients (reqwest) validate certificates by default against system trust stores
- GitHub uses HSTS and certificate transparency
- Most users operate on trusted networks

Factors increasing likelihood:
- No defense-in-depth beyond default TLS validation
- No binary signature verification
- Multiple update tools share the same vulnerable pattern

## Recommendation

Implement defense-in-depth for binary updates:

**1. Add Certificate Pinning:**
```rust
// In update_helper.rs or a new security configuration module
pub fn build_secure_http_client() -> Result<reqwest::Client> {
    let github_cert_pins = [
        // GitHub's certificate public key hashes (update periodically)
        "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
    ];
    
    reqwest::ClientBuilder::new()
        .tls_built_in_root_certs(true)
        .min_tls_version(reqwest::tls::Version::TLS_1_2)
        // Add certificate pinning via reqwest extensions or custom verifier
        .build()
}
```

**2. Implement Checksum Verification:**
After download, verify SHA256 checksums published alongside releases:
```rust
// After update completes in mod.rs
fn verify_binary_checksum(binary_path: &Path, expected_hash: &str) -> Result<()> {
    use sha2::{Sha256, Digest};
    let mut file = std::fs::File::open(binary_path)?;
    let mut hasher = Sha256::new();
    std::io::copy(&mut file, &mut hasher)?;
    let hash = format!("{:x}", hasher.finalize());
    
    if hash != expected_hash {
        return Err(anyhow!("Binary checksum mismatch"));
    }
    Ok(())
}
```

**3. Implement Signature Verification:**
Sign release binaries with Aptos signing keys and verify signatures before installation.

## Proof of Concept

**Setup:**
```bash
# Terminal 1: Start a malicious proxy with rogue certificate
mitmproxy --mode reverse:https://github.com --listen-port 443

# Terminal 2: Configure system to trust the mitmproxy CA
export SSL_CERT_FILE=/path/to/mitmproxy-ca.pem

# Terminal 3: Trigger update (would need DNS poisoning or host file modification)
aptos update aptos
```

**Expected Result (Vulnerable):**
- Update proceeds through malicious proxy
- Malicious binary is downloaded and installed
- No checksum/signature verification prevents this

**Expected Result (Patched):**
- Certificate pinning rejects the proxy's certificate
- OR checksum verification detects tampered binary
- Update fails safely

## Notes

**Important Clarifications:**

1. **Default Security Posture**: The `self_update` crate uses `reqwest`, which by default validates TLS certificates against the system trust store. The vulnerability exists in the *absence of defense-in-depth*, not complete absence of TLS validation.

2. **Scope Limitation**: This vulnerability affects CLI tooling infrastructure, not the core Aptos blockchain protocol. It does not directly impact consensus, state management, or on-chain operations. However, compromise of operator tooling could have downstream effects.

3. **Dependency Trust**: The security relies on the `self_update` crate (fork at `https://github.com/banool/self_update.git`) properly implementing TLS validation. [6](#0-5) 

4. **Standard Practice Gap**: Industry best practices for software update mechanisms (per NIST, OWASP) recommend certificate pinning AND cryptographic signature verification for binary updates. The current implementation lacks both additional protections beyond basic TLS.

5. **Attack Sophistication**: While requiring MITM capabilities or CA compromise raises the attack difficulty, supply chain attacks targeting developer tooling are increasingly common and high-value targets.

### Citations

**File:** crates/aptos/src/update/tool.rs (L24-33)
```rust
impl UpdateTool {
    pub async fn execute(self) -> CliResult {
        match self {
            UpdateTool::Aptos(tool) => tool.execute_serialized().await,
            UpdateTool::Revela(tool) => tool.execute_serialized().await,
            UpdateTool::Movefmt(tool) => tool.execute_serialized().await,
            UpdateTool::MoveMutationTest(tool) => tool.execute_serialized().await,
            UpdateTool::ProverDependencies(tool) => tool.execute_serialized().await,
        }
    }
```

**File:** crates/aptos/src/update/aptos.rs (L139-148)
```rust
        Update::configure()
            .repo_owner(&self.repo_owner)
            .repo_name(&self.repo_name)
            .bin_name("aptos")
            .current_version(current_version)
            .target_version_tag(&format!("aptos-cli-v{}", info.target_version))
            .target(target)
            .no_confirm(self.prompt_options.assume_yes)
            .build()
            .map_err(|e| anyhow!("Failed to build self-update configuration: {:#}", e))
```

**File:** crates/aptos/src/update/mod.rs (L50-56)
```rust
        // Build the updater.
        let updater = self.build_updater(&info)?;

        // Update the binary.
        let result = updater
            .update()
            .map_err(|e| anyhow!("Failed to update {}: {:#}", self.pretty_name(), e))?;
```

**File:** crates/aptos/src/governance/mod.rs (L422-425)
```rust
    let client = reqwest::ClientBuilder::default()
        .tls_built_in_root_certs(true)
        .build()
        .map_err(|err| CliError::UnexpectedError(format!("Failed to build HTTP client {}", err)))?;
```

**File:** secure/storage/vault/src/lib.rs (L133-143)
```rust
        let mut tls_builder = native_tls::TlsConnector::builder();
        tls_builder.min_protocol_version(Some(native_tls::Protocol::Tlsv12));
        if let Some(certificate) = ca_certificate {
            // First try the certificate as a PEM encoded cert, then as DER, and then panic.
            let mut cert = native_tls::Certificate::from_pem(certificate.as_bytes());
            if cert.is_err() {
                cert = native_tls::Certificate::from_der(certificate.as_bytes());
            }
            tls_builder.add_root_certificate(cert.unwrap());
        }
        let tls_connector = Arc::new(tls_builder.build().unwrap());
```

**File:** crates/aptos/Cargo.toml (L99-102)
```text
self_update = { git = "https://github.com/banool/self_update.git", rev = "8306158ad0fd5b9d4766a3c6bf967e7ef0ea5c4b", features = [
    "archive-zip",
    "compression-zip-deflate",
] }
```
