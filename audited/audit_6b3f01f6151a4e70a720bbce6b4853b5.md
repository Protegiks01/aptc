# Audit Report

## Title
SyncInfo Verification Bypass in Vote Message Processing Allows Consensus Safety Check Evasion

## Summary
The `VoteMsg::verify()` function in the Aptos consensus protocol makes safety-critical assertions about vote validity based on unverified `SyncInfo` data. The deferred `SyncInfo` verification in `RoundManager::sync_up()` is conditional and can be completely skipped, allowing votes with forged synchronization metadata to bypass consensus safety checks and be aggregated into Quorum Certificates.

## Finding Description

The vulnerability exists in a chain of verification logic across multiple files:

**1. Initial Verification with Unverified SyncInfo** [1](#0-0) 

The `VoteMsg::verify()` function performs three critical safety checks that depend on `SyncInfo` content, but explicitly does NOT verify the `SyncInfo` itself. The comment on lines 77-79 states this verification is "deferred."

**2. Conditional Verification in sync_up()** [2](#0-1) 

The deferred verification only occurs if `sync_info.has_newer_certificates()` returns true (line 880). If false, the function returns `Ok(())` without any cryptographic verification (line 905).

**3. has_newer_certificates() Logic** [3](#0-2) 

This method only compares round numbers—no cryptographic verification occurs. An attacker can trivially ensure this returns false by setting forged certificate rounds to be equal to or lower than the victim's local state.

**4. Vote Processing Without Verification** [4](#0-3) 

After `ensure_round_and_sync_up()` succeeds (potentially without SyncInfo verification), the vote is processed normally.

**5. Vote Aggregation** [5](#0-4) 

The `insert_vote()` function aggregates votes into QCs without any SyncInfo verification, relying solely on vote signatures.

**Attack Path:**

1. Attacker (malicious validator or compromised key) creates a `VoteMsg` with:
   - Valid vote signature (using validator key)
   - Forged `SyncInfo` containing fake QCs/TCs with invalid signatures
   - Forged certificate rounds set ≤ victim's local rounds

2. `VoteMsg::verify()` is called:
   - Checks pass using forged `SyncInfo` round numbers
   - `SyncInfo` cryptographic verification is explicitly skipped

3. `process_vote_msg()` → `ensure_round_and_sync_up()` → `sync_up()`:
   - `has_newer_certificates()` returns false (attacker-controlled)
   - `SyncInfo` verification is completely bypassed

4. Vote is processed via `process_vote()` and aggregated into QC

**Broken Invariant:**
This violates **Cryptographic Correctness** (Invariant #10): "BLS signatures, VRF, and hash operations must be secure." The protocol makes security decisions based on unverified cryptographic data, specifically comparing verified QC rounds with potentially forged QC rounds in the timeout consistency check.

## Impact Explanation

**Severity: Medium to High**

While this vulnerability requires validator access (signing key), it creates multiple security risks:

1. **Safety Check Bypass**: The checks in `VoteMsg::verify()` become meaningless when SyncInfo is forged:
   - Round consistency check can be evaded
   - Timeout-to-SyncInfo consistency check compares verified data with unverified data

2. **Defense-in-Depth Violation**: The protocol assumes all cryptographic data is verified before use. This breaks that assumption.

3. **Future Risk**: Code that assumes SyncInfo has been verified could introduce new vulnerabilities.

4. **Protocol Invariant Violation**: Accepting consensus messages with unverified components violates the principle that all cryptographic data must be validated.

This does not immediately lead to consensus safety violations because the vote signature itself is still verified. However, it weakens the consensus protocol's safety guarantees and could be chained with other vulnerabilities.

**Classification: Medium Severity** - This represents a "significant protocol violation" per the bug bounty criteria, as it allows security checks to be bypassed with forged cryptographic data.

## Likelihood Explanation

**Likelihood: Medium**

- **Attacker Requirements**: Requires validator signing key (compromised validator or malicious insider)
- **Complexity**: Low - attacker simply sets SyncInfo rounds to not trigger `has_newer_certificates()`
- **Detectability**: Low - forged SyncInfo is never verified, so forgery goes undetected
- **Frequency**: Can be exploited on every vote message sent by compromised validator

## Recommendation

**Fix: Always verify SyncInfo before processing votes**

Modify `RoundManager::sync_up()` to always verify SyncInfo, even when it doesn't have newer certificates:

```rust
async fn sync_up(&mut self, sync_info: &SyncInfo, author: Author) -> anyhow::Result<()> {
    // ALWAYS verify SyncInfo first
    sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
        error!(
            SecurityEvent::InvalidSyncInfoMsg,
            sync_info = sync_info,
            remote_peer = author,
            error = ?e,
        );
        VerifyError::from(e)
    })?;
    
    let local_sync_info = self.block_store.sync_info();
    if sync_info.has_newer_certificates(&local_sync_info) {
        // Only use SyncInfo if it has newer certificates
        SYNC_INFO_RECEIVED_WITH_NEWER_CERT.inc();
        let result = self
            .block_store
            .add_certs(sync_info, self.create_block_retriever(author))
            .await;
        self.process_certificates().await?;
        result
    } else {
        Ok(())
    }
}
```

**Alternative: Verify in VoteMsg::verify()**

Move SyncInfo verification earlier to `VoteMsg::verify()` to fail fast:

```rust
pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
    // ... existing checks ...
    
    // Verify SyncInfo immediately
    self.sync_info.verify(validator)
        .context("Failed to verify SyncInfo in VoteMsg")?;
    
    self.vote().verify(validator)
}
```

This maintains the security guarantee that all cryptographic data is verified before acceptance.

## Proof of Concept

```rust
// Proof of Concept: Demonstrate SyncInfo verification bypass
// File: consensus/src/round_manager_test_verify_bypass.rs

#[tokio::test]
async fn test_syncinfo_verification_bypass() {
    use consensus_types::{vote_msg::VoteMsg, vote::Vote, sync_info::SyncInfo};
    use aptos_crypto::bls12381;
    
    // Setup: Create validator signer and verifier
    let (signers, validator_verifier) = random_validator_verifier(4, Some(2), false);
    let validator = &signers[0];
    
    // Step 1: Create a valid vote
    let vote_data = random_vote_data();
    let ledger_info = random_ledger_info();
    let vote = Vote::new(vote_data, validator.author(), ledger_info, validator).unwrap();
    
    // Step 2: Create FORGED SyncInfo with invalid signature
    let fake_qc = QuorumCert::new(
        random_vote_data(),
        LedgerInfoWithSignatures::new(
            random_ledger_info(),
            AggregateSignature::empty(), // FORGED - no valid signatures!
        ),
    );
    
    let forged_sync_info = SyncInfo::new(
        fake_qc, // Contains forged QC with invalid signatures
        random_wrapped_ledger_info(),
        None,
    );
    
    // Step 3: Create VoteMsg with valid vote but forged SyncInfo
    let vote_msg = VoteMsg::new(vote, forged_sync_info.clone());
    
    // Step 4: Verify VoteMsg - this SHOULD reject but PASSES
    let result = vote_msg.verify(validator.author(), &validator_verifier);
    assert!(result.is_ok(), "VoteMsg::verify() passed with forged SyncInfo!");
    
    // Step 5: Simulate sync_up() with forged SyncInfo that doesn't have newer certs
    // The verification is SKIPPED because has_newer_certificates() returns false
    
    // Step 6: Vote is accepted and can be aggregated into QC
    let mut pending_votes = PendingVotes::new();
    let reception_result = pending_votes.insert_vote(&vote_msg.vote(), &validator_verifier);
    
    // VULNERABILITY: Vote with never-verified SyncInfo is accepted!
    assert!(matches!(reception_result, VoteReceptionResult::VoteAdded(_)));
    
    println!("VULNERABILITY CONFIRMED: Vote with forged SyncInfo was accepted without verification!");
}
```

**Notes:**
- This PoC requires validator signing capabilities (test environment)
- The forged `SyncInfo` contains a `QuorumCert` with `AggregateSignature::empty()` (invalid)
- The verification bypass occurs because `has_newer_certificates()` returns false
- The vote is still aggregated despite the `SyncInfo` never being cryptographically verified

### Citations

**File:** consensus/consensus-types/src/vote_msg.rs (L56-81)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.vote().author() == sender,
            "Vote author {:?} is different from the sender {:?}",
            self.vote().author(),
            sender,
        );
        ensure!(
            self.vote().epoch() == self.sync_info.epoch(),
            "VoteMsg has different epoch"
        );
        ensure!(
            self.vote().vote_data().proposed().round() > self.sync_info.highest_round(),
            "Vote Round should be higher than SyncInfo"
        );
        if let Some((timeout, _)) = self.vote().two_chain_timeout() {
            ensure!(
                timeout.hqc_round() <= self.sync_info.highest_certified_round(),
                "2-chain Timeout hqc should be less or equal than the sync info hqc"
            );
        }
        // We're not verifying SyncInfo here yet: we are going to verify it only in case we need
        // it. This way we avoid verifying O(n) SyncInfo messages while aggregating the votes
        // (O(n^2) signature verifications).
        self.vote().verify(validator)
    }
```

**File:** consensus/src/round_manager.rs (L878-907)
```rust
    async fn sync_up(&mut self, sync_info: &SyncInfo, author: Author) -> anyhow::Result<()> {
        let local_sync_info = self.block_store.sync_info();
        if sync_info.has_newer_certificates(&local_sync_info) {
            info!(
                self.new_log(LogEvent::ReceiveNewCertificate)
                    .remote_peer(author),
                "Local state {},\n remote state {}", local_sync_info, sync_info
            );
            // Some information in SyncInfo is ahead of what we have locally.
            // First verify the SyncInfo (didn't verify it in the yet).
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
            SYNC_INFO_RECEIVED_WITH_NEWER_CERT.inc();
            let result = self
                .block_store
                .add_certs(sync_info, self.create_block_retriever(author))
                .await;
            self.process_certificates().await?;
            result
        } else {
            Ok(())
        }
    }
```

**File:** consensus/src/round_manager.rs (L1697-1716)
```rust
    pub async fn process_vote_msg(&mut self, vote_msg: VoteMsg) -> anyhow::Result<()> {
        fail_point!("consensus::process_vote_msg", |_| {
            Err(anyhow::anyhow!("Injected error in process_vote_msg"))
        });
        // Check whether this validator is a valid recipient of the vote.
        if self
            .ensure_round_and_sync_up(
                vote_msg.vote().vote_data().proposed().round(),
                vote_msg.sync_info(),
                vote_msg.vote().author(),
            )
            .await
            .context("[RoundManager] Stop processing vote")?
        {
            self.process_vote(vote_msg.vote())
                .await
                .context("[RoundManager] Add a new vote")?;
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/sync_info.rs (L218-223)
```rust
    pub fn has_newer_certificates(&self, other: &SyncInfo) -> bool {
        self.highest_certified_round() > other.highest_certified_round()
            || self.highest_timeout_round() > other.highest_timeout_round()
            || self.highest_ordered_round() > other.highest_ordered_round()
            || self.highest_commit_round() > other.highest_commit_round()
    }
```

**File:** consensus/src/pending_votes.rs (L275-481)
```rust
    pub fn insert_vote(
        &mut self,
        vote: &Vote,
        validator_verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        // derive data from vote
        let li_digest = vote.ledger_info().hash();

        //
        // 1. Has the author already voted for this round?
        //

        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }

        //
        // 2. Store new vote (or update, in case it's a new timeout vote)
        //

        self.author_to_vote
            .insert(vote.author(), (vote.clone(), li_digest));

        //
        // 3. Let's check if we can create a QC
        //

        let len = self.li_digest_to_votes.len() + 1;
        // obtain the ledger info with signatures associated to the vote's ledger info
        let (hash_index, status) = self.li_digest_to_votes.entry(li_digest).or_insert_with(|| {
            (
                len,
                VoteStatus::NotEnoughVotes(SignatureAggregator::new(vote.ledger_info().clone())),
            )
        });

        let validator_voting_power = validator_verifier.get_voting_power(&vote.author());

        if validator_voting_power.is_none() {
            warn!("Received vote from an unknown author: {}", vote.author());
            return VoteReceptionResult::UnknownAuthor(vote.author());
        }
        let validator_voting_power =
            validator_voting_power.expect("Author must exist in the validator set.");
        if validator_voting_power == 0 {
            warn!("Received vote with no voting power, from {}", vote.author());
        }
        let cur_epoch = vote.vote_data().proposed().epoch() as i64;
        let cur_round = vote.vote_data().proposed().round() as i64;
        counters::CONSENSUS_CURRENT_ROUND_QUORUM_VOTING_POWER
            .set(validator_verifier.quorum_voting_power() as f64);

        if !vote.is_timeout() {
            counters::CONSENSUS_CURRENT_ROUND_VOTED_POWER
                .with_label_values(&[&vote.author().to_string(), &hash_index_to_str(*hash_index)])
                .set(validator_voting_power as f64);
            counters::CONSENSUS_LAST_VOTE_EPOCH
                .with_label_values(&[&vote.author().to_string()])
                .set(cur_epoch);
            counters::CONSENSUS_LAST_VOTE_ROUND
                .with_label_values(&[&vote.author().to_string()])
                .set(cur_round);
        }

        let voting_power = match status {
            VoteStatus::EnoughVotes(li_with_sig) => {
                return VoteReceptionResult::NewQuorumCertificate(Arc::new(QuorumCert::new(
                    vote.vote_data().clone(),
                    li_with_sig.clone(),
                )));
            },
            VoteStatus::NotEnoughVotes(sig_aggregator) => {
                // add this vote to the signature aggregator
                sig_aggregator.add_signature(vote.author(), vote.signature_with_status());

                // check if we have enough signatures to create a QC
                match sig_aggregator.check_voting_power(validator_verifier, true) {
                    // a quorum of signature was reached, a new QC is formed
                    Ok(aggregated_voting_power) => {
                        assert!(
                                aggregated_voting_power >= validator_verifier.quorum_voting_power(),
                                "QC aggregation should not be triggered if we don't have enough votes to form a QC"
                            );
                        let verification_result = {
                            let _timer = counters::VERIFY_MSG
                                .with_label_values(&["vote_aggregate_and_verify"])
                                .start_timer();

                            sig_aggregator.aggregate_and_verify(validator_verifier).map(
                                |(ledger_info, aggregated_sig)| {
                                    LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                                },
                            )
                        };
                        match verification_result {
                            Ok(ledger_info_with_sig) => {
                                *status = VoteStatus::EnoughVotes(ledger_info_with_sig.clone());
                                return VoteReceptionResult::NewQuorumCertificate(Arc::new(
                                    QuorumCert::new(vote.vote_data().clone(), ledger_info_with_sig),
                                ));
                            },
                            Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => {
                                voting_power
                            },
                            Err(e) => return VoteReceptionResult::ErrorAggregatingSignature(e),
                        }
                    },

                    // not enough votes
                    Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => voting_power,

                    // error
                    Err(error) => {
                        error!(
                            "MUST_FIX: vote received could not be added: {}, vote: {}",
                            error, vote
                        );
                        return VoteReceptionResult::ErrorAddingVote(error);
                    },
                }
            },
        };

        //
        // 4. We couldn't form a QC, let's check if we can create a TC
        //

        if let Some((timeout, signature)) = vote.two_chain_timeout() {
            counters::CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER
                .with_label_values(&[&vote.author().to_string()])
                .set(validator_voting_power as f64);
            counters::CONSENSUS_LAST_TIMEOUT_VOTE_EPOCH
                .with_label_values(&[&vote.author().to_string()])
                .set(cur_epoch);
            counters::CONSENSUS_LAST_TIMEOUT_VOTE_ROUND
                .with_label_values(&[&vote.author().to_string()])
                .set(cur_round);

            let two_chain_votes = self
                .maybe_2chain_timeout_votes
                .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
            two_chain_votes.add(
                vote.author(),
                timeout.clone(),
                signature.clone(),
                RoundTimeoutReason::Unknown,
            );

            let partial_tc = two_chain_votes.partial_2chain_tc_mut();
            let tc_voting_power =
                match validator_verifier.check_voting_power(partial_tc.signers(), true) {
                    Ok(_) => {
                        return match partial_tc.aggregate_signatures(validator_verifier) {
                            Ok(tc_with_sig) => VoteReceptionResult::New2ChainTimeoutCertificate(
                                Arc::new(tc_with_sig),
                            ),
                            Err(e) => VoteReceptionResult::ErrorAggregatingTimeoutCertificate(e),
                        };
                    },
                    Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => voting_power,
                    Err(error) => {
                        error!(
                        "MUST_FIX: 2-chain timeout vote received could not be added: {}, vote: {}",
                        error, vote
                    );
                        return VoteReceptionResult::ErrorAddingVote(error);
                    },
                };

            // Echo timeout if receive f+1 timeout message.
            if !self.echo_timeout {
                let f_plus_one = validator_verifier.total_voting_power()
                    - validator_verifier.quorum_voting_power()
                    + 1;
                if tc_voting_power >= f_plus_one {
                    self.echo_timeout = true;
                    return VoteReceptionResult::EchoTimeout(tc_voting_power);
                }
            }
        }

        //
        // 5. No QC (or TC) could be formed, return the QC's voting power
        //

        VoteReceptionResult::VoteAdded(voting_power)
    }
```
