# Audit Report

## Title
Gas Undercharging in Type Info Native Functions Due to Deferred Gas Metering and Absence of Gas Correctness Tests

## Summary
The `native_type_of` and `native_type_name` functions in `type_info.rs` charge gas AFTER performing expensive operations (type-to-TypeTag conversion and canonical string generation), violating the fundamental "charge-first, compute-later" principle of blockchain gas metering. Combined with the complete absence of gas charging tests, this creates a gas undercharging vulnerability that enables DoS attacks through resource exhaustion.

## Finding Description
The vulnerability exists in the gas charging sequence of the type info native functions: [1](#0-0) 

The execution flow is:
1. **Line 55**: Charges minimal base gas (1102 units = ~551 microseconds computational budget)
2. **Line 57**: Calls `type_to_type_tag()` - performs expensive recursive type tree traversal, allocating TypeTag objects and checking pseudo-gas limits
3. **Line 60**: Calls `to_canonical_string()` - performs another expensive tree traversal to build formatted output string
4. **Line 64**: Finally charges per-byte gas based on string length (18 gas units per byte)

The developers explicitly acknowledge this is problematic: [2](#0-1) 

The pseudo-gas limits are meant to constrain complexity: [3](#0-2) 

However, these are complexity limits, not actual gas charges. The pseudo-gas mechanism charges an internal "cost" to prevent extreme cases but doesn't charge actual transaction gas until after the work completes.

**Attack Scenario:**

An attacker can create types with maximum allowed complexity:
- Transaction-level limits allow up to 128 type nodes with depth 20: [4](#0-3) 
- Generic instantiation allows up to 32 type parameters: [5](#0-4) 

Example malicious type: `Container<Struct1<T1>, Struct2<T2>, ..., Struct32<T32>>` where each type parameter is itself complex. This passes transaction validation but forces validators to:
1. Recursively traverse 60-100+ type nodes in `type_to_type_tag`
2. Traverse them again in `to_canonical_string`  
3. Perform allocations, string formatting, pseudo-gas checks

If the pseudo-gas limit is exceeded during conversion, the transaction aborts but the validator has already performed significant work processing type nodes, paying only the base 1102 gas units.

**Invariant Violation:**

This breaks the "Resource Limits" invariant: [6](#0-5) 

The gas charged should cover computational cost BEFORE operations execute, not after.

**Testing Gap:**

There are NO tests validating gas charging correctness: [7](#0-6) 

The only test (`test_type_of_internal`) validates functional correctness, not gas metering. Without gas correctness tests, bugs in gas parameter calibration, changes to underlying operations' complexity, or gas charging logic errors go undetected.

## Impact Explanation
This qualifies as **High Severity** under Aptos bug bounty criteria for "Validator node slowdowns":

An attacker can spam transactions calling `type_of<T>()` or `type_name<T>()` with maximally complex types. Each transaction:
- Forces validators to perform milliseconds of type tree traversal and string formatting
- Pays only 1102 base gas (551 microseconds budget) if operations fail
- Pays under-calibrated gas even if operations succeed

At scale, this enables:
1. **Resource Exhaustion**: Validators waste CPU cycles on undercharged operations
2. **Transaction Throughput Degradation**: Expensive operations crowd out legitimate transactions
3. **Economic Attack**: Cost to attacker is minimal (base gas only), but cost to network is high (actual CPU time)

The gas calibration shows computational gas is valued at ~0.5 microseconds per unit: [8](#0-7) 

Processing complex type trees can take multiple milliseconds, but only microseconds of gas are charged upfront.

## Likelihood Explanation
**Likelihood: High**

- **Ease of Exploitation**: Any user can submit transactions with complex generic types
- **No Special Permissions**: Doesn't require validator access or special capabilities
- **Low Cost**: Attacker pays minimal gas per attack transaction
- **Immediate Impact**: Each malicious transaction immediately wastes validator resources
- **Scalability**: Attack can be trivially scaled by submitting many transactions

The TODO comment indicates developers are aware of the issue but haven't addressed it, and the absence of tests means it will persist across code changes.

## Recommendation

**Immediate Fix:**

1. **Charge gas proportionally BEFORE expensive operations:**

```rust
fn native_type_of(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.is_empty());

    context.charge(TYPE_INFO_TYPE_OF_BASE)?;
    
    // NEW: Estimate type complexity and charge upfront
    let estimated_complexity = estimate_type_complexity(&ty_args[0])?;
    let estimated_gas = TYPE_INFO_TYPE_OF_PER_BYTE_IN_STR * NumBytes::new(estimated_complexity);
    context.charge(estimated_gas)?;
    
    let type_tag = context.type_to_type_tag(&ty_args[0])?;
    let type_tag_str = type_tag.to_canonical_string();
    
    // Charge any remaining gas based on actual vs estimated
    let actual_length = type_tag_str.len() as u64;
    if actual_length > estimated_complexity {
        let additional = TYPE_INFO_TYPE_OF_PER_BYTE_IN_STR * NumBytes::new(actual_length - estimated_complexity);
        context.charge(additional)?;
    }
    
    // ... rest of function
}
```

2. **Add comprehensive gas correctness tests:**

```rust
#[test]
fn test_type_of_gas_charging() {
    // Test various type complexities
    // Verify gas charged is proportional to work done
    // Test edge cases: max depth, max nodes, max type parameters
    // Verify operations fail gracefully with correct gas charged
}

#[test]
fn test_type_name_gas_charging() {
    // Similar tests for type_name
}

#[test]
fn test_gas_parameter_calibration() {
    // Benchmark actual computational cost
    // Verify gas parameters (1102, 18) are correctly calibrated
}
```

3. **Add fuzzing tests for gas metering edge cases**

4. **Document gas charging invariants and validation in code comments**

## Proof of Concept

```move
// malicious_type_complexity.move
module attacker::gas_attack {
    use std::type_info;
    
    // Create deeply nested generic structs
    struct Layer1<T> { value: T }
    struct Layer2<T> { value: Layer1<T> }
    struct Layer3<T> { value: Layer2<T> }
    
    // Container with maximum type parameters (32 in production)
    struct Complex<T1, T2, T3, T4, T5, T6, T7, T8,
                   T9, T10, T11, T12, T13, T14, T15, T16,
                   T17, T18, T19, T20, T21, T22, T23, T24,
                   T25, T26, T27, T28, T29, T30, T31, T32> {
        dummy: u64
    }
    
    // Attack entry point
    public entry fun exploit() {
        // Force expensive type_to_type_tag operations
        // Each call processes 32 complex type parameters
        type_info::type_of<Complex<
            Layer3<u64>, Layer3<u128>, Layer3<u256>, Layer3<address>,
            Layer3<u64>, Layer3<u128>, Layer3<u256>, Layer3<address>,
            Layer3<u64>, Layer3<u128>, Layer3<u256>, Layer3<address>,
            Layer3<u64>, Layer3<u128>, Layer3<u256>, Layer3<address>,
            Layer3<u64>, Layer3<u128>, Layer3<u256>, Layer3<address>,
            Layer3<u64>, Layer3<u128>, Layer3<u256>, Layer3<address>,
            Layer3<u64>, Layer3<u128>, Layer3<u256>, Layer3<address>,
            Layer3<u64>, Layer3<u128>, Layer3<u256>, Layer3<address>
        >>();
        
        // Spam this across many transactions to degrade validator performance
    }
}
```

**Exploitation Steps:**
1. Deploy the malicious module
2. Submit hundreds of transactions calling `exploit()`
3. Each transaction forces validators to traverse 32 * 4 = 128 type nodes
4. Validators perform milliseconds of work per transaction
5. Attacker pays minimal gas (base + small per-byte cost)
6. Network throughput degrades as validators waste CPU on undercharged operations

**Notes:**

The absence of gas correctness tests means this issue will persist and could worsen as the codebase evolves. Changes to `type_to_type_tag` or `to_canonical_string` complexity will not trigger test failures, allowing gas undercharging bugs to accumulate. This violates Move VM Safety invariant #3: "Bytecode execution must respect gas limits and memory constraints."

### Citations

**File:** aptos-move/framework/src/natives/type_info.rs (L44-45)
```rust
 *   gas cost: base_cost + unit_cost * type_size
 *
```

**File:** aptos-move/framework/src/natives/type_info.rs (L55-64)
```rust
    context.charge(TYPE_INFO_TYPE_OF_BASE)?;

    let type_tag = context.type_to_type_tag(&ty_args[0])?;

    if context.eval_gas(TYPE_INFO_TYPE_OF_PER_BYTE_IN_STR) > 0.into() {
        let type_tag_str = type_tag.to_canonical_string();
        // Ideally, we would charge *before* the `type_to_type_tag()` and `type_tag.to_string()` calls above.
        // But there are other limits in place that prevent this native from being called with too much work.
        context
            .charge(TYPE_INFO_TYPE_OF_PER_BYTE_IN_STR * NumBytes::new(type_tag_str.len() as u64))?;
```

**File:** aptos-move/framework/src/natives/type_info.rs (L147-182)
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use move_core_types::{account_address::AccountAddress, identifier::Identifier};
    use move_vm_types::values::VMValueCast;

    #[test]
    fn test_type_of_internal() {
        let dummy_st = StructTag {
            address: AccountAddress::random(),
            module: Identifier::new("DummyModule").unwrap(),
            name: Identifier::new("DummyStruct").unwrap(),
            type_args: vec![TypeTag::Vector(Box::new(TypeTag::U8))],
        };

        let dummy_as_strings = dummy_st.to_canonical_string();
        let mut dummy_as_strings = dummy_as_strings.split("::");
        let dummy_as_type_of = type_of_internal(&dummy_st).unwrap().pop().unwrap();
        let dummy_as_type_of: Struct = dummy_as_type_of.cast().unwrap();
        let mut dummy_as_type_of = dummy_as_type_of.unpack().unwrap();

        let account_addr =
            AccountAddress::from_hex_literal(dummy_as_strings.next().unwrap()).unwrap();
        assert!(Value::address(account_addr)
            .equals(&dummy_as_type_of.next().unwrap())
            .unwrap());
        let module = dummy_as_strings.next().unwrap().as_bytes().to_owned();
        assert!(Value::vector_u8(module)
            .equals(&dummy_as_type_of.next().unwrap())
            .unwrap());
        let name = dummy_as_strings.next().unwrap().as_bytes().to_owned();
        assert!(Value::vector_u8(name)
            .equals(&dummy_as_type_of.next().unwrap())
            .unwrap());
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L158-159)
```rust
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L246-249)
```rust
        // 5000 limits type tag total size < 5000 bytes and < 50 nodes.
        type_max_cost: 5000,
        type_base_cost: 100,
        type_byte_cost: 1,
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L50-51)
```rust
        // ~5 microseconds should equal one unit of computational gas. We bound the maximum
        // computational time of any given transaction at roughly 20 seconds. We want this number and
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L266-274)
```rust
            max_ty_size: NumTypeNodes,
            { RELEASE_V1_15.. => "max_ty_size" },
            128,
        ],
        [
            max_ty_depth: NumTypeNodes,
            { RELEASE_V1_15.. => "max_ty_depth" },
            20,
        ],
```
