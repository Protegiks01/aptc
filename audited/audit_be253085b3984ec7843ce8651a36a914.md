# Audit Report

## Title
State Proof Verification Bypass in DbStateView During Merkle Tree Pruning Window

## Summary
A critical logic flaw in `DbStateView::get()` allows state values to be returned without cryptographic verification during an 89-million version pruning window, breaking the fundamental security guarantee of "verified" state views. The vulnerability stems from mismatched pruning configurations between the State Merkle database (1M versions) and State KV database (90M versions), combined with silent error handling that skips proof verification when the Merkle tree is unavailable.

## Finding Description

The `DbStateView` provides a "verified" state view that cryptographically validates all state reads against a trusted state root hash. However, the implementation contains a critical flaw in the verification logic. [1](#0-0) 

The code attempts to verify state values by:
1. Calling `get_state_value_with_proof_by_version` to retrieve the value with a Merkle proof
2. Verifying the proof against the expected root hash
3. Then calling `get_state_value_with_version_by_version` to return the actual value

**The Critical Flaw**: The verification is wrapped in `if let Ok((value, proof))` which silently skips verification if `get_state_value_with_proof_by_version` returns an error. When verification is skipped, the code proceeds to return an **unverified** value from the second database call.

This becomes exploitable due to a massive mismatch in pruning configurations: [2](#0-1) 

The State Merkle pruner keeps only **1 million versions** while the State KV pruner keeps **90 million versions**, creating an 89-million version vulnerability window where:
- State KV data exists and can be queried
- Merkle tree roots are pruned and unavailable
- Proof verification is silently skipped
- Unverified state values are returned

The pruning checks confirm this behavior: [3](#0-2) [4](#0-3) 

During the vulnerability window, `get_state_value_with_proof_by_version_ext` fails the merkle pruning check, while `get_state_value_with_version_by_version` succeeds with the KV pruning check.

## Impact Explanation

**Severity: Critical** - This breaks Invariant #4 (State Consistency: State transitions must be atomic and verifiable via Merkle proofs).

The vulnerability enables:

1. **Consensus Safety Violations**: If validators query state during the window and receive different values due to database inconsistencies, they may produce different state roots, causing chain splits.

2. **State Corruption Propagation**: If database corruption occurs (via bugs, storage errors, or attacks), the corruption will not be detected during reads in the vulnerability window, allowing invalid state to propagate through the system.

3. **Verification Bypass**: The `VerifiedStateViewAtVersion` trait promises cryptographic verification but fails to deliver during 98.9% of the prunable history (89M out of 90M versions).

This meets **Critical Severity** criteria as it can cause consensus/safety violations and non-recoverable network partitions if validators diverge on state values during execution.

## Likelihood Explanation

**Likelihood: High** - This vulnerability is actively present in the default configuration and affects all nodes:

1. **Always Active**: The pruning window exists on all nodes running default configurations
2. **Long Duration**: The 89M version window represents months of history on a high-throughput network
3. **Common Access Pattern**: Historical state queries are common for:
   - State sync operations
   - Archive node queries  
   - Debugging and analysis tools
   - Smart contract execution that reads older state

While exploitation requires either database corruption or deliberate manipulation, the verification bypass itself occurs automatically and continuously, creating a persistent security gap.

## Recommendation

**Immediate Fix**: The verification should fail loudly rather than silently skip when proof retrieval fails:

```rust
fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
    if let Some(version) = self.version {
        if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
            // FIXED: Always attempt verification, never skip
            let (value, proof) = self.db.get_state_value_with_proof_by_version(key, version)?;
            proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
            return Ok(value.map(|v| (version, v))); // Return verified value
        }
        Ok(self.db.get_state_value_with_version_by_version(key, version)?)
    } else {
        Ok(None)
    }
}
```

**Configuration Fix**: Align pruning windows to eliminate the gap: [5](#0-4) 

Set `state_merkle_pruner_config.prune_window` to match `ledger_pruner_config.prune_window` (90M versions) to ensure Merkle proofs are available for all queryable state.

## Proof of Concept

```rust
// Reproduction steps in Rust integration test:
#[test]
fn test_verification_bypass_in_pruning_window() {
    let (db, _) = create_test_db_with_history(100_000_000); // Create 100M versions
    
    // Query a version in the vulnerability window 
    // (between latest-90M and latest-1M)
    let vulnerable_version = 10_000_000; // 10M versions old
    let latest_li = db.reader.get_latest_ledger_info().unwrap();
    
    // Create a "verified" state view
    let state_view = db.reader
        .verified_state_view_at_version(Some(vulnerable_version), &latest_li)
        .unwrap();
    
    // Try to read state - this will skip verification!
    let test_key = StateKey::raw(b"test_key");
    let result = state_view.get_state_slot(&test_key);
    
    // Result succeeds but value was NOT cryptographically verified
    // If database corruption existed, it would not be detected
    assert!(result.is_ok());
    
    // Verification: Check that Merkle tree is pruned at this version
    let proof_result = db.reader.get_state_proof_by_version_ext(
        test_key.crypto_hash_ref(),
        vulnerable_version,
        0,
        false
    );
    assert!(proof_result.is_err()); // Merkle tree pruned
    
    // But State KV is still available
    let kv_result = db.reader.get_state_value_with_version_by_version(
        &test_key,
        vulnerable_version
    );
    assert!(kv_result.is_ok()); // KV not pruned
    
    // Conclusion: Verification was bypassed!
}
```

## Notes

The vulnerability affects the `VerifiedStateViewAtVersion` implementation which is used in critical paths including executor test helpers for verifying account balances and state consistency. The 89M version window represents a significant portion of blockchain history where state reads lack cryptographic guarantees, violating the core security model of Aptos's authenticated state storage.

### Citations

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L27-46)
```rust
    fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
        if let Some(version) = self.version {
            if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
                // TODO(aldenhu): sample-verify proof inside DB
                // DB doesn't support returning proofs for buffered state, so only optionally
                // verify proof.
                // TODO: support returning state proof for buffered state.
                if let Ok((value, proof)) =
                    self.db.get_state_value_with_proof_by_version(key, version)
                {
                    proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
                }
            }
            Ok(self
                .db
                .get_state_value_with_version_by_version(key, version)?)
        } else {
            Ok(None)
        }
    }
```

**File:** config/src/config/storage_config.rs (L387-412)
```rust
impl Default for LedgerPrunerConfig {
    fn default() -> Self {
        LedgerPrunerConfig {
            enable: true,
            prune_window: 90_000_000,
            batch_size: 5_000,
            user_pruning_window_offset: 200_000,
        }
    }
}

impl Default for StateMerklePrunerConfig {
    fn default() -> Self {
        StateMerklePrunerConfig {
            enable: true,
            // This allows a block / chunk being executed to have access to a non-latest state tree.
            // It needs to be greater than the number of versions the state committing thread is
            // able to commit during the execution of the block / chunk. If the bad case indeed
            // happens due to this being too small, a node restart should recover it.
            // Still, defaulting to 1M to be super safe.
            prune_window: 1_000_000,
            // A 10k transaction block (touching 60k state values, in the case of the account
            // creation benchmark) on a 4B items DB (or 1.33B accounts) yields 300k JMT nodes
            batch_size: 1_000,
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L644-655)
```rust
    fn get_state_value_with_version_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<Option<(Version, StateValue)>> {
        gauged_api("get_state_value_with_version_by_version", || {
            self.error_if_state_kv_pruned("StateValue", version)?;

            self.state_store
                .get_state_value_with_version_by_version(state_key, version)
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L677-694)
```rust
    fn get_state_value_with_proof_by_version_ext(
        &self,
        key_hash: &HashValue,
        version: Version,
        root_depth: usize,
        use_hot_state: bool,
    ) -> Result<(Option<StateValue>, SparseMerkleProofExt)> {
        gauged_api("get_state_value_with_proof_by_version_ext", || {
            self.error_if_state_merkle_pruned("State merkle", version)?;

            self.state_store.get_state_value_with_proof_by_version_ext(
                key_hash,
                version,
                root_depth,
                use_hot_state,
            )
        })
    }
```
