# Audit Report

## Title
Malicious Validators Can Certify Backdoored APKs with Predictable Randomness Values

## Summary
The APK certification process does not verify that the randomness factor `r` used to create augmented public keys was generated with proper entropy. Byzantine validators (< 1/3) can create APKs with predictable `r` values that pass all cryptographic checks, enabling them to know their exact contributions to future randomness outputs and potentially bias or predict randomness generation.

## Finding Description

The vulnerability exists in the APK certification flow for the Pinkas Weighted VUF randomness scheme. When a validator broadcasts their `AugmentedData` containing a delta value `(pi=g^r, rks=[g^(r*sk[i])])`, the verification only checks cryptographic consistency through a pairing equation, but does not verify that `r` was generated with proper entropy. [1](#0-0) 

The `add_certified_apk()` function performs no validation itself, relying entirely on upstream verification. [2](#0-1) 

This function is called through `add_certified_delta()` which invokes `derive_apk()` for verification. [3](#0-2) 

The verification in `augment_pubkey()` only checks that the pairing equation holds: [4](#0-3) 

This pairing check at lines 134-140 verifies: `e(delta.pi, Σ(pk[j]^tau^j)) = e(Σ(rks[j]^tau^j), g_hat)`

**The Critical Flaw:** This equation will pass for ANY value of `r` (random or predictable), as long as `pi` and `rks` are internally consistent. There is no verification that `r` was chosen randomly or unpredictably.

**Attack Path:**

1. A Byzantine validator modifies their node software to use a predictable/known value for `r` when generating their augmented key pair, instead of the standard random generation: [5](#0-4) 

2. They generate `delta = (pi=g^r_known, rks=[g^(r_known*sk[i])])` with this predictable `r`

3. They broadcast this in their `AugmentedData` [6](#0-5) 

4. Honest validators receive and verify it through the verification task: [7](#0-6) 

5. The verification passes because the delta is cryptographically consistent, and honest validators sign it: [8](#0-7) 

6. Once 2/3+1 signatures are collected (including honest validators), the `CertifiedAugData` is created: [9](#0-8) 

7. All validators add this backdoored APK to their certified APKs through the `augment()` function: [10](#0-9) 

8. When generating randomness shares, the malicious validator knows their exact contribution since they know `r^{-1}`: [11](#0-10) 

Their share is `H(msg)^(r^{-1})` where `r^{-1}` is known to them.

9. Multiple colluding Byzantine validators (< 1/3) can coordinate their known `r` values to bias the randomness aggregation: [12](#0-11) 

## Impact Explanation

This vulnerability breaks the **Cryptographic Correctness** invariant for VRF/VUF operations. Byzantine validators should have zero ability to predict or bias on-chain randomness, but this vulnerability gives them:

1. **Perfect knowledge of their randomness contributions** - They know exactly what `share = H(msg)^(r^{-1})` will be
2. **Coordination capabilities** - Multiple colluding validators can coordinate their known contributions
3. **Selective participation** - They could potentially choose when to participate based on partial knowledge

The impact qualifies as **High Severity** under the Aptos Bug Bounty criteria:
- **Significant protocol violation**: Breaks the unpredictability guarantee of the VUF-based randomness beacon
- **Consensus integrity risk**: Randomness is used for critical consensus operations including leader election
- **Economic impact**: Biased randomness could affect validator selection, rewards, and on-chain applications depending on randomness

While Byzantine validators with < 1/3 stake cannot fully predict the final randomness (requires threshold shares), having ANY ability to bias or gain information about randomness is a critical security flaw for a randomness beacon.

## Likelihood Explanation

**Likelihood: High**

- Byzantine validators are explicitly part of the Aptos threat model (< 1/3 Byzantine tolerance)
- The attack requires only modifying the validator node software, which is entirely feasible for a Byzantine actor
- No external coordination or timing attacks needed
- The vulnerability affects every epoch's randomness generation
- Economic incentives exist for validators to bias randomness (leader selection, validator selection, etc.)
- Once a backdoored APK is certified, it persists for the entire epoch

## Recommendation

Add entropy verification to the APK certification process. The system should verify that the `r` value was generated with proper randomness, not just that it's cryptographically consistent.

**Recommended Fix:**

1. **Commit-Reveal Scheme**: Require validators to commit to their `delta` value before revealing it, making it impossible to adaptively choose predictable values

2. **Verifiable Random Generation**: Use a verifiable delay function (VDF) or similar mechanism to prove that `r` was derived from unpredictable sources

3. **Cross-Validation**: Require validators to include a proof that their `r` was derived from the previous epoch's randomness output, making it impossible to pre-compute

4. **Minimum Entropy Check**: Add validation in `augment_pubkey()` to reject deltas that appear to have low entropy (though this is hard to implement cryptographically)

The most practical solution would be option 1 or 3, adding additional fields to `AugmentedData`:

```rust
pub struct AugmentedData {
    delta: Delta,
    fast_delta: Option<Delta>,
    // Add commitment to previous randomness
    randomness_commitment: HashValue,
}
```

And verify in the `verify()` function that the delta was derived deterministically from unpredictable sources.

## Proof of Concept

A Byzantine validator would modify `epoch_manager.rs` to replace the random `r` generation:

```rust
// Original secure code (line 1102-1104):
let mut rng = StdRng::from_rng(thread_rng()).map_err(...)?;
let augmented_key_pair = WVUF::augment_key_pair(&vuf_pp, sk.main, pk.main, &mut rng);

// Malicious modification:
let mut predictable_rng = StdRng::seed_from_u64(12345); // Fixed seed
let augmented_key_pair = WVUF::augment_key_pair(&vuf_pp, sk.main, pk.main, &mut predictable_rng);
```

The resulting APK would pass all verification checks, but the validator would know `r^{-1}` precisely, enabling them to compute their exact share `H(msg)^(r^{-1})` for any message before participating in randomness generation.

**To demonstrate:** A test could be created showing that two different `r` values (one random, one predictable) both produce APKs that pass `augment_pubkey()` verification, proving the vulnerability exists.

---

**Notes**

The vulnerability is particularly concerning because:
- The security question specifically asks about Byzantine validators, placing this attack within the stated threat model
- The certification threshold (2/3+1) means honest validators unwittingly enable the attack by signing backdoored APKs
- No equivocation detection helps here since validators only broadcast one APK
- The impact compounds with multiple colluding Byzantine validators

### Citations

**File:** types/src/randomness.rs (L128-136)
```rust
    pub fn add_certified_apk(&self, index: usize, apk: APK) -> anyhow::Result<()> {
        assert!(index < self.certified_apks.len());
        if self.certified_apks[index].get().is_some() {
            return Ok(());
        }
        self.certified_apks[index].set(apk).unwrap();
        Ok(())
    }
}
```

**File:** consensus/src/rand/rand_gen/types.rs (L97-148)
```rust
    fn aggregate<'a>(
        shares: impl Iterator<Item = &'a RandShare<Self>>,
        rand_config: &RandConfig,
        rand_metadata: RandMetadata,
    ) -> anyhow::Result<Randomness>
    where
        Self: Sized,
    {
        let timer = std::time::Instant::now();
        let mut apks_and_proofs = vec![];
        for share in shares {
            let id = rand_config
                .validator
                .address_to_validator_index()
                .get(share.author())
                .copied()
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with invalid share author: {}",
                        share.author
                    )
                })?;
            let apk = rand_config
                .get_certified_apk(share.author())
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with missing apk for share from {}",
                        share.author
                    )
                })?;
            apks_and_proofs.push((Player { id }, apk.clone(), share.share().share));
        }

        let proof = WVUF::aggregate_shares(&rand_config.wconfig, &apks_and_proofs);
        let metadata_serialized = bcs::to_bytes(&rand_metadata).map_err(|e| {
            anyhow!("Share::aggregate failed with metadata serialization error: {e}")
        })?;
        let eval = WVUF::derive_eval(
            &rand_config.wconfig,
            &rand_config.vuf_pp,
            metadata_serialized.as_slice(),
            &rand_config.get_all_certified_apk(),
            &proof,
            THREAD_MANAGER.get_exe_cpu_pool(),
        )
        .map_err(|e| anyhow!("Share::aggregate failed with WVUF derive_eval error: {e}"))?;
        debug!("WVUF derivation time: {} ms", timer.elapsed().as_millis());
        let eval_bytes = bcs::to_bytes(&eval)
            .map_err(|e| anyhow!("Share::aggregate failed with eval serialization error: {e}"))?;
        let rand_bytes = Sha3_256::digest(eval_bytes.as_slice()).to_vec();
        Ok(Randomness::new(rand_metadata, rand_bytes))
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L151-176)
```rust
impl TAugmentedData for AugmentedData {
    fn generate(rand_config: &RandConfig, fast_rand_config: &Option<RandConfig>) -> AugData<Self>
    where
        Self: Sized,
    {
        let delta = rand_config.get_my_delta().clone();
        rand_config
            .add_certified_delta(&rand_config.author(), delta.clone())
            .expect("Add self delta should succeed");

        let fast_delta = if let Some(fast_config) = fast_rand_config.as_ref() {
            let fast_delta = fast_config.get_my_delta().clone();
            fast_config
                .add_certified_delta(&rand_config.author(), fast_delta.clone())
                .expect("Add self delta for fast path should succeed");
            Some(fast_delta)
        } else {
            None
        };

        let data = AugmentedData {
            delta: delta.clone(),
            fast_delta,
        };
        AugData::new(rand_config.epoch(), rand_config.author(), data)
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L178-194)
```rust
    fn augment(
        &self,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        author: &Author,
    ) {
        let AugmentedData { delta, fast_delta } = self;
        rand_config
            .add_certified_delta(author, delta.clone())
            .expect("Add delta should succeed");

        if let (Some(config), Some(fast_delta)) = (fast_rand_config, fast_delta) {
            config
                .add_certified_delta(author, fast_delta.clone())
                .expect("Add delta for fast path should succeed");
        }
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L651-654)
```rust
    pub fn add_certified_apk(&self, peer: &Author, apk: APK) -> anyhow::Result<()> {
        let index = self.get_id(peer);
        self.keys.add_certified_apk(index, apk)
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L656-665)
```rust
    fn derive_apk(&self, peer: &Author, delta: Delta) -> anyhow::Result<APK> {
        let apk = WVUF::augment_pubkey(&self.vuf_pp, self.get_pk_share(peer).clone(), delta)?;
        Ok(apk)
    }

    pub fn add_certified_delta(&self, peer: &Author, delta: Delta) -> anyhow::Result<()> {
        let apk = self.derive_apk(peer, delta)?;
        self.add_certified_apk(peer, apk)?;
        Ok(())
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L108-143)
```rust
    fn augment_pubkey(
        pp: &Self::PublicParameters,
        pk: Self::PubKeyShare,
        // lpk: &Self::BlsPubKey,
        delta: Self::Delta,
    ) -> anyhow::Result<Self::AugmentedPubKeyShare> {
        if delta.rks.len() != pk.len() {
            bail!(
                "Expected PKs and RKs to be of the same length. Got {} and {}, respectively.",
                delta.rks.len(),
                pk.len()
            );
        }

        // TODO: Fiat-Shamir transform instead of RNG
        let tau = random_scalar(&mut thread_rng());

        let pks = pk
            .iter()
            .map(|pk| *pk.as_group_element())
            .collect::<Vec<G2Projective>>();
        let taus = get_powers_of_tau(&tau, pks.len());

        let pks_combined = g2_multi_exp(&pks[..], &taus[..]);
        let rks_combined = g1_multi_exp(&delta.rks[..], &taus[..]);

        if multi_pairing(
            [&delta.pi, &rks_combined].into_iter(),
            [&pks_combined, &pp.g_hat.neg()].into_iter(),
        ) != Gt::identity()
        {
            bail!("RPKs were not correctly randomized.");
        }

        Ok((delta, pk))
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L145-151)
```rust
    fn create_share(ask: &Self::AugmentedSecretKeyShare, msg: &[u8]) -> Self::ProofShare {
        let (r_inv, _) = ask;

        let hash = Self::hash_to_curve(msg);

        hash.mul(r_inv)
    }
```

**File:** consensus/src/epoch_manager.rs (L1102-1104)
```rust
            let mut rng =
                StdRng::from_rng(thread_rng()).map_err(NoRandomnessReason::RngCreationError)?;
            let augmented_key_pair = WVUF::augment_key_pair(&vuf_pp, sk.main, pk.main, &mut rng);
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L221-261)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingRandGenRequest>,
        verified_msg_tx: UnboundedSender<RpcRequest<S, D>>,
        rand_config: RandConfig,
        fast_rand_config: Option<RandConfig>,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(rand_gen_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = rand_config.clone();
            let fast_config_clone = fast_rand_config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
                        Ok(msg) => {
                            if msg
                                .verify(
                                    &epoch_state_clone,
                                    &config_clone,
                                    &fast_config_clone,
                                    rand_gen_msg.sender,
                                )
                                .is_ok()
                            {
                                let _ = tx.unbounded_send(RpcRequest {
                                    req: msg,
                                    protocol: rand_gen_msg.protocol,
                                    response_sender: rand_gen_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid rand gen message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L102-115)
```rust
    pub fn add_aug_data(&mut self, data: AugData<D>) -> anyhow::Result<AugDataSignature> {
        if let Some(existing_data) = self.data.get(data.author()) {
            ensure!(
                existing_data == &data,
                "[AugDataStore] equivocate data from {}",
                data.author()
            );
        } else {
            self.db.save_aug_data(&data)?;
        }
        let sig = AugDataSignature::new(self.epoch, self.signer.sign(&data)?);
        self.data.insert(*data.author(), data);
        Ok(sig)
    }
```

**File:** consensus/src/rand/rand_gen/reliable_broadcast_state.rs (L48-66)
```rust
    fn add(&self, peer: Author, ack: Self::Response) -> anyhow::Result<Option<Self::Aggregated>> {
        ack.verify(peer, &self.epoch_state.verifier, &self.aug_data)?;
        let mut parital_signatures_guard = self.partial_signatures.lock();
        parital_signatures_guard.add_signature(peer, ack.into_signature());
        let qc_aug_data = self
            .epoch_state
            .verifier
            .check_voting_power(parital_signatures_guard.signatures().keys(), true)
            .ok()
            .map(|_| {
                let aggregated_signature = self
                    .epoch_state
                    .verifier
                    .aggregate_signatures(parital_signatures_guard.signatures_iter())
                    .expect("Signature aggregation should succeed");
                CertifiedAugData::new(self.aug_data.clone(), aggregated_signature)
            });
        Ok(qc_aug_data)
    }
```
