# Audit Report

## Title
Consensus Publisher Channel Send Failures Not Tracked in Metrics Leading to Undetected Observer Network Degradation

## Summary
The `publish_message()` function in the consensus publisher fails to track channel send errors in metrics, relying only on log warnings. When the outbound message channel fills up with many subscribers, widespread send failures go unnoticed, degrading observer network health without triggering metric-based alerts.

## Finding Description

The consensus publisher's `publish_message()` function sends consensus updates to all active subscribers using a bounded channel with capacity of 1000 messages. [1](#0-0) 

When publishing messages, the function iterates through all active subscribers and uses `try_send()` to queue messages to an internal channel. [2](#0-1) 

When `try_send()` fails (e.g., channel full), the error is only logged as a warning with no metric increment. [3](#0-2) 

The `PUBLISHER_SENT_MESSAGE_ERRORS` metric exists but is only incremented for network-level send failures in the serialization/sending task, not for channel send failures. [4](#0-3) 

**Exploitation Scenario:**

1. Publisher has 100 active subscribers
2. Message serialization/network sending is slower than message production
3. Each `publish_message()` call queues 100 messages (one per subscriber)
4. After 10 consensus updates, the 1000-capacity channel fills up
5. All subsequent `try_send()` calls fail for all subscribers
6. Only log warnings appear - no metrics spike to alert operators
7. Observer network stops receiving updates but appears healthy in metric dashboards

## Impact Explanation

This qualifies as **Medium severity** per the security question scope, affecting observer network operational health:

- **Observer Network Degradation**: All observers stop receiving consensus updates when the channel fills, causing them to fall behind consensus
- **Silent Failure Mode**: Operators monitoring metrics won't detect the issue since channel send errors aren't tracked
- **No Self-Healing**: Failed subscribers remain in the active subscriber list, continuing to cause failures
- **Requires Manual Intervention**: Operators must analyze logs to detect and diagnose the issue

However, this does NOT affect:
- Core consensus safety or liveness (observers are auxiliary components)
- Blockchain state consistency
- Fund security
- Validator operations

The impact is limited to degraded observer network quality-of-service, not core blockchain security.

## Likelihood Explanation

**High likelihood** in networks with:
- Many observer nodes (50-100+ subscribers)
- High consensus block production rate
- Slow network conditions or message serialization bottlenecks
- Insufficient channel capacity relative to subscriber count

The issue occurs naturally without requiring attacker action when system load exceeds channel capacity.

## Recommendation

Add metric tracking for channel send failures:

```rust
// In publish_message() function, after try_send() fails:
if let Err(error) = outbound_message_sender.try_send((*peer_network_id, message.clone())) {
    warn!(LogSchema::new(LogEntry::ConsensusPublisher)
        .event(LogEvent::SendDirectSendMessage)
        .message(&format!(
            "Failed to send outbound message to the receiver for peer {:?}! Error: {:?}",
            peer_network_id, error
        )));
    
    // ADD THIS: Track channel send failures in metrics
    metrics::increment_counter(
        &metrics::PUBLISHER_SENT_MESSAGE_ERRORS,
        "channel_send_failed",
        peer_network_id,
    );
}
```

Additionally:
1. Add aggregated error count metric per publishing round
2. Implement circuit breaker to remove consistently failing subscribers
3. Consider increasing default channel capacity based on expected subscriber count
4. Add health check endpoint that reports recent send failure rates

## Proof of Concept

```rust
#[tokio::test]
async fn test_channel_overflow_with_many_subscribers() {
    use futures::StreamExt;
    
    // Create publisher with small channel size
    let config = ConsensusObserverConfig {
        max_network_channel_size: 10, // Small channel for testing
        ..Default::default()
    };
    
    let network_id = NetworkId::Public;
    let peers_and_metadata = PeersAndMetadata::new(&[network_id]);
    let network_client = NetworkClient::new(vec![], vec![], hashmap![], peers_and_metadata);
    let client = Arc::new(ConsensusObserverClient::new(network_client));
    
    let (publisher, mut receiver) = ConsensusPublisher::new(config, client);
    
    // Add 20 subscribers (exceeds channel capacity of 10)
    let mut subscribers = vec![];
    for _ in 0..20 {
        let peer = PeerNetworkId::new(network_id, PeerId::random());
        publisher.add_active_subscriber(peer);
        subscribers.push(peer);
    }
    
    // Publish message - should fail for some subscribers due to channel overflow
    let message = ConsensusObserverMessage::new_ordered_block_message(
        vec![],
        LedgerInfoWithSignatures::new(
            LedgerInfo::new(BlockInfo::empty(), HashValue::zero()),
            AggregateSignature::empty(),
        ),
    );
    
    publisher.publish_message(message);
    
    // Count how many messages actually made it to the channel
    let mut received_count = 0;
    while receiver.next().now_or_never().is_some() {
        received_count += 1;
    }
    
    // Verify: only ~10 messages fit in channel, rest are dropped
    assert!(received_count <= 10, "Expected channel overflow");
    assert!(received_count < 20, "Some sends should have failed");
    
    // NOTE: This demonstrates that errors occur but aren't tracked in metrics
}
```

## Notes

While this is a legitimate operational concern affecting observer network monitoring and health detection, it's important to note that:

1. **Observers are auxiliary components** - they don't participate in consensus or affect blockchain state consistency
2. **No security invariants are broken** - consensus safety, liveness, and state consistency are unaffected  
3. **No direct attack path exists** - this is a system degradation issue rather than an exploitable vulnerability
4. **Core blockchain operation continues normally** even when all observers are degraded

The issue is primarily an **observability and operational health monitoring gap** rather than a critical security vulnerability. The security impact is limited to reduced visibility into observer network health, which could delay detection of broader network issues.

### Citations

**File:** config/src/config/consensus_observer_config.rs (L68-68)
```rust
            max_network_channel_size: 1000,
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L212-232)
```rust
    pub fn publish_message(&self, message: ConsensusObserverDirectSend) {
        // Get the active subscribers
        let active_subscribers = self.get_active_subscribers();

        // Send the message to all active subscribers
        for peer_network_id in &active_subscribers {
            // Send the message to the outbound receiver for publishing
            let mut outbound_message_sender = self.outbound_message_sender.clone();
            if let Err(error) =
                outbound_message_sender.try_send((*peer_network_id, message.clone()))
            {
                // The message send failed
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                        .event(LogEvent::SendDirectSendMessage)
                        .message(&format!(
                            "Failed to send outbound message to the receiver for peer {:?}! Error: {:?}",
                            peer_network_id, error
                    )));
            }
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_client.rs (L76-81)
```rust
            // Update the direct send error metrics
            metrics::increment_counter(
                &metrics::PUBLISHER_SENT_MESSAGE_ERRORS,
                error.get_label(),
                peer_network_id,
            );
```
