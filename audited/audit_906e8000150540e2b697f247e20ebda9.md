# Audit Report

## Title
Cross-Epoch Payload Retention Allows Memory Exhaustion DoS in Consensus Observer

## Summary
The `remove_blocks_for_epoch_round()` function in the consensus observer's payload store incorrectly retains block payloads from future epochs during cleanup operations. This allows malicious network peers to fill the payload store with payloads from distant future epochs, causing memory exhaustion and denial of service by preventing legitimate payloads from being stored.

## Finding Description

The vulnerability exists in how the consensus observer cleans up block payloads during epoch transitions and block commits. The core issue is in the `remove_blocks_for_epoch_round()` function: [1](#0-0) 

This function uses `BTreeMap::split_off()` with a tuple key `(epoch, split_off_round)`. Due to lexicographic tuple comparison, `split_off` returns all entries where `(entry_epoch, entry_round) >= (epoch, split_off_round)`. This correctly removes past epoch payloads but **retains all future epoch payloads**.

The attack path works as follows:

1. **Malicious payload injection**: A malicious peer sends block payload messages for future epochs (e.g., epochs 100, 200, 300) while the network is at epoch 10. The `process_block_payload_message()` function accepts these payloads: [2](#0-1) 

There is no upper bound check on epoch numbers - only a check that the payload is ahead of the last ordered block.

2. **Unverified storage**: Future epoch payloads are stored as unverified: [3](#0-2) 

3. **Incomplete cleanup on commit**: When blocks are committed via `handle_committed_blocks()`, it calls `remove_blocks_for_epoch_round()` with the committed epoch: [4](#0-3) 

This only removes payloads up to the committed epoch, leaving future epoch payloads intact.

4. **Incomplete cleanup on epoch transition**: During epoch transitions in `process_commit_sync_notification()`, only `verify_payload_signatures()` is called: [5](#0-4) 

The `verify_payload_signatures()` function explicitly skips future epoch payloads: [6](#0-5) 

5. **Accumulation across epochs**: As the network progresses through epochs 10→11→12→..., the malicious payloads from epochs 100+ remain in the store indefinitely, never being cleaned up.

## Impact Explanation

This is a **HIGH severity** vulnerability based on Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: The payload store has a size limit enforced by `max_num_pending_blocks`: [7](#0-6) 

Once filled with malicious future-epoch payloads, legitimate payloads are dropped, preventing the consensus observer from functioning properly.

2. **Memory Exhaustion**: Each payload contains transaction data and proof-of-store information. An attacker can fill the store with thousands of malicious payloads (up to `max_num_pending_blocks`), consuming significant memory.

3. **Consensus Observer Disruption**: Consensus observers rely on receiving and storing block payloads to verify and forward consensus decisions. If the payload store is full of invalid entries, the observer cannot process legitimate blocks, breaking the consensus observer protocol's functionality.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack Complexity**: LOW - Attacker only needs to send block payload messages with arbitrary future epoch numbers
- **Attacker Requirements**: Minimal - Any network peer can send consensus observer messages
- **Detection Difficulty**: HIGH - The attack is stealthy as invalid payloads appear as legitimate future blocks
- **Mitigation Presence**: NONE - No upper bound validation on epoch numbers, no cleanup of future epoch payloads

The attack can be launched by any malicious node on the network without requiring validator privileges or sophisticated exploits.

## Recommendation

Implement a two-part fix:

1. **Add epoch boundary validation** in `process_block_payload_message()`:
   - Reject payloads more than 1-2 epochs ahead of the current epoch
   - Add validation: `if block_epoch > epoch_state.epoch + MAX_EPOCH_AHEAD { return; }`

2. **Fix cleanup logic** to remove future epoch payloads during epoch transitions:
   - In `process_commit_sync_notification()`, after ending the epoch, call `clear_all_payloads()` to remove all stored payloads from previous epochs
   - OR modify `verify_payload_signatures()` to explicitly remove payloads from future epochs (epoch > current_epoch)

Example fix for option 1:

```rust
// In process_block_payload_message(), after line 364:
const MAX_EPOCH_AHEAD: u64 = 2;
if block_epoch > epoch_state.epoch + MAX_EPOCH_AHEAD {
    increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
    return;
}
```

Example fix for option 2:

```rust
// In verify_payload_signatures(), replace lines 229-231:
if epoch > current_epoch {
    // Remove future epoch payloads as they're invalid
    if let Entry::Occupied(entry) = self.block_payloads.lock().entry((epoch, round)) {
        entry.remove();
    }
    continue; // Process next payload
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_future_epoch_payload_retention_vulnerability() {
    use aptos_config::config::ConsensusObserverConfig;
    use consensus::consensus_observer::observer::payload_store::BlockPayloadStore;
    use consensus::consensus_observer::network::observer_message::BlockPayload;
    use aptos_types::block_info::BlockInfo;
    use aptos_crypto::HashValue;
    
    // Create payload store with limit of 100 blocks
    let config = ConsensusObserverConfig {
        max_num_pending_blocks: 100,
        ..Default::default()
    };
    let mut store = BlockPayloadStore::new(config);
    
    // Attacker sends payloads for future epochs (current epoch is 10)
    for future_epoch in 100..200 {
        for round in 0..10 {
            let block_info = BlockInfo::new(
                future_epoch,
                round,
                HashValue::random(),
                HashValue::random(),
                0,
                0,
                None,
            );
            let payload = BlockPayload::new(
                block_info,
                BlockTransactionPayload::empty()
            );
            // These are accepted and stored as unverified
            store.insert_block_payload(payload, false);
        }
    }
    
    // Verify malicious payloads filled the store
    assert_eq!(store.get_block_payloads().lock().len(), 100);
    
    // Simulate epoch 10 blocks being committed
    store.remove_blocks_for_epoch_round(10, 99);
    
    // BUG: Future epoch payloads are NOT removed
    // All 100 malicious payloads remain in the store
    assert_eq!(store.get_block_payloads().lock().len(), 100);
    
    // Simulate multiple epoch transitions (10->11->12->...->20)
    for epoch in 11..20 {
        store.remove_blocks_for_epoch_round(epoch, 99);
    }
    
    // BUG: Malicious payloads from epochs 100-200 STILL remain
    assert_eq!(store.get_block_payloads().lock().len(), 100);
    
    // Impact: Legitimate epoch 20 payloads cannot be stored
    let legitimate_payload = BlockPayload::new(
        BlockInfo::new(20, 0, HashValue::random(), HashValue::random(), 0, 0, None),
        BlockTransactionPayload::empty()
    );
    store.insert_block_payload(legitimate_payload, true);
    
    // Legitimate payload is DROPPED due to size limit
    // Only malicious future-epoch payloads remain
}
```

**Notes:**

This vulnerability breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits." The consensus observer's payload store can be permanently filled with invalid future-epoch entries, preventing legitimate operation.

The root cause is the semantic mismatch between the function's intended behavior ("remove all blocks up to epoch X") and its actual implementation (which only removes blocks from epochs ≤ X, retaining all future epochs). Combined with the lack of upper-bound epoch validation, this creates a persistent DoS vector against consensus observer nodes.

### Citations

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L84-95)
```rust
        // Verify that the number of payloads doesn't exceed the maximum
        let max_num_pending_blocks = self.consensus_observer_config.max_num_pending_blocks as usize;
        if self.block_payloads.lock().len() >= max_num_pending_blocks {
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Exceeded the maximum number of payloads: {:?}. Dropping block: {:?}!",
                    max_num_pending_blocks,
                    block_payload.block(),
                ))
            );
            return; // Drop the block if we've exceeded the maximum
        }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L112-119)
```rust
    pub fn remove_blocks_for_epoch_round(&self, epoch: u64, round: Round) {
        // Determine the round to split off
        let split_off_round = round.saturating_add(1);

        // Remove the blocks from the payload store
        let mut block_payloads = self.block_payloads.lock();
        *block_payloads = block_payloads.split_off(&(epoch, split_off_round));
    }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L227-231)
```rust
        for (epoch, round) in payload_epochs_and_rounds {
            // Check if we can break early (BtreeMaps are sorted by key)
            if epoch > current_epoch {
                break;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L366-380)
```rust
        // Determine if the payload is behind the last ordered block, or if it already exists
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let payload_out_of_date =
            (block_epoch, block_round) <= (last_ordered_block.epoch(), last_ordered_block.round());
        let payload_exists = self
            .observer_block_data
            .lock()
            .existing_payload_entry(&block_payload);

        // If the payload is out of date or already exists, ignore it
        if payload_out_of_date || payload_exists {
            // Update the metrics for the dropped block payload
            update_metrics_for_dropped_block_payload_message(peer_network_id, &block_payload);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L399-430)
```rust
        // If the payload is for the current epoch, verify the proof signatures
        let epoch_state = self.get_epoch_state();
        let verified_payload = if block_epoch == epoch_state.epoch {
            // Verify the block proof signatures
            if let Err(error) = block_payload.verify_payload_signatures(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify block payload signatures! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                        block_payload.block(), peer_network_id, error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
                return;
            }

            true // We have successfully verified the signatures
        } else {
            false // We can't verify the signatures yet
        };

        // Update the latency metrics for block payload processing
        update_message_processing_latency_metrics(
            message_received_time,
            &peer_network_id,
            metrics::BLOCK_PAYLOAD_LABEL,
        );

        // Update the payload store with the payload
        self.observer_block_data
            .lock()
            .insert_block_payload(block_payload, verified_payload);
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1026-1045)
```rust
        // If the epoch has changed, end the current epoch and start the latest one.
        let current_epoch_state = self.get_epoch_state();
        if synced_epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;

            // Verify the block payloads for the new epoch
            let new_epoch_state = self.get_epoch_state();
            let verified_payload_rounds = self
                .observer_block_data
                .lock()
                .verify_payload_signatures(&new_epoch_state);

            // Order all the pending blocks that are now ready (these were buffered during state sync)
            for payload_round in verified_payload_rounds {
                self.order_ready_pending_block(new_epoch_state.epoch, payload_round)
                    .await;
            }
        };
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L182-187)
```rust
    fn handle_committed_blocks(&mut self, ledger_info: LedgerInfoWithSignatures) {
        // Remove the committed blocks from the payload and ordered block stores
        self.block_payload_store.remove_blocks_for_epoch_round(
            ledger_info.commit_info().epoch(),
            ledger_info.commit_info().round(),
        );
```
