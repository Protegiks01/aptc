# Audit Report

## Title
WHERE Clause Bypass in Indexer UPSERT Operations via Token Name Injection

## Summary
A logic flaw in the indexer's `execute_with_better_error` function allows attackers to bypass version-based UPSERT filtering by injecting the string "where" into token names or collection names. This enables older transaction states to overwrite newer states in the `current_token_pending_claims` table during reprocessing or concurrent indexer operations, causing state inconsistencies.

## Finding Description

The Aptos indexer uses UPSERT operations with version-based filtering to maintain current state tables. For `current_token_pending_claims`, the system is designed to only allow updates when `last_transaction_version <= excluded.last_transaction_version`, preventing older data from overwriting newer data. [1](#0-0) 

However, the `execute_with_better_error` helper function contains a flawed check that drops the WHERE clause if the query's debug output contains the string "where" (case-insensitive): [2](#0-1) 

This check was intended to handle empty inserts (where Diesel generates `SELECT 1 FROM TABLE WHERE 1=0`), but it incorrectly matches ANY occurrence of "where" in the query, including user-controlled data in the VALUES clause.

Token names and collection names are user-controlled strings that can contain arbitrary text up to 128 characters: [3](#0-2) [4](#0-3) 

These names are stored directly in the database without sanitization and appear in Diesel's debug query output. When a token name or collection name contains "where" (e.g., "Where Dreams Come True"), the WHERE clause is dropped, allowing version-based protection to be bypassed.

The Aptos indexer supports concurrent batch processing and reprocessing from specific versions: [5](#0-4) 

This creates scenarios where older versions could be processed after newer versions, which should normally be prevented by the WHERE clause.

**Attack Scenario:**
1. Attacker creates a token with name containing "where" (e.g., "NFT - where art meets technology")
2. Transaction V1000: Creates a pending claim with amount=100
3. Transaction V2000: Cancels the claim (sets amount=0)  
4. Indexer processes V2000 first, database shows amount=0
5. During reprocessing or concurrent operation, V1000 is processed
6. Due to "where" in token name, WHERE clause is dropped
7. V1000 (amount=100) overwrites V2000 (amount=0)
8. Database now incorrectly shows an active claim that was actually canceled

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos Bug Bounty program criteria: "State inconsistencies requiring intervention."

The indexer database serves as the primary query interface for blockchain state. When it contains incorrect data:
- Users and applications relying on the indexer API receive false information about claim states
- Canceled claims may appear active, or active claims may appear canceled
- Marketplaces, wallets, and other off-chain systems make incorrect decisions based on corrupted data
- Manual intervention (database correction or full reindexing) is required to restore consistency
- The blockchain state itself remains correct, but the indexer becomes unreliable

While this doesn't affect consensus or on-chain funds directly, it breaks the core guarantee that indexer state reflects blockchain state, potentially affecting user experience and ecosystem applications.

## Likelihood Explanation

**Likelihood: Medium**

Prerequisites for exploitation:
1. Attacker creates tokens with names containing "where" (trivial, fully under attacker control)
2. Indexer reprocessing or concurrent operations occur (common in production deployments)
3. Specific claim modifications happen with the vulnerable token (attacker can trigger)

The indexer architecture explicitly supports concurrent processing with multiple tasks and reprocessing capabilities, making scenarios where older transactions are processed after newer ones realistic and expected. The attack requires no special privilegesâ€”any user can create tokens with arbitrary names.

## Recommendation

Replace the overly broad string matching with a more precise check that only targets the specific empty-insert pattern:

```rust
pub fn execute_with_better_error<U>(
    conn: &mut PgConnection,
    query: U,
    mut additional_where_clause: Option<&'static str>,
) -> QueryResult<usize>
where
    U: QueryFragment<Pg> + diesel::query_builder::QueryId,
{
    let original_query = diesel::debug_query::<diesel::pg::Pg, _>(&query).to_string();
    
    // Only skip WHERE clause for empty inserts (SELECT 1 WHERE 1=0)
    // Not for any query containing "where" in VALUES data
    if original_query.contains("SELECT 1") && original_query.contains("WHERE 1=0") {
        additional_where_clause = None;
    }
    
    let final_query = UpsertFilterLatestTransactionQuery {
        query,
        where_clause: additional_where_clause,
    };
    let debug = diesel::debug_query::<diesel::pg::Pg, _>(&final_query).to_string();
    aptos_logger::debug!("Executing query: {:?}", debug);
    let res = final_query.execute(conn);
    if let Err(ref e) = res {
        aptos_logger::warn!("Error running query: {:?}\n{}", e, debug);
    }
    res
}
```

Alternatively, always apply the WHERE clause and let the database handle empty result sets gracefully.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[cfg(test)]
mod test {
    use super::*;
    use diesel::prelude::*;
    
    #[test]
    fn test_where_clause_bypass() {
        // Setup: Create a token with name containing "where"
        let token_name = "My NFT - where dreams come true";
        
        // Simulate two transactions modifying the same claim
        let claim_v1000 = CurrentTokenPendingClaim {
            token_data_id_hash: "hash123".to_string(),
            property_version: BigDecimal::from(0),
            from_address: "0xabc".to_string(),
            to_address: "0xdef".to_string(),
            collection_data_id_hash: "coll123".to_string(),
            creator_address: "0x123".to_string(),
            collection_name: "Test Collection".to_string(),
            name: token_name.to_string(), // Contains "where"
            amount: BigDecimal::from(100),
            table_handle: "0xtable".to_string(),
            last_transaction_version: 1000,
            last_transaction_timestamp: NaiveDateTime::from_timestamp(1000, 0),
            token_data_id: "0xtoken".to_string(),
            collection_id: "0xcoll".to_string(),
        };
        
        let claim_v2000 = CurrentTokenPendingClaim {
            amount: BigDecimal::from(0), // Claim canceled
            last_transaction_version: 2000,
            last_transaction_timestamp: NaiveDateTime::from_timestamp(2000, 0),
            ..claim_v1000.clone()
        };
        
        // Insert v2000 first (newer version)
        insert_current_token_claims(&mut conn, &[claim_v2000]).unwrap();
        
        // Verify database has v2000
        let result = current_token_pending_claims::table
            .filter(current_token_pending_claims::token_data_id_hash.eq("hash123"))
            .first::<CurrentTokenPendingClaim>(&mut conn)
            .unwrap();
        assert_eq!(result.last_transaction_version, 2000);
        assert_eq!(result.amount, BigDecimal::from(0));
        
        // Now insert v1000 (older version)
        // Due to "where" in name, WHERE clause is dropped
        insert_current_token_claims(&mut conn, &[claim_v1000]).unwrap();
        
        // BUG: Database now has v1000 instead of v2000!
        let result = current_token_pending_claims::table
            .filter(current_token_pending_claims::token_data_id_hash.eq("hash123"))
            .first::<CurrentTokenPendingClaim>(&mut conn)
            .unwrap();
        assert_eq!(result.last_transaction_version, 1000); // Should be 2000!
        assert_eq!(result.amount, BigDecimal::from(100)); // Should be 0!
    }
}
```

## Notes

This vulnerability affects the indexer subsystem, which is a critical component for ecosystem applications even though it operates off-chain. The blockchain state itself remains secure and unaffected. However, the indexer's reliability is essential for user experience and application functionality in the Aptos ecosystem.

### Citations

**File:** crates/indexer/src/processors/token_processor.rs (L519-555)
```rust
fn insert_current_token_claims(
    conn: &mut PgConnection,
    items_to_insert: &[CurrentTokenPendingClaim],
) -> Result<(), diesel::result::Error> {
    use schema::current_token_pending_claims::dsl::*;

    let chunks = get_chunks(
        items_to_insert.len(),
        CurrentTokenPendingClaim::field_count(),
    );

    for (start_ind, end_ind) in chunks {
        execute_with_better_error(
            conn,
            diesel::insert_into(schema::current_token_pending_claims::table)
                .values(&items_to_insert[start_ind..end_ind])
                .on_conflict((
                    token_data_id_hash, property_version, from_address, to_address
                ))
                .do_update()
                .set((
                    collection_data_id_hash.eq(excluded(collection_data_id_hash)),
                    creator_address.eq(excluded(creator_address)),
                    collection_name.eq(excluded(collection_name)),
                    name.eq(excluded(name)),
                    amount.eq(excluded(amount)),
                    table_handle.eq(excluded(table_handle)),
                    last_transaction_version.eq(excluded(last_transaction_version)),
                    inserted_at.eq(excluded(inserted_at)),
                    token_data_id.eq(excluded(token_data_id)),
                    collection_id.eq(excluded(collection_id)),
                )),
            Some(" WHERE current_token_pending_claims.last_transaction_version <= excluded.last_transaction_version "),
        )?;
    }
    Ok(())
}
```

**File:** crates/indexer/src/database.rs (L72-77)
```rust
    let original_query = diesel::debug_query::<diesel::pg::Pg, _>(&query).to_string();
    // This is needed because if we don't insert any row, then diesel makes a call like this
    // SELECT 1 FROM TABLE WHERE 1=0
    if original_query.to_lowercase().contains("where") {
        additional_where_clause = None;
    }
```

**File:** crates/indexer/src/models/token_models/token_utils.rs (L50-56)
```rust
    pub fn get_collection_trunc(&self) -> String {
        truncate_str(&self.collection, NAME_LENGTH)
    }

    pub fn get_name_trunc(&self) -> String {
        truncate_str(&self.name, NAME_LENGTH)
    }
```

**File:** crates/indexer/src/util.rs (L23-27)
```rust
pub fn truncate_str(val: &str, max_chars: usize) -> String {
    let mut trunc = val.to_string();
    trunc.truncate(max_chars);
    trunc
}
```

**File:** crates/indexer/src/runtime.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```
