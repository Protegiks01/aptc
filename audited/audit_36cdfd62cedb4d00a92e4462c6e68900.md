# Audit Report

## Title
Orphaned Hasura Container Due to Insufficient Cleanup on Localnet Crash

## Summary
The Aptos localnet's indexer API service creates a Hasura Docker container without automatic cleanup mechanisms. When the localnet process crashes or is forcefully terminated before executing shutdown steps, the Hasura container remains running indefinitely, consuming system resources and exposing unauthenticated GraphQL APIs.

## Finding Description

The vulnerability exists in the container lifecycle management of the localnet's indexer API service. The Hasura container is created and started without Docker-level auto-removal configuration. [1](#0-0) 

The container cleanup relies entirely on shutdown steps being executed via `StopContainerShutdownStep`: [2](#0-1) 

However, these shutdown steps are explicitly documented as "best effort" and are not guaranteed to execute: [3](#0-2) 

The shutdown mechanism has critical gaps:

1. **Panic-triggered process exit bypasses cleanup**: When a panic occurs, the crash handler immediately terminates the process: [4](#0-3) 

2. **Ctrl-C handler registered late**: The signal handler is only registered after all services complete startup, leaving a window where crashes have no cleanup mechanism: [5](#0-4) 

3. **Uncatchable termination signals**: SIGKILL and similar signals cannot be intercepted by user-space handlers.

4. **Exposed APIs without authentication**: The orphaned container continues exposing the Hasura console and GraphQL API in development mode: [6](#0-5) 

## Impact Explanation

This issue constitutes **Medium severity** as specified in the security question, based on:

1. **Resource Consumption**: Orphaned containers consume CPU and memory indefinitely, potentially exhausting developer machine resources with repeated crashes during development/testing cycles.

2. **API Exposure**: The Hasura container exposes:
   - GraphQL API on the configured port (default 8090)
   - Hasura console with full query capabilities (`HASURA_GRAPHQL_ENABLE_CONSOLE=true`)
   - Direct access to the postgres database via configured connection string
   - No authentication in development mode (`HASURA_GRAPHQL_DEV_MODE=true`)

3. **Scope Limitation**: While this affects the local development environment rather than production blockchain infrastructure, it creates security and operational issues for developers running the localnet tool.

## Likelihood Explanation

This vulnerability has **high likelihood** of occurrence:

1. **Common trigger scenarios**:
   - Any Rust panic during localnet startup or runtime
   - Process killed with SIGKILL (`kill -9`)
   - System crashes or OOM killer termination
   - Forced termination during debugging

2. **No protective measures**: The container has no Docker-level auto-removal or restart policies configured.

3. **Development context**: Crashes are common during development and testing, making repeated orphaned container accumulation probable.

## Recommendation

Implement defense-in-depth container cleanup:

**1. Add Docker auto-removal configuration** in `indexer_api.rs`:

```rust
use bollard::models::HostConfig;

let host_config = HostConfig {
    network_mode,
    extra_hosts: Some(vec!["host.docker.internal:host-gateway".to_string()]),
    port_bindings: Some(hashmap! { /* ... */ }),
    auto_remove: Some(true),  // Add this field
    ..Default::default()
};
```

**2. Register signal handlers earlier** in the startup sequence before container creation.

**3. Implement cleanup at pre_run** to detect and remove stale containers from previous crashed runs: [7](#0-6) 

The code already calls `delete_container()` in `pre_run()`, which is good, but this only helps on the next startup, not for the current crash.

**4. Add Docker container labels** to enable automated garbage collection by external tools.

## Proof of Concept

**Reproduction Steps:**

```bash
# Terminal 1: Start localnet with indexer API
cargo run -- node run-local-testnet --with-indexer-api

# Wait for startup to complete
# Terminal 2: Force kill the process before graceful shutdown
pkill -9 aptos  # or kill -9 <PID>

# Verify orphaned container
docker ps | grep local-testnet-indexer-api

# Container remains running:
# CONTAINER ID   IMAGE           PORTS                    NAMES
# <id>          hasura/...      0.0.0.0:8090->8090/tcp   local-testnet-indexer-api

# API remains accessible
curl http://127.0.0.1:8090/

# Container consumes resources
docker stats local-testnet-indexer-api
```

**Alternative trigger via panic:**

```rust
// In any service's run_service() before ctrl-c handler registration
panic!("Simulated crash during startup");
// Result: Container orphaned, shutdown steps never execute
```

## Notes

This vulnerability is specific to the local testnet development tool and does not affect production blockchain consensus, validator operations, or on-chain security. However, it represents a valid operational security concern for developers using the localnet CLI, particularly regarding resource exhaustion and unintended API exposure during development workflows.

### Citations

**File:** crates/aptos/src/node/local_testnet/indexer_api.rs (L109-134)
```rust
    async fn pre_run(&self) -> Result<()> {
        if self.existing_hasura_url.is_some() {
            return Ok(());
        }

        // Confirm Docker is available.
        get_docker().await?;

        // Delete any existing indexer API container we find.
        delete_container(INDEXER_API_CONTAINER_NAME).await?;

        // Pull the image here so it is not subject to the 30 second startup timeout.
        pull_docker_image(HASURA_IMAGE).await?;

        // Warn the user about DOCKER_DEFAULT_PLATFORM.
        if let Ok(var) = std::env::var("DOCKER_DEFAULT_PLATFORM") {
            eprintln!(
                "WARNING: DOCKER_DEFAULT_PLATFORM is set to {}. This may cause problems \
                with running the indexer API. If it fails to start up, try unsetting \
                this env var.\n",
                var
            );
        }

        Ok(())
    }
```

**File:** crates/aptos/src/node/local_testnet/indexer_api.rs (L222-242)
```rust
        let config = Config {
            image: Some(HASURA_IMAGE.to_string()),
            tty: Some(true),
            exposed_ports,
            host_config: Some(host_config),
            env: Some(vec![
                format!("PG_DATABASE_URL={}", postgres_connection_string),
                format!(
                    "HASURA_GRAPHQL_METADATA_DATABASE_URL={}",
                    postgres_connection_string
                ),
                format!("INDEXER_V2_POSTGRES_URL={}", postgres_connection_string),
                "HASURA_GRAPHQL_DEV_MODE=true".to_string(),
                "HASURA_GRAPHQL_ENABLE_CONSOLE=true".to_string(),
                // See the docs for the image, this is a magic path inside the
                // container where they have already bundled in the UI assets.
                "HASURA_GRAPHQL_CONSOLE_ASSETS_DIR=/srv/console-assets".to_string(),
                format!("HASURA_GRAPHQL_SERVER_PORT={}", self.indexer_api_port),
            ]),
            ..Default::default()
        };
```

**File:** crates/aptos/src/node/local_testnet/indexer_api.rs (L311-323)
```rust
    fn get_shutdown_steps(&self) -> Vec<Box<dyn ShutdownStep>> {
        if self.existing_hasura_url.is_some() {
            return vec![];
        }

        // Unfortunately the Hasura container does not shut down when the CLI does and
        // there doesn't seem to be a good way to make it do so. To work around this,
        // we register a step that will stop the container on shutdown.
        // Read more here: https://stackoverflow.com/q/77171786/3846032.
        vec![Box::new(StopContainerShutdownStep::new(
            INDEXER_API_CONTAINER_NAME,
        ))]
    }
```

**File:** crates/aptos/src/node/local_testnet/traits.rs (L76-83)
```rust
    /// The ServiceManager may return ShutdownSteps. The tool will run these on shutdown.
    /// This is best effort, there is nothing we can do if part of the code aborts or
    /// the process receives something like SIGKILL.
    ///
    /// See `ShutdownStep` for more information.
    fn get_shutdown_steps(&self) -> Vec<Box<dyn ShutdownStep>> {
        vec![]
    }
```

**File:** crates/crash-handler/src/lib.rs (L52-57)
```rust
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** crates/aptos/src/node/local_testnet/mod.rs (L433-444)
```rust
        // Create a task that listens for ctrl-c. We want to intercept it so we can run
        // the shutdown steps before properly exiting. This is of course best effort,
        // see `ShutdownStep` for more info. In particular, to speak to how "best effort"
        // this really is, to make sure ctrl-c happens more or less instantly, we only
        // register this handler after all the services have started.
        let abort_handle = join_set.spawn(async move {
            tokio::signal::ctrl_c()
                .await
                .expect("Failed to register ctrl-c hook");
            Ok(())
        });
        let ctrl_c_task_id = abort_handle.id();
```
