# Audit Report

## Title
Unauthenticated Backup Metadata Enables Validator Denial of Service via State Restoration Poisoning

## Summary
The backup metadata cache system accepts metadata files from backup storage without cryptographic verification. When combined with the optional nature of trusted waypoints during database restoration, an attacker who compromises backup storage can inject malicious metadata pointing to attacker-controlled blockchain state. Validators restoring without trusted waypoints will accept this malicious state, become unable to sync with the legitimate network, and fail to participate in consensus—effectively achieving targeted denial of service against validators.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Unauthenticated Metadata Loading**

The metadata cache system downloads and trusts metadata files without verification: [1](#0-0) 

The `sync_and_load` function downloads metadata files from backup storage and directly deserializes them without any cryptographic signature verification or hash validation. The metadata determines which backup files are used for restore operations.

**2. Unverified Epoch 0 Acceptance**

During epoch history restoration, if no trusted waypoint is provided, the first epoch's LedgerInfo is accepted without verification: [2](#0-1) 

When `previous_li` is `None` (first epoch being restored) and no trusted waypoint exists for that version, the epoch ending LedgerInfo is accepted without any cryptographic verification. This allows an attacker to inject an arbitrary epoch 0 with an attacker-controlled validator set.

**3. Trusted Waypoints Are Optional**

The restore process accepts an optional list of trusted waypoints, which can be empty: [3](#0-2) 

The test suite demonstrates restoration with empty waypoints: [4](#0-3) 

**4. Malicious State Becomes Trust Anchor**

After restoration, the bootstrapper initializes with the epoch state from the restored database: [5](#0-4) [6](#0-5) 

This epoch state becomes the trust anchor for verifying all subsequent ledger infos from the network.

**Attack Execution Path:**

1. Attacker compromises backup storage (e.g., S3 bucket via leaked credentials) or performs MITM attack
2. Attacker creates malicious backup set:
   - Epoch ending backups with attacker-controlled validator set from epoch 0
   - State snapshots consistent with malicious ledger
   - Transaction backups matching the malicious state
   - Metadata files pointing to these malicious backups
3. Validator runs restore without trusted waypoints:
   ```bash
   aptos-debugger aptos-db restore bootstrap-db \
     --target-db-dir /db \
     --local-fs-dir /backup
   # Note: No --trust-waypoint arguments
   ```
4. Metadata loaded without verification (cache.rs)
5. Epoch 0 LedgerInfo accepted without verification (epoch_ending/restore.rs)
6. Database populated with attacker's blockchain state
7. Validator starts up, loads malicious epoch state as trust anchor (bootstrapper.rs)
8. Validator attempts to sync with network:
   - Network sends legitimate LedgerInfoWithSignatures
   - These have signatures from real validator set
   - Validator's malicious epoch state has different validator verifier
   - Verification fails: `latest_epoch_state.verify(epoch_ending_ledger_info)` rejects legitimate data
9. **Validator is permanently stuck, cannot sync with network, cannot participate in consensus**

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

1. **Validator Node Unavailability**: An attacker who compromises backup storage can prevent affected validators from successfully restoring and rejoining the network. This achieves targeted denial of service against specific validators.

2. **Network Stability Risk**: If multiple validators are simultaneously affected (e.g., multiple validators use the same compromised backup storage), the network could experience reduced validator participation, potentially impacting liveness.

3. **Operational Disruption**: Validators that successfully complete restore operations but cannot sync represent a critical operational failure requiring manual intervention, database wiping, and re-restoration with correct waypoints.

4. **Silent Failure Mode**: The restore process completes successfully without warnings, making it difficult to detect that the database contains poisoned state until the node fails to sync with the network.

The impact is categorized as **High** rather than Critical because:
- It requires compromising backup storage, not exploitable purely over the network
- It affects availability rather than directly causing consensus safety violations or fund loss
- Recovery is possible by re-restoring with proper trusted waypoints
- Unlikely to affect majority of validators simultaneously unless backup infrastructure is centralized

However, this could escalate to **Critical** if backup storage compromise affects a significant portion of validators simultaneously.

## Likelihood Explanation

**High Likelihood** in practice:

1. **Common Attack Vector**: Backup storage compromise is a realistic threat:
   - Cloud storage credentials are frequently leaked
   - Misconfigured S3/GCS buckets are common
   - MITM attacks possible if TLS not properly configured
   - Backup storage often has weaker access controls than production systems

2. **Default Configuration Weakness**: The Helm template shows trusted waypoints are configured as an optional list: [7](#0-6) 
   
   If `config.trusted_waypoints` is empty or not configured, no waypoints are provided.

3. **Lack of Warnings**: The system provides no warnings when restoring without trusted waypoints, making it easy for operators to unknowingly deploy vulnerable configurations.

4. **Documentation Gaps**: The optional nature of trusted waypoints and the security implications are not clearly emphasized in operational documentation.

5. **Test Coverage**: The test suite demonstrates restoration with empty waypoints, potentially encouraging this pattern: [8](#0-7) 

## Recommendation

**Immediate Fixes:**

1. **Require Genesis Waypoint**: Make the genesis waypoint mandatory for all restore operations. Modify the code to fail if no trusted waypoint is provided:

```rust
// In storage/backup/backup-cli/src/utils/mod.rs
impl TrustedWaypointOpt {
    pub fn verify(self) -> Result<HashMap<Version, Waypoint>> {
        ensure!(
            !self.trust_waypoint.is_empty(),
            "At least one trusted waypoint (typically genesis) must be provided for secure restore operations"
        );
        
        let mut trusted_waypoints = HashMap::new();
        for w in self.trust_waypoint {
            trusted_waypoints
                .insert(w.version(), w)
                .map_or(Ok(()), |w| {
                    Err(AptosDbError::Other(format!(
                        "Duplicated waypoints at version {}",
                        w.version()
                    )))
                })?;
        }
        
        // Verify genesis waypoint (version 0) is present
        ensure!(
            trusted_waypoints.contains_key(&0),
            "Genesis waypoint (version 0) must be provided"
        );
        
        Ok(trusted_waypoints)
    }
}
```

2. **Sign Metadata Files**: Add cryptographic signatures to metadata files using validator operator keys or a separate metadata signing key:

```rust
// In storage/backup/backup-cli/src/metadata/mod.rs
pub struct SignedMetadata {
    pub metadata: Metadata,
    pub signature: Ed25519Signature,
    pub signer: AccountAddress,
}

impl SignedMetadata {
    pub fn verify(&self, trusted_signers: &HashSet<AccountAddress>) -> Result<()> {
        ensure!(
            trusted_signers.contains(&self.signer),
            "Metadata signed by untrusted signer: {}",
            self.signer
        );
        
        let message = bcs::to_bytes(&self.metadata)?;
        self.signature.verify(&message, &self.signer)?;
        Ok(())
    }
}
```

3. **Add Verification Warnings**: Log prominent warnings when restoring without sufficient trusted waypoints:

```rust
// In storage/backup/backup-cli/src/coordinators/restore.rs
if trusted_waypoints.is_empty() {
    warn!("⚠️  SECURITY WARNING: Restoring without trusted waypoints is insecure!");
    warn!("⚠️  Malicious backup data will be accepted without verification!");
    warn!("⚠️  Provide --trust-waypoint arguments to ensure safe restoration!");
}
```

**Long-term Solutions:**

1. **Blockchain-Based Metadata**: Store backup metadata on-chain with cryptographic proofs, making it tamper-evident
2. **Content-Addressed Storage**: Use content hashing for all backup files with hash verification
3. **Waypoint Registry**: Maintain a publicly-verifiable registry of trusted waypoints for each network
4. **Automated Waypoint Injection**: Automatically include genesis waypoint from node configuration during restore

## Proof of Concept

```rust
// Proof of Concept demonstrating the vulnerability
// This would be implemented as a Rust integration test

use aptos_backup_cli::metadata::{Metadata, EpochEndingBackupMeta};
use aptos_storage_interface::DbReader;
use aptos_types::waypoint::Waypoint;
use std::collections::HashMap;

#[test]
fn test_malicious_metadata_acceptance() {
    // 1. Setup: Create malicious backup storage with attacker-controlled epoch 0
    let malicious_storage = create_malicious_backup_storage();
    
    // 2. Create metadata pointing to malicious backups
    let malicious_metadata = vec![
        Metadata::new_epoch_ending_backup(
            0, // first_epoch: attacker's epoch 0
            5, // last_epoch
            0, // first_version
            10000, // last_version
            malicious_storage.get_manifest_handle(),
        ),
        // Additional malicious state snapshots and transaction backups
    ];
    
    // Write metadata without any signatures
    malicious_storage.write_metadata(&malicious_metadata);
    
    // 3. Victim validator attempts restore WITHOUT trusted waypoints
    let restore_opt = RestoreCoordinatorOpt {
        metadata_cache_opt: MetadataCacheOpt::new(Some("/tmp/cache")),
        replay_all: false,
        ledger_history_start_version: None,
        skip_epoch_endings: false,
    };
    
    let global_opt = GlobalRestoreOptions {
        target_version: 10000,
        trusted_waypoints: Arc::new(HashMap::new()), // Empty - no trusted waypoints!
        run_mode: Arc::new(RestoreRunMode::Verify),
        concurrent_downloads: 4,
        replay_concurrency_level: 1,
    };
    
    // 4. Restore completes successfully (BUG: should fail!)
    let coordinator = RestoreCoordinator::new(restore_opt, global_opt, malicious_storage);
    let result = tokio_test::block_on(coordinator.run());
    
    assert!(result.is_ok(), "Restore should succeed (demonstrating the bug)");
    
    // 5. Verify the database now contains malicious epoch state
    let db = open_restored_db();
    let epoch_state = db.get_latest_epoch_state().unwrap();
    
    // The epoch state is from attacker's validator set, not legitimate network
    assert_ne!(
        epoch_state.verifier,
        legitimate_network_verifier(),
        "Malicious epoch state was accepted"
    );
    
    // 6. Demonstrate that node cannot sync with legitimate network
    let legitimate_ledger_info = get_legitimate_network_ledger_info();
    
    // This will fail because the malicious epoch state cannot verify legitimate signatures
    let verify_result = epoch_state.verify(&legitimate_ledger_info);
    assert!(
        verify_result.is_err(),
        "Node cannot verify legitimate network data - DoS achieved"
    );
}

fn create_malicious_backup_storage() -> Arc<dyn BackupStorage> {
    // Create backup storage with attacker-controlled blockchain state
    // Epoch 0 has attacker's validator set with their BLS keys
    // All signatures are valid within the malicious chain
    // State snapshots and transactions are internally consistent
    todo!("Implementation details omitted for brevity")
}
```

**Demonstration Steps:**

1. Setup malicious backup storage with attacker-controlled genesis
2. Run restore: `aptos-debugger aptos-db restore bootstrap-db --target-db-dir /test-db --local-fs-dir /malicious-backup`
3. Start validator with restored database
4. Observe validator fails to sync with legitimate network
5. Check logs showing continuous verification failures of legitimate ledger infos

## Notes

This vulnerability represents a critical weakness in the trust model for backup/restore operations. The system implicitly trusts backup storage to provide authentic metadata and blockchain state, when it should cryptographically verify all data against known trusted anchors (waypoints).

The impact is exacerbated by:
- Optional nature of trusted waypoints in current implementation
- Lack of warnings when operating without waypoints
- Production configurations (Helm charts) that may omit waypoints
- Test patterns that demonstrate unsafe usage

While the immediate impact is denial of service rather than consensus safety violation, this represents a serious operational security issue that could significantly disrupt network operations if backup infrastructure is compromised.

### Citations

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L90-122)
```rust
pub async fn sync_and_load(
    opt: &MetadataCacheOpt,
    storage: Arc<dyn BackupStorage>,
    concurrent_downloads: usize,
) -> Result<MetadataView> {
    let timer = Instant::now();
    let cache_dir = opt.cache_dir();
    create_dir_all(&cache_dir).await.err_notes(&cache_dir)?; // create if not present already

    // List cached metadata files.
    let dir = read_dir(&cache_dir).await.err_notes(&cache_dir)?;
    let local_hashes_vec: Vec<String> = ReadDirStream::new(dir)
        .filter_map(|entry| match entry {
            Ok(e) => {
                let path = e.path();
                let file_name = path.file_name()?.to_str()?;
                Some(file_name.to_string())
            },
            Err(_) => None,
        })
        .collect()
        .await;
    let local_hashes: HashSet<_> = local_hashes_vec.into_iter().collect();
    // List remote metadata files.
    let mut remote_file_handles = storage.list_metadata_files().await?;
    if remote_file_handles.is_empty() {
        initialize_identity(&storage).await.context(
            "\
            Backup storage appears empty and failed to put in identity metadata, \
            no point to go on. If you believe there is content in the backup, check authentication.\
            ",
        )?;
        remote_file_handles = storage.list_metadata_files().await?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-146)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L332-346)
```rust
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** testsuite/smoke-test/src/storage.rs (L136-136)
```rust
    db_restore(backup_path.path(), db_dir.as_path(), &[], None);
```

**File:** testsuite/smoke-test/src/storage.rs (L412-429)
```rust
pub(crate) fn db_restore(
    backup_path: &Path,
    db_path: &Path,
    trusted_waypoints: &[Waypoint],
    target_verion: Option<Version>, /* target version should be same as epoch ending version to start a node */
) {
    let now = Instant::now();
    let bin_path = workspace_builder::get_bin("aptos-debugger");
    let metadata_cache_path = TempPath::new();

    metadata_cache_path.create_as_dir().unwrap();

    let mut cmd = Command::new(bin_path.as_path());
    cmd.args(["aptos-db", "restore", "bootstrap-db"]);
    trusted_waypoints.iter().for_each(|w| {
        cmd.arg("--trust-waypoint");
        cmd.arg(w.to_string());
    });
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L341-344)
```rust
        // Load the latest epoch state from storage
        let latest_epoch_state = utils::fetch_latest_epoch_state(storage.clone())
            .expect("Unable to fetch latest epoch state!");
        let verified_epoch_states = VerifiedEpochStates::new(latest_epoch_state);
```

**File:** state-sync/state-sync-driver/src/utils.rs (L258-265)
```rust
pub fn fetch_latest_epoch_state(storage: Arc<dyn DbReader>) -> Result<EpochState, Error> {
    storage.get_latest_epoch_state().map_err(|error| {
        Error::StorageError(format!(
            "Failed to get the latest epoch state from storage: {:?}",
            error
        ))
    })
}
```

**File:** terraform/helm/fullnode/templates/fullnode.yaml (L57-57)
```yaml
            {{ range .config.trusted_waypoints }} --trust-waypoint {{ . }}{{ end }} \
```
