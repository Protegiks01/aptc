# Audit Report

## Title
Missing Preferred Round Validation in Order Vote Flow Allows Voting on Potentially Conflicting Chain Branches

## Summary
The `guarded_construct_and_sign_order_vote()` function in the consensus safety rules does not enforce the "second voting rule" (preferred round check) that is enforced during proposal signing. This allows validators to sign order votes for blocks whose Quorum Certificates reference chain states that are inconsistent with the validator's observed 2-chain progression, potentially enabling consensus safety violations under specific network conditions.

## Finding Description

The consensus safety rules implement a "second voting rule" via `verify_and_update_preferred_round()` that ensures validators only progress forward in the chain by checking that `qc.certified_block().round() >= preferred_round`. This check is critical for maintaining consensus safety and preventing equivocation. [1](#0-0) 

This safety check is properly enforced when validators sign block proposals: [2](#0-1) 

However, the order vote flow completely bypasses this check. In `guarded_construct_and_sign_order_vote()`, the function directly calls `observe_qc()` without any preferred round validation: [3](#0-2) 

The only safety check performed is `safe_for_order_vote()`, which only validates against `highest_timeout_round`: [4](#0-3) 

The `observe_qc()` function updates `preferred_round` based on the QC's `parent_block().round()` (the two-chain round), but since this happens BEFORE any validation against the current `preferred_round`, a validator could sign order votes for blocks that represent conflicting chain branches: [5](#0-4) 

### Attack Scenario

1. **Initial State**: Validator has observed chain `Genesis <- A(R1) <- B(R2) <- C(R3)` and voted on these blocks, setting `preferred_round = 2` (B's round from the 2-chain)

2. **Malicious QC Creation**: A Byzantine proposer (or set of colluding validators) creates block `D(R10)` that extends an earlier block in the chain, with a QC where:
   - `certified_block() = D (round 10)`
   - `parent_block() = A (round 1)`  â† This is < preferred_round (2)

3. **OrderVoteProposal Processing**: When an honest validator receives an `OrderVoteProposal` for block D:
   - `verify_order_vote_proposal()` only checks QC validity and consistency, not preferred round
   - `observe_qc()` is called: updates `one_chain_round = 10`, but `preferred_round` stays at 2 since `1 < 2`
   - `safe_for_order_vote()` only checks `10 > highest_timeout_round`
   - **Order vote is signed** despite the QC referencing a chain state (parent at R1) that conflicts with the validator's committed 2-chain view (preferred_round R2)

4. **Consensus Safety Impact**: If enough validators sign such order votes due to network partitions or message delays, different validators could finalize different chain branches, violating the consensus safety invariant.

## Impact Explanation

**Severity: Critical**

This violates the **Consensus Safety** invariant as defined in the Aptos security model. Specifically:

1. **Safety Rule Bypass**: The missing validation allows circumvention of a fundamental safety mechanism designed to prevent validators from signing conflicting chain commitments

2. **Potential Chain Fork**: Under adversarial network conditions combined with Byzantine behavior (< 2f+1 required), validators could sign order votes for blocks representing different chain branches, potentially leading to a network partition

3. **Inconsistent Finalization**: Different validators could have different views of which blocks are ordered, causing state divergence

Per the Aptos bug bounty program, this qualifies as **Critical Severity** because it represents a "Consensus/Safety violation" that could lead to chain splits under Byzantine conditions combined with network delays.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability can be triggered when:

1. **Network partition exists** causing validators to have different views of the chain
2. **Byzantine proposers** create blocks with QCs referencing older chain states
3. **Message timing** causes order vote proposals to arrive before validators have fully synchronized

The attack does require Byzantine behavior to create the malicious QC initially (2f+1 signatures), but once such a QC exists, honest validators will incorrectly accept and sign order votes for it due to the missing check. In production networks with network latency and partitions, this scenario is realistic.

## Recommendation

Add the preferred round validation to the order vote flow, mirroring the check performed during proposal signing:

```rust
pub(crate) fn guarded_construct_and_sign_order_vote(
    &mut self,
    order_vote_proposal: &OrderVoteProposal,
) -> Result<OrderVote, Error> {
    self.signer()?;
    self.verify_order_vote_proposal(order_vote_proposal)?;
    let proposed_block = order_vote_proposal.block();
    let mut safety_data = self.persistent_storage.safety_data()?;

    // ADD PREFERRED ROUND CHECK BEFORE observe_qc
    self.verify_and_update_preferred_round(
        order_vote_proposal.quorum_cert(),
        &mut safety_data
    )?;

    self.safe_for_order_vote(proposed_block, &safety_data)?;
    
    // ... rest of function
}
```

This ensures order votes are only signed for blocks whose QCs are consistent with the validator's observed 2-chain progression, maintaining the safety invariant.

## Proof of Concept

```rust
// Test case demonstrating the vulnerability
fn test_order_vote_violates_preferred_round() {
    let (mut safety_rules, signer) = create_safety_rules();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    let round = genesis_qc.certified_block().round();
    
    safety_rules.initialize(&proof).unwrap();
    
    // Build honest chain: Genesis <- A(1) <- B(2) <- C(3)
    let a = test_utils::make_proposal_with_qc(round + 1, genesis_qc.clone(), &signer);
    let b = make_proposal_with_parent(round + 2, &a, None, &signer);
    let c = make_proposal_with_parent(round + 3, &b, Some(&a), &signer);
    
    // Vote on A, B, C - this sets preferred_round = 2 (B's round)
    safety_rules.construct_and_sign_vote_two_chain(&a, None).unwrap();
    safety_rules.construct_and_sign_vote_two_chain(&b, None).unwrap();
    safety_rules.construct_and_sign_vote_two_chain(&c, None).unwrap();
    
    let state = safety_rules.consensus_state().unwrap();
    assert_eq!(state.preferred_round(), 2); // B's round
    
    // Create malicious block D(10) that extends Genesis, not C
    // This simulates a Byzantine proposer creating a fork
    let d = make_proposal_with_qc_and_proof(
        round + 10,
        test_utils::empty_proof(),
        genesis_qc.clone(), // Extends genesis, not C!
        &signer,
    );
    
    // Create OrderVoteProposal for D with QC that has parent = Genesis (round 0)
    // In reality, this QC would need 2f+1 signatures from Byzantine validators
    let qc_for_d = create_qc_for_block(&d, round + 9); // certified_block=D, parent=Genesis
    let order_vote_proposal = OrderVoteProposal::new(
        d.block().clone(),
        qc_for_d.certified_block().clone(),
        Arc::new(qc_for_d),
    );
    
    // BUG: This should fail because qc_for_d.parent_block().round() (0) < preferred_round (2)
    // But it succeeds because the check is missing!
    let result = safety_rules.construct_and_sign_order_vote(&order_vote_proposal);
    assert!(result.is_ok(), "Order vote was signed despite conflicting with preferred_round!");
    
    // For comparison, signing D as a proposal correctly fails:
    let proposal_result = safety_rules.sign_proposal(d.block().block_data());
    assert!(matches!(
        proposal_result.unwrap_err(),
        Error::IncorrectPreferredRound(0, 2)
    ), "Proposal signing correctly rejects due to preferred_round violation");
}
```

This PoC demonstrates that while proposal signing correctly enforces the preferred round check, order vote signing does not, allowing validators to sign votes for blocks that conflict with their established chain view.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L172-188)
```rust
    /// Second voting rule
    fn verify_and_update_preferred_round(
        &mut self,
        quorum_cert: &QuorumCert,
        safety_data: &mut SafetyData,
    ) -> Result<bool, Error> {
        let preferred_round = safety_data.preferred_round;
        let one_chain_round = quorum_cert.certified_block().round();

        if one_chain_round < preferred_round {
            return Err(Error::IncorrectPreferredRound(
                one_chain_round,
                preferred_round,
            ));
        }
        Ok(self.observe_qc(quorum_cert, safety_data))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L346-370)
```rust
    fn guarded_sign_proposal(
        &mut self,
        block_data: &BlockData,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        self.verify_author(block_data.author())?;

        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(block_data.epoch(), &safety_data)?;

        if block_data.round() <= safety_data.last_voted_round {
            return Err(Error::InvalidProposal(format!(
                "Proposed round {} is not higher than last voted round {}",
                block_data.round(),
                safety_data.last_voted_round
            )));
        }

        self.verify_qc(block_data.quorum_cert())?;
        self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;
        // we don't persist the updated preferred round to save latency (it'd be updated upon voting)

        let signature = self.sign(block_data)?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L97-119)
```rust
    pub(crate) fn guarded_construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        // Exit early if we cannot sign
        self.signer()?;
        self.verify_order_vote_proposal(order_vote_proposal)?;
        let proposed_block = order_vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // Record 1-chain data
        self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

        self.safe_for_order_vote(proposed_block, &safety_data)?;
        // Construct and sign order vote
        let author = self.signer()?.author();
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
        let signature = self.sign(&ledger_info)?;
        let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
        self.persistent_storage.set_safety_data(safety_data)?;
        Ok(order_vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L168-178)
```rust
    fn safe_for_order_vote(&self, block: &Block, safety_data: &SafetyData) -> Result<(), Error> {
        let round = block.round();
        if round > safety_data.highest_timeout_round {
            Ok(())
        } else {
            Err(Error::NotSafeForOrderVote(
                round,
                safety_data.highest_timeout_round,
            ))
        }
    }
```
