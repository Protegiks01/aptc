# Audit Report

## Title
Timestamp Validation Bypass in Indexer GRPC Metadata Manager Enables Stale Data Acceptance and Service Registry Pollution

## Summary
The `is_stale_timestamp` function in the indexer GRPC metadata manager fails to validate timestamps set in the future, allowing malicious data services to bypass staleness detection. This enables perpetual registration of offline services and acceptance of stale blockchain data.

## Finding Description

The `LiveDataServiceInfo` struct contains a timestamp field that data services self-report in ping responses. [1](#0-0) 

When data services respond to ping requests, they set their own timestamp. [2](#0-1) 

The metadata manager validates timestamps using `is_stale_timestamp`, which uses `saturating_sub` to calculate staleness. [3](#0-2) 

**The Critical Flaw:** When a timestamp is set to a future date, `saturating_sub` returns 0, causing the staleness check to always pass. The unreachability detection logic relies solely on this flawed check. [4](#0-3) 

**Attack Scenario:**
1. Attacker registers a malicious data service by sending a heartbeat with `LiveDataServiceInfo` containing a timestamp set to year 2100
2. The metadata manager stores this timestamp without validation
3. The attacker stops responding or serves stale blockchain data
4. Every second, the manager checks for unreachable services using `is_stale_timestamp`
5. Because the timestamp is in the future, staleness = 0, failing the `>= 60 seconds` threshold
6. The service is never marked unreachable and never removed from the registry
7. User requests are routed to this dead/malicious service [5](#0-4) 

This directly answers the security question: **YES, timestamps can be set to values that don't match wall clock time, causing both time-travel attacks (future timestamps) and stale data acceptance.**

## Impact Explanation

This vulnerability qualifies as **Medium severity** per the Aptos bug bounty criteria:

**State Inconsistencies Requiring Intervention:** Malicious data services serving stale blockchain data will be accepted as "fresh" by the routing logic, causing indexer clients to receive incorrect historical state. This creates state inconsistencies between what clients believe is current data versus actual blockchain state.

**Service Degradation (approaching High severity):** Accumulation of dead services in the registry causes:
- Failed user requests when routed to offline services
- Resource exhaustion as the registry grows unbounded
- Degraded routing performance as the candidate pool becomes polluted

While this affects the indexer layer (not core consensus), the indexer is critical infrastructure for wallets, explorers, and dApps. Widespread stale data acceptance could cause serious issues for ecosystem participants.

## Likelihood Explanation

**Very High Likelihood:**
- **Low Attacker Requirements:** No authentication exists for data service registration
- **Trivial Exploitation:** Attacker simply sends one malformed heartbeat message with future timestamp
- **No Detection:** No logging or monitoring alerts on future timestamps
- **Persistent Impact:** Once registered, the malicious service remains indefinitely
- **No Rate Limiting:** Attacker can register multiple malicious services

The attack requires minimal resources and can be executed by any network participant.

## Recommendation

Add bidirectional timestamp validation to reject both stale AND future timestamps:

```rust
fn is_invalid_timestamp(timestamp: Timestamp, stale_threshold: Duration, future_threshold: Duration) -> bool {
    let timestamp_since_epoch = Duration::new(timestamp.seconds as u64, timestamp.nanos as u32);
    let now_since_epoch = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
    
    // Check if timestamp is too old
    let staleness = now_since_epoch.saturating_sub(timestamp_since_epoch);
    if staleness >= stale_threshold {
        return true;
    }
    
    // Check if timestamp is too far in the future
    let future_offset = timestamp_since_epoch.saturating_sub(now_since_epoch);
    if future_offset >= future_threshold {
        return true;
    }
    
    false
}
```

Replace all calls to `is_stale_timestamp` with `is_invalid_timestamp` using appropriate thresholds (e.g., 60 seconds for staleness, 5 seconds for future tolerance to account for clock skew).

Additionally, add validation in `handle_live_data_service_info` to reject timestamps that fail validation before storing them.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::time::{Duration, SystemTime, UNIX_EPOCH};
    use aptos_protos::util::timestamp::Timestamp;

    #[test]
    fn test_future_timestamp_bypass() {
        // Create a timestamp 1 year in the future
        let future_time = SystemTime::now() + Duration::from_secs(365 * 24 * 60 * 60);
        let future_ts = future_time.duration_since(UNIX_EPOCH).unwrap();
        let future_timestamp = Timestamp {
            seconds: future_ts.as_secs() as i64,
            nanos: future_ts.subsec_nanos() as i32,
        };
        
        // The current implementation incorrectly returns false (not stale)
        let result = MetadataManager::is_stale_timestamp(
            future_timestamp, 
            Duration::from_secs(60)
        );
        
        assert_eq!(result, false, "BUG: Future timestamp bypasses staleness check!");
        // Expected: should return true to mark as invalid
        
        // Demonstrate staleness calculation returns 0
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
        let future_dur = Duration::new(future_timestamp.seconds as u64, future_timestamp.nanos as u32);
        let staleness = now.saturating_sub(future_dur);
        
        assert_eq!(staleness, Duration::ZERO, "saturating_sub returns 0 for future timestamps");
    }
}
```

## Notes

This vulnerability is specific to the indexer GRPC infrastructure and does not affect core blockchain consensus, transaction processing, or on-chain state. However, the indexer is critical infrastructure that many ecosystem participants depend on for accurate blockchain data. The combination of easy exploitability and potential for widespread impact on data consumers justifies Medium severity classification.

### Citations

**File:** protos/rust/src/pb/aptos.indexer.v1.rs (L196-208)
```rust
pub struct LiveDataServiceInfo {
    #[prost(uint64, tag="1")]
    pub chain_id: u64,
    #[prost(message, optional, tag="2")]
    pub timestamp: ::core::option::Option<super::super::util::timestamp::Timestamp>,
    #[prost(uint64, optional, tag="3")]
    pub known_latest_version: ::core::option::Option<u64>,
    #[prost(message, optional, tag="4")]
    pub stream_info: ::core::option::Option<StreamInfo>,
    /// If not present, it means the data service is not available to serve anything yet.
    #[prost(uint64, optional, tag="5")]
    pub min_servable_version: ::core::option::Option<u64>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs (L176-182)
```rust
            let info = LiveDataServiceInfo {
                chain_id: self.connection_manager.chain_id(),
                timestamp: Some(timestamp_now_proto()),
                known_latest_version: Some(known_latest_version),
                stream_info: Some(stream_info),
                min_servable_version,
            };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L167-173)
```rust
    fn is_stale_timestamp(timestamp: Timestamp, threshold: Duration) -> bool {
        let timestamp_since_epoch = Duration::new(timestamp.seconds as u64, timestamp.nanos as u32);
        let now_since_epoch = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
        let staleness = now_since_epoch.saturating_sub(timestamp_since_epoch);

        staleness >= threshold
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L219-228)
```rust
                    let unreachable = live_data_service.recent_states.back().is_some_and(|s| {
                        Self::is_stale_timestamp(
                            s.timestamp.unwrap_or_default(),
                            Duration::from_secs(60),
                        )
                    });
                    if unreachable {
                        unreachable_live_data_services.push(address.clone());
                        continue;
                    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L71-88)
```rust
    fn pick_live_data_service(&self, starting_version: u64) -> Option<String> {
        let mut candidates = vec![];
        for candidate in self.metadata_manager.get_live_data_services_info() {
            if let Some(info) = candidate.1.back().as_ref() {
                // TODO(grao): Handle the case when the requested starting version is beyond the
                // latest version.
                if info.min_servable_version.is_none()
                    || starting_version < info.min_servable_version.unwrap()
                {
                    continue;
                }
                let num_active_streams = info.stream_info.as_ref().unwrap().active_streams.len();
                candidates.push((candidate.0, num_active_streams));
            }
        }

        Self::pick_data_service_from_candidate(candidates)
    }
```
