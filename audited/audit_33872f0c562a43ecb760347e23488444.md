# Audit Report

## Title
Unauthenticated Admin Service Endpoint Enables I/O Amplification DoS on Testnet/Devnet Validators

## Summary
The admin service's `/debug/consensus/block` endpoint performs unbounded full database scans when called without a `block_id` parameter, reading all blocks from the consensus database and all batches from the quorum store. On testnet/devnet validators, this service is enabled by default without authentication and binds to all network interfaces, allowing unprivileged attackers to trigger excessive disk I/O that degrades validator performance.

## Finding Description

The admin service exposes debug endpoints for consensus data inspection. When the `/debug/consensus/block` endpoint is called without specifying a `block_id` query parameter, it triggers a complete scan of both the consensus database and quorum store database: [1](#0-0) 

This function calls `consensus_db.consensus_db().get_data()` which internally performs: [2](#0-1) 

The `get_all::<BlockSchema>()` method creates a database iterator and collects ALL blocks: [3](#0-2) 

Similarly, `quorum_store_db.get_all_batches()` reads all batch data from the quorum store. These operations have no pagination, rate limiting, or size constraints.

The critical vulnerability stems from the default admin service configuration on testnet/devnet: [4](#0-3) 

The service is automatically enabled on non-mainnet chains with no authentication: [5](#0-4) 

The authentication check allows all requests when `authentication_configs` is empty: [6](#0-5) 

**Attack Path:**
1. Attacker identifies a testnet/devnet validator with admin service exposed (port 9102)
2. Sends `GET http://validator-ip:9102/debug/consensus/block` (without `block_id` parameter)
3. Validator performs full table scan of consensus DB and quorum store DB
4. Disk I/O spikes, impacting consensus operations and block processing
5. Attacker repeats requests to sustain performance degradation

This breaks the **Resource Limits invariant** (#9: "All operations must respect gas, storage, and computational limits"), as the endpoint performs unbounded I/O operations without resource controls.

## Impact Explanation

This qualifies as **Medium severity** under the Aptos bug bounty program, potentially escalating to **High severity**:

**Medium Severity** ($10,000): The issue causes validator performance degradation requiring operational intervention. Sustained attacks could force validators to restart or implement emergency firewall rules.

**High Severity** ($50,000): The vulnerability causes "Validator node slowdowns" as explicitly listed in the High severity criteria. During consensus-critical operations, disk I/O contention from database scans can delay block processing, voting, and execution.

The impact includes:
- Degraded validator performance during consensus operations
- Potential missed block proposals due to I/O bottlenecks
- Consensus round delays affecting network throughput
- Validator operator intervention required (firewall rules, service restart)

## Likelihood Explanation

**Likelihood: Medium to High on testnet/devnet**

The attack is trivial to execute:
- **No authentication required** on default testnet/devnet configurations
- **Simple HTTP GET request** (no exploit code needed)
- **Port commonly accessible** if validators are deployed without additional network hardening
- **No rate limiting** allows sustained attacks

Testnet/devnet validators are often deployed with default configurations for ease of testing, making them more likely to have the admin service exposed. Many operators focus on mainnet security while using default settings for test networks.

**Likelihood: Low on mainnet**

The admin service is disabled by default on mainnet and requires authentication if enabled: [7](#0-6) 

## Recommendation

**Immediate Mitigations:**

1. **Implement pagination and limits** for database scan operations:
```rust
pub fn dump_blocks(
    consensus_db: &dyn PersistentLivenessStorage,
    quorum_store_db: &dyn QuorumStoreStorage,
    block_id: Option<HashValue>,
    max_blocks: Option<usize>, // Add limit parameter
) -> anyhow::Result<String> {
    // ... existing code ...
    
    let (_, _, mut blocks, _) = consensus_db.consensus_db().get_data()?;
    
    // Limit the number of blocks processed
    if let Some(max) = max_blocks {
        blocks.truncate(max);
    }
    
    // ... rest of function
}
```

2. **Add rate limiting** to admin service endpoints using a semaphore or token bucket:
```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

struct Context {
    // ... existing fields ...
    admin_request_semaphore: Arc<Semaphore>,
}

// In serve_requests:
let permit = context.admin_request_semaphore
    .try_acquire()
    .map_err(|_| reply_with_status(
        StatusCode::TOO_MANY_REQUESTS,
        "Rate limit exceeded"
    ))?;
```

3. **Require authentication by default on all chains**:
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "127.0.0.1".to_string(), // Bind to localhost only
            port: 9102,
            authentication_configs: vec![
                // Force operators to explicitly configure authentication
            ],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
}
```

4. **Change default binding address** from `0.0.0.0` to `127.0.0.1` to prevent accidental exposure.

5. **Add request size/time budgets** with timeout and result size limits.

## Proof of Concept

**Reproduction Steps:**

1. Deploy a testnet validator with default admin service configuration:
```bash
# Use default NodeConfig which enables admin service on testnet
aptos node run-local-testnet --with-indexer-api
```

2. Verify admin service is accessible:
```bash
curl http://localhost:9102/debug/consensus/block
# Returns all blocks without authentication
```

3. Measure disk I/O impact:
```bash
# Monitor disk I/O
iostat -x 1 &

# Trigger multiple concurrent requests
for i in {1..10}; do
    curl "http://localhost:9102/debug/consensus/block" &
done

# Observe I/O spike and validator performance metrics
```

4. Observe performance degradation in validator logs showing increased block processing latency.

**Expected Result:** Multiple concurrent database scans cause measurable disk I/O contention, increasing block processing time and consensus round latency.

**Rust Test Reproduction:**
```rust
#[tokio::test]
async fn test_admin_service_io_amplification() {
    // Setup validator with default testnet config
    let node_config = NodeConfig::default_for_public_full_node();
    assert_eq!(node_config.admin_service.enabled, Some(true));
    assert!(node_config.admin_service.authentication_configs.is_empty());
    
    // Simulate multiple concurrent requests
    let mut handles = vec![];
    for _ in 0..10 {
        let handle = tokio::spawn(async {
            reqwest::get("http://localhost:9102/debug/consensus/block")
                .await
                .unwrap()
        });
        handles.push(handle);
    }
    
    // All requests succeed without authentication
    for handle in handles {
        assert!(handle.await.unwrap().status().is_success());
    }
}
```

**Notes**

While mainnet deployments have proper protections (service disabled by default, authentication required if enabled), the vulnerability exists in testnet/devnet default configurations where the admin service is enabled without authentication and binds to all network interfaces. This represents a defense-in-depth failure where operators deploying test validators without additional network hardening are vulnerable to performance degradation attacks.

The issue is exacerbated by the lack of rate limiting and unbounded nature of the database scan operations, which persist across all deployment configurations. Even with authentication enabled, a compromised admin credential could enable the same attack vector.

### Citations

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L179-204)
```rust
fn dump_blocks(
    consensus_db: &dyn PersistentLivenessStorage,
    quorum_store_db: &dyn QuorumStoreStorage,
    block_id: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    let all_batches = quorum_store_db.get_all_batches()?;

    let (_, _, blocks, _) = consensus_db.consensus_db().get_data()?;

    for block in blocks {
        let id = block.id();
        if block_id.is_none() || id == block_id.unwrap() {
            body.push_str(&format!("Block ({id:?}): \n\n"));
            match extract_txns_from_block(&block, &all_batches) {
                Ok(txns) => {
                    body.push_str(&format!("{txns:?}"));
                },
                Err(e) => {
                    body.push_str(&format!("Not available: {e:?}"));
                },
            };
            body.push_str("\n\n");
        }
    }
```

**File:** consensus/src/consensusdb/mod.rs (L80-106)
```rust
    pub fn get_data(
        &self,
    ) -> Result<(
        Option<Vec<u8>>,
        Option<Vec<u8>>,
        Vec<Block>,
        Vec<QuorumCert>,
    )> {
        let last_vote = self.get_last_vote()?;
        let highest_2chain_timeout_certificate = self.get_highest_2chain_timeout_certificate()?;
        let consensus_blocks = self
            .get_all::<BlockSchema>()?
            .into_iter()
            .map(|(_, block)| block)
            .collect();
        let consensus_qcs = self
            .get_all::<QCSchema>()?
            .into_iter()
            .map(|(_, qc)| qc)
            .collect();
        Ok((
            last_vote,
            highest_2chain_timeout_certificate,
            consensus_blocks,
            consensus_qcs,
        ))
    }
```

**File:** consensus/src/consensusdb/mod.rs (L201-205)
```rust
    pub fn get_all<S: Schema>(&self) -> Result<Vec<(S::Key, S::Value)>, DbError> {
        let mut iter = self.db.iter::<S>()?;
        iter.seek_to_first();
        Ok(iter.collect::<Result<Vec<(S::Key, S::Value)>, AptosDbError>>()?)
    }
```

**File:** config/src/config/admin_service_config.rs (L41-50)
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
```

**File:** config/src/config/admin_service_config.rs (L67-78)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }
```

**File:** config/src/config/admin_service_config.rs (L93-103)
```rust
        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

            modified_config = true; // The config was modified
        }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-174)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };
```
