# Audit Report

## Title
Metadata Version Incompatibility Causes Silent Deserialization Failures and Validation Bypass

## Summary
The `get_metadata_from_compiled_code()` function silently converts BCS deserialization errors to `None`, making it indistinguishable from legitimate "no metadata" cases. This enables validation bypass when future metadata versions or malformed metadata fail to deserialize, potentially causing consensus divergence between validators running different code versions. [1](#0-0) 

## Finding Description

The core vulnerability exists in the metadata extraction logic where deserialization errors are silently discarded: [2](#0-1) 

This breaks the **Deterministic Execution** invariant in multiple scenarios:

**Scenario 1: Future Metadata Version Incompatibility**
If a future compiler creates bytecode with an evolved metadata format (e.g., "V1.5" or "V2") but continues using the `APTOS_METADATA_KEY_V1` key, current validator nodes will fail to deserialize it. The `.ok()` pattern converts the error to `None`, causing the system to treat the module as having no metadata.

**Scenario 2: Consensus Divergence**
When validators run different code versions that interpret metadata differently:
- Validator A (old version): Deserialization fails → returns `None` → bypasses attribute validation
- Validator B (new version): Deserialization succeeds → extracts attributes → enforces validation
- **Result**: Different validators make different validation decisions, violating consensus safety

**Critical validation paths affected:**

1. **Event Validation** - When metadata deserialization fails, the system incorrectly assumes no event structs exist: [3](#0-2) 

This allows structs to be emitted via `0x1::event::emit` without the required `#[event]` attribute, bypassing the validation that should catch this: [4](#0-3) 

2. **Resource Group Validation** - Similar issue where failed deserialization is treated as "no resource groups": [5](#0-4) 

3. **Module Publishing Validation** - While `check_metadata_format` provides some protection, it's only called when resource groups are enabled: [6](#0-5) 

If deserialization fails after `check_metadata_format`, all attribute validation is silently bypassed.

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria:

1. **State Inconsistencies Requiring Intervention**: If different validators interpret metadata differently due to version mismatches, the blockchain could experience validation divergence requiring manual intervention or rollback.

2. **Validation Bypass**: Malformed or incompatible metadata can bypass critical security checks for:
   - Event attribute validation (allowing invalid event emissions)
   - Resource group membership validation (allowing resources outside their designated groups)
   - View function identification (potentially allowing non-view functions in view contexts)

3. **Consensus Risk**: While not an immediate consensus break, version incompatibility during upgrades could cause validators to diverge on transaction acceptance, threatening the **Deterministic Execution** invariant.

The issue doesn't directly enable fund theft or complete network failure, but it creates state inconsistencies and could lead to consensus issues during protocol upgrades.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability becomes exploitable in these scenarios:

1. **Protocol Upgrades**: When the Aptos team introduces a new metadata format (V2), there's a transitional period where some validators haven't upgraded yet. During this window, modules with the new format would be interpreted differently by different validators.

2. **Malicious Module Publishing**: An attacker could craft bytecode with intentionally malformed V1 metadata that fails BCS deserialization. While `check_metadata_format` normally catches this, the silent error handling means any bypasses would go undetected.

3. **Compiler Bugs**: If a future Move compiler accidentally generates slightly incompatible metadata, it would silently fail to deserialize on existing validators without any error indication.

The attack requires either:
- Access to a modified compiler (low barrier)
- Waiting for a protocol upgrade window (guaranteed to occur)
- Finding a way to bypass `check_metadata_format` (moderate difficulty)

## Recommendation

**Fix 1: Add explicit version field to RuntimeModuleMetadataV1**

Create a versioned wrapper structure:
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VersionedRuntimeModuleMetadata {
    pub version: u32,
    pub metadata: RuntimeModuleMetadataV1,
}
```

**Fix 2: Return Result instead of Option**

Change the function signature to properly propagate errors: [7](#0-6) 

Should become:
```rust
pub fn get_metadata_from_compiled_code(
    code: &impl CompiledCodeMetadata,
) -> Result<Option<RuntimeModuleMetadataV1>, BcsError>
```

**Fix 3: Always validate metadata format**

Remove the feature flag dependency: [8](#0-7) 

Should become:
```rust
check_metadata_format(module)?;
```

**Fix 4: Add version compatibility checking**

Before deserializing, verify that the metadata version matches expected format:
```rust
if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY_V1) {
    // Add version magic bytes check at the start of data.value
    if !is_compatible_metadata_version(&data.value) {
        return Err(MalformedError::IncompatibleVersion);
    }
    let metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)?;
    // ...
}
```

## Proof of Concept

```rust
#[test]
fn test_future_metadata_version_causes_validation_bypass() {
    use move_binary_format::CompiledModule;
    use move_core_types::metadata::Metadata;
    use aptos_types::vm::module_metadata::{
        get_metadata_from_compiled_code, RuntimeModuleMetadataV1, APTOS_METADATA_KEY_V1
    };
    
    // Create a valid compiled module
    let mut module = create_test_module();
    
    // Craft "future V2 metadata" that can't deserialize as V1
    // This simulates a future compiler version or malicious bytecode
    #[derive(Serialize)]
    struct FutureMetadataV2 {
        error_map: BTreeMap<u64, ErrorDescription>,
        struct_attributes: BTreeMap<String, Vec<KnownAttribute>>,
        fun_attributes: BTreeMap<String, Vec<KnownAttribute>>,
        // New field that didn't exist in V1
        future_field: String,
        // Changed field type
        version: u32,
    }
    
    let future_metadata = FutureMetadataV2 {
        error_map: BTreeMap::new(),
        struct_attributes: BTreeMap::new(),
        fun_attributes: BTreeMap::new(),
        future_field: "new_data".to_string(),
        version: 2,
    };
    
    // Serialize with V1 key but V2 structure
    let serialized = bcs::to_bytes(&future_metadata).unwrap();
    module.metadata = vec![Metadata {
        key: APTOS_METADATA_KEY_V1.to_vec(),
        value: serialized,
    }];
    
    // Attempt to deserialize - should fail silently
    let result = get_metadata_from_compiled_code(&module);
    
    // BUG: Returns None instead of error
    assert!(result.is_none(), "Should return None on incompatible version");
    
    // This module would pass validation thinking it has no metadata
    // But it actually has attributes that should be validated!
    // This demonstrates the validation bypass vulnerability
}

#[test]
fn test_consensus_divergence_on_version_mismatch() {
    // Validator A running old code
    let validator_a_result = get_metadata_from_compiled_code_v1(&module);
    // Returns None - treats as no metadata
    
    // Validator B running new code
    let validator_b_result = get_metadata_from_compiled_code_v2(&module);
    // Successfully deserializes - enforces validations
    
    // Different validators make different validation decisions!
    assert_ne!(
        validator_a_result.is_some(),
        validator_b_result.is_some(),
        "Consensus divergence detected"
    );
}
```

## Notes

While `check_metadata_format` provides validation when resource groups are enabled (which is default on mainnet as confirmed here: [9](#0-8) ), the fundamental design flaw of silently discarding deserialization errors remains. This creates a forward compatibility risk that could manifest during protocol upgrades or if feature flags are ever disabled.

The special handling for version 5 bytecode demonstrates awareness of version compatibility issues: [10](#0-9) 

However, this is a retroactive patch rather than a robust versioning strategy. The absence of an explicit version field in `RuntimeModuleMetadataV1` structure prevents proper forward compatibility checking.

### Citations

**File:** types/src/vm/module_metadata.rs (L287-308)
```rust
pub fn get_metadata_from_compiled_code(
    code: &impl CompiledCodeMetadata,
) -> Option<RuntimeModuleMetadataV1> {
    if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY_V1) {
        let mut metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value).ok();
        // Clear out metadata for v5, since it shouldn't have existed in the first place and isn't
        // being used. Note, this should have been gated in the verify module metadata.
        if code.version() == 5 {
            if let Some(metadata) = metadata.as_mut() {
                metadata.struct_attributes.clear();
                metadata.fun_attributes.clear();
            }
        }
        metadata
    } else if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY) {
        // Old format available, upgrade to new one on the fly
        let data_v0 = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value).ok()?;
        Some(data_v0.upgrade())
    } else {
        None
    }
}
```

**File:** types/src/vm/module_metadata.rs (L449-456)
```rust
    if features.are_resource_groups_enabled() {
        check_metadata_format(module)?;
    }
    let metadata = if let Some(metadata) = get_metadata_from_compiled_code(module) {
        metadata
    } else {
        return Ok(());
    };
```

**File:** aptos-move/aptos-vm/src/verifier/event_validation.rs (L45-48)
```rust
        let mut new_event_structs = get_metadata_from_compiled_code(new_module).map_or_else(
            || Ok(HashSet::new()),
            |metadata| extract_event_metadata(&metadata),
        )?;
```

**File:** aptos-move/aptos-vm/src/verifier/event_validation.rs (L132-133)
```rust
                                } else if !event_structs.contains(struct_name.as_str()) {
                                    metadata_validation_err(format!("Missing #[event] attribute on {}. The #[event] attribute is required for all structs passed into 0x1::event::emit.", struct_name).as_str())
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L120-124)
```rust
        if let Some(metadata) = get_metadata_from_compiled_code(new_module) {
            extract_resource_group_metadata(&metadata)?
        } else {
            (BTreeMap::new(), BTreeMap::new())
        };
```

**File:** types/src/on_chain_config/aptos_features.rs (L183-183)
```rust
            FeatureFlag::RESOURCE_GROUPS,
```
