# Audit Report

## Title
Stream Fragmentation Buffer Boundary Bypass Allows Memory Exhaustion Beyond max_message_size Limit

## Summary
The stream fragmentation logic contains an off-by-one error in the `max_fragments` calculation that allows an attacker to reconstruct messages exceeding `max_message_size` by approximately `max_frame_size`. This occurs because the calculation does not account for the initial data already present in the StreamHeader's message field, allowing attackers to bypass memory limits and cause resource exhaustion.

## Finding Description

The vulnerability exists in the calculation of `max_fragments` and the validation logic for inbound stream messages. [1](#0-0) 

The calculation `max_fragments = max_message_size / max_frame_size` assumes that fragments are the only source of data, but fails to account for the initial data already present in the StreamHeader's `message` field. [2](#0-1) 

With default configuration values of `MAX_FRAME_SIZE = 4 MiB` and `MAX_MESSAGE_SIZE = 64 MiB`, this yields `max_fragments = 16`.

When an outbound stream is created legitimately, the first `max_frame_size` bytes remain in the header message, and only the remainder is fragmented: [3](#0-2) 

However, the inbound validation only checks that the number of fragments doesn't exceed `max_fragments`: [4](#0-3) 

There is **no validation** that the total reconstructed message size (header data + all fragments) stays within `max_message_size`.

When fragments are appended, they simply grow the vector without size checks: [5](#0-4) 

**Attack Scenario:**
1. Attacker sends a StreamHeader with `num_fragments = 16` and a message containing ~4 MiB of data
2. Attacker sends 16 StreamFragment messages, each containing ~4 MiB of raw_data
3. The validation at line 151 passes: `16 <= 16` ✓
4. Total reconstructed size: ~4 MiB + (16 × ~4 MiB) = ~68 MiB
5. This exceeds `max_message_size` of 64 MiB by ~4 MiB

The frame size limit enforced by `LengthDelimitedCodec` only validates individual frame sizes, not cumulative message size: [6](#0-5) 

## Impact Explanation

This vulnerability is **High Severity** according to Aptos bug bounty criteria for the following reasons:

1. **Validator Node Slowdowns**: An attacker can force validators to allocate and process messages larger than the configured `max_message_size`, consuming excessive memory. With default values, each malicious stream consumes 68 MiB instead of the expected 64 MiB maximum—a 6.25% increase per message.

2. **Resource Exhaustion DoS**: An attacker can establish multiple connections and send many oversized streamed messages concurrently, multiplying memory consumption. With 100 concurrent malicious streams, this consumes an extra 400 MiB beyond limits.

3. **Protocol Violation**: This breaks the documented invariant "Resource Limits: All operations must respect gas, storage, and computational limits" by allowing messages to exceed the configured `max_message_size` safety bound.

4. **Consensus Impact**: If validator nodes become memory-constrained or experience slowdowns from processing oversized messages, this can degrade consensus performance and potentially cause liveness issues.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attacker Requirements**: Only requires ability to establish a network connection to a validator or fullnode—no special privileges, authentication, or stake required
- **Attack Complexity**: LOW—attacker simply needs to craft a StreamHeader and fragments with specific sizes
- **Detection Difficulty**: The attack is difficult to distinguish from legitimate large message streaming without deep packet inspection
- **No Rate Limiting**: The vulnerability can be exploited repeatedly without special conditions
- **Default Configuration Vulnerable**: All nodes using default `MAX_FRAME_SIZE` and `MAX_MESSAGE_SIZE` values are affected

## Recommendation

The `max_fragments` calculation must account for the initial data in the StreamHeader's message field. There are two solutions:

**Solution 1: Adjust max_fragments calculation**
```rust
// In network/framework/src/peer/mod.rs, line 168
let max_fragments = (max_message_size / max_frame_size).saturating_sub(1);
```

This ensures total size is bounded: `max_frame_size + (max_fragments * max_frame_size) <= max_message_size`

**Solution 2: Add explicit size validation in InboundStream::new()**
```rust
// In network/framework/src/protocols/stream/mod.rs, after line 153
let header_data_size = header_message.data_len();
let max_total_size = max_fragments * max_frame_size;
ensure!(
    header_data_size <= max_total_size,
    "Stream header data size {} plus fragments would exceed max message size!",
    header_data_size
);
```

**Recommended approach**: Implement both solutions for defense-in-depth. Solution 1 fixes the root cause, while Solution 2 provides an additional validation layer.

## Proof of Concept

```rust
// This PoC demonstrates the vulnerability by showing how an attacker
// can craft a stream that exceeds max_message_size

use aptos_network::protocols::stream::{InboundStreamBuffer, StreamHeader, StreamFragment};
use aptos_network::protocols::wire::messaging::v1::{NetworkMessage, DirectSendMsg};
use aptos_network::protocols::wire::handshake::v1::ProtocolId;

#[test]
fn test_stream_size_limit_bypass() {
    const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; // 4 MiB
    const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; // 64 MiB
    
    // Calculate max_fragments as done in peer/mod.rs:168
    let max_fragments = MAX_MESSAGE_SIZE / MAX_FRAME_SIZE; // = 16
    
    let mut inbound_stream = InboundStreamBuffer::new(max_fragments);
    
    // Create header with message containing MAX_FRAME_SIZE of data
    let header_data = vec![0u8; MAX_FRAME_SIZE];
    let header = StreamHeader {
        request_id: 1,
        num_fragments: max_fragments as u8, // 16 fragments
        message: NetworkMessage::DirectSendMsg(DirectSendMsg {
            protocol_id: ProtocolId::ConsensusRpcBcs,
            priority: 0,
            raw_msg: header_data,
        }),
    };
    
    // This should pass validation but leads to oversized message
    assert!(inbound_stream.new_stream(header).is_ok());
    
    // Send max_fragments (16) fragments, each with MAX_FRAME_SIZE data
    for fragment_id in 1..=max_fragments as u8 {
        let fragment = StreamFragment {
            request_id: 1,
            fragment_id,
            raw_data: vec![0u8; MAX_FRAME_SIZE],
        };
        
        let result = inbound_stream.append_fragment(fragment);
        
        if fragment_id == max_fragments as u8 {
            // Final fragment completes the stream
            let reconstructed_message = result.unwrap().unwrap();
            let total_size = reconstructed_message.data_len();
            
            // VULNERABILITY: Total size exceeds MAX_MESSAGE_SIZE
            // Expected: <= 64 MiB
            // Actual: ~68 MiB (4 MiB header + 16 * 4 MiB fragments)
            assert!(total_size > MAX_MESSAGE_SIZE, 
                "Total size {} exceeds MAX_MESSAGE_SIZE {}", 
                total_size, MAX_MESSAGE_SIZE);
            
            println!("VULNERABILITY CONFIRMED:");
            println!("  MAX_MESSAGE_SIZE: {} bytes ({} MiB)", 
                MAX_MESSAGE_SIZE, MAX_MESSAGE_SIZE / (1024*1024));
            println!("  Reconstructed size: {} bytes ({} MiB)", 
                total_size, total_size / (1024*1024));
            println!("  Excess: {} bytes ({} MiB)", 
                total_size - MAX_MESSAGE_SIZE, 
                (total_size - MAX_MESSAGE_SIZE) / (1024*1024));
        } else {
            assert!(result.unwrap().is_none());
        }
    }
}
```

## Notes

This vulnerability affects all Aptos nodes (validators and fullnodes) using the default network configuration. The 4 MiB excess per malicious stream may seem small, but when multiplied across many concurrent connections, it enables significant memory exhaustion attacks. The fix requires updating the fragment calculation logic in `peer/mod.rs` and adding explicit validation in `stream/mod.rs` to properly enforce the `max_message_size` invariant.

### Citations

**File:** network/framework/src/peer/mod.rs (L168-168)
```rust
        let max_fragments = max_message_size / max_frame_size;
```

**File:** config/src/config/network_config.rs (L49-50)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** network/framework/src/protocols/stream/mod.rs (L150-153)
```rust
        ensure!(
            (header_num_fragments as usize) <= max_fragments,
            "Stream header exceeds max fragments limit!"
        );
```

**File:** network/framework/src/protocols/stream/mod.rs (L200-209)
```rust
        // Append the fragment data to the message
        let raw_data = &mut fragment.raw_data;
        match &mut self.message {
            NetworkMessage::Error(_) => {
                panic!("StreamHeader for NetworkMessage::Error(_) should be rejected!")
            },
            NetworkMessage::RpcRequest(request) => request.raw_request.append(raw_data),
            NetworkMessage::RpcResponse(response) => response.raw_response.append(raw_data),
            NetworkMessage::DirectSendMsg(message) => message.raw_msg.append(raw_data),
        }
```

**File:** network/framework/src/protocols/stream/mod.rs (L286-301)
```rust
        // Split the message data into chunks
        let rest = match &mut message {
            NetworkMessage::Error(_) => {
                unreachable!("NetworkMessage::Error(_) should always fit into a single frame!")
            },
            NetworkMessage::RpcRequest(request) => {
                request.raw_request.split_off(self.max_frame_size)
            },
            NetworkMessage::RpcResponse(response) => {
                response.raw_response.split_off(self.max_frame_size)
            },
            NetworkMessage::DirectSendMsg(message) => {
                message.raw_msg.split_off(self.max_frame_size)
            },
        };
        let chunks = rest.chunks(self.max_frame_size);
```

**File:** network/framework/src/protocols/wire/messaging/v1/mod.rs (L197-203)
```rust
pub fn network_message_frame_codec(max_frame_size: usize) -> LengthDelimitedCodec {
    LengthDelimitedCodec::builder()
        .max_frame_length(max_frame_size)
        .length_field_length(4)
        .big_endian()
        .new_codec()
}
```
