# Audit Report

## Title
Waypoint Verification Bypass Through Storage Version Check Enables Incorrect Bootstrap Fetch Decisions

## Summary
The `should_fetch_epoch_ending_ledger_infos()` function can make incorrect fetch decisions due to premature waypoint verification. When storage already contains data beyond the waypoint version, the waypoint is marked as verified without cryptographic validation, potentially allowing the node to skip necessary epoch fetches and proceed with unverified chain state.

## Finding Description

The vulnerability exists in the interaction between three critical functions in the bootstrapper: [1](#0-0) 

This function determines whether to continue fetching epoch ending ledger infos using OR logic: fetch if epochs not fetched OR waypoint not verified.

The waypoint can be prematurely marked as verified without cryptographic validation: [2](#0-1) 

This bypass assumes storage integrity - if storage version >= waypoint version, the waypoint is marked verified without calling the cryptographic verification function: [3](#0-2) 

**Attack Scenario:**

1. **Node starts with storage at version 10000, epoch 5** (potentially from wrong chain, corrupted, or misconfigured snapshot)
2. **Waypoint configured at version 5000, epoch 3**
3. **Network advertises epoch 5 (same as storage)**

**Execution Flow:**

- `fetch_epoch_ending_ledger_infos()` calls `verify_waypoint_is_satisfiable()`
- Storage check: 10000 >= 5000 â†’ Sets `verified_waypoint = true` **WITHOUT** cryptographic verification
- Calculates `highest_local_epoch_end` = 5 from storage
- Network advertises `highest_advertised_epoch_end` = 5
- Condition check at line 848: 5 < 5 = false (no new epochs)
- Goes to line 861: waypoint verified? **Yes** (incorrectly)
- Sets `fetched_epoch_ending_ledger_infos = true` [4](#0-3) 

**Result:**
- `should_fetch_epoch_ending_ledger_infos()` returns **false** (both flags true)
- Node proceeds to transaction sync **without cryptographically verifying the waypoint**
- No epoch endings fetched from network for validation
- Node relies entirely on potentially corrupted/misconfigured storage

This violates the **Cryptographic Correctness** invariant - the waypoint is a trust anchor that must be cryptographically verified, not assumed valid based on version comparison.

## Impact Explanation

**Severity: Medium** (per Aptos bug bounty criteria: "State inconsistencies requiring intervention")

The waypoint serves as a critical trust anchor to ensure nodes bootstrap to the correct chain. Bypassing its cryptographic verification creates several risks:

1. **Wrong Chain Bootstrapping**: Node configured for mainnet but given testnet storage would proceed without detecting the mismatch
2. **Corrupted Storage Acceptance**: Storage corruption goes undetected if version checks pass
3. **Configuration Mismatch**: Waypoint change between restarts isn't validated against actual storage data

While this doesn't directly enable consensus violations or fund theft, it creates state inconsistencies where nodes may operate on incorrect chain state, requiring manual intervention to detect and repair.

## Likelihood Explanation

**Likelihood: Low-Medium**

This vulnerability requires one of these conditions:
- **Storage corruption** (malicious snapshot, database tampering, bit rot)
- **Configuration changes** (waypoint updated but storage retained)
- **Cross-network errors** (testnet storage with mainnet config)

These are operational/deployment scenarios rather than pure protocol attacks. However, in a distributed network with many node operators, configuration errors and snapshot misuse occur regularly, making this a realistic concern for the network's overall security posture.

The impact is amplified because:
- Waypoint is specifically designed to prevent these scenarios
- Defense-in-depth principle dictates critical checks should not be skipped
- Silent failures are harder to detect than explicit verification errors

## Recommendation

The waypoint must be cryptographically verified on every bootstrap, regardless of storage state. Modify `verify_waypoint_is_satisfiable()` to:

```rust
fn verify_waypoint_is_satisfiable(
    &mut self,
    global_data_summary: &GlobalDataSummary,
) -> Result<(), Error> {
    let waypoint_version = self.driver_configuration.waypoint.version();
    let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
    
    // If storage has data at or beyond waypoint, verify it cryptographically
    if latest_ledger_info.ledger_info().version() >= waypoint_version {
        // Fetch the ledger info at the exact waypoint version
        if let Ok(Some(waypoint_ledger_info)) = self.storage.get_epoch_ending_ledger_info(waypoint_version) {
            // Cryptographically verify the waypoint
            self.driver_configuration.waypoint.verify(&waypoint_ledger_info)?;
            self.verified_epoch_states.set_verified_waypoint(waypoint_version);
            return Ok(());
        }
        // If waypoint version not found in storage, fall through to network check
    }
    
    // Check if waypoint is satisfiable from network
    let highest_advertised_ledger_info = global_data_summary
        .advertised_data
        .highest_synced_ledger_info()
        .ok_or_else(|| Error::UnsatisfiableWaypoint(
            "Unable to check waypoint satisfiability! No highest advertised ledger info found in the network!".into(),
        ))?;
    let highest_advertised_version = highest_advertised_ledger_info.ledger_info().version();
    
    if highest_advertised_version < waypoint_version {
        Err(Error::UnsatisfiableWaypoint(
            format!("The waypoint is not satisfiable! No advertised version higher than our waypoint! Highest version: {:?}, waypoint version: {:?}.",
                highest_advertised_version, waypoint_version)
        ))
    } else {
        Ok(())
    }
}
```

This ensures the waypoint hash is always cryptographically verified against storage data before being marked as verified.

## Proof of Concept

```rust
#[cfg(test)]
mod waypoint_bypass_test {
    use super::*;
    use aptos_types::waypoint::Waypoint;
    
    #[tokio::test]
    async fn test_waypoint_bypass_via_storage_version_check() {
        // Setup: Create a bootstrapper with storage at version 10000
        // and waypoint at version 5000 (different chain/corrupted)
        
        let mut mock_storage = MockDbReader::new();
        let wrong_chain_ledger_info = create_ledger_info_at_version(10000, wrong_epoch_state());
        mock_storage.expect_get_latest_ledger_info()
            .returning(move || Ok(wrong_chain_ledger_info.clone()));
        
        // Configure with DIFFERENT waypoint (correct chain)
        let correct_waypoint = Waypoint::new_any(&create_correct_chain_ledger_info_at_version(5000));
        
        let mut bootstrapper = create_test_bootstrapper(
            Arc::new(mock_storage),
            correct_waypoint
        );
        
        // Execute
        let global_summary = create_global_summary_with_epoch(5);
        bootstrapper.initialize_active_data_stream(&global_summary).await.unwrap();
        
        // Verify: Waypoint marked as verified WITHOUT cryptographic check
        assert!(bootstrapper.verified_epoch_states.verified_waypoint());
        
        // Verify: Both flags set to true, skipping fetch
        assert!(bootstrapper.verified_epoch_states.fetched_epoch_ending_ledger_infos());
        
        // Result: Node proceeds with wrong chain data!
        assert!(!bootstrapper.should_fetch_epoch_ending_ledger_infos());
    }
}
```

**Notes:**
- The waypoint is designed as a defense-in-depth mechanism against storage corruption and configuration errors
- Current implementation bypasses cryptographic verification based solely on version comparison
- This creates a silent failure mode where incorrect chain state is accepted without explicit validation
- The fix ensures waypoint hash is always verified against storage data, maintaining the security guarantee

### Citations

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L445-450)
```rust
    fn should_fetch_epoch_ending_ledger_infos(&self) -> bool {
        !self
            .verified_epoch_states
            .fetched_epoch_ending_ledger_infos()
            || !self.verified_epoch_states.verified_waypoint()
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L847-873)
```rust
        // Compare the highest local epoch end to the highest advertised epoch end
        if highest_local_epoch_end < highest_advertised_epoch_end {
            info!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
                "Found higher epoch ending ledger infos in the network! Local: {:?}, advertised: {:?}",
                   highest_local_epoch_end, highest_advertised_epoch_end
            )));
            let next_epoch_end = highest_local_epoch_end.checked_add(1).ok_or_else(|| {
                Error::IntegerOverflow("The next epoch end has overflown!".into())
            })?;
            let epoch_ending_stream = self
                .streaming_client
                .get_all_epoch_ending_ledger_infos(next_epoch_end)
                .await?;
            self.active_data_stream = Some(epoch_ending_stream);
        } else if self.verified_epoch_states.verified_waypoint() {
            info!(LogSchema::new(LogEntry::Bootstrapper).message(
                "No new epoch ending ledger infos to fetch! All peers are in the same epoch!"
            ));
            self.verified_epoch_states
                .set_fetched_epoch_ending_ledger_infos();
        } else {
            return Err(Error::AdvertisedDataError(format!(
                "Our waypoint is unverified, but there's no higher epoch ending ledger infos \
                advertised! Highest local epoch end: {:?}, highest advertised epoch end: {:?}",
                highest_local_epoch_end, highest_advertised_epoch_end
            )));
        };
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L884-890)
```rust
        // If our storage has already synced beyond our waypoint, nothing needs to be checked
        let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        let waypoint_version = self.driver_configuration.waypoint.version();
        if latest_ledger_info.ledger_info().version() >= waypoint_version {
            self.verified_epoch_states
                .set_verified_waypoint(waypoint_version);
            return Ok(());
```

**File:** types/src/waypoint.rs (L62-79)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
```
