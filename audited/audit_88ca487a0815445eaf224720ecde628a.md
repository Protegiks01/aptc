# Audit Report

## Title
Permanent Connection Poisoning via Single Corrupted Frame in NoiseStream

## Summary
The `NoiseStream` implementation contains a critical state management flaw where a single decryption error permanently poisons the connection. Once `ReadState::DecryptionError` is set, all subsequent read attempts fail indefinitely, forcing expensive reconnections. This enables Byzantine validators to degrade network performance and potentially impact consensus liveness through targeted connection disruption.

## Finding Description

The vulnerability exists in the `NoiseStream` read state machine implementation. When decryption fails, the stream enters an unrecoverable error state with no reset mechanism. [1](#0-0) 

When decryption fails during frame processing, the `read_state` is permanently set to `DecryptionError`. [2](#0-1) 

All subsequent `poll_read` calls immediately return an error without attempting recovery. The state is never reset back to `Init`, making the stream permanently unusable.

Furthermore, the underlying `NoiseSession` is also invalidated when decryption fails: [3](#0-2) 

This creates a double-lock: the stream state remains in `DecryptionError`, and even if reset, the session's `valid` flag is false, causing future decryption attempts to fail immediately: [4](#0-3) 

**Attack Scenario:**

A Byzantine validator can exploit this by sending a single malformed frame to peer validators:
1. Establish authenticated connection via Noise IK handshake
2. Send one frame with corrupted authentication tag (passes length check but fails decryption)
3. Target validator's stream enters permanent `DecryptionError` state
4. All subsequent legitimate messages are rejected
5. Connection must be torn down and re-established [5](#0-4) 

The `PeerManager` detects the failed connection and removes the peer, triggering reconnection via `ConnectivityManager`. [6](#0-5) 

A `LostPeer` notification is sent, forcing the connectivity manager to re-dial with exponential backoff.

## Impact Explanation

**Severity: HIGH** per Aptos bug bounty criteria - "Validator node slowdowns"

**Impact Quantification:**

1. **Single Connection Disruption**: Each poisoned connection forces reconnection overhead (TCP handshake, Noise IK handshake, state synchronization)

2. **Amplification Attack**: A single Byzantine validator can poison connections to all other validators by sending one corrupted frame per connection

3. **Consensus Degradation**: During reconnection periods, consensus messages cannot be delivered, potentially causing:
   - Increased round times
   - Timeout-based view changes
   - Temporary loss of quorum if multiple connections are poisoned simultaneously

4. **Network-Wide Impact**: With N validators, a Byzantine validator can force N-1 reconnections repeatedly, creating sustained network instability

5. **No Defense**: The system has no mechanism to distinguish between accidental corruption (hardware/network errors) and deliberate attacks, so all decryption failures trigger the same unrecoverable state

This violates the **Consensus Liveness** invariant by degrading validator communication beyond the tolerance expected from < 1/3 Byzantine faults.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Factors increasing likelihood:**
- Simple to execute: Requires only sending a single corrupted frame
- Low attacker requirements: Any validator in the active set can launch the attack
- No detection mechanism: Appears as network error, difficult to attribute to malicious behavior
- Repeatable: Attacker can continuously re-poison connections after reconnection

**Factors limiting likelihood:**
- Requires attacker to control a validator (within < 1/3 Byzantine tolerance)
- Mutual authentication prevents external attackers from injecting frames
- May trigger monitoring alerts if reconnection rate is anomalously high

The attack is realistic because Byzantine fault tolerance assumes up to f malicious validators, and this vulnerability allows even a single Byzantine validator to cause disproportionate disruption beyond what the consensus protocol is designed to tolerate.

## Recommendation

Implement graceful error recovery by resetting the read state and attempting to synchronize with the next valid frame:

```rust
ReadState::DecryptionError(ref e) => {
    // Log the error for monitoring
    error!(error = %e, "Decryption Error: {}", e);
    
    // Instead of returning error indefinitely, attempt recovery
    // by resetting to Init state and continuing
    warn!("Attempting to recover from decryption error by resetting stream state");
    self.read_state = ReadState::Init;
    
    // Return the error once to notify the caller
    return Poll::Ready(Err(io::Error::new(
        io::ErrorKind::InvalidData,
        format!("DecryptionError (recovered): {}", e),
    )));
}
```

**Additional hardening measures:**

1. **Connection-level error threshold**: Track consecutive decryption errors and only close connection after multiple failures (e.g., 3-5), allowing recovery from single corruption events

2. **NoiseSession reset**: Provide a mechanism to re-establish session keys without full reconnection if corruption is detected

3. **Monitoring and alerting**: Track decryption error rates per peer to detect potential Byzantine behavior

4. **Frame-level checksums**: Add application-layer checksums before encryption to detect corruption earlier

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::noise::{NoiseUpgrader, HandshakeAuthMode, AntiReplayTimestamps};
    use aptos_config::network_id::NetworkContext;
    use aptos_crypto::{test_utils::TEST_SEED, traits::Uniform, x25519};
    use aptos_memsocket::MemorySocket;
    use futures::{executor::block_on, future::join, io::AsyncWriteExt};
    use rand::SeedableRng;

    #[test]
    fn test_corrupted_frame_poisons_connection() {
        // Setup two peers with noise handshake
        let mut rng = ::rand::rngs::StdRng::from_seed(TEST_SEED);
        
        let client_private = x25519::PrivateKey::generate(&mut rng);
        let client_public = client_private.public_key();
        let client_peer_id = aptos_types::account_address::from_identity_public_key(client_public);
        let client_context = NetworkContext::mock_with_peer_id(client_peer_id);
        
        let server_private = x25519::PrivateKey::generate(&mut rng);
        let server_public = server_private.public_key();
        let server_peer_id = aptos_types::account_address::from_identity_public_key(server_public);
        let server_context = NetworkContext::mock_with_peer_id(server_peer_id);
        
        let client = NoiseUpgrader::new(
            client_context,
            client_private,
            HandshakeAuthMode::server_only(&[client_context.network_id()]),
        );
        let server = NoiseUpgrader::new(
            server_context,
            server_private,
            HandshakeAuthMode::server_only(&[server_context.network_id()]),
        );
        
        // Establish connection
        let (dialer_socket, listener_socket) = MemorySocket::new_pair();
        let (client_session, server_session) = block_on(join(
            client.upgrade_outbound(
                dialer_socket,
                server_peer_id,
                server_public,
                AntiReplayTimestamps::now,
            ),
            server.upgrade_inbound(listener_socket),
        ));
        
        let (mut client_stream, _) = client_session.unwrap();
        let (mut server_stream, _, _) = server_session.unwrap();
        
        // Send valid message first
        block_on(client_stream.write_all(b"valid message")).unwrap();
        block_on(client_stream.flush()).unwrap();
        
        let mut buf = vec![0u8; 13];
        block_on(server_stream.read_exact(&mut buf)).unwrap();
        assert_eq!(&buf, b"valid message");
        
        // Inject corrupted frame directly into socket
        // This simulates a Byzantine validator sending a malformed frame
        let corrupted_frame = vec![0xFF; 100]; // Invalid encrypted data
        let frame_len = (corrupted_frame.len() as u16).to_be_bytes();
        
        // Write corrupted frame length and data
        block_on(async {
            let socket = &mut client_stream.socket;
            socket.write_all(&frame_len).await.unwrap();
            socket.write_all(&corrupted_frame).await.unwrap();
            socket.flush().await.unwrap();
        });
        
        // First read attempt will fail with decryption error
        let mut buf = vec![0u8; 100];
        let result = block_on(server_stream.read(&mut buf));
        assert!(result.is_err());
        assert!(result.unwrap_err().kind() == io::ErrorKind::InvalidData);
        
        // Send another valid message
        block_on(client_stream.write_all(b"second valid message")).unwrap();
        block_on(client_stream.flush()).unwrap();
        
        // ALL subsequent read attempts will fail, even though valid data arrived
        let result = block_on(server_stream.read(&mut buf));
        assert!(result.is_err()); // Connection is permanently poisoned!
        
        let result = block_on(server_stream.read(&mut buf));
        assert!(result.is_err()); // Still failing!
        
        // The connection is now unusable and must be torn down
        // This demonstrates the permanent poisoning vulnerability
    }
}
```

## Notes

This vulnerability represents a violation of the **graceful degradation** principle. While the Noise protocol correctly detects authentication failures, the stream implementation's lack of recovery mechanism transforms a single error into a permanent connection failure. This is particularly problematic in a Byzantine fault-tolerant system where malicious behavior is expected and should be contained rather than amplified.

The fix should balance between resilience to transient errors and protection against sustained attacks, potentially using a threshold-based approach that tolerates limited errors while still detecting persistent Byzantine behavior.

### Citations

**File:** network/framework/src/noise/stream.rs (L154-157)
```rust
                                Err(e) => {
                                    error!(error = %e, "Decryption Error: {}", e);
                                    self.read_state = ReadState::DecryptionError(e);
                                },
```

**File:** network/framework/src/noise/stream.rs (L191-196)
```rust
                ReadState::DecryptionError(ref e) => {
                    return Poll::Ready(Err(io::Error::new(
                        io::ErrorKind::InvalidData,
                        format!("DecryptionError: {}", e),
                    )))
                },
```

**File:** crates/aptos-crypto/src/noise.rs (L668-670)
```rust
        if !self.valid {
            return Err(NoiseError::SessionClosed);
        }
```

**File:** crates/aptos-crypto/src/noise.rs (L690-695)
```rust
        read_key
            .open_in_place(nonce, aead::Aad::empty(), message)
            .map_err(|_| {
                self.valid = false;
                NoiseError::Decrypt
            })?;
```

**File:** network/framework/src/peer_manager/mod.rs (L275-296)
```rust
            TransportNotification::Disconnected(lost_conn_metadata, reason) => {
                // See: https://github.com/aptos-labs/aptos-core/issues/3128#issuecomment-605351504 for
                // detailed reasoning on `Disconnected` events should be handled correctly.
                info!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata_with_address(&lost_conn_metadata),
                    disconnection_reason = reason,
                    "{} Connection {} closed due to {}",
                    self.network_context,
                    lost_conn_metadata,
                    reason
                );
                let peer_id = lost_conn_metadata.remote_peer_id;
                // If the active connection with the peer is lost, remove it from `active_peers`.
                if let Entry::Occupied(entry) = self.active_peers.entry(peer_id) {
                    let (conn_metadata, _) = entry.get();
                    let connection_id = conn_metadata.connection_id;
                    if connection_id == lost_conn_metadata.connection_id {
                        // We lost an active connection.
                        entry.remove();
                        self.remove_peer_from_metadata(peer_id, connection_id);
                    }
```

**File:** network/framework/src/peer_manager/mod.rs (L318-326)
```rust
                // Notify upstream if there's still no active connection. This might be redundant,
                // but does not affect correctness.
                if !self.active_peers.contains_key(&peer_id) {
                    let notif = ConnectionNotification::LostPeer(
                        lost_conn_metadata,
                        self.network_context.network_id(),
                    );
                    self.send_conn_notification(peer_id, notif);
                }
```
