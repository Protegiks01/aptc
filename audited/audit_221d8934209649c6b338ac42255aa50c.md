# Audit Report

## Title
Database Corruption During Pruning Causes Undetected Transaction Index-Record Mismatch

## Summary
The `get_pruning_candidate_transactions()` function lacks validation that the database iterator correctly seeks to the start version. If database corruption causes `iter.seek(&start)` to position incorrectly, the function will collect the wrong set of transactions, leading to a critical mismatch where transaction hash indices and transaction records are deleted for different version ranges. This violates the State Consistency invariant and creates permanent database inconsistencies that persist undetected.

## Finding Description

The pruning logic in `TransactionPruner` has a critical validation gap. [1](#0-0) 

The function performs the following operations without validation:

1. Seeks to the start version using `iter.seek(&start)` 
2. Collects all transactions by iterating until `version >= end`
3. Returns the collected transactions

The critical flaw: **there is no validation that the first transaction returned actually has version == start**. 

Compare this to the defensive implementation elsewhere in the codebase: [2](#0-1) 

This uses `expect_continuous_versions()` which validates each version matches expectations: [3](#0-2) 

The pruning function uses the collected candidate transactions in critically inconsistent ways: [4](#0-3) 

The mismatch occurs at:
- **Line 43-46**: Deletes hash indices for transactions actually collected (potentially wrong set)
- **Line 47-51**: Deletes transaction records based on version range parameters (correct set): [5](#0-4) 

**Attack Scenario:**

If database corruption causes `seek(100)` to position at version 110 instead:
1. `candidate_transactions` contains versions [110, 200)
2. Hash indices for versions [110, 200) are deleted
3. Transaction records for versions [100, 200) are deleted 
4. Progress marker updated to version 200

**Result**: Versions [100, 110) have:
- Transaction records deleted ✗
- Hash indices still present ✓

When users query by hash: [6](#0-5) 

The flow becomes:
1. `get_transaction_version_by_hash()` succeeds, returns version (e.g., 105)
2. `get_transaction_with_proof()` called with version 105: [7](#0-6) 
3. Line 1085: `get_transaction(version)` **fails** - transaction was pruned
4. API returns error despite hash index claiming transaction exists

## Impact Explanation

**Severity: Medium** (State inconsistencies requiring intervention per Aptos Bug Bounty)

This breaks the **State Consistency** invariant:
- Creates permanent database inconsistencies between hash indices and transaction records
- Causes API failures when querying transactions by hash
- No detection mechanism exists - the inconsistency persists silently
- Requires manual database intervention to resolve
- Affects node reliability and API availability

While database corruption from hardware failure is the triggering event (not directly attacker-controlled), the **lack of defensive validation** allows the corruption to propagate into permanent, undetected inconsistencies. The codebase demonstrates awareness of this risk by using `ExpectContinuousVersions` elsewhere, making its absence in the pruning path a security-relevant defensive programming failure.

## Likelihood Explanation

**Likelihood: Low-Medium**

While database corruption from hardware failures is relatively rare due to RocksDB's integrity checks, it can occur through:
- Disk hardware failures bypassing checksums
- Memory corruption before data is written
- Bugs in RocksDB's seek implementation
- File system corruption
- SSTable corruption affecting index structures

The lack of validation means that **any** corruption affecting seek positioning will create persistent database inconsistencies without detection. The impact is amplified because pruning is an irreversible operation.

## Recommendation

Add defensive validation using the existing `ExpectContinuousVersions` infrastructure:

```rust
fn get_pruning_candidate_transactions(
    &self,
    start: Version,
    end: Version,
) -> Result<Vec<(Version, Transaction)>> {
    ensure!(end >= start, "{} must be >= {}", end, start);

    let mut iter = self
        .ledger_db
        .transaction_db_raw()
        .iter::<TransactionSchema>()?;
    iter.seek(&start)?;
    
    // Use expect_continuous_versions to validate seek positioned correctly
    let validated_iter = iter.expect_continuous_versions(start, (end - start) as usize)?;
    
    let mut txns = Vec::new();
    for txn in validated_iter {
        let txn = txn?;
        txns.push(txn);
    }

    Ok(txns.into_iter().enumerate().map(|(i, txn)| (start + i as u64, txn)).collect())
}
```

This ensures that:
1. The first transaction has version == start (validates seek correctness)
2. All subsequent transactions are continuous
3. Any corruption causing seek to position incorrectly is detected immediately
4. The function fails safely rather than creating silent inconsistencies

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::transaction::Transaction;
    
    #[test]
    fn test_seek_corruption_detection() {
        // Simulate scenario where database corruption causes seek to position at wrong version
        // 
        // Setup:
        // 1. Create database with transactions at versions [100, 200)
        // 2. Manually corrupt database index to make seek(100) position at 110
        // 3. Call get_pruning_candidate_transactions(100, 200)
        // 
        // Expected behavior WITHOUT fix:
        // - Returns transactions [110, 200) without error
        // - Pruning proceeds with mismatched deletions
        // - Database becomes inconsistent
        //
        // Expected behavior WITH fix (using expect_continuous_versions):
        // - Detects that first transaction has version 110, not 100
        // - Returns error: "iterator: first version 100, expecting version 100, got 110"
        // - Pruning aborts safely
        //
        // This test would require database corruption simulation which is
        // difficult to achieve reliably in a unit test. A manual test using
        // a corrupted RocksDB instance would be needed to fully demonstrate.
    }
}
```

**Notes:**
While this vulnerability requires database corruption to trigger (not directly attacker-controlled), it represents a critical defensive programming failure. The codebase already implements the necessary validation mechanism (`ExpectContinuousVersions`) and uses it elsewhere for transaction iteration, but inexplicably omits it from the pruning path where data loss is irreversible. This creates an undetected failure mode where hardware corruption leads to permanent database inconsistencies rather than detectable errors.

### Citations

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L37-74)
```rust
    fn prune(&self, current_progress: Version, target_version: Version) -> Result<()> {
        let mut batch = SchemaBatch::new();
        let candidate_transactions =
            self.get_pruning_candidate_transactions(current_progress, target_version)?;
        self.ledger_db
            .transaction_db()
            .prune_transaction_by_hash_indices(
                candidate_transactions.iter().map(|(_, txn)| txn.hash()),
                &mut batch,
            )?;
        self.ledger_db.transaction_db().prune_transactions(
            current_progress,
            target_version,
            &mut batch,
        )?;
        self.transaction_store
            .prune_transaction_summaries_by_account(&candidate_transactions, &mut batch)?;
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::TransactionPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;
        if let Some(indexer_db) = self.internal_indexer_db.as_ref() {
            if indexer_db.transaction_enabled() {
                let mut index_batch = SchemaBatch::new();
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut index_batch)?;
                index_batch.put::<InternalIndexerMetadataSchema>(
                    &IndexerMetadataKey::TransactionPrunerProgress,
                    &IndexerMetadataValue::Version(target_version),
                )?;
                indexer_db.get_inner_db_ref().write_schemas(index_batch)?;
            } else {
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut batch)?;
            }
        }
        self.ledger_db.transaction_db().write_schemas(batch)
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L106-131)
```rust
    fn get_pruning_candidate_transactions(
        &self,
        start: Version,
        end: Version,
    ) -> Result<Vec<(Version, Transaction)>> {
        ensure!(end >= start, "{} must be >= {}", end, start);

        let mut iter = self
            .ledger_db
            .transaction_db_raw()
            .iter::<TransactionSchema>()?;
        iter.seek(&start)?;

        // The capacity is capped by the max number of txns we prune in a single batch. It's a
        // relatively small number set in the config, so it won't cause high memory usage here.
        let mut txns = Vec::with_capacity((end - start) as usize);
        for item in iter {
            let (version, txn) = item?;
            if version >= end {
                break;
            }
            txns.push((version, txn));
        }

        Ok(txns)
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L63-71)
```rust
    pub(crate) fn get_transaction_iter(
        &self,
        start_version: Version,
        num_transactions: usize,
    ) -> Result<impl Iterator<Item = Result<Transaction>> + '_> {
        let mut iter = self.db.iter::<TransactionSchema>()?;
        iter.seek(&start_version)?;
        iter.expect_continuous_versions(start_version, num_transactions)
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L169-179)
```rust
    pub(crate) fn prune_transactions(
        &self,
        begin: Version,
        end: Version,
        db_batch: &mut SchemaBatch,
    ) -> Result<()> {
        for version in begin..end {
            db_batch.delete::<TransactionSchema>(&version)?;
        }
        Ok(())
    }
```

**File:** storage/aptosdb/src/utils/iterators.rs (L40-62)
```rust
    fn next_impl(&mut self) -> Result<Option<T>> {
        if self.expected_next_version >= self.end_version {
            return Ok(None);
        }

        let ret = match self.inner.next().transpose()? {
            Some((version, transaction)) => {
                ensure!(
                    version == self.expected_next_version,
                    "{} iterator: first version {}, expecting version {}, got {} from underlying iterator.",
                    std::any::type_name::<T>(),
                    self.first_version,
                    self.expected_next_version,
                    version,
                );
                self.expected_next_version += 1;
                Some(transaction)
            },
            None => None,
        };

        Ok(ret)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L232-245)
```rust
    fn get_transaction_by_hash(
        &self,
        hash: HashValue,
        ledger_version: Version,
        fetch_events: bool,
    ) -> Result<Option<TransactionWithProof>> {
        gauged_api("get_transaction_by_hash", || {
            self.ledger_db
                .transaction_db()
                .get_transaction_version_by_hash(&hash, ledger_version)?
                .map(|v| self.get_transaction_with_proof(v, ledger_version, fetch_events))
                .transpose()
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L1068-1095)
```rust
    pub(super) fn get_transaction_with_proof(
        &self,
        version: Version,
        ledger_version: Version,
        fetch_events: bool,
    ) -> Result<TransactionWithProof> {
        self.error_if_ledger_pruned("Transaction", version)?;

        let proof = self
            .ledger_db
            .transaction_info_db()
            .get_transaction_info_with_proof(
                version,
                ledger_version,
                self.ledger_db.transaction_accumulator_db(),
            )?;

        let transaction = self.ledger_db.transaction_db().get_transaction(version)?;

        // If events were requested, also fetch those.
        let events = if fetch_events {
            Some(self.ledger_db.event_db().get_events_by_version(version)?)
        } else {
            None
        };

        Ok(TransactionWithProof {
            version,
```
