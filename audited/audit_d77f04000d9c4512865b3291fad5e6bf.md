# Audit Report

## Title
Cost-Free Computation in Cryptographic Algebra Deserialization Native Functions

## Summary
Native functions in the cryptographic algebra module perform vector allocation, copying, and byte reversal operations before charging gas, allowing attackers to obtain free computation by repeatedly calling deserialization functions with MSB-formatted inputs.

## Finding Description
The `deserialize_internal` native function in [1](#0-0)  handles deserialization of cryptographic structures. For MSB (Most Significant Byte) formatted inputs, the implementation performs expensive preprocessing operations before gas is charged.

Specifically, for formats like `BLS12381FrMsb`, `BN254FrMsb`, and `BN254FqMsb`, the code:

1. Performs a size validation check [2](#0-1) 
2. Allocates a new vector and copies all input bytes [3](#0-2) 
3. Reverses the byte order in-place [4](#0-3) 
4. THEN charges gas via the `ark_deserialize_internal!` macro [5](#0-4) 

The Move VM's interpreter calls native functions after only a no-op upfront charge [6](#0-5) , meaning the preprocessing work is entirely free if the native function returns an error via `PartialVMError`.

The native function interface design explicitly allows returning `Err(PartialVMError)` without charging gas for "invariant violations" [7](#0-6) , and the interpreter propagates these errors immediately without additional charging [8](#0-7) .

An attacker can craft a transaction that calls `crypto_algebra::deserialize<S, F>()` [9](#0-8)  in a tight loop with malformed data that passes size checks but fails deserialization, obtaining free memory allocation, copying, and byte manipulation operations.

## Impact Explanation
This issue breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits." The vulnerability allows gas metering bypass, qualifying as **Low to Medium Severity** under Aptos bug bounty criteria:

- **Not Critical/High**: Does not cause loss of funds, consensus violations, or validator node crashes
- **Medium Severity Justification**: Represents a gas metering discrepancy allowing limited free computation, though the per-operation impact is small (32-byte vector operations)
- **Practical Impact**: While individual operations are cheap, in aggregate across many transactions this could slightly increase validator computational load without corresponding gas payment

However, the actual exploitability is limited because:
- Attackers still pay gas for loop iterations and function call overhead
- The free operations (32-byte allocation/copy/reverse) are computationally inexpensive
- Transaction gas limits bound total exploitation per transaction

## Likelihood Explanation
**Likelihood: Low to Medium**

The vulnerability is easily triggered (any user can call the public `deserialize` function), but the economic incentive is minimal:
- Attackers save only ~100-200 gas units per call for 32-byte operations
- Must still pay for all Move bytecode execution (loops, function calls, other operations)
- The gas savings are insufficient to motivate sophisticated exploitation
- More likely to occur accidentally in legitimate use cases than malicious exploitation

## Recommendation
Implement gas charging BEFORE performing any expensive operations in native functions. Specifically:

1. **For MSB deserialization**: Charge a preprocessing cost before vector allocation and reversal
2. **General pattern**: Follow the guidance in `SafeNativeContext` [10](#0-9)  which states "Always remember: first charge gas, then execute!"

**Code fix for `deserialize_internal`:**

```rust
(Some(Structure::BLS12381Fr), Some(SerializationFormat::BLS12381FrMsb)) => {
    if bytes.len() != 32 {
        return Ok(smallvec![Value::bool(false), Value::u64(0)]);
    }
    // Charge for preprocessing BEFORE doing the work
    context.charge(ALGEBRA_ARK_BLS12_381_FR_DESER_PREPROCESSING)?;
    let mut bytes_copy: Vec<u8> = bytes.to_vec();
    bytes_copy.reverse();
    let bytes = bytes_copy.as_slice();
    ark_deserialize_internal!(...)
}
```

Add preprocessing gas parameters to the gas schedule for all MSB deserialization operations.

## Proof of Concept

```move
module attacker::exploit {
    use aptos_std::crypto_algebra;
    use aptos_std::bls12381_algebra::{Fr, FormatFrMsb};
    
    public entry fun exploit_free_computation() {
        // Malformed 32-byte input that will fail deserialization
        let malformed_bytes = vector[0u8; 32];
        
        let i = 0;
        // Call deserialize 10,000 times in a loop
        while (i < 10000) {
            // Each call allocates 32 bytes, copies, and reverses
            // BEFORE charging gas - this work is free!
            let _result = crypto_algebra::deserialize<Fr, FormatFrMsb>(&malformed_bytes);
            i = i + 1;
        };
        
        // Attacker obtains ~320KB of free memory operations
        // Total gas charged: only loop iterations + function call overhead
        // Missing gas: vector allocations + copies + reversals
    }
}
```

**Notes**

While this vulnerability technically exists, its practical impact is limited by:
1. The small size of operations (32 bytes per call)
2. Transaction gas limits bounding total exploitation
3. Attackers still paying for substantial overhead (Move bytecode execution)

The issue represents a design flaw in the gas metering boundary between the VM and native functions, where the "fail fast" pattern inadvertently creates a free computation window. The fix should ensure all computational work is accounted for in gas metering, maintaining the integrity of the gas system across the trust boundary.

### Citations

**File:** aptos-move/framework/src/natives/cryptography/algebra/serialization.rs (L299-299)
```rust
        $context.charge($gas)?;
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/serialization.rs (L336-608)
```rust
pub fn deserialize_internal(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert_eq!(2, ty_args.len());
    let structure_opt = structure_from_ty_arg!(context, &ty_args[0]);
    let format_opt = format_from_ty_arg!(context, &ty_args[1]);
    abort_unless_serialization_format_enabled!(context, format_opt);
    let vector_ref = safely_pop_arg!(args, VectorRef);
    let bytes_ref = vector_ref.as_bytes_ref();
    let bytes = bytes_ref.as_slice();
    match (structure_opt, format_opt) {
        (Some(Structure::BLS12381Fr), Some(SerializationFormat::BLS12381FrLsb)) => {
            // Valid BLS12381FrLsb serialization should be 32-byte.
            // NOTE: Arkworks deserialization cost grows as the input size grows.
            // So exit early if the size is incorrect, for gas safety. (Also applied to other cases across this file.)
            if bytes.len() != 32 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_deserialize_internal!(
                context,
                bytes,
                ark_bls12_381::Fr,
                deserialize_uncompressed,
                ALGEBRA_ARK_BLS12_381_FR_DESER
            )
        },
        (Some(Structure::BLS12381Fr), Some(SerializationFormat::BLS12381FrMsb)) => {
            // Valid BLS12381FrMsb serialization should be 32-byte.
            if bytes.len() != 32 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            let mut bytes_copy: Vec<u8> = bytes.to_vec();
            bytes_copy.reverse();
            let bytes = bytes_copy.as_slice();
            ark_deserialize_internal!(
                context,
                bytes,
                ark_bls12_381::Fr,
                deserialize_uncompressed,
                ALGEBRA_ARK_BLS12_381_FR_DESER
            )
        },
        (Some(Structure::BLS12381Fq12), Some(SerializationFormat::BLS12381Fq12LscLsb)) => {
            // Valid BLS12381Fq12LscLsb serialization should be 576-byte.
            if bytes.len() != 576 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_deserialize_internal!(
                context,
                bytes,
                ark_bls12_381::Fq12,
                deserialize_uncompressed,
                ALGEBRA_ARK_BLS12_381_FQ12_DESER
            )
        },
        (Some(Structure::BLS12381G1), Some(SerializationFormat::BLS12381G1Uncompressed)) => {
            // Valid BLS12381G1AffineUncompressed serialization should be 96-byte.
            if bytes.len() != 96 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_ec_point_deserialize_internal!(
                context,
                bytes,
                ark_bls12_381::G1Affine,
                deserialize_uncompressed,
                ALGEBRA_ARK_BLS12_381_G1_AFFINE_DESER_UNCOMP
            )
        },
        (Some(Structure::BLS12381G1), Some(SerializationFormat::BLS12381G1Compressed)) => {
            // Valid BLS12381G1AffineCompressed serialization should be 48-byte.
            if bytes.len() != 48 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_ec_point_deserialize_internal!(
                context,
                bytes,
                ark_bls12_381::G1Affine,
                deserialize_compressed,
                ALGEBRA_ARK_BLS12_381_G1_AFFINE_DESER_COMP
            )
        },
        (Some(Structure::BLS12381G2), Some(SerializationFormat::BLS12381G2Uncompressed)) => {
            // Valid BLS12381G2AffineUncompressed serialization should be 192-byte.
            if bytes.len() != 192 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_ec_point_deserialize_internal!(
                context,
                bytes,
                ark_bls12_381::G2Affine,
                deserialize_uncompressed,
                ALGEBRA_ARK_BLS12_381_G2_AFFINE_DESER_UNCOMP
            )
        },
        (Some(Structure::BLS12381G2), Some(SerializationFormat::BLS12381G2Compressed)) => {
            // Valid BLS12381G2AffineCompressed serialization should be 96-byte.
            if bytes.len() != 96 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_ec_point_deserialize_internal!(
                context,
                bytes,
                ark_bls12_381::G2Affine,
                deserialize_compressed,
                ALGEBRA_ARK_BLS12_381_G2_AFFINE_DESER_COMP
            )
        },
        (Some(Structure::BLS12381Gt), Some(SerializationFormat::BLS12381Gt)) => {
            // Valid BLS12381Gt serialization should be 576-byte.
            if bytes.len() != 576 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            context.charge(ALGEBRA_ARK_BLS12_381_FQ12_DESER)?;
            match <ark_bls12_381::Fq12>::deserialize_uncompressed(bytes) {
                Ok(element) => {
                    context.charge(
                        ALGEBRA_ARK_BLS12_381_FQ12_POW_U256 + ALGEBRA_ARK_BLS12_381_FQ12_EQ,
                    )?;
                    if element.pow(BLS12381_R_SCALAR.0) == ark_bls12_381::Fq12::one() {
                        let handle = store_element!(context, element)?;
                        Ok(smallvec![Value::bool(true), Value::u64(handle as u64)])
                    } else {
                        Ok(smallvec![Value::bool(false), Value::u64(0)])
                    }
                },
                _ => Ok(smallvec![Value::bool(false), Value::u64(0)]),
            }
        },
        (Some(Structure::BN254Fr), Some(SerializationFormat::BN254FrLsb)) => {
            if bytes.len() != 32 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_deserialize_internal!(
                context,
                bytes,
                ark_bn254::Fr,
                deserialize_uncompressed,
                ALGEBRA_ARK_BN254_FR_DESER
            )
        },
        (Some(Structure::BN254Fr), Some(SerializationFormat::BN254FrMsb)) => {
            if bytes.len() != 32 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            let mut bytes_copy: Vec<u8> = bytes.to_vec();
            bytes_copy.reverse();
            let bytes = bytes_copy.as_slice();
            ark_deserialize_internal!(
                context,
                bytes,
                ark_bn254::Fr,
                deserialize_uncompressed,
                ALGEBRA_ARK_BN254_FR_DESER
            )
        },
        (Some(Structure::BN254Fq), Some(SerializationFormat::BN254FqLsb)) => {
            if bytes.len() != 32 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_deserialize_internal!(
                context,
                bytes,
                ark_bn254::Fq,
                deserialize_uncompressed,
                ALGEBRA_ARK_BN254_FQ_DESER
            )
        },
        (Some(Structure::BN254Fq), Some(SerializationFormat::BN254FqMsb)) => {
            if bytes.len() != 32 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            let mut bytes_copy: Vec<u8> = bytes.to_vec();
            bytes_copy.reverse();
            let bytes = bytes_copy.as_slice();
            ark_deserialize_internal!(
                context,
                bytes,
                ark_bn254::Fq,
                deserialize_uncompressed,
                ALGEBRA_ARK_BN254_FQ_DESER
            )
        },
        (Some(Structure::BN254Fq12), Some(SerializationFormat::BN254Fq12LscLsb)) => {
            // Valid BN254Fq12LscLsb serialization should be 32*12 = 64-byte.
            if bytes.len() != 384 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_deserialize_internal!(
                context,
                bytes,
                ark_bn254::Fq12,
                deserialize_uncompressed,
                ALGEBRA_ARK_BN254_FQ12_DESER
            )
        },
        (Some(Structure::BN254G1), Some(SerializationFormat::BN254G1Uncompressed)) => {
            // Valid BN254G1AffineUncompressed serialization should be 64-byte.
            if bytes.len() != 64 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_ec_point_deserialize_internal!(
                context,
                bytes,
                ark_bn254::G1Affine,
                deserialize_uncompressed,
                ALGEBRA_ARK_BN254_G1_AFFINE_DESER_UNCOMP
            )
        },
        (Some(Structure::BN254G1), Some(SerializationFormat::BN254G1Compressed)) => {
            // Valid BN254G1AffineCompressed serialization should be 32-byte.
            if bytes.len() != 32 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_ec_point_deserialize_internal!(
                context,
                bytes,
                ark_bn254::G1Affine,
                deserialize_compressed,
                ALGEBRA_ARK_BN254_G1_AFFINE_DESER_COMP
            )
        },
        (Some(Structure::BN254G2), Some(SerializationFormat::BN254G2Uncompressed)) => {
            // Valid BN254G2AffineUncompressed serialization should be 128-byte.
            if bytes.len() != 128 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_ec_point_deserialize_internal!(
                context,
                bytes,
                ark_bn254::G2Affine,
                deserialize_uncompressed,
                ALGEBRA_ARK_BN254_G2_AFFINE_DESER_UNCOMP
            )
        },
        (Some(Structure::BN254G2), Some(SerializationFormat::BN254G2Compressed)) => {
            // Valid BN254G2AffineCompressed serialization should be 64-byte.
            if bytes.len() != 64 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_ec_point_deserialize_internal!(
                context,
                bytes,
                ark_bn254::G2Affine,
                deserialize_compressed,
                ALGEBRA_ARK_BN254_G2_AFFINE_DESER_COMP
            )
        },
        (Some(Structure::BN254Gt), Some(SerializationFormat::BN254Gt)) => {
            // Valid BN254Gt serialization should be 32*12=384-byte.
            if bytes.len() != 384 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            context.charge(ALGEBRA_ARK_BN254_FQ12_DESER)?;
            match <ark_bn254::Fq12>::deserialize_uncompressed(bytes) {
                Ok(element) => {
                    context.charge(ALGEBRA_ARK_BN254_FQ12_POW_U256 + ALGEBRA_ARK_BN254_FQ12_EQ)?;
                    if element.pow(BN254_R_SCALAR.0) == ark_bn254::Fq12::one() {
                        let handle = store_element!(context, element)?;
                        Ok(smallvec![Value::bool(true), Value::u64(handle as u64)])
                    } else {
                        Ok(smallvec![Value::bool(false), Value::u64(0)])
                    }
                },
                _ => Ok(smallvec![Value::bool(false), Value::u64(0)]),
            }
        },
        _ => Err(SafeNativeError::Abort {
            abort_code: MOVE_ABORT_CODE_NOT_IMPLEMENTED,
        }),
    }
}
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L208-214)
```rust
    fn charge_native_function_before_execution(
        &mut self,
        _ty_args: impl ExactSizeIterator<Item = impl TypeView>,
        _args: impl ExactSizeIterator<Item = impl ValueView>,
    ) -> PartialVMResult<()> {
        Ok(())
    }
```

**File:** third_party/move/move-vm/types/src/natives/function.rs (L31-34)
```rust
/// when an error condition is met that should not charge for the execution. A common example
/// is a VM invariant violation which should have been forbidden by the verifier.
/// Errors (typically user errors and aborts) that are logically part of the function execution
/// must be expressed in a `NativeResult` with a cost and a VMStatus.
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1106-1106)
```rust
        let result = native_function(&mut native_context, ty_args, args)?;
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/crypto_algebra.move (L210-218)
```text
    public fun deserialize<S, F>(bytes: &vector<u8>): Option<Element<S>> {
        abort_unless_cryptography_algebra_natives_enabled();
        let (succeeded, handle) = deserialize_internal<S, F>(bytes);
        if (succeeded) {
            some(Element<S> { handle })
        } else {
            none()
        }
    }
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L69-72)
```rust
    /// Always remember: first charge gas, then execute!
    ///
    /// In other words, this function **MUST** always be called **BEFORE** executing **any**
    /// gas-metered operation or library call within a native function.
```
