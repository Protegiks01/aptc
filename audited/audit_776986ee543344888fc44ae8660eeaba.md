# Audit Report

## Title
Peer Monitoring Service Error Response Size Validation Bypass Enables Memory Exhaustion DoS

## Summary
The peer monitoring service client fails to validate the size of error responses from remote peers, allowing malicious peers to send error payloads up to ~60 MB instead of the intended 100 KB limit. This bypasses the `max_num_response_bytes` validation that only applies to successful responses, enabling memory exhaustion denial-of-service attacks against validator nodes.

## Finding Description

The peer monitoring service implements a response size validation mechanism to prevent malicious peers from sending oversized responses. However, this validation contains a critical bypass: it only checks successful responses, not error responses. [1](#0-0) 

The error path at lines 126-131 returns early without calling `sanity_check_response_size`, while successful responses are validated at lines 135-142. The size validation function itself is properly implemented: [2](#0-1) 

The configuration sets the intended maximum response size to 100 KB: [3](#0-2) 

However, error responses can be as large as the network's `MAX_APPLICATION_MESSAGE_SIZE` (~60 MB): [4](#0-3) 

**Attack Flow:**

1. Malicious peer acts as a peer monitoring service server
2. Victim node sends monitoring requests (latency ping, network info, node info)
3. Malicious server responds with crafted `PeerMonitoringServiceError` containing a String field of ~60 MB
4. The error is serialized and sent over the network using BCS: [5](#0-4) 

5. The error type conversion creates the large string payload: [6](#0-5) 

6. The victim deserializes the error using BCS with only recursion depth limits (64), not size limits: [7](#0-6) 

7. The error is logged, which involves string operations on the 60 MB payload: [8](#0-7) 

With `max_concurrent_requests` defaulting to 1000: [9](#0-8) 

A malicious peer can trigger allocation of up to **60 GB** of memory (1000 requests × 60 MB per error), causing validator node memory exhaustion.

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: Memory exhaustion from processing 60 MB error strings causes significant performance degradation
- **DoS attack vector**: Multiple malicious peers can coordinate to amplify the attack across multiple victim nodes
- **Protocol violation**: The 600x bypass of intended size limits (60 MB vs 100 KB) violates the resource limits invariant

The attack does not require validator privileges—any network peer can exploit this. The impact is bounded by network-level limits rather than application-level validation, which represents a significant defense-in-depth failure.

## Likelihood Explanation

**Likelihood: High**

- **Low attacker requirements**: Any node can act as a malicious peer monitoring service server
- **Easy exploitation**: Simply respond to legitimate requests with oversized errors
- **Common attack surface**: Peer monitoring runs continuously on all validator nodes
- **No authentication bypass needed**: The vulnerability is in legitimate error handling logic
- **Multiple attack vectors**: Can be triggered via latency ping, network info, or node info requests

## Recommendation

Apply size validation to error responses, not just successful responses. Modify the error handling path to validate error size before processing:

```rust
// In peer-monitoring-service/client/src/peer_states/peer_state.rs
// Around line 123-131, modify the error handling:

// Process any response errors
let monitoring_service_response = match monitoring_service_response {
    Ok(monitoring_service_response) => monitoring_service_response,
    Err(error) => {
        // Validate error size before processing
        if let Err(size_error) = validate_error_size(max_num_response_bytes, &error) {
            peer_state_value
                .write()
                .handle_monitoring_service_response_error(&peer_network_id, size_error);
            return;
        }
        
        peer_state_value
            .write()
            .handle_monitoring_service_response_error(&peer_network_id, error);
        return;
    },
};

// Add validation function:
fn validate_error_size(
    max_num_response_bytes: u64,
    error: &Error,
) -> Result<(), Error> {
    // Estimate error size by serializing it
    let error_bytes = match error {
        Error::PeerMonitoringServiceError(e) => {
            bcs::to_bytes(e).map_err(|_| 
                Error::UnexpectedError("Failed to serialize error".to_string())
            )?
        },
        _ => return Ok(()), // Only check PeerMonitoringServiceError
    };
    
    if error_bytes.len() as u64 > max_num_response_bytes {
        return Err(Error::UnexpectedError(format!(
            "Error response too large: {} bytes (max: {})",
            error_bytes.len(),
            max_num_response_bytes
        )));
    }
    
    Ok(())
}
```

## Proof of Concept

```rust
// Add to peer-monitoring-service/client/src/tests/
#[tokio::test]
async fn test_oversized_error_response_dos() {
    use aptos_peer_monitoring_service_types::{
        PeerMonitoringServiceError,
        PeerMonitoringServiceMessage,
    };
    
    // Create a very large error string (50 MB)
    let large_error_string = "X".repeat(50 * 1024 * 1024);
    let malicious_error = PeerMonitoringServiceError::InternalError(
        large_error_string
    );
    
    // Serialize the error response
    let error_response = PeerMonitoringServiceMessage::Response(
        Err(malicious_error)
    );
    let serialized = bcs::to_bytes(&error_response).unwrap();
    
    // Verify the payload is indeed oversized (> 100 KB limit)
    assert!(serialized.len() > 100 * 1024);
    println!("Malicious error payload size: {} MB", 
        serialized.len() / (1024 * 1024));
    
    // Deserialize - this succeeds, bypassing the 100 KB limit
    let deserialized: PeerMonitoringServiceMessage = 
        bcs::from_bytes(&serialized).unwrap();
    
    // This demonstrates the vulnerability: oversized errors 
    // can be deserialized without size validation
    match deserialized {
        PeerMonitoringServiceMessage::Response(Err(e)) => {
            match e {
                PeerMonitoringServiceError::InternalError(s) => {
                    assert_eq!(s.len(), 50 * 1024 * 1024);
                    println!("ERROR: Deserialized {} MB error without size check", 
                        s.len() / (1024 * 1024));
                },
                _ => panic!("Wrong error type"),
            }
        },
        _ => panic!("Wrong message type"),
    }
}
```

**Notes:**
- The vulnerability specifically affects the peer monitoring service client's error handling logic
- While BCS recursion limits (64 depth) prevent stack overflow, they don't limit string lengths
- The network layer's `MAX_APPLICATION_MESSAGE_SIZE` (~60 MB) is the only bound, which is 600x larger than the intended 100 KB limit
- The issue breaks the Resource Limits invariant: "All operations must respect gas, storage, and computational limits"
- This is not a cryptographic or consensus issue, but a resource exhaustion DoS vulnerability in the networking layer

### Citations

**File:** peer-monitoring-service/client/src/peer_states/peer_state.rs (L123-142)
```rust
            // Process any response errors
            let monitoring_service_response = match monitoring_service_response {
                Ok(monitoring_service_response) => monitoring_service_response,
                Err(error) => {
                    peer_state_value
                        .write()
                        .handle_monitoring_service_response_error(&peer_network_id, error);
                    return;
                },
            };

            // Verify the response respects the message size limits
            if let Err(error) =
                sanity_check_response_size(max_num_response_bytes, &monitoring_service_response)
            {
                peer_state_value
                    .write()
                    .handle_monitoring_service_response_error(&peer_network_id, error);
                return;
            }
```

**File:** peer-monitoring-service/client/src/peer_states/peer_state.rs (L313-330)
```rust
fn sanity_check_response_size(
    max_num_response_bytes: u64,
    monitoring_service_response: &PeerMonitoringServiceResponse,
) -> Result<(), Error> {
    // Calculate the number of bytes in the response
    let num_response_bytes = monitoring_service_response.get_num_bytes()?;

    // Verify the response respects the max message sizes
    if num_response_bytes > max_num_response_bytes {
        return Err(Error::UnexpectedError(format!(
            "The monitoring service response ({:?}) is too large: {:?}. Maximum allowed: {:?}",
            monitoring_service_response.get_label(),
            num_response_bytes,
            max_num_response_bytes
        )));
    }

    Ok(())
```

**File:** config/src/config/peer_monitoring_config.rs (L28-28)
```rust
            max_num_response_bytes: 100 * 1024, // 100 KB
```

**File:** config/src/config/network_config.rs (L47-50)
```rust
pub const MAX_APPLICATION_MESSAGE_SIZE: usize =
    (MAX_MESSAGE_SIZE - MAX_MESSAGE_METADATA_SIZE) - MESSAGE_PADDING_SIZE; /* The message size that applications should check against */
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** peer-monitoring-service/server/src/network.rs (L106-112)
```rust
    pub fn send(self, response: Result<PeerMonitoringServiceResponse>) {
        let msg = PeerMonitoringServiceMessage::Response(response);
        let result = bcs::to_bytes(&msg)
            .map(Bytes::from)
            .map_err(RpcError::BcsError);
        let _ = self.response_tx.send(result);
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L66-68)
```rust
        let bounded_executor = BoundedExecutor::new(
            node_config.peer_monitoring_service.max_concurrent_requests as usize,
            executor,
```

**File:** peer-monitoring-service/server/src/lib.rs (L198-203)
```rust
                match error {
                    Error::InvalidRequest(error) => {
                        Err(PeerMonitoringServiceError::InvalidRequest(error))
                    },
                    error => Err(PeerMonitoringServiceError::InternalError(error.to_string())),
                }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L226-252)
```rust
    pub fn from_bytes<T: DeserializeOwned>(&self, bytes: &[u8]) -> anyhow::Result<T> {
        // Start the deserialization timer
        let deserialization_timer = start_serialization_timer(*self, DESERIALIZATION_LABEL);

        // Deserialize the message
        let result = match self.encoding() {
            Encoding::Bcs(limit) => self.bcs_decode(bytes, limit),
            Encoding::CompressedBcs(limit) => {
                let compression_client = self.get_compression_client();
                let raw_bytes = aptos_compression::decompress(
                    &bytes.to_vec(),
                    compression_client,
                    MAX_APPLICATION_MESSAGE_SIZE,
                )
                .map_err(|e| anyhow! {"{:?}", e})?;
                self.bcs_decode(&raw_bytes, limit)
            },
            Encoding::Json => serde_json::from_slice(bytes).map_err(|e| anyhow!("{:?}", e)),
        };

        // Only record the duration if deserialization was successful
        if result.is_ok() {
            deserialization_timer.observe_duration();
        }

        result
    }
```

**File:** peer-monitoring-service/client/src/peer_states/latency_info.rs (L197-211)
```rust
    fn handle_monitoring_service_response_error(
        &mut self,
        peer_network_id: &PeerNetworkId,
        error: Error,
    ) {
        // Handle the failure
        self.handle_request_failure(peer_network_id);

        // Log the error
        warn!(LogSchema::new(LogEntry::LatencyPing)
            .event(LogEvent::ResponseError)
            .message("Error encountered when pinging peer!")
            .peer(peer_network_id)
            .error(&error));
    }
```
