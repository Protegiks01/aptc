# Audit Report

## Title
Man-in-the-Middle Attack in Move Package Version Resolution Due to Missing HTTPS Enforcement

## Summary
The `resolve_network_version()` function in the Move package resolver accepts arbitrary HTTP URLs without enforcing HTTPS, enabling MITM attackers to provide fake ledger version numbers that get locked in package manifests. This supply chain vulnerability allows attackers to manipulate package dependency resolution during Move module compilation.

## Finding Description

The Move package resolver uses `resolve_network_version()` to query Aptos fullnode APIs and lock the current ledger version for reproducible builds. However, the implementation has critical security flaws:

**1. No HTTPS Enforcement:** [1](#0-0) 

The function accepts any `Url` without validating the scheme. It creates an `aptos_rest_client::Client` with the provided URL and queries the ledger information.

**2. Scheme Ignored in URL Canonicalization:** [2](#0-1) 

The `CanonicalNodeIdentity` explicitly ignores the URL scheme (comment: "Ignores the scheme") and treats HTTP and HTTPS URLs equivalently.

**3. URL Source - User-Provided in Package Manifest:** [3](#0-2) 

The `node_url` field in dependencies is a raw string with no validation. [4](#0-3) 

The URL from the manifest is converted using `Url::from_str()` without scheme validation before being passed to `resolve_network_version()`.

**4. TLS Verification Only Applies to HTTPS:** [5](#0-4) 

While reqwest has default TLS certificate verification enabled, this only protects HTTPS connections. HTTP requests are sent in plaintext without any protection.

**Attack Path:**
1. Attacker operates a malicious HTTP endpoint at `http://attacker.com:8080`
2. Developer adds Aptos dependency in `Move.toml`: `{ aptos = "http://attacker.com:8080", address = "0x1" }`
3. Developer runs `aptos move compile`
4. Package resolver calls `resolve_network_version(http://attacker.com:8080)`
5. MITM attacker intercepts plaintext HTTP request
6. Attacker returns fake version number (e.g., version 999999999)
7. Fake version locked in `Move.lock`: `on_chain."attacker.com:8080" = 999999999`
8. Subsequent `fetch_on_chain_package()` calls use this fake version, potentially fetching non-existent or malicious package data

## Impact Explanation

This vulnerability enables supply chain attacks on Move package dependencies. While primarily affecting the development toolchain rather than runtime consensus, it can indirectly lead to on-chain security issues:

- **Malicious Package Injection**: Attackers can force resolution to specific ledger versions containing vulnerable or malicious package versions
- **Dependency Confusion**: Fake version numbers can cause build failures or force developers to use compromised packages
- **Trust Exploitation**: Developers may not realize HTTP URLs are dangerous, assuming the toolchain validates connections

This qualifies as **Medium severity** per the Aptos Bug Bounty program under "Limited funds loss or manipulation" because malicious packages deployed on-chain could steal funds from users, though the attack path is indirect and requires developer error.

## Likelihood Explanation

**Likelihood: Medium**

- Requires developer to use HTTP URL (unlikely but possible for local testing scenarios)
- Requires MITM position (achievable on untrusted networks, compromised DNS, or local network attacks)
- No warning or validation alerts developers to the security risk
- Particularly dangerous in development environments where HTTP endpoints might be used for testing

The attack is feasible because:
1. Move.toml accepts arbitrary URL strings without validation
2. No warnings are issued for HTTP URLs
3. Developers might use HTTP for local fullnodes during development
4. The locked version persists across builds, spreading the compromise

## Recommendation

Implement HTTPS enforcement and certificate validation:

**1. Add scheme validation in CanonicalNodeIdentity:**
```rust
// In canonical.rs
impl CanonicalNodeIdentity {
    pub fn new(node_url: &Url) -> Result<Self> {
        // Enforce HTTPS for security
        if node_url.scheme() != "https" {
            bail!(
                "Node URL must use HTTPS for security. Got: {}. HTTP URLs are vulnerable to MITM attacks.",
                node_url
            );
        }
        
        let host = node_url
            .host_str()
            .ok_or_else(|| anyhow!("invalid node URL, unable to extract host: {}", node_url))?
            .to_ascii_lowercase();
        
        // ... rest of implementation
    }
}
```

**2. Add validation when parsing dependencies:**
```rust
// In resolver.rs
PackageLocation::Aptos {
    node_url,
    package_addr,
} => {
    remote_url = Url::from_str(&node_url)?;
    
    // Validate HTTPS scheme
    if remote_url.scheme() != "https" {
        bail!(
            "Aptos dependencies must use HTTPS node URLs. Got: {}",
            remote_url
        );
    }
    
    // ... rest of implementation
}
```

**3. Document security requirement:**
Add warning in Move.toml documentation and error messages explaining that only HTTPS node URLs should be used to prevent MITM attacks.

## Proof of Concept

**Setup malicious server:**
```rust
// malicious_server.rs
use warp::Filter;

#[tokio::main]
async fn main() {
    let route = warp::path!("v1")
        .map(|| {
            // Return fake ledger information with manipulated version
            warp::reply::json(&serde_json::json!({
                "chain_id": 1,
                "epoch": "1",
                "ledger_version": "999999999",  // Fake version
                "ledger_timestamp": "1234567890",
                "oldest_ledger_version": "0",
                "oldest_block_height": "0",
                "block_height": "999999"
            }))
        });
    
    // Run HTTP server (vulnerable to MITM)
    warp::serve(route).run(([127, 0, 0, 1], 8080)).await;
}
```

**Victim Move.toml:**
```toml
[package]
name = "victim_package"
version = "0.1.0"

[dependencies]
MaliciousDep = { aptos = "http://localhost:8080", address = "0x1" }
```

**Execute attack:**
```bash
# Terminal 1: Run malicious server
cargo run --bin malicious_server

# Terminal 2: MITM can intercept and modify HTTP traffic
# No TLS protection since URL is http://

# Terminal 3: Compile victim package
cd victim_package
aptos move compile

# Result: Move.lock contains:
# [on_chain]
# "localhost:8080" = 999999999  # Locked fake version
```

The fake version 999999999 is now locked and will be used for all future dependency resolution, potentially causing package fetch failures or loading of malicious packages if the attacker controls the specified address.

## Notes

While the `aptos_rest_client` has TLS certificate verification enabled by default (via reqwest with default features), this protection only applies to HTTPS connections. The core vulnerability is the **acceptance of HTTP URLs** without any validation or warning, leaving plaintext communication vulnerable to interception regardless of the client's TLS capabilities.

### Citations

**File:** third_party/move/tools/move-package-resolver/src/lock.rs (L90-106)
```rust
    pub async fn resolve_network_version(&mut self, fullnode_url: &Url) -> Result<u64> {
        let node_identity = CanonicalNodeIdentity::new(fullnode_url)?;

        let res = match self.on_chain.entry(node_identity.to_string()) {
            btree_map::Entry::Occupied(entry) => *entry.get(),
            btree_map::Entry::Vacant(entry) => {
                let client = aptos_rest_client::Client::new(fullnode_url.clone());
                let version = client.get_ledger_information().await?.into_inner().version;

                entry.insert(version);

                version
            },
        };

        Ok(res)
    }
```

**File:** third_party/move/tools/move-package-cache/src/canonical.rs (L82-109)
```rust
/// Canonicalized identity of a node, derived from a [`Url`].
/// - Ignores the scheme
/// - Converts host & path to lowercase
/// - Keeps port, but only if it is non-default
/// - Trims trailing slashes
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct CanonicalNodeIdentity(String);

impl CanonicalNodeIdentity {
    pub fn new(node_url: &Url) -> Result<Self> {
        let host = node_url
            .host_str()
            .ok_or_else(|| anyhow!("invalid node URL, unable to extract host: {}", node_url))?
            .to_ascii_lowercase();

        let port = match node_url.port() {
            Some(port) => match (node_url.scheme(), port) {
                ("http", 80) | ("https", 443) => "".to_string(),
                _ => format!(":{}", port),
            },
            None => "".to_string(),
        };

        let path = node_url.path().to_ascii_lowercase();
        let path = path.trim_end_matches("/");

        Ok(Self(format!("{}{}{}", host, port, path)))
    }
```

**File:** third_party/move/tools/move-package-manifest/src/manifest.rs (L150-156)
```rust
        /// URL to the Aptos full-node connected to the network where the package is published.
        node_url: String,

        /// Address of the published package.
        package_addr: AccountAddress,
    },
}
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L413-428)
```rust
        PackageLocation::Aptos {
            node_url,
            package_addr,
        } => {
            remote_url = Url::from_str(&node_url)?;

            let identity = PackageIdentity {
                name: dep_name.to_string(),
                location: SourceLocation::OnChain {
                    node: CanonicalNodeIdentity::new(&remote_url)?,
                    package_addr,
                },
            };

            (identity, Some(&remote_url))
        },
```

**File:** Cargo.toml (L761-767)
```text
reqwest = { version = "0.11.11", features = [
    "blocking",
    "cookies",
    "json",
    "multipart",
    "stream",
] }
```
