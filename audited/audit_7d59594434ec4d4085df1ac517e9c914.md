# Audit Report

## Title
Resource Exhaustion via Unmetered Storage Reads in Federated Keyless Signature Validation

## Summary
An attacker can cause validator node slowdown by submitting transactions with federated keyless authenticators that reference non-existent or unique `jwk_addr` values. Each transaction triggers up to 3 expensive uncached database reads during mempool validation before gas is charged, allowing resource exhaustion of the storage layer.

## Finding Description

The vulnerability exists in the keyless signature validation flow where federated keyless authenticators trigger expensive storage reads during transaction validation in the mempool, prior to gas metering.

**Attack Flow:**

1. **Transaction Submission to Mempool**: Transactions submitted via API flow to mempool which validates them in parallel. [1](#0-0) 

2. **Validation Calls Keyless Authenticator Check**: During validation, `validate_signed_transaction` extracts keyless authenticators and calls `keyless_validation::validate_authenticators` without passing a gas meter. [2](#0-1) 

3. **Per-Authenticator Storage Reads**: For each federated keyless authenticator, if the JWK is not found in the main registry at `0x1`, the validation attempts to fetch JWKs from the custom `jwk_addr` specified in the authenticator. [3](#0-2) 

4. **Expensive Database I/O**: The `get_federated_jwks_onchain` function calls `get_resource_on_chain_at_addr`. [4](#0-3)  This performs an expensive `get_resource_bytes_with_metadata_and_layout` call that reads from the database. [5](#0-4) 

5. **No Gas Metering**: The `validate_authenticators` function signature shows it does not take a gas meter parameter. [6](#0-5)  This validation happens during mempool validation before gas is charged.

**Attacker Control:**

The attacker controls the `jwk_addr` field in `FederatedKeylessPublicKey`, which is part of the public key structure. [7](#0-6) 

**Attack Parameters:**

Maximum keyless signatures per transaction defaults to 3. [8](#0-7)  This limit is enforced during validation. [9](#0-8) 

**Cache Ineffectiveness:**

The `PooledVMValidator` maintains multiple VM validators, each with its own `CachedModuleView<CachedDbStateView>`. [10](#0-9)  The pool randomly selects validators. [11](#0-10)  Attackers using unique addresses bypass caching since each validator has its own cache and addresses are randomly distributed across validators.

## Impact Explanation

This vulnerability falls under **High Severity** per the Aptos bug bounty program criteria for "Validator Node Slowdowns" - significant performance degradation affecting consensus through DoS via resource exhaustion.

The impact is amplified because:
1. Storage reads for non-existent resources require Jellyfish Merkle tree traversals
2. Parallel validation means multiple expensive reads occur simultaneously
3. No gas is charged for failed validations, making the attack cost-free
4. Each transaction can trigger 3 database reads (max_signatures_per_txn limit)

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely because:

1. **Low barrier to entry**: Attacker only needs ability to submit transactions via public API
2. **No resource cost**: Failed validations don't charge gas
3. **Simple execution**: Creating transactions with custom `jwk_addr` values is straightforward  
4. **Amplification factor**: 3 storage reads per transaction Ã— parallel validation
5. **Feature enabled by default**: The federated keyless feature flag is included in default enabled features. [12](#0-11) 

## Recommendation

Implement rate limiting or gas metering for storage reads during federated keyless validation:

1. **Add gas metering to validation**: Pass a gas meter to `validate_authenticators` and charge for storage reads
2. **Rate limit by jwk_addr**: Track and limit lookups to unique `jwk_addr` values per time window
3. **Cache at pool level**: Use shared cache across all VMValidators to prevent cache bypass
4. **Limit federated lookups**: Consider restricting federated keyless to allowlisted addresses

## Proof of Concept

```rust
// Conceptual PoC - attacker creates multiple transactions:
for i in 0..1000 {
    let unique_jwk_addr = AccountAddress::from_hex_literal(format!("0x{:x}", 0x1000 + i));
    let fed_pk = FederatedKeylessPublicKey {
        jwk_addr: unique_jwk_addr,
        pk: keyless_pk.clone(),
    };
    // Create transaction with 3 federated keyless authenticators
    // Each referencing different unique_jwk_addr values
    // Submit to mempool - triggers 3 uncached database reads per transaction
    // With parallel validation, storage layer is flooded
}
```

Each transaction triggers expensive `get_resource_bytes_with_metadata_and_layout` calls for non-existent resources during mempool validation, overwhelming the storage layer without charging gas.

## Notes

The vulnerability exploits the design of federated keyless authentication where arbitrary `jwk_addr` values can trigger unmetered database lookups during validation. While mempool has capacity limits, validation occurs before these checks, allowing the storage exhaustion to proceed. The federated keyless feature flag check occurs during validation but does not prevent the expensive storage reads for enabled features.

### Citations

**File:** mempool/src/shared_mempool/tasks.rs (L490-503)
```rust
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1798-1811)
```rust
        let keyless_authenticators = aptos_types::keyless::get_authenticators(transaction)
            .map_err(|_| VMStatus::error(StatusCode::INVALID_SIGNATURE, None))?;

        // If there are keyless TXN authenticators, validate them all.
        if !keyless_authenticators.is_empty() && !self.is_simulation {
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
        }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L60-71)
```rust
    let bytes = resolver
        .get_resource_bytes_with_metadata_and_layout(addr, &struct_tag, &module.metadata, None)
        .map_err(|e| e.finish(Location::Undefined).into_vm_status())?
        .0
        .ok_or_else(|| {
            value_deserialization_error!(format!(
                "get_resource failed on {}::{}::{}",
                addr.to_hex_literal(),
                T::struct_tag().module,
                T::struct_tag().name
            ))
        })?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L96-102)
```rust
fn get_federated_jwks_onchain(
    resolver: &impl AptosMoveResolver,
    jwk_addr: &AccountAddress,
    module_storage: &impl ModuleStorage,
) -> anyhow::Result<FederatedJWKs, VMStatus> {
    get_resource_on_chain_at_addr::<FederatedJWKs>(jwk_addr, resolver, module_storage)
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L153-160)
```rust
pub(crate) fn validate_authenticators(
    pvk: Option<&PreparedVerifyingKey<Bn254>>,
    configuration: Option<&Configuration>,
    authenticators: &Vec<(AnyKeylessPublicKey, KeylessSignature)>,
    features: &Features,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> Result<(), VMStatus> {
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L202-205)
```rust
    if authenticators.len() > config.max_signatures_per_txn as usize {
        // println!("[aptos-vm][groth16] Too many keyless authenticators");
        return Err(invalid_signature!("Too many keyless authenticators"));
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L235-260)
```rust
    for (pk, sig) in authenticators {
        // Try looking up the jwk in 0x1.
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
            // 1: If found in 0x1, then we consider that the ground truth & we are done.
            Ok(jwk) => jwk,
            // 2: If not found in 0x1, we check the Keyless PK type.
            Err(e) => {
                match pk {
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
        };
```

**File:** types/src/keyless/mod.rs (L376-379)
```rust
pub struct FederatedKeylessPublicKey {
    pub jwk_addr: AccountAddress,
    pub pk: KeylessPublicKey,
}
```

**File:** types/src/keyless/configuration.rs (L65-65)
```rust
            max_signatures_per_txn: 3,
```

**File:** vm-validator/src/vm_validator.rs (L122-134)
```rust
#[derive(Clone)]
pub struct PooledVMValidator {
    vm_validators: Vec<Arc<Mutex<VMValidator>>>,
}

impl PooledVMValidator {
    pub fn new(db_reader: Arc<dyn DbReader>, pool_size: usize) -> Self {
        let mut vm_validators = Vec::new();
        for _ in 0..pool_size {
            vm_validators.push(Arc::new(Mutex::new(VMValidator::new(db_reader.clone()))));
        }
        PooledVMValidator { vm_validators }
    }
```

**File:** vm-validator/src/vm_validator.rs (L136-140)
```rust
    fn get_next_vm(&self) -> Arc<Mutex<VMValidator>> {
        let mut rng = thread_rng(); // Create a thread-local random number generator
        let random_index = rng.gen_range(0, self.vm_validators.len()); // Generate random index
        self.vm_validators[random_index].clone() // Return the VM at the random index
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L219-219)
```rust
            FeatureFlag::FEDERATED_KEYLESS,
```
