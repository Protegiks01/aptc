# Audit Report

## Title
Indexer Stream Panic on Unknown Transaction Types During Schema Evolution

## Summary
The transaction filter matching logic in the indexer-grpc service contains an unsafe `.expect()` call that panics when encountering unknown transaction types. This causes all active streams using `TransactionRootFilter` to crash mid-execution when the blockchain protocol is upgraded with new transaction types, violating the availability guarantees of the streaming API.

## Finding Description

The vulnerability exists in the `TransactionRootFilter::matches()` method where transaction type validation is performed: [1](#0-0) 

This code uses `.expect()` on a `TryFrom` conversion that can fail when the transaction's `r#type` field contains a value not recognized by the compiled `TransactionType` enum. The `TransactionType` enum is generated from protobuf definitions and currently includes these variants: [2](#0-1) 

**Attack Scenario:**

1. A client establishes a long-running indexer stream with a transaction filter that specifies transaction type filtering (e.g., filtering for `TRANSACTION_TYPE_USER`)
2. The filter is successfully parsed and validated at stream initialization: [3](#0-2) 

3. The Aptos blockchain undergoes a protocol upgrade that introduces a new transaction type (e.g., `TRANSACTION_TYPE_RANDOMNESS = 22` or `TRANSACTION_TYPE_DKG = 24`)
4. The indexer node processes transactions containing this new type value
5. When the filter attempts to match these transactions, the `TransactionType::try_from(item.r#type)` conversion fails because the old compiled code doesn't recognize the new enum value
6. The `.expect("Invalid transaction type")` panics, **crashing the entire stream and disconnecting all clients**

The root cause is that filters are parsed once at stream start but applied throughout the stream's lifetime: [4](#0-3) 

This creates a temporal coupling between the filter validation (at stream start with old schema) and filter application (mid-stream with new schema), breaking the availability guarantee.

## Impact Explanation

**Severity: Medium (API Crashes - up to $10,000 per bug bounty criteria)**

This vulnerability causes:

1. **Denial of Service**: All indexer streams using `TransactionRootFilter` with transaction type filtering crash simultaneously when unknown transaction types are encountered
2. **Service Disruption**: All connected clients are disconnected and must reconnect, causing data gaps and service interruptions
3. **Cascading Failures**: If multiple indexer nodes are affected, the entire indexer infrastructure can become unavailable during protocol upgrades
4. **Data Loss Risk**: Clients may miss transactions during the crash window if they don't properly handle reconnection

While this doesn't affect consensus or core blockchain operations, it violates the availability guarantees of the indexer API, which is classified as "High Severity" under the bug bounty program's "API crashes" category. However, given that it requires a protocol upgrade to trigger and only affects the indexer infrastructure (not consensus), a **Medium severity** classification is appropriate.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability will trigger with **high certainty** whenever:
- A protocol upgrade introduces new transaction types (which has happened in Aptos with the addition of `TRANSACTION_TYPE_VALIDATOR` and `TRANSACTION_TYPE_BLOCK_EPILOGUE`)
- Indexer nodes have not been upgraded to the new protobuf schema before processing transactions with the new types
- Active streams exist with `TransactionRootFilter` that specify transaction type filtering

The likelihood is **not Low** because:
1. Protocol evolution is a planned and expected activity in blockchain networks
2. The codebase shows evidence of transaction type additions (values 5-19 are marked as "skipped for no reason", suggesting room for future types)
3. The DKG/randomness infrastructure suggests potential for new transaction types
4. Deployment timing issues between blockchain nodes and indexer nodes are common

The likelihood is **not Critical** because:
1. It requires a protocol upgrade to trigger
2. Only affects streams using specific filter configurations
3. Can be mitigated by proper deployment sequencing

## Recommendation

Replace the unsafe `.expect()` call with graceful error handling that either:

**Option 1: Skip unknown transaction types**
```rust
fn matches(&self, item: &Transaction) -> bool {
    if !self
        .success
        .matches_opt(&item.info.as_ref().map(|i| i.success))
    {
        return false;
    }

    if let Some(txn_type) = &self.txn_type {
        // Gracefully handle unknown transaction types
        match TransactionType::try_from(item.r#type) {
            Ok(actual_type) => {
                if txn_type != &actual_type {
                    return false;
                }
            },
            Err(_) => {
                // Unknown transaction type - treat as non-match
                return false;
            }
        }
    }

    true
}
```

**Option 2: Add forward compatibility with warning**
```rust
fn matches(&self, item: &Transaction) -> bool {
    if !self
        .success
        .matches_opt(&item.info.as_ref().map(|i| i.success))
    {
        return false;
    }

    if let Some(txn_type) = &self.txn_type {
        match TransactionType::try_from(item.r#type) {
            Ok(actual_type) => {
                if txn_type != &actual_type {
                    return false;
                }
            },
            Err(e) => {
                // Log warning for unknown transaction type but don't crash
                tracing::warn!(
                    "Unknown transaction type {} encountered in filter matching: {:?}",
                    item.r#type,
                    e
                );
                return false;
            }
        }
    }

    true
}
```

**Additional Hardening:**
The same review should be applied to all filter matching code to identify similar unsafe operations. The grep search revealed other `.expect()` and `.unwrap()` calls in filter code that should be audited: [5](#0-4) 

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_protos::transaction::v1::{Transaction, TransactionInfo};

    #[test]
    #[should_panic(expected = "Invalid transaction type")]
    fn test_unknown_transaction_type_causes_panic() {
        // Create a filter that checks transaction type
        let filter = TransactionRootFilterBuilder::default()
            .txn_type(TransactionType::User)
            .build()
            .unwrap();

        // Create a transaction with an unknown type value
        // This simulates a new transaction type added in a protocol upgrade
        let transaction = Transaction {
            r#type: 99, // Unknown transaction type
            info: Some(TransactionInfo {
                success: true,
                ..Default::default()
            }),
            ..Default::default()
        };

        // This will panic with "Invalid transaction type"
        let _ = filter.matches(&transaction);
    }

    #[test]
    fn test_known_transaction_type_works() {
        let filter = TransactionRootFilterBuilder::default()
            .txn_type(TransactionType::User)
            .build()
            .unwrap();

        let transaction = Transaction {
            r#type: TransactionType::User as i32,
            info: Some(TransactionInfo {
                success: true,
                ..Default::default()
            }),
            ..Default::default()
        };

        // This should work fine
        assert!(filter.matches(&transaction));
    }
}
```

To demonstrate the vulnerability in a running system:
1. Start an indexer node with streams active
2. Modify a blockchain node to emit transactions with `type = 99`
3. Observe all streams with `TransactionRootFilter` crash with panic
4. Client connections are terminated abruptly

**Notes**

The vulnerability is specifically tied to the security question about schema evolution and filter lifetime. While protobuf is designed for forward compatibility, the Rust code's use of `.expect()` defeats this safety mechanism. The issue is exacerbated by the fact that:

1. Filters are validated once at stream initialization with the current schema
2. They remain in memory and are applied throughout the stream's lifetime
3. No re-validation or schema version checking occurs during stream execution
4. The panic provides no recovery mechanism - the entire stream process terminates

This represents a violation of the principle that "valid operations should not cause panics in production code" and demonstrates poor schema evolution handling in a distributed system context.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/transaction_root.rs (L67-73)
```rust
        if let Some(txn_type) = &self.txn_type {
            if txn_type
                != &TransactionType::try_from(item.r#type).expect("Invalid transaction type")
            {
                return false;
            }
        }
```

**File:** protos/proto/aptos/transaction/v1/transaction.proto (L47-56)
```text
  enum TransactionType {
    TRANSACTION_TYPE_UNSPECIFIED = 0;
    TRANSACTION_TYPE_GENESIS = 1;
    TRANSACTION_TYPE_BLOCK_METADATA = 2;
    TRANSACTION_TYPE_STATE_CHECKPOINT = 3;
    TRANSACTION_TYPE_USER = 4;
    // values 5-19 skipped for no reason
    TRANSACTION_TYPE_VALIDATOR = 20;
    TRANSACTION_TYPE_BLOCK_EPILOGUE = 21;
  }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/localnet_data_service.rs (L63-71)
```rust
        // Parse transaction filter if present.
        let filter = if let Some(proto_filter) = r.transaction_filter {
            Some(parse_transaction_filter(
                proto_filter,
                self.service_context.max_transaction_filter_size_bytes,
            )?)
        } else {
            None
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L174-182)
```rust
                // Apply filter if present.
                let pb_txns = if let Some(ref filter) = filter {
                    pb_txns
                        .into_iter()
                        .filter(|txn| filter.matches(txn))
                        .collect::<Vec<_>>()
                } else {
                    pb_txns
                };
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L21-21)
```rust
/// let filter = UserTransactionFilterBuilder::default().sender(address).build().unwrap();
```
