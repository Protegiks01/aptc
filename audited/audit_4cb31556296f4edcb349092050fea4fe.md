# Audit Report

## Title
Resource Amplification via Duplicate State Keys in Remote State View Service

## Summary
The `handle_message()` function in `remote_state_view_service.rs` processes all state_keys without deduplication, causing redundant `get_state_value()` calls when duplicates are present. This creates unnecessary resource consumption despite client-side expectations that the server would deduplicate.

## Finding Description

The vulnerability stems from a design mismatch between the client and server components of the remote execution system.

The client-side code explicitly documents that it does NOT deduplicate state_keys to avoid overhead, expecting the server to handle deduplication: [1](#0-0) 

The `extract_state_keys()` function collects state keys from all transactions without any deduplication: [2](#0-1) 

These potentially duplicate keys are passed to the remote state view client, which sends them in batches to the coordinator: [3](#0-2) 

However, the server-side `handle_message()` function does NOT deduplicate before processing: [4](#0-3) 

Each state_key in the vector, including duplicates, triggers a `get_state_value()` call. While the underlying `CachedStateView` has a memorization cache that prevents expensive database lookups for duplicates: [5](#0-4) 

The cache mitigates database cost but duplicates still cause:
- Repeated lock acquisitions 
- Multiple cache lookups for the same key
- Unnecessary entries in the response vector
- Wasted network bandwidth

## Impact Explanation

This qualifies as **Medium severity** per Aptos bug bounty criteria as it enables resource consumption amplification without critical impact:

- Does NOT cause fund loss or consensus violations
- Does NOT cause total liveness failure 
- DOES cause inefficient resource usage (CPU, memory, bandwidth)
- The caching mechanism prevents this from escalating to High severity node slowdowns

An attacker can amplify resource consumption by submitting multiple transactions that naturally touch the same popular storage locations (e.g., high-traffic token accounts), causing legitimate duplication in read/write hints.

## Likelihood Explanation

**High likelihood** - This occurs naturally during normal operation:

1. Transaction read/write hints are determined by transaction type and parameters: [6](#0-5) 

2. Multiple transactions in a block naturally share storage locations (sender accounts, popular token contracts)
3. No special permissions required - any transaction sender triggers this
4. The code comment acknowledges duplicates are expected but assumed to be handled

## Recommendation

Add deduplication in `handle_message()` before processing state_keys:

```rust
pub fn handle_message(
    message: Message,
    state_view: Arc<RwLock<Option<Arc<S>>>>,
    kv_tx: Arc<Vec<Sender<Message>>>,
) {
    let _timer = REMOTE_EXECUTOR_TIMER
        .with_label_values(&["0", "kv_requests"])
        .start_timer();
    let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
        .with_label_values(&["0", "kv_req_deser"])
        .start_timer();
    let req: RemoteKVRequest = bcs::from_bytes(&message.data).unwrap();
    drop(bcs_deser_timer);

    let (shard_id, state_keys) = req.into();
    
    // Deduplicate state_keys to avoid redundant processing
    use std::collections::HashSet;
    let unique_keys: Vec<StateKey> = state_keys
        .into_iter()
        .collect::<HashSet<_>>()
        .into_iter()
        .collect();
    
    trace!(
        "remote state view service - received request for shard {} with {} keys ({} unique)",
        shard_id,
        state_keys.len(),
        unique_keys.len()
    );
    
    let resp = unique_keys
        .into_iter()
        .map(|state_key| {
            let state_value = state_view
                .read()
                .unwrap()
                .as_ref()
                .unwrap()
                .get_state_value(&state_key)
                .unwrap();
            (state_key, state_value)
        })
        .collect_vec();
    // ... rest of function
}
```

## Proof of Concept

```rust
#[test]
fn test_duplicate_state_keys_amplification() {
    use aptos_types::state_store::state_key::StateKey;
    use aptos_types::account_address::AccountAddress;
    
    // Create a state key
    let addr = AccountAddress::random();
    let state_key = StateKey::raw(b"test_key");
    
    // Simulate duplicate keys as would come from multiple transactions
    // touching the same account
    let duplicate_keys = vec![
        state_key.clone(),
        state_key.clone(),
        state_key.clone(),
        state_key.clone(),
        state_key.clone(),
    ];
    
    // Create RemoteKVRequest with duplicates
    let request = RemoteKVRequest::new(0, duplicate_keys);
    
    // Serialize and send to handle_message
    let message = Message::new(bcs::to_bytes(&request).unwrap());
    
    // The handle_message function will call get_state_value() 5 times
    // for the same key, when it should only call once and reuse the result
    
    // Measurement: Count lock acquisitions and cache lookups
    // Expected: 5 lock acquisitions, 5 cache lookups (1 miss, 4 hits)
    // Desired: 1 lock acquisition, 1 cache lookup
}
```

## Notes

The underlying `CachedStateView` already has a TODO comment acknowledging this issue: [7](#0-6) 

This suggests the developers are aware of the inefficiency but haven't implemented deduplication at the appropriate layer. The fix should be at the `RemoteStateViewService` layer to honor the client-side assumption documented in the comments.

### Citations

**File:** execution/executor-service/src/remote_cordinator_client.rs (L49-51)
```rust
    // Extract all the state keys from the execute block command. It is possible that there are duplicate state keys.
    // We are not de-duplicating them here to avoid the overhead of deduplication. The state view server will deduplicate
    // the state keys.
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L52-76)
```rust
    fn extract_state_keys(command: &ExecuteBlockCommand) -> Vec<StateKey> {
        command
            .sub_blocks
            .sub_block_iter()
            .flat_map(|sub_block| {
                sub_block
                    .transactions
                    .par_iter()
                    .map(|txn| {
                        let mut state_keys = vec![];
                        for storage_location in txn
                            .txn()
                            .read_hints()
                            .iter()
                            .chain(txn.txn().write_hints().iter())
                        {
                            state_keys.push(storage_location.state_key().clone());
                        }
                        state_keys
                    })
                    .flatten()
                    .collect::<Vec<StateKey>>()
            })
            .collect::<Vec<StateKey>>()
    }
```

**File:** execution/executor-service/src/remote_state_view.rs (L172-180)
```rust
    fn send_state_value_request(
        shard_id: ShardId,
        sender: Arc<Sender<Message>>,
        state_keys: Vec<StateKey>,
    ) {
        let request = RemoteKVRequest::new(shard_id, state_keys);
        let request_message = bcs::to_bytes(&request).unwrap();
        sender.send(Message::new(request_message)).unwrap();
    }
```

**File:** execution/executor-service/src/remote_state_view_service.rs (L89-107)
```rust
        let (shard_id, state_keys) = req.into();
        trace!(
            "remote state view service - received request for shard {} with {} keys",
            shard_id,
            state_keys.len()
        );
        let resp = state_keys
            .into_iter()
            .map(|state_key| {
                let state_value = state_view
                    .read()
                    .unwrap()
                    .as_ref()
                    .unwrap()
                    .get_state_value(&state_key)
                    .unwrap();
                (state_key, state_value)
            })
            .collect_vec();
```

**File:** storage/storage-interface/src/state_store/state_view/cached_state_view.rs (L283-297)
```rust
    fn get_state_slot(&self, state_key: &StateKey) -> StateViewResult<StateSlot> {
        let _timer = TIMER.timer_with(&["get_state_value"]);
        COUNTER.inc_with(&["sv_total_get"]);

        // First check if requested key is already memorized.
        if let Some(slot) = self.memorized.get_cloned(state_key) {
            COUNTER.inc_with(&["sv_memorized"]);
            return Ok(slot);
        }

        // TODO(aldenhu): reduce duplicated gets
        let slot = self.get_unmemorized(state_key)?;
        self.memorized.try_insert(state_key, &slot);
        Ok(slot)
    }
```

**File:** types/src/transaction/analyzed_transaction.rs (L195-221)
```rust
pub fn rw_set_for_coin_transfer(
    sender_address: AccountAddress,
    receiver_address: AccountAddress,
    receiver_exists: bool,
) -> (Vec<StorageLocation>, Vec<StorageLocation>) {
    let mut write_hints = vec![
        account_resource_location(sender_address),
        coin_store_location(sender_address),
    ];
    if sender_address != receiver_address {
        write_hints.push(coin_store_location(receiver_address));
    }
    if !receiver_exists {
        // If the receiver doesn't exist, we create the receiver account, so we need to write the
        // receiver account resource.
        write_hints.push(account_resource_location(receiver_address));
    }

    let read_hints = vec![
        current_ts_location(),
        features_location(),
        aptos_coin_info_location(),
        chain_id_location(),
        transaction_fee_burn_cap_location(),
    ];
    (read_hints, write_hints)
}
```

**File:** storage/storage-interface/src/state-store/state_view/cached_state_view.rs (L293-293)
```rust

```
