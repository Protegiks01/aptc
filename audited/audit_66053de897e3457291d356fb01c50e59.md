# Audit Report

## Title
Consensus Divergence Due to Silent Config Deserialization Fallback During Rolling Upgrades

## Summary

When on-chain configs are upgraded to new versions through governance, nodes running outdated binary versions fail to deserialize the updated configs. Instead of halting or requiring intervention, the code silently falls back to default/missing config values. This causes nodes with different binary versions to execute blocks with different parameters (transaction shuffling, gas limits, etc.), producing different state roots and breaking consensus safety.

## Finding Description

The on-chain config system uses versioned enums (`OnChainExecutionConfig::V1` through `V7`, `OnChainConsensusConfig::V1` through `V5`) to allow config evolution. When these configs are upgraded through governance proposals, the new serialized config is stored on-chain.

The critical vulnerability occurs in how config deserialization failures are handled: [1](#0-0) 

The `fetch_config_and_bytes` function converts deserialization errors to `None` via `.ok()?`. This `None` is then handled by callers using fallback patterns: [2](#0-1) 

When old nodes encounter a config version they don't recognize (e.g., `V8`), BCS deserialization fails because the variant is unknown. The code logs a warning but continues with `unwrap_or_default()` or `unwrap_or_else(default_if_missing)`: [3](#0-2) 

The `Missing` variant returns fundamentally different execution parameters: [4](#0-3) 

**Attack Scenario:**

1. Network is running with `OnChainExecutionConfig::V7` configured with `UseCaseAware` transaction shuffling and `ComplexLimitV1` gas limits
2. Governance proposal upgrades config to hypothetical `V8` with new fields
3. Nodes with updated binaries successfully deserialize `V8` and use the configured values
4. Nodes with old binaries:
   - Attempt to deserialize `V8` 
   - BCS fails because variant tag is unknown
   - Fall back to `OnChainExecutionConfig::Missing`
   - Use `NoShuffling` and `NoLimit` instead
5. During block execution, the transaction shuffler produces different transaction orderings: [5](#0-4) 

Different transaction orderings lead to different execution results and different state roots, violating the **Deterministic Execution** invariant. This causes a consensus fork where nodes with different binary versions produce divergent ledger states.

## Impact Explanation

**Severity: CRITICAL** (Consensus/Safety Violation - up to $1,000,000 per Aptos Bug Bounty)

This vulnerability directly breaks **Consensus Safety** (Invariant #2) and **Deterministic Execution** (Invariant #1):

- Nodes executing identical blocks produce different state roots
- Network splits into multiple forks based on binary version
- Requires hardfork intervention to recover
- All consensus guarantees (Byzantine fault tolerance, finality) are violated

The impact qualifies as "Non-recoverable network partition (requires hardfork)" under Critical severity. During a rolling upgrade window, a significant portion of the network (potentially >33% if upgrades are staggered) could be executing with different configs, making consensus impossible.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers during normal operational procedures:

1. **Governance upgrades are routine**: Execution and consensus configs are upgraded through governance to tune performance or enable new features
2. **Rolling upgrades are standard practice**: Validators upgrade binaries gradually to avoid downtime
3. **Mixed versions are expected**: During any upgrade window (typically hours to days), the network has mixed binary versions
4. **No attacker required**: This occurs naturally during legitimate governance upgrades, not requiring malicious intent

The vulnerability has likely not manifested yet because:
- The current versioning pattern creates new variants rather than extending existing ones
- The community may perform coordinated upgrades where most nodes update simultaneously
- Default configs may happen to be similar to actual configs in current deployments

However, as the protocol evolves and more config variants are added, the probability of triggering this condition increases significantly.

## Recommendation

**Immediate Fix:**

Change config fetch behavior to **fail hard** on deserialization errors for critical configs that affect consensus determinism, rather than silently falling back to defaults.

For `OnChainExecutionConfig` and `OnChainConsensusConfig`, modify the fetch pattern:

```rust
// In consensus/src/epoch_manager.rs, replace:
let consensus_config = onchain_consensus_config.unwrap_or_default();

// With:
let consensus_config = onchain_consensus_config.expect(
    "Failed to deserialize on-chain consensus config. \
     This node's binary is incompatible with the current on-chain config version. \
     Please upgrade to the latest binary version."
);
```

Similarly for execution config. The node should **halt** rather than continue with potentially incompatible configs.

**Long-term Solution:**

1. **Version compatibility metadata**: Include minimum binary version requirements in config upgrades
2. **Pre-upgrade validation**: Require governance proposals to specify binary version requirements
3. **Graceful degradation**: For non-consensus-critical configs, fallbacks are acceptable, but execution/consensus configs must fail hard
4. **Upgrade coordination**: Implement protocol-level mechanisms to ensure sufficient validator participation before activating new config versions (similar to feature flags)

## Proof of Concept

```rust
// Test demonstrating consensus divergence
#[test]
fn test_config_version_mismatch_causes_divergence() {
    // Simulate two nodes with different binary versions
    
    // Node 1: Old binary (knows V1-V7)
    let old_enum = OnChainExecutionConfig::V7(ExecutionConfigV7 {
        transaction_shuffler_type: TransactionShufflerType::UseCaseAware {
            sender_spread_factor: 32,
            platform_use_case_spread_factor: 0,
            user_use_case_spread_factor: 4,
        },
        block_gas_limit_type: BlockGasLimitType::ComplexLimitV1 { /* ... */ },
        enable_per_block_gas_limit: true,
        transaction_deduper_type: TransactionDeduperType::TxnHashAndAuthenticatorV1,
        gas_price_to_burn: 90,
        persisted_auxiliary_info_version: 1,
    });
    
    // Serialize V7 config
    let v7_bytes = bcs::to_bytes(&old_enum).unwrap();
    
    // Node 2: Hypothetical V8 config (new binary)
    // Old node tries to deserialize - will fail
    // Falls back to Missing variant
    
    let old_node_config = OnChainExecutionConfig::default_if_missing();
    
    // Compare execution parameters
    assert_eq!(old_enum.transaction_shuffler_type(), 
               TransactionShufflerType::UseCaseAware { /* ... */ });
    assert_eq!(old_node_config.transaction_shuffler_type(), 
               TransactionShufflerType::NoShuffling); // DIFFERENT!
    
    // Transaction order will differ
    let txns = vec![/* same transaction set */];
    let order_new = shuffle_with_config(&old_enum, txns.clone());
    let order_old = shuffle_with_config(&old_node_config, txns.clone());
    
    assert_ne!(order_new, order_old); // CONSENSUS DIVERGENCE!
}
```

## Notes

The security question asked whether "old code can deserialize into smaller structs silently truncating data." The actual behavior is subtly different but more severe:

1. **BCS does NOT silently truncate** - it fails with an error when encountering unknown enum variants or trailing bytes
2. **However**, the error handling code silently **substitutes default values** instead of propagating the error
3. This substitution is **worse than truncation** because it masks incompatibility and causes deterministic execution violations

The vulnerability exists in the gap between:
- The config versioning pattern (designed to handle evolution safely)  
- The error handling pattern (designed for optional/missing configs)

When combined during rolling upgrades, these create a critical consensus safety violation. The enum versioning suggests configs can evolve safely, but the fallback behavior undermines this guarantee by allowing incompatible nodes to continue operating with divergent execution parameters.

### Citations

**File:** types/src/on_chain_config/mod.rs (L185-193)
```rust
    fn fetch_config_and_bytes<T>(storage: &T) -> Option<(Self, Bytes)>
    where
        T: ConfigStorage + ?Sized,
    {
        let state_key = StateKey::on_chain_config::<Self>().ok()?;
        let bytes = storage.fetch_config_bytes(&state_key)?;
        let config = Self::deserialize_into_config(&bytes).ok()?;
        Some((config, bytes))
    }
```

**File:** consensus/src/epoch_manager.rs (L1178-1205)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
        let execution_config = onchain_execution_config
            .unwrap_or_else(|_| OnChainExecutionConfig::default_if_missing());
        let onchain_randomness_config_seq_num = onchain_randomness_config_seq_num
            .unwrap_or_else(|_| RandomnessConfigSeqNum::default_if_missing());
```

**File:** types/src/on_chain_config/execution_config.rs (L29-58)
```rust
    pub fn transaction_shuffler_type(&self) -> TransactionShufflerType {
        match &self {
            OnChainExecutionConfig::Missing => TransactionShufflerType::NoShuffling,
            OnChainExecutionConfig::V1(config) => config.transaction_shuffler_type.clone(),
            OnChainExecutionConfig::V2(config) => config.transaction_shuffler_type.clone(),
            OnChainExecutionConfig::V3(config) => config.transaction_shuffler_type.clone(),
            OnChainExecutionConfig::V4(config) => config.transaction_shuffler_type.clone(),
            OnChainExecutionConfig::V5(config) => config.transaction_shuffler_type.clone(),
            OnChainExecutionConfig::V6(config) => config.transaction_shuffler_type.clone(),
            OnChainExecutionConfig::V7(config) => config.transaction_shuffler_type.clone(),
        }
    }

    /// The per-block gas limit being used.
    pub fn block_gas_limit_type(&self) -> BlockGasLimitType {
        match &self {
            OnChainExecutionConfig::Missing => BlockGasLimitType::NoLimit,
            OnChainExecutionConfig::V1(_config) => BlockGasLimitType::NoLimit,
            OnChainExecutionConfig::V2(config) => config
                .block_gas_limit
                .map_or(BlockGasLimitType::NoLimit, BlockGasLimitType::Limit),
            OnChainExecutionConfig::V3(config) => config
                .block_gas_limit
                .map_or(BlockGasLimitType::NoLimit, BlockGasLimitType::Limit),
            OnChainExecutionConfig::V4(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V5(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V6(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V7(config) => config.block_gas_limit_type.clone(),
        }
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L135-139)
```rust
    /// The default values to use when on-chain config is not initialized.
    /// This value should not be changed, for replay purposes.
    pub fn default_if_missing() -> Self {
        OnChainExecutionConfig::Missing
    }
```

**File:** consensus/src/block_preparer.rs (L100-104)
```rust
            let mut shuffled_txns = {
                let _timer = TXN_SHUFFLE_SECONDS.start_timer();

                txn_shuffler.shuffle(deduped_txns)
            };
```
