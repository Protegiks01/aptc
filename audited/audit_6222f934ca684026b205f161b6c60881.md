# Audit Report

## Title
Missing Backoff Trigger for TooManyTransactions Status Enables Mempool DoS

## Summary
The `gen_ack_response()` function in `mempool/src/shared_mempool/tasks.rs` only checks for `MempoolStatusCode::MempoolIsFull` when determining whether to signal backoff to broadcasting peers. It fails to check for `MempoolStatusCode::TooManyTransactions`, which also represents resource exhaustion at the per-account level. This allows malicious peers to continue broadcasting transactions at high frequency (10ms intervals) even when per-account capacity limits are reached, bypassing the backoff mechanism (30 second intervals) and causing resource exhaustion.

## Finding Description

The mempool implements a backpressure mechanism to prevent resource exhaustion: when a peer receives transactions that cannot be processed due to capacity constraints, it should signal the sender to enter backoff mode, reducing broadcast frequency from 10ms to 30 seconds. [1](#0-0) 

The function only checks for `MempoolIsFull`, which indicates global mempool capacity exhaustion. However, there is another capacity-related status code: `TooManyTransactions`, which indicates per-account capacity exhaustion. [2](#0-1) 

Per-account capacity limits are enforced in the transaction store: [3](#0-2) 

With default configuration, accounts are limited to 100 sequence-based transactions or 1000 orderless transactions: [4](#0-3) [5](#0-4) [6](#0-5) 

**Attack Flow:**
1. Attacker controls a malicious peer and multiple accounts
2. Attacker fills each account's mempool capacity (100 or 1000 transactions)
3. Attacker's peer continues broadcasting transactions from these accounts
4. Victim node processes each transaction through expensive operations (network I/O, deserialization, DB reads for sequence numbers, VM validation) before rejecting with `TooManyTransactions`
5. Since `gen_ack_response()` doesn't check `TooManyTransactions`, no backoff is signaled
6. Malicious peer continues broadcasting at 10ms intervals instead of backing off to 30 seconds
7. Victim wastes resources processing transactions that will always be rejected [4](#0-3) 

Before rejection, transactions consume resources: [7](#0-6) [8](#0-7) 

## Impact Explanation

This vulnerability enables a **Medium severity DoS attack** per the Aptos bug bounty criteria ("State inconsistencies requiring intervention" / resource exhaustion affecting node availability):

**Resource Consumption:**
- **Network Bandwidth**: With batch size 300 and 10ms intervals, attackers can send ~30,000 transactions/second per peer that will be processed and rejected
- **CPU**: Each transaction undergoes deserialization, sequence number validation, and VM validation before rejection
- **Database I/O**: Parallel reads to fetch account sequence numbers for all incoming transactions
- **Memory**: Allocations for processing transaction batches

**Amplification Factor:**
- Normal interval: 10ms
- Backoff interval: 30 seconds  
- Bypass factor: 3000x more frequent broadcasts than intended

**Scope:**
- Affects all nodes receiving broadcasts from malicious peers
- Multiple coordinated malicious peers can amplify the attack
- No special privileges required - any peer can exploit this

The attack does not directly compromise consensus safety or steal funds, placing it in Medium rather than Critical/High severity.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Requirements:**
- Ability to run a peer node (trivial)
- Multiple accounts to reach per-account capacity (free/cheap to create)
- Network connectivity to victim nodes (standard for any peer)

**Execution Complexity:**
- Low: Simply broadcast transactions from accounts that have reached capacity
- No cryptographic exploits or complex race conditions required
- Can be automated trivially

**Detection Difficulty:**
- Moderate: Victims see high transaction rejection rates but may attribute to legitimate traffic
- Attackers can distribute across multiple peers and accounts to evade detection

**Economic Incentives:**
- Competitor nodes could use this to degrade peer performance
- Minimal cost to attacker (just network bandwidth)
- Significant cost to victim (CPU, bandwidth, DB I/O)

## Recommendation

Add `MempoolStatusCode::TooManyTransactions` to the backoff check in `gen_ack_response()`:

```rust
fn gen_ack_response(
    message_id: MempoolMessageId,
    results: Vec<SubmissionStatusBundle>,
    peer: &PeerNetworkId,
) -> MempoolSyncMsg {
    let mut backoff_and_retry = false;
    for (_, (mempool_status, _)) in results.into_iter() {
        // Trigger backoff for both global and per-account capacity exhaustion
        if mempool_status.code == MempoolStatusCode::MempoolIsFull 
            || mempool_status.code == MempoolStatusCode::TooManyTransactions {
            backoff_and_retry = true;
            break;
        }
    }

    update_ack_counter(
        peer,
        counters::SENT_LABEL,
        backoff_and_retry,
        backoff_and_retry,
    );
    MempoolSyncMsg::BroadcastTransactionsResponse {
        message_id,
        retry: backoff_and_retry,
        backoff: backoff_and_retry,
    }
}
```

This ensures that when peers broadcast transactions that exceed per-account capacity, they receive backpressure signals and enter backoff mode, reducing broadcast frequency from 10ms to 30 seconds.

## Proof of Concept

```rust
#[cfg(test)]
mod test_backoff_trigger {
    use super::*;
    use aptos_types::mempool_status::{MempoolStatus, MempoolStatusCode};
    
    #[test]
    fn test_gen_ack_response_triggers_backoff_for_too_many_transactions() {
        // Create a mock peer
        let peer = PeerNetworkId::random();
        let message_id = MempoolMessageId::default();
        
        // Simulate results with TooManyTransactions status
        let results = vec![
            (
                create_signed_transaction(),
                (MempoolStatus::new(MempoolStatusCode::TooManyTransactions), None)
            )
        ];
        
        // Generate ACK response
        let response = gen_ack_response(message_id, results, &peer);
        
        // Verify backoff and retry are triggered
        match response {
            MempoolSyncMsg::BroadcastTransactionsResponse { backoff, retry, .. } => {
                assert!(backoff, "Backoff should be true for TooManyTransactions");
                assert!(retry, "Retry should be true for TooManyTransactions");
            },
            _ => panic!("Expected BroadcastTransactionsResponse"),
        }
    }
    
    #[test]
    fn test_current_behavior_no_backoff_for_too_many_transactions() {
        // This test demonstrates the current buggy behavior
        let peer = PeerNetworkId::random();
        let message_id = MempoolMessageId::default();
        
        let results = vec![
            (
                create_signed_transaction(),
                (MempoolStatus::new(MempoolStatusCode::TooManyTransactions), None)
            )
        ];
        
        let response = gen_ack_response(message_id, results, &peer);
        
        // Current buggy behavior: no backoff despite capacity exhaustion
        match response {
            MempoolSyncMsg::BroadcastTransactionsResponse { backoff, retry, .. } => {
                assert!(!backoff, "Current implementation incorrectly does not trigger backoff");
                assert!(!retry, "Current implementation incorrectly does not trigger retry");
            },
            _ => panic!("Expected BroadcastTransactionsResponse"),
        }
    }
}
```

**Notes:**
- The vulnerability specifically affects the backoff mechanism for per-account capacity exhaustion
- `TooManyTransactions` represents legitimate resource pressure that should trigger the same backpressure response as global `MempoolIsFull`
- The fix is minimal (single condition addition) with no performance impact
- Testing should verify that both `MempoolIsFull` and `TooManyTransactions` trigger backoff appropriately

### Citations

**File:** mempool/src/shared_mempool/tasks.rs (L253-278)
```rust
/// If `MempoolIsFull` on any of the transactions, provide backpressure to the downstream peer.
fn gen_ack_response(
    message_id: MempoolMessageId,
    results: Vec<SubmissionStatusBundle>,
    peer: &PeerNetworkId,
) -> MempoolSyncMsg {
    let mut backoff_and_retry = false;
    for (_, (mempool_status, _)) in results.into_iter() {
        if mempool_status.code == MempoolStatusCode::MempoolIsFull {
            backoff_and_retry = true;
            break;
        }
    }

    update_ack_counter(
        peer,
        counters::SENT_LABEL,
        backoff_and_retry,
        backoff_and_retry,
    );
    MempoolSyncMsg::BroadcastTransactionsResponse {
        message_id,
        retry: backoff_and_retry,
        backoff: backoff_and_retry,
    }
}
```

**File:** mempool/src/shared_mempool/tasks.rs (L328-350)
```rust
    let start_storage_read = Instant::now();
    let state_view = smp
        .db
        .latest_state_checkpoint_view()
        .expect("Failed to get latest state checkpoint view.");

    // Track latency: fetching seq number
    let account_seq_numbers = IO_POOL.install(|| {
        transactions
            .par_iter()
            .map(|(t, _, _)| match t.replay_protector() {
                ReplayProtector::Nonce(_) => Ok(None),
                ReplayProtector::SequenceNumber(_) => {
                    get_account_sequence_number(&state_view, t.sender())
                        .map(Some)
                        .inspect_err(|e| {
                            error!(LogSchema::new(LogEntry::DBError).error(e));
                            counters::DB_ERROR.inc();
                        })
                },
            })
            .collect::<Vec<_>>()
    });
```

**File:** mempool/src/shared_mempool/tasks.rs (L486-503)
```rust
    // Track latency: VM validation
    let vm_validation_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::VM_VALIDATION_LABEL])
        .start_timer();
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
```

**File:** types/src/mempool_status.rs (L52-68)
```rust
pub enum MempoolStatusCode {
    // Transaction was accepted by Mempool
    Accepted = 0,
    // Sequence number is old, etc.
    InvalidSeqNumber = 1,
    // Mempool is full (reached max global capacity)
    MempoolIsFull = 2,
    // Account reached max capacity per account
    TooManyTransactions = 3,
    // Invalid update. Only gas price increase is allowed
    InvalidUpdate = 4,
    // transaction didn't pass vm_validation
    VmError = 5,
    UnknownStatus = 6,
    // The transaction filter has rejected the transaction
    RejectedByFilter = 7,
}
```

**File:** mempool/src/core_mempool/transaction_store.rs (L322-345)
```rust
            match txn_replay_protector {
                ReplayProtector::SequenceNumber(_) => {
                    if txns.seq_num_txns_len() >= self.capacity_per_user {
                        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
                            format!(
                                "Mempool over capacity for account. Number of seq number transactions from account: {} Capacity per account: {}",
                                txns.seq_num_txns_len() ,
                                self.capacity_per_user,
                            ),
                        );
                    }
                },
                ReplayProtector::Nonce(_) => {
                    if txns.orderless_txns_len() >= self.orderless_txn_capacity_per_user {
                        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
                            format!(
                                "Mempool over capacity for account. Number of orderless transactions from account: {} Capacity per account: {}",
                                txns.orderless_txns_len(),
                                self.orderless_txn_capacity_per_user,
                            ),
                        );
                    }
                },
            }
```

**File:** config/src/config/mempool_config.rs (L111-112)
```rust
            shared_mempool_tick_interval_ms: 10,
            shared_mempool_backoff_interval_ms: 30_000,
```

**File:** config/src/config/mempool_config.rs (L123-123)
```rust
            capacity_per_user: 100,
```

**File:** config/src/config/mempool_config.rs (L171-171)
```rust
            orderless_txn_capacity_per_user: 1000,
```
