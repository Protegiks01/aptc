# Audit Report

## Title
Side-Channel Information Leakage in powers_of_tau Function Through Non-Constant-Time Scalar Multiplication

## Summary
The `powers_of_tau` function in the DKG range proof implementation performs repeated scalar multiplications with a secret trapdoor value `tau` using arkworks library operations that are not verified to be constant-time. This creates a potential side-channel vulnerability where an attacker with timing measurement capabilities could recover the secret `tau` value, breaking the zero-knowledge properties of the range proof system. [1](#0-0) 

## Finding Description

The `powers_of_tau` function generates the structured reference string (SRS) for the range proof system by computing successive powers of a randomly sampled secret scalar `tau`. The implementation uses a loop that repeatedly multiplies elliptic curve group elements by the same secret scalar: [2](#0-1) 

This function is called during the trusted setup phase of the range proof system: [3](#0-2) 

**Security Guarantee Violation:**

The vulnerability breaks the **Cryptographic Correctness** invariant (Invariant #10), specifically the requirement that cryptographic operations must be secure against side-channel attacks. If `tau` is leaked, the following security properties are violated:

1. **Zero-Knowledge Property**: An attacker who recovers `tau` can compute all elements in the SRS and thus break the zero-knowledge property of the range proofs
2. **Soundness**: With knowledge of `tau`, an attacker can forge arbitrary proofs that appear valid
3. **Trusted Setup Integrity**: The entire cryptographic scheme relies on `tau` remaining secret and being securely destroyed after setup

**Why This Occurs:**

The codebase demonstrates awareness of side-channel vulnerabilities in cryptographic operations: [4](#0-3) 

While the codebase includes constant-time verification infrastructure for `blstrs` and `zkcrypto` scalar multiplication: [5](#0-4) [6](#0-5) 

**However, there is no equivalent constant-time verification for arkworks scalar multiplication**, which is what `powers_of_tau` uses. The arkworks `Mul` trait implementation for curve groups may use variable-time algorithms that leak timing information about the scalar operand.

The attack becomes more feasible because:
- The same secret `tau` is used in `n` iterations (potentially thousands of multiplications)
- Multiple observations of timing variations increase statistical confidence
- The comment indicates this is a known bottleneck, suggesting measurable timing differences [7](#0-6) 

## Impact Explanation

**Severity: HIGH**

This vulnerability falls under the "Significant protocol violations" category from the Aptos bug bounty HIGH severity criteria. If successfully exploited:

1. **Cryptographic Scheme Compromise**: The attacker gains the trapdoor value for the entire range proof system, allowing them to:
   - Forge arbitrary range proofs that verify correctly
   - Break the zero-knowledge property, learning private information that should remain hidden
   - Undermine the security guarantees of any protocol relying on these range proofs

2. **DKG System Impact**: Since this is part of the Distributed Key Generation (DKG) implementation, compromise could affect:
   - Validator key generation ceremonies
   - Threshold cryptography security
   - Privacy-preserving protocols built on top of the DKG system

3. **Scope**: Any validator or participant using the affected range proof system during setup ceremonies is potentially vulnerable

The impact does not reach CRITICAL severity because:
- It does not directly cause loss of funds or consensus violations
- It requires specific attacker capabilities (timing measurement access)
- The attack must occur during the setup phase, not during normal operation

## Likelihood Explanation

**Likelihood: MEDIUM-LOW**

The attack requires specific conditions:

**Attacker Requirements:**
1. **Timing Measurement Capability**: The attacker needs access to high-resolution timing measurements during `powers_of_tau` execution. This could be achieved through:
   - Co-location on the same physical machine (VM escape, shared hosting)
   - Local access to the machine running the setup
   - Network timing attacks (more difficult but demonstrated in some contexts)
   - In a distributed DKG ceremony, a malicious participant with monitoring capabilities

2. **Opportunity Window**: The attack must occur during the setup phase when `powers_of_tau` is executed. This is typically a one-time operation, though in DKG contexts it may occur multiple times across different nodes.

3. **Statistical Analysis**: Successful recovery of `tau` requires:
   - Multiple timing measurements (the loop provides `n` observations)
   - Statistical correlation analysis
   - Knowledge of side-channel attack techniques

**Mitigating Factors:**
- Setup ceremonies may be performed in controlled environments
- Not all deployment scenarios expose timing information to potential attackers
- The attack requires cryptographic and side-channel expertise

**Aggravating Factors:**
- The loop performs many iterations with the same secret, providing multiple observations
- Known side-channel attacks exist against non-constant-time scalar multiplication
- The function is documented as a performance bottleneck, suggesting measurable timing variations

## Recommendation

**Solution 1: Use Constant-Time Scalar Multiplication (Preferred)**

Replace the iterative scalar multiplication with a verified constant-time implementation. Switch from arkworks to `blstrs` (which has constant-time verification) or ensure arkworks operations are constant-time: [8](#0-7) 

Use the `batch_mul` approach with pre-computed powers (which distributes the secret across multiple operations) instead of iterative multiplication, or use a library with constant-time guarantees.

**Solution 2: Add Constant-Time Verification**

Implement dudect-based constant-time testing for arkworks scalar multiplication, similar to the existing tests: [9](#0-8) 

Ensure the tests pass before using arkworks in security-critical contexts like `powers_of_tau`.

**Solution 3: Use Alternative Setup Mechanism**

Consider using a different SRS generation approach:
- Multi-party computation (MPC) for trusted setup where no single party knows `tau`
- Universal and updateable setups that don't rely on a single secret
- Use existing, audited powers-of-tau ceremonies from other projects

## Proof of Concept

A complete PoC requires timing infrastructure, but the vulnerable code path can be demonstrated:

```rust
// Proof of Concept: Timing Measurement Setup
// File: crates/aptos-dkg/src/range_proofs/dekart_univariate.rs

use std::time::Instant;

// Vulnerable function - timing varies based on tau's bit pattern
pub fn measure_powers_of_tau_timing<E: Pairing, R>(
    group_generators: GroupGenerators<E>,
    rng: &mut R,
    n: usize,
) -> (PowersOfTau<E>, Duration)
where
    R: RngCore + CryptoRng,
{
    let start = Instant::now();
    
    // This function performs n scalar multiplications with the same secret tau
    let tau: E::ScalarField = sample_field_element(rng);
    let mut t1 = vec![group_generators.g1.into()];
    let mut t2 = vec![group_generators.g2.into()];
    
    // Each iteration leaks timing information about tau
    for i in 0..n {
        t1.push(t1[i] * tau);  // Potentially variable-time operation
        t2.push(t2[i] * tau);  // Potentially variable-time operation
    }
    
    let elapsed = start.elapsed();
    (PowersOfTau { t1, t2 }, elapsed)
}

// Attack simulation (requires actual timing attack implementation)
// An attacker would:
// 1. Measure execution time for multiple runs
// 2. Correlate timing with tau's bit patterns
// 3. Use statistical analysis to recover tau bits
// 4. Reconstruct the full secret value
```

To implement a full timing attack PoC, one would need to:
1. Run `powers_of_tau` multiple times with different `tau` values
2. Measure timing variations correlated with scalar bit patterns
3. Apply known timing attack techniques (e.g., cache-timing analysis)
4. Demonstrate recovery of `tau` bits with statistical confidence

**Notes**

1. **Scope Limitation**: This vulnerability is specific to the DKG range proof implementation and does not directly affect consensus, Move VM execution, or other core blockchain operations.

2. **Defense-in-Depth**: While side-channel attacks are serious, they typically require specific attacker capabilities. Organizations should still implement defense-in-depth measures like:
   - Performing setup ceremonies in secure, isolated environments
   - Using hardware with side-channel protections
   - Employing multi-party computation for setup when possible

3. **Broader Arkworks Usage**: The same concern applies to other uses of arkworks scalar multiplication throughout the codebase. A comprehensive audit should review all cryptographic operations for constant-time properties.

4. **Verification Gap**: The existence of constant-time testing for `blstrs` but not `arkworks` suggests an oversight in security verification that should be addressed systematically.

### Citations

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L44-60)
```rust
pub fn powers_of_tau<E: Pairing, R>(
    group_generators: GroupGenerators<E>,
    rng: &mut R,
    n: usize,
) -> PowersOfTau<E>
where
    R: RngCore + CryptoRng,
{
    let tau: E::ScalarField = sample_field_element(rng);
    let mut t1 = vec![group_generators.g1.into()];
    let mut t2 = vec![group_generators.g2.into()];
    for i in 0..n {
        t1.push(t1[i] * tau);
        t2.push(t2[i] * tau);
    }
    PowersOfTau { t1, t2 }
}
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L134-134)
```rust
    // The main bottlenecks are `powers_of_tau` and the IFFT steps.
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L145-145)
```rust
        let taus = powers_of_tau(group_generators, rng, max_n); // The taus have length `max_n+1`
```

**File:** crates/aptos-crypto/src/arkworks/hashing.rs (L20-24)
```rust
/// Note: This algorithm is probabilistic and may be vulnerable to
/// side-channel attacks. For more details, see `MapToGroup` in:
/// Boneh, D., Lynn, B., & Shacham, H. (2004). "Short Signatures from the Weil Pairing."
/// Journal of Cryptology, 17, 297â€“319. DOI: 10.1007/s00145-004-0314-9.
/// <https://doi.org/10.1007/s00145-004-0314-9>
```

**File:** crates/aptos-crypto/src/constant_time/blstrs_scalar_mul.rs (L16-26)
```rust
/// Runs a statistical test to check that blst's scalar multiplication on G1 is constant time
/// This function pick random bases for all scalar multiplications.
pub fn run_bench_with_random_bases(runner: &mut CtRunner, rng: &mut BenchRng) {
    build_and_run_bench(runner, rng, true, N);
}

/// Runs a statistical test to check that blst's scalar multiplication on G1 is constant time
/// This function keeps the multiplied base the same: the generator of G1.
pub fn run_bench_with_fixed_bases(runner: &mut CtRunner, rng: &mut BenchRng) {
    build_and_run_bench(runner, rng, false, N);
}
```

**File:** crates/aptos-crypto/src/unit_tests/constant_time_test.rs (L23-39)
```rust
fn test_blstrs_fixed_base_g1_scalar_mul_is_constant_time() {
    let ct_summary = run_bench(
        &BenchName("blstrs_scalar_mul_fixed_base"),
        constant_time::blstrs_scalar_mul::run_bench_with_fixed_bases,
        None,
    )
    .1;

    eprintln!("{:?}", ct_summary);

    let max_t = ct_summary
        .max_t
        .abs()
        .to_i64()
        .expect("Floating point arithmetic went awry.");
    assert_le!(max_t, 5);
}
```

**File:** crates/aptos-crypto/src/arkworks/srs.rs (L153-168)
```rust
pub fn powers_of_tau<C: CurveGroup>(G: C, tau: C::ScalarField, n: usize) -> Vec<C::Affine> {
    // We have to work over `CurveGroup` instead of `AffineRepr` here and in the above function `lagrange_basis()`
    // because for some reason only the former has `batch_mul()` implemented for its elements, and this is much
    // faster than doing the naive approach:
    //
    // let mut proj = Vec::with_capacity(n);
    // proj.push(base.into_group());
    // for i in 0..(n - 1) {
    //     proj.push(proj[i] * tau);
    // }
    // A::Group::normalize_batch(&proj)

    let powers_of_tau = utils::powers(tau, n);

    G.batch_mul(&powers_of_tau)
}
```

**File:** crates/aptos-crypto/src/constant_time/mod.rs (L1-10)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! This module provides implementations of "dudect" statistical tests to check some of our code
//! is constant-time (e.g., like scalar multiplication).

/// Module for testing that blstrs scalar multiplication is constant-time
pub mod blstrs_scalar_mul;
/// Module for testing that zkcrypto scalar multiplication is constant-time
pub mod zkcrypto_scalar_mul;
```
