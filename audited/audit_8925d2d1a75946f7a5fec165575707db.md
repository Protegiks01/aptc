# Audit Report

## Title
Event Sequence Number Corruption Due to Reading Latest State Instead of Historical State During Event Translation

## Summary
The event V2 translator reads blockchain state from the latest checkpoint instead of the state at the transaction version being indexed. When the indexer lags behind the main database and encounters new event keys, it assigns incorrect sequence numbers based on future state, causing permanent data corruption in the event indexer.

## Finding Description

The `EventV2TranslationEngine` in `event_v2_translator.rs` incorrectly reads blockchain state from the **latest checkpoint** when translating V2 events to V1 events, rather than reading the state at the specific transaction version being indexed. [1](#0-0) 

When processing events, the system retrieves the `EventHandle` counter from the account's resource (e.g., `CoinStore.deposit_events.counter`) to determine sequence numbers. This counter value is used as the default when an event key is encountered for the first time: [2](#0-1) 

The sequence number assignment logic uses this counter as a fallback: [3](#0-2) 

**Attack Scenario:**

1. Main DB progresses to version 200, where account Alice has emitted 20 CoinDeposit events (sequence numbers 0-19)
2. Indexer DB is at version 50 (lagging due to restart/sync)
3. At version 100, Alice emitted her first CoinDeposit event (should be sequence number 0)
4. Indexer begins processing version 100
5. Translator reads Alice's CoinStore from **latest state** (version 200), getting counter = 20
6. Since this is the first time seeing Alice's event key, cache is empty, DB is empty
7. System uses default value 20 as the sequence number
8. Alice's first event is assigned sequence number **20** instead of **0**
9. Subsequent events get sequence numbers 21, 22, 23... instead of 1, 2, 3...
10. Sequence numbers 0-19 are permanently missing from the indexer [4](#0-3) 

The core issue is that the translator has no access to the transaction version being processed - it's not passed as a parameter to the translation function. The system should use `state_view_at_version()` instead: [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the "State inconsistencies requiring intervention" category because:

1. **Data Corruption**: Event sequence numbers in the indexer database are permanently incorrect
2. **Query Failures**: API queries for events with the correct sequence numbers (0-N) return empty results
3. **Missing Data**: Large ranges of sequence numbers become inaccessible
4. **API Inconsistency**: The indexer's event sequence numbers don't match the actual on-chain event sequence numbers
5. **Requires Manual Intervention**: Full re-indexing from genesis is needed to fix corrupted data

While this doesn't affect consensus or validator operations directly, it breaks the indexer's core functionality and violates the **State Consistency** invariant that state transitions must be verifiable and consistent.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers automatically in common operational scenarios:

1. **Initial Sync**: New nodes syncing from genesis will corrupt data for any account that continues emitting events while the indexer catches up
2. **Node Restart**: After restart, if the main DB has progressed beyond the indexer's last checkpoint
3. **Lagging Indexer**: During high transaction load when the indexer falls behind the main DB
4. **Fast Sync**: When using fast sync mode where the indexer starts from a snapshot

The vulnerability requires no attacker action - it's a natural consequence of the indexer lagging behind the main database, which is expected behavior during normal operation.

## Recommendation

Modify `EventV2TranslationEngine` to accept and use the transaction version being processed:

1. Add version parameter to `translate_event_v2_to_v1()` and all translator implementations
2. Replace `latest_state_checkpoint_view()` with `state_view_at_version(Some(version))`
3. Pass the transaction version from `db_indexer.rs` line 467/478 to the translation engine

**Proposed Fix:**

```rust
// In event_v2_translator.rs
pub fn get_state_value_bytes_for_resource_at_version(
    &self,
    address: &AccountAddress,
    struct_tag: &StructTag,
    version: Version,
) -> Result<Option<Bytes>> {
    let state_view = self
        .main_db_reader
        .state_view_at_version(Some(version))
        .expect("Failed to get state view");
    let state_key = StateKey::resource(address, struct_tag)?;
    let maybe_state_value = state_view.get_state_value(&state_key)?;
    Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
}
```

Update all translator trait methods to accept version parameter and use version-specific state views.

## Proof of Concept

```rust
// Reproduction test for storage/indexer/src/event_v2_translator.rs
#[test]
fn test_sequence_number_corruption_on_lagging_indexer() {
    // Setup: Main DB at version 200, Indexer at version 50
    let mut main_db = MockMainDB::new();
    let mut indexer_db = MockIndexerDB::new();
    
    // Account Alice emits 20 deposit events at versions 100-119
    let alice_addr = AccountAddress::random();
    for v in 100..120 {
        main_db.execute_transaction_with_deposit_event(v, alice_addr);
    }
    
    // At version 120, Alice's CoinStore.deposit_events.counter = 20
    assert_eq!(main_db.get_deposit_event_count(alice_addr, 120), 20);
    
    // Indexer processes version 100 (Alice's first event)
    let engine = EventV2TranslationEngine::new(
        Arc::new(main_db),
        Arc::new(indexer_db.db.clone())
    );
    
    let v2_event = create_coin_deposit_v2_event(alice_addr);
    let v1_event = engine.translate_event_v2_to_v1(&v2_event).unwrap();
    
    // BUG: sequence_number is 20 instead of 0
    assert_eq!(v1_event.sequence_number(), 20); // Should be 0!
    
    // Sequence numbers 0-19 are now missing from the indexer
    // causing permanent data corruption
}
```

**Notes**

The original security question asked about "database writes bypassing the cache," but investigation revealed that's not the issue - database writes always come from the cache, and the cache-to-DB path is properly synchronized. [6](#0-5) 

The actual vulnerability is the use of latest state instead of historical state when reading blockchain data during event translation, which is a different but related cache coherence issue that causes systematic data corruption in the indexer.

### Citations

**File:** storage/indexer/src/event_v2_translator.rs (L190-200)
```rust
    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
        if let Some(seq) = self.get_cached_sequence_number(event_key) {
            Ok(seq + 1)
        } else {
            let seq = self
                .internal_indexer_db
                .get::<EventSequenceNumberSchema>(event_key)?
                .map_or(default, |seq| seq + 1);
            Ok(seq)
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L202-214)
```rust
    pub fn get_state_value_bytes_for_resource(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
    ) -> Result<Option<Bytes>> {
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        let state_key = StateKey::resource(address, struct_tag)?;
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L248-257)
```rust
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_deposit.account(), &struct_tag)?
        {
            // We can use `DummyCoinType` as it does not affect the correctness of deserialization.
            let coin_store_resource: CoinStoreResource<DummyCoinType> =
                bcs::from_bytes(&state_value_bytes)?;
            let key = *coin_store_resource.deposit_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, coin_store_resource.deposit_events().count())?;
            (key, sequence_number)
```

**File:** storage/indexer/src/db_indexer.rs (L448-463)
```rust
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
```

**File:** storage/indexer/src/db_indexer.rs (L511-521)
```rust
            for event_key in event_keys {
                batch
                    .put::<EventSequenceNumberSchema>(
                        &event_key,
                        &self
                            .event_v2_translation_engine
                            .get_cached_sequence_number(&event_key)
                            .unwrap_or(0),
                    )
                    .expect("Failed to put events by key to a batch");
            }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L93-105)
```rust
pub trait DbStateViewAtVersion {
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView>;
}

impl DbStateViewAtVersion for Arc<dyn DbReader> {
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version,
            maybe_verify_against_state_root_hash: None,
        })
    }
}
```
