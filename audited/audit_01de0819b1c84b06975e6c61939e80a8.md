# Audit Report

## Title
Stream Information Loss in Indexer Load Balancing Due to Unsafe Defaulting

## Summary
The `handle_live_data_service_info()` function in the indexer-grpc-manager unsafely defaults missing `stream_info` to an empty value instead of rejecting invalid heartbeats. This allows attackers to manipulate load balancing decisions by sending malformed heartbeats, causing service overload and indexer availability degradation.

## Finding Description

The vulnerability exists in the indexer-grpc metadata management system. When a data service sends a heartbeat to the GrpcManager, the `stream_info` field (containing active stream counts) is marked as optional in the protobuf specification. [1](#0-0) 

The `handle_live_data_service_info()` function defensively defaults missing `stream_info` to an empty `StreamInfo` with zero active streams. [2](#0-1) 

This modified information is stored as the most recent state in the `recent_states` queue. [3](#0-2) 

The load balancing logic in `pick_live_data_service()` uses this most recent state to select the least-loaded service for new requests, assuming `stream_info` is always present. [4](#0-3) 

Specifically, it calls `.unwrap()` on `stream_info` and counts active streams for load distribution. [5](#0-4) 

**Attack Vector:**

The heartbeat endpoint accepts unauthenticated requests with valid protobuf structure. [6](#0-5) 

An attacker can:
1. Send spoofed heartbeat messages to the GrpcManager with `stream_info: None`
2. The manager defaults this to 0 active streams (even if the real service has many active streams)
3. The load balancer perceives this service as idle and routes disproportionate traffic to it
4. The targeted service becomes overloaded
5. Legitimate stream information is lost as the corrupted state becomes the "most recent"

While normal data services always populate `stream_info` [7](#0-6) , the protobuf definition allows it to be absent, creating this attack surface.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under Aptos bug bounty criteria because it enables:

1. **Service Availability Degradation**: Attackers can cause indexer data services to be overwhelmed with traffic, degrading query response times or causing service failures
2. **Operational Disruption**: The indexer infrastructure provides critical query capabilities for the Aptos ecosystem, and its degradation affects user experience
3. **Load Balancing Manipulation**: Attackers can selectively target specific data services for overload

While this does not affect core blockchain consensus, fund security, or validator operations, it represents a significant availability issue for auxiliary infrastructure that requires operational intervention to resolve.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is highly feasible because:
- The GrpcManager heartbeat endpoint has no authentication or authorization
- The protobuf allows `stream_info` to be optional
- An attacker only needs network access to the GrpcManager endpoint
- The attack requires minimal sophistication (send valid protobuf with one field omitted)
- No special privileges or insider access required

The impact becomes severe during periods of high query load when load balancing is critical for maintaining service availability.

## Recommendation

**Fix: Reject heartbeats with missing stream_info instead of defaulting**

The defensive defaulting behavior should be replaced with strict validation:

```rust
fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    info: LiveDataServiceInfo,
) -> Result<()> {
    // Validate that stream_info is present
    if info.stream_info.is_none() {
        bail!("Invalid heartbeat: stream_info is required");
    }
    
    let mut entry = self
        .live_data_services
        .entry(address.clone())
        .or_insert(LiveDataService::new(address));
    entry.value_mut().recent_states.push_back(info);
    if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
        entry.value_mut().recent_states.pop_front();
    }

    Ok(())
}
```

Apply the same fix to `handle_historical_data_service_info()`. [8](#0-7) 

**Additional Hardening:**
- Consider adding authentication/authorization to the heartbeat endpoint
- Add monitoring/alerting for rejected heartbeats to detect attack attempts
- Implement rate limiting on heartbeat endpoints

## Proof of Concept

```rust
// PoC: Send malicious heartbeat to manipulate load balancing
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    service_info::Info,
    HeartbeatRequest,
    LiveDataServiceInfo,
    ServiceInfo,
};
use tonic::transport::Channel;

#[tokio::test]
async fn test_stream_info_manipulation() {
    // Connect to GrpcManager
    let channel = Channel::from_static("http://grpc-manager:50051")
        .connect()
        .await
        .unwrap();
    let mut client = GrpcManagerClient::new(channel);

    // Send heartbeat with None stream_info to target a victim service
    let malicious_info = LiveDataServiceInfo {
        chain_id: 1,
        timestamp: Some(timestamp_now_proto()),
        known_latest_version: Some(1000),
        stream_info: None, // Omit stream info - will be defaulted to 0 streams
        min_servable_version: Some(0),
    };

    let service_info = ServiceInfo {
        address: Some("victim-service:50052".to_string()),
        info: Some(Info::LiveDataServiceInfo(malicious_info)),
    };

    let request = HeartbeatRequest {
        service_info: Some(service_info),
    };

    // This succeeds and causes the victim service to appear idle
    let response = client.heartbeat(request).await.unwrap();
    
    // Now the load balancer will route excessive traffic to "victim-service:50052"
    // even if it actually has many active streams
    
    // Verify the manipulation by checking load balancing picks this service
    // (actual verification would require access to the manager's internal state)
}
```

**Notes**

This vulnerability is specific to the indexer-grpc infrastructure and does not affect core blockchain consensus, state management, or fund security. However, it represents a real availability risk for the Aptos query infrastructure that can be exploited by unprivileged attackers with network access. The fix is straightforward and should be implemented to ensure robust load balancing and prevent potential denial-of-service attacks against indexer services.

### Citations

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L39-39)
```text
  optional StreamInfo stream_info = 4;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L498-502)
```rust
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L503-506)
```rust
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L511-531)
```rust
    fn handle_historical_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: HistoricalDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .historical_data_services
            .entry(address.clone())
            .or_insert(HistoricalDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L71-88)
```rust
    fn pick_live_data_service(&self, starting_version: u64) -> Option<String> {
        let mut candidates = vec![];
        for candidate in self.metadata_manager.get_live_data_services_info() {
            if let Some(info) = candidate.1.back().as_ref() {
                // TODO(grao): Handle the case when the requested starting version is beyond the
                // latest version.
                if info.min_servable_version.is_none()
                    || starting_version < info.min_servable_version.unwrap()
                {
                    continue;
                }
                let num_active_streams = info.stream_info.as_ref().unwrap().active_streams.len();
                candidates.push((candidate.0, num_active_streams));
            }
        }

        Self::pick_data_service_from_candidate(candidates)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs (L167-180)
```rust
        let stream_info = StreamInfo {
            active_streams: self.connection_manager.get_active_streams(),
        };

        let response = if self.is_live_data_service {
            let min_servable_version = match LIVE_DATA_SERVICE.get() {
                Some(svc) => Some(svc.get_min_servable_version().await),
                None => None,
            };
            let info = LiveDataServiceInfo {
                chain_id: self.connection_manager.chain_id(),
                timestamp: Some(timestamp_now_proto()),
                known_latest_version: Some(known_latest_version),
                stream_info: Some(stream_info),
```
