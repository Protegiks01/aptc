# Audit Report

## Title
Fullnode Isolation Due to Empty Seed Configuration and Missing Discovery Method Validation

## Summary
The `create_seed_peers()` function returns an empty HashMap instead of an error when provided with an empty seed list. Combined with the absence of configuration validation for connectivity methods, this allows fullnodes to start successfully but remain completely isolated from the network, resulting in loss of liveness.

## Finding Description

The vulnerability exists in the network configuration initialization path: [1](#0-0) 

When `seed_peer_entries` is empty, the function returns `Ok(seed_peers)` where `seed_peers` is an empty HashMap. This occurs without any validation error, despite the function signature suggesting validation via `Result<PeerSet, Error>`.

The configuration optimizer only adds seeds for testnet and mainnet chains: [2](#0-1) 

For other chains (devnet, custom networks), no seeds are added. The optimizer also does not set the `discovery_method` field, which defaults to `DiscoveryMethod::None`: [3](#0-2) 

During network initialization, the empty seeds are passed to the ConnectivityManager: [4](#0-3) [5](#0-4) 

When `DiscoveryMethod::None` is configured, no discovery listeners are created: [6](#0-5) 

The config sanitizer lacks validation to ensure at least one connectivity method exists: [7](#0-6) 

**Attack Scenario:**
1. Node operator deploys a fullnode for a non-mainnet/testnet chain (e.g., devnet, custom network)
2. No manual seeds are configured in the YAML
3. No discovery method is explicitly configured (defaults to `None`)
4. Config optimizer runs but doesn't add seeds (chain is not testnet/mainnet)
5. Config sanitizer passes (no validation for empty seeds + no discovery)
6. Node starts successfully with empty `discovered_peers` set
7. Periodic connectivity checks find zero eligible peers to dial
8. Node remains permanently isolated from the network

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty criteria)

This vulnerability causes **loss of liveness** for affected nodes, qualifying as "State inconsistencies requiring intervention" under the Medium severity category. The node:
- Cannot sync blockchain state
- Cannot participate in consensus (if validator)
- Cannot serve API requests with current data
- Requires manual intervention and restart to recover

While this doesn't affect network-wide consensus or other nodes, it represents a critical operational failure for the misconfigured node. The issue is particularly insidious because:
- Configuration appears valid (no errors raised)
- Node starts successfully
- Silent failure mode with no immediate error indication
- Affects any chain except mainnet/testnet by default

## Likelihood Explanation

**Likelihood: Medium**

This issue is likely to occur in the following scenarios:
- Deploying fullnodes on devnet or custom/private networks
- Migrating configurations between different networks
- Testing new chain deployments
- Automated deployment scripts that don't explicitly set discovery methods

The issue is NOT likely for:
- Mainnet/testnet deployments (seeds are auto-configured)
- Deployments following official documentation (typically includes discovery_method: "onchain")

However, the lack of error messages or warnings makes this a silent failure that could waste significant debugging time.

## Recommendation

**Fix 1: Add validation in `create_seed_peers()`**

```rust
fn create_seed_peers(seed_peer_entries: Vec<(&str, &str, &str)>) -> Result<PeerSet, Error> {
    // Validate that seed_peer_entries is not empty
    if seed_peer_entries.is_empty() {
        return Err(Error::InvariantViolation(
            "Seed peer entries cannot be empty. Either provide seed peers or configure a discovery method.".to_string()
        ));
    }
    
    let mut seed_peers = HashMap::new();
    for (account_address, public_key, network_address) in seed_peer_entries {
        let (peer_address, peer) = build_seed_peer(account_address, public_key, network_address)?;
        seed_peers.insert(peer_address, peer);
    }
    Ok(seed_peers)
}
```

**Fix 2: Add connectivity validation in config sanitizer**

Add a new validation function in `config/src/config/config_sanitizer.rs`:

```rust
fn sanitize_network_connectivity(
    node_config: &NodeConfig,
    node_type: NodeType,
    _chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = "NetworkConnectivitySanitizer".to_string();
    
    // Only check fullnode networks for now
    for fullnode_network_config in &node_config.full_node_networks {
        let has_seeds = !fullnode_network_config.seeds.is_empty();
        let has_discovery = fullnode_network_config.discovery_methods()
            .iter()
            .any(|m| !matches!(m, DiscoveryMethod::None));
        
        if !has_seeds && !has_discovery {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "Network {} has no connectivity method configured. Either provide seed peers or configure a discovery method.",
                    fullnode_network_config.network_id
                ),
            ));
        }
    }
    
    Ok(())
}
```

Call this from `NodeConfig::sanitize()`.

**Fix 3: Update optimizer to warn or set default discovery method**

Alternatively, the optimizer could set `discovery_method: Onchain` by default for public networks on all chains, not just mainnet/testnet.

## Proof of Concept

```rust
#[cfg(test)]
mod test_connectivity_failure {
    use super::*;
    use crate::config::{NodeConfig, NetworkConfig, NodeType};
    use aptos_types::chain_id::ChainId;
    
    #[test]
    fn test_empty_seeds_returns_empty_hashmap() {
        // Call create_seed_peers with empty vector
        let result = create_seed_peers(vec![]);
        
        // Verify it returns Ok with empty HashMap (should error instead)
        assert!(result.is_ok());
        let seed_peers = result.unwrap();
        assert!(seed_peers.is_empty());
    }
    
    #[test]
    fn test_node_with_no_connectivity_method() {
        // Create a fullnode config for devnet (not mainnet/testnet)
        let mut node_config = NodeConfig {
            full_node_networks: vec![NetworkConfig {
                network_id: NetworkId::Public,
                discovery_method: DiscoveryMethod::None,  // Default
                seeds: HashMap::new(),  // Empty seeds
                ..Default::default()
            }],
            ..Default::default()
        };
        
        // Run optimizer (won't add seeds for devnet)
        let modified = optimize_public_network_config(
            &mut node_config,
            &serde_yaml::from_str("{}").unwrap(),
            NodeType::PublicFullnode,
            Some(ChainId::test()),  // Not mainnet or testnet
        ).unwrap();
        
        // Verify seeds remain empty
        assert!(!modified);  // No modifications made
        assert!(node_config.full_node_networks[0].seeds.is_empty());
        
        // Config sanitizer would pass (no validation exists)
        let sanitize_result = sanitize_fullnode_network_configs(
            &node_config,
            NodeType::PublicFullnode,
            Some(ChainId::test()),
        );
        assert!(sanitize_result.is_ok());  // This should fail but doesn't
        
        // Node would start but cannot discover any peers
        // ConnectivityManager would have discovered_peers = empty
        // choose_peers_to_dial() would return empty vector
        // Result: Complete network isolation
    }
}
```

## Notes

This vulnerability is a configuration validation gap rather than a protocol-level security flaw. However, it can cause significant operational issues and meets the Medium severity criteria due to:

1. **Silent failure mode** - No errors or warnings are generated
2. **Loss of liveness** - Affected nodes cannot sync or participate in the network
3. **Requires manual intervention** - Node must be reconfigured and restarted
4. **Easy to trigger** - Happens by default for non-mainnet/testnet deployments without explicit configuration

The recommended fixes add defense-in-depth validation at multiple layers to prevent this misconfiguration from causing silent failures.

### Citations

**File:** config/src/config/config_optimizer.rs (L203-215)
```rust
            if local_network_config_yaml["seeds"].is_null() {
                if let Some(chain_id) = chain_id {
                    if chain_id.is_testnet() {
                        fullnode_network_config.seeds =
                            create_seed_peers(TESTNET_SEED_PEERS.into())?;
                        modified_config = true;
                    } else if chain_id.is_mainnet() {
                        fullnode_network_config.seeds =
                            create_seed_peers(MAINNET_SEED_PEERS.into())?;
                        modified_config = true;
                    }
                }
            }
```

**File:** config/src/config/config_optimizer.rs (L267-279)
```rust
/// Creates and returns a set of seed peers from the given entries
fn create_seed_peers(seed_peer_entries: Vec<(&str, &str, &str)>) -> Result<PeerSet, Error> {
    // Create a map of seed peers
    let mut seed_peers = HashMap::new();

    // Add the seed peers
    for (account_address, public_key, network_address) in seed_peer_entries {
        let (peer_address, peer) = build_seed_peer(account_address, public_key, network_address)?;
        seed_peers.insert(peer_address, peer);
    }

    Ok(seed_peers)
}
```

**File:** config/src/config/network_config.rs (L128-147)
```rust
impl Default for NetworkConfig {
    fn default() -> Self {
        NetworkConfig::network_with_id(NetworkId::default())
    }
}

impl NetworkConfig {
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
            network_id,
            runtime_threads: None,
            seed_addrs: HashMap::new(),
            seeds: PeerSet::default(),
            max_frame_size: MAX_FRAME_SIZE,
```

**File:** network/builder/src/builder.rs (L207-219)
```rust
        let seeds = merge_seeds(config);

        network_builder.add_connectivity_manager(
            seeds,
            peers_and_metadata,
            config.max_outbound_connections,
            config.connection_backoff_base,
            config.max_connection_delay_ms,
            config.connectivity_check_interval_ms,
            config.network_channel_size,
            config.mutual_authentication,
            config.enable_latency_aware_dialing,
        );
```

**File:** network/builder/src/builder.rs (L386-388)
```rust
                DiscoveryMethod::None => {
                    continue;
                },
```

**File:** network/framework/src/connectivity_manager/mod.rs (L348-403)
```rust
    pub fn new(
        network_context: NetworkContext,
        time_service: TimeService,
        peers_and_metadata: Arc<PeersAndMetadata>,
        seeds: PeerSet,
        connection_reqs_tx: ConnectionRequestSender,
        connection_notifs_rx: conn_notifs_channel::Receiver,
        requests_rx: aptos_channels::Receiver<ConnectivityRequest>,
        connectivity_check_interval: Duration,
        backoff_strategy: TBackoff,
        max_delay: Duration,
        outbound_connection_limit: Option<usize>,
        mutual_authentication: bool,
        enable_latency_aware_dialing: bool,
    ) -> Self {
        // Verify that the trusted peers set exists and that it is empty
        let trusted_peers = peers_and_metadata
            .get_trusted_peers(&network_context.network_id())
            .unwrap_or_else(|error| {
                panic!("Trusted peers must exist, but found error: {:?}", error)
            });
        assert!(
            trusted_peers.is_empty(),
            "Trusted peers must be empty. Found: {:?}",
            trusted_peers
        );

        info!(
            NetworkSchema::new(&network_context),
            "{} Initialized connectivity manager", network_context
        );

        let mut connmgr = Self {
            network_context,
            time_service,
            peers_and_metadata,
            connected: HashMap::new(),
            discovered_peers: Arc::new(RwLock::new(DiscoveredPeerSet::default())),
            connection_reqs_tx,
            connection_notifs_rx,
            requests_rx,
            dial_queue: HashMap::new(),
            dial_states: HashMap::new(),
            connectivity_check_interval,
            backoff_strategy,
            max_delay,
            event_id: 0,
            outbound_connection_limit,
            mutual_authentication,
            enable_latency_aware_dialing,
        };

        // Set the initial seed config addresses and public keys
        connmgr.handle_update_discovered_peers(DiscoverySource::Config, seeds);
        connmgr
    }
```

**File:** config/src/config/config_sanitizer.rs (L111-154)
```rust
/// Sanitize the fullnode network configs according to the node role and chain ID
fn sanitize_fullnode_network_configs(
    node_config: &NodeConfig,
    node_type: NodeType,
    _chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = FULLNODE_NETWORKS_SANITIZER_NAME.to_string();
    let fullnode_networks = &node_config.full_node_networks;

    // Verify that the fullnode network configs are not empty for fullnodes
    if fullnode_networks.is_empty() && !node_type.is_validator() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Fullnode networks cannot be empty for fullnodes!".into(),
        ));
    }

    // Check each fullnode network config and ensure uniqueness
    let mut fullnode_network_ids = HashSet::new();
    for fullnode_network_config in fullnode_networks {
        let network_id = fullnode_network_config.network_id;

        // Verify that the fullnode network config is not a validator network config
        if network_id.is_validator_network() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Fullnode network configs cannot include a validator network!".into(),
            ));
        }

        // Verify that the fullnode network config is unique
        if !fullnode_network_ids.insert(network_id) {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "Each fullnode network config must be unique! Found duplicate: {}",
                    network_id
                ),
            ));
        }
    }

    Ok(())
}
```
