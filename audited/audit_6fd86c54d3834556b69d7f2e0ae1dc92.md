# Audit Report

## Title
Unimplemented Global Cross-Shard Messaging Causes Network Halt in Remote Execution Mode

## Summary
The `RemoteCrossShardClient::send_global_msg()` function is unimplemented (marked with `todo!()`), but can be triggered during normal block execution when using the default partitioning configuration. This causes the entire executor service to panic, resulting in complete loss of network liveness in distributed sharded execution mode. [1](#0-0) 

## Finding Description
The sharded block executor supports remote/distributed execution through `ExecutorService` and `RemoteCrossShardClient`. The block partitioner creates multiple execution rounds to minimize cross-shard dependencies, with a default configuration that merges remaining transactions into a "global round" (identified by `GLOBAL_ROUND_ID`). [2](#0-1) 

When a transaction in an earlier round writes to a state key that a global round transaction depends on, the cross-shard commit sender attempts to send the write value to the global round: [3](#0-2) 

However, the `RemoteCrossShardClient` implementation of `send_global_msg()` is incomplete and will panic when called. This breaks the **Total loss of liveness/network availability** invariant.

The vulnerability is triggered through the following execution path:

1. Remote sharded execution is initiated using `ExecutorService` with `RemoteCrossShardClient`
2. Block partitioning runs with default config (`partition_last_round = false`)
3. Partitioner creates transactions assigned to `GLOBAL_ROUND_ID` after discarding rounds
4. Transactions in earlier rounds (Round 0, 1, etc.) execute and commit
5. When a transaction has dependent edges to `GLOBAL_ROUND_ID`, it calls `send_global_msg()`
6. System hits `todo!()` macro and panics
7. Executor shard crashes, preventing block completion
8. Network cannot make progress - **total liveness failure**

The `receive_cross_shard_msg()` function itself does not enforce message ordering, but this vulnerability is exploitable before any messages are received, as the sender-side panic prevents message transmission entirely. [4](#0-3) 

## Impact Explanation
This is a **Critical Severity** vulnerability under the Aptos bug bounty program category: **"Total loss of liveness/network availability"** (up to $1,000,000).

When triggered:
- All executor shards using `RemoteCrossShardClient` will crash
- Block execution cannot complete
- Network cannot commit new transactions
- Requires system restart and configuration change to recover
- Affects all validators using distributed sharded execution mode

The remote executor service is production code with a dedicated binary executable: [5](#0-4) 

## Likelihood Explanation
**Likelihood: HIGH**

This vulnerability will trigger automatically under common conditions:

1. **Default Configuration**: The partitioner's default setting creates global rounds (`partition_last_round = false`)
2. **Normal Operation**: Any block with cross-shard dependencies after multiple discarding rounds will create global transactions
3. **No Attacker Required**: Natural transaction patterns can trigger this without malicious input
4. **Production Code Path**: `ExecutorService` has a main.rs binary, indicating intended production use

The only requirement is that remote sharded execution mode is enabled and the system processes blocks with sufficient complexity to require a global round. The vulnerability is deterministic - once the conditions are met, the panic is guaranteed.

## Recommendation
Implement the `send_global_msg()` function in `RemoteCrossShardClient` to properly handle cross-shard messages to the global round. The implementation should mirror the behavior of `LocalCrossShardClient`:

```rust
fn send_global_msg(&self, msg: CrossShardMsg) {
    let global_round = GLOBAL_ROUND_ID;
    // Send to the global shard (last shard)
    let global_shard = self.message_txs.len() - 1;
    let input_message = bcs::to_bytes(&msg).unwrap();
    let tx = self.message_txs[global_shard][global_round].lock().unwrap();
    tx.send(Message::new(input_message)).unwrap();
}
```

Alternatively, if global rounds are not supported in remote execution mode, the system should:
1. Force `partition_last_round = true` when using `RemoteCrossShardClient`
2. Add validation to detect and reject global round creation in remote mode
3. Fail early with a clear error message rather than panicking during execution

## Proof of Concept
```rust
// This test demonstrates the vulnerability path
#[test]
fn test_remote_global_msg_panic() {
    use aptos_executor_service::remote_executor_service::ExecutorService;
    use std::net::{SocketAddr, IpAddr, Ipv4Addr};
    
    // Create remote executor service (uses RemoteCrossShardClient)
    let shard_id = 0;
    let num_shards = 2;
    let num_threads = 4;
    let self_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8000);
    let coord_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 9000);
    let shard_addrs = vec![
        SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8001),
    ];
    
    let mut service = ExecutorService::new(
        shard_id,
        num_shards,
        num_threads,
        self_addr,
        coord_addr,
        shard_addrs,
    );
    
    // Execute a block that creates global round dependencies
    // With default partitioning config (partition_last_round = false),
    // this will create GLOBAL_ROUND_ID transactions
    // When earlier rounds try to send messages to global round,
    // send_global_msg() is called and panics with todo!()
    
    // Expected: System panics with "not yet implemented: Global cross shard message is not supported..."
}
```

To reproduce in a production-like environment:
1. Deploy multiple executor shards using the `executor-service` binary
2. Submit a block with transactions that create cross-shard dependencies across multiple rounds
3. Observe executor service crash when attempting to send global cross-shard messages

## Notes
This vulnerability highlights a fundamental gap between the local and remote execution implementations. The local executor (`LocalCrossShardClient`) properly implements global message handling, but the remote executor was left incomplete. The presence of `todo!()` in production code paths represents a critical reliability risk that should be addressed before distributed sharded execution is deployed.

### Citations

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L51-53)
```rust
    fn send_global_msg(&self, _msg: CrossShardMsg) {
        todo!("Global cross shard message is not supported yet in remote execution mode")
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L61-66)
```rust
    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** execution/block-partitioner/src/v2/config.rs (L54-64)
```rust
impl Default for PartitionerV2Config {
    fn default() -> Self {
        Self {
            num_threads: 8,
            max_partitioning_rounds: 4,
            cross_shard_dep_avoid_threshold: 0.9,
            dashmap_num_shards: 64,
            partition_last_round: false,
            pre_partitioner_config: Box::<ConnectedComponentPartitionerConfig>::default(),
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L122-130)
```rust
                    if *round_id == GLOBAL_ROUND_ID {
                        self.cross_shard_client.send_global_msg(message);
                    } else {
                        self.cross_shard_client.send_cross_shard_msg(
                            *dependent_shard_id,
                            *round_id,
                            message,
                        );
                    }
```

**File:** execution/executor-service/src/main.rs (L27-48)
```rust
fn main() {
    let args = Args::parse();
    aptos_logger::Logger::new().init();

    let (tx, rx) = crossbeam_channel::unbounded();
    ctrlc::set_handler(move || {
        tx.send(()).unwrap();
    })
    .expect("Error setting Ctrl-C handler");

    let _exe_service = ProcessExecutorService::new(
        args.shard_id,
        args.num_shards,
        args.num_executor_threads,
        args.coordinator_address,
        args.remote_executor_addresses,
    );

    rx.recv()
        .expect("Could not receive Ctrl-C msg from channel.");
    info!("Process executor service shutdown successfully.");
}
```
