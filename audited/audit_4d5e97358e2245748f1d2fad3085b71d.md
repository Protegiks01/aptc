# Audit Report

## Title
Environment Variable Bypass of Failpoint Security Controls in Production Deployments

## Summary
The `fail_point!` macro in `send_message_to_peer()` can be activated via the `FAILPOINTS` environment variable, bypassing all Aptos security controls (config sanitizer and API access restrictions) if the production binary is accidentally compiled with the `failpoints` feature enabled.

## Finding Description

The failpoint system in Aptos has multiple layers of security controls to prevent accidental activation in production:

1. **Config Sanitizer**: Rejects failpoints configuration on mainnet [1](#0-0) 
2. **API Access Control**: Requires `api.failpoints_enabled = true` to use the `/v1/set_failpoint` endpoint [2](#0-1) 

However, the underlying `fail` crate (version 0.5.0) [3](#0-2)  supports automatic configuration via the `FAILPOINTS` environment variable at process initialization, **before** any Aptos validation code executes.

The specific failpoint in question is located in the mempool network layer [4](#0-3) . When triggered, it causes `send_message_to_peer()` to return an error instead of sending messages to peers. This function is used to send ACK responses after receiving transactions [5](#0-4) .

**Attack Path:**
1. Production binary accidentally compiled with `--features failpoints` [6](#0-5) 
2. Attacker gains control over environment variables (container orchestration, systemd service, etc.)
3. Attacker sets `FAILPOINTS=mempool::send_to=return`
4. Node starts; fail crate automatically configures failpoint from environment
5. Config sanitizer runs but cannot detect environment-configured failpoints
6. All calls to `send_message_to_peer()` fail, breaking mempool ACK responses
7. Node cannot participate in mempool synchronization

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria for "Validator node slowdowns" and "Significant protocol violations")

- **Single Node Impact**: Cannot send mempool ACKs to peers, disrupting its mempool participation
- **Network Impact**: If multiple nodes are affected, could disrupt transaction propagation
- **No Consensus Impact**: Consensus uses separate networking; mempool disruption doesn't affect safety
- **No State Integrity Impact**: Does not corrupt storage or violate consensus invariants
- **Availability Impact**: Reduces network liveness for transaction dissemination

This is classified as High severity rather than Critical because it:
- Does not cause consensus safety violations
- Does not result in fund loss or theft
- Affects availability but not integrity
- Requires infrastructure-level access to exploit

## Likelihood Explanation

**Likelihood: Low-to-Medium**

The attack requires three conditions:
1. **Build Process Failure**: Production binary compiled with failpoints feature (should never occur with proper CI/CD)
2. **Infrastructure Compromise**: Attacker controls environment variables (requires privileged access to deployment systems)
3. **Monitoring Gap**: Failpoint activation is logged [7](#0-6)  but not detected/alerted

While each condition individually has low probability, the environment variable bypass is concerning because:
- It's not documented in security documentation
- No explicit validation of `FAILPOINTS` environment variable exists
- Aptos security controls assume fail::cfg() is the only activation path

## Recommendation

**Immediate Mitigations:**
1. Add environment variable validation at node startup to detect and reject `FAILPOINTS` env var on mainnet
2. Document the environment variable attack vector in security guidelines
3. Implement monitoring/alerting for failpoint activation warnings

**Long-term Solutions:**
1. Remove failpoints feature from production build profiles completely
2. Use compile-time feature gates that make failpoints a hard compile error in release mode
3. Consider forking the `fail` crate to remove environment variable support

**Code Fix:**
```rust
// In aptos-node/src/lib.rs, after line 273:
if fail::has_failpoints() {
    // Check for FAILPOINTS environment variable
    if std::env::var("FAILPOINTS").is_ok() && chain_id.is_mainnet() {
        panic!("FAILPOINTS environment variable detected on mainnet! This is not allowed.");
    }
}
```

## Proof of Concept

**Scenario**: Mainnet node accidentally deployed with failpoints compiled in

```bash
# Step 1: Compile with failpoints (accidental)
cargo build --release --features failpoints

# Step 2: Attacker sets environment variable
export FAILPOINTS="mempool::send_to=return"

# Step 3: Start node
./target/release/aptos-node --config mainnet-config.yaml

# Result: All mempool ACKs fail with "Injected error in mempool::send_to"
# Node logs show failpoint activation warning but continues running
# Mempool synchronization is broken for this node
```

**Test Case** (Rust):
```rust
#[test]
#[cfg(feature = "failpoints")]
fn test_failpoint_environment_bypass() {
    std::env::set_var("FAILPOINTS", "mempool::send_to=return");
    
    // Simulate node startup - failpoint is active before any validation
    assert!(fail::has_failpoints());
    
    // Call send_message_to_peer - should fail
    let result = network_interface.send_message_to_peer(peer, message);
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Injected error"));
}
```

## Notes

This vulnerability is a defense-in-depth bypass rather than a direct code flaw. The primary mitigation is ensuring production builds never include the failpoints feature, which should be enforced through CI/CD pipeline controls. However, the lack of runtime protection against environment variable activation represents a gap in Aptos's security model that should be addressed.

### Citations

**File:** config/src/config/config_sanitizer.rs (L83-90)
```rust
    let failpoints_enabled = are_failpoints_enabled();
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
```

**File:** api/src/set_failpoints.rs (L27-39)
```rust
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
```

**File:** Cargo.toml (L616-616)
```text
fail = "0.5.0"
```

**File:** mempool/src/shared_mempool/network.rs (L605-607)
```rust
        fail_point!("mempool::send_to", |_| {
            Err(anyhow::anyhow!("Injected error in mempool::send_to").into())
        });
```

**File:** mempool/src/shared_mempool/tasks.rs (L238-241)
```rust
    if let Err(e) = smp
        .network_interface
        .send_message_to_peer(peer, ack_response)
    {
```

**File:** mempool/Cargo.toml (L65-65)
```text
failpoints = ["fail/failpoints", "aptos-vm-validator/failpoints"]
```

**File:** aptos-node/src/lib.rs (L257-258)
```rust
    if fail::has_failpoints() {
        warn!("Failpoints are enabled!");
```
