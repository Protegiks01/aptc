# Audit Report

## Title
Consensus Safety Violation: OnChainConsensusConfig Schema Upgrade Breaks Deterministic Execution via Silent Deserialization Fallback

## Summary
The native function `validator_txn_enabled_internal()` uses `.unwrap_or_default()` when deserializing on-chain consensus configuration bytes. During protocol upgrades that introduce new OnChainConsensusConfig schema versions, validators running older binaries will fail to deserialize the new format and silently fall back to a default configuration where validator transactions are disabled. This causes different validators to execute governance transactions differently, violating deterministic execution and triggering consensus failure.

## Finding Description

The vulnerability exists in the native Rust implementation of `validator_txn_enabled_internal()` which is called by Move framework code during transaction execution: [1](#0-0) 

This function deserializes the on-chain consensus configuration and returns whether validator transactions are enabled. The critical issue is the use of `.unwrap_or_default()` on line 19, which silently returns a default configuration when deserialization fails.

The default OnChainConsensusConfig has validator transactions **disabled**: [2](#0-1) [3](#0-2) 

The OnChainConsensusConfig is an enum that has evolved from V1 to V5: [4](#0-3) 

When BCS deserialization encounters an unknown enum variant (e.g., V6 on a node that only knows V1-V5), it fails with an error. The `.unwrap_or_default()` catches this error and returns the default config without logging or alerting.

**The Attack Scenario:**

During a protocol upgrade that introduces V6:

1. Current network runs with V5 config where `vtxn: ValidatorTxnConfig::V1 { ... }` (enabled)
2. Framework upgrade adds V6 schema support
3. Governance proposal updates on-chain config to V6
4. Some validators have upgraded their binaries (know V1-V6), others haven't (know V1-V5)
5. Transaction `aptos_governance::reconfigure()` executes on all validators: [5](#0-4) 

6. The function calls `consensus_config::validator_txn_enabled()`: [6](#0-5) 

7. **On upgraded validators**: Deserialization succeeds, returns `true`, executes `reconfiguration_with_dkg::try_start()`
8. **On old validators**: Deserialization fails, returns default with vtxn=false, returns `false`, executes `reconfiguration_with_dkg::finish()`

This causes different validators to execute **different code paths** in the same transaction, producing **different state roots** and **breaking consensus**.

The same vulnerability exists in the consensus epoch manager: [7](#0-6) 

## Impact Explanation

This is **Critical Severity** per the Aptos bug bounty program, meeting the "Consensus/Safety violations" category (up to $1,000,000).

**Broken Invariant**: Deterministic Execution - "All validators must produce identical state roots for identical blocks"

**Impact**:
- **Consensus split**: Validators on different software versions cannot agree on the correct state root for blocks containing governance transactions
- **Network partition**: The network splits into two incompatible chains until manual intervention
- **Requires hard fork**: Recovery requires coordinating all validators to roll back or fast-forward to a common state
- **Complete loss of liveness**: No new blocks can be committed while validators disagree on state

**Affected transactions**: Any transaction calling `consensus_config::validator_txn_enabled()`, most critically `aptos_governance::reconfigure()` which is executed for every governance proposal affecting on-chain configuration.

## Likelihood Explanation

**Likelihood: High** - This will occur during every protocol upgrade that adds a new OnChainConsensusConfig variant.

**Evidence of ongoing evolution**: The enum has already grown from V1 (initial) to V5 (current), with each version adding new fields (vtxn config in V3, window_size in V4, rand_check_enabled in V5). Future V6, V7, etc. are inevitable as the protocol evolves.

**Why this will happen**:
1. Protocol upgrades are routine operations
2. Validators upgrade binaries at different times during rolling deployments
3. There is always a window where some validators run old code and some run new code
4. Governance proposals can execute during this mixed-version window
5. No validation prevents config schema mismatches

**No attack required**: This occurs naturally during legitimate protocol upgrades, not from malicious action.

## Recommendation

Replace `.unwrap_or_default()` with explicit error handling that **fails loudly** rather than silently returning incorrect values:

```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    
    // NEVER fall back to default on deserialization failure
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes)
        .map_err(|e| {
            PartialVMError::new(StatusCode::FAILED_TO_DESERIALIZE_RESOURCE)
                .with_message(format!("Failed to deserialize OnChainConsensusConfig: {}", e))
                .finish(Location::Undefined)
        })?;
    
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

Similarly, in epoch_manager.rs, fail the epoch transition rather than silently using defaults:

```rust
let consensus_config = onchain_consensus_config
    .map_err(|e| anyhow!("Failed to deserialize OnChainConsensusConfig: {}", e))?;
```

**Process improvements**:
1. Add compatibility checking before applying config upgrades
2. Require minimum validator version before enabling new config schemas
3. Add monitoring/alerts for deserialization failures
4. Implement config version negotiation during epoch transitions

## Proof of Concept

```rust
#[test]
fn test_forward_compatibility_failure() {
    use aptos_types::on_chain_config::OnChainConsensusConfig;
    
    // Simulate V5 config with validator transactions enabled
    let v5_config = OnChainConsensusConfig::V5 {
        alg: ConsensusAlgorithmConfig::default_for_genesis(),
        vtxn: ValidatorTxnConfig::V1 {
            per_block_limit_txn_count: 2,
            per_block_limit_total_bytes: 2097152,
        },
        window_size: None,
        rand_check_enabled: true,
    };
    
    // Serialize as BCS bytes
    let config_bytes = bcs::to_bytes(&v5_config).unwrap();
    
    // Verify V5 deserializes correctly and vtxn is enabled
    let deserialized_v5: OnChainConsensusConfig = 
        bcs::from_bytes(&config_bytes).unwrap();
    assert!(deserialized_v5.is_vtxn_enabled());
    
    // Simulate future V6 enum variant by creating malformed bytes
    // that old nodes cannot deserialize
    let mut v6_bytes = vec![5u8]; // variant tag 5 = unknown to V1-V5 code
    v6_bytes.extend_from_slice(&config_bytes[1..]); // rest of data
    
    // Attempt deserialization with code that only knows V1-V5
    // This simulates old validator trying to read V6 config
    let result = bcs::from_bytes::<OnChainConsensusConfig>(&v6_bytes);
    
    // Deserialization FAILS with unknown variant
    assert!(result.is_err());
    
    // Current code uses .unwrap_or_default(), which returns V4 with vtxn DISABLED
    let default_config = result.unwrap_or_default();
    assert!(!default_config.is_vtxn_enabled()); // DISABLED!
    
    // This proves different validators get different results:
    // - Upgraded validators: is_vtxn_enabled() returns true
    // - Old validators: is_vtxn_enabled() returns false
    // - Consensus breaks when executing aptos_governance::reconfigure()
}
```

**Move-level demonstration**: Deploy a test that calls `consensus_config::validator_txn_enabled()` in a transaction and observe different validators producing different transaction outputs when config schema is incompatible.

### Citations

**File:** aptos-move/framework/src/natives/consensus_config.rs (L13-21)
```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).unwrap_or_default();
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L147-149)
```rust
    pub fn default_if_missing() -> Self {
        Self::V0
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L190-213)
```rust
/// The on-chain consensus config, in order to be able to add fields, we use enum to wrap the actual struct.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum OnChainConsensusConfig {
    V1(ConsensusConfigV1),
    V2(ConsensusConfigV1),
    V3 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
    },
    V4 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
    },
    V5 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
        // Whether to check if we can skip generating randomness for blocks
        rand_check_enabled: bool,
    },
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L71-76)
```text
    public fun validator_txn_enabled(): bool acquires ConsensusConfig {
        let config_bytes = borrow_global<ConsensusConfig>(@aptos_framework).config;
        validator_txn_enabled_internal(config_bytes)
    }

    native fun validator_txn_enabled_internal(config_bytes: vector<u8>): bool;
```

**File:** consensus/src/epoch_manager.rs (L1178-1201)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
```
