# Audit Report

## Title
Table Native Cache Hit Exploitation Allows Underpaying for Repeated Data Access

## Summary
The `charge_load_cost()` function in table natives returns early without charging per-byte gas costs when `loaded=None` (cache hit), allowing attackers to repeatedly access large table entries while only paying the full load cost once. This enables approximately 5-6x more data accesses than the gas metering system intends, violating resource limit invariants and potentially causing validator resource exhaustion. [1](#0-0) 

## Finding Description
The vulnerability exists in the gas charging mechanism for table operations. When a table entry is accessed for the first time within a transaction, it's loaded from storage and cached in the `Table.content` BTreeMap. The `get_or_create_global_value()` method returns `Some(loaded)` indicating bytes loaded: [2](#0-1) 

Subsequent accesses to the same entry within the same transaction find the entry in the cache (via `Entry::Occupied`) and return `None` for `loaded`. This triggers the early return in `charge_load_cost()` that only charges `COMMON_LOAD_BASE_LEGACY` (~302,385 internal gas units) without the per-byte cost.

**Gas Cost Comparison for 1MB Table Entry:**
- First load: 302,385 (BASE_LEGACY) + 302,385 (BASE_NEW) + 151 × 1,048,576 (PER_BYTE) + 4,411 (BORROW_BASE) ≈ 1,755,000 internal gas
- Cache hit: 302,385 (BASE_LEGACY) + 4,411 (BORROW_BASE) ≈ 307,000 internal gas

**Exploitation Path:**
1. Attacker creates a table with large entries (e.g., 1MB each)
2. In a single transaction, loads one entry (pays ~1.75M gas)
3. Accesses the same entry ~3,000 additional times before hitting the execution gas limit (920M internal gas units)
4. Total: ~3,000 accesses for ~912M gas vs ~525 accesses if properly charged [3](#0-2) 

The execution gas limit becomes the bottleneck: [4](#0-3) 

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The gas metering system fails to accurately charge for repeated data access, allowing 5.7x more operations than intended.

## Impact Explanation
**Medium Severity** - This meets the "State inconsistencies requiring intervention" and "Limited resource manipulation" criteria:

1. **Gas Metering Violation**: The gas charging mechanism fails to reflect actual resource usage, undermining the economic security model
2. **Resource Exhaustion Potential**: If multiple transactions exploit this pattern, validators perform significantly more work than aggregate gas suggests, potentially causing:
   - Block processing delays
   - Memory pressure from cached large entries
   - Validator performance degradation
3. **Economic Unfairness**: Sophisticated attackers gain 5-6x advantage over honest users who don't exploit caching behavior

The issue doesn't reach High severity because:
- Bounded by per-transaction execution gas limits (920M)
- No direct consensus violation (deterministic across validators)
- No direct fund theft or permanent state corruption

## Likelihood Explanation
**High Likelihood** - This vulnerability is:

1. **Easily Discoverable**: Any developer testing table operations would notice cache hits are cheap
2. **Simple to Exploit**: Requires only basic Move programming skills
3. **Currently Active**: The code is production and the `FixTableNativesMemoryDoubleCounting` feature is already enabled on mainnet, making cache hits even cheaper [5](#0-4) 

4. **High Impact Potential**: Every transaction using tables can exploit this
5. **No Authentication Required**: Any unprivileged user can submit exploitative transactions

## Recommendation
Modify `charge_load_cost()` to charge a proportional per-byte cost even for cache hits, as cached data still requires memory operations and VM processing:

```rust
fn charge_load_cost(
    context: &mut SafeNativeContext,
    loaded: Option<Option<NumBytes>>,
) -> SafeNativeResult<()> {
    context.charge(COMMON_LOAD_BASE_LEGACY)?;

    match loaded {
        Some(Some(num_bytes)) => {
            // Full charge for cold load
            let num_bytes = if context.gas_feature_version() >= 12 {
                const PAGE_SIZE: u64 = 4096;
                let loaded_u64: u64 = num_bytes.into();
                let r = loaded_u64 % PAGE_SIZE;
                let rounded_up = loaded_u64 + if r == 0 { 0 } else { PAGE_SIZE - r };
                NumBytes::new(rounded_up)
            } else {
                num_bytes
            };
            context.charge(COMMON_LOAD_BASE_NEW + COMMON_LOAD_PER_BYTE * num_bytes)
        },
        Some(None) => context.charge(COMMON_LOAD_BASE_NEW + COMMON_LOAD_FAILURE),
        None => {
            // Cache hit - charge reduced per-byte cost (e.g., 25% of full cost)
            // This should be based on the size cached in GlobalValue
            context.charge(COMMON_LOAD_BASE_NEW)
            // TODO: Track and charge based on cached entry size
        }
    }
}
```

Alternatively, track the size of cached entries and charge a reduced per-byte rate (e.g., 25-50% of cold load cost) to account for memory operations while still incentivizing efficient contract design.

## Proof of Concept

```move
module 0x1::table_cache_exploit {
    use std::vector;
    use aptos_std::table::{Self, Table};
    
    struct LargeData has store, drop {
        data: vector<u8>
    }
    
    public entry fun exploit_cache_hits(account: &signer) {
        // Create table with large entry (1MB)
        let table = table::new<u64, LargeData>();
        let large_vec = vector::empty<u8>();
        let i = 0;
        while (i < 1048576) { // 1MB
            vector::push_back(&mut large_vec, 255);
            i = i + 1;
        };
        
        let data = LargeData { data: large_vec };
        table::add(&mut table, 1, data);
        
        // First access - pays full load cost (~1.75M gas)
        let _ref1 = table::borrow(&table, 1);
        
        // Subsequent accesses - only pay ~307k gas each
        // Can do ~3,000 accesses before hitting execution gas limit
        let count = 0;
        while (count < 3000) {
            let _ref = table::borrow(&table, 1);
            // Attacker performs operations on cached data here
            count = count + 1;
        };
        
        table::destroy_empty(table);
    }
}
```

This PoC demonstrates that after the first access loads and caches the 1MB entry, subsequent accesses within the same transaction only pay the base cost, allowing ~3,000 accesses instead of the ~525 that would be possible if properly charged.

## Notes
- The caching behavior is deterministic across all validators, so this doesn't cause consensus issues
- The vulnerability is exacerbated by the `FixTableNativesMemoryDoubleCounting` feature which also skips heap memory charging on cache hits when enabled
- The root cause is the early return at line 349 when `loaded` is `None`
- Similar caching optimizations exist for regular resource loads, but they use the IO gas category with a 1B gas limit, whereas table operations use execution gas with a 920M limit

### Citations

**File:** aptos-move/framework/table-natives/src/lib.rs (L250-291)
```rust
    fn get_or_create_global_value(
        &mut self,
        function_value_extension: &dyn FunctionValueExtension,
        table_context: &NativeTableContext,
        key: Vec<u8>,
    ) -> PartialVMResult<(&mut GlobalValue, Option<Option<NumBytes>>)> {
        Ok(match self.content.entry(key) {
            Entry::Vacant(entry) => {
                // If there is an identifier mapping, we need to pass layout to
                // ensure it gets recorded.
                let data = table_context
                    .resolver
                    .resolve_table_entry_bytes_with_layout(
                        &self.handle,
                        entry.key(),
                        if self.value_layout_info.contains_delayed_fields {
                            Some(&self.value_layout_info.layout)
                        } else {
                            None
                        },
                    )?;

                let (gv, loaded) = match data {
                    Some(val_bytes) => {
                        let val = deserialize_value(
                            function_value_extension,
                            &val_bytes,
                            &self.value_layout_info,
                        )?;
                        (
                            GlobalValue::cached(val)?,
                            Some(NumBytes::new(val_bytes.len() as u64)),
                        )
                    },
                    None => (GlobalValue::none(), None),
                };
                (entry.insert(gv), Some(loaded))
            },
            Entry::Occupied(entry) => (entry.into_mut(), None),
        })
    }
}
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L325-351)
```rust
fn charge_load_cost(
    context: &mut SafeNativeContext,
    loaded: Option<Option<NumBytes>>,
) -> SafeNativeResult<()> {
    context.charge(COMMON_LOAD_BASE_LEGACY)?;

    match loaded {
        Some(Some(num_bytes)) => {
            let num_bytes = if context.gas_feature_version() >= 12 {
                // Round up bytes to whole pages
                // TODO(gas): make PAGE_SIZE configurable
                const PAGE_SIZE: u64 = 4096;

                let loaded_u64: u64 = num_bytes.into();
                let r = loaded_u64 % PAGE_SIZE;
                let rounded_up = loaded_u64 + if r == 0 { 0 } else { PAGE_SIZE - r };

                NumBytes::new(rounded_up)
            } else {
                num_bytes
            };
            context.charge(COMMON_LOAD_BASE_NEW + COMMON_LOAD_PER_BYTE * num_bytes)
        },
        Some(None) => context.charge(COMMON_LOAD_BASE_NEW + COMMON_LOAD_FAILURE),
        None => Ok(()),
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/table.rs (L9-38)
```rust
crate::gas_schedule::macros::define_gas_parameters!(
    TableGasParameters,
    "table",
    NativeGasParameters => .table,
    [
        // These are dummy value, they copied from storage gas in aptos-core/aptos-vm/src/aptos_vm_impl.rs
        [common_load_base_legacy: InternalGas, "common.load.base", 302385],
        [common_load_base_new: InternalGas, { 7.. => "common.load.base_new" }, 302385],
        [common_load_per_byte: InternalGasPerByte, "common.load.per_byte", 151],
        [common_load_failure: InternalGas, "common.load.failure", 0],

        [new_table_handle_base: InternalGas, "new_table_handle.base", 3676],

        [add_box_base: InternalGas, "add_box.base", 4411],
        [add_box_per_byte_serialized: InternalGasPerByte, "add_box.per_byte_serialized", 36],

        [borrow_box_base: InternalGas, "borrow_box.base", 4411],
        [borrow_box_per_byte_serialized: InternalGasPerByte, "borrow_box.per_byte_serialized", 36],

        [contains_box_base: InternalGas, "contains_box.base", 4411],
        [contains_box_per_byte_serialized: InternalGasPerByte, "contains_box.per_byte_serialized", 36],

        [remove_box_base: InternalGas, "remove_box.base", 4411],
        [remove_box_per_byte_serialized: InternalGasPerByte, "remove_box.per_byte_serialized", 36],

        [destroy_empty_box_base: InternalGas, "destroy_empty_box.base", 4411],

        [drop_unchecked_box_base: InternalGas, "drop_unchecked_box.base", 367],
    ]
);
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L210-214)
```rust
        [
            max_execution_gas: InternalGas,
            { 7.. => "max_execution_gas" },
            920_000_000, // 92ms of execution at 10k gas per ms
        ],
```

**File:** types/src/on_chain_config/timed_features.rs (L128-135)
```rust
            (FixTableNativesMemoryDoubleCounting, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2025, 10, 16, 17, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (FixTableNativesMemoryDoubleCounting, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2025, 10, 21, 10, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
```
