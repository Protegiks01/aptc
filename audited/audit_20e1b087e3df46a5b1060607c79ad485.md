# Audit Report

## Title
JWK Observer Lacks HTTP Timeout Configuration, Enabling Network-Based Denial of Service for Keyless Authentication

## Summary
The JWK observer component, responsible for fetching JSON Web Keys from OIDC providers, creates HTTP clients without timeout configuration. This allows network-level attackers to cause indefinite hangs in JWK fetching, preventing timely JWK updates and causing denial of service for keyless authentication users.

## Finding Description

The JWK consensus system is critical for keyless authentication in Aptos. Validators periodically fetch JWKs from OIDC providers (Google, Facebook, etc.) and use consensus to update the on-chain JWK set. When OIDC providers rotate their keys, validators must observe and agree on the new keys for users to authenticate.

**The vulnerability exists in the HTTP client configuration:** [1](#0-0) [2](#0-1) 

The `reqwest::Client::new()` call creates an HTTP client with **no timeout configuration**. This means HTTP requests can hang indefinitely on:
- DNS resolution failures
- TCP connection establishment delays
- Slow/unresponsive servers
- Network congestion or packet loss

**The observer silently ignores fetch failures:** [3](#0-2) 

When fetching fails, the error is logged but no observation is pushed to the consensus manager. The observer continues with its periodic interval.

**Validators require identical JWK views to reach consensus:** [4](#0-3) 

This strict equality check means if some validators observe new JWKs while others are stuck with stale JWKs (due to hanging HTTP requests), they cannot reach consensus.

**JWT validation requires up-to-date JWKs:** [5](#0-4) 

If the JWK for a JWT's `kid` (key ID) is not found on-chain, the transaction is rejected with an invalid signature error.

**Attack Scenario:**

1. An attacker with network-level capabilities (BGP hijacking, DNS manipulation, or ISP-level control) degrades network paths between validators and OIDC providers
2. Some validators' HTTP requests hang indefinitely (no timeout configured)
3. OIDC provider rotates keys (standard security practice)
4. Validators with working network paths observe new JWKs
5. Validators with degraded paths remain stuck with stale JWKs or no observations
6. Validators cannot reach consensus on JWK updates (divergent views violate equality check)
7. If >1/3 validators are affected, JWK updates cannot achieve quorum
8. On-chain JWKs become stale
9. Users with JWTs signed by new keys cannot authenticate
10. **Denial of Service**: Keyless authentication is broken until network issues resolve

**Evidence that chaos testing has not been performed:**

No tests exist for network conditions like timeouts, latency, or packet loss in the JWK consensus codebase. The smoke tests use local dummy HTTP servers with no network degradation simulation.

## Impact Explanation

This vulnerability meets **MEDIUM to HIGH severity** criteria:

**MEDIUM Severity aspects:**
- State inconsistencies requiring intervention (stale on-chain JWKs vs actual provider JWKs)
- Limited impact scope (affects only keyless authentication, not core blockchain consensus)

**HIGH Severity aspects:**
- Validator node slowdowns (hanging HTTP requests block observer threads)
- Significant protocol violations (JWK consensus liveness failure)
- Denial of service for legitimate users (keyless authentication unavailable)

While this doesn't directly affect fund security or core blockchain consensus, it causes significant availability issues for keyless authentication, which is a critical user-facing feature. The severity is elevated because:

1. Keyless authentication is designed for mainstream adoption, so unavailability affects many users
2. The attack can persist until network issues are manually resolved
3. Multiple validators can be simultaneously affected
4. The vulnerability is in production code with no defensive measures

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Factors increasing likelihood:**
- Network issues naturally occur (congestion, routing problems, DNS failures)
- OIDC providers regularly rotate keys for security
- No timeout means any network delay can cause issues
- Attack requires only network-level capabilities (BGP, DNS), not validator access
- Multiple OIDC providers increases attack surface
- Geographic diversity of validators increases probability of network issues

**Factors decreasing likelihood:**
- Requires network-level attack capabilities or natural network failures
- Validators typically have reliable network infrastructure
- Multiple validators must be affected simultaneously for quorum failure
- OIDC providers generally have high availability

The vulnerability is particularly concerning because even natural network issues (not malicious attacks) can trigger it, and there are no safeguards to recover automatically.

## Recommendation

**Immediate Fix:** Add timeout configuration to HTTP clients in the JWK fetching code.

```rust
// In crates/jwk-utils/src/lib.rs

pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    // Configure client with reasonable timeout (15 seconds is common in codebase)
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(15))
        .build()?;
    
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}

pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(15))
        .build()?;
    
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

**Additional Hardening:**

1. **Implement retry logic with exponential backoff** for transient failures
2. **Add circuit breaker pattern** to detect consistently failing providers
3. **Implement fallback mechanisms** to use cached JWKs temporarily
4. **Add monitoring and alerting** for JWK fetch failures across validators
5. **Create chaos engineering tests** specifically for network conditions:
   - Network partition scenarios
   - High latency (200ms+)
   - Packet loss (10-50%)
   - Timeout scenarios
   - DNS resolution failures

**Reference implementations in codebase:** [6](#0-5) [7](#0-6) 

These files demonstrate proper timeout configuration patterns used elsewhere in the codebase (typically 10-15 seconds).

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// Add to: crates/aptos-jwk-consensus/src/jwk_observer.rs

#[cfg(test)]
mod network_timeout_tests {
    use super::*;
    use tokio::time::{timeout, Duration};
    use std::sync::Arc;
    use tokio::sync::Mutex;
    
    // Simulates a hanging HTTP server
    async fn start_hanging_server() -> String {
        use warp::Filter;
        
        let route = warp::path!("config")
            .map(|| {
                // Never respond - simulate network hang
                tokio::time::sleep(Duration::from_secs(3600)).await;
                warp::reply::json(&"should never reach here")
            });
        
        let (addr, server) = warp::serve(route)
            .bind_with_graceful_shutdown(([127, 0, 0, 1], 0), async {
                tokio::signal::ctrl_c().await.ok();
            });
        
        tokio::spawn(server);
        format!("http://127.0.0.1:{}/config", addr.port())
    }
    
    #[tokio::test]
    async fn test_jwk_fetch_hangs_without_timeout() {
        let hanging_url = start_hanging_server().await;
        
        // This will hang indefinitely without timeout
        let fetch_result = timeout(
            Duration::from_secs(5),
            fetch_jwks_uri_from_openid_config(&hanging_url)
        ).await;
        
        // Without timeout in the HTTP client, this will timeout at the test level
        assert!(fetch_result.is_err(), "Fetch should timeout at test level due to no HTTP client timeout");
    }
    
    #[tokio::test]
    async fn test_observer_continues_with_failed_fetches() {
        let hanging_url = start_hanging_server().await;
        let (tx, mut rx) = aptos_channel::new(QueueStyle::KLAST, 10, None);
        
        // Spawn observer with very short interval
        let observer = JWKObserver::spawn(
            1, // epoch
            AccountAddress::random(),
            "test_issuer".to_string(),
            hanging_url,
            Duration::from_millis(100), // short interval
            tx,
        );
        
        // Wait and check that no observations are received
        tokio::time::sleep(Duration::from_secs(2)).await;
        
        let received = timeout(Duration::from_millis(100), rx.select_next_some()).await;
        assert!(received.is_err(), "No observations should be received from hanging server");
        
        observer.shutdown().await;
    }
    
    #[tokio::test] 
    async fn test_divergent_views_prevent_consensus() {
        // This test would demonstrate that validators with different JWK observations
        // cannot reach consensus due to the strict equality check in observation_aggregation.rs
        
        // Setup would require:
        // 1. Multiple mock validators
        // 2. Some fetching from fast server (new JWKs)
        // 3. Some fetching from slow/hanging server (stale JWKs)
        // 4. Attempt consensus aggregation
        // 5. Verify that quorum cannot be reached
        
        // This demonstrates the security impact: network issues -> divergent views -> no consensus -> stale on-chain JWKs -> auth failures
    }
}
```

**Notes:**
- The actual codebase uses `reqwest::Client` without any timeout configuration in JWK fetching
- Other parts of the codebase (REST clients, faucet, pepper service) properly configure 10-15 second timeouts
- No chaos engineering tests exist for JWK consensus under adverse network conditions
- The vulnerability can be triggered by natural network issues, not just malicious attacks
- The impact is amplified by the strict equality requirement in consensus aggregation

### Citations

**File:** crates/jwk-utils/src/lib.rs (L29-29)
```rust
    let client = reqwest::Client::new();
```

**File:** crates/jwk-utils/src/lib.rs (L41-41)
```rust
    let client = reqwest::Client::new();
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L74-83)
```rust
                    let result = fetch_jwks(open_id_config_url.as_str(), my_addr).await;
                    debug!(issuer = issuer, "observe_result={:?}", result);
                    let secs = timer.elapsed().as_secs_f64();
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
                    } else {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "err"]).observe(secs);
                    }
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-84)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L121-126)
```rust
    let jwk_move_struct = jwks.get_jwk(&pk.iss_val, &jwt_header.kid).map_err(|_| {
        invalid_signature!(format!(
            "JWK for {} with KID {} was not found",
            pk.iss_val, jwt_header.kid
        ))
    })?;
```

**File:** keyless/pepper/service/src/utils.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use anyhow::{anyhow, ensure};
use hyper::{Body, Request};
use reqwest::Client;
use std::time::Duration;

// Timeout for client requests
const CLIENT_REQUEST_TIMEOUT_SECS: u64 = 15;

// Origin header constants
const MISSING_ORIGIN_STRING: &str = ""; // Default to empty string if origin header is missing
const ORIGIN_HEADER: &str = "origin";

/// Creates and returns a reqwest HTTP client with a timeout
pub fn create_request_client() -> Client {
    Client::builder()
        .timeout(Duration::from_secs(CLIENT_REQUEST_TIMEOUT_SECS))
        .build()
        .expect("Failed to build the request client!")
}

/// Extracts the origin header from the request
pub fn get_request_origin(request: &Request<Body>) -> String {
    request
        .headers()
        .get(ORIGIN_HEADER)
        .and_then(|header_value| header_value.to_str().ok())
        .unwrap_or(MISSING_ORIGIN_STRING)
        .to_owned()
}

/// Converts a hex-encoded string (with "0x" prefix) to a byte vector
pub fn unhexlify_api_bytes(api_output: &str) -> anyhow::Result<Vec<u8>> {
    // Verify the input format
    ensure!(api_output.len() >= 2);
    let lower = api_output.to_lowercase();
    ensure!(&lower[0..2] == "0x");

    // Decode the hex string
    hex::decode(&lower[2..]).map_err(|error| {
        anyhow!(
            "unhexlify_api_bytes() failed to decode intput {}! Error: {}",
            lower,
            error
        )
    })
}

```

**File:** crates/aptos-rest-client/src/faucet.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{error::FaucetClientError, Client, Result};
use aptos_types::transaction::SignedTransaction;
use move_core_types::account_address::AccountAddress;
use reqwest::{Client as ReqwestClient, Response, Url};
use std::time::Duration;

pub struct FaucetClient {
    faucet_url: Url,
    inner: ReqwestClient,
    rest_client: Client,
    token: Option<String>,
}

impl FaucetClient {
    pub fn new(faucet_url: Url, rest_url: Url) -> Self {
        Self::new_from_rest_client(faucet_url, Client::new(rest_url))
    }

    pub fn new_for_testing(faucet_url: Url, rest_url: Url) -> Self {
        Self {
            faucet_url,
            inner: ReqwestClient::builder()
                .timeout(Duration::from_secs(10))
                .build()
                .unwrap(),
            rest_client: Client::new(rest_url)
                // By default the path is prefixed with the version, e.g. `v1`.
                // The fake API used in the faucet tests doesn't have a
                // versioned API however, so we just set it to `/`.
                .version_path_base("/".to_string())
                .unwrap(),
            token: None,
        }
    }

    pub fn new_from_rest_client(faucet_url: Url, rest_client: Client) -> Self {
        Self {
            faucet_url,
            inner: ReqwestClient::builder()
                .timeout(Duration::from_secs(10))
                .build()
                .unwrap(),
            rest_client,
            token: None,
        }
    }

```
