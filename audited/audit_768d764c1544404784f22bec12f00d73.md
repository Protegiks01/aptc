# Audit Report

## Title
Race Condition in Concurrent Prover Dependencies Installation Leading to File Corruption and Resource Exhaustion

## Summary
The `ProverDependencyInstaller::execute()` function lacks synchronization mechanisms to prevent concurrent executions from causing race conditions during the installation of prover dependencies (Boogie, Z3, and CVC5). Multiple simultaneous installations can result in corrupted binaries, wasted network bandwidth, and excessive disk I/O.

## Finding Description

The `execute()` method calls `self.download_dependency().await` without any locking mechanism to serialize concurrent executions. [1](#0-0) 

When multiple processes or threads invoke this command simultaneously, they all attempt to:
1. Create the same installation directory [2](#0-1) 
2. Download and install binaries to identical file paths [3](#0-2) 
3. Set the same environment variables [4](#0-3) 

All installations write to the same shared directory determined by the operating system. [5](#0-4) 

The underlying `update_binary` function uses `tokio::task::spawn_blocking` but provides no cross-invocation file locking. [6](#0-5) 

In contrast, the Move package manager implements comprehensive locking to prevent exactly these race conditions, using both thread-level and process-level locks with explicit documentation of the risks. [7](#0-6) 

**Attack Scenario:**
An attacker with local access, or a legitimate user running automation scripts, executes:
```bash
aptos update prover-dependencies &
aptos update prover-dependencies &
aptos update prover-dependencies &
```

This triggers concurrent downloads of the same binaries with all processes writing to identical files, causing:
- **File corruption**: Interleaved writes from multiple processes produce corrupted executables
- **Resource exhaustion**: NÃ— redundant downloads consuming network bandwidth, disk I/O, and temporary storage
- **Broken tool chain**: Corrupted prover binaries fail to execute, breaking the Move prover workflow

## Impact Explanation

This vulnerability qualifies as **Medium severity** per the security question's classification. While it does not directly affect blockchain consensus, validator operations, or on-chain state, it impacts the development toolchain integrity and can cause resource exhaustion on developer machines. The corrupted installations could potentially disrupt critical development and verification workflows for smart contract security.

## Likelihood Explanation

**High likelihood**: The vulnerability is easily triggered by:
- Developers running parallel build scripts or CI/CD pipelines
- Automation tools invoking the update command concurrently
- Users manually running multiple terminal sessions
- No special privileges or deep technical knowledge required

## Recommendation

Implement file-system level locking similar to the Move package manager's `PackageLock` pattern. Add a locking mechanism that combines:

1. **Thread-level synchronization**: Use `std::sync::Mutex` wrapped in `once_cell::sync::Lazy` for in-process serialization
2. **Process-level synchronization**: Use `named_lock::NamedLock` for cross-process serialization
3. **Lock acquisition**: Acquire both locks at the start of `download_dependency()` and release them upon completion

The lock should use a user-specific name (e.g., `aptos_prover_deps_lock_{username}`) to avoid conflicts between different users on the same system while ensuring proper serialization per user.

Example structure:
```rust
use named_lock::{NamedLock, NamedLockGuard};
use once_cell::sync::Lazy;
use std::sync::{Mutex, MutexGuard};

static PROVER_DEPS_THREAD_LOCK: Lazy<Mutex<()>> = Lazy::new(|| Mutex::new(()));
static PROVER_DEPS_PROCESS_LOCK: Lazy<NamedLock> = Lazy::new(|| {
    let lock_name = format!("aptos_prover_deps_{}", whoami::username());
    NamedLock::create(&lock_name).unwrap()
});
```

Then acquire both locks at the beginning of `download_dependency()` before any file system operations.

## Proof of Concept

```bash
#!/bin/bash
# Race condition demonstration script

# Start three concurrent installations
aptos update prover-dependencies &
PID1=$!

aptos update prover-dependencies &
PID2=$!

aptos update prover-dependencies &
PID3=$!

# Wait for all processes
wait $PID1
wait $PID2
wait $PID3

# Verify binary integrity
~/.local/bin/boogie /version
if [ $? -ne 0 ]; then
    echo "CORRUPTED: Boogie binary is broken"
fi

~/.local/bin/z3 --version
if [ $? -ne 0 ]; then
    echo "CORRUPTED: Z3 binary is broken"
fi

# Check for partial/corrupted files
file ~/.local/bin/boogie
file ~/.local/bin/z3
```

Expected result: At least one of the binaries will be corrupted or the file integrity check will fail due to concurrent write conflicts.

## Notes

The vulnerability exists because the prover dependency installer does not follow the same defensive programming patterns established elsewhere in the codebase. The Move package manager explicitly addresses these exact race conditions with comprehensive locking, but this pattern was not applied to the CLI update infrastructure. This inconsistency creates a security gap in the toolchain that should be remedied by applying the established best practices uniformly.

### Citations

**File:** crates/aptos/src/update/prover_dependencies.rs (L105-114)
```rust
        let install_dir = match self.install_dir.clone() {
            Some(dir) => dir,
            None => {
                let dir = get_additional_binaries_dir();
                // Make the directory if it doesn't already exist.
                std::fs::create_dir_all(&dir)
                    .with_context(|| format!("Failed to create directory: {:?}", dir))?;
                dir
            },
        };
```

**File:** crates/aptos/src/update/prover_dependencies.rs (L122-152)
```rust
        let res = self
            .install_binary(
                install_dir.clone(),
                BOOGIE_EXE,
                BOOGIE_BINARY_NAME,
                TARGET_BOOGIE_VERSION,
                "/",
                "Boogie program verifier version ",
                BOOGIE_EXE_ENV,
            )
            .await?;
        println!("{}", res);

        BoogieOptions::check_version_is_compatible(
            Z3_BINARY_NAME,
            TARGET_Z3_VERSION,
            MIN_Z3_VERSION,
            MAX_Z3_VERSION,
        )?;
        let res = self
            .install_binary(
                install_dir.clone(),
                Z3_EXE,
                Z3_BINARY_NAME,
                TARGET_Z3_VERSION,
                "--",
                "Z3 version ",
                Z3_EXE_ENV,
            )
            .await?;
        println!("{}", res);
```

**File:** crates/aptos/src/update/prover_dependencies.rs (L202-206)
```rust
        let install_dir = install_dir.join(exe_name);
        if let Err(err) = self.add_env_var(env_name, &install_dir) {
            eprintln!("{:#}. Please set it manually", err);
        }
        Ok(result)
```

**File:** crates/aptos/src/update/prover_dependencies.rs (L216-218)
```rust
    async fn execute(self) -> CliTypedResult<String> {
        self.download_dependency().await
    }
```

**File:** crates/aptos/src/update/helpers.rs (L9-21)
```rust
pub fn get_additional_binaries_dir() -> PathBuf {
    #[cfg(windows)]
    {
        let home_dir = std::env::var("USERPROFILE").unwrap_or_else(|_| "".into());
        PathBuf::from(home_dir).join(".aptoscli/bin")
    }

    #[cfg(not(windows))]
    {
        let home_dir = std::env::var("HOME").unwrap_or_else(|_| "".into());
        PathBuf::from(home_dir).join(".local/bin")
    }
}
```

**File:** crates/aptos/src/update/mod.rs (L113-131)
```rust
async fn update_binary<Updater: BinaryUpdater + Sync + Send + 'static>(
    updater: Updater,
) -> CliTypedResult<String> {
    let name = updater.pretty_name();
    if updater.check() {
        let info = tokio::task::spawn_blocking(move || updater.get_update_info())
            .await
            .context(format!("Failed to check {} version", name))??;
        if info.current_version.unwrap_or_default() != info.target_version {
            return Ok(format!("Update is available ({})", info.target_version));
        }

        return Ok(format!("Already up to date ({})", info.target_version));
    }

    tokio::task::spawn_blocking(move || updater.update())
        .await
        .context(format!("Failed to install or update {}", name))?
}
```

**File:** third_party/move/tools/move-package/src/package_lock.rs (L17-25)
```rust
/// The package lock is a lock held across threads and processes. This lock is held to ensure that
/// the Move package manager has a consistent (read: serial) view of the file system. Without this
/// lock we can easily get into race conditions around caching and overwriting of packages (e.g.,
/// thread 1 and thread 2 compete to build package P in the same location), as well as downloading
/// of git dependencies (thread 1 starts downloading git dependency, meanwhile thread 2 sees the
/// git directory before it has been fully populated but assumes it has been fully downloaded and
/// starts building the package before the git dependency has been fully downloaded by thread 1.
/// This will then lead to file not found errors). These same issues could occur across processes,
/// this is why we grab both a thread lock and process lock.
```
