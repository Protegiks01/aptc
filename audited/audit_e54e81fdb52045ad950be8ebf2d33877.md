# Audit Report

## Title
Unlimited Token Minting in Faucet Service Due to Missing Rate Limits and Amount Restrictions

## Summary
The faucet service configured via `build_for_cli()` has no rate limiting (empty `checker_configs`) and no amount restrictions (`maximum_amount` set to `None`), allowing attackers to mint unlimited APT tokens when the service is exposed to the network. This occurs in Docker container deployments or when explicitly binding to `0.0.0.0`.

## Finding Description
The faucet service initialization in `build_for_cli()` creates a `MintFunder` with critical security controls disabled: [1](#0-0) [2](#0-1) 

The `MintFunder::get_amount()` function returns the user-requested amount directly when `maximum_amount` is `None`: [3](#0-2) 

When the local testnet runs inside a Docker container, services automatically bind to `0.0.0.0` (all network interfaces): [4](#0-3) 

This creates an attack path where:
1. Developer runs `aptos node run-localnet` inside Docker (automatic) or with `--bind-to 0.0.0.0` (explicit)
2. Faucet exposes on `0.0.0.0:8081` (default port) with no authentication
3. Attacker sends: `POST /fund` with arbitrary `amount` value
4. Faucet mints requested amount with no validation or limits

The vulnerability violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." While gas is paid for minting, there are no application-level restrictions on mint amounts or frequency.

## Impact Explanation
**Critical Severity - Loss of Funds (unlimited minting)**

This meets the Critical severity criteria under "Loss of Funds (theft or minting)" because:
- Attackers can mint arbitrary amounts of APT tokens (e.g., `999999999999999999`)
- No rate limiting allows repeated exploitation
- Completely compromises the local testnet's token economics
- Could affect development and testing environments

While this affects local testnets rather than production mainnet, it represents a complete security breakdown of the faucet service when exposed, and developers may not realize the exposure risk when using Docker containers.

## Likelihood Explanation
**High Likelihood**

This vulnerability is highly likely to occur because:
1. Docker deployment automatically triggers exposure (`bind_to = 0.0.0.0`)
2. No warnings exist about security implications
3. Default port (8081) is well-known
4. Exploitation requires only basic HTTP requests
5. No authentication or authorization checks

Developers commonly run services in Docker containers for convenience, unknowingly exposing the faucet to network attacks. The vulnerability is trivially exploitable once exposed.

## Recommendation

Implement defense-in-depth security controls in `build_for_cli()`:

1. **Add default amount limits:**
```rust
transaction_submission_config: TransactionSubmissionConfig::new(
    Some(100_000_000_000),  // maximum_amount: 100 APT
    Some(1_000_000_000_000), // maximum_amount_with_bypass: 1000 APT
    // ... rest of config
),
```

2. **Add basic rate limiting checker:** [1](#0-0) 

Add a simple IP-based rate limiter even for CLI usage to prevent abuse.

3. **Add security warnings when binding to 0.0.0.0:**
Print prominent warnings when the faucet is exposed beyond localhost, informing users of the security implications.

4. **Consider authentication for network-exposed faucets:**
Require a simple auth token when `bind_to != 127.0.0.1`.

## Proof of Concept

**Setup:**
```bash
# Run localnet in Docker (automatically binds to 0.0.0.0)
docker run --rm -it aptos-cli aptos node run-localnet
```

**Exploit:**
```bash
# From external machine on same network
VICTIM_IP="192.168.1.100"  # Docker host IP
ATTACKER_ADDR="0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"

# Mint 999 trillion tokens (essentially unlimited)
curl -X POST "http://${VICTIM_IP}:8081/fund" \
  -H "Content-Type: application/json" \
  -d "{\"amount\": 999999999999999999, \"address\": \"${ATTACKER_ADDR}\"}"

# Verify - repeat unlimited times with no rate limit
for i in {1..100}; do
  curl -X POST "http://${VICTIM_IP}:8081/fund" \
    -H "Content-Type: application/json" \
    -d "{\"amount\": 100000000000, \"address\": \"${ATTACKER_ADDR}\"}"
done
```

**Expected Result:**
All requests succeed, minting the requested amounts with no restrictions or rate limiting.

## Notes

While this vulnerability affects local testnets rather than production infrastructure, it represents a complete security control failure in the faucet service. The combination of automatic network exposure in Docker containers, lack of amount restrictions, and absence of rate limiting creates a critical security risk for development environments. Organizations using these tools for testing could face token supply manipulation affecting their test scenarios and potentially exposing internal network services.

### Citations

**File:** crates/aptos-faucet/core/src/server/run.rs (L276-277)
```rust
            bypasser_configs: vec![],
            checker_configs: vec![],
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L286-287)
```rust
                    None,    // maximum_amount
                    None,    // maximum_amount_with_bypass
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L540-550)
```rust
    fn get_amount(&self, amount: Option<u64>, did_bypass_checkers: bool) -> u64 {
        match (
            amount,
            self.txn_config.get_maximum_amount(did_bypass_checkers),
        ) {
            (Some(amount), Some(maximum_amount)) => std::cmp::min(amount, maximum_amount),
            (Some(amount), None) => amount,
            (None, Some(maximum_amount)) => std::cmp::min(self.amount_to_fund, maximum_amount),
            (None, None) => self.amount_to_fund,
        }
    }
```

**File:** crates/aptos/src/node/local_testnet/mod.rs (L274-283)
```rust
        let bind_to = match self.bind_to {
            Some(bind_to) => bind_to,
            None => {
                if running_inside_container {
                    Ipv4Addr::new(0, 0, 0, 0)
                } else {
                    Ipv4Addr::new(127, 0, 0, 1)
                }
            },
        };
```
