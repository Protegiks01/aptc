# Audit Report

## Title
Empty `self_advertised_address` Causes Denial-of-Service in Indexer-GRPC Infrastructure via Panic on Invalid URI Parsing

## Summary
The `self_advertised_address` configuration field in `IndexerGrpcManagerConfig` lacks validation against empty strings. When an empty address is broadcast via heartbeat messages to peer GrpcManagers, it triggers a panic during URI parsing, causing a denial-of-service by crashing receiving nodes. This affects both the GrpcManager and DataService components of the indexer infrastructure.

## Finding Description
The indexer-grpc system uses a distributed heartbeat protocol for service discovery, where each GrpcManager advertises its address to peers. The `self_advertised_address` field is defined without any validation: [1](#0-0) 

When a GrpcManager starts, it periodically sends heartbeat messages containing its self-advertised address to all peer GrpcManagers: [2](#0-1) 

The receiving GrpcManager processes this heartbeat via the RPC handler: [3](#0-2) 

When the address is empty (not `None`, but `Some("")`), it passes through the optional checks and is forwarded to the metadata handler: [4](#0-3) 

If this is a new peer (empty string not yet in the map), the code attempts to create a new `Peer` instance with the empty address: [5](#0-4) 

The `Channel::from_shared()` method attempts to parse the empty string as a URI. Since an empty string is not a valid URI per RFC 3986, this operation fails and the `.expect("Bad address.")` call triggers a **panic**, immediately crashing the entire GrpcManager process.

**Attack Path:**
1. Attacker configures or modifies a GrpcManager config file with `self_advertised_address: ""`
2. The misconfigured GrpcManager starts and joins the cluster
3. It sends periodic heartbeat messages containing the empty address to all peers
4. Each peer GrpcManager that receives the heartbeat crashes due to panic in `Peer::new()`
5. Result: Denial-of-service affecting all GrpcManagers in the indexer cluster

The same vulnerability exists in the DataService component: [6](#0-5) 

## Impact Explanation
This vulnerability qualifies as **HIGH severity** per the Aptos bug bounty criteria:

- **API crashes**: The GrpcManager is a critical API component that serves indexer queries. Crashing these services directly impacts API availability.
- **Significant protocol violations**: The heartbeat protocol is designed for reliable service discovery. A single malformed heartbeat should not crash receiving nodes, violating the robustness guarantee.
- **Infrastructure disruption**: The indexer-grpc infrastructure is essential for blockchain data access. Widespread crashes would disable transaction indexing and querying capabilities.

While this doesn't directly affect consensus or validator operations, it represents a critical availability failure in production infrastructure that many applications depend on.

## Likelihood Explanation
**Likelihood: MEDIUM**

This vulnerability can manifest through:

1. **Accidental misconfiguration**: Operators may accidentally leave the address field empty or misconfigure it during deployment
2. **Configuration file corruption**: File system errors or automation bugs could result in empty string values
3. **Malicious configuration**: An attacker with config file write access could intentionally inject empty addresses
4. **Default value bugs**: Missing or incorrect default values in configuration management systems

The attack requires no special privileges beyond being able to run a GrpcManager node in the cluster (or modify a config file). The crash is immediate and deterministic once the heartbeat is received. The cascading effect makes this particularly dangerous - one misconfigured node can crash an entire cluster.

## Recommendation
Add validation to reject empty addresses during configuration loading. Implement checks at multiple layers:

**1. Config validation at load time:**
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcManagerConfig {
    pub(crate) chain_id: u64,
    pub(crate) service_config: ServiceConfig,
    #[serde(default = "default_cache_config")]
    pub(crate) cache_config: CacheConfig,
    pub(crate) file_store_config: IndexerGrpcFileStoreConfig,
    pub(crate) self_advertised_address: GrpcAddress,
    pub(crate) grpc_manager_addresses: Vec<GrpcAddress>,
    pub(crate) fullnode_addresses: Vec<GrpcAddress>,
    pub(crate) is_master: bool,
    pub(crate) allow_fn_fallback: bool,
}

impl IndexerGrpcManagerConfig {
    pub fn validate(&self) -> Result<(), Error> {
        if self.self_advertised_address.is_empty() {
            return Err(Error::InvalidConfig(
                "self_advertised_address cannot be empty".to_string()
            ));
        }
        // Validate it's a valid URI
        Channel::from_shared(self.self_advertised_address.clone())
            .map_err(|e| Error::InvalidConfig(format!(
                "self_advertised_address is not a valid URI: {}", e
            )))?;
        Ok(())
    }
}
```

**2. Defensive handling in Peer::new():**
```rust
fn new(address: GrpcAddress) -> Result<Self, Error> {
    if address.is_empty() {
        return Err(anyhow!("Cannot create peer with empty address"));
    }
    let channel = Channel::from_shared(address)
        .map_err(|e| anyhow!("Invalid address for peer: {}", e))?
        .connect_lazy();
    let client = GrpcManagerClient::new(channel)
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
    Ok(Self {
        client,
        recent_states: VecDeque::new(),
    })
}
```

**3. Reject invalid addresses in heartbeat handler:**
```rust
async fn heartbeat(
    &self,
    request: Request<HeartbeatRequest>,
) -> Result<Response<HeartbeatResponse>, Status> {
    let request = request.into_inner();
    if let Some(service_info) = request.service_info {
        if let Some(address) = service_info.address {
            // Validate address is not empty
            if address.is_empty() {
                return Err(Status::invalid_argument("Address cannot be empty"));
            }
            if let Some(info) = service_info.info {
                return self
                    .handle_heartbeat(address, info)
                    .await
                    .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
            }
        }
    }
    Err(Status::invalid_argument("Bad request."))
}
```

Apply the same validation to `IndexerGrpcDataServiceConfig`.

## Proof of Concept
```rust
#[cfg(test)]
mod test {
    use super::*;
    use tonic::transport::Channel;

    #[test]
    fn test_empty_address_causes_panic() {
        // This test demonstrates that Channel::from_shared panics on empty string
        let result = std::panic::catch_unwind(|| {
            Channel::from_shared("".to_string())
                .expect("Bad address.")
                .connect_lazy();
        });
        assert!(result.is_err(), "Empty address should cause panic");
    }

    #[test]
    fn test_peer_new_with_empty_address() {
        // This demonstrates the actual vulnerability path
        let empty_address = "".to_string();
        
        // Attempting to create a Peer with empty address will panic
        let result = std::panic::catch_unwind(|| {
            Peer::new(empty_address)
        });
        
        assert!(result.is_err(), 
            "Creating Peer with empty address should panic, causing DoS");
    }

    #[test]
    fn test_config_validation_should_reject_empty() {
        let mut config = IndexerGrpcManagerConfig {
            chain_id: 1,
            service_config: ServiceConfig {
                listen_address: "127.0.0.1:8080".parse().unwrap(),
            },
            cache_config: default_cache_config(),
            file_store_config: IndexerGrpcFileStoreConfig::default(),
            self_advertised_address: "".to_string(), // Empty!
            grpc_manager_addresses: vec![],
            fullnode_addresses: vec![],
            is_master: false,
            allow_fn_fallback: false,
        };
        
        // This should fail validation (after fix is applied)
        // Currently no validation exists, allowing the vulnerability
        assert!(config.self_advertised_address.is_empty(), 
            "Empty address is currently accepted without validation");
    }
}
```

## Notes
- This vulnerability affects the availability of the indexer-grpc infrastructure but does not directly impact consensus, validators, or on-chain state.
- The indexer-grpc components are critical for off-chain data access and application functionality, making their availability important for the ecosystem.
- While not directly part of the core blockchain consensus, the indexer infrastructure is production-critical infrastructure maintained in the aptos-core repository.
- Other network components in the codebase show precedent for address validation (e.g., `network_config.rs` checks for empty listen addresses), suggesting this validation should be applied consistently.
- The vulnerability can be triggered accidentally through misconfiguration, making it a realistic operational risk even without malicious intent.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L37-37)
```rust
    pub(crate) self_advertised_address: GrpcAddress,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L45-58)
```rust
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
        let client = GrpcManagerClient::new(channel)
            .send_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Zstd)
            .max_encoding_message_size(MAX_MESSAGE_SIZE)
            .max_decoding_message_size(MAX_MESSAGE_SIZE);
        Self {
            client,
            recent_states: VecDeque::new(),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L411-428)
```rust
    async fn heartbeat(&self, mut client: GrpcManagerClient<Channel>) -> Result<()> {
        let grpc_manager_info = GrpcManagerInfo {
            chain_id: self.chain_id,
            timestamp: Some(timestamp_now_proto()),
            known_latest_version: Some(self.get_known_latest_version()),
            master_address: self.master_address.lock().unwrap().clone(),
        };
        let service_info = ServiceInfo {
            address: Some(self.self_advertised_address.clone()),
            info: Some(Info::GrpcManagerInfo(grpc_manager_info)),
        };
        let request = HeartbeatRequest {
            service_info: Some(service_info),
        };
        let _ = client.heartbeat(request).await?;

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L552-567)
```rust
    fn handle_grpc_manager_info(&self, address: GrpcAddress, info: GrpcManagerInfo) -> Result<()> {
        self.master_address
            .lock()
            .unwrap()
            .clone_from(&info.master_address);

        let mut entry = self
            .grpc_managers
            .entry(address.clone())
            .or_insert(Peer::new(address));
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L91-91)
```rust
    pub(crate) self_advertised_address: String,
```
