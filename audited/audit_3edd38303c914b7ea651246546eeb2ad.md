# Audit Report

## Title
Stale Validator References in RoundProposer Mapping Cause Predictable Liveness Degradation

## Summary
The `RoundProposer` implementation in the consensus layer does not automatically update its round-to-validator mapping when the validator set rotates. This causes specific rounds to timeout when mapped validators leave the active set, leading to predictable liveness degradation without safety violations.

## Finding Description

The `RoundProposer` struct stores a static `HashMap<Round, Author>` mapping that is initialized from the on-chain consensus configuration and never updated during validator set rotations. [1](#0-0) 

When a new epoch starts with a rotated validator set, the `EpochManager` creates a new `RoundProposer` instance but uses the same on-chain configuration that may reference validators no longer in the active set: [2](#0-1) 

The critical flow:
1. On-chain config contains `RoundProposer{round 100 => Validator A}`
2. Validator A leaves the active validator set in a new epoch
3. The on-chain config is not updated (requires governance action)
4. When round 100 arrives, `get_valid_proposer(100)` returns Validator A's address
5. No other validator can propose (rejected as invalid proposer): [3](#0-2) 

6. If Validator A tries to propose, signature verification fails because they're not in the current `ValidatorVerifier`: [4](#0-3) [5](#0-4) 

7. The round times out, causing network slowdown.

The `default_proposer` field does get updated to the first validator in the new epoch, but this only applies to rounds NOT explicitly mapped in the HashMap: [6](#0-5) 

## Impact Explanation

**Severity: Medium**

This issue causes **temporary liveness degradation** but does not violate consensus safety:

- **No fund loss**: Assets remain secure
- **No safety violation**: No chain splits or double-spending
- **Temporary impact**: Affected rounds timeout and the network continues with subsequent rounds
- **Predictable performance degradation**: Each timeout wastes time (typically seconds to minutes per round)
- **Cumulative effect**: If multiple rounds map to removed validators, cumulative delays can significantly slow block production

Per Aptos bug bounty criteria, this falls under **Medium Severity** as it causes "state inconsistencies requiring intervention" (governance must update the config) and temporary performance degradation, but not total liveness loss or critical safety violations.

## Likelihood Explanation

**Likelihood: Low to Medium**

This issue requires specific preconditions:
1. Governance configures consensus to use `ProposerElectionType::RoundProposer` (uncommon - most deployments use `LeaderReputation`)
2. Validator set rotates with validators leaving the active set (common during regular operations)
3. Governance fails to update the on-chain consensus config to reflect the new validator set (operational oversight) [7](#0-6) 

The likelihood increases if:
- RoundProposer is actively used
- High validator churn occurs
- Config update processes are not well-automated

## Recommendation

**Solution 1: Validation Check (Immediate Fix)**

Add validation during epoch initialization to detect and warn about stale validator mappings:

```rust
// In epoch_manager.rs, modify create_proposer_election()
ProposerElectionType::RoundProposer(round_proposers) => {
    // Validate that all mapped validators are in the current set
    let current_validators: HashSet<_> = epoch_state
        .verifier
        .get_ordered_account_addresses_iter()
        .collect();
    
    for (round, validator) in round_proposers.iter() {
        if !current_validators.contains(validator) {
            warn!(
                "RoundProposer maps round {} to validator {} which is not in the current validator set",
                round, validator
            );
        }
    }
    
    let default_proposer = proposers
        .first()
        .expect("INVARIANT VIOLATION: proposers is empty");
    Arc::new(RoundProposer::new(
        round_proposers.clone(),
        *default_proposer,
    ))
}
```

**Solution 2: Auto-Filtering (Better Fix)**

Filter out invalid mappings during initialization:

```rust
ProposerElectionType::RoundProposer(round_proposers) => {
    let current_validators: HashSet<_> = epoch_state
        .verifier
        .get_ordered_account_addresses_iter()
        .collect();
    
    let filtered_proposers: HashMap<Round, Author> = round_proposers
        .iter()
        .filter(|(_, validator)| current_validators.contains(validator))
        .map(|(round, validator)| (*round, *validator))
        .collect();
    
    let default_proposer = proposers
        .first()
        .expect("INVARIANT VIOLATION: proposers is empty");
    Arc::new(RoundProposer::new(
        filtered_proposers,
        *default_proposer,
    ))
}
```

**Solution 3: Documentation (Operational)**

Clearly document in the consensus config that RoundProposer requires manual updates during validator rotations, and provide governance scripts to automate this.

## Proof of Concept

```rust
// Test demonstrating the issue
#[test]
fn test_stale_round_proposer_mapping() {
    // Epoch N setup
    let validator_a = AccountAddress::random();
    let validator_b = AccountAddress::random();
    let validator_c = AccountAddress::random();
    
    let epoch_n_validators = vec![validator_a, validator_b, validator_c];
    
    // On-chain config maps round 100 to validator A
    let mut round_proposers = HashMap::new();
    round_proposers.insert(100, validator_a);
    
    // Epoch N+1: Validator A leaves, D joins
    let validator_d = AccountAddress::random();
    let epoch_n1_validators = vec![validator_b, validator_c, validator_d];
    
    // Create RoundProposer with old config and new validator set
    let round_proposer = RoundProposer::new(
        round_proposers,
        epoch_n1_validators[0] // default_proposer updated
    );
    
    // Round 100 still returns validator A
    assert_eq!(round_proposer.get_valid_proposer(100), validator_a);
    
    // But validator A is NOT in the current validator set
    let validator_verifier = ValidatorVerifier::new(
        epoch_n1_validators.iter().map(|addr| {
            ValidatorConsensusInfo::new(*addr, PublicKey::random(), 1)
        }).collect()
    );
    
    // Signature verification would fail for validator A
    // (cannot demonstrate without actual signing, but get_public_key would return None)
    assert!(validator_verifier.get_public_key(&validator_a).is_none());
    
    // Round 101 (not mapped) correctly falls back to validator B
    assert_eq!(round_proposer.get_valid_proposer(101), validator_b);
}
```

This test demonstrates that round 100 would return a validator not in the current set, causing that round to timeout while other rounds work correctly.

## Notes

- This is an **operational/configuration issue** rather than a critical consensus safety bug
- The network **does recover** automatically via timeout mechanisms
- Impact is limited to **performance degradation**, not safety violations
- The `default_proposer` mechanism provides automatic recovery for unmapped rounds
- This issue is specific to the `RoundProposer` election type, which appears less commonly used than `LeaderReputation`

### Citations

**File:** consensus/src/liveness/round_proposer_election.rs (L9-15)
```rust
pub struct RoundProposer {
    // A pre-defined map specifying proposers per round
    proposers: HashMap<Round, Author>,
    // Default proposer to use if proposer for a round is unspecified.
    // We hardcode this to the first proposer
    default_proposer: Author,
}
```

**File:** consensus/src/liveness/round_proposer_election.rs (L27-32)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        match self.proposers.get(&round) {
            None => self.default_proposer,
            Some(round_proposer) => *round_proposer,
        }
    }
```

**File:** consensus/src/epoch_manager.rs (L396-405)
```rust
            ProposerElectionType::RoundProposer(round_proposers) => {
                // Hardcoded to the first proposer
                let default_proposer = proposers
                    .first()
                    .expect("INVARIANT VIOLATION: proposers is empty");
                Arc::new(RoundProposer::new(
                    round_proposers.clone(),
                    *default_proposer,
                ))
            },
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L46-60)
```rust
    pub fn is_valid_proposal(&self, block: &Block) -> bool {
        block.author().is_some_and(|author| {
            let valid_author = self.is_valid_proposer(author, block.round());
            if !valid_author {
                warn!(
                    SecurityEvent::InvalidConsensusProposal,
                    "Proposal is not from valid author {}, expected {} for round {} and id {}",
                    author,
                    self.get_valid_proposer(block.round()),
                    block.round(),
                    block.id()
                );

                return false;
            }
```

**File:** types/src/validator_verifier.rs (L255-267)
```rust
    pub fn verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature: &bls12381::Signature,
    ) -> std::result::Result<(), VerifyError> {
        match self.get_public_key(&author) {
            Some(public_key) => public_key
                .verify_struct_signature(message, signature)
                .map_err(|_| VerifyError::InvalidMultiSignature),
            None => Err(VerifyError::UnknownAuthor),
        }
    }
```

**File:** consensus/consensus-types/src/block.rs (L425-440)
```rust
    pub fn validate_signature(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        match self.block_data.block_type() {
            BlockType::Genesis => bail!("We should not accept genesis from others"),
            BlockType::NilBlock { .. } => self.quorum_cert().verify(validator),
            BlockType::Proposal { author, .. } => {
                let signature = self
                    .signature
                    .as_ref()
                    .ok_or_else(|| format_err!("Missing signature in Proposal"))?;
                let (res1, res2) = rayon::join(
                    || validator.verify(*author, &self.block_data, signature),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L46-56)
```text
    /// This can be called by on-chain governance to update on-chain consensus configs for the next epoch.
    /// Example usage:
    /// ```
    /// aptos_framework::consensus_config::set_for_next_epoch(&framework_signer, some_config_bytes);
    /// aptos_framework::aptos_governance::reconfigure(&framework_signer);
    /// ```
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```
