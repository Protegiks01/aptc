# Audit Report

## Title
Move Prover Verification Bypass via Incomplete Memory Usage Analysis in Recursive Functions

## Summary
The Move Prover's memory usage analysis (`usage_analysis.rs`) unconditionally marks analysis results as reaching fixedpoint, causing premature termination of iterative analysis for mutually recursive functions. This leads to incomplete memory usage information, causing `find_relevant_invariants()` to miss global invariants that should be checked, resulting in a verification bypass.

## Finding Description

The vulnerability exists in the Move Prover's bytecode analysis pipeline, specifically in the interaction between memory usage analysis and invariant relevance detection.

**Root Cause:**

The `UsageProcessor` always sets the fixedpoint flag to `true` when storing analysis results, regardless of whether the analysis has actually converged: [1](#0-0) 

For mutually recursive functions (strongly connected components in the call graph), the first analysis iteration cannot access callees' summaries from the cache, as they don't exist yet: [2](#0-1) 

When the cache returns `None`, the analysis silently skips the callee's memory usage without recording it. However, the incomplete summary is still marked as having reached fixedpoint.

The fixedpoint loop in the pipeline checks whether all annotations have reached fixedpoint: [3](#0-2) 

Since the incomplete summary was marked as fixedpoint=true, the loop exits after the first iteration with incomplete results.

**Propagation to Invariant Analysis:**

The incomplete memory usage is later used by `find_relevant_invariants()` to determine which global invariants apply to each function: [4](#0-3) 

Because the memory usage is incomplete (missing the callees' memory accesses/modifications), invariants that should be checked are not identified as relevant and are omitted from verification.

**Security Impact:**

Global invariants are critical for ensuring correctness of the Aptos Framework. The staking module has suspendable invariants including validator set validity: [5](#0-4) 

If these invariants are missed during verification due to incomplete memory usage analysis, framework code could pass verification despite violating critical invariants, potentially leading to:
- Validator set corruption
- Consensus failures  
- Incorrect reward distribution
- Governance bypass

## Impact Explanation

This is a **High Severity** verification bypass in the Move Prover, a critical security tool used in the Aptos CI pipeline: [6](#0-5) 

While the prover is not part of the runtime system, it is a critical defense layer for framework verification. A bypass in this tool could allow vulnerable code to be deployed to the framework, potentially affecting consensus-critical components like staking and governance.

However, this does not reach Critical severity because:
1. Multiple other security controls exist (code review, testing, audits, governance)
2. Requires specific conditions (recursive functions with global invariants)
3. Indirect attack path (must bypass verification, then deploy code)
4. The TODO comment suggests developers are aware recursion may be problematic [7](#0-6) 

## Likelihood Explanation

**Moderate to Low Likelihood:**

1. **Preconditions:**
   - Requires mutually recursive or self-recursive functions
   - Functions must access/modify memory covered by global invariants
   - Code must pass through the prover (framework code primarily)

2. **Move allows recursion:**
   Move permits regular recursion (confirmed by test examples and compiler infrastructure): [8](#0-7) 

3. **Limited current exposure:**
   - Aptos Framework functions are generally not recursive
   - Most recursive patterns occur in library code (data structures, algorithms)
   - Critical framework modules (staking, governance) don't use obvious recursion

4. **Defense in depth:**
   - Code review would likely catch suspicious recursive patterns
   - Extensive testing would detect invariant violations
   - Security audits provide additional coverage

## Recommendation

The fixedpoint flag should be computed based on actual convergence, not unconditionally set to true. The analysis should compare the current and previous iteration's results:

```rust
fn process(
    &self,
    targets: &mut FunctionTargetsHolder,
    func_env: &FunctionEnv,
    mut data: FunctionData,
    _scc_opt: Option<&[FunctionEnv]>,
) -> FunctionData {
    let summary = Self::analyze(targets, func_env, &data);
    
    // Check if analysis has converged by comparing with previous iteration
    let reached_fixedpoint = if let Some(old_summary) = data.annotations.get::<UsageState>() {
        // Compare old and new summaries for equality
        old_summary.accessed.all == summary.accessed.all &&
        old_summary.modified.all == summary.modified.all &&
        old_summary.assumed.all == summary.assumed.all &&
        old_summary.asserted.all == summary.asserted.all
    } else {
        // First iteration never reaches fixedpoint
        false
    };
    
    data.annotations.set(summary, reached_fixedpoint);
    data
}
```

Additionally, implement the `PartialEq` trait for `UsageState` and `MemoryUsage` to enable proper convergence checking: [9](#0-8) 

## Proof of Concept

Create a test demonstrating the bug with mutually recursive functions:

```rust
// test_recursive_invariant_bypass.move
module 0x1::test_recursive {
    struct GlobalState has key {
        value: u64
    }
    
    spec module {
        invariant [suspendable] global<GlobalState>(@0x1).value <= 100;
    }
    
    // Mutually recursive functions
    public fun function_a(n: u64) acquires GlobalState {
        if (n > 0) {
            function_b(n - 1);
        }
    }
    
    public fun function_b(n: u64) acquires GlobalState {
        let state = borrow_global_mut<GlobalState>(@0x1);
        state.value = 200; // Violates invariant!
        if (n > 0) {
            function_a(n - 1);
        }
    }
}
```

Run the Move Prover on this code. Due to the bug:
1. First iteration: `function_a` analysis doesn't include `function_b`'s memory usage
2. Memory usage marked as fixedpoint=true prematurely
3. Invariant on `GlobalState` not detected as relevant to `function_a`
4. Verification passes despite invariant violation in `function_b`

**Notes:**

- This vulnerability affects the Move Prover verification tool, not the runtime VM
- Impact is indirect: allows potentially unsafe code to pass verification
- Defense in depth (code review, testing, audits) provides mitigation
- The TODO comment suggests this limitation may be known to developers
- Primary risk is to Aptos Framework verification; third-party contracts typically don't use the prover

### Citations

**File:** third_party/move/move-model/bytecode/src/usage_analysis.rs (L32-53)
```rust
#[derive(AbstractDomain, Default, Clone)]
pub struct MemoryUsage {
    // The memory directly used in the function.
    pub direct: SetDomain<QualifiedInstId<StructId>>,
    // The memory transitively used in either the function itself or at least one of its callees.
    pub transitive: SetDomain<QualifiedInstId<StructId>>,
    // The union of the above sets
    pub all: SetDomain<QualifiedInstId<StructId>>,
}

#[derive(AbstractDomain, Default, Clone)]
pub struct UsageState {
    /// The memory accessed by this function. This is the union of the three individual fields
    /// below.
    pub accessed: MemoryUsage,
    /// The memory modified by this function.
    pub modified: MemoryUsage,
    /// The memory mentioned by the assume expressions in this function.
    pub assumed: MemoryUsage,
    /// The memory mentioned by the assert expressions in this function.
    pub asserted: MemoryUsage,
}
```

**File:** third_party/move/move-model/bytecode/src/usage_analysis.rs (L196-207)
```rust
            Call(_, _, oper, _, _) => match oper {
                Function(mid, fid, inst)
                | OpaqueCallBegin(mid, fid, inst)
                | OpaqueCallEnd(mid, fid, inst) => {
                    let callee_id = mid.qualified(*fid);
                    if let Some(summary) = self
                        .cache
                        .get::<UsageState>(callee_id, &FunctionVariant::Baseline)
                    {
                        state.subsume_callee(summary, inst);
                    }
                },
```

**File:** third_party/move/move-model/bytecode/src/usage_analysis.rs (L309-321)
```rust
impl FunctionTargetProcessor for UsageProcessor {
    fn process(
        &self,
        targets: &mut FunctionTargetsHolder,
        func_env: &FunctionEnv,
        mut data: FunctionData,
        _scc_opt: Option<&[FunctionEnv]>,
    ) -> FunctionData {
        let summary = Self::analyze(targets, func_env, &data);
        // TODO(mengxu): re-check the code on whether recursion have an impact on the analysis here.
        data.annotations.set(summary, true);
        data
    }
```

**File:** third_party/move/move-model/bytecode/src/function_target_pipeline.rs (L457-479)
```rust
                        Either::Right(scc) => 'fixedpoint: loop {
                            let scc_env: Vec<_> =
                                scc.iter().map(|fid| env.get_function(*fid)).collect();
                            for fid in scc {
                                let func_env = env.get_function(*fid);
                                targets.process(&func_env, processor.as_ref(), Some(&scc_env));
                            }

                            // check for fixedpoint in summaries
                            for fid in scc {
                                let func_env = env.get_function(*fid);
                                if func_env.is_inline() {
                                    continue;
                                }
                                for (_, target) in targets.get_targets(&func_env) {
                                    if !target.data.annotations.reached_fixedpoint() {
                                        continue 'fixedpoint;
                                    }
                                }
                            }
                            // fixedpoint reached when execution hits this line
                            break 'fixedpoint;
                        },
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/verification_analysis.rs (L574-625)
```rust
    fn find_relevant_invariants<'a>(
        target: &FunctionTarget,
        invariants: impl Iterator<Item = &'a GlobalInvariant>,
    ) -> InvariantRelevance {
        let mem_usage = usage_analysis::get_memory_usage(target);
        let mem_accessed = &mem_usage.accessed.all;
        let mem_modified = &mem_usage.modified.all;
        let mem_direct_accessed = &mem_usage.accessed.direct;
        let mem_direct_modified = &mem_usage.modified.direct;

        let mut inv_accessed = BTreeSet::new();
        let mut inv_modified = BTreeSet::new();
        let mut inv_direct_accessed = BTreeSet::new();
        let mut inv_direct_modified = BTreeSet::new();
        for inv in invariants {
            for fun_mem in mem_accessed.iter() {
                for inv_mem in &inv.mem_usage {
                    if inv_mem.module_id != fun_mem.module_id || inv_mem.id != fun_mem.id {
                        continue;
                    }
                    let adapter =
                        TypeUnificationAdapter::new_vec(&fun_mem.inst, &inv_mem.inst, true, true);
                    let rel = adapter.unify(
                        &mut NoUnificationContext,
                        Variance::SpecVariance,
                        /* shallow_subst */ false,
                    );
                    if rel.is_some() {
                        inv_accessed.insert(inv.id);

                        // the rest exploits the fact that the `used_memory` set (a read-write set)
                        // is always a superset of the others.
                        if mem_modified.contains(fun_mem) {
                            inv_modified.insert(inv.id);
                        }
                        if mem_direct_accessed.contains(fun_mem) {
                            inv_direct_accessed.insert(inv.id);
                        }
                        if mem_direct_modified.contains(fun_mem) {
                            inv_direct_modified.insert(inv.id);
                        }
                    }
                }
            }
        }
        InvariantRelevance {
            accessed: inv_accessed,
            modified: inv_modified,
            direct_accessed: inv_direct_accessed,
            direct_modified: inv_direct_modified,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.spec.move (L47-51)
```text
        invariant [suspendable] exists<ValidatorSet>(@aptos_framework) ==> validator_set_is_valid();
        // After genesis, `AptosCoinCapabilities`, `ValidatorPerformance` and `ValidatorSet` exist.
        invariant [suspendable] chain_status::is_operating() ==> exists<AptosCoinCapabilities>(@aptos_framework);
        invariant [suspendable] chain_status::is_operating() ==> exists<ValidatorPerformance>(@aptos_framework);
        invariant [suspendable] chain_status::is_operating() ==> exists<ValidatorSet>(@aptos_framework);
```

**File:** .github/workflows/prover-daily-test.yaml (L1-50)
```yaml
name: "Prover Daily Test"
on:
  # Allow us to manually run this specific workflow without a PR
  workflow_dispatch:
  # schedule: # NOTE: when ready to re-enable, the schedule should be dictated by PIES
  pull_request:
    paths:
      - ".github/workflows/prover-daily-test.yaml"
      - ".github/actions/move-prover-setup/**"

env:
  CARGO_INCREMENTAL: "0"
  CARGO_TERM_COLOR: always

# cancel redundant builds
concurrency:
  # cancel redundant builds on PRs (only on PR, not on branches)
  group: ${{ github.workflow }}-${{ (github.event_name == 'pull_request' && github.ref) || github.sha }}
  cancel-in-progress: true

jobs:
  prover-inconsistency-test:
    runs-on: runs-on,cpu=64,family=c7,disk=large,image=aptos-ubuntu-x64,run-id=${{ github.run_id }}
    timeout-minutes: ${{ github.event_name == 'pull_request' && 10 || 480}}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # get all the history because cargo xtest --change-since origin/main requires it.
      - uses: ./.github/actions/move-prover-setup
      - run: MVP_TEST_DISALLOW_TIMEOUT_OVERWRITE=1 MVP_TEST_VC_TIMEOUT=1200 cargo test -p aptos-move-examples --release -- --include-ignored prover
      - run: MVP_TEST_DISALLOW_TIMEOUT_OVERWRITE=1 MVP_TEST_VC_TIMEOUT=7200 cargo test -p aptos-framework --release -- --include-ignored prover
      - run: MVP_TEST_DISALLOW_TIMEOUT_OVERWRITE=1 MVP_TEST_VC_TIMEOUT=1200 MVP_TEST_INCONSISTENCY=1 cargo test -p aptos-move-examples --release -- --include-ignored prover
      - run: MVP_TEST_DISALLOW_TIMEOUT_OVERWRITE=1 MVP_TEST_VC_TIMEOUT=7200 MVP_TEST_INCONSISTENCY=1 cargo test -p aptos-framework --release -- --include-ignored prover
```

**File:** aptos-move/e2e-move-tests/src/tests/function_caches.rs (L23-36)
```rust
        module 0x99::m {
            public entry fun factorial(n: u64) {
                factorial_impl(n);
            }

            fun factorial_impl(n: u64): u64 {
                if (n <= 1) {
                    1
                } else {
                    n * factorial_impl(n - 1)
                }
            }
        }
        "#,
```
