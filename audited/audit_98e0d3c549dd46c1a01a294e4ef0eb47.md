# Audit Report

## Title
Information Disclosure of Private Function Metadata via View Function API Type Argument Validation

## Summary
The `convert_view_function` method in `api/types/src/convert.rs` leaks metadata about private and non-view functions by revealing the expected number of generic type parameters in error messages before validating whether the function is actually a view function.

## Finding Description

The vulnerability exists in the view function conversion process where type argument validation occurs before view function authorization checks. [1](#0-0) 

The method uses `find_function` to locate functions: [2](#0-1) 

This method searches **all** function definitions regardless of visibility (private, public, friend) or function type (view, entry, non-entry). The `MoveFunction` structure contains visibility information: [3](#0-2) 

**Attack Flow:**
1. Attacker calls the view API endpoint with a private function name
2. `convert_view_function` successfully finds the private function using `find_function`
3. Before checking `func.is_view`, the code validates type arguments (line 1036-1042)
4. If type argument count mismatches, the error reveals: `"expected {N} type arguments for view function MODULE::FUNCTION, but got {M}"`
5. This discloses that a private function exists and has N generic type parameters

The actual view function validation happens **later** during execution: [4](#0-3) 

But by this point, metadata has already been leaked via the error message.

## Impact Explanation

This issue qualifies as **Low Severity** per Aptos bug bounty criteria under "Minor information leaks." 

The attacker can:
- Probe for existence of private/internal functions by name
- Learn the number of generic type parameters of these functions

The attacker **cannot**:
- Execute private functions
- Access protected state or resources
- Cause consensus violations
- Impact funds or validator operations

## Likelihood Explanation

**High likelihood** of exploitation:
- No authentication required beyond API access
- Simple HTTP POST request to `/view` endpoint
- Deterministic and repeatable
- Requires only knowledge of potential function names (e.g., through code analysis or naming conventions)

## Recommendation

Add validation that the function is marked as a view function **before** performing type argument validation and revealing metadata:

```rust
pub fn convert_view_function(&self, view_request: ViewRequest) -> Result<ViewFunction> {
    let ViewRequest {
        function,
        type_arguments,
        arguments,
    } = view_request;

    let module = function.module.clone();
    let code = self.inner.view_existing_module(&module.clone().into())? as Arc<dyn Bytecode>;
    let func = code
        .find_function(function.name.0.as_ident_str())
        .ok_or_else(|| format_err!("could not find view function by {}", function))?;
    
    // Validate it's a view function BEFORE revealing metadata
    ensure!(
        func.is_view,
        "function {} is not a view function",
        function
    );
    
    ensure!(
        func.generic_type_params.len() == type_arguments.len(),
        "expected {} type arguments for view function {}, but got {}",
        func.generic_type_params.len(),
        function,
        type_arguments.len()
    );
    
    // ... rest of implementation
}
```

## Proof of Concept

```rust
// Assume a module at 0x1::secret_module with private function:
// fun private_function<T, U>(x: T): U { abort 1 }

// Attacker's API call:
POST /v1/view
Content-Type: application/json
{
    "function": "0x1::secret_module::private_function",
    "type_arguments": ["u64"],  // Wrong count (function expects 2)
    "arguments": []
}

// Current behavior - LEAKS METADATA:
// Response: 400 Bad Request
// "expected 2 type arguments for view function 0x1::secret_module::private_function, but got 1"

// Attacker learns:
// 1. private_function exists
// 2. It has 2 generic type parameters

// After fix - NO LEAK:
// Response: 400 Bad Request  
// "function 0x1::secret_module::private_function is not a view function"
```

## Notes

While this is a valid information disclosure vulnerability, it is **explicitly categorized as Low severity** in the security question itself and matches the Aptos bug bounty category for "Minor information leaks" ($1,000 maximum). The vulnerability does not compromise funds, consensus, or system availability, but does leak module metadata that could aid attackers in reconnaissance or social engineering attacks.

### Citations

**File:** api/types/src/convert.rs (L1024-1058)
```rust
    pub fn convert_view_function(&self, view_request: ViewRequest) -> Result<ViewFunction> {
        let ViewRequest {
            function,
            type_arguments,
            arguments,
        } = view_request;

        let module = function.module.clone();
        let code = self.inner.view_existing_module(&module.clone().into())? as Arc<dyn Bytecode>;
        let func = code
            .find_function(function.name.0.as_ident_str())
            .ok_or_else(|| format_err!("could not find view function by {}", function))?;
        ensure!(
            func.generic_type_params.len() == type_arguments.len(),
            "expected {} type arguments for view function {}, but got {}",
            func.generic_type_params.len(),
            function,
            type_arguments.len()
        );
        let args = self
            .try_into_vm_values(&func, &arguments)?
            .iter()
            .map(bcs::to_bytes)
            .collect::<Result<_, bcs::Error>>()?;

        Ok(ViewFunction {
            module: module.into(),
            function: function.name.into(),
            ty_args: type_arguments
                .iter()
                .map(|v| v.try_into())
                .collect::<Result<_>>()?,
            args,
        })
    }
```

**File:** api/types/src/bytecode.rs (L263-271)
```rust
    fn find_function(&self, name: &IdentStr) -> Option<MoveFunction> {
        self.function_defs
            .iter()
            .find(|def| {
                let fhandle = ModuleAccess::function_handle_at(self, def.function);
                ModuleAccess::identifier_at(self, fhandle.name) == name
            })
            .map(|def| self.new_move_function(def))
    }
```

**File:** api/types/src/move_types.rs (L1221-1236)
```rust
pub struct MoveFunction {
    pub name: IdentifierWrapper,
    pub visibility: MoveFunctionVisibility,
    /// Whether the function can be called as an entry function directly in a transaction
    pub is_entry: bool,
    /// Whether the function is a view function or not
    pub is_view: bool,
    /// Generic type params associated with the Move function
    pub generic_type_params: Vec<MoveFunctionGenericTypeParam>,
    /// Parameters associated with the move function
    pub params: Vec<MoveType>,
    /// Return type of the function
    #[serde(rename = "return")]
    #[oai(rename = "return")]
    pub return_: Vec<MoveType>,
}
```

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L35-53)
```rust
pub(crate) fn validate_view_function(
    session: &mut SessionExt<impl AptosMoveResolver>,
    loader: &impl Loader,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    args: Vec<Vec<u8>>,
    fun_name: &IdentStr,
    func: &LoadedFunction,
    module_metadata: Option<&RuntimeModuleMetadataV1>,
    struct_constructors_feature: bool,
) -> PartialVMResult<Vec<Vec<u8>>> {
    // Must be marked as view function.
    let is_view = determine_is_view(module_metadata, fun_name);
    if !is_view {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("function not marked as view function".to_string()),
        );
    }
```
