# Audit Report

## Title
Race Condition in Per-Key JWK Consensus Allows Mismatched Quorum Certificate Acceptance

## Summary
The `new_rb_request()` function does not check for duplicate (epoch, issuer, kid) tuples, and the higher-level `maybe_start_consensus()` function contains a flawed duplicate check that only considers consensus "already started" when the JWK value matches. This allows a race condition where consensus for a new JWK value can overwrite an in-progress consensus, but the aborted consensus may still deliver its quorum certificate, which gets blindly accepted without validation. This can cause validators to disagree on which JWK updates are certified, violating consensus determinism.

## Finding Description

The vulnerability exists in the per-key JWK consensus system and involves multiple interacting components:

**1. Missing Duplicate Check in `new_rb_request()`** [1](#0-0) 

The function simply creates an `ObservedKeyLevelUpdateRequest` without any duplicate checking. While this is by design (as a factory method), it relies on higher-level duplicate prevention.

**2. Flawed Duplicate Prevention in `maybe_start_consensus()`** [2](#0-1) 

The critical flaw is at line 187: the check only returns early if `my_proposal.observed.to_upsert == update.to_upsert`. If a different JWK value is observed for the same (issuer, kid), this evaluates to false, allowing a new consensus to start.

**3. State Overwriting via HashMap Insert** [3](#0-2) 

When a new consensus starts, it calls `states_by_key.insert()`, which **overwrites** the previous state. This drops the old `QuorumCertProcessGuard`, triggering an abort of the first consensus task.

**4. Race Condition with Async Task Completion** [4](#0-3) 

The consensus task may have already completed `rb.broadcast()` and sent the QC to the channel before the abort takes effect. The QC delivery is asynchronous.

**5. Missing Validation in QC Acceptance** [5](#0-4) 

When `process_quorum_certified_update()` receives a QC, it checks if the state is `InProgress` but **never validates** that the incoming `issuer_level_repr` matches the `my_proposal` in the current state. It blindly accepts any QC as long as consensus is in progress.

**Attack Scenario:**

1. Validator observes JWK value A for (epoch 100, issuer "Google", kid "key1")
2. `maybe_start_consensus()` starts consensus, spawning async task T1 for value A
3. JWK provider rotates to value B
4. Validator observes value B for the same (epoch 100, "Google", "key1")
5. `maybe_start_consensus()` checks: `A == B` → false, proceeds to start new consensus
6. New consensus task T2 is spawned for value B
7. State is overwritten: `states_by_key[("Google", "key1")] = InProgress{proposal: B, ...}`
8. Old abort handle is dropped, attempting to abort T1
9. **Race condition**: T1 may have already sent QC_A to the channel
10. `process_quorum_certified_update()` receives QC_A
11. Current state shows `InProgress{proposal: B, ...}`
12. QC_A is accepted without checking it matches proposal B
13. State becomes `Finished{my_proposal: B, quorum_certified: QC_A}` ← **Mismatch!**
14. Different validators experiencing different timing may accept different QCs
15. Validator transaction pool receives conflicting JWK updates from different validators

**Consensus Conflict:** [6](#0-5) 

The validator transaction pool uses topics to deduplicate. Each validator can have only one transaction per (issuer, kid) topic. If Validator1 accepts QC_A and Validator2 accepts QC_B, they will propose different validator transactions during block proposal, potentially causing consensus disagreement.

## Impact Explanation

**High Severity** - This qualifies as a "Significant protocol violation" under the Aptos bug bounty program for the following reasons:

1. **Breaks Deterministic Execution Invariant**: Validators may accept different quorum-certified JWK updates for the same key, leading to state divergence
2. **Validator Transaction Conflicts**: Different validators will have different transactions in their pools, causing proposal disagreements
3. **JWK Authentication Impact**: Incorrect JWK updates affect OpenID Connect authentication, a critical security component
4. **Does Not Cause Fund Loss**: This is limited to JWK consensus, not the main blockchain state or funds
5. **Does Not Halt Network**: The network continues operating, but with potential authentication inconsistencies

This does not reach **Critical** severity because it doesn't directly cause fund loss, permanent network partition, or complete liveness failure.

## Likelihood Explanation

**Medium Likelihood** - This vulnerability can occur under realistic conditions:

**Triggering Conditions:**
- Rapid JWK rotation by OIDC providers (common for security best practices)
- Network delays causing observations to arrive out of order across validators
- Different validators having slightly different observation timing
- No attacker action required - happens naturally during normal JWK updates

**Frequency:**
- JWK rotations occur regularly (hours to days) for security
- Each rotation has a chance of triggering the race condition
- More likely during coordinated key rotations across multiple providers

**Exploitability:**
- Does not require privileged access
- No special attacker actions needed
- Purely timing-dependent on natural system operations

## Recommendation

**Fix 1: Add Proposal Validation in `process_quorum_certified_update()`**

Add validation that the incoming QC matches the current proposal before accepting it:

```rust
pub fn process_quorum_certified_update(
    &mut self,
    issuer_level_repr: QuorumCertifiedUpdate,
) -> Result<()> {
    let key_level_update = KeyLevelUpdate::try_from_issuer_level_repr(&issuer_level_repr.update)?;
    let issuer = &key_level_update.issuer;
    let kid = &key_level_update.kid;
    
    let state = self.states_by_key.entry((issuer.clone(), kid.clone())).or_default();
    match state {
        ConsensusState::InProgress { my_proposal, .. } => {
            // ADDED: Validate QC matches current proposal
            let my_update = &my_proposal.observed.try_as_issuer_level_repr()?;
            ensure!(
                my_update == &issuer_level_repr.update,
                "QC update does not match current proposal"
            );
            
            // Original code continues...
            let topic = Topic::JWK_CONSENSUS_PER_KEY_MODE { ... };
            // ...
        },
        _ => Err(anyhow!("qc update not expected in state {}", state.name())),
    }
}
```

**Fix 2: Improve Duplicate Check in `maybe_start_consensus()`**

Change the duplicate check to prevent starting new consensus when any consensus is in progress, regardless of value:

```rust
fn maybe_start_consensus(&mut self, update: KeyLevelUpdate) -> Result<()> {
    let key = (update.issuer.clone(), update.kid.clone());
    
    // Check if consensus is already in progress for this key
    if matches!(
        self.states_by_key.get(&key),
        Some(ConsensusState::InProgress { .. })
    ) {
        // Log that we're skipping because consensus is already active
        debug!("Skipping consensus start - already in progress for {:?}", key);
        return Ok(());
    }
    
    // If Finished, we can start new consensus for a different value
    if let Some(ConsensusState::Finished { my_proposal, .. }) = self.states_by_key.get(&key) {
        if my_proposal.observed.to_upsert == update.to_upsert {
            // Same value already finished, skip
            return Ok(());
        }
        // Different value - clear the finished state and proceed
        self.states_by_key.remove(&key);
    }
    
    // Continue with starting consensus...
}
```

**Both fixes should be applied** for defense in depth.

## Proof of Concept

```rust
#[cfg(test)]
mod test_race_condition {
    use super::*;
    use aptos_types::jwks::{JWK, rsa::RSA_JWK};
    
    #[tokio::test]
    async fn test_mismatched_qc_acceptance() {
        // Setup: Create a KeyLevelConsensusManager
        let manager = setup_test_manager();
        
        // Step 1: Observe JWK value A
        let jwk_a = JWK::RSA(RSA_JWK::new_256_aqab("key1", "value_A"));
        let update_a = KeyLevelUpdate {
            issuer: b"google.com".to_vec(),
            base_version: 1,
            kid: b"key1".to_vec(),
            to_upsert: Some(jwk_a.clone()),
        };
        
        // Start consensus for value A
        manager.maybe_start_consensus(update_a.clone()).unwrap();
        
        // Verify state is InProgress with proposal A
        let state = manager.states_by_key.get(&(b"google.com".to_vec(), b"key1".to_vec()));
        assert!(matches!(state, Some(ConsensusState::InProgress { .. })));
        
        // Step 2: Before T1 completes, observe JWK value B
        let jwk_b = JWK::RSA(RSA_JWK::new_256_aqab("key1", "value_B"));
        let update_b = KeyLevelUpdate {
            issuer: b"google.com".to_vec(),
            base_version: 1,
            kid: b"key1".to_vec(),
            to_upsert: Some(jwk_b.clone()),
        };
        
        // Start consensus for value B (should overwrite)
        manager.maybe_start_consensus(update_b.clone()).unwrap();
        
        // State should now have proposal B
        let state = manager.states_by_key.get(&(b"google.com".to_vec(), b"key1".to_vec()));
        if let Some(ConsensusState::InProgress { my_proposal, .. }) = state {
            assert_eq!(my_proposal.observed.to_upsert, Some(jwk_b.clone()));
        }
        
        // Step 3: Simulate QC_A arriving (from aborted task)
        let qc_a = create_test_qc(update_a.try_as_issuer_level_repr().unwrap());
        
        // Process QC_A - this should fail but currently doesn't
        let result = manager.process_quorum_certified_update(qc_a);
        
        // BUG: This succeeds when it should fail
        assert!(result.is_ok(), "QC_A was accepted despite proposal being B");
        
        // Verify the inconsistency
        let state = manager.states_by_key.get(&(b"google.com".to_vec(), b"key1".to_vec()));
        if let Some(ConsensusState::Finished { my_proposal, quorum_certified, .. }) = state {
            // my_proposal has value B, but quorum_certified has value A
            assert_ne!(
                my_proposal.observed.to_upsert,
                KeyLevelUpdate::try_from_issuer_level_repr(&quorum_certified.update)
                    .unwrap()
                    .to_upsert
            );
        }
    }
}
```

**Notes:**
- The vulnerability exists in the production code paths used during normal JWK consensus operations
- It requires no attacker interaction, only natural timing variations in a distributed system
- The fix is straightforward: add validation that QCs match current proposals before acceptance
- This affects the security-critical OpenID Connect authentication system used by Aptos
- Different validators may end up with inconsistent views of which JWKs are certified, potentially causing authentication failures or security weaknesses

### Citations

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L32-40)
```rust
    fn new_rb_request(
        epoch: u64,
        payload: &ProviderJWKs,
    ) -> anyhow::Result<ObservedKeyLevelUpdateRequest> {
        let KeyLevelUpdate { issuer, kid, .. } =
            KeyLevelUpdate::try_from_issuer_level_repr(payload)
                .context("new_rb_request failed with repr translation")?;
        Ok(ObservedKeyLevelUpdateRequest { epoch, issuer, kid })
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L179-194)
```rust
    fn maybe_start_consensus(&mut self, update: KeyLevelUpdate) -> Result<()> {
        let consensus_already_started = match self
            .states_by_key
            .get(&(update.issuer.clone(), update.kid.clone()))
            .cloned()
        {
            Some(ConsensusState::InProgress { my_proposal, .. })
            | Some(ConsensusState::Finished { my_proposal, .. }) => {
                my_proposal.observed.to_upsert == update.to_upsert
            },
            _ => false,
        };

        if consensus_already_started {
            return Ok(());
        }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L216-228)
```rust
        self.states_by_key.insert(
            (update.issuer.clone(), update.kid.clone()),
            ConsensusState::InProgress {
                my_proposal: ObservedKeyLevelUpdate {
                    author: self.my_addr,
                    observed: update,
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard {
                    handle: abort_handle,
                },
            },
        );
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L334-354)
```rust
        match state {
            ConsensusState::InProgress { my_proposal, .. } => {
                let topic = Topic::JWK_CONSENSUS_PER_KEY_MODE {
                    issuer: issuer.clone(),
                    kid: kid.clone(),
                };
                let txn = ValidatorTransaction::ObservedJWKUpdate(issuer_level_repr.clone());
                let vtxn_guard = self.vtxn_pool.put(topic, Arc::new(txn), None);
                *state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: issuer_level_repr,
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    issuer = issuer_str,
                    kid = kid_str,
                    base_version = key_level_update.base_version,
                    "certified key-level update accepted."
                );
                Ok(())
```

**File:** crates/aptos-jwk-consensus/src/update_certifier.rs (L67-79)
```rust
        let task = async move {
            let qc_update = rb.broadcast(req, agg_state).await.expect("cannot fail");
            ConsensusMode::log_certify_done(epoch, &qc_update);
            let session_key = ConsensusMode::session_key_from_qc(&qc_update);
            match session_key {
                Ok(key) => {
                    let _ = qc_update_tx.push(key, qc_update);
                },
                Err(e) => {
                    error!("JWK update QCed but could not identify the session key: {e}");
                },
            }
        };
```

**File:** crates/validator-transaction-pool/src/lib.rs (L58-82)
```rust
    pub fn put(
        &self,
        topic: Topic,
        txn: Arc<ValidatorTransaction>,
        pull_notification_tx: Option<aptos_channel::Sender<(), Arc<ValidatorTransaction>>>,
    ) -> TxnGuard {
        let mut pool = self.inner.lock();
        let seq_num = pool.next_seq_num;
        pool.next_seq_num += 1;

        pool.txn_queue.insert(seq_num, PoolItem {
            topic: topic.clone(),
            txn,
            pull_notification_tx,
        });

        if let Some(old_seq_num) = pool.seq_nums_by_topic.insert(topic.clone(), seq_num) {
            pool.txn_queue.remove(&old_seq_num);
        }

        TxnGuard {
            pool: self.inner.clone(),
            seq_num,
        }
    }
```
