# Audit Report

## Title
Gas Parameter Post-Processing Bypass Leading to Consensus Divergence via Trait Abstraction Leakage

## Summary
The `FromOnChainGasSchedule` trait provides an incomplete abstraction for gas parameter initialization. Critical post-processing logic that overwrites table gas parameters exists outside the trait implementation, creating a risk of consensus divergence if validators use different code paths or implement custom gas parameter types.

## Finding Description

The `FromOnChainGasSchedule` trait in [1](#0-0)  promises to construct gas parameters from on-chain storage. However, this abstraction is fundamentally incomplete.

The trait implementation for `TableGasParameters` uses hardcoded initial values: [2](#0-1) 

After trait deserialization completes, the production execution path applies **mandatory post-processing** that completely overwrites these values based on feature version and storage pricing: [3](#0-2) 

This post-processing logic:
1. For feature versions 2-6: Uses `StorageGasSchedule.per_item_read` (separate on-chain config)
2. For feature versions 7-9: Uses `StorageGasSchedule.per_item_read` for `common_load_base_new`
3. For feature version 10+: Uses transaction-level storage IO parameters

The table load gas calculation directly uses these parameters: [4](#0-3) 

**Divergence Scenario**:

Multiple code paths exist that use the trait without post-processing:
- API context: [5](#0-4) 
- Test harness: [6](#0-5) 
- Simulation: [7](#0-6) 

While current production validators uniformly use the post-processing path via: [8](#0-7) 

The trait abstraction creates a **semantic contract violation**. Any implementation that:
1. Relies on the trait interface for gas parameter initialization
2. Doesn't discover the hidden post-processing requirement
3. Processes transactions with table operations

Will calculate **different gas costs** than the canonical implementation, violating the deterministic execution invariant.

## Impact Explanation

**Severity: Critical** (Consensus Divergence - up to $1,000,000 per Aptos Bug Bounty)

This breaks **Invariant #1: Deterministic Execution** - "All validators must produce identical state roots for identical blocks."

If validators using different code paths process blocks containing table operations (`table::add`, `table::borrow`, `table::remove`, `table::contains`), they will:
- Charge different gas amounts (difference between hardcoded 302,385 vs. actual storage pricing)
- Generate different gas refunds
- Potentially trigger different out-of-gas errors
- Produce different final state roots

This leads to **non-recoverable network partition** requiring a hard fork to resolve.

## Likelihood Explanation

**Current State**: Low likelihood - all official validators use identical code paths.

**Future Risk**: Medium-to-High likelihood for:
- Teams building alternative validator implementations
- Codebase refactoring that inadvertently removes post-processing
- Addition of new gas parameter types following the same flawed pattern
- Third-party tools that execute transactions for estimation/simulation

The trait interface **appears complete** but is fundamentally broken. The macro-generated implementation in: [9](#0-8) 

provides no indication that additional processing is required. The comment "These are dummy value" exists in the parameter definitions but doesn't explain the post-processing requirement.

## Recommendation

**Option 1: Encapsulate Post-Processing in Trait** (Preferred)

Move the post-processing logic into the trait implementation or add a separate initialization method that enforces the complete flow:

```rust
pub trait FromOnChainGasSchedule: Sized {
    fn from_on_chain_gas_schedule(
        gas_schedule: &BTreeMap<String, u64>,
        feature_version: u64,
    ) -> Result<Self, String>;
    
    // New method to handle post-processing
    fn finalize_with_storage_config(
        &mut self,
        feature_version: u64,
        features: &Features,
        config_storage: &impl ConfigStorage,
    ) -> Result<(), String>;
}
```

Then implement `finalize_with_storage_config` for `TableGasParameters` to encapsulate the version-dependent logic.

**Option 2: Deprecate Direct Trait Usage**

Make the trait implementation `pub(crate)` and force all consumers to use `get_gas_parameters()` which guarantees post-processing. Add compile-time warnings for direct trait usage.

**Option 3: Remove Hardcoded Dummy Values**

Make the trait fail with a clear error if required parameters are missing from on-chain storage, forcing proper configuration rather than silently using incorrect defaults.

## Proof of Concept

```rust
// Demonstrates gas calculation divergence
use aptos_gas_schedule::{AptosGasParameters, FromOnChainGasSchedule};
use aptos_types::on_chain_config::GasScheduleV2;

fn test_gas_divergence() {
    // Simulate two validators processing the same block
    let gas_schedule_v2 = GasScheduleV2 {
        feature_version: 10,
        entries: vec![
            ("table.common.load.base".to_string(), 302385),
            ("table.common.load.per_byte".to_string(), 151),
            // ... other params
        ],
    };
    
    // Validator A: Uses trait directly (incorrect)
    let params_a = AptosGasParameters::from_on_chain_gas_schedule(
        &gas_schedule_v2.into_btree_map(),
        10,
    ).unwrap();
    
    // Validator B: Uses production path with post-processing (correct)
    // This would call get_gas_parameters() which modifies:
    // params_b.natives.table.common_load_base_new = 
    //     params_b.vm.txn.storage_io_per_state_slot_read
    
    // For a table load of 1000 bytes:
    // Validator A charges: 302385 (legacy) + 302385 (new) + 151*1000 = 755,770 gas
    // Validator B charges: 0 (legacy) + X (storage param) + Y*1000 = different value
    
    // Result: Different gas costs → Different refunds → Different state roots
    // → CONSENSUS DIVERGENCE
}
```

---

**Notes**:

While all current production validators use the correct code path, this design flaw represents a **latent consensus vulnerability**. The trait abstraction violates the principle of complete encapsulation, hiding critical initialization logic in a separate module. This creates significant risk for:

1. Future maintainability (refactoring could break consensus)
2. Third-party implementations (trait appears sufficient but isn't)
3. Code reuse in non-consensus contexts (API, tests) using incorrect parameters

The `StorageGasSchedule` dependency is particularly problematic - it's fetched from a separate on-chain config: [10](#0-9) 

This creates a complex, non-obvious dependency chain that violates the trait's semantic contract.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/traits.rs (L7-15)
```rust
pub trait FromOnChainGasSchedule: Sized {
    /// Constructs a value of this type from a map representation of the on-chain gas schedule.
    /// `None` should be returned when the gas schedule is missing some required entries.
    /// Unused entries should be safely ignored.
    fn from_on_chain_gas_schedule(
        gas_schedule: &BTreeMap<String, u64>,
        feature_version: u64,
    ) -> Result<Self, String>;
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/table.rs (L14-18)
```rust
        // These are dummy value, they copied from storage gas in aptos-core/aptos-vm/src/aptos_vm_impl.rs
        [common_load_base_legacy: InternalGas, "common.load.base", 302385],
        [common_load_base_new: InternalGas, { 7.. => "common.load.base_new" }, 302385],
        [common_load_per_byte: InternalGasPerByte, "common.load.per_byte", 151],
        [common_load_failure: InternalGas, "common.load.failure", 0],
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L66-93)
```rust
            // TODO(gas): Table extension utilizes IoPricing directly.
            // Overwrite table io gas parameters with global io pricing.
            let g = &mut gas_params.natives.table;
            match gas_feature_version {
                0..=1 => (),
                2..=6 => {
                    if let IoPricing::V2(pricing) = &storage_gas_params.io_pricing {
                        g.common_load_base_legacy = pricing.per_item_read * NumArgs::new(1);
                        g.common_load_base_new = 0.into();
                        g.common_load_per_byte = pricing.per_byte_read;
                        g.common_load_failure = 0.into();
                    }
                }
                7..=9 => {
                    if let IoPricing::V2(pricing) = &storage_gas_params.io_pricing {
                        g.common_load_base_legacy = 0.into();
                        g.common_load_base_new = pricing.per_item_read * NumArgs::new(1);
                        g.common_load_per_byte = pricing.per_byte_read;
                        g.common_load_failure = 0.into();
                    }
                }
                10.. => {
                    g.common_load_base_legacy = 0.into();
                    g.common_load_base_new = gas_params.vm.txn.storage_io_per_state_slot_read * NumArgs::new(1);
                    g.common_load_per_byte = gas_params.vm.txn.storage_io_per_state_byte_read;
                    g.common_load_failure = 0.into();
                }
            };
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L325-351)
```rust
fn charge_load_cost(
    context: &mut SafeNativeContext,
    loaded: Option<Option<NumBytes>>,
) -> SafeNativeResult<()> {
    context.charge(COMMON_LOAD_BASE_LEGACY)?;

    match loaded {
        Some(Some(num_bytes)) => {
            let num_bytes = if context.gas_feature_version() >= 12 {
                // Round up bytes to whole pages
                // TODO(gas): make PAGE_SIZE configurable
                const PAGE_SIZE: u64 = 4096;

                let loaded_u64: u64 = num_bytes.into();
                let r = loaded_u64 % PAGE_SIZE;
                let rounded_up = loaded_u64 + if r == 0 { 0 } else { PAGE_SIZE - r };

                NumBytes::new(rounded_up)
            } else {
                num_bytes
            };
            context.charge(COMMON_LOAD_BASE_NEW + COMMON_LOAD_PER_BYTE * num_bytes)
        },
        Some(None) => context.charge(COMMON_LOAD_BASE_NEW + COMMON_LOAD_FAILURE),
        None => Ok(()),
    }
}
```

**File:** api/src/context.rs (L1509-1513)
```rust
                        AptosGasParameters::from_on_chain_gas_schedule(
                            &gas_schedule,
                            feature_version,
                        )
                        .ok()
```

**File:** aptos-move/e2e-move-tests/src/harness.rs (L169-173)
```rust
        let gas_params = AptosGasParameters::from_on_chain_gas_schedule(
            &gas_schedule.into_btree_map(),
            feature_version,
        )
        .unwrap();
```

**File:** aptos-move/aptos-release-builder/src/simulate.rs (L439-442)
```rust
        let gas_params = AptosGasParameters::from_on_chain_gas_schedule(
            &gas_schedule.into_btree_map(),
            gas_feature_version,
        )
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L212-213)
```rust
        let storage_environment =
            AptosEnvironment::new_with_delayed_field_optimization_enabled(&state_view);
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L32-46)
```rust
        impl $crate::traits::FromOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
        }
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L242-266)
```rust
    pub fn new(
        feature_version: u64,
        gas_params: &AptosGasParameters,
        config_storage: &impl ConfigStorage,
    ) -> IoPricing {
        use aptos_types::on_chain_config::OnChainConfig;
        use IoPricing::*;

        match feature_version {
            0 => V1(IoPricingV1::new(gas_params)),
            1..=9 => match StorageGasSchedule::fetch_config(config_storage) {
                None => V1(IoPricingV1::new(gas_params)),
                Some(schedule) => V2(IoPricingV2::new_with_storage_curves(
                    feature_version,
                    &schedule,
                    gas_params,
                )),
            },
            10..=11 => V3(IoPricingV3 {
                feature_version,
                legacy_free_write_bytes_quota: gas_params.vm.txn.legacy_free_write_bytes_quota,
            }),
            12.. => V4(IoPricingV4),
        }
    }
```
