# Audit Report

## Title
Genesis Configuration Allows Zero or Past Timestamp for Employee Vesting Start, Enabling Immediate Vesting Schedule Violation

## Summary
The `employee_vesting_start` field in the genesis configuration can be set to 0 or a past timestamp without proper validation, allowing all employee vesting to unlock immediately upon blockchain launch instead of over the intended multi-year schedule.

## Finding Description

The vulnerability exists in the genesis configuration validation flow. The `employee_vesting_start` field is defined as an optional u64 timestamp in the genesis configuration [1](#0-0) , but lacks Rust-side validation to ensure it represents a reasonable future timestamp.

During genesis initialization, the timestamp module is initialized to 0 microseconds [2](#0-1) . Subsequently, employee vesting contracts are created with the configured `employee_vesting_start` value [3](#0-2) .

The Move-side validation in `create_vesting_schedule` checks that the start timestamp must be greater than or equal to the current blockchain time [4](#0-3) . However, since the blockchain time is 0 during genesis, setting `employee_vesting_start` to 0 or 1 passes this validation (0 >= 0).

When the blockchain launches and the first block updates the timestamp to actual current time (e.g., ~1.7 billion seconds for 2024), the vesting contract's start time becomes far in the past. When `vest()` is called, it calculates completed periods as `(current_time - 0) / period_duration` [5](#0-4) , resulting in an enormous number of completed periods that far exceeds the intended vesting schedule.

The Rust validation function `validate_genesis_config` does not check `employee_vesting_start` at all [6](#0-5) .

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria for "Limited funds loss or manipulation" and "State inconsistencies requiring intervention."

If `employee_vesting_start` is misconfigured to 0 or a small value:
- All employee tokens vest immediately instead of over the intended 3-4 year schedule
- Violates the fundamental vesting invariant of time-locked compensation
- Could cause economic disruption if employees immediately liquidate tokens
- Requires manual intervention or hard fork to correct

While this doesn't constitute direct fund theft, it represents a severe violation of intended vesting mechanics that could result in premature distribution of millions of tokens meant to vest over years.

## Likelihood Explanation

**Likelihood: Low to Medium**

This requires control over the genesis configuration file, which is not accessible to unprivileged attackers. However, it could occur through:
- Accidental misconfiguration (setting to 0 instead of proper Unix timestamp)
- Copy-paste error from test configuration
- Malicious insider with genesis preparation access
- Lack of automated validation in CI/CD pipeline

The default value is properly set [7](#0-6) , but custom configurations are not validated.

## Recommendation

Add validation in `validate_genesis_config` to ensure `employee_vesting_start` represents a reasonable future timestamp:

```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    // Existing validations...
    
    // Validate employee vesting start time
    let current_time = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs();
    
    assert!(
        genesis_config.employee_vesting_start > current_time,
        "Employee vesting start time must be in the future. Got: {}, Current: {}",
        genesis_config.employee_vesting_start,
        current_time
    );
    
    assert!(
        genesis_config.employee_vesting_start < current_time + (365 * 24 * 3600 * 2), // 2 years in future
        "Employee vesting start time is too far in the future (>2 years)"
    );
}
```

Additionally, add validation when reading from YAML in `Layout::from_disk` to fail early if the value is clearly invalid.

## Proof of Concept

**Test Scenario:**

1. Create genesis configuration with `employee_vesting_start: 0`
2. Execute genesis transaction (blockchain time = 0)
3. Validation passes: `assert!(0 >= 0)` succeeds
4. Blockchain launches, first block sets time to 1729000000 (Oct 2024)
5. Call `vest(contract_address)`
6. Vesting proceeds because `0 < 1729000000`
7. Calculated periods: `(1729000000 - 0) / 300 = 5,763,333` periods
8. All vesting unlocks immediately

**Move Test Reproduction:**

```move
#[test(aptos_framework = @0x1, admin = @0x123)]
public entry fun test_genesis_vesting_with_zero_start(
    aptos_framework: &signer,
    admin: &signer,
) {
    // Simulate genesis: time = 0
    timestamp::set_time_has_started_for_testing(aptos_framework);
    
    // Create vesting schedule with start = 0 (passes during genesis)
    let schedule = create_vesting_schedule(
        vector[fixed_point32::create_from_rational(1, 48)],
        0,  // employee_vesting_start = 0
        2592000  // 30 days period
    );
    
    // Simulate blockchain launch: update time to real current time
    timestamp::update_global_time_for_test_secs(1729000000);
    
    // Vest should now allow immediate unlocking
    // Calculated periods would be enormous: ~19907 periods
    // All vesting completes immediately instead of over 4 years
}
```

## Notes

This is a **configuration validation vulnerability** rather than a runtime exploit. It requires privileged access to genesis configuration but represents a critical gap in defensive validation that could lead to severe economic consequences if misconfigured. The issue should be addressed by adding proper timestamp validation in the Rust genesis preparation code before the genesis transaction is created.

### Citations

**File:** crates/aptos-genesis/src/config.rs (L69-69)
```rust
    pub employee_vesting_start: Option<u64>,
```

**File:** crates/aptos-genesis/src/config.rs (L125-125)
```rust
            employee_vesting_start: Some(1663456089),
```

**File:** aptos-move/framework/aptos-framework/sources/timestamp.move (L25-29)
```text
    public(friend) fun set_time_has_started(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        let timer = CurrentTimeMicroseconds { microseconds: 0 };
        move_to(aptos_framework, timer);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L251-254)
```text
            let vesting_schedule = vesting::create_vesting_schedule(
                schedule,
                employee_vesting_start,
                employee_vesting_period_duration,
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L531-534)
```text
        assert!(
            start_timestamp_secs >= timestamp::now_seconds(),
            error::invalid_argument(EVESTING_START_TOO_SOON),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L695-696)
```text
        let last_completed_period =
            (timestamp::now_seconds() - vesting_schedule.start_timestamp_secs) / vesting_schedule.period_duration;
```

**File:** aptos-move/vm-genesis/src/lib.rs (L405-439)
```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    assert!(
        genesis_config.min_stake <= genesis_config.max_stake,
        "Min stake must be smaller than or equal to max stake"
    );
    assert!(
        genesis_config.epoch_duration_secs > 0,
        "Epoch duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs > 0,
        "Recurring lockup duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs >= genesis_config.epoch_duration_secs,
        "Recurring lockup duration must be at least as long as epoch duration"
    );
    assert!(
        genesis_config.rewards_apy_percentage > 0 && genesis_config.rewards_apy_percentage < 100,
        "Rewards APY must be > 0% and < 100%"
    );
    assert!(
        genesis_config.voting_duration_secs > 0,
        "On-chain voting duration must be > 0"
    );
    assert!(
        genesis_config.voting_duration_secs < genesis_config.recurring_lockup_duration_secs,
        "Voting duration must be strictly smaller than recurring lockup"
    );
    assert!(
        genesis_config.voting_power_increase_limit > 0
            && genesis_config.voting_power_increase_limit <= 50,
        "voting_power_increase_limit must be > 0 and <= 50"
    );
}
```
