# Audit Report

## Title
SSRF Vulnerability in Move Package Dependency Resolution Allows Access to Internal Services via Malicious node_url

## Summary
The `maybe_download_package()` function in `package_hooks.rs` fails to validate user-controlled `node_url` values from Move.toml dependency declarations before making HTTP requests. An attacker can specify internal IP addresses, IPv6 addresses, or alternate IP representations to bypass URL filtering and access internal services, cloud metadata endpoints, or perform port scanning. [1](#0-0) 

## Finding Description
When the Aptos CLI processes Move package dependencies with custom "aptos" keys, it extracts the `node_url` from the dependency declaration and uses it to download packages from on-chain registries. The vulnerability occurs through this chain:

1. **Manifest Parsing**: The `parse_dependency()` function extracts `node_url` from Move.toml without validation [2](#0-1) 

2. **Hook Resolution**: During dependency resolution, the system calls `resolve_custom_dependency()` with the unchecked URL [3](#0-2) 

3. **HTTP Request**: The `maybe_download_package()` function parses the URL using only `Url::parse()` which validates syntax but not security, then creates an HTTP client that makes requests to the attacker-controlled destination [4](#0-3) 

4. **Client Creation**: The `CachedPackageRegistry::create()` function directly uses the URL without any SSRF checks [5](#0-4) 

The hooks are registered at CLI startup, making this vulnerability active for all Move package operations: [6](#0-5) 

An attacker can craft a malicious Move.toml with entries like:
```toml
[dependencies]
MaliciousPackage = { aptos = "http://127.0.0.1:6379", address = "0x1" }
MaliciousPackage2 = { aptos = "http://169.254.169.254/latest/meta-data/", address = "0x2" }
MaliciousPackage3 = { aptos = "http://[::1]:8080/admin", address = "0x3" }
MaliciousPackage4 = { aptos = "http://0177.0.0.1/internal", address = "0x4" }
```

When a victim runs `aptos move compile`, `aptos move test`, or `aptos move publish`, the CLI will make HTTP requests to these internal endpoints without validation.

## Impact Explanation
This is a **High Severity** vulnerability according to Aptos bug bounty criteria for the following reasons:

1. **API Access**: Attackers can access internal REST APIs, admin interfaces, and development servers not meant to be publicly accessible
2. **Cloud Metadata Services**: Access to `169.254.169.254` allows credential theft from AWS, GCP, or Azure metadata services
3. **Port Scanning**: Attackers can enumerate internal network topology and discover running services
4. **Information Disclosure**: Internal service responses can leak sensitive configuration, version information, or application data
5. **Potential for Further Exploitation**: Successful SSRF can be chained with other vulnerabilities in internal services

While this doesn't directly affect blockchain consensus or validator nodes, it compromises the security of developer environments and CI/CD pipelines where the Aptos CLI is used. An attacker distributing a malicious Move package could compromise all developers who attempt to build it.

## Likelihood Explanation
The likelihood of exploitation is **High** because:

1. **Common Attack Vector**: Developers frequently download and build third-party Move packages, similar to npm/cargo/pip packages
2. **No Special Privileges Required**: Any attacker can create a malicious Move.toml and distribute it via GitHub, forums, or documentation
3. **Silent Exploitation**: SSRF attempts occur during normal build operations without obvious indicators to the victim
4. **Wide Attack Surface**: All Aptos CLI commands that process dependencies are affected (compile, test, publish, verify)
5. **No Warning to Users**: The CLI provides no warnings about untrusted dependency sources

## Recommendation
Implement comprehensive URL validation before making HTTP requests in `maybe_download_package()`:

```rust
async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    if !info
        .download_to
        .join(CompiledPackageLayout::BuildInfo.path())
        .exists()
    {
        let url = Url::parse(info.node_url.as_str())?;
        
        // Validate URL for SSRF protection
        validate_url_for_ssrf(&url)?;
        
        let registry = CachedPackageRegistry::create(
            url,
            load_account_arg(info.package_address.as_str())?,
            false,
        )
        .await?;
        let package = registry.get_package(info.package_name).await?;
        package.save_package_to_disk(info.download_to.as_path())
    } else {
        Ok(())
    }
}

fn validate_url_for_ssrf(url: &Url) -> anyhow::Result<()> {
    // Only allow http and https schemes
    if url.scheme() != "http" && url.scheme() != "https" {
        bail!("Only http and https URLs are allowed");
    }
    
    // Get the host
    let host = url.host_str().ok_or_else(|| anyhow!("URL must have a host"))?;
    
    // Block IP addresses - require domain names
    if host.parse::<std::net::IpAddr>().is_ok() {
        bail!("IP addresses are not allowed in node URLs. Use domain names instead.");
    }
    
    // Additional checks could include:
    // - Maintain an allowlist of trusted domains
    // - Resolve DNS and check resolved IPs aren't private
    // - Require HTTPS for production use
    
    Ok(())
}
```

Alternatively, implement DNS resolution with IP filtering as seen in the network layer: [7](#0-6) 

## Proof of Concept

Create a malicious Move.toml:
```toml
[package]
name = "MaliciousPackage"
version = "1.0.0"

[dependencies]
# This will attempt to access local Redis
EvilDep1 = { aptos = "http://127.0.0.1:6379", address = "0x1" }

# This will attempt to access AWS metadata service
EvilDep2 = { aptos = "http://169.254.169.254/latest/meta-data/iam/security-credentials/", address = "0x2" }

# This will attempt IPv6 localhost
EvilDep3 = { aptos = "http://[::1]:8080/admin", address = "0x3" }

# This will attempt octal representation
EvilDep4 = { aptos = "http://0177.0.0.1:22", address = "0x4" }
```

When a victim runs:
```bash
aptos move compile --package-dir ./MaliciousPackage
```

The CLI will make HTTP GET requests to:
- `http://127.0.0.1:6379/v1/accounts/0x1/resource/0x1::code::PackageRegistry` 
- `http://169.254.169.254/latest/meta-data/iam/security-credentials//v1/accounts/0x2/resource/0x1::code::PackageRegistry`
- `http://[::1]:8080/admin/v1/accounts/0x3/resource/0x1::code::PackageRegistry`
- `http://0177.0.0.1:22/v1/accounts/0x4/resource/0x1::code::PackageRegistry`

These requests will be visible in target service logs or can be confirmed using a local HTTP server to capture the requests.

## Notes

This vulnerability exists because the Move package system's extensibility mechanism (custom dependency hooks) was designed to download packages from blockchain nodes but lacks security controls appropriate for handling untrusted user input. The URL is controlled entirely by the Move.toml author and processed without validation, creating a classic SSRF vulnerability.

While the immediate impact is limited to developer machines and CI/CD environments (not validator nodes), this is still a significant security issue that violates the principle of least privilege and could enable supply chain attacks against Aptos ecosystem developers.

### Citations

**File:** crates/aptos/src/move_tool/package_hooks.rs (L38-55)
```rust
async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    if !info
        .download_to
        .join(CompiledPackageLayout::BuildInfo.path())
        .exists()
    {
        let registry = CachedPackageRegistry::create(
            Url::parse(info.node_url.as_str())?,
            load_account_arg(info.package_address.as_str())?,
            false,
        )
        .await?;
        let package = registry.get_package(info.package_name).await?;
        package.save_package_to_disk(info.download_to.as_path())
    } else {
        Ok(())
    }
}
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L392-416)
```rust
                (None, None, Some(custom_key)) => {
                    let package_name = Symbol::from(dep_name);
                    let address = match table.remove("address") {
                        None => bail!("Address not supplied for 'node' dependency"),
                        Some(r) => Symbol::from(
                            r.as_str()
                                .ok_or_else(|| format_err!("Node address not a string"))?,
                        ),
                    };
                    // Downloaded packages are of the form <sanitized_node_url>_<address>_<package>
                    let node_url = custom_key
                        .as_str()
                        .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
                    let local_path = PathBuf::from(MOVE_HOME.clone()).join(format!(
                        "{}_{}_{}",
                        url_to_file_name(node_url),
                        address,
                        package_name
                    ));
                    node_info = Some(PM::CustomDepInfo {
                        node_url: Symbol::from(node_url),
                        package_address: address,
                        package_name,
                        download_to: local_path.clone(),
                    });
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L612-614)
```rust
        if let Some(node_info) = &dep.node_info {
            package_hooks::resolve_custom_dependency(dep_name, node_info)?
        }
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L43-53)
```rust
    pub async fn create(
        url: Url,
        addr: AccountAddress,
        with_bytecode: bool,
    ) -> anyhow::Result<Self> {
        let client = Client::new(url);
        // Need to use a different type to deserialize JSON
        let inner = client
            .get_account_resource_bcs::<PackageRegistry>(addr, "0x1::code::PackageRegistry")
            .await?
            .into_inner();
```

**File:** crates/aptos/src/main.rs (L16-18)
```rust
fn main() {
    // Register hooks.
    move_tool::register_package_hooks();
```

**File:** network/netcore/src/transport/tcp.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```
