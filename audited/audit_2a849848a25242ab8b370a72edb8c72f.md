# Audit Report

## Title
Encrypted Transactions Bypass Content-Based Transaction Filters in Mempool, Consensus, and Execution Layers

## Summary
The `TransactionFilter` implementation fails to properly inspect encrypted transaction payloads in the `Encrypted` state, allowing attackers to bypass all content-based filtering rules (entry function matching, module address matching, script argument matching) by simply encrypting their transactions. This affects critical security controls across mempool submission, API simulation, consensus voting, execution filtering, and quorum store batch processing.

## Finding Description

The Aptos Core transaction filtering system is designed to enforce access control policies by allowing or denying transactions based on their content (entry functions, module addresses, etc.). However, when a transaction uses `EncryptedPayload` in the `Encrypted` state (before decryption), the filter cannot access the transaction's executable content, causing all content-based filter rules to fail silently.

**Root Cause:**

The `EncryptedPayload` enum has three states: [1](#0-0) 

When a payload is in the `Encrypted` state, the `executable_ref()` method returns an error: [2](#0-1) 

The `TransactionFilter` attempts to match entry functions, module addresses, and script arguments for `EncryptedPayload` transactions: [3](#0-2) 

When `payload.executable_ref()` fails with "Transaction is encrypted", the `if let Ok(executable)` guard fails, and the function returns `false`. This means the filter rule **does not match**, allowing the transaction through even if it should be denied.

**Attack Propagation Path:**

1. **Mempool Filtering**: When transactions are submitted to mempool, they pass through `filter_transactions()` [4](#0-3) 

2. **API Simulation Filtering**: When users simulate transactions via API, the filter checks are applied [5](#0-4) 

3. **Filter Configuration**: The system supports multiple filters for different layers [6](#0-5) 

4. **Encrypted Payload Identification**: While the filter can identify that a transaction IS encrypted [7](#0-6) , it cannot inspect the encrypted content to apply content-based rules.

5. **Bypass Mechanism**: An attacker creates a transaction calling a restricted function, encrypts it (keeping it in `Encrypted` state), submits it through mempool, and the filter fails to extract the executable content, returning `false` for all content matchers. The deny rule doesn't apply, and the transaction is admitted.

**Broken Invariants:**

- **Transaction Validation**: Filters must enforce all invariants regardless of payload format
- **Access Control**: System must prevent execution of restricted operations at filter boundaries
- **Deterministic Execution**: All validators should agree on which transactions pass filtering

## Impact Explanation

**Severity: High (up to $50,000) - Significant Protocol Violation**

This vulnerability constitutes a significant protocol violation because:

1. **Security Control Bypass**: Transaction filters are deployed as security mechanisms to restrict access to sensitive operations. Complete bypass undermines the entire filtering layer.

2. **Multi-Layer Impact**: The vulnerability affects five critical filtering points:
   - Mempool submission (`mempool_filter`)
   - API transaction simulation (`api_filter`)
   - Consensus voting (`consensus_filter`)
   - Block execution (`execution_filter`)
   - Quorum store batching (`quorum_store_filter`)

3. **Attack Surface**: Any unprivileged transaction sender can exploit this by encrypting their transaction payload. No special privileges, validator collusion, or complex setup required.

4. **Real-World Deployment**: Production networks that configure filters to restrict certain entry functions (e.g., administrative operations, governance actions, or module upgrades) are vulnerable if encrypted transactions are enabled.

While this doesn't directly cause loss of funds or consensus safety violations (the transactions still execute through normal validation), it bypasses a fundamental security boundary, allowing restricted operations to proceed when they should be blocked.

## Likelihood Explanation

**Likelihood: Medium-High**

The likelihood is significant because:

1. **Simple Exploitation**: An attacker only needs to encrypt their transaction payload. No complex cryptographic attacks or deep protocol knowledge required.

2. **Deployment Dependency**: The vulnerability only manifests when:
   - Transaction filters are configured and enabled (via `filter_enabled: true`)
   - Encrypted transactions feature is active
   - Content-based filter rules exist (entry function, module address, etc.)

3. **Feature Adoption**: As encrypted transactions become more widely adopted in Aptos, and as operators configure filters for security/compliance reasons, the attack surface grows.

4. **Detection Difficulty**: The bypass is silent - there's no error or warning that filtering failed. Operators may not realize their filters are ineffective against encrypted payloads.

5. **Legitimate Use Case**: Encrypted transactions are a legitimate feature, so attackers can hide malicious activity within normal encrypted transaction traffic.

## Recommendation

**Immediate Fix:**

Modify the filter matching logic to handle encrypted payloads securely. There are three approaches:

**Option 1: Deny all encrypted transactions when content-based filters are active**

```rust
// In TransactionMatcher::matches()
TransactionMatcher::EntryFunction(address, module_name, function) => {
    match signed_transaction.payload() {
        TransactionPayload::EncryptedPayload(payload) => {
            // If still encrypted, deny by default for security
            if payload.is_encrypted() {
                return false; // Conservative: deny unknown content
            }
            // If decrypted, check normally
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function(entry_function, address, module_name, function)
                    },
                    _ => false,
                }
            } else {
                false
            }
        },
        // ... handle other payload types
    }
}
```

**Option 2: Add explicit filter rule for encrypted transactions**

Require operators to explicitly allow encrypted transactions:

```yaml
mempool_filter:
  filter_enabled: true
  transaction_filter:
    transaction_rules:
      # Must explicitly allow encrypted transactions first
      - Allow:
          - EncryptedTransaction
      # Then apply content filters
      - Deny:
          - EntryFunction: ["0x1", "restricted", "admin_op"]
```

**Option 3: Require decryption before filtering (architectural change)**

Ensure all encrypted transactions are decrypted before they reach the filter layer. This requires changes to the transaction processing pipeline.

**Documentation Fix:**

Update filter documentation to clearly warn operators that content-based filters cannot inspect encrypted payloads in `Encrypted` state, and provide guidance on how to handle encrypted transactions securely.

## Proof of Concept

```rust
#[test]
fn test_encrypted_transaction_bypasses_entry_function_filter() {
    use aptos_types::{
        chain_id::ChainId,
        transaction::{
            encrypted_payload::EncryptedPayload, EntryFunction, RawTransaction,
            SignedTransaction, TransactionExecutable, TransactionExtraConfig,
            TransactionPayload,
        },
    };
    use aptos_crypto::{ed25519::Ed25519PrivateKey, HashValue, PrivateKey, SigningKey, Uniform};
    use move_core_types::account_address::AccountAddress;
    
    // Create a filter that denies transactions calling 0x1::coin::transfer
    let filter = TransactionFilter::empty()
        .add_entry_function_filter(false, AccountAddress::ONE, "coin".to_string(), "transfer".to_string())
        .add_all_filter(true);
    
    // Create a plaintext transaction calling coin::transfer
    let entry_function = EntryFunction::new(
        move_core_types::language_storage::ModuleId::new(
            AccountAddress::ONE,
            move_core_types::identifier::Identifier::new("coin").unwrap(),
        ),
        move_core_types::identifier::Identifier::new("transfer").unwrap(),
        vec![],
        vec![],
    );
    
    let plaintext_payload = TransactionPayload::EntryFunction(entry_function.clone());
    let private_key = Ed25519PrivateKey::generate_for_testing();
    let raw_txn = RawTransaction::new(
        AccountAddress::random(),
        0,
        plaintext_payload,
        1000,
        1,
        1000,
        ChainId::new(1),
    );
    let plaintext_transaction = SignedTransaction::new(
        raw_txn.clone(),
        private_key.public_key(),
        private_key.sign(&raw_txn).unwrap(),
    );
    
    // Verify plaintext transaction is DENIED
    assert!(!filter.allows_transaction(&plaintext_transaction));
    
    // Create an ENCRYPTED transaction with the same entry function
    let encrypted_payload = EncryptedPayload::Encrypted {
        ciphertext: aptos_types::secret_sharing::Ciphertext::random(),
        extra_config: TransactionExtraConfig::V1 {
            multisig_address: None,
            replay_protection_nonce: None,
        },
        payload_hash: HashValue::random(),
    };
    
    let encrypted_transaction_payload = TransactionPayload::EncryptedPayload(encrypted_payload);
    let raw_txn_encrypted = RawTransaction::new(
        AccountAddress::random(),
        0,
        encrypted_transaction_payload,
        1000,
        1,
        1000,
        ChainId::new(1),
    );
    let encrypted_transaction = SignedTransaction::new(
        raw_txn_encrypted.clone(),
        private_key.public_key(),
        private_key.sign(&raw_txn_encrypted).unwrap(),
    );
    
    // VULNERABILITY: Encrypted transaction BYPASSES the filter!
    assert!(filter.allows_transaction(&encrypted_transaction));
    
    // Even though it contains the same restricted entry function,
    // it passes through because the filter cannot inspect encrypted content
    println!("VULNERABILITY CONFIRMED: Encrypted transaction bypassed entry function filter!");
}
```

**Expected Behavior**: Both transactions should be denied by the filter.

**Actual Behavior**: Plaintext transaction is correctly denied, but encrypted transaction bypasses the filter and is allowed through.

## Notes

1. **Extra Config Accessible**: While encrypted transactions bypass content filtering, the `extra_config` field (containing `multisig_address` and `replay_protection_nonce`) CAN still be accessed even for encrypted payloads [8](#0-7) . Only the `executable` content is inaccessible.

2. **Three States Matter**: The vulnerability specifically affects `EncryptedPayload::Encrypted` state. Once decrypted to `EncryptedPayload::Decrypted` state (with executable field populated), the filter can inspect content normally [9](#0-8) .

3. **Multiple Matchers Affected**: The bypass affects `EntryFunction`, `ModuleAddress`, and script argument matching in `AccountAddress` matcher. The `Sender`, `TransactionId`, `PublicKey`, and `EncryptedTransaction` matchers work correctly.

4. **Test Evidence**: Existing tests only verify that encrypted transactions can be identified, not that content-based filtering works for encrypted payloads [10](#0-9) .

### Citations

**File:** types/src/transaction/encrypted_payload.rs (L42-64)
```rust
pub enum EncryptedPayload {
    Encrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
    },
    FailedDecryption {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,
    },
    Decrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,

        // decrypted things
        executable: TransactionExecutable,
        decryption_nonce: u64,
    },
}
```

**File:** types/src/transaction/encrypted_payload.rs (L82-87)
```rust
    pub fn executable_ref(&self) -> Result<TransactionExecutableRef<'_>> {
        let Self::Decrypted { executable, .. } = self else {
            bail!("Transaction is encrypted");
        };
        Ok(executable.as_ref())
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L362-374)
```rust
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function(entry_function, address, module_name, function)
                    },
                }
            } else {
                false
            }
        },
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L440-447)
```rust
        TransactionPayload::EncryptedPayload(payload) => match payload.extra_config() {
            TransactionExtraConfig::V1 {
                multisig_address, ..
            } => multisig_address
                .map(|multisig_address| multisig_address == *address)
                .unwrap_or(false),
        },
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L435-437)
```rust
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
```

**File:** api/src/transactions.rs (L621-625)
```rust
            if api_filter.is_enabled()
                && !api_filter
                    .transaction_filter()
                    .allows_transaction(&signed_transaction)
            {
```

**File:** config/src/config/transaction_filters_config.rs (L10-18)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
}
```

**File:** types/src/transaction/mod.rs (L959-961)
```rust
    pub fn is_encrypted_variant(&self) -> bool {
        matches!(self, Self::EncryptedPayload(_))
    }
```

**File:** crates/aptos-transaction-filters/src/tests/transaction_filter.rs (L143-163)
```rust
#[test]
fn test_encrypted_transaction_filter() {
    // Create a filter that only allows encrypted transactions
    let transactions = utils::create_encrypted_and_plaintext_transactions();
    let filter = TransactionFilter::empty()
        .add_encrypted_transaction_filter(true)
        .add_all_filter(false);

    // Verify that the filter returns only encrypted transactions (txn 0, 1 and 2)
    let filtered_transactions = filter.filter_transactions(transactions.clone());
    assert_eq!(filtered_transactions, transactions[0..3].to_vec());

    // Create a filter that denies encrypted transactions
    let filter = TransactionFilter::empty()
        .add_encrypted_transaction_filter(false)
        .add_all_filter(true);

    // Verify that the filter returns only plaintext transactions (txn 3 onwards)
    let filtered_transactions = filter.filter_transactions(transactions.clone());
    assert_eq!(filtered_transactions, transactions[3..].to_vec());
}
```
