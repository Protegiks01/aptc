# Audit Report

## Title
Missing Version Monotonicity Validation in JWK Consensus Allows Duplicate Version Proposals

## Summary
The `process_new_observation()` function in the JWK consensus manager lacks validation to ensure version numbers are strictly greater than previously proposed versions. During the window between achieving a quorum-certified update and receiving the on-chain state synchronization, multiple observations can create proposals with identical version numbers, violating version monotonicity and potentially causing consensus liveness issues.

## Finding Description

In `process_new_observation()`, when a new JWK observation is received, the function calculates the next version number based solely on the on-chain state: [1](#0-0) 

The version calculation uses `state.on_chain_version() + 1`, which retrieves the version from the locally cached on-chain state: [2](#0-1) 

**Critical Gap**: The function does not check whether:
1. A consensus is already in progress for a higher version
2. A quorum-certified update has been achieved but not yet committed on-chain
3. The proposed version would duplicate a previous proposal

When a quorum-certified update is processed, the local state updates only the `consensus_state` field but **does not update** `state.on_chain`: [3](#0-2) 

The `state.on_chain` field is only updated when `reset_with_on_chain_state()` is called after receiving an on-chain state sync event: [4](#0-3) 

**Race Condition Window**: Between the time when:
- A quorum-certified update (version N+1) is put into the validator transaction pool, AND
- The on-chain state synchronization event updates the local cache

If a new observation arrives during this window, it will:
1. Calculate version as `N + 1` (because `on_chain` still shows version N)
2. Create a new proposal with the same version N+1 but potentially different JWK content
3. Overwrite the `consensus_state` from `Finished` back to `InProgress`
4. Drop the `QuorumCertProcessGuard`, which aborts the previous consensus process: [5](#0-4) 

**Exploitation Scenario**:
1. Initial state: On-chain version is 5 for issuer "https://accounts.google.com"
2. First observation at T=0: Proposes version 6, consensus starts
3. At T=5s: Quorum achieved, transaction put in pool, state becomes `Finished`
4. At T=6s: New observation (JWKs legitimately changed or triggered maliciously)
5. System calculates version as `5 + 1 = 6` (on-chain still shows 5)
6. Creates new proposal for version 6 with different content
7. Overwrites state, drops guard, aborts previous consensus
8. Original version 6 transaction removed from pool
9. New version 6 consensus starts

This can repeat indefinitely if observations arrive faster than transactions execute, causing a liveness failure where JWK updates never commit.

While the VM validates version monotonicity at execution time and rejects duplicates: [6](#0-5) 

The lack of validation at the proposal level allows:
- Multiple different proposals with identical versions
- Consensus state machine confusion
- Wasted validator resources on redundant rounds
- Potential denial of service if observations are frequent

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty criteria for the following reasons:

1. **State Inconsistencies Requiring Intervention**: Different validators may be in different consensus states (some with the old version 6 proposal, others with the new version 6 proposal), creating coordination problems that require manual investigation.

2. **Liveness Issues**: If JWK observations occur frequently (either through legitimate rapid changes or malicious triggering), the system can enter a state where JWK updates never successfully commit to the blockchain, preventing the protocol from updating critical cryptographic keys.

3. **Resource Exhaustion**: Each aborted consensus round wastes validator CPU, network bandwidth, and cryptographic signature operations across the validator set.

4. **Protocol Violation**: The semantic expectation that each proposal should have a unique, strictly monotonic version number is violated at the proposal level, even though the VM catches duplicates at execution.

The issue does not qualify as Critical or High because:
- It does not compromise consensus safety (the VM validation prevents actual on-chain duplicates)
- It does not allow theft or minting of funds
- It does not cause permanent network partition
- Validator nodes continue operating (though inefficiently)

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can occur through multiple realistic scenarios:

1. **Normal Operation**: During periods of legitimate rapid JWK rotation by identity providers (Google, Facebook, etc.), the natural timing of observations and on-chain commits can trigger this race condition.

2. **Network Latency**: In validators with slower network connections or during network congestion, the delay between transaction pool insertion and on-chain execution increases the race window.

3. **Malicious Triggering**: An attacker observing the JWK consensus protocol could deliberately flood the system with observations (either by controlling an identity provider's JWK endpoint or exploiting observation logic) to prevent progress.

The likelihood is elevated because:
- No privileged access is required (observations are part of normal protocol operation)
- The race window can be several seconds to minutes depending on network conditions
- Multiple validators running observation threads independently increases collision probability
- The window exists for every issuer being tracked (potentially dozens)

## Recommendation

Add validation in `process_new_observation()` to prevent creating proposals when:
1. Consensus is already `InProgress` or `Finished` for this issuer
2. The calculated version would be less than or equal to a version already in the transaction pool

**Proposed Fix**:

```rust
pub fn process_new_observation(
    &mut self,
    issuer: Issuer,
    jwks: Vec<JWKMoveStruct>,
) -> Result<()> {
    debug!(
        epoch = self.epoch_state.epoch,
        issuer = String::from_utf8(issuer.clone()).ok(),
        "Processing new observation."
    );
    let state = self.states_by_issuer.entry(issuer.clone()).or_default();
    state.observed = Some(jwks.clone());
    
    // NEW: Check if consensus is already in progress or finished
    match &state.consensus_state {
        ConsensusState::InProgress { my_proposal, .. } => {
            debug!(
                epoch = self.epoch_state.epoch,
                issuer = String::from_utf8(issuer.clone()).ok(),
                current_version = my_proposal.observed.version,
                "Consensus already in progress, skipping new observation"
            );
            return Ok(());
        },
        ConsensusState::Finished { quorum_certified, .. } => {
            // Only proceed if the new observation differs from the QC'd update
            if state.observed.as_ref() == Some(&quorum_certified.update.jwks) {
                debug!(
                    epoch = self.epoch_state.epoch,
                    issuer = String::from_utf8(issuer.clone()).ok(),
                    "Observation matches finished consensus, skipping"
                );
                return Ok(());
            }
            // Fall through to check against on-chain state
        },
        ConsensusState::NotStarted => {
            // Proceed with normal logic
        },
    }
    
    if state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
        let new_version = state.on_chain_version() + 1;
        
        // NEW: Additional safety check - ensure version is strictly increasing
        // from any finished consensus
        if let ConsensusState::Finished { quorum_certified, .. } = &state.consensus_state {
            if new_version <= quorum_certified.update.version {
                debug!(
                    epoch = self.epoch_state.epoch,
                    issuer = String::from_utf8(issuer.clone()).ok(),
                    calculated_version = new_version,
                    qc_version = quorum_certified.update.version,
                    "New version not strictly greater than QC'd version, skipping"
                );
                return Ok(());
            }
        }
        
        let observed = ProviderJWKs {
            issuer: issuer.clone(),
            version: new_version,
            jwks,
        };
        
        // ... rest of existing logic
    }

    Ok(())
}
```

Alternative approach: Update `state.on_chain` immediately when a QC is achieved in `process_quorum_certified_update()`, rather than waiting for the on-chain state sync event.

## Proof of Concept

```rust
#[tokio::test]
async fn test_duplicate_version_proposals() {
    use aptos_jwk_consensus::jwk_manager::IssuerLevelConsensusManager;
    use aptos_types::jwks::{Issuer, JWKMoveStruct, ProviderJWKs};
    
    // Setup: Create manager with initial on-chain state at version 5
    let mut manager = setup_test_manager();
    let issuer = b"https://accounts.google.com".to_vec();
    
    // Simulate initial on-chain state
    let initial_state = ProviderJWKs {
        issuer: issuer.clone(),
        version: 5,
        jwks: vec![create_test_jwk("key1")],
    };
    manager.reset_with_on_chain_state(AllProvidersJWKs {
        entries: vec![initial_state],
    }).unwrap();
    
    // First observation: Creates proposal with version 6
    let new_jwks_1 = vec![create_test_jwk("key2")];
    manager.process_new_observation(issuer.clone(), new_jwks_1.clone()).unwrap();
    
    // Verify: Consensus is InProgress with version 6
    let state = manager.states_by_issuer.get(&issuer).unwrap();
    assert!(matches!(state.consensus_state, ConsensusState::InProgress { .. }));
    if let ConsensusState::InProgress { my_proposal, .. } = &state.consensus_state {
        assert_eq!(my_proposal.observed.version, 6);
    }
    
    // Simulate QC achieved (without on-chain state sync)
    let qc_update = create_test_qc(issuer.clone(), 6, new_jwks_1);
    manager.process_quorum_certified_update(qc_update).unwrap();
    
    // Verify: State is now Finished, but on_chain still shows version 5
    let state = manager.states_by_issuer.get(&issuer).unwrap();
    assert!(matches!(state.consensus_state, ConsensusState::Finished { .. }));
    assert_eq!(state.on_chain_version(), 5); // Still 5!
    
    // VULNERABILITY: Second observation before on-chain sync
    let new_jwks_2 = vec![create_test_jwk("key3")];
    manager.process_new_observation(issuer.clone(), new_jwks_2).unwrap();
    
    // BUG: This creates another proposal with version 6!
    let state = manager.states_by_issuer.get(&issuer).unwrap();
    if let ConsensusState::InProgress { my_proposal, .. } = &state.consensus_state {
        assert_eq!(my_proposal.observed.version, 6); // Duplicate version!
        println!("VULNERABILITY: Created duplicate version 6 proposal");
    }
    
    // The previous Finished state was overwritten, and the transaction
    // was removed from the pool due to guard drop
}
```

**Notes:**
- The vulnerability exists in the production code at the specified file and function
- No validator privileges are required to trigger this condition
- The race window is realistic and can occur during normal operations
- While the VM prevents duplicate on-chain versions, the proposal-level duplication wastes resources and can cause liveness issues
- The severity is Medium based on potential for state inconsistencies and resource exhaustion

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L194-201)
```rust
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        state.observed = Some(jwks.clone());
        if state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L231-255)
```rust
    pub fn reset_with_on_chain_state(&mut self, on_chain_state: AllProvidersJWKs) -> Result<()> {
        info!(
            epoch = self.epoch_state.epoch,
            "reset_with_on_chain_state starting."
        );
        let onchain_issuer_set: HashSet<Issuer> = on_chain_state
            .entries
            .iter()
            .map(|entry| entry.issuer.clone())
            .collect();
        let local_issuer_set: HashSet<Issuer> = self.states_by_issuer.keys().cloned().collect();

        for issuer in local_issuer_set.difference(&onchain_issuer_set) {
            info!(
                epoch = self.epoch_state.epoch,
                op = "delete",
                issuer = issuer.clone(),
                "reset_with_on_chain_state"
            );
        }

        self.states_by_issuer
            .retain(|issuer, _| onchain_issuer_set.contains(issuer));
        for on_chain_provider_jwks in on_chain_state.entries {
            let issuer = on_chain_provider_jwks.issuer.clone();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L332-350)
```rust
        match &state.consensus_state {
            ConsensusState::InProgress { my_proposal, .. } => {
                //TODO: counters
                let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
                let vtxn_guard =
                    self.vtxn_pool
                        .put(Topic::JWK_CONSENSUS(issuer.clone()), Arc::new(txn), None);
                state.consensus_state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: update.clone(),
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    issuer = String::from_utf8(issuer).ok(),
                    version = update.update.version,
                    "certified update accepted."
                );
                Ok(())
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L377-381)
```rust
    pub fn on_chain_version(&self) -> u64 {
        self.on_chain
            .as_ref()
            .map_or(0, |provider_jwks| provider_jwks.version)
    }
```

**File:** crates/aptos-jwk-consensus/src/types.rs (L96-100)
```rust
impl Drop for QuorumCertProcessGuard {
    fn drop(&mut self) {
        let QuorumCertProcessGuard { handle } = self;
        handle.abort();
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L128-130)
```rust
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```
