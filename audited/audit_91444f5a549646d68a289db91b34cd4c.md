# Audit Report

## Title
Information Disclosure via Unprotected Inspection Service Configuration Endpoint on Mainnet Validator Fullnodes

## Summary
The `expose_configuration` field in `InspectionServiceConfig` lacks documentation about its security implications, and the sanitizer only protects mainnet validators but not mainnet validator fullnodes (VFNs), allowing sensitive network topology and infrastructure information to be exposed through the `/configuration` endpoint.

## Finding Description

The `expose_configuration` boolean field controls whether the node's full configuration is exposed via the inspection service's `/configuration` HTTP endpoint. [1](#0-0) 

When enabled, the endpoint returns the complete `NodeConfig` structure using debug formatting. [2](#0-1) 

**Three Security Issues Identified:**

1. **No Documentation**: The field has zero inline documentation explaining what information is exposed and the security implications. [3](#0-2) 

2. **Incomplete Mainnet Protection**: The sanitizer only blocks `NodeType::Validator` on mainnet, NOT `NodeType::ValidatorFullnode`. [4](#0-3)  The `is_validator()` method returns `false` for VFNs. [5](#0-4) 

3. **Silent Auto-Enabling**: The optimizer automatically enables this endpoint for all non-mainnet nodes without operator awareness, with only a comment stating "to aid debugging". [6](#0-5) 

**Information Exposed:**

When enabled, the endpoint exposes the complete `NodeConfig` including:
- Network topology: seed peers, peer IDs, network addresses [7](#0-6) 
- VFN private network configuration showing validator connections [8](#0-7) 
- Storage paths, API endpoints, all operational parameters [9](#0-8) 

## Impact Explanation

This qualifies as **Medium severity** information disclosure per Aptos bug bounty criteria because:

1. **Mainnet VFNs Unprotected**: Validator fullnodes on mainnet can expose their configuration, revealing the private VFN network topology that directly connects to validators, violating the security boundary the sanitizer was designed to enforce.

2. **Attack Enablement**: The exposed information (validator peer IDs, network addresses, seed peers, infrastructure details) can be used to:
   - Map the complete validator network topology
   - Plan targeted DDoS attacks on specific validators
   - Identify validator infrastructure for physical or network-level attacks
   - Facilitate eclipse attacks by understanding peer connectivity

3. **Operator Confusion**: Without documentation or warnings, operators may enable this thinking it's safe "debug output" without understanding they're exposing sensitive operational details including network topology and infrastructure configuration.

## Likelihood Explanation

**High likelihood** of occurrence because:

1. VFNs are commonly deployed on mainnet alongside validators [10](#0-9) 
2. Operators may explicitly enable for debugging without understanding implications
3. Non-mainnet nodes have it auto-enabled, establishing a pattern that operators might replicate
4. The error message provides no security warning, only instruction to enable [11](#0-10) 
5. Exploitation requires only an HTTP GET request to a public endpoint

## Recommendation

**Fix 1: Add comprehensive documentation**
```rust
/// Controls whether the node's full configuration is exposed via the /configuration endpoint.
/// 
/// SECURITY WARNING: Enabling this exposes sensitive information including:
/// - Network topology (seed peers, validator addresses, peer IDs)
/// - Storage paths and database locations
/// - API endpoints and operational parameters
/// - System configuration details
/// 
/// This information could be used by attackers to map network infrastructure
/// and plan targeted attacks. Should ONLY be enabled in controlled debugging
/// environments, NEVER in production on mainnet.
/// 
/// Default: false for security
pub expose_configuration: bool,
```

**Fix 2: Extend sanitizer to cover VFNs on mainnet**
```rust
// Verify that mainnet validators AND VFNs do not expose the configuration
if let Some(chain_id) = chain_id {
    if (node_type.is_validator() || node_type.is_validator_fullnode())
        && chain_id.is_mainnet()
        && inspection_service_config.expose_configuration
    {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Mainnet validators and validator fullnodes should not expose the node configuration!".to_string(),
        ));
    }
}
```

**Fix 3: Add security warning to disabled message**
```rust
pub const CONFIGURATION_DISABLED_MESSAGE: &str =
    "This endpoint is disabled for security. It exposes sensitive network topology and infrastructure details. \
     Only enable in controlled debugging environments: inspection_service.expose_configuration: true";
```

## Proof of Concept

**Step 1: Deploy mainnet VFN with expose_configuration enabled**
```yaml
# mainnet_vfn_config.yaml
base:
  role: "full_node"
  
full_node_networks:
  - network_id: "public"
  - network_id:
      private: "vfn"
    seeds:
      <validator_peer_id>:
        addresses: ["/ip4/<validator_ip>/tcp/6181/..."]
        role: "Validator"

inspection_service:
  expose_configuration: true  # Sanitizer does NOT block this for VFNs!
```

**Step 2: Query the endpoint**
```bash
curl http://<vfn_ip>:9101/configuration
```

**Step 3: Response contains sensitive information**
```
NodeConfig { 
  full_node_networks: [
    NetworkConfig { 
      seeds: { 
        <validator_peer_id>: Peer { 
          addresses: ["/ip4/<validator_ip>/tcp/6181/..."],
          role: Validator 
        }
      }
    }
  ],
  storage: StorageConfig { dir: "/opt/aptos/data" },
  ...
}
```

This exposes the private VFN→Validator network topology, which attackers can use to map validator infrastructure and plan targeted attacks, violating the security boundary that the mainnet sanitizer was designed to enforce.

---

## Notes

The core issue is a gap in security boundaries: the sanitizer explicitly protects mainnet validators from exposing configuration, but validator fullnodes (VFNs)—which have direct private network connections to validators—are not protected by the same check. Combined with zero documentation about security implications and silent auto-enabling behavior, this creates a realistic scenario where operators unknowingly expose sensitive infrastructure details that could aid attackers in reconnaissance and targeted attacks against validator infrastructure.

### Citations

**File:** config/src/config/inspection_service_config.rs (L15-24)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
}
```

**File:** config/src/config/inspection_service_config.rs (L54-64)
```rust
        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
```

**File:** config/src/config/inspection_service_config.rs (L81-88)
```rust
        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L9-10)
```rust
pub const CONFIGURATION_DISABLED_MESSAGE: &str =
    "This endpoint is disabled! Enable it in the node config at inspection_service.expose_configuration: true";
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-26)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };
```

**File:** config/src/config/node_config_loader.rs (L30-32)
```rust
    pub fn is_validator(self) -> bool {
        self == NodeType::Validator
    }
```

**File:** config/src/config/network_config.rs (L96-101)
```rust
    /// Addresses of initial peers to connect to. In a mutual_authentication network,
    /// we will extract the public keys from these addresses to set our initial
    /// trusted peers set.  TODO: Replace usage in configs with `seeds` this is for backwards compatibility
    pub seed_addrs: HashMap<PeerId, Vec<NetworkAddress>>,
    /// The initial peers to connect to prior to onchain discovery
    pub seeds: PeerSet,
```

**File:** config/src/config/test_data/validator_full_node.yaml (L32-40)
```yaml
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
      max_outbound_connections: 1
      network_id:
          private: "vfn"
      seeds:
        00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237:
          addresses:
          - "/ip4/127.0.0.1/tcp/6181/noise-ik/f0274c2774519281a8332d0bb9d8101bd58bc7bb154b38039bc9096ce04e1237/handshake/0"
          role: "Validator"
```

**File:** config/src/config/node_config.rs (L37-92)
```rust
pub struct NodeConfig {
    #[serde(default)]
    pub admin_service: AdminServiceConfig,
    #[serde(default)]
    pub api: ApiConfig,
    #[serde(default)]
    pub base: BaseConfig,
    #[serde(default)]
    pub consensus: ConsensusConfig,
    #[serde(default)]
    pub consensus_observer: ConsensusObserverConfig,
    #[serde(default)]
    pub dag_consensus: DagConsensusConfig,
    #[serde(default)]
    pub dkg: DKGConfig,
    #[serde(default)]
    pub execution: ExecutionConfig,
    #[serde(default)]
    pub failpoints: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub full_node_networks: Vec<NetworkConfig>,
    #[serde(default)]
    pub indexer: IndexerConfig,
    #[serde(default)]
    pub indexer_grpc: IndexerGrpcConfig,
    #[serde(default)]
    pub indexer_table_info: IndexerTableInfoConfig,
    #[serde(default)]
    pub inspection_service: InspectionServiceConfig,
    #[serde(default)]
    pub jwk_consensus: JWKConsensusConfig,
    #[serde(default)]
    pub logger: LoggerConfig,
    #[serde(default)]
    pub mempool: MempoolConfig,
    #[serde(default)]
    pub netbench: Option<NetbenchConfig>,
    #[serde(default)]
    pub node_startup: NodeStartupConfig,
    #[serde(default)]
    pub peer_monitoring_service: PeerMonitoringServiceConfig,
    /// In a randomness stall, set this to be on-chain `RandomnessConfigSeqNum` + 1.
    /// Once enough nodes restarted with the new value, the chain should unblock with randomness disabled.
    #[serde(default)]
    pub randomness_override_seq_num: u64,
    #[serde(default)]
    pub state_sync: StateSyncConfig,
    #[serde(default)]
    pub storage: StorageConfig,
    #[serde(default)]
    pub transaction_filters: TransactionFiltersConfig,
    #[serde(default)]
    pub validator_network: Option<NetworkConfig>,
    #[serde(default)]
    pub indexer_db_config: InternalIndexerDBConfig,
}
```

**File:** terraform/helm/aptos-node/files/configs/fullnode-base.yaml (L1-1)
```yaml
###
```
