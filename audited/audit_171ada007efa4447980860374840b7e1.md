# Audit Report

## Title
Fee Payer Transaction Simulation Uses Wrong Address for Balance Query Leading to Incorrect Max Gas Calculations

## Summary
The `simulate_transaction()` REST API endpoint incorrectly queries the transaction sender's balance instead of the fee payer's balance when calculating maximum gas amounts for fee payer transactions with `estimate_max_gas_amount=true`. This causes simulation results to diverge from actual on-chain execution behavior, breaking the fundamental contract of the simulation API.

## Finding Description
Aptos supports fee payer transactions where a designated fee payer address pays for transaction gas costs instead of the sender. During on-chain execution, the transaction validation framework correctly checks the fee payer's balance for gas payment capability.

The vulnerability exists in the `simulate_transaction()` function. When the `estimate_max_gas_amount` query parameter is set to true, the code calculates the maximum affordable gas by querying an account's APT balance. However, it always queries the transaction sender's balance, regardless of whether the transaction is a fee payer transaction. [1](#0-0) 

For fee payer transactions, this is incorrect because gas is actually paid by the fee payer, not the sender. The on-chain prologue functions explicitly pass the fee payer address as the gas payer parameter to `prologue_common`, ensuring balance checks use the correct address: [2](#0-1) 

The `prologue_common` function then checks the gas payer's balance: [3](#0-2) 

The fee payer address is accessible through the transaction authenticator's `fee_payer_address()` method: [4](#0-3) 

**Exploit Scenario:**
1. User A (sender) has 100 APT balance
2. User B (fee payer) has 10 APT balance
3. User A creates a fee payer transaction with B as the fee payer
4. Simulation with `estimate_max_gas_amount=true` queries A's 100 APT balance and returns a high max gas estimate
5. User constructs transaction based on simulation results
6. Transaction fails on-chain during prologue because B only has 10 APT, causing unexpected rejection

## Impact Explanation
This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty program criteria for "Limited Protocol Violations" involving state inconsistencies and limited funds manipulation.

**Specific Impacts:**

1. **State Inconsistencies**: The simulation API is designed to accurately predict on-chain execution behavior. This bug creates deterministic divergence between simulation and actual execution, violating the API's core guarantee.

2. **Limited Funds Manipulation**: While not direct theft, the incorrect estimation causes:
   - Users to waste gas fees submitting transactions that fail on-chain but passed simulation
   - Wallets and dApps to incorrectly estimate required fee payer balances
   - Integration failures for applications relying on accurate gas estimation

3. **User Experience Degradation**: Breaks trust in the simulation API, a critical tool for transaction construction.

This does not reach High/Critical severity because it does not enable:
- Consensus violations or chain splits
- Direct fund theft or unauthorized minting
- Network-wide failures or validator crashes
- Complete loss of network liveness

## Likelihood Explanation
**Likelihood: High**

This vulnerability triggers deterministically under normal conditions:

- **Frequency**: Occurs in every fee payer transaction simulation where `estimate_max_gas_amount=true` and sender/fee payer have different balances
- **Attacker Profile**: Any Aptos user can create fee payer transactions through standard APIs
- **Preconditions**: None beyond normal network operation
- **Execution Complexity**: Single REST API call to `/transactions/simulate`
- **Economic Cost**: Minimal (standard API usage)

Fee payer transactions are a standard Aptos feature for sponsored transactions, making this a commonly-used code path. The bug requires no special blockchain state, race conditions, or coordinated timing.

## Recommendation
Modify the balance query logic to check the fee payer's balance for fee payer transactions:

```rust
// In api/src/transactions.rs, around line 675
let balance_address = signed_transaction
    .authenticator_ref()
    .fee_payer_address()
    .unwrap_or_else(|| signed_transaction.sender());

let output = AptosVM::execute_view_function(
    &state_view,
    ModuleId::new(AccountAddress::ONE, ident_str!("coin").into()),
    ident_str!("balance").into(),
    vec![AptosCoinType::type_tag()],
    vec![balance_address.to_vec()],
    context.node_config.api.max_gas_view_function,
);
```

This ensures that:
- For fee payer transactions, the fee payer's balance is queried
- For regular transactions, the sender's balance is queried (preserving existing behavior)
- Simulation accurately reflects on-chain execution behavior

## Proof of Concept
The vulnerability can be demonstrated with the following REST API test:

```rust
// Create two accounts with different balances
let sender = create_account_with_balance(100 * OCTAS_PER_APT);
let fee_payer = create_account_with_balance(10 * OCTAS_PER_APT);

// Create a fee payer transaction
let txn = create_fee_payer_transaction(
    sender.address(),
    fee_payer.address(),
    /* payload */ transfer_coins(recipient, 1 * OCTAS_PER_APT)
);

// Simulate with gas estimation
let response = POST("/v1/transactions/simulate?estimate_max_gas_amount=true")
    .json(txn);

// The simulation will calculate max gas based on sender's 100 APT balance
// But on-chain execution will check fee payer's 10 APT balance
// This divergence causes the simulation to be inaccurate
```

## Notes
- This vulnerability affects the REST API layer, not the core consensus or execution logic
- On-chain execution behavior is correct; only the simulation endpoint is affected
- The fix is straightforward and requires minimal code changes
- No historical transactions are affected; this only impacts future simulations
- The bug exists because fee payer transactions are a relatively newer feature and the simulation code was not updated to handle them correctly

### Citations

**File:** api/src/transactions.rs (L670-677)
```rust
                let output = AptosVM::execute_view_function(
                    &state_view,
                    ModuleId::new(AccountAddress::ONE, ident_str!("coin").into()),
                    ident_str!("balance").into(),
                    vec![AptosCoinType::type_tag()],
                    vec![signed_transaction.sender().to_vec()],
                    context.node_config.api.max_gas_view_function,
                );
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L187-212)
```text
        // Check if the gas payer has enough balance to pay for the transaction
        let max_transaction_fee = txn_gas_price * txn_max_gas_units;
        if (!skip_gas_payment(
            is_simulation,
            gas_payer_address
        )) {
            assert!(
                permissioned_signer::check_permission_capacity_above(
                    gas_payer,
                    (max_transaction_fee as u256),
                    GasPermission {}
                ),
                error::permission_denied(PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT)
            );
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            }
        };
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L455-465)
```text
        prologue_common(
            &sender,
            &create_signer::create_signer(fee_payer_address),
            ReplayProtector::SequenceNumber(txn_sequence_number),
            option::some(txn_sender_public_key),
            txn_gas_price,
            txn_max_gas_units,
            txn_expiration_time,
            chain_id,
            false,
        );
```

**File:** types/src/transaction/authenticator.rs (L297-311)
```rust
    pub fn fee_payer_address(&self) -> Option<AccountAddress> {
        match self {
            Self::Ed25519 { .. }
            | Self::MultiEd25519 { .. }
            | Self::MultiAgent { .. }
            | Self::SingleSender { .. } => None,
            Self::FeePayer {
                sender: _,
                secondary_signer_addresses: _,
                secondary_signers: _,
                fee_payer_address,
                ..
            } => Some(*fee_payer_address),
        }
    }
```
