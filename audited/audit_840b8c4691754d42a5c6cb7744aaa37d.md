# Audit Report

## Title
Authentication Bypass in Aptos Faucet via X_IS_JWT_HEADER Manipulation

## Summary
The Aptos Faucet's `AuthTokenChecker` can be completely bypassed by setting the `X_IS_JWT_HEADER` HTTP header to any value, allowing unauthorized access to faucet funds without providing valid authentication credentials. This occurs because the checker assumes JWT validation will happen elsewhere but doesn't enforce this requirement.

## Finding Description

The Aptos Faucet implements two authentication mechanisms that both use the `Authorization` header:
1. Simple auth tokens (validated by `AuthTokenChecker`)
2. Firebase JWT tokens (validated by `FirebaseJwtVerifier` when configured)

To differentiate between these mechanisms, the `X_IS_JWT_HEADER` header is used as a signal. However, a critical logic flaw exists in how `AuthTokenChecker` handles this header. [1](#0-0) 

When `X_IS_JWT_HEADER` is present in the request headers (regardless of its value), `AuthTokenChecker` immediately returns an empty rejection vector, effectively passing the check without validating any credentials. The checker assumes that if this header is present, JWT validation will occur in another component (like `RedisRatelimitChecker` configured with JWT-based ratelimiting). [2](#0-1) 

However, this assumption is not enforced. If a faucet is configured with:
- `AuthTokenChecker` (to require auth tokens)
- `RedisRatelimitChecker` with IP-based ratelimiting (NOT JWT-based)
- OR any other checker configuration without JWT validation

Then an attacker can bypass the authentication requirement entirely by simply adding `X_IS_JWT_HEADER: any_value` to their request headers, without providing either a valid auth token OR a valid JWT.

The `AuthTokenBypasser` correctly handles this scenario by returning `false` (cannot bypass) when the header is present: [3](#0-2) 

But this doesn't prevent the authentication bypass in the checker.

**Attack Flow:**
1. Attacker identifies faucet requires auth tokens via `AuthTokenChecker`
2. Attacker sends request with `X_IS_JWT_HEADER: arbitrary_value` header
3. `AuthTokenChecker.check()` detects header presence and returns `Ok(vec![])` - no validation performed
4. If no JWT validation is configured, request proceeds without authentication
5. Attacker must still pass other checkers (captcha, rate limits), but auth is bypassed
6. Attacker can repeatedly drain faucet funds

## Impact Explanation

**Severity Assessment: Medium**

This vulnerability allows unauthorized access to faucet resources, bypassing intended access controls. While this affects the faucet service rather than core blockchain consensus or mainnet funds, it represents a significant security failure:

- **Limited funds loss or manipulation**: Attackers can drain testnet faucet funds without authorization
- **Access control bypass**: Completely circumvents the authentication mechanism
- **Operational impact**: Could require manual intervention to restore faucet functionality

This aligns with **Medium Severity** criteria in the Aptos Bug Bounty program: "Limited funds loss or manipulation" and "State inconsistencies requiring intervention."

**Important Note**: This vulnerability is limited to the Aptos Faucet auxiliary service and does not affect core blockchain components (consensus, Move VM, storage, governance, or staking). It does not enable:
- Mainnet fund theft
- Consensus safety violations
- Validator compromise
- State corruption in the blockchain

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Trivial exploitation**: Only requires adding a single HTTP header to requests
2. **No special privileges needed**: Any user can send HTTP requests to the faucet
3. **Common misconfiguration**: Faucets may be deployed with `AuthTokenChecker` but without JWT validation
4. **No detection mechanism**: The bypass leaves no obvious audit trail indicating improper access
5. **Clear benefit to attackers**: Free access to faucet funds for testing or malicious purposes

The only barriers are:
- Faucet must be configured with `AuthTokenChecker` but without JWT validation
- Attacker still needs to pass other checkers (captcha, rate limiting)

However, captcha/rate-limiting can often be circumvented through various techniques, making the authentication bypass the critical weak point.

## Recommendation

**Fix the logic error in `AuthTokenChecker` by validating that JWT authentication actually occurs when `X_IS_JWT_HEADER` is present.**

Option 1: Enforce JWT validation in `AuthTokenChecker`:
```rust
async fn check(
    &self,
    data: CheckerData,
    _dry_run: bool,
) -> Result<Vec<RejectionReason>, AptosTapError> {
    // If JWT header is present, this checker should not be used at all.
    // Return an error to indicate misconfiguration.
    if data.headers.contains_key(X_IS_JWT_HEADER) {
        return Err(AptosTapError::new(
            "X_IS_JWT_HEADER is set but AuthTokenChecker is configured. Use JWT-based validation instead.".to_string(),
            AptosTapErrorCode::CheckerError,
        ));
    }
    
    // Existing auth token validation logic...
}
```

Option 2: Validate the header value strictly:
```rust
async fn check(
    &self,
    data: CheckerData,
    _dry_run: bool,
) -> Result<Vec<RejectionReason>, AptosTapError> {
    // Only skip auth token check if JWT header is explicitly set to "true"
    // AND ensure JWT validation is configured elsewhere
    if let Some(header_value) = data.headers.get(X_IS_JWT_HEADER) {
        if header_value.to_str().ok().map(|v| v.eq_ignore_ascii_case("true")).unwrap_or(false) {
            // Log warning that JWT validation must be configured
            aptos_logger::warn!("X_IS_JWT_HEADER detected, JWT validation must be configured");
            return Ok(vec![]);
        }
    }
    
    // Existing auth token validation logic...
}
```

Option 3 (Recommended): Remove the header check entirely from `AuthTokenChecker` and rely on separate, explicit checker configurations:
```rust
async fn check(
    &self,
    data: CheckerData,
    _dry_run: bool,
) -> Result<Vec<RejectionReason>, AptosTapError> {
    // Remove the X_IS_JWT_HEADER check entirely
    // If both auth mechanisms are needed, configure both checkers explicitly
    
    let auth_token = match data
        .headers
        .get(AUTHORIZATION)
        .and_then(|v| v.to_str().ok())
        .and_then(|v| v.split_whitespace().nth(1))
    {
        Some(auth_token) => auth_token,
        None => return Ok(vec![RejectionReason::new(
            "Either the Authorization header is missing or it is not in the form of 'Bearer <token>'".to_string(),
            RejectionReasonCode::AuthTokenInvalid,
        )]),
    };
    
    if self.manager.contains(auth_token) {
        Ok(vec![])
    } else {
        Ok(vec![RejectionReason::new(
            format!("The given auth token is not allowed by the server: {}", auth_token),
            RejectionReasonCode::AuthTokenInvalid,
        )])
    }
}
```

## Proof of Concept

```bash
# Normal request without auth token - REJECTED
curl -X POST http://faucet.example.com/fund \
  -H "Content-Type: application/json" \
  -d '{"address": "0x1234..."}' 
# Expected: 403 Forbidden (auth token required)

# Attack: Set X_IS_JWT_HEADER to bypass auth - SUCCEEDS
curl -X POST http://faucet.example.com/fund \
  -H "Content-Type: application/json" \
  -H "X-Is-Jwt: bypass" \
  -d '{"address": "0x1234..."}' 
# Expected with vulnerability: 200 OK (if other checks pass)
# Expected after fix: 403 Forbidden or 500 Server Error

# The header value doesn't matter - any value works
curl -X POST http://faucet.example.com/fund \
  -H "Content-Type: application/json" \
  -H "X-Is-Jwt: literally_anything" \
  -d '{"address": "0x1234..."}' 
# Expected with vulnerability: 200 OK (authentication bypassed)
```

**Rust Test Case:**
```rust
#[tokio::test]
async fn test_auth_bypass_vulnerability() {
    // Setup: Create AuthTokenChecker with valid tokens
    let config = ListManagerConfig { /* ... */ };
    let checker = AuthTokenChecker::new(config).unwrap();
    
    // Create request data WITHOUT valid auth token but WITH X_IS_JWT_HEADER
    let mut headers = HeaderMap::new();
    headers.insert("x-is-jwt", "arbitrary_value".parse().unwrap());
    // Note: No Authorization header provided
    
    let checker_data = CheckerData {
        receiver: AccountAddress::random(),
        source_ip: "127.0.0.1".parse().unwrap(),
        headers: Arc::new(headers),
        time_request_received_secs: 0,
    };
    
    // BUG: This should reject (no valid auth), but passes
    let result = checker.check(checker_data, false).await.unwrap();
    assert!(result.is_empty()); // Vulnerability: check passes without auth!
}
```

## Notes

This vulnerability is specific to the Aptos Faucet auxiliary service and does not affect core blockchain protocol components (consensus, Move VM, state management, governance, or staking). The faucet distributes testnet tokens and is not part of the critical blockchain infrastructure. However, it represents a serious access control failure that could lead to unauthorized resource consumption and operational disruption of faucet services.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L37-40)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L42-53)
```rust
        let auth_token = match data
            .headers
            .get(AUTHORIZATION)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.split_whitespace().nth(1))
        {
            Some(auth_token) => auth_token,
            None => return Ok(vec![RejectionReason::new(
                "Either the Authorization header is missing or it is not in the form of 'Bearer <token>'".to_string(),
                RejectionReasonCode::AuthTokenInvalid,
            )]),
        };
```

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L33-36)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(false);
        }
```
