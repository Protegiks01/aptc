# Audit Report

## Title
REST Discovery Man-in-the-Middle Vulnerability Enables Eclipse Attacks via Unauthenticated Validator Set Injection

## Summary
The REST-based peer discovery mechanism (`DiscoveryMethod::Rest`) lacks cryptographic verification of fetched validator set data, relying solely on TLS for security. An attacker capable of performing MITM attacks on the configured REST endpoint can inject arbitrary validator set data containing attacker-controlled public keys and network addresses, enabling complete control over the victim node's peer discovery process and facilitating eclipse attacks that isolate nodes from the legitimate validator network.

## Finding Description

The vulnerability exists in the REST discovery implementation where validator set data is fetched from an arbitrary REST endpoint without cryptographic verification. [1](#0-0) 

The `setup_discovery()` function creates a REST discovery listener using the configured URL without validating that it uses HTTPS or implementing additional security measures: [2](#0-1) 

The `RestStream` uses `aptos_rest_client::Client::new()` which creates a reqwest HTTP client: [3](#0-2) [4](#0-3) 

The client builder uses default reqwest settings without enforcing HTTPS or implementing certificate pinning. The `RestDiscovery` configuration accepts any URL: [5](#0-4) 

When the REST endpoint is polled, the validator set data is simply deserialized and used directly: [6](#0-5) 

The fetched `ValidatorSet` structure has no signature or cryptographic authentication: [7](#0-6) 

This untrusted data is then processed and added to the trusted peers set: [8](#0-7) [9](#0-8) 

**Attack Flow:**
1. Attacker performs MITM on REST endpoint (via DNS hijacking, CA compromise, HTTP URL, or operator misconfiguration)
2. Attacker returns malicious `ValidatorSet` with attacker-controlled public keys and addresses
3. Node deserializes this data and updates its trusted peers set
4. Node attempts connections to attacker's peers
5. Attacker's peers successfully authenticate via Noise handshake (because attacker has matching private keys): [10](#0-9) 

6. Node is now eclipsed, connecting only to attacker-controlled peers
7. Node receives false blockchain data and is isolated from legitimate validators

**Broken Invariants:**
- **Consensus Safety**: Network partitioning can prevent validators from participating in consensus
- **Cryptographic Correctness**: Peer discovery should be based on cryptographically verified data, not unauthenticated REST responses
- **Network Security**: Nodes should not accept peer information from untrusted sources

## Impact Explanation

**Severity: HIGH** per Aptos bug bounty criteria

This vulnerability enables:

1. **Eclipse Attacks**: Complete isolation of victim nodes from the legitimate validator network
2. **Validator Partitioning**: Active validators can be partitioned from consensus, degrading network liveness
3. **False Data Injection**: Eclipsed nodes receive attacker-controlled blockchain state
4. **Denial of Service**: Victim nodes fail to sync with legitimate chain state

This qualifies as **High Severity** under the Aptos bug bounty program:
- "Validator node slowdowns" - Validators unable to connect to legitimate peers experience degraded performance
- "Significant protocol violations" - Breaking the peer discovery security model violates protocol assumptions
- While not directly causing consensus safety violations (as consensus has separate protections), it enables network-level attacks that can impact availability and node operation

The attack does not require validator privileges or stake majority, making it exploitable by external attackers with network-level capabilities.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack is feasible under several realistic scenarios:

1. **HTTP Configuration**: If an operator configures REST discovery with an `http://` URL (no TLS), MITM requires only network position
2. **DNS Hijacking**: Attacker compromises DNS for the REST endpoint domain
3. **CA Compromise**: Attacker obtains valid TLS certificate through CA compromise or malicious CA installation on victim system
4. **Malicious Endpoint**: Operator is tricked into configuring a malicious REST endpoint URL

**Factors Increasing Likelihood:**
- No validation that URLs must be HTTPS in configuration
- No certificate pinning or additional verification
- REST discovery is a documented feature nodes may legitimately use
- Operators may configure REST discovery when "genesis is significantly far behind in time" (per code comments)

**Factors Decreasing Likelihood:**
- Production validators typically use OnChain discovery, which has cryptographic verification through consensus
- REST discovery is optional
- Requires either network-level MITM capability or social engineering

However, the lack of any warning or security guidance in the code means operators may unknowingly use this insecure discovery method.

## Recommendation

Implement multiple security layers for REST discovery:

**1. Enforce HTTPS-only URLs:**
```rust
// In config/src/config/network_config.rs
impl RestDiscovery {
    pub fn validate(&self) -> Result<(), String> {
        if self.url.scheme() != "https" {
            return Err(format!(
                "REST discovery URL must use HTTPS for security. Got: {}",
                self.url.scheme()
            ));
        }
        Ok(())
    }
}
```

**2. Add cryptographic verification of validator set data:**
The validator set fetched from REST should be signed by a quorum of validators or include a verifiable proof. Consider:
- Requiring the REST endpoint to return not just the `ValidatorSet` but also a `LedgerInfoWithSignatures` that proves the validator set is committed on-chain
- Implementing certificate pinning for known REST endpoints
- Adding a configuration option to specify expected root certificate for TLS verification

**3. Add security warnings in configuration:**
```rust
/// REST-based peer discovery (SECURITY WARNING: Only use with trusted HTTPS endpoints)
/// This method trusts the REST endpoint to provide legitimate validator data.
/// For production use, prefer OnChain discovery which has cryptographic verification.
pub struct RestDiscovery {
    /// REST endpoint URL (MUST be HTTPS)
    pub url: url::Url,
    pub interval_secs: u64,
}
```

**4. Implement defense-in-depth:**
- Limit REST discovery to only add peers, never remove peers discovered through OnChain methods
- Add metrics/alerts when REST discovery provides significantly different peer sets than OnChain discovery
- Consider requiring operator confirmation before trusting REST-discovered peers

## Proof of Concept

```rust
// Minimal PoC demonstrating the vulnerability
// File: testsuite/smoke-test/src/rest_discovery_mitm_test.rs

use aptos_config::config::{DiscoveryMethod, RestDiscovery, NetworkConfig};
use aptos_rest_client::Client;
use aptos_types::{
    on_chain_config::ValidatorSet,
    validator_info::ValidatorInfo,
    validator_config::ValidatorConfig,
    PeerId,
};
use url::Url;

#[tokio::test]
async fn test_rest_discovery_accepts_unsigned_validator_set() {
    // 1. Set up a malicious REST endpoint (using mock server)
    let malicious_server = setup_malicious_rest_server().await;
    
    // 2. Create attacker-controlled validator set
    let attacker_peer_id = PeerId::random();
    let attacker_public_key = generate_attacker_keys();
    let malicious_validator = ValidatorInfo::new(
        attacker_peer_id,
        0, // voting power
        ValidatorConfig::new(
            attacker_public_key.consensus,
            bcs::to_bytes(&vec![attacker_public_key.network_address]).unwrap(),
            bcs::to_bytes(&vec![attacker_public_key.network_address]).unwrap(),
            0,
        ),
    );
    let malicious_validator_set = ValidatorSet::new(vec![malicious_validator]);
    
    // 3. Configure malicious server to return this validator set
    malicious_server.set_validator_set(malicious_validator_set.clone());
    
    // 4. Configure victim node with REST discovery pointing to malicious server
    let mut network_config = NetworkConfig::default();
    network_config.discovery_method = DiscoveryMethod::Rest(RestDiscovery {
        url: Url::parse(&malicious_server.url()).unwrap(),
        interval_secs: 1,
    });
    
    // 5. Start discovery process
    let discovery_listener = start_rest_discovery(network_config).await;
    
    // 6. Verify that victim node accepts malicious validator set
    tokio::time::sleep(Duration::from_secs(2)).await;
    let discovered_peers = get_discovered_peers(&discovery_listener).await;
    
    // VULNERABILITY DEMONSTRATED: Node accepts unsigned validator set from REST endpoint
    assert!(discovered_peers.contains_key(&attacker_peer_id));
    assert_eq!(discovered_peers.len(), 1); // Only attacker's peer discovered
    
    // Node is now eclipsed and will only connect to attacker's peer
}

// Helper to demonstrate HTTP (non-TLS) also works
#[test]
fn test_rest_discovery_accepts_http_urls() {
    let config = RestDiscovery {
        url: Url::parse("http://malicious-endpoint.com/v1").unwrap(), // HTTP!
        interval_secs: 60,
    };
    
    // VULNERABILITY: No validation that URL must be HTTPS
    // config.validate() would fail if proper validation existed
    assert_eq!(config.url.scheme(), "http"); // Insecure scheme accepted
}
```

**Expected Behavior:**
The node should reject validator sets from REST endpoints unless they include cryptographic proof of authenticity (e.g., quorum signatures from known validators).

**Actual Behavior:**
The node accepts and trusts any validator set data returned by the configured REST endpoint, enabling eclipse attacks.

## Notes

This vulnerability is particularly concerning because:

1. **Silent Failure**: Operators may unknowingly configure insecure REST discovery without warnings
2. **Trust Assumption Violation**: The system implicitly trusts REST endpoints without documenting this security model
3. **Comparison with OnChain Discovery**: OnChain discovery has cryptographic verification through consensus, but REST discovery has none - this inconsistency is not documented
4. **Defense Depth**: While Noise handshake provides peer authentication, it cannot defend against this attack because the attacker controls both public and private keys

The vulnerability demonstrates that security mechanisms at one layer (Noise authentication) cannot compensate for missing security at another layer (peer discovery verification).

### Citations

**File:** network/builder/src/builder.rs (L379-385)
```rust
                DiscoveryMethod::Rest(rest_discovery) => DiscoveryChangeListener::rest(
                    self.network_context,
                    conn_mgr_reqs_tx.clone(),
                    rest_discovery.url.clone(),
                    Duration::from_secs(rest_discovery.interval_secs),
                    self.time_service.clone(),
                ),
```

**File:** network/discovery/src/rest.rs (L24-36)
```rust
impl RestStream {
    pub(crate) fn new(
        network_context: NetworkContext,
        rest_url: url::Url,
        interval_duration: Duration,
        time_service: TimeService,
    ) -> Self {
        RestStream {
            network_context,
            rest_client: aptos_rest_client::Client::new(rest_url),
            interval: Box::pin(time_service.interval(interval_duration)),
        }
    }
```

**File:** network/discovery/src/rest.rs (L42-68)
```rust
    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        // Wait for delay, or add the delay for next call
        futures::ready!(self.interval.as_mut().poll_next(cx));

        // Retrieve the onchain resource at the interval
        // TODO there should be a better way than converting this to a blocking call
        let response = block_on(self.rest_client.get_account_resource_bcs::<ValidatorSet>(
            AccountAddress::ONE,
            "0x1::stake::ValidatorSet",
        ));
        Poll::Ready(match response {
            Ok(inner) => {
                let validator_set = inner.into_inner();
                Some(Ok(extract_validator_set_updates(
                    self.network_context,
                    validator_set,
                )))
            },
            Err(err) => {
                info!(
                    "Failed to retrieve validator set by REST discovery {:?}",
                    err
                );
                Some(Err(DiscoveryError::Rest(err)))
            },
        })
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L134-136)
```rust
    pub fn new(base_url: Url) -> Self {
        Self::builder(AptosBaseUrl::Custom(base_url)).build()
    }
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L95-109)
```rust
    pub fn build(self) -> Client {
        let version_path_base = get_version_path_with_base(self.base_url.clone());

        Client {
            inner: self
                .reqwest_builder
                .default_headers(self.headers)
                .timeout(self.timeout)
                .cookie_store(true)
                .build()
                .unwrap(),
            base_url: self.base_url,
            version_path_base,
        }
    }
```

**File:** config/src/config/network_config.rs (L359-364)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "snake_case")]
pub struct RestDiscovery {
    pub url: url::Url,
    pub interval_secs: u64,
}
```

**File:** types/src/on_chain_config/validator_set.rs (L23-32)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct ValidatorSet {
    pub scheme: ConsensusScheme,
    pub active_validators: Vec<ValidatorInfo>,
    pub pending_inactive: Vec<ValidatorInfo>,
    pub pending_active: Vec<ValidatorInfo>,
    pub total_voting_power: u128,
    pub total_joining_power: u128,
}
```

**File:** network/discovery/src/validator_set.rs (L107-150)
```rust
/// Extracts a set of ConnectivityRequests from a ValidatorSet which are appropriate for a network with type role.
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```

**File:** network/framework/src/connectivity_manager/mod.rs (L886-1002)
```rust
    fn handle_update_discovered_peers(
        &mut self,
        src: DiscoverySource,
        new_discovered_peers: PeerSet,
    ) {
        // Log the update event
        info!(
            NetworkSchema::new(&self.network_context),
            "{} Received updated list of discovered peers! Source: {:?}, num peers: {:?}",
            self.network_context,
            src,
            new_discovered_peers.len()
        );

        // Remove peers that no longer have relevant network information
        let mut keys_updated = false;
        let mut peers_to_check_remove = Vec::new();
        for (peer_id, peer) in self.discovered_peers.write().peer_set.iter_mut() {
            let new_peer = new_discovered_peers.get(peer_id);
            let check_remove = if let Some(new_peer) = new_peer {
                if new_peer.keys.is_empty() {
                    keys_updated |= peer.keys.clear_src(src);
                }
                if new_peer.addresses.is_empty() {
                    peer.addrs.clear_src(src);
                }
                new_peer.addresses.is_empty() && new_peer.keys.is_empty()
            } else {
                keys_updated |= peer.keys.clear_src(src);
                peer.addrs.clear_src(src);
                true
            };
            if check_remove {
                peers_to_check_remove.push(*peer_id);
            }
        }

        // Remove peers that no longer have state
        for peer_id in peers_to_check_remove {
            self.discovered_peers.write().remove_peer_if_empty(&peer_id);
        }

        // Make updates to the peers accordingly
        for (peer_id, discovered_peer) in new_discovered_peers {
            // Don't include ourselves, because we don't need to dial ourselves
            if peer_id == self.network_context.peer_id() {
                continue;
            }

            // Create the new `DiscoveredPeer`, role is set when a `Peer` is first discovered
            let mut discovered_peers = self.discovered_peers.write();
            let peer = discovered_peers
                .peer_set
                .entry(peer_id)
                .or_insert_with(|| DiscoveredPeer::new(discovered_peer.role));

            // Update the peer's pubkeys
            let mut peer_updated = false;
            if peer.keys.update(src, discovered_peer.keys) {
                info!(
                    NetworkSchema::new(&self.network_context)
                        .remote_peer(&peer_id)
                        .discovery_source(&src),
                    "{} pubkey sets updated for peer: {}, pubkeys: {}",
                    self.network_context,
                    peer_id.short_str(),
                    peer.keys
                );
                keys_updated = true;
                peer_updated = true;
            }

            // Update the peer's addresses
            if peer.addrs.update(src, discovered_peer.addresses) {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    network_addresses = &peer.addrs,
                    "{} addresses updated for peer: {}, update src: {:?}, addrs: {}",
                    self.network_context,
                    peer_id.short_str(),
                    src,
                    &peer.addrs,
                );
                peer_updated = true;
            }

            // If we're currently trying to dial this peer, we reset their
            // dial state. As a result, we will begin our next dial attempt
            // from the first address (which might have changed) and from a
            // fresh backoff (since the current backoff delay might be maxed
            // out if we can't reach any of their previous addresses).
            if peer_updated {
                if let Some(dial_state) = self.dial_states.get_mut(&peer_id) {
                    *dial_state = DialState::new(self.backoff_strategy.clone());
                }
            }
        }

        // update eligible peers accordingly
        if keys_updated {
            // For each peer, union all of the pubkeys from each discovery source
            // to generate the new eligible peers set.
            let new_eligible = self.discovered_peers.read().get_eligible_peers();

            // Swap in the new eligible peers set
            if let Err(error) = self
                .peers_and_metadata
                .set_trusted_peers(&self.network_context.network_id(), new_eligible)
            {
                error!(
                    NetworkSchema::new(&self.network_context),
                    error = %error,
                    "Failed to update trusted peers set"
                );
            }
        }
    }
```

**File:** network/framework/src/noise/handshake.rs (L366-427)
```rust
        // if mutual auth mode, verify the remote pubkey is in our set of trusted peers
        let network_id = self.network_context.network_id();
        let peer_role = match &self.auth_mode {
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
            },
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
        }?;
```
