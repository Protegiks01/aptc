# Audit Report

## Title
Mutex Poisoning in Secret Sharing Causes Permanent Consensus Halt on First Block

## Summary
The secret sharing subsystem in Aptos consensus contains a critical vulnerability where the first attempt to add a self-share triggers a guaranteed panic while holding the `secret_share_store` mutex lock. Because the codebase uses `aptos_infallible::Mutex` which panics on poisoned locks, this permanently blocks all future secret sharing operations, halting randomness generation and consensus progress for the entire epoch.

## Finding Description
The vulnerability exists in the secret sharing implementation used for distributed randomness generation in Aptos consensus. The attack path is as follows:

1. When a new block arrives, `SecretShareManager::process_incoming_block()` acquires the mutex lock on `secret_share_store`: [1](#0-0) 

2. While holding the lock, it calls `add_self_share()`: [2](#0-1) 

3. `add_self_share()` retrieves peer weights from the config: [3](#0-2) 

4. This HashMap is initialized as empty and never populated: [4](#0-3) 

5. The code then calls `add_share_with_metadata()` which attempts to look up the author's weight in the empty HashMap: [5](#0-4) 

6. This `.expect()` panics because the HashMap is empty, poisoning the mutex while it's held.

7. The mutex uses `aptos_infallible::Mutex` which converts poisoned lock attempts into panics: [6](#0-5) 

8. All subsequent attempts to lock the `secret_share_store` panic with "Cannot currently handle a poisoned lock", permanently blocking:
   - Processing of external secret shares from other validators
   - Adding self-shares for future blocks
   - Aggregation of shares for randomness generation

**Secondary panic points** while holding the same lock include:
- `SecretShareAggregator::retain()` also expects authors to exist in the empty weights map: [7](#0-6) 
- `SecretShareAggregator::try_aggregate()` expects self-share to be present: [8](#0-7) 

This breaks the **Consensus Liveness** invariant - nodes cannot progress consensus if randomness is required for block proposals or transaction execution.

## Impact Explanation
This is a **Critical Severity** vulnerability under the Aptos Bug Bounty program because it causes:

- **Total loss of liveness/network availability**: Once triggered, the entire epoch's secret sharing is permanently halted. No validator can process secret shares, preventing randomness generation.
- **Non-recoverable without intervention**: The poisoned mutex state persists for the entire epoch. Recovery requires either an epoch transition (if consensus can still progress without randomness) or emergency intervention.
- **Deterministic trigger**: This is not a race condition - it triggers on the **first** block requiring secret sharing in any epoch where the feature is enabled.

If Aptos consensus depends on randomness for liveness (leader election, transaction ordering, etc.), this becomes a complete network halt requiring a hardfork to resolve.

## Likelihood Explanation
**Likelihood: Guaranteed to occur if secret sharing is enabled**

The vulnerability triggers automatically without any attacker action:
- The `weights` HashMap in `SecretShareConfig` is initialized empty in the constructor
- No code path populates this HashMap
- The first `add_self_share()` call for any block will panic

Currently, based on code inspection, secret sharing appears to be under development and may not be enabled in production (the `spawn_decoupled_execution()` call passes `None` for `secret_sharing_config`): [9](#0-8) 

However, if/when this feature is enabled, the vulnerability will trigger immediately and deterministically.

## Recommendation

**Short-term fix**: Populate the `weights` HashMap properly in `SecretShareConfig::new()` by extracting weights from the validator configuration:

```rust
pub fn new(
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    digest_key: DigestKey,
    msk_share: MasterSecretKeyShare,
    verification_keys: Vec<VerificationKey>,
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
    encryption_key: EncryptionKey,
) -> Self {
    // Properly initialize weights from validator verifier
    let weights: HashMap<Author, u64> = validator
        .get_ordered_account_addresses_iter()
        .map(|addr| (*addr, validator.get_voting_power(addr).unwrap_or(1)))
        .collect();
    
    Self {
        _author: author,
        _epoch: epoch,
        validator,
        digest_key,
        msk_share,
        verification_keys,
        config,
        encryption_key,
        weights,
    }
}
```

**Medium-term fix**: Replace `aptos_infallible::Mutex` with proper error handling in critical consensus paths. Mutex poisoning should be recoverable or logged, not cause cascading panics.

**Long-term fix**: Implement comprehensive validation of `SecretShareConfig` state before use, with early detection of missing weights.

## Proof of Concept

```rust
#[cfg(test)]
mod test_mutex_poisoning {
    use super::*;
    use aptos_types::validator_verifier::ValidatorVerifier;
    use aptos_crypto::hash::HashValue;
    use std::sync::Arc;
    
    #[test]
    #[should_panic(expected = "Author must exist in weights")]
    fn test_add_self_share_panics_with_empty_weights() {
        // Create a minimal SecretShareConfig with empty weights (current implementation)
        let author = AccountAddress::random();
        let epoch = 1;
        let validator = Arc::new(ValidatorVerifier::new(vec![]));
        
        // Create mock crypto components (simplified for PoC)
        let digest_key = /* mock DigestKey */;
        let msk_share = /* mock MasterSecretKeyShare */;
        let verification_keys = vec![];
        let config = /* mock ThresholdConfig */;
        let encryption_key = /* mock EncryptionKey */;
        
        let secret_share_config = SecretShareConfig::new(
            author,
            epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
        );
        
        // Create SecretShareStore with this config
        let (decision_tx, _) = unbounded();
        let store = Arc::new(Mutex::new(SecretShareStore::new(
            epoch,
            author,
            secret_share_config.clone(),
            decision_tx,
        )));
        
        // Create a self share
        let metadata = SecretShareMetadata::new(
            epoch,
            1, // round
            0, // timestamp
            HashValue::zero(),
            vec![], // digest
        );
        let self_share = SecretShare::new(
            author,
            metadata,
            /* mock SecretKeyShare */,
        );
        
        // Acquire lock and call add_self_share - this WILL PANIC
        let mut locked_store = store.lock();
        locked_store.add_self_share(self_share).unwrap();
        // Execution never reaches here - panic occurs in add_share_with_metadata()
    }
    
    #[test]
    fn test_mutex_poisoned_after_panic() {
        // After the above panic, attempting to lock the mutex again would panic
        // with "Cannot currently handle a poisoned lock"
        // This demonstrates the permanent denial of service
    }
}
```

**Notes:**
- This vulnerability is in production code but may not be actively triggered if secret sharing is disabled
- The empty `weights` HashMap initialization is at: [10](#0-9) 
- Similar issues exist in `SecretShareAggregator::retain()` which also expects weights to be populated
- The `get_peer_weight()` method currently returns a hardcoded `1` instead of using the weights map: [11](#0-10)

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L143-143)
```rust
            let mut secret_share_store = self.secret_share_store.lock();
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L145-147)
```rust
            secret_share_store
                .add_self_share(self_secret_share.clone())
                .expect("Add self dec share should succeed");
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L52-54)
```rust
        let self_share = self
            .get_self_share()
            .expect("Aggregated item should have self share");
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L76-80)
```rust
        self.total_weight = self
            .shares
            .keys()
            .map(|author| weights.get(author).expect("Author must exist for weight"))
            .sum();
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L162-164)
```rust
        let share_weight = *share_weights
            .get(share.author())
            .expect("Author must exist in weights");
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L242-242)
```rust
        let peer_weights = self.secret_share_config.get_peer_weights();
```

**File:** types/src/secret_sharing.rs (L145-169)
```rust
    weights: HashMap<Author, u64>,
}

impl SecretShareConfig {
    pub fn new(
        author: Author,
        epoch: u64,
        validator: Arc<ValidatorVerifier>,
        digest_key: DigestKey,
        msk_share: MasterSecretKeyShare,
        verification_keys: Vec<VerificationKey>,
        config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
        encryption_key: EncryptionKey,
    ) -> Self {
        Self {
            _author: author,
            _epoch: epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
            weights: HashMap::new(),
        }
```

**File:** types/src/secret_sharing.rs (L196-198)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }
```

**File:** crates/aptos-infallible/src/mutex.rs (L19-23)
```rust
    pub fn lock(&self) -> MutexGuard<'_, T> {
        self.0
            .lock()
            .expect("Cannot currently handle a poisoned lock")
    }
```

**File:** consensus/src/pipeline/execution_client.rs (L549-549)
```rust
            None,
```
