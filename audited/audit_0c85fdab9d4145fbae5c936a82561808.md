# Audit Report

## Title
Missing Validator Authorization in Secret Share Request Handler Allows Unauthorized Access to Encrypted Transaction Data

## Summary

The `handle_incoming_msg()` function in `secret_share_manager.rs` serves decryption key shares to any authenticated network peer without verifying the requester is in the current epoch's validator set. This allows removed validators to request and decrypt encrypted transactions during the network disconnection window after epoch transitions.

## Finding Description

The secret sharing system implements threshold decryption for encrypted transactions. Each validator derives decryption key shares for blocks, and any threshold number of shares can reconstruct the full decryption key.

The vulnerability exists in the message verification and handling flow:

1. **Insufficient Verification**: The `verify()` method for `RequestShare` messages only validates the epoch number, not sender authorization. [1](#0-0) 

2. **Unused Sender Information**: The `IncomingSecretShareRequest` struct contains a `sender` field marked as `#[allow(unused)]`, indicating it's never validated. [2](#0-1) 

3. **Unchecked Share Distribution**: The `handle_incoming_msg()` function directly serves secret shares without verifying the requester is in the current validator set. [3](#0-2) 

4. **No Validator Set Check**: The verification task deserializes and verifies messages but never checks if the sender is in `epoch_state.verifier`. [4](#0-3) 

**Attack Scenario:**
- Validator Alice is removed from the validator set at epoch transition Nâ†’N+1
- Before the network's `close_stale_connections()` disconnects her, Alice sends `RequestShare` messages for blocks in epoch N+1
- Current validators serve their shares without checking Alice's authorization
- Alice collects threshold shares and reconstructs decryption keys for encrypted transactions she should not access
- Alice decrypts sensitive transaction data from blocks after her removal

The secret shares are used to decrypt encrypted transaction payloads, as shown in the decryption pipeline: [5](#0-4) 

## Impact Explanation

**Severity: Critical** (Cryptographic Access Control Bypass)

This vulnerability allows unauthorized access to encrypted transaction data, violating the fundamental security property that only active validators should decrypt sensitive transaction payloads. 

The impact includes:
- **Confidentiality Breach**: Removed/malicious validators can decrypt encrypted transactions after their removal
- **Consensus Invariant Violation**: Breaks the "Access Control" invariant that system resources must be protected
- **Privacy Violation**: Users submitting encrypted transactions expect only current validators can decrypt them
- **Extended Attack Window**: The race window between validator removal and network disconnection provides exploitation opportunity

This meets **Critical Severity** criteria as it enables unauthorized access to cryptographic material that protects sensitive user data.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploitable:

1. **Common Trigger**: Epoch transitions with validator set changes happen regularly in production
2. **Race Window**: Network disconnection via `close_stale_connections()` is not instantaneous [6](#0-5) 

3. **No Rate Limiting**: There are no restrictions on request frequency or volume
4. **Simple Exploitation**: Attacker only needs to send standard `RequestShare` messages
5. **No Detection**: The missing validation means malicious requests appear legitimate

## Recommendation

Add sender validation in the `handle_incoming_msg()` function to verify the requester is in the current epoch's validator set:

```rust
fn handle_incoming_msg(&self, rpc: SecretShareRpc, sender: Author) {
    let SecretShareRpc {
        msg,
        protocol,
        response_sender,
    } = rpc;
    match msg {
        SecretShareMessage::RequestShare(request) => {
            // ADDED: Validate sender is in current validator set
            if !self.epoch_state.verifier.get_ordered_account_addresses().contains(&sender) {
                warn!(
                    "Rejecting RequestShare from unauthorized sender {} not in validator set",
                    sender
                );
                return;
            }
            
            let result = self
                .secret_share_store
                .lock()
                .get_self_share(request.metadata());
            // ... rest of existing code
        },
        // ... rest of match arms
    }
}
```

Additionally, modify the `verification_task()` to pass the sender information through to `handle_incoming_msg()`, and update the `SecretShareRpc` struct to include the sender field.

## Proof of Concept

```rust
// Proof of Concept Test (pseudo-code for integration test)
#[tokio::test]
async fn test_unauthorized_secret_share_request() {
    // Setup: Create epoch N with validators [A, B, C, D]
    let mut test_env = TestEnvironment::new();
    let (validator_a, validator_b, validator_c, validator_d) = 
        test_env.create_validators(4);
    
    // Epoch N: All validators active
    test_env.start_epoch(vec![validator_a, validator_b, validator_c, validator_d]);
    
    // Create block with encrypted transaction
    let encrypted_tx = create_encrypted_transaction();
    let block = test_env.create_block_with_txns(vec![encrypted_tx]);
    
    // Epoch N+1: Remove validator_a from set
    test_env.transition_epoch(vec![validator_b, validator_c, validator_d]);
    
    // ATTACK: Before network disconnects validator_a, send RequestShare
    let request = RequestSecretShare::new(SecretShareMetadata {
        epoch: test_env.current_epoch(),
        round: block.round(),
        timestamp: block.timestamp_usecs(),
        block_id: block.id(),
        digest: block.digest(),
    });
    
    // Send request from removed validator_a to active validator_b
    let response = validator_a.send_rpc(
        validator_b.address(),
        SecretShareMessage::RequestShare(request),
        Duration::from_secs(5),
    ).await;
    
    // VULNERABILITY: validator_b serves the share without checking authorization
    assert!(response.is_ok());
    let share = extract_share(response.unwrap());
    
    // Collect threshold shares from other validators similarly
    let shares = collect_shares_from_all(validator_a, &[validator_b, validator_c]);
    
    // IMPACT: Removed validator can decrypt transactions
    let decryption_key = reconstruct_key(shares);
    let decrypted_tx = decrypt_transaction(encrypted_tx, decryption_key);
    
    // This should FAIL but currently SUCCEEDS
    assert!(decrypted_tx.is_some(), "Removed validator should not decrypt transactions!");
}
```

## Notes

The vulnerability exists because the protocol assumes all connected peers are authorized validators, relying solely on network-level authentication. However, during epoch transitions, stale validators remain connected briefly before `close_stale_connections()` removes them. This race window, combined with the missing application-level authorization check, allows unauthorized access to cryptographic material.

The fix requires adding validator set membership verification at the application layer, independent of network connectivity status.

### Citations

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** consensus/src/network.rs (L154-161)
```rust
#[derive(Debug)]
pub struct IncomingSecretShareRequest {
    pub req: SecretShareNetworkMessage,
    #[allow(unused)]
    pub sender: Author,
    pub protocol: ProtocolId,
    pub response_sender: oneshot::Sender<Result<Bytes, RpcError>>,
}
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-235)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L286-308)
```rust
            SecretShareMessage::RequestShare(request) => {
                let result = self
                    .secret_share_store
                    .lock()
                    .get_self_share(request.metadata());
                match result {
                    Ok(Some(share)) => {
                        self.process_response(
                            protocol,
                            response_sender,
                            SecretShareMessage::Share(share),
                        );
                    },
                    Ok(None) => {
                        warn!(
                            "Self secret share could not be found for RPC request {}",
                            request.metadata().round
                        );
                    },
                    Err(e) => {
                        warn!("[SecretShareManager] Failed to get share: {}", e);
                    },
                }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L95-120)
```rust
        let metadata = SecretShareMetadata::new(
            block.epoch(),
            block.round(),
            block.timestamp_usecs(),
            block.id(),
            digest.clone(),
        );

        let derived_key_share = FPTXWeighted::derive_decryption_key_share(&msk_share, &digest)?;
        derived_self_key_share_tx
            .send(Some(SecretShare::new(
                author,
                metadata.clone(),
                derived_key_share,
            )))
            .expect("must send properly");

        // TODO(ibalajiarun): improve perf
        let proofs = FPTXWeighted::eval_proofs_compute_all(&proofs_promise, &digest_key);

        let maybe_decryption_key = secret_shared_key_rx
            .await
            .expect("decryption key should be available");
        // TODO(ibalajiarun): account for the case where decryption key is not available
        let decryption_key = maybe_decryption_key.expect("decryption key should be available");

```

**File:** network/framework/src/connectivity_manager/mod.rs (L484-531)
```rust
    async fn close_stale_connections(&mut self) {
        if let Some(trusted_peers) = self.get_trusted_peers() {
            // Identify stale peer connections
            let stale_peers = self
                .connected
                .iter()
                .filter(|(peer_id, _)| !trusted_peers.contains_key(peer_id))
                .filter_map(|(peer_id, metadata)| {
                    // If we're using server only auth, we need to not evict unknown peers
                    // TODO: We should prevent `Unknown` from discovery sources
                    if !self.mutual_authentication
                        && metadata.origin == ConnectionOrigin::Inbound
                        && (metadata.role == PeerRole::ValidatorFullNode
                            || metadata.role == PeerRole::Unknown)
                    {
                        None
                    } else {
                        Some(*peer_id) // The peer is stale
                    }
                });

            // Close existing connections to stale peers
            for stale_peer in stale_peers {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&stale_peer),
                    "{} Closing stale connection to peer {}",
                    self.network_context,
                    stale_peer.short_str()
                );

                if let Err(disconnect_error) = self
                    .connection_reqs_tx
                    .disconnect_peer(stale_peer, DisconnectReason::StaleConnection)
                    .await
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .remote_peer(&stale_peer),
                        error = %disconnect_error,
                        "{} Failed to close stale connection to peer {}, error: {}",
                        self.network_context,
                        stale_peer.short_str(),
                        disconnect_error
                    );
                }
            }
        }
    }
```
