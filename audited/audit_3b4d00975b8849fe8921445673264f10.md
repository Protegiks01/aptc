# Audit Report

## Title
Cross-Chain DKG Transcript Replay Attack Due to Missing Chain ID Validation

## Summary
The `process_dkg_result_inner()` function in `aptos-move/aptos-vm/src/validator_txns/dkg.rs` fails to validate chain ID when processing DKG (Distributed Key Generation) transcripts. This allows DKG transcripts from one network (e.g., testnet) to be replayed on another network (e.g., mainnet) if both chains reach the same epoch number, potentially compromising randomness security across independent chains.

## Finding Description
The DKG transcript validation performs only epoch-based validation without any chain ID or network identity checks. This breaks the fundamental security guarantee that independent blockchain networks should have cryptographically independent randomness sources.

**Structural Vulnerability:**

The `DKGTranscriptMetadata` structure contains only epoch and author information, with no chain identifier: [1](#0-0) 

The validation logic in `process_dkg_result_inner()` only checks epoch matching: [2](#0-1) 

**Missing Chain Binding:**

Unlike user transactions which include chain_id in their RawTransaction structure: [3](#0-2) 

ValidatorTransaction has no chain_id field: [4](#0-3) 

**Cryptographic Verification Gap:**

The transcript cryptographic verification binds to epoch and validator addresses, but NOT to chain_id: [5](#0-4) 

**Attack Propagation Path:**

1. A validator observes a valid `DKGResult` transaction on Chain A (e.g., testnet with chain_id=2)
2. Both Chain A and Chain B (e.g., mainnet with chain_id=1) reach epoch N simultaneously
3. The validator (operating on both chains or acting maliciously) proposes the Chain A transcript on Chain B
4. Validation passes at every layer:
   - Consensus layer validation only checks signatures: [6](#0-5) 
   - VM validation only checks epoch match (line 100 in dkg.rs, cited above)
   - No chain_id validation exists anywhere in the flow
5. Both chains commit identical DKG outputs, breaking randomness independence

**Invariant Violations:**

This vulnerability breaks Critical Invariant #10 (Cryptographic Correctness) and Invariant #2 (Consensus Safety) by allowing cross-chain state pollution that validators should never be able to introduce, even maliciously.

## Impact Explanation
**Severity: Critical** - This meets the Aptos Bug Bounty "Consensus/Safety violations" category.

**Security Impact:**
- **Randomness Compromise**: Independent chains would generate identical randomness outputs, violating the fundamental assumption that each network has independent entropy
- **Cross-Chain Front-Running**: Attackers observing randomness-dependent operations on one chain could predict and front-run identical operations on another chain
- **Protocol Safety Violation**: Breaks the deterministic execution invariant by allowing external chain state to influence on-chain outcomes

**Affected Systems:**
- Any randomness-dependent applications (NFT minting, lotteries, validator selection)
- Cross-chain security assumptions
- Network independence guarantees

## Likelihood Explanation
**Likelihood: Medium-High**

**Feasibility Factors:**
- **Epoch Alignment**: Different chains WILL eventually reach the same epoch number (deterministic over time)
- **Validator Overlap**: Test networks and preview networks often share validators with mainnet during network launches
- **Transaction Visibility**: DKG transactions are publicly observable on all chains
- **Exploitation Window**: Persistent (remains exploitable as long as the chains share epoch numbers)

**Attacker Requirements:**
- Validator access on the target chain (to propose blocks containing the replayed transaction)
- Ability to observe transactions on the source chain (public)
- Timing coordination to exploit when epochs align

**Exploitation Complexity**: Low - once epochs align, the attack is straightforward copy-paste of transaction data.

## Recommendation
**Add chain_id validation to DKG transcript processing:**

1. **Include chain_id in DKGTranscriptMetadata:**
```rust
// In types/src/dkg/mod.rs
pub struct DKGTranscriptMetadata {
    pub epoch: u64,
    pub author: AccountAddress,
    pub chain_id: ChainId,  // ADD THIS
}
```

2. **Validate chain_id in process_dkg_result_inner:**
```rust
// In aptos-move/aptos-vm/src/validator_txns/dkg.rs, after line 102:
use aptos_types::chain_id::ChainId;

// Fetch the chain_id from on-chain configuration
let chain_id = ChainId::fetch_config(resolver)
    .ok_or(Expected(MissingResourceChainId))?;

// Validate chain_id matches
if dkg_node.metadata.chain_id != chain_id {
    return Err(Expected(ChainIdMismatch));
}
```

3. **Update transcript generation to include chain_id:**
Modify DKG transcript creation to bind the chain_id at generation time, ensuring the cryptographic verification also incorporates chain identity.

4. **Add corresponding error codes:**
```rust
// In dkg.rs ExpectedFailure enum
ChainIdMismatch = 0x10004,
MissingResourceChainId = 0x30004,
```

## Proof of Concept

**Conceptual PoC (requires multi-chain test environment):**

```rust
// Pseudocode demonstrating the vulnerability

// Setup: Two chains at epoch 100
// Chain A (testnet, chain_id=2)
// Chain B (mainnet, chain_id=1)

// Step 1: Observe valid DKGResult on Chain A
let chain_a_dkg_transcript = DKGTranscript {
    metadata: DKGTranscriptMetadata {
        epoch: 100,
        author: validator_address,
        // NO CHAIN_ID FIELD!
    },
    transcript_bytes: valid_transcript_bytes,
};

// Step 2: Create ValidatorTransaction for Chain B
let replay_txn = ValidatorTransaction::DKGResult(chain_a_dkg_transcript.clone());

// Step 3: Include in Chain B proposal (requires validator access)
// Validation at consensus layer (round_manager.rs:1134)
// -> Only checks signature, passes ✓

// Step 4: Execute in VM (dkg.rs:100)
// -> Only checks epoch == 100, passes ✓
// -> NO chain_id check exists!

// Result: Chain B accepts Chain A's DKG transcript
// Both chains now have IDENTICAL randomness outputs
// Security invariant VIOLATED
```

**Verification Steps:**
1. Deploy two independent Aptos networks with overlapping validator sets
2. Advance both chains to the same epoch number
3. Capture a DKGResult transaction from Chain A
4. Submit the same DKGResult via validator proposal on Chain B
5. Observe that Chain B accepts the transcript without error
6. Verify both chains produce identical randomness output

**Notes:**
- This vulnerability exists in the validation logic itself, making it a protocol-level issue
- Exploitation requires validator participation, but the bug allows what should be rejected to succeed
- The impact affects all randomness-dependent applications across both chains
- Even accidental replay (due to validator misconfiguration) would cause critical security failure

### Citations

**File:** types/src/dkg/mod.rs (L28-32)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, Eq, CryptoHasher, BCSCryptoHash)]
pub struct DKGTranscriptMetadata {
    pub epoch: u64,
    pub author: AccountAddress,
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L99-102)
```rust
        // Check epoch number.
        if dkg_node.metadata.epoch != config_resource.epoch() {
            return Err(Expected(EpochNotCurrent));
        }
```

**File:** types/src/transaction/mod.rs (L203-204)
```rust
    /// Chain ID of the Aptos network this transaction is intended for.
    chain_id: ChainId,
```

**File:** types/src/validator_txn.rs (L14-18)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub enum ValidatorTransaction {
    DKGResult(DKGTranscript),
    ObservedJWKUpdate(jwks::QuorumCertifiedUpdate),
}
```

**File:** types/src/dkg/real_dkg/mod.rs (L363-374)
```rust
        let aux = dealers_addresses
            .iter()
            .map(|address| (params.pvss_config.epoch, address))
            .collect::<Vec<_>>();

        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** consensus/src/round_manager.rs (L1134-1135)
```rust
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
```
