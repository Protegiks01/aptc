# Audit Report

## Title
Indexer Node Panic Due to Missing Processor Name Validation in IndexerConfig

## Summary
The `IndexerConfig` lacks validation for the `processor` field, allowing invalid processor names to reach `Processor::from_string()` at runtime, which triggers a panic instead of graceful error handling. This causes indexer node crashes and potential denial of service.

## Finding Description
The vulnerability exists in the configuration validation chain for the Aptos indexer service. When a node starts, configuration validation occurs in two phases: optimization and sanitization. However, `IndexerConfig` only implements the `ConfigOptimizer` trait and does NOT implement `ConfigSanitizer`, meaning no validation occurs for the processor name field. [1](#0-0) 

The `IndexerConfig::optimize()` method sets the processor name from environment variables or configuration with a default value, but never validates that it matches one of the four valid processor types. [2](#0-1) 

Furthermore, `NodeConfig::sanitize()` explicitly does NOT call any sanitization for `IndexerConfig`, unlike other config components. [3](#0-2) 

The invalid configuration propagates through the system until runtime initialization, where `Processor::from_string()` is called with the unvalidated processor name. [4](#0-3) 

When an invalid processor name is provided, the match statement in `from_string()` falls through to the default case, which panics. [5](#0-4) 

The valid processor names are: `"default_processor"`, `"token_processor"`, `"coin_processor"`, and `"stake_processor"`. [6](#0-5) [7](#0-6) [8](#0-7) [9](#0-8) 

## Impact Explanation
This qualifies as **High Severity** per the Aptos bug bounty criteria for the following reasons:

1. **API/Service Crashes**: The panic causes the indexer runtime to crash, taking down the entire indexer service. This falls under "API crashes" listed as High severity.

2. **Availability Impact**: Indexer nodes provide critical blockchain data indexing services. A crash prevents transaction indexing, affecting dependent applications and users.

3. **Misconfiguration Exploitation**: While not directly exploitable by external attackers without deployment access, misconfigurations are common in production environments, especially with environment variable overrides.

4. **No Graceful Degradation**: The panic occurs after significant initialization work (database connection pooling, tailer instantiation), wasting resources and complicating debugging.

## Likelihood Explanation
This issue has **medium to high likelihood** of occurrence:

1. **Configuration Flexibility**: The system accepts processor names from both config files and the `PROCESSOR_NAME` environment variable, increasing misconfiguration risk.

2. **Lack of Documentation Guards**: Typos in processor names (e.g., `"token-processor"` instead of `"token_processor"`) would trigger this panic.

3. **Deployment Automation**: Automated deployment systems using templated configurations could propagate invalid processor names across multiple nodes.

4. **Late Failure**: The panic occurs during runtime initialization rather than config loading, making it harder to catch in pre-deployment validation.

## Recommendation
Implement validation for the `processor` field in `IndexerConfig`. Two approaches are recommended:

**Approach 1: Add validation in `IndexerConfig::optimize()`**
```rust
// In config/src/config/indexer_config.rs
impl ConfigOptimizer for IndexerConfig {
    fn optimize(...) -> Result<bool, Error> {
        // ... existing code ...
        
        // Verify and set the processor
        indexer_config.processor = env_var_or_default(
            PROCESSOR_NAME,
            indexer_config
                .processor
                .clone()
                .or_else(|| Some("default_processor".to_string())),
            None,
        );
        
        // ADDED: Validate the processor name
        if let Some(ref processor_name) = indexer_config.processor {
            const VALID_PROCESSORS: &[&str] = &[
                "default_processor",
                "token_processor", 
                "coin_processor",
                "stake_processor"
            ];
            
            if !VALID_PROCESSORS.contains(&processor_name.as_str()) {
                return Err(Error::InvariantViolation(
                    format!(
                        "Invalid processor name '{}'. Must be one of: {}",
                        processor_name,
                        VALID_PROCESSORS.join(", ")
                    )
                ));
            }
        }
        
        // ... rest of existing code ...
    }
}
```

**Approach 2: Implement `ConfigSanitizer` for `IndexerConfig`**
Add a sanitization implementation and register it in `NodeConfig::sanitize()`.

**Approach 3: Use Result type instead of panic**
Modify `Processor::from_string()` to return `Result<Self, String>` instead of panicking, providing graceful error handling.

## Proof of Concept

**Reproduction Steps:**

1. Create a node configuration file with an invalid processor name:
```yaml
indexer:
  enabled: true
  postgres_uri: "postgresql://localhost/test"
  processor: "invalid_processor"
```

2. Or set the environment variable:
```bash
export PROCESSOR_NAME="invalid_processor"
export INDEXER_DATABASE_URL="postgresql://localhost/test"
```

3. Start an Aptos node with indexer enabled using this configuration.

4. The node will crash with panic message:
```
thread 'indexer' panicked at 'Processor unsupported invalid_processor', crates/indexer/src/processors/mod.rs:28:17
```

**Expected Behavior:** Configuration validation should fail during the `load_from_path()` call with a clear error message indicating the invalid processor name and listing valid options.

**Actual Behavior:** The invalid configuration passes through optimization and sanitization phases, only to trigger a panic during runtime initialization after database connections are established.

---

## Notes
This vulnerability demonstrates a gap in the configuration validation framework where `IndexerConfig` lacks the same sanitization rigor applied to other configuration components like `IndexerGrpcConfig` and `InternalIndexerDBConfig`. The fix should follow the established patterns in the codebase for configuration validation to maintain consistency.

### Citations

**File:** config/src/config/indexer_config.rs (L119-199)
```rust
impl ConfigOptimizer for IndexerConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        _local_config_yaml: &Value,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        // If the indexer is not enabled, there's nothing to do
        let indexer_config = &mut node_config.indexer;
        if !indexer_config.enabled {
            return Ok(false);
        }

        // TODO: we really shouldn't be overriding the configs if they are
        // specified in the local node config file. This optimizer should
        // migrate to the pattern used by other optimizers, but for now, we'll
        // just keep the legacy behaviour to avoid breaking anything.

        // Verify and set the postgres uri
        indexer_config.postgres_uri = env_var_or_default(
            INDEXER_DATABASE_URL,
            indexer_config.postgres_uri.clone(),
            Some(format!(
                "Either 'config.indexer.postgres_uri' or '{}' must be set!",
                INDEXER_DATABASE_URL
            )),
        );

        // Verify and set the processor
        indexer_config.processor = env_var_or_default(
            PROCESSOR_NAME,
            indexer_config
                .processor
                .clone()
                .or_else(|| Some("default_processor".to_string())),
            None,
        );

        // Verify and set the starting version
        indexer_config.starting_version = match std::env::var(STARTING_VERSION).ok() {
            None => indexer_config.starting_version,
            Some(starting_version) => match starting_version.parse::<u64>() {
                Ok(version) => Some(version),
                Err(error) => {
                    // This will allow a processor to have STARTING_VERSION undefined when deploying
                    warn!(
                        "Invalid STARTING_VERSION: {}. Error: {:?}. Using {:?} instead.",
                        starting_version, error, indexer_config.starting_version
                    );
                    indexer_config.starting_version
                },
            },
        };

        // Set appropriate defaults
        indexer_config.skip_migrations = indexer_config.skip_migrations.or(Some(false));
        indexer_config.check_chain_id = indexer_config.check_chain_id.or(Some(true));
        indexer_config.batch_size = default_if_zero(
            indexer_config.batch_size.map(|v| v as u64),
            DEFAULT_BATCH_SIZE as u64,
        )
        .map(|v| v as u16);
        indexer_config.fetch_tasks = default_if_zero(
            indexer_config.fetch_tasks.map(|v| v as u64),
            DEFAULT_FETCH_TASKS as u64,
        )
        .map(|v| v as u8);
        indexer_config.processor_tasks = default_if_zero(
            indexer_config.processor_tasks.map(|v| v as u64),
            DEFAULT_PROCESSOR_TASKS as u64,
        )
        .map(|value| value as u8);
        indexer_config.emit_every = indexer_config.emit_every.or(Some(0));
        indexer_config.gap_lookback_versions = env_var_or_default(
            GAP_LOOKBACK_VERSIONS,
            indexer_config.gap_lookback_versions.or(Some(1_500_000)),
            None,
        );

        Ok(true)
    }
```

**File:** config/src/config/config_sanitizer.rs (L39-70)
```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }

        // Sanitize all of the sub-configs
        AdminServiceConfig::sanitize(node_config, node_type, chain_id)?;
        ApiConfig::sanitize(node_config, node_type, chain_id)?;
        BaseConfig::sanitize(node_config, node_type, chain_id)?;
        ConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        DagConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        ExecutionConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_failpoints_config(node_config, node_type, chain_id)?;
        sanitize_fullnode_network_configs(node_config, node_type, chain_id)?;
        IndexerGrpcConfig::sanitize(node_config, node_type, chain_id)?;
        InspectionServiceConfig::sanitize(node_config, node_type, chain_id)?;
        LoggerConfig::sanitize(node_config, node_type, chain_id)?;
        MempoolConfig::sanitize(node_config, node_type, chain_id)?;
        NetbenchConfig::sanitize(node_config, node_type, chain_id)?;
        StateSyncConfig::sanitize(node_config, node_type, chain_id)?;
        StorageConfig::sanitize(node_config, node_type, chain_id)?;
        InternalIndexerDBConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_validator_network_config(node_config, node_type, chain_id)?;

        Ok(()) // All configs passed validation
    }
```

**File:** crates/indexer/src/runtime.rs (L108-132)
```rust
    let processor_name = config.processor.clone().unwrap();
    let check_chain_id = config.check_chain_id.unwrap();
    let skip_migrations = config.skip_migrations.unwrap();
    let fetch_tasks = config.fetch_tasks.unwrap();
    let processor_tasks = config.processor_tasks.unwrap();
    let emit_every = config.emit_every.unwrap();
    let batch_size = config.batch_size.unwrap();
    let lookback_versions = config.gap_lookback_versions.unwrap() as i64;

    info!(processor_name = processor_name, "Starting indexer...");

    let db_uri = &config.postgres_uri.unwrap();
    info!(
        processor_name = processor_name,
        "Creating connection pool..."
    );
    let conn_pool = new_db_pool(db_uri).expect("Failed to create connection pool");
    info!(
        processor_name = processor_name,
        "Created the connection pool... "
    );

    info!(processor_name = processor_name, "Instantiating tailer... ");

    let processor_enum = Processor::from_string(&processor_name);
```

**File:** crates/indexer/src/processors/mod.rs (L21-30)
```rust
impl Processor {
    pub fn from_string(input_str: &String) -> Self {
        match input_str.as_str() {
            DEFAULT_PROCESSOR_NAME => Self::DefaultProcessor,
            TOKEN_PROCESSOR_NAME => Self::TokenProcessor,
            COIN_PROCESSOR_NAME => Self::CoinProcessor,
            STAKE_PROCESSOR_NAME => Self::StakeProcessor,
            _ => panic!("Processor unsupported {}", input_str),
        }
    }
```

**File:** crates/indexer/src/processors/default_processor.rs (L32-32)
```rust
pub const NAME: &str = "default_processor";
```

**File:** crates/indexer/src/processors/token_processor.rs (L58-58)
```rust
pub const NAME: &str = "token_processor";
```

**File:** crates/indexer/src/processors/coin_processor.rs (L28-28)
```rust
pub const NAME: &str = "coin_processor";
```

**File:** crates/indexer/src/processors/stake_processor.rs (L29-29)
```rust
pub const NAME: &str = "stake_processor";
```
