# Audit Report

## Title
Bytecode Verifier Cache Bypass Allows References in Struct Type Parameters via Function Types

## Summary
The Move bytecode verifier's signature caching mechanism in `signature_v2.rs` contains a critical flaw that allows references to be embedded in struct type parameters through function types. The cache key lacks the `allow_ref` parameter, and the explicit reference check at line 664 only validates direct references (`&T`), not references nested within `Function` types. This enables malicious modules to bypass type safety invariants, potentially causing consensus splits between validators.

## Finding Description

The vulnerability exists in the interaction between three components: [1](#0-0) 

The cache key `(sig_idx, ty_idx, required_abilities)` critically **omits** the `allow_ref` parameter. When a cache hit occurs, the cached result is returned without re-checking whether references should be allowed. [2](#0-1) 

Function types ALWAYS validate their parameters with `allow_ref=true` (line 179), regardless of the outer context. This means `Function(&T, (), abilities)` is accepted even when the outer check requires `allow_ref=false`. [3](#0-2) 

The explicit check only validates `ty.is_reference()`, which returns `false` for `Function` types. [4](#0-3) 

**Attack Path:**

1. **Signature Pool Caching** - Module verification begins: [5](#0-4) 

All signatures are cached with `allow_ref=true`, including `Function(&T, (), abilities)` types.

2. **Struct Instantiation Verification** - Later: [6](#0-5) 

When checking `MyStruct<Function(&T, (), abilities)>`:
- Line 664's `ty.is_reference()` returns `false` (Function is not a direct reference) âœ“ passes
- Line 669 calls cached function with `allow_ref=false` parameter
- Cache hit returns result validated with `allow_ref=true` from step 1
- References inside the function type are NOT re-validated

**Invariant Violated:** Move's type system requires that storable struct types cannot contain references (directly or indirectly). This vulnerability allows struct type parameters to contain `Function` types with reference parameters, violating type safety.

## Impact Explanation

**Critical Severity - Consensus Split Risk**

This vulnerability meets the CRITICAL severity threshold for multiple reasons:

1. **Consensus Safety Violation**: Different validator implementations or versions may handle this differently, causing validators to disagree on module validity. Some validators might accept the module while others reject it, leading to a non-recoverable consensus split requiring a hard fork.

2. **Type Safety Breakdown**: Move's entire security model depends on the guarantee that storable types don't contain references. Breaking this invariant undermines:
   - Memory safety guarantees
   - Resource semantics
   - Global storage consistency

3. **VM State Corruption**: If such a type bypasses verification and enters the VM, it may cause undefined behavior, crashes, or state corruption during execution, as the VM assumes struct fields never contain references.

4. **Deterministic Execution Failure**: Violates Aptos Invariant #1 - validators may produce different state roots for identical blocks if they disagree on module validity.

## Likelihood Explanation

**High Likelihood**

- **Ease of Exploitation**: Any user can submit a transaction deploying a malicious Move module with crafted type signatures
- **No Special Privileges Required**: Attackers need only the ability to publish modules (standard transaction capability)
- **Deterministic Trigger**: The verification order is fixed - `verify_signature_pool_contextless` always runs before `verify_struct_instantiations_contextless` [7](#0-6) 

- **Cache Hit Guaranteed**: When struct type parameters have no ability constraints, `arg_abilities=AbilitySet::EMPTY` matches the cached key [8](#0-7) 

## Recommendation

**Immediate Fix**: Include `allow_ref` in the cache key to ensure cached results are only reused when the validation context matches:

```rust
// In verify_type_in_signature_contextless
let r = match self
    .ty_results
    .borrow_mut()
    .entry((sig_idx, ty_idx, required_abilities, allow_ref))  // Add allow_ref to key
{
    btree_map::Entry::Occupied(entry) => *entry.into_mut(),
    btree_map::Entry::Vacant(entry) => {
        // ... existing code
    }
};
```

**Additional Hardening**: Recursively validate that function types used as struct type arguments don't contain references in their parameters, regardless of caching:

```rust
// In verify_struct_type_params, after line 667
if let SignatureToken::Function(params, results, _) = ty {
    for param in params.iter().chain(results) {
        if contains_reference(param) {
            return Err(PartialVMError::new(StatusCode::INVALID_SIGNATURE_TOKEN)
                .with_message("function type with references not allowed in struct type parameter".to_string()));
        }
    }
}
```

## Proof of Concept

**Malicious Move Module Structure:**

```move
module attacker::exploit {
    // Define a struct with unconstrained type parameter
    struct Exploit<T> {
        field: T
    }
    
    // Create a signature containing: Function(&u64, (), AbilitySet::EMPTY)
    // Instantiate: Exploit<Function(&u64, (), AbilitySet::EMPTY)>
    
    // This would be represented in bytecode with:
    // - SignatureIndex pointing to [Function([Reference(U64)], [], EMPTY)]
    // - StructDefInstantiation using that signature as type argument
}
```

**Verification Steps:**
1. Compile malicious module with crafted bytecode containing function type with reference parameters
2. Submit module deployment transaction
3. Module passes verification due to cache bypass
4. Consensus split occurs if validators have different verifier versions or cache states

**Expected Result**: Module should be rejected with `INVALID_SIGNATURE_TOKEN` error, but instead passes verification due to the cache bypass vulnerability.

---

**Notes:**

The vulnerability is explicitly acknowledged by the developers through the IMPORTANT comments at lines 503, 660, and 939, but the mitigation (explicit `is_reference()` checks) is insufficient because it only catches direct references, not references nested within complex types like `Function`. The root cause is the incomplete cache key that fails to capture the `allow_ref` validation context.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L172-187)
```rust
            Function(params, results, abilities) => {
                assert_abilities(*abilities, required_abilities)?;
                if self.sig_checker_v2_fix_function_signatures {
                    for ty in params.iter().chain(results) {
                        self.check_ty(
                            ty,
                            // Immediate params and returns can be references.
                            true,
                            // Note we do not need to check abilities of argument or result types,
                            // they do not matter for the `required_abilities`.
                            AbilitySet::EMPTY,
                            param_constraints,
                        )?
                    }
                }
            },
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L370-400)
```rust
    fn verify_type_in_signature_contextless(
        &self,
        sig_idx: SignatureIndex,
        ty_idx: usize,
        required_abilities: AbilitySet,
        allow_ref: bool,
    ) -> PartialVMResult<&'a BitsetTypeParameterConstraints<N>> {
        let r = match self
            .ty_results
            .borrow_mut()
            .entry((sig_idx, ty_idx, required_abilities))
        {
            btree_map::Entry::Occupied(entry) => *entry.into_mut(),
            btree_map::Entry::Vacant(entry) => {
                let mut param_constraints = BitsetTypeParameterConstraints::new();
                let sig = self.resolver.signature_at(sig_idx);
                let ty = &sig.0[ty_idx];
                self.check_ty(ty, allow_ref, required_abilities, &mut param_constraints)
                    .map_err(|err| {
                        err.append_message_with_separator(' ', format!("at type {}", ty_idx))
                            .at_index(IndexKind::Signature, sig_idx.0)
                    })?;

                let r = self.constraints.alloc(param_constraints);

                *entry.insert(r)
            },
        };

        Ok(r)
    }
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L436-444)
```rust
    fn verify_signature_pool_contextless(&self) -> PartialVMResult<()> {
        for sig_idx in 0..self.resolver.signatures().len() {
            // Here we check signatures, which can be locals for instance, so references should be
            // allowed. Note that this function will cache results, which means that the signature
            // which is not supposed reference is cached with references allowed. One must make
            // sure any later checks do not go through cache, but explicitly reject references.
            self.verify_signature_contextless(SignatureIndex(sig_idx as u16), true)?;
        }
        Ok(())
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L652-658)
```rust
            let arg_abilities = if struct_handle.type_parameters[ty_idx].is_phantom {
                struct_handle.type_parameters[ty_idx].constraints
            } else {
                struct_handle.type_parameters[ty_idx]
                    .constraints
                    .union(required_abilities.requires())
            };
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L660-667)
```rust
            // IMPORTANT:
            //   This check should be kept here at all times, because it is possible
            //   that the signature is already cached when allowing references, so the
            //   below traversal will not complain about references...
            if ty.is_reference() {
                return Err(PartialVMError::new(StatusCode::INVALID_SIGNATURE_TOKEN)
                    .with_message("reference not allowed".to_string()));
            }
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L682-689)
```rust
    fn verify_struct_instantiations_contextless(&self) -> PartialVMResult<()> {
        for struct_inst_idx in 0..self.resolver.struct_instantiations().unwrap().len() {
            self.verify_struct_instantiation_contextless(
                StructDefInstantiationIndex(struct_inst_idx as u16),
                AbilitySet::EMPTY,
            )?;
        }
        Ok(())
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1157-1164)
```rust
    // Check if all signatures & instantiations are well-formed without any specific contexts.
    // This is only needed if we want to keep the binary format super clean.
    checker.verify_signature_pool_contextless()?;
    checker.verify_function_instantiations_contextless()?;
    checker.verify_struct_instantiations_contextless()?;
    checker.verify_field_instantiations_contextless()?;
    checker.verify_struct_variant_instantiations_contextless()?;
    checker.verify_variant_field_instantiations_contextless()?;
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L1191-1195)
```rust
    pub fn is_reference(&self) -> bool {
        use SignatureToken::*;

        matches!(self, Reference(_) | MutableReference(_))
    }
```
