# Audit Report

## Title
State Snapshot Restoration Bypasses Cryptographic Verification Leading to Byzantine State Injection

## Summary
The state snapshot restoration process in Aptos allows validators to restore blockchain state from backups without verifying cryptographic signatures when using the oneoff StateSnapshot restore command or when the `--skip-epoch-endings` flag is set. This enables a Byzantine attacker to create malicious state snapshots that honest validators will accept, causing catastrophic state divergence across the network.

## Finding Description

The vulnerability exists in the state snapshot restoration flow. When a validator restores from a state snapshot backup, the system is designed to verify the LedgerInfoWithSignatures against the epoch history to ensure the backup comes from the legitimate blockchain. However, this critical verification is completely bypassed in two scenarios: [1](#0-0) 

In the oneoff StateSnapshot restore command, the `epoch_history` parameter is hardcoded to `None`, meaning no signature verification occurs. [2](#0-1) 

Similarly, when using the full restore coordinator with the `--skip-epoch-endings` flag (labeled as "used for debugging"), the epoch_history is set to `None`. [3](#0-2) 

During restoration, the only verification performed when `epoch_history` is `None` is checking internal consistency - that the transaction info proof matches the ledger info, and that the root hash in the manifest matches the proof. Critically, line 137-139 shows that signature verification via `epoch_history.verify_ledger_info(&li)` is skipped entirely when epoch_history is absent.

The manifest and proof both come from the same untrusted backup storage source, meaning an attacker can create a completely self-consistent but fraudulent backup with:
1. An arbitrary fake state tree
2. A fake LedgerInfoWithSignatures with no valid validator signatures
3. Self-consistent Merkle proofs
4. A manifest tying everything together [4](#0-3) 

The trusted waypoints mechanism also provides no protection, as the documentation explicitly states that LedgerInfos "are NOT checked at all when doing one-shot restoring of the transaction and state backups."

**Attack Path:**

1. Byzantine attacker creates a malicious state snapshot:
   - Generates arbitrary state (e.g., inflated balances, modified validator set)
   - Computes Merkle tree root hash for the fake state
   - Creates fake LedgerInfoWithSignatures (no real validator signatures needed)
   - Generates valid Merkle proofs for the fake tree
   - Packages everything into a backup manifest

2. Attacker hosts the malicious backup (cloud storage, local server, etc.)

3. Attacker social engineers or tricks an honest validator operator into restoring from this backup using either:
   - `aptos-db-tool restore one-off state-snapshot --state-manifest <malicious_manifest>`
   - `aptos-db-tool restore bootstrap-db --skip-epoch-endings`

4. The honest validator restores the malicious state without signature verification

5. The validator now has a completely different state than the rest of the network, causing:
   - Different execution results for the same transactions
   - Different state root hashes in proposed blocks
   - Inability to reach consensus with honest validators
   - Potential network partition if multiple validators are affected

## Impact Explanation

This vulnerability has **Critical** severity under the Aptos bug bounty criteria as it constitutes a **Consensus/Safety violation**. The core invariants broken are:

1. **Deterministic Execution**: Validators with poisoned state will produce different state roots for identical blocks
2. **State Consistency**: The fundamental guarantee that all validators maintain identical state is violated

The attack enables:
- **Byzantine State Injection**: Arbitrary manipulation of blockchain state without validator signatures
- **Network Partition**: Affected validators cannot participate in consensus with honest nodes
- **Chain Split Risk**: If sufficient validators restore from the same malicious checkpoint, it could create a competing chain
- **Loss of Funds**: Malicious state could include inflated balances, modified ownership, or corrupted validator sets

This is more severe than a typical safety violation because it requires no validator key compromise - just operator error or social engineering during what appears to be legitimate disaster recovery.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is highly feasible because:

1. **Legitimate Use Cases**: The oneoff restore commands and `--skip-epoch-endings` flag exist for operational purposes, making their use plausible
2. **Social Engineering Surface**: Validator operators may be directed to restore from backups during disaster recovery scenarios
3. **No Special Privileges Required**: Attacker needs no validator keys, just ability to host files and communicate with operators
4. **Operational Pressure**: During outages or data loss events, operators may skip verification steps
5. **Documentation Gaps**: The security implications of `--skip-epoch-endings` are not prominently documented beyond "used for debugging"

The attack becomes more likely if:
- An attacker compromises backup storage infrastructure
- Operators follow outdated or incorrect recovery procedures
- There's urgency during disaster recovery scenarios

## Recommendation

**Immediate Fixes:**

1. **Remove the bypass in oneoff restore**: The oneoff StateSnapshot restore must verify signatures

2. **Require epoch history verification**: Make `epoch_history` a required parameter or verify against trusted waypoints

3. **Enforce waypoint verification**: Even for oneoff restores, verify the LedgerInfoWithSignatures against a trusted genesis waypoint at minimum

4. **Remove or restrict --skip-epoch-endings**: This flag should either be removed from production builds or require additional confirmation of the security risks

**Suggested Code Fix:**

In `storage/db-tool/src/restore.rs`, instead of hardcoding `None`:

```rust
// BEFORE (line 88-92):
StateSnapshotRestoreController::new(
    opt,
    global.try_into()?,
    storage.init_storage().await?,
    None, /* epoch_history */  // VULNERABLE!
)

// AFTER:
// Require epoch history for security
let epoch_handles = /* load epoch backups */;
let epoch_history = Some(Arc::new(
    EpochHistoryRestoreController::new(
        epoch_handles,
        global.clone().try_into()?,
        storage.clone(),
    )
    .run(None)
    .await?,
));

StateSnapshotRestoreController::new(
    opt,
    global.try_into()?,
    storage.init_storage().await?,
    epoch_history,  // REQUIRED
)
```

Additionally, add explicit checks in `StateSnapshotRestoreController::run_impl`:

```rust
// Require epoch_history for production use
ensure!(
    self.epoch_history.is_some(),
    "State snapshot restore requires epoch history verification for security. \
     Use --epoch-ending-manifest to provide epoch history."
);
```

## Proof of Concept

**Step 1: Create Malicious Backup**

```rust
// malicious_backup_creator.rs
use aptos_crypto::HashValue;
use aptos_types::{
    transaction::Version,
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    proof::TransactionInfoWithProof,
};

fn create_malicious_backup(output_dir: &Path) {
    // Create arbitrary fake state with modified balances/validator set
    let fake_state_root = HashValue::random();
    let version: Version = 1000;
    
    // Create fake LedgerInfo (no real validator signatures)
    let fake_ledger_info = LedgerInfo::new(
        /* ... fake block info with fake_state_root ... */
    );
    
    // Create fake signatures (or empty)
    let fake_li_with_sigs = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        BTreeMap::new(), // Empty signatures!
    );
    
    // Create self-consistent proof for the fake state
    let fake_txn_info_with_proof = /* ... create proof ... */;
    
    // Write manifest pointing to fake state
    let manifest = StateSnapshotBackup {
        version,
        epoch: 10,
        root_hash: fake_state_root,
        chunks: /* ... fake chunks with self-consistent proofs ... */,
        proof: /* ... file with fake_txn_info_with_proof & fake_li_with_sigs ... */,
    };
    
    // Save to storage
    fs::write(output_dir.join("state.manifest"), serde_json::to_vec(&manifest)?)?;
}
```

**Step 2: Victim Validator Restores**

```bash
# Victim validator attempts recovery
aptos-db-tool restore one-off state-snapshot \
    --state-manifest file:///attacker-controlled/state.manifest \
    --state-into-version 1000 \
    --local-fs-dir /attacker-controlled/backup \
    --db-dir /opt/aptos/data

# State restored WITHOUT signature verification!
# Validator now has corrupted state divergent from network
```

**Verification:**
After restoration, the victim validator's state root hash will differ from honest validators at the same version, causing consensus failures and inability to validate blocks.

## Notes

This vulnerability is particularly insidious because:
1. The restoration process appears to work correctly (no errors)
2. The Merkle tree proofs verify successfully (they're valid for the fake tree)
3. The divergence only becomes apparent when trying to participate in consensus
4. Recovery requires wiping the database and restoring from a legitimate source, causing significant downtime

The root cause is treating signature verification as optional rather than mandatory for all state restoration operations.

### Citations

**File:** storage/db-tool/src/restore.rs (L88-92)
```rust
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-230)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-139)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L341-343)
```rust
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
```
