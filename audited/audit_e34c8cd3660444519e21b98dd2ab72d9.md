# Audit Report

## Title
Coin Creator Address Not Standardized to 66-Character Format Causing Query Inconsistencies

## Summary
The `creator_address` field in the `coin_infos` table is not standardized to the 66-character format (0x + 64 hex) used throughout the indexer. Special addresses (0x0 to 0xf) are stored in short form (e.g., "0x1"), while the rest of the indexer standardizes all addresses to 66 characters, creating query inconsistencies.

## Finding Description
The indexer has a utility function `standardize_address()` that normalizes all addresses to 66 characters by padding with leading zeros. [1](#0-0) 

This standardization is applied consistently across the indexer for addresses in coin activities [2](#0-1) , coin balances [3](#0-2) , token collections [4](#0-3) , and other models.

However, in `coin_infos.rs`, the `creator_address` is extracted directly from the Move type without standardization. [5](#0-4) 

The address comes from `CoinInfoType::from_move_type()` which uses `inner.address.to_string()`. [6](#0-5) 

The `Address` type's `Display` implementation uses `to_hex_literal()` which produces short form addresses for special addresses (0x0 to 0xf). [7](#0-6) 

The `to_hex_literal()` method uses `short_str_lossless()` which strips leading zeros. [8](#0-7) 

This results in addresses like "0x1" (3 characters) being stored in the database for special addresses, while non-special addresses are stored in a longer form. The database schema defines the field as `VARCHAR(66)` which accepts variable-length strings up to 66 characters, so no constraint violation occurs. [9](#0-8) 

**Attack Scenario:**
When a client queries the GraphQL API or database for coins created by address "0x0000000000000000000000000000000000000000000000000000000000000001" (standardized long form), the query will fail to match records stored with "0x1" (short form), even though they represent the same address. This affects the composite index on creator_address. [10](#0-9) 

## Impact Explanation
This qualifies as **Low Severity** per Aptos bug bounty criteria for "Non-critical implementation bugs." The issue causes:
- Query inconsistencies when searching by creator_address
- Reduced effectiveness of database indexes
- Integration difficulties for external systems expecting standardized addresses
- No funds loss, consensus break, or availability impact (indexer is off-chain)

## Likelihood Explanation
**High likelihood of occurrence:**
- Every coin created by a special address (0x0-0xf) will have this inconsistency
- System addresses like 0x1 (aptos_framework) are commonly used for coin creation
- Any client using standardized address format in queries will experience failures
- The inconsistency is deterministic and affects all existing records

## Recommendation
Apply `standardize_address()` to the creator_address before storing it in the database:

**Fix in `crates/indexer/src/models/coin_models/coin_utils.rs`:**
```rust
use crate::util::standardize_address;

impl CoinInfoType {
    pub fn from_move_type(move_type: &MoveType, txn_version: i64) -> anyhow::Result<Self> {
        let coin_type = move_type.to_string();
        let (address, _, _) = if let MoveType::Struct(inner) = move_type {
            (
                standardize_address(&inner.address.to_string()),  // ADD standardize_address()
                inner.module.to_string(),
                inner.name.to_string(),
            )
        } else {
            Err(anyhow::anyhow!(
                "MoveType is not a struct: {:?}, version: {}",
                move_type,
                txn_version
            ))?
        };
        Ok(Self {
            coin_type,
            creator_address: address,
        })
    }
}
```

## Proof of Concept
```sql
-- Assume a coin was created by address 0x1 (aptos_framework)
-- The creator_address would be stored as "0x1"

-- This query will FAIL to find the record:
SELECT * FROM coin_infos 
WHERE creator_address = '0x0000000000000000000000000000000000000000000000000000000000000001';
-- Returns: 0 rows

-- But this query will SUCCEED:
SELECT * FROM coin_infos 
WHERE creator_address = '0x1';
-- Returns: matching rows

-- The composite index becomes inconsistent:
-- Index ci_ca_name_symbol_index contains "0x1" 
-- But queries use "0x000...001"
-- Leading to index misses and full table scans
```

**Notes:**
- This issue only affects the indexer, an off-chain query infrastructure component
- The blockchain consensus and execution remain unaffected  
- The fix requires a database migration to standardize existing creator_address values
- All other address fields in the indexer already use standardization consistently

### Citations

**File:** crates/indexer/src/util.rs (L14-17)
```rust
/// Standardizes all addresses and table handles to be length 66 (0x-64 length hash)
pub fn standardize_address(handle: &str) -> String {
    format!("0x{:0>64}", &handle[2..])
}
```

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L237-240)
```rust
            event_account_address: standardize_address(&event.guid.account_address.to_string()),
            event_creation_number: event.guid.creation_number.0 as i64,
            event_sequence_number: event.sequence_number.0 as i64,
            owner_address: standardize_address(&event.guid.account_address.to_string()),
```

**File:** crates/indexer/src/models/coin_models/coin_balances.rs (L59-59)
```rust
                let owner_address = standardize_address(&write_resource.address.to_string());
```

**File:** crates/indexer/src/models/token_models/collection_datas.rs (L121-121)
```rust
            creator_address = standardize_address(&creator_address);
```

**File:** crates/indexer/src/models/coin_models/coin_infos.rs (L70-70)
```rust
                    creator_address: coin_info_type.creator_address.clone(),
```

**File:** crates/indexer/src/models/coin_models/coin_utils.rs (L148-166)
```rust
    pub fn from_move_type(move_type: &MoveType, txn_version: i64) -> anyhow::Result<Self> {
        let coin_type = move_type.to_string();
        let (address, _, _) = if let MoveType::Struct(inner) = move_type {
            (
                inner.address.to_string(),
                inner.module.to_string(),
                inner.name.to_string(),
            )
        } else {
            Err(anyhow::anyhow!(
                "MoveType is not a struct: {:?}, version: {}",
                move_type,
                txn_version
            ))?
        };
        Ok(Self {
            coin_type,
            creator_address: address,
        })
```

**File:** api/types/src/address.rs (L40-48)
```rust
impl fmt::Display for Address {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // While the inner type, AccountAddress, has a Display impl already, we don't
        // use it. As part of the AIP-40 migration, the Display impl of the inner
        // AccountAddress was changed to conform to AIP-40, but doing that for the API
        // would constitute a breaking change. So we keep an explicit display impl
        // here that maintains the existing address formatting behavior.
        write!(f, "{}", self.0.to_hex_literal())
    }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L182-184)
```rust
    pub fn to_hex_literal(&self) -> String {
        format!("0x{}", self.short_str_lossless())
    }
```

**File:** crates/indexer/migrations/2022-10-04-073529_add_coin_tables/up.sql (L43-43)
```sql
  creator_address VARCHAR(66) NOT NULL,
```

**File:** crates/indexer/migrations/2022-10-04-073529_add_coin_tables/up.sql (L51-51)
```sql
CREATE INDEX ci_ca_name_symbol_index on coin_infos (creator_address, name, symbol);
```
