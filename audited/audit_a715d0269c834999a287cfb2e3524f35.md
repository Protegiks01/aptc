# Audit Report

## Title
Transaction Filter Public Key Bypass Enables Signature Forgery DoS Attack

## Summary
The transaction filter's public key matching occurs before signature verification, allowing attackers to craft transactions with whitelisted public keys but invalid signatures. These malicious transactions bypass filter rules and force validators to perform expensive cryptographic signature verification before rejection, enabling resource exhaustion attacks against nodes with public key-based filters enabled.

## Finding Description

The transaction filter system implements security policy enforcement at multiple stages (mempool, consensus, execution). When configured with `PublicKey` matchers, the filter is intended to allow/deny transactions based on the public keys in their authenticators. [1](#0-0) 

The critical flaw is that `matches_transaction_authenticator_public_key()` only extracts and compares public keys from the transaction authenticator without verifying that the signatures are valid for those keys. [2](#0-1) 

In the transaction processing pipeline, the filter is applied first in the mempool: [3](#0-2) 

Signature verification occurs much later during validation: [4](#0-3) 

**Attack Scenario:**

1. Validator operator configures mempool filter with `Allow` rule for specific public keys (e.g., whitelisted accounts only)
2. Attacker identifies the whitelisted public keys from on-chain data or configuration
3. Attacker crafts millions of transactions containing whitelisted public keys in their authenticators
4. Attacker uses invalid signatures (random bytes or signatures from different keys)
5. Transactions pass the filter check at line 437 because public keys match the allowlist
6. Each transaction proceeds to validation where expensive signature verification occurs
7. All signatures fail verification, but CPU resources have been consumed
8. Validator node experiences slowdown due to excessive signature verification overhead

The signature verification process performs cryptographic operations for each authenticator type (Ed25519, MultiEd25519, SingleKey, MultiKey, etc.), which are computationally expensive: [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria: "Validator node slowdowns."

**Quantified Impact:**
- Validators with public key filters enabled can be forced to perform signature verification on arbitrary numbers of invalid transactions
- Signature verification is cryptographically expensive (Ed25519: ~100k ops/sec per core, multi-sig even slower)
- An attacker submitting thousands of transactions per second can exhaust validator CPU resources
- This causes legitimate transaction processing delays and potential consensus participation issues
- The filter's intended purpose—early rejection to save resources—is completely bypassed

**Scope:**
- Affects all validators and nodes with transaction filters configured to use `PublicKey` matchers
- While filters are optional (disabled by default), they are explicitly documented as "security policy enforcement" mechanisms, implying operators should be able to rely on them [6](#0-5) 

## Likelihood Explanation

**Likelihood: Medium to High**

**Requirements for exploitation:**
- Target validator must have transaction filter enabled with `PublicKey` matcher rules
- Attacker must identify which public keys are whitelisted (typically discoverable from configuration or on-chain data)
- Attacker needs ability to submit transactions to the network (no special privileges required)

**Ease of execution:**
- Simple to craft transactions with arbitrary public keys and invalid signatures
- No cryptographic complexity required—attacker just copies whitelisted public keys
- Can be automated to generate high transaction volumes
- No special network access or validator privileges needed

**Detection difficulty:**
- Attack traffic looks similar to normal transaction submission
- Rejected transactions appear in standard validation failure logs
- Filter bypass is silent—no indication that security policy is being circumvented

## Recommendation

**Immediate Fix: Verify signatures before public key matching**

The transaction filter should verify signatures before checking public key filters. Modify the validation flow to ensure cryptographic correctness before policy enforcement:

```rust
// In mempool/src/shared_mempool/tasks.rs
// Move signature verification before filter application:

pub(crate) fn process_incoming_transactions<NetworkClient, TransactionValidator>(
    smp: &SharedMempool<NetworkClient, TransactionValidator>,
    transactions: Vec<(SignedTransaction, Option<u64>, Option<BroadcastPeerPriority>)>,
    timeline_state: TimelineState,
    client_submitted: bool,
) -> Vec<SubmissionStatusBundle> {
    let mut statuses = vec![];
    
    // NEW: Verify signatures BEFORE filtering
    let transactions: Vec<_> = transactions
        .into_iter()
        .filter_map(|(txn, seq, priority)| {
            match txn.verify_signature() {
                Ok(_) => Some((txn, seq, priority)),
                Err(_) => {
                    statuses.push((txn, (
                        MempoolStatus::new(MempoolStatusCode::VmError),
                        Some(StatusCode::INVALID_SIGNATURE),
                    )));
                    None
                }
            }
        })
        .collect();
    
    // THEN apply filter to signature-verified transactions
    let transactions = filter_transactions(&smp.transaction_filter_config, transactions, &mut statuses);
    
    // Continue with rest of processing...
}
```

**Alternative Fix: Document limitation and add signature verification option**

If moving signature verification is too expensive for the common case, add an explicit configuration option:

```rust
pub struct TransactionFilterConfig {
    filter_enabled: bool,
    verify_signatures_before_filter: bool,  // NEW OPTION
    transaction_filter: TransactionFilter,
}
```

When `verify_signatures_before_filter` is enabled, perform signature checks before filter evaluation for public key matchers.

**Long-term Recommendation:**

Redesign the filter to separate unauthenticated attributes (sender address, transaction ID) from authenticated attributes (public keys). Only check authenticated attributes after signature verification, or clearly document that public key filters operate on unverified data and should not be relied upon for security-critical policies.

## Proof of Concept

```rust
#[tokio::test]
async fn test_public_key_filter_signature_forgery_bypass() {
    use aptos_crypto::ed25519::{Ed25519PrivateKey, Ed25519PublicKey};
    use aptos_crypto::{PrivateKey, Uniform};
    use aptos_types::transaction::{
        authenticator::{AccountAuthenticator, TransactionAuthenticator, AnyPublicKey},
        RawTransaction, SignedTransaction, Script,
    };
    use aptos_transaction_filters::{
        transaction_filter::{TransactionFilter, TransactionMatcher},
    };
    
    // Setup: Create a whitelisted key and a victim key
    let whitelisted_key = Ed25519PrivateKey::generate_for_testing();
    let whitelisted_pubkey = whitelisted_key.public_key();
    let attacker_key = Ed25519PrivateKey::generate_for_testing();
    
    // Create filter that ONLY allows the whitelisted public key
    let filter = TransactionFilter::empty()
        .add_public_key_filter(true, AnyPublicKey::ed25519(whitelisted_pubkey.clone()));
    
    // Create a transaction from attacker's address
    let raw_txn = RawTransaction::new(
        AccountAddress::random(),
        0,
        TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
        100000,
        0,
        u64::MAX,
        ChainId::test(),
    );
    
    // ATTACK: Sign with attacker's key, but claim it's from whitelisted key
    let attacker_signature = attacker_key.sign(&raw_txn).unwrap();
    
    // Forge authenticator with whitelisted public key but attacker's signature
    let forged_authenticator = TransactionAuthenticator::Ed25519 {
        public_key: whitelisted_pubkey.clone(),  // WHITELISTED KEY
        signature: attacker_signature,            // INVALID SIGNATURE FOR THIS KEY
    };
    
    let forged_txn = SignedTransaction::new_with_authenticator(
        raw_txn,
        forged_authenticator,
    );
    
    // BUG: Filter allows the transaction because it only checks public key
    assert!(filter.allows_transaction(&forged_txn), 
        "Filter should be bypassed with forged public key");
    
    // Signature verification correctly rejects it (but resources already wasted)
    assert!(forged_txn.verify_signature().is_err(),
        "Signature verification should fail");
    
    // IMPACT: Attacker can flood mempool with transactions that:
    // 1. Pass the filter (bypass security policy)
    // 2. Force expensive signature verification
    // 3. Get rejected after wasting CPU resources
    
    println!("SUCCESS: Public key filter bypassed with signature forgery!");
    println!("This transaction would pass mempool filter but fail validation,");
    println!("wasting validator CPU on signature verification.");
}
```

This proof of concept demonstrates that an attacker can craft transactions with whitelisted public keys but invalid signatures that bypass the transaction filter, forcing validators to perform expensive signature verification operations before rejection.

## Notes

The vulnerability exists because the transaction filter is applied as an optimization/policy layer before full transaction validation. The design assumes that checking transaction metadata (public keys, addresses, etc.) is cheaper than signature verification. However, this creates a security gap where public key-based filtering can be bypassed through signature forgery.

The fix requires either:
1. Performing signature verification before public key filtering (more secure but potentially slower)
2. Clearly documenting that public key filters operate on unverified data (current behavior is implicit)
3. Adding a configuration option to enable signature verification before filtering for security-critical deployments

The vulnerability primarily affects deployments using public key allowlists as a security mechanism, where operators expect only transactions from specific keys to consume validation resources.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L204-206)
```rust
            TransactionMatcher::PublicKey(public_key) => {
                matches_transaction_authenticator_public_key(signed_transaction, public_key)
            },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L534-574)
```rust
fn matches_transaction_authenticator_public_key(
    signed_transaction: &SignedTransaction,
    any_public_key: &AnyPublicKey,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.authenticator_ref() {
        TransactionAuthenticator::Ed25519 { public_key, .. } => {
            compare_ed25519_public_key(public_key, any_public_key)
        },
        TransactionAuthenticator::MultiEd25519 { public_key, .. } => {
            public_key.public_keys().iter().any(|ed25519_public_key| {
                compare_ed25519_public_key(ed25519_public_key, any_public_key)
            })
        },
        TransactionAuthenticator::MultiAgent {
            sender,
            secondary_signers,
            ..
        } => {
            matches_account_authenticator_public_key(sender, any_public_key)
                || secondary_signers
                    .iter()
                    .any(|signer| matches_account_authenticator_public_key(signer, any_public_key))
        },
        TransactionAuthenticator::FeePayer {
            sender,
            secondary_signers,
            fee_payer_signer,
            ..
        } => {
            matches_account_authenticator_public_key(sender, any_public_key)
                || secondary_signers
                    .iter()
                    .any(|signer| matches_account_authenticator_public_key(signer, any_public_key))
                || matches_account_authenticator_public_key(fee_payer_signer, any_public_key)
        },
        TransactionAuthenticator::SingleSender { sender } => {
            matches_account_authenticator_public_key(sender, any_public_key)
        },
    }
}
```

**File:** mempool/src/shared_mempool/tasks.rs (L320-321)
```rust
    let transactions =
        filter_transactions(&smp.transaction_filter_config, transactions, &mut statuses);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3232-3237)
```rust
        let txn = match transaction.check_signature() {
            Ok(t) => t,
            _ => {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            },
        };
```

**File:** types/src/transaction/authenticator.rs (L160-242)
```rust
    pub fn verify(&self, raw_txn: &RawTransaction) -> Result<()> {
        let num_sigs: usize = self.sender().number_of_signatures()
            + self
                .secondary_signers()
                .iter()
                .map(|auth| auth.number_of_signatures())
                .sum::<usize>();
        if num_sigs > MAX_NUM_OF_SIGS {
            return Err(Error::new(AuthenticationError::MaxSignaturesExceeded));
        }
        match self {
            Self::Ed25519 {
                public_key,
                signature,
            } => signature.verify(raw_txn, public_key),
            Self::FeePayer {
                sender,
                secondary_signer_addresses,
                secondary_signers,
                fee_payer_address,
                fee_payer_signer,
            } => {
                // In the fee payer model, the fee payer address can be optionally signed. We
                // realized when we designed the fee payer model, that we made it too restrictive
                // by requiring the signature over the fee payer address. So now we need to live in
                // a world where we support a multitude of different solutions. The modern approach
                // assumes that some may sign over the address and others will sign over the zero
                // address, so we verify both and only fail if the signature fails for either of
                // them. The legacy approach is to assume the address of the fee payer is signed
                // over.
                let mut to_verify = vec![sender];
                let _ = secondary_signers
                    .iter()
                    .map(|signer| to_verify.push(signer))
                    .collect::<Vec<_>>();

                let no_fee_payer_address_message = RawTransactionWithData::new_fee_payer(
                    raw_txn.clone(),
                    secondary_signer_addresses.clone(),
                    AccountAddress::ZERO,
                );

                let mut remaining = to_verify
                    .iter()
                    .filter(|verifier| verifier.verify(&no_fee_payer_address_message).is_err())
                    .collect::<Vec<_>>();

                remaining.push(&fee_payer_signer);

                let fee_payer_address_message = RawTransactionWithData::new_fee_payer(
                    raw_txn.clone(),
                    secondary_signer_addresses.clone(),
                    *fee_payer_address,
                );

                for verifier in remaining {
                    verifier.verify(&fee_payer_address_message)?;
                }

                Ok(())
            },
            Self::MultiEd25519 {
                public_key,
                signature,
            } => signature.verify(raw_txn, public_key),
            Self::MultiAgent {
                sender,
                secondary_signer_addresses,
                secondary_signers,
            } => {
                let message = RawTransactionWithData::new_multi_agent(
                    raw_txn.clone(),
                    secondary_signer_addresses.clone(),
                );
                sender.verify(&message)?;
                for signer in secondary_signers {
                    signer.verify(&message)?;
                }
                Ok(())
            },
            Self::SingleSender { sender } => sender.verify(raw_txn),
        }
    }
```

**File:** config/src/config/transaction_filters_config.rs (L13-17)
```rust
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
```
