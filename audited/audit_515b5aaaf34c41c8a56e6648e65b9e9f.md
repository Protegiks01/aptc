# Audit Report

## Title
Orderless Transaction Metadata Corruption in Large Package Staging Area

## Summary
The `large_packages` module allows package chunks to be staged across multiple transactions, but when orderless (nonce-based) transactions are used, the mempool's reverse-nonce prioritization can cause chunks to execute in the wrong order, resulting in corrupted package metadata in the staging area.

## Finding Description

The large package deployment mechanism in Aptos allows splitting large packages across multiple transactions by staging chunks in a `StagingArea` resource. The staging process appends metadata chunks to a vector and indexes code chunks in a SmartTable. [1](#0-0) [2](#0-1) 

When users create orderless transactions (using nonces instead of sequence numbers) to stage chunks, the mempool's `PriorityIndex` ordering logic prioritizes transactions with **higher nonces first** when other factors (gas price, insertion time) are equal: [3](#0-2) 

The critical line is the reverse ordering of `replay_protector` at line 209, which prefers higher nonce values. Combined with the `ReplayProtector` enum's natural ordering where `Nonce(a) < Nonce(b)` when `a < b`: [4](#0-3) 

This creates a scenario where if a user submits:
- Tx1 (nonce=100): metadata chunk "ABC", code chunks [0, 1]  
- Tx2 (nonce=200): metadata chunk "DEF", code chunks [2, 3]

And both transactions have similar gas prices and arrive at the mempool in quick succession, Tx2 will be pulled from mempool **before** Tx1 due to its higher nonce, resulting in execution order: Tx2 â†’ Tx1.

This produces:
- Corrupted metadata: "DEFABC" instead of "ABCDEF"
- Correctly indexed code (due to SmartTable indexing)

When the package is published, the corrupted metadata bytes will fail deserialization or produce incorrect package configuration: [5](#0-4) 

**Critical Gap**: The module provides no documentation about transaction ordering requirements and does not prevent orderless transactions: [6](#0-5) 

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: The staging area becomes corrupted with metadata in wrong order, requiring manual cleanup
- **Limited manipulation**: While primarily affecting the user's own deployment, corrupted metadata could potentially bypass validation checks if deserialization produces unexpected but valid-looking data

The impact is limited because:
- Only affects users who choose orderless transactions for chunked publishing
- Deterministic execution ensures all validators see the same corrupted result (no consensus split)
- User can recover by calling `cleanup_staging_area` and resubmitting with sequence-numbered transactions

However, this represents a clear violation of data integrity expectations for package deployment.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability occurs when:
1. User employs orderless transactions for chunked publishing (not prevented or documented against)
2. Multiple chunk transactions are submitted with similar gas prices
3. Transactions arrive at mempool in quick succession (parallel submission)
4. Block proposer pulls transactions before insertion time differences dominate ordering

The chunked publishing utilities in `chunked_publish.rs` create generic payloads that work with both transaction types: [7](#0-6) 

With no warnings against orderless usage, developers implementing chunked publishing clients might reasonably choose orderless transactions for their parallel submission benefits, unknowingly triggering this issue.

## Recommendation

**1. Add explicit validation in `stage_code_chunk_internal`:**

```move
inline fun stage_code_chunk_internal(
    owner: &signer,
    metadata_chunk: vector<u8>,
    code_indices: vector<u16>,
    code_chunks: vector<vector<u8>>
): &mut StagingArea {
    assert!(
        vector::length(&code_indices) == vector::length(&code_chunks),
        error::invalid_argument(ECODE_MISMATCH)
    );
    
    // NEW: Prevent orderless transactions
    assert!(
        !features::is_orderless_transaction(),
        error::invalid_state(EORDERLESS_NOT_SUPPORTED)
    );
    
    // ... rest of implementation
}
```

**2. Update module documentation:**

Add clear warnings in the module comments:
```move
/// # Important Notes
///
/// * **Chunked publishing requires sequence-numbered transactions**: All staging transactions
///   must use sequential sequence numbers, NOT orderless (nonce-based) transactions. 
///   Orderless transactions may execute in wrong order, corrupting package metadata.
```

**3. Update chunked_publish.rs documentation:**

Add comments warning about transaction type requirements when using the generated payloads.

## Proof of Concept

```move
#[test(account = @0x1)]
fun test_orderless_chunk_corruption(account: &signer) {
    // Setup: Enable orderless transactions feature
    features::change_feature_flags_for_testing(
        account,
        vector[features::get_orderless_transactions_feature()],
        vector[]
    );
    
    // Simulate two orderless transactions with reversed nonces
    // In real execution, higher nonce (200) executes before lower nonce (100)
    
    // Transaction 2 (nonce 200) - should be second but executes first
    large_packages::stage_code_chunk(
        account,
        b"DEF",  // metadata chunk 2
        vector[2u16, 3u16],  // code indices
        vector[b"code2", b"code3"]  // code chunks
    );
    
    // Transaction 1 (nonce 100) - should be first but executes second  
    large_packages::stage_code_chunk(
        account,
        b"ABC",  // metadata chunk 1
        vector[0u16, 1u16],  // code indices
        vector[b"code0", b"code1"]  // code chunks
    );
    
    // Verify corruption: metadata is "DEFABC" instead of "ABCDEF"
    let staging_area = borrow_global<StagingArea>(signer::address_of(account));
    assert!(staging_area.metadata_serialized == b"DEFABC", 0);
    // Code chunks are correctly indexed (not shown for brevity)
}
```

**Notes:**
- This vulnerability does not break consensus (all validators execute identically)
- Impact is limited to package deployment integrity, not broader system security
- Prevention requires either explicit checks or clear documentation of requirements
- The reverse-nonce ordering in mempool is intentional for fairness but creates this edge case

### Citations

**File:** aptos-move/framework/aptos-experimental/sources/large_packages.move (L19-34)
```text
/// # Usage
///
/// 1. **Stage Code Chunks**:
///     - Call `stage_code_chunk` with the appropriate metadata and code chunks.
///     - Ensure that `code_indices` are provided from `0` to `last_module_idx`, without any
///       gaps.
///
///
/// 2. **Publish or Upgrade**:
///     - In order to upload the last data chunk and publish the package, call `stage_code_chunk_and_publish_to_account` or `stage_code_chunk_and_publish_to_object`.
///
///     - For object code upgrades, call `stage_code_chunk_and_upgrade_object_code` with the argument `code_object` provided.
///
/// 3. **Cleanup**:
///     - In order to remove `StagingArea` resource from an account, call `cleanup_staging_area`.
///
```

**File:** aptos-move/framework/aptos-experimental/sources/large_packages.move (L60-64)
```text
    struct StagingArea has key {
        metadata_serialized: vector<u8>,
        code: SmartTable<u64, vector<u8>>,
        last_module_idx: u64
    }
```

**File:** aptos-move/framework/aptos-experimental/sources/large_packages.move (L156-180)
```text
        let staging_area = borrow_global_mut<StagingArea>(owner_address);

        if (!vector::is_empty(&metadata_chunk)) {
            vector::append(&mut staging_area.metadata_serialized, metadata_chunk);
        };

        let i = 0;
        while (i < vector::length(&code_chunks)) {
            let inner_code = *vector::borrow(&code_chunks, i);
            let idx = (*vector::borrow(&code_indices, i) as u64);

            if (smart_table::contains(&staging_area.code, idx)) {
                vector::append(
                    smart_table::borrow_mut(&mut staging_area.code, idx), inner_code
                );
            } else {
                smart_table::add(&mut staging_area.code, idx, inner_code);
                if (idx > staging_area.last_module_idx) {
                    staging_area.last_module_idx = idx;
                }
            };
            i = i + 1;
        };

        staging_area
```

**File:** aptos-move/framework/aptos-experimental/sources/large_packages.move (L183-188)
```text
    inline fun publish_to_account(
        publisher: &signer, staging_area: &mut StagingArea
    ) {
        let code = assemble_module_code(staging_area);
        code::publish_package_txn(publisher, staging_area.metadata_serialized, code);
    }
```

**File:** mempool/src/core_mempool/index.rs (L192-214)
```rust
impl Ord for OrderedQueueKey {
    fn cmp(&self, other: &OrderedQueueKey) -> Ordering {
        // Higher gas preferred
        match self.gas_ranking_score.cmp(&other.gas_ranking_score) {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        // Lower insertion time preferred
        match self.insertion_time.cmp(&other.insertion_time).reverse() {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        // Higher address preferred
        match self.address.cmp(&other.address) {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        match self.replay_protector.cmp(&other.replay_protector).reverse() {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        self.hash.cmp(&other.hash)
    }
```

**File:** types/src/transaction/mod.rs (L112-116)
```rust
#[derive(Debug, Copy, Clone, Eq, PartialEq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub enum ReplayProtector {
    Nonce(u64),
    SequenceNumber(u64),
}
```

**File:** aptos-move/framework/src/chunked_publish.rs (L119-139)
```rust
// Create a transaction payload for staging chunked data to the staging area.
fn large_packages_stage_code_chunk(
    metadata_chunk: Vec<u8>,
    code_indices: Vec<u16>,
    code_chunks: Vec<Vec<u8>>,
    large_packages_module_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            large_packages_module_address,
            ident_str!("large_packages").to_owned(),
        ),
        ident_str!("stage_code_chunk").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&metadata_chunk).unwrap(),
            bcs::to_bytes(&code_indices).unwrap(),
            bcs::to_bytes(&code_chunks).unwrap(),
        ],
    ))
}
```
