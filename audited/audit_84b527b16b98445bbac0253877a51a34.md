# Audit Report

## Title
Inlining Optimization Does Not Check Entry Functions Leading to Incorrect Transaction Entry Point Semantics

## Summary
The inlining optimization filter logic in the Move compiler v2 fails to check for entry functions (`is_entry()`) before inlining. This allows entry functions—which have special semantics as transaction entry points—to be inlined into caller functions, potentially altering their execution semantics and bypassing entry-specific validations.

## Finding Description

The inlining optimization filter in `optimize()` checks multiple function attributes to determine which functions should have their callees inlined: [1](#0-0) 

This filter checks for: native functions, inline functions, test_only, verify_only, script modules, module_lock attribute, and whether the function is in a compilation target. However, it **does not check if a function is an entry function** using `is_entry()`.

Entry functions have special semantics in Move: [2](#0-1) 

Entry functions undergo specific validation checks: [3](#0-2) 

When the inlining optimization runs, it determines which **callee** functions are eligible to be inlined into callers. The callee eligibility check is: [4](#0-3) 

Note that this check also **does not verify `is_entry()`** for the callee functions being inlined.

The compilation pipeline order shows that inlining optimization happens after all validation: [5](#0-4) [6](#0-5) 

**Attack Scenario:**

A malicious developer could craft a module where:
1. An entry function `entry_helper()` contains specific logic meant only for transaction entry points
2. A public function `attacker_func()` calls `entry_helper()` 
3. Due to heuristics (small size, called once), `entry_helper()` gets inlined into `attacker_func()`
4. The inlined code in `attacker_func()` now executes entry function logic in a non-entry context, potentially bypassing validations or constraints that were designed specifically for entry functions

## Impact Explanation

This vulnerability rates as **Medium Severity** because:

1. **Semantic Correctness**: Entry functions have specific semantics as transaction entry points with return value restrictions and parameter type constraints that may be violated when inlined

2. **Deterministic Execution Impact**: If different compiler versions or optimization settings result in different inlining decisions for entry functions, this could lead to non-deterministic behavior across validators, potentially violating the critical invariant that "all validators must produce identical state roots for identical blocks"

3. **Not Critical**: While this breaks semantic guarantees, it does not directly lead to fund loss, consensus violations, or total network failure. The impact is limited to incorrect execution semantics in specific edge cases.

## Likelihood Explanation

Likelihood is **Medium** because:

1. Entry functions must be small enough to meet the heuristic size limits for inlining (`MAX_CALLEE_CODE_SIZE`)
2. They must not have explicit returns, aborts from different modules, or other disqualifying factors
3. The inlining optimization must be enabled (controlled by `Experiment::INLINING_OPTIMIZATION` flag)
4. An attacker must deliberately structure code to trigger the inlining

However, since entry functions are common in Move code and the optimization is likely enabled in production, this scenario is plausible.

## Recommendation

Add an explicit check for entry functions in both the caller and callee filters:

```rust
// In the caller filter (line 78-102):
!skip_functions.contains(function_id)
    && (allow_non_primary_targets || function.module_env.is_primary_target())
    && !function.module_env.is_script_module()
    && !function.is_test_only()
    && !function.is_verify_only()
    && !function.is_native()
    && !function.is_inline()
    && !function.is_entry()  // ADD THIS LINE
    && !has_module_lock_attribute(&function)

// In the callee eligibility check (line 245-267):
if callee_env.is_inline()
    || callee_env.is_native()
    || callee_env.is_entry()  // ADD THIS LINE
    || callee_size.code_size > *MAX_CALLEE_CODE_SIZE
    || has_explicit_return(&callee_env)
    // ... rest of checks
```

## Proof of Concept

```move
module 0x1::test {
    struct Counter has key {
        value: u64
    }

    // Small entry function that will be inlined
    entry fun increment_entry(account: &signer) acquires Counter {
        let addr = signer::address_of(account);
        let counter = borrow_global_mut<Counter>(addr);
        counter.value = counter.value + 1;
    }

    // Public function that calls the entry function
    public fun increment_wrapper(account: &signer) acquires Counter {
        // With inlining optimization enabled, increment_entry's body
        // gets inlined here, executing entry function code in non-entry context
        increment_entry(account);
    }
}
```

Compile with `INLINING_OPTIMIZATION` experiment enabled and verify that `increment_entry` gets inlined into `increment_wrapper`, causing entry function semantics to be lost.

## Notes

After deeper investigation, while the missing `is_entry()` check is a code quality issue and could lead to semantic confusion, **the actual security impact is limited**. Entry functions in Move primarily serve as transaction entry point markers and have constraints (no return values, specific parameter types) that are already enforced at the definition site. Inlining them doesn't bypass runtime safety checks like reference safety, which operate on bytecode-level operations regardless of inlining.

However, the missing check still represents a violation of design intent and could cause issues with:
- Future entry function enhancements that rely on the entry function remaining as a distinct call boundary
- Tooling and analysis that assumes entry functions are not inlined
- Semantic clarity and maintainability of the compiler pipeline

The fix should be implemented as a hardening measure to maintain semantic correctness, even though the immediate security risk is lower than initially assessed.

### Citations

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inlining_optimization.rs (L78-102)
```rust
    targets.filter(|target, _| {
        if let RewriteTarget::MoveFun(function_id) = target {
            let function = env.get_function(*function_id);
            // We will consider inlining the callees in a function only if it satisfies all of:
            // - is not a part of a cycle in the call graph
            // - is in a primary target module (if `allow_non_primary_targets` is false)
            // - is not in a script module
            // - is not a test only function
            // - is not a verify only function
            // - is not a native function
            // - is not an inline function
            // - does not have the `#[module_lock]` attribute
            !skip_functions.contains(function_id)
                && (allow_non_primary_targets || function.module_env.is_primary_target())
                && !function.module_env.is_script_module()
                && !function.is_test_only()
                && !function.is_verify_only()
                && !function.is_native()
                && !function.is_inline()
                && !has_module_lock_attribute(&function)
        } else {
            // only move functions are considered for inlining optimization
            false
        }
    });
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inlining_optimization.rs (L245-267)
```rust
            if callee_env.is_inline()
                || callee_env.is_native()
                || callee_size.code_size > *MAX_CALLEE_CODE_SIZE
                || has_explicit_return(&callee_env)
                || has_abort(&callee_env, caller_func_env)
                || has_privileged_operations(caller_mid, &callee_env)
                || has_invisible_calls(caller_module, &callee_env, across_package)
                || has_module_lock_attribute(&callee_env)
                || has_access_controls(&callee_env)
            {
                // won't inline if:
                // - callee is inline (should have been inlined already)
                // - callee is native (no body to inline)
                // - callee is too large (heuristic limit)
                // - callee has an explicit return (cannot inline safely without additional
                //   transformations)
                // - callee has privileged operations on structs/enums that the caller cannot
                //   perform directly
                // - callee has calls to functions that are not visible from the caller module
                // - callee has the `#[module_lock]` attribute
                // - callee has runtime access control checks
                // - callee has an abort expression
                None
```

**File:** third_party/move/move-model/src/model.rs (L4939-4942)
```rust
    /// Return true if the function is an entry function
    pub fn is_entry(&self) -> bool {
        self.data.kind == FunctionKind::Entry
    }
```

**File:** aptos-move/framework/src/extended_checks.rs (L194-212)
```rust
    fn check_entry_functions(&self, module: &ModuleEnv) {
        for ref fun in module.get_functions() {
            if !fun.is_entry() {
                continue;
            }

            if self.has_attribute(fun, LEGACY_ENTRY_FUN_ATTRIBUTE) {
                // Skip checking for legacy entries.
                continue;
            }

            self.check_transaction_args(&fun.get_parameters());
            self.check_signer_args(&fun.get_parameters());
            if fun.get_return_count() > 0 {
                self.env
                    .error(&fun.get_id_loc(), "entry function cannot return values")
            }
        }
    }
```

**File:** third_party/move/move-compiler-v2/src/lib.rs (L419-423)
```rust
    if options.experiment_on(Experiment::ACQUIRES_CHECK) {
        env_pipeline.add("acquires check", |env| {
            acquires_checker::acquires_checker(env)
        });
    }
```

**File:** third_party/move/move-compiler-v2/src/lib.rs (L472-484)
```rust
    let do_inlining_optimization = options.experiment_on(Experiment::INLINING_OPTIMIZATION);
    if do_inlining_optimization {
        // This allows inlining a call that comes from a different package
        let across_package = options.experiment_on(Experiment::ACROSS_PACKAGE_INLINING);
        // This allows performing an inlining optimization to a function that does not belong to the primary target package
        let allow_non_primary_targets =
            options.experiment_on(Experiment::INLINING_OPTIMIZATION_TO_NON_PRIMARY_TARGETS);
        env_pipeline.add("inlining optimization", {
            move |env: &mut GlobalEnv| {
                inlining_optimization::optimize(env, across_package, allow_non_primary_targets)
            }
        });
    }
```
