# Audit Report

## Title
Resource Exhaustion via Unbounded Validator Transaction Deserialization Before Size Validation

## Summary
A resource exhaustion vulnerability exists in the validator transaction processing pipeline where malicious validators can submit proposals containing excessively large DKGResult or ObservedJWKUpdate transactions (up to 64MB) that must be fully deserialized before the consensus layer validates their size against configured limits (default 6MB). This 10x gap between network-layer deserialization capacity and consensus-layer validation limits enables memory exhaustion attacks on validator nodes.

## Finding Description

The vulnerability exists in the transaction processing flow spanning from network message reception to consensus validation. The core issue is a **pre-validation deserialization gap**.

**Attack Flow:**

1. **Network Reception**: When a `ProposalMsg` or `OptProposalMsg` is received, it contains a `Vec<ValidatorTransaction>` embedded in the block's `ProposalExt` or `OptBlockBody` variant. [1](#0-0) 

2. **Unbounded Type Definitions**: The `ValidatorTransaction` enum contains variants with unbounded vector fields:
   - `DKGResult(DKGTranscript)` where `DKGTranscript` has `transcript_bytes: Vec<u8>`
   - `ObservedJWKUpdate(QuorumCertifiedUpdate)` where `QuorumCertifiedUpdate.update.jwks: Vec<JWKMoveStruct>` [2](#0-1) [3](#0-2) [4](#0-3) 

3. **Network-Layer Deserialization**: The entire message is deserialized via `bcs::from_bytes()` at the network layer **before** any size validation. The network permits messages up to `MAX_MESSAGE_SIZE = 64 * 1024 * 1024` (64MB). [5](#0-4) [6](#0-5) 

4. **Delayed Validation**: Size validation only occurs **after** complete deserialization in `RoundManager::process_proposal()`, where validator transactions are checked against `max_receiving_block_bytes` (default 6MB). [7](#0-6) [8](#0-7) 

5. **No Pre-Deserialization Guards**: The `ProposalMsg::verify()` and `Block::verify_well_formed()` methods perform signature and structural validation but **do not** check validator transaction sizes before deserialization completes. [9](#0-8) 

**Exploitation Scenario:**

A malicious validator crafts a `ProposalExt` with multiple `DKGTranscript` transactions, each containing `transcript_bytes` filled with 10MB of dummy data. Sending 6 such transactions in a single proposal (60MB total) forces every receiving validator to:
- Deserialize all 60MB into memory structures
- Only then reject the proposal for exceeding the 6MB limit
- Suffer temporary memory spike of 60MB per malicious proposal

Multiple coordinated malicious validators can amplify this by sending such proposals simultaneously to all honest validators.

**Broken Invariant:** This violates the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits." The system permits unbounded memory allocation during deserialization before enforcing configured resource limits.

## Impact Explanation

**Severity: High** per Aptos Bug Bounty criteria for "Validator node slowdowns."

**Impact Details:**
- **Memory Exhaustion**: Each malicious proposal can force ~60MB memory allocation before rejection
- **Amplification**: Multiple malicious validators can coordinate simultaneous attacks
- **Node Degradation**: Repeated attacks can cause memory pressure, garbage collection pauses, and performance degradation
- **Consensus Disruption**: If validators crash or slow significantly, consensus liveness could be impacted

While not causing permanent network failure (Critical), this enables **significant validator node slowdowns** qualifying as High severity. The attack requires validator privileges (validators can propose blocks), but any single malicious validator in the active set can execute it.

## Likelihood Explanation

**Likelihood: Medium-to-High**

**Attack Requirements:**
- Attacker must control at least one validator in the active set
- No additional privileges or exploits needed beyond normal validator operations
- Attack is trivial to execute (craft oversized validator transactions)

**Mitigating Factors:**
- Requires malicious validator (not completely permissionless)
- Network message size caps maximum impact at 64MB per proposal
- Honest validators can identify and potentially slash malicious proposers

**Overall:** Given that gaining validator status requires stake but the attack is otherwise straightforward, and the gap between network limits (64MB) and validation limits (6MB) is significant, this vulnerability has medium-to-high likelihood of being exploited if a malicious actor gains validator status.

## Recommendation

Implement **pre-deserialization size checks** at the network layer before allocating memory for validator transactions.

**Recommended Fix:**

1. Add a size limit check in the network message codec or immediately after frame reading, before BCS deserialization
2. Enforce `max_receiving_block_bytes` limit earlier in the pipeline
3. Add explicit size limits to `DKGTranscript::transcript_bytes` and `QuorumCertifiedUpdate` structures

**Code Fix Example** (pseudo-code for network layer):

```rust
// In network/framework/src/protocols/wire/messaging/v1/mod.rs
// After receiving frame but before deserialization:

const MAX_VALIDATOR_TXN_BYTES: usize = 6 * 1024 * 1024; // Match consensus limit

fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
    match self.project().framed_read.poll_next(cx) {
        Poll::Ready(Some(Ok(frame))) => {
            let frame = frame.freeze();
            
            // Pre-check frame size against validator transaction limits
            if frame.len() > MAX_VALIDATOR_TXN_BYTES {
                return Poll::Ready(Some(Err(ReadError::FrameTooLarge(frame.len()))));
            }
            
            match bcs::from_bytes(&frame) {
                Ok(message) => Poll::Ready(Some(Ok(message))),
                Err(err) => /* ... */
            }
        },
        // ...
    }
}
```

Additionally, add type-level size constraints:

```rust
// In types/src/dkg/mod.rs
pub struct DKGTranscript {
    pub metadata: DKGTranscriptMetadata,
    #[serde(with = "serde_bytes")]
    pub transcript_bytes: Vec<u8>, // Add validation in constructor
}

impl DKGTranscript {
    const MAX_TRANSCRIPT_BYTES: usize = 5 * 1024 * 1024; // 5MB
    
    pub fn new(epoch: u64, author: AccountAddress, transcript_bytes: Vec<u8>) -> Result<Self> {
        ensure!(
            transcript_bytes.len() <= Self::MAX_TRANSCRIPT_BYTES,
            "DKG transcript exceeds maximum size"
        );
        Ok(Self {
            metadata: DKGTranscriptMetadata { epoch, author },
            transcript_bytes,
        })
    }
}
```

## Proof of Concept

**Rust Reproduction Steps:**

```rust
// Create a malicious DKGTranscript with oversized transcript_bytes
use aptos_types::{
    dkg::DKGTranscript,
    validator_txn::ValidatorTransaction,
};

#[test]
fn test_oversized_validator_transaction_exhaustion() {
    // Create oversized transcript bytes (10MB)
    let oversized_bytes = vec![0u8; 10 * 1024 * 1024];
    
    let malicious_dkg = DKGTranscript::new(
        999, // epoch
        AccountAddress::ZERO,
        oversized_bytes,
    );
    
    let validator_txn = ValidatorTransaction::DKGResult(malicious_dkg);
    
    // Serialize to BCS
    let serialized = bcs::to_bytes(&validator_txn).unwrap();
    
    // This would be sent over network
    // On receiving validator:
    // 1. Network layer deserializes via bcs::from_bytes() - allocates 10MB
    // 2. Only THEN does round_manager check size_in_bytes()
    // 3. Rejects for exceeding 6MB limit
    
    assert!(serialized.len() > 6 * 1024 * 1024); // Exceeds validation limit
    assert!(serialized.len() < 64 * 1024 * 1024); // But under network limit
    
    // Proof: Gap between network deserialization (64MB) and validation (6MB)
}
```

**Attack Simulation:**

```rust
// Malicious validator creates proposal with 6 oversized DKG transactions
fn create_malicious_proposal() -> ProposalExt {
    let mut malicious_vtxns = Vec::new();
    
    for i in 0..6 {
        let oversized_transcript = vec![i as u8; 10 * 1024 * 1024]; // 10MB each
        malicious_vtxns.push(ValidatorTransaction::DKGResult(
            DKGTranscript::new(999, AccountAddress::ZERO, oversized_transcript)
        ));
    }
    
    ProposalExt::V0 {
        validator_txns: malicious_vtxns, // Total: 60MB
        payload: Payload::empty(false, true),
        author: AccountAddress::ONE,
        failed_authors: vec![],
    }
    // When this is sent and received:
    // - Network layer deserializes all 60MB
    // - round_manager then rejects for exceeding 6MB
    // - But 60MB was already allocated and processed
}
```

## Notes

This vulnerability specifically affects the **consensus layer's validator transaction processing** and represents a gap between network-layer capabilities and application-layer validation. The fix requires coordination between network configuration and consensus validation to ensure consistent size limits are enforced before memory allocation occurs during deserialization.

### Citations

**File:** consensus/consensus-types/src/proposal_ext.rs (L50-63)
```rust
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]
pub enum ProposalExt {
    V0 {
        validator_txns: Vec<ValidatorTransaction>,
        /// T of the block (e.g. one or more transaction(s)
        payload: Payload,
        /// Author of the block that can be validated by the author's public key and the signature
        author: Author,
        /// Failed authors from the parent's block to this block.
        /// I.e. the list of consecutive proposers from the
        /// immediately preceeding rounds that didn't produce a successful block.
        failed_authors: Vec<(Round, Author)>,
    },
}
```

**File:** types/src/validator_txn.rs (L14-18)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub enum ValidatorTransaction {
    DKGResult(DKGTranscript),
    ObservedJWKUpdate(jwks::QuorumCertifiedUpdate),
}
```

**File:** types/src/dkg/mod.rs (L48-54)
```rust
/// DKG transcript and its metadata.
#[derive(Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct DKGTranscript {
    pub metadata: DKGTranscriptMetadata,
    #[serde(with = "serde_bytes")]
    pub transcript_bytes: Vec<u8>,
}
```

**File:** types/src/jwks/mod.rs (L303-307)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct QuorumCertifiedUpdate {
    pub update: ProviderJWKs,
    pub multi_sig: AggregateSignature,
}
```

**File:** network/framework/src/protocols/wire/messaging/v1/mod.rs (L225-241)
```rust
    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        match self.project().framed_read.poll_next(cx) {
            Poll::Ready(Some(Ok(frame))) => {
                let frame = frame.freeze();

                match bcs::from_bytes(&frame) {
                    Ok(message) => Poll::Ready(Some(Ok(message))),
                    // Failed to deserialize the NetworkMessage
                    Err(err) => {
                        let mut frame = frame;
                        let frame_len = frame.len();
                        // Keep a few bytes from the frame for debugging
                        frame.truncate(8);
                        let err = ReadError::DeserializeError(err, frame_len, frame);
                        Poll::Ready(Some(Err(err)))
                    },
                }
```

**File:** config/src/config/network_config.rs (L49-50)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** consensus/src/round_manager.rs (L1140-1177)
```rust
            proposal.validator_txns().map_or((0, 0), |txns| {
                txns.iter().fold((0, 0), |(count_acc, size_acc), txn| {
                    (count_acc + 1, size_acc + txn.size_in_bytes())
                })
            });

        let num_validator_txns = num_validator_txns as u64;
        let validator_txns_total_bytes = validator_txns_total_bytes as u64;
        let vtxn_count_limit = self.vtxn_config.per_block_limit_txn_count();
        let vtxn_bytes_limit = self.vtxn_config.per_block_limit_total_bytes();
        let author_hex = author.to_hex();
        PROPOSED_VTXN_COUNT
            .with_label_values(&[&author_hex])
            .inc_by(num_validator_txns);
        PROPOSED_VTXN_BYTES
            .with_label_values(&[&author_hex])
            .inc_by(validator_txns_total_bytes);
        info!(
            vtxn_count_limit = vtxn_count_limit,
            vtxn_count_proposed = num_validator_txns,
            vtxn_bytes_limit = vtxn_bytes_limit,
            vtxn_bytes_proposed = validator_txns_total_bytes,
            proposer = author_hex,
            "Summarizing proposed validator txns."
        );

        ensure!(
            num_validator_txns <= vtxn_count_limit,
            "process_proposal failed with per-block vtxn count limit exceeded: limit={}, actual={}",
            self.vtxn_config.per_block_limit_txn_count(),
            num_validator_txns
        );
        ensure!(
            validator_txns_total_bytes <= vtxn_bytes_limit,
            "process_proposal failed with per-block vtxn bytes limit exceeded: limit={}, actual={}",
            self.vtxn_config.per_block_limit_total_bytes(),
            validator_txns_total_bytes
        );
```

**File:** config/src/config/consensus_config.rs (L231-231)
```rust
            max_receiving_block_bytes: 6 * 1024 * 1024, // 6MB
```

**File:** consensus/consensus-types/src/proposal_msg.rs (L82-118)
```rust
    pub fn verify(
        &self,
        sender: Author,
        validator: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> Result<()> {
        if let Some(proposal_author) = self.proposal.author() {
            ensure!(
                proposal_author == sender,
                "Proposal author {:?} doesn't match sender {:?}",
                proposal_author,
                sender
            );
        }
        let (payload_result, sig_result) = rayon::join(
            || {
                self.proposal().payload().map_or(Ok(()), |p| {
                    p.verify(validator, proof_cache, quorum_store_enabled)
                })
            },
            || {
                self.proposal()
                    .validate_signature(validator)
                    .map_err(|e| format_err!("{:?}", e))
            },
        );
        payload_result?;
        sig_result?;

        // if there is a timeout certificate, verify its signatures
        if let Some(tc) = self.sync_info.highest_2chain_timeout_cert() {
            tc.verify(validator).map_err(|e| format_err!("{:?}", e))?;
        }
        // Note that we postpone the verification of SyncInfo until it's being used.
        self.verify_well_formed()
    }
```
