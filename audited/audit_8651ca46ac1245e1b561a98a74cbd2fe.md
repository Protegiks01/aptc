# Audit Report

## Title
Incomplete Gap Detection in State Sync Data Aggregation Allows Malicious Peers to Cause State Sync Failures

## Summary
The state sync data aggregation logic in `peer_states.rs` does not detect gaps in advertised transaction ranges during aggregation, and gap detection only occurs once at stream creation. Malicious peers can advertise fragmented ranges (e.g., transactions 0-100 and 200-300, missing 101-199), and if honest peers disconnect during sync, nodes will repeatedly request unavailable data until max retry limits are reached, causing state sync failure and preventing new validators from joining the network.

## Finding Description
The aggregation logic collects advertised data ranges from all peers without performing gap validation or range merging: [1](#0-0) 

This code simply pushes all advertised ranges into vectors. When multiple peers advertise non-contiguous ranges, the aggregated `AdvertisedData` contains these gaps without detection.

While gap detection exists via the `contains_range` method: [2](#0-1) 

This validation is only performed once during stream creation: [3](#0-2) 

**Attack Scenario:**
1. Node A needs to sync transactions 0 to 1,000,000
2. Initial peer state: Honest Peer 1 advertises [0-500,000], Honest Peer 2 advertises [500,001-1,000,000]
3. Stream creation succeeds as no gaps exist
4. Malicious Peer 3 joins advertising [0-100,000] and [600,000-1,000,000] (gap: 100,001-599,999)
5. Honest Peers 1 and 2 disconnect or are rate-limited out
6. Global data summary refresh updates with only Peer 3's fragmented ranges
7. Stream engine creates requests for transactions in the gap (e.g., 200,000-300,000): [4](#0-3) 

8. All data requests fail as no peer has the requested data
9. Requests are retried with exponential backoff: [5](#0-4) 

10. After reaching `max_request_retry` (default: 5), the stream terminates: [6](#0-5) [7](#0-6) 

The node cannot complete state sync and remains unable to participate in consensus.

## Impact Explanation
This vulnerability qualifies as **HIGH SEVERITY** under the Aptos bug bounty program criteria:

1. **Validator Node Slowdowns**: Nodes attempting to sync are blocked, consuming resources through repeated failed requests and retries
2. **Significant Protocol Violations**: State sync is a critical protocol component for network liveness
3. **Network Availability**: New validators cannot join the network if they encounter this condition during bootstrapping
4. **Denial of Service**: Coordinated malicious peers can systematically prevent specific nodes from syncing by advertising fragmented ranges

This breaks the **State Consistency** invariant: nodes cannot achieve consistent state with the network when state sync fails due to unavailable data gaps.

## Likelihood Explanation
**HIGH LIKELIHOOD** of occurrence:

1. **Low Attack Complexity**: Any network peer can advertise arbitrary storage summaries without authentication of completeness
2. **Realistic Network Conditions**: Peers naturally disconnect due to network issues, making honest peer unavailability common
3. **No Cost to Attacker**: Malicious peers can advertise false ranges without resource expenditure
4. **Amplification**: A single malicious peer combined with natural network churn can affect multiple syncing nodes
5. **Persistent Effect**: Once triggered, the node remains unable to sync until manual intervention or network topology changes

The attack requires only:
- Running a malicious peer node (trivial)
- Advertising fragmented ranges (no validation)
- Waiting for honest peer disconnection (natural occurrence)

## Recommendation

Implement gap detection and validation during data aggregation and continuously during stream operation:

**1. Add Gap Detection to Aggregation Logic:**
```rust
// In peer_states.rs, after collecting ranges
fn validate_and_merge_ranges(ranges: &mut Vec<CompleteDataRange<u64>>) -> Result<(), Error> {
    if ranges.is_empty() {
        return Ok(());
    }
    
    // Sort ranges by lowest value
    ranges.sort_by_key(|r| r.lowest());
    
    // Check for gaps between consecutive ranges
    for window in ranges.windows(2) {
        let current_highest = window[0].highest();
        let next_lowest = window[1].lowest();
        
        if next_lowest > current_highest + 1 {
            return Err(Error::DataIsUnavailable(format!(
                "Gap detected in advertised ranges: {} to {}",
                current_highest + 1,
                next_lowest - 1
            )));
        }
    }
    
    Ok(())
}
```

**2. Optimize Gap Detection:**
Replace the O(n*m) `contains_range` with O(m) interval-based checking:
```rust
pub fn contains_range_optimized(
    lowest: u64,
    highest: u64,
    advertised_ranges: &[CompleteDataRange<u64>],
) -> bool {
    // Sort ranges and check if [lowest, highest] is covered by union
    let mut sorted = advertised_ranges.to_vec();
    sorted.sort_by_key(|r| r.lowest());
    
    let mut covered_up_to = lowest;
    for range in sorted {
        if range.lowest() > covered_up_to {
            return false; // Gap found
        }
        covered_up_to = covered_up_to.max(range.highest() + 1);
        if covered_up_to > highest {
            return true; // Fully covered
        }
    }
    covered_up_to > highest
}
```

**3. Revalidate During Stream Execution:**
Add periodic gap checking in `update_progress_of_data_stream` before creating new requests.

## Proof of Concept

```rust
// Add to state-sync/data-streaming-service/src/tests/
#[tokio::test]
async fn test_gap_in_advertised_ranges_causes_stream_failure() {
    use aptos_storage_service_types::responses::CompleteDataRange;
    use aptos_data_client::global_summary::AdvertisedData;
    
    // Setup: Create advertised data with gaps
    let mut advertised_data = AdvertisedData::empty();
    
    // Malicious peer advertises fragmented ranges
    advertised_data.transactions.push(CompleteDataRange::new(0, 100).unwrap());
    advertised_data.transactions.push(CompleteDataRange::new(200, 300).unwrap());
    // Gap: versions 101-199 are missing
    
    // Verify gap is NOT detected by current implementation
    // contains_range will iterate and find the gap, but aggregation doesn't call it
    let has_gap = !AdvertisedData::contains_range(0, 300, &advertised_data.transactions);
    assert!(has_gap, "Gap should be detected");
    
    // Simulate stream requesting data from gap
    // Requests for versions 101-199 will fail repeatedly
    // After max_request_retry attempts, stream terminates
    // Node cannot complete state sync
    
    // Expected behavior: Aggregation should reject ranges with gaps
    // or merge contiguous ranges before advertising
}
```

**Notes**

The vulnerability exists at multiple layers:
1. **Aggregation layer** (`peer_states.rs`): No gap validation when collecting ranges from peers
2. **Validation layer** (`global_summary.rs`): Performance issues in gap detection (O(n*m) complexity)
3. **Stream layer** (`streaming_service.rs`): Gap checking only at creation, not during runtime when advertised data changes

The `contains_range` method has severe performance implications for large ranges (e.g., checking 10M transactions would iterate 10M times), potentially causing timeouts even when gaps exist. Combined with the lack of runtime revalidation, this creates a reliable denial-of-service vector against state sync.

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L363-386)
```rust
        for summary in storage_summaries {
            // Collect aggregate data advertisements
            if let Some(epoch_ending_ledger_infos) = summary.data_summary.epoch_ending_ledger_infos
            {
                advertised_data
                    .epoch_ending_ledger_infos
                    .push(epoch_ending_ledger_infos);
            }
            if let Some(states) = summary.data_summary.states {
                advertised_data.states.push(states);
            }
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
            if let Some(transactions) = summary.data_summary.transactions {
                advertised_data.transactions.push(transactions);
            }
            if let Some(transaction_outputs) = summary.data_summary.transaction_outputs {
                advertised_data
                    .transaction_outputs
                    .push(transaction_outputs);
            }
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L153-173)
```rust
    pub fn contains_range(
        lowest: u64,
        highest: u64,
        advertised_ranges: &[CompleteDataRange<u64>],
    ) -> bool {
        for item in lowest..=highest {
            let mut item_exists = false;

            for advertised_range in advertised_ranges {
                if advertised_range.contains(item) {
                    item_exists = true;
                    break;
                }
            }

            if !item_exists {
                return false;
            }
        }
        true
    }
```

**File:** state-sync/data-streaming-service/src/streaming_service.rs (L286-287)
```rust
        // Verify the data stream can be fulfilled using the currently advertised data
        data_stream.ensure_data_is_available(&advertised_data)?;
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1259-1265)
```rust
            let client_requests = create_data_client_request_batch(
                next_request_version,
                target_ledger_info.ledger_info().version(),
                num_requests_to_send,
                optimal_chunk_sizes,
                self.clone().into(),
            )?;
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L447-447)
```rust
            || self.request_failure_count >= self.streaming_service_config.max_request_retry
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L733-734)
```rust
        // Increment the number of client failures for this request
        self.request_failure_count += 1;
```

**File:** config/src/config/state_sync_config.rs (L277-277)
```rust
            max_request_retry: 5,
```
