# Audit Report

## Title
Unmetered Type Layout Computation Enables DoS via Complex Type Structures

## Summary
The Move VM's type layout computation performs expensive recursive traversal and memory allocation for up to 512 nodes without proportional gas charging, allowing attackers to cause validator slowdowns by creating types with exponentially growing complexity.

## Finding Description

The Move VM computes type layouts when executing native functions like `bcs::to_bytes`, event emission, and table operations. The layout computation involves recursive traversal of type structures and memory allocation for each node in the type tree. [1](#0-0) 

The production configuration allows up to 512 nodes in a type layout: [2](#0-1) 

During layout construction, the system performs recursive tree traversal with node counting but **no proportional gas charging** for the actual computation work: [3](#0-2) 

Critically, the developers acknowledge this missing gas metering in a TODO comment: [4](#0-3) 

The only gas charged is for module loading (based on module SIZE in bytes, not type complexity): [5](#0-4) 

**Attack Path:**

1. Attacker publishes a module with exponentially growing struct definitions (e.g., `A0` containing one field, `A1` containing two `A0` fields, `A2` containing two `A1` fields, etc.): [6](#0-5) 

2. For struct `An`, the node count follows the formula: `nodes(An) = 2^(n+1) - 1`. Therefore `A8` has 511 nodes (just under the 512 limit).

3. Attacker calls `bcs::to_bytes<vector<A8>>(&value)` which triggers layout computation: [7](#0-6) 

4. The VM recursively traverses all 511 nodes, allocating memory and building the layout tree, without charging gas proportional to this work.

5. While layouts are cached within a block, the attacker can exploit this across blocks or use different type instantiations to bypass caching: [8](#0-7) 

This breaks the invariant: "Resource Limits: All operations must respect gas, storage, and computational limits."

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program category "Validator node slowdowns."

Each layout computation for a complex type approaching 512 nodes involves:
- 511 recursive function calls
- 511 memory allocations for `MoveTypeLayout` structures
- Full tree traversal and construction

An attacker can repeatedly exploit this by:
- Submitting transactions in each new block (when cache is cold)
- Using multiple complex type definitions or different type instantiations (e.g., `MyStruct<u8>`, `MyStruct<u64>`)
- Creating multiple modules with different exponential type structures

While individual operations complete, sustained exploitation across blocks can degrade validator performance, as validators must process this unmetered work alongside legitimate transactions.

## Likelihood Explanation

**Likelihood: High**

The attack is straightforward to execute:
- Requires only ability to publish a module (standard user capability)
- No special permissions or validator access needed
- Deterministic exploitation: always triggers unmetered computation
- Multiple attack vectors: any native function requiring layout computation (BCS serialization, event emission, table operations)
- Existing test code demonstrates the feasibility: [9](#0-8) 

## Recommendation

Implement proportional gas charging for layout construction based on the number of nodes processed. The recommended fix:

1. Add a new gas parameter for layout node processing (e.g., `LAYOUT_CONSTRUCTION_PER_NODE`)

2. Charge gas during layout construction in `check_depth_and_increment_count`:

```rust
fn check_depth_and_increment_count(
    &self,
    gas_meter: &mut impl GasMeter, // Change type to support charging
    node_count: &mut u64,
    depth: u64,
) -> PartialVMResult<()> {
    let max_count = self.vm_config().layout_max_size;
    if *node_count > max_count || *node_count == max_count && self.is_lazy_loading_enabled() {
        return Err(
            PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES).with_message(format!(
                "Number of type nodes when constructing type layout exceeded the maximum of {}",
                max_count
            )),
        );
    }
    
    // NEW: Charge gas proportional to node count
    gas_meter.charge_layout_node()?;
    
    *node_count += 1;

    if depth > self.vm_config().layout_max_depth {
        return Err(
            PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED).with_message(format!(
                "Depth of a layout exceeded the maximum of {} during construction",
                self.vm_config().layout_max_depth
            )),
        );
    }
    Ok(())
}
```

3. Update the gas schedule to include the new parameter with appropriate calibration based on actual CPU cost per node.

4. Address the TODO comment as noted by developers: [10](#0-9) 

## Proof of Concept

```rust
// File: test_layout_dos.move
module 0xbeef::layout_dos {
    struct A0 has drop { a: u64 }
    struct A1 has drop { a: A0, b: A0 }
    struct A2 has drop { a: A1, b: A1 }
    struct A3 has drop { a: A2, b: A2 }
    struct A4 has drop { a: A3, b: A3 }
    struct A5 has drop { a: A4, b: A4 }
    struct A6 has drop { a: A5, b: A5 }
    struct A7 has drop { a: A6, b: A6 }
    struct A8 has drop { a: A7, b: A7 } // 2^9 - 1 = 511 nodes

    use std::bcs;
    use std::vector;

    public entry fun exploit() {
        // This triggers layout computation for ~511 nodes
        // without proportional gas charging
        bcs::to_bytes<A8>(&A8 {
            a: A7 { /* ... initialize deeply ... */ },
            b: A7 { /* ... initialize deeply ... */ }
        });
    }
    
    public entry fun repeated_exploit() {
        // Call multiple times to amplify effect
        let i = 0;
        while (i < 100) {
            bcs::to_bytes<A8>(&A8 { /* ... */ });
            i = i + 1;
        }
    }
}
```

To reproduce:
1. Publish the module above to the chain
2. Execute `exploit()` entry function
3. Observe that gas charged is based only on module loading and BCS output size, not the ~511 node layout computation
4. Execute `repeated_exploit()` across multiple blocks to demonstrate sustained validator slowdown
5. Monitor validator CPU and memory metrics to confirm disproportionate resource consumption relative to gas charged

### Citations

**File:** third_party/move/move-vm/runtime/src/config.rs (L27-29)
```rust
    /// Maximum allowed number of nodes in a type layout. This includes the types of fields for
    /// struct types.
    pub layout_max_size: u64,
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L215-219)
```rust
    let layout_max_size = if gas_feature_version >= RELEASE_V1_30 {
        512
    } else {
        256
    };
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L88-114)
```rust
        let ty_pool = self.runtime_environment().ty_pool();
        if self.vm_config().enable_layout_caches {
            let key = match ty {
                Type::Struct { idx, .. } => {
                    let ty_args_id = ty_pool.intern_ty_args(&[]);
                    Some(StructKey {
                        idx: *idx,
                        ty_args_id,
                    })
                },
                Type::StructInstantiation { idx, ty_args, .. } => {
                    let ty_args_id = ty_pool.intern_ty_args(ty_args);
                    Some(StructKey {
                        idx: *idx,
                        ty_args_id,
                    })
                },
                _ => None,
            };

            if let Some(key) = key {
                if let Some(result) = self.struct_definition_loader.load_layout_from_cache(
                    gas_meter,
                    traversal_context,
                    &key,
                ) {
                    return result;
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L197-222)
```rust
    fn check_depth_and_increment_count(
        &self,
        node_count: &mut u64,
        depth: u64,
    ) -> PartialVMResult<()> {
        let max_count = self.vm_config().layout_max_size;
        if *node_count > max_count || *node_count == max_count && self.is_lazy_loading_enabled() {
            return Err(
                PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES).with_message(format!(
                    "Number of type nodes when constructing type layout exceeded the maximum of {}",
                    max_count
                )),
            );
        }
        *node_count += 1;

        if depth > self.vm_config().layout_max_depth {
            return Err(
                PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED).with_message(format!(
                    "Depth of a layout exceeded the maximum of {} during construction",
                    self.vm_config().layout_max_depth
                )),
            );
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L363-367)
```rust
    // TODO(lazy-loading):
    //   We do not add struct cyclic checks here because it can be rather expensive to check. In
    //   general, because we have depth / count checks and charges for modules this will eventually
    //   terminate in any case. In the future, layouts should be revisited anyway.
    //   Consider adding proper charges here for layout construction (before rollout).
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L56-76)
```rust
    #[inline]
    fn charge_dependency(
        &mut self,
        _kind: DependencyKind,
        addr: &AccountAddress,
        _name: &IdentStr,
        size: NumBytes,
    ) -> PartialVMResult<()> {
        // Modules under special addresses are considered system modules that should always
        // be loaded, and are therefore excluded from gas charging.
        //
        // TODO: 0xA550C18 is a legacy system address we used, but it is currently not covered by
        //       `.is_special()`. We should double check if this address still needs special
        //       treatment.
        if self.feature_version() >= 15 && !addr.is_special() {
            self.algebra
                .charge_execution(DEPENDENCY_PER_MODULE + DEPENDENCY_PER_BYTE * size)?;
            self.algebra.count_dependency(size)?;
        }
        Ok(())
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/type_too_large.data/type_too_large/sources/test.move (L1-12)
```text
module 0xbeef::test {

    struct A0 has drop { a: u64 }
    struct A1 has drop { a: A0, b: A0 }
    struct A2 has drop { a: A1, b: A1 }
    struct A3 has drop { a: A2, b: A2 }
    struct A4 has drop { a: A3, b: A3 }
    struct A5 has drop { a: A4, b: A4 }
    struct A6 has drop { a: A5, b: A5 }
    struct A7 has drop { a: A6, b: A6 }
    struct A8 has drop { a: A7, b: A7 }
    struct A9 has drop { a: A8, b: A8 }
```

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L67-89)
```rust
    let layout = if context.get_feature_flags().is_lazy_loading_enabled() {
        // With lazy loading, propagate the error directly. This is because errors here are likely
        // from metering, so we should not remap them in any way. Note that makes it possible to
        // fail on constructing a very deep / large layout and not be charged, but this is already
        // the case for regular execution, so we keep it simple. Also, charging more gas after
        // out-of-gas failure in layout construction does not make any sense.
        //
        // Example:
        //   - Constructing layout runs into dependency limit.
        //   - We cannot do `context.charge(BCS_TO_BYTES_FAILURE)?;` because then we can end up in
        //     the state where out of gas and dependency limit are hit at the same time.
        context.type_to_type_layout(arg_type)?
    } else {
        match context.type_to_type_layout(arg_type) {
            Ok(layout) => layout,
            Err(_) => {
                context.charge(BCS_TO_BYTES_FAILURE)?;
                return Err(SafeNativeError::Abort {
                    abort_code: NFE_BCS_SERIALIZATION_FAILURE,
                });
            },
        }
    };
```

**File:** aptos-move/e2e-move-tests/src/tests/type_too_large.rs (L12-44)
```rust
#[test_case(true)]
#[test_case(false)]
fn type_too_large(enable_lazy_loading: bool) {
    let mut h = MoveHarness::new_with_lazy_loading(enable_lazy_loading);

    // Load the code
    let acc = h.new_account_at(AccountAddress::from_hex_literal("0xbeef").unwrap());
    assert_success!(h.publish_package(
        &acc,
        &common::test_dir_path("type_too_large.data/type_too_large"),
    ));

    let result = h.run_entry_function(
        &acc,
        str::parse("0xbeef::test::run").unwrap(),
        vec![],
        vec![],
    );

    // With lazy loading, layout construction errors with too many type nodes and the error is
    // propagated. Without lazy loading, the error happens inside the serializer and is remapped
    // to serialization failure error code (legacy behaviour).
    if enable_lazy_loading {
        assert!(matches!(
            result,
            TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(Some(
                StatusCode::TOO_MANY_TYPE_NODES
            )))
        ));
    } else {
        assert_abort!(result, 0x1C5);
    }
}
```
