# Audit Report

## Title
Transaction Order Violation in Admin Service Block Dump Causing Incorrect Replay State Roots

## Summary
The `dump_blocks_bcs()` function in the admin service iterates consensus blocks in lexicographic hash order rather than blockchain chronological order (epoch, round), causing transactions to be extracted in the wrong sequence. When this data is used for replay execution by debugging tools, it produces different state roots than the original blockchain execution.

## Finding Description

The vulnerability exists in the transaction extraction logic used by admin/debugging endpoints: [1](#0-0) 

The blocks are retrieved via `ConsensusDB::get_data()` which internally calls: [2](#0-1) 

This uses `get_all::<BlockSchema>()`: [3](#0-2) 

The critical issue is that `BlockSchema` uses `HashValue` (block ID) as the database key: [4](#0-3) 

RocksDB's iterator returns entries in **lexicographic byte order of the HashValue**, not in blockchain chronological order (epoch, round). Block hashes are cryptographically random and have no correlation with block sequence.

The extracted transactions are consumed by the aptos-debugger for replay execution: [5](#0-4) 

And also via direct consensus DB access: [6](#0-5) 

The debugger then executes these transactions, expecting them to be in correct order: [7](#0-6) 

**Invariant Broken**: Deterministic Execution - the replay produces a different state root than the original blockchain execution because transactions are executed in hash order rather than (epoch, round) order.

## Impact Explanation

**Severity: High**

This vulnerability affects the integrity of debugging and verification infrastructure but does NOT directly impact production consensus. However, it qualifies as **High severity** under "Significant protocol violations" because:

1. **State Inconsistencies**: Replayed execution produces incorrect state roots, violating deterministic execution guarantees for verification purposes
2. **Debugging Infrastructure Compromise**: Critical debugging tools produce incorrect results, potentially masking real issues or creating false positives during incident response
3. **Verification Failures**: Any replay-based verification or forensic analysis will produce wrong results

While this doesn't allow fund theft or consensus manipulation in production (admin endpoint requires privileged access), it severely undermines the reliability of debugging and verification tools used by validators and core developers for critical operational tasks.

## Likelihood Explanation

**Likelihood: Medium-High**

This issue occurs whenever:
1. The admin endpoint `/debug/consensus/block?bcs=true` is called without a specific `block_id` parameter (dumps all blocks)
2. The debugger's `execute_pending_block` command is run with a consensus DB path (not REST endpoint)
3. Multiple blocks exist in the consensus DB

The bug triggers deterministically once conditions are met. The likelihood is medium-high because:
- Admin/debugging operations are frequent during development and incident response
- The function is specifically designed for replay scenarios
- No special attacker privileges beyond admin access are needed

## Recommendation

Sort blocks by (epoch, round) before extracting transactions:

```rust
fn dump_blocks_bcs(
    consensus_db: &dyn PersistentLivenessStorage,
    quorum_store_db: &dyn QuorumStoreStorage,
    block_id: Option<HashValue>,
) -> anyhow::Result<Vec<u8>> {
    let all_batches = quorum_store_db.get_all_batches()?;
    let (_, _, mut blocks, _) = consensus_db.consensus_db().get_data()?;
    
    // Sort blocks by (epoch, round) to preserve blockchain order
    blocks.sort_by_key(|b| (b.epoch(), b.round()));

    let mut all_txns = Vec::new();
    for block in blocks {
        let id = block.id();
        if block_id.is_none() || id == block_id.unwrap() {
            match extract_txns_from_block(&block, &all_batches) {
                Ok(txns) => {
                    all_txns.extend(txns.into_iter().cloned().map(Transaction::UserTransaction));
                },
                Err(e) => bail!("Failed to extract txns from block ({id:?}): {e:?}."),
            };
        }
    }

    bcs::to_bytes(&all_txns).map_err(Error::msg)
}
```

Apply the same fix to `dump_blocks()` and `dump_pending_txns()` in:
- `crates/aptos-admin-service/src/server/consensus/mod.rs::dump_blocks()`  
- `consensus/src/util/db_tool.rs::dump_pending_txns()`

## Proof of Concept

```rust
// Test demonstrating hash order != blockchain order
#[test]
fn test_block_iteration_order_violation() {
    use aptos_crypto::HashValue;
    
    // Simulate three blocks with sequential rounds but random hashes
    let block1_hash = HashValue::from_hex("AAAA...").unwrap(); // Round 1
    let block2_hash = HashValue::from_hex("5555...").unwrap(); // Round 2  
    let block3_hash = HashValue::from_hex("FFFF...").unwrap(); // Round 3
    
    // Lexicographic hash order: 0x5555 < 0xAAAA < 0xFFFF
    // But blockchain order: Round 1 < Round 2 < Round 3
    
    // When ConsensusDB.get_all() iterates, it returns:
    // [block2 (0x5555, round=2), block1 (0xAAAA, round=1), block3 (0xFFFF, round=3)]
    // This violates chronological ordering!
    
    assert!(block2_hash < block1_hash); // Hash order
    assert!(1 < 2); // But round 1 should come before round 2!
}
```

**Notes**:
- This issue only affects debugging/admin tools, not production consensus execution
- The actual consensus protocol correctly orders blocks by (epoch, round) during execution
- Admin service endpoints require privileged access, limiting exploitability
- However, the bug still violates the deterministic execution invariant for replay scenarios and qualifies as a significant protocol violation in the debugging infrastructure

### Citations

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L224-237)
```rust
    let (_, _, blocks, _) = consensus_db.consensus_db().get_data()?;

    let mut all_txns = Vec::new();
    for block in blocks {
        let id = block.id();
        if block_id.is_none() || id == block_id.unwrap() {
            match extract_txns_from_block(&block, &all_batches) {
                Ok(txns) => {
                    all_txns.extend(txns.into_iter().cloned().map(Transaction::UserTransaction));
                },
                Err(e) => bail!("Failed to extract txns from block ({id:?}): {e:?}."),
            };
        }
    }
```

**File:** consensus/src/consensusdb/mod.rs (L90-94)
```rust
        let consensus_blocks = self
            .get_all::<BlockSchema>()?
            .into_iter()
            .map(|(_, block)| block)
            .collect();
```

**File:** consensus/src/consensusdb/mod.rs (L201-205)
```rust
    pub fn get_all<S: Schema>(&self) -> Result<Vec<(S::Key, S::Value)>, DbError> {
        let mut iter = self.db.iter::<S>()?;
        iter.seek_to_first();
        Ok(iter.collect::<Result<Vec<(S::Key, S::Value)>, AptosDbError>>()?)
    }
```

**File:** consensus/src/consensusdb/schema/block/mod.rs (L23-33)
```rust
define_schema!(BlockSchema, HashValue, Block, BLOCK_CF_NAME);

impl KeyCodec<BlockSchema> for HashValue {
    fn encode_key(&self) -> Result<Vec<u8>> {
        Ok(self.to_vec())
    }

    fn decode_key(data: &[u8]) -> Result<Self> {
        Ok(HashValue::from_slice(data)?)
    }
}
```

**File:** aptos-move/aptos-debugger/src/execute_pending_block.rs (L59-78)
```rust
                // Get the pending transactions from the REST endpoint
                let base_url =
                    Url::parse(&block_rest_endpoint)?.join("/debug/consensus/block?bcs=true")?;
                let url = if let Some(block_id) = self.block_id {
                    base_url.join(&format!("&block_id={block_id:?}"))?
                } else {
                    base_url
                };
                info!("GET {url:?}...");
                let body = reqwest::get(url).await?.bytes().await?;
                let pending_txns: Vec<_> = bcs::from_bytes(&body)?;

                // Question[MI Counter]: Is it okay to use these auxiliary infos here?
                let pending_aux_infos = (0..pending_txns.len())
                    .map(|i| aptos_types::transaction::PersistedAuxiliaryInfo::V1 {
                        transaction_index: i as u32,
                    })
                    .collect::<Vec<_>>();

                (pending_txns, pending_aux_infos)
```

**File:** aptos-move/aptos-debugger/src/execute_pending_block.rs (L84-96)
```rust
                let cmd = aptos_consensus::util::db_tool::Command {
                    db_dir: consensus_db_path,
                    block_id: self.block_id,
                };
                let txns = cmd.dump_pending_txns()?;

                // For consensus DB path, create auxiliary infos with sequential indices
                let aux_infos = (0..txns.len())
                    .map(|i| aptos_types::transaction::PersistedAuxiliaryInfo::V1 {
                        transaction_index: i as u32,
                    })
                    .collect::<Vec<_>>();

```

**File:** aptos-move/aptos-debugger/src/execute_pending_block.rs (L108-114)
```rust
        let txn_outputs = debugger.execute_transactions_at_version(
            self.begin_version,
            block,
            block_auxiliary_infos,
            self.repeat_execution_times.unwrap_or(1),
            &self.opts.concurrency_level,
        )?;
```
