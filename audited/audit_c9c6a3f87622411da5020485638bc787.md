# Audit Report

## Title
Missing Gas Schedule Parameter Validation Enables Network DoS via Governance

## Summary
The gas schedule update mechanism lacks bounds validation on individual parameter values, allowing governance to deploy extreme parameter values (u64::MAX or 0) that can cause network-wide denial of service or economic security breaches through the saturating arithmetic in the gas algebra.

## Finding Description

The gas algebra in `gas_algebra.rs` uses saturating arithmetic for all operations to prevent panics [1](#0-0) [2](#0-1) . When gas schedules are loaded from on-chain configuration, parameters are converted directly from u64 values with no bounds validation [3](#0-2) .

The Move gas schedule module contains TODO comments acknowledging this missing validation [4](#0-3) [5](#0-4) [6](#0-5) , but only validates feature version ordering [7](#0-6) .

**Attack Vector:**
1. Governance passes proposal setting gas parameters to u64::MAX
2. Any gas calculation like `INTRINSIC_GAS_PER_BYTE * transaction_size` saturates to u64::MAX [8](#0-7) 
3. Gas charging attempts to deduct u64::MAX from transaction balance [9](#0-8) 
4. All transactions immediately fail with OUT_OF_GAS

Alternatively, setting parameters to 0 makes all operations free, breaking economic security.

## Impact Explanation

**Severity: High** - This meets the bug bounty criteria for "Validator node slowdowns" and "Significant protocol violations":

- **Network DoS**: Setting critical parameters to u64::MAX causes all transactions to fail, halting the network until governance can pass a fix (requires multiple epochs)
- **Economic Security Breach**: Setting parameters to 0 enables unlimited free computation and storage
- **State Inconsistency**: Extreme limit values like setting `max_execution_gas` to 1 cause legitimate transactions to fail limit checks [10](#0-9) 

This breaks the invariants:
- "Resource Limits: All operations must respect gas, storage, and computational limits"
- "Move VM Safety: Bytecode execution must respect gas limits and memory constraints"

## Likelihood Explanation

**Likelihood: Medium-Low**

**Requirements:**
- Attacker needs governance voting power to pass malicious proposal
- OR governance process compromise
- This falls under "insider threat" or "governance compromise" scenarios

**Mitigating Factors:**
- Governance participants are assumed trusted per the trust model
- Multi-step proposal process with voting period provides review opportunity
- Issue is documented in TODO comments, suggesting awareness

However, the **complete absence of validation** means any governance error or compromise immediately translates to network impact with no safety net.

## Recommendation

Implement comprehensive bounds validation in the `from_on_chain_gas_schedule` method:

```rust
// In macros.rs, replace line 40 with:
if let Some(key) = define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
    let name = format!("{}.{}", $prefix, key);
    let value = gas_schedule.get(&name)
        .cloned()
        .ok_or_else(|| format!("Gas parameter {} does not exist.", name))?;
    
    // Add bounds validation
    validate_parameter_bounds(&name, value, feature_version)?;
    
    params.$name = value.into();
}
```

Define reasonable bounds for each parameter category:
- Execution gas parameters: 0 < value < u64::MAX / 1000
- Per-byte costs: 0 < value < 1_000_000
- Limits (max_execution_gas, etc.): MIN_REASONABLE < value < MAX_REASONABLE

Add explicit validation in `gas_schedule.move`:
```move
// Replace TODO comments with actual validation
public fun validate_gas_schedule(schedule: &GasScheduleV2): bool {
    // Check all parameters are within reasonable bounds
    // Ensure no parameters are 0 or u64::MAX
    // Validate that multiplications won't saturate for typical usage
}
```

## Proof of Concept

```rust
#[test]
fn test_malicious_gas_schedule_dos() {
    use aptos_gas_schedule::*;
    use move_core_types::gas_algebra::*;
    
    // Create gas parameters with u64::MAX
    let mut malicious_schedule = BTreeMap::new();
    malicious_schedule.insert("txn.intrinsic_gas_per_byte".to_string(), u64::MAX);
    malicious_schedule.insert("txn.min_transaction_gas_units".to_string(), u64::MAX);
    
    let params = AptosGasParameters::from_on_chain_gas_schedule(
        &malicious_schedule, 
        LATEST_GAS_FEATURE_VERSION
    ).unwrap();
    
    // Any transaction calculation saturates
    let txn_size = NumBytes::new(100);
    let intrinsic = params.vm.txn.calculate_intrinsic_gas(txn_size);
    let result = intrinsic.evaluate(LATEST_GAS_FEATURE_VERSION, &params.vm);
    
    // Result is u64::MAX, causing immediate OUT_OF_GAS
    assert_eq!(u64::from(result), u64::MAX);
    
    // This would brick the network as all transactions fail
}
```

## Notes

While this vulnerability requires governance compromise to exploit (making it an "insider threat"), the **complete absence of validation** represents a critical gap in defense-in-depth. The TODO comments indicate this is a known limitation, but the implementation has remained vulnerable. Given that governance is controlled by stake-weighted voting, any governance attack vector (vote buying, key compromise, voting bug) could immediately translate to network DoS with no technical safeguards.

The saturating arithmetic in `gas_algebra.rs` is working as designedâ€”the vulnerability is in the governance layer's failure to validate inputs before they reach the algebra.

### Citations

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L209-209)
```rust
        Self::new(self.val.saturating_add(rhs.val))
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L230-230)
```rust
    GasQuantity::new(x.val.saturating_mul(y.val))
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L40-40)
```rust
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-67)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L75-75)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L98-100)
```text
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L309-309)
```rust
        MIN_TRANSACTION_GAS_UNITS + INTRINSIC_GAS_PER_BYTE * excess
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L187-202)
```rust
        let amount = abstract_amount.evaluate(self.feature_version, &self.vm_gas_params);

        match self.balance.checked_sub(amount) {
            Some(new_balance) => {
                self.balance = new_balance;
                self.execution_gas_used += amount;
            },
            None => {
                let old_balance = self.balance;
                self.balance = 0.into();
                if self.feature_version >= 12 {
                    self.execution_gas_used += old_balance;
                }
                return Err(PartialVMError::new(StatusCode::OUT_OF_GAS));
            },
        };
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L204-208)
```rust
        if self.feature_version >= 7 && self.execution_gas_used > self.max_execution_gas {
            Err(PartialVMError::new(StatusCode::EXECUTION_LIMIT_REACHED))
        } else {
            Ok(())
        }
```
