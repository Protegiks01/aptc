# Audit Report

## Title
Unmetered Cyclic Dependency Detection Allows Resource Exhaustion in Non-Lazy-Loading Mode

## Summary
The `visit_dependencies_and_verify` function performs unmetered DFS traversal for cyclic dependency detection during module publishing. An attacker can create modules with circular dependencies that force expensive bytecode verification operations before the cycle is detected, consuming validator CPU resources without corresponding gas charges.

## Finding Description

The vulnerability exists in the module verification flow when lazy loading is disabled. The `visit_dependencies_and_verify` function in `module_storage.rs` performs a depth-first search to verify modules and detect circular dependencies, but this operation is explicitly marked as unmetered. [1](#0-0) 

When an attacker publishes a module bundle containing circular dependencies (M1→M2→...→Mn→M1), the verification process:

1. Starts verifying M1, performs local bytecode verification (unmetered)
2. Recursively descends to M2, performs local bytecode verification (unmetered)
3. Continues through the chain until Mn
4. Only detects the cycle when attempting to re-verify M1 [2](#0-1) 

Each local verification involves expensive operations including structural checks, type checking, and bytecode validation via `build_locally_verified_module`: [3](#0-2) 

The critical issue is that gas charging for dependencies only covers modules OUTSIDE the published bundle, not modules INSIDE it: [4](#0-3) 

This means an attacker can force up to 767 unmetered bytecode verifications (with `max_num_dependencies` = 768) before the cycle is detected. [5](#0-4) 

## Impact Explanation

This vulnerability enables validator performance degradation during module publishing operations, qualifying as **Medium severity** per Aptos bug bounty criteria ("Validator node slowdowns").

**However, there is a critical limitation**: This vulnerability only manifests when lazy loading is **disabled**. In production, lazy loading is enabled by default: [6](#0-5) 

With lazy loading enabled, cyclic dependency checking is skipped during publishing: [7](#0-6) [8](#0-7) 

## Likelihood Explanation

**Likelihood: Very Low**

While the vulnerability exists in the codebase, exploitation requires lazy loading to be disabled, which is **not** the default configuration in production. Lazy loading is explicitly enabled in the default feature flags and cannot be disabled by unprivileged attackers—only through governance proposals.

The attack would require:
1. Governance to disable lazy loading via on-chain proposal (extremely unlikely)
2. OR a bug/misconfiguration that disables lazy loading
3. Attacker then publishes module bundle with circular dependencies

Without these preconditions, the vulnerable code path is not executed.

## Recommendation

Despite lazy loading being enabled by default, the unmetered cycle detection represents a defense-in-depth weakness. Recommendations:

1. **Add gas metering** to `visit_dependencies_and_verify` to charge for verification work
2. **Add early cycle detection** before performing expensive verification operations
3. **Document the security implications** of disabling lazy loading
4. **Add monitoring/alerts** if lazy loading is disabled in production

Example fix: Introduce gas charging before local verification in the dependency traversal loop, similar to `check_dependencies_and_charge_gas`.

## Proof of Concept

```rust
// Conceptual PoC - would need to be adapted to actual test framework
// This demonstrates the attack when lazy loading is disabled

// Create modules M1, M2, M3 forming a cycle: M1→M2→M3→M1
let m1 = create_module("M1", vec!["M2"]); // M1 depends on M2
let m2 = create_module("M2", vec!["M3"]); // M2 depends on M3  
let m3 = create_module("M3", vec!["M1"]); // M3 depends on M1 (cycle!)

// Publish bundle with lazy loading disabled
let bundle = ModuleBundle::new(vec![m1, m2, m3]);

// This would trigger unmetered verification of M1, M2, M3
// before detecting the cycle at M3→M1
publish_module_bundle_without_lazy_loading(bundle);

// Expected: Multiple unmetered bytecode verifications occur
// before CYCLIC_MODULE_DEPENDENCY error is raised
```

---

**Notes:**

While this vulnerability exists in the codebase, its **practical exploitability is severely limited** by the default enablement of lazy loading. The vulnerable code path is only reached in non-default configurations. This represents more of a **latent security weakness** than an actively exploitable vulnerability in production deployments. The security question correctly identifies this as Medium severity, reflecting both the technical validity of the issue and its limited practical impact due to configuration defaults.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L111-112)
```rust
    /// Note 1: this API is not metered!
    /// Note 2: this API is used before lazy loading was enabled!
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L372-381)
```rust
    runtime_environment.paranoid_check_module_address_and_name(
        module.code().deserialized(),
        module_id.address(),
        module_id.name(),
    )?;
    let locally_verified_code = runtime_environment.build_locally_verified_module(
        module.code().deserialized().clone(),
        module.extension().size_in_bytes(),
        module.extension().hash(),
    )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L399-415)
```rust
        if visited.insert(dependency_id.clone()) {
            // Dependency is not verified, and we have not visited it yet.
            let verified_dependency = visit_dependencies_and_verify(
                dependency_id.clone(),
                dependency,
                dependency_version,
                visited,
                module_cache_with_context,
            )?;
            verified_dependencies.push(verified_dependency);
        } else {
            // We must have found a cycle otherwise.
            return Err(module_cyclic_dependency_error!(
                dependency_id.address(),
                dependency_id.name()
            ));
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1621-1629)
```rust
                modules
                    .iter()
                    .flat_map(|module| {
                        module
                            .immediate_dependencies_iter()
                            .chain(module.immediate_friends_iter())
                    })
                    .filter(|addr_and_name| !module_ids_in_bundle.contains(addr_and_name)),
            )?;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L251-254)
```rust
            max_num_dependencies: NumModules,
            { RELEASE_V1_10.. => "max_num_dependencies" },
            768,
        ],
```

**File:** types/src/on_chain_config/aptos_features.rs (L266-266)
```rust
            FeatureFlag::ENABLE_LAZY_LOADING,
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L259-260)
```rust
                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L276-279)
```rust
            } else {
                // Verify the module and its dependencies, and that they do not form a cycle.
                staged_module_storage
                    .unmetered_get_eagerly_verified_module(addr, name)?
```
