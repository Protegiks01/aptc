# Audit Report

## Title
Signature Type Mismatch in BatchInfo to BatchInfoExt Conversion Causes Proof Aggregation Failure

## Summary
The conversion from `SignedBatchInfo<BatchInfo>` to `SignedBatchInfo<BatchInfoExt>` reuses signatures without re-verification, creating a type mismatch that causes cryptographic verification to fail during proof-of-store aggregation. This breaks consensus liveness for V1 batches.

## Finding Description

The vulnerability occurs through a multi-stage signature type mismatch in the quorum store batch handling flow:

**Stage 1: Signature Creation** [1](#0-0) 

For V1 batches, the system signs the unwrapped `BatchInfo` directly, then converts to `SignedBatchInfo<BatchInfoExt>`.

**Stage 2: Network Transmission** [2](#0-1) 

Before sending, the signature is converted back to `SignedBatchInfo<BatchInfo>` and transmitted as a V1 message.

**Stage 3: Verification and Re-conversion** [3](#0-2) 

The receiver verifies the signature against `BatchInfo` (which passes), then converts it to `SignedBatchInfo<BatchInfoExt>` using the problematic `From` implementation: [4](#0-3) 

**Stage 4: Aggregation Failure** [5](#0-4) 

When creating the proof-of-store, the aggregated signatures are verified against `BatchInfoExt`, but the individual signatures were created for `BatchInfo`.

**Why This Fails:**

The cryptographic signing message includes a type-specific hash seed: [6](#0-5) 

The `CryptoHasher` derive macro generates different seeds for different types: [7](#0-6) 

This means:
- `BatchInfo` signing message: `BatchInfoHasher::seed() || bcs(BatchInfo)`  
- `BatchInfoExt` signing message: `BatchInfoExtHasher::seed() || bcs(BatchInfoExt::V1 { info })`

These are cryptographically distinct messages. A BLS signature valid for the first cannot validate against the second.

## Impact Explanation

This violates the **Cryptographic Correctness** invariant and causes **consensus liveness failure** for V1 batches:

1. All V1 batches would fail during proof-of-store aggregation verification
2. Validators cannot form quorum certificates for V1 batches
3. Consensus would halt if V1 batches are still in active use

**Severity Assessment: Critical** - Total loss of liveness/network availability if V1 batches are active. However, the impact depends on whether V1 batches are still deployed in production networks.

## Likelihood Explanation

**Likelihood: Low-to-None** due to the following mitigating factors:

1. **V1 Format May Be Deprecated**: The existence of V2 messages suggests V1 may be a legacy format no longer actively used
2. **No Attacker Control**: An unprivileged attacker cannot force V1 batch creation - this requires validator privileges
3. **Would Be Immediately Detected**: If V1 batches were still in use, this bug would cause immediate consensus failure and would have been caught during deployment

The bug exists in the code, but its exploitability is limited to the deprecation status of V1 batches.

## Recommendation

**Fix 1: Re-sign After Conversion** (Preferred)

Modify the `From<SignedBatchInfo<BatchInfo>> for SignedBatchInfo<BatchInfoExt>` implementation to re-sign with the validator's key:

```rust
impl From<SignedBatchInfo<BatchInfo>> for SignedBatchInfo<BatchInfoExt> {
    fn from(signed_batch_info: SignedBatchInfo<BatchInfo>) -> Self {
        // Do NOT reuse signature - this is the bug
        // Instead, this conversion should only be used after verification
        // and the batch should be re-signed if needed
        panic!("Invalid conversion - signatures cannot be reused between types");
    }
}
```

**Fix 2: Remove V1 Support Entirely**

If V1 batches are truly deprecated, remove all V1 code paths to eliminate the conversion entirely.

**Fix 3: Use Consistent Signing Type**

Always sign `BatchInfoExt` regardless of variant, never sign the unwrapped `BatchInfo`:

```rust
// In batch_store.rs, always sign the full BatchInfoExt
self.generate_signed_batch_info(batch_info).ok()
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a V1 batch (`BatchInfoExt::V1 { info }`)
2. Following the normal signing flow which signs the inner `BatchInfo`
3. Converting to `SignedBatchInfo<BatchInfoExt>` 
4. Attempting to aggregate multiple such signatures
5. Verifying the aggregated signature against `BatchInfoExt`
6. Observing verification failure due to hash seed mismatch

**Test Setup:**
```rust
// This would need to be added to consensus/src/quorum_store/tests/proof_coordinator_test.rs

#[tokio::test]
async fn test_v1_signature_verification_failure() {
    // Create V1 batch info
    let batch_info = BatchInfo::new(...);
    
    // Sign it (creates signature for BatchInfo)
    let signed_v1 = SignedBatchInfo::new(batch_info.clone(), &signer)?;
    
    // Convert to BatchInfoExt (signature now mismatched)
    let signed_v2: SignedBatchInfo<BatchInfoExt> = signed_v1.into();
    
    // Try to verify - this should FAIL
    assert!(signed_v2.verify(...).is_err());
}
```

## Notes

While this is a genuine cryptographic type safety violation in the codebase, its real-world impact depends entirely on whether V1 batches are still actively used in production. The bug does NOT meet the criteria for an exploitable vulnerability because:

1. It cannot be triggered by an unprivileged attacker
2. It appears to be a latent bug in deprecated code paths
3. If active, it would cause immediate system-wide failure (not selective attack)

The issue should be fixed to maintain code correctness, but may already be mitigated by V1 format deprecation.

### Citations

**File:** consensus/src/quorum_store/batch_store.rs (L515-521)
```rust
                if !batch_info.is_v2() {
                    self.generate_signed_batch_info(batch_info.info().clone())
                        .ok()
                        .map(|inner| inner.into())
                } else {
                    self.generate_signed_batch_info(batch_info).ok()
                }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L122-128)
```rust
                    let signed_batch_infos = signed_batch_infos
                        .into_iter()
                        .map(|sbi| sbi.try_into().expect("Batch must be V1 batch"))
                        .collect();
                    network_sender
                        .send_signed_batch_info_msg(signed_batch_infos, vec![peer_id])
                        .await;
```

**File:** consensus/src/round_manager.rs (L184-196)
```rust
            UnverifiedEvent::SignedBatchInfo(sd) => {
                if !self_message {
                    sd.verify(
                        peer_id,
                        max_num_batches,
                        max_batch_expiry_gap_usecs,
                        validator,
                    )?;
                    counters::VERIFY_MSG
                        .with_label_values(&["signed_batch"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::SignedBatchInfo(Box::new((*sd).into()))
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L505-518)
```rust
impl From<SignedBatchInfo<BatchInfo>> for SignedBatchInfo<BatchInfoExt> {
    fn from(signed_batch_info: SignedBatchInfo<BatchInfo>) -> Self {
        let SignedBatchInfo {
            info,
            signer,
            signature,
        } = signed_batch_info;
        Self {
            info: info.into(),
            signer,
            signature,
        }
    }
}
```

**File:** types/src/ledger_info.rs (L517-535)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L170-177)
```rust
pub fn signing_message<T: CryptoHash + Serialize>(
    message: &T,
) -> Result<Vec<u8>, CryptoMaterialError> {
    let mut bytes = <T::Hasher as CryptoHasher>::seed().to_vec();
    bcs::serialize_into(&mut bytes, &message)
        .map_err(|_| CryptoMaterialError::SerializationError)?;
    Ok(bytes)
}
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L387-413)
```rust
            fn new() -> Self {
                let name = aptos_crypto::_serde_name::trace_name::<#type_name #param>()
                    .expect("The `CryptoHasher` macro only applies to structs and enums");
                #hasher_name(
                    aptos_crypto::hash::DefaultHasher::new(&name.as_bytes()))
            }
        }

        static #static_hasher_name: aptos_crypto::_once_cell::sync::Lazy<#hasher_name> =
            aptos_crypto::_once_cell::sync::Lazy::new(|| #hasher_name::new());


        impl std::default::Default for #hasher_name
        {
            fn default() -> Self {
                #static_hasher_name.clone()
            }
        }

        impl aptos_crypto::hash::CryptoHasher for #hasher_name {
            fn seed() -> &'static [u8; 32] {
                #static_seed_name.get_or_init(|| {
                    let name = aptos_crypto::_serde_name::trace_name::<#type_name #param>()
                        .expect("The `CryptoHasher` macro only applies to structs and enums.").as_bytes();
                    aptos_crypto::hash::DefaultHasher::prefixed_hash(&name)
                })
            }
```
