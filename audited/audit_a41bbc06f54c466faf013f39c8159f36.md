# Audit Report

## Title
Unmetered Script Deserialization Allows Resource Exhaustion Before Dependency Gas Charging

## Summary
The `ScriptLoader::load_script()` implementation in the Move VM performs expensive script deserialization before charging gas for dependencies, allowing attackers to consume validator CPU resources without adequate gas payment. This violates the invariant that all computational operations must be properly metered.

## Finding Description

In the EagerLoader implementation, the `load_script()` function deserializes scripts before charging gas for their dependencies. The vulnerability exists in the execution order: [1](#0-0) 

The critical issue is at line 334 where `unmetered_deserialize_and_cache_script()` is called, performing the full deserialization of the script bytecode. This happens **before** the dependency gas charging at lines 338-343. The function name itself reveals the problem: it's "unmetered."

The deserialization process is computationally expensive, involving: [2](#0-1) [3](#0-2) 

The deserialization involves parsing binary tables, reading table contents, loading signatures, code units, and building the compiled script structure. All of this work is done without gas metering.

**Attack Path:**

1. Attacker submits a transaction with a script payload
2. Transaction passes prologue checks (transaction size within limits)
3. Intrinsic gas is charged based only on transaction size (bytes), not computational cost: [4](#0-3) 

4. The `load_script()` function is invoked
5. Script deserialization occurs (unmetered) - expensive CPU work
6. Only after deserialization, dependency gas is charged
7. If gas runs out during dependency charging, the transaction fails
8. But the expensive deserialization work has already consumed validator resources

The TODO comment at line 337 reveals developer awareness of incomplete gas metering:
```
// TODO(Gas): Should we charge dependency gas for the script itself?
```

**Invariant Violated:**

This breaks the critical invariant: "**Resource Limits**: All operations must respect gas, storage, and computational limits" and "**Move VM Safety**: Bytecode execution must respect gas limits and memory constraints."

The same vulnerability exists in the LazyLoader implementation: [5](#0-4) 

## Impact Explanation

This is a **Medium to High severity** vulnerability:

- **High Severity**: Per Aptos bug bounty criteria, "Validator node slowdowns" are High severity. An attacker can repeatedly submit transactions with scripts that have expensive deserialization characteristics (complex nested structures, large table counts, deep nesting) to slow down validators without paying proportionate gas.

- **Medium Severity**: This represents resource exhaustion without proper payment, allowing disproportionate consumption of validator CPU resources relative to gas paid.

The vulnerability enables:
1. **DoS Vector**: Repeated submissions of expensive-to-deserialize scripts
2. **Gas Metering Bypass**: Computational work performed without corresponding gas charges
3. **Validator Resource Exhaustion**: CPU cycles consumed before gas limits enforced
4. **Unfair Resource Allocation**: Attackers pay only for transaction size, not deserialization complexity

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity**: Low - attacker only needs to craft scripts with expensive deserialization
- **Privilege Required**: None - any user can submit script transactions
- **Repeatability**: High - attack can be executed repeatedly
- **Detection**: Difficult - appears as legitimate transaction submissions
- **Cost**: Minimal - attacker pays intrinsic gas based on size, not computational cost

Mitigating factors:
- Transaction size limits (MAX_TRANSACTION_SIZE) bound the maximum deserialization cost per transaction
- Script caching provides some defense against identical repeated submissions
- Intrinsic gas charging based on size provides partial mitigation

However, the fundamental issue remains: deserialization complexity can exceed what transaction size alone would predict, and attackers can vary script content to avoid caching.

## Recommendation

Implement metered deserialization by charging gas before or during the deserialization process:

**Option 1: Charge upfront gas based on serialized script size**
Add a gas charge proportional to the script size before deserialization:

```rust
fn load_script(
    &self,
    config: &LegacyLoaderConfig,
    gas_meter: &mut impl DependencyGasMeter,
    traversal_context: &mut TraversalContext,
    serialized_script: &[u8],
    ty_args: &[TypeTag],
) -> VMResult<LoadedFunction> {
    // Charge gas for script deserialization based on size
    gas_meter.charge_script_deserialization(serialized_script.len())?;
    
    if config.charge_for_dependencies {
        let compiled_script = self.unmetered_deserialize_and_cache_script(serialized_script)?;
        // ... rest of the code
    }
    // ...
}
```

**Option 2: Make deserialization metered**
Instrument the deserialization process itself to charge gas during parsing, though this is more complex as it requires modifying the binary format deserializer.

**Option 3: Increase intrinsic gas formula**
Adjust the intrinsic gas calculation to more heavily weight transaction size for script transactions, ensuring deserialization costs are adequately covered.

The fix should ensure that the TODO comment concern is addressed and script deserialization costs are properly accounted for in the gas schedule.

## Proof of Concept

```rust
// Proof of Concept: Create a script with expensive deserialization
// This demonstrates the vulnerability by showing how deserialization 
// happens before dependency gas charging

use move_binary_format::file_format::{
    CompiledScript, FunctionDefinition, Bytecode, CodeUnit, 
    SignatureToken, Signature, IdentifierIndex, ModuleHandleIndex
};
use move_core_types::identifier::Identifier;

// Create a script with many tables and complex structures
// that will be expensive to deserialize but may have few dependencies
fn create_expensive_script() -> Vec<u8> {
    let mut script = CompiledScript::default();
    
    // Add many module handles (potential dependencies)
    for i in 0..100 {
        script.module_handles.push(/* ... */);
    }
    
    // Add many function signatures with complex type parameters
    for i in 0..1000 {
        let sig = Signature(vec![
            SignatureToken::Vector(Box::new(
                SignatureToken::Vector(Box::new(
                    SignatureToken::Vector(Box::new(SignatureToken::U64))
                ))
            ))
        ]);
        script.signatures.push(sig);
    }
    
    // Add complex code unit
    script.code = CodeUnit {
        locals: Signature(vec![/* many local types */]),
        code: vec![/* many bytecode instructions */],
    };
    
    // Serialize the script
    let mut serialized = Vec::new();
    script.serialize(&mut serialized).unwrap();
    serialized
}

// Attack scenario:
// 1. Attacker creates transaction with expensive_script
// 2. Transaction size is within limits, passes prologue
// 3. Intrinsic gas charged based on size
// 4. load_script() called
// 5. Deserialization occurs (expensive CPU work, unmetered)
// 6. If gas runs out during dependency charging, transaction fails
// 7. But validator has already done expensive deserialization work
// 8. Repeat attack to cause sustained validator slowdown
```

## Notes

This vulnerability affects both the EagerLoader and LazyLoader implementations. The issue is architectural: deserialization is treated as a non-metered operation, when it should be considered part of the computational cost of executing a script transaction.

While transaction size limits and caching provide some mitigation, they do not fully address the fundamental problem that deserialization computational cost is not proportional to transaction size and is not metered. An attacker can craft scripts within size limits that have disproportionately expensive deserialization characteristics.

The presence of the TODO comment indicates this may be a known limitation that has not yet been addressed. Proper gas metering for all computational operations, including deserialization, is essential for maintaining the Move VM safety invariant and preventing resource exhaustion attacks.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L325-357)
```rust
    fn load_script(
        &self,
        config: &LegacyLoaderConfig,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        serialized_script: &[u8],
        ty_args: &[TypeTag],
    ) -> VMResult<LoadedFunction> {
        if config.charge_for_dependencies {
            let compiled_script = self.unmetered_deserialize_and_cache_script(serialized_script)?;
            let compiled_script = traversal_context.referenced_scripts.alloc(compiled_script);

            // TODO(Gas): Should we charge dependency gas for the script itself?
            check_dependencies_and_charge_gas(
                self.module_storage,
                gas_meter,
                traversal_context,
                compiled_script.immediate_dependencies_iter(),
            )?;
        }

        if config.charge_for_ty_tag_dependencies {
            check_type_tag_dependencies_and_charge_gas(
                self.module_storage,
                gas_meter,
                traversal_context,
                ty_args,
            )?;
        }

        let script = self.unmetered_verify_and_cache_script(serialized_script)?;
        self.build_instantiated_script(gas_meter, traversal_context, script, ty_args)
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L259-270)
```rust
    pub fn deserialize_into_script(&self, serialized_script: &[u8]) -> VMResult<CompiledScript> {
        CompiledScript::deserialize_with_config(
            serialized_script,
            &self.vm_config().deserializer_config,
        )
        .map_err(|err| {
            let msg = format!("[VM] deserializer for script returned error: {:?}", err);
            PartialVMError::new(StatusCode::CODE_DESERIALIZATION_ERROR)
                .with_message(msg)
                .finish(Location::Script)
        })
    }
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L427-468)
```rust
fn deserialize_compiled_script(
    binary: &[u8],
    config: &DeserializerConfig,
) -> BinaryLoaderResult<CompiledScript> {
    let binary_len = binary.len();
    let mut cursor = VersionedCursor::new(
        binary,
        config.max_binary_format_version,
        config.max_identifier_size,
    )?;
    let table_count = load_table_count(&mut cursor)?;
    let mut tables: Vec<Table> = Vec::new();
    read_tables(&mut cursor, table_count, &mut tables)?;
    let content_len = check_tables(&mut tables, binary_len)?;

    let mut table_contents_buffer = Vec::new();
    let table_contents = read_table_contents(
        &mut cursor,
        &mut table_contents_buffer,
        content_len as usize,
    )?;
    let type_parameters =
        load_ability_sets(&mut cursor, AbilitySetPosition::FunctionTypeParameters)?;
    let parameters = load_signature_index(&mut cursor)?;
    let access_specifiers = if cursor.version() >= VERSION_8 {
        load_access_specifiers(&mut cursor)?
    } else {
        None
    };
    let code = load_code_unit(&mut cursor)?;
    let mut script = CompiledScript {
        version: cursor.version(),
        type_parameters,
        parameters,
        access_specifiers,
        code,
        ..Default::default()
    };

    build_compiled_script(&mut script, &table_contents, &tables)?;
    Ok(script)
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1040-1060)
```rust
        gas_meter.charge_intrinsic_gas_for_transaction(txn_data.transaction_size())?;
        if txn_data.is_keyless() {
            gas_meter.charge_keyless()?;
        }
        if txn_data.is_slh_dsa_sha2_128s() {
            gas_meter.charge_slh_dsa_sha2_128s()?;
        }

        match executable {
            TransactionExecutableRef::Script(script) => {
                session.execute(|session| {
                    self.validate_and_execute_script(
                        session,
                        serialized_signers,
                        code_storage,
                        gas_meter,
                        traversal_context,
                        script,
                        trace_recorder,
                    )
                })?;
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L120-145)
```rust
    fn metered_verify_and_cache_script(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        serialized_script: &[u8],
    ) -> VMResult<Arc<Script>> {
        use Code::*;

        let hash = sha3_256(serialized_script);
        let deserialized_script = match self.module_storage.get_script(&hash) {
            Some(Verified(script)) => {
                // Before returning early, meter modules because script might have been cached by
                // other thread.
                for (addr, name) in script.immediate_dependencies_iter() {
                    let module_id = ModuleId::new(*addr, name.to_owned());
                    self.charge_module(gas_meter, traversal_context, &module_id)
                        .map_err(|err| err.finish(Location::Undefined))?;
                }
                return Ok(script);
            },
            Some(Deserialized(deserialized_script)) => deserialized_script,
            None => self
                .runtime_environment()
                .deserialize_into_script(serialized_script)
                .map(Arc::new)?,
        };
```
