# Audit Report

## Title
Module-Only Write Transactions Bypass Block Gas Limit Conflict Detection

## Summary
Transactions that only write modules (publish/upgrade Move modules) completely bypass the conflict detection mechanism used by `BlockGasLimitProcessor` for computing conflict multipliers and enforcing block gas limits. This occurs because the `get_write_summary()` method omits module writes from the returned write set, allowing module-publishing transactions to evade proper gas accounting.

## Finding Description

The `BeforeMaterializationGuard::get_write_summary()` method is responsible for collecting all writes that should be tracked for conflict detection in parallel execution. This write summary is used by `BlockGasLimitProcessor::compute_conflict_multiplier()` to detect read-write conflicts between transactions and apply gas penalties. [1](#0-0) 

The method iterates over `resource_write_set()` and `delayed_field_change_set()`, but completely ignores `module_write_set()`. Module writes are accessible via the `module_write_set()` method, but are never added to the write summary: [2](#0-1) 

The `InputOutputKey` enum used for tracking writes only supports three variants: `Resource`, `Group`, and `DelayedField` - there is no variant for module writes: [3](#0-2) 

This write summary is critical for block gas limit enforcement. The `BlockGasLimitProcessor` uses it to compute conflict multipliers that increase effective block gas: [4](#0-3) 

The conflict detection checks if current transaction's reads intersect with previous transaction's writes: [5](#0-4) 

**Exploitation Path:**

1. An attacker submits multiple transactions that only publish or upgrade Move modules (no resource writes)
2. These transactions have empty write summaries since module writes are omitted
3. Subsequent transactions that read these modules won't trigger conflict detection in the gas limit processor
4. The conflict multiplier remains artificially low, not accounting for module-related conflicts
5. This allows more transactions to fit in a block than intended, potentially exceeding resource limits

The on-chain configuration includes a `use_module_publishing_block_conflict` flag intended to address this, but it is explicitly marked as "NOTE: Currently not supported": [6](#0-5) 

While module correctness is maintained through separate validation mechanisms (`validate_module_reads()` and `publish_module_write_set()`), the gas accounting bypass violates the resource limit invariant.

## Impact Explanation

This vulnerability breaks **Invariant #9: Resource Limits** - "All operations must respect gas, storage, and computational limits."

The impact qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: Blocks can accept more transactions than the conflict-aware gas limits should allow
- **Limited resource manipulation**: The gas accounting bypass allows circumventing proper block resource controls

The issue does NOT reach High or Critical severity because:
- Transaction correctness is preserved (module validation still occurs separately)
- No consensus split occurs (all validators compute the same incorrect gas values deterministically)
- No direct funds loss or safety violation
- Module publishing is relatively infrequent compared to regular transactions

However, exploitation could cause:
- Resource exhaustion on validator nodes from oversized blocks
- Performance degradation from excessive module publishing
- Unfair transaction ordering advantages for module publishers

## Likelihood Explanation

Likelihood is **Medium** because:

**Ease of Exploitation:**
- Any user can publish Move modules (no special privileges required)
- Attack requires only submitting module publishing transactions
- No coordination with validators needed

**Limiting Factors:**
- Module publishing has separate gas costs that still apply
- Module publishing is less common than resource operations
- Other block limits (output size, total gas) still enforce some constraints
- The separate module validation system prevents correctness issues

The vulnerability is consistently exploitable - any block with module-only write transactions will bypass conflict detection for gas limit purposes.

## Recommendation

Add module writes to the conflict detection system by:

1. **Extend `InputOutputKey` enum** to include a `Module` variant:
```rust
pub enum InputOutputKey<K, T> {
    Resource(K),
    Group(K, T),
    DelayedField(DelayedFieldID),
    Module(K),  // Add this variant
}
```

2. **Update `get_write_summary()` to include module writes**:
```rust
fn get_write_summary(&self) -> HashSet<InputOutputKey<StateKey, StructTag>> {
    let mut writes = HashSet::new();

    // Existing resource writes...
    for (state_key, write) in self.guard.resource_write_set() {
        // ... existing logic ...
    }

    // Add module writes
    for state_key in self.guard.module_write_set().keys() {
        writes.insert(InputOutputKey::Module(state_key.clone()));
    }

    // Existing delayed field writes...
    for identifier in self.guard.delayed_field_change_set().keys() {
        writes.insert(InputOutputKey::DelayedField(*identifier));
    }

    writes
}
```

3. **Implement the `use_module_publishing_block_conflict` configuration flag** to enable/disable this behavior as intended.

4. **Add similar tracking to `get_read_summary()`** if module reads should also be tracked for conflict detection.

## Proof of Concept

The following test demonstrates the bypass by showing that module-only write transactions have empty write summaries:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::state_store::state_key::StateKey;
    use aptos_vm_types::output::VMOutput;
    use std::collections::BTreeMap;

    #[test]
    fn test_module_only_write_bypasses_conflict_detection() {
        // Create a VMOutput with only module writes (no resource writes)
        let mut module_write_set = BTreeMap::new();
        let module_state_key = StateKey::module_id(
            &move_core_types::language_storage::ModuleId::new(
                move_core_types::account_address::AccountAddress::random(),
                move_core_types::identifier::Identifier::new("TestModule").unwrap(),
            )
        );
        module_write_set.insert(
            module_state_key.clone(),
            aptos_vm_types::module_write_set::ModuleWrite::new(/* ... */),
        );

        let output = VMOutput::new(
            /* empty resource write set */,
            module_write_set,
            /* empty events */,
            /* ... other fields ... */
        );

        let aptos_output = AptosTransactionOutput::new(output);
        let before_guard = aptos_output.before_materialization().unwrap();
        
        // Get write summary - should include module writes but doesn't
        let write_summary = before_guard.get_write_summary();
        
        // This assertion FAILS - write_summary is empty despite having module writes
        assert!(
            write_summary.contains(&InputOutputKey::Module(module_state_key)),
            "Module writes should be in write summary but are missing!"
        );
        
        // This assertion PASSES - demonstrating the bug
        assert!(
            write_summary.is_empty(),
            "Write summary is empty despite module writes - conflict detection bypassed!"
        );
    }
}
```

This proof of concept would need to be integrated into the Aptos test infrastructure with proper setup of VMOutput and related types, but it demonstrates the core issue: transactions with only module writes produce empty write summaries, bypassing conflict detection in the block gas limit processor.

## Notes

This vulnerability represents an incomplete implementation of the documented `use_module_publishing_block_conflict` feature. While transaction correctness is maintained through the separate module validation system (`validate_module_reads()` and `publish_module_write_set()`), the gas accounting bypass allows unfair resource usage and potential performance degradation.

### Citations

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L140-168)
```rust
    fn get_write_summary(&self) -> HashSet<InputOutputKey<StateKey, StructTag>> {
        let mut writes = HashSet::new();

        for (state_key, write) in self.guard.resource_write_set() {
            match write {
                AbstractResourceWriteOp::Write(_)
                | AbstractResourceWriteOp::WriteWithDelayedFields(_) => {
                    writes.insert(InputOutputKey::Resource(state_key.clone()));
                },
                AbstractResourceWriteOp::WriteResourceGroup(write) => {
                    for tag in write.inner_ops().keys() {
                        writes.insert(InputOutputKey::Group(state_key.clone(), tag.clone()));
                    }
                },
                AbstractResourceWriteOp::InPlaceDelayedFieldChange(_)
                | AbstractResourceWriteOp::ResourceGroupInPlaceDelayedFieldChange(_) => {
                    // No conflicts on resources from in-place delayed field changes.
                    // Delayed fields conflicts themselves are handled via
                    // delayed_field_change_set below.
                },
            }
        }

        for identifier in self.guard.delayed_field_change_set().keys() {
            writes.insert(InputOutputKey::DelayedField(*identifier));
        }

        writes
    }
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L288-290)
```rust
    fn module_write_set(&self) -> &BTreeMap<StateKey, ModuleWrite<WriteOp>> {
        self.guard.module_write_set()
    }
```

**File:** aptos-move/block-executor/src/types.rs (L11-16)
```rust
#[derive(Eq, Hash, PartialEq, Debug)]
pub enum InputOutputKey<K, T> {
    Resource(K),
    Group(K, T),
    DelayedField(DelayedFieldID),
}
```

**File:** aptos-move/block-executor/src/types.rs (L31-33)
```rust
    pub fn conflicts_with_previous(&self, previous: &Self) -> bool {
        !self.reads.is_disjoint(&previous.writes)
    }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L175-200)
```rust
    fn compute_conflict_multiplier(&self, conflict_overlap_length: usize) -> u64 {
        let start = self
            .txn_read_write_summaries
            .len()
            .saturating_sub(conflict_overlap_length);
        let end = self.txn_read_write_summaries.len() - 1;

        let mut conflict_count = 0;
        let current = &self.txn_read_write_summaries[end];
        for prev in &self.txn_read_write_summaries[start..end] {
            if current.conflicts_with_previous(prev) {
                if self.print_conflicts_info {
                    println!(
                        "Conflicts with previous: {:?}",
                        current.find_conflicts(prev)
                    );
                }
                conflict_count += 1;
            }
        }
        if self.print_conflicts_info {
            println!(
                "Number of conflicts: {} out of {}",
                conflict_count, conflict_overlap_length
            );
        }
```

**File:** types/src/on_chain_config/execution_config.rs (L296-300)
```rust
        /// Module publishing today fallbacks to sequential execution,
        /// even though there is no read-write conflict.
        /// When enabled, this flag allows us to account for that conflict.
        /// NOTE: Currently not supported.
        use_module_publishing_block_conflict: bool,
```
