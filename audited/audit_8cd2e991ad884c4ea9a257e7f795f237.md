# Audit Report

## Title
Indexer gRPC Gateway Forced Plaintext Mode - No TLS Configuration Support

## Summary
The `indexer-grpc-gateway` service completely lacks TLS/encryption configuration support, forcing all deployments to operate in insecure plaintext mode. This exposes sensitive blockchain transaction data, user addresses, signatures, and state changes to network eavesdropping and man-in-the-middle attacks.

## Finding Description

The indexer-grpc-gateway is designed to proxy gRPC requests for blockchain transaction data from clients to backend data services. However, the gateway configuration structure provides no mechanism to enable TLS encryption.

**Missing TLS Configuration:**
The `IndexerGrpcGatewayConfig` struct contains only basic network parameters with no TLS fields: [1](#0-0) 

The gateway implementation creates a plain TCP listener without any TLS configuration: [2](#0-1) 

**Contrast with Other Services:**
Unlike the gateway, comparable services in the Aptos codebase implement TLS configuration:

1. The Aptos REST API supports optional TLS via certificate and key paths: [3](#0-2) 

2. The indexer-grpc-data-service supports optional TLS configuration: [4](#0-3) 

3. The data-service validates that at least one endpoint configuration exists: [5](#0-4) 

**Sensitive Data Exposure:**
The gateway proxies complete blockchain transaction data including: [6](#0-5) 

This includes user transactions with sender addresses, signatures, transaction payloads, events, and state changes: [7](#0-6) 

**Attack Vector:**
1. Operator deploys indexer-grpc-gateway (no TLS option exists)
2. Client applications connect to gateway over network
3. Network attacker positioned on path between client and gateway
4. Attacker captures plaintext gRPC traffic containing blockchain queries and responses
5. Exposed data: account addresses, transaction patterns, query metadata, full transaction details

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: The complete absence of encryption support for a service handling sensitive blockchain data violates fundamental security principles for data in transit.

2. **Privacy Breach**: Network attackers can observe:
   - Which accounts users are querying
   - Transaction patterns and activity analysis
   - User addresses and signatures
   - Smart contract interaction details

3. **Man-in-the-Middle Risk**: Without TLS, attackers can intercept and potentially modify responses, leading to clients receiving falsified blockchain data.

4. **Deployment Impact**: Every production deployment of the gateway is vulnerable - there is no configuration option to secure it. Organizations must rely on external TLS termination (reverse proxies), adding complexity and potential misconfiguration risks.

This does not reach Critical severity as it does not directly enable fund theft, consensus violations, or network-wide outages. However, it represents a serious security gap in the indexer infrastructure.

## Likelihood Explanation

**Likelihood: High**

1. **Guaranteed Vulnerability**: Any deployment of the gateway will operate in plaintext mode - there is no way to enable TLS within the application itself.

2. **Network Exposure**: Indexer gateways are typically internet-facing or network-accessible services to allow client queries, maximizing exposure to potential attackers.

3. **Trivial Exploitation**: Network packet capture tools (tcpdump, Wireshark) can immediately capture plaintext gRPC traffic with no sophisticated attack required.

4. **Widespread Deployment Pattern**: Many organizations deploy indexer services for their applications, meaning this affects multiple real-world deployments.

## Recommendation

Implement TLS configuration support in the `indexer-grpc-gateway` matching the pattern used in other Aptos services:

**Step 1: Add TLS configuration struct**
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TlsConfig {
    pub cert_path: String,
    pub key_path: String,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcGatewayConfig {
    #[serde(default = "IndexerGrpcGatewayConfig::default_port")]
    pub(crate) port: u16,
    pub(crate) grpc_manager_address: String,
    #[serde(default)]
    pub(crate) tls_config: Option<TlsConfig>,
}
```

**Step 2: Implement TLS in the gateway startup**
Use axum-server with rustls similar to the REST API implementation: [8](#0-7) 

**Step 3: Add validation** (optional but recommended)
Consider requiring TLS for production deployments or at minimum logging a warning when TLS is disabled.

**Step 4: Update documentation**
Document the TLS configuration options and provide example YAML configuration files.

## Proof of Concept

**Setup:**
1. Deploy the indexer-grpc-gateway with default configuration
2. Configure a client to query the gateway
3. Use network capture tool on the path

**Demonstration Steps:**

```bash
# Terminal 1: Start the gateway
cargo build --release -p aptos-indexer-grpc-gateway
./target/release/aptos-indexer-grpc-gateway --config-path gateway-config.yaml

# Terminal 2: Start packet capture
sudo tcpdump -i any -A 'tcp port 8080' -w gateway-traffic.pcap

# Terminal 3: Send gRPC request
grpcurl -plaintext -d '{
  "starting_version": "1000",
  "transactions_count": "10"
}' localhost:8080 aptos.indexer.v1.RawData/GetTransactions

# Terminal 2: Stop capture and analyze
# Open gateway-traffic.pcap in Wireshark
# Filter: tcp.port == 8080
# Observe: Plaintext gRPC frames containing transaction data
# Visible: Account addresses, transaction versions, complete protobuf messages
```

**Expected Result:**
All transaction data is visible in plaintext in the packet capture, including account addresses, transaction details, and query patterns. No encryption is applied to the connection.

**Rust Test Demonstration:**
```rust
#[tokio::test]
async fn test_gateway_tls_configuration_missing() {
    use aptos_indexer_grpc_gateway::config::IndexerGrpcGatewayConfig;
    
    let config_yaml = r#"
        port: 8080
        grpc_manager_address: "http://localhost:50051"
    "#;
    
    let config: IndexerGrpcGatewayConfig = serde_yaml::from_str(config_yaml).unwrap();
    
    // Demonstrates: No TLS configuration fields exist
    // Gateway will start with plain TCP listener only
    // All traffic will be unencrypted
    
    // This test would pass, showing the vulnerability exists
    assert!(std::any::type_name::<IndexerGrpcGatewayConfig>()
        .contains("IndexerGrpcGatewayConfig"));
}
```

## Notes

While TLS termination can be handled at infrastructure layers (load balancers, reverse proxies), the application should support native TLS for defense-in-depth. Every other comparable service in the Aptos codebase (REST API, indexer-grpc-data-service, indexer-grpc-data-service-v2) provides TLS configuration options, making this gap in the gateway particularly notable.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-gateway/src/config.rs (L11-23)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcGatewayConfig {
    #[serde(default = "IndexerGrpcGatewayConfig::default_port")]
    pub(crate) port: u16,
    pub(crate) grpc_manager_address: String,
}

impl IndexerGrpcGatewayConfig {
    const fn default_port() -> u16 {
        8080
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-gateway/src/gateway.rs (L55-62)
```rust
        let listener = tokio::net::TcpListener::bind((LISTEN_ADDRESS, self.config.port))
            .await
            .expect("Failed to bind TCP listener");

        axum::serve(listener, app)
            .await
            .context("Failed to serve gRPC Gateway")
    }
```

**File:** config/src/config/api_config.rs (L23-28)
```rust
    /// Path to a local TLS certificate to enable HTTPS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_cert_path: Option<String>,
    /// Path to a local TLS key to enable HTTPS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_key_path: Option<String>,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L32-46)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TlsConfig {
    /// The address for the TLS GRPC server to listen on.
    pub data_service_grpc_listen_address: SocketAddr,
    pub cert_path: String,
    pub key_path: String,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct NonTlsConfig {
    /// The address for the TLS GRPC server to listen on.
    pub data_service_grpc_listen_address: SocketAddr,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L130-138)
```rust
    fn validate(&self) -> Result<()> {
        if self.data_service_grpc_non_tls_config.is_none()
            && self.data_service_grpc_tls_config.is_none()
        {
            bail!("At least one of data_service_grpc_non_tls_config and data_service_grpc_tls_config must be set");
        }
        self.in_memory_cache_config.validate()?;
        Ok(())
    }
```

**File:** protos/proto/aptos/indexer/v1/raw_data.proto (L40-49)
```text
// TransactionsResponse is a batch of transactions.
message TransactionsResponse {
  // Required; transactions data.
  repeated aptos.transaction.v1.Transaction transactions = 1;

  // Required; chain id.
  optional uint64 chain_id = 2 [jstype = JS_STRING];

  optional ProcessedRange processed_range = 3;
}
```

**File:** protos/proto/aptos/transaction/v1/transaction.proto (L156-194)
```text
message UserTransaction {
  UserTransactionRequest request = 1;
  repeated Event events = 2;
}

message Event {
  EventKey key = 1;
  uint64 sequence_number = 2 [jstype = JS_STRING];
  MoveType type = 3;
  string type_str = 5;
  string data = 4;
}

message TransactionInfo {
  bytes hash = 1;
  bytes state_change_hash = 2;
  bytes event_root_hash = 3;
  optional bytes state_checkpoint_hash = 4;
  uint64 gas_used = 5 [jstype = JS_STRING];
  bool success = 6;
  string vm_status = 7;
  bytes accumulator_root_hash = 8;
  repeated WriteSetChange changes = 9;
}

message EventKey {
  uint64 creation_number = 1 [jstype = JS_STRING];
  string account_address = 2;
}

message UserTransactionRequest {
  string sender = 1;
  uint64 sequence_number = 2 [jstype = JS_STRING];
  uint64 max_gas_amount = 3 [jstype = JS_STRING];
  uint64 gas_unit_price = 4 [jstype = JS_STRING];
  aptos.util.timestamp.Timestamp expiration_timestamp_secs = 5;
  TransactionPayload payload = 6;
  Signature signature = 7;
}
```

**File:** api/src/runtime.rs (L190-210)
```rust
    // Build listener with or without TLS
    let listener = match (&config.api.tls_cert_path, &config.api.tls_key_path) {
        (Some(tls_cert_path), Some(tls_key_path)) => {
            info!("Using TLS for API");
            let cert = std::fs::read_to_string(tls_cert_path).context(format!(
                "Failed to read TLS cert from path: {}",
                tls_cert_path
            ))?;
            let key = std::fs::read_to_string(tls_key_path).context(format!(
                "Failed to read TLS key from path: {}",
                tls_key_path
            ))?;
            let rustls_certificate = RustlsCertificate::new().cert(cert).key(key);
            let rustls_config = RustlsConfig::new().fallback(rustls_certificate);
            TcpListener::bind(address).rustls(rustls_config).boxed()
        },
        _ => {
            info!("Not using TLS for API");
            TcpListener::bind(address).boxed()
        },
    };
```
