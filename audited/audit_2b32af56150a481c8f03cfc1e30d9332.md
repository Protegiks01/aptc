# Audit Report

## Title
Path Traversal in OnDiskStorageConfig Allows Consensus Key Exfiltration via Malicious Configuration

## Summary
The `OnDiskStorageConfig::path()` function does not call `canonicalize()` to resolve path traversal sequences (`..`) or symlinks, allowing an attacker who can modify the validator configuration file to escape the intended `data_dir` containment and write consensus private keys to arbitrary filesystem locations or read from unintended locations. [1](#0-0) 

## Finding Description

The vulnerability exists in the path resolution logic for OnDiskStorage secure backend configuration. When a relative path is configured, the function simply joins it with `data_dir` using `PathBuf::join()` without canonicalizing the result: [1](#0-0) 

This allows path traversal because:
1. The configuration file is deserialized from YAML with user-controlled `path` field
2. If `path` contains `..` components (e.g., `"../../tmp/exfiltrate.json"`), the join operation produces paths like `/opt/aptos/data/../../tmp/exfiltrate.json`
3. When this path is used by the OS to create/open files, it resolves to `/opt/tmp/exfiltrate.json`, escaping `data_dir`

The vulnerability affects the storage of critical consensus data:
- **CONSENSUS_KEY**: BLS private key for block signing [2](#0-1) 
- **SAFETY_DATA**: Epoch, last_voted_round, preferred_round [3](#0-2) 
- **WAYPOINT**: State synchronization checkpoints [4](#0-3) 

The attack flow:
1. Attacker modifies validator configuration YAML to set malicious path [5](#0-4) 
2. Configuration is loaded and storage path is resolved [6](#0-5) 
3. SafetyRules initializes and writes consensus key to traversed path [7](#0-6) 
4. Consensus private key is written to attacker-controlled location [8](#0-7) 

## Impact Explanation

**This does NOT meet the severity criteria for the Aptos bug bounty program.**

While the technical vulnerability exists (lack of path canonicalization), exploitation requires the ability to modify the validator's configuration YAML file. According to the defined trust model, validator operators are trusted actors. An attacker with write access to configuration files already possesses privileges equivalent to or exceeding what this vulnerability provides:

- Direct filesystem access to read consensus keys from their intended location
- Ability to modify other critical configuration parameters
- Potential to execute arbitrary code through other configuration vectors

The Aptos bug bounty program focuses on vulnerabilities "exploitable by unprivileged attacker (no validator insider access required)". This vulnerability requires configuration file write access, which falls under validator operator privileges (a trusted role).

Potential scenarios where this could matter (defense-in-depth):
- Compromised CI/CD pipeline injecting malicious configs
- Insider threat with limited access
- Supply chain attacks on configuration templates

However, these scenarios involve trusted actor compromise, which is explicitly excluded from the threat model.

## Likelihood Explanation

**LOW** - Exploitation requires:
1. Write access to validator configuration files (trusted operation)
2. Node restart to load malicious configuration
3. Attacker-readable destination for key exfiltration OR symlink setup

The attacker must already have significant access to the validator infrastructure, making this a defense-in-depth issue rather than a primary vulnerability.

## Recommendation

Implement path canonicalization to prevent directory traversal:

```rust
pub fn path(&self) -> PathBuf {
    let resolved_path = if self.path.is_relative() {
        self.data_dir.join(&self.path)
    } else {
        self.path.clone()
    };
    
    // Canonicalize to resolve .. and symlinks
    match resolved_path.canonicalize() {
        Ok(canonical) => {
            // Verify the canonical path is still within data_dir
            if !canonical.starts_with(&self.data_dir) {
                panic!("Secure storage path escapes data_dir: {:?}", canonical);
            }
            canonical
        },
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
            // File doesn't exist yet - validate parent directory
            if let Some(parent) = resolved_path.parent() {
                if let Ok(canonical_parent) = parent.canonicalize() {
                    if !canonical_parent.starts_with(&self.data_dir) {
                        panic!("Secure storage path escapes data_dir");
                    }
                }
            }
            resolved_path
        },
        Err(e) => panic!("Failed to canonicalize storage path: {}", e),
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_path_traversal_vulnerability() {
    use std::path::PathBuf;
    use crate::config::OnDiskStorageConfig;
    
    let mut config = OnDiskStorageConfig {
        path: PathBuf::from("../../tmp/malicious.json"),
        namespace: None,
        data_dir: PathBuf::from("/opt/aptos/data"),
    };
    
    let resolved = config.path();
    println!("Resolved path: {:?}", resolved);
    // Output: "/opt/aptos/data/../../tmp/malicious.json"
    // When used by OS, resolves to: "/opt/tmp/malicious.json"
    
    // This escapes the intended data_dir containment
    assert!(!resolved.starts_with("/opt/aptos/data"));
}
```

## Notes

**After strict validation against the checklist, this does NOT qualify as a valid vulnerability for the bug bounty program** because it requires validator operator privileges (configuration file write access), which is a trusted role in the defined threat model. The technical flaw exists, but the attack scenario falls outside the scope of external attacker exploitation without privileged access.

This is a defense-in-depth hardening opportunity rather than an exploitable vulnerability under the current trust assumptions.

### Citations

**File:** config/src/config/secure_backend_config.rs (L140-146)
```rust
    pub fn path(&self) -> PathBuf {
        if self.path.is_relative() {
            self.data_dir.join(&self.path)
        } else {
            self.path.clone()
        }
    }
```

**File:** config/src/config/secure_backend_config.rs (L162-195)
```rust
impl From<&SecureBackend> for Storage {
    fn from(backend: &SecureBackend) -> Self {
        match backend {
            SecureBackend::InMemoryStorage => Storage::from(InMemoryStorage::new()),
            SecureBackend::OnDiskStorage(config) => {
                let storage = Storage::from(OnDiskStorage::new(config.path()));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
            SecureBackend::Vault(config) => {
                let storage = Storage::from(VaultStorage::new(
                    config.server.clone(),
                    config.token.read_token().expect("Unable to read token"),
                    config
                        .ca_certificate
                        .as_ref()
                        .map(|_| config.ca_certificate().unwrap()),
                    config.renew_ttl_secs,
                    config.disable_cas.map_or_else(|| true, |disable| !disable),
                    config.connection_timeout_ms,
                    config.response_timeout_ms,
                ));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
        }
    }
}
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L68-68)
```rust
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L150-169)
```rust
    pub fn set_safety_data(&mut self, data: SafetyData) -> Result<(), Error> {
        let _timer = counters::start_timer("set", SAFETY_DATA);
        counters::set_state(counters::EPOCH, data.epoch as i64);
        counters::set_state(counters::LAST_VOTED_ROUND, data.last_voted_round as i64);
        counters::set_state(
            counters::HIGHEST_TIMEOUT_ROUND,
            data.highest_timeout_round as i64,
        );
        counters::set_state(counters::PREFERRED_ROUND, data.preferred_round as i64);

        match self.internal_store.set(SAFETY_DATA, data.clone()) {
            Ok(_) => {
                self.cached_safety_data = Some(data);
                Ok(())
            },
            Err(error) => {
                self.cached_safety_data = None;
                Err(Error::SecureStorageUnexpectedError(error.to_string()))
            },
        }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L172-185)
```rust
    pub fn waypoint(&self) -> Result<Waypoint, Error> {
        let _timer = counters::start_timer("get", WAYPOINT);
        Ok(self.internal_store.get(WAYPOINT).map(|v| v.value)?)
    }

    pub fn set_waypoint(&mut self, waypoint: &Waypoint) -> Result<(), Error> {
        let _timer = counters::start_timer("set", WAYPOINT);
        counters::set_state(counters::WAYPOINT_VERSION, waypoint.version() as i64);
        self.internal_store.set(WAYPOINT, waypoint)?;
        info!(
            logging::SafetyLogSchema::new(LogEntry::Waypoint, LogEvent::Update).waypoint(*waypoint)
        );
        Ok(())
    }
```

**File:** docker/compose/aptos-node/validator.yaml (L11-13)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L21-26)
```rust
pub fn storage(config: &SafetyRulesConfig) -> PersistentSafetyStorage {
    let backend = &config.backend;
    let internal_storage: Storage = backend.into();
    if let Err(error) = internal_storage.available() {
        panic!("Storage is not available: {:?}", error);
    }
```

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```
