# Audit Report

## Title
Payload Empty Check Bypass Leading to Premature Block Proposal with Zero-Transaction Batches

## Summary
A semantic inconsistency exists between `Payload::is_empty()` and `Payload::len()` methods in the Aptos consensus layer. The `is_empty()` method checks whether container vectors are empty rather than whether the actual transaction count is zero. This allows Byzantine validators to exploit the retry mechanism in `QuorumStoreClient::pull()` by broadcasting batches with zero transactions that pass all validation checks, forcing premature block proposals and degrading network throughput.

## Finding Description

The vulnerability stems from a design inconsistency in how payload emptiness is evaluated versus actual transaction content.

**Core Issue:**

The retry logic in `QuorumStoreClient::pull()` uses `payload.is_empty()` to determine whether to continue polling for transactions: [1](#0-0) 

However, the `Payload::is_empty()` implementation checks container emptiness, not transaction count: [2](#0-1) 

For `QuorumStoreInlineHybrid` payloads, `is_empty()` returns `false` if either the `proofs` vector or `inline_batches` vector contains elements, regardless of whether those elements contain zero transactions. In contrast, the `len()` method correctly counts transactions: [3](#0-2) 

**Attack Scenario:**

1. A Byzantine validator crafts a `Batch` with `num_txns = 0` and broadcasts it via `BatchMsg`

2. The batch passes validation in `ensure_max_limits()` because `0 <= max_batch_txns` is always true: [4](#0-3) 

3. The `Batch::verify()` method validates that the payload matches batch info but does not enforce `num_txns > 0`: [5](#0-4) 

4. Honest validators receive the batch and sign it without additional validation: [6](#0-5) 

5. The Byzantine validator collects signatures (2f+1 voting power) to create a certified `ProofOfStore` with `num_txns = 0`

6. When `ProofManager::handle_proposal_request()` constructs the payload, the proof is included because `proof_block.is_empty()` returns `false` (the vector contains one element): [7](#0-6) 

7. The retry loop exits immediately because `payload.is_empty()` returns `false`, bypassing the intended 30ms wait mechanism that allows transactions to accumulate: [8](#0-7) 

**Security Guarantee Violated:**

The system's intended behavior is to wait for non-empty payloads (as evidenced by the comment "keep polling QuorumStore until there's payloads available"). However, a payload with proof containers but zero transactions bypasses this mechanism, creating a semantic inconsistency between container structure and actual content.

## Impact Explanation

This vulnerability is classified as **Medium Severity** under the Aptos bug bounty program for the following reasons:

**Qualifies as "Limited Protocol Violations" (Medium):**
- Creates a semantic inconsistency between the system's expectation (waiting for transactions) and actual behavior (accepting zero-transaction payloads)
- Byzantine validators can force premature block proposals with zero user transactions
- Reduces network throughput when transactions may become available within the polling window

**Does NOT qualify for Higher Severity:**
- **Not Critical**: No consensus safety violationsâ€”empty blocks are valid in the AptosBFT protocol
- **Not Critical**: No loss of funds or unlimited minting capabilities
- **Not Critical**: No permanent network partition or complete liveness failure
- **Not High**: Does not cause validator node slowdowns or API crashes

The impact is limited to performance degradation through reduced throughput, fitting the "state inconsistencies requiring manual intervention" and "limited protocol violations" categories defined for Medium severity.

## Likelihood Explanation

**Likelihood: Medium-High**

The exploit can be triggered with the following characteristics:

**Requirements:**
- At least one Byzantine validator (< 1/3 Byzantine is within the AptosBFT threat model)
- No special network conditions or timing windows required
- Can be executed during normal network operation

**Feasibility:**
- All validation logic permits `num_txns = 0` batches
- Honest validators will sign empty batches during normal protocol operation (no minimum transaction check exists)
- Byzantine validator only needs to collect 2f+1 signatures, which follows standard consensus mechanisms
- Can be sustained repeatedly to cause persistent throughput degradation

**Barriers:**
- Requires control of a validator node
- Within the stated AptosBFT Byzantine fault tolerance assumptions

The barrier is low once a Byzantine actor controls a validator node, making this exploitable within the protocol's threat model.

## Recommendation

**Fix 1: Add Minimum Transaction Check in `is_empty()`**

Modify `Payload::is_empty()` to check actual transaction count:

```rust
pub fn is_empty(&self) -> bool {
    self.len() == 0
}
```

**Fix 2: Add Validation for Zero-Transaction Batches**

Add a check in `BatchCoordinator::ensure_max_limits()` to reject batches with zero transactions:

```rust
fn ensure_max_limits(&self, batches: &[Batch<BatchInfoExt>]) -> anyhow::Result<()> {
    let mut total_txns = 0;
    let mut total_bytes = 0;
    for batch in batches.iter() {
        ensure!(
            batch.num_txns() > 0,
            "Batch must contain at least one transaction"
        );
        // ... rest of validation
    }
    // ...
}
```

**Fix 3: Prevent Signing Empty Batches**

Add a check in `BatchStore::persist_inner()` before generating signatures:

```rust
fn persist_inner(&self, batch_info: BatchInfoExt, persist_request: PersistedValue<BatchInfoExt>) -> Option<SignedBatchInfo<BatchInfoExt>> {
    if batch_info.num_txns() == 0 {
        debug!("Rejecting batch with zero transactions");
        return None;
    }
    // ... rest of method
}
```

The recommended approach is Fix 1, as it addresses the semantic inconsistency at its root cause and ensures `is_empty()` accurately reflects the intended meaning throughout the codebase.

## Proof of Concept

The following demonstrates the vulnerability through the actual code paths:

```rust
// 1. Byzantine validator creates batch with 0 transactions
let batch_info = BatchInfo::new(
    byzantine_peer_id,
    batch_id,
    epoch,
    expiration,
    empty_payload_digest,
    0, // num_txns = 0
    minimal_bytes,
    gas_bucket_start,
);

// 2. Batch passes ensure_max_limits validation (0 <= max_batch_txns)
// 3. Batch passes Batch::verify() (no num_txns > 0 check)
// 4. Honest validators sign it via BatchStore::persist_inner()
// 5. Byzantine collects 2f+1 signatures to create ProofOfStore

// 6. When proposer calls pull():
let payload = client.pull(params).await?;

// payload.is_empty() returns false (proofs vector has 1 element)
// but payload.len() returns 0 (zero transactions)

// 7. Retry loop exits immediately instead of waiting for transactions:
// if payload.is_empty() && !return_empty && !done {
//     sleep(Duration::from_millis(30)).await;
//     continue;  // This is bypassed!
// }
```

The exploit demonstrates that a payload with one proof containing zero transactions has `is_empty() = false` but `len() = 0`, bypassing the retry mechanism and forcing immediate block proposal.

## Notes

**Additional Context:**

1. Honest validators explicitly prevent creating zero-transaction batches in their batch generation logic: [9](#0-8) 

2. However, this protection only applies to local batch creation, not to validation of received batches from Byzantine peers.

3. The vulnerability exploits a design assumption that "non-empty containers imply non-empty content," which breaks when Byzantine validators craft malicious inputs.

4. The retry delay constant is 30ms (`NO_TXN_DELAY`), so the performance impact per exploited block is bounded but can accumulate over sustained attacks.

### Citations

**File:** consensus/src/payload_client/user/quorum_store_client.rs (L106-128)
```rust
        // keep polling QuorumStore until there's payloads available or there's still pending payloads
        let start_time = Instant::now();

        let payload = loop {
            // Make sure we don't wait more than expected, due to thread scheduling delays/processing time consumed
            let done = start_time.elapsed() >= params.max_poll_time;
            let payload = self
                .pull_internal(
                    params.max_txns,
                    params.max_txns_after_filtering,
                    params.soft_max_txns_after_filtering,
                    params.max_inline_txns,
                    params.maybe_optqs_payload_pull_params.clone(),
                    return_non_full || return_empty || done,
                    params.user_txn_filter.clone(),
                    params.block_timestamp,
                )
                .await?;
            if payload.is_empty() && !return_empty && !done {
                sleep(Duration::from_millis(NO_TXN_DELAY)).await;
                continue;
            }
            break payload;
```

**File:** consensus/consensus-types/src/common.rs (L292-299)
```rust
            Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _)
            | Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _) => {
                proof_with_data.num_txns()
                    + inline_batches
                        .iter()
                        .map(|(_, txns)| txns.len())
                        .sum::<usize>()
            },
```

**File:** consensus/consensus-types/src/common.rs (L342-355)
```rust
    pub fn is_empty(&self) -> bool {
        match self {
            Payload::DirectMempool(txns) => txns.is_empty(),
            Payload::InQuorumStore(proof_with_status) => proof_with_status.proofs.is_empty(),
            Payload::InQuorumStoreWithLimit(proof_with_status) => {
                proof_with_status.proof_with_data.proofs.is_empty()
            },
            Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _)
            | Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _) => {
                proof_with_data.proofs.is_empty() && inline_batches.is_empty()
            },
            Payload::OptQuorumStore(opt_qs_payload) => opt_qs_payload.is_empty(),
        }
    }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L141-146)
```rust
            ensure!(
                batch.num_txns() <= self.max_batch_txns,
                "Exceeds batch txn limit {} > {}",
                batch.num_txns(),
                self.max_batch_txns,
            );
```

**File:** consensus/src/quorum_store/types.rs (L262-279)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        ensure!(
            self.payload.author() == self.author(),
            "Payload author doesn't match the info"
        );
        ensure!(
            self.payload.hash() == *self.digest(),
            "Payload hash doesn't match the digest"
        );
        ensure!(
            self.payload.num_txns() as u64 == self.num_txns(),
            "Payload num txns doesn't match batch info"
        );
        ensure!(
            self.payload.num_bytes() as u64 == self.num_bytes(),
            "Payload num bytes doesn't match batch info"
        );
        for txn in self.payload.txns() {
```

**File:** consensus/src/quorum_store/batch_store.rs (L474-486)
```rust
    fn generate_signed_batch_info<T: TBatchInfo>(
        &self,
        batch_info: T,
    ) -> Result<SignedBatchInfo<T>, CryptoMaterialError> {
        fail_point!("quorum_store::create_invalid_signed_batch_info", |_| {
            Ok(SignedBatchInfo::new_with_signature(
                batch_info.clone(),
                self.validator_signer.author(),
                aptos_crypto::bls12381::Signature::dummy_signature(),
            ))
        });
        SignedBatchInfo::new(batch_info, &self.validator_signer)
    }
```

**File:** consensus/src/quorum_store/proof_manager.rs (L213-214)
```rust
        } else if proof_block.is_empty() && inline_block.is_empty() {
            Payload::empty(true, self.allow_batches_without_pos_in_proposal)
```

**File:** consensus/src/quorum_store/batch_generator.rs (L245-251)
```rust
            if num_batch_txns > 0 {
                let batch_txns: Vec<_> = txns.drain(0..num_batch_txns).collect();
                let batch = self.create_new_batch(batch_txns, expiry_time, bucket_start);
                batches.push(batch);
                *total_batches_remaining = total_batches_remaining.saturating_sub(1);
                txns_remaining -= num_batch_txns;
            }
```
