# Audit Report

## Title
Non-Atomic State Reads in DbStateView Leading to Proof Verification Bypass

## Summary
The `DbStateView::get()` function performs two separate, non-atomic database reads: one to fetch and verify a Merkle proof, and another to fetch the actual value. If concurrent pruning occurs between these reads, the returned value may differ from the cryptographically verified value, violating state consistency guarantees.

## Finding Description

In the `DbStateView::get()` function, proof verification and value retrieval are performed as separate, non-atomic operations: [1](#0-0) 

The execution flow is:
1. **First DB operation** (line 35): `get_state_value_with_proof_by_version(key, version)` queries both StateMerkleDb and StateKvDb, returning a value and cryptographic proof
2. **Proof verification** (line 37): The proof is verified against the state root hash
3. **Second DB operation** (line 42): `get_state_value_with_version_by_version(key, version)` queries StateKvDb again for the same key/version

These operations are not wrapped in a transaction or RocksDB snapshot. The StateKvPruner runs concurrently in a background thread: [2](#0-1) 

The pruner can delete historical versions without coordination with concurrent readers. If pruning occurs between the two reads in `get()`:

**Scenario 1 - Value Deletion:**
- First read: Successfully fetches value at version V, proof verification succeeds ✓
- *Pruning deletes version V*
- Second read: Returns `None` or fails

**Scenario 2 - Version Skipping:**
The `get_state_value_with_version_by_version` implementation uses a seek operation that returns the latest version ≤ requested version: [3](#0-2) 

If the exact version is pruned but an older version remains:
- First read: Verifies value at version V (or version X ≤ V found in Merkle tree)
- *Pruning deletes version X*
- Second read: Returns value from version Y where Y < X ≤ V
- **Result:** The returned value was never cryptographically verified

This violates the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." The Merkle proof verification becomes meaningless when the returned value can differ from the verified value.

## Impact Explanation

This vulnerability can cause **consensus disagreement** between validators:

1. **Deterministic Execution Violation**: Different validators reading the same state key at the same version might receive different values if pruning occurs at slightly different times across nodes. This breaks the fundamental requirement that "all validators must produce identical state roots for identical blocks."

2. **State Inconsistency**: DbStateView is used as the state backend during transaction execution (via the `TStateView` trait implementation at lines 49-75). If transaction execution sees inconsistent state values, this could lead to:
   - Different transaction execution results across validators
   - State root mismatches
   - Failed consensus rounds
   - Potential chain split if validators commit different state roots

3. **Proof Verification Bypass**: The cryptographic proof verification (line 37) provides no security guarantee since the verified value is discarded and a different value is returned. An attacker cannot directly exploit this, but it represents a critical gap in the security model.

This qualifies as **High Severity** per the bug bounty criteria: "Significant protocol violations" that could lead to consensus issues, though it requires specific timing conditions rather than being directly exploitable.

## Likelihood Explanation

**Moderate to High Likelihood** due to:

1. **Concurrent Pruning**: The StateKvPruner operates continuously in the background with no synchronization with read operations
2. **Large Prune Window Edge Cases**: While the default prune window is 90M versions, nodes performing historical queries near the window edge are vulnerable
3. **State Sync Operations**: During state synchronization, nodes may query historical versions while pruning is actively advancing
4. **No Protection Mechanism**: The code uses default `ReadOptions` without RocksDB snapshot isolation: [4](#0-3) 

The developers acknowledge this issue with TODO comments indicating incomplete implementation: [5](#0-4) 

## Recommendation

Implement atomic reads using RocksDB snapshots:

```rust
fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
    if let Some(version) = self.version {
        // Create a single RocksDB snapshot for both operations
        let snapshot = self.db.create_snapshot();
        let read_opts = ReadOptions::default();
        read_opts.set_snapshot(&snapshot);
        
        if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
            if let Ok((value, proof)) =
                self.db.get_state_value_with_proof_by_version_with_opts(key, version, read_opts)
            {
                proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
            }
        }
        
        // Use the SAME snapshot for the second read
        Ok(self.db.get_state_value_with_version_by_version_with_opts(key, version, read_opts)?)
    } else {
        Ok(None)
    }
}
```

Alternatively, modify the function to return the value from the first read (which was already verified) instead of making a second query:

```rust
fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
    if let Some(version) = self.version {
        if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
            let (value, proof) = self.db.get_state_value_with_proof_by_version(key, version)?;
            proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
            Ok(value.map(|v| (version, v)))  // Return the verified value directly
        } else {
            Ok(self.db.get_state_value_with_version_by_version(key, version)?)
        }
    } else {
        Ok(None)
    }
}
```

## Proof of Concept

```rust
// Rust test demonstrating the race condition
#[test]
fn test_non_atomic_state_reads() {
    use std::sync::{Arc, atomic::{AtomicBool, Ordering}};
    use std::thread;
    use std::time::Duration;
    
    let db = setup_test_db();
    let version = 100_000;
    let key = StateKey::test_key();
    
    // Write initial state
    db.put_state_value(&key, version, StateValue::test_value());
    
    let race_detected = Arc::new(AtomicBool::new(false));
    let race_clone = race_detected.clone();
    
    // Thread 1: Performs DbStateView.get() operation
    let reader_thread = thread::spawn(move || {
        let state_view = DbStateView::new(db.clone(), Some(version), Some(root_hash));
        
        // This should be atomic but isn't
        let result1 = state_view.get(&key);
        
        // Small delay to increase race window
        thread::sleep(Duration::from_millis(10));
        
        let result2 = state_view.get(&key);
        
        if result1 != result2 {
            race_clone.store(true, Ordering::SeqCst);
        }
    });
    
    // Thread 2: Prunes the version while reader is active
    let pruner_thread = thread::spawn(move || {
        thread::sleep(Duration::from_millis(5));
        db.prune_state_value(&key, version);  // Prune during read
    });
    
    reader_thread.join().unwrap();
    pruner_thread.join().unwrap();
    
    assert!(race_detected.load(Ordering::SeqCst), 
        "Race condition detected: non-atomic reads returned different values");
}
```

## Notes

This vulnerability is particularly concerning because:
1. The TODO comments indicate the developers are aware proof verification isn't fully robust for buffered state
2. No atomic consistency mechanism (transactions, snapshots) is implemented
3. The security model assumes Merkle proofs provide verification, but this guarantee is broken by the non-atomic design
4. This affects core state reading operations used throughout transaction execution and validation

The fix requires either implementing RocksDB snapshot isolation or restructuring the code to avoid redundant queries.

### Citations

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L27-46)
```rust
    fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
        if let Some(version) = self.version {
            if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
                // TODO(aldenhu): sample-verify proof inside DB
                // DB doesn't support returning proofs for buffered state, so only optionally
                // verify proof.
                // TODO: support returning state proof for buffered state.
                if let Ok((value, proof)) =
                    self.db.get_state_value_with_proof_by_version(key, version)
                {
                    proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
                }
            }
            Ok(self
                .db
                .get_state_value_with_version_by_version(key, version)?)
        } else {
            Ok(None)
        }
    }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/mod.rs (L49-86)
```rust
    fn prune(&self, max_versions: usize) -> Result<Version> {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["state_kv_pruner__prune"]);

        let mut progress = self.progress();
        let target_version = self.target_version();

        while progress < target_version {
            let current_batch_target_version =
                min(progress + max_versions as Version, target_version);

            info!(
                progress = progress,
                target_version = current_batch_target_version,
                "Pruning state kv data."
            );
            self.metadata_pruner
                .prune(progress, current_batch_target_version)?;

            THREAD_MANAGER.get_background_pool().install(|| {
                self.shard_pruners.par_iter().try_for_each(|shard_pruner| {
                    shard_pruner
                        .prune(progress, current_batch_target_version)
                        .map_err(|err| {
                            anyhow!(
                                "Failed to prune state kv shard {}: {err}",
                                shard_pruner.shard_id(),
                            )
                        })
                })
            })?;

            progress = current_batch_target_version;
            self.record_progress(progress);
            info!(progress = progress, "Pruning state kv data is done.");
        }

        Ok(target_version)
    }
```

**File:** storage/aptosdb/src/state_kv_db.rs (L374-402)
```rust
    pub(crate) fn get_state_value_with_version_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<Option<(Version, StateValue)>> {
        let mut read_opts = ReadOptions::default();

        // We want `None` if the state_key changes in iteration.
        read_opts.set_prefix_same_as_start(true);
        if !self.enabled_sharding() {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueSchema>(read_opts)?;
            iter.seek(&(state_key.clone(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        } else {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueByKeyHashSchema>(read_opts)?;
            iter.seek(&(state_key.hash(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        }
    }
```
