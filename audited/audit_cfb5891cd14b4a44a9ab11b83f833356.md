# Audit Report

## Title
Redis Connection String Disclosure Through Unsanitized Error Messages

## Summary
The `Worker::new()` function in the indexer-grpc-cache-worker leaks full Redis connection URLs (including potential credentials) through error messages that are logged to structured logs and stderr when connection failures occur.

## Finding Description

The indexer-grpc-cache-worker does not sanitize error messages before logging them, leading to potential information disclosure of internal infrastructure details. [1](#0-0) 

When `redis::Client::open()` fails, the error context includes the full `redis_main_instance_address` which is formatted using the `Display` trait implementation: [2](#0-1) 

This `RedisUrl` type directly exposes the complete connection string including:
- Redis scheme (redis://)
- Username (if using Redis ACL)
- Password (if included in URL format)
- Hostname/IP address  
- Port number
- Database number

The error propagates through the call chain: [3](#0-2) 

When the error reaches the server framework, it triggers a panic that logs the full error chain: [4](#0-3) 

The panic handler then logs the complete error details: [5](#0-4) 

## Impact Explanation

This is a **Low Severity** information disclosure vulnerability per Aptos bug bounty criteria (up to $1,000). It does not directly compromise funds, consensus, or availability, but provides reconnaissance information that could aid attackers in targeting the infrastructure.

The leaked information includes:
- Internal network topology (Redis server addresses)
- Authentication credentials (if embedded in connection URL)
- Service configuration details

This information could be used to:
- Target Redis servers for direct attack
- Understand internal architecture for further exploitation
- Attempt credential reuse across services

## Likelihood Explanation

**Moderate likelihood** that error messages become accessible to attackers through:
- Misconfigured log aggregation systems with weak access controls
- Container logs in orchestration platforms (Kubernetes, etc.)
- Log files on compromised systems
- Monitoring dashboards accessible to unauthorized parties
- JSON-formatted structured logs exported to external systems

The vulnerability requires:
1. A connection failure to occur (misconfiguration, network issues, wrong credentials)
2. Attacker access to logs through one of the vectors above

## Recommendation

Sanitize Redis connection URLs before including them in error messages. Replace sensitive portions with redacted placeholders:

```rust
let redis_client = redis::Client::open(redis_main_instance_address.0.clone())
    .with_context(|| {
        // Sanitize the URL to avoid leaking credentials
        let sanitized_url = sanitize_redis_url(&redis_main_instance_address);
        format!(
            "[Indexer Cache] Failed to create redis client for {}",
            sanitized_url
        )
    })?;

// Helper function to sanitize Redis URLs
fn sanitize_redis_url(url: &RedisUrl) -> String {
    let parsed = url.as_str();
    // Replace password and username with placeholders
    // e.g., redis://user:pass@host:6379/0 -> redis://***:***@host:6379/0
    // Or just show: redis://[REDACTED]/[DB]
    format!("redis://[REDACTED]@{}:{}/[DB]", 
        url.host_str().unwrap_or("[HOST]"),
        url.port().unwrap_or(6379))
}
```

Apply similar sanitization to file paths and other infrastructure details in error messages throughout the codebase.

## Proof of Concept

```rust
// To reproduce:
// 1. Configure cache worker with invalid Redis credentials:
//    redis_main_instance_address: "redis://user:secretpass@internal-redis.example.com:6379/0"
// 2. Start the cache worker
// 3. Observe logs contain full connection string:
//    "Failed to create cache worker
//     Caused by: [Indexer Cache] Failed to create redis client for redis://user:secretpass@internal-redis.example.com:6379/0"
```

## Notes

This is a valid **LOW severity** information disclosure vulnerability that does not meet the Critical/High/Medium threshold required by the validation checklist, but represents a real security concern for operational deployments. While it doesn't break consensus, execution, or other critical blockchain invariants, it violates security best practices for error handling and could facilitate targeted attacks on infrastructure components.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L84-90)
```rust
        let redis_client = redis::Client::open(redis_main_instance_address.0.clone())
            .with_context(|| {
                format!(
                    "[Indexer Cache] Failed to create redis client for {}",
                    redis_main_instance_address
                )
            })?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/types.rs (L58-62)
```rust
impl Display for RedisUrl {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/lib.rs (L47-54)
```rust
        let mut worker = Worker::new(
            self.fullnode_grpc_address.clone(),
            self.redis_main_instance_address.clone(),
            self.file_store_config.clone(),
            self.enable_cache_compression,
        )
        .await
        .context("Failed to create cache worker")?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L57-58)
```rust
    let main_task_handler =
        tokio::spawn(async move { config.run().await.expect("task should exit with Ok.") });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L156-168)
```rust
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());
    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);
    // Kill the process
    process::exit(12);
}
```
