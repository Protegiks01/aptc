# Audit Report

## Title
Session Restoration DoS via Zero network_version in Remote BaseState Config

## Summary
The `Config` struct in the transaction simulation session lacks validation on the `network_version` field. An attacker can craft a malicious `config.json` with `network_version: 0` in a Remote BaseState, which passes deserialization but causes a panic when the restored session queries any state through the `DebuggerStateView`. [1](#0-0) 

## Finding Description

The vulnerability exists in the session restoration flow where a Config is loaded from disk without validating its fields. When the Config specifies a Remote BaseState, the `network_version` field is passed directly to `DebuggerStateView::new()` without any validation. [2](#0-1) 

The `DebuggerStateView` constructor stores the version without checks: [3](#0-2) 

However, when any state is queried, the `handler_thread` contains an assertion that requires `version > 0`: [4](#0-3) 

**Attack Path:**
1. Attacker creates a malicious `config.json`:
```json
{
  "base": {
    "Remote": {
      "node_url": "https://api.testnet.aptoslabs.com",
      "network_version": 0,
      "api_key": null
    }
  },
  "ops": 0
}
```

2. `Session::load()` successfully deserializes the Config and creates a `DebuggerStateView` with version=0
3. When the session is used (e.g., `execute_transaction()`, `view_resource()`, `fund_account()`), the state store is queried
4. The query reaches `handler_thread` which executes `assert!(version > 0, "Expecting a non-genesis version")` and **panics**
5. The tokio task crashes, potentially crashing the entire application depending on panic handling

This breaks the **Resource Limits** invariant (#9) as it allows unbounded process termination without proper resource control, and violates availability guarantees.

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty criteria: "API crashes" and "Validator node slowdowns."

The impact includes:
- **API Service Crash**: Any API service using the simulation session restoration feature can be crashed remotely
- **Denial of Service**: Repeated exploitation prevents legitimate session restoration operations
- **Development Tool Disruption**: Tools relying on session persistence become unreliable
- **Potential Data Loss**: Unsaved work in simulation sessions could be lost due to unexpected crashes

While this doesn't directly affect consensus or validator operations (simulation sessions are typically used for testing/debugging), it can disrupt critical development infrastructure and API services that use these sessions.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is highly likely to succeed because:
- **No Validation**: Zero input validation on the `network_version` field
- **Easy Exploitation**: Attacker only needs to modify a JSON file
- **Immediate Effect**: Crash occurs on first state query after loading
- **No Authentication Required**: If an attacker can influence the config file (through compromised storage, supply chain, or API endpoints), the attack succeeds

Factors affecting likelihood:
- Requires attacker access to write/modify session configuration files
- Primarily affects development and testing infrastructure rather than production validators
- Services that accept user-provided session configurations are at highest risk

## Recommendation

**Immediate Fix**: Add validation in the `Config` struct and `Session::load()` method:

```rust
impl Config {
    pub fn load_from_file(path: &std::path::Path) -> Result<Self> {
        let json = std::fs::read_to_string(path)?;
        let config: Config = serde_json::from_str(&json)?;
        
        // Validate the config
        config.validate()?;
        
        Ok(config)
    }
    
    pub fn validate(&self) -> Result<()> {
        match &self.base {
            BaseState::Remote { network_version, .. } => {
                if *network_version == 0 {
                    anyhow::bail!("Invalid network_version: must be greater than 0");
                }
            }
            BaseState::Empty => {}
        }
        Ok(())
    }
}
```

**Alternative Fix**: Add validation in `DebuggerStateView::new()`:

```rust
impl DebuggerStateView {
    pub fn new(db: Arc<dyn AptosValidatorInterface + Send>, version: Version) -> Result<Self> {
        if version == 0 {
            return Err(anyhow::anyhow!("Invalid version: must be greater than 0"));
        }
        let (query_sender, thread_receiver) = unbounded_channel();
        tokio::spawn(async move { handler_thread(db, thread_receiver).await });
        Ok(Self {
            query_sender: Mutex::new(query_sender),
            version,
        })
    }
}
```

**Best Practice**: Implement both validations for defense-in-depth.

## Proof of Concept

```rust
#[test]
fn test_malicious_config_with_zero_network_version() -> anyhow::Result<()> {
    use tempfile::tempdir;
    use std::fs;
    
    let temp_dir = tempdir()?;
    let session_path = temp_dir.path();
    
    // Create malicious config.json with network_version=0
    let malicious_config = r#"{
        "base": {
            "Remote": {
                "node_url": "https://api.testnet.aptoslabs.com",
                "network_version": 0,
                "api_key": null
            }
        },
        "ops": 0
    }"#;
    
    fs::create_dir_all(session_path)?;
    fs::write(session_path.join("config.json"), malicious_config)?;
    fs::write(session_path.join("delta.json"), "{}")?;
    
    // Load the session - this succeeds
    let session = Session::load(session_path)?;
    
    // Try to use the session - this will panic with:
    // "Expecting a non-genesis version"
    let account = AccountAddress::ONE;
    let result = std::panic::catch_unwind(|| {
        session.fund_account(account, 1000)
    });
    
    assert!(result.is_err(), "Session should panic with zero network_version");
    
    Ok(())
}
```

**Notes:**
- This vulnerability affects all components that use `Session::load()` with Remote BaseState
- The panic occurs in an async context (tokio task), which may propagate differently depending on the runtime configuration
- Additional edge cases exist with extremely large `ops` values causing filesystem issues, but the zero network_version issue is the most critical

### Citations

**File:** aptos-move/aptos-transaction-simulation-session/src/config.rs (L23-32)
```rust
/// The configuration for a session, stored to a file in the session directory
/// to allow the session to be restored.
#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq)]
pub struct Config {
    /// The base state of the session.
    pub base: BaseState,

    /// The number of operations the session has performed.
    pub ops: u64,
}
```

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L200-233)
```rust
    pub fn load(session_path: impl AsRef<Path>) -> Result<Self> {
        let session_path = session_path.as_ref().to_path_buf();
        let config = Config::load_from_file(&session_path.join("config.json"))?;

        let base = match &config.base {
            BaseState::Empty => EitherStateView::Left(EmptyStateView),
            BaseState::Remote {
                node_url,
                network_version,
                api_key,
            } => {
                let mut builder = Client::builder(AptosBaseUrl::Custom(node_url.clone()));
                if let Some(api_key) = api_key {
                    builder = builder.api_key(api_key)?;
                }
                let client = builder.build();

                let debugger = DebuggerStateView::new(
                    Arc::new(RestDebuggerInterface::new(client)),
                    *network_version,
                );
                EitherStateView::Right(debugger)
            },
        };

        let delta = load_delta(&session_path.join("delta.json"))?;
        let state_store = DeltaStateStore::new_with_base_and_delta(base, delta);

        Ok(Self {
            config,
            path: session_path,
            state_store,
        })
    }
```

**File:** aptos-move/aptos-validator-interface/src/lib.rs (L106-144)
```rust
async fn handler_thread(
    db: Arc<dyn AptosValidatorInterface + Send>,
    mut thread_receiver: UnboundedReceiver<(
        StateKey,
        Version,
        std::sync::mpsc::Sender<Result<Option<StateValue>>>,
    )>,
) {
    const M: NonZeroUsize = NonZeroUsize::new(1024 * 1024).unwrap();
    let cache = Arc::new(Mutex::new(LruCache::<
        (StateKey, Version),
        Option<StateValue>,
    >::new(M)));
    loop {
        let (key, version, sender) =
            if let Some((key, version, sender)) = thread_receiver.recv().await {
                (key, version, sender)
            } else {
                break;
            };
        if let Some(val) = cache.lock().unwrap().get(&(key.clone(), version)) {
            sender.send(Ok(val.clone())).unwrap();
        } else {
            assert!(version > 0, "Expecting a non-genesis version");
            let db = db.clone();
            let cache = cache.clone();
            tokio::spawn(async move {
                let res = db.get_state_value_by_version(&key, version - 1).await;
                match res {
                    Ok(val) => {
                        cache.lock().unwrap().put((key, version), val.clone());
                        sender.send(Ok(val))
                    },
                    Err(err) => sender.send(Err(err)),
                }
            });
        }
    }
}
```

**File:** aptos-move/aptos-validator-interface/src/lib.rs (L147-154)
```rust
    pub fn new(db: Arc<dyn AptosValidatorInterface + Send>, version: Version) -> Self {
        let (query_sender, thread_receiver) = unbounded_channel();
        tokio::spawn(async move { handler_thread(db, thread_receiver).await });
        Self {
            query_sender: Mutex::new(query_sender),
            version,
        }
    }
```
