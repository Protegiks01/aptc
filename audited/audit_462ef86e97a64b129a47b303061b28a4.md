# Audit Report

## Title
Configuration Sanitizer Bypass Allows Mainnet Validators to Disable Critical Runtime Security Checks

## Summary
Malicious validators can bypass mandatory mainnet security configurations by setting `skip_config_sanitizer: true` in their node config, allowing them to disable critical runtime type verification checks (`paranoid_type_verification`). This creates a vector for consensus divergence where validators executing identical blocks may produce different state roots, violating the Deterministic Execution invariant.

## Finding Description

The node configuration system implements a sanitizer that enforces mandatory security requirements for mainnet validators. However, this entire sanitization process can be bypassed by setting a single flag in the validator's configuration file.

**Attack Flow:**

1. **Config Bypass**: A malicious validator sets `skip_config_sanitizer: true` in their YAML config file: [1](#0-0) 

2. **Sanitization Skipped**: The sanitizer checks this flag first and returns early without performing any validation: [2](#0-1) 

3. **Critical Checks Bypassed**: For mainnet validators, the following mandatory checks are bypassed:

   - **Paranoid Type Verification**: Must be enabled on mainnet to catch runtime type safety violations: [3](#0-2) 

   - **Safety Rules Backend**: Must not use in-memory storage on mainnet (loses consensus keys on crash): [4](#0-3) 

   - **Safety Rules Service**: Must use local service for optimal performance on mainnet: [5](#0-4) 

4. **VM Configuration Applied**: The disabled `paranoid_type_verification` setting is propagated to the VM: [6](#0-5) 

5. **Runtime Checks Disabled**: The VM uses `NoRuntimeTypeCheck` instead of `FullRuntimeTypeCheck`: [7](#0-6) 

6. **No Verification Performed**: The `NoRuntimeTypeCheck` implementation performs no runtime type safety verification whatsoever: [8](#0-7) 

**Consensus Divergence Scenario:**

When a transaction exploits a bytecode verifier bug or contains subtle type safety violations:
- **Honest validators** (with paranoid checks enabled): Detect the violation, transaction aborts with a specific error code
- **Malicious validator** (with paranoid checks disabled): No runtime verification occurs, execution continues with undefined behavior, potentially producing a different result

This produces different state roots for identical blocks, breaking consensus safety.

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos Bug Bounty criteria)

This vulnerability enables:
1. **Consensus Safety Violations**: Validators can produce divergent state roots for identical block inputs, violating the Deterministic Execution invariant
2. **Protocol Violations**: Mandatory security controls designed to prevent VM bugs from causing consensus issues can be bypassed
3. **Network Instability**: State root mismatches force block re-execution and can cause validation delays

While this doesn't directly cause fund loss, it creates a significant attack surface for consensus manipulation. The impact is mitigated by the fact that:
- State root mismatches are detectable through consensus monitoring
- Requires malicious validator with node operator access
- Requires a transaction that exploits the disabled checks

However, during network upgrades when new security features are introduced (e.g., additional paranoid checks), malicious validators could maintain vulnerable old configurations, creating a window for exploitation.

## Likelihood Explanation

**Likelihood: Medium-High**

**Factors Increasing Likelihood:**
- Config files are fully controlled by validators - no network-level enforcement
- The bypass is trivial: adding two lines to a YAML file
- During coordinated upgrades, validators may legitimately disable optimizers temporarily, providing cover
- Test configurations that disable sanitizers for performance may leak into production

**Factors Decreasing Likelihood:**
- Requires validator insider access (not an external attacker)
- State root divergence is observable and would expose the malicious validator
- Most validators follow recommended configurations
- Requires finding a transaction that exploits the disabled checks

The most realistic attack window is during network upgrades when configuration changes are expected and new security features are being deployed network-wide.

## Recommendation

**Immediate Fix**: Remove the ability to skip the config sanitizer for mainnet nodes. The sanitizer should always run for production networks:

```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // Only allow skipping sanitizer on non-mainnet chains
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && node_config.node_startup.skip_config_sanitizer {
                return Err(Error::ConfigSanitizerFailed(
                    "NodeConfig".to_string(),
                    "Cannot skip config sanitizer on mainnet!".to_string(),
                ));
            }
        }
        
        // If config sanitization is disabled for non-mainnet, don't do anything
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }

        // ... rest of sanitization logic
    }
}
```

**Additional Hardening:**
1. Add runtime assertions that verify critical flags are enabled when chain_id is mainnet
2. Implement peer verification to detect validators running with non-standard configs
3. Add telemetry/monitoring for validators with disabled security features
4. Consider making critical security flags immutable after initial node setup

## Proof of Concept

```rust
// File: config_sanitizer_bypass_poc.rs
// Demonstrates that a validator can bypass mainnet sanitization

use aptos_config::config::{
    NodeConfig, NodeStartupConfig, ExecutionConfig, SafetyRulesConfig, 
    SecureBackend, ConfigSanitizer
};
use aptos_types::chain_id::ChainId;

fn main() {
    // Create a mainnet validator config with security features disabled
    let mut malicious_config = NodeConfig::default();
    
    // Step 1: Bypass sanitizer
    malicious_config.node_startup = NodeStartupConfig {
        skip_config_sanitizer: true,
        skip_config_optimizer: false,
    };
    
    // Step 2: Disable paranoid checks (normally rejected on mainnet)
    malicious_config.execution = ExecutionConfig {
        paranoid_type_verification: false,  // CRITICAL SECURITY FEATURE DISABLED
        paranoid_hot_potato_verification: false,
        ..Default::default()
    };
    
    // Step 3: Use in-memory backend (normally rejected on mainnet)
    malicious_config.consensus.safety_rules.backend = SecureBackend::InMemoryStorage;
    
    // Attempt sanitization for mainnet
    let result = NodeConfig::sanitize(
        &malicious_config,
        aptos_config::config::node_config_loader::NodeType::Validator,
        Some(ChainId::mainnet()),
    );
    
    // VULNERABILITY: Sanitization passes despite invalid mainnet config!
    assert!(result.is_ok(), "Sanitizer should have been bypassed!");
    
    println!("âœ“ VULNERABILITY CONFIRMED: Mainnet validator can bypass all security checks");
    println!("  - paranoid_type_verification: {}", malicious_config.execution.paranoid_type_verification);
    println!("  - Backend type: {:?}", malicious_config.consensus.safety_rules.backend);
    println!("  - Sanitizer was skipped: {}", malicious_config.node_startup.skip_config_sanitizer);
}
```

**YAML Config Example** (place in validator's config file):
```yaml
node_startup:
  skip_config_sanitizer: true
  
execution:
  paranoid_type_verification: false
  paranoid_hot_potato_verification: false
  
consensus:
  safety_rules:
    backend:
      type: "in_memory_storage"
```

## Notes

This vulnerability is particularly concerning during network upgrades because:
1. Configuration changes are expected during upgrades, reducing suspicion
2. New security features may be added that malicious validators can selectively disable
3. The sanitizer is specifically designed to enforce new security requirements network-wide

The `skip_config_optimizer` flag poses less immediate risk as it primarily affects performance optimizations rather than security enforcement, but should also be restricted on mainnet for defense-in-depth.

### Citations

**File:** config/src/config/node_startup_config.rs (L6-11)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/execution_config.rs (L166-183)
```rust
        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```

**File:** aptos-node/src/utils.rs (L53-56)
```rust
pub fn set_aptos_vm_configurations(node_config: &NodeConfig) {
    set_layout_caches(node_config.execution.layout_caches_enabled);
    set_paranoid_type_checks(node_config.execution.paranoid_type_verification);
    set_async_runtime_checks(node_config.execution.async_runtime_checks);
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L267-278)
```rust
        match (
            paranoid_type_checks,
            optimize_trusted_code,
            paranoid_ref_checks,
        ) {
            (true, true, false) => execute_main!(UntrustedOnlyRuntimeTypeCheck, NoRuntimeRefCheck),
            (true, false, false) => execute_main!(FullRuntimeTypeCheck, NoRuntimeRefCheck),
            (true, true, true) => execute_main!(UntrustedOnlyRuntimeTypeCheck, FullRuntimeRefCheck),
            (true, false, true) => execute_main!(FullRuntimeTypeCheck, FullRuntimeRefCheck),
            (false, _, false) => execute_main!(NoRuntimeTypeCheck, NoRuntimeRefCheck),
            (false, _, true) => execute_main!(NoRuntimeTypeCheck, FullRuntimeRefCheck),
        }
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L220-253)
```rust
impl RuntimeTypeCheck for NoRuntimeTypeCheck {
    #[cfg_attr(feature = "force-inline", inline(always))]
    fn pre_execution_type_stack_transition(
        _frame: &Frame,
        _operand_stack: &mut Stack,
        _instruction: &Instruction,
        _ty_cache: &mut FrameTypeCache,
    ) -> PartialVMResult<()> {
        Ok(())
    }

    #[cfg_attr(feature = "force-inline", inline(always))]
    fn post_execution_type_stack_transition(
        _frame: &Frame,
        _operand_stack: &mut Stack,
        _instruction: &Instruction,
        _ty_cache: &mut FrameTypeCache,
    ) -> PartialVMResult<()> {
        Ok(())
    }

    #[cfg_attr(feature = "force-inline", inline(always))]
    fn should_perform_checks(_for_fun: &Function) -> bool {
        false
    }

    #[cfg_attr(feature = "force-inline", inline(always))]
    fn check_cross_module_regular_call_visibility(
        _caller: &LoadedFunction,
        _callee: &LoadedFunction,
    ) -> PartialVMResult<()> {
        Ok(())
    }
}
```
