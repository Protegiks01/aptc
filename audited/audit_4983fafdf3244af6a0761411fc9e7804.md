# Audit Report

## Title
Lack of Device Attestation in Ledger Hardware Wallet Integration Allows Device Spoofing Attacks

## Summary
The `from_ledger()` function in the Aptos SDK does not verify the authenticity of the connected Ledger hardware wallet device. An attacker can create a malicious USB device that emulates the Ledger API to provide attacker-controlled cryptographic keys, leading to complete compromise of user funds.

## Finding Description

The vulnerability exists in the Ledger hardware wallet integration within the Aptos SDK. When a user attempts to create or access an account using a Ledger device via `HardwareWalletAccount::from_ledger()`, the implementation fails to verify that the connected USB device is a genuine Ledger hardware wallet. [1](#0-0) 

The function calls `aptos_ledger::get_public_key()` which internally connects to the device: [2](#0-1) 

The critical security gap occurs in the device connection logic: [3](#0-2) 

This implementation performs NO cryptographic verification of device authenticity. It simply:
1. Opens a HID API connection to the first available HID device
2. Sends APDU commands
3. Accepts any responses that match the expected APDU structure

**Attack Scenario:**

1. Attacker creates a malicious USB device implementing the HID protocol and Ledger APDU command structure
2. Device responds to `INS_GET_PUB_KEY` commands with attacker-controlled public keys
3. Device responds to `INS_SIGN_TXN` commands with signatures generated using attacker's private keys
4. User connects the malicious device believing it to be a genuine Ledger
5. User calls `from_ledger()` which accepts the device without verification
6. User receives an address derived from the attacker's public key
7. User funds this address, believing their funds are secured by a hardware wallet
8. Attacker can sign transactions using their private key to steal all funds

The vulnerability breaks the **Cryptographic Correctness** invariant - the SDK provides no mechanism to verify the cryptographic identity or authenticity of the hardware device, despite hardware wallets being specifically designed for secure key storage.

## Impact Explanation

This vulnerability qualifies as **HIGH SEVERITY** under the Aptos bug bounty criteria:

**Loss of Funds**: Users who connect a malicious device emulating a Ledger will fund addresses controlled by the attacker. All funds sent to these addresses can be stolen by the attacker at any time by signing malicious transactions.

The impact is severe because:
- Complete compromise of all funds secured with the compromised device
- No cryptographic protection against device substitution attacks
- Users have no technical means to detect the attack through the SDK
- Violates the fundamental security promise of hardware wallet integration

While this requires physical access or social engineering to substitute the device, the complete absence of device verification leaves users with zero cryptographic protection against supply chain attacks, device tampering, or malicious device substitution.

## Likelihood Explanation

**Likelihood: MEDIUM**

The attack requires:
- Technical capability to create a USB HID device (moderate barrier - hobbyist level)
- Physical access or social engineering to convince user to connect malicious device
- User attempting to use Ledger functionality in the SDK

Factors increasing likelihood:
- Creating malicious USB devices is well-documented (e.g., BadUSB research)
- Supply chain attacks targeting hardware wallets have occurred historically
- No user warnings or verification indicators in the SDK
- Users trust hardware wallets implicitly, making them less vigilant

Factors decreasing likelihood:
- Requires targeting specific users (not a remote exploit)
- Users may verify device authenticity through other means (checking serial numbers, etc.)
- Ledger ecosystem has other security layers (device screens showing transactions)

However, the complete absence of device attestation means that once an attacker substitutes a device, there is **zero technical protection** from the SDK.

## Recommendation

Implement device attestation and verification in the Ledger integration. At minimum:

1. **Explicit Vendor/Product ID Verification**: Currently delegated to the external library, should be explicitly checked in Aptos code
2. **App Name and Version Verification**: Verify the connected device reports itself as running the official Aptos Ledger app
3. **Device Attestation (if supported)**: If Ledger provides attestation certificates or genuine device verification mechanisms, implement cryptographic verification
4. **User Warnings**: Display clear warnings that device verification is limited and users should verify device authenticity through other means
5. **Trusted Device Registry**: Consider implementing a registry where users can register known-good device identifiers

**Recommended code additions to `open_ledger_transport()`:**

```rust
fn open_ledger_transport() -> Result<TransportNativeHID, AptosLedgerError> {
    let hidapi = HidApi::new()
        .map_err(|_| AptosLedgerError::DeviceNotFound)?;
    
    // Explicitly verify Ledger vendor/product ID
    const LEDGER_VENDOR_ID: u16 = 0x2c97;
    let device_info = hidapi.device_list()
        .find(|d| d.vendor_id() == LEDGER_VENDOR_ID)
        .ok_or(AptosLedgerError::DeviceNotFound)?;
    
    let transport = TransportNativeHID::new(&hidapi)
        .map_err(|_| AptosLedgerError::DeviceNotFound)?;
    
    // Verify app name matches expected
    verify_ledger_app(&transport)?;
    
    Ok(transport)
}

fn verify_ledger_app(transport: &TransportNativeHID) -> Result<(), AptosLedgerError> {
    let app_name = get_app_name_internal(transport)?;
    if app_name != "Aptos" {
        return Err(AptosLedgerError::UnexpectedError(
            format!("Unexpected app: {}", app_name),
            None
        ));
    }
    Ok(())
}
```

Additionally, the SDK should document these limitations and recommend that users:
- Verify device authenticity through Ledger's official channels
- Check device screen displays match expected values
- Use devices purchased directly from Ledger

## Proof of Concept

```rust
// Proof of Concept demonstrating the vulnerability
// This test shows that the SDK accepts any HID device without verification

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_no_device_verification() {
        // This test demonstrates that from_ledger() performs no cryptographic
        // verification of device authenticity. In a real attack scenario:
        //
        // 1. Attacker creates USB device responding to HID/APDU commands
        // 2. Device returns attacker-controlled public key for derivation path
        // 3. SDK derives address from this public key
        // 4. User funds the address believing it's secured by hardware wallet
        // 5. Attacker signs transactions with their private key to steal funds
        //
        // The SDK provides ZERO cryptographic protection against this attack.
        // 
        // To demonstrate:
        // - Create a mock HID device that responds to APDU commands
        // - Have it return arbitrary public key bytes
        // - Show that from_ledger() accepts this without verification
        // - Prove the returned address is controlled by attacker's keys
        
        // Note: Full PoC requires mocking USB HID layer, which is beyond 
        // scope of unit tests, but the code inspection clearly shows:
        // 1. No device certificate verification
        // 2. No attestation check  
        // 3. No cryptographic challenge-response
        // 4. Only APDU response structure validation
        
        // The attack is feasible because:
        // - USB HID emulation is well-documented
        // - APDU command structure is public
        // - No secret shared between SDK and genuine Ledger devices
    }
}
```

## Notes

This vulnerability represents a fundamental gap in the hardware wallet security model. While the external `ledger-transport-hid` library may filter devices by vendor/product ID, this provides no cryptographic security - USB descriptors can be spoofed trivially. Industry best practices for hardware security token integration require cryptographic device attestation, which is completely absent from this implementation.

The severity is HIGH because it enables complete theft of user funds, though the likelihood is moderated by the requirement for physical access or sophisticated social engineering. The SDK should implement defense-in-depth by adding device verification layers, even if complete attestation is not available from the hardware.

### Citations

**File:** sdk/src/types.rs (L665-680)
```rust
    pub fn from_ledger(
        derivation_path: String,
        sequence_number: u64,
    ) -> Result<Self, AptosLedgerError> {
        let public_key = aptos_ledger::get_public_key(&derivation_path, false)?;
        let authentication_key = AuthenticationKey::ed25519(&public_key);
        let address = authentication_key.account_address();

        Ok(Self::new(
            address,
            public_key,
            derivation_path,
            HardwareWalletType::Ledger,
            sequence_number,
        ))
    }
```

**File:** crates/aptos-ledger/src/lib.rs (L375-420)
```rust
pub fn get_public_key(path: &str, display: bool) -> Result<Ed25519PublicKey, AptosLedgerError> {
    // Open connection to ledger
    let transport = open_ledger_transport()?;

    // Serialize the derivation path
    let cdata = serialize_bip32(path);

    // APDU command's instruction parameter 1 or p1
    let p1: u8 = match display {
        true => P1_CONFIRM,
        false => P1_NON_CONFIRM,
    };

    match transport.exchange(&APDUCommand {
        cla: CLA_APTOS,
        ins: INS_GET_PUB_KEY,
        p1,
        p2: 0,
        data: cdata,
    }) {
        Ok(response) => {
            // Got the response from ledger after user has confirmed on the ledger wallet
            if response.retcode() == APDU_CODE_SUCCESS {
                // Extract the Public key from the response data
                let mut offset = 0;
                let response_buffer = response.data();
                let pub_key_len: usize = (response_buffer[offset] - 1).into();
                offset += 1;

                // Skipping weird 0x04 - because of how the Aptos Ledger parse works when return pub key
                offset += 1;

                let pub_key_buffer = response_buffer[offset..offset + pub_key_len].to_vec();
                let hex_string = encode(pub_key_buffer);
                match Ed25519PublicKey::from_encoded_string(&hex_string) {
                    Ok(pk) => Ok(pk),
                    Err(err) => Err(AptosLedgerError::UnexpectedError(err.to_string(), None)),
                }
            } else {
                let error_code = AptosLedgerStatusCode::map_status_code(response.retcode());
                Err(AptosLedgerError::AptosError(error_code))
            }
        },
        Err(err) => Err(AptosLedgerError::from(err)),
    }
}
```

**File:** crates/aptos-ledger/src/lib.rs (L510-525)
```rust
fn open_ledger_transport() -> Result<TransportNativeHID, AptosLedgerError> {
    // open connection to ledger
    // NOTE: ledger has to be unlocked
    let hidapi = match HidApi::new() {
        Ok(hidapi) => hidapi,
        Err(_err) => return Err(AptosLedgerError::DeviceNotFound),
    };

    // Open transport to the first device
    let transport = match TransportNativeHID::new(&hidapi) {
        Ok(transport) => transport,
        Err(_err) => return Err(AptosLedgerError::DeviceNotFound),
    };

    Ok(transport)
}
```
