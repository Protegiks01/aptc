# Audit Report

## Title
Feature Flags Lost During Epoch Transition When DKG State Changes

## Summary
Feature flags approved via governance can permanently remain in pending state and never activate if DKG (Distributed Key Generation) is disabled after the feature flag change is proposed but before the epoch completes. This occurs because there are two different code paths for epoch transitions that handle feature flag activation inconsistently.

## Finding Description

The Aptos blockchain has two separate code paths for processing epoch transitions:

**Path A (DKG-enabled):** When DKG is enabled, epoch transitions go through `reconfiguration_with_dkg::finish()` which calls `features::on_new_epoch()` to apply pending feature flags before incrementing the epoch. [1](#0-0) 

**Path B (DKG-disabled):** When DKG is disabled, epoch transitions go through `block::block_prologue()` which directly calls `reconfiguration::reconfigure()`, completely bypassing `features::on_new_epoch()`. [2](#0-1) 

The `reconfiguration::reconfigure()` function increments the epoch but never calls `features::on_new_epoch()`: [3](#0-2) 

Critically, `features::on_new_epoch()` is ONLY called from within `reconfiguration_with_dkg::finish()`: [4](#0-3) 

**Attack Scenario:**

1. DKG is enabled (validator_txn_enabled && randomness_config::enabled)
2. Governance proposal calls `toggle_features()` to enable a critical security feature
3. This creates `PendingFeatures` resource and calls `reconfigure()`
4. Since DKG is enabled, `reconfigure()` starts async DKG via `try_start()`
5. Before DKG completes, governance disables DKG via config change
6. Epoch timer expires: `timestamp - last_reconfiguration_time >= epoch_interval`
7. Consensus now creates `BlockMetadata` (not `BlockMetadataExt`) since DKG is disabled
8. VM executes `block_prologue()` which calls `reconfiguration::reconfigure()` directly
9. Epoch increments from N to N+1 **without calling `features::on_new_epoch()`**
10. `PendingFeatures` resource remains at `@std` address but is never applied
11. The approved feature flags never activate

The `toggle_features()` function always creates `PendingFeatures` and expects it to be applied at the next epoch boundary: [5](#0-4) 

Feature flag changes are staged in the `PendingFeatures` resource: [6](#0-5) 

The `on_new_epoch()` function is responsible for moving pending changes to active state: [7](#0-6) 

## Impact Explanation

This is a **HIGH severity** vulnerability per the Aptos bug bounty criteria because it causes:

1. **Governance Integrity Violation**: Approved governance proposals fail to take effect, breaking the fundamental guarantee that passed proposals execute at the next epoch boundary

2. **Security Patch Deployment Failure**: Critical security features intended to patch vulnerabilities can be blocked from activating, leaving the network exposed

3. **State Consistency Break**: Different system components may have inconsistent views of which features are enabled, violating deterministic execution guarantees

4. **Non-Deterministic Behavior**: Feature activation becomes dependent on the timing of DKG state changes rather than being deterministically tied to epoch boundaries

While this doesn't directly cause fund loss or consensus splits, it significantly undermines the governance system and can prevent critical security patches from deploying, meeting the "Significant protocol violations" criteria for High severity.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability will trigger whenever:
- A governance proposal to change feature flags passes while DKG is enabled
- DKG is subsequently disabled (via governance config change) before the epoch completes
- The epoch timer expires, triggering the vulnerable code path

This scenario is realistic because:
1. DKG can be legitimately disabled for operational reasons (debugging, performance issues, or transitioning between randomness implementations)
2. The timing window between proposal execution and epoch completion can be significant (epochs last hours)
3. No special privileges are required - this occurs through normal governance operations
4. The bug is silent - validators won't detect that feature flags failed to apply

## Recommendation

**Fix:** Ensure `features::on_new_epoch()` is always called during epoch transitions, regardless of DKG state.

**Option 1 (Recommended):** Modify `reconfiguration::reconfigure()` to call `features::on_new_epoch()`:

```move
public(friend) fun reconfigure() acquires Configuration {
    // ... existing early returns ...
    
    reconfiguration_state::on_reconfig_start();
    
    // Call stake to compute the new validator set
    stake::on_new_epoch();
    storage_gas::on_reconfig();
    
    // ADD: Apply pending feature flags
    std::features::on_new_epoch(framework);  // <-- Add this line
    
    // Update epoch
    let config_ref = borrow_global_mut<Configuration>(@aptos_framework);
    config_ref.epoch = config_ref.epoch + 1;
    config_ref.last_reconfiguration_time = current_time;
    
    // ... emit events ...
    
    reconfiguration_state::on_reconfig_finish();
}
```

**Option 2:** Ensure `block_prologue()` always uses the DKG-aware path by calling `reconfiguration_with_dkg::finish()` instead of `reconfiguration::reconfigure()` directly.

**Option 3:** Add a check in `features::is_enabled()` to apply `PendingFeatures` if the epoch has changed since they were created, as a defensive fallback.

The recommended approach is Option 1 as it ensures consistent feature flag application regardless of the reconfiguration path taken.

## Proof of Concept

```move
#[test_only]
module test_feature_flag_loss {
    use std::features;
    use aptos_framework::aptos_governance;
    use aptos_framework::consensus_config;
    use aptos_framework::randomness_config;
    use aptos_framework::reconfiguration;
    use aptos_framework::timestamp;
    use aptos_framework::block;
    
    #[test(framework = @aptos_framework)]
    fun test_feature_flags_lost_on_dkg_state_change(framework: &signer) {
        // Setup: Initialize governance and enable DKG
        timestamp::set_time_has_started_for_testing(framework);
        // ... initialize governance, stake, etc ...
        
        // Enable DKG
        consensus_config::set_for_next_epoch(framework, /* validator_txn_enabled = */ true);
        randomness_config::set_for_next_epoch(framework, /* enabled = */ true);
        aptos_governance::force_end_epoch(framework);
        
        // Step 1: Governance proposes to enable FEATURE_X
        let initial_epoch = reconfiguration::current_epoch();
        aptos_governance::toggle_features(
            framework,
            vector[features::CODE_DEPENDENCY_CHECK], // enable
            vector[] // disable
        );
        
        // Verify PendingFeatures exists but feature not yet enabled
        assert!(!features::code_dependency_check_enabled(), 1);
        // assert!(exists<PendingFeatures>(@std), 2); // Would need friend access
        
        // Step 2: Disable DKG before epoch completes
        consensus_config::set_for_next_epoch(framework, /* validator_txn_enabled = */ false);
        
        // Step 3: Trigger epoch change via block_prologue (simulating time passage)
        timestamp::fast_forward_seconds(7200); // 2 hours, past epoch_interval
        
        // Simulate block_prologue execution
        block::block_prologue(
            framework,
            @0x1, // hash
            initial_epoch + 1, // epoch
            1, // round  
            @0x1, // proposer
            vector[], // failed_proposer_indices
            vector[], // previous_block_votes_bitvec
            timestamp::now_microseconds()
        );
        
        // Bug: Epoch changed but feature flag NOT applied!
        let new_epoch = reconfiguration::current_epoch();
        assert!(new_epoch == initial_epoch + 1, 3);
        assert!(!features::code_dependency_check_enabled(), 4); // BUG: Should be enabled!
    }
}
```

## Notes

**Validator Restart Safety:** Regarding the second part of the security question about validator restarts: `PendingFeatures` is stored as an on-chain resource at `@std` address, so it persists across validator restarts since it's part of the blockchain state. Validator restarts do not cause feature flag state loss by themselves. The vulnerability is specifically in the epoch transition logic, not in state persistence.

**Why This Matters:** The deprecated `change_feature_flags()` function was explicitly disabled to enforce the epoch-boundary pattern via `change_feature_flags_for_next_epoch()`, showing the importance of proper feature flag lifecycle management. This vulnerability undermines that design by allowing feature flags to get stuck in pending state. [8](#0-7)

### Citations

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L203-218)
```text
    fun block_prologue(
        vm: signer,
        hash: address,
        epoch: u64,
        round: u64,
        proposer: address,
        failed_proposer_indices: vector<u64>,
        previous_block_votes_bitvec: vector<u8>,
        timestamp: u64
    ) acquires BlockResource, CommitHistory {
        let epoch_interval = block_prologue_common(&vm, hash, epoch, round, proposer, failed_proposer_indices, previous_block_votes_bitvec, timestamp);
        randomness::on_new_block(&vm, epoch, round, option::none());
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration::reconfigure();
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L106-159)
```text
    public(friend) fun reconfigure() acquires Configuration {
        // Do not do anything if genesis has not finished.
        if (chain_status::is_genesis() || timestamp::now_microseconds() == 0 || !reconfiguration_enabled()) {
            return
        };

        let config_ref = borrow_global_mut<Configuration>(@aptos_framework);
        let current_time = timestamp::now_microseconds();

        // Do not do anything if a reconfiguration event is already emitted within this transaction.
        //
        // This is OK because:
        // - The time changes in every non-empty block
        // - A block automatically ends after a transaction that emits a reconfiguration event, which is guaranteed by
        //   VM spec that all transactions comming after a reconfiguration transaction will be returned as Retry
        //   status.
        // - Each transaction must emit at most one reconfiguration event
        //
        // Thus, this check ensures that a transaction that does multiple "reconfiguration required" actions emits only
        // one reconfiguration event.
        //
        if (current_time == config_ref.last_reconfiguration_time) {
            return
        };

        reconfiguration_state::on_reconfig_start();

        // Call stake to compute the new validator set and distribute rewards and transaction fees.
        stake::on_new_epoch();
        storage_gas::on_reconfig();

        assert!(current_time > config_ref.last_reconfiguration_time, error::invalid_state(EINVALID_BLOCK_TIME));
        config_ref.last_reconfiguration_time = current_time;
        spec {
            assume config_ref.epoch + 1 <= MAX_U64;
        };
        config_ref.epoch = config_ref.epoch + 1;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                NewEpoch {
                    epoch: config_ref.epoch,
                },
            );
        };
        event::emit_event<NewEpochEvent>(
            &mut config_ref.events,
            NewEpochEvent {
                epoch: config_ref.epoch,
            },
        );

        reconfiguration_state::on_reconfig_finish();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L714-718)
```text
    public fun toggle_features(aptos_framework: &signer, enable: vector<u64>, disable: vector<u64>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        features::change_feature_flags_for_next_epoch(aptos_framework, enable, disable);
        reconfigure(aptos_framework);
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L785-787)
```text
    public fun change_feature_flags(_framework: &signer, _enable: vector<u64>, _disable: vector<u64>) {
        abort (error::invalid_state(EAPI_DISABLED))
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L805-828)
```text
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L834-844)
```text
    public fun on_new_epoch(framework: &signer) acquires Features, PendingFeatures {
        ensure_framework_signer(framework);
        if (exists<PendingFeatures>(@std)) {
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            if (exists<Features>(@std)) {
                Features[@std].features = features;
            } else {
                move_to(framework, Features { features })
            }
        }
    }
```
