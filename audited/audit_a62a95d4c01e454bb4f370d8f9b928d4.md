# Audit Report

## Title
Incomplete Call Graph Tracking in Spec Rewriter Due to Inconsistent Function Reference Collection

## Summary
A subtle inconsistency in `RewriteTarget::used_funs_with_uses()` causes the spec rewriter to miss functions referenced only through closures (function values) in spec function bodies. This breaks verification soundness by failing to convert transitively-used Move functions to spec functions, potentially allowing incorrect verification results. [1](#0-0) 

## Finding Description

The Move model maintains two distinct methods for tracking function usage:

1. **`used_funs_with_uses()`** - Collects ALL function references including direct calls (`Operation::MoveFunction`) AND closures (`Operation::Closure`) [2](#0-1) 

2. **`called_funs_with_callsites()`** - Collects ONLY direct calls (`Operation::MoveFunction`), excluding closures [3](#0-2) 

However, `RewriteTarget::used_funs_with_uses()` incorrectly uses `called_funs_with_callsites()` for `MoveFun` and `SpecFun` cases while correctly using `used_funs_with_uses()` for `SpecBlock` cases, creating an inconsistency.

The spec rewriter relies on this method to identify all Move functions that need conversion to spec functions during the rewriting phase: [4](#0-3) 

**Exploitation Scenario:**

1. Spec function `SF` references Move function `MF1` through a closure (function value parameter)
2. `MF1` internally references `MF2` through another closure
3. During spec rewriting (line 86), `target.used_funs_with_uses(env)` is called for `SF`
4. Due to the bug, only `MF1` is detected (the direct content), but not through proper closure tracking
5. When computing transitive closure (line 93), `MF2` is missed because the call graph doesn't track closures
6. `MF2` never gets converted to a spec function
7. During verification, if `SF` → `MF1` → `MF2` execution path is followed, the Move (not spec) version of `MF2` may be referenced

The root cause is that the transitive closure computation uses the `called_funs` set populated by `ExpData::called_funs()`, which excludes closures: [5](#0-4) 

This breaks verification soundness because Move functions have different semantics (references, side effects) than their spec equivalents (value-based, pure).

## Impact Explanation

**Severity: Medium (Limited Impact on Verification Infrastructure)**

This vulnerability affects the **verification tooling layer**, not the runtime blockchain execution. The impact is limited to:

- **Verification Soundness**: Teams using formal verification may receive incorrect verification results
- **Indirect Security Risk**: If developers rely on verification passing as a security guarantee, buggy code could be deployed
- **Development Infrastructure**: Affects the Move Prover's correctness, which is part of the security development lifecycle

**Why Not Higher Severity:**
- The Aptos blockchain does NOT mandate formal verification for module deployment
- Runtime execution is unaffected - this bug doesn't affect consensus, state transitions, or fund security
- The Move VM and on-chain execution remain secure regardless of this verification bug
- Impact requires developers to specifically use formal verification AND rely on it exclusively

This falls under development/tooling infrastructure issues rather than direct blockchain security vulnerabilities. While verification is part of the security ecosystem, it's not enforced by the protocol.

## Likelihood Explanation

**Likelihood: Low to Medium**

**Required Conditions:**
1. Developer must use formal verification (Move Prover) on their module
2. Spec functions must use higher-order functions (closures/function values)
3. Transitive dependencies must exist through closure chains
4. Developer must rely solely on verification without additional testing

**Mitigating Factors:**
- Higher-order functions in specs are relatively uncommon
- Most developers use testing in addition to formal verification
- The Move Prover may emit errors in some cases when spec functions are missing
- Lambda lifting typically converts closures to standalone functions that are tracked separately

**Amplifying Factors:**
- Subtle bug that could go unnoticed
- Affects all users of the Move Prover in the v2 compiler pipeline
- No runtime errors to detect the issue

## Recommendation

**Fix 1: Correct the `RewriteTarget::used_funs_with_uses()` method**

Change lines 204 and 210 to use the correct method:

```rust
// Before (INCORRECT):
MoveFun(id) => env
    .get_function(*id)
    .get_def()
    .map(|e| e.called_funs_with_callsites())  // BUG: Should use used_funs_with_uses()
    .unwrap_or_default(),

// After (CORRECT):
MoveFun(id) => env
    .get_function(*id)
    .get_def()
    .map(|e| e.used_funs_with_uses())  // Fixed: Now includes closures
    .unwrap_or_default(),
```

**Fix 2: Update transitive closure to track closure-based dependencies**

Modify the call graph construction to use `used_funs` instead of `called_funs` when building transitive relationships for verification: [6](#0-5) 

Add a separate `used_funs_transitive` computation that includes closures for spec rewriting purposes.

## Proof of Concept

```rust
// Note: This is a conceptual PoC showing the bug's impact

module 0x42::verification_bug {
    // Helper function referenced only through closure
    fun helper(x: u64): u64 {
        x + 1  // Has side effects in Move version
    }
    
    // Function that uses helper as closure
    fun processor(f: |u64| u64, x: u64): u64 {
        f(x)
    }
    
    // Spec function that should track the full closure chain
    spec fun spec_processor(f: |u64| u64, x: u64): u64 {
        f(x)  // Should invoke spec version of all reachable functions
    }
    
    spec module {
        // This spec references processor with helper as closure
        // BUG: helper won't be converted to spec function
        // Verification may use Move version instead of spec version
        ensures spec_processor(|y| helper(y), 5) == 6;
    }
}
```

**Expected behavior:** All transitively referenced functions (including `helper`) should be converted to spec functions.

**Actual behavior:** Functions referenced only through closures in spec function bodies are missed, potentially causing verification to use Move semantics instead of spec semantics.

**Verification Steps:**
1. Enable detailed logging in spec_rewriter.rs
2. Create a module with nested closure references in spec functions  
3. Observe that transitively-referenced functions are not added to `called_funs` set
4. Verification proceeds with incomplete function mapping

---

**Notes:** This is a genuine bug in the verification infrastructure, but its security impact is limited to the verification layer, not the runtime blockchain execution. It affects verification soundness rather than consensus or fund security. The issue should be fixed to maintain the integrity of the formal verification toolchain.

### Citations

**File:** third_party/move/move-compiler-v2/src/env_pipeline/rewrite_target.rs (L193-217)
```rust
impl RewriteTarget {
    /// Gets the functions called or referenced in the target.
    pub fn used_funs_with_uses(
        &self,
        env: &GlobalEnv,
    ) -> BTreeMap<QualifiedId<FunId>, BTreeSet<NodeId>> {
        use RewriteTarget::*;
        match self {
            MoveFun(id) => env
                .get_function(*id)
                .get_def()
                .map(|e| e.called_funs_with_callsites())
                .unwrap_or_default(),
            SpecFun(id) => env
                .get_spec_fun(*id)
                .body
                .as_ref()
                .map(|e| e.called_funs_with_callsites())
                .unwrap_or_default(),
            SpecBlock(target) => {
                let spec = env.get_spec_block(target);
                spec.used_funs_with_uses()
            },
        }
    }
```

**File:** third_party/move/move-model/src/ast.rs (L1199-1216)
```rust
    /// Returns the Move functions called or referenced by this expression, along with nodes of call sites or references.
    pub fn used_funs_with_uses(&self) -> BTreeMap<QualifiedId<FunId>, BTreeSet<NodeId>> {
        let mut used: BTreeMap<_, BTreeSet<_>> = BTreeMap::new();
        let mut visitor = |e: &ExpData| {
            match e {
                ExpData::Call(node_id, Operation::MoveFunction(mid, fid), _)
                | ExpData::Call(node_id, Operation::Closure(mid, fid, _), _) => {
                    used.entry(mid.qualified(*fid))
                        .or_default()
                        .insert(*node_id);
                },
                _ => {},
            };
            true // keep going
        };
        self.visit_post_order(&mut visitor);
        used
    }
```

**File:** third_party/move/move-model/src/ast.rs (L1218-1229)
```rust
    /// Returns the Move functions called by this expression
    pub fn called_funs(&self) -> BTreeSet<QualifiedId<FunId>> {
        let mut called = BTreeSet::new();
        let mut visitor = |e: &ExpData| {
            if let ExpData::Call(_, Operation::MoveFunction(mid, fid), _) = e {
                called.insert(mid.qualified(*fid));
            };
            true // keep going
        };
        self.visit_post_order(&mut visitor);
        called
    }
```

**File:** third_party/move/move-model/src/ast.rs (L1249-1263)
```rust
    /// Returns the Move functions called by this expression, along with nodes of call sites.
    pub fn called_funs_with_callsites(&self) -> BTreeMap<QualifiedId<FunId>, BTreeSet<NodeId>> {
        let mut called: BTreeMap<_, BTreeSet<_>> = BTreeMap::new();
        let mut visitor = |e: &ExpData| {
            if let ExpData::Call(node_id, Operation::MoveFunction(mid, fid), _) = e {
                called
                    .entry(mid.qualified(*fid))
                    .or_default()
                    .insert(*node_id);
            }
            true // keep going
        };
        self.visit_post_order(&mut visitor);
        called
    }
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/spec_rewriter.rs (L68-96)
```rust
    // Identify the Move functions transitively called by those targets. They need to be
    // converted to spec functions.
    let mut called_funs = BTreeSet::new();
    for target in targets.keys() {
        let callees: BTreeSet<_> = match target {
            RewriteTarget::MoveFun(_) => {
                if let RewriteState::Def(def) = target.get_env_state(env) {
                    let mut spec_callees = BTreeSet::new();
                    def.visit_inline_specs(&mut |spec| {
                        spec_callees.extend(spec.used_funs_with_uses().into_keys());
                        true // keep going
                    });
                    spec_callees
                } else {
                    BTreeSet::new()
                }
            },
            RewriteTarget::SpecFun(_) | RewriteTarget::SpecBlock(_) => {
                target.used_funs_with_uses(env).into_keys().collect()
            },
        };
        for callee in callees {
            called_funs.insert(callee);
            let mut transitive = env
                .get_function(callee)
                .get_transitive_closure_of_called_functions();
            called_funs.append(&mut transitive);
        }
    }
```

**File:** third_party/move/move-model/src/builder/module_builder.rs (L3655-3685)
```rust
            let spec = self.fun_specs.remove(&name.symbol).unwrap_or_default();
            let def = self.fun_defs.remove(&name.symbol);
            let called_funs = Some(def.as_ref().map(|e| e.called_funs()).unwrap_or_default());
            let used_funs = Some(def.as_ref().map(|e| e.used_funs()).unwrap_or_default());
            let access_specifiers = self.fun_access_specifiers.remove(&name.symbol);
            let fun_id = FunId::new(name.symbol);
            let data = FunctionData {
                name: name.symbol,
                loc: FunctionLoc {
                    full: entry.loc.clone(),
                    id_loc: entry.name_loc.clone(),
                    result_type_loc: entry.result_type_loc.clone(),
                },
                def_idx: None,
                handle_idx: None,
                visibility: entry.visibility,
                has_package_visibility: self.package_funs.contains(&fun_id),
                is_native: entry.is_native,
                kind: entry.kind,
                attributes: entry.attributes.clone(),
                type_params: entry.type_params.clone(),
                params: entry.params.clone(),
                result_type: entry.result_type.clone(),
                access_specifiers,
                acquired_structs: None,
                spec: spec.into(),
                def,
                called_funs,
                calling_funs: RefCell::default(),
                transitive_closure_of_called_funs: RefCell::default(),
                used_funs,
```
