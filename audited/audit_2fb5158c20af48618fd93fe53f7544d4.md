# Audit Report

## Title
Incorrect `more` Field in Epoch Change Proofs Causes Peer Desynchronization and State Sync Failures

## Summary
The storage service's `get_epoch_ending_ledger_infos_by_size` function unconditionally sets the `more` field to `false` in `EpochChangeProof` responses, even when the response is incomplete due to size limits, time limits, or missing data. This causes clients to incorrectly believe they have received all requested epoch-ending ledger infos, leading to verification failures and peer desynchronization.

## Finding Description
The vulnerability exists in the size-and-time-aware chunking implementation of epoch ending ledger info retrieval. When a client requests epoch-ending ledger infos from `start_epoch` to `expected_end_epoch`, the server may return fewer epochs than requested due to three distinct conditions:

**1. Size limitations**: The response progress tracker determines that the next ledger info would exceed `max_response_size`, causing the loop to break early. [1](#0-0) 

**2. Time limitations**: The storage read duration exceeds `max_storage_read_wait_time_ms`, causing `is_response_complete()` to return true. [2](#0-1) [3](#0-2) 

**3. Missing data**: The underlying storage iterator runs out of data prematurely, returning `None`. [4](#0-3) 

In all three cases, the function unconditionally creates an `EpochChangeProof` with `more = false`, incorrectly signaling that all requested epochs have been provided. [5](#0-4) 

This breaks the epoch change verification protocol. When a client receives an incomplete `EpochChangeProof` with `more = false` and then receives a `latest_ledger_info` from an epoch beyond what was provided in the proof, the verification logic rejects it as inconsistent. [6](#0-5) 

The condition at line 183 requires `epoch_change_proof.more` to be `true` when the latest ledger info's epoch exceeds the proof's epoch range. Since `more` is incorrectly set to `false`, the verification fails with "Inconsistent epoch change proof and latest ledger info", even though the proof is simply incomplete, not inconsistent.

The underlying database implementation correctly determines the `more` field by checking if the requested range exceeds the limit. [7](#0-6)  However, the storage service layer discards this information in the new implementation.

The test suite confirms this protocol semantics, demonstrating that `more = false` with a gap causes verification failure, while `more = true` allows the verification to succeed. [8](#0-7) 

## Impact Explanation
This is a **HIGH severity** vulnerability per the Aptos bug bounty program criteria, specifically matching category #8 "Validator Node Slowdowns":

1. **Validator Node Slowdowns**: Nodes repeatedly fail to verify valid epoch changes, causing them to trigger stream resets [9](#0-8)  and retry requests, fall behind in synchronization, and experience degraded performance.

2. **Significant Protocol Violations**: The `more` field is part of the state synchronization protocol's contract. Setting it incorrectly violates the protocol's correctness guarantees and breaks the trust model between peers.

3. **Peer Desynchronization**: Different nodes may have different views of which epochs are "complete," leading to inconsistent state across the network. A node with incomplete epoch data marked as complete may make incorrect decisions about which peers to trust or which epoch changes to accept.

4. **State Sync Liveness Issues**: Nodes may become stuck unable to progress past certain epochs when legitimate epoch change proofs are rejected as "inconsistent." While retry logic exists, if all peers have the same size/time limitations, the retries will continue to fail with the same error.

## Likelihood Explanation
This vulnerability has **HIGH likelihood** of occurrence:

1. **Natural Triggers**: The bug is triggered naturally during normal operations when a node is syncing from a lagging peer that doesn't have all requested epochs, response size limits are exceeded for large epoch change proofs, or storage read times exceed configured limits during heavy load.

2. **No Attacker Required**: The vulnerability manifests without malicious intent. Any node that is behind in synchronization or experiences slow storage reads will serve incorrect `more` flags.

3. **Common Scenario**: During network upgrades or when new nodes join, they must sync through many epochs. If any peer in the sync path has size or time limitations, incorrect `more` flags will be served.

4. **Configuration Dependent**: The feature is enabled by default. [10](#0-9)  When `enable_size_and_time_aware_chunking` is enabled (which is the modern, recommended configuration), the buggy code path is always used.

## Recommendation
The `get_epoch_ending_ledger_infos_by_size` function should correctly set the `more` field based on whether the response is complete:

```rust
// Determine if there are more epochs to fetch
let more = self.num_items_fetched < self.num_items_to_fetch;

// Create the epoch change proof with the correct more flag
let epoch_change_proof = EpochChangeProof::new(epoch_ending_ledger_infos, more);
```

Specifically, `more` should be set to `true` when:
- The loop broke due to size limitations
- The loop broke due to time limitations  
- The iterator returned `None` before fetching all requested epochs

The fix should check `response_progress_tracker.num_items_fetched < num_ledger_infos_to_fetch` to determine the correct value.

## Proof of Concept
The vulnerability can be demonstrated by:

1. Configuring a storage service with a small `max_network_chunk_bytes` (e.g., 1KB)
2. Creating epoch ending ledger infos that exceed this size limit
3. Requesting multiple epochs and observing the truncated response with `more = false`
4. Attempting to verify the incomplete proof with a later epoch's ledger info
5. Observing the "Inconsistent epoch change proof and latest ledger info" error

The test case at `trusted_state_test.rs` already validates the protocol semantics, showing that incomplete proofs with `more = false` correctly fail verification while `more = true` allows them to succeed.

### Citations

**File:** state-sync/storage-service/server/src/storage.rs (L256-256)
```rust
        while !response_progress_tracker.is_response_complete() {
```

**File:** state-sync/storage-service/server/src/storage.rs (L264-271)
```rust
                    if response_progress_tracker
                        .data_items_fits_in_response(true, num_serialized_bytes)
                    {
                        epoch_ending_ledger_infos.push(epoch_ending_ledger_info);
                        response_progress_tracker.add_data_item(num_serialized_bytes);
                    } else {
                        break; // Cannot add any more data items
                    }
```

**File:** state-sync/storage-service/server/src/storage.rs (L276-284)
```rust
                None => {
                    // Log a warning that the iterator did not contain all the expected data
                    warn!(
                        "The epoch ending ledger info iterator is missing data! \
                        Start epoch: {:?}, expected end epoch: {:?}, num ledger infos to fetch: {:?}",
                        start_epoch, expected_end_epoch, num_ledger_infos_to_fetch
                    );
                    break;
                },
```

**File:** state-sync/storage-service/server/src/storage.rs (L288-289)
```rust
        // Create the epoch change proof
        let epoch_change_proof = EpochChangeProof::new(epoch_ending_ledger_infos, false);
```

**File:** state-sync/storage-service/server/src/storage.rs (L1427-1430)
```rust
        // If the storage read duration exceeds the maximum, the response is complete
        if self.overflowed_storage_read_duration() {
            return true;
        }
```

**File:** types/src/trusted_state.rs (L183-186)
```rust
            } else if latest_li.ledger_info().epoch() > new_epoch && epoch_change_proof.more {
                epoch_change_li
            } else {
                bail!("Inconsistent epoch change proof and latest ledger info");
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L1044-1048)
```rust
        let (paging_epoch, more) = if end_epoch - start_epoch > limit as u64 {
            (start_epoch + limit as u64, true)
        } else {
            (end_epoch, false)
        };
```

**File:** types/src/unit_tests/trusted_state_test.rs (L387-399)
```rust
        // ratcheting with more = false should fail, since the state proof claims
        // we're done syncing epoch changes but doesn't get us all the way to the
        // latest ledger info
        let mut change_proof = EpochChangeProof::new(lis_with_sigs, false /* more */);
        trusted_state
            .verify_and_ratchet_inner(&latest_li, &change_proof)
            .expect_err("Should return Err when more is false and there's a gap");

        // ratcheting with more = true is fine
        change_proof.more = true;
        let trusted_state_change = trusted_state
            .verify_and_ratchet_inner(&latest_li, &change_proof)
            .expect("Should succeed with more in EpochChangeProof");
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1099-1104)
```rust
                self.reset_active_stream(Some(NotificationAndFeedback::new(
                    notification_id,
                    NotificationFeedback::PayloadProofFailed,
                )))
                .await?;
                return Err(error);
```

**File:** config/src/config/state_sync_config.rs (L14-14)
```rust
const ENABLE_SIZE_AND_TIME_AWARE_CHUNKING: bool = true;
```
