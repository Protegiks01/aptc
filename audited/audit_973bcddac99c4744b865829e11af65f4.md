# Audit Report

## Title
Denial of Service via Integer Logarithm Panic in Digest Computation with Empty Ciphertext Arrays

## Summary
The `DigestKey::digest()` function can be triggered to panic when processing empty ciphertext arrays, causing a Denial of Service on validator nodes. The panic occurs in `compute_mult_tree()` when computing `0.ilog2()`, which happens before reaching the MSM operation mentioned in the security question.

## Finding Description

The vulnerability exists in the batch encryption digest computation path. When an empty ciphertext array is passed to the digest function, it creates an `IdSet` with zero capacity and empty polynomial roots. This eventually leads to a panic in the multiplication tree construction.

**Execution Flow:**

1. Attacker calls digest with empty ciphertext array: `digest_key.digest(&mut ids, round)` where `ids` is created from `[]` [1](#0-0) 

2. `IdSet::from_slice(&[])` creates an IdSet with `capacity = 0` and empty `poly_roots` [2](#0-1) 

3. The capacity check passes: `0 > tau_powers_g1[round].len() - 1` evaluates to false (assuming tau_powers_g1 has at least 1 element) [3](#0-2) 

4. `compute_poly_coeffs()` is called, which invokes `compute_mult_tree(&[])` with empty roots [4](#0-3) 

5. In `compute_mult_tree()`, when `roots` is empty:
   - `bases` becomes empty after mapping
   - `bases.resize(0, ...)` keeps it empty  
   - `num_leaves = 0`
   - Line 21: `depth = num_leaves.ilog2()` â†’ **PANIC** with "argument of integer logarithm must be positive" [5](#0-4) 

**Note:** While the security question asks about `msm().unwrap()` at line 128, the actual panic occurs earlier in the call chain at `compute_mult_tree`. The `msm()` operation would likely not return None because `coeffs.resize()` ensures matching lengths, but the code never reaches that point due to the earlier panic. [6](#0-5) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:
- **Validator node crashes**: Any validator processing an empty digest request will panic and crash
- **Consensus disruption**: Multiple validators crashing simultaneously could impact liveness
- **API crashes**: Nodes with exposed APIs accepting digest requests become vulnerable to trivial DoS

The vulnerability does not cause loss of funds or permanent state corruption, but it enables easy denial of service attacks against validator infrastructure.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploited because:
1. **No authentication required**: The digest function is part of the batch encryption protocol that processes user-submitted ciphertexts
2. **Trivial exploit**: Attacker simply needs to submit an empty ciphertext array
3. **Deterministic crash**: The panic is guaranteed when the condition is met
4. **No resource cost**: Unlike many DoS attacks, this requires minimal resources from the attacker

The only uncertainty is whether the batch encryption module is actively deployed in consensus paths where external inputs could trigger this vulnerability.

## Recommendation

Add validation to reject empty ciphertext arrays before processing:

**Option 1: Validate in digest implementations**
```rust
// In fptx.rs, fptx_succinct.rs, fptx_weighted.rs
fn digest(
    digest_key: &Self::DigestKey,
    cts: &[Self::Ciphertext],
    round: Self::Round,
) -> anyhow::Result<(Self::Digest, Self::EvalProofsPromise)> {
    if cts.is_empty() {
        return Err(anyhow!("Cannot compute digest for empty ciphertext array"));
    }
    // ... existing code
}
```

**Option 2: Validate in compute_mult_tree**
```rust
// In mult_tree.rs
pub fn compute_mult_tree<F: FftField>(roots: &[F]) -> Vec<Vec<DensePolynomial<F>>> {
    if roots.is_empty() {
        return vec![vec![DenseUVPolynomial::from_coefficients_vec(vec![F::one()])]];
    }
    // ... existing code
}
```

**Option 3: Validate in IdSet::from_slice**
```rust
// In ids/mod.rs
pub fn from_slice(ids: &[Id]) -> Option<Self> {
    if ids.is_empty() {
        return None; // or return error
    }
    // ... existing code
}
```

**Recommended approach:** Implement Option 1 at the API boundary to provide clear error messages and prevent invalid inputs from entering the system.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "argument of integer logarithm must be positive")]
fn test_empty_ciphertext_dos() {
    use ark_std::rand::thread_rng;
    use crate::shared::digest::DigestKey;
    use crate::shared::ids::{IdSet, UncomputedCoeffs};
    
    let mut rng = thread_rng();
    let batch_size = 8;
    let num_rounds = 1;
    
    // Create valid digest key
    let digest_key = DigestKey::new(&mut rng, batch_size, num_rounds).unwrap();
    
    // Create empty IdSet (simulating empty ciphertext array)
    let mut ids: IdSet<UncomputedCoeffs> = IdSet::from_slice(&[]).unwrap();
    
    // This will panic in compute_mult_tree with 0.ilog2()
    let _result = digest_key.digest(&mut ids, 0);
}
```

This test demonstrates that calling `digest()` with an empty IdSet causes a panic in `compute_mult_tree` when it attempts to compute `0.ilog2()`.

## Notes

The security question specifically mentions line 128 (`msm().unwrap()`), but the actual panic occurs earlier at line 21 of `mult_tree.rs` in the `0.ilog2()` call. Both issues are in the same execution path triggered by empty ciphertext arrays, but the `mult_tree` panic executes first. The `msm().unwrap()` is additionally protected by the `coeffs.resize()` call that ensures length matching, making it less likely to panic even if execution reached that point.

### Citations

**File:** crates/aptos-batch-encryption/src/schemes/fptx.rs (L105-109)
```rust
        let mut ids: IdSet<UncomputedCoeffs> =
            IdSet::from_slice(&cts.iter().map(|ct| ct.id()).collect::<Vec<Id>>())
                .ok_or(anyhow!(""))?;

        digest_key.digest(&mut ids, round)
```

**File:** crates/aptos-batch-encryption/src/shared/ids/mod.rs (L63-68)
```rust
    pub fn from_slice(ids: &[Id]) -> Option<Self> {
        let mut result = Self::with_capacity(ids.len())?;
        for id in ids {
            result.add(id);
        }
        Some(result)
```

**File:** crates/aptos-batch-encryption/src/shared/ids/mod.rs (L91-101)
```rust
    pub fn compute_poly_coeffs(&self) -> IdSet<ComputedCoeffs> {
        let mult_tree = compute_mult_tree(&self.poly_roots);

        IdSet {
            poly_roots: self.poly_roots.clone(),
            capacity: self.capacity,
            poly_coeffs: ComputedCoeffs {
                coeffs: mult_tree[mult_tree.len() - 1][0].coeffs.clone(),
                mult_tree,
            },
        }
```

**File:** crates/aptos-batch-encryption/src/shared/digest.rs (L116-122)
```rust
        } else if ids.capacity() > self.tau_powers_g1[round].len() - 1 {
            Err(anyhow!(
                "Tried to compute a batch digest with size {}, where setup supports up to size {}",
                ids.capacity(),
                self.tau_powers_g1[round].len() - 1
            ))?
        } else {
```

**File:** crates/aptos-batch-encryption/src/shared/digest.rs (L123-132)
```rust
            let ids = ids.compute_poly_coeffs();
            let mut coeffs = ids.poly_coeffs();
            coeffs.resize(self.tau_powers_g1[round].len(), Fr::zero());

            let digest = Digest {
                digest_g1: G1Projective::msm(&self.tau_powers_g1[round], &coeffs)
                    .unwrap()
                    .into(),
                round,
            };
```

**File:** crates/aptos-batch-encryption/src/shared/algebra/mult_tree.rs (L7-23)
```rust
pub fn compute_mult_tree<F: FftField>(roots: &[F]) -> Vec<Vec<DensePolynomial<F>>> {
    let mut bases: Vec<DensePolynomial<F>> = roots
        .iter()
        .cloned()
        .map(|u| DenseUVPolynomial::from_coefficients_vec(vec![-u, F::one()]))
        .collect();

    bases.resize(
        bases.len().next_power_of_two(),
        DenseUVPolynomial::from_coefficients_vec(vec![F::one()]),
    );

    let num_leaves = bases.len();
    let mut result = vec![bases];
    let depth = num_leaves.ilog2();
    assert_eq!(2usize.pow(depth), num_leaves);

```
