# Audit Report

## Title
Unauthenticated Remote SafetyRules Service Allows MITM Attacks on Consensus Signing Operations

## Summary
The SafetyRules `Process` service mode establishes an unauthenticated, unencrypted TCP connection to transmit consensus-critical signing requests, enabling Man-in-the-Middle (MITM) attacks that can compromise validator consensus operations, leading to equivocation, slashing, and potential consensus safety violations.

## Finding Description

The SafetyRules component is responsible for enforcing consensus safety rules and cryptographically signing block proposals, votes, and timeouts using the validator's BLS private key. When configured in `Process` service mode, SafetyRules runs as a separate service that the consensus node communicates with over a network connection.

The vulnerability exists in how this remote connection is established. The `new_process()` function creates a `ProcessService` that connects to a remote SafetyRules server: [1](#0-0) 

This ProcessService implements the `RemoteService` trait, which creates a `NetworkClient`: [2](#0-1) 

The critical flaw is that `NetworkClient` uses plain TCP connections without any TLS encryption or authentication mechanism: [3](#0-2) 

The connection is established using `TcpStream::connect_timeout()` with only `set_nodelay(true)` configured—no TLS wrapper, no certificate validation, no authentication handshake.

Over this unprotected channel, the system transmits highly sensitive consensus operations serialized as JSON: [4](#0-3) 

These operations include:
- **SignProposal**: Signs block proposals with the validator's BLS private key
- **ConstructAndSignVoteTwoChain**: Creates and signs consensus votes
- **SignTimeoutWithQC**: Signs timeout messages
- **SignCommitVote**: Signs commit votes for finalization
- **ConstructAndSignOrderVote**: Signs ordering votes

All requests and responses flow through the `RemoteClient` which simply writes serialized data to the TCP stream: [5](#0-4) 

### Attack Scenario

An attacker with a network MITM position (e.g., compromised router, ARP spoofing, BGP hijacking) between the consensus node and SafetyRules server can:

1. **Intercept signing requests** containing block proposals, vote proposals, and other consensus-critical data
2. **Modify requests** to change what gets signed (e.g., alter block data, change proposed rounds)
3. **Replay old signing requests** to cause the validator to double-sign or equivocate
4. **Inject malicious requests** to sign adversarial blocks or votes
5. **Learn validator's consensus state** by observing all signing operations

This breaks the fundamental **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine validators."

## Impact Explanation

**Severity: Critical** (per Aptos Bug Bounty Program)

This vulnerability qualifies as **Critical** because it enables:

1. **Consensus/Safety Violations**: An attacker can cause a validator to:
   - Sign conflicting blocks at the same round (equivocation)
   - Sign votes for multiple competing chains
   - Double-sign timeout messages
   - These violations break BFT safety guarantees and can lead to chain splits

2. **Loss of Funds**: The validator's stake can be slashed for equivocation or malicious behavior induced by the attacker. With a validator stake potentially worth millions of dollars, this represents direct loss of funds.

3. **Network Partition Risk**: If multiple validators are compromised this way, an attacker could orchestrate a consensus split requiring intervention or hardfork to resolve.

While the configuration sanitizer prevents this mode on mainnet (line 99 checks `chain_id.is_mainnet()`): [6](#0-5) 

The vulnerability still exists in the codebase and is described as "the production, separate service approach": [7](#0-6) 

This means:
- **Testnets are vulnerable** (no mainnet check)
- **Private deployments are vulnerable** if they use this mode
- **Risk of accidental enablement** through misconfiguration
- **Code represents dangerous pattern** that could be copied elsewhere

## Likelihood Explanation

**Likelihood: Medium to High**

While mainnet validators are protected by the config sanitizer, the likelihood remains significant because:

1. **Testnets actively use this mode**: Development and staging environments likely use the Process service mode for isolation, making them immediate targets
2. **MITM attacks are feasible**: Attackers can position themselves via:
   - Compromised network infrastructure (routers, switches)
   - ARP/NDP spoofing on local networks
   - BGP hijacking for cross-network attacks
   - Compromised cloud provider infrastructure
   - DNS spoofing if hostnames are used

3. **High-value target**: Validators represent high-value targets with significant stake at risk
4. **No authentication barrier**: Unlike authenticated protocols, there's no cryptographic hurdle for the attacker to overcome—just network position
5. **Silent exploitation**: The attack leaves minimal traces since valid operations are being performed, just initiated by an attacker

## Recommendation

Implement mutual TLS (mTLS) authentication for the SafetyRules remote service:

**1. Add TLS support to NetworkClient/NetworkServer:**

```rust
use rustls::{ClientConfig, ServerConfig};
use rustls_pemfile;
use std::sync::Arc;

pub struct NetworkClient {
    service: String,
    server: SocketAddr,
    stream: Option<NetworkStream>,
    timeout_ms: u64,
    tls_config: Option<Arc<ClientConfig>>, // Add TLS config
}

impl NetworkClient {
    pub fn new_with_tls(
        service: String, 
        server: SocketAddr, 
        timeout_ms: u64,
        tls_config: Arc<ClientConfig>
    ) -> Self {
        Self {
            service,
            server,
            stream: None,
            timeout_ms,
            tls_config: Some(tls_config),
        }
    }
    
    fn server(&mut self) -> Result<&mut NetworkStream, Error> {
        if self.stream.is_none() {
            let timeout = std::time::Duration::from_millis(self.timeout_ms);
            let tcp_stream = TcpStream::connect_timeout(&self.server, timeout)?;
            tcp_stream.set_nodelay(true)?;
            
            // Wrap in TLS if configured
            let stream = if let Some(tls_config) = &self.tls_config {
                let server_name = rustls::ServerName::try_from("safety-rules")
                    .map_err(|_| Error::NetworkError(std::io::Error::new(
                        std::io::ErrorKind::InvalidInput, 
                        "Invalid server name"
                    )))?;
                let tls_stream = rustls::StreamOwned::new(
                    rustls::ClientConnection::new(tls_config.clone(), server_name)?,
                    tcp_stream
                );
                Box::new(tls_stream) as Box<dyn Read + Write>
            } else {
                Box::new(tcp_stream) as Box<dyn Read + Write>
            };
            
            self.stream = Some(NetworkStream::new(stream, self.server, self.timeout_ms));
        }
        self.stream.as_mut().ok_or(Error::NoActiveStream)
    }
}
```

**2. Update SafetyRulesConfig to include TLS certificates:**

```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub struct RemoteService {
    pub server_address: NetworkAddress,
    pub tls_cert_path: Option<PathBuf>,
    pub tls_key_path: Option<PathBuf>,
    pub tls_ca_path: Option<PathBuf>,
}
```

**3. Update RemoteService trait to use TLS-enabled client:**

```rust
pub trait RemoteService {
    fn client(&self) -> SerializerClient {
        let network_client = if self.has_tls_config() {
            let tls_config = self.load_tls_config()
                .expect("Failed to load TLS config");
            NetworkClient::new_with_tls(
                "safety-rules".to_string(),
                self.server_address(),
                self.network_timeout_ms(),
                tls_config,
            )
        } else {
            NetworkClient::new(
                "safety-rules".to_string(),
                self.server_address(),
                self.network_timeout_ms(),
            )
        };
        let service = Box::new(RemoteClient::new(network_client));
        SerializerClient::new_client(service)
    }
}
```

**4. Enforce TLS in production:**

Update the config sanitizer to require TLS for Process mode:

```rust
// In safety_rules_config.rs sanitize()
if let SafetyRulesService::Process(remote_service) = &safety_rules_config.service {
    if remote_service.tls_cert_path.is_none() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Process mode must use TLS authentication. Configure tls_cert_path, tls_key_path, and tls_ca_path.".to_string(),
        ));
    }
}
```

## Proof of Concept

```rust
// poc_mitm_safety_rules.rs
// Demonstrates MITM interception of SafetyRules signing requests

use std::net::{TcpListener, TcpStream};
use std::io::{Read, Write};
use std::thread;

/// Simulated MITM proxy that intercepts SafetyRules traffic
fn mitm_proxy(listen_addr: &str, target_addr: &str) {
    let listener = TcpListener::bind(listen_addr).unwrap();
    println!("[MITM] Listening on {}", listen_addr);
    
    for stream in listener.incoming() {
        let mut client = stream.unwrap();
        let mut server = TcpStream::connect(target_addr).unwrap();
        println!("[MITM] Connection established - intercepting traffic");
        
        // Spawn threads to proxy both directions
        let mut client_clone = client.try_clone().unwrap();
        let mut server_clone = server.try_clone().unwrap();
        
        // Client -> Server (intercept requests)
        thread::spawn(move || {
            let mut buffer = vec![0u8; 4096];
            loop {
                match client_clone.read(&mut buffer) {
                    Ok(n) if n > 0 => {
                        // Parse the length-prefixed message
                        if n >= 4 {
                            let len = u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]) as usize;
                            if n >= 4 + len {
                                let msg = &buffer[4..4+len];
                                let json: serde_json::Value = serde_json::from_slice(msg).unwrap();
                                println!("[MITM] Intercepted request: {}", json);
                                
                                // Attacker can modify the request here!
                                // For example, change the round number, block data, etc.
                                
                                server_clone.write_all(&buffer[..n]).unwrap();
                            }
                        }
                    },
                    _ => break,
                }
            }
        });
        
        // Server -> Client (intercept responses)
        thread::spawn(move || {
            let mut buffer = vec![0u8; 4096];
            loop {
                match server.read(&mut buffer) {
                    Ok(n) if n > 0 => {
                        if n >= 4 {
                            let len = u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]]) as usize;
                            if n >= 4 + len {
                                let msg = &buffer[4..4+len];
                                let json: serde_json::Value = serde_json::from_slice(msg).unwrap();
                                println!("[MITM] Intercepted response (signature): {}", json);
                                // Attacker now has visibility into all signed data
                            }
                        }
                        client.write_all(&buffer[..n]).unwrap();
                    },
                    _ => break,
                }
            }
        });
    }
}

#[test]
fn test_mitm_attack() {
    // 1. Start legitimate SafetyRules server on port 6191
    // 2. Start MITM proxy on port 6190 forwarding to 6191
    // 3. Configure consensus to connect to port 6190 instead of 6191
    // 4. Observe all signing requests passing through MITM
    
    thread::spawn(|| {
        mitm_proxy("127.0.0.1:6190", "127.0.0.1:6191");
    });
    
    // Consensus node connects to 6190 thinking it's the real server
    // All SafetyRulesInput messages (SignProposal, ConstructAndSignVoteTwoChain, etc.)
    // are now visible and modifiable by the attacker
}
```

**To reproduce:**

1. Configure a validator with `SafetyRulesService::Process` mode pointing to a remote address
2. Position a MITM proxy between consensus and SafetyRules (e.g., via ARP spoofing)
3. Intercept and log all `SafetyRulesInput` messages (block proposals, vote requests, etc.)
4. Optionally modify requests to cause double-signing or other consensus violations
5. Observe that the validator processes modified requests without detecting tampering

## Notes

While the mainnet config sanitizer provides defense-in-depth, the fundamental security issue remains:

1. **Testnets are exposed**: Any non-mainnet deployment using Process mode is vulnerable
2. **Code smell**: The existence of unauthenticated remote signing represents a dangerous pattern
3. **Future risk**: Configuration errors, bypasses, or new deployment modes could re-expose this
4. **Compliance concern**: Handling cryptographic signing operations over unauthenticated channels violates security best practices

The vulnerability should be fixed by implementing mTLS rather than relying solely on configuration restrictions.

### Citations

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L138-143)
```rust
    pub fn new_process(server_addr: SocketAddr, timeout_ms: u64) -> Self {
        let process_service = ProcessService::new(server_addr, timeout_ms);
        Self {
            internal_safety_rules: SafetyRulesWrapper::Process(process_service),
        }
    }
```

**File:** consensus/safety-rules/src/remote_service.rs (L13-28)
```rust
pub trait RemoteService {
    fn client(&self) -> SerializerClient {
        let network_client = NetworkClient::new(
            "safety-rules".to_string(),
            self.server_address(),
            self.network_timeout_ms(),
        );
        let service = Box::new(RemoteClient::new(network_client));
        SerializerClient::new_client(service)
    }

    fn server_address(&self) -> SocketAddr;

    /// Network Timeout in milliseconds.
    fn network_timeout_ms(&self) -> u64;
}
```

**File:** consensus/safety-rules/src/remote_service.rs (L57-82)
```rust
struct RemoteClient {
    network_client: NetworkClient,
}

impl RemoteClient {
    pub fn new(network_client: NetworkClient) -> Self {
        Self { network_client }
    }

    fn process_one_message(&mut self, input: &[u8]) -> Result<Vec<u8>, Error> {
        self.network_client.write(input)?;
        self.network_client.read().map_err(|e| e.into())
    }
}

impl TSerializerClient for RemoteClient {
    fn request(&mut self, input: SafetyRulesInput) -> Result<Vec<u8>, Error> {
        let input_message = serde_json::to_vec(&input)?;
        loop {
            match self.process_one_message(&input_message) {
                Err(err) => warn!("Failed to communicate with SafetyRules service: {}", err),
                Ok(value) => return Ok(value),
            }
        }
    }
}
```

**File:** secure/net/src/lib.rs (L228-269)
```rust
    fn server(&mut self) -> Result<&mut NetworkStream, Error> {
        if self.stream.is_none() {
            self.increment_counter(Method::Connect, MethodResult::Query);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Client,
                LogEvent::ConnectionAttempt,
            )
            .remote_peer(&self.server));

            let timeout = std::time::Duration::from_millis(self.timeout_ms);
            let mut stream = TcpStream::connect_timeout(&self.server, timeout);

            let sleeptime = time::Duration::from_millis(100);
            while let Err(err) = stream {
                self.increment_counter(Method::Connect, MethodResult::Failure);
                warn!(SecureNetLogSchema::new(
                    &self.service,
                    NetworkMode::Client,
                    LogEvent::ConnectionFailed,
                )
                .error(&err.into())
                .remote_peer(&self.server));

                thread::sleep(sleeptime);
                stream = TcpStream::connect_timeout(&self.server, timeout);
            }

            let stream = stream?;
            stream.set_nodelay(true)?;
            self.stream = Some(NetworkStream::new(stream, self.server, self.timeout_ms));
            self.increment_counter(Method::Connect, MethodResult::Success);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Client,
                LogEvent::ConnectionSuccessful,
            )
            .remote_peer(&self.server));
        }

        self.stream.as_mut().ok_or(Error::NoActiveStream)
    }
```

**File:** consensus/safety-rules/src/serializer.rs (L22-34)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum SafetyRulesInput {
    ConsensusState,
    Initialize(Box<EpochChangeProof>),
    SignProposal(Box<BlockData>),
    SignTimeoutWithQC(
        Box<TwoChainTimeout>,
        Box<Option<TwoChainTimeoutCertificate>>,
    ),
    ConstructAndSignVoteTwoChain(Box<VoteProposal>, Box<Option<TwoChainTimeoutCertificate>>),
    ConstructAndSignOrderVote(Box<OrderVoteProposal>),
    SignCommitVote(Box<LedgerInfoWithSignatures>, Box<LedgerInfo>),
}
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```

**File:** config/src/config/safety_rules_config.rs (L203-216)
```rust
/// Defines how safety rules should be executed
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case", tag = "type")]
pub enum SafetyRulesService {
    /// This runs safety rules in the same thread as event processor
    Local,
    /// This is the production, separate service approach
    Process(RemoteService),
    /// This runs safety rules in the same thread as event processor but data is passed through the
    /// light weight RPC (serializer)
    Serializer,
    /// This creates a separate thread to run safety rules, it is similar to a fork / exec style
    Thread,
}
```
