# Audit Report

## Title
Telemetry Authentication Panic Causes Complete Node Crash via Malformed Handshake Response

## Summary
A malicious or compromised telemetry service can crash any Aptos node by sending a malformed `handshake_msg` in the authentication response. The `authenticate()` function uses `.unwrap()` on the result of `finalize_connection()`, causing a panic that terminates the entire node process via the global panic handler.

## Finding Description

The vulnerability exists in the telemetry client authentication flow where nodes authenticate with the telemetry service using the Noise IK protocol. [1](#0-0) 

The critical issue is at lines 346-348 where `finalize_connection()` is called with `.unwrap()`: [2](#0-1) 

The `AuthResponse` structure has no validation on the `handshake_msg` field: [3](#0-2) 

The server can send any byte vector as `handshake_msg`, and it will successfully deserialize at line 336: [4](#0-3) 

However, `finalize_connection()` can fail with multiple errors: [5](#0-4) 

When `finalize_connection()` returns an error (e.g., `NoiseError::MsgTooShort` or `NoiseError::Decrypt`), the `.unwrap()` panics. The global panic handler then terminates the **entire node process**: [6](#0-5) 

**Attack Flow:**

1. Node starts and initializes telemetry service early in boot sequence: [7](#0-6) 

2. Telemetry tasks periodically call `send_authenticated_request()` which triggers `get_auth_token()`: [8](#0-7) 

3. When authentication is needed, malicious server sends malformed response:
   - Empty `handshake_msg` → causes `NoiseError::MsgTooShort`
   - Short `handshake_msg` (< 32 bytes) → causes `NoiseError::MsgTooShort`
   - Invalid ciphertext → causes `NoiseError::Decrypt`

4. The `.unwrap()` panics, panic handler executes `process::exit(12)`, node crashes

## Impact Explanation

This vulnerability achieves **High Severity** per Aptos bug bounty criteria:

- **"Validator node slowdowns"** - Actually causes complete validator node crashes
- **"API crashes"** - Terminates the entire node process, not just API

The impact includes:
- **Complete node unavailability** - The node process exits entirely
- **Validator set disruption** - Crashed validators cannot participate in consensus
- **Network degradation** - If multiple validators use the same telemetry endpoint and it's compromised, widespread crashes possible
- **Automatic restart loops** - If orchestration systems restart the node, it will crash again on next authentication

This does NOT qualify as Critical because:
- It affects individual nodes, not the entire network
- Requires control of telemetry service endpoint
- No consensus safety violation (just liveness degradation)
- No fund loss or permanent state corruption

## Likelihood Explanation

**Likelihood: Medium-High**

Requirements for exploitation:
1. **Compromise telemetry service endpoint** - Attacker needs to either:
   - Compromise the official telemetry service
   - Perform MITM attack on telemetry connections
   - Social engineer operators to use malicious telemetry URL via `ENV_TELEMETRY_SERVICE_URL`

2. **Target has telemetry enabled** - This is the default configuration [9](#0-8) 

3. **Trigger authentication** - Happens automatically:
   - On node startup
   - When tokens expire and need renewal (401 response triggers re-auth) [10](#0-9) 

The attack is trivial to execute once the telemetry endpoint is controlled - simply return a JSON response with empty or malformed `handshake_msg`.

## Recommendation

Replace the `.unwrap()` with proper error handling:

```rust
pub async fn authenticate(&self) -> Result<String, anyhow::Error> {
    // ... existing code ...
    
    let resp = match error_for_status_with_body(response).await {
        Ok(response) => Ok(response.json::<AuthResponse>().await?),
        Err(err) => {
            debug!(
                "[telemetry-client] Error sending authentication request: {}",
                err,
            );
            Err(anyhow!("error {}", err))
        },
    }?;

    // Replace .unwrap() with proper error handling
    let (response_payload, _) = noise_config
        .finalize_connection(initiator_state, resp.handshake_msg.as_slice())
        .map_err(|e| {
            anyhow!(
                "Failed to finalize Noise handshake with telemetry service: {}. \
                This may indicate a compromised or misconfigured telemetry endpoint.",
                e
            )
        })?;

    let jwt = String::from_utf8(response_payload)?;

    Ok(jwt)
}
```

Additionally, add validation on `AuthResponse` deserialization to check minimum size requirements:

```rust
impl AuthResponse {
    fn validate(&self) -> Result<(), anyhow::Error> {
        // Minimum size: 32 bytes ephemeral key + 16 bytes auth tag
        if self.handshake_msg.len() < 48 {
            return Err(anyhow!("handshake_msg too short"));
        }
        Ok(())
    }
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_malformed_handshake_causes_panic() {
    use aptos_crypto::Uniform;
    use aptos_telemetry_service::types::auth::AuthResponse;
    use httpmock::MockServer;
    use std::panic;
    
    let server = MockServer::start();
    
    // Mock server returns malformed AuthResponse
    let mock = server.mock(|when, then| {
        when.method("POST").path("/api/v1/auth");
        then.status(200).json_body_obj(&AuthResponse {
            handshake_msg: vec![0u8; 10], // Too short - will cause MsgTooShort error
        });
    });
    
    // Mock the index endpoint to return server public key
    let mut rng = rand::thread_rng();
    let server_private_key = x25519::PrivateKey::generate(&mut rng);
    server.mock(|when, then| {
        when.method("GET").path("/api/v1/");
        then.status(200).json_body_obj(&IndexResponse {
            public_key: server_private_key.public_key(),
        });
    });
    
    let mut node_config = NodeConfig::default();
    // Set a private key for authentication
    let client_private_key = x25519::PrivateKey::generate(&mut rng);
    node_config.set_identity_key(client_private_key);
    
    let client = TelemetrySender::new(
        Url::parse(&server.base_url()).unwrap(),
        ChainId::default(),
        &node_config,
    );
    
    // This will panic with "called `Result::unwrap()` on an `Err` value"
    // In production, this panic propagates to the panic handler which calls process::exit(12)
    let result = panic::catch_unwind(panic::AssertUnwindSafe(|| {
        tokio::runtime::Runtime::new().unwrap().block_on(async {
            client.authenticate().await
        })
    }));
    
    assert!(result.is_err(), "Expected panic due to .unwrap() on finalize_connection error");
}
```

**Notes:**
- The vulnerability requires controlling the telemetry service endpoint, but does not require validator privileges
- The crash is deterministic and repeatable
- The panic handler terminates the entire process, not just the telemetry thread
- Nodes can be protected by disabling telemetry via `ENV_APTOS_DISABLE_TELEMETRY=true` environment variable
- The fix requires replacing `.unwrap()` with proper error handling throughout the authentication flow

### Citations

**File:** crates/aptos-telemetry/src/sender.rs (L100-123)
```rust
    pub async fn send_authenticated_request(
        &self,
        request_builder: RequestBuilder,
    ) -> Result<Response, anyhow::Error> {
        let token = self.get_auth_token().await?;

        let request = request_builder
            .try_clone()
            .expect("Could not clone request_builder")
            .bearer_auth(token)
            .build()?;

        let mut response = self.client.execute(request).await?;

        // do 1 retry if the first attempt failed
        if response.status() == StatusCode::UNAUTHORIZED {
            // looks like request failed due to auth error. Let's get a new a fresh token. If this fails again we'll just return the error.
            self.reset_token();
            let token = self.get_auth_token().await?;
            let request = request_builder.bearer_auth(token).build()?;
            response = self.client.execute(request).await?;
        }
        Ok(response)
    }
```

**File:** crates/aptos-telemetry/src/sender.rs (L245-256)
```rust
    async fn get_auth_token(&self) -> Result<String, Error> {
        // Try to read the token holding a read lock
        let token = { self.auth_context.token.read().as_ref().cloned() };
        match token {
            Some(token) => Ok(token),
            None => {
                let token = self.authenticate().await?;
                *self.auth_context.token.write() = Some(token.clone());
                Ok(token)
            },
        }
    }
```

**File:** crates/aptos-telemetry/src/sender.rs (L287-353)
```rust
    pub async fn authenticate(&self) -> Result<String, anyhow::Error> {
        let noise_config = match &self.auth_context.noise_config {
            Some(config) => config,
            None => return Err(anyhow!("Cannot send telemetry without private key")),
        };
        let server_public_key = self.server_public_key().await?;

        // buffer to first noise handshake message
        let mut client_noise_msg = vec![0; noise::handshake_init_msg_len(0)];

        // build the prologue (chain_id | peer_id | server_public_key)
        const CHAIN_ID_LENGTH: usize = 1;
        const ID_SIZE: usize = CHAIN_ID_LENGTH + PeerId::LENGTH;
        const PROLOGUE_SIZE: usize = CHAIN_ID_LENGTH + PeerId::LENGTH + x25519::PUBLIC_KEY_SIZE;
        let mut prologue = [0; PROLOGUE_SIZE];
        prologue[..CHAIN_ID_LENGTH].copy_from_slice(&[self.chain_id.id()]);
        prologue[CHAIN_ID_LENGTH..ID_SIZE].copy_from_slice(self.peer_id.as_ref());
        prologue[ID_SIZE..PROLOGUE_SIZE].copy_from_slice(server_public_key.as_slice());

        let mut rng = rand::rngs::OsRng;

        // craft first handshake message  (-> e, es, s, ss)
        let initiator_state = noise_config
            .initiate_connection(
                &mut rng,
                &prologue,
                server_public_key,
                None,
                &mut client_noise_msg,
            )
            .unwrap();

        let auth_request = AuthRequest {
            chain_id: self.chain_id,
            peer_id: self.peer_id,
            role_type: self.role_type,
            server_public_key,
            handshake_msg: client_noise_msg,
            run_uuid: self.uuid,
        };

        let response = self
            .client
            .post(self.build_path("auth")?)
            .json::<AuthRequest>(&auth_request)
            .send()
            .await?;

        let resp = match error_for_status_with_body(response).await {
            Ok(response) => Ok(response.json::<AuthResponse>().await?),
            Err(err) => {
                debug!(
                    "[telemetry-client] Error sending authentication request: {}",
                    err,
                );
                Err(anyhow!("error {}", err))
            },
        }?;

        let (response_payload, _) = noise_config
            .finalize_connection(initiator_state, resp.handshake_msg.as_slice())
            .unwrap();

        let jwt = String::from_utf8(response_payload)?;

        Ok(jwt)
    }
```

**File:** crates/aptos-telemetry-service/src/types/auth.rs (L23-26)
```rust
#[derive(Serialize, Deserialize)]
pub struct AuthResponse {
    pub handshake_msg: Vec<u8>,
}
```

**File:** crates/aptos-crypto/src/noise.rs (L350-400)
```rust
    pub fn finalize_connection(
        &self,
        handshake_state: InitiatorHandshakeState,
        received_message: &[u8],
    ) -> Result<(Vec<u8>, NoiseSession), NoiseError> {
        // checks
        if received_message.len() > MAX_SIZE_NOISE_MSG {
            return Err(NoiseError::ReceivedMsgTooLarge);
        }
        // retrieve handshake state
        let InitiatorHandshakeState {
            mut h,
            mut ck,
            e,
            rs,
        } = handshake_state;

        // <- e
        let mut re = [0u8; x25519::PUBLIC_KEY_SIZE];
        let mut cursor = Cursor::new(received_message);
        cursor
            .read_exact(&mut re)
            .map_err(|_| NoiseError::MsgTooShort)?;
        mix_hash(&mut h, &re);
        let re = x25519::PublicKey::from(re);

        // <- ee
        let dh_output = e.diffie_hellman(&re);
        mix_key(&mut ck, &dh_output)?;

        // <- se
        let dh_output = self.private_key.diffie_hellman(&re);
        let k = mix_key(&mut ck, &dh_output)?;

        // <- payload
        let offset = cursor.position() as usize;

        let aead = aes_key(&k[..]);
        let mut in_out = cursor.into_inner()[offset..].to_vec();
        let nonce = aead::Nonce::assume_unique_for_key([0u8; AES_NONCE_SIZE]);
        let plaintext = aead
            .open_in_place(nonce, Aad::from(&h), &mut in_out)
            .map_err(|_| NoiseError::Decrypt)?;

        // split
        let (k1, k2) = hkdf(&ck, None)?;
        let session = NoiseSession::new(k1, k2, rs);

        //
        Ok((plaintext.to_vec(), session))
    }
```

**File:** crates/crash-handler/src/lib.rs (L26-58)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
}
```

**File:** aptos-node/src/lib.rs (L718-724)
```rust
    // Start the telemetry service (as early as possible and before any blocking calls)
    let telemetry_runtime = services::start_telemetry_service(
        &node_config,
        remote_log_rx,
        logger_filter_update_job,
        chain_id,
    );
```

**File:** crates/aptos-telemetry/src/service.rs (L65-69)
```rust
/// Returns true iff telemetry is disabled
#[inline]
pub fn telemetry_is_disabled() -> bool {
    is_env_variable_true(ENV_APTOS_DISABLE_TELEMETRY)
}
```
