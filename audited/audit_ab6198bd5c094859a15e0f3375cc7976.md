# Audit Report

## Title
Missing Signature Verification on Incoming Commit Decisions Allows Single Validator to Bypass Consensus and Manipulate Pruner State

## Summary
The consensus pipeline's `buffer_manager.rs` accepts incoming `CommitDecision` messages from other validators without verifying the BLS aggregate signatures, allowing a single malicious validator to commit blocks and manipulate pruner target versions without achieving 2f+1 consensus agreement.

## Finding Description
The vulnerability exists in the consensus pipeline's handling of incoming `CommitMessage::Decision` messages. When a validator receives a `CommitDecision` from another validator via RPC, the `process_commit_message()` function processes it without calling the `CommitDecision::verify()` method to validate signatures. [1](#0-0) 

The `CommitMessage` enum defines a `verify()` method that validates signatures for both votes and decisions: [2](#0-1) 

However, this verification is **never called** before processing the commit decision. The code directly advances the buffer item to aggregated state using the unverified `commit_proof.ledger_info()`.

The attack flow:
1. Malicious validator receives and pre-commits blocks through normal consensus execution
2. Malicious validator creates a fabricated `CommitDecision` with a `LedgerInfoWithSignatures` containing arbitrary version and forged/missing signatures
3. Malicious validator sends this to other validators via RPC
4. Receiving validators accept it without signature verification in `buffer_manager.rs`
5. The fabricated commit decision flows through the pipeline to `commit_ledger()`
6. Storage validates root hash (which passes if pre-committed data exists) but NOT signatures
7. Blocks are committed and `maybe_set_pruner_target_db_version()` is called with the fabricated version [3](#0-2) 

The storage layer's `check_and_put_ledger_info()` validates root hash and epoch continuity, but these checks are insufficient because they don't verify that 2f+1 validators actually agreed: [4](#0-3) 

After successful commit, `post_commit()` calls `maybe_set_pruner_target_db_version()` with the fabricated version: [5](#0-4) 

This directly manipulates the pruner's target database version without consensus agreement.

## Impact Explanation
**Critical Severity** - This vulnerability breaks the fundamental **Consensus Safety** invariant that requires 2f+1 validator agreement before committing blocks. A single malicious validator can:

1. **Commit blocks without consensus**: Bypass the 2f+1 signature requirement and commit arbitrary pre-executed blocks
2. **Manipulate pruner state**: Control which versions get pruned by setting arbitrary pruner target versions via `maybe_set_pruner_target_db_version()`
3. **Cause state divergence**: Different validators could commit different blocks if multiple malicious validators send conflicting commit decisions
4. **Break chain safety**: Violates AptosBFT safety guarantees under < 1/3 Byzantine assumption

This meets the Critical Severity criteria for "Consensus/Safety violations" as defined in the Aptos Bug Bounty program.

## Likelihood Explanation
**High Likelihood** - The attack requires:
- Single malicious validator with network access (no 2f+1 collusion needed)
- Ability to send RPC messages to other validators (normal P2P network functionality)
- Pre-committed blocks at target version (achievable through normal execution flow)

The attack is straightforward with no complex timing requirements or race conditions. Any validator can execute it at any time.

## Recommendation
Add signature verification before processing incoming commit decisions in `buffer_manager.rs`:

```rust
CommitMessage::Decision(commit_proof) => {
    // Add verification here
    if let Err(error) = commit_proof.verify(&self.verifier) {
        error!("Failed to verify commit decision: {:?}", error);
        reply_nack(protocol, response_sender);
        return None;
    }
    
    let target_block_id = commit_proof.ledger_info().commit_info().id();
    info!(
        "Receive commit decision {}",
        commit_proof.ledger_info().commit_info()
    );
    // ... rest of processing
}
```

The verification should use the same `CommitDecision::verify()` method that is correctly implemented but currently unused: [6](#0-5) 

## Proof of Concept
```rust
// Rust PoC demonstrating the vulnerability
use aptos_consensus_types::pipeline::commit_decision::CommitDecision;
use aptos_types::ledger_info::LedgerInfoWithSignatures;
use aptos_crypto::bls12381::Signature;

fn exploit_missing_verification() {
    // 1. Create a fabricated LedgerInfoWithSignatures with arbitrary version
    let mut fabricated_ledger_info = LedgerInfoWithSignatures::new(
        ledger_info_with_version_1000, // Contains version = 1000
        AggregateSignature::empty(), // No valid signatures!
    );
    
    // 2. Wrap in CommitDecision
    let malicious_commit = CommitDecision::new(fabricated_ledger_info);
    
    // 3. Send to other validators via CommitMessage::Decision
    network_sender.send_commit_message(
        target_validator,
        CommitMessage::Decision(malicious_commit)
    ).await;
    
    // 4. Target validator's buffer_manager.rs processes it WITHOUT verification
    // 5. Blocks at version 1000 get committed without 2f+1 agreement
    // 6. Pruner target set to version 1000 via maybe_set_pruner_target_db_version()
}
```

## Notes
The consensus observer implementation correctly verifies commit decisions before processing: [7](#0-6) 

This demonstrates the developers were aware of the need for verification but failed to implement it consistently in the regular consensus pipeline's `buffer_manager.rs`.

### Citations

**File:** consensus/src/pipeline/buffer_manager.rs (L786-812)
```rust
            CommitMessage::Decision(commit_proof) => {
                let target_block_id = commit_proof.ledger_info().commit_info().id();
                info!(
                    "Receive commit decision {}",
                    commit_proof.ledger_info().commit_info()
                );
                let cursor = self
                    .buffer
                    .find_elem_by_key(*self.buffer.head_cursor(), target_block_id);
                if cursor.is_some() {
                    let item = self.buffer.take(&cursor);
                    let new_item = item.try_advance_to_aggregated_with_ledger_info(
                        commit_proof.ledger_info().clone(),
                    );
                    let aggregated = new_item.is_aggregated();
                    self.buffer.set(&cursor, new_item);

                    reply_ack(protocol, response_sender);
                    if aggregated {
                        return Some(target_block_id);
                    }
                } else if self.try_add_pending_commit_proof(commit_proof.into_inner()) {
                    reply_ack(protocol, response_sender);
                } else {
                    reply_nack(protocol, response_sender); // TODO: send_commit_proof() doesn't care about the response and this should be direct send not RPC
                }
            },
```

**File:** consensus/src/pipeline/commit_reliable_broadcast.rs (L35-54)
```rust
impl CommitMessage {
    /// Verify the signatures on the message
    pub fn verify(&self, sender: Author, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        match self {
            CommitMessage::Vote(vote) => {
                let _timer = counters::VERIFY_MSG
                    .with_label_values(&["commit_vote"])
                    .start_timer();
                vote.verify(sender, verifier)
            },
            CommitMessage::Decision(decision) => {
                let _timer = counters::VERIFY_MSG
                    .with_label_values(&["commit_decision"])
                    .start_timer();
                decision.verify(verifier)
            },
            CommitMessage::Ack(_) => bail!("Unexpected ack in incoming commit message"),
            CommitMessage::Nack => bail!("Unexpected NACK in incoming commit message"),
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L78-112)
```rust
    fn commit_ledger(
        &self,
        version: Version,
        ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
        chunk_opt: Option<ChunkToCommit>,
    ) -> Result<()> {
        gauged_api("commit_ledger", || {
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
            let _lock = self
                .commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["commit_ledger"]);

            let old_committed_ver = self.get_and_check_commit_range(version)?;

            let mut ledger_batch = SchemaBatch::new();
            // Write down LedgerInfo if provided.
            if let Some(li) = ledger_info_with_sigs {
                self.check_and_put_ledger_info(version, li, &mut ledger_batch)?;
            }
            // Write down commit progress
            ledger_batch.put::<DbMetadataSchema>(
                &DbMetadataKey::OverallCommitProgress,
                &DbMetadataValue::Version(version),
            )?;
            self.ledger_db.metadata_db().write_schemas(ledger_batch)?;

            // Notify the pruners, invoke the indexer, and update in-memory ledger info.
            self.post_commit(old_committed_ver, version, ledger_info_with_sigs, chunk_opt)
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L540-600)
```rust
    fn check_and_put_ledger_info(
        &self,
        version: Version,
        ledger_info_with_sig: &LedgerInfoWithSignatures,
        ledger_batch: &mut SchemaBatch,
    ) -> Result<(), AptosDbError> {
        let ledger_info = ledger_info_with_sig.ledger_info();

        // Verify the version.
        ensure!(
            ledger_info.version() == version,
            "Version in LedgerInfo doesn't match last version. {:?} vs {:?}",
            ledger_info.version(),
            version,
        );

        // Verify the root hash.
        let db_root_hash = self
            .ledger_db
            .transaction_accumulator_db()
            .get_root_hash(version)?;
        let li_root_hash = ledger_info_with_sig
            .ledger_info()
            .transaction_accumulator_hash();
        ensure!(
            db_root_hash == li_root_hash,
            "Root hash pre-committed doesn't match LedgerInfo. pre-commited: {:?} vs in LedgerInfo: {:?}",
            db_root_hash,
            li_root_hash,
        );

        // Verify epoch continuity.
        let current_epoch = self
            .ledger_db
            .metadata_db()
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            ledger_info_with_sig.ledger_info().epoch() == current_epoch,
            "Gap in epoch history. Trying to put in LedgerInfo in epoch: {}, current epoch: {}",
            ledger_info_with_sig.ledger_info().epoch(),
            current_epoch,
        );

        // Ensure that state tree at the end of the epoch is persisted.
        if ledger_info_with_sig.ledger_info().ends_epoch() {
            let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
            ensure!(
                state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
                "State checkpoint not persisted at the end of the epoch, version {}, next_epoch {}, snapshot in db: {:?}",
                version,
                ledger_info_with_sig.ledger_info().next_block_epoch(),
                state_snapshot,
            );
        }

        // Put write to batch.
        self.ledger_db
            .metadata_db()
            .put_ledger_info(ledger_info_with_sig, ledger_batch)?;
        Ok(())
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L625-633)
```rust
            // Activate the ledger pruner and state kv pruner.
            // Note the state merkle pruner is activated when state snapshots are persisted
            // in their async thread.
            self.ledger_pruner
                .maybe_set_pruner_target_db_version(version);
            self.state_store
                .state_kv_pruner
                .maybe_set_pruner_target_db_version(version);

```

**File:** consensus/consensus-types/src/pipeline/commit_decision.rs (L49-59)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            !self.ledger_info.commit_info().is_ordered_only(),
            "Unexpected ordered only commit info"
        );
        // We do not need to check the author because as long as the signature tree
        // is valid, the message should be valid.
        self.ledger_info
            .verify_signatures(validator)
            .context("Failed to verify Commit Decision")
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L465-482)
```rust

        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }
```
