# Audit Report

## Title
Feature Flag Enforcement Bypass via Mempool-Execution Version Mismatch During Epoch Changes

## Summary
Transactions can enter mempool under one set of feature flags but execute under different feature flags after an epoch change, bypassing on-chain governance decisions to disable features. This occurs because feature flag validation happens only at mempool admission, not during execution.

## Finding Description

The Aptos VM performs feature flag validation at two distinct points in a transaction's lifecycle: mempool admission and execution. However, these validation checks are not equivalent, creating a governance bypass vulnerability during epoch changes.

**Mempool Admission (VMValidator::validate_transaction)**: [1](#0-0) 

The VMValidator checks four critical feature flags:
- `SINGLE_SENDER_AUTHENTICATOR` - gates single sender authenticator support
- `WEBAUTHN_SIGNATURE` - gates WebAuthn signature scheme
- `SLH_DSA_SHA2_128S_SIGNATURE` - gates SLH-DSA signature scheme  
- `ALLOW_SERIALIZED_SCRIPT_ARGS` - gates serialized script arguments

If any of these features are disabled but the transaction attempts to use them, validation returns `FEATURE_UNDER_GATING` and the transaction is rejected.

**Execution Path (execute_user_transaction_impl)**: [2](#0-1) 

During execution, the VM calls `validate_signed_transaction` to revalidate the transaction. However, this function does NOT re-check the signature-type feature flags mentioned above. [3](#0-2) 

The `validate_signed_transaction` function only checks account abstraction features and keyless authentication, but completely omits validation of `SINGLE_SENDER_AUTHENTICATOR`, `WEBAUTHN_SIGNATURE`, `SLH_DSA_SHA2_128S_SIGNATURE`, and `ALLOW_SERIALIZED_SCRIPT_ARGS`.

**Epoch Change/Reconfiguration Mechanism**: [4](#0-3) 

When a reconfiguration event occurs (epoch change), mempool restarts the validator to pick up new on-chain configurations. However, existing transactions in mempool are NOT re-validated against the new feature flags. [5](#0-4) 

The validator restart only refreshes the state view; it does not purge or revalidate existing mempool transactions.

**Feature Flag Updates via Governance**: [6](#0-5) 

Governance can disable feature flags for the next epoch using `change_feature_flags_for_next_epoch`, which buffers the changes until epoch boundary. [7](#0-6) 

At epoch change, `on_new_epoch` applies the pending feature flag changes.

**Attack Scenario**:

1. Feature `WEBAUTHN_SIGNATURE` is currently **ENABLED** on-chain
2. Attacker submits transaction with WebAuthn signature
3. Transaction passes mempool validation (feature is enabled)
4. Transaction sits in mempool waiting for consensus inclusion
5. Governance proposal executes to **DISABLE** `WEBAUTHN_SIGNATURE` feature for security reasons (e.g., vulnerability discovered)
6. Epoch change occurs, new feature flags take effect
7. Validator restarts with new configuration (feature now disabled)
8. Transaction remains in mempool without re-validation
9. Consensus includes transaction in next block
10. Execution calls `execute_user_transaction_impl` â†’ `validate_signed_transaction`
11. **BUG**: `validate_signed_transaction` does NOT check `WEBAUTHN_SIGNATURE` flag
12. Transaction executes successfully despite feature being disabled, bypassing governance decision

This violates the **Governance Integrity** invariant: governance decisions to disable features must be enforceable across all transactions.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria for the following reasons:

1. **Governance Bypass**: Circumvents on-chain governance decisions about which features should be enabled. When governance disables a feature flag, the intent is that NO transactions using that feature should execute.

2. **Security Policy Violation**: Feature flags are often disabled for critical security reasons:
   - Vulnerability discovered in signature scheme (WebAuthn, SLH-DSA)
   - Deprecation of insecure features
   - Emergency response to active exploits

3. **Time Window**: The vulnerability has a realistic exploitation window during:
   - Planned feature deprecations announced in governance proposals
   - Emergency feature disablement for security incidents
   - Regular epoch changes (every 2 hours on mainnet)

4. **Significant Protocol Violation**: Breaks the fundamental assumption that disabled features cannot be used, which is critical for protocol evolution and security hardening.

While this does not directly cause loss of funds or consensus failure, it represents a significant protocol violation that undermines governance authority and could enable execution of transactions using known-vulnerable features even after governance has explicitly disabled them.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability is likely to occur because:

1. **Frequent Epoch Changes**: Aptos has regular epoch changes (approximately every 2 hours on mainnet), providing many opportunities for exploitation.

2. **Predictable Governance Actions**: Feature flag changes are announced through governance proposals that go through public voting periods, giving attackers advance notice.

3. **Mempool Retention**: Transactions can remain in mempool for extended periods (governed by `system_transaction_timeout_secs` configuration), spanning multiple epochs.

4. **Low Attacker Cost**: Exploiting this requires only:
   - Submitting a transaction with a to-be-disabled feature
   - Waiting for governance to disable the feature
   - Transaction executes when included in a block

5. **No Special Privileges**: Any transaction sender can exploit this; no validator access or special permissions required.

The only limiting factor is that an attacker must time their transaction submission to occur before a feature disablement, but this is easily achievable given public governance processes.

## Recommendation

**Fix 1: Re-validate Feature Flags During Execution**

Add feature flag checks to `validate_signed_transaction` to match those in `VMValidator::validate_transaction`:

```rust
fn validate_signed_transaction(
    &self,
    session: &mut SessionExt<impl AptosMoveResolver>,
    module_storage: &impl ModuleStorage,
    transaction: &SignedTransaction,
    transaction_data: &TransactionMetadata,
    log_context: &AdapterLogSchema,
    is_approved_gov_script: bool,
    traversal_context: &mut TraversalContext,
    gas_meter: &mut impl AptosGasMeter,
) -> Result<SerializedSigners, VMStatus> {
    // ADD: Re-check signature type feature flags during execution
    if !self.features().is_enabled(FeatureFlag::SINGLE_SENDER_AUTHENTICATOR) {
        if let TransactionAuthenticator::SingleSender{ .. } = transaction.authenticator_ref() {
            return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
        }
    }

    if !self.features().is_enabled(FeatureFlag::WEBAUTHN_SIGNATURE) {
        if let Ok(sk_authenticators) = transaction.authenticator_ref().to_single_key_authenticators() {
            for authenticator in sk_authenticators {
                if let AnySignature::WebAuthn { .. } = authenticator.signature() {
                    return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
                }
            }
        }
    }

    if !self.features().is_enabled(FeatureFlag::SLH_DSA_SHA2_128S_SIGNATURE) {
        if let Ok(sk_authenticators) = transaction.authenticator_ref().to_single_key_authenticators() {
            for authenticator in sk_authenticators {
                if let AnySignature::SlhDsa_Sha2_128s { .. } = authenticator.signature() {
                    return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
                }
            }
        }
    }

    if !self.features().is_enabled(FeatureFlag::ALLOW_SERIALIZED_SCRIPT_ARGS) {
        if let Ok(TransactionExecutableRef::Script(script)) = transaction.payload().executable_ref() {
            for arg in script.args() {
                if let TransactionArgument::Serialized(_) = arg {
                    return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
                }
            }
        }
    }

    // ... existing validation logic continues
}
```

**Fix 2: Purge Incompatible Transactions on Config Update**

Alternatively, invalidate mempool transactions that use disabled features when configuration changes:

```rust
pub(crate) async fn process_config_update<V, P>(
    config_update: OnChainConfigPayload<P>,
    validator: Arc<RwLock<V>>,
    broadcast_within_validator_network: Arc<RwLock<bool>>,
    mempool: Arc<Mutex<CoreMempool>>, // ADD: access to mempool
) where
    V: TransactionValidation,
    P: OnChainConfigProvider,
{
    // Restart validator first
    if let Err(e) = validator.write().restart() {
        counters::VM_RECONFIG_UPDATE_FAIL_COUNT.inc();
        error!(LogSchema::event_log(LogEntry::ReconfigUpdate, LogEvent::VMUpdateFail).error(&e));
    }

    // ADD: Revalidate mempool transactions and purge those that are now invalid
    // This requires exposing a revalidation API on mempool
    
    // ... existing config update logic
}
```

**Recommended Approach**: Implement Fix 1 as it provides defense-in-depth by ensuring execution always validates against current feature flags, regardless of when the transaction entered mempool.

## Proof of Concept

```rust
// Reproduction Steps:

// 1. Setup: Enable WEBAUTHN_SIGNATURE feature flag
change_feature_flags_for_next_epoch(&framework_signer, 
    vec![features::get_webauthn_signature_feature()], 
    vec![]
);
aptos_governance::reconfigure(&framework_signer);

// 2. Submit transaction with WebAuthn signature
let webauthn_txn = create_transaction_with_webauthn_signature(sender_address);
mempool.submit_transaction(webauthn_txn);
// Transaction is validated and accepted into mempool

// 3. Governance disables WEBAUTHN_SIGNATURE feature
change_feature_flags_for_next_epoch(&framework_signer,
    vec![],
    vec![features::get_webauthn_signature_feature()]
);

// 4. Trigger epoch change
aptos_governance::reconfigure(&framework_signer);
// Validator restarts, feature is now disabled

// 5. Consensus includes transaction in block
let block = create_block_with_transaction(webauthn_txn);

// 6. Execute block
let result = vm.execute_block(block);

// BUG: Transaction executes successfully even though WEBAUTHN_SIGNATURE is disabled
assert!(result.is_ok()); // This should fail but doesn't!

// Expected: Transaction should fail with StatusCode::FEATURE_UNDER_GATING
// Actual: Transaction executes successfully, bypassing governance decision
```

## Notes

This vulnerability represents a subtle but significant gap in Aptos's defense-in-depth strategy. While the feature flag mechanism correctly gates new transaction submissions via mempool validation, the lack of re-validation during execution creates a time-of-check-time-of-use (TOCTOU) vulnerability across epoch boundaries.

The issue is particularly concerning for emergency feature disablements where governance needs to immediately halt usage of a vulnerable feature. Transactions already in mempool can continue to execute using the disabled feature for up to `system_transaction_timeout_secs` duration (default 86400 seconds = 24 hours).

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1779-1900)
```rust
    fn validate_signed_transaction(
        &self,
        session: &mut SessionExt<impl AptosMoveResolver>,
        module_storage: &impl ModuleStorage,
        transaction: &SignedTransaction,
        transaction_data: &TransactionMetadata,
        log_context: &AdapterLogSchema,
        is_approved_gov_script: bool,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl AptosGasMeter,
    ) -> Result<SerializedSigners, VMStatus> {
        // Check transaction format.
        if transaction.contains_duplicate_signers() {
            return Err(VMStatus::error(
                StatusCode::SIGNERS_CONTAIN_DUPLICATES,
                None,
            ));
        }

        let keyless_authenticators = aptos_types::keyless::get_authenticators(transaction)
            .map_err(|_| VMStatus::error(StatusCode::INVALID_SIGNATURE, None))?;

        // If there are keyless TXN authenticators, validate them all.
        if !keyless_authenticators.is_empty() && !self.is_simulation {
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
        }

        // Account Abstraction dispatchable authentication.
        let senders = transaction_data.senders();
        let proofs = transaction_data.authentication_proofs();

        // Validate that the number of senders matches the number of authentication proofs
        if senders.len() != proofs.len() {
            return Err(VMStatus::error(
                StatusCode::INVALID_NUMBER_OF_AUTHENTICATION_PROOFS,
                Some(format!(
                    "Mismatch between senders count ({}) and authentication proofs count ({})",
                    senders.len(),
                    proofs.len()
                )),
            ));
        }

        // Add fee payer.
        let fee_payer_signer = if let Some(fee_payer) = transaction_data.fee_payer {
            Some(match &transaction_data.fee_payer_authentication_proof {
                Some(AuthenticationProof::Abstract {
                    function_info,
                    auth_data,
                }) => {
                    let enabled = match auth_data {
                        AbstractAuthenticationData::V1 { .. } => {
                            self.features().is_account_abstraction_enabled()
                        },
                        AbstractAuthenticationData::DerivableV1 { .. } => {
                            self.features().is_derivable_account_abstraction_enabled()
                        },
                    };
                    if enabled {
                        dispatchable_authenticate(
                            session,
                            gas_meter,
                            fee_payer,
                            function_info.clone(),
                            auth_data,
                            traversal_context,
                            module_storage,
                        )
                        .map_err(|mut vm_error| {
                            if vm_error.major_status() == OUT_OF_GAS {
                                vm_error
                                    .set_major_status(ACCOUNT_AUTHENTICATION_GAS_LIMIT_EXCEEDED);
                            }
                            vm_error.into_vm_status()
                        })
                    } else {
                        return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
                    }
                },
                _ => Ok(serialized_signer(&fee_payer)),
            }?)
        } else {
            None
        };
        let sender_signers = itertools::zip_eq(senders, proofs)
            .map(|(sender, proof)| match proof {
                AuthenticationProof::Abstract {
                    function_info,
                    auth_data,
                } => {
                    let enabled = match auth_data {
                        AbstractAuthenticationData::V1 { .. } => {
                            self.features().is_account_abstraction_enabled()
                        },
                        AbstractAuthenticationData::DerivableV1 { .. } => {
                            self.features().is_derivable_account_abstraction_enabled()
                        },
                    };
                    if enabled {
                        dispatchable_authenticate(
                            session,
                            gas_meter,
                            sender,
                            function_info.clone(),
                            auth_data,
                            traversal_context,
                            module_storage,
                        )
                        .map_err(|mut vm_error| {
                            if vm_error.major_status() == OUT_OF_GAS {
                                vm_error
                                    .set_major_status(ACCOUNT_AUTHENTICATION_GAS_LIMIT_EXCEEDED);
                            }
                            vm_error.into_vm_status()
                        })
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1998-2012)
```rust
        // Revalidate the transaction.
        let mut prologue_session = PrologueSession::new(self, &txn_data, resolver);
        let initial_gas = gas_meter.balance();
        let serialized_signers = unwrap_or_discard!(prologue_session.execute(|session| {
            self.validate_signed_transaction(
                session,
                code_storage,
                txn,
                &txn_data,
                log_context,
                is_approved_gov_script,
                &mut traversal_context,
                gas_meter,
            )
        }));
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3172-3227)
```rust
        if !self
            .features()
            .is_enabled(FeatureFlag::SINGLE_SENDER_AUTHENTICATOR)
        {
            if let aptos_types::transaction::authenticator::TransactionAuthenticator::SingleSender{ .. } = transaction.authenticator_ref() {
                return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
            }
        }

        if !self.features().is_enabled(FeatureFlag::WEBAUTHN_SIGNATURE) {
            if let Ok(sk_authenticators) = transaction
                .authenticator_ref()
                .to_single_key_authenticators()
            {
                for authenticator in sk_authenticators {
                    if let AnySignature::WebAuthn { .. } = authenticator.signature() {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            } else {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            }
        }

        if !self
            .features()
            .is_enabled(FeatureFlag::SLH_DSA_SHA2_128S_SIGNATURE)
        {
            if let Ok(sk_authenticators) = transaction
                .authenticator_ref()
                .to_single_key_authenticators()
            {
                for authenticator in sk_authenticators {
                    if let AnySignature::SlhDsa_Sha2_128s { .. } = authenticator.signature() {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            } else {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            }
        }

        if !self
            .features()
            .is_enabled(FeatureFlag::ALLOW_SERIALIZED_SCRIPT_ARGS)
        {
            if let Ok(TransactionExecutableRef::Script(script)) =
                transaction.payload().executable_ref()
            {
                for arg in script.args() {
                    if let TransactionArgument::Serialized(_) = arg {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            }
        }
```

**File:** mempool/src/shared_mempool/tasks.rs (L762-794)
```rust
pub(crate) async fn process_config_update<V, P>(
    config_update: OnChainConfigPayload<P>,
    validator: Arc<RwLock<V>>,
    broadcast_within_validator_network: Arc<RwLock<bool>>,
) where
    V: TransactionValidation,
    P: OnChainConfigProvider,
{
    info!(LogSchema::event_log(
        LogEntry::ReconfigUpdate,
        LogEvent::Process
    ));

    if let Err(e) = validator.write().restart() {
        counters::VM_RECONFIG_UPDATE_FAIL_COUNT.inc();
        error!(LogSchema::event_log(LogEntry::ReconfigUpdate, LogEvent::VMUpdateFail).error(&e));
    }

    let consensus_config: anyhow::Result<OnChainConsensusConfig> = config_update.get();
    match consensus_config {
        Ok(consensus_config) => {
            *broadcast_within_validator_network.write() =
                !consensus_config.quorum_store_enabled() && !consensus_config.is_dag_enabled()
        },
        Err(e) => {
            error!(
                "Failed to read on-chain consensus config, keeping value broadcast_within_validator_network={}: {}",
                *broadcast_within_validator_network.read(),
                e
            );
        },
    }
}
```

**File:** vm-validator/src/vm_validator.rs (L70-74)
```rust
    fn restart(&mut self) -> Result<()> {
        let db_state_view = self.db_state_view();
        self.state.reset_all(db_state_view.into());
        Ok(())
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L805-828)
```text
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L834-844)
```text
    public fun on_new_epoch(framework: &signer) acquires Features, PendingFeatures {
        ensure_framework_signer(framework);
        if (exists<PendingFeatures>(@std)) {
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            if (exists<Features>(@std)) {
                Features[@std].features = features;
            } else {
                move_to(framework, Features { features })
            }
        }
    }
```
