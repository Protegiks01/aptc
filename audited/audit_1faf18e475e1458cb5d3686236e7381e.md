# Audit Report

## Title
Integer Underflow in Total Supply Aggregation Causes State Corruption via Wrapping Arithmetic

## Summary
The `add_delta` function in `sharded_aggregator_service.rs` performs unchecked u128 subtraction that wraps around on underflow in release builds, potentially corrupting the total supply value written to blockchain state. This breaks the deterministic execution invariant and can create artificially inflated supply values. [1](#0-0) 

## Finding Description

During sharded block execution, the system aggregates total supply changes across multiple shards that execute in parallel. Each shard uses a temporary base value (`TOTAL_SUPPLY_AGGR_BASE_VAL = u128::MAX >> 1`) during execution, then converts back to the real base value during aggregation.

The vulnerability exists in the `add_delta` helper function which applies a signed delta to a u128 value. When the delta is negative (`is_positive == false`), it performs subtraction without overflow checking. In Rust release builds (used in production), integer underflow wraps around rather than panicking. [2](#0-1) 

The code even acknowledges this limitation in its comment but provides no actual safeguard. [3](#0-2) 

**Attack Scenario:**

1. Real `total_supply_base_val` in state is relatively small (e.g., 10^9 tokens)
2. `TOTAL_SUPPLY_AGGR_BASE_VAL ≈ 1.7 × 10^38` (half of u128::MAX)
3. Multiple shards execute burn transactions in parallel
4. Each shard's transactions see the fake base value and can burn tokens
5. The `base_val_delta` computed is massively negative: `{delta: TOTAL_SUPPLY_AGGR_BASE_VAL - total_supply_base_val, is_positive: false}`
6. When aggregating, if a transaction's `txn_total_supply` is less than the accumulated negative delta, the subtraction `txn_total_supply - delta_for_round.delta` underflows
7. The wrapped result (approximately `u128::MAX`) is written to state via `update_total_supply` [4](#0-3) 

This corrupted value is then persisted to the blockchain state: [5](#0-4) 

## Impact Explanation

**Severity: Critical**

This vulnerability breaks multiple critical invariants:

1. **Deterministic Execution**: If different validators process the underflow differently (e.g., due to compiler differences or build configurations), they will produce different state roots, breaking consensus.

2. **State Consistency**: The total supply value in state becomes corrupted to a massive positive number (near u128::MAX), breaking the fundamental accounting invariant of the blockchain.

3. **Supply Tracking Integrity**: All subsequent operations that read total supply will see the corrupted value, potentially enabling:
   - Bypassing mint/burn limits that check against maximum supply
   - Breaking economic assumptions in DeFi protocols
   - Corrupting reward calculations and staking logic

This qualifies as **Critical Severity** under Aptos bug bounty criteria as it causes state corruption requiring manual intervention or hardfork to fix, and potentially enables loss of funds through broken supply checks.

## Likelihood Explanation

**Likelihood: Medium**

While the exact conditions to trigger underflow are complex, they are achievable:

1. **Sharded execution is a production feature**: The code path executes whenever sharded block execution is enabled
2. **No explicit validation**: There are zero checks preventing the underflow condition
3. **Edge cases exist**: Transactions with unusual total supply values, extreme burn amounts across multiple shards, or specific timing of operations could trigger underflow
4. **Release builds always wrap**: Production validators run release builds where integer underflow silently wraps rather than panicking

The complexity of orchestrating the attack is balanced by the fact that the vulnerability is always present when processing transactions in sharded mode, and only requires specific transaction patterns to trigger.

## Recommendation

Replace the unchecked arithmetic with explicit overflow checking:

```rust
fn add_delta(self, other: u128) -> Result<u128, String> {
    if self.is_positive {
        other.checked_add(self.delta)
            .ok_or_else(|| format!("Overflow adding positive delta {} to {}", self.delta, other))
    } else {
        other.checked_sub(self.delta)
            .ok_or_else(|| format!("Underflow subtracting delta {} from {}", self.delta, other))
    }
}
```

Then propagate the error up through the call stack and handle it appropriately (likely by aborting block execution). The aggregation function should validate that all arithmetic operations succeed:

```rust
txn_output.update_total_supply(
    delta_for_round.add_delta(txn_total_supply)
        .expect("Total supply delta calculation must not overflow")
);
```

Alternatively, use saturating arithmetic if wrapping to bounds is acceptable, though checked arithmetic with explicit error handling is preferable for critical financial values.

## Proof of Concept

```rust
#[test]
fn test_add_delta_underflow() {
    // Simulate scenario where delta exceeds the value
    let large_negative_delta = DeltaU128 {
        delta: 1000,
        is_positive: false,
    };
    
    let small_value: u128 = 500;
    
    // In release mode, this wraps around instead of panicking
    // Expected: 500 - 1000 = underflow → wraps to u128::MAX - 499
    let result = large_negative_delta.add_delta(small_value);
    
    // Result should be near u128::MAX, not a small negative number
    assert!(result > u128::MAX / 2, 
        "Underflow occurred: result = {}, expected near u128::MAX", result);
    
    // This demonstrates that the function silently produces
    // a massively incorrect positive value when underflow occurs
    println!("Underflow result: {}", result);
    println!("u128::MAX: {}", u128::MAX);
}

#[test]
fn test_realistic_underflow_scenario() {
    // Realistic values from sharded execution
    const TOTAL_SUPPLY_AGGR_BASE_VAL: u128 = u128::MAX >> 1;
    let real_supply: u128 = 1_000_000_000; // 1 billion tokens
    
    // Base value delta is massively negative
    let base_val_delta = DeltaU128::get_delta(real_supply, TOTAL_SUPPLY_AGGR_BASE_VAL);
    assert!(!base_val_delta.is_positive);
    assert_eq!(base_val_delta.delta, TOTAL_SUPPLY_AGGR_BASE_VAL - real_supply);
    
    // Transaction that burned tokens, resulting in lower supply
    let txn_total_supply = TOTAL_SUPPLY_AGGR_BASE_VAL - 2_000_000_000;
    
    // Applying the delta causes underflow
    let result = base_val_delta.add_delta(txn_total_supply);
    
    // Result wrapped around to massive positive value
    assert!(result > TOTAL_SUPPLY_AGGR_BASE_VAL,
        "Underflow caused supply corruption: {}", result);
}
```

**Notes**

The vulnerability is exacerbated by the design choice to use `u128::MAX >> 1` as the temporary base value during sharded execution. This creates a massive gap between the temporary and real base values, increasing the magnitude of `base_val_delta` and making underflow more likely when combined with transaction-specific deltas. The lack of any validation or checked arithmetic in a critical financial calculation represents a fundamental oversight in the implementation.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L26-29)
```rust
/// This class ensures that deltas can use all 128 bits without having to let go of the sign bit for
/// cases where the delta is negative. That is, we don't have to use conversions to i128.
/// However, it does not handle overflow and underflow. That is, it will indicate to the caller of
/// the faulty logic with their usage of deltas.
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L51-57)
```rust
    fn add_delta(self, other: u128) -> u128 {
        if self.is_positive {
            self.delta + other
        } else {
            other - self.delta
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L233-235)
```rust
                                txn_output.update_total_supply(
                                    delta_for_round.add_delta(txn_total_supply),
                                );
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/aggr_overridden_state_view.rs (L14-14)
```rust
pub const TOTAL_SUPPLY_AGGR_BASE_VAL: u128 = u128::MAX >> 1;
```

**File:** types/src/write_set.rs (L730-739)
```rust
    fn update_total_supply(&mut self, value: u128) {
        assert!(self
            .0
            .write_set
            .insert(
                TOTAL_SUPPLY_STATE_KEY.clone(),
                WriteOp::legacy_modification(bcs::to_bytes(&value).unwrap().into())
            )
            .is_some());
    }
```
