# Audit Report

## Title
Panic-Induced Denial of Service via Malformed DKG Transcript with Empty Cryptographic Commitment Vectors

## Summary
A boundary condition vulnerability exists in the DKG (Distributed Key Generation) transcript verification flow where malformed transcripts with empty cryptographic commitment vectors can cause validator nodes to panic before proper size validation occurs, leading to denial of service during epoch transitions.

## Finding Description
The vulnerability stems from an unsafe ordering of validation checks in the DKG transcript verification pipeline. When a peer transcript is received during DKG, the system performs validation in this sequence: [1](#0-0) 

The `verify_transcript_extra()` function is called first, before `verify_transcript()`. Within `verify_transcript_extra()`, when a fast-path transcript is present, the function compares dealt public keys: [2](#0-1) 

The `get_dealt_public_key()` method retrieves the dealt public key from the transcript using an unsafe access pattern: [3](#0-2) 

If an attacker crafts a malformed transcript where the `V_hat` vector is empty, the `.last().unwrap()` call will panic. The critical issue is that `verify_transcript()`, which contains proper size validation via `check_sizes()`, is only called **after** `verify_transcript_extra()`: [4](#0-3) 

**Attack Path:**
1. Attacker creates a malformed `Transcripts` struct with empty vectors (V_hat, R, C, etc.)
2. Attacker serializes it to BCS bytes and wraps it in a `DKGTranscript` message
3. Attacker sends this to validator nodes during a DKG session
4. Victim node deserializes the transcript successfully (deserialization only validates cryptographic point encodings)
5. `verify_transcript_extra()` is invoked first
6. If the malformed transcript has a non-empty `fast` field, line 326 calls `get_dealt_public_key()`
7. The `.last().unwrap()` on an empty `V_hat` vector causes a panic
8. Validator node crashes before proper size checks in `verify_transcript()` can catch the malformation

This breaks the **Consensus Safety** and **Deterministic Execution** invariants by allowing external actors to crash consensus-participating nodes during critical epoch transition periods.

## Impact Explanation
This vulnerability represents **High Severity** under the Aptos bug bounty program criteria:

- **Validator node crashes**: The panic directly terminates the validator process, classified as "Validator node slowdowns" or "API crashes" in the High severity category
- **Consensus availability degradation**: During DKG sessions (epoch transitions), crashed validators cannot participate in randomness generation, potentially stalling the protocol
- **Epoch transition disruption**: DKG is critical for secure epoch transitions; widespread crashes could delay or prevent epoch changes

The impact is bounded by:
- DKG only runs during epoch transitions (limited attack window)
- No direct fund loss
- Nodes can restart, but repeated attacks cause persistent unavailability
- Requires attackers to reach the DKG message handling code

This does not qualify as Critical severity because it doesn't result in permanent network partition, fund loss, or consensus safety violations (assuming honest majority restarts).

## Likelihood Explanation
**Likelihood: Medium**

**Requirements for exploitation:**
- DKG must be active (during epoch transitions, approximately every 2 hours on mainnet)
- Attacker must be able to send peer-to-peer messages to validator nodes
- No authentication or voting power required to send malformed transcripts
- Simple to craft: just create a `Transcripts` struct with empty vectors and serialize it

**Feasibility:**
- The attack is trivial once the window is open - requires only basic knowledge of the DKG message format
- BCS serialization allows arbitrary struct construction
- No cryptographic signatures are validated before the panic occurs
- Multiple validators can be targeted simultaneously

The medium likelihood assessment reflects that while the attack window is time-constrained (DKG sessions), the exploitation is straightforward and the impact on network availability during those critical windows is significant.

## Recommendation
**Option 1 (Preferred):** Reorder verification to call full validation first:

```rust
// In dkg/src/transcript_aggregation/mod.rs, swap lines 96-101:
S::verify_transcript(&self.dkg_pub_params, &transcript)
    .context("transcript verification failed")?;

S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
    .context("extra verification failed")?;
```

**Option 2:** Add early size validation in `verify_transcript_extra()`:

```rust
// In types/src/dkg/real_dkg/mod.rs, add at start of verify_transcript_extra():
fn verify_transcript_extra(
    trx: &Self::Transcript,
    verifier: &ValidatorVerifier,
    checks_voting_power: bool,
    ensures_single_dealer: Option<AccountAddress>,
) -> anyhow::Result<()> {
    // Add early bounds check
    ensure!(!trx.main.V_hat.is_empty(), "transcript has empty V_hat vector");
    if let Some(fast_trx) = &trx.fast {
        ensure!(!fast_trx.V_hat.is_empty(), "fast transcript has empty V_hat vector");
    }
    
    // ... rest of function
}
```

**Option 3:** Make `get_dealt_public_key()` return `Result<T>` instead of panicking:

```rust
// In crates/aptos-dkg/src/pvss/das/weighted_protocol.rs:
fn get_dealt_public_key(&self) -> anyhow::Result<Self::DealtPubKey> {
    self.V_hat.last()
        .map(|v| Self::DealtPubKey::new(*v))
        .ok_or_else(|| anyhow!("V_hat vector is empty"))
}
```

**Recommendation:** Implement Option 1 as it provides defense-in-depth by ensuring comprehensive validation happens before any potentially unsafe operations. Option 2 or 3 can be added as additional safety measures.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_dkg::pvss::das::WeightedTranscript;
    use types::dkg::real_dkg::{Transcripts, RealDKG};
    
    #[test]
    #[should_panic(expected = "called `Option::unwrap()` on a `None` value")]
    fn test_malformed_transcript_causes_panic() {
        // Create a malformed transcript with empty vectors
        let malformed_main = WeightedTranscript {
            soks: vec![],
            R: vec![],
            R_hat: vec![],
            V: vec![],
            V_hat: vec![], // Empty - will cause panic
            C: vec![],
        };
        
        let malformed_fast = WeightedTranscript {
            soks: vec![],
            R: vec![],
            R_hat: vec![],
            V: vec![],
            V_hat: vec![], // Empty - will cause panic
            C: vec![],
        };
        
        let malformed_transcripts = Transcripts {
            main: malformed_main,
            fast: Some(malformed_fast), // Fast path must be present to trigger line 326
        };
        
        // Serialize to simulate network transmission
        let transcript_bytes = bcs::to_bytes(&malformed_transcripts).unwrap();
        
        // Deserialize (this succeeds - no size checks)
        let trx: Transcripts = bcs::from_bytes(&transcript_bytes).unwrap();
        
        // This panics at line 326 when comparing dealt public keys
        // verify_transcript_extra() would be called here with the malformed transcript
        // The panic occurs at: trx.main.get_dealt_public_key() 
        let _ = trx.main.get_dealt_public_key(); // Panics here
    }
}
```

## Notes

The vulnerability specifically affects the **boundary condition** of empty vectors in PVSS trait methods, as specified in the security question. The core issue is that the `get_dealt_public_key()` trait method implementation assumes non-empty vectors without validating this precondition, and the verification flow calls this method before proper size validation occurs. This represents a failure to handle the empty vector edge case safely, leading to undefined behavior (panic) that compromises node availability.

### Citations

**File:** dkg/src/transcript_aggregation/mod.rs (L96-101)
```rust
        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L324-327)
```rust
        if let Some(fast_trx) = &trx.fast {
            ensure!(fast_trx.get_dealers() == main_trx_dealers);
            ensure!(trx.main.get_dealt_public_key() == fast_trx.get_dealt_public_key());
        }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L215-217)
```rust
    fn get_dealt_public_key(&self) -> Self::DealtPubKey {
        Self::DealtPubKey::new(*self.V_hat.last().unwrap())
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L415-455)
```rust
    fn check_sizes(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
        let W = sc.get_total_weight();

        if self.V.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V.len()
            );
        }

        if self.V_hat.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V_hat.len()
            );
        }

        if self.R.len() != W {
            bail!(
                "Expected {} G_1 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R.len()
            );
        }

        if self.R_hat.len() != W {
            bail!(
                "Expected {} G_2 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R_hat.len()
            );
        }

        if self.C.len() != W {
            bail!("Expected C of length {}, but got {}", W, self.C.len());
        }

        Ok(())
    }
```
