# Audit Report

## Title
Timestamp Parsing Panic Vulnerability Leading to Cascading Indexer Service Failures

## Summary
The `parse_timestamp` function in `ecosystem/indexer-grpc/indexer-grpc-utils/src/lib.rs` lacks input validation and panics on invalid timestamp values instead of returning errors. This can cause cascading failures across multiple indexer services when processing transactions with timestamps outside the valid range for `chrono::NaiveDateTime`.

## Finding Description

The indexer-grpc-utils library contains timestamp parsing functions that are called throughout the indexer infrastructure without proper validation: [1](#0-0) 

This function panics if the timestamp seconds value is outside the valid range for `chrono::NaiveDateTime` (approximately year 262143 BCE to 262142 CE) or if nanos is invalid. The function is called via `timestamp_to_iso`: [2](#0-1) 

These functions are used in critical paths across multiple indexer services for logging and metrics: [3](#0-2) 

The protobuf Timestamp specification documents valid ranges: [4](#0-3) 

However, unlike the main indexer's defensive implementation which clamps timestamps: [5](#0-4) 

The indexer-grpc-utils version provides no such protection, creating a divergence in error handling between indexer components.

Additionally, `system_time_to_proto` panics if system time is before UNIX_EPOCH: [6](#0-5) 

This function is used when creating heartbeat messages and progress samples, meaning a misconfigured system clock can crash services.

## Impact Explanation

This qualifies as **Medium Severity** per the bug bounty criteria because:

1. **Service Crashes**: Panics cause immediate termination of indexer services (data service, cache worker, fullnode streamer, file store)
2. **Cascading Failures**: Multiple services processing the same transaction will all crash, creating widespread unavailability
3. **State Inconsistencies**: Services may crash mid-processing, leaving databases in inconsistent states requiring manual intervention
4. **Data Poisoning**: If invalid timestamps are stored in cache/database, every service attempting to process them will crash until the data is cleaned

The vulnerability affects availability and operational integrity of the indexer infrastructure, which is critical for dApp functionality and blockchain data access.

## Likelihood Explanation

**Likelihood: Low to Medium**

While exploitation requires specific conditions, several realistic scenarios exist:

1. **System Clock Misconfiguration**: Data services with clocks set before 1970 will panic when sending heartbeats
2. **Data Corruption**: Redis cache or file store corruption could introduce invalid timestamp values
3. **Blockchain Edge Cases**: While consensus validates timestamps, there's no explicit upper bound check ensuring timestamps stay within NaiveDateTime's valid range
4. **Operational Errors**: During maintenance or recovery operations, corrupted transaction data could be reprocessed

The impact is significant enough that even low-probability operational failures create substantial risk.

## Recommendation

Implement defensive timestamp validation and error handling:

```rust
pub fn parse_timestamp(ts: &Timestamp, version: i64) -> Result<chrono::NaiveDateTime, String> {
    // Validate nanos range
    if ts.nanos < 0 || ts.nanos >= 1_000_000_000 {
        return Err(format!(
            "Invalid nanos value {} for timestamp at version {}",
            ts.nanos, version
        ));
    }
    
    // Clamp seconds to valid NaiveDateTime range (similar to indexer util.rs)
    const MAX_TIMESTAMP_SECS: i64 = 253_402_300_799; // 9999-12-31 23:59:59
    const MIN_TIMESTAMP_SECS: i64 = -62135596800;    // 0001-01-01 00:00:00
    
    let clamped_seconds = ts.seconds.clamp(MIN_TIMESTAMP_SECS, MAX_TIMESTAMP_SECS);
    
    #[allow(deprecated)]
    chrono::NaiveDateTime::from_timestamp_opt(clamped_seconds, ts.nanos as u32)
        .ok_or_else(|| format!(
            "Could not parse clamped timestamp {:?} for version {}",
            ts, version
        ))
}

pub fn system_time_to_proto(system_time: SystemTime) -> Result<Timestamp, String> {
    let ts = system_time
        .duration_since(UNIX_EPOCH)
        .map_err(|e| format!("SystemTime before UNIX_EPOCH: {}", e))?;
    
    Ok(Timestamp {
        seconds: ts.as_secs() as i64,
        nanos: ts.subsec_nanos() as i32,
    })
}
```

Update all call sites to handle errors gracefully with logging instead of panicking.

## Proof of Concept

```rust
#[cfg(test)]
mod timestamp_panic_tests {
    use super::*;
    use aptos_protos::util::timestamp::Timestamp;
    
    #[test]
    #[should_panic(expected = "Could not parse timestamp")]
    fn test_timestamp_far_future_panics() {
        // Timestamp in year 300000 - outside NaiveDateTime range
        let invalid_ts = Timestamp {
            seconds: 9_000_000_000_000,
            nanos: 0,
        };
        
        // This will panic in current implementation
        let _ = parse_timestamp(&invalid_ts, 12345);
    }
    
    #[test]
    #[should_panic(expected = "Could not parse timestamp")]
    fn test_timestamp_invalid_nanos_panics() {
        // Invalid nanos value
        let invalid_ts = Timestamp {
            seconds: 1_000_000_000,
            nanos: 1_000_000_000, // Must be < 1,000,000,000
        };
        
        // This will panic
        let _ = parse_timestamp(&invalid_ts, 12345);
    }
    
    #[test]
    #[should_panic(expected = "SystemTime before UNIX EPOCH")]
    fn test_system_time_before_epoch_panics() {
        use std::time::{Duration, UNIX_EPOCH};
        
        // Time before UNIX epoch
        let time_before_epoch = UNIX_EPOCH - Duration::from_secs(1000);
        
        // This will panic
        let _ = system_time_to_proto(time_before_epoch);
    }
}
```

**Notes**

This vulnerability demonstrates a critical divergence in defensive programming practices between different indexer components. While the main indexer (`crates/indexer/src/util.rs`) properly validates and clamps timestamps, the gRPC utilities lack these protections despite being used in production-critical paths. The cascading nature of the failures—where one invalid timestamp can bring down multiple services—elevates this from a simple robustness issue to a medium-severity availability vulnerability requiring defensive validation and graceful error handling.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/lib.rs (L107-113)
```rust
pub fn system_time_to_proto(system_time: SystemTime) -> Timestamp {
    let ts = system_time.duration_since(UNIX_EPOCH).unwrap();
    Timestamp {
        seconds: ts.as_secs() as i64,
        nanos: ts.subsec_nanos() as i32,
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/lib.rs (L125-128)
```rust
pub fn timestamp_to_iso(timestamp: &Timestamp) -> String {
    let dt = parse_timestamp(timestamp, 0);
    dt.format("%Y-%m-%dT%H:%M:%S%.9fZ").to_string()
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/lib.rs (L135-139)
```rust
pub fn parse_timestamp(ts: &Timestamp, version: i64) -> chrono::NaiveDateTime {
    #[allow(deprecated)]
    chrono::NaiveDateTime::from_timestamp_opt(ts.seconds, ts.nanos as u32)
        .unwrap_or_else(|| panic!("Could not parse timestamp {:?} for version {}", ts, version))
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/counters.rs (L284-285)
```rust
    let start_txn_timestamp_iso = start_version_timestamp.map(timestamp_to_iso);
    let end_txn_timestamp_iso = end_version_timestamp.map(timestamp_to_iso);
```

**File:** protos/rust/src/pb/aptos.util.timestamp.rs (L9-19)
```rust
    /// Represents seconds of UTC time since Unix epoch
    /// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
    /// 9999-12-31T23:59:59Z inclusive.
    #[prost(int64, tag="1")]
    pub seconds: i64,
    /// Non-negative fractions of a second at nanosecond resolution. Negative
    /// second values with fractions must still have non-negative nanos values
    /// that count forward in time. Must be from 0 to 999,999,999
    /// inclusive.
    #[prost(int32, tag="2")]
    pub nanos: i32,
```

**File:** crates/indexer/src/util.rs (L58-65)
```rust
pub fn parse_timestamp_secs(ts: u64, version: i64) -> chrono::NaiveDateTime {
    #[allow(deprecated)]
    chrono::NaiveDateTime::from_timestamp_opt(
        std::cmp::min(ts, MAX_TIMESTAMP_SECS as u64) as i64,
        0,
    )
    .unwrap_or_else(|| panic!("Could not parse timestamp {:?} for version {}", ts, version))
}
```
