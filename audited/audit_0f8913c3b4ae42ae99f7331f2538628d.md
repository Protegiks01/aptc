# Audit Report

## Title
Database-Loaded LedgerInfoWithSignatures Bypass Signature Verification During Consensus Recovery

## Summary
Validators loading `LedgerInfoWithSignatures` from their local AptosDB during consensus recovery do not re-verify the BLS aggregate signatures. An attacker with direct database write access can inject forged ledger info with invalid signatures that the recovering validator will trust as the consensus root state.

## Finding Description

The vulnerability exists in the consensus recovery path where validators reload their state from persistent storage. The attack flow is:

1. **Database Deserialization Without Verification**: When consensus starts, `StorageWriteProxy::start()` calls `get_latest_ledger_info()` to load the latest ledger info from AptosDB. [1](#0-0) 

2. **Schema-Level BCS Deserialization**: The `LedgerInfoSchema` simply deserializes the bytes using BCS without any cryptographic verification. [2](#0-1) 

3. **RootInfo Construction**: The unverified `LedgerInfoWithSignatures` is used to construct `RootInfo` containing `commit_cert` and `ordered_cert` wrapped ledger infos. [3](#0-2) 

4. **BlockTree Initialization**: The `RootInfo` is passed to `BlockTree::new()` which stores these certificates as `highest_commit_cert` and `highest_ordered_cert` without calling `verify()`. [4](#0-3) 

5. **No Verification Path**: Grep searches confirm no signature verification occurs on database-loaded ledger info: no calls to `verify_signatures()` on `storage_ledger` or `latest_ledger_info` exist in the recovery code path.

**Contrast with Network Path**: When receiving `SyncInfo` from peers, the code DOES verify signatures through `SyncInfo::verify()`. [5](#0-4)  However, this verification is absent for locally stored data during recovery.

## Impact Explanation

**Severity Assessment**: This issue has **LIMITED CRITICAL IMPACT** despite bypassing signature verification because:

1. **Requires Privileged Access**: The attack requires direct database write access to a validator node, which is equivalent to full system compromise. An attacker with this level of access could also:
   - Modify the consensus binary
   - Access validator private keys
   - Modify configuration files
   - Execute arbitrary code

2. **Limited Network Propagation**: A single compromised validator with forged ledger info cannot force other honest validators to accept the invalid state because:
   - Honest validators would verify any consensus messages received
   - The forged state wouldn't pass validation when broadcast to peers
   - The compromised validator would fall out of sync but not cause network-wide splits

3. **Defense-in-Depth Violation**: While not a standalone critical vulnerability, the lack of verification violates defense-in-depth principles. The system should verify all cryptographic proofs, even from local storage, to protect against:
   - Database corruption (accidental or malicious)
   - Backup/restore attacks
   - Supply chain attacks on database files

## Likelihood Explanation

**Low Likelihood for Network Impact**:
- Requires compromising a validator's filesystem/database (very privileged access)
- Single compromised validator cannot cause consensus safety violations network-wide
- Would require coordinated compromise of >f validators to have consensus impact
- If attacker has database access, they likely have keys too, making signature forging moot

**However**: The lack of verification is a real code path that could be strengthened.

## Recommendation

Implement signature verification on database-loaded `LedgerInfoWithSignatures` during consensus recovery:

```rust
// In StorageWriteProxy::start() or recover_from_ledger()
fn recover_from_ledger(&self) -> LedgerRecoveryData {
    let latest_ledger_info = self
        .aptos_db
        .get_latest_ledger_info()
        .expect("Failed to get latest ledger info.");
    
    // Add verification step
    if let Some(epoch_state) = self.get_current_epoch_state() {
        latest_ledger_info
            .verify_signatures(&epoch_state.verifier)
            .expect("Invalid signatures in stored ledger info - database corruption detected");
    }
    
    LedgerRecoveryData::new(latest_ledger_info)
}
```

This provides defense-in-depth against database tampering attacks while maintaining the existing security model.

## Proof of Concept

**Note**: This vulnerability requires validator node compromise, which is outside the scope of automated testing. A PoC would require:

1. Direct database write access to a validator's AptosDB
2. Crafting a `LedgerInfoWithSignatures` with invalid/forged BLS signatures
3. Writing it to the `LedgerInfoSchema` table
4. Restarting the validator
5. Observing that consensus loads the forged state without verification

The validator would enter an inconsistent state but would not be able to propagate the invalid state to honest peers.

## Notes

**Validation Checklist Assessment**:
- ❌ **Exploitable by unprivileged attacker**: FAILS - requires database write access (validator insider access)
- ✅ Vulnerability lies within Aptos Core codebase
- ❌ **Attack path is realistic**: Database write access is extremely privileged
- ❌ **Impact meets Critical severity**: Limited to compromised node, no network-wide consensus breaks
- ⚠️ Breaks defense-in-depth principle but not a standalone critical vulnerability

**Conclusion**: While the code lacks signature verification on recovery (which is what the security question asks about), this does NOT meet the criteria for a **Critical** vulnerability per the validation checklist because it requires privileged validator insider access (database write) and cannot cause network-wide consensus safety violations. The lack of verification is a defense-in-depth gap rather than an exploitable critical flaw.

### Citations

**File:** storage/aptosdb/src/persistent_liveness_storage.rs (L549-552)
```rust

```

**File:** storage/aptosdb/src/schema/ledger_info/mod.rs (L49-51)
```rust
    fn decode_value(data: &[u8]) -> Result<Self> {
        bcs::from_bytes(data).map_err(Into::into)
    }
```

**File:** consensus/src/persistent_liveness_storage.rs (L125-128)
```rust
                (
                    self.storage_ledger.ledger_info().consensus_block_id(),
                    self.storage_ledger.clone(),
                )
```

**File:** consensus/src/block_storage/block_tree.rs (L140-141)
```rust
            highest_ordered_cert: Arc::new(root_ordered_cert),
            highest_commit_cert: Arc::new(root_commit_cert),
```

**File:** consensus/consensus-types/src/sync_info.rs (L187-200)
```rust
        self.highest_quorum_cert
            .verify(validator)
            .and_then(|_| {
                self.highest_ordered_cert
                    .as_ref()
                    .map_or(Ok(()), |cert| cert.verify(validator))
                    .context("Fail to verify ordered certificate")
            })
            .and_then(|_| {
                // we do not verify genesis ledger info
                if self.highest_commit_cert.commit_info().round() > 0 {
                    self.highest_commit_cert
                        .verify(validator)
                        .context("Fail to verify commit certificate")?
```
