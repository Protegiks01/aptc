# Audit Report

## Title
Weight Double-Counting in Weighted Secret Sharing Due to Incomplete Player Removal and Deserialization Bypass

## Summary
A logic error in `get_random_eligible_subset_of_players()` allows the same player to be selected multiple times when only one player remains in the pool, causing weight double-counting. This bug can only manifest when `threshold_weight > sum(weights)`, which violates the constructor invariant. However, the `WeightedConfig` struct derives `Deserialize` without custom validation, allowing malicious deserialization to bypass constructor checks and create configurations where this invariant is violated. [1](#0-0) 

## Finding Description

The vulnerability exists in the player removal logic within `get_random_eligible_subset_of_players()`. When selecting players to meet the threshold weight requirement, the function should remove each selected player from the pool. However, the removal only occurs when `len > 1`: [2](#0-1) 

When `len == 1`, the last remaining player is NOT removed from `player_and_weights`. If `current_weight < threshold` after selecting this player, the loop continues and selects the same player again, causing weight double-counting.

**Normal Protection**: The constructor validates that `threshold_weight <= sum(weights)`: [3](#0-2) 

This ensures that after selecting all unique players, `current_weight >= threshold`, preventing the bug from manifesting.

**Vulnerability Path**: The `WeightedConfig` struct derives `Deserialize` without custom validation: [4](#0-3) 

While the nested `tc` field has custom deserialization that validates `t <= n`: [5](#0-4) 

There is no validation that `tc.n == sum(weights)`. A malicious serialized `WeightedConfig` could have:
- `tc.threshold = 10, tc.total_shares = 10` (valid `ThresholdConfig`)
- `weights = [3, 3, 3]` (sum = 9, not 10)

This creates the inconsistency where `threshold (10) > sum(weights) (9)`.

**Impact on DKG**: The `DKGPvssConfig` used in Distributed Key Generation contains `WeightedConfig` and derives `Deserialize`: [6](#0-5) 

When `get_random_eligible_subset_of_players()` is used for secret reconstruction, duplicate players cause the same shares to be used multiple times: [7](#0-6) 

Lagrange interpolation with duplicate points is mathematically undefined, causing reconstruction failure and DKG disruption.

## Impact Explanation

**Severity: Medium to High**

This vulnerability could cause:
1. **DKG Failure**: Secret reconstruction fails due to duplicate shares in Lagrange interpolation
2. **Consensus Disruption**: If DKG is used for randomness beacon or validator set operations, failures could disrupt consensus
3. **Denial of Service**: Honest validators unable to complete DKG sessions

However, the exploitability is limited because:
- The attack requires deserialization of malicious `WeightedConfig` data
- I did not find concrete evidence of `DKGPvssConfig` being deserialized from untrusted network sources in the codebase examined
- The normal construction path via `build_dkg_pvss_config` properly validates all constraints

The impact qualifies as **High Severity** (validator node slowdowns, significant protocol violations) if exploitable, but the likelihood is reduced by the lack of a clear deserialization attack vector from untrusted sources.

## Likelihood Explanation

**Likelihood: Low to Medium**

The bug will only manifest if:
1. An attacker can inject a maliciously serialized `WeightedConfig` or `DKGPvssConfig` 
2. The system deserializes this data without additional validation
3. The malicious config has `threshold > sum(weights)`

The normal construction paths appear to properly validate constraints. However, if there are any code paths that deserialize these structures from network messages, local storage, or on-chain data without validation, the bug becomes exploitable.

## Recommendation

**Immediate Fix**: Add custom `Deserialize` implementation for `WeightedConfig` that validates all invariants:

```rust
impl<'de, TC: ThresholdConfig> Deserialize<'de> for WeightedConfig<TC> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct WeightedConfigData<TC> {
            tc: TC,
            num_players: usize,
            weights: Vec<usize>,
            starting_index: Vec<usize>,
            max_weight: usize,
            min_weight: usize,
        }
        
        let data = WeightedConfigData::deserialize(deserializer)?;
        
        // Validate invariants
        let sum_weights: usize = data.weights.iter().sum();
        if sum_weights != data.tc.get_total_num_shares() {
            return Err(serde::de::Error::custom(format!(
                "Invalid WeightedConfig: sum of weights ({}) != tc.total_shares ({})",
                sum_weights, data.tc.get_total_num_shares()
            )));
        }
        
        // Reconstruct using validated new() to ensure all other invariants
        WeightedConfig::new(data.tc.get_threshold(), data.weights)
            .map_err(serde::de::Error::custom)
    }
}
```

**Additional Fix**: Fix the incomplete player removal logic:

```rust
// Remove unconditionally, not just when len > 1
player_and_weights.swap(idx, len - 1);
player_and_weights.pop();
```

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    use aptos_crypto::blstrs::threshold_config::ThresholdConfigBlstrs;
    
    #[test]
    #[should_panic(expected = "reconstruction")]
    fn test_weight_double_counting_exploit() {
        // Manually construct invalid WeightedConfig via deserialization bypass
        // This simulates what could happen if malicious serialized data is processed
        
        // Create valid ThresholdConfig: 10-out-of-10
        let tc = ThresholdConfigBlstrs::new(10, 10).unwrap();
        
        // Manually construct WeightedConfig with mismatched weights
        // weights sum to 9, but tc expects 10
        let invalid_wconfig = WeightedConfig {
            tc,
            num_players: 3,
            weights: vec![3, 3, 3],  // sum = 9, but tc.n = 10!
            starting_index: vec![0, 3, 6],
            max_weight: 3,
            min_weight: 3,
        };
        
        let mut rng = rand::thread_rng();
        let players = invalid_wconfig.get_random_eligible_subset_of_players(&mut rng);
        
        // Due to bug, player 2 will be selected 2+ times
        // players.len() > 3 (should be at most 3 unique players)
        // This causes reconstruction to fail with duplicate points
        assert!(players.len() > 3, "Bug manifested: {} players selected when only 3 exist", players.len());
    }
}
```

**Note**: This PoC cannot be directly compiled as it requires accessing private fields. In a real exploit, the attacker would create malicious serialized bytes and have the system deserialize them.

## Notes

While this vulnerability represents a genuine logic error protected by constructor validation, I **cannot provide concrete evidence** that an unprivileged attacker can trigger it through deserialization of untrusted network data in the current codebase. The `DKGPvssConfig` appears to be constructed via validated paths like `build_dkg_pvss_config`. Without a demonstrated attack vector showing how untrusted data reaches the deserialization path, this may not meet the threshold for a Critical or High severity bounty claim. However, it represents a significant defense-in-depth weakness that should be fixed to prevent future exploitation if deserialization attack vectors emerge.

### Citations

**File:** crates/aptos-crypto/src/weighted_config.rs (L38-54)
```rust
#[derive(Clone, Deserialize, Serialize, Debug, PartialEq, Eq)]
pub struct WeightedConfig<TC: ThresholdConfig> {
    /// A weighted config is a $w$-out-of-$W$ threshold config, where $w$ is the minimum weight
    /// needed to reconstruct the secret and $W$ is the total weight.
    tc: TC,
    /// The total number of players in the protocol.
    num_players: usize,
    /// Each player's weight
    weights: Vec<usize>,
    /// Player's starting index `a` in a vector of all `W` shares, such that this player owns shares
    /// `W[a, a + weight[player])`. Useful during weighted secret reconstruction.
    starting_index: Vec<usize>,
    /// The maximum weight of any player.
    max_weight: usize,
    /// The minimum weight of any player.
    min_weight: usize,
}
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L67-96)
```rust
    pub fn new(threshold_weight: usize, weights: Vec<usize>) -> anyhow::Result<Self> {
        if threshold_weight == 0 {
            return Err(anyhow!(
                "expected the minimum reconstruction weight to be > 0"
            ));
        }

        if weights.is_empty() {
            return Err(anyhow!("expected a non-empty vector of player weights"));
        }
        let max_weight = *weights.iter().max().unwrap();
        let min_weight = *weights.iter().min().unwrap();

        let n = weights.len();
        let W = weights.iter().sum();

        // e.g., Suppose the weights for players 0, 1 and 2 are [2, 4, 3]
        // Then, our PVSS transcript implementation will store a vector of 2 + 4 + 3 = 9 shares,
        // such that:
        //  - Player 0 will own the shares at indices [0..2), i.e.,starting index 0
        //  - Player 1 will own the shares at indices [2..2 + 4) = [2..6), i.e.,starting index 2
        //  - Player 2 will own the shares at indices [6, 6 + 3) = [6..9), i.e., starting index 6
        let mut starting_index = Vec::with_capacity(weights.len());
        starting_index.push(0);

        for w in weights.iter().take(n - 1) {
            starting_index.push(starting_index.last().unwrap() + w);
        }

        let tc = TC::new(threshold_weight, W)?;
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L333-371)
```rust
    fn get_random_eligible_subset_of_players<R>(&self, rng: &mut R) -> Vec<Player>
    where
        R: RngCore,
    {
        // the randomly-picked "capable" subset of players who can reconstruct the secret
        let mut picked_players = vec![];
        // the set of remaining players that we are picking a "capable" subset from
        let mut player_and_weights = self
            .weights
            .iter()
            .enumerate()
            .map(|(i, w)| (i, *w))
            .collect::<Vec<(usize, usize)>>();
        let mut current_weight = 0;

        while current_weight < self.tc.get_threshold() {
            // pick a random player, and move it to the picked set
            let idx = rng.gen_range(0, player_and_weights.len());
            let (player_id, weight) = player_and_weights[idx];
            picked_players.push(self.get_player(player_id));

            // efficiently remove the picked player from the set of remaining players
            let len = player_and_weights.len();
            if len > 1 {
                player_and_weights.swap(idx, len - 1);
                player_and_weights.pop();
            }

            // rinse and repeat until the picked players jointly have enough weight
            current_weight += weight;
        }

        // println!();
        // println!(
        //     "Returned random capable subset {{ {} }}",
        //     vec_to_str!(picked_players)
        // );
        picked_players
    }
```

**File:** crates/aptos-crypto/src/blstrs/threshold_config.rs (L37-54)
```rust
impl<'de> Deserialize<'de> for ThresholdConfigBlstrs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Deserialize only the serializable fields (t, n)
        #[derive(Deserialize)]
        struct SerializedFields {
            t: usize,
            n: usize,
        }

        let serialized = SerializedFields::deserialize(deserializer)?;

        // Rebuild the skipped fields using `new`
        ThresholdConfigBlstrs::new(serialized.t, serialized.n).map_err(serde::de::Error::custom)
    }
}
```

**File:** types/src/dkg/real_dkg/mod.rs (L43-57)
```rust
#[derive(Deserialize, Serialize, Clone, Debug)]
pub struct DKGPvssConfig {
    pub epoch: u64,
    // weighted config for randomness generation
    pub wconfig: SSConfig,
    // weighted config for randomness generation in fast path
    pub fast_wconfig: Option<SSConfig>,
    // DKG public parameters
    pub pp: DkgPP,
    // DKG encryption public keys
    pub eks: Vec<EncPK>,
    // Some metrics for caller to consume.
    #[serde(skip)]
    pub rounding_summary: RoundingSummary,
}
```

**File:** crates/aptos-dkg/src/pvss/test_utils.rs (L336-348)
```rust
    let players_and_shares = sc
        .get_random_eligible_subset_of_players(rng)
        .into_iter()
        .map(|p| {
            let (sk, pk) = trx.decrypt_own_share(sc, &p, &dks[p.get_id()], pp);

            assert_eq!(pk, trx.get_public_key_share(sc, &p));

            (p, sk)
        })
        .collect::<Vec<(Player, T::DealtSecretKeyShare)>>();

    T::DealtSecretKey::reconstruct(sc, &players_and_shares).unwrap()
```
