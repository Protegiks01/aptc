# Audit Report

## Title
Configuration Sanitizer Bypass Allows Mainnet Validators to Use Non-Persistent Storage for Consensus Safety Rules

## Summary
A malicious or misconfigured validator operator can bypass critical safety configuration checks by setting `skip_config_sanitizer: true` in their node configuration, allowing deployment of a mainnet validator with `InMemoryStorage` backend for `SafetyRules` despite explicit sanitization checks designed to prevent this. This enables validators to lose critical consensus safety data upon restart, potentially leading to equivocation and double-voting.

## Finding Description

The `SafetyRulesConfig` struct defaults to using `InMemoryStorage` as its secure backend. [1](#0-0) 

A config sanitizer explicitly checks and rejects `InMemoryStorage` for mainnet validators to prevent consensus safety violations. [2](#0-1) 

However, the `NodeConfig` includes a `skip_config_sanitizer` flag that completely bypasses all sanitization checks when set to `true`. [3](#0-2) 

This flag is user-configurable via the node's YAML configuration file [4](#0-3)  and defaults to `false`, but can be explicitly enabled by a validator operator. [5](#0-4) 

The `InMemoryStorage` implementation is explicitly documented as unsuitable for production use, as it provides no persistence across restarts. [6](#0-5) 

When a validator uses `InMemoryStorage`, the `SafetyData` struct—which tracks critical consensus safety information including `last_voted_round`, `preferred_round`, `one_chain_round`, `last_vote`, and `highest_timeout_round`—is lost upon node restart. [7](#0-6) 

**Attack Path:**
1. Malicious validator operator creates a `validator.yaml` configuration file
2. Sets `node_startup.skip_config_sanitizer: true` in the configuration
3. Either relies on `Default::default()` (which sets `InMemoryStorage`) or explicitly configures `consensus.safety_rules.backend.type: in_memory_storage`
4. Starts the mainnet validator node using `aptos-node --config-path validator.yaml`
5. The sanitizer check is bypassed at startup [8](#0-7) 
6. Validator runs with non-persistent safety storage on mainnet
7. Upon any restart, all `SafetyData` is lost
8. Validator can double-vote or violate consensus safety rules without internal prevention

## Impact Explanation

This vulnerability enables a **Consensus Safety Violation** which qualifies as **Critical Severity** under the Aptos Bug Bounty program.

While a single Byzantine validator does not break BFT consensus safety guarantees (which tolerate < 1/3 Byzantine validators), this vulnerability is critical because:

1. **Breaks Defense-in-Depth**: The sanitizer is a critical safety control designed to prevent exactly this misconfiguration. Its bypass defeats a fundamental security layer.

2. **Enables Equivocation**: Loss of `SafetyData` upon restart allows a validator to:
   - Vote for conflicting proposals in the same round (double-voting)
   - Sign proposals in rounds already voted on  
   - Violate the monotonicity guarantees of `last_voted_round`
   - Break the safety invariants that SafetyRules is designed to enforce

3. **Cascading Risk**: If multiple validator operators (either maliciously or through misconfiguration) use this bypass, and their combined voting power exceeds 1/3, consensus safety guarantees are completely broken, potentially leading to chain splits.

4. **Defeats Mainnet Protections**: The explicit sanitizer check shows clear intent to prevent `InMemoryStorage` on mainnet. The bypass flag defeats this protection entirely.

This violates the critical invariant: **"Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine"** by removing a key defense mechanism.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Accidental Misconfiguration**: Operators copying test configurations or following incomplete documentation could accidentally enable this flag
- **Malicious Use**: A compromised or malicious validator operator can intentionally use this to enable Byzantine behavior
- **Configuration Complexity**: The flag's existence and purpose may not be well-understood, leading to misuse
- **No Runtime Enforcement**: Once the flag is set, there are no additional runtime checks to prevent the dangerous configuration

The test case explicitly demonstrates this bypass working as described. [9](#0-8) 

## Recommendation

**Immediate Fix:**

1. **Remove `skip_config_sanitizer` from production configurations** or make it only available when compiled with a test feature flag:

```rust
#[cfg(not(feature = "production"))]
pub skip_config_sanitizer: bool,
```

2. **Add additional runtime validation** in `SafetyRulesManager::storage()` to explicitly reject `InMemoryStorage` on mainnet regardless of sanitizer status:

```rust
pub fn storage(config: &SafetyRulesConfig) -> PersistentSafetyStorage {
    let backend = &config.backend;
    
    // Additional safety check: Never allow InMemoryStorage in production
    #[cfg(not(any(test, feature = "testing")))]
    if matches!(backend, SecureBackend::InMemoryStorage) {
        panic!("InMemoryStorage is not allowed in production builds");
    }
    
    let internal_storage: Storage = backend.into();
    // ... rest of implementation
}
```

3. **Add chain-specific validation** that cannot be bypassed:

```rust
// In SafetyRulesConfig::sanitize, before the skip check
if let Some(chain_id) = chain_id {
    if chain_id.is_mainnet() && safety_rules_config.backend.is_in_memory() {
        // This check should run BEFORE skip_config_sanitizer
        panic!("CRITICAL: InMemoryStorage cannot be used on mainnet. This is a fatal configuration error.");
    }
}
```

## Proof of Concept

**Step 1:** Create a malicious validator configuration (`malicious_validator.yaml`):

```yaml
base:
  role: validator
  data_dir: "/opt/aptos/data"

node_startup:
  skip_config_sanitizer: true  # Bypass all safety checks
  skip_config_optimizer: false

consensus:
  safety_rules:
    backend:
      type: in_memory_storage  # Use non-persistent storage
    service:
      type: local
    initial_safety_rules_config:
      type: none

# ... rest of validator config
```

**Step 2:** Start the validator node:
```bash
aptos-node --config-path malicious_validator.yaml
```

**Expected Result:** 
- Node starts successfully on mainnet
- Sanitizer check is bypassed (no error about `InMemoryStorage`)
- Console output shows: "Identified node type (Validator) and chain ID (Some(ChainId(1))) from node config!"
- Validator operates with non-persistent safety storage

**Step 3:** Restart the validator:
```bash
pkill aptos-node
aptos-node --config-path malicious_validator.yaml
```

**Expected Result:**
- All `SafetyData` is lost (last_voted_round resets to 0)
- Validator can now vote in rounds it previously voted on
- Consensus safety rules are violated for this validator

**Verification:**
Monitor safety rules metrics to confirm `last_voted_round` resets to 0 after restart, indicating loss of safety data and potential for equivocation.

## Notes

This vulnerability exists at the intersection of insider threat (validator operator) and system design. While the BFT protocol is designed to tolerate Byzantine behavior from individual validators, the sanitizer exists as a critical safety control to prevent operators from accidentally or maliciously enabling such behavior. The `skip_config_sanitizer` flag completely defeats this protection with no additional safeguards, warnings, or documentation about the severe security implications of its use on mainnet.

### Citations

**File:** config/src/config/safety_rules_config.rs (L36-49)
```rust
impl Default for SafetyRulesConfig {
    fn default() -> Self {
        Self {
            backend: SecureBackend::InMemoryStorage,
            logger: LoggerConfig::default(),
            service: SafetyRulesService::Local,
            test: None,
            // Default value of 30 seconds for a timeout
            network_timeout_ms: 30_000,
            enable_cached_safety_data: true,
            initial_safety_rules_config: InitialSafetyRulesConfig::None,
        }
    }
}
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L212-239)
```rust
    fn test_disable_config_sanitizer() {
        // Create a default node config (with sanitization enabled)
        let mut node_config = NodeConfig::default();

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer fails
        let error =
            NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
                .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
    }
```

**File:** config/src/config/node_config.rs (L75-75)
```rust
    pub node_startup: NodeStartupConfig,
```

**File:** config/src/config/node_startup_config.rs (L14-20)
```rust
impl Default for NodeStartupConfig {
    fn default() -> Self {
        Self {
            skip_config_optimizer: false,
            skip_config_sanitizer: false,
        }
    }
```

**File:** secure/storage/src/in_memory.rs (L9-14)
```rust
/// InMemoryStorage represents a key value store that is purely in memory and intended for single
/// threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission checks and simply
/// is a proof of concept to unblock building of applications without more complex data stores.
/// Internally, it retains all data, which means that it must make copies of all key material which
/// violates the code base. It violates it because the anticipation is that data stores would
/// securely handle key material. This should not be used in production.
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** config/src/config/node_config_loader.rs (L126-145)
```rust
/// Optimize and sanitize the node config for the current environment
fn optimize_and_sanitize_node_config(
    node_config: &mut NodeConfig,
    local_config_yaml: Value,
) -> Result<(), Error> {
    // Extract the node type and chain ID from the node config
    let (node_type, chain_id) = extract_node_type_and_chain_id(node_config);

    // Print the extracted node type and chain ID
    println!(
        "Identified node type ({:?}) and chain ID ({:?}) from node config!",
        node_type, chain_id
    );

    // Optimize the node config
    NodeConfig::optimize(node_config, &local_config_yaml, node_type, chain_id)?;

    // Sanitize the node config
    NodeConfig::sanitize(node_config, node_type, chain_id)
}
```
