# Audit Report

## Title
Unbounded RSA Modulus Size in Keyless Authentication Enables Validator CPU Exhaustion

## Summary
The keyless authentication system lacks validation on RSA modulus sizes when parsing JWKs for OpenIdSig verification. An attacker can install federated JWKs with extremely large RSA keys (e.g., 8192-bit moduli) and submit transactions that force all validators to perform computationally expensive signature verifications, causing significant CPU exhaustion without paying proportional gas costs.

## Finding Description

The Aptos keyless authentication system supports two signature verification paths: ZeroKnowledgeSig (using ZK proofs) and OpenIdSig (using direct RSA signature verification). While the ZK path enforces a 256-byte (2048-bit) RSA modulus size constraint, the OpenIdSig path has no such validation.

**Missing Validation in JWK Parsing:**

When JWKs are parsed, the `TryFrom<&serde_json::Value>` implementation for `RSA_JWK` extracts the modulus `n` field as a raw string without any size validation. [1](#0-0) 

The only RSA modulus size validation exists in `to_poseidon_scalar()`, which explicitly checks for the "circuit-supported RSA modulus size" of 256 bytes (2048 bits). However, this method is exclusively used for zero-knowledge proof verification, not for OpenIdSig verification. [2](#0-1) 

**Vulnerable Signature Verification Path:**

For OpenIdSig-based keyless transactions, the signature verification path uses `verify_signature_without_exp_check()` which directly calls `jsonwebtoken::decode()` with the unvalidated RSA key components. [3](#0-2) 

This verification is invoked through `OpenIdSig::verify_jwt_signature()` during transaction validation. [4](#0-3) 

The critical issue is that keyless authenticator validation occurs during `validate_signed_transaction()` BEFORE the transaction prologue executes. [5](#0-4) [6](#0-5) 

Gas checking only happens inside `run_prologue_with_payload()`, which is called after validation. [7](#0-6) 

This means expensive RSA signature verification with large keys is performed before any gas is charged.

**Attack Path:**

1. Any user can call the public entry function `update_federated_jwk_set()` to install custom JWKs at their own address. [8](#0-7) 

2. The only constraints are that JWKs cannot be installed at the `@aptos_framework` address and the BCS-serialized size must be under 2 KiB (2048 bytes). [9](#0-8) [10](#0-9) 

3. An 8192-bit RSA modulus encodes to approximately 1365 base64url characters, which fits within the 2 KiB limit along with other JWK fields.

4. The attacker creates federated keyless accounts using these oversized JWKs and submits transactions with OpenIdSig signatures.

5. During validation, federated JWKs are retrieved from the attacker's address and used for signature verification. [11](#0-10) 

6. All validators processing blocks containing these transactions must perform the expensive RSA signature verification before any gas is charged.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria: "Validator node slowdowns."

RSA signature verification computational cost scales approximately quadratically with key size. An 8192-bit RSA key is 4x larger than the standard 2048-bit key, resulting in approximately 16x slower verification. This creates an asymmetric resource exhaustion attack where:

- The attacker pays only normal transaction gas costs
- Validators incur significantly higher CPU costs for signature verification
- The verification happens before gas charging in the transaction validation phase
- Multiple transactions can be submitted to continuously exhaust validator CPU resources
- All validators in the network are affected when processing blocks containing such transactions

This breaks the fundamental Resource Limits invariant: signature verification cost is unbounded and not reflected in gas consumption, allowing attackers to impose disproportionate computational burden on validators.

## Likelihood Explanation

**Likelihood: High**

The attack is straightforward to execute with no special privileges required:
- `update_federated_jwk_set()` is a public entry function callable by any user
- No compromises of trusted OIDC providers needed
- Attacker has full control over federated JWK installation at their own address
- The 2 KiB serialization limit accommodates 8192-bit RSA keys
- Can be repeated arbitrarily by submitting multiple transactions
- Standard cryptographic libraries easily generate large RSA keys
- The attacker only needs to control a simple OIDC provider to sign JWTs

## Recommendation

Add RSA modulus size validation for all JWK parsing paths, not just the ZK proof path:

1. In `RSA_JWK::TryFrom<&serde_json::Value>`, validate that the decoded modulus size does not exceed `RSA_MODULUS_BYTES` (256 bytes):

```rust
impl TryFrom<&serde_json::Value> for RSA_JWK {
    type Error = anyhow::Error;
    
    fn try_from(json_value: &serde_json::Value) -> Result<Self, Self::Error> {
        // ... existing field extraction ...
        
        let ret = Self { /* ... */ };
        
        // Validate modulus size
        let modulus = base64::decode_config(&ret.n, URL_SAFE_NO_PAD)?;
        ensure!(
            modulus.len() <= Self::RSA_MODULUS_BYTES,
            "RSA modulus size {} exceeds maximum allowed size {}",
            modulus.len(),
            Self::RSA_MODULUS_BYTES
        );
        
        Ok(ret)
    }
}
```

2. Alternatively, enforce the check in `verify_signature_without_exp_check()` before signature verification.

3. Consider adding additional validation in `patch_federated_jwks()` to reject JWK installations with oversized moduli early.

## Proof of Concept

The vulnerability can be demonstrated with the following scenario:

1. Generate an 8192-bit RSA keypair using standard crypto libraries
2. Encode the public key as a JWK with the 8192-bit modulus
3. Call `0x1::jwks::update_federated_jwk_set()` with the oversized JWK
4. Create a federated keyless account pointing to this JWK address
5. Generate a JWT signed with the 8192-bit private key
6. Submit transactions using OpenIdSig with this JWT
7. Observe that validators must verify the 8192-bit RSA signature during transaction validation, before any gas is charged

The computational cost difference can be measured by timing RSA signature verification with 2048-bit vs 8192-bit keys using the `jsonwebtoken` crate's `decode()` function.

**Notes:**
- While the report mentions 12288-bit keys, the 2 KiB limit may not accommodate keys of that size with BCS encoding overhead. However, 8192-bit keys definitely fit and provide sufficient impact for a High severity issue.
- The exact performance degradation ratio depends on the RSA implementation and public exponent used, but the asymmetric cost remains regardless of the precise multiplier.

### Citations

**File:** types/src/jwks/rsa/mod.rs (L89-95)
```rust
    pub fn verify_signature_without_exp_check(&self, jwt_token: &str) -> Result<TokenData<Claims>> {
        let mut validation = Validation::new(Algorithm::RS256);
        validation.validate_exp = false;
        let key = &DecodingKey::from_rsa_components(&self.n, &self.e)?;
        let claims = jsonwebtoken::decode::<Claims>(jwt_token, key, &validation)?;
        Ok(claims)
    }
```

**File:** types/src/jwks/rsa/mod.rs (L102-125)
```rust
    pub fn to_poseidon_scalar(&self) -> Result<ark_bn254::Fr> {
        let mut modulus = base64::decode_config(&self.n, URL_SAFE_NO_PAD)?;
        // The circuit only supports RSA256
        if modulus.len() != Self::RSA_MODULUS_BYTES {
            bail!(
                "Wrong modulus size, must be {} bytes",
                Self::RSA_MODULUS_BYTES
            );
        }

        // This is done to match the circuit, which requires the modulus in a verify specific format
        // due to how RSA verification is implemented
        modulus.reverse();

        let mut scalars = modulus
            .chunks(24) // Pack 3 64 bit limbs per scalar, so chunk into 24 bytes per scalar
            .map(|chunk| {
                poseidon_bn254::keyless::pack_bytes_to_one_scalar(chunk)
                    .expect("chunk converts to scalar")
            })
            .collect::<Vec<ark_bn254::Fr>>();
        scalars.push(ark_bn254::Fr::from(Self::RSA_MODULUS_BYTES as i32));
        poseidon_bn254::hash_scalars(scalars)
    }
```

**File:** types/src/jwks/rsa/mod.rs (L132-178)
```rust
impl TryFrom<&serde_json::Value> for RSA_JWK {
    type Error = anyhow::Error;

    fn try_from(json_value: &serde_json::Value) -> Result<Self, Self::Error> {
        let kty = json_value
            .get("kty")
            .ok_or_else(|| anyhow!("Field `kty` not found"))?
            .as_str()
            .ok_or_else(|| anyhow!("Field `kty` is not a string"))?
            .to_string();

        ensure!(
            kty.as_str() == "RSA",
            "json to rsa jwk conversion failed with incorrect kty"
        );

        let ret = Self {
            kty,
            kid: json_value
                .get("kid")
                .ok_or_else(|| anyhow!("Field `kid` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `kid` is not a string"))?
                .to_string(),
            alg: json_value
                .get("alg")
                .ok_or_else(|| anyhow!("Field `alg` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `alg` is not a string"))?
                .to_string(),
            e: json_value
                .get("e")
                .ok_or_else(|| anyhow!("Field `e` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `e` is not a string"))?
                .to_string(),
            n: json_value
                .get("n")
                .ok_or_else(|| anyhow!("Field `n` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `n` is not a string"))?
                .to_string(),
        };

        Ok(ret)
    }
}
```

**File:** types/src/keyless/openid_sig.rs (L126-139)
```rust
    pub fn verify_jwt_signature(
        &self,
        rsa_jwk: &RSA_JWK,
        jwt_header_json: &str,
    ) -> anyhow::Result<()> {
        let jwt_b64 = format!(
            "{}.{}.{}",
            base64url_encode_str(jwt_header_json),
            base64url_encode_str(&self.jwt_payload_json),
            base64url_encode_bytes(&self.jwt_sig)
        );
        rsa_jwk.verify_signature_without_exp_check(&jwt_b64)?;
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1803-1810)
```rust
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1932-1950)
```rust
        // The prologue MUST be run AFTER any validation. Otherwise you may run prologue and hit
        // SEQUENCE_NUMBER_TOO_NEW if there is more than one transaction from the same sender and
        // end up skipping validation.
        let executable = transaction
            .executable_ref()
            .map_err(|_| deprecated_module_bundle!())?;
        let extra_config = transaction.extra_config();
        self.run_prologue_with_payload(
            session,
            module_storage,
            &serialized_signers,
            executable,
            extra_config,
            transaction_data,
            log_context,
            is_approved_gov_script,
            traversal_context,
        )?;
        Ok(serialized_signers)
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2805-2814)
```rust
        check_gas(
            self.gas_params(log_context)?,
            self.gas_feature_version(),
            session.resolver,
            module_storage,
            txn_data,
            self.features(),
            is_approved_gov_script,
            log_context,
        )?;
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L33-33)
```text
    const MAX_FEDERATED_JWKS_SIZE_BYTES: u64 = 2 * 1024; // 2 KiB
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L183-203)
```text
    public fun patch_federated_jwks(jwk_owner: &signer, patches: vector<Patch>) acquires FederatedJWKs {
        // Prevents accidental calls in 0x1::jwks that install federated JWKs at the Aptos framework address.
        assert!(!system_addresses::is_aptos_framework_address(signer::address_of(jwk_owner)),
            error::invalid_argument(EINSTALL_FEDERATED_JWKS_AT_APTOS_FRAMEWORK)
        );

        let jwk_addr = signer::address_of(jwk_owner);
        if (!exists<FederatedJWKs>(jwk_addr)) {
            move_to(jwk_owner, FederatedJWKs { jwks: AllProvidersJWKs { entries: vector[] } });
        };

        let fed_jwks = borrow_global_mut<FederatedJWKs>(jwk_addr);
        vector::for_each_ref(&patches, |obj|{
            let patch: &Patch = obj;
            apply_patch(&mut fed_jwks.jwks, *patch);
        });

        // TODO: Can we check the size more efficiently instead of serializing it via BCS?
        let num_bytes = vector::length(&bcs::to_bytes(fed_jwks));
        assert!(num_bytes < MAX_FEDERATED_JWKS_SIZE_BYTES, error::invalid_argument(EFEDERATED_JWKS_TOO_LARGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L258-277)
```text
    public entry fun update_federated_jwk_set(jwk_owner: &signer, iss: vector<u8>, kid_vec: vector<String>, alg_vec: vector<String>, e_vec: vector<String>, n_vec: vector<String>) acquires FederatedJWKs {
        assert!(!vector::is_empty(&kid_vec), error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        let num_jwk = vector::length<String>(&kid_vec);
        assert!(vector::length(&alg_vec) == num_jwk , error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&e_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&n_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));

        let remove_all_patch = new_patch_remove_all();
        let patches = vector[remove_all_patch];
        while (!vector::is_empty(&kid_vec)) {
            let kid = vector::pop_back(&mut kid_vec);
            let alg = vector::pop_back(&mut alg_vec);
            let e = vector::pop_back(&mut e_vec);
            let n = vector::pop_back(&mut n_vec);
            let jwk = new_rsa_jwk(kid, alg, e, n);
            let patch = new_patch_upsert_jwk(iss, jwk);
            vector::push_back(&mut patches, patch)
        };
        patch_federated_jwks(jwk_owner, patches);
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L243-260)
```rust
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
        };
```
