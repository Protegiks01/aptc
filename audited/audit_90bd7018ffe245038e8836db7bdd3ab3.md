# Audit Report

## Title
BlockStore RwLock Poisoning Can Cause Permanent Consensus Liveness Failure on Panic During Block Insertion

## Summary
A panic occurring during block insertion while holding the BlockStore's write lock will poison the RwLock, causing all subsequent consensus operations to panic. This creates an inconsistent in-memory BlockTree state where a parent block references a child that doesn't exist in the id_to_block mapping, violating critical tree invariants and requiring node restart for recovery.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **aptos-infallible RwLock wrapper** that panics on poisoned locks [1](#0-0) 

2. **BlockStore's block insertion flow** that persists to storage then acquires write lock [2](#0-1) 

3. **BlockTree's insert_block** with non-atomic state modifications [3](#0-2) 

**Critical execution sequence:**

1. Block is persisted to storage successfully
2. Write lock acquired on `BlockTree` 
3. Parent block's `children` HashSet is modified to add the new child [4](#0-3) 
4. **If panic occurs here** (from assert failure [5](#0-4)  or the add_child assert [6](#0-5)  or any other panic), the RwLock becomes poisoned
5. Block is NOT added to `id_to_block` HashMap
6. `round_to_ids` map is NOT updated
7. Any subsequent lock acquisition panics immediately

**State corruption invariant violations:**
- BlockTree invariant broken: "For all parent links, a child link exists" - parent has child ID in its children set, but that child doesn't exist in id_to_block
- Storage consistency broken: persistent storage has the block, but in-memory tree doesn't
- Consensus Safety: "State transitions must be atomic and verifiable via Merkle proofs"

## Impact Explanation

**Severity: Medium**

This issue causes **validator node liveness failure** requiring manual restart, meeting the criteria for state inconsistencies requiring intervention. However, it does NOT reach Critical severity because:

1. **Single-node impact**: Only affects the validator where the panic occurred, not the entire network
2. **Requires underlying bug**: The panic itself requires either a code bug (duplicate insertion), resource exhaustion, or other panic condition - not directly triggerable by an attacker
3. **Recovery possible**: Node restart with storage rebuild restores consistency
4. **Network resilience**: Aptos consensus tolerates <1/3 Byzantine failures, so a single offline node doesn't halt the network

The poisoned lock prevents the node from participating in consensus until restart, which impacts network decentralization and that validator's rewards, but doesn't compromise overall consensus safety.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability triggers only when:
1. A panic occurs during the critical section between parent modification and full block insertion
2. Realistic panic sources include:
   - Assert failures from duplicate block insertion bugs
   - Out-of-memory during HashMap allocation
   - Integer overflow in counter operations
   - Stack overflow
   - Bugs in Drop implementations

The defensive asserts [5](#0-4)  suggest the developers anticipated potential inconsistency scenarios. The explicit "Cannot currently handle a poisoned lock" message [7](#0-6)  indicates this is a known design limitation.

## Recommendation

**Solution 1: Use panic-safe insertion pattern**

Replace the non-atomic multi-step insertion with a transaction-like pattern:

```rust
pub(super) fn insert_block(
    &mut self,
    block: PipelinedBlock,
) -> anyhow::Result<Arc<PipelinedBlock>> {
    let block_id = block.id();
    if let Some(existing_block) = self.get_block(&block_id) {
        return Ok(existing_block);
    }
    
    // Validate parent exists before any modifications
    let parent_id = block.parent_id();
    ensure!(
        self.get_linkable_block(&parent_id).is_some(),
        "Parent block {} not found",
        parent_id
    );
    
    // Validate no duplicate before modifications
    ensure!(
        !self.id_to_block.contains_key(&block_id),
        "Block {} already exists in tree",
        block_id
    );
    
    let linkable_block = LinkableBlock::new(block);
    let arc_block = Arc::clone(linkable_block.executed_block());
    
    // All validations passed, now perform atomic modifications
    // If panic occurs after this point, data is corrupted
    self.id_to_block.insert(block_id, linkable_block);
    self.round_to_ids.insert(arc_block.round(), block_id);
    
    // This is last and can fail without corruption
    if let Some(parent_block) = self.get_linkable_block_mut(&parent_id) {
        let _ = parent_block.children.insert(block_id); // Don't assert
    }
    
    counters::NUM_BLOCKS_IN_TREE.inc();
    Ok(arc_block)
}
```

**Solution 2: Handle poisoned locks gracefully in aptos-infallible**

Modify the RwLock wrapper to recover from poisoned state rather than panic.

**Solution 3: Use std::panic::catch_unwind around critical section**

Wrap the insert_block call in catch_unwind to prevent lock poisoning.

## Proof of Concept

```rust
#[cfg(test)]
mod poison_test {
    use super::*;
    use std::panic;
    
    #[test]
    #[should_panic(expected = "Cannot currently handle a poisoned lock")]
    fn test_poisoned_lock_on_panic_during_insertion() {
        // Setup BlockStore with initial state
        let block_store = /* initialize BlockStore */;
        
        // Insert a valid parent block
        let parent_block = /* create parent block */;
        block_store.insert_block(parent_block).await.unwrap();
        
        // Attempt to insert child block that will panic mid-insertion
        // by triggering the assert on line 325 through test hooks
        let child_block = /* create child with same ID as existing */;
        
        // This should panic during insertion, poisoning the lock
        let _ = panic::catch_unwind(|| {
            block_store.insert_block(child_block).await
        });
        
        // Any subsequent operation should panic due to poisoned lock
        let new_block = /* create another block */;
        block_store.insert_block(new_block).await.unwrap(); // Panics here
    }
}
```

## Notes

While this represents a genuine code quality issue with the aptos-infallible design decision to panic on poisoned locks, **the exploitability by an unprivileged external attacker is extremely limited**. The panic must originate from internal code paths (bugs, resource exhaustion) rather than malicious input, as block validation occurs before insertion. This is primarily a **resilience and availability issue** rather than a direct security vulnerability, as the network continues operating and the affected node can recover via restart.

### Citations

**File:** crates/aptos-infallible/src/rwlock.rs (L22-22)
```rust
            .expect("Cannot currently handle a poisoned lock")
```

**File:** crates/aptos-infallible/src/rwlock.rs (L26-30)
```rust
    pub fn write(&self) -> RwLockWriteGuard<'_, T> {
        self.0
            .write()
            .expect("Cannot currently handle a poisoned lock")
    }
```

**File:** consensus/src/block_storage/block_store.rs (L512-516)
```rust
        self.storage
            .save_tree(vec![pipelined_block.block().clone()], vec![])
            .context("Insert block failed when saving block")?;
        self.inner.write().insert_block(pipelined_block)
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L55-61)
```rust
    pub fn add_child(&mut self, child_id: HashValue) {
        assert!(
            self.children.insert(child_id),
            "Block {:x} already existed.",
            child_id,
        );
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L319-325)
```rust
            match self.get_linkable_block_mut(&block.parent_id()) {
                Some(parent_block) => parent_block.add_child(block_id),
                None => bail!("Parent block {} not found", block.parent_id()),
            };
            let linkable_block = LinkableBlock::new(block);
            let arc_block = Arc::clone(linkable_block.executed_block());
            assert!(self.id_to_block.insert(block_id, linkable_block).is_none());
```
