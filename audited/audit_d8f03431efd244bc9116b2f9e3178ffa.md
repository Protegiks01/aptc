# Audit Report

## Title
Missing Epoch Validation in sign_commit_vote() Allows Cross-Epoch Commit Signatures

## Summary
The `guarded_sign_commit_vote()` function in SafetyRules lacks epoch validation, allowing validators to generate signatures for commit votes from epochs different than their current epoch. This violates epoch isolation guarantees and creates a consensus safety vulnerability during epoch transitions or when consensus bugs allow wrong-epoch data through.

## Finding Description

The SafetyRules component is the final guardian of consensus safety, enforcing voting rules that prevent validators from signing invalid state. All other signing functions (`guarded_sign_proposal`, `guarded_sign_timeout_with_qc`, `guarded_construct_and_sign_vote_two_chain`) validate that the epoch matches the current SafetyRules epoch stored in `SafetyData`. [1](#0-0) 

However, `guarded_sign_commit_vote()` completely omits this critical validation: [2](#0-1) 

The function only validates that the old and new ledger infos match in their pre-execution fields (epoch, round, id) via `match_ordered_only()`: [3](#0-2) 

But critically, it never checks that these epochs match the current SafetyRules epoch: [4](#0-3) 

When `skip_sig_verify = true` (Local mode, which is the default for local SafetyRules instances), even the signature verification is bypassed: [5](#0-4) 

**Attack Scenario:**

During epoch transition (epoch N â†’ epoch N+1):
1. The buffer manager has ExecutedItems with `ordered_proof` from epoch N still in the pipeline
2. SafetyRules transitions to epoch N+1 via `guarded_initialize()`
3. `advance_signing_root()` creates a SigningRequest with epoch N data: [6](#0-5) 

4. SigningPhase calls `sign_commit_vote(ordered_proof_epoch_N, commit_ledger_info_epoch_N)`
5. `guarded_sign_commit_vote()` validates consistency between the two ledger infos (both epoch N) but never checks against SafetyData.epoch (N+1)
6. If `skip_sig_verify = true`, the validator signs a commit for epoch N while operating in epoch N+1

This violates the fundamental consensus invariant that validators must only sign for their current epoch, enabling potential consensus safety violations.

## Impact Explanation

**Severity: HIGH** (Significant Protocol Violation - up to $50,000 per Aptos Bug Bounty)

This vulnerability breaks **Consensus Safety Invariant #2** by allowing validators to sign commits for epochs they are not currently operating in. The impacts include:

1. **Epoch Isolation Violation**: Validators can sign commits for previous or future epochs, breaking the epoch boundary guarantees that are fundamental to AptosBFT safety.

2. **Consensus Safety Risk**: During epoch transitions, validators could sign conflicting commits across epoch boundaries, potentially enabling chain splits or equivocation that wouldn't normally be possible.

3. **Defense-in-Depth Failure**: SafetyRules is the last line of defense. Even if consensus has bugs that allow wrong-epoch data through, SafetyRules should protect against it. This missing check means SafetyRules fails its core mission.

4. **Replay Attack Surface**: Old epoch signatures could potentially be replayed or misused in ways that would normally be prevented by epoch isolation.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability is highly likely to be triggered in production:

1. **Epoch Transitions Are Common**: Aptos undergoes regular epoch changes (governance-triggered reconfigurations, validator set updates). During these transitions, there's a window where old-epoch ExecutedItems may still be in the signing pipeline.

2. **Race Condition Window**: The buffer manager and SafetyRules epoch updates are not atomic. Between SafetyRules initializing for epoch N+1 and the buffer being cleared of epoch N items, there's a race where this vulnerability is exposed.

3. **No Defense When skip_sig_verify=true**: Local mode completely bypasses signature verification, making this trivially exploitable without requiring validator set changes between epochs.

4. **No Test Coverage**: The absence of tests for cross-epoch sign_commit_vote indicates this scenario was not considered during development: [7](#0-6) 

## Recommendation

Add epoch validation in `guarded_sign_commit_vote()` consistent with other signing functions:

```rust
fn guarded_sign_commit_vote(
    &mut self,
    ledger_info: LedgerInfoWithSignatures,
    new_ledger_info: LedgerInfo,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;

    let old_ledger_info = ledger_info.ledger_info();
    
    // FIX: Add epoch validation
    let mut safety_data = self.persistent_storage.safety_data()?;
    self.verify_epoch(old_ledger_info.epoch(), &safety_data)?;
    self.verify_epoch(new_ledger_info.epoch(), &safety_data)?;

    if !old_ledger_info.commit_info().is_ordered_only()
        && old_ledger_info.commit_info() != new_ledger_info.commit_info()
    {
        return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
    }

    if !old_ledger_info
        .commit_info()
        .match_ordered_only(new_ledger_info.commit_info())
    {
        return Err(Error::InconsistentExecutionResult(
            old_ledger_info.commit_info().to_string(),
            new_ledger_info.commit_info().to_string(),
        ));
    }

    if !self.skip_sig_verify {
        ledger_info
            .verify_signatures(&self.epoch_state()?.verifier)
            .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
    }

    let signature = self.sign(&new_ledger_info)?;
    Ok(signature)
}
```

## Proof of Concept

```rust
#[test]
fn test_sign_commit_vote_wrong_epoch() {
    use aptos_safety_rules::test_utils;
    use aptos_types::block_info::BlockInfo;
    
    // Create SafetyRules in epoch 1
    let (mut safety_rules, signer) = test_utils::make_safety_rules();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();
    
    // Create blocks in epoch 1
    let round = genesis_qc.certified_block().round();
    let a1 = test_utils::make_proposal_with_qc(round + 1, genesis_qc, &signer);
    let ordered_ledger_info = a1.block().quorum_cert().ledger_info().clone();
    
    // Create commit ledger info for epoch 1
    let commit_ledger_info = LedgerInfo::new(
        ordered_ledger_info.ledger_info().commit_info().clone(),
        HashValue::zero()
    );
    
    // Advance SafetyRules to epoch 2 (simulating epoch transition)
    let epoch2_proof = test_utils::make_epoch_change_proof(2);
    safety_rules.initialize(&epoch2_proof).unwrap();
    
    // Attempt to sign commit vote for epoch 1 data while in epoch 2
    // VULNERABILITY: This should fail with IncorrectEpoch but currently succeeds in Local mode
    let result = safety_rules.sign_commit_vote(
        ordered_ledger_info,
        commit_ledger_info
    );
    
    // Expected: Err(Error::IncorrectEpoch(1, 2))
    // Actual: Ok(signature) when skip_sig_verify=true
    assert!(matches!(result, Err(Error::IncorrectEpoch(1, 2))), 
        "Should reject signing for wrong epoch, got: {:?}", result);
}
```

## Notes

This vulnerability demonstrates a critical gap in SafetyRules' defense-in-depth strategy. While consensus protocols typically ensure epoch consistency, SafetyRules must independently enforce this invariant as the final safety check. The inconsistency between validation in other signing functions and `sign_commit_vote()` suggests this was an oversight rather than an intentional design decision.

The vulnerability is particularly concerning because the comment in the code explicitly states that `skip_sig_verify` mode relies on "consensus already verifies" - but epoch validation is not consensus verification, it's a SafetyRules state consistency check that should always be performed.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L346-369)
```rust
    fn guarded_sign_proposal(
        &mut self,
        block_data: &BlockData,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        self.verify_author(block_data.author())?;

        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(block_data.epoch(), &safety_data)?;

        if block_data.round() <= safety_data.last_voted_round {
            return Err(Error::InvalidProposal(format!(
                "Proposed round {} is not higher than last voted round {}",
                block_data.round(),
                safety_data.last_voted_round
            )));
        }

        self.verify_qc(block_data.quorum_cert())?;
        self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;
        // we don't persist the updated preferred round to save latency (it'd be updated upon voting)

        let signature = self.sign(block_data)?;
        Ok(signature)
```

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L131-136)
```rust
    pub fn new_local(storage: PersistentSafetyStorage) -> Self {
        let safety_rules = SafetyRules::new(storage, true);
        Self {
            internal_safety_rules: SafetyRulesWrapper::Local(Arc::new(RwLock::new(safety_rules))),
        }
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L456-488)
```rust
    async fn advance_signing_root(&mut self) {
        let cursor = self.signing_root;
        self.signing_root = self
            .buffer
            .find_elem_from(cursor.or_else(|| *self.buffer.head_cursor()), |item| {
                item.is_executed()
            });
        sample!(
            SampleRate::Frequency(2),
            info!(
                "Advance signing root from {:?} to {:?}",
                cursor, self.signing_root
            )
        );
        if self.signing_root.is_some() {
            let item = self.buffer.get(&self.signing_root);
            let executed_item = item.unwrap_executed_ref();
            let request = self.create_new_request(SigningRequest {
                ordered_ledger_info: executed_item.ordered_proof.clone(),
                commit_ledger_info: executed_item.partial_commit_proof.data().clone(),
                blocks: executed_item.executed_blocks.clone(),
            });
            if cursor == self.signing_root {
                let sender = self.signing_phase_tx.clone();
                Self::spawn_retry_request(sender, request, Duration::from_millis(100));
            } else {
                self.signing_phase_tx
                    .send(request)
                    .await
                    .expect("Failed to send signing request");
            }
        }
    }
```

**File:** consensus/safety-rules/src/tests/suite.rs (L846-876)
```rust
fn test_sign_commit_vote(constructor: &Callback) {
    // we construct a chain of proposals
    // genesis -- a1 -- a2 -- a3

    let (mut safety_rules, signer) = constructor();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);

    let round = genesis_qc.certified_block().round();
    safety_rules.initialize(&proof).unwrap();

    let a1 = test_utils::make_proposal_with_qc(round + 1, genesis_qc, &signer);
    let a2 = make_proposal_with_parent(round + 2, &a1, None, &signer);
    let a3 = make_proposal_with_parent(round + 3, &a2, Some(&a1), &signer);

    // now we try to agree on a1's execution result
    let ledger_info_with_sigs = a3.block().quorum_cert().ledger_info();
    // make sure this is for a1
    assert!(ledger_info_with_sigs
        .ledger_info()
        .commit_info()
        .match_ordered_only(
            &a1.block()
                .gen_block_info(*ACCUMULATOR_PLACEHOLDER_HASH, 0, None,)
        ));

    assert!(safety_rules
        .sign_commit_vote(
            ledger_info_with_sigs.clone(),
            ledger_info_with_sigs.ledger_info().clone()
        )
        .is_ok());
```
