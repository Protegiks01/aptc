# Audit Report

## Title
Unbounded MSM Computation in DKG Sigma Protocol Enables Validator DoS via Malicious Transcript Deserialization

## Summary
The DKG protocol's sigma protocol verification performs unbounded multi-scalar multiplication (MSM) operations on attacker-controlled witness data deserialized from DKG transcripts. An attacker can craft a malicious transcript containing extremely large nested vectors in the proof witness, causing memory exhaustion and CPU overload during verification, leading to validator node crashes and preventing DKG key generation.

## Finding Description

The vulnerability exists in the DKG transcript verification flow where sigma protocol proofs are deserialized and verified without validating the size of witness vectors before performing expensive cryptographic operations.

**Attack Flow:**

1. **Unbounded Deserialization**: DKG transcripts are deserialized without size limits [1](#0-0) 

2. **Malicious Witness Structure**: The proof contains a witness with unconstrained nested vectors [2](#0-1) 

3. **Missing Size Validation**: Verification only checks outer dimensions, not inner vector sizes [3](#0-2) 

4. **Direct MSM Usage**: The witness is directly used to create MSM terms without bounds checking [4](#0-3) 

5. **MSM Term Construction**: Creates MSM inputs by iterating over unchecked nested vectors [5](#0-4) 

6. **Unbounded MSM Computation**: Performs expensive curve operations with no upper bound [6](#0-5) 

**Attack Scenario:**
- Legitimate transcript: ~32,000 scalars (200 validators × 10 weight × 16 chunks)
- Malicious transcript: 100,000,000 scalars (1 player × 1 weight × 100M chunks)
- Memory: 100M × 32 bytes = 3.2 GB per malicious transcript
- Computation: Minutes to hours of MSM operations on 100M points

The attacker can craft the `chunked_plaintexts` or `elgamal_randomness` fields in `HkzgWeightedElgamalWitness` with arbitrarily large inner vectors, bypassing the outer dimension checks that only validate against `sc.get_total_num_players()`.

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Severity: HIGH** (Validator node slowdowns, per Aptos Bug Bounty criteria)

**Impact:**
- **Memory Exhaustion**: Gigabytes of memory allocated during deserialization and verification
- **CPU Exhaustion**: Hours of MSM computation blocking validator threads
- **Validator Node DoS**: Nodes crash or become unresponsive during DKG
- **DKG Protocol Failure**: Prevents validator key generation for randomness beacon
- **Network Liveness Impact**: Blocks epoch transitions requiring DKG completion

The vulnerability affects all validators participating in DKG verification when a malicious transcript is broadcast, potentially causing network-wide disruption during critical reconfiguration periods.

## Likelihood Explanation

**Likelihood: HIGH**

**Attack Prerequisites:**
- Attacker must be a validator participating in DKG (common during normal operations)
- Requires ability to submit DKG transcript (standard validator capability)
- No collusion or stake majority required

**Ease of Exploitation:**
- Simple to craft: Modify witness vectors in serialized transcript
- Deterministic: Always causes resource exhaustion on targeted validators
- Low cost: Single malicious transcript can DoS multiple validators
- Hard to detect: Appears as legitimate transcript until verification

The attack is highly likely because any participant in the DKG protocol can submit a malicious transcript, and the computational cost is imposed on all verifying validators.

## Recommendation

**Immediate Fix:**

1. **Add Size Validation Before MSM Operations:**

Add bounds checking in `weighted_transcript.rs` after line 153:

```rust
// Validate witness sizes before expensive verification
let max_chunks = num_chunks_per_scalar::<E::ScalarField>(pp.ell) as usize;
let max_total_chunks = sc.get_total_weight() * max_chunks;

if let FirstProofItem::Commitment(_) = &self.sharing_proof.SoK.first_proof_item {
    // For compact proofs, validate the witness size
    let total_chunks: usize = self.sharing_proof.SoK.z.chunked_plaintexts
        .iter()
        .flat_map(|player| player.iter())
        .map(|inner| inner.len())
        .sum();
    
    if total_chunks > max_total_chunks {
        bail!("Witness chunked_plaintexts exceeds maximum size: {} > {}", 
              total_chunks, max_total_chunks);
    }
    
    let total_randomness: usize = self.sharing_proof.SoK.z.elgamal_randomness
        .iter()
        .map(|inner| inner.len())
        .sum();
    
    if total_randomness > sc.get_max_weight() * max_chunks {
        bail!("Witness elgamal_randomness exceeds maximum size: {} > {}",
              total_randomness, sc.get_max_weight() * max_chunks);
    }
}
```

2. **Use Bounded Deserialization:**

Replace unbounded `bcs::from_bytes` with size-limited version in `dkg.rs` line 106:

```rust
const MAX_TRANSCRIPT_SIZE: usize = 10 * 1024 * 1024; // 10 MB limit
let transcript = bcs::from_bytes_with_limit::<<DefaultDKG as DKGTrait>::Transcript>(
    dkg_node.transcript_bytes.as_slice(),
    MAX_TRANSCRIPT_SIZE
)
.map_err(|_| Expected(TranscriptDeserializationFailed))?;
```

3. **Add MsmInput Size Validation:**

Modify `MsmInput::new` in `msm.rs` line 77 to enforce maximum size:

```rust
fn new(bases: Vec<Self::Base>, scalars: Vec<Self::Scalar>) -> anyhow::Result<Self> {
    const MAX_MSM_SIZE: usize = 1_000_000; // 1M point limit
    if bases.len() != scalars.len() {
        anyhow::bail!("MsmInput length mismatch: {} bases, {} scalars", 
                     bases.len(), scalars.len());
    }
    if bases.len() > MAX_MSM_SIZE {
        anyhow::bail!("MsmInput exceeds maximum size: {} > {}", 
                     bases.len(), MAX_MSM_SIZE);
    }
    Ok(Self { bases, scalars })
}
```

## Proof of Concept

```rust
// Proof of Concept: Create malicious DKG transcript with oversized witness
use aptos_dkg::pvss::chunky::{
    hkzg_chunked_elgamal::HkzgWeightedElgamalWitness,
    weighted_transcript::Transcript,
};
use aptos_crypto::arkworks::random::sample_field_elements;
use ark_bls12_381::{Bls12_381, Fr};

fn create_malicious_transcript() -> Transcript<Bls12_381> {
    let mut rng = rand::thread_rng();
    
    // Create malicious witness with 10 million chunks instead of expected ~16
    let malicious_chunks_count = 10_000_000;
    
    let malicious_witness = HkzgWeightedElgamalWitness {
        hkzg_randomness: univariate_hiding_kzg::CommitmentRandomness::<Fr>::rand(&mut rng),
        chunked_plaintexts: vec![
            vec![
                Scalar::vec_from_inner(
                    sample_field_elements(malicious_chunks_count, &mut rng)
                )
            ]
        ],
        elgamal_randomness: vec![
            vec![Scalar(Fr::rand(&mut rng)); malicious_chunks_count]
        ],
    };
    
    // Create proof with malicious witness
    let malicious_proof = sigma_protocol::Proof {
        first_proof_item: FirstProofItem::Commitment(/* legitimate commitment */),
        z: malicious_witness, // This will cause DoS during verification
    };
    
    // Create transcript with malicious proof
    Transcript {
        dealer: Player { id: 0 },
        subtrs: /* legitimate subtranscript */,
        sharing_proof: SharingProof {
            SoK: malicious_proof,
            range_proof: /* legitimate range proof */,
            range_proof_commitment: /* legitimate commitment */,
        },
    }
}

// When this transcript is verified:
// 1. Deserialization succeeds (no size limit)
// 2. Outer dimension checks pass (1 player is valid)
// 3. MSM terms are created from 10M elements
// 4. MSM computation allocates 10M * 96 bytes ≈ 960 MB
// 5. Curve operations take hours, blocking validator
```

**Notes**

This vulnerability is particularly severe because:
1. It affects the DKG protocol which is critical for validator set changes
2. The attack can be triggered by any DKG participant without special privileges
3. Multiple validators verify the same transcript, amplifying the DoS impact
4. No gas metering applies to validator transaction processing, so resource exhaustion is uncapped

### Citations

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L106-109)
```rust
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;
```

**File:** crates/aptos-dkg/src/pvss/chunky/hkzg_chunked_elgamal.rs (L47-51)
```rust
pub struct HkzgWeightedElgamalWitness<F: PrimeField> {
    pub hkzg_randomness: univariate_hiding_kzg::CommitmentRandomness<F>,
    pub chunked_plaintexts: Vec<Vec<Vec<Scalar<F>>>>, // For each player, plaintexts z_i, which are chunked z_{i,j}
    pub elgamal_randomness: Vec<Vec<Scalar<F>>>, // For at most max_weight, for each chunk, a blinding factor
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-153)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L124-124)
```rust
        let msm_terms_for_prover_response = self.msm_terms(&proof.z);
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L229-259)
```rust
    fn msm_terms(&self, input: &Self::Domain) -> Self::CodomainShape<Self::MsmInput> {
        // C_{i,j} = z_{i,j} * G_1 + r_j * ek[i]
        let Cs = input
            .plaintext_chunks
            .iter()
            .enumerate()
            .map(|(i, z_i)| {
                // here `i` is the player's id
                chunks_vec_msm_terms::<C>(self.pp, self.eks[i], z_i, &input.plaintext_randomness)
            })
            .collect();

        // R_j = r_j * H_1
        let Rs = input
            .plaintext_randomness
            .iter()
            .map(|inner_vec| {
                inner_vec
                    .iter()
                    .map(|&r_j| MsmInput {
                        bases: vec![self.pp.H],
                        scalars: vec![r_j.0],
                    })
                    .collect()
            })
            .collect();

        WeightedCodomainShape {
            chunks: Cs,
            randomness: Rs,
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L262-264)
```rust
    fn msm_eval(input: Self::MsmInput) -> Self::MsmOutput {
        C::msm(input.bases(), input.scalars()).expect("MSM failed in ChunkedElgamal")
    }
```
