# Audit Report

## Title
Unauthorized CoinStore Migration via migrate_coin_store_to_fungible_store Function

## Summary
The `migrate_coin_store_to_fungible_store` entry function allows any user to migrate any account's CoinStore to a FungibleStore without requiring the account owner's signature, once migration feature flags are enabled. While the `MigrationFlag` struct is deprecated and unused, the actual migration mechanism lacks proper authorization checks.

## Finding Description

The Aptos Framework provides two migration functions in the coin module:

1. **Authorized migration** [1](#0-0)  - This function requires the account's signer and includes permission checks.

2. **Unauthorized migration** [2](#0-1)  - This function accepts a vector of addresses without requiring any signer or authorization from those accounts.

The vulnerability lies in `migrate_coin_store_to_fungible_store`, which only checks whether certain feature flags are enabled but performs no authorization verification for the accounts being migrated. The function calls `maybe_convert_to_fungible_store` [3](#0-2)  which performs a destructive state change by moving the entire CoinStore resource from the account and converting it to a FungibleStore.

**Attack Path:**
1. Attacker waits for `NEW_ACCOUNTS_DEFAULT_TO_FA_STORE` or `NEW_ACCOUNTS_DEFAULT_TO_FA_APT_STORE` feature flags to be enabled
2. Attacker submits transaction calling `migrate_coin_store_to_fungible_store<CoinType>(vec![victim_address_1, victim_address_2, ...])`
3. The function migrates all specified accounts without their consent
4. Victims' CoinStores are removed and replaced with FungibleStores

**Regarding MigrationFlag:** The `MigrationFlag` struct [4](#0-3)  is marked as deprecated [5](#0-4)  and is not actively used in the current migration logic, making it irrelevant to the authorization concern.

## Impact Explanation

This is classified as **Medium Severity** because:

- **No direct funds loss**: The migration preserves account balances and frozen states
- **State consistency maintained**: The conversion is designed to be equivalent
- **Unauthorized state modification**: Users lose control over their account storage format
- **Application compatibility risk**: External systems expecting CoinStore may break
- **Limited by governance**: The vulnerability only activates when feature flags are enabled

This does not qualify for High severity because it does not cause validator slowdowns, API crashes, or significant protocol safety violations. It does not qualify for Critical severity as there is no loss of funds, consensus violation, or network partition.

## Likelihood Explanation

**Likelihood: Medium**

The exploit requires:
- Feature flags to be enabled (governance-controlled decision)
- Knowledge of target addresses
- Simple entry function call (low technical barrier)

Once feature flags are enabled, execution is trivial. However, the feature flags themselves provide a governance gate, suggesting this may be intentional design for system-wide migration rather than a pure vulnerability. The lack of explicit authorization checks contrasts with the authorized `migrate_to_fungible_store` function, indicating potential oversight.

## Recommendation

Add authorization checks to `migrate_coin_store_to_fungible_store`:

**Option 1: Restrict to framework account**
```move
public entry fun migrate_coin_store_to_fungible_store<CoinType>(
    framework: &signer,
    accounts: vector<address>
) acquires CoinStore, CoinConversionMap, CoinInfo {
    system_addresses::assert_aptos_framework(framework);
    if (features::new_accounts_default_to_fa_store_enabled()
        || features::new_accounts_default_to_fa_apt_store_enabled()) {
        std::vector::for_each(accounts, |account| {
            maybe_convert_to_fungible_store<CoinType>(account);
        });
    }
}
```

**Option 2: Require all account signers**
```move
public entry fun migrate_coin_store_to_fungible_store<CoinType>(
    accounts: vector<&signer>
) acquires CoinStore, CoinConversionMap, CoinInfo {
    if (features::new_accounts_default_to_fa_store_enabled()
        || features::new_accounts_default_to_fa_apt_store_enabled()) {
        std::vector::for_each(accounts, |account| {
            assert_signer_has_permission<CoinType>(account);
            maybe_convert_to_fungible_store<CoinType>(signer::address_of(account));
        });
    }
}
```

## Proof of Concept

```move
#[test_only]
module test_addr::unauthorized_migration_test {
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    use std::vector;
    
    #[test(attacker = @0xBAD, victim = @0xVICTIM, framework = @aptos_framework)]
    fun test_unauthorized_migration(
        attacker: &signer,
        victim: &signer, 
        framework: &signer
    ) {
        // Setup: Enable feature flags
        use aptos_framework::features;
        features::change_feature_flags_for_testing(
            framework,
            vector[features::get_new_accounts_default_to_fa_store_feature()],
            vector[]
        );
        
        // Setup: Create accounts and register coin stores
        aptos_framework::account::create_account_for_test(signer::address_of(attacker));
        aptos_framework::account::create_account_for_test(signer::address_of(victim));
        coin::register<AptosCoin>(victim);
        
        // Attack: Attacker migrates victim's account without authorization
        let victim_addr = signer::address_of(victim);
        coin::migrate_coin_store_to_fungible_store<AptosCoin>(
            vector[victim_addr]  // No victim signature required!
        );
        
        // Verify: Victim's CoinStore was migrated without consent
        assert!(!exists<coin::CoinStore<AptosCoin>>(victim_addr), 0);
    }
}
```

## Notes

This finding represents an **authorization gap** rather than a critical security vulnerability. The design may be intentional for facilitating system-wide migration when governance enables the feature flags. However, it violates the principle of user sovereignty over account state and contradicts the authorization pattern used in `migrate_to_fungible_store`. The severity is limited by governance-controlled feature flags and the preservation of all account invariants (balance, frozen state).

### Citations

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L650-701)
```text
    fun maybe_convert_to_fungible_store<CoinType>(
        account: address
    ) acquires CoinStore, CoinConversionMap, CoinInfo {
        if (exists<CoinStore<CoinType>>(account)) {
            let CoinStore<CoinType> { coin, frozen, deposit_events, withdraw_events } =
                move_from<CoinStore<CoinType>>(account);
            if (is_coin_initialized<CoinType>() && coin.value > 0) {
                let metadata = ensure_paired_metadata<CoinType>();
                let store =
                    primary_fungible_store::ensure_primary_store_exists(
                        account, metadata
                    );

                event::emit(
                    CoinStoreDeletion {
                        coin_type: type_info::type_name<CoinType>(),
                        event_handle_creation_address: guid::creator_address(
                            event::guid(&deposit_events)
                        ),
                        deleted_deposit_event_handle_creation_number: guid::creation_num(
                            event::guid(&deposit_events)
                        ),
                        deleted_withdraw_event_handle_creation_number: guid::creation_num(
                            event::guid(&withdraw_events)
                        )
                    }
                );

                if (coin.value == 0) {
                    destroy_zero(coin);
                } else {
                    fungible_asset::unchecked_deposit_with_no_events(
                        object_address(&store),
                        coin_to_fungible_asset(coin)
                    );
                };

                // Note:
                // It is possible the primary fungible store may already exist before this function call.
                // In this case, if the account owns a frozen CoinStore and an unfrozen primary fungible store, this
                // function would convert and deposit the rest coin into the primary store and freeze it to make the
                // `frozen` semantic as consistent as possible.
                if (frozen != fungible_asset::is_frozen(store)) {
                    fungible_asset::set_frozen_flag_internal(store, frozen);
                }
            } else {
                destroy_zero(coin);
            };
            event::destroy_handle(deposit_events);
            event::destroy_handle(withdraw_events);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L716-723)
```text
    /// Voluntarily migrate to fungible store for `CoinType` if not yet.
    public entry fun migrate_to_fungible_store<CoinType>(
        account: &signer
    ) acquires CoinStore, CoinConversionMap, CoinInfo {
        let account_addr = signer::address_of(account);
        assert_signer_has_permission<CoinType>(account);
        maybe_convert_to_fungible_store<CoinType>(account_addr);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L725-738)
```text
    /// Migrate to fungible store for `CoinType` if not yet.
    public entry fun migrate_coin_store_to_fungible_store<CoinType>(
        accounts: vector<address>
    ) acquires CoinStore, CoinConversionMap, CoinInfo {
        if (features::new_accounts_default_to_fa_store_enabled()
            || features::new_accounts_default_to_fa_apt_store_enabled()) {
            std::vector::for_each(
                accounts,
                |account| {
                    maybe_convert_to_fungible_store<CoinType>(account);
                }
            );
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1978-1981)
```text
    #[deprecated]
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    /// The flag the existence of which indicates the primary fungible store is created by the migration from CoinStore.
    struct MigrationFlag has key {}
```

**File:** types/src/account_config/resources/fungible_store.rs (L84-96)
```rust
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Default)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct MigrationFlag {
    // Thanks to the "feature" of 1-byte empty struct
    dummy: bool,
}

impl MoveStructType for MigrationFlag {
    const MODULE_NAME: &'static IdentStr = ident_str!("coin");
    const STRUCT_NAME: &'static IdentStr = ident_str!("MigrationFlag");
}

impl MoveResource for MigrationFlag {}
```
