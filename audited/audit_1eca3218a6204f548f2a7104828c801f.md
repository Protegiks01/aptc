# Audit Report

## Title
View Function Argument Construction DoS via Unbounded Vector Recursion in Eager Loading Mode

## Summary
The `validate_view_function()` function in the view function verifier uses `UnmeteredGasMeter` when eager loading is enabled, allowing attackers to submit deeply nested vector arguments that cause excessive CPU consumption and potential stack overflow through unbounded recursion in `recursively_construct_arg()`.

## Finding Description

The vulnerability exists in the argument construction path for view functions. When a view function is called via the REST API, the system must deserialize and construct the provided arguments. [1](#0-0) 

The critical issue occurs when lazy loading is disabled (eager loading mode). In this case, the code explicitly uses `UnmeteredGasMeter`, which provides no resource limits during argument construction.

The argument construction process calls `recursively_construct_arg()`, which processes vectors recursively: [2](#0-1) 

This function has **no depth limit** on vector nesting. It recursively processes each vector element by calling itself again. The only protection is `max_invocations` (set to 10), but this only applies to struct constructor invocations, not vector recursion: [3](#0-2) 

An attacker can exploit this by:
1. Deploying a Move module with a view function accepting deeply nested vectors (e.g., `vector<vector<vector<...>>>`)
2. Calling this view function via the REST API endpoint
3. Providing BCS-encoded arguments with extreme nesting depth (e.g., 1000+ levels)
4. When eager loading is used, each nesting level causes an unmetered recursive call
5. This results in stack exhaustion or CPU starvation

**Example Attack Payload:**
- Function signature: `public fun my_view(data: vector<vector<vector<u8>>>): u64`
- Attack payload: Nested vectors with 500+ levels, each containing 1 element
- BCS encoding size: ~500 bytes (under the 1MB limit)
- Recursive calls: 500+ unmetered function calls

This breaks the **Resource Limits** and **Move VM Safety** invariants, which require all operations to respect computational limits.

## Impact Explanation

This qualifies as **High Severity** per the Aptos bug bounty program for the following reasons:

1. **Validator Node Slowdowns**: Malicious view function calls can consume excessive CPU resources on validator nodes, degrading performance and potentially causing them to fall behind in consensus.

2. **API Crashes**: The REST API nodes processing these requests can experience:
   - Stack overflow crashes (if recursion depth exceeds stack limits)
   - CPU exhaustion leading to request timeouts
   - Service degradation affecting legitimate users

3. **Availability Impact**: While not causing permanent network partition, this can temporarily reduce network availability by:
   - Slowing down nodes processing malicious view requests
   - Creating API service outages
   - Forcing operators to restart affected nodes

The attack is particularly severe because:
- View functions are read-only and don't require transaction fees
- No gas is charged when `UnmeteredGasMeter` is used
- Attackers can repeatedly exploit this with minimal cost
- The REST API is publicly accessible

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly likely to be exploited because:

1. **Accessibility**: View functions are callable by anyone via public REST API endpoints without authentication or gas costs.

2. **Feature Flag Dependency**: The vulnerability is exploitable whenever the `ENABLE_LAZY_LOADING` feature flag is disabled. This flag is:
   - Configurable on-chain via governance
   - Can be disabled for testing, debugging, or performance reasons
   - Not guaranteed to be enabled on all nodes

3. **Simple Exploitation**: The attack requires only:
   - Deploying a Move module with a view function accepting nested vectors
   - Making REST API calls with crafted BCS-encoded arguments
   - No special permissions or resources needed

4. **Low Detection**: View function calls don't appear on-chain and may not be heavily monitored, making the attack difficult to detect until performance degradation occurs.

5. **Production Relevance**: Even if lazy loading is enabled by default in mainnet, the code path exists and represents a security risk during:
   - Network upgrades when features are toggled
   - Testing environments
   - Custom deployments

## Recommendation

Implement a **depth limit** for vector recursion in `recursively_construct_arg()`. This should be separate from the `max_invocations` counter and apply specifically to nested data structure depth.

**Recommended Fix:**

Add a `max_depth` parameter to track recursion depth and enforce a reasonable limit (e.g., 32 or 64 levels):

```rust
pub(crate) fn recursively_construct_arg(
    session: &mut SessionExt<impl AptosMoveResolver>,
    loader: &impl Loader,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    ty: &Type,
    allowed_structs: &ConstructorMap,
    cursor: &mut Cursor<&[u8]>,
    initial_cursor_len: usize,
    max_invocations: &mut u64,
    arg: &mut Vec<u8>,
    max_depth: &mut u32,  // NEW PARAMETER
) -> Result<(), VMStatus> {
    // Check depth limit
    if *max_depth == 0 {
        return Err(VMStatus::error(
            StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
            Some(String::from("Maximum nesting depth exceeded")),
        ));
    }
    *max_depth -= 1;
    
    match ty {
        Vector(inner) => {
            let mut len = get_len(cursor)?;
            serialize_uleb128(len, arg);
            while len > 0 {
                recursively_construct_arg(
                    session,
                    loader,
                    gas_meter,
                    traversal_context,
                    inner,
                    allowed_structs,
                    cursor,
                    initial_cursor_len,
                    max_invocations,
                    arg,
                    max_depth,  // Pass depth tracker
                )?;
                len -= 1;
            }
        },
        // ... rest of match arms
    }
    
    *max_depth += 1;  // Restore depth on exit
    Ok(())
}
```

Initialize `max_depth` in `construct_arg()` with a reasonable limit (e.g., 64):

```rust
let mut max_depth = 64;
recursively_construct_arg(
    session,
    loader,
    gas_meter,
    traversal_context,
    &ty,
    allowed_structs,
    cursor,
    initial_cursor_len,
    max_invocations,
    &mut arg,
    &mut max_depth,
)?;
```

**Alternative/Additional Fix:**

Even with lazy loading enabled, ensure gas metering properly accounts for argument construction complexity. Consider making argument construction always metered, regardless of loading mode.

## Proof of Concept

**Step 1: Create a Move module with a vulnerable view function**

```move
module 0xCAFE::nested_vectors {
    use std::vector;

    #[view]
    public fun process_nested(data: vector<vector<vector<u8>>>): u64 {
        // Simple view function that accepts deeply nested vectors
        vector::length(&data)
    }
}
```

**Step 2: Create BCS-encoded deeply nested vector payload**

```rust
use bcs;

fn create_nested_vector_payload(depth: usize) -> Vec<u8> {
    let mut payload = vec![0x00]; // Empty u8 vector at innermost level
    
    // Wrap in nested vectors
    for _ in 0..depth {
        // BCS encoding: vector length (1) + previous payload
        let mut wrapper = vec![0x01]; // Length = 1
        wrapper.extend_from_slice(&payload);
        payload = wrapper;
    }
    
    payload
}

// Create payload with 500 levels of nesting
let malicious_payload = create_nested_vector_payload(500);
```

**Step 3: Call view function via REST API**

```bash
curl -X POST https://fullnode.mainnet.aptoslabs.com/v1/view \
  -H "Content-Type: application/json" \
  -d '{
    "function": "0xCAFE::nested_vectors::process_nested",
    "type_arguments": [],
    "arguments": ["<base64_encoded_malicious_payload>"]
  }'
```

**Expected Result (when eager loading is enabled):**
- Node experiences high CPU usage
- Request hangs or times out
- Potential stack overflow crash
- No gas charged for the operation

**Test Environment Setup:**
1. Deploy the Move module to a test network
2. Configure a node with `ENABLE_LAZY_LOADING` feature flag disabled
3. Send requests with increasing nesting depth (100, 200, 500, 1000 levels)
4. Monitor CPU usage, memory consumption, and response times
5. Observe degradation or crash at sufficient depth

## Notes

This vulnerability demonstrates a critical oversight in resource management for view functions. While view functions are designed to be read-only and lightweight, the lack of proper recursion limits in argument construction creates an exploitable DoS vector. The issue is particularly concerning because:

1. The vulnerable code path exists regardless of production configuration
2. The `UnmeteredGasMeter` usage explicitly bypasses gas limits
3. The REST API exposure makes this trivially exploitable
4. No warning or documentation about nesting depth limits exists

Organizations running Aptos nodes should ensure the `ENABLE_LAZY_LOADING` feature flag is enabled and consider implementing additional rate limiting on view function endpoints until this issue is patched.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L64-90)
```rust
    let result = if loader.is_lazy_loading_enabled() {
        transaction_arg_validation::construct_args(
            session,
            loader,
            gas_meter,
            traversal_context,
            func.param_tys(),
            args,
            func.ty_args(),
            allowed_structs,
            true,
        )
    } else {
        let traversal_storage = TraversalStorage::new();
        transaction_arg_validation::construct_args(
            session,
            loader,
            // No metering with eager loading.
            &mut UnmeteredGasMeter,
            &mut TraversalContext::new(&traversal_storage),
            func.param_tys(),
            args,
            func.ty_args(),
            allowed_structs,
            true,
        )
    };
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L289-301)
```rust
            let mut max_invocations = 10; // Read from config in the future
            recursively_construct_arg(
                session,
                loader,
                gas_meter,
                traversal_context,
                ty,
                allowed_structs,
                &mut cursor,
                initial_cursor_len,
                &mut max_invocations,
                &mut new_arg,
            )?;
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L345-363)
```rust
        Vector(inner) => {
            // get the vector length and iterate over each element
            let mut len = get_len(cursor)?;
            serialize_uleb128(len, arg);
            while len > 0 {
                recursively_construct_arg(
                    session,
                    loader,
                    gas_meter,
                    traversal_context,
                    inner,
                    allowed_structs,
                    cursor,
                    initial_cursor_len,
                    max_invocations,
                    arg,
                )?;
                len -= 1;
            }
```
