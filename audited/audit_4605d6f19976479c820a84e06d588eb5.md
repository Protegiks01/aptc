# Audit Report

## Title
Peer Monitoring Service Fails to Distinguish Byzantine Behavior from Network Failures, Allowing Malicious Peers to Evade Detection

## Summary
The peer monitoring service client uniformly treats all `RpcError` variants as generic failures without distinguishing between legitimate network issues (timeouts, disconnections) and Byzantine behavior (invalid responses, deserialization errors). This allows malicious peers to send corrupt data while avoiding classification as Byzantine actors, polluting network topology metadata used by consensus, state sync, and mempool for peer selection.

## Finding Description

The peer monitoring service client error handling system has a critical flaw in error classification: [1](#0-0) 

All `RpcError` variants are collapsed into a single `Error::RpcError` type. The `RpcError` enum includes both legitimate network failures and malicious behaviors: [2](#0-1) 

**Critical distinction missing:**
- **Legitimate failures**: `TimedOut`, `NotConnected`, `IoError`, `UnexpectedResponseChannelCancel`, `TooManyPending`
- **Byzantine indicators**: `InvalidRpcResponse`, `BcsError`, `ApplicationError`

When errors occur, all state handlers uniformly call `handle_request_failure()` which only increments a consecutive failure counter: [3](#0-2) [4](#0-3) 

The TODO comment reveals disconnect logic is not implemented. Compare this to the state-sync data client, which properly distinguishes error types: [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. Malicious peer sends `InvalidRpcResponse` or `BcsError` responses (detected at RPC layer): [7](#0-6) 

2. Error propagates to peer monitoring client: [8](#0-7) 

3. Treated identically to legitimate timeout (no distinction made)
4. Peer occasionally sends valid responses to reset consecutive failure counter
5. Peer continues providing polluted `distance_from_validators` and latency data

**Impact on critical systems:**

The corrupted `PeerMonitoringMetadata` affects routing decisions in:

- **Consensus Observer**: Uses distance/latency for peer subscription selection
- **State Sync**: Uses distance/latency for optimal peer routing  
- **Mempool**: Uses distance/latency for transaction forwarding prioritization [9](#0-8) 

## Impact Explanation

**High Severity** per Aptos bug bounty criteria - "Significant protocol violations":

1. **Byzantine Detection Failure**: The system cannot distinguish active attacks (malformed responses) from benign network issues
2. **Routing Manipulation**: Malicious peers can provide false network topology data influencing consensus, state sync, and mempool
3. **Network Degradation**: Multiple malicious peers can degrade network performance by polluting peer selection algorithms
4. **No Mitigation**: Unlike state-sync which has peer scoring (MALICIOUS_MULTIPLIER=0.8, IGNORE_PEER_THRESHOLD=25.0), peer monitoring has no Byzantine detection or banning mechanism

This violates the invariant: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" by failing to properly identify Byzantine peers.

## Likelihood Explanation

**High Likelihood:**
- **Low Attack Complexity**: Malicious peer simply needs to send malformed RPC responses
- **No Special Access Required**: Any network peer can exploit this
- **Difficult to Detect**: Legitimate network issues provide cover for malicious behavior
- **No Defense Mechanism**: System lacks peer scoring/banning for peer monitoring service
- **High Value Target**: Peer monitoring metadata affects critical routing decisions across multiple subsystems

## Recommendation

Implement Byzantine error classification similar to state-sync data client:

1. **Add error classification to peer monitoring service:**

```rust
// In peer-monitoring-service/client/src/error.rs
pub enum ErrorType {
    /// Benign network failures (timeouts, disconnections)
    NetworkFailure,
    /// Suspicious behavior indicating Byzantine peer (invalid responses, deserialization errors)
    Byzantine,
}

impl Error {
    pub fn classify_error_type(&self) -> ErrorType {
        match self {
            Error::RpcError(rpc_error) => {
                // Parse the error string to determine type
                let error_str = rpc_error.to_string();
                if error_str.contains("InvalidRpcResponse") 
                    || error_str.contains("BcsError")
                    || error_str.contains("ApplicationError") {
                    ErrorType::Byzantine
                } else {
                    ErrorType::NetworkFailure
                }
            }
            _ => ErrorType::NetworkFailure,
        }
    }
}
```

2. **Implement peer scoring system:**

```rust
// Add to PeerState
pub struct PeerState {
    score: f64, // Start at 50.0, range 0.0-100.0
    // ... existing fields
}

impl PeerState {
    fn handle_request_failure(&mut self, error_type: ErrorType) {
        let multiplier = match error_type {
            ErrorType::NetworkFailure => 0.95,  // 5% penalty
            ErrorType::Byzantine => 0.7,        // 30% penalty
        };
        self.score = f64::max(self.score * multiplier, 0.0);
        
        // Ignore peer if score drops below threshold
        if self.score < 25.0 {
            warn!("Peer score dropped below threshold, should be ignored");
            // TODO: Actually implement peer ignoring/disconnection
        }
    }
}
```

3. **Update error handlers to use classification:**

```rust
fn handle_monitoring_service_response_error(
    &mut self,
    peer_network_id: &PeerNetworkId,
    error: Error,
) {
    let error_type = error.classify_error_type();
    self.handle_request_failure(peer_network_id, error_type);
    // ... existing logging
}
```

4. **Implement the TODO disconnect logic** referenced in latency_info.rs line 64

## Proof of Concept

```rust
#[tokio::test]
async fn test_byzantine_peer_detection() {
    // Setup peer monitoring client with mock network
    let node_config = NodeConfig::default();
    let time_service = TimeService::mock();
    let peer_network_id = PeerNetworkId::random();
    
    // Create peer state
    let mut latency_state = LatencyInfoState::new(
        node_config.peer_monitoring_service.latency_monitoring,
        time_service.clone(),
    );
    
    // Simulate Byzantine behavior: peer sends InvalidRpcResponse
    let byzantine_error = Error::RpcError(RpcError::InvalidRpcResponse);
    
    // Handle error multiple times (simulating persistent malicious behavior)
    for _ in 0..10 {
        latency_state.handle_monitoring_service_response_error(
            &peer_network_id,
            byzantine_error.clone(),
        );
    }
    
    // Current behavior: peer is NOT marked as Byzantine
    // consecutive failures counter increments but no distinction is made
    let failures = latency_state.request_tracker.read().get_num_consecutive_failures();
    assert_eq!(failures, 10);
    
    // Expected behavior: peer should be scored as Byzantine and ignored
    // But currently this does NOT happen - the vulnerability
    
    // Now send one valid response
    latency_state.record_new_latency_and_reset_failures(0, 0.1);
    
    // Failure counter resets, allowing malicious peer to continue
    let failures_after = latency_state.request_tracker.read().get_num_consecutive_failures();
    assert_eq!(failures_after, 0); // Vulnerability: Byzantine peer can reset and continue
}
```

## Notes

The vulnerability is particularly concerning because:
1. Peer monitoring metadata directly influences consensus observer subscription selection, state sync peer routing, and mempool forwarding prioritization
2. The state-sync subsystem already has proper Byzantine detection (ErrorType::Malicious with 0.8 multiplier), demonstrating the codebase understands this distinction is necessary
3. The TODO comment at line 64 of latency_info.rs explicitly acknowledges the missing disconnect logic
4. No compensating controls exist - there is no peer reputation system for the peer monitoring service

### Citations

**File:** peer-monitoring-service/client/src/error.rs (L10-23)
```rust
#[derive(Debug, Error)]
pub enum Error {
    #[error("Network error: {0}")]
    NetworkError(String),

    #[error("Error from remote monitoring service: {0}")]
    PeerMonitoringServiceError(#[from] PeerMonitoringServiceError),

    #[error("Aptos network rpc error: {0}")]
    RpcError(#[from] RpcError),

    #[error("Unexpected error encountered: {0}")]
    UnexpectedError(String),
}
```

**File:** network/framework/src/protocols/rpc/error.rs (L13-44)
```rust
#[derive(Debug, Error)]
pub enum RpcError {
    #[error("Error: {0:?}")]
    Error(#[from] anyhow::Error),

    #[error("IO error: {0}")]
    IoError(#[from] io::Error),

    #[error("Bcs error: {0:?}")]
    BcsError(#[from] bcs::Error),

    #[error("Not connected with peer: {0}")]
    NotConnected(PeerId),

    #[error("Received invalid rpc response message")]
    InvalidRpcResponse,

    #[error("Application layer unexpectedly dropped response channel")]
    UnexpectedResponseChannelCancel,

    #[error("Error in application layer handling rpc request: {0:?}")]
    ApplicationError(anyhow::Error),

    #[error("Error sending on mpsc channel, connection likely shutting down: {0:?}")]
    MpscSendError(#[from] mpsc::SendError),

    #[error("Too many pending RPCs: {0}")]
    TooManyPending(u32),

    #[error("Rpc timed out")]
    TimedOut,
}
```

**File:** peer-monitoring-service/client/src/peer_states/latency_info.rs (L59-72)
```rust
    /// Handles a ping failure for the specified peer
    fn handle_request_failure(&self, peer_network_id: &PeerNetworkId) {
        // Update the number of ping failures for the request tracker
        self.request_tracker.write().record_response_failure();

        // TODO: If the number of ping failures is too high, disconnect from the node
        let num_consecutive_failures = self.request_tracker.read().get_num_consecutive_failures();
        if num_consecutive_failures >= self.latency_monitoring_config.max_latency_ping_failures {
            warn!(LogSchema::new(LogEntry::LatencyPing)
                .event(LogEvent::TooManyPingFailures)
                .peer(peer_network_id)
                .message("Too many ping failures occurred for the peer!"));
        }
    }
```

**File:** peer-monitoring-service/client/src/peer_states/latency_info.rs (L197-211)
```rust
    fn handle_monitoring_service_response_error(
        &mut self,
        peer_network_id: &PeerNetworkId,
        error: Error,
    ) {
        // Handle the failure
        self.handle_request_failure(peer_network_id);

        // Log the error
        warn!(LogSchema::new(LogEntry::LatencyPing)
            .event(LogEvent::ResponseError)
            .message("Error encountered when pinging peer!")
            .peer(peer_network_id)
            .error(&error));
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L45-63)
```rust
pub enum ErrorType {
    /// A response or error that's not actively malicious but also doesn't help
    /// us make progress, e.g., timeouts, remote errors, invalid data, etc...
    NotUseful,
    /// A response or error that appears to be actively hindering progress or
    /// attempting to deceive us, e.g., invalid proof.
    Malicious,
}

impl From<ResponseError> for ErrorType {
    fn from(error: ResponseError) -> Self {
        match error {
            ResponseError::InvalidData | ResponseError::InvalidPayloadDataType => {
                ErrorType::NotUseful
            },
            ResponseError::ProofVerificationError => ErrorType::Malicious,
        }
    }
}
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L167-174)
```rust
    /// Updates the score of the peer according to an error
    fn update_score_error(&mut self, error: ErrorType) {
        let multiplier = match error {
            ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
            ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        };
        self.score = f64::max(self.score * multiplier, MIN_SCORE);
    }
```

**File:** network/framework/src/protocols/rpc/mod.rs (L225-228)
```rust
        let peer_id = request.sender.peer_id();
        let NetworkMessage::RpcRequest(rpc_request) = &request.message else {
            return Err(RpcError::InvalidRpcResponse);
        };
```

**File:** peer-monitoring-service/client/src/network.rs (L40-60)
```rust
    ) -> Result<PeerMonitoringServiceResponse, Error> {
        let response = self
            .network_client
            .send_to_peer_rpc(
                PeerMonitoringServiceMessage::Request(request),
                timeout,
                recipient,
            )
            .await
            .map_err(|error| Error::NetworkError(error.to_string()))?;
        match response {
            PeerMonitoringServiceMessage::Response(Ok(response)) => Ok(response),
            PeerMonitoringServiceMessage::Response(Err(err)) => {
                Err(Error::PeerMonitoringServiceError(err))
            },
            PeerMonitoringServiceMessage::Request(request) => Err(Error::NetworkError(format!(
                "Got peer monitoring request instead of response! Request: {:?}",
                request
            ))),
        }
    }
```

**File:** peer-monitoring-service/client/src/peer_states/peer_state.rs (L186-214)
```rust
    /// Extracts peer monitoring metadata from the overall peer state
    pub fn extract_peer_monitoring_metadata(&self) -> Result<PeerMonitoringMetadata, Error> {
        // Create an empty metadata entry for the peer
        let mut peer_monitoring_metadata = PeerMonitoringMetadata::default();

        // Get and store the average latency ping
        let latency_info_state = self.get_latency_info_state()?;
        let average_latency_ping_secs = latency_info_state.get_average_latency_ping_secs();
        peer_monitoring_metadata.average_ping_latency_secs = average_latency_ping_secs;

        let latest_ping_latency_secs = latency_info_state.get_latest_latency_ping_secs();
        peer_monitoring_metadata.latest_ping_latency_secs = latest_ping_latency_secs;

        // Get and store the detailed monitoring metadata
        let internal_client_state = self.get_internal_client_state()?;
        peer_monitoring_metadata.internal_client_state = internal_client_state;

        // Get and store the latest network info response
        let network_info_state = self.get_network_info_state()?;
        let network_info_response = network_info_state.get_latest_network_info_response();
        peer_monitoring_metadata.latest_network_info_response = network_info_response;

        // Get and store the latest node info response
        let node_info_state = self.get_node_info_state()?;
        let node_info_response = node_info_state.get_latest_node_info_response();
        peer_monitoring_metadata.latest_node_info_response = node_info_response;

        Ok(peer_monitoring_metadata)
    }
```
