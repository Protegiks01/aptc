# Audit Report

## Title
Unauthorized Event Emission During Transaction Prologue via Account Abstraction Custom Authentication Functions

## Summary
The native event emission functions `native_write_to_event_store()` and `native_write_module_event_to_store()` lack execution phase validation, allowing user-defined account abstraction authentication modules to emit events during the transaction prologue phase where such operations should be restricted. This violates transaction execution semantics and enables unauthorized event writes.

## Finding Description
The vulnerability exists due to three interconnected design issues:

1. **Missing Phase Validation**: The event emission native functions do not check the current execution phase (prologue/execution/epilogue) before allowing events to be written. [1](#0-0) 

The function directly pushes events to `NativeEventContext` without any validation of the session type.

2. **User Code Execution During Prologue**: Account abstraction allows custom user-defined authentication modules to execute during the prologue phase through the `dispatchable_authenticate` mechanism. [2](#0-1) 

The `validate_signed_transaction` function is called within the `PrologueSession`, and it executes custom authentication code: [3](#0-2) 

This calls user-defined Move modules via: [4](#0-3) 

3. **Event Propagation from Prologue**: Events emitted during the prologue session are included in the final transaction output without filtering. [5](#0-4) [6](#0-5) 

The events are simply concatenated when change sets are squashed, with no phase-based filtering.

**Attack Flow**:
1. Attacker deploys a malicious account abstraction authentication module that emits events in its authentication function
2. Registers this module via `add_authentication_function()`
3. Submits transactions using this custom authenticator
4. During prologue execution, the custom authentication function runs and emits events
5. These events appear in the final transaction output, bypassing normal execution phase restrictions

## Impact Explanation
This is a **High Severity** vulnerability because:

1. **Protocol Violation**: Breaks the fundamental invariant that prologue should only perform validation, not state-observable operations like event emission
2. **Indexer Confusion**: Off-chain indexers and tooling expect events only during the execution phase, potentially causing data corruption or incorrect state tracking
3. **Event Semantics Violation**: Events emitted during prologue could appear to originate from system operations, potentially misleading users and applications
4. **Deterministic Execution Risk**: If different validators have different views of when events should be emitted, this could theoretically lead to consensus divergence in edge cases

While this doesn't directly lead to fund theft, it represents a significant protocol violation that could have cascading effects on the ecosystem.

## Likelihood Explanation
**Likelihood: Medium-High**

- Account abstraction is an actively used feature in Aptos
- Any user can deploy and register custom authentication modules
- The vulnerability is inherent in the design - no special conditions needed
- Exploitation requires only Move programming knowledge
- Impact is immediate and affects all transactions using the malicious authenticator

## Recommendation
Implement execution phase tracking and validation in the event emission native functions:

1. **Add Phase Tracking**: Extend `NativeTransactionContext` or create a new context extension to track the current execution phase
2. **Add Phase Validation**: Modify `native_write_to_event_store()` and `native_write_module_event_to_store()` to check the execution phase:

```rust
fn native_write_to_event_store(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // Get execution phase from context
    let session_phase = context.extensions().get::<SessionPhaseContext>();
    
    // Disallow event emission during prologue
    if matches!(session_phase.current_phase(), ExecutionPhase::Prologue) {
        return Err(SafeNativeError::Abort {
            abort_code: error::invalid_state(EEVENT_EMISSION_NOT_ALLOWED_IN_PROLOGUE),
        });
    }
    
    // Optionally: restrict epilogue emissions to system addresses only
    if matches!(session_phase.current_phase(), ExecutionPhase::Epilogue) {
        // Allow only system addresses like @aptos_framework
        // to emit events during epilogue
    }
    
    // ... rest of implementation
}
```

3. **Update Session Creation**: Ensure all session types (Prologue, User, Epilogue) properly set the phase in their respective contexts

## Proof of Concept

```move
// malicious_auth.move
module malicious_user::evil_authenticator {
    use aptos_framework::event;
    use std::signer;
    
    #[event]
    struct PrologueEvent has drop, store {
        message: vector<u8>,
        timestamp: u64,
    }
    
    // Custom authentication function that emits events during prologue
    public fun authenticate(
        account: signer,
        _auth_data: vector<u8>
    ): signer {
        // This event emission happens during PROLOGUE phase!
        event::emit(PrologueEvent {
            message: b"Unauthorized event from prologue!",
            timestamp: 12345,
        });
        
        // Return the signer to complete authentication
        account
    }
}

// Steps to exploit:
// 1. Deploy the module above
// 2. Call: aptos_framework::account_abstraction::add_authentication_function(
//       account,
//       @malicious_user,
//       string::utf8(b"evil_authenticator"),
//       string::utf8(b"authenticate")
//    )
// 3. Submit any transaction with AbstractAuthenticator using this function
// 4. Observe that PrologueEvent appears in transaction output despite being emitted during prologue
```

**Notes**:
- The system itself emits `FeeStatement` events during epilogue, but this is intended system behavior
- User code should NOT be able to emit events during prologue
- The vulnerability specifically affects account abstraction custom authentication modules
- Current implementation provides no mechanism to distinguish or restrict event emission based on execution phase

### Citations

**File:** aptos-move/framework/src/natives/event.rs (L102-151)
```rust
fn native_write_to_event_store(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.len() == 3);

    let ty = &ty_args[0];
    let msg = arguments.pop_back().unwrap();
    let seq_num = safely_pop_arg!(arguments, u64);
    let guid = safely_pop_arg!(arguments, Vec<u8>);

    // TODO(Gas): Get rid of abstract memory size
    context.charge(
        EVENT_WRITE_TO_EVENT_STORE_BASE
            + EVENT_WRITE_TO_EVENT_STORE_PER_ABSTRACT_VALUE_UNIT * context.abs_val_size(&msg)?,
    )?;
    let ty_tag = context.type_to_type_tag(ty)?;
    let (layout, contains_delayed_fields) = context
        .type_to_type_layout_with_delayed_fields(ty)?
        .unpack();

    let function_value_extension = context.function_value_extension();
    let max_value_nest_depth = context.max_value_nest_depth();
    let blob = ValueSerDeContext::new(max_value_nest_depth)
        .with_delayed_fields_serde()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&msg, &layout)?
        .ok_or_else(|| {
            SafeNativeError::InvariantViolation(PartialVMError::new(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            ))
        })?;
    let key = bcs::from_bytes(guid.as_slice()).map_err(|_| {
        SafeNativeError::InvariantViolation(PartialVMError::new(StatusCode::EVENT_KEY_MISMATCH))
    })?;

    let ctx = context.extensions_mut().get_mut::<NativeEventContext>();
    let event =
        ContractEvent::new_v1(key, seq_num, ty_tag, blob).map_err(|_| SafeNativeError::Abort {
            abort_code: ECANNOT_CREATE_EVENT,
        })?;
    // TODO(layouts): avoid cloning layouts for events with delayed fields.
    ctx.events.push((
        event,
        contains_delayed_fields.then(|| layout.as_ref().clone()),
    ));
    Ok(smallvec![])
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1845-1860)
```rust
                        dispatchable_authenticate(
                            session,
                            gas_meter,
                            fee_payer,
                            function_info.clone(),
                            auth_data,
                            traversal_context,
                            module_storage,
                        )
                        .map_err(|mut vm_error| {
                            if vm_error.major_status() == OUT_OF_GAS {
                                vm_error
                                    .set_major_status(ACCOUNT_AUTHENTICATION_GAS_LIMIT_EXCEEDED);
                            }
                            vm_error.into_vm_status()
                        })
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1999-2012)
```rust
        let mut prologue_session = PrologueSession::new(self, &txn_data, resolver);
        let initial_gas = gas_meter.balance();
        let serialized_signers = unwrap_or_discard!(prologue_session.execute(|session| {
            self.validate_signed_transaction(
                session,
                code_storage,
                txn,
                &txn_data,
                log_context,
                is_approved_gov_script,
                &mut traversal_context,
                gas_meter,
            )
        }));
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3415-3424)
```rust
    session
        .execute_function_bypass_visibility(
            &ACCOUNT_ABSTRACTION_MODULE,
            AUTHENTICATE,
            vec![],
            params,
            gas_meter,
            traversal_context,
            module_storage,
        )
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L230-231)
```rust
        let event_context: NativeEventContext = extensions.remove();
        let events = event_context.legacy_into_events();
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L765-765)
```rust
        self.events.extend(additional_events);
```
