# Audit Report

## Title
NIL Block Creation Bypasses Failed Proposer Tracking When max_failed_authors_to_store is Zero

## Summary
When `max_failed_authors_to_store` is configured to 0 via on-chain governance, NIL blocks are created with an empty `failed_authors` vector even though they should contain the current round's failed proposer. This breaks the leader reputation mechanism, causing failed proposers to avoid accountability and remain eligible for frequent leader selection despite poor performance.

## Finding Description
The vulnerability exists in the NIL block generation logic. When a validator times out waiting for a proposal, it generates a NIL block to maintain consensus progress. [1](#0-0) 

The NIL block creation calls `compute_failed_authors` with `include_cur_round=true` to track which proposers failed. [2](#0-1) 

However, when `max_failed_authors_to_store` is set to 0, the loop in `compute_failed_authors` becomes empty:
- `end_round = round + 1` (current round + 1)
- `start = max(previous_round + 1, round + 1 - 0) = round + 1`
- Loop `for i in start..end_round` iterates over `round+1..round+1`, which is empty

This results in an empty `failed_authors` vector, even though the NIL block is generated precisely because the designated proposer for that round failed to propose.

The `max_failed_authors_to_store` configuration has no validation preventing it from being set to 0. [3](#0-2) 

**Impact on Leader Reputation**: The empty `failed_authors` is converted to empty `failed_proposer_indices` in block metadata. [4](#0-3) 

The leader reputation system reads these indices to count failed proposals. [5](#0-4) 

With empty indices, failed proposers are not penalized in reputation calculations, allowing underperforming validators to maintain high reputation scores and be selected as leaders more frequently than they should.

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Specific Impacts**:
1. **Leader Reputation Manipulation**: Failed proposers avoid accountability, corrupting the proposer election fairness mechanism
2. **Consensus Performance Degradation**: Underperforming validators are repeatedly selected as leaders, causing more timeouts and reducing network throughput
3. **Potential Liveness Issues**: In scenarios with multiple underperforming validators, the network may experience increased round delays
4. **Governance Trust Violation**: The configuration appears valid but silently breaks a critical consensus subsystem

This does not directly cause funds loss, consensus safety violations, or network partition, so it does not meet Critical or High severity thresholds.

## Likelihood Explanation
**Likelihood: Medium**

The vulnerability requires:
1. A governance proposal to set `max_failed_authors_to_store` to 0
2. The proposal must pass (requires stake voting)
3. No validation prevents this configuration

**Scenarios**:
- **Malicious governance**: An attacker with governance influence could intentionally set this to disable failed proposer tracking
- **Accidental misconfiguration**: An operator might set it to 0 thinking it disables the feature, not realizing it breaks the mechanism
- **Testing gone wrong**: A test configuration could accidentally be deployed to mainnet

The default value is 10, so explicit action is required. However, once set to 0, the vulnerability automatically affects all subsequent NIL blocks without requiring any additional attacker action.

## Recommendation
Add validation to prevent `max_failed_authors_to_store` from being set to 0. The minimum valid value should be 1.

**Fix in `consensus/src/liveness/proposal_generator.rs`**:

Add a validation check in the `compute_failed_authors` function:
```rust
pub fn compute_failed_authors(
    &self,
    round: Round,
    previous_round: Round,
    include_cur_round: bool,
    proposer_election: Arc<dyn ProposerElection>,
) -> Vec<(Round, Author)> {
    // Ensure we can track at least the current round's failure
    if include_cur_round && self.max_failed_authors_to_store == 0 {
        error!("max_failed_authors_to_store is 0, cannot track failed proposers");
        // Return at least the current round's failed proposer
        return vec![(round, proposer_election.get_valid_proposer(round))];
    }
    
    let end_round = round + u64::from(include_cur_round);
    let mut failed_authors = Vec::new();
    let start = std::cmp::max(
        previous_round + 1,
        end_round.saturating_sub(self.max_failed_authors_to_store as u64),
    );
    for i in start..end_round {
        failed_authors.push((i, proposer_election.get_valid_proposer(i)));
    }
    failed_authors
}
```

**Better fix in `types/src/on_chain_config/consensus_config.rs`**:

Add validation when deserializing the config:
```rust
impl ConsensusConfigV1 {
    pub fn validate(&self) -> Result<()> {
        ensure!(
            self.max_failed_authors_to_store > 0,
            "max_failed_authors_to_store must be at least 1 to track failed proposers"
        );
        Ok(())
    }
}
```

## Proof of Concept
```rust
#[test]
fn test_nil_block_empty_failed_authors_when_max_is_zero() {
    use consensus::liveness::proposal_generator::ProposalGenerator;
    use consensus_types::block::Block;
    use consensus_types::common::Round;
    
    // Setup: Create ProposalGenerator with max_failed_authors_to_store = 0
    let proposal_generator = ProposalGenerator::new(
        /* ... other params ... */
        0, // max_failed_authors_to_store = 0
        /* ... other params ... */
    );
    
    // Scenario: Validator times out at round 10
    let current_round: Round = 10;
    let previous_round: Round = 9;
    
    // Generate NIL block
    let nil_block = proposal_generator
        .generate_nil_block(current_round, proposer_election.clone())
        .unwrap();
    
    // Vulnerability: failed_authors should contain (10, proposer_for_round_10)
    // but is actually empty
    assert_eq!(nil_block.block_data().failed_authors(), Some(&vec![]));
    
    // Expected behavior: Should contain the failed proposer
    let expected_failed_proposer = proposer_election.get_valid_proposer(current_round);
    let expected = vec![(current_round, expected_failed_proposer)];
    
    // This assertion fails, demonstrating the bug
    assert_ne!(nil_block.block_data().failed_authors(), Some(&expected));
    
    // Impact: Block metadata will have empty failed_proposer_indices
    let validators = epoch_state.verifier.get_ordered_account_addresses();
    let metadata = nil_block.new_metadata(&validators);
    assert_eq!(metadata.failed_proposer_indices(), &vec![]);
    // The failed proposer escapes accountability
}
```

## Notes
- The vulnerability is triggered automatically once `max_failed_authors_to_store` is set to 0 through governance
- Regular proposals are validated for correct `failed_authors` lists, but locally-generated NIL blocks bypass this validation [6](#0-5) 
- The issue affects leader reputation calculations used for proposer election [5](#0-4) 
- NIL blocks are local constructs generated during timeouts and do not propagate as proposals over the network [7](#0-6)

### Citations

**File:** consensus/src/liveness/proposal_generator.rs (L462-476)
```rust
    pub fn generate_nil_block(
        &self,
        round: Round,
        proposer_election: Arc<dyn ProposerElection>,
    ) -> anyhow::Result<Block> {
        let hqc = self.ensure_highest_quorum_cert(round)?;
        let quorum_cert = hqc.as_ref().clone();
        let failed_authors = self.compute_failed_authors(
            round, // to include current round, as that is what failed
            quorum_cert.certified_block().round(),
            true,
            proposer_election,
        );
        Ok(Block::new_nil(round, quorum_cert, failed_authors))
    }
```

**File:** consensus/src/liveness/proposal_generator.rs (L884-902)
```rust
    pub fn compute_failed_authors(
        &self,
        round: Round,
        previous_round: Round,
        include_cur_round: bool,
        proposer_election: Arc<dyn ProposerElection>,
    ) -> Vec<(Round, Author)> {
        let end_round = round + u64::from(include_cur_round);
        let mut failed_authors = Vec::new();
        let start = std::cmp::max(
            previous_round + 1,
            end_round.saturating_sub(self.max_failed_authors_to_store as u64),
        );
        for i in start..end_round {
            failed_authors.push((i, proposer_election.get_valid_proposer(i)));
        }

        failed_authors
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L471-488)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub struct ConsensusConfigV1 {
    pub decoupled_execution: bool,
    // Deprecated and unused, cannot be renamed easily, due to yaml on framework_upgrade test
    pub back_pressure_limit: u64,
    pub exclude_round: u64,
    pub proposer_election_type: ProposerElectionType,
    pub max_failed_authors_to_store: usize,
}

impl Default for ConsensusConfigV1 {
    fn default() -> Self {
        Self {
            decoupled_execution: true,
            back_pressure_limit: 10,
            exclude_round: 40,
            max_failed_authors_to_store: 10,
            proposer_election_type: ProposerElectionType::LeaderReputation(
```

**File:** consensus/consensus-types/src/block.rs (L619-638)
```rust
    fn failed_authors_to_indices(
        validators: &[AccountAddress],
        failed_authors: &[(Round, Author)],
    ) -> Vec<u32> {
        failed_authors
            .iter()
            .map(|(_round, failed_author)| {
                validators
                    .iter()
                    .position(|&v| v == *failed_author)
                    .unwrap_or_else(|| {
                        panic!(
                            "Failed author {} not in validator list {:?}",
                            *failed_author, validators
                        )
                    })
            })
            .map(|index| u32::try_from(index).expect("Index is out of bounds for u32"))
            .collect()
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L428-450)
```rust
    pub fn count_failed_proposals(
        &self,
        epoch_to_candidates: &HashMap<u64, Vec<Author>>,
        history: &[NewBlockEvent],
    ) -> HashMap<Author, u32> {
        Self::history_iter(
            history,
            epoch_to_candidates,
            self.proposer_window_size,
            self.reputation_window_from_stale_end,
        )
        .fold(HashMap::new(), |mut map, meta| {
            match Self::indices_to_validators(
                &epoch_to_candidates[&meta.epoch()],
                meta.failed_proposer_indices(),
            ) {
                Ok(failed_proposers) => {
                    for &failed_proposer in failed_proposers {
                        let count = map.entry(failed_proposer).or_insert(0);
                        *count += 1;
                    }
                },
                Err(msg) => {
```

**File:** consensus/src/round_manager.rs (L1051-1060)
```rust
                    let nil_block = self
                        .proposal_generator
                        .generate_nil_block(round, self.proposer_election.clone())?;
                    info!(
                        self.new_log(LogEvent::VoteNIL),
                        "Planning to vote for a NIL block {}", nil_block
                    );
                    counters::VOTE_NIL_COUNT.inc();
                    let nil_vote = self.vote_block(nil_block).await?;
                    (true, nil_vote)
```

**File:** consensus/src/round_manager.rs (L1216-1231)
```rust
        if !proposal.is_opt_block() {
            // Validate that failed_authors list is correctly specified in the block.
            let expected_failed_authors = self.proposal_generator.compute_failed_authors(
                proposal.round(),
                proposal.quorum_cert().certified_block().round(),
                false,
                self.proposer_election.clone(),
            );
            ensure!(
                proposal.block_data().failed_authors().is_some_and(|failed_authors| *failed_authors == expected_failed_authors),
                "[RoundManager] Proposal for block {} has invalid failed_authors list {:?}, expected {:?}",
                proposal.round(),
                proposal.block_data().failed_authors(),
                expected_failed_authors,
            );
        }
```
