# Audit Report

## Title
Unbounded Request Body Processing in Aptos Faucet Allows Memory Exhaustion DoS Attack

## Summary
The Aptos Faucet server lacks request body size limits, allowing attackers to exhaust server memory by sending gigabyte-sized POST requests. Unlike the main Aptos API which enforces an 8 MB limit via `PostSizeLimit` middleware, the faucet accepts unbounded request bodies that are fully buffered in memory before processing.

## Finding Description

The `ServerConfig` struct contains only basic server configuration (listen address, port, API path) without any request body size limit fields: [1](#0-0) 

The main Aptos API properly implements request size limits using the `PostSizeLimit` middleware with a default 8 MB limit: [2](#0-1) [3](#0-2) 

However, the faucet server initialization applies only CORS and logging middleware without any size limit protection: [4](#0-3) 

The faucet endpoints accept JSON payloads via `Json<FundRequest>` without size validation: [5](#0-4) 

**Attack Path:**
1. Attacker sends POST request to `/fund`, `/is_eligible`, or `/mint` endpoint
2. Request includes `Content-Length: 1073741824` (1 GB) header
3. Attacker streams 1 GB of JSON data (e.g., padding fields with massive strings)
4. Poem framework buffers entire request body in memory before deserialization
5. Multiple concurrent requests (bypassing `max_concurrent_requests` which only limits count, not size) exhaust available memory
6. Faucet process crashes with OOM or becomes unresponsive
7. Legitimate users cannot receive test funds, disrupting Aptos network onboarding

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program:
- **API crashes**: The faucet API crashes or becomes unresponsive due to memory exhaustion
- **Service unavailability**: New users cannot obtain test funds to interact with testnet/devnet
- **Infrastructure impact**: If the faucet shares resources with other services, it can affect broader infrastructure

The main API includes tests explicitly verifying that oversized payloads are rejected with HTTP 413: [6](#0-5) 

This demonstrates the Aptos team's awareness of unbounded request processing risks, yet the same protection is missing from the faucet.

## Likelihood Explanation

**Likelihood: High**
- The faucet is a publicly accessible service requiring no authentication for basic requests
- Attack is trivial to execute using standard HTTP clients (curl, Python requests, etc.)
- No rate limiting on request size, only on concurrent request count
- Attacker needs minimal resources (single machine can send large requests)
- Low technical barrier to exploitation

## Recommendation

Add the `PostSizeLimit` middleware to the faucet server with a reasonable size limit (e.g., 1 MB, which is far more than needed for legitimate `FundRequest` payloads).

**Recommended Fix:**

1. Add a `max_request_body_size` field to `ServerConfig`:
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ServerConfig {
    pub listen_address: String,
    pub listen_port: u16,
    pub api_path_base: String,
    
    /// Maximum POST request body size in bytes (default: 1 MB)
    #[serde(default = "ServerConfig::default_max_request_body_size")]
    pub max_request_body_size: u64,
}

impl ServerConfig {
    fn default_max_request_body_size() -> u64 {
        1024 * 1024 // 1 MB
    }
}
```

2. Import and apply the `PostSizeLimit` middleware in `run.rs`:
```rust
use crate::middleware::PostSizeLimit; // Add to api crate and import

let api_server_future = Server::new_with_acceptor(TcpAcceptor::from_tokio(listener)?).run(
    Route::new()
        .nest(/* ... */)
        .with(cors)
        .with(PostSizeLimit::new(self.server_config.max_request_body_size))
        .around(middleware_log),
);
```

Alternatively, reuse the existing `PostSizeLimit` implementation from the main API crate.

## Proof of Concept

```rust
// PoC: Send oversized request to faucet
use reqwest;
use serde_json::json;

#[tokio::test]
async fn test_faucet_memory_exhaustion() {
    let faucet_url = "http://localhost:10212/fund";
    
    // Create a 100 MB JSON payload (legitimate FundRequest is ~100 bytes)
    let large_payload = json!({
        "address": "0x1".to_string() + &"a".repeat(100_000_000),
        "amount": 1000
    });
    
    // Send multiple concurrent requests
    let mut handles = vec![];
    for _ in 0..10 {
        let payload = large_payload.clone();
        let handle = tokio::spawn(async move {
            let client = reqwest::Client::new();
            client.post(faucet_url)
                .json(&payload)
                .send()
                .await
        });
        handles.push(handle);
    }
    
    // These requests will cause memory exhaustion
    // Expected: Server should reject with 413 PayloadTooLarge
    // Actual: Server attempts to buffer all requests, exhausts memory
    for handle in handles {
        let _ = handle.await;
    }
}
```

**Notes:**
- The `max_concurrent_requests` semaphore only limits the number of concurrent requests, not their cumulative memory footprint
- A single 1 GB request or ten 100 MB requests can exhaust typical server memory allocations
- The poem framework's JSON deserialization reads the entire request body into memory before parsing, making this vulnerability exploitable even with `Content-Length` validation alone (the existing `PostSizeLimit` checks `Content-Length` before buffering)

### Citations

**File:** crates/aptos-faucet/core/src/server/server_args.rs (L6-19)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ServerConfig {
    /// What address to listen on, e.g. localhost / 0.0.0.0
    #[serde(default = "ServerConfig::default_listen_address")]
    pub listen_address: String,

    /// What port to listen on.
    #[serde(default = "ServerConfig::default_listen_port")]
    pub listen_port: u16,

    /// API path base. e.g. "/v1"
    #[serde(default = "ServerConfig::default_api_path_base")]
    pub api_path_base: String,
}
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** api/src/runtime.rs (L255-255)
```rust
            .with(PostSizeLimit::new(size_limit))
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L207-220)
```rust
        let api_server_future = Server::new_with_acceptor(TcpAcceptor::from_tokio(listener)?).run(
            Route::new()
                .nest(
                    &self.server_config.api_path_base,
                    Route::new()
                        .nest("", api_service)
                        .catch_all_error(convert_error),
                )
                .at("/spec.json", spec_json)
                .at("/spec.yaml", spec_yaml)
                .at("/mint", poem::post(mint.data(fund_api_components)))
                .with(cors)
                .around(middleware_log),
        );
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L102-119)
```rust
    async fn fund(
        &self,
        fund_request: Json<FundRequest>,
        asset: poem_openapi::param::Query<Option<String>>,
        // This automagically uses FromRequest to get this data from the request.
        // It takes into things like X-Forwarded-IP and X-Real-IP.
        source_ip: RealIp,
        // Same thing, this uses FromRequest.
        header_map: &HeaderMap,
    ) -> poem::Result<Json<FundResponse>, AptosTapErrorResponse> {
        let txns = self
            .components
            .fund_inner(fund_request.0, source_ip, header_map, false, asset.0)
            .await?;
        Ok(Json(FundResponse {
            txn_hashes: get_hashes(&txns),
        }))
    }
```

**File:** api/src/tests/transactions_test.rs (L2015-2026)
```rust
async fn test_submit_transaction_rejects_payload_too_large_bcs_txn_body() {
    let mut context = new_test_context(current_function_name!());

    let resp = context
        .expect_status_code(413)
        .post_bcs_txn(
            "/transactions",
            gen_string(context.context.content_length_limit() + 1).as_bytes(),
        )
        .await;
    context.check_golden_output(resp);
}
```
