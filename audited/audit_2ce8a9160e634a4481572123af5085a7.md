# Audit Report

## Title
Validator Set Tampering via Malicious Backup Service with Compromised Keys Allows Consensus Divergence

## Summary
The epoch-ending backup restore process accepts validator set modifications from potentially malicious backup services when validator keys are compromised, allowing restored nodes to diverge from the legitimate network consensus. The optional nature of trusted waypoints creates a critical security gap where operators may unknowingly restore fraudulent validator sets.

## Finding Description

The vulnerability exists in the epoch-ending ledger info restore mechanism. When restoring from backups, the system verifies epoch-ending ledger infos through a chain of cryptographic signatures, where each epoch's ledger info is signed by the previous epoch's validators. [1](#0-0) 

The `get_epoch_ending_ledger_infos()` function fetches epoch-ending ledger infos from a backup service without any cryptographic verification at the client level. The verification happens later during the restore process: [2](#0-1) 

The verification logic checks signatures using the previous epoch's validator set via `EpochState::verify()`: [3](#0-2) 

**Attack Scenario:**

1. **Prerequisites**: Attacker has compromised validator private keys from epoch N and controls (or can intercept) the backup service
2. **Tampering**: Attacker modifies epoch N's ending LedgerInfo to replace `next_epoch_state` with a malicious validator set for epoch N+1
3. **Re-signing**: Attacker re-signs the modified LedgerInfo using compromised keys from epoch N validators
4. **Manifest Update**: Attacker updates the backup manifest waypoints to match: [4](#0-3) 

5. **Propagation**: Attacker creates a consistent fraudulent chain for subsequent epochs using the malicious validator set

**Why Verification Fails:**

The only protection against this attack is trusted waypoints, which are **optional**: [5](#0-4) 

During restoration, the system only checks trusted waypoints if they are provided: [6](#0-5) 

If no trusted waypoint exists for a version, the code falls back to signature verification, which passes because the attacker used legitimate (but compromised) keys. The manifest waypoint check also passes because the attacker controls both the ledger info and the manifest.

## Impact Explanation

**Critical Severity** per Aptos bug bounty criteria:

1. **Consensus Safety Violation**: Restored nodes accept blocks from unauthorized validators, breaking the fundamental consensus invariant that only legitimate validator sets can produce valid blocks

2. **Non-Recoverable Network Partition**: Restored nodes diverge from the legitimate network and cannot automatically recover without manual intervention and re-restoration from trusted sources

3. **Potential Loss of Funds**: If multiple nodes are compromised through this mechanism, attackers controlling the fraudulent validator sets could potentially cause double-spending or other fund loss scenarios

4. **Byzantine Fault Tolerance Bypass**: The attack circumvents the < 1/3 Byzantine fault tolerance guarantees by introducing unauthorized validators into restored nodes' validator sets

The vulnerability directly violates Critical Invariant #2 (Consensus Safety) and enables attacks that meet the "Consensus/Safety violations" and "Non-recoverable network partition" criteria for Critical severity.

## Likelihood Explanation

**Moderate to High Likelihood:**

**Prerequisites:**
- Validator key compromise (explicitly within scope of the security question)
- Malicious or compromised backup service (realistic for insider threats or supply chain attacks)
- Operator performing restore without comprehensive trusted waypoints (common operational practice)

**Realistic Scenarios:**
1. **Insider Threat**: Malicious validator operator with access to historical keys compromises their own backup service
2. **Supply Chain Attack**: Third-party backup service provider is compromised
3. **Infrastructure Breach**: Attacker gains access to validator infrastructure and exfiltrates keys over time

**Operational Reality:**
- Documentation presents trusted waypoints as optional features for "compatibility confirmation" rather than mandatory security requirements
- Operators may only provide waypoints for genesis and recent epochs, leaving historical epochs vulnerable
- No system warnings or requirements enforce comprehensive waypoint usage

## Recommendation

**Mandatory Verification Requirement:**

Implement a security policy that requires either:
1. Trusted waypoints for all epoch boundaries being restored, OR
2. Out-of-band verification against known-good chain state

**Code Changes:**

Modify the restore controller to enforce waypoint requirements:

```rust
// In restore.rs, add validation in preheat_impl
async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
    let manifest: EpochEndingBackup = 
        self.storage.load_json_file(&self.manifest_handle).await?;
    manifest.verify()?;
    
    // NEW: Enforce waypoint policy
    let requires_comprehensive_waypoints = 
        self.trusted_waypoints.is_empty() || 
        self.has_gaps_in_waypoints(&manifest);
    
    if requires_comprehensive_waypoints {
        return Err(anyhow!(
            "Security policy requires trusted waypoints for all epochs in range [{}, {}]. \
            Please provide --trust-waypoint for critical epoch boundaries to prevent \
            validator set tampering attacks.",
            manifest.first_epoch,
            manifest.last_epoch
        ));
    }
    
    // ... rest of existing logic
}
```

**Documentation Updates:**

Update the CLI help text to emphasize security requirements:

```rust
#[clap(
    long,
    help = "REQUIRED FOR SECURITY: Trusted waypoints for epoch boundaries. \
    Without comprehensive waypoints, malicious backup services with compromised \
    validator keys can modify validator sets. Minimum required: genesis waypoint \
    and waypoints for all epochs with validator set changes."
)]
pub trust_waypoint: Vec<Waypoint>,
```

**Additional Safeguards:**
- Implement automatic waypoint fetching from multiple trusted sources (e.g., multiple RPC endpoints)
- Add restore-time warnings when gaps exist in trusted waypoint coverage
- Provide tooling to generate complete waypoint sets from trusted full nodes

## Proof of Concept

```rust
#[cfg(test)]
mod validator_set_tampering_test {
    use super::*;
    use aptos_crypto::ed25519::Ed25519PrivateKey;
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        validator_verifier::{ValidatorVerifier, ValidatorConsensusInfo},
        validator_signer::ValidatorSigner,
        epoch_state::EpochState,
    };
    
    #[test]
    fn test_tampered_validator_set_accepted_without_waypoints() {
        // Setup: Create legitimate epoch 0 validator set
        let legitimate_validators: Vec<ValidatorSigner> = (0..4)
            .map(|i| ValidatorSigner::random([i; 32]))
            .collect();
        
        let mut validator_infos = vec![];
        for v in &legitimate_validators {
            validator_infos.push(ValidatorConsensusInfo::new(
                v.author(),
                v.public_key(),
                1,
            ));
        }
        let epoch0_verifier = ValidatorVerifier::new(validator_infos.clone());
        
        // Create epoch 0 ending ledger info with LEGITIMATE epoch 1 validator set
        let legitimate_epoch1_state = EpochState::new(1, epoch0_verifier.clone());
        let epoch0_block_info = BlockInfo::new(
            0, 100, HashValue::random(), HashValue::random(),
            999, 1000000, Some(legitimate_epoch1_state.clone())
        );
        let epoch0_ledger_info = LedgerInfo::new(epoch0_block_info, HashValue::zero());
        
        // Attacker scenario: Modify to malicious validator set
        let malicious_validators: Vec<ValidatorSigner> = (10..14)
            .map(|i| ValidatorSigner::random([i; 32]))
            .collect();
        
        let mut malicious_validator_infos = vec![];
        for v in &malicious_validators {
            malicious_validator_infos.push(ValidatorConsensusInfo::new(
                v.author(),
                v.public_key(),
                1,
            ));
        }
        let malicious_epoch1_verifier = ValidatorVerifier::new(malicious_validator_infos);
        let malicious_epoch1_state = EpochState::new(1, malicious_epoch1_verifier);
        
        // Create tampered ledger info with MALICIOUS validator set
        let tampered_block_info = BlockInfo::new(
            0, 100, HashValue::random(), HashValue::random(),
            999, 1000000, Some(malicious_epoch1_state)
        );
        let tampered_ledger_info = LedgerInfo::new(tampered_block_info, HashValue::zero());
        
        // Re-sign with compromised keys (simulating key compromise)
        let tampered_signed = generate_ledger_info_with_sig(
            &legitimate_validators[..3], // 3 of 4 validators
            tampered_ledger_info.clone()
        );
        
        // Verify that signatures are valid (they should be - attacker used real keys)
        assert!(epoch0_verifier.verify_multi_signatures(
            &tampered_ledger_info,
            tampered_signed.signatures()
        ).is_ok());
        
        // This demonstrates the vulnerability: The tampered ledger info with 
        // malicious validator set passes signature verification because
        // compromised keys were used, and without trusted waypoints,
        // the restore process would accept this fraudulent validator set.
        
        // In a real restore scenario without trusted waypoints, this would
        // cause the restored node to accept blocks from the malicious validators.
    }
}
```

**Notes:**

The vulnerability requires the specific confluence of compromised validator keys and malicious backup infrastructure, which may seem like a high bar. However, given:

1. The long-lived nature of blockchain systems (years of historical epochs)
2. The accumulation of old validator keys that may have reduced security
3. The reliance on third-party backup services in production deployments
4. The critical nature of consensus integrity

This represents a significant attack surface that violates the fundamental security model of the blockchain. The optional nature of trusted waypoints transforms what should be a defense-in-depth measure into a critical single point of failure.

### Citations

**File:** storage/backup/backup-cli/src/utils/backup_service_client.rs (L135-145)
```rust
    pub async fn get_epoch_ending_ledger_infos(
        &self,
        start_epoch: u64,
        end_epoch: u64,
    ) -> Result<impl AsyncRead + use<>> {
        self.get(
            "epoch_ending_ledger_infos",
            &format!("{}/{}", start_epoch, end_epoch),
        )
        .await
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** types/src/waypoint.rs (L129-148)
```rust
#[derive(Deserialize, Serialize, CryptoHasher, BCSCryptoHash)]
struct Ledger2WaypointConverter {
    epoch: u64,
    root_hash: HashValue,
    version: Version,
    timestamp_usecs: u64,
    next_epoch_state: Option<EpochState>,
}

impl Ledger2WaypointConverter {
    pub fn new(ledger_info: &LedgerInfo) -> Self {
        Self {
            epoch: ledger_info.epoch(),
            root_hash: ledger_info.transaction_accumulator_hash(),
            version: ledger_info.version(),
            timestamp_usecs: ledger_info.timestamp_usecs(),
            next_epoch_state: ledger_info.next_epoch_state().cloned(),
        }
    }
}
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```
