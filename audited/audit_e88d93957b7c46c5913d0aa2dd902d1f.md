# Audit Report

## Title
Missing Encryption Key Validation in Batch Threshold Encryption Allows Threshold Security Bypass

## Summary
The `encrypt()` function in the batch threshold encryption module does not validate that the `EncryptionKey` is properly formed with valid elliptic curve points. An attacker who can control the encryption key distribution could provide a malformed key (e.g., identity element or attacker-controlled key) that bypasses threshold decryption requirements, allowing single-party decryption of what should be threshold-protected data.

## Finding Description

The batch threshold encryption scheme is used in Aptos consensus for secret sharing across validators. The encryption process accepts an `EncryptionKey` containing two G2 elliptic curve points (`sig_mpk_g2` and `tau_g2`) but performs no validation on these values. [1](#0-0) 

The `bibe_encrypt` function directly uses `self.sig_mpk_g2` and `self.tau_g2` without checking if they are:
1. Valid non-identity group elements
2. In the correct prime-order subgroup
3. Corresponding to a legitimate threshold setup

**Attack Scenario:**

If an attacker can manipulate the encryption key distribution (via man-in-the-middle attack during epoch setup, compromised key distribution channel, or API misuse), they could:

1. Provide `sig_mpk_g2 = identity` (point at infinity), causing the encryption to use degraded cryptographic parameters where the one-time pad is derived from `pairing(hash(identity), identity)`, resulting in predictable or zero OTP values.

2. Provide `sig_mpk_g2 = G2 * attacker_msk` where they know `attacker_msk`, allowing them to compute decryption keys directly as `(digest + hash(sig_mpk_g2)) * attacker_msk` without needing threshold shares.

The setup function creates the encryption key but only validates master secret key shares against verification keys, not the encryption key itself: [2](#0-1) 

The encryption key constructor performs no validation: [3](#0-2) 

## Impact Explanation

**Severity Assessment: Medium to High**

This vulnerability breaks the **Cryptographic Correctness** invariant (#10) by potentially allowing bypass of threshold security guarantees. However, the practical impact is limited by the attack requirements:

- **If exploitable**: Complete bypass of threshold encryption (Critical severity)
- **In practice**: Requires attacker control over encryption key distribution, making it a **High severity** issue requiring specific attack prerequisites

The vulnerability does NOT directly affect:
- Consensus safety (validators use proper DKG-derived keys)
- State integrity (encryption is separate from state commitment)
- Fund security (no direct fund loss mechanism)

However, it could affect secret sharing in consensus if an attacker compromises the key distribution channel during epoch transitions.

## Likelihood Explanation

**Likelihood: Low to Medium**

The exploitation requires one of the following attack vectors:

1. **Man-in-the-Middle during epoch setup** - Requires network-level access to intercept and modify encryption key distribution (Low likelihood, as this is typically over authenticated channels)

2. **Compromised DKG process** - Requires validator-level compromise (Low likelihood, considered out of scope for unprivileged attackers)

3. **API misuse in derived systems** - If other Aptos components or external developers use this library without understanding the security requirements (Medium likelihood)

The primary concern is that the library lacks defensive input validation, making it fragile in deployment scenarios beyond the core consensus use case.

## Recommendation

Add validation to the `EncryptionKey` constructor and at encryption time:

```rust
impl EncryptionKey {
    pub fn new(sig_mpk_g2: G2Affine, tau_g2: G2Affine) -> Result<Self> {
        // Validate sig_mpk_g2 is not identity
        if sig_mpk_g2.is_zero() {
            return Err(BatchEncryptionError::InvalidEncryptionKey(
                "sig_mpk_g2 cannot be the identity element"
            ))?;
        }
        
        // Validate tau_g2 is not identity
        if tau_g2.is_zero() {
            return Err(BatchEncryptionError::InvalidEncryptionKey(
                "tau_g2 cannot be the identity element"
            ))?;
        }
        
        // Validate points are in the correct subgroup
        if !sig_mpk_g2.is_in_correct_subgroup_assuming_on_curve() {
            return Err(BatchEncryptionError::InvalidEncryptionKey(
                "sig_mpk_g2 not in correct subgroup"
            ))?;
        }
        
        if !tau_g2.is_in_correct_subgroup_assuming_on_curve() {
            return Err(BatchEncryptionError::InvalidEncryptionKey(
                "tau_g2 not in correct subgroup"
            ))?;
        }
        
        Ok(Self { sig_mpk_g2, tau_g2 })
    }
}
```

Additionally, add validation in `bibe_encrypt` as defense-in-depth:

```rust
fn bibe_encrypt<R: RngCore + CryptoRng>(
    &self,
    rng: &mut R,
    plaintext: &impl Plaintext,
    id: Id,
) -> Result<BIBECiphertext> {
    // Validate encryption key components
    if self.sig_mpk_g2.is_zero() || self.tau_g2.is_zero() {
        return Err(BatchEncryptionError::InvalidEncryptionKey(
            "Encryption key contains identity elements"
        ))?;
    }
    
    // ... rest of encryption logic
}
```

## Proof of Concept

```rust
#[test]
fn test_encryption_with_identity_key() {
    use ark_std::rand::thread_rng;
    use ark_ec::AffineRepr;
    
    let mut rng = thread_rng();
    
    // Create malformed encryption key with identity element
    let malformed_ek = EncryptionKey {
        sig_mpk_g2: G2Affine::zero(), // identity element
        tau_g2: G2Affine::generator(),
    };
    
    let plaintext = String::from("secret message");
    let associated_data = String::from("data");
    
    // This should fail but currently succeeds
    let ct = malformed_ek.encrypt(&mut rng, &plaintext, &associated_data);
    
    // The ciphertext is created with degraded security
    assert!(ct.is_ok(), "Encryption with identity key should be rejected but succeeds");
    
    // The OTP will be derived from pairing(hash(identity), identity)
    // which compromises the encryption security
}

#[test]
fn test_encryption_with_attacker_controlled_key() {
    use ark_std::rand::thread_rng;
    use ark_ff::UniformRand;
    
    let mut rng = thread_rng();
    
    // Attacker knows the secret key
    let attacker_msk = Fr::rand(&mut rng);
    let attacker_mpk = (G2Affine::generator() * attacker_msk).into();
    
    let malicious_ek = EncryptionKey {
        sig_mpk_g2: attacker_mpk,
        tau_g2: G2Affine::generator(),
    };
    
    let plaintext = String::from("secret");
    let associated_data = String::from("data");
    
    // Encryption succeeds with attacker's key
    let ct = malicious_ek.encrypt(&mut rng, &plaintext, &associated_data).unwrap();
    
    // Attacker can derive decryption key without threshold shares
    // by computing: decryption_key = (digest + hash(attacker_mpk)) * attacker_msk
    // This bypasses the threshold requirement completely
}
```

## Notes

**Threat Model Considerations:**

While this is a valid defensive programming issue, the practical exploitability in the Aptos consensus context is **limited** because:

1. The encryption key is generated from a trusted DKG process during epoch setup
2. The key is distributed through authenticated validator channels
3. Exploitation requires network-level access or validator compromise

However, this remains a **valid vulnerability** because:

1. The public API lacks input validation, violating defensive programming principles
2. If the library is used in other contexts (non-consensus applications), it could be exploitable
3. Future changes to key distribution mechanisms could make this more exploitable
4. Defense-in-depth principles dictate that cryptographic operations should validate their inputs

**Recommendation Priority:** HIGH - Add validation to prevent potential future exploitation vectors and improve library robustness for general-purpose use.

### Citations

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L119-152)
```rust
    fn bibe_encrypt<R: RngCore + CryptoRng>(
        &self,
        rng: &mut R,
        plaintext: &impl Plaintext,
        id: Id,
    ) -> Result<BIBECiphertext> {
        let r = [Fr::rand(rng), Fr::rand(rng)];
        let hashed_encryption_key: G1Affine = symmetric::hash_g2_element(self.sig_mpk_g2)?;

        let ct_g2 = [
            (G2Affine::generator() * r[0] + self.sig_mpk_g2 * r[1]).into(),
            ((G2Affine::generator() * id.x() - self.tau_g2) * r[0]).into(),
            (-(G2Affine::generator() * r[1])).into(),
        ];

        let otp_source_gt: PairingOutput =
            -PairingSetting::pairing(hashed_encryption_key, self.sig_mpk_g2) * r[1];

        let mut otp_source_bytes = Vec::new();
        otp_source_gt.serialize_compressed(&mut otp_source_bytes)?;
        let otp = OneTimePad::from_source_bytes(otp_source_bytes);

        let symmetric_key = SymmetricKey::new(rng);
        let padded_key = otp.pad_key(&symmetric_key);

        let symmetric_ciphertext = symmetric_key.encrypt(rng, plaintext)?;

        Ok(BIBECiphertext {
            id,
            ct_g2,
            padded_key,
            symmetric_ciphertext,
        })
    }
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L241-243)
```rust
        let mpk_g2: G2Affine = subtranscript.get_dealt_public_key().as_g2();

        let ek = EncryptionKey::new(mpk_g2, digest_key.tau_g2);
```

**File:** crates/aptos-batch-encryption/src/shared/encryption_key.rs (L23-25)
```rust
    pub fn new(sig_mpk_g2: G2Affine, tau_g2: G2Affine) -> Self {
        Self { sig_mpk_g2, tau_g2 }
    }
```
