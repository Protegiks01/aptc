# Audit Report

## Title
Memory Accounting Error in native_remove_box() Charges Instead of Releases Heap Memory

## Summary
The `native_remove_box()` function incorrectly calls `use_heap_memory()` after removing a table entry, charging for memory that should be released. This causes incorrect memory quota accounting and can lead to premature `MEMORY_LIMIT_EXCEEDED` errors.

## Finding Description

The `native_remove_box()` function in `aptos-move/framework/table-natives/src/lib.rs` contains a critical memory accounting bug that violates the Move VM's memory quota invariant. [1](#0-0) 

The bug occurs in the following sequence:

1. **Lines 588-589**: The function retrieves or loads the GlobalValue from storage
2. **Lines 590-600**: It calculates the heap memory size of the value currently in the GlobalValue
3. **Line 602**: It removes the value using `gv.move_from()`, which extracts the value and marks the GlobalValue as deleted
4. **Line 614**: It calls `context.use_heap_memory(amount)`, which **charges** for heap memory

The critical error is at line 614. The function calls `use_heap_memory()` which **reduces** the available memory quota, treating the removal operation as if it were allocating new memory. This is backwards - when a value is removed, memory should be **released** (quota increased), not charged (quota decreased). [2](#0-1) 

The `use_heap_memory()` implementation shows it subtracts from `remaining_memory_quota`. The corresponding `release_heap_memory()` function exists to add back to the quota, but `SafeNativeContext` does not expose a release method. [3](#0-2) 

The `FixTableNativesMemoryDoubleCounting` feature flag was introduced to address memory double-counting issues, but it only prevents charging when values are already cached (`loaded.is_none()`). It does not fix the fundamental issue when values are loaded from storage (`loaded.is_some()`). [4](#0-3) 

**Attack Scenario:**

An attacker can exploit this by:
1. Creating a table and adding large values to it in transaction T1 (values persist to storage)
2. In transaction T2, removing those values:
   - Each value is loaded from storage (`loaded = Some(...)`)
   - Memory is incorrectly charged via `use_heap_memory()` instead of being released
   - The memory quota is depleted with each removal
3. After removing enough values, the memory quota is exhausted
4. The transaction aborts with `MEMORY_LIMIT_EXCEEDED`
5. This can be used to cause denial of service or manipulate transaction outcomes

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per the Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: Incorrect memory accounting corrupts the memory quota state within a transaction
- **Transaction failures**: Legitimate operations can fail with `MEMORY_LIMIT_EXCEEDED` even when they should succeed
- **Resource limit violation**: Breaks invariant #9 "Resource Limits: All operations must respect gas, storage, and computational limits" [5](#0-4) 

The memory quota is set to 10,000,000 abstract value units. With sufficiently large table values, an attacker can exhaust this quota through repeated remove operations, causing legitimate transactions to fail. [6](#0-5) 

The codebase confirms that `MEMORY_LIMIT_EXCEEDED` is a real, enforced error condition.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability manifests whenever:
- A user removes table entries that were previously persisted to storage
- The `FixTableNativesMemoryDoubleCounting` feature is enabled (currently rolling out)
- The removed values are loaded from storage in the same transaction

The attack requires no special privileges - any user can create and manipulate tables. The pattern of adding values in one transaction and removing them in another is a common and legitimate use case, making this bug likely to occur in normal operations.

## Recommendation

**Immediate Fix:** Remove the incorrect `use_heap_memory()` call from `native_remove_box()`:

```rust
// REMOVE these lines (614-615):
if let Some(amount) = mem_usage {
    context.use_heap_memory(amount)?;
}
```

The VM's `charge_native_function` will correctly charge for the return value when it's placed on the stack, so no additional memory charging is needed in the native function itself. [7](#0-6) 

**Complete Fix:** Add a `release_heap_memory()` method to `SafeNativeContext` and call it in `native_remove_box()` to properly release the memory that was charged when the value was initially loaded:

```rust
// In SafeNativeContext (context.rs):
pub fn release_heap_memory(&mut self, amount: u64) -> SafeNativeResult<()> {
    if self.timed_feature_enabled(TimedFeatureFlag::FixMemoryUsageTracking) {
        if self.has_direct_gas_meter_access_in_native_context() {
            self.gas_meter_mut().release_heap_memory(amount.into());
        }
    }
    Ok(())
}

// In native_remove_box():
if let Some(amount) = mem_usage {
    context.release_heap_memory(amount)?;  // Release instead of charge
}
```

## Proof of Concept

```move
module 0xCAFE::exploit {
    use std::table::{Self, Table};
    use std::vector;

    struct LargeData has store, drop {
        data: vector<u64>
    }

    public entry fun exploit_memory_accounting(account: &signer) {
        // Create a table
        let table = table::new<u64, LargeData>();
        
        // Add large values (will persist to storage when transaction commits)
        let i = 0;
        while (i < 100) {
            let large_value = LargeData { 
                data: vector::empty() 
            };
            let j = 0;
            while (j < 1000) {
                vector::push_back(&mut large_value.data, 0xFFFFFFFFFFFFFFFF);
                j = j + 1;
            };
            table::add(&mut table, i, large_value);
            i = i + 1;
        };
        
        move_to(account, table);
    }

    public entry fun trigger_bug(account: &signer) acquires Table {
        let table = move_from<Table<u64, LargeData>>(account);
        
        // Remove all entries - each removal incorrectly charges memory
        // With enough large values, this will hit MEMORY_LIMIT_EXCEEDED
        let i = 0;
        while (i < 100) {
            let _removed = table::remove(&mut table, i);
            i = i + 1;
        };
        
        table::destroy_empty(table);
    }
}
```

**Expected behavior:** The second transaction should succeed as memory is properly accounted.
**Actual behavior:** The second transaction fails with `MEMORY_LIMIT_EXCEEDED` due to incorrect memory charging in `native_remove_box()`.

## Notes

The existing `FixTableNativesMemoryDoubleCounting` feature flag provides partial mitigation by preventing charges when values are cached, but the fundamental bug persists when values are loaded from storage. A complete fix requires either removing the memory charge entirely (letting the VM handle return value charging) or properly implementing memory release semantics in native functions.

### Citations

**File:** aptos-move/framework/table-natives/src/lib.rs (L561-619)
```rust
fn native_remove_box(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 2);

    context.charge(REMOVE_BOX_BASE)?;
    let fix_memory_double_counting =
        context.timed_feature_enabled(TimedFeatureFlag::FixTableNativesMemoryDoubleCounting);

    let (extensions, mut loader_context, abs_val_gas_params, gas_feature_version) =
        context.extensions_with_loader_context_and_gas_params();
    let table_context = extensions.get::<NativeTableContext>();
    let mut table_data = table_context.table_data.borrow_mut();

    let key = args.pop_back().unwrap();
    let handle = get_table_handle(&safely_pop_arg!(args, StructRef))?;

    let table =
        table_data.get_or_create_table(&mut loader_context, handle, &ty_args[0], &ty_args[2])?;

    let function_value_extension = loader_context.function_value_extension();
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let key_cost = REMOVE_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);

    let (gv, loaded) =
        table.get_or_create_global_value(&function_value_extension, table_context, key_bytes)?;
    let mem_usage = if !fix_memory_double_counting || loaded.is_some() {
        gv.view()
            .map(|val| {
                abs_val_gas_params
                    .abstract_heap_size(&val, gas_feature_version)
                    .map(u64::from)
            })
            .transpose()?
    } else {
        None
    };

    let res = match gv.move_from() {
        Ok(val) => Ok(smallvec![val]),
        Err(_) => Err(SafeNativeError::Abort {
            abort_code: NOT_FOUND,
        }),
    };

    drop(table_data);

    // TODO(Gas): Figure out a way to charge this earlier.
    context.charge(key_cost)?;
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
    charge_load_cost(context, loaded)?;

    res
}
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L48-63)
```rust
    fn use_heap_memory(&mut self, amount: AbstractValueSize) -> PartialVMResult<()> {
        if self.feature_version >= 3 {
            match self.remaining_memory_quota.checked_sub(amount) {
                Some(remaining_quota) => {
                    self.remaining_memory_quota = remaining_quota;
                    Ok(())
                },
                None => {
                    self.remaining_memory_quota = 0.into();
                    Err(PartialVMError::new(StatusCode::MEMORY_LIMIT_EXCEEDED))
                },
            }
        } else {
            Ok(())
        }
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L66-70)
```rust
    fn release_heap_memory(&mut self, amount: AbstractValueSize) {
        if self.feature_version >= 3 {
            self.remaining_memory_quota += amount;
        }
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L358-375)
```rust
    fn charge_native_function(
        &mut self,
        amount: InternalGas,
        ret_vals: Option<impl ExactSizeIterator<Item = impl ValueView> + Clone>,
    ) -> PartialVMResult<()> {
        if let Some(mut ret_vals) = ret_vals.clone() {
            self.use_heap_memory(ret_vals.try_fold(AbstractValueSize::zero(), |acc, val| {
                let heap_size = self
                    .vm_gas_params()
                    .misc
                    .abs_val
                    .abstract_heap_size(val, self.feature_version())?;
                Ok::<_, PartialVMError>(acc + heap_size)
            })?)?;
        }

        self.base.charge_native_function(amount, ret_vals)
    }
```

**File:** types/src/on_chain_config/timed_features.rs (L26-27)
```rust
    /// Fixes the bug that table natives double count the memory usage of the global values.
    FixTableNativesMemoryDoubleCounting,
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L142-142)
```rust
        [memory_quota: AbstractValueSize, { 1.. => "memory_quota" }, 10_000_000],
```

**File:** aptos-move/e2e-move-tests/src/tests/memory_quota.rs (L101-106)
```rust
    assert!(matches!(
        result,
        TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(Some(
            StatusCode::MEMORY_LIMIT_EXCEEDED
        )))
    ));
```
