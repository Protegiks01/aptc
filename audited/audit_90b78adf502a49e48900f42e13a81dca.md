# Audit Report

## Title
Missing Bounds Check in DKG Public Key Share Retrieval Causes Validator Panic During Epoch Transition

## Summary
The `get_public_key_share()` function in the PVSS transcript implementation lacks bounds checking when accessing the `Vs` vector with `player.id`, and the consensus layer fails to validate that the validator set size matches the DKG transcript's expected size before calling this function. This can cause all validator nodes to panic simultaneously during epoch transition if a validator set size mismatch occurs.

## Finding Description

The vulnerability exists across two related issues:

**Issue 1: Missing Bounds Check in `get_public_key_share()`**

The `get_public_key_share()` function directly accesses `self.Vs[player.id]` without bounds validation: [1](#0-0) 

The same issue exists in the v2 implementation: [2](#0-1) 

**Issue 2: Missing Validator Set Size Validation in Consensus Layer**

In the epoch manager, when setting up randomness for a new epoch, the code iterates from `0..new_epoch_state.verifier.len()` to retrieve public key shares without validating that this matches the transcript's `Vs` vector size: [3](#0-2) 

The `dkg_pub_params` are created from the DKG session metadata, which contains the `target_validator_set` used to build the transcript: [4](#0-3) 

The code validates only that the DKG session is for the correct epoch, but NOT that the validator set sizes match: [5](#0-4) 

**Root Cause:**

The `Vs` vector size is determined by `dkg_pub_params.pvss_config.wconfig.get_total_num_players()`, which comes from the `target_validator_set` in the DKG session metadata. This is set when the DKG session starts: [6](#0-5) 

While transcript verification ensures `Vs.len() == sc.get_total_num_players()`: [7](#0-6) 

There is NO validation that `new_epoch_state.verifier.len()` matches this size when the transcript is used in a later epoch.

**Attack Scenario:**

If the validator set size changes between DKG session creation and epoch transition (through governance actions, state inconsistencies, or implementation bugs), then:
1. `Vs.len()` = size of `target_validator_set` when DKG session was created
2. `new_epoch_state.verifier.len()` = current epoch's validator set size
3. When `new_epoch_state.verifier.len() > Vs.len()`, accessing `Vs[player.id]` with `player.id >= Vs.len()` causes an **out-of-bounds panic**
4. All validators attempting epoch transition encounter the same panic simultaneously
5. Network-wide liveness failure until manual intervention

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program because:

1. **Validator Node Crashes**: The panic occurs in critical epoch transition code, causing validator nodes to crash when attempting to set up randomness configuration for the new epoch

2. **Deterministic Failure**: All validators process the same DKG session and validator set, so all nodes will panic simultaneously, not just a subset

3. **Liveness Impact**: Epoch transitions are critical for consensus - if validators cannot complete epoch transition, the network experiences liveness failure

4. **Requires Manual Intervention**: Recovery requires identifying and fixing the root cause (validator set mismatch), potentially requiring emergency governance actions or hotfix deployment

While the validator set size is expected to be consistent under normal operation, the **lack of defensive validation** creates a fragile system where edge cases, implementation bugs, or state inconsistencies can cause catastrophic network-wide failures.

## Likelihood Explanation

**Moderate Likelihood** due to:

1. **Assumed Invariant**: The code assumes `target_validator_set` at DKG time equals the actual validator set at epoch transition, but this assumption is not enforced programmatically

2. **No Defensive Programming**: Despite the comment "No need to verify the transcript," basic bounds checking should still be performed to prevent panics

3. **Edge Cases**: While rare, validator set changes during reconfiguration, state sync issues, or governance actions could violate the assumed invariant

4. **Secondary Vulnerability**: Even if the primary invariant holds under normal conditions, this missing validation amplifies the impact of any bug elsewhere that causes validator set inconsistencies

## Recommendation

**Add defensive bounds checking in two locations:**

**Fix 1: Add bounds check in `get_public_key_share()`**

```rust
fn get_public_key_share(
    &self,
    _sc: &Self::SecretSharingConfig,
    player: &Player,
) -> Self::DealtPubKeyShare {
    // Validate player ID is within bounds
    if player.id >= self.Vs.len() {
        panic!(
            "Player ID {} exceeds Vs vector bounds (len={})",
            player.id,
            self.Vs.len()
        );
    }
    
    self.Vs[player.id]
        .iter()
        .map(|&V_i| keys::DealtPubKeyShare::<E>::new(keys::DealtPubKey::new(V_i.into_affine())))
        .collect()
}
```

**Fix 2: Add validator set size validation in `try_get_rand_config_for_new_epoch()`**

```rust
// After line 1079, before the loop:
if new_epoch_state.verifier.len() != dkg_pub_params.pvss_config.wconfig.get_total_num_players() {
    return Err(NoRandomnessReason::ValidatorSetSizeMismatch {
        expected: dkg_pub_params.pvss_config.wconfig.get_total_num_players(),
        actual: new_epoch_state.verifier.len(),
    });
}

let pk_shares = (0..new_epoch_state.verifier.len())
    .map(|id| {
        // Now guaranteed to be in bounds
        transcript
            .main
            .get_public_key_share(&dkg_pub_params.pvss_config.wconfig, &Player { id })
    })
    .collect::<Vec<_>>();
```

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the panic scenario
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_player_id_exceeds_vs_bounds() {
    // Setup: Create a transcript with Vs.len() = 10
    let sc = create_weighted_config_with_players(10);
    let transcript = create_test_transcript_for_config(&sc);
    
    // Attack: Try to get public key share for player 11
    // This simulates what happens when new_epoch_state.verifier.len() = 11
    // but the DKG transcript was created for 10 validators
    let invalid_player = Player { id: 10 }; // Out of bounds!
    
    // This will panic with "index out of bounds"
    let _ = transcript.get_public_key_share(&sc, &invalid_player);
}

// Scenario: Validator set size mismatch during epoch transition
#[test]  
fn test_epoch_transition_validator_set_mismatch() {
    // 1. DKG session created for 100 validators
    let dkg_metadata = create_dkg_metadata_with_validators(100);
    let dkg_pub_params = DefaultDKG::new_public_params(&dkg_metadata);
    
    // 2. Transcript created and verified (Vs.len() = 100)
    let transcript = create_and_verify_transcript(&dkg_pub_params);
    
    // 3. Epoch state with 101 validators (mismatch!)
    let new_epoch_state = create_epoch_state_with_validators(101);
    
    // 4. Attempt to get pk_shares - this will panic at id=100
    let result = std::panic::catch_unwind(|| {
        let pk_shares = (0..new_epoch_state.verifier.len())
            .map(|id| {
                transcript.main.get_public_key_share(
                    &dkg_pub_params.pvss_config.wconfig,
                    &Player { id }
                )
            })
            .collect::<Vec<_>>();
        pk_shares
    });
    
    // Verify the panic occurred
    assert!(result.is_err(), "Expected panic due to out-of-bounds access");
}
```

## Notes

The `Player` struct includes a comment acknowledging this design weakness: [8](#0-7) 

While the `SecretSharingConfig::get_player()` method includes bounds checking: [9](#0-8) 

The `Player.id` field is public, allowing direct construction of Player instances with arbitrary IDs, bypassing this protection. The consensus code directly constructs Player instances without using `get_player()`: [10](#0-9) 

This vulnerability demonstrates the importance of defensive programming in consensus-critical code paths, even when certain invariants are expected to hold under normal operation.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L147-152)
```rust
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L302-311)
```rust
    fn get_public_key_share(
        &self,
        _sc: &Self::SecretSharingConfig,
        player: &Player,
    ) -> Self::DealtPubKeyShare {
        self.Vs[player.id]
            .iter()
            .map(|&V_i| keys::DealtPubKeyShare::<E>::new(keys::DealtPubKey::new(V_i.into_affine())))
            .collect()
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L598-607)
```rust
    fn get_public_key_share(
        &self,
        _sc: &Self::SecretSharingConfig,
        player: &Player,
    ) -> Self::DealtPubKeyShare {
        self.Vs[player.id]
            .iter()
            .map(|&V_i| keys::DealtPubKeyShare::<E>::new(keys::DealtPubKey::new(V_i.into_affine())))
            .collect()
    }
```

**File:** consensus/src/epoch_manager.rs (L1043-1045)
```rust
        if dkg_session.metadata.dealer_epoch + 1 != new_epoch_state.epoch {
            return Err(NoRandomnessReason::CompletedSessionTooOld);
        }
```

**File:** consensus/src/epoch_manager.rs (L1046-1046)
```rust
        let dkg_pub_params = DefaultDKG::new_public_params(&dkg_session.metadata);
```

**File:** consensus/src/epoch_manager.rs (L1080-1086)
```rust
        let pk_shares = (0..new_epoch_state.verifier.len())
            .map(|id| {
                transcript
                    .main
                    .get_public_key_share(&dkg_pub_params.pvss_config.wconfig, &Player { id })
            })
            .collect::<Vec<_>>();
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L34-39)
```text
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
```

**File:** crates/aptos-crypto/src/player.rs (L26-28)
```rust
/// The point of Player is to provide type-safety: ensure nobody creates out-of-range player IDs.
/// So there is no `new()` method; only the SecretSharingConfig trait is allowed to create them.
// TODO: AFAIK the only way to really enforce this is to put both traits inside the same module (or use unsafe Rust)
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L324-329)
```rust
    fn get_player(&self, i: usize) -> Player {
        let n = self.get_total_num_players();
        assert_lt!(i, n);

        Player { id: i }
    }
```
