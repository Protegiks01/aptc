# Audit Report

## Title
LRU Cache Eviction Enables Performance Degradation Through Strategic Module Publishing

## Summary
The `VERIFIED_MODULES_CACHE` in the Move VM runtime uses an LRU eviction policy with a fixed capacity of 100,000 entries and no prioritization for critical framework modules. An attacker can strategically publish numerous unique modules to fill the cache, causing eviction of Aptos framework modules (coin, account, stake, etc.). When these evicted modules are subsequently accessed during normal transaction processing, expensive bytecode re-verification occurs without gas charges, causing temporary validator performance degradation. [1](#0-0) 

## Finding Description

The vulnerability exists in the global module verification cache that stores bytecode verification results by module hash. The cache implementation uses an LRU eviction policy: [2](#0-1) 

When modules are published, they undergo staging verification which calls `build_locally_verified_module`: [3](#0-2) 

This function checks the global cache and performs expensive bytecode verification if the module hash is not cached: [4](#0-3) 

The verification process is computationally expensive but completely unmetered (no gas charged): [5](#0-4) 

**Attack Path:**

1. Attacker publishes 100,000+ unique modules (different bytecode hashes) to various addresses over time
2. Each published module triggers staging verification, adding its hash to `VERIFIED_MODULES_CACHE`
3. Once the cache reaches 100,000 capacity, LRU eviction begins
4. Critical Aptos framework modules at address 0x1 (coin, account, stake, governance, transaction_validation) can be evicted as they are treated equally to user modules
5. When legitimate user transactions require these framework modules, they are not in cache
6. Expensive bytecode verification occurs synchronously during transaction execution (free of gas charges)
7. This causes measurable performance degradation on validator nodes

Framework modules receive no special cache protection: [6](#0-5) 

While special addresses (0x0-0xf) skip gas charging during module access, they still undergo cache lookup and can be evicted from `VERIFIED_MODULES_CACHE`.

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria, specifically "validator node slowdowns" which could impact High severity but with important mitigations:

**Actual Impact:**
- Temporary performance degradation on validators when evicted framework modules are accessed
- Increased transaction processing latency during cache misses
- CPU resource exhaustion during synchronous re-verification
- Self-healing: evicted modules are immediately re-cached after first access

**Does NOT cause:**
- Consensus safety violations
- Fund loss or theft  
- Permanent network disruption
- State corruption

The impact is limited because evicted modules are automatically re-cached on first access, making the attack effect temporary unless continuously maintained.

## Likelihood Explanation

**Likelihood: Low to Medium**

**Required Resources:**
- Economic cost: Publishing 100,000 unique modules at ~1,838 + 7Ã—(module_size) gas units each requires substantial funds
- For 1KB modules: ~883 million gas units total
- Must create 100,000 distinct bytecode variants (different hashes)

**Feasibility Factors:**
- Attack is technically possible and requires no privileged access
- Cache persists across blocks (global static lifetime)
- Cache metrics make detection possible: [7](#0-6) 

- Attack requires sustained effort to maintain as evicted modules self-heal on access
- High economic barrier reduces practical exploitation likelihood

## Recommendation

**Immediate Mitigation:**
Implement cache prioritization for framework modules to prevent their eviction:

```rust
// In verified_module_cache.rs
pub(crate) struct VerifiedModuleCache {
    cache: Mutex<lru::LruCache<[u8; 32], ()>>,
    pinned: Mutex<HashSet<[u8; 32]>>, // Protected framework module hashes
}

impl VerifiedModuleCache {
    pub(crate) fn pin(&self, module_hash: [u8; 32]) {
        self.pinned.lock().insert(module_hash);
    }
    
    pub(crate) fn put(&self, module_hash: [u8; 32]) {
        if verifier_cache_enabled() {
            let mut cache = self.cache.lock();
            let pinned = self.pinned.lock();
            
            // Prevent eviction of pinned modules
            if cache.len() >= VERIFIED_CACHE_SIZE.get() {
                // Evict oldest non-pinned entry
                while let Some((key, _)) = cache.pop_lru() {
                    if !pinned.contains(&key) {
                        break;
                    }
                    cache.put(key, ()); // Re-insert pinned
                }
            }
            cache.put(module_hash, ());
        }
    }
}
```

**Long-term Solutions:**
1. Pin framework modules at genesis and during prefetch: [8](#0-7) 

2. Implement tiered caching with separate pools for framework vs user modules
3. Add rate limiting on module publishing per account
4. Consider metering verification cost or implementing adaptive cache sizing based on module importance

## Proof of Concept

```rust
#[test]
fn test_cache_eviction_attack() {
    use move_core_types::account_address::AccountAddress;
    use move_binary_format::CompiledModule;
    
    // Setup test environment
    let mut modules = vec![];
    
    // Publish 100,001 unique modules to fill cache beyond capacity
    for i in 0..100_001 {
        // Create unique module by varying constants
        let module_bytes = create_unique_module(i);
        let addr = AccountAddress::random();
        
        // Publish module - triggers verification and cache insertion
        publish_module(&addr, module_bytes);
    }
    
    // Verify framework module was evicted
    let framework_hash = get_module_hash(&AccountAddress::ONE, "coin");
    assert!(!VERIFIED_MODULES_CACHE.contains(&framework_hash));
    
    // Trigger framework module load - forces re-verification
    let start = std::time::Instant::now();
    load_module(&AccountAddress::ONE, "coin");
    let duration = start.elapsed();
    
    // Verification should take significant time (not served from cache)
    assert!(duration.as_millis() > 10); // Verification overhead
    
    // Module is now re-cached
    assert!(VERIFIED_MODULES_CACHE.contains(&framework_hash));
}
```

## Notes

This vulnerability represents a design limitation where unmetered operations (bytecode verification) can be weaponized through cache eviction. While the economic cost provides a natural barrier, determined attackers with sufficient resources could exploit this for temporary validator DoS. The self-healing nature and detection mechanisms provide partial mitigation, but explicit protection for critical system modules should be implemented to prevent strategic cache pollution attacks.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L13-22)
```rust
pub(crate) struct VerifiedModuleCache(Mutex<lru::LruCache<[u8; 32], ()>>);

impl VerifiedModuleCache {
    /// Maximum size of the cache. When modules are cached, they can skip re-verification.
    const VERIFIED_CACHE_SIZE: NonZeroUsize = NonZeroUsize::new(100_000).unwrap();

    /// Returns new empty verified module cache.
    pub(crate) fn empty() -> Self {
        Self(Mutex::new(lru::LruCache::new(Self::VERIFIED_CACHE_SIZE)))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L51-54)
```rust
lazy_static! {
    pub(crate) static ref VERIFIED_MODULES_CACHE: VerifiedModuleCache =
        VerifiedModuleCache::empty();
}
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L252-257)
```rust
                let locally_verified_code = staged_runtime_environment
                    .build_locally_verified_module(
                        compiled_module.clone(),
                        bytes.len(),
                        &sha3_256(bytes),
                    )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L184-198)
```rust
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L380-383)
```rust
    pub fn log_verified_cache_size() {
        let size = VERIFIED_MODULES_CACHE.size();
        VERIFIED_MODULE_CACHE_SIZE.set(size as i64);
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L295-329)
```rust
    fn unmetered_get_lazily_verified_module(
        &self,
        module_id: &ModuleId,
    ) -> VMResult<Option<Arc<Module>>> {
        let (module, version) = match self.get_module_or_build_with(module_id, self)? {
            Some(module_and_version) => module_and_version,
            None => return Ok(None),
        };

        if module.code().is_verified() {
            return Ok(Some(module.code().verified().clone()));
        }

        let _timer = VM_TIMER.timer_with_label("unmetered_get_lazily_verified_module [cache miss]");
        let runtime_environment = self.runtime_environment();
        runtime_environment.paranoid_check_module_address_and_name(
            module.code().deserialized(),
            module_id.address(),
            module_id.name(),
        )?;
        let locally_verified_code = runtime_environment.build_locally_verified_module(
            module.code().deserialized().clone(),
            module.extension().size_in_bytes(),
            module.extension().hash(),
        )?;
        let verified_code =
            runtime_environment.build_verified_module_skip_linking_checks(locally_verified_code)?;
        let verified_module = self.insert_verified_module(
            module_id.clone(),
            verified_code,
            module.extension().clone(),
            version,
        )?;
        Ok(Some(verified_module.code().verified().clone()))
    }
```

**File:** third_party/move/move-vm/runtime/src/module_traversal.rs (L59-65)
```rust
    pub fn visit_if_not_special_address(
        &mut self,
        addr: &'a AccountAddress,
        name: &'a IdentStr,
    ) -> bool {
        !addr.is_special() && self.visited.insert((addr, name), ()).is_none()
    }
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L345-380)
```rust
fn prefetch_aptos_framework(
    state_view: &impl StateView,
    guard: &mut AptosModuleCacheManagerGuard,
) -> Result<(), PanicError> {
    let code_storage = state_view.as_aptos_code_storage(guard.environment());

    // INVARIANT:
    //   If framework code exists in storage, the transitive closure will be verified and cached to
    //   avoid cold starts. From metering perspective, all modules are at special addresses, so we
    //   do not need to meter anything.
    cfg_if! {
        if #[cfg(fuzzing)] {
            let maybe_loaded = code_storage
                .unmetered_get_module_skip_verification(&AccountAddress::ONE, ident_str!("transaction_validation"))
                .map_err(|err| {
                    PanicError::CodeInvariantError(format!("Unable to fetch Aptos framework: {:?}", err))
                })?;
        } else {
            let maybe_loaded = code_storage
                .unmetered_get_eagerly_verified_module(&AccountAddress::ONE, ident_str!("transaction_validation"))
                .map_err(|err| {
                    PanicError::CodeInvariantError(format!("Unable to fetch Aptos framework: {:?}", err))
                })?;
        }
    }

    if maybe_loaded.is_some() {
        // Framework must have been loaded. Drain verified modules from local cache into
        // global cache.
        let verified_module_code_iter = code_storage.into_verified_module_code_iter()?;
        guard
            .module_cache_mut()
            .insert_verified(verified_module_code_iter)?;
    }
    Ok(())
}
```
