# Audit Report

## Title
Indexer Filter Bypass via Unhandled ScriptPayload Transactions

## Summary
The `get_entry_function_payload_from_transaction_payload()` function in the transaction filter uses a catch-all pattern that silently allows non-entry-function payload types (specifically `ScriptPayload`) to bypass user-defined filters, violating the documented filtering behavior and potentially causing incorrect indexing or resource exhaustion in downstream systems.

## Finding Description

The transaction filter system allows indexer clients to subscribe to specific transaction types via the `UserTransactionFilter` with a `payload_filter` field. The filter is designed to match only transactions calling specific entry functions. [1](#0-0) 

However, the `get_entry_function_payload_from_transaction_payload()` function uses a non-exhaustive match pattern with a catch-all that returns `None` for unhandled payload types: [2](#0-1) 

The protobuf `TransactionPayload` type defines four payload variants: `EntryFunctionPayload`, `ScriptPayload`, `WriteSetPayload`, and `MultisigPayload`. [3](#0-2) 

The function explicitly handles only `EntryFunctionPayload` and `MultisigPayload`, while `ScriptPayload` and `WriteSetPayload` fall through to the catch-all returning `None`.

When a `payload_filter` is set and `get_entry_function_payload_from_transaction_payload()` returns `None`, the filter check is **silently skipped** and the transaction matches: [4](#0-3) 

**Attack Path:**
1. Victim: Indexer client sets up filter: `sender=0x123 AND payload=0x1::coin::transfer`
2. Attacker: Submits a `ScriptPayload` transaction from address `0x123`
3. Filter logic: `get_entry_function_payload_from_transaction_payload()` returns `None`
4. Filter bypass: The payload check is skipped, transaction incorrectly matches the filter
5. Impact: Client receives unintended transaction in filtered stream

Script transactions are explicitly supported and validated by the API: [5](#0-4) 

The filter is applied as an inclusion filter where matching transactions are retained: [6](#0-5) 

## Impact Explanation

This is a **High severity** issue for the following reasons:

1. **Violation of Filter Guarantees**: Clients setting payload filters expect to receive ONLY transactions matching those filters. Silent bypasses break this guarantee.

2. **Downstream System Impact**: Indexing systems, monitoring tools, and DeFi protocols that rely on filtered data may:
   - Index incorrect or incomplete state
   - Miss critical state changes
   - Make incorrect business logic decisions
   - Experience resource exhaustion from processing unexpected transaction volumes

3. **Silent Failure**: The bypass is completely silent—no error is raised, making it difficult for clients to detect the issue.

4. **Documented Limitation Not Enforced**: The README states "we only support the entry function payload" but the code silently allows non-entry-function payloads to pass through filters rather than explicitly rejecting them.

While this does not directly affect consensus or cause fund loss, it violates critical data integrity guarantees in the indexing infrastructure, which qualifies as a "Significant protocol violation" under the High severity category.

## Likelihood Explanation

**Likelihood: High**

- Script transactions are fully supported in Aptos and can be submitted by any user via the REST API
- No special privileges or insider access required
- Trivial to exploit—simply submit a script transaction instead of an entry function call
- Common scenario: Any indexer client using payload filters is vulnerable
- No detection mechanism—clients cannot easily identify when they receive bypassed transactions

## Recommendation

The `get_entry_function_payload_from_transaction_payload()` function should be modified to explicitly handle all payload variants rather than using a catch-all pattern. When a `payload_filter` is set, non-entry-function payloads should cause the filter to **reject** the transaction, not skip the check.

**Recommended Fix:**

```rust
fn get_entry_function_payload_from_transaction_payload(
    payload: &TransactionPayload,
) -> Option<&EntryFunctionPayload> {
    if let Some(payload) = &payload.payload {
        match payload {
            transaction_payload::Payload::EntryFunctionPayload(ef_payload) => Some(ef_payload),
            transaction_payload::Payload::MultisigPayload(ms_payload) => ms_payload
                .transaction_payload
                .as_ref()
                .and_then(|tp| tp.payload.as_ref())
                .map(|payload| match payload {
                    multisig_transaction_payload::Payload::EntryFunctionPayload(ef_payload) => {
                        ef_payload
                    },
                }),
            // Explicitly handle other variants - they don't contain entry functions
            transaction_payload::Payload::ScriptPayload(_) => None,
            transaction_payload::Payload::WriteSetPayload(_) => None,
        }
    } else {
        None
    }
}
```

Additionally, modify the `matches()` function to reject transactions when a payload filter is set but no entry function payload is found:

```rust
if let Some(payload_filter) = &self.payload {
    let entry_function_payload = user_request
        .payload
        .as_ref()
        .and_then(get_entry_function_payload_from_transaction_payload);
    
    match entry_function_payload {
        Some(payload) => {
            if !payload_filter.matches(payload) {
                return false;
            }
        },
        // If payload filter is set but transaction has no entry function, reject it
        None => return false,
    }
}
```

## Proof of Concept

```rust
use aptos_protos::transaction::v1::{
    transaction::TxnData,
    transaction_payload::{Payload},
    EntryFunctionId, EntryFunctionPayload, MoveModuleId, MoveScriptBytecode,
    ScriptPayload, Transaction, TransactionPayload, UserTransaction,
    UserTransactionRequest,
};
use aptos_transaction_filter::{
    EntryFunctionFilterBuilder, UserTransactionFilterBuilder,
    UserTransactionPayloadFilterBuilder, Filterable,
};

#[test]
fn test_script_payload_bypasses_filter() {
    // Create a filter for coin::transfer entry function
    let entry_function_filter = EntryFunctionFilterBuilder::default()
        .address("0x1")
        .module("coin")
        .function("transfer")
        .build()
        .unwrap();
    
    let payload_filter = UserTransactionPayloadFilterBuilder::default()
        .function(entry_function_filter)
        .build()
        .unwrap();
    
    let filter = UserTransactionFilterBuilder::default()
        .sender("0x123")
        .payload(payload_filter)
        .build()
        .unwrap();

    // Create a transaction with ScriptPayload (NOT an entry function)
    let script_txn = Transaction {
        version: 1,
        txn_data: Some(TxnData::User(UserTransaction {
            request: Some(UserTransactionRequest {
                sender: "0x123".to_string(),
                payload: Some(TransactionPayload {
                    r#type: 2, // ScriptPayload
                    payload: Some(Payload::ScriptPayload(ScriptPayload {
                        code: Some(MoveScriptBytecode {
                            bytecode: vec![],
                            abi: None,
                        }),
                        type_arguments: vec![],
                        arguments: vec![],
                    })),
                    extra_config: None,
                }),
                sequence_number: 1,
                max_gas_amount: 1000,
                gas_unit_price: 1,
                expiration_timestamp_secs: None,
                signature: None,
            }),
            events: vec![],
        })),
        ..Default::default()
    };

    // BUG: This should return false (filter should reject non-entry-function payloads)
    // but it returns true (filter bypass)
    assert!(filter.matches(&script_txn), 
        "Script transaction bypassed the entry function filter!");
}
```

**Notes**

The vulnerability stems from insufficient type exhaustiveness checking combined with incorrect fallback behavior. The Rust compiler does not enforce exhaustive matching when a catch-all pattern is present, allowing new payload types to silently bypass filters. The fix requires both explicit handling of all variants and rejecting transactions that don't match the filter criteria rather than silently skipping validation.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/README.md (L20-20)
```markdown
    - Payload: we only support the entry function payload
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L100-114)
```rust
        if let Some(payload_filter) = &self.payload {
            // Get the entry_function_payload from both UserPayload and MultisigPayload
            let entry_function_payload = user_request
                .payload
                .as_ref()
                .and_then(get_entry_function_payload_from_transaction_payload);
            if let Some(payload) = entry_function_payload {
                // Here we have an actual EntryFunctionPayload
                if !payload_filter.matches(payload) {
                    return false;
                }
            }
        }

        true
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L275-295)
```rust
fn get_entry_function_payload_from_transaction_payload(
    payload: &TransactionPayload,
) -> Option<&EntryFunctionPayload> {
    if let Some(payload) = &payload.payload {
        match payload {
            transaction_payload::Payload::EntryFunctionPayload(ef_payload) => Some(ef_payload),
            transaction_payload::Payload::MultisigPayload(ms_payload) => ms_payload
                .transaction_payload
                .as_ref()
                .and_then(|tp| tp.payload.as_ref())
                .map(|payload| match payload {
                    multisig_transaction_payload::Payload::EntryFunctionPayload(ef_payload) => {
                        ef_payload
                    },
                }),
            _ => None,
        }
    } else {
        None
    }
}
```

**File:** protos/rust/src/pb/aptos.transaction.v1.rs (L627-636)
```rust
    pub enum Payload {
        #[prost(message, tag="2")]
        EntryFunctionPayload(super::EntryFunctionPayload),
        #[prost(message, tag="3")]
        ScriptPayload(super::ScriptPayload),
        #[prost(message, tag="5")]
        WriteSetPayload(super::WriteSetPayload),
        #[prost(message, tag="6")]
        MultisigPayload(super::MultisigPayload),
    }
```

**File:** api/src/transactions.rs (L1268-1269)
```rust
            TransactionPayload::Script(script) => {
                TransactionsApi::validate_script(ledger_info, script)?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/file_store_reader.rs (L140-142)
```rust
                if let Some(ref filter) = filter {
                    transactions.retain(|t| filter.matches(t));
                }
```
