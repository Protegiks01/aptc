# Audit Report

## Title
Malicious Validator Can DoS Consensus by Flooding Invalid CommitVotes Forcing Expensive Signature Verification

## Summary
A malicious or compromised validator can cause Denial of Service (DoS) on all validators by flooding them with invalid CommitVotes. After being added to the `pessimistic_verify_set`, each subsequent invalid vote forces expensive BLS signature verification in a bounded executor with only 16 concurrent task slots, blocking legitimate CommitVote processing from honest validators.

## Finding Description
The vulnerability exists in the CommitVote verification flow within the consensus pipeline. The system uses a bounded executor with a capacity of 16 concurrent tasks to verify incoming CommitVotes. [1](#0-0) 

When a CommitVote arrives, it is processed by a verification task that calls the expensive signature verification before any validation of the vote's round or validity. [2](#0-1) 

The verification flow calls `CommitVote::verify()` which only performs a cheap author-sender equality check before calling the expensive cryptographic verification. [3](#0-2) 

With optimistic signature verification enabled by default [4](#0-3) , the first invalid vote from an attacker bypasses verification. However, during signature aggregation, the invalid signature is detected and the attacker's identity is added to the `pessimistic_verify_set`. [5](#0-4) 

Once in the pessimistic set, all subsequent votes from that validator require full BLS signature verification in the verification task, even if the vote is for an invalid round or will ultimately be rejected. [6](#0-5) 

**Attack Path:**
1. Malicious validator sends one invalid CommitVote (bypasses verification due to optimistic mode)
2. Invalid signature detected during aggregation â†’ attacker added to `pessimistic_verify_set`
3. Attacker floods with invalid CommitVotes for any rounds (past/present/future)
4. Each vote spawns a verification task that performs expensive BLS signature verification
5. The bounded executor (16 slot capacity) becomes saturated with verification tasks
6. New incoming CommitVotes (including from honest validators) must wait for available slots
7. Legitimate consensus messages are delayed, causing validator slowdown

The critical flaw is that signature verification occurs before round validation or any rate limiting checks. Even votes for rounds outside the 100-round cache window trigger full cryptographic verification. [7](#0-6) 

## Impact Explanation
This qualifies as **High Severity** under the Aptos bug bounty program criteria for "Validator node slowdowns". A single malicious or compromised validator can significantly degrade consensus performance across the entire validator network by:

- Saturating the bounded executor's 16 task slots with signature verifications
- Delaying processing of legitimate CommitVotes from honest validators  
- Potentially causing timeouts and consensus round failures
- Degrading network-wide consensus throughput

Multiple colluding malicious validators (still <1/3 for BFT assumptions) could amplify this attack, making it even more severe.

## Likelihood Explanation
**Likelihood: Medium**

**Attacker Requirements:**
- Control of at least one validator identity (compromised keys or malicious validator operator)
- Ability to send network messages to other validators

**Complexity:** Low - once in pessimistic set, simply flood with invalid signatures

**Realistic Scenarios:**
- Compromised validator node or stolen validator keys
- Malicious validator operator 
- Validators are economic actors and some may be adversarial (BFT assumption)

While requiring validator access raises the barrier, validator compromises are realistic threats that Byzantine fault tolerant systems must defend against.

## Recommendation
Add round validation and rate limiting checks **before** expensive signature verification:

```rust
// In BufferManager verification task
spawn_named!("buffer manager verification", async move {
    while let Some((sender, commit_msg)) = commit_msg_rx.next().await {
        let tx = verified_commit_msg_tx.clone();
        let epoch_state_clone = epoch_state.clone();
        
        // ADDED: Cheap pre-validation before verification
        match &commit_msg.req {
            CommitMessage::Vote(vote) => {
                let round = vote.round();
                // Reject votes outside reasonable round window
                if round > highest_committed_round + max_future_rounds 
                   || round <= highest_committed_round {
                    warn!("Vote for invalid round {} ignored", round);
                    continue;
                }
            },
            _ => {}
        }
        
        bounded_executor
            .spawn(async move {
                match commit_msg.req.verify(sender, &epoch_state_clone.verifier) {
                    Ok(_) => {
                        let _ = tx.unbounded_send(commit_msg);
                    },
                    Err(e) => warn!("Invalid commit message: {}", e),
                }
            })
            .await;
    }
});
```

Additionally, implement per-author rate limiting:
- Track verification attempts per author per time window
- Temporarily ban authors exceeding threshold
- Consider increasing bounded executor capacity or using separate executor for signature verification

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_commit_vote_verification_dos() {
    use aptos_consensus_types::pipeline::commit_vote::CommitVote;
    use aptos_types::validator_verifier::ValidatorVerifier;
    use aptos_crypto::bls12381::Signature;
    
    // Setup validator verifier with optimistic verification enabled
    let (validator_signers, mut validator_verifier) = 
        create_test_validators(7);
    validator_verifier.set_optimistic_sig_verification_flag(true);
    
    // Malicious validator
    let attacker = &validator_signers[0];
    let ledger_info = create_test_ledger_info();
    
    // Step 1: Send first invalid vote (bypasses verification)
    let invalid_vote = CommitVote::new_with_signature(
        attacker.author(),
        ledger_info.clone(),
        Signature::dummy_signature(), // Invalid signature
    );
    
    // This bypasses signature verification initially
    assert!(invalid_vote.verify(attacker.author(), &validator_verifier).is_ok());
    
    // Step 2: After aggregation fails, attacker is in pessimistic set
    validator_verifier.add_pessimistic_verify_set(attacker.author());
    
    // Step 3: Flood with invalid votes for various rounds
    let start = std::time::Instant::now();
    for round in 0..100 {
        let ledger_info_at_round = create_ledger_info_for_round(round);
        let invalid_vote = CommitVote::new_with_signature(
            attacker.author(),
            ledger_info_at_round,
            Signature::dummy_signature(),
        );
        
        // Each of these now triggers expensive signature verification
        let result = invalid_vote.verify(attacker.author(), &validator_verifier);
        assert!(result.is_err()); // Verification fails but AFTER expensive check
    }
    let elapsed = start.elapsed();
    
    // Demonstrates that 100 signature verifications take significant time
    println!("100 invalid signature verifications took: {:?}", elapsed);
    // On real hardware, this would be >100ms, blocking the bounded executor
}
```

**Notes:**
- The vulnerability requires controlling a validator identity, which limits the attack surface but is realistic under BFT threat model
- The impact on consensus liveness and validator performance is significant
- The fix is straightforward: validate message metadata before expensive cryptographic operations

### Citations

**File:** config/src/config/consensus_config.rs (L379-382)
```rust
            num_bounded_executor_tasks: 16,
            enable_pre_commit: true,
            max_pending_rounds_in_commit_vote_cache: 100,
            optimistic_sig_verification: true,
```

**File:** consensus/src/pipeline/buffer_manager.rs (L335-361)
```rust
    fn try_add_pending_commit_vote(&mut self, vote: CommitVote) -> bool {
        let block_id = vote.commit_info().id();
        let round = vote.commit_info().round();

        // Don't need to store commit vote if we have already committed up to that round
        if round <= self.highest_committed_round {
            true
        } else
        // Store the commit vote only if it is for one of the next 100 rounds.
        if round > self.highest_committed_round
            && self.highest_committed_round + self.max_pending_rounds_in_commit_vote_cache > round
        {
            self.pending_commit_votes
                .entry(round)
                .or_default()
                .insert(vote.author(), vote);
            true
        } else {
            debug!(
                round = round,
                highest_committed_round = self.highest_committed_round,
                block_id = block_id,
                "Received a commit vote not in the next 100 rounds, ignored."
            );
            false
        }
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L919-934)
```rust
        spawn_named!("buffer manager verification", async move {
            while let Some((sender, commit_msg)) = commit_msg_rx.next().await {
                let tx = verified_commit_msg_tx.clone();
                let epoch_state_clone = epoch_state.clone();
                bounded_executor
                    .spawn(async move {
                        match commit_msg.req.verify(sender, &epoch_state_clone.verifier) {
                            Ok(_) => {
                                let _ = tx.unbounded_send(commit_msg);
                            },
                            Err(e) => warn!("Invalid commit message: {}", e),
                        }
                    })
                    .await;
            }
        });
```

**File:** consensus/consensus-types/src/pipeline/commit_vote.rs (L103-113)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.author() == sender,
            "Commit vote author {:?} doesn't match with the sender {:?}",
            self.author(),
            sender
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify Commit Vote")
    }
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```
