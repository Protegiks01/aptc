# Audit Report

## Title
Insufficient Fork Detection Coverage in TransactionCorrectnessChecker Due to Single-Point Sampling

## Summary
The `TransactionCorrectnessChecker` only validates a single transaction at the midpoint of the shared version range between baseline and target nodes. While it correctly detects forks at or before this sampled version through accumulator root hash verification, it cannot detect forks that occur after `middle_shared_version`, creating a significant blind spot for recent chain divergence.

## Finding Description

The `TransactionCorrectnessChecker.check()` function computes a shared version window between the baseline and target nodes, then selects only the middle version for validation: [1](#0-0) 

The checker compares the `accumulator_root_hash` at `middle_shared_version` between both nodes. The accumulator root hash is a cryptographic commitment to all transactions up to that version, so **the checker correctly detects forks at or before `middle_shared_version`**. [2](#0-1) 

However, the critical issue is that **only this single version is checked**. The checker does not validate any other versions in the shared range, including more recent transactions approaching `latest_shared_version`.

**Attack Scenario:**
1. A malicious node operator maintains correct blockchain state up to version 5000
2. Baseline and target shared window is versions [1000, 10000], so `middle_shared_version = 5500`
3. The node forks at version 6000, serving incorrect transactions for versions 6000-10000
4. The TransactionCorrectnessChecker samples only version 5500, which is correct, and returns a passing score (100)
5. Users trusting the node-checker result query the node for recent data (e.g., version 9000)
6. Those users receive forked/incorrect transaction data and state

The accumulator proof verification system confirms this is a Merkle tree structure where each root hash depends on all previous transactions: [3](#0-2) 

This means while the checker has comprehensive validation **up to** `middle_shared_version`, it has zero validation **after** it.

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: Users querying the validated node receive incorrect blockchain data for recent transactions
- **Limited funds manipulation**: Applications making decisions based on forked state data could experience incorrect balance queries, failed transaction submissions, or wrong smart contract state reads

The Aptos Node Health Checker (NHC) is the official tool for validating node health and trustworthiness. A passing score implies the node is serving correct data, but this validation gap allows forked nodes to appear healthy while serving incorrect recent transactions. [4](#0-3) 

The success message misleadingly implies comprehensive validation: "your node is returning valid transaction data" - when in reality, only a single historical point was verified.

## Likelihood Explanation

**Likelihood: Medium-High**

- **Attack Complexity**: LOW - A malicious node operator simply needs to maintain correct state up to the sampled version, then fork afterward
- **Attacker Requirements**: Node operator control (not requiring validator privileges or consensus manipulation)
- **Detection Difficulty**: The attack is invisible to the node-checker by design
- **Impact Scope**: All users/applications trusting the node-checker result for this node would be affected

The shared version window can be large (thousands of versions), and only checking the midpoint leaves approximately 50% of the range unvalidated. For example, if the window is 10,000 versions, ~5,000 recent versions are never verified.

## Recommendation

Implement multi-point sampling across the shared version range to detect forks at multiple points in the blockchain history:

```rust
// Instead of checking only the middle version:
let middle_shared_version = (oldest_shared_version.saturating_add(latest_shared_version)) / 2;

// Check multiple sample points including recent versions:
let sample_count = 5; // Configurable
let sample_versions: Vec<u64> = (0..sample_count)
    .map(|i| {
        oldest_shared_version + 
        (latest_shared_version - oldest_shared_version) * i / (sample_count - 1)
    })
    .collect();

// Verify all sample versions, particularly emphasizing recent transactions
for version in sample_versions {
    let baseline_tx = Self::get_transaction_by_version(&baseline_client, version, "baseline").await?;
    let target_tx = Self::get_transaction_by_version(&target_client, version, "target").await?;
    
    if Self::unwrap_accumulator_root_hash(&baseline_tx)? != 
       Self::unwrap_accumulator_root_hash(&target_tx)? {
        return Ok(vec![Self::build_result(
            format!("Fork detected at version {}", version),
            0,
            format!("Accumulator root hash mismatch at version {}", version)
        )]);
    }
}
```

This ensures forks anywhere in the shared range are detected, particularly at recent versions where users are most likely to query.

## Proof of Concept

The vulnerability can be demonstrated by running the node-checker against a forked node:

```rust
// Scenario: Node forked at version 6000
// Baseline node: versions [0, 10000] all correct
// Target node: versions [0, 5999] correct, versions [6000, 10000] forked

// Setup:
// - oldest_shared_version = 1000
// - latest_shared_version = 10000
// - middle_shared_version = 5500

// Expected behavior (current):
// 1. Checker fetches version 5500 from both nodes
// 2. Accumulator root hashes match (fork hasn't occurred yet)
// 3. Returns score 100 (PASS)
// 4. User queries target node for version 9000
// 5. Receives forked transaction data

// Expected behavior (with fix):
// 1. Checker samples versions [1000, 3250, 5500, 7750, 10000]
// 2. Versions 1000, 3250, 5500 match
// 3. Version 7750: accumulator root hash mismatch detected
// 4. Returns score 0 (FAIL) with fork detection message
// 5. User does not trust this node
```

To reproduce:
1. Set up a baseline Aptos node synced to the canonical chain
2. Set up a target node that forks after version N
3. Configure N to be greater than `(oldest + latest) / 2`
4. Run TransactionCorrectnessChecker
5. Observe it returns a passing score despite the fork
6. Query a version > N from the target node
7. Verify the data differs from the baseline

**Notes**

To directly answer the security question: **Yes, the checker CAN detect forks earlier than middle_shared_version** through the accumulator root hash, which is a cryptographic commitment to all previous transactions. The accumulator is a Merkle tree where the root hash at any version depends on all transactions from genesis to that version, as implemented in the proof verification system. [5](#0-4) 

However, the checker **only samples a single point** in the version range, creating a blind spot for forks that occur after the sampled version. This is the exploitable vulnerability - not inadequate detection for pre-middle_shared_version forks (which works correctly), but complete absence of detection for post-middle_shared_version forks.

### Citations

**File:** ecosystem/node-checker/src/checker/transaction_correctness.rs (L134-167)
```rust
        // Get the oldest ledger version between the two nodes.
        let oldest_shared_version = max(oldest_baseline_version, oldest_target_version);

        // Get the least up to date latest ledger version between the two nodes.
        let latest_shared_version = min(latest_baseline_version, latest_target_version);

        // Ensure that there is a window between the oldest shared version and
        // latest shared version. If there is not, it will not be possible to
        // pull a transaction that both nodes have.
        if oldest_shared_version > latest_shared_version {
            return Ok(vec![Self::build_result(
                "Unable to pull transaction from both nodes".to_string(),
                0,
                format!(
                    "We were unable to find a ledger version window between \
                        the baseline and target nodes. The oldest and latest \
                        ledger versions on the baseline node are {} and {}. \
                        The oldest and latest ledger versions on the target \
                        node are {} and {}. This means your API cannot return \
                        a transaction that the baseline has for us to verify. \
                        Likely this means your node is too out of sync with \
                        the network, but it could also indicate an \
                        over-aggressive pruner.",
                    oldest_baseline_version,
                    latest_baseline_version,
                    oldest_target_version,
                    latest_target_version,
                ),
            )]);
        }

        // Select a version in the middle of shared oldest and latest version.
        let middle_shared_version =
            (oldest_shared_version.saturating_add(latest_shared_version)) / 2;
```

**File:** ecosystem/node-checker/src/checker/transaction_correctness.rs (L173-220)
```rust
        let middle_baseline_transaction = Self::get_transaction_by_version(
            &baseline_api_index_provider.client,
            middle_shared_version,
            "baseline",
        )
        .await?;
        let middle_baseline_accumulator_root_hash =
            Self::unwrap_accumulator_root_hash(&middle_baseline_transaction)?;

        let evaluation = match Self::get_transaction_by_version(
            &target_api_index_provider.client,
            middle_shared_version,
            "latest",
        )
        .await
        {
            Ok(middle_target_transaction) => {
                match Self::unwrap_accumulator_root_hash(&middle_target_transaction) {
                    Ok(middle_target_accumulator_root_hash) => {
                        if middle_baseline_accumulator_root_hash
                            == middle_target_accumulator_root_hash
                        {
                            Self::build_result(
                                "Target node produced valid recent transaction".to_string(),
                                100,
                                format!(
                                    "We were able to pull the same transaction (version: {}) \
                                    from both your node and the baseline node. Great! This \
                                    implies that your node is returning valid transaction data.",
                                    middle_shared_version,
                                ),
                            )
                        } else {
                            Self::build_result(
                                "Target node produced recent transaction, but it was invalid"
                                    .to_string(),
                                0,
                                format!(
                                    "We were able to pull the same transaction (version: {}) \
                                    from both your node and the baseline node. However, the \
                                    transaction was invalid compared to the baseline as the \
                                    accumulator root hash of the transaction ({}) was different \
                                    compared to the baseline ({}).",
                                    middle_shared_version,
                                    middle_target_accumulator_root_hash,
                                    middle_baseline_accumulator_root_hash,
                                ),
                            )
```

**File:** types/src/proof/definition.rs (L66-100)
```rust
    /// Verifies an element whose hash is `element_hash` and version is `element_version` exists in
    /// the accumulator whose root hash is `expected_root_hash` using the provided proof.
    pub fn verify(
        &self,
        expected_root_hash: HashValue,
        element_hash: HashValue,
        element_index: u64,
    ) -> Result<()> {
        ensure!(
            self.siblings.len() <= MAX_ACCUMULATOR_PROOF_DEPTH,
            "Accumulator proof has more than {} ({}) siblings.",
            MAX_ACCUMULATOR_PROOF_DEPTH,
            self.siblings.len()
        );

        let actual_root_hash = self
            .siblings
            .iter()
            .fold(
                (element_hash, element_index),
                // `index` denotes the index of the ancestor of the element at the current level.
                |(hash, index), sibling_hash| {
                    (
                        if index % 2 == 0 {
                            // the current node is a left child.
                            MerkleTreeInternalNode::<H>::new(hash, *sibling_hash).hash()
                        } else {
                            // the current node is a right child.
                            MerkleTreeInternalNode::<H>::new(*sibling_hash, hash).hash()
                        },
                        // The index of the parent at its level.
                        index / 2,
                    )
                },
            )
```

**File:** types/src/proof/mod.rs (L39-61)
```rust
/// Verifies that a given `transaction_info` exists in the ledger using provided proof.
fn verify_transaction_info(
    ledger_info: &LedgerInfo,
    transaction_version: Version,
    transaction_info: &TransactionInfo,
    ledger_info_to_transaction_info_proof: &TransactionAccumulatorProof,
) -> Result<()> {
    ensure!(
        transaction_version <= ledger_info.version(),
        "Transaction version {} is newer than LedgerInfo version {}.",
        transaction_version,
        ledger_info.version(),
    );

    let transaction_info_hash = transaction_info.hash();
    ledger_info_to_transaction_info_proof.verify(
        ledger_info.transaction_accumulator_hash(),
        transaction_info_hash,
        transaction_version,
    )?;

    Ok(())
}
```
