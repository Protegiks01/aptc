# Audit Report

## Title
Unauthenticated Remote Execution Commands Allow Coordinator Impersonation and Consensus Manipulation

## Summary
The remote executor service accepts execution commands from ANY network peer without authenticating the sender. An attacker can send arbitrary `ExecuteBlock` commands to executor shards, bypassing consensus and causing different shards to execute different transactions, breaking deterministic execution and consensus safety.

## Finding Description
The executor service (ExecutorService) is designed to receive execution commands from a coordinator via a network-based RPC system. However, the implementation contains a critical authentication flaw: [1](#0-0) 

The `ExecutorService` stores a `coordinator_address` during initialization, but this address is **never used to authenticate incoming commands**. Instead, it only creates an outbound channel TO the coordinator. [2](#0-1) 

The `RemoteCoordinatorClient` creates an inbound channel for messages with type `execute_command_{shard_id}` that accepts messages from ANY peer without verification. [3](#0-2) 

The GRPC server's `simple_msg_exchange` method retrieves the `remote_addr` but **never uses it for authentication**. It only checks if a handler is registered for the message type, then forwards the message without verifying the sender's identity. [4](#0-3) 

The `ShardedExecutorService` receives commands in a loop and executes them without any verification that they came from the legitimate coordinator.

**Attack Flow:**
1. Attacker discovers executor shard network addresses (e.g., through network scanning or configuration leaks)
2. Attacker crafts a malicious `RemoteExecutionRequest::ExecuteBlock` with arbitrary transactions
3. Attacker BCS-serializes the payload and sends it via gRPC to the executor service with message type `execute_command_{shard_id}`
4. Executor service receives and executes the malicious commands without authentication
5. Different shards execute different transaction sets, breaking consensus

This violates the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

## Impact Explanation
This is a **CRITICAL** severity vulnerability per Aptos Bug Bounty criteria:

- **Consensus/Safety violations**: An attacker can cause different shards to execute different transactions, leading to state divergence across the network. This breaks AptosBFT consensus safety guarantees.

- **Non-recoverable network partition**: If shards execute inconsistent transaction sets, validators will produce different state roots, causing a consensus failure that may require a hard fork to recover.

- **Loss of Funds**: An attacker could execute transactions that transfer funds, mint tokens, or manipulate account states on specific shards while other shards remain unaware, leading to double-spending or unauthorized asset transfers.

The vulnerability bypasses ALL consensus mechanisms by directly commanding the execution layer, making it exploitable even with < 1/3 Byzantine validators.

## Likelihood Explanation
**Likelihood: HIGH**

Requirements for exploitation:
- Network access to executor service endpoints (must know IP and port)
- Knowledge of message type format: `execute_command_{shard_id}` (deterministic and discoverable)
- Ability to construct BCS-serialized messages (straightforward with public Rust libraries) [5](#0-4) 

The executor service is designed to run as a network service with addresses passed as command-line arguments, indicating it's meant to be accessible over the network. There's no TLS, mTLS, or authentication mechanism in the network layer. [6](#0-5) 

The service binds to network addresses that could be external-facing, not just localhost.

## Recommendation
Implement mutual authentication between the coordinator and executor services:

1. **Add mTLS/TLS with certificate verification**: Configure the gRPC server to require TLS and verify client certificates against the expected coordinator's certificate.

2. **Add application-layer authentication**: Include a cryptographic signature in each message that the executor can verify:

```rust
// In RemoteExecutionRequest
pub struct RemoteExecutionRequest {
    ExecuteBlock(ExecuteBlockCommand),
    signature: Signature, // Signed by coordinator's private key
    timestamp: u64,
    nonce: u64,
}

// In RemoteCoordinatorClient::receive_execute_command
fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
    match self.command_rx.recv() {
        Ok(message) => {
            let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
            
            // VERIFY SIGNATURE AGAINST KNOWN COORDINATOR PUBLIC KEY
            if !self.verify_coordinator_signature(&request) {
                error!("Received command from unauthorized sender");
                return ExecutorShardCommand::Stop;
            }
            
            // Check timestamp/nonce to prevent replay attacks
            if !self.verify_freshness(&request) {
                error!("Received replayed or stale command");
                return ExecutorShardCommand::Stop;
            }
            
            // Process authenticated command...
        }
    }
}
```

3. **Network isolation**: Deploy executor services on isolated network segments accessible only to the coordinator.

## Proof of Concept

```rust
// Malicious client that impersonates the coordinator
use aptos_secure_net::network_controller::{Message, NetworkController};
use aptos_executor_service::{RemoteExecutionRequest, ExecuteBlockCommand};
use std::net::SocketAddr;

fn exploit_executor_service(
    malicious_coordinator_addr: SocketAddr,
    target_executor_addr: SocketAddr,
    shard_id: usize,
) {
    // Create a network controller for the attacker
    let mut controller = NetworkController::new(
        "attacker".to_string(),
        malicious_coordinator_addr,
        5000,
    );
    
    // Create outbound channel to target executor
    let message_type = format!("execute_command_{}", shard_id);
    let command_tx = controller.create_outbound_channel(
        target_executor_addr,
        message_type,
    );
    
    controller.start();
    
    // Craft malicious execution request with arbitrary transactions
    let malicious_command = RemoteExecutionRequest::ExecuteBlock(
        ExecuteBlockCommand {
            sub_blocks: /* crafted malicious transactions */,
            concurrency_level: 1,
            onchain_config: /* attacker-controlled config */,
        }
    );
    
    // Serialize and send - NO AUTHENTICATION REQUIRED
    let payload = bcs::to_bytes(&malicious_command).unwrap();
    command_tx.send(Message::new(payload)).unwrap();
    
    // The executor will execute the malicious command without verification!
}
```

**Notes:**
- This vulnerability exists because the `coordinator_address` stored in `ExecutorService` is used only for outbound communication, not for inbound authentication
- The GRPC server accepts messages from any peer that knows the correct message type format
- No TLS, certificate validation, or cryptographic authentication is implemented
- The message type format is deterministic and easily guessable: `execute_command_{shard_id}`
- This breaks the fundamental security assumption that only the legitimate coordinator can send execution commands to shards

### Citations

**File:** execution/executor-service/src/remote_executor_service.rs (L22-55)
```rust
    pub fn new(
        shard_id: ShardId,
        num_shards: usize,
        num_threads: usize,
        self_address: SocketAddr,
        coordinator_address: SocketAddr,
        remote_shard_addresses: Vec<SocketAddr>,
    ) -> Self {
        let service_name = format!("executor_service-{}", shard_id);
        let mut controller = NetworkController::new(service_name, self_address, 5000);
        let coordinator_client = Arc::new(RemoteCoordinatorClient::new(
            shard_id,
            &mut controller,
            coordinator_address,
        ));
        let cross_shard_client = Arc::new(RemoteCrossShardClient::new(
            &mut controller,
            remote_shard_addresses,
        ));

        let executor_service = Arc::new(ShardedExecutorService::new(
            shard_id,
            num_shards,
            num_threads,
            coordinator_client,
            cross_shard_client,
        ));

        Self {
            shard_id,
            controller,
            executor_service,
        }
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L27-47)
```rust
    pub fn new(
        shard_id: ShardId,
        controller: &mut NetworkController,
        coordinator_address: SocketAddr,
    ) -> Self {
        let execute_command_type = format!("execute_command_{}", shard_id);
        let execute_result_type = format!("execute_result_{}", shard_id);
        let command_rx = controller.create_inbound_channel(execute_command_type);
        let result_tx =
            controller.create_outbound_channel(coordinator_address, execute_result_type);

        let state_view_client =
            RemoteStateViewClient::new(shard_id, controller, coordinator_address);

        Self {
            state_view_client: Arc::new(state_view_client),
            command_rx,
            result_tx,
            shard_id,
        }
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L215-260)
```rust
    pub fn start(&self) {
        trace!(
            "Shard starting, shard_id={}, num_shards={}.",
            self.shard_id,
            self.num_shards
        );
        let mut num_txns = 0;
        loop {
            let command = self.coordinator_client.receive_execute_command();
            match command {
                ExecutorShardCommand::ExecuteSubBlocks(
                    state_view,
                    transactions,
                    concurrency_level_per_shard,
                    onchain_config,
                ) => {
                    num_txns += transactions.num_txns();
                    trace!(
                        "Shard {} received ExecuteBlock command of block size {} ",
                        self.shard_id,
                        num_txns
                    );
                    let exe_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "execute_block"]);
                    let ret = self.execute_block(
                        transactions,
                        state_view.as_ref(),
                        BlockExecutorConfig {
                            local: BlockExecutorLocalConfig::default_with_concurrency_level(
                                concurrency_level_per_shard,
                            ),
                            onchain: onchain_config,
                        },
                    );
                    drop(state_view);
                    drop(exe_timer);

                    let _result_tx_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "result_tx"]);
                    self.coordinator_client.send_execution_result(ret);
                },
                ExecutorShardCommand::Stop => {
                    break;
                },
            }
        }
```

**File:** execution/executor-service/src/main.rs (L9-25)
```rust
#[derive(Debug, Parser)]
struct Args {
    #[clap(long, default_value_t = 8)]
    pub num_executor_threads: usize,

    #[clap(long)]
    pub shard_id: usize,

    #[clap(long)]
    pub num_shards: usize,

    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
}
```

**File:** execution/executor-service/src/process_executor_service.rs (L17-45)
```rust
    pub fn new(
        shard_id: ShardId,
        num_shards: usize,
        num_threads: usize,
        coordinator_address: SocketAddr,
        remote_shard_addresses: Vec<SocketAddr>,
    ) -> Self {
        let self_address = remote_shard_addresses[shard_id];
        info!(
            "Starting process remote executor service on {}; coordinator address: {}, other shard addresses: {:?}; num threads: {}",
            self_address, coordinator_address, remote_shard_addresses, num_threads
        );
        aptos_node_resource_metrics::register_node_metrics_collector(None);
        let _mp = MetricsPusher::start_for_local_run(
            &("remote-executor-service-".to_owned() + &shard_id.to_string()),
        );

        AptosVM::set_concurrency_level_once(num_threads);
        let mut executor_service = ExecutorService::new(
            shard_id,
            num_shards,
            num_threads,
            self_address,
            coordinator_address,
            remote_shard_addresses,
        );
        executor_service.start();
        Self { executor_service }
    }
```
