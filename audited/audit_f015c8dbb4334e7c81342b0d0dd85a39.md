# Audit Report

## Title
Integer Overflow in Gas Validation Lacks Protection Against Malicious Governance Gas Schedule Updates

## Summary
The gas validation code in `aptos-move/aptos-vm/src/gas.rs` performs unchecked multiplication of `gas_unit_price * max_gas_amount` without overflow protection. While current governance-set parameters are safe, the gas schedule update mechanism lacks validation to prevent overflow-inducing parameter values, creating a potential denial-of-service vulnerability if governance mistakenly or maliciously sets incompatible values.

## Finding Description
The vulnerability exists at the intersection of two systems:

1. **Missing Governance Validation**: The gas schedule update functions in `aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move` contain TODO comments indicating that consistency checks should be implemented but are not. [1](#0-0) 

2. **Unchecked Arithmetic in Validation**: The `check_gas` function performs unprotected u64 multiplication when validating account creation gas requirements. [2](#0-1) 

The code comment explicitly states the intended invariant: "We want this number and `MAX_PRICE_PER_GAS_UNIT` to always satisfy the inequality that MAXIMUM_NUMBER_OF_GAS_UNITS * MAX_PRICE_PER_GAS_UNIT < min(u64::MAX, GasUnits<GasCarrier>::MAX)" [3](#0-2) 

However, this invariant is **not enforced** when governance updates the gas schedule via `set_for_next_epoch` or `set_for_next_epoch_check_hash`. [4](#0-3) 

**Attack Scenario:**
1. Governance proposes and approves a gas schedule update with `max_price_per_gas_unit = 10^19` and `maximum_number_of_gas_units = 10^3`
2. Product exceeds u64::MAX (10^22 > 1.8Ã—10^19)
3. Users submit transactions with these maximum values
4. In release mode, the multiplication wraps around to a small value
5. The check `if actual < expected` incorrectly rejects valid transactions
6. New account creation becomes impossible

**Contrast with Move Code**: The Move epilogue properly protects against this by casting to u128 before multiplication. [5](#0-4) 

## Impact Explanation
**High Severity** - This qualifies as "Significant protocol violations" per the bug bounty program. While not directly exploitable by unprivileged attackers, it represents a critical missing validation that could result in:
- Complete denial of service for new account creation
- Protocol degradation requiring emergency governance intervention
- Violation of the "Resource Limits" invariant

The impact is systemic but requires governance participation, placing it in the High rather than Critical category.

## Likelihood Explanation
**Medium to Low Likelihood** - Exploitation requires:
- Governance proposal and approval (trusted actors)
- Either honest mistake or coordinated malicious action
- No automated validation to catch the error

However, the TODO comments indicate this is a **known gap** in validation, increasing the likelihood that it could be triggered accidentally during routine gas schedule updates.

## Recommendation
Implement the missing validation in `gas_schedule.move`:

```rust
// In set_for_next_epoch and set_for_next_epoch_check_hash:
let params = parse_gas_params(&new_gas_schedule);
let max_price = params.max_price_per_gas_unit;
let max_units = params.maximum_number_of_gas_units;

// Validate overflow invariant using u128 arithmetic
assert!(
    (max_price as u128) * (max_units as u128) < (u64::MAX as u128),
    error::invalid_argument(EINVALID_GAS_SCHEDULE_OVERFLOW_RISK)
);
```

Additionally, add overflow protection to the Rust validation code:

```rust
let actual = gas_unit_price.checked_mul(max_gas_amount)
    .ok_or_else(|| VMStatus::error(StatusCode::ARITHMETIC_ERROR, None))?;
```

## Proof of Concept

```rust
// In aptos-move/e2e-tests/
#[test]
#[should_panic(expected = "overflow")]
fn test_gas_schedule_overflow_vulnerability() {
    let mut harness = MoveHarness::new();
    let mut gas_schedule = harness.get_gas_schedule();
    
    // Set dangerous parameters that violate overflow invariant
    for (name, val) in gas_schedule.entries.iter_mut() {
        if name == "txn.max_price_per_gas_unit" {
            *val = u64::MAX / 2; // Large but not MAX
        }
        if name == "txn.maximum_number_of_gas_units" {
            *val = 1000; // Causes overflow when multiplied
        }
    }
    
    // This should be rejected but currently isn't
    harness.executor.exec(
        "gas_schedule",
        "set_for_next_epoch",
        vec![],
        vec![
            MoveValue::Signer(CORE_CODE_ADDRESS).simple_serialize().unwrap(),
            bcs::to_bytes(&bcs::to_bytes(&gas_schedule).unwrap()).unwrap(),
        ],
    );
    
    // Apply the update
    harness.executor.exec("reconfiguration_with_dkg", "finish", vec![], vec![
        MoveValue::Signer(CORE_CODE_ADDRESS).simple_serialize().unwrap(),
    ]);
    
    // Now attempt account creation transaction - will overflow
    let txn = create_account_txn(
        /* gas_unit_price */ u64::MAX / 2,
        /* max_gas_amount */ 1000,
    );
    
    // This will trigger overflow in gas.rs line 233
    harness.run_transaction(txn);
}
```

## Notes

The vulnerability represents a **defense-in-depth failure** rather than a directly exploitable attack. The current production parameters (max_price_per_gas_unit = 10 billion, maximum_number_of_gas_units = 2 million) are safe. [6](#0-5) [7](#0-6) 

However, the lack of validation in governance update paths creates unnecessary risk. The Rosetta API also contains a similar unchecked multiplication. [8](#0-7)

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-48)
```text
        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L213-233)
```rust
    let gas_unit_price: u64 = txn_metadata.gas_unit_price().into();
    if crate::aptos_vm::should_create_account_resource(
        txn_metadata,
        features,
        resolver,
        module_storage,
    )? && (gas_unit_price != 0 || !features.is_default_account_resource_enabled())
    {
        let max_gas_amount: u64 = txn_metadata.max_gas_amount().into();
        let pricing = DiskSpacePricing::new(gas_feature_version, features);
        let storage_fee_per_account_create: u64 = pricing
            .hack_estimated_fee_for_account_creation(txn_gas_params)
            .into();

        let expected = gas_unit_price * 10
            + if features.is_new_account_default_to_fa_store() {
                1
            } else {
                2
            } * storage_fee_per_account_create;
        let actual = gas_unit_price * max_gas_amount;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L52-53)
```rust
        // `MAX_PRICE_PER_GAS_UNIT` to always satisfy the inequality that
        // MAXIMUM_NUMBER_OF_GAS_UNITS * MAX_PRICE_PER_GAS_UNIT < min(u64::MAX, GasUnits<GasCarrier>::MAX)
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L68-71)
```rust
            max_price_per_gas_unit: FeePerGasUnit,
            "max_price_per_gas_unit",
            10_000_000_000
        ],
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L599-603)
```text
        assert!(
            (txn_gas_price as u128) * (gas_used as u128) <= MAX_U64,
            error::out_of_range(EOUT_OF_GAS)
        );
        let transaction_fee_amount = txn_gas_price * gas_used;
```

**File:** config/global-constants/src/lib.rs (L28-31)
```rust
#[cfg(any(test, feature = "testing"))]
pub const MAX_GAS_AMOUNT: u64 = 100_000_000;
#[cfg(not(any(test, feature = "testing")))]
pub const MAX_GAS_AMOUNT: u64 = 2_000_000;
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L120-125)
```rust
    pub fn suggested_gas_fee(gas_unit_price: u64, max_gas_amount: u64) -> Amount {
        Amount {
            value: (gas_unit_price * max_gas_amount).to_string(),
            currency: native_coin(),
        }
    }
```
