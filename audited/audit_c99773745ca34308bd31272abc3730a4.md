# Audit Report

## Title
Missing Validation of Sharded Output Length Leading to Silent Transaction Omission and Consensus Divergence

## Summary
The `ShardedBlockExecutor::execute_block()` coordinator fails to validate that the number of shard results returned by `ExecutorClient::execute_block()` matches the value returned by `ExecutorClient::num_shards()`. This allows a malicious or buggy ExecutorClient implementation to return fewer shards than expected, causing transactions assigned to missing shards to be silently dropped from execution, resulting in consensus failure across validators.

## Finding Description

The vulnerability exists in the result aggregation logic of the sharded block executor coordinator. The coordinator queries `num_shards()` to determine the expected shard count and uses this value to size internal data structures, but never validates that the actual `sharded_output` returned from execution contains the expected number of shards. [1](#0-0) 

The coordinator retrieves `num_executor_shards` from the executor client and validates it matches the input partitioning. However, when aggregating results: [2](#0-1) 

The code creates `ordered_results` with size `num_executor_shards * num_rounds` based on the value from `num_shards()`, but then iterates using `sharded_output.into_iter().enumerate()` which uses the **actual length** of the returned vector. If these values don't match:

**Attack Scenario - Fewer Shards Returned (M < N):**
- Coordinator calls `num_shards()` → Returns N = 4
- Transactions partitioned into 4 shards
- Assertion passes: 4 == 4 ✓  
- Malicious `execute_block()` returns only M = 2 shard results
- `ordered_results` sized for 4 shards × 3 rounds = 12 slots
- Loop iterates only 2 times (M=2), filling slots for shards 0-1
- Slots for shards 2-3 remain as empty vectors
- Transactions from shards 2-3 are **silently omitted** from final output [3](#0-2) 

The empty vectors are extended into the final result, contributing nothing, causing transactions to vanish without error.

This breaks the **Deterministic Execution** invariant: validators using different ExecutorClient implementations (or different versions with bugs) will produce different transaction outputs for the same block, leading to divergent state roots and consensus failure. [4](#0-3) 

The trait interface provides no guarantees about the consistency between `num_shards()` return values and the structure of `ShardedExecutionOutput`. While the provided implementations (LocalExecutorClient, RemoteExecutorClient) maintain this invariant internally, the interface doesn't enforce it.

## Impact Explanation

**Severity: Critical** (Consensus/Safety Violation)

If exploited, this vulnerability causes:

1. **Missing Transaction Execution**: Transactions assigned to missing shards are never executed, violating completeness guarantees
2. **Consensus Divergence**: Different validators produce different state roots for the same block, breaking consensus safety
3. **Non-Deterministic State Transitions**: Network cannot reach agreement on block validity
4. **Potential Network Partition**: Validators may permanently fork if they commit divergent states

This qualifies as Critical under Aptos bug bounty criteria: "Consensus/Safety violations" that break the fundamental guarantee that all honest validators must produce identical state roots for identical input blocks.

## Likelihood Explanation

**Likelihood: Low (requires privileged access or implementation bug)**

Direct exploitation requires either:
1. **Malicious Validator Operator** - Modifying node software to inject malicious ExecutorClient (insider threat)
2. **Buggy Implementation** - A legitimate ExecutorClient implementation with a bug that returns inconsistent shard counts
3. **Future Vulnerability** - Changes to allow dynamic ExecutorClient selection without proper validation

Current production code uses hardcoded LocalExecutorClient: [5](#0-4) 

However, this remains a **design flaw** violating defense-in-depth principles. The coordinator should validate untrusted boundaries even from "trusted" components, as:
- Future refactoring might introduce configurability
- Bugs in legitimate implementations could trigger the issue  
- The interface design doesn't enforce safety invariants

## Recommendation

Add explicit validation that `sharded_output.len()` matches `num_executor_shards` immediately after receiving results:

```rust
pub fn execute_block(
    &self,
    state_view: Arc<S>,
    transactions: PartitionedTransactions,
    concurrency_level_per_shard: usize,
    onchain_config: BlockExecutorConfigFromOnchain,
) -> Result<Vec<TransactionOutput>, VMStatus> {
    let _timer = SHARDED_BLOCK_EXECUTION_SECONDS.start_timer();
    let num_executor_shards = self.executor_client.num_shards();
    NUM_EXECUTOR_SHARDS.set(num_executor_shards as i64);
    assert_eq!(
        num_executor_shards,
        transactions.num_shards(),
        "Block must be partitioned into {} sub-blocks",
        num_executor_shards
    );
    let (sharded_output, global_output) = self
        .executor_client
        .execute_block(
            state_view,
            transactions,
            concurrency_level_per_shard,
            onchain_config,
        )?
        .into_inner();
    
    // ADD THIS VALIDATION
    assert_eq!(
        sharded_output.len(),
        num_executor_shards,
        "ExecutorClient returned {} shards but num_shards() reported {}. This indicates a buggy or malicious ExecutorClient implementation.",
        sharded_output.len(),
        num_executor_shards
    );
    
    info!("ShardedBlockExecutor Received all results");
    let _aggregation_timer = SHARDED_EXECUTION_RESULT_AGGREGATION_SECONDS.start_timer();
    let num_rounds = sharded_output[0].len();
    
    // ADD THIS VALIDATION FOR CONSISTENCY
    for (shard_id, shard_results) in sharded_output.iter().enumerate() {
        assert_eq!(
            shard_results.len(),
            num_rounds,
            "Shard {} returned {} rounds but expected {}",
            shard_id,
            shard_results.len(),
            num_rounds
        );
    }
    
    // ... rest of aggregation logic
}
```

## Proof of Concept

```rust
// File: aptos-move/aptos-vm/tests/malicious_executor_client_poc.rs

use aptos_types::{
    block_executor::{
        config::BlockExecutorConfigFromOnchain,
        partitioner::PartitionedTransactions,
    },
    state_store::StateView,
    transaction::TransactionOutput,
};
use aptos_vm::sharded_block_executor::{
    executor_client::{ExecutorClient, ShardedExecutionOutput},
    ShardedBlockExecutor,
};
use move_core_types::vm_status::VMStatus;
use std::sync::Arc;

// Malicious ExecutorClient that reports 4 shards but only returns 2
struct MaliciousExecutorClient;

impl<S: StateView + Sync + Send + 'static> ExecutorClient<S> for MaliciousExecutorClient {
    fn num_shards(&self) -> usize {
        4 // Claims 4 shards
    }

    fn execute_block(
        &self,
        _state_view: Arc<S>,
        _transactions: PartitionedTransactions,
        _concurrency_level_per_shard: usize,
        _onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<ShardedExecutionOutput, VMStatus> {
        // Returns only 2 shards worth of results
        let sharded_output = vec![
            vec![vec![]], // Shard 0, Round 0
            vec![vec![]], // Shard 1, Round 0
            // Shards 2 and 3 are MISSING - their transactions will be dropped!
        ];
        Ok(ShardedExecutionOutput::new(sharded_output, vec![]))
    }

    fn shutdown(&mut self) {}
}

#[test]
fn test_missing_shard_results_vulnerability() {
    // Create coordinator with malicious client
    let malicious_client = MaliciousExecutorClient;
    let coordinator = ShardedBlockExecutor::new(malicious_client);
    
    // Partition transactions for 4 shards (as reported by num_shards())
    let partitioned_txns = create_test_partitioned_transactions(4);
    let state_view = Arc::new(EmptyStateView);
    
    // Execute block - transactions from shards 2-3 will be silently dropped
    let result = coordinator.execute_block(
        state_view,
        partitioned_txns,
        4,
        BlockExecutorConfigFromOnchain::default(),
    );
    
    // Without validation, this succeeds but returns incomplete results
    assert!(result.is_ok());
    let outputs = result.unwrap();
    
    // Transactions that should have been executed are missing!
    // This demonstrates the vulnerability
}
```

## Notes

While current production implementations (LocalExecutorClient, RemoteExecutorClient) maintain the invariant internally by design, the **interface contract lacks enforcement**. This violates secure coding principles and creates a fragile dependency on implementation correctness. The coordinator must validate structural invariants at trust boundaries, treating even "trusted" components with defensive programming practices to prevent future bugs or malicious modifications from causing consensus failures.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L78-85)
```rust
        let num_executor_shards = self.executor_client.num_shards();
        NUM_EXECUTOR_SHARDS.set(num_executor_shards as i64);
        assert_eq!(
            num_executor_shards,
            transactions.num_shards(),
            "Block must be partitioned into {} sub-blocks",
            num_executor_shards
        );
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L98-106)
```rust
        let num_rounds = sharded_output[0].len();
        let mut aggregated_results = vec![];
        let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds];
        // Append the output from individual shards in the round order
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                ordered_results[round * num_executor_shards + shard_id] = result;
            }
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L108-115)
```rust
        for result in ordered_results.into_iter() {
            aggregated_results.extend(result);
        }

        // Lastly append the global output
        aggregated_results.extend(global_output);

        Ok(aggregated_results)
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/executor_client.rs (L35-50)
```rust
// Interface to communicate from the block executor coordinator to the executor shards.
pub trait ExecutorClient<S: StateView + Sync + Send + 'static>: Send + Sync {
    fn num_shards(&self) -> usize;

    // A blocking call that executes the transactions in the block. It returns the execution results from each shard
    // and in the round order and also the global output.
    fn execute_block(
        &self,
        state_view: Arc<S>,
        transactions: PartitionedTransactions,
        concurrency_level_per_shard: usize,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<ShardedExecutionOutput, VMStatus>;

    fn shutdown(&mut self);
}
```

**File:** execution/executor-service/src/local_executor_helper.rs (L14-21)
```rust
pub static SHARDED_BLOCK_EXECUTOR: Lazy<
    Arc<Mutex<ShardedBlockExecutor<CachedStateView, LocalExecutorClient<CachedStateView>>>>,
> = Lazy::new(|| {
    info!("LOCAL_SHARDED_BLOCK_EXECUTOR created");
    Arc::new(Mutex::new(
        LocalExecutorClient::create_local_sharded_block_executor(AptosVM::get_num_shards(), None),
    ))
});
```
