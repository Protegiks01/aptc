# Audit Report

## Title
Resource Group Metadata Upgrade Attack: Permanent Fund Freezing Through Storage Location Mismatch

## Summary
When the `SAFER_RESOURCE_GROUPS` feature flag is disabled, malicious module publishers can add `resource_group_member` or `resource_group` attributes to existing structs during module upgrades, causing all previously deployed instances to become permanently inaccessible due to a storage location mismatch. This results in permanent freezing of user funds and potential consensus violations.

## Finding Description

The vulnerability exists in the resource group validation logic where the `SAFER_RESOURCE_GROUPS` feature flag controls whether adding resource group attributes to existing structs is permitted. [1](#0-0) 

When this flag is disabled, the function returns early, bypassing critical validation checks that prevent adding resource group metadata to existing structs: [2](#0-1) 

The attack works through a storage location mismatch:

1. **Initial State**: A module publishes a struct `S` without resource group membership. Users deploy instances stored at `StateKey::resource(address, S)`.

2. **Metadata Change**: When `SAFER_RESOURCE_GROUPS` is disabled, the publisher upgrades the module to add `#[resource_group_member(group = G)]` to struct `S`.

3. **Storage Location Shift**: After upgrade, the resource resolution logic checks metadata to determine storage location: [3](#0-2) 

4. **Data Loss**: Reads now look for resources at `StateKey::resource_group(address, G)` instead of the original `StateKey::resource(address, S)`, making all pre-upgrade instances permanently inaccessible: [4](#0-3) [5](#0-4) 

These create fundamentally different storage paths - resources stored at the old location become unreachable after the metadata change.

The test suite explicitly demonstrates this "unsafe" behavior is permitted when the flag is disabled: [6](#0-5) 

## Impact Explanation

**Critical Severity** - This vulnerability enables **permanent freezing of funds** requiring a hardfork to recover:

1. **Permanent Data Loss**: All user-owned instances of the affected struct become permanently inaccessible through normal VM operations
2. **Fund Freezing**: If structs contain tokens, coins, or other value-bearing resources, those funds are permanently locked
3. **Consensus Violations**: If validators process the upgrade transaction in different blocks, they will read different storage locations, breaking deterministic execution (Invariant #1)
4. **State Inconsistency**: The blockchain state becomes corrupted with orphaned resources at old storage locations (Invariant #4)
5. **Mass User Impact**: A single malicious module upgrade affects ALL users who deployed instances before the upgrade

This meets the Critical severity criteria: "Permanent freezing of funds (requires hardfork)" from the Aptos bug bounty program.

## Likelihood Explanation

**Medium Likelihood** (conditional on governance action):

**Prerequisites:**
- Governance must disable `SAFER_RESOURCE_GROUPS` through the on-chain governance process
- Flag is enabled by default: [7](#0-6) 

**Exploitation Path:**
1. Attacker deploys module with innocent-looking struct
2. Users interact with the module, storing resources
3. Governance disables `SAFER_RESOURCE_GROUPS` (e.g., for compatibility reasons)
4. Attacker immediately upgrades module to add resource group metadata
5. All user funds in that struct become permanently frozen

**Why This Matters:**
- Governance may disable the flag for legitimate reasons (backward compatibility, emergency fixes)
- Once disabled, ANY module publisher can exploit this
- Users cannot detect or prevent the attack
- Damage is permanent and affects all pre-upgrade instances

## Recommendation

**Never disable the `SAFER_RESOURCE_GROUPS` feature flag** under any circumstances. If compatibility with unsafe upgrades is needed, implement a migration mechanism:

```rust
// In resource_groups.rs, enforce the safety check unconditionally:
// Remove lines 167-169 completely, always execute validation:

// Always validate - never allow unsafe resource group upgrades
for group in new_groups.keys() {
    if structs.remove(group) {
        metadata_validation_err("Invalid addition of resource_group attribute")?;
    }
}

for member in new_members.keys() {
    if structs.remove(member) {
        metadata_validation_err("Invalid addition of resource_group_member attribute")?;
    }
}
```

**Additional Protections:**
1. Document the severe consequences of disabling this flag in governance proposals
2. Add runtime checks that refuse to execute modules with metadata changes affecting existing structs
3. Implement a storage migration mechanism that automatically moves resources to new locations when metadata changes are detected
4. Add warnings in the module publishing flow when metadata changes affect existing structs

## Proof of Concept

```move
// Module V1 - Initial deployment
module 0xAttacker::VulnerableToken {
    struct TokenStore has key {
        balance: u64,
    }
    
    public fun store_tokens(account: &signer, amount: u64) {
        move_to(account, TokenStore { balance: amount });
    }
    
    public fun get_balance(addr: address): u64 acquires TokenStore {
        borrow_global<TokenStore>(addr).balance
    }
}

// Users call store_tokens, storing TokenStore at:
// StateKey::resource(user_address, TokenStore)

// --- Governance disables SAFER_RESOURCE_GROUPS ---

// Module V2 - Malicious upgrade (ONLY possible with flag disabled)
module 0xAttacker::VulnerableToken {
    #[resource_group_member(group = 0xAttacker::VulnerableToken::TokenGroup)]
    struct TokenStore has key {
        balance: u64,
    }
    
    #[resource_group(scope = address)]
    struct TokenGroup {}
    
    // This now looks at StateKey::resource_group(user_address, TokenGroup)
    public fun get_balance(addr: address): u64 acquires TokenStore {
        borrow_global<TokenStore>(addr).balance  // FAILS - wrong location!
    }
}

// Result: All user funds in TokenStore become permanently inaccessible
// They remain at the old storage location but VM now looks elsewhere
```

**Test Reproduction:**
Adapt the existing test case to demonstrate fund loss: [8](#0-7) 

Modify to show that resources stored before the upgrade cannot be read after adding the `resource_group` attribute.

---

## Notes

This vulnerability is **conditional** - it only becomes exploitable when governance explicitly disables `SAFER_RESOURCE_GROUPS`. However, the severity of the impact (permanent fund freezing affecting all users) and the impossibility of recovery without a hardfork makes this a Critical-severity finding. The feature flag exists precisely to prevent this attack, and governance must be warned that disabling it enables permanent fund theft through metadata manipulation.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L167-169)
```rust
    if !features.is_enabled(FeatureFlag::SAFER_RESOURCE_GROUPS) {
        return Ok((new_groups, new_members));
    }
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L176-186)
```rust
    for group in new_groups.keys() {
        if structs.remove(group) {
            metadata_validation_err("Invalid addition of resource_group attribute")?;
        }
    }

    for member in new_members.keys() {
        if structs.remove(member) {
            metadata_validation_err("Invalid addition of resource_group_member attribute")?;
        }
    }
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L105-110)
```rust
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;
```

**File:** types/src/state_store/state_key/mod.rs (L140-150)
```rust
        Ok(Self(REGISTRY.resource(struct_tag, address).get_or_add(
            struct_tag,
            address,
            || {
                Ok(StateKeyInner::AccessPath(AccessPath::resource_access_path(
                    *address,
                    struct_tag.clone(),
                )?))
            },
        )?))
    }
```

**File:** types/src/state_store/state_key/mod.rs (L160-171)
```rust
    pub fn resource_group(address: &AccountAddress, struct_tag: &StructTag) -> Self {
        Self(
            REGISTRY
                .resource_group(struct_tag, address)
                .get_or_add(struct_tag, address, || {
                    Ok(StateKeyInner::AccessPath(
                        AccessPath::resource_group_access_path(*address, struct_tag.clone()),
                    ))
                })
                .expect("only possible error is resource path serialization"),
        )
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/resource_groups.rs (L474-508)
```rust
fn verify_unsafe_resource_group_member_upgrades() {
    let mut h = MoveHarness::new_with_features(vec![], vec![FeatureFlag::SAFER_RESOURCE_GROUPS]);
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    // Initial code
    let source = r#"
        module 0xf00d::M {
            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);

    // Incompatible addition of ResourceGroupMember
    let source = r#"
        module 0xf00d::M {
            #[resource_group_member(group = 0xf00d::M::ResourceGroup)]
            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);
}
```

**File:** aptos-move/e2e-move-tests/src/tests/resource_groups.rs (L592-626)
```rust
fn verify_unsafe_resource_group_upgrades() {
    let mut h = MoveHarness::new_with_features(vec![], vec![FeatureFlag::SAFER_RESOURCE_GROUPS]);
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    // Initial code
    let source = r#"
        module 0xf00d::M {
            #[resource_group(scope = address)]
            struct ResourceGroup { }

            struct NotResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);

    // Incompatible promotion of ResourceGroup
    let source = r#"
        module 0xf00d::M {
            #[resource_group(scope = address)]
            struct ResourceGroup { }

            #[resource_group(scope = address)]
            struct NotResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L205-205)
```rust
            FeatureFlag::SAFER_RESOURCE_GROUPS,
```
