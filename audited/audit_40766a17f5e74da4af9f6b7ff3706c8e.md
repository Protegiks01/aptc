# Audit Report

## Title
Consensus Observer Accepts Unverified Future Epoch Commit Decisions Leading to Network Partition

## Summary
The consensus observer fails to validate commit decisions for future epochs, allowing an attacker to send a malicious `CommitDecision` message with invalid signatures or a manipulated validator set. This causes the observer to update its root to an unverified state and partition itself from the legitimate network, resulting in denial of service for applications relying on the observer.

## Finding Description
The vulnerability exists in the consensus observer's commit decision processing logic. When a `CommitDecision` message is received, the code only verifies signatures for commit decisions matching the **current epoch**. For commit decisions in **future epochs**, no cryptographic verification is performed, yet the system proceeds to accept and act on the unverified data. [1](#0-0) 

The verification only occurs when `commit_epoch == epoch_state.epoch`. However, if the commit is for a future epoch, the code skips verification entirely and proceeds to lines 500-527: [2](#0-1) 

A TODO comment explicitly acknowledges this security gap: [3](#0-2) 

At line 522, the code calls `update_blocks_for_state_sync_commit()` which unconditionally updates the observer's root ledger info without any validation: [4](#0-3) 

The root update occurs through `update_root()` at line 282, which performs no validation: [5](#0-4) 

**Attack Path:**
1. Attacker crafts a `CommitDecision` message for epoch N+1 (one epoch ahead of current)
2. The message contains a `LedgerInfoWithSignatures` with invalid signatures or a manipulated validator set
3. Observer receives the message via network
4. Observer checks epoch and finds it's for the future (line 503: `commit_epoch > last_block.epoch()`)
5. Observer **skips signature verification** entirely
6. Observer calls `update_blocks_for_state_sync_commit()` which updates the root to the unverified ledger info
7. Observer's `get_last_ordered_block()`, `get_highest_committed_epoch_round()` now return fake epoch/round
8. Observer rejects all legitimate messages from the real network (wrong epoch)
9. Observer is partitioned from the network

This breaks the **State Consistency** invariant - the observer's root state no longer reflects legitimate committed state from the blockchain.

## Impact Explanation
This vulnerability allows an unprivileged network attacker to cause **denial of service** for consensus observer nodes by forcing them into a network partition state. While this affects observer nodes rather than validators, it has significant impact:

1. **API Service Disruption**: Observer nodes are typically used by full node APIs, indexers, and data services. A partitioned observer cannot serve accurate blockchain data.

2. **Network Partition**: The observer permanently rejects messages from the legitimate network because it believes it's in a different epoch. Recovery requires manual intervention (restart).

3. **No Privileged Access Required**: Any network peer can send the malicious `CommitDecision` message - no validator access or stake is required.

According to Aptos bug bounty criteria, this qualifies as **High Severity**: "API crashes" and "Significant protocol violations". Observer nodes provide critical API services, and forcing them into an unusable state disrupts blockchain data availability for applications.

## Likelihood Explanation
This vulnerability has **high likelihood** of exploitation:

1. **Low Attack Complexity**: The attacker only needs to craft a `CommitDecision` message with a future epoch number and send it over the network. No complex state manipulation or precise timing is required.

2. **No Special Privileges**: Any network peer can send direct-send messages to observer nodes. The attacker doesn't need validator keys, stake, or insider access.

3. **Immediate Impact**: The root is updated immediately upon receiving the malicious message (before state sync even starts), so the attack succeeds instantly.

4. **Observable Behavior**: The TODO comment indicates the development team is aware this is unfinished code, suggesting it may be actively exploitable in production.

5. **Persistent Effect**: Once the root is updated, the observer remains partitioned until manually restarted or reset.

## Recommendation
Implement signature verification for **all** commit decisions, regardless of epoch. The commit proof's signatures must be validated against the appropriate epoch state before updating any internal state.

**Recommended Fix:**

```rust
// In process_commit_decision_message(), after line 465:
let epoch_state = self.get_epoch_state();

// For future epochs, we need to obtain the target epoch's validator set
// from the commit proof's next_epoch_state (if this is an epoch-ending LI)
let verification_epoch_state = if commit_epoch > epoch_state.epoch {
    // Extract next epoch state from the commit proof if it's an epoch-ending ledger info
    match commit_decision.commit_proof().ledger_info().next_epoch_state() {
        Some(next_epoch_state) => next_epoch_state.clone(),
        None => {
            // Not an epoch-ending LI but claims future epoch - reject
            error!(LogSchema::new(LogEntry::ConsensusObserver)
                .message("Rejecting commit decision for future epoch without epoch change proof"));
            return;
        }
    }
} else {
    epoch_state.clone()
};

// Always verify commit proof before accepting
if let Err(error) = commit_decision.verify_commit_proof(&verification_epoch_state) {
    error!(LogSchema::new(LogEntry::ConsensusObserver)
        .message(&format!("Failed to verify commit decision: {:?}", error)));
    increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
    return;
}

// Only after verification succeeds, proceed with state sync
```

Additionally, remove the premature root update in `update_blocks_for_state_sync_commit()`. The root should only be updated **after** state sync successfully completes and verifies the epoch transition.

## Proof of Concept
The following demonstrates the vulnerability:

```rust
// Test case for consensus_observer.rs
#[tokio::test]
async fn test_unverified_future_epoch_attack() {
    // Setup observer at epoch 10
    let current_epoch = 10;
    let observer = create_test_observer(current_epoch).await;
    
    // Attacker crafts commit decision for epoch 11 with invalid signatures
    let fake_epoch = current_epoch + 1;
    let fake_commit_proof = LedgerInfoWithSignatures::new(
        LedgerInfo::new(
            BlockInfo::random_with_epoch(fake_epoch, 100),
            HashValue::random(),
        ),
        AggregateSignature::empty(), // Invalid signature!
    );
    
    let malicious_commit = CommitDecision::new(fake_commit_proof.clone());
    
    // Send to observer
    observer.process_commit_decision_message(
        PeerNetworkId::random(),
        Instant::now(),
        malicious_commit,
    );
    
    // Verify observer accepted unverified commit and updated root
    let observer_root = observer.observer_block_data.lock().root();
    assert_eq!(observer_root.ledger_info().epoch(), fake_epoch);
    
    // Observer is now partitioned - it will reject legitimate epoch 10 messages
    // This demonstrates the security violation
}
```

The test confirms that the observer accepts an epoch 11 commit decision with empty (invalid) signatures and updates its root, proving the lack of verification for future epochs.

## Notes
This vulnerability is explicitly documented as unresolved in the codebase via the TODO comment at lines 497-498 of `consensus_observer.rs`. The code currently "relies on state sync" to eventually detect the invalid epoch transition, but the damage occurs before state sync can validate anything - the root is already corrupted and the observer is already partitioned from the legitimate network.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L467-482)
```rust
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L497-498)
```rust
        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L500-527)
```rust
        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L275-291)
```rust
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());

        // Update the block payload store
        self.block_payload_store
            .remove_blocks_for_epoch_round(commit_epoch, commit_round);

        // Update the ordered block store
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L300-302)
```rust
    pub fn update_root(&mut self, new_root: LedgerInfoWithSignatures) {
        self.root = new_root;
    }
```
