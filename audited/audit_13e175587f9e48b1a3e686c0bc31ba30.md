# Audit Report

## Title
Commit Vote Equivocation Vulnerability Due to Missing Persistent Voting History

## Summary
The `sign_commit_vote` function in SafetyRules does not persist voting history before returning signatures, allowing validators to equivocate (double-vote) on commit votes after crash-recovery scenarios. This violates the fundamental safety guarantee of Byzantine Fault Tolerant consensus and can lead to consensus splits.

## Finding Description

The vulnerability exists in the consensus signing pipeline where commit votes are signed without persistent state updates. The critical flow is:

1. **Signing Phase invocation**: [1](#0-0) 

2. **SafetyRules processes commit vote**: The `guarded_sign_commit_vote` function performs validation but **does not update or persist any voting history**: [2](#0-1) 

3. **No persistence occurs**: Unlike regular votes which explicitly persist safety data, commit votes skip this critical step. The TODO comments acknowledge missing guarding rules: [3](#0-2) 

**Contrast with regular voting**: Regular votes through `guarded_construct_and_sign_vote_two_chain` properly persist voting history including last_voted_round and last_vote: [4](#0-3) 

**SafetyData structure**: The persistent voting history that should be updated: [5](#0-4) 

**No commit vote persistence interface**: The storage interface only provides `save_vote()` for regular votes, not commit votes: [6](#0-5) 

**Attack Scenario:**
1. Validator receives ordered block B (round R) with ordered proof
2. Block B is executed locally producing state root H1
3. SafetyRules signs commit vote for (block_id, H1) → returns signature S1
4. **Node crashes** before BufferManager broadcasts or persists
5. Node restarts with no memory of S1
6. Due to state sync inconsistency or malicious execution manipulation, block B produces state root H2 ≠ H1
7. SafetyRules has no record of signing S1, validates the new commit info, and signs commit vote for (block_id, H2) → returns signature S2
8. **Equivocation**: Validator has now signed two conflicting execution results for the same block

This breaks the consensus safety invariant that honest validators (< 2/3 threshold) never equivocate. With enough crash-induced equivocations, attackers could obtain 2f+1 signatures on conflicting execution results, causing permanent chain splits.

## Impact Explanation

**Severity: Critical** (Consensus Safety Violation)

This vulnerability qualifies for **Critical** severity under Aptos bug bounty criteria:
- **Consensus/Safety violations**: Enables validator equivocation, the fundamental consensus safety violation
- **Non-recoverable network partition (requires hardfork)**: If conflicting commit proofs both achieve 2f+1 signatures, different validators could commit different execution results, creating an irreconcilable fork

**Concrete Impact:**
- Validators can unknowingly sign conflicting commit votes after crashes
- Breaks the BFT assumption that honest validators never equivocate
- Enables chain splits if multiple validators crash during critical periods
- Could lead to double-spending if different execution results contain different transaction outcomes
- Requires hardfork to resolve if both conflicting states achieve finality

## Likelihood Explanation

**Likelihood: Medium-High**

While this requires specific timing conditions, crashes are common in production distributed systems:

**Factors increasing likelihood:**
- Node crashes occur regularly (power failures, OOM, bugs, upgrades)
- The vulnerability window is the time between signing (line 415) and successful commit proof finalization
- No special privileges required - exploits normal crash-recovery scenarios
- Deterministic execution is hard to guarantee perfectly (state sync issues, execution bugs)
- Affects ALL validators running the consensus pipeline

**Factors decreasing likelihood:**
- Requires crash at specific timing window
- Execution should be deterministic in normal operation
- Multiple validators would need to crash for full exploitation

However, the **severity outweighs the timing constraints** - even rare occurrences of equivocation are catastrophic for consensus safety.

## Recommendation

Implement persistent voting history for commit votes matching the pattern used for regular votes:

```rust
fn guarded_sign_commit_vote(
    &mut self,
    ledger_info: LedgerInfoWithSignatures,
    new_ledger_info: LedgerInfo,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;

    let old_ledger_info = ledger_info.ledger_info();
    
    // ... existing validation code ...

    // NEW: Load safety data and check for previous commit vote
    let mut safety_data = self.persistent_storage.safety_data()?;
    
    // Check if we've already signed a commit vote for this round
    let round = new_ledger_info.round();
    if let Some(last_commit_vote_round) = safety_data.last_commit_vote_round {
        if round <= last_commit_vote_round {
            return Err(Error::AlreadySignedCommitVote(round, last_commit_vote_round));
        }
    }

    let signature = self.sign(&new_ledger_info)?;
    
    // NEW: Persist the commit vote round before returning
    safety_data.last_commit_vote_round = Some(round);
    // Optionally store the full commit info hash for additional validation
    safety_data.last_commit_info_hash = Some(new_ledger_info.commit_info().id());
    self.persistent_storage.set_safety_data(safety_data)?;

    Ok(signature)
}
```

**Required SafetyData schema changes:**
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    pub preferred_round: u64,
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    pub highest_timeout_round: u64,
    // NEW: Track commit vote history
    pub last_commit_vote_round: Option<u64>,
    pub last_commit_info_hash: Option<HashValue>,
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
    use aptos_types::block_info::BlockInfo;
    use aptos_crypto::HashValue;

    #[test]
    fn test_commit_vote_equivocation_after_crash() {
        // Setup SafetyRules with persistent storage
        let mut safety_rules = setup_safety_rules();
        
        // Create ordered proof (ledger info with ordered-only commit_info)
        let ordered_block_info = BlockInfo::new(
            1, // epoch
            100, // round
            HashValue::random(),
            HashValue::zero(), // ordered-only has zero executed state
            0, // version
            0, // timestamp
            None,
        );
        let ordered_ledger_info = LedgerInfo::new(ordered_block_info.clone(), HashValue::zero());
        let ordered_proof = create_quorum_cert(ordered_ledger_info);
        
        // First execution result
        let commit_info_1 = BlockInfo::new(
            1,
            100,
            ordered_block_info.id(),
            HashValue::random(), // execution result H1
            100,
            1000,
            None,
        );
        let commit_ledger_info_1 = LedgerInfo::new(commit_info_1, HashValue::zero());
        
        // Sign first commit vote
        let sig_1 = safety_rules.sign_commit_vote(
            ordered_proof.clone(),
            commit_ledger_info_1.clone()
        ).expect("First sign should succeed");
        
        // SIMULATE CRASH: Create new SafetyRules instance (loses in-memory state)
        drop(safety_rules);
        let mut safety_rules = setup_safety_rules(); // Restart from persistent storage
        
        // Second execution result (different from first)
        let commit_info_2 = BlockInfo::new(
            1,
            100,
            ordered_block_info.id(),
            HashValue::random(), // execution result H2 ≠ H1
            100,
            1000,
            None,
        );
        let commit_ledger_info_2 = LedgerInfo::new(commit_info_2, HashValue::zero());
        
        // BUG: Should fail but doesn't - validator signs conflicting commit vote
        let sig_2_result = safety_rules.sign_commit_vote(
            ordered_proof,
            commit_ledger_info_2
        );
        
        // VULNERABILITY: Second signature succeeds, creating equivocation
        assert!(sig_2_result.is_ok(), "EQUIVOCATION: Signed two different commit votes for same round!");
        
        // Validator has now signed conflicting execution results:
        // - Signature sig_1 on commit_ledger_info_1 (state root H1)
        // - Signature sig_2 on commit_ledger_info_2 (state root H2)
        // This is a consensus safety violation
    }
}
```

**Notes:**

The vulnerability is confirmed by explicit TODO comments indicating missing implementation, the complete absence of persistent state updates in the commit vote signing path, and the stark contrast with regular vote handling which does persist safety data. This is not a theoretical issue - crash-recovery scenarios are common in production blockchain networks, making this a critical safety gap requiring immediate remediation.

### Citations

**File:** consensus/src/pipeline/signing_phase.rs (L90-92)
```rust
            self.safety_rule_handle
                .sign_commit_vote(ordered_ledger_info, commit_ledger_info.clone())
        };
```

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L91-92)
```rust
        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/src/persistent_liveness_storage.rs (L33-65)
```rust
pub trait PersistentLivenessStorage: Send + Sync {
    /// Persist the blocks and quorum certs into storage atomically.
    fn save_tree(&self, blocks: Vec<Block>, quorum_certs: Vec<QuorumCert>) -> Result<()>;

    /// Delete the corresponding blocks and quorum certs atomically.
    fn prune_tree(&self, block_ids: Vec<HashValue>) -> Result<()>;

    /// Persist consensus' state
    fn save_vote(&self, vote: &Vote) -> Result<()>;

    /// Construct data that can be recovered from ledger
    fn recover_from_ledger(&self) -> LedgerRecoveryData;

    /// Construct necessary data to start consensus.
    fn start(&self, order_vote_enabled: bool, window_size: Option<u64>) -> LivenessStorageData;

    /// Persist the highest 2chain timeout certificate for improved liveness - proof for other replicas
    /// to jump to this round
    fn save_highest_2chain_timeout_cert(
        &self,
        highest_timeout_cert: &TwoChainTimeoutCertificate,
    ) -> Result<()>;

    /// Retrieve a epoch change proof for SafetyRules so it can instantiate its
    /// ValidatorVerifier.
    fn retrieve_epoch_change_proof(&self, version: u64) -> Result<EpochChangeProof>;

    /// Returns a handle of the aptosdb.
    fn aptos_db(&self) -> Arc<dyn DbReader>;

    // Returns a handle of the consensus db
    fn consensus_db(&self) -> Arc<ConsensusDB>;
}
```
