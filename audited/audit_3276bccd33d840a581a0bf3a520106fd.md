# Audit Report

## Title
Consensus Observer: Untrusted Timestamp in BlockPayload Enables Expired Batch Inclusion Attack

## Summary
The consensus observer's `verify_payload_digests()` function uses an unvalidated timestamp from network messages to determine batch expiration before the timestamp is validated against the ordered block. A Byzantine validator can exploit this by sending a BlockPayload with a manipulated timestamp (e.g., 0) along with transactions from expired batches, causing different observers to execute different transaction sets for the same block and breaking consensus determinism.

## Finding Description

The consensus observer system has a critical timestamp validation ordering issue. When processing `BlockPayload` messages, the system extracts the `block_info` directly from the untrusted network message and immediately uses its timestamp to determine which batches are expired. [1](#0-0) 

This timestamp is then used in the batch reconstruction logic to skip expired batches: [2](#0-1) 

**Attack Execution Path:**

1. **Malicious Payload Creation**: A Byzantine validator (allowed under < 1/3 Byzantine threat model) crafts a BlockPayload with `timestamp_usecs = 0` and includes transactions for ALL batches, including those that are expired at the actual block timestamp.

2. **Digest Verification Bypass**: With timestamp=0, the expiration check at line 996 evaluates as `0 > expiration` = false for all batches, causing ALL batches (including expired ones) to be reconstructed and verified. The digest verification passes because the transactions genuinely match the batch digests.

3. **Race Condition Exploitation**: The observer accepts the first BlockPayload for each (epoch, round) and ignores subsequent ones: [3](#0-2) 

If the Byzantine validator sends its malicious payload before honest validators, it wins the race.

4. **Verification Against OrderedBlock**: When the legitimate OrderedBlock arrives, verification only checks that BatchInfo structures match, NOT the actual transaction lists: [4](#0-3) 

The honest publisher includes ALL proof references (including expired batches) in the block structure, so this verification passes. However, the honest publisher only includes transactions for non-expired batches when constructing its payload: [5](#0-4) 

5. **Malicious Execution**: When the execution pipeline requests transactions, it retrieves them from the stored payload which contains the expired batch transactions: [6](#0-5) 

**Result**: Different observers execute different transaction sets depending on whose BlockPayload they received first, breaking consensus determinism.

## Impact Explanation

This vulnerability represents a **Critical Severity** consensus safety violation under the Aptos bug bounty program (Category #2: Consensus/Safety Violations).

**Concrete Impact:**
- **Consensus Determinism Broken**: Different observers execute different transactions for the same (epoch, round), computing different state roots
- **State Divergence**: Network participants develop inconsistent ledger views
- **BFT Safety Violation**: Byzantine validator (< 1/3) can cause consensus split without requiring majority collusion
- **Potential Double-Spending**: Expired transactions that were already included in earlier blocks could be re-executed

The test case confirms this design: expired QS batches are expected to be skipped during verification, but inline batches must be included: [7](#0-6) 

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attacker Requirements:**
- Must be a validator that consensus observers subscribe to (or compromise such a validator)
- Requires < 1/3 Byzantine stake (allowed by threat model)
- Needs low-latency network access to win race against honest validators

**Attack Complexity: LOW**
- Simple timestamp manipulation in BlockPayload message
- No cryptographic bypass required (batch proof signatures remain valid)
- Straightforward race condition exploitation

**Correction to Original Report**: The attack does NOT allow "any peer" to exploit this - only subscribed publishers (typically validators) can send BlockPayload messages that will be processed: [8](#0-7) 

However, within the validator set, a single Byzantine validator can perform this attack, making it feasible within the stated threat model.

## Recommendation

**Fix**: Validate the BlockPayload timestamp before using it for batch expiration checks, or defer expiration filtering until after OrderedBlock verification.

**Option 1 - Defer Filtering**: Modify `verify_payload_digests()` to NOT filter expired batches during initial verification. Instead, filter them during execution after the OrderedBlock timestamp has been validated.

**Option 2 - Use Validated Timestamp**: Extract and validate the timestamp from the OrderedBlock first, then use it to re-verify the stored BlockPayload's transaction list matches expected non-expired batches.

**Option 3 - Transaction List Verification**: Extend `verify_against_ordered_payload()` to verify not just BatchInfo structures but also that the actual transaction count matches the expected non-expired transaction count based on the validated OrderedBlock timestamp.

## Proof of Concept

While a complete PoC would require network setup with multiple validators, the vulnerability can be demonstrated conceptually:

```rust
// Conceptual PoC showing the vulnerability
// 1. Create BlockPayload with timestamp=0
let malicious_block_info = BlockInfo::new(epoch, round, ..., 0); // timestamp=0
let expired_batch_info = BatchInfo::new(..., expiration=1000); // expired at t=1000

// 2. Include transactions for expired batch
let all_transactions = vec![...transactions_from_expired_batch...];
let malicious_payload = BlockPayload::new(malicious_block_info, all_transactions);

// 3. Verification passes because 0 < 1000
assert!(malicious_payload.verify_payload_digests().is_ok());

// 4. Later, OrderedBlock arrives with correct timestamp=2000
let ordered_block = OrderedBlock::new(..., timestamp=2000);

// 5. Verification still passes (only checks BatchInfo, not transactions)
assert!(verify_against_ordered_payload(&malicious_payload, &ordered_block).is_ok());

// 6. Execution uses malicious payload with expired transactions
let txns = get_transactions_for_observer(&malicious_payload);
assert!(txns.contains_expired_batch_transactions()); // VULNERABILITY
```

## Notes

This vulnerability demonstrates a critical timestamp validation ordering issue in the consensus observer architecture. The fix requires ensuring that timestamp-dependent security decisions (like batch expiration) are only made after the timestamp has been cryptographically validated through the consensus protocol, not based on untrusted network messages.

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L720-737)
```rust
    fn verify_batches(&self, expected_proofs: &[ProofOfStore<BatchInfo>]) -> Result<(), Error> {
        // Get the batches in the block transaction payload
        let payload_proofs = self.payload_proofs();
        let payload_batches: Vec<&BatchInfo> =
            payload_proofs.iter().map(|proof| proof.info()).collect();

        // Compare the expected batches against the payload batches
        let expected_batches: Vec<&BatchInfo> =
            expected_proofs.iter().map(|proof| proof.info()).collect();
        if expected_batches != payload_batches {
            return Err(Error::InvalidMessageError(format!(
                "Transaction payload failed batch verification! Expected batches {:?}, but found {:?}!",
                expected_batches, payload_batches
            )));
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L874-878)
```rust
    /// Verifies the block payload digests and returns an error if the data is invalid
    pub fn verify_payload_digests(&self) -> Result<(), Error> {
        // Get the block info, transactions, payload proofs and inline batches
        let block_info = self.block.clone();
        let transactions = self.transaction_payload.transactions();
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L987-998)
```rust
fn reconstruct_batch(
    block_info: &BlockInfo,
    transactions_iter: &mut IntoIter<SignedTransaction>,
    expected_batch_info: &BatchInfo,
    skip_expired_batches: bool,
) -> Result<Option<Vec<SignedTransaction>>, Error> {
    // If the batch is expired we should skip reconstruction (as the
    // transactions for the expired batch won't be sent in the payload).
    // Note: this should only be required for QS batches (not inline batches).
    if skip_expired_batches && block_info.timestamp_usecs() > expected_batch_info.expiration() {
        return Ok(None);
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L1708-1721)
```rust
        // Create multiple batch proofs (where some batches are expired)
        let (proofs, non_expired_transactions) =
            create_mixed_expiration_proofs(block_timestamp, &signed_transactions);

        // Create a block payload (with non-expired transactions, all proofs and no inline batches)
        let block_payload = create_block_payload(
            Some(block_info.clone()),
            &non_expired_transactions,
            &proofs,
            &[],
        );

        // Verify the block payload digests and ensure it passes
        assert_ok!(block_payload.verify_payload_digests());
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L370-380)
```rust
        let payload_exists = self
            .observer_block_data
            .lock()
            .existing_payload_entry(&block_payload);

        // If the payload is out of date or already exists, ignore it
        if payload_out_of_date || payload_exists {
            // Update the metrics for the dropped block payload
            update_metrics_for_dropped_block_payload_message(peer_network_id, &block_payload);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L578-594)
```rust
        // Verify the message is from the peers we've subscribed to
        if let Err(error) = self
            .subscription_manager
            .verify_message_for_subscription(peer_network_id)
        {
            // Update the rejected message counter
            increment_rejected_message_counter(&peer_network_id, &message);

            // Log the error and return
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received message that was not from an active subscription! Error: {:?}",
                    error,
                ))
            );
            return;
        }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L102-106)
```rust
            if block_timestamp <= batch_info.expiration() {
                futures.push(batch_reader.get_batch(batch_info, responders.clone()));
            } else {
                debug!("QSE: skipped expired batch {}", batch_info.digest());
            }
```

**File:** consensus/src/payload_manager/co_payload_manager.rs (L70-75)
```rust
    // Return the transactions and the transaction limit
    Ok((
        transaction_payload.transactions(),
        transaction_payload.transaction_limit(),
        transaction_payload.gas_limit(),
    ))
```
