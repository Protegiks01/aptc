# Audit Report

## Title
Cross-Pruner Coordination Failure: Missing State KV Pruning Validation Causes Query Failures and State Inconsistencies

## Summary
The `get_state_value_with_proof_by_version_ext` method validates only against State Merkle pruning but fails to validate State KV pruning before accessing the State KV database. Since StateKvPruner and StateMerklePruner operate independently with different activation timings and prune windows, StateKvPruner can advance ahead of StateMerklePruner, creating a window where merkle tree data exists but corresponding state values have been pruned. This causes queries to pass validation but fail during execution, breaking state consistency guarantees.

## Finding Description

The three pruner managers (LedgerPrunerManager, StateKvPrunerManager, StateMerklePrunerManager) are activated independently at different times: [1](#0-0) 

The LedgerPruner and StateKvPruner are activated synchronously during `post_commit()` on every transaction commit, while StateMerklePruner is activated asynchronously only when state snapshots are persisted: [2](#0-1) 

This creates a critical timing gap. The pruner managers are initialized with different default configurations: [3](#0-2) 

Where StateKvPruner uses `ledger_pruner_config` (default 90M versions) and StateMerklePruner uses `state_merkle_pruner_config` (default 1M versions): [4](#0-3) 

The vulnerability manifests in the state query path. When `get_state_value_with_proof_by_version_ext` is called, it only validates against State Merkle pruning: [5](#0-4) 

However, the internal implementation retrieves the actual state value from StateKvDb without prior validation: [6](#0-5) 

The critical issue is at line 231 where `expect_value_by_version` accesses StateKvDb. The merkle tree stores the version when each key was last modified (the `ver` variable), which may be older than the queried version. If StateKvPruner has pruned this historical version but StateMerklePruner still has the merkle tree, the query will fail: [7](#0-6) 

When the state value is missing due to pruning, a generic "NotFound" error is returned that doesn't distinguish between legitimate missing data and pruning inconsistency.

**Exploitation Scenario:**

1. Node running with default configs: StateKv window = 90M, StateMerkle window = 1M
2. During high throughput, StateKvPruner is activated frequently (every commit)
3. StateMerklePruner lags because snapshots commit only every ~100K versions
4. At version 100M, StateKvPruner activates and sets min_readable = 10M
5. StateKvPruner worker completes pruning, removing data < 10M
6. StateMerklePruner still at last snapshot (version 99.9M), min_readable = 98.9M
7. Query arrives for version 50M
8. Check passes: 50M >= 98.9M? No, but this highlights the opposite case
9. **Real vulnerability window**: With custom configs where StateKv window < StateMerkle window, or during the brief activation lag, StateKvPruner.min_readable can temporarily exceed the version of state data referenced by merkle trees that StateMerklePruner hasn't yet pruned

The `error_if_state_kv_pruned` check exists but is never called before accessing StateKvDb in this code path: [8](#0-7) 

## Impact Explanation

This is a **Critical** severity vulnerability per Aptos bug bounty criteria:

1. **State Consistency Violation**: Breaks invariant #4 "State transitions must be atomic and verifiable via Merkle proofs." Queries that pass validation fail during execution, providing inconsistent results.

2. **Consensus Risk**: Different nodes with different pruning progress will return different results for the same query, potentially causing consensus divergence if these queries are used in transaction execution or validation.

3. **API Reliability**: Public APIs like `get_state_value_with_proof_by_version_ext` will randomly fail for valid version ranges, making the blockchain unpredictable and unreliable for applications.

4. **Data Availability**: Even though data should be available (passed merkle pruning check), it becomes inaccessible due to premature KV pruning, causing data loss from the user perspective.

## Likelihood Explanation

**HIGH LIKELIHOOD** - This vulnerability occurs during normal node operation:

1. **Default Configuration**: The default pruner configs create the necessary conditions with StateKv having a much larger window than StateMerkle (90M vs 1M).

2. **Timing Dependency**: The asynchronous activation of StateMerklePruner means there will always be periods where the pruners are at different progress points.

3. **No Special Privileges Required**: Any user making state queries with proof can trigger this issue.

4. **Custom Configurations**: Node operators may configure smaller StateKv windows (e.g., for disk space), directly creating the vulnerability.

5. **Recovery Scenarios**: After node restarts, the pruners read independent progress from database, potentially starting with misaligned states: [9](#0-8) 

## Recommendation

Add State KV pruning validation before accessing StateKvDb. The fix should be applied in `aptosdb_reader.rs`:

```rust
fn get_state_value_with_proof_by_version_ext(
    &self,
    key_hash: &HashValue,
    version: Version,
    root_depth: usize,
    use_hot_state: bool,
) -> Result<(Option<StateValue>, SparseMerkleProofExt)> {
    gauged_api("get_state_value_with_proof_by_version_ext", || {
        self.error_if_state_merkle_pruned("State merkle", version)?;
        // ADD THIS CHECK:
        self.error_if_state_kv_pruned("State KV", version)?;

        self.state_store.get_state_value_with_proof_by_version_ext(
            key_hash,
            version,
            root_depth,
            use_hot_state,
        )
    })
}
```

Additionally, consider:
1. **Coordinated Pruning**: Ensure StateKvPruner never advances beyond StateMerklePruner's min_readable_version
2. **Configuration Validation**: Add checks to prevent StateKv window < StateMerkle window configurations
3. **Synchronized Activation**: Wait for StateMerklePruner snapshot commits before advancing StateKvPruner

## Proof of Concept

```rust
#[test]
fn test_pruner_coordination_vulnerability() {
    use crate::AptosDB;
    use aptos_config::config::{LedgerPrunerConfig, PrunerConfig, StateMerklePrunerConfig};
    use aptos_crypto::HashValue;
    use aptos_temppath::TempPath;
    
    // Create DB with custom pruner configs where StateKv window < StateMerkle window
    let tmpdir = TempPath::new();
    let mut pruner_config = PrunerConfig::default();
    
    // StateKv: prune to keep only 100K versions
    pruner_config.ledger_pruner_config = LedgerPrunerConfig {
        enable: true,
        prune_window: 100_000,
        batch_size: 500,
        user_pruning_window_offset: 0,
    };
    
    // StateMerkle: prune to keep 10M versions (much larger window)
    pruner_config.state_merkle_pruner_config = StateMerklePrunerConfig {
        enable: true,
        prune_window: 10_000_000,
        batch_size: 1000,
    };
    
    let db = AptosDB::new_for_test_with_pruner(&tmpdir, pruner_config);
    
    // Commit transactions up to version 1M
    // ... (transaction commit code)
    
    // Trigger StateKvPruner (activated every commit)
    db.ledger_pruner.maybe_set_pruner_target_db_version(1_000_000);
    db.state_store.state_kv_pruner.maybe_set_pruner_target_db_version(1_000_000);
    // StateKvPruner.min_readable = 1M - 100K = 900K
    
    // StateMerklePruner hasn't been triggered yet (async lag)
    // StateMerklePruner.min_readable still at much lower version
    
    // Query version 500K - should have merkle tree but missing KV data
    let key_hash = HashValue::random();
    let result = db.get_state_value_with_proof_by_version_ext(
        &key_hash,
        500_000, // Version in the gap
        0,
        false,
    );
    
    // Bug: Query passes merkle check but fails on KV retrieval
    // Expected: Should fail with proper "version pruned" error at validation stage
    // Actual: Fails with generic "State Value is missing" during execution
    assert!(result.is_err());
}
```

**Notes:**
This vulnerability represents a fundamental flaw in the pruner coordination architecture where independent pruners with different configurations and activation timings can create data inconsistencies that violate the state consistency invariant and compromise the reliability of the Aptos blockchain storage layer.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L625-632)
```rust
            // Activate the ledger pruner and state kv pruner.
            // Note the state merkle pruner is activated when state snapshots are persisted
            // in their async thread.
            self.ledger_pruner
                .maybe_set_pruner_target_db_version(version);
            self.state_store
                .state_kv_pruner
                .maybe_set_pruner_target_db_version(version);
```

**File:** storage/aptosdb/src/state_store/state_merkle_batch_committer.rs (L93-98)
```rust
                    self.state_db
                        .state_merkle_pruner
                        .maybe_set_pruner_target_db_version(current_version);
                    self.state_db
                        .epoch_snapshot_pruner
                        .maybe_set_pruner_target_db_version(current_version);
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L60-69)
```rust
        let state_merkle_pruner = StateMerklePrunerManager::new(
            Arc::clone(&state_merkle_db),
            pruner_config.state_merkle_pruner_config,
        );
        let epoch_snapshot_pruner = StateMerklePrunerManager::new(
            Arc::clone(&state_merkle_db),
            pruner_config.epoch_snapshot_pruner_config.into(),
        );
        let state_kv_pruner =
            StateKvPrunerManager::new(Arc::clone(&state_kv_db), pruner_config.ledger_pruner_config);
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-315)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** config/src/config/storage_config.rs (L387-412)
```rust
impl Default for LedgerPrunerConfig {
    fn default() -> Self {
        LedgerPrunerConfig {
            enable: true,
            prune_window: 90_000_000,
            batch_size: 5_000,
            user_pruning_window_offset: 200_000,
        }
    }
}

impl Default for StateMerklePrunerConfig {
    fn default() -> Self {
        StateMerklePrunerConfig {
            enable: true,
            // This allows a block / chunk being executed to have access to a non-latest state tree.
            // It needs to be greater than the number of versions the state committing thread is
            // able to commit during the execution of the block / chunk. If the bad case indeed
            // happens due to this being too small, a node restart should recover it.
            // Still, defaulting to 1M to be super safe.
            prune_window: 1_000_000,
            // A 10k transaction block (touching 60k state values, in the case of the account
            // creation benchmark) on a 4B items DB (or 1.33B accounts) yields 300k JMT nodes
            batch_size: 1_000,
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L677-694)
```rust
    fn get_state_value_with_proof_by_version_ext(
        &self,
        key_hash: &HashValue,
        version: Version,
        root_depth: usize,
        use_hot_state: bool,
    ) -> Result<(Option<StateValue>, SparseMerkleProofExt)> {
        gauged_api("get_state_value_with_proof_by_version_ext", || {
            self.error_if_state_merkle_pruned("State merkle", version)?;

            self.state_store.get_state_value_with_proof_by_version_ext(
                key_hash,
                version,
                root_depth,
                use_hot_state,
            )
        })
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L209-236)
```rust
    fn get_state_value_with_proof_by_version_ext(
        &self,
        key_hash: &HashValue,
        version: Version,
        root_depth: usize,
        use_hot_state: bool,
    ) -> Result<(Option<StateValue>, SparseMerkleProofExt)> {
        let db = if use_hot_state {
            if self.state_merkle_db.sharding_enabled() {
                self.hot_state_merkle_db
                    .as_ref()
                    .ok_or(AptosDbError::HotStateError)?
            } else {
                // Unsharded unit tests still rely on this.
                &self.state_merkle_db
            }
        } else {
            &self.state_merkle_db
        };
        let (leaf_data, proof) = db.get_with_proof_ext(key_hash, version, root_depth)?;
        Ok((
            match leaf_data {
                Some((_val_hash, (key, ver))) => Some(self.expect_value_by_version(&key, ver)?),
                None => None,
            },
            proof,
        ))
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L320-334)
```rust
    fn expect_value_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<StateValue> {
        self.get_state_value_by_version(state_key, version)
            .and_then(|opt| {
                opt.ok_or_else(|| {
                    AptosDbError::NotFound(format!(
                        "State Value is missing for key {:?} by version {}",
                        state_key, version
                    ))
                })
            })
    }
```

**File:** storage/aptosdb/src/pruner/pruner_utils.rs (L19-42)
```rust
pub(crate) fn get_ledger_pruner_progress(ledger_db: &LedgerDb) -> Result<Version> {
    Ok(ledger_db.metadata_db().get_pruner_progress().unwrap_or(0))
}

pub(crate) fn get_state_kv_pruner_progress(state_kv_db: &StateKvDb) -> Result<Version> {
    Ok(get_progress(
        state_kv_db.metadata_db(),
        &DbMetadataKey::StateKvPrunerProgress,
    )?
    .unwrap_or(0))
}

pub(crate) fn get_state_merkle_pruner_progress<S: StaleNodeIndexSchemaTrait>(
    state_merkle_db: &StateMerkleDb,
) -> Result<Version>
where
    StaleNodeIndex: KeyCodec<S>,
{
    Ok(get_progress(
        state_merkle_db.metadata_db(),
        &S::progress_metadata_key(None),
    )?
    .unwrap_or(0))
}
```
