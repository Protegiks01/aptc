# Audit Report

## Title
BlockSTM V1 Memory Ordering Bug in Module Read Validation Enables Potential Non-Deterministic Execution

## Summary
BlockSTM V1 contains a memory ordering bug where `skip_module_reads_validation` is stored and loaded with `Ordering::Relaxed`, providing no synchronization guarantee between the thread publishing modules and threads performing validation. This violates proper synchronization semantics and could theoretically allow different validators to produce different state roots for identical blocks.

## Finding Description

The vulnerability is a **memory ordering bug** in BlockSTM V1's synchronization mechanism for module read validation: [1](#0-0) 

The flag is initialized to `true`, causing module read validation to be skipped by default.

When a transaction publishes modules, the flag is set to `false` using **Relaxed ordering**: [2](#0-1) 

During validation, the flag is loaded using **Relaxed ordering**: [3](#0-2) 

The validation logic skips module read checks when the flag is `true`: [4](#0-3) 

**The Memory Ordering Issue:**

`Ordering::Relaxed` provides **no synchronization** across threads. Even though:
1. Thread A (commit): stores flag with Relaxed → modifies `validation_idx` with SeqCst
2. Thread B (validation): reads `validation_idx` with Acquire → reads flag with Relaxed

The Acquire-SeqCst synchronization on `validation_idx` does NOT guarantee thread B sees the Relaxed store to the flag. This creates a race where different validators' validation threads might observe different flag values, leading to:
- Some validators skip module validation → commit with stale module code
- Other validators perform module validation → detect staleness → re-execute with new module code
- Different state roots produced from identical input blocks

The module validation would catch stale reads if executed: [5](#0-4) 

The developer comment acknowledges intended synchronization through `decrease_validation_idx`, but Relaxed ordering doesn't participate in this synchronization: [6](#0-5) 

## Impact Explanation

**Critical Severity** - Consensus/Safety Violation per Aptos bug bounty criteria:

This is a synchronization correctness bug that violates the Rust memory model. While the race window is extremely small, if triggered it would cause:
- **Different validators produce different state roots** for identical blocks
- **Consensus failure** requiring manual intervention
- **Potential network partition** if validators diverge on state

This qualifies as a **logic vulnerability** in the synchronization mechanism, which makes it valid regardless of triggering difficulty.

## Likelihood Explanation

**Low-to-Medium Likelihood**:

While theoretically possible, the actual triggering likelihood is low because:
- The race window is nanoseconds-scale between store and load operations
- Modern memory systems often provide stronger guarantees than the memory model requires
- Requires precise timing where module publishing occurs with dependent transactions in the same block
- No evidence this has manifested in production

However, this is still a **correctness bug** that violates proper synchronization semantics and could manifest unpredictably under specific timing conditions, network latency variations, or different hardware platforms.

**Note**: BlockSTM V2 does not use this flag and is unaffected: [7](#0-6) 

## Recommendation

Change the memory ordering from `Relaxed` to at least `Release`/`Acquire`:

**In `scheduler_wrapper.rs` line 87:**
```rust
skip_module_reads_validation.store(false, Ordering::Release);
```

**In `executor.rs` line 1372:**
```rust
skip_module_reads_validation.load(Ordering::Acquire)
```

This establishes proper synchronization where the Acquire load is guaranteed to observe all effects that happened-before the Release store, ensuring validation threads always see the updated flag after module publishing.

Alternatively, consider migrating to BlockSTM V2 which uses a more granular validation approach that doesn't rely on this flag.

## Proof of Concept

A formal PoC for memory ordering bugs is difficult to construct reliably due to the non-deterministic nature of race conditions. However, the bug can be demonstrated through code inspection and memory model analysis showing that `Ordering::Relaxed` provides insufficient synchronization guarantees for the intended semantics.

The correctness violation can be verified by reviewing the Rust memory model documentation which explicitly states that Relaxed operations provide no synchronization and cannot be used to establish happens-before relationships required for correct cross-thread communication.

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L810-815)
```rust
            && (skip_module_reads_validation
                || read_set.validate_module_reads(
                    global_module_cache,
                    versioned_cache.module_cache(),
                    None,
                ))
```

**File:** aptos-move/block-executor/src/executor.rs (L1367-1373)
```rust
                    let valid = Self::validate(
                        txn_idx,
                        last_input_output,
                        global_module_cache,
                        versioned_cache,
                        skip_module_reads_validation.load(Ordering::Relaxed),
                    );
```

**File:** aptos-move/block-executor/src/executor.rs (L1895-1895)
```rust
        let skip_module_reads_validation = AtomicBool::new(true);
```

**File:** aptos-move/block-executor/src/scheduler_wrapper.rs (L24-30)
```rust
pub(crate) enum SchedulerWrapper<'a> {
    // The AtomicBool contains a flag that determines whether to skip module reads
    // when performing validation. BlockSTMv1 uses this as an optimization to
    // avoid unnecessary work when no modules have been published. BlockSTMv2 has
    // a different validation logic, and does not require this flag. The flag is
    // stored in SchedulerWrapper only for a write (it's never read), to simplify
    // the implementation in executor.rs and avoid passing atomic booleans.
```

**File:** aptos-move/block-executor/src/scheduler_wrapper.rs (L84-87)
```rust
            SchedulerWrapper::V1(_, skip_module_reads_validation) => {
                // Relaxed suffices as syncronization (reducing validation index) occurs after
                // setting the module read validation flag.
                skip_module_reads_validation.store(false, Ordering::Relaxed);
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1060-1061)
```rust
        let validate = |key: &K, read: &ModuleRead<DC, VC, S>| match read {
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
```
