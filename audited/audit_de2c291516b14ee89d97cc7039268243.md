# Audit Report

## Title
Secret Share Aggregation Denial of Service via Metadata Mismatch in retain()

## Summary
The `SecretShareAggregator::retain()` function can cause aggregation failure when shares with mismatched metadata are filtered out after being counted toward the threshold. Byzantine validators can exploit this by broadcasting shares with incorrect metadata during the proactive broadcast phase, causing temporary denial of service in the secret sharing decryption pipeline.

## Finding Description

The vulnerability exists in the secret sharing aggregation logic that handles threshold-based reconstruction of decryption keys for encrypted transactions. The issue occurs in the state transition from `PendingMetadata` to `PendingDecision` state.

**Attack Flow:**

1. **Proactive Broadcast Phase**: When blocks arrive, validators compute and broadcast their secret shares to all peers. [1](#0-0) 

2. **Unvalidated Share Acceptance**: Incoming shares are added to the aggregator while in `PendingMetadata` state WITHOUT metadata validation. [2](#0-1) 

3. **Weight Accumulation**: Each accepted share increments `total_weight` in the aggregator. [3](#0-2) 

4. **Byzantine Shares Injected**: Malicious validators broadcast shares with incorrect metadata (wrong `block_id`, `digest`, or `timestamp`) that pass cryptographic verification but have mismatched metadata fields. [4](#0-3) 

5. **Self Share Triggers retain()**: When the node's self share is computed and added, it triggers `add_share_with_metadata()` which calls `retain()` to filter shares by metadata. [5](#0-4) 

6. **Shares Filtered, Weight Drops**: The `retain()` method removes all shares with mismatched metadata and recalculates `total_weight`. [6](#0-5) 

7. **Aggregation Fails**: If enough Byzantine shares were filtered out, `total_weight` drops below threshold, causing `try_aggregate()` to return early without performing aggregation. [7](#0-6) 

**Why Byzantine Shares Pass Initial Validation:**

Shares are cryptographically verified against their own digest during network message verification. [8](#0-7) [9](#0-8) 

However, this verification only confirms the share is valid for ITS digest - it doesn't validate that the digest, block_id, or timestamp are correct for the round. Byzantine validators can compute valid shares for fabricated metadata.

**Critical Code Path:**

The vulnerability stems from the asymmetry in validation:
- **Proactive broadcast path**: No metadata validation in `PendingMetadata` state
- **Reactive request path**: Strict metadata validation via `SecretShareAggregateState::add()` [10](#0-9) 

**Example Attack Scenario:**
- Threshold: 7 validators required
- Total validators: 10 (7 honest + 3 Byzantine, within BFT bounds)
- Byzantine validators send shares with wrong `block_id` early
- 3 Byzantine shares + 4 honest shares arrive = total_weight = 7 (≥ threshold)
- Self share arrives, triggers `retain()`
- Byzantine shares filtered out: total_weight = 5 (< threshold)
- Aggregation fails, requiring 300ms retry delay + reactive share requests

## Impact Explanation

This vulnerability causes **High Severity** impact per Aptos bug bounty criteria:

**Validator Node Slowdowns**: Blocks cannot be fully processed until secret shares are aggregated. The retry mechanism introduces a minimum 300ms delay per affected round. [11](#0-10) 

**Protocol Violations**: The secret sharing protocol expects aggregation to succeed promptly once threshold shares are received. This vulnerability breaks that guarantee by allowing shares to be accepted and counted, then discarded.

**Pipeline Stalls**: Blocks are queued waiting for decryption keys. [12](#0-11)  Until aggregation succeeds, the entire pipeline is blocked for that round.

**Repeated Attacks**: Byzantine validators can persistently send incorrect metadata for every round, causing sustained performance degradation across the network.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Byzantine validators within BFT bounds (< 1/3 of total stake)
- Ability to compute secret shares with arbitrary metadata
- Network access to broadcast shares proactively

**Attack Complexity: Low**
- Byzantine validators simply broadcast shares with modified metadata fields
- No sophisticated cryptographic attacks needed
- Attack is repeatable for every consensus round

**Real-World Scenarios:**
1. **Intentional Byzantine Behavior**: Malicious validators deliberately send wrong metadata to degrade network performance
2. **Software Bugs**: Validators with buggy implementations that compute shares for incorrect block views
3. **Network Race Conditions**: In edge cases where validators see different proposed blocks before consensus

The attack is more effective when:
- Byzantine validators coordinate timing (send bad shares early)
- Network latency causes honest shares to arrive slower
- The threshold is set close to the number of honest validators

## Recommendation

**Option 1: Reject Shares in PendingMetadata State (Partial Fix)**
Add early metadata validation when possible, but this doesn't fully solve the issue since correct metadata isn't known until self share arrives.

**Option 2: Track and Warn on Weight Drop (Detection)**
Add logging/alerting when `retain()` causes significant weight reduction:

```rust
fn retain(&mut self, metadata: &SecretShareMetadata, weights: &HashMap<Author, u64>) {
    let old_weight = self.total_weight;
    self.shares.retain(|_, share| share.metadata == *metadata);
    self.total_weight = self
        .shares
        .keys()
        .map(|author| weights.get(author).expect("Author must exist for weight"))
        .sum();
    
    if old_weight >= threshold && self.total_weight < threshold {
        warn!(
            "Metadata filtering caused weight drop from {} to {}, below threshold {}. Filtered {} shares.",
            old_weight,
            self.total_weight,
            threshold,
            old_weight - self.total_weight
        );
    }
}
```

**Option 3: Two-Phase Metadata Validation (Recommended)**
Separate metadata establishment from share collection:

```rust
fn add_share(&mut self, share: SecretShare, share_weight: u64) -> anyhow::Result<()> {
    match self {
        SecretShareItem::PendingMetadata(aggr) => {
            // Store shares without counting weight yet
            aggr.pending_shares.insert(share.author, share);
            Ok(())
        },
        SecretShareItem::PendingDecision {
            metadata,
            share_aggregator,
        } => {
            ensure!(
                metadata == &share.metadata,
                "Metadata mismatch"
            );
            share_aggregator.add_share(share, share_weight);
            Ok(())
        },
        SecretShareItem::Decided { .. } => Ok(()),
    }
}

fn add_share_with_metadata(&mut self, share: SecretShare, share_weights: &HashMap<Author, u64>) -> anyhow::Result<()> {
    let item = std::mem::replace(self, Self::new(Author::ONE));
    let new_item = match item {
        SecretShareItem::PendingMetadata(aggr) => {
            let metadata = share.metadata.clone();
            // Only count weight for shares with matching metadata
            let mut share_aggregator = SecretShareAggregator::new(aggr.self_author);
            for (author, pending_share) in aggr.pending_shares {
                if pending_share.metadata == metadata {
                    let weight = *share_weights.get(&author).unwrap_or(&0);
                    share_aggregator.add_share(pending_share, weight);
                }
            }
            // Add self share
            let self_weight = *share_weights.get(share.author()).expect("Author must exist");
            share_aggregator.add_share(share, self_weight);
            
            SecretShareItem::PendingDecision {
                metadata,
                share_aggregator,
            }
        },
        // ... rest unchanged
    };
    let _ = std::mem::replace(self, new_item);
    Ok(())
}
```

This ensures `total_weight` only reflects shares that will actually be used for aggregation.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_metadata_mismatch_drops_below_threshold() {
    use aptos_types::secret_sharing::{SecretShare, SecretShareMetadata};
    use aptos_consensus_types::common::Author;
    use std::collections::HashMap;
    
    // Setup: threshold=7, 10 validators
    let threshold = 7u64;
    let mut weights = HashMap::new();
    
    // Create aggregator
    let self_author = Author::random();
    let mut aggregator = SecretShareAggregator::new(self_author);
    
    // Add 3 Byzantine shares with WRONG metadata
    let wrong_metadata = SecretShareMetadata {
        epoch: 1,
        round: 100,
        timestamp: 1000,
        block_id: HashValue::random(), // Wrong block_id
        digest: vec![0xBE, 0xEF], // Wrong digest
    };
    
    for i in 0..3 {
        let byzantine_author = Author::random();
        weights.insert(byzantine_author, 1);
        let byzantine_share = SecretShare::new(
            byzantine_author,
            wrong_metadata.clone(),
            /* mock secret key share */
        );
        aggregator.add_share(byzantine_share, 1);
    }
    
    // Add 4 honest shares with CORRECT metadata
    let correct_metadata = SecretShareMetadata {
        epoch: 1,
        round: 100,
        timestamp: 1000,
        block_id: HashValue::random(), // Correct block_id
        digest: vec![0xCA, 0xFE], // Correct digest
    };
    
    for i in 0..4 {
        let honest_author = Author::random();
        weights.insert(honest_author, 1);
        let honest_share = SecretShare::new(
            honest_author,
            correct_metadata.clone(),
            /* mock secret key share */
        );
        aggregator.add_share(honest_share, 1);
    }
    
    // At this point: total_weight = 7 (3 Byzantine + 4 honest) >= threshold ✓
    assert_eq!(aggregator.total_weight, 7);
    assert!(aggregator.total_weight >= threshold);
    
    // Self share arrives, triggers retain()
    aggregator.retain(&correct_metadata, &weights);
    
    // After retain: total_weight = 4 (only honest shares) < threshold ✗
    assert_eq!(aggregator.total_weight, 4);
    assert!(aggregator.total_weight < threshold);
    
    // Aggregation will fail!
    let result = aggregator.try_aggregate(&config, correct_metadata, tx);
    assert!(matches!(result, Either::Left(_))); // Returns aggregator without aggregating
}
```

**Notes:**
- The vulnerability is exploitable within BFT assumptions (< 1/3 Byzantine validators)
- Recovery requires the reactive share request mechanism (300ms+ delay)
- Attack can be repeated for every consensus round
- Impact is temporary performance degradation, not permanent liveness failure
- Byzantine validators can selectively target specific rounds for maximum disruption

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L132-158)
```rust
    async fn process_incoming_block(&self, block: &PipelinedBlock) -> DropGuard {
        let futures = block.pipeline_futs().expect("pipeline must exist");
        let self_secret_share = futures
            .secret_sharing_derive_self_fut
            .await
            .expect("Decryption share computation is expected to succeed")
            .expect("Must not be None");
        let metadata = self_secret_share.metadata().clone();

        // Now acquire lock and update store
        {
            let mut secret_share_store = self.secret_share_store.lock();
            secret_share_store.update_highest_known_round(block.round());
            secret_share_store
                .add_self_share(self_secret_share.clone())
                .expect("Add self dec share should succeed");
        }

        info!(LogSchema::new(LogEvent::BroadcastSecretShare)
            .epoch(self.epoch_state.epoch)
            .author(self.author)
            .round(block.round()));
        self.network_sender.broadcast_without_self(
            SecretShareMessage::Share(self_secret_share).into_network_message(),
        );
        self.spawn_share_requester_task(metadata)
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L246-248)
```rust
        let task = async move {
            // TODO(ibalajiarun): Make this configurable
            tokio::time::sleep(Duration::from_millis(300)).await;
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L32-36)
```rust
    pub fn add_share(&mut self, share: SecretShare, weight: u64) {
        if self.shares.insert(share.author, share).is_none() {
            self.total_weight += weight;
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L38-46)
```rust
    pub fn try_aggregate(
        self,
        secret_share_config: &SecretShareConfig,
        metadata: SecretShareMetadata,
        decision_tx: Sender<SecretSharedKey>,
    ) -> Either<Self, SecretShare> {
        if self.total_weight < secret_share_config.threshold() {
            return Either::Left(self);
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L74-81)
```rust
    fn retain(&mut self, metadata: &SecretShareMetadata, weights: &HashMap<Author, u64>) {
        self.shares.retain(|_, share| share.metadata == *metadata);
        self.total_weight = self
            .shares
            .keys()
            .map(|author| weights.get(author).expect("Author must exist for weight"))
            .sum();
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L108-128)
```rust
    fn add_share(&mut self, share: SecretShare, share_weight: u64) -> anyhow::Result<()> {
        match self {
            SecretShareItem::PendingMetadata(aggr) => {
                aggr.add_share(share, share_weight);
                Ok(())
            },
            SecretShareItem::PendingDecision {
                metadata,
                share_aggregator,
            } => {
                ensure!(
                    metadata == &share.metadata,
                    "[SecretShareItem] SecretShare metadata from {} mismatch with block metadata!",
                    share.author,
                );
                share_aggregator.add_share(share, share_weight);
                Ok(())
            },
            SecretShareItem::Decided { .. } => Ok(()),
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L156-182)
```rust
    fn add_share_with_metadata(
        &mut self,
        share: SecretShare,
        share_weights: &HashMap<Author, u64>,
    ) -> anyhow::Result<()> {
        let item = std::mem::replace(self, Self::new(Author::ONE));
        let share_weight = *share_weights
            .get(share.author())
            .expect("Author must exist in weights");
        let new_item = match item {
            SecretShareItem::PendingMetadata(mut share_aggregator) => {
                let metadata = share.metadata.clone();
                share_aggregator.retain(share.metadata(), share_weights);
                share_aggregator.add_share(share, share_weight);
                SecretShareItem::PendingDecision {
                    metadata,
                    share_aggregator,
                }
            },
            SecretShareItem::PendingDecision { .. } => {
                bail!("Cannot add self share in PendingDecision state");
            },
            SecretShareItem::Decided { .. } => return Ok(()),
        };
        let _ = std::mem::replace(self, new_item);
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L33-39)
```rust
pub struct SecretShareMetadata {
    pub epoch: u64,
    pub round: Round,
    pub timestamp: u64,
    pub block_id: HashValue,
    pub digest: Digest,
}
```

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** consensus/src/rand/secret_sharing/reliable_broadcast_state.rs (L44-60)
```rust
    fn add(&self, peer: Author, share: Self::Response) -> anyhow::Result<Option<()>> {
        ensure!(share.author() == &peer, "Author does not match");
        ensure!(
            share.metadata() == &self.secret_share_metadata,
            "Metadata does not match: local {:?}, received {:?}",
            self.secret_share_metadata,
            share.metadata()
        );
        share.verify(&self.secret_share_config)?;
        info!(LogSchema::new(LogEvent::ReceiveReactiveSecretShare)
            .epoch(share.epoch())
            .round(share.metadata().round)
            .remote_peer(*share.author()));
        let mut store = self.secret_share_store.lock();
        let aggregated = store.add_share(share)?.then_some(());
        Ok(aggregated)
    }
```

**File:** consensus/src/rand/secret_sharing/block_queue.rs (L60-77)
```rust
    pub fn is_fully_secret_shared(&self) -> bool {
        self.pending_secret_key_rounds.is_empty()
    }

    pub fn set_secret_shared_key(&mut self, round: Round, key: SecretSharedKey) {
        let offset = self.offset(round);
        if self.pending_secret_key_rounds.contains(&round) {
            observe_block(
                self.blocks()[offset].timestamp_usecs(),
                BlockStage::SECRET_SHARING_ADD_DECISION,
            );
            let block = &self.blocks_mut()[offset];
            if let Some(tx) = block.pipeline_tx().lock().as_mut() {
                tx.secret_shared_key_tx.take().map(|tx| tx.send(Some(key)));
            }
            self.pending_secret_key_rounds.remove(&round);
        }
    }
```
