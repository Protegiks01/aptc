# Audit Report

## Title
JWK Consensus Config Unsafe Default During Upgrade Path Causes Keyless Account Denial of Service

## Summary
During network upgrades, if `OnChainJWKConsensusConfig` is not initialized and the fallback to deprecated resources fails, the consensus configuration defaults to `Off`, which would disable JWK consensus and break all keyless accounts network-wide.

## Finding Description
The `OnChainJWKConsensusConfig` system uses a fallback mechanism to support migration from the deprecated `Features` + `SupportedOIDCProviders` configuration to the new dedicated config resource. However, this fallback has a dangerous default behavior that can break keyless accounts during upgrades. [1](#0-0) 

When validators start a new epoch, they attempt to fetch the `OnChainJWKConsensusConfig`. If this fails (config not yet initialized), the code falls back to constructing an equivalent config from deprecated resources: [2](#0-1) 

The fallback implementation fetches `Features` and `SupportedOIDCProviders` as `Option` types: [3](#0-2) 

The critical flaw is in the `From` implementation. If `Features` is `None` (missing or deserialization failed), it unconditionally returns `Off`: [4](#0-3) 

This violates the principle of safe defaults during upgrades. If a chain has keyless accounts working (JWK consensus enabled), and during an upgrade the config fetch fails for any reason, the system defaults to disabling JWK consensus entirely.

**Dangerous Upgrade Scenario:**
1. Chain is running with keyless accounts enabled via old mechanism
2. Governance proposes framework upgrade adding `JWKConsensusConfig`
3. Binary upgrade happens, nodes expect new config structure
4. If `JWKConsensusConfig` not yet initialized AND `Features` resource becomes temporarily inaccessible during state transition
5. Config defaults to `Off` via line 129
6. JWK consensus disabled, all keyless accounts cannot authenticate

## Impact Explanation
This qualifies as **High Severity** per Aptos bug bounty criteria for "Significant protocol violations" and potentially impacts availability. If triggered during an upgrade:

- **Immediate Impact**: All keyless accounts lose authentication capability network-wide
- **User Impact**: Users with keyless accounts cannot access their funds until emergency intervention
- **Network Impact**: Requires emergency governance action or rollback to restore functionality
- **State Inconsistency**: Creates a window where keyless account state exists but authentication is disabled

While not permanent (can be fixed via governance), this represents a significant protocol violation that breaks a critical authentication mechanism affecting all keyless account users.

## Likelihood Explanation
**Likelihood: MEDIUM during upgrades**

This requires specific conditions during network upgrades:
- Framework upgrade introducing `JWKConsensusConfig` resource
- Race condition where binary expects new config before on-chain initialization
- Governance proposal sequencing error (disabling old mechanism before enabling new)
- Transient state during framework transaction execution where `Features` is inaccessible

While not trivially exploitable by external attackers, this is a realistic operational risk during the frequent network upgrades that Aptos performs. The fallback logic using `.ok()` at line 1966 silently converts errors to `None`, making failures invisible.

## Recommendation
Implement a safer default strategy that preserves existing functionality during upgrades:

**Option 1: Preserve last known good state**
```rust
pub fn default_if_missing() -> Self {
    // During migration, default to enabled to avoid breaking keyless accounts
    Self::default_enabled()
}
```

**Option 2: Make the fallback more robust**
```rust
fn equivalent_jwk_consensus_config_from_deprecated_resources(
    payload: &OnChainConfigPayload<P>,
) -> OnChainJWKConsensusConfig {
    let features = payload.get::<Features>().unwrap_or_default(); // Use default instead of .ok()
    let oidc_providers = payload.get::<SupportedOIDCProviders>().ok();
    OnChainJWKConsensusConfig::from((Some(features), oidc_providers))
}
```

**Option 3: Fail explicitly instead of defaulting silently**
Add logging and explicit error handling when configs are missing during non-genesis scenarios to make upgrade issues visible before they cause outages.

**Required governance procedure:**
Document mandatory ordering for config migrations:
1. Initialize new `JWKConsensusConfig` with current settings
2. Wait for epoch boundary
3. Only then deprecate old mechanism

## Proof of Concept

```rust
// This demonstrates the vulnerable code path
#[test]
fn test_missing_features_defaults_to_off() {
    use aptos_types::on_chain_config::{Features, OnChainJWKConsensusConfig};
    use aptos_types::jwks::SupportedOIDCProviders;
    
    // Scenario: Both Features and SupportedOIDCProviders are missing
    let features: Option<Features> = None;
    let providers: Option<SupportedOIDCProviders> = None;
    
    let config = OnChainJWKConsensusConfig::from((features, providers));
    
    // This defaults to Off, breaking keyless accounts
    assert!(matches!(config, OnChainJWKConsensusConfig::Off));
    assert!(!config.jwk_consensus_enabled());
    
    // Expected: Should preserve enabled state or fail explicitly
    // Actual: Silently disables critical authentication mechanism
}
```

## Notes
While the `default_features()` implementation includes `JWK_CONSENSUS` (line 221 in aptos_features.rs), making Features default to enabled, the fallback code uses `.ok()` which converts any fetch error to `None`, bypassing this safety mechanism. The upgrade path should be more defensive given the critical nature of keyless account authentication. [5](#0-4)

### Citations

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L57-59)
```rust
    pub fn default_if_missing() -> Self {
        Self::Off
    }
```

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L112-132)
```rust
impl From<(Option<Features>, Option<SupportedOIDCProviders>)> for OnChainJWKConsensusConfig {
    fn from(
        (features, supported_oidc_providers): (Option<Features>, Option<SupportedOIDCProviders>),
    ) -> Self {
        if let Some(features) = features {
            if features.is_enabled(FeatureFlag::JWK_CONSENSUS) {
                let oidc_providers = supported_oidc_providers
                    .unwrap_or_default()
                    .providers
                    .into_iter()
                    .filter_map(|deprecated| OIDCProvider::try_from(deprecated).ok())
                    .collect();
                OnChainJWKConsensusConfig::V1(ConfigV1 { oidc_providers })
            } else {
                OnChainJWKConsensusConfig::Off
            }
        } else {
            OnChainJWKConsensusConfig::Off
        }
    }
}
```

**File:** consensus/src/epoch_manager.rs (L1223-1226)
```rust
        let jwk_consensus_config = onchain_jwk_consensus_config.unwrap_or_else(|_| {
            // `jwk_consensus_config` not yet initialized, falling back to the old configs.
            Self::equivalent_jwk_consensus_config_from_deprecated_resources(&payload)
        });
```

**File:** consensus/src/epoch_manager.rs (L1963-1969)
```rust
    fn equivalent_jwk_consensus_config_from_deprecated_resources(
        payload: &OnChainConfigPayload<P>,
    ) -> OnChainJWKConsensusConfig {
        let features = payload.get::<Features>().ok();
        let oidc_providers = payload.get::<SupportedOIDCProviders>().ok();
        OnChainJWKConsensusConfig::from((features, oidc_providers))
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L221-221)
```rust
            FeatureFlag::JWK_CONSENSUS,
```
