# Audit Report

## Title
Rate Limit Bypass via Day Boundary and TTL Misalignment in Redis Faucet Checker

## Summary
The `RedisRatelimitChecker` in the Aptos faucet uses misaligned time boundaries for calculating Redis key names versus TTL expiration, creating a ~7-hour window each day where rate limits can be bypassed. This allows attackers to obtain 2-3x their intended daily token allocation by timing requests around UTC midnight.

## Finding Description

The vulnerability stems from two conflicting time calculation methods used in the `get_key_and_secs_until_next_day()` function: [1](#0-0) 

The function calls two helper methods that use incompatible day boundaries:

1. **Day number calculation** uses `days_since_tap_epoch()` which divides time since `TAP_EPOCH_SECS`: [2](#0-1) 

2. **TTL calculation** uses `seconds_until_next_day()` which calculates time until UTC midnight via modulo: [3](#0-2) 

The critical issue: `TAP_EPOCH_SECS` is set to 1664089260, which corresponds to September 25, 2022 at 7:01:00 AM UTC (12:01 AM PDT): [4](#0-3) 

This creates **misaligned boundaries**:
- Redis key day numbers reset at **7:01 AM UTC** (every 86400 seconds from `TAP_EPOCH_SECS`)
- Redis key TTL expires at **00:00 UTC midnight** (every 86400 seconds from Unix epoch)

**Exploitation Window (00:00 - 07:01 AM UTC):**

1. **Before midnight**: User exhausts their daily limit (e.g., 10 requests). Redis key = `"ip:1.2.3.4:123"`, TTL expires at midnight.

2. **After midnight (00:01 AM)**: The old Redis key has expired, but `days_since_tap_epoch()` still returns `123` (day hasn't changed yet, waiting for 7:01 AM).

3. **Bypass occurs**: When checking the limit, Redis GET returns `None` for the expired key. The code treats this as 0 requests: [5](#0-4) 

4. User can make another full allocation of requests. A new key is created with the same day number `123`.

5. **After 7:01 AM**: Day number increments to `124`, creating a new Redis key. User gets a third fresh allocation.

**Result**: In a ~24-hour period, users can obtain up to 3x their configured daily limit.

## Impact Explanation

**Severity: Low** (as indicated in the security question)

This vulnerability:
- Only affects the **Aptos Faucet** (testnet token distribution), not mainnet or consensus
- Does NOT impact blockchain consensus, validator operations, or production funds
- Allows abuse of testnet token distribution for development/testing purposes
- Does not provide attackers with real economic value (testnet tokens have no market value)

Per Aptos bug bounty categories, this qualifies as **Low Severity** ($1,000): "Non-critical implementation bugs" affecting a non-production service component.

## Likelihood Explanation

**Likelihood: High**

The attack is trivially executable:
- No special permissions required
- No complex timing - just make requests between midnight and 7:01 AM UTC
- Automation-friendly: attackers can script requests at these specific times
- Repeatable daily

Any user can exploit this by observing the faucet's UTC-based timing and scheduling requests accordingly.

## Recommendation

**Fix Option 1: Align TTL with day boundaries**

Calculate TTL to expire at the next day boundary (7:01 AM UTC), not UTC midnight:

```rust
fn get_key_and_secs_until_next_day(
    &self,
    ratelimit_key_prefix: &str,
    ratelimit_key_value: &str,
) -> (String, u64) {
    let now_secs = get_current_time_secs();
    let days = days_since_tap_epoch(now_secs);
    let next_day_boundary = TAP_EPOCH_SECS + ((days + 1) * 86400);
    let seconds_until_next_day = next_day_boundary - now_secs;
    let key = format!(
        "{}:{}:{}",
        ratelimit_key_prefix,
        ratelimit_key_value,
        days
    );
    (key, seconds_until_next_day)
}
```

**Fix Option 2: Use UTC midnight for both**

Change `days_since_tap_epoch()` to calculate days from Unix epoch (aligning with UTC midnight):

```rust
pub fn days_since_unix_epoch(current_time_secs: u64) -> u64 {
    current_time_secs / 86400
}
```

Both approaches eliminate the misalignment and close the exploitation window.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    
    #[test]
    fn test_rate_limit_bypass_via_misaligned_boundaries() {
        // TAP_EPOCH_SECS = 1664089260 (Sept 25, 2022 at 7:01 AM UTC)
        const TAP_EPOCH: u64 = 1664089260;
        
        // Scenario: Sept 27, 2022
        // Phase 1: 10:00 AM UTC (before day boundary)
        let time_10am = TAP_EPOCH + 86400 + 10800; // Day 1, 10 AM
        let day_10am = (time_10am - TAP_EPOCH) / 86400; // = 1
        let ttl_10am = 86400 - (time_10am % 86400);
        
        println!("10 AM UTC: day={}, TTL={}h", day_10am, ttl_10am / 3600);
        // Output: day=1, TTL=14h (expires at midnight)
        
        // Phase 2: 00:30 AM UTC next day (after midnight, before 7:01 AM)
        let time_midnight = time_10am + 50400 + 1800; // +14h to midnight, +30min
        let day_midnight = (time_midnight - TAP_EPOCH) / 86400; // STILL = 1!
        let ttl_midnight = 86400 - (time_midnight % 86400);
        
        println!("00:30 AM UTC: day={}, TTL={}h", day_midnight, ttl_midnight / 3600);
        // Output: day=1, TTL=23.5h
        
        // Phase 3: 08:00 AM UTC (after 7:01 AM boundary)
        let time_8am = time_midnight + 27000; // +7.5 hours
        let day_8am = (time_8am - TAP_EPOCH) / 86400; // NOW = 2
        
        println!("08:00 AM UTC: day={}", day_8am);
        // Output: day=2
        
        // Vulnerability confirmed:
        // - Same day number (1) used from 10 AM to 7:01 AM next day
        // - But TTL expires at midnight, creating None window
        // - Then day increments to 2, giving third allocation
        assert_eq!(day_10am, 1);
        assert_eq!(day_midnight, 1); // Same day despite midnight passing
        assert_eq!(day_8am, 2); // Fresh day after 7:01 AM
    }
}
```

## Notes

**To answer the original security question directly:**

1. **"Are time calculations at lines 191-192 done in UTC?"** 
   - YES, all time calculations use UTC (via `SystemTime::now().duration_since(UNIX_EPOCH)`) [6](#0-5) 

2. **"Can an attacker exploit daylight saving time changes or timezone offsets?"**
   - NO for DST/timezone offsets directly (since everything is UTC-based)
   - BUT YES for a different timing attack: The misalignment between day boundaries (7:01 AM UTC) and TTL expiration (midnight UTC) creates an exploitable ~7-hour window where rate limits can be bypassed

The vulnerability is **not** related to timezone manipulation as initially hypothesized, but rather to **internal time boundary misalignment** within the UTC-based system itself. This is a subtle but real implementation flaw that allows 2-3x rate limit bypass.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L186-200)
```rust
    fn get_key_and_secs_until_next_day(
        &self,
        ratelimit_key_prefix: &str,
        ratelimit_key_value: &str,
    ) -> (String, u64) {
        let now_secs = get_current_time_secs();
        let seconds_until_next_day = seconds_until_next_day(now_secs);
        let key = format!(
            "{}:{}:{}",
            ratelimit_key_prefix,
            ratelimit_key_value,
            days_since_tap_epoch(now_secs)
        );
        (key, seconds_until_next_day)
    }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L202-221)
```rust
    fn check_limit_value(
        &self,
        limit_value: Option<i64>,
        seconds_until_next_day: u64,
    ) -> Option<RejectionReason> {
        if limit_value.unwrap_or(0) > self.args.max_requests_per_day as i64 {
            Some(
                RejectionReason::new(
                    format!(
                        "You have reached the maximum allowed number of requests per day: {}",
                        self.args.max_requests_per_day
                    ),
                    RejectionReasonCode::UsageLimitExhausted,
                )
                .retry_after(seconds_until_next_day),
            )
        } else {
            None
        }
    }
```

**File:** crates/aptos-faucet/core/src/helpers.rs (L19-24)
```rust
pub fn get_current_time_secs() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time has gone backwards???")
        .as_secs()
}
```

**File:** crates/aptos-faucet/core/src/helpers.rs (L26-29)
```rust
/// This unixtime is 12:01am PDT on 2021-09-25. See the docstring for
/// RedisRatelimitChecker for more information on how we use this value.
/// We also use this in MemoryRatelimitChecker in a similar way.
pub const TAP_EPOCH_SECS: u64 = 1664089260;
```

**File:** crates/aptos-faucet/core/src/helpers.rs (L33-35)
```rust
pub fn days_since_tap_epoch(current_time_secs: u64) -> u64 {
    (current_time_secs - TAP_EPOCH_SECS) / 86400
}
```

**File:** crates/aptos-faucet/core/src/helpers.rs (L37-40)
```rust
pub fn seconds_until_next_day(current_time_secs: u64) -> u64 {
    let seconds_since_midnight = current_time_secs % 86400;
    86400 - seconds_since_midnight
}
```
