# Audit Report

## Title
Gas Price Manipulation Bypasses Transaction Deduplication Leading to Validator Resource Exhaustion

## Summary
The transaction deduplication mechanism in Aptos consensus uses `(committed_hash, authenticator)` pairs as deduplication keys. Since `gas_unit_price` is part of the hashed `RawTransaction`, transactions with identical sender, sequence number, and payload but different gas prices bypass deduplication. An attacker can exploit this by submitting variants to different validators, causing redundant signature verification and resource waste.

## Finding Description

The vulnerability exists in the consensus transaction deduplication logic. The deduplication mechanism uses `(txn.committed_hash(), txn.authenticator())` as the unique identifier for filtering duplicates: [1](#0-0) 

The `committed_hash()` function computes a hash of the entire `SignedTransaction` (which includes the `RawTransaction`): [2](#0-1) 

The `RawTransaction` struct includes `gas_unit_price` as a field: [3](#0-2) 

This design allows transactions with identical sender, sequence number, and payload but different `gas_unit_price` values to have different hashes and bypass deduplication.

**Attack Execution Path:**

1. Attacker submits Transaction A with gas_price=100 to Validator 1's mempool
2. Attacker submits Transaction A with gas_price=200 to Validator 2's mempool  
3. Each validator's mempool accepts their version (mempool allows gas price updates within a single validator): [4](#0-3) 

4. Validator 1's quorum store creates Batch_1 with gas_price=100 version
5. Validator 2's quorum store creates Batch_2 with gas_price=200 version
6. The quorum store tracks transactions using `TransactionSummary` which includes the hash: [5](#0-4) 

7. Block leader pulls both batches. The batch-level deduplication uses transaction summaries with hashes, so different gas prices pass through: [6](#0-5) 

8. Block preparation runs deduplication: [7](#0-6) 

9. Both transactions pass deduplication (different hashes) and undergo expensive parallel signature verification
10. During execution, the first transaction succeeds and increments the account's sequence number
11. The second transaction fails with `SEQUENCE_NUMBER_TOO_OLD`: [8](#0-7) 

The existing test confirms this behavior is by design - transactions with the same sender and sequence number but different content are not filtered: [9](#0-8) 

## Impact Explanation

**Severity: High** (per Aptos bug bounty criteria for "Validator node slowdowns")

This vulnerability enables a scalable resource exhaustion attack:

1. **Validator CPU Exhaustion**: Each duplicate variant undergoes expensive cryptographic signature verification operations in the parallel SIG_VERIFY_POOL, consuming significant CPU resources without producing valid transactions.

2. **Block Space Wastage**: Invalid duplicate transactions occupy block space that could contain valid transactions, directly reducing network throughput.

3. **Network Bandwidth Waste**: Duplicate transactions are propagated through the quorum store network and stored by multiple validators.

4. **Scalable DoS**: An attacker can submit N variants (up to ~100-150 variants matching the number of validators) of the same logical transaction with different gas prices. Each variant forces validators to perform signature verification, creating an NÃ— amplification of wasted work.

This directly aligns with the High severity "Validator Node Slowdowns" category in the Aptos bug bounty program, as it causes significant performance degradation through protocol-level resource exhaustion.

## Likelihood Explanation

**Likelihood: High**

The attack is highly feasible:

1. **No Special Access**: Any user can submit transactions to multiple validators' public mempool endpoints
2. **Low Cost**: The attacker only pays gas for the one transaction that executes successfully; failed duplicates are discarded without gas charges
3. **Simple Execution**: The attacker signs the same transaction multiple times with different `gas_unit_price` values and submits each variant to a different validator
4. **Difficult to Detect**: Individual validators see legitimate gas price updates in their own mempools; the pattern only becomes apparent when variants from multiple validators are included in a single block
5. **Limited Mitigation**: While per-validator rate limiting exists, it doesn't prevent coordinated submission across multiple validators

## Recommendation

Implement sequence-number-aware deduplication that filters transactions with the same `(sender, sequence_number)` pair regardless of other fields. This could be done by:

1. Adding a first-stage deduplication filter based on `(sender, replay_protector)` pairs before the current hash-based deduplication
2. For transactions with duplicate `(sender, sequence_number)`, select only the one with highest gas price
3. This would prevent the resource waste while maintaining the ability to process legitimate gas price bumps

Alternatively, implement batch-level deduplication in the quorum store that detects and filters semantic duplicates (same sender/sequence) across different batches before block construction.

## Proof of Concept

The existing test `test_repeated_sequence_number` demonstrates that transactions with the same sender and sequence number but different content (including different gas prices) are not filtered by deduplication: [9](#0-8) 

A full PoC would involve:
1. Creating multiple signed transactions with same sender, sequence number, and payload but different gas_unit_price values
2. Submitting each variant to a different validator's mempool
3. Observing that a block can include multiple variants
4. Measuring the wasted signature verification operations for the variants that fail with SEQUENCE_NUMBER_TOO_OLD

## Notes

This vulnerability represents a design trade-off where conservative deduplication (to avoid complex validation before signature verification) creates an exploitable resource exhaustion vector. While the system correctly handles these transactions at execution time, the intermediate processing (signature verification, prologue validation) represents wasted validator resources that can be exploited at scale.

The attack amplification factor is limited by the number of validators (~100-150 on mainnet), but this is still sufficient to cause measurable performance degradation and throughput reduction when exploited systematically.

### Citations

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L68-68)
```rust
                true => Some((txn.committed_hash(), txn.authenticator())),
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L236-256)
```rust
    fn test_repeated_sequence_number() {
        let deduper = TxnHashAndAuthenticatorDeduper::new();

        let sender = Account::new();
        let receiver = Account::new();

        let txn_0a = empty_txn(sender.addr, 0, 100)
            .sign(&sender.privkey, sender.pubkey.clone())
            .unwrap()
            .into_inner();
        // Different txn, same sender and sequence number. Should not be filtered.
        let txn_0b = peer_to_peer_txn(sender.addr, receiver.addr, 0, 100)
            .sign(&sender.privkey, sender.pubkey)
            .unwrap()
            .into_inner();
        let txns = block(vec![&txn_0a, &txn_0b, &txn_0a]);
        let expected = block(vec![&txn_0a, &txn_0b]);
        let deduped_txns = deduper.dedup(txns);
        assert_eq!(expected.len(), deduped_txns.len());
        assert_eq!(expected, deduped_txns);
    }
```

**File:** types/src/transaction/mod.rs (L194-194)
```rust
    gas_unit_price: u64,
```

**File:** types/src/transaction/mod.rs (L1335-1339)
```rust
    pub fn committed_hash(&self) -> HashValue {
        *self
            .committed_hash
            .get_or_init(|| Transaction::UserTransaction(self.clone()).hash())
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L274-278)
```rust
                } else if current_version.get_gas_price() < txn.get_gas_price() {
                    // Update txn if gas unit price is a larger value than before
                    if let Some(txn) = txns.remove(&txn_replay_protector) {
                        self.index_remove(&txn);
                    };
```

**File:** consensus/consensus-types/src/common.rs (L38-42)
```rust
pub struct TransactionSummary {
    pub sender: AccountAddress,
    pub replay_protector: ReplayProtector,
    pub hash: HashValue,
}
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L642-643)
```rust
                                    .filter(|txn_summary| {
                                        !filtered_txns.contains(txn_summary)
```

**File:** consensus/src/block_preparer.rs (L99-99)
```rust
            let deduped_txns = txn_deduper.dedup(filtered_txns);
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L63-63)
```text
    const PROLOGUE_ESEQUENCE_NUMBER_TOO_OLD: u64 = 1002;
```
