# Audit Report

## Title
Database State Inconsistency After Interrupted Genesis Commit

## Summary
An interrupted commit during genesis bootstrapping leaves the AptosDB in an inconsistent state where physical databases contain data but the commit progress marker is missing. The recovery mechanism fails to detect and remediate this inconsistency, potentially causing validator startup failures and requiring manual database deletion.

## Finding Description
The genesis bootstrap process in `Command::run()` follows a two-phase commit pattern: [1](#0-0) 

The commit process delegates to `GenesisCommitter::commit()` which calls `save_transactions()`: [2](#0-1) 

This internally executes two sequential operations via the `DbWriter` trait:
1. `pre_commit_ledger()` - writes genesis data to all databases
2. `commit_ledger()` - writes the `OverallCommitProgress` marker [3](#0-2) 

**The Critical Flaw:**

When a process interruption (crash, SIGKILL, power failure) occurs after `pre_commit_ledger()` completes but before `commit_ledger()` finishes:
- Physical databases (transaction_db, state_kv_db, transaction_accumulator_db, etc.) contain genesis data at version 0
- `LedgerCommitProgress` and `StateKvCommitProgress` metadata are written: [4](#0-3) 
- **`OverallCommitProgress` is NOT written** (still None)

On database reopening, `StateStore::sync_commit_progress()` is designed to detect and truncate inconsistencies: [5](#0-4) 

However, this function has a critical gap: **it only performs truncation when `OverallCommitProgress` exists**. When `OverallCommitProgress` is None (the interrupted genesis case), it simply logs a message and performs no remediation: [6](#0-5) 

This creates a state where:
1. Physical databases contain partial or complete genesis data
2. The buffered state is initialized as empty (version 0) because `get_synced_version()` returns None: [7](#0-6) 
3. In-memory transaction accumulator shows 0 leaves while physical DB has data: [8](#0-7) 

## Impact Explanation
This issue qualifies as **Medium Severity** under the Aptos bug bounty program category: "State inconsistencies requiring intervention."

**Actual Impact:**
- Validator nodes may fail to start after interrupted genesis bootstrap
- Database enters an unrecoverable state requiring manual deletion and re-initialization
- Potential for subtle data corruption if some parallel writes in `pre_commit_ledger()` completed while others did not: [9](#0-8) 

**Impact Limitations:**
- Does NOT cause network-wide consensus violations (local database issue only)
- Does NOT result in funds loss or theft
- The waypoint verification mechanism prevents committing incorrect genesis data
- Recovery is possible by re-running bootstrap with the correct genesis file and waypoint

However, this falls short of High/Critical severity because:
- It's a local operational issue, not a network security vulnerability
- Requires specific timing of process interruption during a narrow window
- The waypoint check provides protection against data corruption

## Likelihood Explanation
**Moderate likelihood** in production environments:
- Process interruptions during deployment are common (system crashes, OOM kills, operator errors)
- The vulnerable window occurs during every genesis bootstrap operation
- Operators may not immediately recognize the inconsistent state
- The failure mode is subtle - databases appear to have data but logical state is empty

**Triggering conditions:**
- Any process interruption (SIGKILL, SIGTERM, crash, power failure) between lines 620 and 627 of `save_transactions()`
- Parallel write threads in `pre_commit_ledger()` may complete partially if interrupted during execution

## Recommendation
Enhance `sync_commit_progress()` to detect and remediate the missing `OverallCommitProgress` case:

```rust
pub fn sync_commit_progress(
    ledger_db: Arc<LedgerDb>,
    state_kv_db: Arc<StateKvDb>,
    state_merkle_db: Arc<StateMerkleDb>,
    crash_if_difference_is_too_large: bool,
) {
    let ledger_metadata_db = ledger_db.metadata_db();
    if let Some(overall_commit_progress) = ledger_metadata_db
        .get_synced_version()
        .expect("DB read failed.")
    {
        // Existing truncation logic...
    } else {
        // NEW: Check if databases actually have any data
        let ledger_commit_progress = ledger_metadata_db
            .get_ledger_commit_progress()
            .ok();
        
        if let Some(ledger_progress) = ledger_commit_progress {
            // Data exists but OverallCommitProgress is missing - truncate everything
            warn!(
                "Found data at version {} but no OverallCommitProgress. Truncating to empty state.",
                ledger_progress
            );
            truncate_ledger_db(ledger_db.clone(), None).expect("Failed to truncate");
            truncate_state_kv_db(&state_kv_db, ledger_progress, 0, 1).expect("Failed to truncate");
            truncate_state_merkle_db(&state_merkle_db, 0).expect("Failed to truncate");
        } else {
            info!("No overall commit progress was found and database is empty - fresh start.");
        }
    }
}
```

Additionally, consider making the bootstrap tool idempotent by checking database state before proceeding.

## Proof of Concept

```rust
#[cfg(test)]
mod test_interrupted_genesis {
    use super::*;
    use aptos_db::AptosDB;
    use aptos_storage_interface::{DbWriter, DbReader};
    use aptos_temppath::TempPath;
    use std::sync::Arc;

    #[test]
    fn test_interrupted_genesis_commit() {
        // Setup temporary database
        let tmpdir = TempPath::new();
        let db = AptosDB::open(
            StorageDirPaths::from_path(&tmpdir),
            false,
            NO_OP_STORAGE_PRUNER_CONFIG,
            RocksdbConfigs::default(),
            false,
            BUFFERED_STATE_TARGET_ITEMS,
            DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD,
            None,
            HotStateConfig::default(),
        ).unwrap();
        let db = DbReaderWriter::new(db);

        // Load genesis transaction
        let genesis_txn = load_genesis_txn(&genesis_file).unwrap();
        
        // Calculate genesis
        let ledger_summary = db.reader.get_pre_committed_ledger_summary().unwrap();
        let committer = calculate_genesis::<AptosVMBlockExecutor>(
            &db, 
            ledger_summary, 
            &genesis_txn
        ).unwrap();

        // Simulate interrupted commit - call pre_commit_ledger but not commit_ledger
        let chunk = committer.output.output.expect_complete_result().as_chunk_to_commit();
        db.writer.pre_commit_ledger(chunk.clone(), true).unwrap();
        
        // Simulate crash by dropping DB without calling commit_ledger
        drop(db);

        // Reopen database - this triggers sync_commit_progress
        let db_reopened = AptosDB::open(
            StorageDirPaths::from_path(&tmpdir),
            false,
            NO_OP_STORAGE_PRUNER_CONFIG,
            RocksdbConfigs::default(),
            false,
            BUFFERED_STATE_TARGET_ITEMS,
            DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD,
            None,
            HotStateConfig::default(),
        ).unwrap();
        let db_reopened = DbReaderWriter::new(db_reopened);

        // Verify inconsistent state
        let ledger_summary_after = db_reopened.reader.get_pre_committed_ledger_summary().unwrap();
        
        // Bug: next_version() returns 0 (empty) but databases have data
        assert_eq!(ledger_summary_after.next_version(), 0);
        
        // But LedgerCommitProgress exists with version 0
        let ledger_progress = db_reopened.reader
            .ledger_db.metadata_db()
            .get_ledger_commit_progress();
        assert_eq!(ledger_progress.unwrap(), 0);
        
        // This inconsistency causes problems when trying to bootstrap again
        println!("Database in inconsistent state: logical version=0, physical data exists at version 0");
    }
}
```

**Notes:**
- This vulnerability affects the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs"
- The atomic commit guarantee is violated when interruptions occur between the two-phase commit
- While the waypoint verification provides some protection, the recovery mechanism has a blind spot for the genesis case where `OverallCommitProgress` is expected to be None for fresh databases
- The fix requires distinguishing between "truly empty database" and "interrupted commit with missing OverallCommitProgress"

### Citations

**File:** storage/db-tool/src/bootstrap.rs (L96-101)
```rust
            if self.commit {
                committer
                    .commit()
                    .with_context(|| format_err!("Committing genesis to DB."))?;
                println!("Successfully committed genesis.")
            }
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L99-112)
```rust
    pub fn commit(self) -> Result<()> {
        self.db.save_transactions(
            self.output
                .output
                .expect_complete_result()
                .as_chunk_to_commit(),
            self.output.ledger_info_opt.as_ref(),
            true, /* sync_commit */
        )?;
        info!("Genesis commited.");
        // DB bootstrapped, avoid anything that could fail after this.

        Ok(())
    }
```

**File:** storage/storage-interface/src/lib.rs (L608-628)
```rust
    fn save_transactions(
        &self,
        chunk: ChunkToCommit,
        ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
        sync_commit: bool,
    ) -> Result<()> {
        // For reconfig suffix.
        if ledger_info_with_sigs.is_none() && chunk.is_empty() {
            return Ok(());
        }

        if !chunk.is_empty() {
            self.pre_commit_ledger(chunk.clone(), sync_commit)?;
        }
        let version_to_commit = if let Some(ledger_info_with_sigs) = ledger_info_with_sigs {
            ledger_info_with_sigs.ledger_info().version()
        } else {
            chunk.expect_last_version()
        };
        self.commit_ledger(version_to_commit, ledger_info_with_sigs, Some(chunk))
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L271-319)
```rust
        THREAD_MANAGER.get_non_exe_cpu_pool().scope(|s| {
            // TODO(grao): Write progress for each of the following databases, and handle the
            // inconsistency at the startup time.
            //
            // TODO(grao): Consider propagating the error instead of panic, if necessary.
            s.spawn(|_| {
                self.commit_events(
                    chunk.first_version,
                    chunk.transaction_outputs,
                    skip_index_and_usage,
                )
                .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .write_set_db()
                    .commit_write_sets(chunk.first_version, chunk.transaction_outputs)
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .transaction_db()
                    .commit_transactions(
                        chunk.first_version,
                        chunk.transactions,
                        skip_index_and_usage,
                    )
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .persisted_auxiliary_info_db()
                    .commit_auxiliary_info(chunk.first_version, chunk.persisted_auxiliary_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_state_kv_and_ledger_metadata(chunk, skip_index_and_usage)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_transaction_infos(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                new_root_hash = self
                    .commit_transaction_accumulator(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
        });
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L360-365)
```rust
        ledger_metadata_batch
            .put::<DbMetadataSchema>(
                &DbMetadataKey::LedgerCommitProgress,
                &DbMetadataValue::Version(chunk.expect_last_version()),
            )
            .unwrap();
```

**File:** storage/aptosdb/src/state_store/mod.rs (L410-502)
```rust
    pub fn sync_commit_progress(
        ledger_db: Arc<LedgerDb>,
        state_kv_db: Arc<StateKvDb>,
        state_merkle_db: Arc<StateMerkleDb>,
        crash_if_difference_is_too_large: bool,
    ) {
        let ledger_metadata_db = ledger_db.metadata_db();
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");

            // State K/V commit progress isn't (can't be) written atomically with the data,
            // because there are shards, so we have to attempt truncation anyway.
            info!(
                state_kv_commit_progress = state_kv_commit_progress,
                "Start state KV truncation..."
            );
            let difference = state_kv_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_state_kv_db(
                &state_kv_db,
                state_kv_commit_progress,
                overall_commit_progress,
                std::cmp::max(difference as usize, 1), /* batch_size */
            )
            .expect("Failed to truncate state K/V db.");

            let state_merkle_max_version = get_max_version_in_state_merkle_db(&state_merkle_db)
                .expect("Failed to get state merkle max version.")
                .expect("State merkle max version cannot be None.");
            if state_merkle_max_version > overall_commit_progress {
                let difference = state_merkle_max_version - overall_commit_progress;
                if crash_if_difference_is_too_large {
                    assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
                }
            }
            let state_merkle_target_version = find_tree_root_at_or_before(
                ledger_metadata_db,
                &state_merkle_db,
                overall_commit_progress,
            )
            .expect("DB read failed.")
            .unwrap_or_else(|| {
                panic!(
                    "Could not find a valid root before or at version {}, maybe it was pruned?",
                    overall_commit_progress
                )
            });
            if state_merkle_target_version < state_merkle_max_version {
                info!(
                    state_merkle_max_version = state_merkle_max_version,
                    target_version = state_merkle_target_version,
                    "Start state merkle truncation..."
                );
                truncate_state_merkle_db(&state_merkle_db, state_merkle_target_version)
                    .expect("Failed to truncate state merkle db.");
            }
        } else {
            info!("No overall commit progress was found!");
        }
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L561-565)
```rust
        let num_transactions = state_db
            .ledger_db
            .metadata_db()
            .get_synced_version()?
            .map_or(0, |v| v + 1);
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L709-728)
```rust
    fn get_pre_committed_ledger_summary(&self) -> Result<LedgerSummary> {
        gauged_api("get_pre_committed_ledger_summary", || {
            let (state, state_summary) = self
                .state_store
                .current_state_locked()
                .to_state_and_summary();
            let num_txns = state.next_version();

            let frozen_subtrees = self
                .ledger_db
                .transaction_accumulator_db()
                .get_frozen_subtree_hashes(num_txns)?;
            let transaction_accumulator =
                Arc::new(InMemoryAccumulator::new(frozen_subtrees, num_txns)?);
            Ok(LedgerSummary {
                state,
                state_summary,
                transaction_accumulator,
            })
        })
```
