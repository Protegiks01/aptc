# Audit Report

## Title
BLS12381 Private Key Memory Disclosure via Missing Zeroization

## Summary
The BLS12381 `PrivateKey::to_bytes()` function and related serialization paths do not zeroize sensitive private key material after use, leaving validator consensus keys exposed in memory. This violates cryptographic best practices and creates multiple attack vectors for key extraction through memory analysis.

## Finding Description

The vulnerability exists across multiple code paths in the BLS12381 private key implementation:

**Primary Vulnerability Location:** [1](#0-0) 

This function returns a fixed-size byte array containing the raw private key material without any zeroization mechanism.

**Secondary Exposure - ValidCryptoMaterial Trait:** [2](#0-1) 

The trait implementation creates a `Vec<u8>` from the byte array, which is also not zeroized when dropped.

**Tertiary Exposure - Clone Implementation:** [3](#0-2) 

The Clone trait creates serialized intermediate copies that remain in memory.

**Key Encoding Exposure:** [4](#0-3) 

The encoding functions call `to_bytes()` multiple times, creating additional unzeroized copies for hex/base64 encoding.

**Serialization Derive Macro:** [5](#0-4) 

The SerializeKey macro generates code that calls `to_bytes()` without zeroization.

**Validator Usage Context:** [6](#0-5) 

ValidatorSigner uses Arc-wrapped BLS12381 private keys for consensus signing operations.

**Storage Layer:** [7](#0-6) 

Private keys are stored and retrieved from secure storage without memory protection guarantees.

**Attack Vectors:**

1. **Core Dumps**: When a validator node crashes, core dumps contain unzeroized key material
2. **Memory Dumps**: Diagnostic tools or compromised monitoring systems can extract keys
3. **Swap Space**: Keys paged to disk remain unencrypted and unzeroized
4. **Cold Boot Attacks**: RAM retains data briefly after power loss
5. **Memory Allocator Reuse**: Freed memory may be reallocated before being overwritten

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria)

This vulnerability enables validator private key disclosure, which directly threatens:

1. **Consensus Safety**: Stolen validator keys allow signature forgery, enabling:
   - Vote manipulation
   - Proposal signing by non-validators
   - Quorum certificate forgery
   
2. **Byzantine Attack Enablement**: Each compromised validator key reduces the Byzantine fault tolerance threshold, potentially enabling attacks below the 1/3 threshold

3. **Validator Impersonation**: Attackers can participate in consensus as legitimate validators

This breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure."

The impact qualifies as HIGH severity under "Significant protocol violations" as it compromises the fundamental security assumption of validator key confidentiality.

## Likelihood Explanation

**Likelihood: MEDIUM**

While exploitation requires some level of system access, multiple realistic scenarios exist:

1. **Privileged Access**: Root compromise of validator nodes (increasingly common in cloud environments)
2. **Diagnostic Tools**: Memory profiling or debugging tools in development/staging environments
3. **Core Dumps**: Automatically generated during crashes and often uploaded to monitoring systems
4. **Container Escapes**: Kubernetes/Docker escapes providing memory access
5. **Supply Chain**: Compromised monitoring agents with memory access

The likelihood is MEDIUM rather than LOW because:
- Validator nodes are high-value targets
- Memory dumps are routine in operations
- Multiple code paths expose the vulnerability
- No compensating controls exist

## Recommendation

Implement secure zeroization using Rust's `zeroize` crate:

```rust
use zeroize::{Zeroize, ZeroizeOnDrop};

// Modify PrivateKey to implement ZeroizeOnDrop
#[derive(SerializeKey, DeserializeKey, SilentDebug, SilentDisplay, ZeroizeOnDrop)]
pub struct PrivateKey {
    pub(crate) privkey: blst::min_pk::SecretKey,
}

// Create a zeroizing wrapper for byte arrays
impl PrivateKey {
    pub fn to_bytes(&self) -> [u8; Self::LENGTH] {
        self.privkey.to_bytes()
    }
    
    // Provide a secure variant that zeroizes
    pub fn to_bytes_zeroizing(&self) -> ZeroizingBytes<Self::LENGTH> {
        ZeroizingBytes::new(self.to_bytes())
    }
}

// Wrapper type that zeroizes on drop
pub struct ZeroizingBytes<const N: usize>([u8; N]);

impl<const N: usize> ZeroizingBytes<N> {
    fn new(bytes: [u8; N]) -> Self {
        Self(bytes)
    }
}

impl<const N: usize> Drop for ZeroizingBytes<N> {
    fn drop(&mut self) {
        self.0.zeroize();
    }
}

// Update ValidCryptoMaterial trait implementation
impl traits::ValidCryptoMaterial for PrivateKey {
    const AIP_80_PREFIX: &'static str = "bls12381-priv-";
    
    fn to_bytes(&self) -> Vec<u8> {
        let bytes = self.to_bytes();
        let vec = bytes.to_vec();
        // Zeroize the temporary array
        let mut temp = bytes;
        temp.zeroize();
        vec
    }
}
```

Additionally:
1. Audit all call sites to use zeroizing variants
2. Implement `Drop` for PrivateKey to zeroize internal state
3. Use `secrecy` crate for secret values
4. Enable memory locking via `mlock()` where possible
5. Document security-critical paths requiring zeroization

## Proof of Concept

```rust
use aptos_crypto::{bls12381, Uniform, PrivateKey};
use std::ptr;

fn main() {
    // Generate a private key
    let mut rng = rand::thread_rng();
    let private_key = bls12381::PrivateKey::generate(&mut rng);
    
    // Call to_bytes() - this creates a copy in memory
    let key_bytes = private_key.to_bytes();
    let key_ptr = key_bytes.as_ptr();
    
    println!("Key bytes address: {:p}", key_ptr);
    println!("First 8 bytes: {:02x?}", &key_bytes[..8]);
    
    // Drop the key_bytes array
    drop(key_bytes);
    
    // Memory is NOT zeroized - we can still read it
    // (In real attack, this would be via memory dump/core dump)
    unsafe {
        let leaked_bytes = std::slice::from_raw_parts(key_ptr, 32);
        println!("After drop, first 8 bytes still readable: {:02x?}", 
                 &leaked_bytes[..8]);
        // This demonstrates the memory is not zeroized
    }
    
    // Demonstrate with ValidCryptoMaterial trait
    let vec_bytes = aptos_crypto::ValidCryptoMaterial::to_bytes(&private_key);
    let vec_ptr = vec_bytes.as_ptr();
    println!("\nVec bytes address: {:p}", vec_ptr);
    
    drop(vec_bytes);
    
    unsafe {
        let leaked_vec = std::slice::from_raw_parts(vec_ptr, 32);
        println!("After Vec drop, bytes still readable: {:02x?}", 
                 &leaked_vec[..8]);
    }
}
```

To verify the vulnerability exists:
1. Compile with `cargo build --release`
2. Run the binary
3. Observe that dropped memory still contains key material
4. Generate a core dump during execution (`kill -ABRT <pid>`)
5. Analyze core dump with `gdb` or `lldb` to extract key bytes

**Notes**

This vulnerability affects all private key types in the codebase (Ed25519, Secp256k1, Secp256r1) as they follow the same pattern. The issue is particularly critical for BLS12381 keys used in consensus as validator compromise directly threatens network security. While the underlying BLST library may handle its own memory securely, the Aptos wrapper code creates multiple unprotected copies during serialization, encoding, and cloning operations.

### Citations

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L94-97)
```rust
    /// Serialize a PrivateKey.
    pub fn to_bytes(&self) -> [u8; Self::LENGTH] {
        self.privkey.to_bytes()
    }
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L131-137)
```rust
impl traits::ValidCryptoMaterial for PrivateKey {
    const AIP_80_PREFIX: &'static str = "bls12381-priv-";

    fn to_bytes(&self) -> Vec<u8> {
        self.to_bytes().to_vec()
    }
}
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L184-190)
```rust
#[cfg(any(test, feature = "cloneable-private-keys"))]
impl Clone for PrivateKey {
    fn clone(&self) -> Self {
        let serialized: &[u8] = &(self.to_bytes());
        PrivateKey::try_from(serialized).unwrap()
    }
}
```

**File:** crates/aptos-crypto/src/encoding_type.rs (L50-62)
```rust
impl EncodingType {
    /// Encodes `Key` into one of the `EncodingType`s
    pub fn encode_key<Key: ValidCryptoMaterial>(
        &self,
        name: &'static str,
        key: &Key,
    ) -> Result<Vec<u8>, EncodingError> {
        Ok(match self {
            EncodingType::Hex => hex::encode_upper(key.to_bytes()).into_bytes(),
            EncodingType::BCS => bcs::to_bytes(key).map_err(|err| EncodingError::BCS(name, err))?,
            EncodingType::Base64 => base64::encode(key.to_bytes()).into_bytes(),
        })
    }
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L185-211)
```rust
#[proc_macro_derive(SerializeKey)]
pub fn serialize_key(source: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(source).expect("Incorrect macro input");
    let name = &ast.ident;
    let name_string = find_key_name(&ast, name.to_string());
    quote! {
        impl ::serde::Serialize for #name {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: ::serde::Serializer,
            {
                if serializer.is_human_readable() {
                    self.to_encoded_string()
                        .map_err(<S::Error as ::serde::ser::Error>::custom)
                        .and_then(|str| serializer.serialize_str(&str[..]))
                } else {
                    // See comment in deserialize_key.
                    serializer.serialize_newtype_struct(
                        #name_string,
                        serde_bytes::Bytes::new(&ValidCryptoMaterial::to_bytes(self).as_slice()),
                    )
                }
            }
        }
    }
    .into()
}
```

**File:** types/src/validator_signer.rs (L16-29)
```rust
#[derive(Debug)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Clone))]
pub struct ValidatorSigner {
    author: AccountAddress,
    private_key: Arc<bls12381::PrivateKey>,
}

impl ValidatorSigner {
    pub fn new(author: AccountAddress, private_key: Arc<bls12381::PrivateKey>) -> Self {
        ValidatorSigner {
            author,
            private_key,
        }
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-81)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }

        internal_store.set(OWNER_ACCOUNT, author)?;
        Ok(())
    }
```
