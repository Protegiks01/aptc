# Audit Report

## Title
Missing Cryptographic Verification of Aggregated VUF Proofs Enables Silent Randomness Corruption

## Summary
The consensus randomness generation system fails to cryptographically verify aggregated VUF proofs before deriving randomness values. While individual proof shares are verified, the aggregated proof is never validated against the round metadata, and the `derive_eval` function ignores its message parameter entirely. This creates a critical gap where metadata mismatches or aggregation errors would go undetected, potentially causing consensus to use incorrect randomness for a given round.

## Finding Description

The Aptos consensus uses a Weighted Verifiable Unpredictable Function (WVUF) for randomness generation. The intended protocol flow requires:

1. Each validator creates a `ProofShare` for message M using `create_share(ask, M)` [1](#0-0) 
2. Other validators verify shares using `verify_share(pp, apk, M, proof_share)` [2](#0-1) 
3. Shares are aggregated using `aggregate_shares()` [3](#0-2) 
4. **The aggregated proof should be verified using `verify_proof(pp, pk, apks, M, proof)`** [4](#0-3) 
5. Finally, derive evaluation using `derive_eval()` [5](#0-4) 

**The vulnerability:** The consensus implementation in `Share::aggregate()` skips step 4 entirely. After aggregating shares, it directly calls `derive_eval` without calling `verify_proof`: [6](#0-5) 

This is exacerbated by the fact that both WVUF implementations (BLS and Pinkas) completely ignore the message parameter in `derive_eval`:

- **Pinkas implementation:** [7](#0-6) 
- **BLS implementation:** [8](#0-7) 

The test code demonstrates the correct usage pattern with `verify_proof` being called after aggregation: [9](#0-8) 

**Attack Scenario:**

While individual ProofShares ARE cryptographically bound to messages during creation: [10](#0-9) 

And verified correctly: [11](#0-10) 

The missing `verify_proof` call creates vulnerability if:
1. A bug causes metadata mismatch between share collection and aggregation
2. State corruption affects the `RandMetadata` passed to `aggregate()`
3. Race conditions in `RandStore` cause wrong metadata to be used
4. Aggregation logic has bugs producing invalid proofs

Since `derive_eval` ignores its message parameter, even if the correct metadata is passed, it's never validated. The system would silently compute randomness based on whatever proof was aggregated, regardless of whether it corresponds to the claimed round/epoch.

## Impact Explanation

This vulnerability breaks the **Cryptographic Correctness** invariant and could lead to **Consensus Safety violations** (Critical Severity per bug bounty).

If exploited (via a secondary bug causing metadata mismatch):
- Different validators might use different randomness for the same round
- This breaks deterministic execution, violating the consensus protocol
- Could cause chain splits or safety failures
- Affects leader election and other consensus operations dependent on randomness

The lack of cryptographic verification means bugs would manifest as silent consensus divergence rather than explicit verification failures, making them harder to detect and debug.

## Likelihood Explanation

**Current likelihood: Medium-to-Low** - Requires a secondary bug (metadata handling error, race condition, or state corruption) to manifest.

**Defense-in-depth failure:** The system relies solely on code correctness for metadata consistency rather than cryptographic guarantees. The `RandStore` does have metadata checks: [12](#0-11) 

However, these are programmatic checks that can be bypassed by bugs. The missing `verify_proof` call means there's no cryptographic backstop.

## Recommendation

Add `verify_proof` call before `derive_eval` in `Share::aggregate()`:

```rust
fn aggregate<'a>(
    shares: impl Iterator<Item = &'a RandShare<Self>>,
    rand_config: &RandConfig,
    rand_metadata: RandMetadata,
) -> anyhow::Result<Randomness>
where
    Self: Sized,
{
    // ... existing code to collect shares and aggregate ...
    
    let proof = WVUF::aggregate_shares(&rand_config.wconfig, &apks_and_proofs);
    let metadata_serialized = bcs::to_bytes(&rand_metadata)
        .map_err(|e| anyhow!("Share::aggregate failed with metadata serialization error: {e}"))?;
    
    // ADD THIS: Verify aggregated proof before deriving evaluation
    WVUF::verify_proof(
        &rand_config.vuf_pp,
        &rand_config.keys.pk,  // Would need to store PK in RandConfig
        &rand_config.get_all_certified_apk(),
        metadata_serialized.as_slice(),
        &proof,
    ).map_err(|e| anyhow!("Share::aggregate failed with proof verification error: {e}"))?;
    
    let eval = WVUF::derive_eval(
        &rand_config.wconfig,
        &rand_config.vuf_pp,
        metadata_serialized.as_slice(),
        &rand_config.get_all_certified_apk(),
        &proof,
        THREAD_MANAGER.get_exe_cpu_pool(),
    ).map_err(|e| anyhow!("Share::aggregate failed with WVUF derive_eval error: {e}"))?;
    
    // ... rest of function ...
}
```

## Proof of Concept

This vulnerability cannot be demonstrated with a standalone PoC because it requires a secondary bug (metadata mismatch or aggregation error) to manifest. However, the following test would fail if such a bug existed and demonstrates the missing check:

```rust
#[test]
fn test_aggregated_proof_must_match_metadata() {
    // Setup: Create shares for round 100
    let round_100_metadata = RandMetadata { epoch: 1, round: 100 };
    let shares_for_100 = create_and_verify_shares(round_100_metadata.clone());
    
    // Aggregate shares (this would work)
    let proof = WVUF::aggregate_shares(&wconfig, &shares_for_100);
    
    // BUG SIMULATION: Try to use this proof for round 101
    let round_101_metadata = RandMetadata { epoch: 1, round: 101 };
    let metadata_101_serialized = bcs::to_bytes(&round_101_metadata).unwrap();
    
    // Current code: derive_eval would succeed (ignores message!)
    let eval = WVUF::derive_eval(
        &wconfig, &vuf_pp, 
        metadata_101_serialized.as_slice(),  // Wrong metadata!
        &apks, &proof, &thread_pool
    );
    assert!(eval.is_ok());  // PASSES - but shouldn't!
    
    // With fix: verify_proof would catch the mismatch
    let verify_result = WVUF::verify_proof(
        &vuf_pp, &pk, &apks,
        metadata_101_serialized.as_slice(),
        &proof
    );
    assert!(verify_result.is_err());  // FAILS - proof is for round 100, not 101!
}
```

The test demonstrates that without `verify_proof`, there's no cryptographic check ensuring the proof corresponds to the claimed metadata.

---

**Notes:**
- Individual ProofShares ARE cryptographically bound and cannot be directly reused across messages
- The vulnerability is at the **aggregation level** where proof verification is skipped
- This is a defense-in-depth failure that could enable silent consensus corruption if combined with metadata handling bugs
- The fix requires adding the public key to `RandConfig` and calling `verify_proof` before `derive_eval`

### Citations

**File:** crates/aptos-dkg/src/weighted_vuf/traits.rs (L49-49)
```rust
    fn create_share(ask: &Self::AugmentedSecretKeyShare, msg: &[u8]) -> Self::ProofShare;
```

**File:** crates/aptos-dkg/src/weighted_vuf/traits.rs (L51-56)
```rust
    fn verify_share(
        pp: &Self::PublicParameters,
        apk: &Self::AugmentedPubKeyShare,
        msg: &[u8],
        proof: &Self::ProofShare,
    ) -> anyhow::Result<()>;
```

**File:** crates/aptos-dkg/src/weighted_vuf/traits.rs (L58-61)
```rust
    fn aggregate_shares(
        wc: &WeightedConfigBlstrs,
        apks_and_proofs: &[(Player, Self::AugmentedPubKeyShare, Self::ProofShare)],
    ) -> Self::Proof;
```

**File:** crates/aptos-dkg/src/weighted_vuf/traits.rs (L66-73)
```rust
    fn derive_eval(
        wc: &WeightedConfigBlstrs,
        pp: &Self::PublicParameters,
        msg: &[u8],
        apks: &[Option<Self::AugmentedPubKeyShare>],
        proof: &Self::Proof,
        thread_pool: &ThreadPool,
    ) -> anyhow::Result<Self::Evaluation>;
```

**File:** crates/aptos-dkg/src/weighted_vuf/traits.rs (L79-85)
```rust
    fn verify_proof(
        pp: &Self::PublicParameters,
        pk: &Self::PubKey,
        apks: &[Option<Self::AugmentedPubKeyShare>],
        msg: &[u8],
        proof: &Self::Proof,
    ) -> anyhow::Result<()>;
```

**File:** consensus/src/rand/rand_gen/types.rs (L130-142)
```rust
        let proof = WVUF::aggregate_shares(&rand_config.wconfig, &apks_and_proofs);
        let metadata_serialized = bcs::to_bytes(&rand_metadata).map_err(|e| {
            anyhow!("Share::aggregate failed with metadata serialization error: {e}")
        })?;
        let eval = WVUF::derive_eval(
            &rand_config.wconfig,
            &rand_config.vuf_pp,
            metadata_serialized.as_slice(),
            &rand_config.get_all_certified_apk(),
            &proof,
            THREAD_MANAGER.get_exe_cpu_pool(),
        )
        .map_err(|e| anyhow!("Share::aggregate failed with WVUF derive_eval error: {e}"))?;
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L145-151)
```rust
    fn create_share(ask: &Self::AugmentedSecretKeyShare, msg: &[u8]) -> Self::ProofShare {
        let (r_inv, _) = ask;

        let hash = Self::hash_to_curve(msg);

        hash.mul(r_inv)
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L153-170)
```rust
    fn verify_share(
        pp: &Self::PublicParameters,
        apk: &Self::AugmentedPubKeyShare,
        msg: &[u8],
        proof: &Self::ProofShare,
    ) -> anyhow::Result<()> {
        let delta = Self::get_public_delta(apk);

        let h = Self::hash_to_curve(msg);

        if multi_pairing([&delta.pi, &pp.g_neg].into_iter(), [proof, &h].into_iter())
            != Gt::identity()
        {
            bail!("PinkasWVUF ProofShare failed to verify.");
        }

        Ok(())
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L192-208)
```rust
    fn derive_eval(
        wc: &WeightedConfigBlstrs,
        _pp: &Self::PublicParameters,
        _msg: &[u8],
        apks: &[Option<Self::AugmentedPubKeyShare>],
        proof: &Self::Proof,
        thread_pool: &ThreadPool,
    ) -> anyhow::Result<Self::Evaluation> {
        let (rhs, rks, lagr, ranges) =
            Self::collect_lagrange_coeffs_shares_and_rks(wc, apks, proof)?;

        // Compute the RK multiexps in parallel
        let lhs = Self::rk_multiexps(proof, rks, &lagr, &ranges, thread_pool);

        // Interpolate the WVUF evaluation in parallel
        Ok(Self::multi_pairing(lhs, rhs, thread_pool))
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/bls/mod.rs (L144-153)
```rust
    fn derive_eval(
        _wc: &WeightedConfigBlstrs,
        _pp: &Self::PublicParameters,
        _msg: &[u8],
        _apks: &[Option<Self::AugmentedPubKeyShare>],
        proof: &Self::Proof,
        _thread_pool: &ThreadPool,
    ) -> anyhow::Result<Self::Evaluation> {
        Ok(*proof)
    }
```

**File:** crates/aptos-dkg/tests/weighted_vuf.rs (L162-166)
```rust
    let proof = WVUF::aggregate_shares(&wc, &apks_and_proofs);

    // Make sure the aggregated proof is valid
    WVUF::verify_proof(&vuf_pp, pk, &apks[..], msg, &proof)
        .expect("WVUF aggregated proof should verify");
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L150-154)
```rust
                ensure!(
                    &metadata.metadata == share.metadata(),
                    "[RandStore] RandShare metadata from {} mismatch with block metadata!",
                    share.author(),
                );
```
