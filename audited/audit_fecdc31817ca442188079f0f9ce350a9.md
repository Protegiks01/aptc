# Audit Report

## Title
Unbounded Divergence Between highest_ordered_cert() and highest_commit_cert() Due to Missing Gap Validation

## Summary
The consensus layer allows `highest_ordered_cert` and `highest_commit_cert` to diverge without explicit bounds checking, potentially indicating execution pipeline stalls, Byzantine behavior, or consensus health issues. While existing back-pressure mechanisms limit operational impact, the lack of monitoring and validation on this gap prevents early detection of serious consensus anomalies.

## Finding Description

The Aptos consensus implements a decoupled execution model where ordering and execution occur in separate pipelines. Two critical certificates track this separation:

- **highest_ordered_cert**: Updated when blocks reach the ordering phase [1](#0-0) 
- **highest_commit_cert**: Updated only after execution completes via commit callback [2](#0-1) 

The vulnerability manifests through several code paths:

1. **Network QC Processing**: When validators receive SyncInfo messages containing quorum certificates from peers, `insert_quorum_cert()` updates `highest_ordered_cert` based solely on the certificate's commit_info round, without verifying the block is locally executable [1](#0-0) 

2. **Execution Pipeline Failure Handling**: The `finalize_order()` method returns `Ok(())` even when the execution channel send fails, silently dropping ordered blocks [3](#0-2) 

3. **Missing Gap Validation**: The `SyncInfo::verify()` method only checks that `highest_ordered_round() >= highest_commit_round()` but imposes no upper bound on the gap [4](#0-3) 

The developer comment at line 381 explicitly questions this design: "Question: We are updating highest_ordered_cert but not highest_ordered_root. Is that fine?" [5](#0-4) 

**Attack Scenario:**
1. Execution pipeline experiences degradation (slow storage, memory pressure, etc.)
2. Ordering continues advancing via vote_back_pressure (limit: 12 rounds) [6](#0-5) 
3. Validator receives SyncInfo from peers with higher QC rounds
4. `insert_quorum_cert()` advances `highest_ordered_cert` far beyond local execution state
5. `highest_commit_cert` remains stalled due to execution backlog
6. Gap grows to hundreds of rounds without detection

## Impact Explanation

**Medium Severity** per Aptos Bug Bounty criteria:
- **State Inconsistencies**: Excessive divergence indicates the validator cannot execute blocks that the network has ordered, creating state sync requirements
- **Consensus Health Indicator**: The gap reveals potential Byzantine behavior (malicious QCs causing execution failures) or network partition scenarios
- **Operational Blindspot**: No monitoring exists to alert operators of this condition, preventing timely intervention

This breaks the **State Consistency** invariant: while state transitions remain atomic, the inability to observe execution lag through certificate monitoring prevents detection of serious consensus degradation.

## Likelihood Explanation

**High Likelihood** in production environments:
- Execution pipeline degradation occurs during high transaction load
- Network latency causes validators to receive QCs from faster peers
- Memory pressure or disk I/O bottlenecks slow execution
- The lack of explicit bounds checking means the condition naturally emerges under stress

The existing back-pressure mechanisms (`vote_back_pressure_limit` and `MAX_BACKLOG`) operate on different metrics (ordered_root vs commit_root, latest_round vs highest_committed_round) and do not constrain the certificate gap [7](#0-6) 

## Recommendation

Implement explicit validation and monitoring for the certificate gap:

```rust
// In consensus/src/block_storage/block_tree.rs, add to insert_quorum_cert:

pub(super) fn insert_quorum_cert(&mut self, qc: QuorumCert) -> anyhow::Result<()> {
    // ... existing code ...
    
    if self.highest_ordered_cert.commit_info().round() < qc.commit_info().round() {
        let new_ordered_round = qc.commit_info().round();
        let current_commit_round = self.highest_commit_cert.commit_info().round();
        
        // Add bounds check
        const MAX_ORDERED_COMMIT_GAP: u64 = 100; // Configurable threshold
        if new_ordered_round > current_commit_round + MAX_ORDERED_COMMIT_GAP {
            warn!(
                "Excessive gap between ordered ({}) and commit ({}): {} rounds",
                new_ordered_round,
                current_commit_round,
                new_ordered_round - current_commit_round
            );
            counters::ORDERED_COMMIT_GAP_EXCESSIVE.inc();
            // Consider rejecting the QC or triggering state sync
        }
        
        self.highest_ordered_cert = Arc::new(qc.into_wrapped_ledger_info());
    }
    
    Ok(())
}
```

Additionally, add monitoring in `BlockStore::sync_info()`:

```rust
fn sync_info(&self) -> SyncInfo {
    let ordered_round = self.highest_ordered_cert().commit_info().round();
    let commit_round = self.highest_commit_cert().commit_info().round();
    
    counters::ORDERED_COMMIT_GAP.set((ordered_round - commit_round) as i64);
    
    SyncInfo::new_decoupled(/* ... */)
}
```

## Proof of Concept

The following demonstrates the divergence scenario:

```rust
// Test in consensus/src/block_storage/block_store_test.rs
#[tokio::test]
async fn test_excessive_ordered_commit_gap() {
    let (mut runtime, mut playground) = prepare_runtime();
    
    // Create block store with execution disabled
    let block_store = Arc::new(/* initialize with mock execution client */);
    
    // Simulate network receiving QCs from faster peers
    for round in 1..150 {
        let qc = QuorumCert::new(
            BlockInfo::new(/* round */, /* ... */),
            LedgerInfoWithSignatures::new(/* ... */)
        );
        
        // This should update highest_ordered_cert
        block_store.insert_single_quorum_cert(qc).unwrap();
    }
    
    // Verify gap has grown without bounds
    let ordered_round = block_store.highest_ordered_cert().commit_info().round();
    let commit_round = block_store.highest_commit_cert().commit_info().round();
    let gap = ordered_round - commit_round;
    
    assert!(gap > 100, "Gap should exceed reasonable bounds: {}", gap);
    // No error or warning was logged - THIS IS THE ISSUE
}
```

## Notes

The vulnerability is subtle because:
1. Existing back-pressure mechanisms prevent operational failures but don't bound the certificate gap
2. The decoupled execution architecture intentionally separates these concerns
3. The comment in the code acknowledges the design question but provides no validation

The gap serves as a critical health metric for consensus and execution synchronization, yet no monitoring exists to alert operators when it exceeds safe thresholds.

### Citations

**File:** consensus/src/block_storage/block_tree.rs (L341-346)
```rust
    fn update_highest_commit_cert(&mut self, new_commit_cert: WrappedLedgerInfo) {
        if new_commit_cert.commit_info().round() > self.highest_commit_cert.commit_info().round() {
            self.highest_commit_cert = Arc::new(new_commit_cert);
            self.update_commit_root(self.highest_commit_cert.commit_info().id());
        }
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L380-383)
```rust
        if self.highest_ordered_cert.commit_info().round() < qc.commit_info().round() {
            // Question: We are updating highest_ordered_cert but not highest_ordered_root. Is that fine?
            self.highest_ordered_cert = Arc::new(qc.into_wrapped_ledger_info());
        }
```

**File:** consensus/src/pipeline/execution_client.rs (L613-622)
```rust
        if execute_tx
            .send(OrderedBlocks {
                ordered_blocks: blocks,
                ordered_proof: ordered_proof.ledger_info().clone(),
            })
            .await
            .is_err()
        {
            debug!("Failed to send to buffer manager, maybe epoch ends");
        }
```

**File:** consensus/consensus-types/src/sync_info.rs (L158-165)
```rust
        ensure!(
            self.highest_ordered_round() >= self.highest_commit_round(),
            format!(
                "HOC {} has lower round than HLI {}",
                self.highest_ordered_cert(),
                self.highest_commit_cert()
            )
        );
```

**File:** consensus/src/block_storage/block_store.rs (L703-703)
```rust
        ordered_round > self.vote_back_pressure_limit + commit_round
```

**File:** consensus/src/pipeline/buffer_manager.rs (L906-910)
```rust
    fn need_back_pressure(&self) -> bool {
        const MAX_BACKLOG: Round = 20;

        self.back_pressure_enabled && self.highest_committed_round + MAX_BACKLOG < self.latest_round
    }
```
