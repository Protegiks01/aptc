# Audit Report

## Title
Missing On-Chain Equivocation Evidence Submission and Slashing Enforcement Mechanism

## Summary
Malicious validators can equivocate (vote for multiple conflicting blocks in the same round) without facing penalties because: (1) slashing is not implemented in the staking framework, (2) equivocation detection exists only at the local consensus layer without an on-chain evidence submission mechanism, and (3) QuorumCert verification does not cross-check whether signers participated in conflicting QCs for the same round.

## Finding Description

The Aptos consensus protocol implements equivocation detection at the vote aggregation level but lacks mechanisms to enforce accountability through slashing. This breaks the **Consensus Safety** invariant's accountability component and the **Staking Security** invariant regarding validator penalties.

### Equivocation Detection Without Enforcement

When validators vote, the `PendingVotes` structure detects equivocation (same author, different LedgerInfo digests, same round): [1](#0-0) 

However, this only logs a `SecurityEvent::ConsensusEquivocatingVote` and returns `EquivocateVote` - there is no mechanism to submit this evidence on-chain or trigger slashing.

### Slashing Not Implemented

The staking framework contains only defensive code anticipating slashing, not actual enforcement: [2](#0-1) 

The code explicitly states "if implemented", confirming slashing is not active. Even the handling of potential slashing at lines 2023-2043 only adjusts commission calculations when detecting stake reduction, without enforcing penalties. [3](#0-2) 

### QC Verification Gap

The `QuorumCert::verify()` function validates hash consistency and signature validity but does not check whether signers also signed conflicting QCs for the same round: [4](#0-3) 

### BlockTree Accepts Multiple Blocks Per Round

When multiple blocks are received for the same round, the system only logs a warning without rejection: [5](#0-4) 

### Attack Scenario

A malicious validator can:
1. Modify their local `SafetyRules` to bypass the last-voted-round check: [6](#0-5) 

2. Create two votes for different blocks (BlockA and BlockB) at round R
3. Distribute Vote_A to one set of validators and Vote_B to another set
4. If network conditions or the validator's manipulation prevents both votes from reaching the same node, equivocation detection fails
5. Even if detected locally, no on-chain evidence can be submitted
6. No slashing occurs

### Impact Chain

The vulnerability enables:
- **Accountability failure**: Byzantine validators face no economic consequences for protocol violations
- **Consensus safety risk**: While the 2f+1 quorum requirement prevents safety violations under normal conditions, the lack of accountability reduces deterrence against sophisticated attacks combining equivocation with network manipulation
- **Economic attack vector**: Validators can attempt to manipulate consensus without risking their stake

## Impact Explanation

This issue constitutes a **High Severity** vulnerability under the Aptos bug bounty criteria as a "Significant protocol violation". While it does not immediately cause consensus safety violations (which are prevented by the quorum requirements), it represents a fundamental accountability gap that:

1. Violates the Byzantine Fault Tolerance accountability property
2. Removes economic disincentives for validator misbehavior
3. Could enable more sophisticated attacks when combined with network manipulation
4. Contradicts the expected validator punishment mechanism documented in the staking framework

The conflicting voting power is tracked for observability: [7](#0-6) 

But this is only metrics/logging - no enforcement action is taken.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is realistic because:
1. Any validator can modify their local software to bypass SafetyRules
2. Network manipulation or proposer equivocation can distribute conflicting votes
3. The detection mechanism only works if both votes reach the same validator
4. No slashing enforcement exists even when detection succeeds

Mitigating factors:
1. Consensus safety is still maintained by quorum requirements under the standard BFT assumptions (< 1/3 Byzantine)
2. Equivocation is detectable and logged for forensic analysis
3. Validators risk reputation damage if equivocation is publicized

## Recommendation

Implement a comprehensive accountability mechanism:

### 1. Add Equivocation Evidence Structure
```rust
// In consensus-types
pub struct EquivocationEvidence {
    pub validator: AccountAddress,
    pub epoch: u64,
    pub round: Round,
    pub vote1: Vote,
    pub vote2: Vote,
}

impl EquivocationEvidence {
    pub fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
        ensure!(self.vote1.author() == self.vote2.author());
        ensure!(self.vote1.vote_data().proposed().round() == 
                self.vote2.vote_data().proposed().round());
        ensure!(self.vote1.ledger_info().hash() != 
                self.vote2.ledger_info().hash());
        self.vote1.verify(verifier)?;
        self.vote2.verify(verifier)?;
        Ok(())
    }
}
```

### 2. Add On-Chain Evidence Submission
```move
// In stake.move or new slashing.move module
public entry fun submit_equivocation_evidence(
    reporter: &signer,
    validator: address,
    epoch: u64,
    round: u64,
    evidence_bytes: vector<u8>
) acquires ValidatorSet {
    // Deserialize and verify evidence
    // Slash validator's stake
    // Reward reporter
}
```

### 3. Enhance QC Verification
Add cross-checking in `insert_single_quorum_cert` to detect conflicting QCs:
```rust
pub fn insert_single_quorum_cert(&self, qc: QuorumCert) -> anyhow::Result<()> {
    // Existing checks...
    
    // New: Check for conflicting QCs at the same round
    if let Some(existing_qc) = self.get_qc_for_round(qc.certified_block().round()) {
        if existing_qc.certified_block().id() != qc.certified_block().id() {
            // Detect conflicting QCs - build evidence and submit
            self.handle_conflicting_qcs(existing_qc, qc)?;
        }
    }
    // ...
}
```

### 4. Implement Slashing Logic
Replace placeholder comments with actual slashing enforcement in `delegation_pool.move` and `stake.move`.

## Proof of Concept

```rust
// consensus/src/pending_votes_test.rs
#[test]
fn test_equivocation_without_slashing() {
    let (signers, validator_verifier) = random_validator_verifier(4, Some(2), false);
    let mut pending_votes = PendingVotes::new();
    
    // Validator 0 creates two different votes for the same round
    let li1 = random_ledger_info();
    let li2 = random_ledger_info();
    let vote_data = random_vote_data();
    
    let vote1 = Vote::new(vote_data.clone(), signers[0].author(), li1, &signers[0]).unwrap();
    let vote2 = Vote::new(vote_data, signers[0].author(), li2, &signers[0]).unwrap();
    
    // First vote accepted
    assert_eq!(
        pending_votes.insert_vote(&vote1, &validator_verifier),
        VoteReceptionResult::VoteAdded(1)
    );
    
    // Second vote detected as equivocation
    assert_eq!(
        pending_votes.insert_vote(&vote2, &validator_verifier),
        VoteReceptionResult::EquivocateVote
    );
    
    // VULNERABILITY: No mechanism to submit evidence on-chain
    // No slashing occurs even though equivocation is detected
    // Validator faces no economic penalty
}
```

**Notes**

While the consensus protocol maintains safety through quorum requirements and SafetyRules enforcement for honest validators, the complete absence of on-chain accountability mechanisms represents a critical gap in the Byzantine Fault Tolerance security model. The system can detect equivocation locally but cannot enforce economic penalties, which is essential for deterring validator misbehavior in proof-of-stake systems. This is acknowledged in the codebase comments ("if implemented") but represents a significant protocol incompleteness rather than a fully implemented security feature.

### Citations

**File:** consensus/src/pending_votes.rs (L287-308)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L153-157)
```text
    /// Slashing (if implemented) should not be applied to already `inactive` stake.
    /// Not only it invalidates the accounting of past observed lockup cycles (OLC),
    /// but is also unfair to delegators whose stake has been inactive before validator started misbehaving.
    /// Additionally, the inactive stake does not count on the voting power of validator.
    const ESLASHED_INACTIVE_STAKE_ON_PAST_OLC: u64 = 7;
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L2023-2043)
```text
        // unsynced are rewards and slashes routed exclusively to/out the stake pool

        // operator `active` rewards not persisted yet to the active shares pool
        let pool_active = total_coins(&pool.active_shares);
        let commission_active = if (active > pool_active) {
            math64::mul_div(active - pool_active, pool.operator_commission_percentage, MAX_FEE)
        } else {
            // handle any slashing applied to `active` stake
            0
        };
        // operator `pending_inactive` rewards not persisted yet to the pending_inactive shares pool
        let pool_pending_inactive = total_coins(pending_inactive_shares_pool(pool));
        let commission_pending_inactive = if (pending_inactive > pool_pending_inactive) {
            math64::mul_div(
                pending_inactive - pool_pending_inactive,
                pool.operator_commission_percentage,
                MAX_FEE
            )
        } else {
            // handle any slashing applied to `pending_inactive` stake
            0
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L119-148)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "Quorum Cert's hash mismatch LedgerInfo"
        );
        // Genesis's QC is implicitly agreed upon, it doesn't have real signatures.
        // If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore
        // because of the round constraint.
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
        }
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify QuorumCert")?;
        self.vote_data.verify()?;
        Ok(())
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L326-335)
```rust
            // Note: the assumption is that we have/enforce unequivocal proposer election.
            if let Some(old_block_id) = self.round_to_ids.get(&arc_block.round()) {
                warn!(
                    "Multiple blocks received for round {}. Previous block id: {}",
                    arc_block.round(),
                    old_block_id
                );
            } else {
                self.round_to_ids.insert(arc_block.round(), block_id);
            }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** consensus/src/round_manager.rs (L611-612)
```rust
        let conflicting_voting_power = voting_powers.into_iter().sum::<u128>() - max_voting_power;
        let conflicting_num_votes = votes_counts.into_iter().sum::<usize>() - max_num_votes;
```
