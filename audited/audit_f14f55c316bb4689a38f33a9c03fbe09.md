# Audit Report

## Title
Missing PVSS Transcript Verification Allows Byzantine Public Key Share Forgery in Batch Encryption Setup

## Summary
The `setup()` function in the FPTXWeighted batch encryption scheme accepts PVSS subtranscripts without cryptographic verification. The `get_public_key_share()` method extracts public key shares directly from the transcript structure without validating their correctness, and only the local player's verification key is validated against their decrypted secret share. This allows Byzantine dealers to inject forged verification keys for other players, breaking the security of the threshold decryption protocol.

## Finding Description

The vulnerability exists in the batch threshold encryption setup process at multiple levels:

**1. Missing Subtranscript Verification**

The `setup()` function receives a PVSS subtranscript as input but never validates its cryptographic correctness: [1](#0-0) 

**2. Unvalidated Public Key Share Extraction**

The `get_public_key_share()` implementation simply extracts values from the transcript's `Vs` array without any cryptographic validation: [2](#0-1) 

These extracted shares are directly used to create verification keys: [3](#0-2) 

**3. Insufficient Local-Only Validation**

The setup function only validates that the current player's own verification key matches their decrypted secret share: [4](#0-3) 

This validation cannot detect forged verification keys for OTHER players.

**4. No Verification Enforcement in Protocol**

While a comprehensive `verify()` method exists for PVSS transcripts: [5](#0-4) 

There is no enforcement that this verification must occur before calling `setup()`. The test code demonstrates transcripts being used without verification: [6](#0-5) 

**Attack Scenario:**

1. A Byzantine dealer creates a malicious PVSS transcript with forged `Vs` (public key share commitments) for targeted honest players
2. The malicious transcript's subtranscript is extracted without verification
3. Subtranscripts from multiple dealers (including the Byzantine one) are aggregated
4. Honest players call `setup()` with the aggregated subtranscript
5. Each player extracts verification keys using `get_public_key_share()`, receiving the forged keys for other players
6. Each player only validates their own VK-SK pair, not detecting the forgery in others' keys
7. During threshold decryption, players use the forged verification keys to verify decryption key shares
8. Byzantine players can:
   - Make valid decryption shares from honest players appear invalid (denial of service)
   - Make invalid decryption shares from Byzantine players appear valid (safety violation)

This breaks **Cryptographic Invariant #10** (Cryptographic Correctness) and **Consensus Invariant #2** (Consensus Safety under < 1/3 Byzantine).

## Impact Explanation

**Critical Severity** - This vulnerability enables consensus safety violations:

- **Threshold Decryption Manipulation**: Byzantine validators can prevent honest validators' decryption shares from being accepted, blocking the decryption of encrypted transactions. With forged verification keys, honest shares computed correctly from legitimate secret shares will fail verification checks that use the forged public keys.

- **Consensus Divergence**: Different nodes may accept different sets of decryption shares based on which transcripts they received, potentially causing validators to disagree on which encrypted transactions can be decrypted, leading to state divergence.

- **Liveness Failure**: If enough honest validators' shares are rejected due to forged verification keys, the threshold for reconstruction cannot be met, permanently blocking decryption of encrypted payloads.

This directly impacts the batch encryption feature used for encrypted transaction execution in consensus, qualifying as a **Consensus/Safety violation** per the bug bounty critical severity criteria.

## Likelihood Explanation

**High Likelihood** - The vulnerability will manifest if:

1. The batch encryption feature is enabled in production (currently in testing/development phase)
2. Any single Byzantine validator participates in the PVSS dealing process
3. No additional verification layer is added before production deployment

The attack requires no sophisticated timing, no collusion beyond a single Byzantine validator, and no special network conditions. The test code demonstrates the exact vulnerable pattern, showing this is the intended usage without verification.

## Recommendation

**Immediate Fix: Enforce Transcript Verification Before Setup**

Modify the `setup()` function to require a verified transcript or add verification as the first step:

1. **Option 1 - Verify in setup():**
   Add transcript verification at the beginning of `setup()` before extracting any shares. This requires passing the full transcript (not just subtranscript) and verification parameters.

2. **Option 2 - Type-safe verified transcript:**
   Create a `VerifiedSubtranscript` wrapper type that can only be constructed after successful verification, and change `setup()` to accept only this verified type.

3. **Option 3 - Verification in aggregation:**
   Ensure individual transcripts are verified before their subtranscripts are extracted and aggregated, as shown in the DKG code: [7](#0-6) 

**Additional Safeguard:**

Add validation that all players' verification keys are consistent with the PVSS transcript commitments, not just the local player's key. This would involve checking the pairing equation for each player's VK against the transcript's commitments.

## Proof of Concept

The existing test demonstrates the vulnerability pattern: [8](#0-7) 

To demonstrate the attack, modify this test to:
1. Create a malicious transcript with `Vs[target_player_id]` set to arbitrary G2 points instead of correct PVSS shares
2. Extract and aggregate subtranscripts without verification
3. Call `setup()` - it will succeed and accept the forged verification keys
4. Show that honest players' correctly computed decryption shares fail verification against the forged VKs

The vulnerability is confirmed by the fact that `get_public_key_share()` performs no validation and `setup()` only checks local VK-SK consistency.

## Notes

This vulnerability is particularly critical because:

1. **Silent Failure**: The forged verification keys appear valid to each individual player who only checks their own key
2. **Aggregation Amplification**: A single malicious transcript pollutes the entire aggregated result
3. **Trust Assumption Violation**: The code assumes PVSS transcripts are pre-verified, but this assumption is not enforced
4. **Production Risk**: While currently in testing, deploying without fixing this would immediately expose the network to Byzantine attacks

The DKG implementation (using DAS PVSS) correctly verifies transcripts before use, but the batch encryption implementation (using chunky PVSS) lacks this critical check. This inconsistency suggests the vulnerability may be an oversight in the batch encryption module development.

### Citations

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L229-240)
```rust
    fn setup(
        digest_key: &Self::DigestKey,
        pvss_public_params: &<Self::SubTranscript as Subtranscript>::PublicParameters,
        subtranscript: &Self::SubTranscript,
        threshold_config: &Self::ThresholdConfig,
        current_player: Player,
        msk_share_decryption_key: &<Self::SubTranscript as Subtranscript>::DecryptPrivKey,
    ) -> Result<(
        Self::EncryptionKey,
        Vec<Self::VerificationKey>,
        Self::MasterSecretKeyShare,
    )> {
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L245-257)
```rust
        let vks: Vec<Self::VerificationKey> = threshold_config
            .get_players()
            .into_iter()
            .map(|p| Self::VerificationKey {
                weighted_player: p,
                mpk_g2,
                vks_g2: subtranscript
                    .get_public_key_share(threshold_config, &p)
                    .into_iter()
                    .map(|s| s.as_g2())
                    .collect(),
            })
            .collect();
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L275-283)
```rust
        vks[msk_share.weighted_player.get_id()]
            .vks_g2
            .iter()
            .zip(msk_share.shamir_share_evals.clone())
            .try_for_each(|(vk_raw, msk_share_raw)| {
                (G2Projective::from(*vk_raw) == G2Affine::generator() * msk_share_raw)
                    .then_some(())
                    .ok_or(BatchEncryptionError::VKMSKMismatchError)
            })?;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L125-132)
```rust
    fn verify<A: Serialize + Clone>(
        &self,
        sc: &Self::SecretSharingConfig,
        pp: &Self::PublicParameters,
        spks: &[Self::SigningPubKey],
        eks: &[Self::EncryptPubKey],
        sid: &A,
    ) -> anyhow::Result<()> {
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L302-311)
```rust
    fn get_public_key_share(
        &self,
        _sc: &Self::SecretSharingConfig,
        player: &Player,
    ) -> Self::DealtPubKeyShare {
        self.Vs[player.id]
            .iter()
            .map(|&V_i| keys::DealtPubKeyShare::<E>::new(keys::DealtPubKey::new(V_i.into_affine())))
            .collect()
    }
```

**File:** crates/aptos-batch-encryption/src/tests/fptx_weighted_smoke.rs (L123-157)
```rust
    let subtrx_paths: Vec<<T as HasAggregatableSubtranscript>::Subtranscript> = secrets
        .iter()
        .enumerate()
        .map(|(i, s)| {
            T::deal(
                &tc,
                &pp,
                &ssks[i],
                &spks[i],
                &eks,
                s,
                &NoAux,
                &tc.get_player(i),
                &mut rng_aptos,
            )
            .get_subtranscript()
        })
        .collect();

    let mut subtranscript = subtrx_paths[0].clone();
    for acc in &subtrx_paths[1..] {
        subtranscript.aggregate_with(&tc, acc).unwrap();
    }

    let dk = DigestKey::new(&mut rng, 8, 1).unwrap();

    let (ek, vks, _) =
        FPTXWeighted::setup(&dk, &pp, &subtranscript, &tc, tc.get_player(0), &dks[0]).unwrap();

    let msk_shares: Vec<<FPTXWeighted as BatchThresholdEncryption>::MasterSecretKeyShare> = tc
        .get_players()
        .into_iter()
        .map(|p| {
            let (_, _, msk_share) =
                FPTXWeighted::setup(&dk, &pp, &subtranscript, &tc, p, &dks[p.get_id()]).unwrap();
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```
