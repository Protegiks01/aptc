# Audit Report

## Title
Critical Authentication Bypass in Aptos Faucet via X-IS-JWT Header Manipulation

## Summary
The `AuthTokenChecker` in the Aptos Faucet contains a critical authentication bypass vulnerability. An attacker can bypass all authentication checks by simply adding the `x-is-jwt` header to their request without providing any valid JWT token, potentially draining the entire faucet if no JWT validator is configured.

## Finding Description

The vulnerability exists in the `AuthTokenChecker::check()` function, which is responsible for validating API tokens in faucet requests. The function contains a dangerous early-return logic: [1](#0-0) 

This code checks only for the **presence** of the `x-is-jwt` header key, not its value, and immediately returns success without performing any authentication. The implicit assumption is that when this header is present, another checker (specifically `RedisRatelimitChecker` with JWT-based ratelimiting) will validate the JWT token.

However, this assumption is **not enforced** by the system architecture. The faucet's checker configuration is flexible, allowing operators to configure: [2](#0-1) 

The `FirebaseJwtVerifier` that validates JWTs is only instantiated when using `RedisRatelimitChecker` with JWT-based configuration: [3](#0-2) [4](#0-3) 

**Vulnerable Configuration Scenarios:**

1. **AuthTokenChecker + RedisRatelimitChecker with IP-based ratelimiting**: The auth token check is bypassed, and only IP-based limits apply (no JWT validation)

2. **AuthTokenChecker alone**: The auth token check is bypassed with no other authentication

3. **AuthTokenChecker + other non-JWT checkers**: Same bypass issue

The configuration validation only checks YAML syntax, not logical security requirements: [5](#0-4) 

**Attack Path:**

1. Attacker sends POST request to `/fund` endpoint with `x-is-jwt` header (any value or empty)
2. Request enters checker validation pipeline: [6](#0-5) 
3. `AuthTokenChecker` sees the header and returns `Ok(vec![])` - **bypassed**
4. If `RedisRatelimitChecker` uses IP-based ratelimiting (not JWT), it never validates the JWT
5. Request proceeds to funding without any authentication
6. Attacker can drain faucet funds up to IP-based rate limits or configured maximum amounts

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program for the following reasons:

- **Loss of Funds**: Attackers can drain the entire faucet balance through repeated unauthorized requests
- **Access Control Bypass**: Complete circumvention of authentication mechanisms
- **Wide Attack Surface**: Exploitable on any faucet instance with the vulnerable configuration
- **No Special Requirements**: Exploitable with simple HTTP requests, no sophisticated techniques needed

The faucet is designed to distribute testnet/devnet funds in a controlled manner. This vulnerability allows unlimited unauthorized access, potentially exhausting funds meant for legitimate developers and breaking the intended access control model.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Simple Exploitation**: Requires only adding a single HTTP header
2. **No Authentication Required**: Attacker needs no credentials or valid tokens
3. **Configuration Error Prone**: The vulnerable configuration (AuthTokenChecker without JWT validation) is a natural deployment scenario
4. **No Code Modification**: Existing faucet deployments may already have this configuration
5. **Observable Behavior**: The `build_for_cli` function explicitly creates configurations with empty checker lists: [7](#0-6) 

The vulnerability exists because of an architectural flaw where one checker assumes another checker will perform validation, but this dependency is not enforced.

## Recommendation

**Immediate Fix:**

Modify `AuthTokenChecker::check()` to validate that a JWT checker is configured when the `x-is-jwt` header is present, or remove the early-return bypass entirely:

```rust
// Option 1: Remove the bypass entirely and let JWT validation happen elsewhere
// Delete lines 37-40 from auth_token.rs

// Option 2: Verify header value is "true" before bypassing
if let Some(header_value) = data.headers.get(X_IS_JWT_HEADER) {
    if header_value.to_str().ok().map_or(false, |v| v.eq_ignore_ascii_case("true")) {
        // Only bypass if properly set, but this still requires JWT validator
        // to be configured separately
        return Ok(vec![]);
    }
}

// Option 3 (RECOMMENDED): Create a dedicated JWT checker
// Move the bypass logic to a separate JwtAuthChecker that always validates JWTs
// when x-is-jwt header is present, making the dependency explicit
```

**Long-term Fix:**

1. Create a dedicated `JwtAuthChecker` that validates JWT tokens when `x-is-jwt` is present
2. Add configuration validation that ensures if `AuthTokenChecker` is enabled, either:
   - No `x-is-jwt` bypass logic exists, OR
   - A JWT validator checker is also configured
3. Add integration tests that verify authentication cannot be bypassed with header manipulation

## Proof of Concept

```bash
# Setup: Faucet configured with AuthTokenChecker and IP-based RedisRatelimitChecker
# (or just AuthTokenChecker alone)

# Legitimate request (should fail without valid token):
curl -X POST http://faucet-address/fund \
  -H "Content-Type: application/json" \
  -d '{"amount": 1000000000, "address": "0x1234...abcd"}'
# Response: 403 Forbidden - Auth token invalid

# Attack request with bypass header:
curl -X POST http://faucet-address/fund \
  -H "Content-Type: application/json" \
  -H "x-is-jwt: bypass" \
  -d '{"amount": 1000000000, "address": "0x1234...abcd"}'
# Response: 200 OK - Funds transferred!

# Attacker can repeat this up to IP-based rate limits,
# draining the faucet without any valid authentication
```

**Rust Integration Test PoC:**

```rust
#[tokio::test]
async fn test_auth_bypass_via_jwt_header() -> Result<()> {
    // Configure faucet with AuthTokenChecker but NO JWT validation
    let config = r#"
    checker_configs:
      - type: AuthToken
        file_path: /tmp/auth_tokens.txt
      - type: IpBlocklist
        file_path: /tmp/ip_blocklist.txt
    "#;
    
    let (port, _handle) = start_server(config).await?;
    
    // Request with x-is-jwt header but no valid JWT should be accepted
    let response = reqwest::Client::new()
        .post(format!("http://127.0.0.1:{}/fund", port))
        .header("Content-Type", "application/json")
        .header("x-is-jwt", "malicious")  // Bypass header
        .body(r#"{"amount": 100, "address": "0x1234"}"#)
        .send()
        .await?;
    
    // This should fail but currently succeeds due to vulnerability
    assert_eq!(response.status(), 200);  // VULNERABLE!
    
    Ok(())
}
```

## Notes

This vulnerability demonstrates a **broken architectural assumption** where the `AuthTokenChecker` delegates JWT validation to another component without enforcing that the component exists or is properly configured. The faucet's modular checker design allows dangerous configurations where authentication can be completely bypassed.

The vulnerability is particularly severe because:
- It affects production faucet deployments
- The configuration validation does not catch this security issue
- The `build_for_cli` function shows empty checker configurations are explicitly supported
- No warning or error is generated when this unsafe configuration is used

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L37-40)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L79-107)
```rust
/// This enum lets us represent all the different checkers in a config. This
/// should only be used at config reading time.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(tag = "type")]
pub enum CheckerConfig {
    /// Requires that an auth token is included in the Authorization header.
    AuthToken(ListManagerConfig),

    /// Requires a legitimate Google ReCaptcha token.
    GoogleCaptcha(GoogleCaptchaCheckerConfig),

    /// Rejects requests if their IP is in a blocklisted IPrnage.
    IpBlocklist(IpRangeManagerConfig),

    /// Checkers whether a config-defined magic header kv is present.
    MagicHeader(MagicHeaderCheckerConfig),

    /// Basic in memory ratelimiter that allows a single successful request per IP.
    MemoryRatelimit(MemoryRatelimitCheckerConfig),

    /// Ratelimiter that uses Redis.
    RedisRatelimit(RedisRatelimitCheckerConfig),

    /// Rejects requests if their Referer is blocklisted.
    RefererBlocklist(ListManagerConfig),

    /// In-house captcha solution.
    TapCaptcha(TapCaptchaCheckerConfig),
}
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L18-24)
```rust
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(tag = "type")]
pub enum RatelimitKeyProviderConfig {
    #[default]
    Ip,
    Jwt(FirebaseJwtVerifierConfig),
}
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L162-167)
```rust
        let ratelimit_key_provider = match args.ratelimit_key_provider_config.clone() {
            RatelimitKeyProviderConfig::Ip => RatelimitKeyProvider::Ip,
            RatelimitKeyProviderConfig::Jwt(config) => {
                RatelimitKeyProvider::Jwt(FirebaseJwtVerifier::new(config).await?)
            },
        };
```

**File:** crates/aptos-faucet/core/src/server/validate_config.rs (L17-35)
```rust
    pub async fn validate_config(&self) -> Result<()> {
        let file = File::open(&self.config_path).with_context(|| {
            format!(
                "Failed to load config at {}",
                self.config_path.to_string_lossy()
            )
        })?;
        let reader = BufReader::new(file);
        let run_config: RunConfig = serde_yaml::from_reader(reader).with_context(|| {
            format!(
                "Failed to parse config at {}",
                self.config_path.to_string_lossy()
            )
        })?;

        info!("Config is valid: {:#?}", run_config);

        Ok(())
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L262-270)
```rust
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L277-277)
```rust
            checker_configs: vec![],
```
