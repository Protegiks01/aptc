# Audit Report

## Title
Database Validation Bypass Due to Hardcoded Sharding Assumption in verify_state_kvs()

## Summary
The `verify_state_kvs()` function in the indexer validation tool unconditionally opens sharded StateKvDb databases, regardless of the production node's actual sharding configuration. When a production node runs with `enable_storage_sharding: false`, state data is stored in the ledger_db, but the validation tool opens separate (empty or stale) shard databases, resulting in a complete validation bypass where no actual state data is checked.

## Finding Description
The validation tool's `verify_state_kvs()` function directly calls `StateKvDb::open_sharded()`: [1](#0-0) 

This unconditionally opens 16 sharded databases and validates each shard: [2](#0-1) 

However, production nodes use `StateKvDb::new()`, which respects the `enable_storage_sharding` configuration: [3](#0-2) 

When `enable_storage_sharding: false`, production stores state data in `ledger_db`, not in separate shards (lines 63-70). The sharding flag defaults to `true`: [4](#0-3) 

But this is configurable per deployment. The validation logic iterates through state_kv_db keys and checks if they exist in the internal indexer: [5](#0-4) 

**Critical Issue**: If production has sharding disabled, the validation tool opens empty/stale shard databases, finds zero keys to validate, reports "Number of missing keys: 0" (line 189), and passes validation without checking any actual state data in ledger_db. Corruption in the real production data goes completely undetected.

Other db_debugger tools correctly use `ShardingConfig`: [6](#0-5) 

But the validation tool lacks this configuration parameter.

## Impact Explanation
**HIGH Severity** - This constitutes a significant protocol violation per the Aptos bug bounty program. The validation tool provides false confidence in database integrity:

1. **State Consistency Violation**: Validators rely on database validation to detect corruption before it propagates to consensus
2. **Hidden Corruption**: Corrupted state data in ledger_db would not be detected, potentially causing consensus divergence when validators with different corrupted states disagree
3. **False Security Guarantees**: Operators believe their database is validated when no actual validation occurred
4. **Deployment Risk**: Corrupted databases could be deployed to production based on false validation results

This breaks the **State Consistency** invariant (#4) that state transitions must be verifiable.

## Likelihood Explanation
**Medium-High Likelihood**:

1. **Configuration Variation**: While the default is sharding enabled, testing environments, specific deployment scenarios, or historical setups may disable sharding
2. **Tool Usage Pattern**: Database validation is a critical operational procedure run regularly by node operators
3. **Migration Scenarios**: Nodes that migrate from non-sharded to sharded configurations would have data in both locations
4. **Silent Failure**: The tool completes successfully without warnings, giving no indication of the validation bypass
5. **No Safeguards**: No configuration checks or warnings exist to detect the mismatch

A node operator following standard validation procedures on a non-sharded database would experience this issue.

## Recommendation
The validation tool must respect the production database's sharding configuration. Add a `ShardingConfig` parameter and use `StateKvDb::new()` instead of `StateKvDb::open_sharded()`:

**Modified `verify_state_kvs()` signature:**
```rust
pub fn verify_state_kvs(
    db_root_path: &Path,
    internal_db: &DB,
    target_ledger_version: u64,
    enable_storage_sharding: bool,  // ADD THIS
) -> Result<()>
```

**Modified database opening:**
```rust
let ledger_db = LedgerDb::new(
    db_root_path,
    RocksdbConfigs {
        enable_storage_sharding,
        ..Default::default()
    },
    None, None, true,
)?;

let state_kv_db = StateKvDb::new(
    &storage_dir,
    RocksdbConfigs {
        enable_storage_sharding,  // USE CONFIG
        ..Default::default()
    },
    None, None, false,
    ledger_db.metadata_db_arc(),
)?;
```

**Update CLI to accept sharding flag:**
```rust
#[derive(Parser, Debug)]
pub struct ValidationArgs {
    #[clap(short, long)]
    pub db_root_path: String,
    
    #[clap(short, long)]
    pub internal_indexer_db_path: String,
    
    #[clap(short, long)]
    pub target_version: u64,
    
    #[clap(long)]
    pub enable_storage_sharding: bool,  // ADD THIS
}
```

This ensures the validation tool opens the same database storage as production.

## Proof of Concept

**Setup:**
1. Initialize an AptosDB with `enable_storage_sharding: false`
2. Write state data (data goes to ledger_db)
3. Run the validation tool (opens empty shards)
4. Observe validation passes despite not checking actual data

**Rust reproduction steps:**
```rust
use aptos_db::AptosDB;
use aptos_config::config::{RocksdbConfigs, StorageDirPaths, NO_OP_STORAGE_PRUNER_CONFIG};
use tempfile::TempDir;

#[test]
fn test_validation_bypass_non_sharded() {
    let tmpdir = TempDir::new().unwrap();
    
    // Create production DB with sharding DISABLED
    let db = AptosDB::new_without_pruner(
        tmpdir.path(),
        false,  // readonly
        1000,   // buffered_state_target_items
        0,      // max_num_nodes_per_lru_cache_shard
        false,  // enable_indexer
        false,  // enable_sharding - DISABLED
    );
    
    // Write state data (goes to ledger_db, not shards)
    // ... write operations ...
    
    // Now run validation tool
    // It calls StateKvDb::open_sharded() which opens EMPTY shards
    let state_kv_db = StateKvDb::open_sharded(
        &StorageDirPaths::from_path(tmpdir.path()),
        RocksdbConfig::default(),
        None, None, false,
    ).unwrap();
    
    // Iterate through shards - will find ZERO keys
    for shard_id in 0..16 {
        let shard = state_kv_db.db_shard(shard_id);
        let mut iter = shard.iter::<StateValueByKeyHashSchema>().unwrap();
        iter.seek_to_first();
        
        let mut count = 0;
        for _ in iter {
            count += 1;
        }
        
        // Validation finds 0 keys per shard, reports success
        // Real data in ledger_db is NEVER validated
        assert_eq!(count, 0);  // FALSE POSITIVE
    }
}
```

The test demonstrates that when sharding is disabled, the validation tool validates empty databases while the real state data in ledger_db remains unchecked.

## Notes
While the security question mentions a "pruner enabled flag," the actual parameter at line 122 is the `readonly` flag. However, the investigation revealed a more fundamental vulnerability: the hardcoded sharding assumption causes the validation tool to open incorrect database storage when production uses non-sharded configuration, resulting in a complete validation bypass that could mask state corruption and lead to consensus divergence.

### Citations

**File:** storage/aptosdb/src/db_debugger/validation.rs (L121-122)
```rust
    let state_kv_db =
        StateKvDb::open_sharded(&storage_dir, RocksdbConfig::default(), None, None, false)?;
```

**File:** storage/aptosdb/src/db_debugger/validation.rs (L140-144)
```rust
    for shard_id in 0..16 {
        let shard = state_kv_db.db_shard(shard_id);
        println!("Validating state_kv for shard {}", shard_id);
        verify_state_kv(shard, &all_internal_keys, target_ledger_version)?;
    }
```

**File:** storage/aptosdb/src/db_debugger/validation.rs (L157-191)
```rust
fn verify_state_kv(
    shard: &DB,
    all_internal_keys: &HashSet<HashValue>,
    target_ledger_version: u64,
) -> Result<()> {
    let read_opts = ReadOptions::default();
    let mut iter = shard.iter_with_opts::<StateValueByKeyHashSchema>(read_opts)?;
    // print a message every 10k keys
    let mut counter = 0;
    iter.seek_to_first();
    let mut missing_keys = 0;
    for value in iter {
        let (state_key_hash, version) = value?.0;
        if version > target_ledger_version {
            continue;
        }
        // check if the state key hash is present in the internal db
        if !all_internal_keys.contains(&state_key_hash) {
            missing_keys += 1;
            println!(
                "State key hash not found in internal db: {:?}, version: {}",
                state_key_hash, version
            );
        }
        counter += 1;
        if counter as usize % SAMPLE_RATE == 0 {
            println!(
                "Processed {} keys, the current sample is {} at version {}",
                counter, state_key_hash, version
            );
        }
    }
    println!("Number of missing keys: {}", missing_keys);
    Ok(())
}
```

**File:** storage/aptosdb/src/state_kv_db.rs (L54-80)
```rust
    pub(crate) fn new(
        db_paths: &StorageDirPaths,
        rocksdb_configs: RocksdbConfigs,
        env: Option<&Env>,
        block_cache: Option<&Cache>,
        readonly: bool,
        ledger_db: Arc<DB>,
    ) -> Result<Self> {
        let sharding = rocksdb_configs.enable_storage_sharding;
        if !sharding {
            info!("State K/V DB is not enabled!");
            return Ok(Self {
                state_kv_metadata_db: Arc::clone(&ledger_db),
                state_kv_db_shards: arr![Arc::clone(&ledger_db); 16],
                hot_state_kv_db_shards: None,
                enabled_sharding: false,
            });
        }

        Self::open_sharded(
            db_paths,
            rocksdb_configs.state_kv_db_config,
            env,
            block_cache,
            readonly,
        )
    }
```

**File:** config/src/config/storage_config.rs (L233-233)
```rust
            enable_storage_sharding: true,
```

**File:** storage/aptosdb/src/db_debugger/common/mod.rs (L46-61)
```rust
    pub fn open_state_kv_db(&self) -> Result<StateKvDb> {
        let leger_db = self.open_ledger_db()?;
        let env = None;
        let block_cache = None;
        StateKvDb::new(
            &StorageDirPaths::from_path(&self.db_dir),
            RocksdbConfigs {
                enable_storage_sharding: self.sharding_config.enable_storage_sharding,
                ..Default::default()
            },
            env,
            block_cache,
            true,
            leger_db.metadata_db_arc(),
        )
    }
```
