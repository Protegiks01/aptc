# Audit Report

## Title
OptQuorumStore Exclude Authors Bypass Allows Byzantine Validators to Cause Persistent Resource Exhaustion

## Summary
The `exclude_authors` mechanism in OptQuorumStore can be empty or ineffective against Byzantine validators who ensure batch availability while including invalid transactions. This allows malicious validators to persistently force honest nodes to process invalid batches, causing resource exhaustion and validator slowdowns without penalty.

## Finding Description

OptQuorumStore (OptQS) is designed to improve consensus performance by allowing optimistic inclusion of batches without requiring quorum signatures (ProofOfStore). The security mechanism relies on an `exclude_authors` HashSet to exclude validators whose batches have caused problems. [1](#0-0) 

However, the exclusion mechanism has a critical flaw: it ONLY tracks validators whose batches caused `PayloadUnavailable` failures (missing batches), not validators who include invalid or malicious content. [2](#0-1) 

The `get_exclude_authors()` method only adds authors who had `PayloadUnavailable` timeout failures in the tracking window. If a Byzantine validator ensures their batches are always available (properly stored and retrievable) but fills them with invalid transactions, they will never be added to `exclude_authors`. [3](#0-2) 

When OptQS parameters are returned, `exclude_authors` can be legitimately empty (line 145-159), meaning NO validators are excluded from opt_batches selection.

The critical security gap is in how opt_batches are validated. Unlike regular batches that require ProofOfStore with quorum signatures, opt_batches only verify that authors are valid validators: [4](#0-3) 

There is NO signature verification, NO transaction validation, and NO content checking for opt_batches at consensus time. The payload verification only confirms authors are in the validator set. [5](#0-4) 

**Attack Scenario:**

1. Byzantine validator ensures OptQS is enabled (default configuration)
2. Byzantine validator creates batches with invalid/malicious transactions
3. Validator ensures batches are properly stored and available to all nodes
4. When Byzantine validator becomes proposer, they include their own opt_batches
5. Since batches are available, no `PayloadUnavailable` failure occurs
6. `exclude_authors` remains empty - validator is not excluded
7. All honest validators must process the malicious opt_batches during execution
8. Invalid transactions fail during execution, wasting validator resources
9. Byzantine validator repeats attack in every round they propose
10. No penalty or accountability mechanism triggers

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program criteria: "Validator node slowdowns."

The attack allows Byzantine validators to:
- **Persistently degrade validator performance** by forcing processing of invalid transactions
- **Bypass the quorum signature security model** - opt_batches skip the 2f+1 validator verification
- **Cause resource exhaustion** on all honest validators in the network
- **Violate the Resource Limits invariant** by allowing unbounded resource waste across rounds

The impact is bounded by block size and gas limits per block, but can be sustained across multiple rounds, causing persistent performance degradation across the entire validator set.

## Likelihood Explanation

**Likelihood: High**

This attack is highly likely because:
1. OptQS is **enabled by default** in the configuration
2. Requires only a **single Byzantine validator** with normal validator privileges
3. Byzantine validator needs to be elected proposer (happens in rotation)
4. No technical sophistication required - simply include invalid transactions in batches
5. No detection or penalty mechanism exists for this behavior
6. The vulnerability is inherent to the design - exclude_authors only tracks availability failures

The attacker requirements are minimal:
- Must be an elected validator (requires stake, but within BFT threat model)
- Must ensure batch availability (normal validator operation)
- Must include invalid transactions (trivial to generate)

## Recommendation

Implement multi-dimensional failure tracking that monitors batch quality, not just availability:

```rust
// Enhanced failure tracking in proposal_status_tracker.rs
pub enum BatchFailureReason {
    Unavailable,
    InvalidTransactions { failed_tx_count: u64 },
    ExecutionTimeout,
    ResourceExhaustion,
}

fn get_exclude_authors(&self) -> HashSet<Author> {
    let mut exclude_authors = HashSet::new();
    
    for round_reason in self.past_round_statuses.iter().rev().take(self.window) {
        match round_reason {
            NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { missing_authors }) => {
                // Existing logic
            },
            NewRoundReason::ExecutionFailure { authors_with_invalid_batches } => {
                // NEW: Track validators whose batches had invalid transactions
                for author in authors_with_invalid_batches {
                    exclude_authors.insert(*author);
                }
            },
            _ => {}
        }
    }
    
    exclude_authors
}
```

Additionally, add post-execution validation:
- Track which opt_batches had transactions that failed validation/execution
- Report these failures back to the failure tracker
- Implement reputation-based exclusion for validators with high failure rates
- Consider requiring lightweight signatures on opt_batches from the batch author

Alternative mitigation: Disable OptQS in production until proper accountability mechanisms are implemented, or require ProofOfStore for all batches.

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the attack flow
#[test]
fn test_byzantine_validator_resource_exhaustion() {
    // Setup: Network with 4 validators, 1 Byzantine
    let byzantine_validator = validator_set[0];
    
    // Byzantine validator creates batch with invalid transactions
    let invalid_txns = vec![
        create_invalid_transaction(), // Invalid signature
        create_invalid_transaction(), // Invalid sequence number
        // ... up to block size limit
    ];
    let malicious_batch = byzantine_validator.create_batch(invalid_txns);
    
    // Ensure batch is available (stored properly)
    byzantine_validator.store_batch(malicious_batch);
    
    // Byzantine validator becomes proposer
    let proposal = byzantine_validator.create_proposal_with_optqs(
        opt_batches: vec![malicious_batch], // No ProofOfStore required!
        exclude_authors: HashSet::new(),     // Empty because no availability failures
    );
    
    // All validators process proposal
    for honest_validator in honest_validators {
        // Batch passes consensus validation (author is valid)
        assert!(proposal.verify_payload()); // PASSES
        
        // Validators waste resources executing invalid transactions
        let execution_result = honest_validator.execute_block(proposal);
        assert!(execution_result.has_failed_transactions()); // Invalid txns failed
        
        // But Byzantine validator is NOT excluded
        assert!(!exclude_authors.contains(&byzantine_validator));
    }
    
    // Attack repeats in next round - no penalty applied
    assert_eq!(failure_tracker.get_exclude_authors(), HashSet::new());
}
```

**Notes:**

The vulnerability exists because the `exclude_authors` defense mechanism is insufficient - it only protects against availability failures, not content validity. Byzantine validators who ensure batch availability can include arbitrary invalid content in opt_batches, forcing honest validators to waste resources processing invalid transactions without consequence. This bypasses the fundamental quorum signature security model of Byzantine Fault Tolerant consensus systems.

### Citations

**File:** consensus/consensus-types/src/payload_pull_params.rs (L10-14)
```rust
#[derive(Clone)]
pub struct OptQSPayloadPullParams {
    pub exclude_authors: HashSet<Author>,
    pub minimum_batch_age_usecs: u64,
}
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L128-160)
```rust
    fn get_params(&self) -> Option<OptQSPayloadPullParams> {
        if !self.enable_opt_qs {
            return None;
        }

        let tracker = self.failure_tracker.lock();

        counters::OPTQS_LAST_CONSECUTIVE_SUCCESS_COUNT
            .observe(tracker.last_consecutive_success_count as f64);
        if tracker.last_consecutive_success_count < tracker.window {
            warn!(
                "Skipping OptQS: (last_consecutive_successes) {} < {} (window)",
                tracker.last_consecutive_success_count, tracker.window
            );
            return None;
        }

        let exclude_authors = tracker.get_exclude_authors();
        if !exclude_authors.is_empty() {
            let exclude_authors_str: Vec<_> =
                exclude_authors.iter().map(|a| a.short_str()).collect();
            for author in &exclude_authors_str {
                counters::OPTQS_EXCLUDE_AUTHORS_COUNT
                    .with_label_values(&[author.as_str()])
                    .inc();
            }
            warn!("OptQS exclude authors: {:?}", exclude_authors_str);
        }
        Some(OptQSPayloadPullParams {
            exclude_authors,
            minimum_batch_age_usecs: self.minimum_batch_age_usecs,
        })
    }
```

**File:** consensus/consensus-types/src/common.rs (L558-572)
```rust
    pub fn verify_opt_batches<T: TBatchInfo>(
        verifier: &ValidatorVerifier,
        opt_batches: &OptBatches<T>,
    ) -> anyhow::Result<()> {
        let authors = verifier.address_to_validator_index();
        for batch in &opt_batches.batch_summary {
            ensure!(
                authors.contains_key(&batch.author()),
                "Invalid author {} for batch {}",
                batch.author(),
                batch.digest()
            );
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/common.rs (L598-607)
```rust
            (true, Payload::OptQuorumStore(OptQuorumStorePayload::V1(p))) => {
                let proof_with_data = p.proof_with_data();
                Self::verify_with_cache(&proof_with_data.batch_summary, verifier, proof_cache)?;
                Self::verify_inline_batches(
                    p.inline_batches()
                        .iter()
                        .map(|batch| (batch.info(), batch.transactions())),
                )?;
                Self::verify_opt_batches(verifier, p.opt_batches())?;
                Ok(())
```
