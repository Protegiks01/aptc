# Audit Report

## Title
Peer Monitoring Metadata Poisoning Enables Eclipse Attacks and State Sync Manipulation via False Distance Claims

## Summary
Malicious peers can inject false `distance_from_validators` metadata into `PeersAndMetadata`, causing honest nodes to make incorrect routing decisions for state synchronization, mempool transaction forwarding, and consensus observer subscriptions. The validation logic only performs strict checks for distances 0 and 1, but accepts any self-reported distance from 2 to 100 without verification, enabling eclipse attacks and data poisoning.

## Finding Description
The peer monitoring service allows peers to self-report their `distance_from_validators` metric, which measures topological distance from the validator set. This metric is critical for peer selection across three major subsystems: [1](#0-0) [2](#0-1) [3](#0-2) 

The validation logic in the peer monitoring client performs role-based checks for distances 0 and 1, but for distances â‰¥ 2, only validates that the distance is below the maximum threshold: [4](#0-3) 

**Attack Path:**

1. Malicious PFN connects to an honest PFN on the Public network using `MaybeMutual` authentication mode
2. The malicious peer responds to `GetNetworkInformation` requests with a fabricated `distance_from_validators = 2` (falsely claiming to be very close to validators)
3. Honest PFNs at actual distance 5-10 report their true distances
4. The honest node's state sync client groups peers by distance using a `BTreeMap`, which sorts by ascending distance
5. When selecting peers for data requests, the malicious peer at (false) distance 2 is prioritized over honest peers at (true) distance 5-10
6. The malicious peer can then:
   - Serve stale blockchain data, causing sync delays or failures
   - Serve subtly corrupted data to cause state inconsistencies
   - Monopolize connections to eclipse the victim node
   - Drop mempool transactions to enable censorship attacks

The metadata update flow shows that this self-reported data directly populates the routing metadata: [5](#0-4) [6](#0-5) 

## Impact Explanation
**High Severity** - This vulnerability enables multiple attack vectors:

1. **Eclipse Attacks**: By claiming optimal distance, malicious peers can monopolize peer selection for state sync, effectively isolating victims from the honest network
2. **State Synchronization Poisoning**: Malicious peers can serve stale or incorrect blockchain data to nodes performing state sync, potentially causing state corruption or sync failures
3. **Transaction Censorship**: In mempool priority forwarding, malicious peers claiming low distance receive transactions first and can selectively drop them
4. **Consensus Observer Disruption**: Malicious peers can monopolize consensus observer subscriptions, disrupting consensus propagation for non-validator nodes

While this does not directly compromise validator consensus safety (validators use `Mutual` authentication), it severely impacts the security and reliability of full nodes (VFN/PFN), which are critical for ecosystem health. The attack requires no privileged access and can be executed by any peer connecting to public networks.

## Likelihood Explanation
**High Likelihood** - The attack is trivially executable:

1. **Low Barrier to Entry**: Any entity can spin up a malicious full node and connect to the public network
2. **No Authentication Required**: Public networks use `MaybeMutual` authentication, allowing any peer to connect
3. **Simple Exploitation**: The attacker only needs to return a false distance value in a standard RPC response
4. **Immediate Effect**: The false metadata is immediately incorporated into routing decisions with no additional validation
5. **Persistent Impact**: Once the false metadata is accepted, it continues to influence routing decisions until the peer disconnects

The vulnerability is currently exploitable in production networks wherever `MaybeMutual` authentication is used, which includes all PFN-PFN and VFN-PFN connections on public networks.

## Recommendation
Implement cryptographic verification of the `distance_from_validators` claim, or replace self-reported distances with locally computed metrics:

**Option 1: Local Distance Computation**
Instead of trusting peer-reported distances, compute distance based on the peer's authenticated role and network topology:
- If peer role is `Validator`: distance = 0
- If peer role is `ValidatorFullNode`: distance = 1  
- If peer role is `Unknown` on Public network: distance = 2 + (measure based on observed behavior)

**Option 2: Cryptographic Proof**
Require peers to provide a cryptographic chain-of-trust proof showing their distance:
- Validators at distance 0 sign a certificate for their connected VFNs
- VFNs at distance 1 sign certificates for their connected PFNs
- Verify the signature chain before accepting the distance claim

**Option 3: Enhanced Validation**
Strengthen the validation logic to cross-check claims against observed network topology:
- Track which peers connect to which other peers
- Verify that a peer claiming distance N is connected to at least one peer at distance N-1
- Reject claims that are inconsistent with observed connection patterns

**Immediate Mitigation:**
Until a full fix is deployed, tighten the validation bounds for untrusted peers by rejecting excessively low distance claims from peers with `Unknown` roles on public networks.

## Proof of Concept

```rust
// Proof of concept: Malicious peer claiming false distance

use aptos_peer_monitoring_service_types::response::{
    NetworkInformationResponse, PeerMonitoringServiceResponse
};
use std::collections::BTreeMap;

// Malicious peer handler
fn handle_network_info_request() -> PeerMonitoringServiceResponse {
    // Falsely claim distance 2 (very close to validators)
    // when actual distance might be 10+ or disconnected entirely
    let fake_response = NetworkInformationResponse {
        connected_peers: BTreeMap::new(), // Can also fake connections
        distance_from_validators: 2, // FALSE: Should be much higher!
    };
    
    PeerMonitoringServiceResponse::NetworkInformation(fake_response)
}

// This false distance will pass validation because:
// 1. Line 137-140 in network_info.rs only checks: distance <= MAX_DISTANCE_FROM_VALIDATORS (100)
// 2. No verification that peer is actually at distance 2
// 3. Distance 2 places peer in highest priority group for state sync, mempool, consensus observer
```

The attack flow:
1. Deploy malicious full node
2. Connect to honest PFN on Public network  
3. Respond to `GetNetworkInformation` with `distance_from_validators: 2`
4. Honest node accepts this value (passes validation at line 139)
5. Honest node now preferentially selects malicious peer for all data requests
6. Attacker can serve stale data, drop transactions, or eclipse the victim

## Notes
While the `dummy.rs` test file itself uses `Mutual` authentication which would require the attacker to be in the trusted peers set, the underlying vulnerability in the peer monitoring metadata validation affects all network configurations using `MaybeMutual` authentication, including production public networks. The validation logic weakness enables metadata poisoning that violates routing integrity across state sync, mempool, and consensus observer subsystems.

### Citations

**File:** state-sync/aptos-data-client/src/utils.rs (L23-64)
```rust
/// Chooses peers weighted by distance from the validator set
/// and latency. We prioritize distance over latency as we want
/// to avoid close but not up-to-date peers.
pub fn choose_random_peers_by_distance_and_latency(
    peers: HashSet<PeerNetworkId>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    num_peers_to_choose: usize,
) -> HashSet<PeerNetworkId> {
    // Group peers and latency weights by validator distance, i.e., distance -> [(peer, latency weight)]
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for peer in peers {
        if let Some((distance, latency)) =
            get_distance_and_latency_for_peer(&peers_and_metadata, peer)
        {
            let latency_weight = convert_latency_to_weight(latency);
            peers_and_latencies_by_distance
                .entry(distance)
                .or_insert_with(Vec::new)
                .push((peer, latency_weight));
        }
    }

    // Select the peers by distance and latency weights. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut selected_peers = HashSet::new();
    for (_, peers_and_latencies) in peers_and_latencies_by_distance {
        // Select the peers by latency weights
        let num_peers_remaining = num_peers_to_choose.saturating_sub(selected_peers.len()) as u64;
        let peers = choose_random_peers_by_weight(num_peers_remaining, peers_and_latencies);

        // Add the peers to the entire set
        selected_peers.extend(peers);

        // If we have selected enough peers, return early
        if selected_peers.len() >= num_peers_to_choose {
            return selected_peers;
        }
    }

    // Return the selected peers
    selected_peers
}
```

**File:** mempool/src/shared_mempool/priority.rs (L103-109)
```rust
        // Otherwise, compare by peer distance from the validators.
        // This avoids badly configured/connected peers (e.g., broken VN-VFN connections).
        let distance_ordering =
            compare_validator_distance(monitoring_metadata_a, monitoring_metadata_b);
        if !distance_ordering.is_eq() {
            return distance_ordering; // Only return if it's not equal
        }
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L275-312)
```rust
/// Sorts the peers by subscription optimality (in descending order of
/// optimality). This requires: (i) sorting the peers by distance from the
/// validator set and ping latency (lower values are more optimal); and (ii)
/// filtering out peers that don't support consensus observer.
///
/// Note: we prioritize distance over latency as we want to avoid close
/// but not up-to-date peers. If peers don't have sufficient metadata
/// for sorting, they are given a lower priority.
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L116-154)
```rust
        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```

**File:** peer-monitoring-service/client/src/lib.rs (L251-259)
```rust
                // Insert the latest peer monitoring metadata into peers and metadata
                if let Err(error) = peers_and_metadata
                    .update_peer_monitoring_metadata(peer_network_id, peer_monitoring_metadata)
                {
                    warn!(LogSchema::new(LogEntry::MetadataUpdateLoop)
                        .event(LogEvent::UnexpectedErrorEncountered)
                        .peer(&peer_network_id)
                        .error(&error.into()));
                }
```

**File:** network/framework/src/application/storage.rs (L294-317)
```rust
    pub fn update_peer_monitoring_metadata(
        &self,
        peer_network_id: PeerNetworkId,
        peer_monitoring_metadata: PeerMonitoringMetadata,
    ) -> Result<(), Error> {
        // Grab the write lock for the peer metadata
        let mut peers_and_metadata = self.peers_and_metadata.write();

        // Fetch the peer metadata for the given network
        let peer_metadata_for_network =
            get_peer_metadata_for_network(&peer_network_id, &mut peers_and_metadata)?;

        // Update the peer monitoring metadata for the peer
        if let Some(peer_metadata) = peer_metadata_for_network.get_mut(&peer_network_id.peer_id()) {
            peer_metadata.peer_monitoring_metadata = peer_monitoring_metadata;
        } else {
            return Err(missing_peer_metadata_error(&peer_network_id));
        }

        // Update the cached peers and metadata
        self.set_cached_peers_and_metadata(peers_and_metadata.clone());

        Ok(())
    }
```
