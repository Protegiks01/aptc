# Audit Report

## Title
Genesis Transaction Script Execution Bypasses Gas Metering Leading to Bootstrapper Denial of Service

## Summary
During genesis execution in the db-tool bootstrapper, gas metering is not enforced when executing `WriteSetPayload::Script` variants. A malicious genesis transaction containing an infinite loop or computationally expensive operations would hang the bootstrapper indefinitely, preventing nodes from initializing and joining the network.

## Finding Description

The vulnerability exists in the genesis transaction execution path where gas metering is bypassed for script-based genesis payloads.

**Vulnerability Chain:**

1. The bootstrapper loads the genesis transaction file without validation: [1](#0-0) 

2. The loaded transaction is only verified to be a `GenesisTransaction` type, with no content validation: [2](#0-1) 

3. The transaction is executed via `calculate_genesis` which uses `BlockExecutorConfigFromOnchain::new_no_block_limit()`: [3](#0-2) 

4. A `WriteSetPayload` can contain either a `Direct` changeset or a `Script` that executes to generate the changeset: [4](#0-3) 

5. When executing `WriteSetPayload::Script`, the AptosVM uses `UnmeteredGasMeter` which does not enforce any gas limits: [5](#0-4) 

6. The `UnmeteredGasMeter` returns unlimited gas budget and performs no actual metering:
According to the codebase documentation, `UnmeteredGasMeter` is a dummy gas meter where all charge methods return `Ok(())` without tracking or limiting gas usage, and `balance_internal()` returns `u64::MAX`.

**Attack Scenario:**

An attacker who can influence the genesis transaction file (via supply chain attack, compromised distribution channel, or social engineering) creates a malicious genesis transaction with a `WriteSetPayload::Script` containing:
- An infinite loop in Move bytecode
- Computationally expensive operations (e.g., exponential complexity algorithms)
- Large memory allocations

When node operators run the bootstrapper with this malicious genesis file, the script executes without gas limits, causing the bootstrapper to hang indefinitely.

**Broken Invariant:**

This violates the critical invariant #9: "Resource Limits: All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Severity: Medium to High**

This vulnerability enables a denial-of-service attack on node bootstrapping:

- **Validator Node Slowdowns/Hangs**: Validators attempting to bootstrap from a malicious genesis file will hang indefinitely, preventing them from joining the network (High Severity - up to $50,000)
- **State Inconsistencies**: If some nodes bootstrap successfully while others hang, it creates operational inconsistencies requiring manual intervention (Medium Severity)
- **Network Availability Impact**: During network genesis or hard fork scenarios where new genesis files are distributed, this could prevent significant portions of the network from coming online

The impact is particularly severe in:
- Initial network launch scenarios
- Hard fork events requiring new genesis
- Disaster recovery situations where nodes restore from genesis
- New validator onboarding

## Likelihood Explanation

**Likelihood: Medium**

The attack requires the attacker to influence the genesis transaction file used by node operators. This is achievable through:

1. **Supply Chain Attacks**: Compromising distribution channels or mirrors where genesis files are hosted
2. **Man-in-the-Middle Attacks**: Intercepting genesis file downloads over insecure connections
3. **Social Engineering**: Convincing operators to use malicious genesis files disguised as legitimate ones
4. **Compromised Infrastructure**: If an attacker gains access to systems hosting genesis files

While this requires more than a simple network transaction, it's within the capabilities of sophisticated attackers, especially during critical network events when many operators download genesis files simultaneously.

The likelihood increases during:
- Network launches when genesis files are widely distributed
- Hard fork events
- Scenarios where operators are under time pressure to bootstrap nodes

## Recommendation

**Immediate Fix**: Enforce gas metering for all genesis script execution.

Modify the `execute_write_set` function to use a production gas meter with a reasonable limit for script-based genesis payloads: [6](#0-5) 

**Recommended Changes:**

1. Replace `UnmeteredGasMeter` with a production gas meter when executing `WriteSetPayload::Script`
2. Set a reasonable gas limit for genesis scripts (e.g., 10 million gas units)
3. Add validation in the bootstrapper to verify genesis transaction structure before execution
4. Implement a timeout mechanism in the bootstrapper to detect and abort hanging genesis executions

**Additional Security Measures:**

1. **Cryptographic Verification**: Sign genesis transaction files with Aptos Foundation keys and verify signatures before execution
2. **Content Hash Validation**: Publish official genesis file hashes and verify them in the bootstrapper
3. **Script Complexity Analysis**: Implement static analysis to detect potentially dangerous patterns (loops, recursion) in genesis scripts before execution

## Proof of Concept

**Malicious Genesis Transaction Construction:**

```rust
// File: poc_malicious_genesis.rs
use aptos_types::transaction::{Transaction, WriteSetPayload, Script};
use move_core_types::{language_storage::TypeTag, transaction_argument::TransactionArgument};
use aptos_types::account_address::AccountAddress;

fn create_malicious_genesis() -> Transaction {
    // Move bytecode for infinite loop:
    // main() {
    //     loop {}
    // }
    let infinite_loop_bytecode = vec![
        // Simplified Move bytecode representing an infinite loop
        // In practice, would need to compile valid Move script with while(true) {}
        0xA1, 0x1E, 0xC0, 0xDE, // Magic number
        // ... bytecode instructions for infinite loop
    ];
    
    let script = Script::new(
        infinite_loop_bytecode,
        vec![], // no type arguments
        vec![], // no arguments
    );
    
    let payload = WriteSetPayload::Script {
        execute_as: AccountAddress::from_hex_literal("0x1").unwrap(),
        script,
    };
    
    Transaction::GenesisTransaction(payload)
}

// Serialize and write to file
fn main() {
    let malicious_genesis = create_malicious_genesis();
    let serialized = bcs::to_bytes(&malicious_genesis).unwrap();
    std::fs::write("malicious_genesis.blob", serialized).unwrap();
    
    println!("Created malicious genesis transaction");
    println!("Running bootstrapper with this file will hang indefinitely");
}
```

**Execution:**

```bash
# Compile the PoC
cargo run --bin poc_malicious_genesis

# Run bootstrapper with malicious genesis (will hang)
cargo run --bin aptos-db-tool -- \
    /path/to/db \
    --genesis-txn-file malicious_genesis.blob
# Process will hang indefinitely without timeout
```

**Expected Behavior**: The bootstrapper hangs indefinitely as the infinite loop script executes without gas metering.

## Notes

This vulnerability specifically affects the genesis bootstrapping process and highlights the critical need for gas metering enforcement across all transaction execution paths, including privileged system transactions. While genesis transactions are expected to be trusted, defense-in-depth principles require resource limits even for these special cases to prevent denial-of-service scenarios from supply chain compromises or operational errors.

### Citations

**File:** storage/db-tool/src/bootstrap.rs (L42-47)
```rust
        let genesis_txn = load_genesis_txn(&self.genesis_txn_file)
            .with_context(|| format_err!("Failed loading genesis txn."))?;
        assert!(
            matches!(genesis_txn, Transaction::GenesisTransaction(_)),
            "Not a GenesisTransaction"
        );
```

**File:** storage/db-tool/src/bootstrap.rs (L108-114)
```rust
fn load_genesis_txn(path: &Path) -> Result<Transaction> {
    let mut file = File::open(path)?;
    let mut buffer = vec![];
    file.read_to_end(&mut buffer)?;

    Ok(bcs::from_bytes(&buffer)?)
}
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L136-146)
```rust
    let execution_output = DoGetExecutionOutput::by_transaction_execution::<V>(
        &V::new(),
        vec![genesis_txn.clone().into()].into(),
        // TODO(grao): Do we need any auxiliary info for hard fork? Not now, but maybe one day we
        // will need it.
        vec![AuxiliaryInfo::new_empty()],
        &ledger_summary.state,
        base_state_view,
        BlockExecutorConfigFromOnchain::new_no_block_limit(),
        TransactionSliceMetadata::unknown(),
    )?;
```

**File:** types/src/transaction/mod.rs (L1008-1018)
```rust
pub enum WriteSetPayload {
    /// Directly passing in the WriteSet.
    Direct(ChangeSet),
    /// Generate the WriteSet by running a script.
    Script {
        /// Execute the script as the designated signer.
        execute_as: AccountAddress,
        /// Script body that gets executed.
        script: Script,
    },
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2266-2326)
```rust
    fn execute_write_set(
        &self,
        resolver: &impl AptosMoveResolver,
        code_storage: &impl AptosCodeStorage,
        write_set_payload: &WriteSetPayload,
        txn_sender: Option<AccountAddress>,
        session_id: SessionId,
    ) -> Result<(VMChangeSet, ModuleWriteSet), VMStatus> {
        match write_set_payload {
            WriteSetPayload::Direct(change_set) => {
                // this transaction is never delayed field capable.
                // it requires restarting execution afterwards,
                // which allows it to be used as last transaction in delayed_field_enabled context.
                let (change_set, module_write_set) =
                    create_vm_change_set_with_module_write_set_when_delayed_field_optimization_disabled(
                        change_set.clone(),
                    );

                // validate_waypoint_change_set checks that this is true, so we only log here.
                if !Self::should_restart_execution(change_set.events()) {
                    // This invariant needs to hold irrespectively, so we log error always.
                    // but if we are in delayed_field_optimization_capable context, we cannot execute any transaction after this.
                    // as transaction afterwards would be executed assuming delayed fields are exchanged and
                    // resource groups are split, but WriteSetPayload::Direct has materialized writes,
                    // and so after executing this transaction versioned state is inconsistent.
                    error!(
                        "[aptos_vm] direct write set finished without requiring should_restart_execution");
                }

                Ok((change_set, module_write_set))
            },
            WriteSetPayload::Script { script, execute_as } => {
                let mut tmp_session = self.new_session(resolver, session_id, None);
                let senders = match txn_sender {
                    None => vec![serialized_signer(execute_as)],
                    Some(sender) => vec![serialized_signer(&sender), serialized_signer(execute_as)],
                };

                let traversal_storage = TraversalStorage::new();
                let mut traversal_context = TraversalContext::new(&traversal_storage);

                self.validate_and_execute_script(
                    &mut tmp_session,
                    &SerializedSigners::new(senders, None),
                    code_storage,
                    &mut UnmeteredGasMeter,
                    &mut traversal_context,
                    script,
                    &mut NoOpTraceRecorder,
                )?;

                let change_set_configs =
                    ChangeSetConfigs::unlimited_at_gas_feature_version(self.gas_feature_version());
                let change_set = tmp_session.finish(&change_set_configs, code_storage)?;

                // While scripts should be able to publish modules, this should be done through
                // native context, and so the module write set must always be empty.
                Ok((change_set, ModuleWriteSet::empty()))
            },
        }
    }
```
