# Audit Report

## Title
Consensus Security Events Can Be Silently Dropped Due to Async Logging Channel Saturation

## Summary
When async logging is enabled (default configuration), critical consensus security events such as `ConsensusInvalidMessage`, `ConsensusEquivocatingVote`, and `InvalidBlock` can be silently dropped if the logging channel becomes full. The system lacks a fallback mechanism, potentially hiding forensic evidence of consensus attacks at the exact moment when detailed logging is most crucial for security incident response.

## Finding Description

The Aptos logger uses an async logging architecture with a bounded channel of size 10,000 entries. [1](#0-0) 

When a log event is recorded, it flows through the following path:
1. Security events (e.g., `SecurityEvent::ConsensusInvalidMessage`) are logged using the `error!()` macro [2](#0-1) 
2. This triggers `Logger::record()` which creates a `LogEntry` and calls `send_entry()` [3](#0-2) 
3. The `send_entry()` method attempts to send the log via `try_send()`, which is non-blocking [4](#0-3) 

**Critical Issue:** When `try_send()` fails because the channel is full, the log entry is **silently dropped** with only a counter increment. There is no fallback mechanism such as:
- Blocking until space is available for critical security events
- Writing directly to disk
- Prioritizing security events over informational logs
- Alerting operators immediately of log loss

This affects critical consensus security events including:
- `ConsensusInvalidMessage` - invalid messages from peers
- `ConsensusEquivocatingVote` - equivocating votes [5](#0-4) 
- `InvalidConsensusProposal` - invalid proposals [6](#0-5) 
- `InvalidRetrievedBlock` - invalid block retrievals [7](#0-6) 

**Attack Scenario:**
An attacker could exploit this by:
1. Sending malformed consensus messages at high volume to multiple validators
2. Filling the 10,000-entry logging channel with error logs
3. Subsequently performing more sophisticated attacks (subtle equivocation, timing attacks on proposals)
4. The detailed forensic information about the sophisticated attack is dropped
5. Incident responders lack the peer IDs, message contents, and error details needed for investigation

While the `STRUCT_LOG_QUEUE_ERROR_COUNT` metric is incremented [8](#0-7) , and monitoring alerts exist [9](#0-8) , the alert is only warning-level and fires after 5 minutes of sustained log drops - long after an attack could exploit this window.

## Impact Explanation

This issue qualifies as **Medium Severity** under the Aptos bug bounty criteria for the following reasons:

**State Inconsistencies Requiring Intervention:** While this doesn't directly cause state corruption, it creates forensic blindness during security incidents. When consensus attacks occur, operators cannot determine:
- Which peers sent malicious messages
- What the specific attack pattern was
- Whether subsequent anomalies are related to the initial attack
- The full scope and timeline of the incident

This forces manual intervention and may require rolling back to earlier states or hard forks if the attack's full impact cannot be determined from limited metrics alone.

**Security Monitoring Compromise:** The security event logging system defined in [10](#0-9)  exists specifically to "detect malicious behavior from other validators." When these logs are dropped during an attack, the system fails its core security monitoring purpose.

**Not Critical Because:**
- Consensus safety mechanisms (voting rules, QC verification) still function
- Metrics counters (CRITICAL_ERRORS, ERROR_LOG_COUNT) are still incremented
- No direct fund loss or consensus protocol violation
- Network rate limiting provides some protection against log flooding

## Likelihood Explanation

**Likelihood: Medium**

This scenario is moderately likely to occur under the following conditions:

1. **During Active Attacks:** When a validator is under attack, log volume naturally spikes. This creates a dangerous feedback loop where the attack itself causes the logging system to fail exactly when detailed logs are most needed.

2. **Network Anomalies:** During network partitions, state sync issues, or epoch transitions, validators may process many invalid messages from peers with stale state, filling the log buffer.

3. **Byzantine Validators:** A malicious validator with signing keys can generate valid-looking but Byzantine messages (equivocations, invalid proposals) at high volume to deliberately saturate logging channels of honest validators.

4. **Operational Issues:** Memory pressure, disk I/O bottlenecks, or downstream log aggregation failures can slow the log processing thread, causing the channel to fill even under normal load.

The default channel size of 10,000 entries may seem large, but during consensus attacks involving multiple malicious peers, this can be exhausted quickly. Each invalid message generates a structured log entry with peer information, message details, and error context.

## Recommendation

Implement a multi-tier logging strategy with prioritization and fallback mechanisms:

```rust
fn send_entry(&self, entry: LogEntry) {
    // Synchronous printer (if configured) is unaffected
    if let Some(printer) = &self.printer {
        let s = (self.formatter)(&entry).expect("Unable to format");
        printer.write(s);
    }

    if let Some(sender) = &self.sender {
        // Prioritize security events - use blocking send for critical logs
        let is_security_event = entry.data().contains_key(&Key::new("security-event"));
        let is_critical_error = entry.metadata.level() == Level::Error;
        
        if is_security_event || (is_critical_error && entry.data().contains_key(&Key::new("critical-error"))) {
            // For security events, block briefly to ensure delivery
            match sender.send_timeout(
                LoggerServiceEvent::LogEntry(entry),
                Duration::from_millis(100)
            ) {
                Ok(_) => {},
                Err(e) => {
                    // Last resort: write directly to emergency log file
                    eprintln!("[CRITICAL] Failed to log security event: {:?}", e);
                    STRUCT_LOG_QUEUE_ERROR_COUNT.inc();
                    SECURITY_LOG_DROP_COUNT.inc(); // New metric
                }
            }
        } else {
            // Non-critical logs use try_send (current behavior)
            if sender.try_send(LoggerServiceEvent::LogEntry(entry)).is_err() {
                STRUCT_LOG_QUEUE_ERROR_COUNT.inc();
            }
        }
    }
}
```

Additional improvements:
1. **Increase channel size** for production validators: Change CHANNEL_SIZE from 10,000 to 100,000
2. **Add security event counter**: Separate metric tracking dropped security events specifically
3. **Upgrade alert severity**: Make "Logs Being Dropped" a critical alert, not warning
4. **Emergency log file**: Create a separate emergency log file for security events when the channel is full
5. **Rate limit logging itself**: Implement sampling for high-volume non-critical logs to preserve capacity for security events

## Proof of Concept

The vulnerability can be demonstrated with the following Rust test that simulates log channel saturation:

```rust
#[cfg(test)]
mod security_log_drop_test {
    use super::*;
    use aptos_logger::{Level, Logger, SecurityEvent};
    use std::sync::Arc;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_security_events_dropped_on_channel_full() {
        // Initialize logger with small channel for testing
        let mut builder = AptosData::builder();
        builder
            .channel_size(10) // Small channel to trigger overflow
            .is_async(true)
            .level(Level::Debug);
        let logger = builder.build();

        // Fill the channel with non-critical logs
        for i in 0..15 {
            info!("Filling channel with log {}", i);
        }

        // Give async thread time to process (but not enough to clear channel)
        thread::sleep(Duration::from_millis(10));

        // Now try to log a critical security event
        let initial_error_count = STRUCT_LOG_QUEUE_ERROR_COUNT.get();
        
        error!(
            SecurityEvent::ConsensusInvalidMessage,
            peer = "malicious_validator",
            error = "equivocating vote detected"
        );

        // Verify the security event was dropped
        let final_error_count = STRUCT_LOG_QUEUE_ERROR_COUNT.get();
        assert!(
            final_error_count > initial_error_count,
            "Security event should have been dropped due to full channel"
        );

        // The security event details are lost - only a counter was incremented
        // In a real attack, the peer ID and error details would be unavailable
        // for incident response
    }
}
```

To demonstrate in a running validator:
1. Deploy a malicious peer that sends 10,000 malformed consensus messages rapidly
2. Monitor `aptos_struct_log_queue_error_count` metric
3. Send an equivocating vote immediately after
4. Observe that the equivocation details are not present in logs, only the drop counter increased

## Notes

The `alert!()` macro used for critical VM errors does increment the `CRITICAL_ERRORS` counter even when logs are dropped [11](#0-10) , providing some detection capability. However, consensus security events logged via `error!(SecurityEvent::...)` do not have this dual-path protection, making them fully vulnerable to silent drops.

The logging system's non-blocking design is intentional to prevent logging from impacting consensus performance [1](#0-0) . However, this creates a "fails when you need it most" scenario where the system's security monitoring is degraded precisely during attacks when detailed forensics are most critical.

### Citations

**File:** crates/aptos-logger/src/aptos_logger.rs (L43-44)
```rust
/// Default size of log write channel, if the channel is full, logs will be dropped
pub const CHANNEL_SIZE: usize = 10000;
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L550-564)
```rust
    fn send_entry(&self, entry: LogEntry) {
        if let Some(printer) = &self.printer {
            let s = (self.formatter)(&entry).expect("Unable to format");
            printer.write(s);
        }

        if let Some(sender) = &self.sender {
            if sender
                .try_send(LoggerServiceEvent::LogEntry(entry))
                .is_err()
            {
                STRUCT_LOG_QUEUE_ERROR_COUNT.inc();
            }
        }
    }
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L572-580)
```rust
    fn record(&self, event: &Event) {
        let entry = LogEntry::new(
            event,
            ::std::thread::current().name(),
            self.enable_backtrace,
        );

        self.send_entry(entry)
    }
```

**File:** consensus/src/epoch_manager.rs (L1613-1618)
```rust
                            error!(
                                SecurityEvent::ConsensusInvalidMessage,
                                remote_peer = peer_id,
                                error = ?e,
                                unverified_event = unverified_event
                            );
```

**File:** consensus/src/pending_votes.rs (L300-305)
```rust
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L50-57)
```rust
                warn!(
                    SecurityEvent::InvalidConsensusProposal,
                    "Proposal is not from valid author {}, expected {} for round {} and id {}",
                    author,
                    self.get_valid_proposer(block.round()),
                    block.round(),
                    block.id()
                );
```

**File:** consensus/src/network.rs (L305-309)
```rust
                error!(
                    SecurityEvent::InvalidRetrievedBlock,
                    request_block_response = response,
                    error = ?e,
                );
```

**File:** crates/aptos-logger/src/counters.rs (L31-37)
```rust
pub static STRUCT_LOG_QUEUE_ERROR_COUNT: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!(
        "aptos_struct_log_queue_error_count",
        "Count of all errors during queuing struct logs."
    )
    .unwrap()
});
```

**File:** terraform/helm/monitoring/files/rules/alerts.yml (L156-166)
```yaml
  - alert: Logs Being Dropped
    expr: 1 < (rate(aptos_struct_log_queue_error[1m]) + rate(aptos_struct_log_send_error[1m]))
    for: 5m
    labels:
      severity: warning
      summary: "Logs being dropped"
    annotations:
      description: "Logging Transmit Error rate is high \
        check the logging dashboard and \
        there may be network issues, downstream throughput issues, or something wrong with Vector \
        TODO: Runbook"
```

**File:** crates/aptos-logger/src/security.rs (L23-82)
```rust
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SecurityEvent {
    //
    // Mempool
    //
    /// Mempool received a transaction from another peer with an invalid signature
    InvalidTransactionMempool,

    /// Mempool received an invalid network event
    InvalidNetworkEventMempool,

    // Consensus
    // ---------
    /// Consensus received an invalid message (not well-formed, invalid vote data or incorrect signature)
    ConsensusInvalidMessage,

    /// Consensus received an equivocating vote
    ConsensusEquivocatingVote,

    /// Consensus received an equivocating order vote
    ConsensusEquivocatingOrderVote,

    /// Consensus received an invalid proposal
    InvalidConsensusProposal,

    /// Consensus received an invalid new round message
    InvalidConsensusRound,

    /// Consensus received an invalid sync info message
    InvalidSyncInfoMsg,

    /// A received block is invalid
    InvalidRetrievedBlock,

    /// A block being committed or executed is invalid
    InvalidBlock,

    // State-Sync
    // ----------
    /// Invalid chunk of transactions received
    StateSyncInvalidChunk,

    // Health Checker
    // --------------
    /// HealthChecker received an invalid network event
    InvalidNetworkEventHC,

    /// HealthChecker received an invalid message
    InvalidHealthCheckerMsg,

    // Network
    // -------
    /// Network received an invalid message from a remote peer
    InvalidNetworkEvent,

    /// A failed noise handshake that's either a clear bug or indicates some
    /// security issue.
    NoiseHandshake,
}
```

**File:** aptos-move/aptos-vm-logging/src/lib.rs (L164-169)
```rust
macro_rules! alert {
    ($($args:tt)+) => {
	error!($($args)+);
	CRITICAL_ERRORS.inc();
    };
}
```
