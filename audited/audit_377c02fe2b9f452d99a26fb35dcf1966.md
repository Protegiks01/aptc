# Audit Report

## Title
Stack Overflow Vulnerability in `native_from_bytes()` Due to Missing Depth Check During Deserialization

## Summary
The `native_from_bytes()` function in `aptos-move/framework/src/natives/util.rs` deserializes Move values without tracking or checking nesting depth, despite the serialization path enforcing such limits. This asymmetry allows attackers to craft deeply nested payloads that trigger unbounded recursive deserialization, potentially causing platform-dependent stack overflow and non-deterministic validator node crashes.

## Finding Description

The vulnerability exists in the deserialization path used by `native_from_bytes()`. While Move value serialization enforces a maximum nesting depth of 128 via `check_depth()`, the deserialization process has **no corresponding depth tracking or validation**.

**Vulnerable Code Path:**

1. **Entry point** - `native_from_bytes()` creates a `ValueSerDeContext` with `max_value_nest_depth` and calls `deserialize()`: [1](#0-0) 

2. **Deserialization without depth tracking** - The `DeserializationSeed` struct lacks a `depth` field: [2](#0-1) 

3. **Recursive processing without checks** - Structs recursively deserialize: [3](#0-2) 

4. **Vectors also recurse without checks**: [4](#0-3) 

5. **Struct fields recurse through visitor**: [5](#0-4) 

**In contrast, serialization enforces depth limits:**

The `SerializationReadyValue` struct includes a `depth` field: [6](#0-5) 

And actively checks it during serialization: [7](#0-6) 

The `check_depth()` implementation enforces the limit: [8](#0-7) 

**Attack Scenario:**

1. Attacker creates a Move type with depth approaching 128 (e.g., nested structs: `struct A { b: B }`, `struct B { c: C }`, etc.)
2. Type layout construction succeeds as depth ≤ 128: [9](#0-8) 

3. Attacker crafts BCS-encoded bytes representing a fully-populated nested value at depth ~128
4. Attacker submits transaction calling a native function that uses `from_bytes<T>()` with the malicious payload
5. Deserialization recursively processes all ~128 nesting levels **without any depth check**
6. Each recursive call consumes Rust stack space
7. On systems with smaller stacks or higher stack frame sizes, this triggers stack overflow and crashes the validator node

**Broken Invariants:**

- **Deterministic Execution**: Stack overflow is platform-dependent (stack size varies: 2MB Linux, 1MB macOS, 8MB Windows), causing non-deterministic validator behavior
- **Move VM Safety**: Bytecode execution fails to respect memory constraints (stack exhaustion)
- **Resource Limits**: Operations do not respect computational limits (unbounded recursion)

## Impact Explanation

**Severity: HIGH** (Validator Node Crashes + Non-Deterministic Behavior)

This vulnerability enables **non-deterministic validator node crashes**, which violates the consensus safety invariant:

1. **Platform-Dependent Behavior**: Different validators may crash or succeed based on:
   - Operating system (different default stack sizes)
   - Thread configuration
   - Current stack usage
   - Compiler optimization levels

2. **Consensus Split Risk**: If some validators crash while processing a block containing the malicious transaction, but others succeed (or have already crashed/restarted), this creates:
   - Temporary liveness degradation
   - Potential for different validators to be at different states
   - Network instability requiring manual intervention

3. **Denial of Service**: Attackers can repeatedly submit transactions to crash validators, degrading network availability

While not as severe as fund theft or permanent consensus failure, this meets **High Severity** criteria per the bug bounty program: "Validator node slowdowns" and "Significant protocol violations" (non-deterministic execution violates determinism invariant).

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Favorable Conditions for Attacker:**
- Any transaction sender can exploit this (no special privileges required)
- Multiple native functions expose `from_bytes<T>()` with user-controlled types
- Attacker controls both the type definition and the serialized bytes
- Cost is just transaction gas (low economic barrier)

**Exploitation Complexity:**
- Attacker must create a deeply nested type (trivial - just define recursive structs)
- Must craft valid BCS-encoded bytes (straightforward with BCS libraries)
- Must identify a code path that calls `from_bytes<T>()` on user-controlled types

**Uncertainty Factors:**
- Actual stack depth required for overflow depends on platform
- Modern systems have larger stacks (2-8MB), making exploitation less certain
- Compiler optimizations may reduce per-frame stack usage
- Requires testing to confirm exploitability on production environments

## Recommendation

**Immediate Fix: Add Depth Tracking to Deserialization**

Modify `DeserializationSeed` to track depth similar to `SerializationReadyValue`:

```rust
pub(crate) struct DeserializationSeed<'c, L> {
    pub(crate) ctx: &'c ValueSerDeContext<'c>,
    pub(crate) layout: L,
    pub(crate) depth: u64,  // ADD THIS FIELD
}
```

Add depth checking at the start of the `deserialize` implementation:

```rust
fn deserialize<D: serde::de::Deserializer<'d>>(
    self,
    deserializer: D,
) -> Result<Self::Value, D::Error> {
    // ADD THIS CHECK
    self.ctx.check_depth(self.depth).map_err(D::Error::custom)?;
    
    use MoveTypeLayout as L;
    match self.layout {
        // ... rest of implementation
    }
}
```

Increment depth when creating child seeds:

```rust
// For structs:
let seed = DeserializationSeed {
    ctx: self.ctx,
    layout: struct_layout,
    depth: self.depth + 1,  // INCREMENT
};

// For vectors:
let seed = DeserializationSeed {
    ctx: self.ctx,
    layout,
    depth: self.depth + 1,  // INCREMENT
};
```

Initialize depth to 1 in the entry point: [10](#0-9) 

Change to:
```rust
pub fn deserialize(self, bytes: &[u8], layout: &MoveTypeLayout) -> Option<Value> {
    let seed = DeserializationSeed { 
        ctx: &self, 
        layout,
        depth: 1,  // START AT DEPTH 1
    };
    bcs::from_bytes_seed(seed, bytes).ok()
}
```

## Proof of Concept

**Move PoC (Conceptual - requires framework access):**

```move
module attacker::stack_bomb {
    use std::bcs;
    use aptos_std::from_bcs;

    // Create deeply nested type (pseudocode - repeat 127 times)
    struct L127 { x: u64 }
    struct L126 { x: L127 }
    struct L125 { x: L126 }
    // ... continue nesting ...
    struct L1 { x: L2 }
    struct L0 { x: L1 }

    public entry fun trigger_overflow() {
        // Craft BCS bytes for fully-nested L0 value
        // Each level has actual struct data, not just empty
        let malicious_bytes = construct_deep_nesting_bytes();
        
        // This will trigger recursive deserialization without depth check
        let _value = from_bcs::to_bytes<L0>(&malicious_bytes);
        // Stack overflow may occur here depending on platform
    }
}
```

**Rust Reproduction Steps:**

1. Create a test with a deeply nested type layout (depth = 128)
2. Serialize a fully-populated value of this type using a different path
3. Call `ValueSerDeContext::deserialize()` with these bytes
4. Observe that deserialization succeeds without depth checking
5. On systems with smaller stacks, observe potential stack overflow
6. Compare with serialization path which would fail the depth check

**Expected Behavior:**
- Deserialization should fail with `VM_MAX_VALUE_DEPTH_REACHED` error (same as serialization)
- Actual behavior: Deserialization proceeds unchecked until completion or stack overflow

## Notes

**Additional Context:**

1. **Maximum Depth Constants**: Both `layout_max_depth` and `max_value_nest_depth` are set to 128: [11](#0-10) 

2. **Layout Construction Has Checks**: The type layout construction properly enforces depth limits, but this occurs before deserialization and doesn't protect against the recursive deserialization itself.

3. **Asymmetry is the Root Cause**: The fundamental issue is the asymmetric treatment of depth between serialization (checked) and deserialization (unchecked), violating defense-in-depth principles.

4. **Platform Dependency Creates Non-Determinism**: The most severe aspect is that stack overflow depends on platform characteristics, potentially causing different validators to behave differently on the same transaction—a critical consensus violation.

### Citations

**File:** aptos-move/framework/src/natives/util.rs (L46-51)
```rust
    let function_value_extension = context.function_value_extension();
    let max_value_nest_depth = context.max_value_nest_depth();
    let val = match ValueSerDeContext::new(max_value_nest_depth)
        .with_legacy_signer()
        .with_func_args_deserialization(&function_value_extension)
        .deserialize(&bytes, &layout)
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L57-57)
```rust
pub const DEFAULT_MAX_VM_VALUE_NESTED_DEPTH: u64 = 128;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4818-4826)
```rust
pub(crate) struct SerializationReadyValue<'c, 'l, 'v, L, V> {
    // Contains the current (possibly custom) serialization context.
    pub(crate) ctx: &'c ValueSerDeContext<'c>,
    // Layout for guiding serialization.
    pub(crate) layout: &'l L,
    // Value to serialize.
    pub(crate) value: &'v V,
    pub(crate) depth: u64,
}
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4838-4838)
```rust
        self.ctx.check_depth(self.depth).map_err(S::Error::custom)?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5085-5090)
```rust
pub(crate) struct DeserializationSeed<'c, L> {
    // Holds extensions external to the deserializer.
    pub(crate) ctx: &'c ValueSerDeContext<'c>,
    // Layout to guide deserialization.
    pub(crate) layout: L,
}
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5131-5138)
```rust
            // Structs.
            L::Struct(struct_layout) => {
                let seed = DeserializationSeed {
                    ctx: self.ctx,
                    layout: struct_layout,
                };
                Ok(Value::struct_(seed.deserialize(deserializer)?))
            },
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5156-5163)
```rust
                layout => {
                    let seed = DeserializationSeed {
                        ctx: self.ctx,
                        layout,
                    };
                    let vector = deserializer.deserialize_seq(VectorElementVisitor(seed))?;
                    Value::Container(Container::Vec(Rc::new(RefCell::new(vector))))
                },
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5300-5310)
```rust
        for (i, field_layout) in self.1.iter().enumerate() {
            if let Some(elem) = seq.next_element_seed(DeserializationSeed {
                ctx: self.0,
                layout: field_layout,
            })? {
                val.push(elem)
            } else {
                return Err(A::Error::invalid_length(i, &self));
            }
        }
        Ok(val)
```

**File:** third_party/move/move-vm/types/src/value_serde.rs (L149-157)
```rust
    pub(crate) fn check_depth(&self, depth: u64) -> PartialVMResult<()> {
        if self
            .max_value_nested_depth
            .is_some_and(|max_depth| depth > max_depth)
        {
            return Err(PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED));
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/types/src/value_serde.rs (L238-241)
```rust
    pub fn deserialize(self, bytes: &[u8], layout: &MoveTypeLayout) -> Option<Value> {
        let seed = DeserializationSeed { ctx: &self, layout };
        bcs::from_bytes_seed(seed, bytes).ok()
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L213-220)
```rust
        if depth > self.vm_config().layout_max_depth {
            return Err(
                PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED).with_message(format!(
                    "Depth of a layout exceeded the maximum of {} during construction",
                    self.vm_config().layout_max_depth
                )),
            );
        }
```
