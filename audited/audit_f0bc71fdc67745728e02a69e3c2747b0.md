# Audit Report

## Title
FaTransfer Transaction Creates FungibleStore Without Account Resource, Violating State Consistency Invariants

## Summary
The native executor's `FaTransfer` transaction handling fails to create the `Account` resource when depositing to a new address. Unlike `Transfer` and `BatchTransfer` which properly use the return value from `deposit_apt()` to trigger account creation, `FaTransfer` ignores the return value and never calls `check_or_create_account()`. This creates addresses with `FungibleStore` resources but no `Account` resource, violating critical state consistency invariants.

## Finding Description

The `deposit_apt()` function returns a boolean indicating whether the store (CoinStore or FungibleStore) existed before the deposit operation. [1](#0-0) 

Callers are expected to use this return value to determine if the `Account` resource needs to be created. The `Transfer` and `BatchTransfer` handlers correctly implement this pattern: [2](#0-1) 

However, the `FaTransfer` handler completely ignores the return value and never calls `check_or_create_account()`: [3](#0-2) 

The same vulnerability exists in the parallel executor implementation: [4](#0-3) 

When `deposit_fa_apt()` is called on a new address, it creates a `FungibleStore` and `ObjectCore` but does not verify or create the `Account` resource: [5](#0-4) 

This deviates from the correct implementation in the Aptos Framework, where `aptos_account::transfer` always creates the account before transferring: [6](#0-5) 

**Attack Path:**
1. Attacker sends a `FaTransfer` transaction to a previously unused address
2. The native executor calls `deposit_fa_apt()` which creates a `FungibleStore` at the address
3. The return value indicating the store didn't exist is discarded
4. No call to `check_or_create_account()` is made
5. The address now has a `FungibleStore` but lacks the fundamental `Account` resource
6. Future operations on this address may fail or behave unexpectedly due to missing sequence numbers, authentication keys, and other critical account metadata

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Specific Impacts:**
1. **State Consistency Violation**: Breaks the invariant that all addresses with resources must have an `Account` resource
2. **Missing Critical Metadata**: Addresses lack sequence numbers, authentication keys, guid creation counters, and event handles defined in the `Account` struct: [7](#0-6) 
3. **Transaction Validation Issues**: Attempts to send transactions FROM these addresses would fail sequence number validation since no `Account` resource exists
4. **Deterministic Execution Risk**: The native executor is meant to benchmark deterministic execution for the real AptosVM, but this inconsistency means it produces different state outcomes than the real implementation

The `Account` resource can never be deleted (no `move_from<Account>` exists in the codebase), so this is a permanent state inconsistency that would require manual intervention to correct.

## Likelihood Explanation

**Likelihood: High** within the context of native executor usage.

The vulnerability triggers automatically whenever:
- The native executor is used (for benchmarking/testing)
- FA migration is complete (`OPERATIONS_DEFAULT_TO_FA_APT_STORE` feature flag enabled)
- A `FaTransfer` is sent to a new address

No special conditions or race conditions are required. The bug is deterministic and will occur every time these conditions are met. While the native executor is primarily used for benchmarking (not production), state inconsistencies in benchmark code can mask real issues and provide incorrect performance/correctness data.

## Recommendation

The `FaTransfer` handler must capture the return value from `deposit_fa_apt()` and call `check_or_create_account()` when the store didn't previously exist, matching the pattern used by `Transfer` and `BatchTransfer`.

**Fixed Code (native_vm.rs):**
```rust
NativeTransaction::FaTransfer {
    sender,
    sequence_number,
    recipient,
    amount,
} => {
    self.check_and_set_sequence_number(
        sender,
        sequence_number,
        view,
        &mut resource_write_set,
    )?;
    self.withdraw_fa_apt_from_signer(
        sender,
        amount,
        view,
        gas,
        &mut resource_write_set,
        &mut events,
    )?;
    if amount > 0 {
        let existed = self.deposit_fa_apt(
            recipient,
            amount,
            view,
            &mut resource_write_set,
            &mut events,
        )?;
        
        // FIXED: Create account if store didn't exist
        if !existed {
            self.check_or_create_account(
                recipient,
                false, // fail_on_account_existing
                false, // fail_on_account_missing  
                true,  // create_account_resource
                view,
                &mut resource_write_set,
            )?;
        }
    }
},
```

The same fix should be applied to the parallel executor: [8](#0-7) 

## Proof of Concept

```rust
// Test case demonstrating the vulnerability
#[test]
fn test_fa_transfer_missing_account_creation() {
    use aptos_types::account_address::AccountAddress;
    
    // Setup: Initialize native VM with FA migration enabled
    let native_vm = NativeVMExecutorTask {
        fa_migration_complete: true,
        db_util: DbAccessUtil::new(),
    };
    
    // Create sender with Account resource
    let sender = AccountAddress::random();
    let recipient = AccountAddress::random(); // Fresh address
    
    // Execute FaTransfer to new recipient
    let txn = NativeTransaction::FaTransfer {
        sender,
        sequence_number: 0,
        recipient,
        amount: 1000,
    };
    
    // After execution, check state:
    // 1. Recipient has FungibleStore (created by deposit_fa_apt)
    let store_key = primary_apt_store(recipient);
    assert!(view.get_resource_from_group(&store_key, &fungible_store_tag).is_some());
    
    // 2. Recipient LACKS Account resource (BUG!)
    let account_key = new_state_key_account(&recipient);
    assert!(view.get_resource(&account_key).is_none()); // This passes, proving the bug
    
    // 3. Attempting to send transaction FROM recipient would fail
    //    because sequence number validation requires Account resource
}
```

**Notes**

This vulnerability only affects the native executor used for benchmarking, not the production AptosVM. However, it represents a critical deviation from the correct implementation in the Aptos Framework and violates the fundamental state consistency invariant that all addresses with resources must have an `Account` resource. The return value confusion occurs because callers must interpret whether the boolean indicates store existence and take appropriate action to ensure account creation, but the `FaTransfer` handler fails to do this.

### Citations

**File:** execution/executor-benchmark/src/native/native_vm.rs (L234-263)
```rust
            NativeTransaction::FaTransfer {
                sender,
                sequence_number,
                recipient,
                amount,
            } => {
                self.check_and_set_sequence_number(
                    sender,
                    sequence_number,
                    view,
                    &mut resource_write_set,
                )?;
                self.withdraw_fa_apt_from_signer(
                    sender,
                    amount,
                    view,
                    gas,
                    &mut resource_write_set,
                    &mut events,
                )?;
                if amount > 0 {
                    self.deposit_fa_apt(
                        recipient,
                        amount,
                        view,
                        &mut resource_write_set,
                        &mut events,
                    )?;
                }
            },
```

**File:** execution/executor-benchmark/src/native/native_vm.rs (L289-307)
```rust
                let exists = self.deposit_apt(
                    fa_migration_complete,
                    recipient,
                    amount,
                    view,
                    &mut resource_write_set,
                    &mut events,
                )?;

                if !exists || fail_on_account_existing {
                    self.check_or_create_account(
                        recipient,
                        fail_on_account_existing,
                        fail_on_account_missing,
                        !fa_migration_complete,
                        view,
                        &mut resource_write_set,
                    )?;
                }
```

**File:** execution/executor-benchmark/src/native/native_vm.rs (L734-761)
```rust
    /// Returns bool whether FungibleStore existed.
    fn deposit_apt(
        &self,
        fa_migration_complete: bool,
        recipient_address: AccountAddress,
        transfer_amount: u64,
        view: &(impl ExecutorView + ResourceGroupView),
        resource_write_set: &mut BTreeMap<StateKey, AbstractResourceWriteOp>,
        events: &mut Vec<(ContractEvent, Option<MoveTypeLayout>)>,
    ) -> Result<bool, ()> {
        if fa_migration_complete {
            self.deposit_fa_apt(
                recipient_address,
                transfer_amount,
                view,
                resource_write_set,
                events,
            )
        } else {
            self.deposit_coin_apt(
                recipient_address,
                transfer_amount,
                view,
                resource_write_set,
                events,
            )
        }
    }
```

**File:** execution/executor-benchmark/src/native/native_vm.rs (L764-831)
```rust
    fn deposit_fa_apt(
        &self,
        recipient_address: AccountAddress,
        transfer_amount: u64,
        view: &(impl ExecutorView + ResourceGroupView),
        resource_write_set: &mut BTreeMap<StateKey, AbstractResourceWriteOp>,
        events: &mut Vec<(ContractEvent, Option<MoveTypeLayout>)>,
    ) -> Result<bool, ()> {
        let recipient_store_address = primary_apt_store(recipient_address);
        let recipient_fa_store_object_key = self
            .db_util
            .new_state_key_object_resource_group(&recipient_store_address);
        let fungible_store_rg_tag = &self.db_util.common.fungible_store;

        let (mut fa_store, rest_to_create, existed) =
            match Self::get_value_from_group::<FungibleStoreResource>(
                &recipient_fa_store_object_key,
                fungible_store_rg_tag,
                view,
            )? {
                Some(fa_store) => (fa_store, None, true),
                None => (
                    FungibleStoreResource::new(AccountAddress::TEN, 0, false),
                    Some(BTreeMap::from([(
                        self.db_util.common.object_core.clone(),
                        bcs::to_bytes(&DbAccessUtil::new_object_core(
                            recipient_store_address,
                            recipient_address,
                        ))
                        .map_err(hide_error)?,
                    )])),
                    false,
                ),
            };

        fa_store.balance += transfer_amount;

        let fa_store_write = if existed {
            Self::create_single_resource_in_group_modification(
                &fa_store,
                &recipient_fa_store_object_key,
                fungible_store_rg_tag.clone(),
                view,
            )?
        } else {
            let mut rg = rest_to_create.unwrap();
            rg.insert(
                fungible_store_rg_tag.clone(),
                bcs::to_bytes(&fa_store).map_err(hide_error)?,
            );
            Self::create_resource_in_group_creation(&recipient_fa_store_object_key, rg, view)?
        };
        resource_write_set.insert(recipient_fa_store_object_key, fa_store_write);

        if transfer_amount > 0 {
            let event = DepositFAEvent {
                store: recipient_store_address,
                amount: transfer_amount,
            };
            events.push((
                event
                    .create_event_v2()
                    .expect("Creating DepositFAEvent should always succeed"),
                None,
            ));
        }
        Ok(existed)
    }
```

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L339-350)
```rust
            NativeTransaction::FaTransfer {
                sender,
                sequence_number,
                recipient,
                amount,
            } => {
                self.update_sequence_number(sender, sequence_number, state_view, &mut output)?;

                self.withdraw_fa_apt_from_signer(sender, amount, gas, state_view, &mut output)?;

                let _existed = self.deposit_fa_apt(recipient, amount, state_view, &mut output)?;
            },
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L82-97)
```text
    public entry fun transfer(source: &signer, to: address, amount: u64) {
        if (!account::exists_at(to)) {
            create_account(to)
        };

        if (features::operations_default_to_fa_apt_store_enabled()) {
            fungible_transfer_only(source, to, amount)
        } else {
            // Resource accounts can be created without registering them to receive APT.
            // This conveniently does the registration if necessary.
            if (!coin::is_account_registered<AptosCoin>(to)) {
                coin::register<AptosCoin>(&create_signer(to));
            };
            coin::transfer<AptosCoin>(source, to, amount)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L60-69)
```text
    /// Resource representing an account.
    struct Account has key, store {
        authentication_key: vector<u8>,
        sequence_number: u64,
        guid_creation_num: u64,
        coin_register_events: EventHandle<CoinRegisterEvent>,
        key_rotation_events: EventHandle<KeyRotationEvent>,
        rotation_capability_offer: CapabilityOffer<RotationCapability>,
        signer_capability_offer: CapabilityOffer<SignerCapability>,
    }
```
