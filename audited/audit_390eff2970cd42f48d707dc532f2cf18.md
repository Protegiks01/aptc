# Audit Report

## Title
Incomplete Test Native Validation in `assert_no_test_natives()` Allows Critical Test Functions in Production

## Summary
The `assert_no_test_natives()` function in `aptos-vm/src/natives.rs` has incomplete coverage, missing 6 test-only native functions across cryptography, event, and algebra modules. Additionally, it checks for a non-existent function name (`emitted_events_internal`) while the actual test natives (`emitted_events` and `emitted_events_by_handle`) remain unvalidated. If the "testing" feature flag is accidentally enabled in production builds, these unvalidated natives would be exposed, potentially enabling information disclosure, cryptographic weaknesses, and gas metering bypasses.

## Finding Description
The `assert_no_test_natives()` function is designed as a safety check to ensure test-only native functions are not present in production builds. However, the current implementation has critical gaps: [1](#0-0) 

The function checks for 9 specific test native names, but examination of the framework reveals additional test-only natives that are **not validated**:

**1. Event Module Mismatch:**
The assertion checks for `event::emitted_events_internal`, but the actual registered test natives are:
- `emitted_events` 
- `emitted_events_by_handle` [2](#0-1) [3](#0-2) [4](#0-3) 

**2. Crypto Algebra Module:**
The `rand_insecure_internal` native is never validated: [5](#0-4) [6](#0-5) 

**3. Ristretto255 Module:**
The `random_scalar_internal` native is unvalidated: [7](#0-6) 

**4. Bulletproofs Module:**
Two proof generation functions lack validation: [8](#0-7) 

These test natives are compiled into the binary when `feature = "testing"` is enabled, and all natives are registered through the same `aptos_natives_with_builder` pipeline: [9](#0-8) 

## Impact Explanation
This qualifies as **HIGH severity** under Aptos bug bounty criteria due to potential for:

1. **Information Disclosure**: `emitted_events` and `emitted_events_by_handle` expose internal event state that could leak sensitive transaction data or be used to bypass access controls in smart contracts relying on event opacity.

2. **Cryptographic Weakness**: `rand_insecure_internal` and `random_scalar_internal` provide test-quality randomness that could compromise cryptographic operations if accidentally used in production contexts.

3. **Gas Metering Bypass**: `prove_range_internal` and `prove_batch_range_internal` create zero-knowledge proofs without proper gas charging, potentially enabling resource exhaustion attacks.

4. **Deterministic Execution Violation**: If test natives produce non-deterministic results or different behavior across nodes, this breaks the critical invariant that all validators must produce identical state roots for identical blocks.

The vulnerability requires the "testing" feature to be accidentally enabled in production, but such misconfigurations have occurred in blockchain systems historically (e.g., debug endpoints left enabled, test flags in production builds).

## Likelihood Explanation
**Likelihood: Medium-to-Low** with **High Impact** if exploited.

The attack requires:
1. Production build accidentally compiled with `--features testing` flag
2. Attacker discovering the enabled test natives through binary analysis or testing
3. Crafting transactions that call these natives

While accidental feature flag enabling is rare, the consequences are severe. This is analogous to a "defense-in-depth" failure - the assertion exists specifically to catch this error, but it's currently ineffective for 6 critical functions.

## Recommendation
Update `assert_no_test_natives()` to check for all test-only natives:

```rust
pub fn assert_no_test_natives(err_msg: &str) {
    assert!(
        aptos_natives(
            LATEST_GAS_FEATURE_VERSION,
            NativeGasParameters::zeros(),
            MiscGasParameters::zeros(),
            TimedFeaturesBuilder::enable_all().build(),
            Features::default()
        )
        .into_iter()
        .all(|(_, module_name, func_name, _)| {
            !(module_name.as_str() == "unit_test"
                && func_name.as_str() == "create_signers_for_testing"
                || module_name.as_str() == "ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "multi_ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "multi_ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "bls12381" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_proof_of_possession_internal"
                // Fix: Check correct event native names
                || module_name.as_str() == "event"
                    && func_name.as_str() == "emitted_events"
                || module_name.as_str() == "event"
                    && func_name.as_str() == "emitted_events_by_handle"
                // Add missing crypto_algebra natives
                || module_name.as_str() == "crypto_algebra"
                    && func_name.as_str() == "rand_insecure_internal"
                // Add missing ristretto255 natives
                || module_name.as_str() == "ristretto255"
                    && func_name.as_str() == "random_scalar_internal"
                // Add missing bulletproofs natives
                || module_name.as_str() == "ristretto255_bulletproofs"
                    && func_name.as_str() == "prove_range_internal"
                || module_name.as_str() == "ristretto255_bulletproofs"
                    && func_name.as_str() == "prove_batch_range_internal")
        }),
        "{}",
        err_msg
    )
}
```

Additionally, consider implementing a more maintainable approach using annotations or a registry pattern to automatically track all test-only natives rather than manual enumeration.

## Proof of Concept

To verify this vulnerability exists:

1. **Build with testing feature enabled:**
```bash
cd aptos-core
cargo build --release --features testing -p aptos-node
```

2. **Check native function table:**
```rust
#[test]
fn test_unvalidated_test_natives() {
    use aptos_vm::natives::aptos_natives;
    use aptos_gas_schedule::{LATEST_GAS_FEATURE_VERSION, NativeGasParameters, MiscGasParameters};
    use aptos_types::on_chain_config::{TimedFeaturesBuilder, Features};
    
    let natives = aptos_natives(
        LATEST_GAS_FEATURE_VERSION,
        NativeGasParameters::zeros(),
        MiscGasParameters::zeros(),
        TimedFeaturesBuilder::enable_all().build(),
        Features::default()
    );
    
    // These will be present when testing feature is enabled
    let has_emitted_events = natives.iter()
        .any(|(_, m, f, _)| m.as_str() == "event" && f.as_str() == "emitted_events");
    let has_rand_insecure = natives.iter()
        .any(|(_, m, f, _)| m.as_str() == "crypto_algebra" && f.as_str() == "rand_insecure_internal");
    
    assert!(has_emitted_events, "emitted_events is present but not validated");
    assert!(has_rand_insecure, "rand_insecure_internal is present but not validated");
}
```

3. **Verify assertion doesn't catch them:**
```rust
#[test]
#[should_panic]
fn test_assert_should_catch_test_natives() {
    // This will NOT panic even though test natives are present
    aptos_vm::natives::assert_no_test_natives(
        "Test natives should have been caught"
    );
}
```

The proof demonstrates that when compiled with the testing feature, these 6 unvalidated natives are present in the function table and would be callable from Move code, yet `assert_no_test_natives()` fails to detect them.

## Notes
This is a defense-in-depth vulnerability - the primary protection is not enabling the testing feature in production. However, the explicit assertion exists as a safety mechanism to catch configuration errors, and its incomplete implementation undermines this safety guarantee. The severity is elevated because the unchecked functions include those that could violate deterministic execution (randomness) and expose privileged information (events), both of which are critical to blockchain consensus and security.

### Citations

**File:** aptos-move/aptos-vm/src/natives.rs (L161-191)
```rust
pub fn assert_no_test_natives(err_msg: &str) {
    assert!(
        aptos_natives(
            LATEST_GAS_FEATURE_VERSION,
            NativeGasParameters::zeros(),
            MiscGasParameters::zeros(),
            TimedFeaturesBuilder::enable_all().build(),
            Features::default()
        )
        .into_iter()
        .all(|(_, module_name, func_name, _)| {
            !(module_name.as_str() == "unit_test"
                && func_name.as_str() == "create_signers_for_testing"
                || module_name.as_str() == "ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "multi_ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "multi_ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "bls12381" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_proof_of_possession_internal"
                || module_name.as_str() == "event"
                    && func_name.as_str() == "emitted_events_internal")
        }),
        "{}",
        err_msg
    )
}
```

**File:** aptos-move/framework/src/natives/event.rs (L334-342)
```rust
    #[cfg(feature = "testing")]
    natives.extend([(
        "emitted_events_by_handle",
        native_emitted_events_by_handle as RawSafeNative,
    )]);

    #[cfg(feature = "testing")]
    natives.extend([("emitted_events", native_emitted_events as RawSafeNative)]);

```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L25-25)
```text
    public native fun emitted_events<T: drop + store>(): vector<T>;
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L86-86)
```text
    public native fun emitted_events_by_handle<T: drop + store>(handle: &EventHandle<T>): vector<T>;
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/mod.rs (L375-379)
```rust
    #[cfg(feature = "testing")]
    natives.extend([(
        "rand_insecure_internal",
        rand_insecure_internal as RawSafeNative,
    )]);
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/crypto_algebra.move (L320-321)
```text
    #[test_only]
    native fun rand_insecure_internal<S>(): u64;
```

**File:** aptos-move/framework/src/natives/cryptography/ristretto255.rs (L41-45)
```rust
    #[cfg(feature = "testing")]
    natives.extend([(
        "random_scalar_internal",
        ristretto255_scalar::native_scalar_random as RawSafeNative,
    )]);
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L433-443)
```rust
    #[cfg(feature = "testing")]
    natives.extend([
        (
            "prove_range_internal",
            native_test_only_prove_range as RawSafeNative,
        ),
        (
            "prove_batch_range_internal",
            native_test_only_batch_prove_range,
        ),
    ]);
```

**File:** aptos-move/aptos-vm-environment/src/natives.rs (L10-45)
```rust
pub fn aptos_natives_with_builder(
    builder: &mut SafeNativeBuilder,
    inject_create_signer_for_gov_sim: bool,
) -> NativeFunctionTable {
    let vector_bytecode_instruction_methods = HashSet::from([
        "empty",
        "length",
        "borrow",
        "borrow_mut",
        "push_back",
        "pop_back",
        "destroy_empty",
        "swap",
    ]);

    #[allow(unreachable_code)]
    aptos_move_stdlib::natives::all_natives(CORE_CODE_ADDRESS, builder)
        .into_iter()
        .filter(|(_, name, func_name, _)|
            if name.as_str() == "vector" && vector_bytecode_instruction_methods.contains(func_name.as_str()) {
                println!("ERROR: Tried to register as native a vector bytecode_instruction method {}, skipping.", func_name.as_str());
                false
            } else {
                true
            }
        )
        .chain(aptos_framework::natives::all_natives(
            CORE_CODE_ADDRESS,
            builder,
            inject_create_signer_for_gov_sim,
        ))
        .chain(aptos_table_natives::table_natives(
            CORE_CODE_ADDRESS,
            builder,
        ))
        .collect()
```
