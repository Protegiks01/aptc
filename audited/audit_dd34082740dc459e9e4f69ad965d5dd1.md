# Audit Report

## Title
Platform-Dependent Abort Codes in `vector::move_range` Could Break Consensus Under Mixed Architecture Deployments

## Summary
The `native_move_range()` function in `aptos-move/framework/move-stdlib/src/natives/vector.rs` performs `usize` conversions from `u64` parameters that behave differently on 32-bit versus 64-bit systems. When conversion fails (u64 > u32::MAX on 32-bit), it aborts with error code `0x10001`, while successful conversion followed by bounds checking aborts with code `0x1`. This produces different `ExecutionStatus::MoveAbort` values that would break the deterministic execution invariant if validators ran on mixed architectures.

## Finding Description

The vulnerability exists in the usize conversions at lines 49, 51, and 52: [1](#0-0) 

The `map_err` closure returns an abort code computed by `error::invalid_argument(EINDEX_OUT_OF_BOUNDS)`: [2](#0-1) [3](#0-2) [4](#0-3) 

This produces abort code `(0x1 << 16) + 1 = 0x10001 = 65537`.

However, if the conversion succeeds (64-bit system), the bounds check at lines 61-68 aborts with just `EINDEX_OUT_OF_BOUNDS` (value `1`): [5](#0-4) 

When Move transactions abort, the abort code becomes part of the `ExecutionStatus`: [6](#0-5) [7](#0-6) 

Different abort codes produce different transaction outputs, violating the **Deterministic Execution** invariant.

## Impact Explanation

**Theoretical Critical Severity**: If validators ran on mixed architectures (32-bit and 64-bit), this would cause:
- **Consensus failure**: Validators would compute different state roots for the same block
- **Network partition**: Different validator subsets would form incompatible chains
- **Requires hardfork**: No automatic recovery mechanism exists

This meets the "Non-recoverable network partition (requires hardfork)" criterion for Critical severity ($1,000,000).

**However, practical impact is NONE** because:
1. Hardware requirements (8 cores, 31 GB RAM) implicitly require 64-bit systems
2. 32-bit systems cannot address 31 GB RAM without PAE extensions
3. No production validator deployment uses 32-bit architectures
4. Modern cloud infrastructure is exclusively 64-bit

## Likelihood Explanation

**Likelihood: Extremely Low (Effectively Zero)**

For this vulnerability to manifest:
1. At least one validator must run on a 32-bit system
2. A transaction must call `vector::move_range` with position/length > u32::MAX (4,294,967,295)
3. Both conditions must occur simultaneously

**Barriers preventing exploitation:**
- Hardware checker validates 31 GB RAM requirement, impossible on 32-bit without unrealistic configuration
- No compile-time check prevents 32-bit builds, but deployment constraints do
- Modern Rust toolchains default to 64-bit targets
- Cloud providers (AWS, GCP, Azure) only offer 64-bit instances for validator-grade hardware

**Attack feasibility:**
An unprivileged attacker can submit the malicious transaction (step 2), but cannot force validators to run on 32-bit architecture (step 1). This requires validator operator control, violating the "no validator insider access required" criterion.

## Recommendation

Add a compile-time assertion to make the 64-bit requirement explicit:

```rust
// At the top of aptos-node/src/lib.rs or a core crate
#[cfg(not(target_pointer_width = "64"))]
compile_error!("Aptos validators require 64-bit architecture for deterministic execution");
```

Alternative fix: Ensure consistent error handling by using the same abort code path:

```rust
let insert_position = usize::try_from(safely_pop_arg!(args, u64))
    .map_err(|_| SafeNativeError::Abort { abort_code: EINDEX_OUT_OF_BOUNDS })?;
```

However, the recommended approach is the compile-time check, as it makes platform requirements explicit.

## Proof of Concept

```move
// File: test_vector_architecture.move
script {
    use std::vector;
    
    fun main() {
        let from = vector::empty<u64>();
        let to = vector::empty<u64>();
        
        // Push some elements
        vector::push_back(&mut from, 1);
        
        // Call move_range with position > u32::MAX
        // On 32-bit: aborts with code 65537 during conversion
        // On 64-bit: aborts with code 1 during bounds check
        vector::move_range(
            &mut from,
            5_000_000_000,  // > u32::MAX = 4,294,967,295
            1,
            &mut to,
            0
        );
    }
}
```

**Note**: This PoC demonstrates the different abort codes but cannot demonstrate actual consensus failure without deploying 32-bit validators, which is not feasible in production environments.

---

## Notes

**Critical Validation Failure**: While this represents a genuine code defect violating the principle of explicit platform requirements, it **does not meet the bug bounty criteria** for the following reasons:

1. **Not exploitable by unprivileged attackers**: Requires validator operator control to deploy 32-bit nodes
2. **Unrealistic attack path**: Hardware requirements prevent 32-bit deployment in practice  
3. **No production impact**: Zero validators run on 32-bit architecture
4. **Precondition control**: Attacker cannot force the required conditions

The issue is a **code quality/robustness concern** rather than a practically exploitable vulnerability. The proper classification is "defense in depth" - adding explicit compile-time checks to prevent theoretical issues.

Given the strict validation criteria requiring realistic exploitability without validator insider access, this finding does not qualify for bug bounty submission despite the technical correctness of the determinism violation analysis.

### Citations

**File:** aptos-move/framework/move-stdlib/src/natives/vector.rs (L28-28)
```rust
pub const EINDEX_OUT_OF_BOUNDS: u64 = 1;
```

**File:** aptos-move/framework/move-stdlib/src/natives/vector.rs (L46-53)
```rust
    let map_err = |_| SafeNativeError::Abort {
        abort_code: error::invalid_argument(EINDEX_OUT_OF_BOUNDS),
    };
    let insert_position = usize::try_from(safely_pop_arg!(args, u64)).map_err(map_err)?;
    let to = safely_pop_arg!(args, VectorRef);
    let length = usize::try_from(safely_pop_arg!(args, u64)).map_err(map_err)?;
    let removal_position = usize::try_from(safely_pop_arg!(args, u64)).map_err(map_err)?;
    let from = safely_pop_arg!(args, VectorRef);
```

**File:** aptos-move/framework/move-stdlib/src/natives/vector.rs (L61-69)
```rust
    if removal_position
        .checked_add(length)
        .is_none_or(|end| end > from_len)
        || insert_position > to_len
    {
        return Err(SafeNativeError::Abort {
            abort_code: EINDEX_OUT_OF_BOUNDS,
        });
    }
```

**File:** types/src/error.rs (L116-116)
```rust
pub const INVALID_ARGUMENT: u64 = 0x1;
```

**File:** types/src/error.rs (L160-162)
```rust
pub fn invalid_argument(r: u64) -> u64 {
    canonical(INVALID_ARGUMENT, r)
}
```

**File:** types/src/transaction/mod.rs (L1492-1496)
```rust
    MoveAbort {
        location: AbortLocation,
        code: u64,
        info: Option<AbortInfo>,
    },
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1150-1153)
```rust
            NativeResult::Abort { cost, abort_code } => {
                gas_meter.charge_native_function(cost, Option::<std::iter::Empty<&Value>>::None)?;
                Err(PartialVMError::new(StatusCode::ABORTED).with_sub_status(abort_code))
            },
```
