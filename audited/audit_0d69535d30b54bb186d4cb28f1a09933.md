# Audit Report

## Title
Validator Network-Wide Panic via Deprecated TransactionShufflerType in OnChainExecutionConfig

## Summary
Successfully deserialized `OnChainExecutionConfig` containing deprecated `TransactionShufflerType` variants (`SenderAwareV2` or `DeprecatedFairness`) causes all validator nodes to panic during epoch initialization, resulting in total network liveness failure requiring a hard fork to recover.

## Finding Description

The vulnerability exists in the interaction between config deserialization and runtime usage. While `fetch_config_and_update_hash()` successfully deserializes bytes into valid enum variants without panicking, the deserialized configs contain deprecated variants that trigger `unreachable!()` panics when used. [1](#0-0) 

The deserialization succeeds because `TransactionShufflerType` enum includes all variants: [2](#0-1) 

However, when validators attempt to use this config during epoch start, `create_transaction_shuffler()` is called: [3](#0-2) 

This function contains `unreachable!()` macros for deprecated variants: [4](#0-3) 

The Move contract provides no validation beyond checking non-empty bytes: [5](#0-4) 

**Attack Path:**
1. Attacker injects bytes into StateView (via storage corruption, state sync manipulation, or malicious governance proposal) representing `OnChainExecutionConfig::V7` with `transaction_shuffler_type: TransactionShufflerType::SenderAwareV2(0)`
2. Bytes successfully deserialize via two-round BCS deserialization without error
3. Config is stored and propagated to all validators
4. At next epoch boundary, all validators call `create_transaction_shuffler()`
5. Pattern match hits `SenderAwareV2(_)` case at line 78-79
6. `unreachable!()` macro executes, causing panic
7. All validators crash simultaneously
8. Network experiences total liveness failure

**Broken Invariants:**
- **Deterministic Execution**: Violated through network-wide crash rather than divergence
- **Network Availability**: Total loss of liveness

## Impact Explanation

This qualifies as **Critical Severity** per Aptos bug bounty criteria:
- **Total loss of liveness/network availability**: All validators crash when attempting to start the next epoch
- **Non-recoverable network partition (requires hardfork)**: Once the malicious config is committed, validators cannot progress without code changes to handle the deprecated variant or manual state intervention

The impact is network-wide and immediate upon the next epoch transition.

## Likelihood Explanation

**Medium-High Likelihood:**
- **Governance Attack**: Any account with sufficient stake to submit proposals can craft malicious ExecutionConfig bytes
- **Storage Corruption**: Bugs in state sync, database corruption, or Merkle tree manipulation could inject malformed configs
- **State Sync Manipulation**: Malicious peers could potentially provide corrupted state during fast sync

The vulnerability is deterministic once triggered - there are no race conditions or probabilistic elements. The only barrier is injecting the bytes into StateView through one of the above vectors.

## Recommendation

Implement strict validation in the Move contract and add defensive error handling in Rust:

**Move Contract Fix:**
```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // Add validation to ensure config deserializes to supported variants
    validate_execution_config(&config);
    
    config_buffer::upsert(ExecutionConfig { config });
}

fun validate_execution_config(config_bytes: &vector<u8>) {
    // Deserialize and verify no deprecated variants present
    // Reject SenderAwareV2, DeprecatedFairness, etc.
}
```

**Rust Defensive Fix:**
```rust
pub fn create_transaction_shuffler(
    shuffler_type: TransactionShufflerType,
) -> Arc<dyn TransactionShuffler> {
    use TransactionShufflerType::*;

    match shuffler_type {
        NoShuffling => {
            info!("Using no-op transaction shuffling");
            Arc::new(NoOpShuffler {})
        },
        DeprecatedSenderAwareV1(_) | SenderAwareV2(_) | DeprecatedFairness => {
            // Instead of unreachable!(), gracefully degrade
            error!("Deprecated shuffler type detected, falling back to NoOp");
            Arc::new(NoOpShuffler {})
        },
        UseCaseAware { ... } => { ... }
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::on_chain_config::{
        OnChainExecutionConfig, ExecutionConfigV7, TransactionShufflerType,
        BlockGasLimitType, TransactionDeduperType,
    };
    
    #[test]
    #[should_panic(expected = "unreachable")]
    fn test_deprecated_shuffler_causes_panic() {
        // Create config with deprecated SenderAwareV2
        let malicious_config = OnChainExecutionConfig::V7(ExecutionConfigV7 {
            transaction_shuffler_type: TransactionShufflerType::SenderAwareV2(32),
            block_gas_limit_type: BlockGasLimitType::NoLimit,
            enable_per_block_gas_limit: false,
            transaction_deduper_type: TransactionDeduperType::NoDedup,
            gas_price_to_burn: 0,
            persisted_auxiliary_info_version: 0,
        });
        
        // Serialize to bytes (simulating malicious bytes in StateView)
        let inner_bytes = bcs::to_bytes(&malicious_config).unwrap();
        let outer_bytes = bcs::to_bytes(&inner_bytes).unwrap();
        
        // Deserialize succeeds
        let deserialized = OnChainExecutionConfig::deserialize_into_config(&outer_bytes).unwrap();
        
        // But using the config causes panic
        let _shuffler = create_transaction_shuffler(deserialized.transaction_shuffler_type());
        // Panic occurs here ^
    }
}
```

**Notes:**

The vulnerability is fundamentally about the gap between BCS deserialization success and runtime safety. While BCS correctly deserializes valid enum variants, the codebase contains `unreachable!()` assertions assuming certain variants will never appear in production. This assumption can be violated through StateView manipulation, governance attacks, or storage corruption, leading to network-wide validator crashes during epoch transitions.

### Citations

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L328-336)
```rust
/// Fetches config from storage and updates the hash if it exists. Returns the fetched config.
fn fetch_config_and_update_hash<T: OnChainConfig>(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> Option<T> {
    let (config, bytes) = T::fetch_config_and_bytes(state_view)?;
    sha3_256.update(&bytes);
    Some(config)
}
```

**File:** types/src/on_chain_config/execution_config.rs (L228-240)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "snake_case")] // cannot use tag = "type" as nested enums cannot work, and bcs doesn't support it
pub enum TransactionShufflerType {
    NoShuffling,
    DeprecatedSenderAwareV1(u32),
    SenderAwareV2(u32),
    DeprecatedFairness,
    UseCaseAware {
        sender_spread_factor: usize,
        platform_use_case_spread_factor: usize,
        user_use_case_spread_factor: usize,
    },
}
```

**File:** consensus/src/pipeline/execution_client.rs (L560-561)
```rust
        let transaction_shuffler =
            create_transaction_shuffler(onchain_execution_config.transaction_shuffler_type());
```

**File:** consensus/src/transaction_shuffler/mod.rs (L64-101)
```rust
pub fn create_transaction_shuffler(
    shuffler_type: TransactionShufflerType,
) -> Arc<dyn TransactionShuffler> {
    use TransactionShufflerType::*;

    match shuffler_type {
        NoShuffling => {
            info!("Using no-op transaction shuffling");
            Arc::new(NoOpShuffler {})
        },
        DeprecatedSenderAwareV1(_) => {
            info!("Using no-op sender aware shuffling v1");
            Arc::new(NoOpShuffler {})
        },
        SenderAwareV2(_) => {
            unreachable!("SenderAware shuffler is no longer supported.")
        },
        DeprecatedFairness => {
            unreachable!("DeprecatedFairness shuffler is no longer supported.")
        },
        UseCaseAware {
            sender_spread_factor,
            platform_use_case_spread_factor,
            user_use_case_spread_factor,
        } => {
            let config = use_case_aware::Config {
                sender_spread_factor,
                platform_use_case_spread_factor,
                user_use_case_spread_factor,
            };
            info!(
                config = ?config,
                "Using use case aware transaction shuffling."
            );
            Arc::new(use_case_aware::UseCaseAwareShuffler { config })
        },
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/execution_config.move (L48-52)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        config_buffer::upsert(ExecutionConfig { config });
    }
```
