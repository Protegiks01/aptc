# Audit Report

## Title
Cross-Chain Replay Attack in Keyless ZKP Authentication: Missing Chain ID Binding Enables Testnet-to-Mainnet Proof Reuse

## Summary
The Zero-Knowledge Proof (ZKP) verification system for keyless accounts does not bind the proof to a specific chain ID. This allows an attacker to generate a valid ZKP proof on testnet and replay it on mainnet with the same ephemeral key, enabling unauthorized cross-chain authentication and potential fund theft.

## Finding Description

The keyless authentication system uses Groth16 zero-knowledge proofs to verify that a user possesses a valid OIDC (OpenID Connect) token authorizing a specific ephemeral public key. The ZKP's public inputs are hashed to create a `public_inputs_hash` which is verified against the proof.

**Critical Flaw**: The `hash_public_inputs` function computes this hash over 11 different fields, but **chain ID is not included**: [1](#0-0) 

The function includes: ephemeral public key, identity commitment, expiration timestamp, expiration horizon, issuer hash, extra field hash, JWT header hash, JWK hash, and override aud hash - but no chain identifier.

The `Configuration` struct, which would be the natural place for chain-specific parameters, also lacks a chain ID field: [2](#0-1) 

During transaction verification, the ZKP is validated using this chain-agnostic public inputs hash: [3](#0-2) 

**Attack Scenario**:

1. **Testnet Setup**: Attacker creates ephemeral key pair (EPK, ESK) and obtains OIDC JWT with nonce containing commitment to EPK on testnet
2. **Generate ZKP**: Attacker generates ZKP_testnet proving knowledge of valid OIDC signature for EPK on testnet
3. **Mainnet Exploitation**: Attacker creates a mainnet transaction (TXN_mainnet with mainnet chain ID)
4. **Sign Transaction**: Attacker signs `TransactionAndProof{TXN_mainnet, ZKP_testnet}` with ESK, creating ephemeral_sig_mainnet
5. **Submit Attack**: Attacker submits to mainnet with `KeylessSignature{cert: ZKP_testnet, ephemeral_signature: ephemeral_sig_mainnet}`

**Why Verification Passes**:

The ephemeral signature verification checks that the transaction was signed by the ephemeral key: [4](#0-3) 

This passes because the attacker signed with the correct ESK. The ZKP verification then computes `public_inputs_hash` and verifies it against the proof - this also passes because the hash computation is identical on both chains (no chain ID binding). The transaction's chain ID is checked by the prologue, but this only validates the transaction itself, not the ZKP proof's origin.

**Broken Invariant**: The system violates the **Cryptographic Correctness** invariant - zero-knowledge proofs must bind to all relevant authentication context, including the target chain. This also breaks **Transaction Validation** guarantees that all authentication credentials are chain-specific.

## Impact Explanation

**Severity: CRITICAL (up to $1,000,000)**

This vulnerability enables:

1. **Cross-Chain Authentication Bypass**: Valid testnet credentials authorize mainnet transactions
2. **Potential Fund Theft**: If an attacker can obtain or generate ephemeral keys on testnet (possibly through phishing or social engineering with "testnet-only" credentials), they can use the same proof to authorize real mainnet transactions
3. **Security Model Violation**: Users and applications reasonably assume testnet proofs cannot affect mainnet, breaking fundamental blockchain separation
4. **Account Takeover Risk**: Compromised testnet ephemeral keys become mainnet attack vectors

This meets the **Critical Severity** criteria for:
- Potential loss of funds through unauthorized transaction authorization
- Significant protocol violation enabling cross-chain replay attacks
- Breaking fundamental security assumptions of the keyless authentication system

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible because:

1. **No Special Privileges Required**: Any user can create keyless accounts and generate ZKPs on testnet
2. **Testnet Access is Free**: Attackers can freely experiment on testnet without cost
3. **Same Identity on Both Chains**: Keyless account addresses are derived from identity parameters without chain binding, so the same account exists on both networks
4. **Reusable Components**: The ephemeral key can be reused, and only the transaction needs to be re-signed
5. **No Detection Mechanism**: The system has no way to detect that a ZKP originated from a different chain

Attack scenarios include:
- Users sharing "testnet-only" ephemeral keys that become mainnet vulnerabilities
- Phishing attacks offering testnet testing that capture credentials usable on mainnet
- Compromised testnet development environments exposing mainnet risk
- Malicious users intentionally exploiting the cross-chain replay for unauthorized access

## Recommendation

**Solution**: Include chain ID in the ZKP's public inputs hash.

1. **Add chain_id to Configuration struct**:
```rust
// types/src/keyless/configuration.rs
pub struct Configuration {
    pub chain_id: u8,  // Add this field
    pub override_aud_vals: Vec<String>,
    pub max_signatures_per_txn: u16,
    // ... rest of fields
}
```

2. **Update hash_public_inputs function signature and computation**:
```rust
// types/src/keyless/bn254_circom.rs
pub fn hash_public_inputs(
    config: &Configuration,
    epk: &EphemeralPublicKey,
    idc: &IdCommitment,
    exp_timestamp_secs: u64,
    exp_horizon_secs: u64,
    iss: &str,
    extra_field: Option<&str>,
    jwt_header_json: &str,
    jwk: &RSA_JWK,
    override_aud_val: Option<&str>,
) -> anyhow::Result<Fr> {
    // ... existing field computation ...
    
    let chain_id_fr = Fr::from(config.chain_id);
    
    let mut frs = vec![];
    frs.append(&mut epk_frs);
    frs.push(idc);
    frs.push(exp_timestamp_secs);
    frs.push(exp_horizon_secs);
    frs.push(chain_id_fr);  // Add chain ID here
    frs.push(iss_field_hash);
    // ... rest of fields ...
    
    poseidon_bn254::hash_scalars(frs)
}
```

3. **Update ZK Circuit**: The underlying Groth16 circuit must be updated to include chain_id as a public input and verify it during proof generation. This requires circuit recompilation and new proving/verifying keys.

4. **Deploy with Migration**: 
   - Deploy updated circuit and verification keys on-chain
   - Ensure all ZKP-generating services (prover service) are updated to include chain_id
   - Consider backwards compatibility period or coordinated upgrade

## Proof of Concept

**Conceptual PoC** (requires full keyless infrastructure):

```rust
// This demonstrates the attack flow conceptually
// Actual execution requires OIDC provider integration and ZK prover service

async fn poc_cross_chain_replay_attack() {
    // Step 1: Generate ephemeral key on testnet
    let (testnet_epk, testnet_esk) = generate_ephemeral_keypair();
    
    // Step 2: Get OIDC JWT with EPK commitment on testnet
    let jwt = get_oidc_jwt_with_epk_nonce(testnet_epk, "testnet-user@example.com");
    
    // Step 3: Generate ZKP on testnet
    let zkp_testnet = generate_groth16_proof(
        jwt,
        testnet_epk,
        /* testnet config without chain_id */
    );
    
    // Step 4: Create mainnet transaction
    let mainnet_txn = create_transaction(
        sender: derive_keyless_address("testnet-user@example.com"),
        chain_id: ChainId::mainnet(), // Mainnet chain ID
        payload: transfer_coins(victim_address, 1000000),
    );
    
    // Step 5: Sign mainnet transaction with testnet ephemeral key
    let txn_and_proof = TransactionAndProof {
        message: mainnet_txn.clone(),
        proof: Some(zkp_testnet), // Using testnet ZKP!
    };
    let ephemeral_sig = testnet_esk.sign(&txn_and_proof);
    
    // Step 6: Create keyless signature
    let keyless_sig = KeylessSignature {
        cert: EphemeralCertificate::ZeroKnowledgeSig(ZeroKnowledgeSig {
            proof: ZKP::Groth16(zkp_testnet),
            exp_horizon_secs: 3600,
            extra_field: None,
            override_aud_val: None,
            training_wheels_signature: None,
        }),
        ephemeral_pubkey: testnet_epk,
        ephemeral_signature: ephemeral_sig,
        jwt_header_json: /* ... */,
        exp_date_secs: /* ... */,
    };
    
    // Step 7: Submit to mainnet - WILL SUCCEED despite ZKP from testnet
    let signed_txn = SignedTransaction::new(
        mainnet_txn,
        TransactionAuthenticator::single_sender(
            AccountAuthenticator::single_key(
                AnyPublicKey::Keyless { 
                    public_key: derive_keyless_pk("testnet-user@example.com")
                },
                AnySignature::Keyless { signature: keyless_sig },
            )
        ),
    );
    
    submit_transaction_to_mainnet(signed_txn).await;
    // Transaction succeeds! Testnet proof authorized mainnet transaction.
}
```

**Verification Steps**:
1. The ephemeral signature verification passes (line 1346 in authenticator.rs) because ESK correctly signed the transaction
2. The public_inputs_hash computation is identical on testnet and mainnet since it doesn't include chain_id
3. The ZKP verification passes (line 347 in keyless_validation.rs) because the proof validates against the chain-agnostic hash
4. The prologue checks pass because the transaction itself has the correct mainnet chain_id

The attack succeeds because no component validates that the ZKP proof originated from the same chain as the transaction being authorized.

---

**Notes**:
This vulnerability represents a fundamental design flaw in the keyless authentication public inputs specification. The fix requires coordinated updates to the ZK circuit, on-chain verification logic, and all proof-generating services. Until deployed, testnet and mainnet keyless proofs are mutually interchangeable, violating chain isolation guarantees.

### Citations

**File:** types/src/keyless/bn254_circom.rs (L279-369)
```rust
pub fn hash_public_inputs(
    config: &Configuration,
    epk: &EphemeralPublicKey,
    idc: &IdCommitment,
    exp_timestamp_secs: u64,
    exp_horizon_secs: u64,
    iss: &str,
    extra_field: Option<&str>,
    jwt_header_json: &str,
    jwk: &RSA_JWK,
    override_aud_val: Option<&str>,
) -> anyhow::Result<Fr> {
    let (has_extra_field, extra_field_hash) = match extra_field {
        None => (Fr::zero(), *EMPTY_EXTRA_FIELD_HASH),
        Some(extra_field) => (
            Fr::one(),
            poseidon_bn254::keyless::pad_and_hash_string(
                extra_field,
                config.max_extra_field_bytes as usize,
            )?,
        ),
    };

    let (override_aud_val_hash, use_override_aud) = match override_aud_val {
        Some(override_aud_val) => (
            cached_pad_and_hash_string(override_aud_val, IdCommitment::MAX_AUD_VAL_BYTES)?,
            ark_bn254::Fr::from(1),
        ),
        None => (*EMPTY_OVERRIDE_AUD_FIELD_HASH, ark_bn254::Fr::from(0)),
    };

    // Add the hash of the jwt_header with the "." separator appended
    let jwt_header_b64_with_separator = format!("{}.", base64url_encode_str(jwt_header_json));
    let jwt_header_hash = cached_pad_and_hash_string(
        &jwt_header_b64_with_separator,
        config.max_jwt_header_b64_bytes as usize,
    )?;

    let jwk_hash = cached_jwk_hash(jwk)?;

    // Add the hash of the value of the `iss` field
    let iss_field_hash = cached_pad_and_hash_string(iss, config.max_iss_val_bytes as usize)?;

    // Add the id_commitment as a scalar
    let idc = Fr::from_le_bytes_mod_order(&idc.0);

    // Add the exp_timestamp_secs as a scalar
    let exp_timestamp_secs = Fr::from(exp_timestamp_secs);

    // Add the epk lifespan as a scalar
    let exp_horizon_secs = Fr::from(exp_horizon_secs);

    let mut epk_frs = poseidon_bn254::keyless::pad_and_pack_bytes_to_scalars_with_len(
        epk.to_bytes().as_slice(),
        config.max_commited_epk_bytes as usize,
    )?;

    // println!("Num EPK scalars:    {}", epk_frs.len());
    // for (i, e) in epk_frs.iter().enumerate() {
    //     println!("EPK Fr[{}]:          {}", i, e.to_string())
    // }
    // println!("IDC:                {}", idc);
    // println!("exp_timestamp_secs: {}", exp_timestamp_secs);
    // println!("exp_horizon_secs:   {}", exp_horizon_secs);
    // println!("iss field:          {}", pk.iss_val);
    // println!("iss field hash:     {}", iss_field_hash);
    // println!("Has extra field:    {}", has_extra_field);
    // println!("Extra field val:    {:?}", proof.extra_field);
    // println!("Extra field hash:   {}", extra_field_hash);
    // println!("JWT header val:     {}", jwt_header_b64_with_separator);
    // println!("JWT header hash:    {}", jwt_header_hash);
    // println!("JWK hash:           {}", jwk_hash);
    // println!("Override aud hash:  {}", override_aud_val_hash);
    // println!("Use override aud:   {}", use_override_aud.to_string());

    let mut frs = vec![];
    frs.append(&mut epk_frs);
    frs.push(idc);
    frs.push(exp_timestamp_secs);
    frs.push(exp_horizon_secs);
    frs.push(iss_field_hash);
    frs.push(has_extra_field);
    frs.push(extra_field_hash);
    frs.push(jwt_header_hash);
    frs.push(jwk_hash);
    frs.push(override_aud_val_hash);
    frs.push(use_override_aud);
    // TODO(keyless): If we plan on avoiding verifying the same PIH twice, there should be no
    //  need for caching here. If we do not, we should cache the result here too.
    poseidon_bn254::hash_scalars(frs)
}
```

**File:** types/src/keyless/configuration.rs (L22-32)
```rust
#[derive(Serialize, Deserialize, Eq, PartialEq, Debug)]
pub struct Configuration {
    pub override_aud_vals: Vec<String>,
    pub max_signatures_per_txn: u16,
    pub max_exp_horizon_secs: u64,
    pub training_wheels_pubkey: Option<Vec<u8>>,
    pub max_commited_epk_bytes: u16,
    pub max_iss_val_bytes: u16,
    pub max_extra_field_bytes: u16,
    pub max_jwt_header_b64_bytes: u32,
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L307-347)
```rust
                        let public_inputs_hash = get_public_inputs_hash(
                            signature,
                            public_key.inner_keyless_pk(),
                            rsa_jwk,
                            config,
                        )
                        .map_err(|_| {
                            // println!("[aptos-vm][groth16] PIH computation failed");
                            invalid_signature!("Could not compute public inputs hash")
                        })?;
                        // println!("Public inputs hash time: {:?}", start.elapsed());

                        let groth16_and_stmt =
                            Groth16ProofAndStatement::new(*groth16proof, public_inputs_hash);

                        // The training wheels signature is only checked if a training wheels PK is set on chain
                        if training_wheels_pk.is_some() {
                            match &zksig.training_wheels_signature {
                                Some(training_wheels_sig) => {
                                    training_wheels_sig
                                        .verify(
                                            &groth16_and_stmt,
                                            training_wheels_pk.as_ref().unwrap(),
                                        )
                                        .map_err(|_| {
                                            // println!("[aptos-vm][groth16] TW sig verification failed");
                                            invalid_signature!(
                                                "Could not verify training wheels signature"
                                            )
                                        })?;
                                },
                                None => {
                                    // println!("[aptos-vm][groth16] Expected TW sig to be set");
                                    return Err(invalid_signature!(
                                        "Training wheels signature expected but it is missing"
                                    ));
                                },
                            }
                        }

                        let result = zksig.verify_groth16_proof(public_inputs_hash, pvk.unwrap());
```

**File:** types/src/transaction/authenticator.rs (L1319-1347)
```rust
    fn verify_keyless_ephemeral_signature<T: Serialize + CryptoHash>(
        message: &T,
        signature: &KeylessSignature,
    ) -> Result<()> {
        // Verifies the ephemeral signature on (TXN [+ ZKP]). The rest of the verification,
        // i.e., [ZKPoK of] OpenID signature verification is done in
        // `AptosVM::run_prologue`.
        //
        // This is because the JWK, under which the [ZKPoK of an] OpenID signature verifies,
        // can only be fetched from on chain inside the `AptosVM`.
        //
        // This deferred verification is what actually ensures the `signature.ephemeral_pubkey`
        // used below is the right pubkey signed by the OIDC provider.

        let mut txn_and_zkp = TransactionAndProof {
            message,
            proof: None,
        };

        // Add the ZK proof into the `txn_and_zkp` struct, if we are in the ZK path
        match &signature.cert {
            EphemeralCertificate::ZeroKnowledgeSig(proof) => txn_and_zkp.proof = Some(proof.proof),
            EphemeralCertificate::OpenIdSig(_) => {},
        }

        signature
            .ephemeral_signature
            .verify(&txn_and_zkp, &signature.ephemeral_pubkey)
    }
```
