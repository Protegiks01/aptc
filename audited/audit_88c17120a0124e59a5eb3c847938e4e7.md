# Audit Report

## Title
Move Prover Silently Filters Test-Only Spec Blocks Leading to False Proofs of Correctness

## Summary
The Move compiler v2's model builder for the Move Prover filters out spec blocks marked with `#[test_only]` without warning, potentially causing critical security invariants to be excluded from formal verification and resulting in false proofs of correctness.

## Finding Description

The Move Prover verification pipeline has a filtering asymmetry that causes `#[test_only]` spec blocks to be silently removed during verification builds. This occurs through the following chain:

1. **Model Builder Configuration**: When building the Move model for the prover, only `compile_verify_code` is set to true, while `compile_test_code` defaults to false. [1](#0-0) 

2. **Flag Propagation**: This configuration is passed to the model builder, which sets `keep_testing_functions` to false when `compile_test_code` is false. [2](#0-1) 

3. **Spec Block Filtering**: The legacy parser's test filter removes spec blocks marked `#[test_only]` when `keep_testing_functions()` is false. [3](#0-2) 

4. **Spec Block Attribute Support**: Spec blocks support attributes including test-only markers. [4](#0-3) 

**Exploitation Scenario:**
A developer writing security-critical Move modules might:
- Misunderstand that `#[test_only]` means "only verified during test runs"
- Apply `#[test_only]` to spec blocks containing critical invariants
- Run the Move Prover, which silently filters these specs
- Receive a "proof of correctness" that missed verifying these invariants
- Deploy vulnerable code that passed verification with incomplete spec coverage

The filtering logic provides no warnings, error messages, or indication that specs were excluded from verification.

## Impact Explanation

**Severity: Medium**

This is a tooling vulnerability that can lead to false confidence in verified code, potentially enabling:

- **State Consistency Violations**: If module-level invariants about state transitions are in filtered specs, consensus-critical state corruption could go undetected
- **Access Control Bypasses**: Security specs protecting system resources (e.g., `@aptos_framework` addresses) could be silently excluded
- **Governance Integrity Issues**: Voting power calculation invariants in filtered specs could allow governance manipulation
- **Staking Security Bugs**: Reward/penalty calculation specs could be missed, enabling validator reward manipulation

While this doesn't directly cause fund loss or consensus failures, it undermines the formal verification process that protects against these critical issues. The impact is indirect but significant: vulnerable code can pass verification and reach production.

## Likelihood Explanation

**Likelihood: Low-Medium**

This requires:
- Developer confusion about `#[test_only]` vs `#[verify_only]` semantics
- Application of `#[test_only]` to security-critical spec blocks
- No manual review catching the missing specs

The likelihood is elevated by:
- Lack of warnings or errors when specs are filtered
- No prover output indicating which specs were verified
- Potentially confusing attribute naming (`test_only` might seem appropriate for "test my invariants")

## Recommendation

**Immediate Fix:**
Set `compile_test_code = true` when building models for the prover to include test-only specs:

```rust
// In model_builder.rs, line 133
options.compile_verify_code = true;
options.compile_test_code = true;  // ADD THIS
```

**Better Long-term Solution:**
1. Add compiler warnings when spec blocks have `#[test_only]` attributes
2. Document that `#[verify_only]` should be used for verification-specific specs, not `#[test_only]`
3. Have the prover report which spec blocks were included in verification
4. Consider treating `#[test_only]` on spec blocks as an error during verification builds

## Proof of Concept

Create a Move module with a critical invariant in a `#[test_only]` spec block:

```move
module 0x1::vulnerable {
    struct Balance has key { value: u64 }
    
    public fun withdraw(account: &signer, amount: u64) {
        // ... withdrawal logic ...
    }
    
    #[test_only]
    spec withdraw {
        // CRITICAL: This invariant will be filtered out during prover runs!
        ensures old(global<Balance>(signer::address_of(account)).value) >= amount;
    }
}
```

**Verification Steps:**
1. Run Move Prover on this module
2. The `#[test_only]` spec block is silently filtered
3. Prover verifies the module without checking the balance invariant
4. If `withdraw()` has a bug allowing over-withdrawal, prover won't catch it
5. Vulnerable code receives "proof of correctness"

This demonstrates how critical security invariants can be excluded from verification, potentially allowing consensus-breaking or fund-stealing bugs to pass formal verification.

## Notes

This vulnerability affects the Move Prover's completeness guarantees rather than being a direct protocol exploit. However, given that Aptos relies heavily on formal verification for security assurance of critical components (consensus, governance, staking), any weakness in the verification pipeline poses significant risk. The silent nature of the filtering makes this particularly dangerousâ€”developers receive no indication that their security specs were excluded from verification.

### Citations

**File:** third_party/move/tools/move-package/src/compilation/model_builder.rs (L133-133)
```rust
                options.compile_verify_code = true;
```

**File:** third_party/move/move-model/src/lib.rs (L107-107)
```rust
            .set_keep_testing_functions(compile_test_code)
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L224-235)
```rust
fn should_remove_node(env: &CompilationEnv, attrs: &[P::Attributes], is_source_def: bool) -> bool {
    use known_attributes::TestingAttribute;
    let flattened_attrs: Vec<_> = attrs.iter().flat_map(test_attributes).collect();
    let is_test_only = flattened_attrs
        .iter()
        .any(|attr| matches!(attr.1, TestingAttribute::Test | TestingAttribute::TestOnly));
    is_test_only && !env.flags().keep_testing_functions()
        || (!is_source_def
            && flattened_attrs
                .iter()
                .any(|attr| attr.1 == TestingAttribute::Test))
}
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs (L340-345)
```rust
pub struct SpecBlock_ {
    pub attributes: Vec<Attributes>,
    pub target: SpecBlockTarget,
    pub uses: Vec<UseDecl>,
    pub members: Vec<SpecBlockMember>,
}
```
