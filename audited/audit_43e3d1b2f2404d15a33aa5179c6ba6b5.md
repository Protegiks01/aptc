# Audit Report

## Title
Silent Message Dropping in Remote Executor gRPC Service Leads to System Deadlock

## Summary
The `simple_msg_exchange` gRPC handler in the remote executor networking layer silently drops messages when no handler is registered, returning a success response to the sender. This causes the coordinator to indefinitely block waiting for execution results that will never arrive, resulting in total liveness failure.

## Finding Description

The vulnerability exists in the gRPC network service implementation used by the remote executor architecture for sharded parallel block execution. [1](#0-0) 

When a message arrives with a `message_type` for which no handler is registered, the code:
1. Logs an error message
2. Returns `Ok(Response::new(Empty {}))` - indicating success to the sender
3. Never delivers the message to any handler

The sender-side code treats this as successful delivery: [2](#0-1) 

This breaks a critical invariant: **message delivery acknowledgment must reflect actual delivery status**.

In the remote executor architecture, the coordinator sends execution commands to shards and blocks waiting for results: [3](#0-2) 

If an execution command message is silently dropped due to unregistered handler, the coordinator blocks forever on `rx.recv()` with no timeout, causing total system liveness failure.

**How This Could Manifest:**

While message types are consistently formatted in the current codebase, this vulnerability amplifies the impact of any bug that causes message type mismatches:

1. **Software Update Race Condition**: During a rolling update where coordinator and shards run different versions with incompatible message type schemes
2. **Configuration Errors**: Misconfigured shard IDs causing message routing failures  
3. **Dynamic Message Type Construction Bugs**: Any future code that dynamically constructs message types incorrectly
4. **Handler Registration Failures**: Edge cases where handler registration silently fails but the server starts anyway [4](#0-3) 

## Impact Explanation

This constitutes **Medium severity** based on Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: When messages are dropped, the system enters a deadlocked state requiring manual intervention to recover
- **Not Critical/High severity** because: The vulnerability cannot be directly exploited by an external attacker - it requires a pre-existing software bug or misconfiguration to manifest

The impact when triggered:
- Total liveness failure (coordinator deadlock)
- Block execution stalls indefinitely
- Requires node restart to recover
- Could affect production deployments during upgrades or misconfigurations

## Likelihood Explanation

**Likelihood: Medium**

While the current codebase maintains consistent message type formatting, the likelihood increases due to:

1. **Operational Risk**: Rolling updates, version mismatches, configuration errors are common operational scenarios
2. **Error Amplification**: Any future bug in message routing gets amplified into a total failure rather than a detectable error
3. **No Defense in Depth**: Missing timeouts and error propagation mean any single failure cascades to system deadlock
4. **Production Usage**: Remote executor is used in production when remote addresses are configured: [5](#0-4) 

## Recommendation

**Fix 1: Return error status when handler not found**

Modify `simple_msg_exchange` to return an error when no handler is registered:

```rust
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    // ... existing code ...
    
    if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
        handler.send(msg).unwrap();
        Ok(Response::new(Empty {}))
    } else {
        error!(
            "No handler registered for sender: {:?} and msg type {:?}",
            remote_addr, message_type
        );
        Err(Status::not_found(format!(
            "No handler registered for message type: {:?}", 
            message_type
        )))
    }
}
```

**Fix 2: Add timeouts to blocking recv() calls**

Replace blocking recv() with recv_timeout():

```rust
fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
    let mut results = vec![];
    for (shard_id, rx) in self.result_rxs.iter().enumerate() {
        let received = rx.recv_timeout(Duration::from_secs(300))
            .map_err(|e| VMStatus::Error(StatusCode::UNKNOWN_STATUS, Some(format!(
                "Timeout waiting for result from shard {}: {}", shard_id, e
            ))))?;
        let result: RemoteExecutionResult = bcs::from_bytes(&received.to_bytes()).unwrap();
        results.push(result.inner?);
    }
    Ok(results)
}
```

**Fix 3: Add handler validation at startup**

Ensure all expected handlers are registered before starting the server: [6](#0-5) 

## Proof of Concept

This PoC demonstrates the deadlock scenario:

```rust
#[test]
fn test_silent_message_drop_causes_deadlock() {
    use std::time::Duration;
    use std::thread;
    
    let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), utils::get_available_port());
    let server_handlers: Arc<Mutex<HashMap<MessageType, Sender<Message>>>> =
        Arc::new(Mutex::new(HashMap::new()));
    
    // Register handler for "registered_type" only
    let (msg_tx, _msg_rx) = crossbeam_channel::unbounded();
    server_handlers
        .lock()
        .unwrap()
        .insert(MessageType::new("registered_type".to_string()), msg_tx);
    
    let server = GRPCNetworkMessageServiceServerWrapper::new(server_handlers, server_addr);
    let rt = Runtime::new().unwrap();
    let (_server_shutdown_tx, server_shutdown_rx) = oneshot::channel();
    
    server.start(&rt, "test".to_string(), server_addr, 1000, server_shutdown_rx);
    thread::sleep(Duration::from_millis(50)); // Wait for server startup
    
    let mut client = GRPCNetworkMessageServiceClientWrapper::new(&rt, server_addr);
    let client_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), utils::get_available_port());
    
    // Send message with UNREGISTERED message type
    let handle = thread::spawn(move || {
        rt.block_on(async {
            client.send_message(
                client_addr,
                Message::new("test".as_bytes().to_vec()),
                &MessageType::new("UNREGISTERED_TYPE".to_string()),
            )
            .await;
        });
    });
    
    // This returns successfully even though message was dropped!
    handle.join().unwrap();
    
    // In real scenario, coordinator would now deadlock waiting for response
    // that will never come because the message was silently dropped
    println!("Message was silently dropped - sender received success!");
}
```

## Notes

This vulnerability exemplifies poor error handling practices where failures are logged but not propagated. While not directly exploitable by external attackers in the current codebase, it creates operational fragility and amplifies the impact of any future bugs in message routing or handler registration. The lack of timeouts and proper error propagation transforms what should be a detectable, recoverable error into a total system deadlock requiring manual intervention.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L140-160)
```rust
    pub async fn send_message(
        &mut self,
        sender_addr: SocketAddr,
        message: Message,
        mt: &MessageType,
    ) {
        let request = tonic::Request::new(NetworkMessage {
            message: message.data,
            message_type: mt.get_type(),
        });
        // TODO: Retry with exponential backoff on failures
        match self.remote_channel.simple_msg_exchange(request).await {
            Ok(_) => {},
            Err(e) => {
                panic!(
                    "Error '{}' sending message to {} on node {:?}",
                    e, self.remote_addr, sender_addr
                );
            },
        }
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L79-113)
```rust
impl CoordinatorClient<RemoteStateViewClient> for RemoteCoordinatorClient {
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```

**File:** secure/net/src/network_controller/inbound_handler.rs (L44-63)
```rust
    pub fn start(&self, rt: &Runtime) -> Option<oneshot::Sender<()>> {
        if self.inbound_handlers.lock().unwrap().is_empty() {
            return None;
        }

        let (server_shutdown_tx, server_shutdown_rx) = oneshot::channel();
        // The server is started in a separate task
        GRPCNetworkMessageServiceServerWrapper::new(
            self.inbound_handlers.clone(),
            self.listen_addr,
        )
        .start(
            rt,
            self.service.clone(),
            self.listen_addr,
            self.rpc_timeout_ms,
            server_shutdown_rx,
        );
        Some(server_shutdown_tx)
    }
```
