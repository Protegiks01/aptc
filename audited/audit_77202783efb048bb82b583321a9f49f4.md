# Audit Report

## Title
Missing Chain ID Validation in Indexer-GRPC Data Manager and File Store Backfiller

## Summary
Multiple client components consuming `GetTransactionsFromNode` responses fail to validate the `chain_id` field against the expected chain identifier. The `data_manager.rs` and `file-store-backfiller/processor.rs` process streaming responses without verifying that transactions originate from the correct blockchain, enabling potential data corruption if connected to a malicious or misconfigured fullnode.

## Finding Description

The `TransactionsFromNodeResponse` protobuf message includes a mandatory `chain_id` field to identify the blockchain network. [1](#0-0) 

The fullnode server correctly populates this field from its ledger context. [2](#0-1) [3](#0-2) 

However, the **data_manager** component, which serves transactions to indexer-grpc API consumers, processes responses without validating the `chain_id` field. [4](#0-3) 

When the data manager falls back to direct fullnode requests (cache lagging scenario), it similarly lacks validation. [5](#0-4) 

The **file-store-backfiller** also processes streaming responses in its backfill loop without chain_id validation. [6](#0-5) 

In contrast, the **cache-worker** correctly validates chain_id on every response and panics on mismatch, demonstrating the expected security pattern. [7](#0-6) 

**Attack Scenario:**
1. Attacker compromises or misconfigures a fullnode in the data manager's fullnode pool
2. The malicious fullnode serves testnet/devnet transactions with incorrect `chain_id`
3. Data manager accepts and caches these transactions without validation
4. Corrupted cross-chain data is served to all downstream indexer-grpc consumers
5. Applications querying the indexer receive invalid transaction data, breaking state consistency

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

1. **Significant Protocol Violation**: Breaks the State Consistency invariant by allowing cross-chain data contamination in the indexer infrastructure
2. **State Inconsistencies Requiring Intervention**: Corrupted data in cache and file store would require manual cleanup and re-synchronization
3. **Cascading Impact**: The data_manager serves all indexer-grpc API consumers, amplifying the damage to the entire indexer ecosystem
4. **No Automatic Detection**: Without explicit validation, corrupted data could persist undetected until downstream services fail

The vulnerability does not reach Critical severity as it:
- Does not directly affect consensus or validator operations
- Requires compromising infrastructure (fullnode) rather than pure protocol exploitation
- Impacts data availability/correctness, not fund theft or consensus safety

## Likelihood Explanation

**Likelihood: Medium**

Required preconditions:
1. Malicious or misconfigured fullnode in the metadata manager's pool
2. Data manager routing requests to the compromised fullnode

This could occur through:
- **Accidental misconfiguration**: Operator adds wrong fullnode address (testnet URL in mainnet config)
- **DNS/network attacks**: Attacker redirects fullnode connections to malicious endpoints
- **Compromised infrastructure**: Attacker gains control of a legitimate fullnode

The data_manager actively tries multiple fullnodes for load balancing, increasing exposure to any single compromised node. [8](#0-7) 

## Recommendation

Add chain_id validation immediately after receiving each response, consistent with the cache-worker implementation:

```rust
// In data_manager.rs, after line 258
match response_item {
    Ok(r) => {
        // Validate chain_id matches expected value
        let expected_chain_id = /* obtain from initialization context */;
        if r.chain_id as u64 != expected_chain_id {
            error!("Chain ID mismatch: expected {}, got {}", expected_chain_id, r.chain_id);
            continue 'out;
        }
        
        if let Some(response) = r.response {
            // ... existing processing logic
        }
    }
}
```

Similarly, add validation in file-store-backfiller's streaming loop after line 274, and ensure the v2-backfiller uses proper error handling instead of asserts (which can be optimized away). [9](#0-8) 

Store the expected `chain_id` during component initialization and validate against it for every response in the stream.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_chain_id_validation_missing() {
    // Setup: Create mock fullnode returning wrong chain_id
    let mock_fullnode = MockFullnode::new(/*correct_chain_id=*/1, /*malicious_chain_id=*/2);
    
    // Create data_manager connected to malicious fullnode
    let mut data_manager = DataManager::new(
        /*expected_chain_id=*/1,
        file_store_config,
        cache_config,
        metadata_manager,
        allow_fn_fallback,
    ).await;
    
    // Request transactions - should fail but currently doesn't
    let request = GetTransactionsFromNodeRequest {
        starting_version: Some(0),
        transactions_count: Some(100),
    };
    
    // This should reject transactions with wrong chain_id
    // Currently it accepts them, causing data corruption
    let result = data_manager.get_transactions(0, 1000).await;
    
    // Vulnerability: result.is_ok() even though chain_id is wrong
    // Expected: result.is_err() with chain_id mismatch error
    assert!(result.is_ok()); // Currently passes - demonstrates vulnerability
}
```

**Notes:**
- The vulnerability is in CLIENT-SIDE validation within indexer infrastructure components, not the server implementation itself
- The fullnode server correctly includes chain_id in all responses
- The security question's phrasing about "server verify" is ambiguous, but the actual issue is clients failing to validate what servers send
- This breaks the State Consistency invariant for the indexer subsystem

### Citations

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.rs (L80-82)
```rust
    /// Making sure that all the responses include a chain id
    #[prost(uint32, tag="3")]
    pub chain_id: u32,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L90-91)
```rust
        let context = self.service_context.context.clone();
        let ledger_chain_id = context.chain_id().id();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L259-259)
```rust
        chain_id: ledger_chain_id as u32,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L217-220)
```rust
            let (address, mut fullnode_client) =
                self.metadata_manager.get_fullnode_for_request(&request);
            trace!("Fullnode ({address}) is picked for request.");
            let response = fullnode_client.get_transactions_from_node(request).await;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L233-279)
```rust
            while let Some(response_item) = response.next().await {
                trace!("Processing 1 response item.");
                loop {
                    trace!("Maybe running GC.");
                    if self.cache.write().await.maybe_gc() {
                        IS_FILE_STORE_LAGGING.set(0);
                        trace!("GC is done, file store is not lagging.");
                        break;
                    }
                    IS_FILE_STORE_LAGGING.set(1);
                    // If file store is lagging, we are not inserting more data.
                    let cache = self.cache.read().await;
                    warn!("Filestore is lagging behind, cache is full [{}, {}), known_latest_version ({}).",
                          cache.start_version,
                          cache.start_version + cache.transactions.len() as u64,
                          self.metadata_manager.get_known_latest_version());
                    tokio::time::sleep(Duration::from_millis(100)).await;
                    if watch_file_store_version {
                        self.update_file_store_version_in_cache(
                            &cache, /*version_can_go_backward=*/ false,
                        )
                        .await;
                    }
                }
                match response_item {
                    Ok(r) => {
                        if let Some(response) = r.response {
                            match response {
                                Response::Data(data) => {
                                    trace!(
                                        "Putting data into cache, {} transaction(s).",
                                        data.transactions.len()
                                    );
                                    self.cache.write().await.put_transactions(data.transactions);
                                },
                                Response::Status(_) => continue,
                            }
                        } else {
                            warn!("Error when getting transactions from fullnode: no data.");
                            continue 'out;
                        }
                    },
                    Err(e) => {
                        warn!("Error when getting transactions from fullnode: {}", e);
                        continue 'out;
                    },
                }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L304-322)
```rust
                    let request = GetTransactionsFromNodeRequest {
                        starting_version: Some(start_version),
                        transactions_count: Some(5000),
                    };

                    let (_, mut fullnode_client) =
                        self.metadata_manager.get_fullnode_for_request(&request);
                    let response = fullnode_client.get_transactions_from_node(request).await?;
                    let mut response = response.into_inner();
                    while let Some(Ok(response_item)) = response.next().await {
                        if let Some(response) = response_item.response {
                            match response {
                                Response::Data(data) => {
                                    return Ok(data.transactions);
                                },
                                Response::Status(_) => continue,
                            }
                        }
                    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L265-302)
```rust
        loop {
            let item = grpc_stream.next().await;
            let item = item.unwrap();
            let response = match item {
                Ok(response) => response,
                Err(e) => {
                    tracing::error!("Failed to get response: {:?}", e);
                    panic!("Failed to get response: {:?}", e);
                },
            };

            let resp = response.response.unwrap();
            match resp {
                Response::Data(txns) => {
                    let transactions = txns.transactions;
                    for txn in transactions {
                        let version = txn.version;
                        // Partial batch may be received; split and insert into buffer.
                        transactions_buffer.insert(version, txn);
                    }
                },
                Response::Status(signal) => {
                    if signal.r#type() != StatusType::BatchEnd {
                        anyhow::bail!("Unexpected status signal type");
                    }
                    while transactions_buffer.len() >= 1000 {
                        // Take the first 1000 transactions.
                        let mut transactions = Vec::new();
                        // Pop the first 1000 transactions from buffer.
                        for _ in 0..1000 {
                            let (_, txn) = transactions_buffer.pop_first().unwrap();
                            transactions.push(txn);
                        }
                        sender.send(transactions).await?;
                    }
                },
            }
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L382-384)
```rust
        if received.chain_id as u64 != fullnode_chain_id as u64 {
            panic!("[Indexer Cache] Chain id mismatch happens during data streaming.");
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-v2-file-store-backfiller/src/processor.rs (L176-176)
```rust
                                    assert!(r.chain_id == chain_id);
```
