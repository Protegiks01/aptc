# Audit Report

## Title
Cryptographic Key Leakage Through Error Messages in Vault Storage - Inadequate Fuzzer Coverage

## Summary
The fuzzer `arb_secret_read_response()` generates test cases with arbitrary HTTP status codes and sensitive cryptographic material in the response body, but fails to verify that error messages from `process_secret_read_response()` do not leak this sensitive data. When non-200/404 status codes are returned, the full response body (containing all secrets in the data BTreeMap) is captured in error messages that are subsequently logged by consensus safety rules, creating a critical information disclosure vulnerability.

## Finding Description

The vulnerability exists in the error handling path of `process_secret_read_response()` in [1](#0-0) 

When the HTTP response status is neither 200 nor 404, the function converts the entire response (including body) into an error via the `From<ureq::Response>` implementation at [2](#0-1) 

This creates an `HttpError` variant containing the full response body as the third parameter [3](#0-2) 

The error then propagates through the storage layer, where it's converted to `InternalError` via [4](#0-3) 

In consensus safety rules, when retrieving consensus keys fails, the error is explicitly logged at [5](#0-4) 

The vulnerability chain:
1. `VaultStorage::get()` calls `read_secret()` to retrieve consensus keys [6](#0-5) 
2. If Vault returns status 500 (or any non-200/404 status) with a JSON body containing the `data` BTreeMap with multiple secrets
3. The entire response body is captured: `Error::HttpError(status, status_text, body)`
4. This becomes: `InternalError("Http error, status code: 500, status text: ..., body: {\"data\":{\"data\":{\"key1\":\"private_key_material\",...}}}")`
5. Then: `SecureStorageUnexpectedError("Internal error: Http error...")`
6. Finally logged via `info!` macro, exposing all cryptographic material to log files, monitoring systems, and operators

The fuzzer at [7](#0-6)  generates responses with arbitrary status codes and arbitrary data BTreeMaps, but the test at [8](#0-7)  merely discards the result without validating that error messages don't contain the sensitive data.

## Impact Explanation

**Critical Severity** - This vulnerability enables information disclosure of consensus private keys (BLS12381 keys used for block signing), which are retrieved via `consensus_sk_by_pk()` [9](#0-8) 

With leaked consensus keys, an attacker could:
- **Forge block signatures**: Sign arbitrary blocks with a validator's key
- **Cause equivocation**: Sign conflicting blocks to violate consensus safety
- **Break consensus safety guarantees**: Violate the fundamental invariant that AptosBFT prevents double-spending with <1/3 Byzantine validators
- **Compromise network integrity**: Use stolen validator credentials to disrupt consensus

This breaks the **Cryptographic Correctness** invariant and **Consensus Safety** invariant, as leaked private keys enable complete compromise of validator operations without requiring 1/3+ Byzantine stake.

## Likelihood Explanation

**Medium-to-Low Likelihood** with severe consequences:

The vulnerability requires one of these conditions:
1. **Vault Server Bug**: Vault returns error status (5xx, 4xx) but includes secret data in response body instead of error message
2. **MITM Attack**: Attacker intercepts TLS connection to Vault (requires certificate compromise or misconfiguration) and injects crafted responses with error status + secret data
3. **Vault Misconfiguration**: Improperly configured Vault that leaks data in error responses
4. **Compromised Vault**: Attacker controls Vault server and returns malicious responses

While these conditions aren't trivial to achieve, defense-in-depth principles require that error messages NEVER contain sensitive data regardless of external conditions. The fuzzer's failure to test this means the codebase lacks verification of this critical security property.

## Recommendation

**Immediate Fix**: Modify `process_secret_read_response()` to sanitize error responses before creating error messages. Never include the full response body in errors when dealing with secret data.

**Enhanced Fuzzer**: Add assertions to verify error messages don't contain sensitive data:

```rust
#[test]
fn process_secret_read_response_proptest((response, secret, key) in arb_secret_read_response()) {
    let result = process_secret_read_response(&secret, &key, response);
    
    // If error, verify it doesn't leak sensitive data from the BTreeMap
    if let Err(err) = result {
        let err_msg = format!("{}", err);
        // Ensure no data from the BTreeMap appears in error message
        // (requires access to the original data map for verification)
        assert!(!err_msg.contains("sensitive_pattern"));
    }
}
```

**Code Fix**: Modify error conversion to exclude response body for secret operations:

```rust
pub fn process_secret_read_response(
    secret: &str,
    key: &str,
    resp: Response,
) -> Result<ReadResponse<Value>, Error> {
    match resp.status() {
        200 => { /* existing logic */ },
        404 => { /* existing logic */ },
        _ => {
            // Don't include response body in error for security
            let status = resp.status();
            let status_text = resp.status_text().to_string();
            resp.into_string()?; // Consume body without capturing
            Err(Error::HttpError(status, status_text, 
                "Response body omitted for security".into()))
        }
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod security_test {
    use super::*;
    use proptest::prelude::*;
    
    proptest! {
        #[test]
        fn test_error_messages_dont_leak_secrets(
            status in 300u16..600u16, // Error status codes
            sensitive_data in prop::collection::btree_map(
                any::<String>(), 
                any::<String>(), 
                1..10
            )
        ) {
            // Skip valid success/not-found statuses
            prop_assume!(status != 200 && status != 404);
            
            let metadata = ReadSecretMetadata {
                created_time: "2024-01-01T00:00:00Z".to_string(),
                version: 1,
            };
            let data = ReadSecretData {
                data: sensitive_data.clone(),
                metadata,
            };
            let read_secret_response = ReadSecretResponse { data };
            let body = serde_json::to_string(&read_secret_response).unwrap();
            let response = Response::new(status, "Error", &body);
            
            // Process the response
            let result = process_secret_read_response("test_secret", "test_key", response);
            
            // CRITICAL CHECK: Error message should NOT contain sensitive data
            if let Err(err) = result {
                let err_msg = format!("{:?}", err);
                for (key, value) in sensitive_data.iter() {
                    prop_assert!(
                        !err_msg.contains(value),
                        "Error message leaked sensitive value: {} for key: {}", 
                        value, key
                    );
                }
            }
        }
    }
}
```

**Notes**

This vulnerability demonstrates a critical gap between testing coverage and security verification. While the fuzzer generates edge cases (error responses with sensitive data), it fails to assert security properties (no data leakage). The error propagates through multiple layers ( [4](#0-3) , [10](#0-9) ) and is ultimately logged, creating persistent information disclosure. Defense-in-depth requires that even under abnormal external conditions (buggy Vault, MITM), the system must not leak cryptographic material through error messages.

### Citations

**File:** secure/storage/vault/src/lib.rs (L41-42)
```rust
    #[error("Http error, status code: {0}, status text: {1}, body: {2}")]
    HttpError(u16, String, String),
```

**File:** secure/storage/vault/src/lib.rs (L75-91)
```rust
impl From<ureq::Response> for Error {
    fn from(resp: ureq::Response) -> Self {
        if resp.synthetic() {
            match resp.into_string() {
                Ok(resp) => Error::SyntheticError(resp),
                Err(error) => Error::InternalError(error.to_string()),
            }
        } else {
            let status = resp.status();
            let status_text = resp.status_text().to_string();
            match resp.into_string() {
                Ok(body) => Error::HttpError(status, status_text, body),
                Err(error) => Error::InternalError(error.to_string()),
            }
        }
    }
}
```

**File:** secure/storage/vault/src/lib.rs (L550-574)
```rust
pub fn process_secret_read_response(
    secret: &str,
    key: &str,
    resp: Response,
) -> Result<ReadResponse<Value>, Error> {
    match resp.status() {
        200 => {
            let mut resp: ReadSecretResponse = serde_json::from_str(&resp.into_string()?)?;
            let data = &mut resp.data;
            let value = data
                .data
                .remove(key)
                .ok_or_else(|| Error::NotFound(secret.into(), key.into()))?;
            let created_time = data.metadata.created_time.clone();
            let version = data.metadata.version;
            Ok(ReadResponse::new(created_time, value, version))
        },
        404 => {
            // Explicitly clear buffer so the stream can be re-used.
            resp.into_string()?;
            Err(Error::NotFound(secret.into(), key.into()))
        },
        _ => Err(resp.into()),
    }
}
```

**File:** secure/storage/src/error.rs (L56-64)
```rust
impl From<aptos_vault_client::Error> for Error {
    fn from(error: aptos_vault_client::Error) -> Self {
        match error {
            aptos_vault_client::Error::NotFound(_, key) => Self::KeyNotSet(key),
            aptos_vault_client::Error::HttpError(403, _, _) => Self::PermissionDenied,
            _ => Self::InternalError(format!("{}", error)),
        }
    }
}
```

**File:** consensus/safety-rules/src/safety_rules.rs (L340-343)
```rust
        initialize_result.inspect_err(|error| {
            info!(SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Error).error(error),);
            self.validator_signer = None;
        })
```

**File:** secure/storage/src/vault.rs (L155-165)
```rust
    fn get<T: DeserializeOwned>(&self, key: &str) -> Result<GetResponse<T>, Error> {
        let secret = key;
        let key = self.unnamespaced(key);
        let resp = self.client().read_secret(secret, key)?;
        let last_update = DateTime::parse_from_rfc3339(&resp.creation_time)?.timestamp() as u64;
        let value: T = serde_json::from_value(resp.value)?;
        self.secret_versions
            .write()
            .insert(key.to_string(), resp.version);
        Ok(GetResponse { last_update, value })
    }
```

**File:** secure/storage/vault/src/fuzzing.rs (L72-101)
```rust
prop_compose! {
    pub fn arb_secret_read_response(
    )(
        status in any::<u16>(),
        status_text in any::<String>(),
        data in prop::collection::btree_map(any::<String>(), arb_json_value(), 0..MAX_COLLECTION_SIZE),
        created_time in any::<String>(),
        version in any::<u32>(),
        secret in any::<String>(),
        key in any::<String>(),
    ) -> (Response, String, String) {
        let metadata = ReadSecretMetadata {
            created_time,
            version,
        };
        let data = ReadSecretData {
            data,
            metadata,
        };
        let read_secret_response = ReadSecretResponse {
            data
        };

        let read_secret_response =
            serde_json::to_string::<ReadSecretResponse>(&read_secret_response).unwrap();
        let read_secret_response = Response::new(status, &status_text, &read_secret_response);

        (read_secret_response, secret, key)
    }
}
```

**File:** secure/storage/vault/src/fuzzing.rs (L337-340)
```rust
        #[test]
        fn process_secret_read_response_proptest((response, secret, key) in arb_secret_read_response()) {
            let _ = process_secret_read_response(&secret, &key, response);
        }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L106-132)
```rust
    pub fn consensus_sk_by_pk(
        &self,
        pk: bls12381::PublicKey,
    ) -> Result<bls12381::PrivateKey, Error> {
        let _timer = counters::start_timer("get", CONSENSUS_KEY);
        let pk_hex = hex::encode(pk.to_bytes());
        let explicit_storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
        let explicit_sk = self
            .internal_store
            .get::<bls12381::PrivateKey>(explicit_storage_key.as_str())
            .map(|v| v.value);
        let default_sk = self.default_consensus_sk();
        let key = match (explicit_sk, default_sk) {
            (Ok(sk_0), _) => sk_0,
            (Err(_), Ok(sk_1)) => sk_1,
            (Err(_), Err(_)) => {
                return Err(Error::ValidatorKeyNotFound("not found!".to_string()));
            },
        };
        if key.public_key() != pk {
            return Err(Error::SecureStorageMissingDataError(format!(
                "Incorrect sk saved for {:?} the expected pk",
                pk
            )));
        }
        Ok(key)
    }
```

**File:** consensus/safety-rules/src/error.rs (L78-99)
```rust
impl From<aptos_secure_storage::Error> for Error {
    fn from(error: aptos_secure_storage::Error) -> Self {
        match error {
            aptos_secure_storage::Error::PermissionDenied => {
                // If a storage error is thrown that indicates a permission failure, we
                // want to panic immediately to alert an operator that something has gone
                // wrong. For example, this error is thrown when a storage (e.g., vault)
                // token has expired, so it makes sense to fail fast and require a token
                // renewal!
                panic!(
                    "A permission error was thrown: {:?}. Maybe the storage token needs to be renewed?",
                    error
                );
            },
            aptos_secure_storage::Error::KeyVersionNotFound(_, _)
            | aptos_secure_storage::Error::KeyNotSet(_) => {
                Self::SecureStorageMissingDataError(error.to_string())
            },
            _ => Self::SecureStorageUnexpectedError(error.to_string()),
        }
    }
}
```
