# Audit Report

## Title
Missing Automated Constant-Time Verification for Cryptographic Dependency Updates

## Summary
When cryptographic dependencies (`bls12_381`, `blstrs`) are updated, the CI/CD pipeline does not automatically verify that the new versions maintain constant-time execution guarantees for scalar multiplication operations. This creates a gap where timing side-channel vulnerabilities could be introduced through dependency updates and merged into production without detection.

## Finding Description

The Aptos codebase implements constant-time verification tests for cryptographic scalar multiplication operations to prevent timing side-channel attacks that could leak private keys. However, these critical security tests are not integrated into the automated CI/CD pipeline.

**Evidence of the Gap:**

1. **Constant-time tests exist but are marked as ignored**: [1](#0-0) 

2. **CI/CD runs unit tests without the `--ignored` flag**: [2](#0-1) 

3. **The test requires manual execution in release mode**: [3](#0-2) 

4. **Only blstrs is verified at pepper service startup, not zkcrypto**: [4](#0-3) 

5. **The pepper service skips constant-time checks in local development**: [5](#0-4) 

**Attack Scenario:**

If a dependency update to `bls12_381` or `blstrs` introduces non-constant-time behavior in scalar multiplication:

1. The update would pass through CI/CD because constant-time tests are skipped
2. The vulnerable code would be merged and deployed
3. An attacker with timing measurement capabilities could exploit the timing variation to extract bits of private scalars used in:
   - BLS signature generation (validator consensus keys)
   - VUF operations (keyless account pepper derivation)
   - DKG operations (distributed key generation)

**Why This Breaks Cryptographic Correctness (Invariant #10):**

Constant-time execution is a fundamental requirement for cryptographic implementations. Timing variations in scalar multiplication can leak secret key material through side-channel attacks. The codebase acknowledges this with extensive constant-time testing infrastructure, but fails to enforce it during dependency updates. [6](#0-5) 

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty criteria)

While this is a testing gap rather than an active vulnerability in the current code, it represents a **significant protocol violation** (High severity category) because:

1. **Validator Security Risk**: If a timing side-channel is introduced, validator private keys could be compromised, leading to consensus violations
2. **Keyless Account Security**: The pepper service uses these cryptographic operations for deriving user peppers - timing leaks could compromise user account security
3. **Systematic Risk**: The gap affects ALL future cryptographic dependency updates, not just a single code path

However, this does **not** qualify as Critical severity because:
- No current exploitable timing vulnerability is demonstrated
- It's a process gap, not an active code bug
- The pepper service does provide a backstop (though incomplete) by checking at startup

## Likelihood Explanation

**Likelihood: Medium to High**

Factors increasing likelihood:
1. Cryptographic libraries are regularly updated for security patches and performance improvements
2. The codebase documents using Dependabot for dependency monitoring: [7](#0-6) 
3. Known bugs have already occurred in `blstrs` dependencies: [8](#0-7) 
4. Timing side-channels are subtle and can be accidentally introduced in optimization efforts

Factors decreasing likelihood:
- Mature cryptographic libraries like `blstrs` (wrapping `blst`) are generally careful about constant-time properties
- The pepper service provides partial protection by verifying blstrs at startup (production only)
- Code review processes may catch obvious timing issues

## Recommendation

**Immediate Actions:**

1. **Create a dedicated CI/CD job for constant-time verification** that runs on:
   - All PRs that modify `Cargo.lock` or cryptographic dependencies
   - Weekly scheduled runs to catch any missed updates
   - Before any release deployment

2. **Add a pre-release checklist** requiring constant-time verification after dependency updates

3. **Extend pepper service startup checks** to include zkcrypto verification: [9](#0-8) 

**Implementation Example:**

Add a new GitHub Actions workflow (`.github/workflows/crypto-constant-time-check.yaml`):

```yaml
name: Cryptographic Constant-Time Verification
on:
  pull_request:
    paths:
      - 'Cargo.lock'
      - 'crates/aptos-crypto/**'
      - 'crates/aptos-dkg/**'
  schedule:
    - cron: '0 0 * * 0'  # Weekly on Sunday
  workflow_dispatch:

jobs:
  constant-time-verification:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run constant-time tests
        run: |
          cargo test --release -p aptos-crypto test_blstrs_fixed_base_g1_scalar_mul_is_constant_time -- --ignored --nocapture
          cargo test --release -p aptos-crypto test_blstrs_random_base_g1_scalar_mul_is_constant_time -- --ignored --nocapture
      - name: Run constant-time examples
        run: |
          cargo run --release --example is_blstrs_constant_time
          cargo run --release --example is_zkcrypto_constant_time
```

## Proof of Concept

**Demonstrating the Gap (Not an Exploit):**

1. The constant-time tests are currently skipped in CI: [10](#0-9) 

2. To verify they work, manually run:
```bash
cd crates/aptos-crypto
cargo test --release test_blstrs_fixed_base_g1_scalar_mul_is_constant_time -- --ignored --nocapture
```

3. If a dependency introduced timing variations, this test would fail with a high t-statistic, but the failure would not be caught by CI/CD.

**Note**: This PoC demonstrates the testing gap, not an actual timing vulnerability. A complete exploit would require:
- An actual timing side-channel in a dependency (not currently demonstrated)
- Precise timing measurements in a production environment
- Statistical analysis to extract key bits

---

**Notes:**

This finding represents a **security best practice violation** rather than an immediately exploitable vulnerability. The current cryptographic dependencies (`bls12_381 0.8.0`, `blstrs 0.7.1`) do not have known timing side-channels, and the codebase has implemented appropriate testing infrastructure. However, the lack of automated enforcement creates systemic risk for future updates.

The severity is rated as High because it affects a critical security property (cryptographic correctness) across multiple system components (consensus, keyless accounts, DKG), even though no active exploit is demonstrated.

### Citations

**File:** crates/aptos-crypto/src/unit_tests/constant_time_test.rs (L9-22)
```rust
#[test]
#[ignore]
/// WARNING: This is marked as "ignored" because unit tests are typically run in debug mode, and we
/// would need this to run in release mode to make sure the dudect framework's statistical measurements
/// are meaningful.
///
/// Nonetheless, we wrote this test to serve as an example for how to call the dudect framework
/// manually, without using the macros that would generate a `main` function, which would not work
/// if we want to run these tests in some other `main` function (like the pepper service).
///
/// To run this test properly, do:
///
///    cargo test --release test_blstrs_fixed_base_g1_scalar_mul_is_constant_time -- --ignored --nocapture
///
```

**File:** .github/actions/rust-unit-tests/action.yaml (L32-46)
```yaml
    - name: Run all unit tests
      run: |
        cargo nextest run \
          --profile ci \
          --cargo-profile ci \
          --locked \
          --workspace \
          --exclude smoke-test \
          --exclude aptos-testcases \
          --exclude aptos-keyless-circuit \
          --retries 3 \
          --no-fail-fast \
          --message-format libtest-json > nextest_output.json || python3 .github/actions/rust-unit-tests/nextest_summary.py nextest_output.json "$GITHUB_STEP_SUMMARY" -f
        python3 .github/actions/rust-unit-tests/nextest_summary.py nextest_output.json "$GITHUB_STEP_SUMMARY" || echo "summary generation had an error"
        rm nextest_output.json
```

**File:** keyless/pepper/service/src/main.rs (L364-392)
```rust
fn verify_constant_time_scalar_multiplication() {
    // Run the constant time benchmarks for random bases
    let abs_max_t = ctbench::run_bench(
        &BenchName("blstrs_scalar_mul/random_bases"),
        constant_time::blstrs_scalar_mul::run_bench_with_random_bases,
        None,
    )
    .1
    .max_t
    .abs()
    .ceil()
    .to_i64()
    .expect("Floating point arithmetic went awry.");
    assert_le!(abs_max_t, ABS_MAX_T);

    // Run the constant time benchmarks for fixed bases
    let abs_max_t = ctbench::run_bench(
        &BenchName("blstrs_scalar_mul/fixed_bases"),
        constant_time::blstrs_scalar_mul::run_bench_with_fixed_bases,
        None,
    )
    .1
    .max_t
    .abs()
    .ceil()
    .to_i64()
    .expect("Floating point arithmetic went awry.");
    assert_le!(abs_max_t, ABS_MAX_T);
}
```

**File:** keyless/pepper/service/src/main.rs (L402-410)
```rust
    // Verify constant-time scalar multiplication if in production.
    if args.local_development_mode {
        info!(
            "Constant-time scalar multiplication verification skipped in local development mode."
        );
    } else {
        info!("Verifying constant-time scalar multiplication...");
        verify_constant_time_scalar_multiplication();
    }
```

**File:** crates/aptos-crypto/src/constant_time/mod.rs (L1-10)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! This module provides implementations of "dudect" statistical tests to check some of our code
//! is constant-time (e.g., like scalar multiplication).

/// Module for testing that blstrs scalar multiplication is constant-time
pub mod blstrs_scalar_mul;
/// Module for testing that zkcrypto scalar multiplication is constant-time
pub mod zkcrypto_scalar_mul;
```

**File:** RUST_SECURE_CODING.md (L42-43)
```markdown
- Aptos utilizes **[Dependabot](https://github.com/dependabot)** to continuously monitor libraries. Our policy requires mandatory updates for critical and high-vulnerabilities, or upon impact evaluation given the context for medium and lower.
- We recommend leveraging [deps.dev](https://deps.dev) to evaluate new third party crates. This site provides an OpenSSF scorecard containing essential information. As a guideline, libraries with a score of 7 or higher are typically safe to import. However, those scoring **below 7** must be flagged during the PR and require a specific justification.
```

**File:** crates/aptos-dkg/README.md (L28-35)
```markdown

### Size-1 multiexps

`blstrs 0.7.0` had a bug (originally from `blst`) where size-1 multiexps (sometimes) don't output the correct result: see [this issue](https://github.com/filecoin-project/blstrs/issues/57) opened by Sourav Das.

As a result, some of our 1 out of 1 weighted PVSS tests which did a secret reconstruction via a size-1 multiexp in G2 failed intermittently. (This test was called `weighted_fail` at commit `5cd69cba8908b6676cf4481457aae93850b6245e`; it runs in a loop until it fails; sometimes it doesn't fail; most of the times it does though.)

We patched this by clumsily checking for the input size before calling `blstrs`'s multiexp wrapper.
```

**File:** crates/aptos-crypto/src/constant_time/zkcrypto_scalar_mul.rs (L14-17)
```rust
/// Runs a statistical test to check that zkcrypto's scalar multiplication on G1 is constant time.
pub fn run_bench(runner: &mut CtRunner, rng: &mut BenchRng) {
    build_and_run_bench(runner, rng, |sk, g1| g1.mul(sk));
}
```
