# Audit Report

## Title
Missing Ledger Info Signature Verification During State Snapshot Restore Enables Forked Chain State Restoration

## Summary
When restoring state snapshots with `skip_epoch_endings=true`, the LedgerInfoWithSignatures is not verified for valid validator signatures, allowing a malicious backup service to provide state from a forked chain or fabricated state that passes all Merkle proof validations but represents incorrect chain state.

## Finding Description

The state snapshot restore process relies on a LedgerInfoWithSignatures to determine the expected state root hash for validation. This ledger info is provided by the backup service and should contain aggregated BLS signatures from 2f+1 validators to prove it represents legitimate committed state. [1](#0-0) 

The code verifies the transaction info against the ledger info and checks that the state root hash matches, but **only** verifies the ledger info against epoch history when `epoch_history.is_some()`. When `skip_epoch_endings=true`, epoch_history is set to None: [2](#0-1) 

The LedgerInfoWithSignatures struct contains validator signatures that should be verified: [3](#0-2) [4](#0-3) 

However, nowhere in the restore path when `epoch_history=None` is `verify_signatures()` called on the LedgerInfoWithSignatures. This means:

1. A malicious backup service can provide a LedgerInfoWithSignatures with empty/invalid signatures or signatures from a forked chain
2. Provide state chunks and Merkle proofs that are internally consistent with the fabricated state root
3. All individual chunk Merkle proof validations pass (they verify against the fabricated root hash)
4. The restore succeeds, leaving the validator with state from a forked/incorrect chain

The Merkle proof validation in JellyfishMerkleRestore correctly verifies that chunks match the expected root hash: [5](#0-4) 

But this validation is only as secure as the expected_root_hash, which comes from an unverified LedgerInfoWithSignatures when epoch history verification is skipped.

## Impact Explanation

**Critical Severity** - This vulnerability enables consensus safety violations and non-recoverable network partitioning:

1. **Consensus Safety Violation**: A validator restoring with incorrect state will produce different state roots for the same blocks, breaking the fundamental consensus invariant that all honest validators must agree on state.

2. **Chain Fork Risk**: If multiple validators restore from the same malicious backup service, they will form a separate network with different state, requiring manual intervention or a hard fork to resolve.

3. **Deterministic Execution Broken**: Validators with forked state will execute transactions differently, violating the critical invariant that identical blocks produce identical state roots.

The skip_epoch_endings flag is exposed as a CLI option making this exploitable without insider access: [6](#0-5) 

## Likelihood Explanation

**Moderate to High Likelihood**:

1. Validators may use `--skip-epoch-endings` for performance during emergency restores or when they believe the backup source is trusted
2. A compromised or malicious backup service endpoint could be used unknowingly
3. The attack requires no cryptographic breaks, only providing internally consistent but fabricated state
4. No validator collusion or key compromise needed - just control of a backup service

## Recommendation

Add mandatory signature verification for LedgerInfoWithSignatures during state snapshot restore, regardless of epoch_history availability:

```rust
// In restore.rs, after loading the ledger info
let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) = 
    self.storage.load_bcs_file(&manifest.proof).await?;

// REQUIRED: Always verify signatures
let validator_verifier = /* obtain from genesis or waypoint */;
li.verify_signatures(&validator_verifier)
    .map_err(|e| anyhow!("Invalid ledger info signatures: {}", e))?;

txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
```

Additionally:
1. Require a trusted waypoint or validator set for signature verification
2. Deprecate or remove the `skip_epoch_endings` option for production restores  
3. Add explicit warnings when epoch verification is skipped

## Proof of Concept

```rust
// Malicious backup service can provide:
use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
use aptos_crypto::hash::HashValue;

// 1. Fabricated ledger info with empty signatures (or old/forked signatures)
let fake_ledger_info = LedgerInfo::new(
    BlockInfo::new(
        /* epoch */ 10,
        /* round */ 100, 
        /* id */ HashValue::random(),
        /* executed_state_id */ HashValue::random(), // Attacker-controlled state root
        /* version */ 1000,
        /* timestamp */ 1234567890,
        None,
    ),
    HashValue::zero(),
);
let fake_li = LedgerInfoWithSignatures::new(fake_ledger_info, AggregateSignature::empty());

// 2. Provide state chunks that hash to the attacker-controlled state root
// 3. Provide valid Merkle proofs for those chunks against the fake root
// 4. Victim runs: db-tool restore --skip-epoch-endings --backup-service malicious.com
// 5. Restore succeeds with forked state, no signature verification performed
```

**Notes**

The vulnerability exists because the cryptographic security chain is broken: while individual Merkle proofs are verified, the root of trust (LedgerInfoWithSignatures) is not verified when epoch_history is None. This allows an attacker to substitute an entirely different state tree that is internally consistent but represents a forked or fabricated chain state.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-139)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** types/src/ledger_info.rs (L241-246)
```rust
pub struct LedgerInfoWithV0 {
    ledger_info: LedgerInfo,
    /// Aggregated BLS signature of all the validators that signed the message. The bitmask in the
    /// aggregated signature can be used to find out the individual validators signing the message
    signatures: AggregateSignature,
}
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L628-697)
```rust
    fn verify(&self, proof: SparseMerkleRangeProof) -> Result<()> {
        let previous_leaf = self
            .previous_leaf
            .as_ref()
            .expect("The previous leaf must exist.");

        let previous_key = previous_leaf.account_key();
        // If we have all siblings on the path from root to `previous_key`, we should be able to
        // compute the root hash. The siblings on the right are already in the proof. Now we
        // compute the siblings on the left side, which represent all the states that have ever
        // been added.
        let mut left_siblings = vec![];

        // The following process might add some extra placeholder siblings on the left, but it is
        // nontrivial to determine when the loop should stop. So instead we just add these
        // siblings for now and get rid of them in the next step.
        let mut num_visited_right_siblings = 0;
        for (i, bit) in previous_key.iter_bits().enumerate() {
            if bit {
                // This node is a right child and there should be a sibling on the left.
                let sibling = if i >= self.partial_nodes.len() * 4 {
                    *SPARSE_MERKLE_PLACEHOLDER_HASH
                } else {
                    Self::compute_left_sibling(
                        &self.partial_nodes[i / 4],
                        previous_key.get_nibble(i / 4),
                        (3 - i % 4) as u8,
                    )
                };
                left_siblings.push(sibling);
            } else {
                // This node is a left child and there should be a sibling on the right.
                num_visited_right_siblings += 1;
            }
        }
        ensure!(
            num_visited_right_siblings >= proof.right_siblings().len(),
            "Too many right siblings in the proof.",
        );

        // Now we remove any extra placeholder siblings at the bottom. We keep removing the last
        // sibling if 1) it's a placeholder 2) it's a sibling on the left.
        for bit in previous_key.iter_bits().rev() {
            if bit {
                if *left_siblings.last().expect("This sibling must exist.")
                    == *SPARSE_MERKLE_PLACEHOLDER_HASH
                {
                    left_siblings.pop();
                } else {
                    break;
                }
            } else if num_visited_right_siblings > proof.right_siblings().len() {
                num_visited_right_siblings -= 1;
            } else {
                break;
            }
        }

        // Left siblings must use the same ordering as the right siblings in the proof
        left_siblings.reverse();

        // Verify the proof now that we have all the siblings
        proof
            .verify(
                self.expected_root_hash,
                SparseMerkleLeafNode::new(*previous_key, previous_leaf.value_hash()),
                left_siblings,
            )
            .map_err(Into::into)
    }
```

**File:** storage/db-tool/src/backup.rs (L153-154)
```rust
    #[clap(long, help = "Skip verifying epoch ending info.")]
    skip_epoch_endings: bool,
```
