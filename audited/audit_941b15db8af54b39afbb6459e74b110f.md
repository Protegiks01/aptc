# Audit Report

## Title
Unbounded Resource Group Tag Accumulation Enables Memory Exhaustion Attack

## Summary
The `group_tags` HashSet in `VersionedGroupData` accumulates all tags written to resource groups within a block without ever removing them, even when tags are deleted. An attacker can exploit this by writing to many different tags across multiple transactions in a block, causing excessive memory consumption on validator nodes during block execution.

## Finding Description

The vulnerability exists in the `VersionedGroupData` structure's handling of resource group tags. The `group_tags` field is a `DashMap<K, HashSet<T>>` that maintains a superset of all tags encountered for each resource group. [1](#0-0) 

Tags are added to this HashSet during base value initialization [2](#0-1)  and during transaction writes. [3](#0-2) [4](#0-3) 

**Critical Issue:** Tags are NEVER removed from `group_tags`, even when resources are deleted. The `remove()` and `remove_v2()` methods only remove entries from `values` and `group_sizes`, but not from `group_tags`. [5](#0-4) [6](#0-5)  The `remove_impl` function only touches the `values` field. [7](#0-6) 

**Attack Vector:**

Resource group writes count as a single write operation regardless of the number of inner tags. The `num_write_ops()` method counts entries in `resource_write_set`, not the inner operations within each `GroupWrite`. [8](#0-7)  Each `GroupWrite` contains an `inner_ops` field with multiple tags, [9](#0-8)  but the entire group counts as one entry in the resource write set.

This means:
- The `max_write_ops_per_transaction` limit of 8,192 [10](#0-9)  doesn't constrain tags within a group
- Only the `max_bytes_all_write_ops_per_transaction` limit of 10MB applies [11](#0-10) 
- With minimal tag+value pairs (~100 bytes each), an attacker can write ~100,000 tags per transaction
- Across a block with multiple transactions, millions of unique tags could accumulate

**Exploitation Steps:**

1. Attacker creates transactions that write to a resource group with many different tags
2. Each transaction uses minimal-sized StructTags and values to maximize tag count within 10MB limit
3. Tags accumulate in `group_tags` HashSet throughout block execution
4. Memory consumption grows linearly: ~100-150 bytes per tag in memory
5. With 1-10 million unique tags, memory consumption reaches 150MB-1.5GB per block
6. This occurs on all validator nodes processing the block

The `finalize_group()` method must iterate over all accumulated tags, exacerbating the performance impact. [12](#0-11) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "Validator node slowdowns" category.

While the memory is freed after block completion (since a new `VersionedGroupData` is created per block via `MVHashMap::new()`), [13](#0-12) [14](#0-13)  the impact during block execution includes:

- **Validator Performance Degradation**: Excessive memory allocation causes garbage collection pressure, CPU cache thrashing, and slower block processing
- **Consensus Delays**: If validators experience significant slowdowns, block confirmation times increase, affecting network liveness
- **Resource Exhaustion**: On memory-constrained validator nodes, this could trigger OOM conditions
- **Amplification Attack**: The attacker's economic cost (gas fees) is proportional to bytes written, not to the memory overhead imposed on validators

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" - while gas is charged for bytes, the memory overhead of tag tracking is not adequately priced.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is feasible because:

1. **No Technical Barriers**: Any user can submit transactions writing to resource groups
2. **Economic Feasibility**: While gas costs apply, they're based on bytes written, not memory overhead
3. **Deterministic Impact**: The memory consumption is predictable and guaranteed
4. **No Rate Limiting**: No specific protection against writing many unique tags

However, mitigating factors include:

1. **Block Gas Limits**: Constrain total transactions per block
2. **Economic Cost**: Attacker must pay gas for all transactions
3. **Temporary Effect**: Memory is freed after each block

The attack becomes more likely if gas costs are low relative to validator hardware costs, or if the attacker's goal is disruption rather than profit.

## Recommendation

Implement a mechanism to remove deleted tags from `group_tags` during the `remove()` and `remove_v2()` operations, or add a limit on the maximum number of unique tags that can accumulate in `group_tags` per resource group per block. Alternatively, implement a tag count limit in the gas schedule that constrains the number of unique tags per resource group write.

## Proof of Concept

A complete PoC would involve creating a Move module that writes to a resource group with many unique tags within a single transaction, then submitting multiple such transactions in a block. The memory consumption can be observed by monitoring validator memory usage during block execution. The core vulnerability is demonstrated by the code paths showing tags are added but never removed from `group_tags`.

## Notes

The code comments explicitly state that `group_tags` maintains "a superset of all tags encountered in group related APIs" [15](#0-14)  indicating this is intentional behavior for correctness during parallel execution. However, this design creates a resource consumption vulnerability when exploited with many unique tags. The `finalize_group` method filters out deleted tags at finalization time, but the memory overhead persists throughout block execution.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L83-86)
```rust
    // Stores a set of tags for this group, basically a superset of all tags encountered in
    // group related APIs. The accesses are synchronized with group size entry (for now),
    // but it is stored separately for conflict free read-path for txn materialization
    // (as the contents of group_tags are used in preparing finalized group contents).
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L92-92)
```rust
    group_tags: DashMap<K, HashSet<T>>,
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L138-144)
```rust
    pub(crate) fn empty() -> Self {
        Self {
            values: VersionedData::empty(),
            group_sizes: DashMap::new(),
            group_tags: DashMap::new(),
        }
    }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L175-177)
```rust
            let mut superset_tags = self.group_tags.entry(group_key.clone()).or_default();
            for (tag, value) in base_values.into_iter() {
                superset_tags.insert(tag.clone());
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L339-358)
```rust
    pub fn remove(&self, group_key: &K, txn_idx: TxnIndex, tags: HashSet<T>) {
        self.remove_impl::<false>(
            group_key,
            txn_idx,
            tags.iter().collect(),
            &mut RegisteredReadDependencies::new(),
        )
        .expect("remove_impl with V1 never fails");

        // TODO: consider setting size_has_changed flag if e.g. the size observed
        // after remove is different.
        assert_some!(
            self.group_sizes
                .get_mut(group_key)
                .expect("Path must exist")
                .size_entries
                .remove(&ShiftedTxnIndex::new(txn_idx)),
            "Entry for the txn must exist to be deleted"
        );
    }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L360-408)
```rust
    pub fn remove_v2(
        &self,
        group_key: &K,
        txn_idx: TxnIndex,
        tags: HashSet<&T>,
    ) -> Result<BTreeMap<TxnIndex, Incarnation>, PanicError> {
        let mut invalidated_dependencies = RegisteredReadDependencies::new();
        self.remove_impl::<true>(group_key, txn_idx, tags, &mut invalidated_dependencies)?;

        let mut group_sizes = self.group_sizes.get_mut(group_key).ok_or_else(|| {
            code_invariant_error(format!(
                "Group sizes at key {:?} must exist for remove_v2",
                group_key
            ))
        })?;
        let removed_size_entry = group_sizes
            .size_entries
            .remove(&ShiftedTxnIndex::new(txn_idx))
            .ok_or_else(|| {
                code_invariant_error(format!(
                    "Group size entry at key {:?} for the txn {} must exist for remove_v2",
                    group_key, txn_idx
                ))
            })?;

        // Handle dependencies for the removed size entry.
        let mut removed_size_deps = take_dependencies(&removed_size_entry.value.dependencies);
        if let Some((_, next_lower_entry)) = Self::get_latest_entry(
            &group_sizes.size_entries,
            txn_idx,
            ReadPosition::BeforeCurrentTxn,
        ) {
            // If the entry that will be read after removal contains the same size,
            // then the dependencies on size can be registered there and not invalidated.
            // In this case, removed_size_deps gets drained.
            if next_lower_entry.value.size == removed_size_entry.value.size {
                next_lower_entry
                    .value
                    .dependencies
                    .lock()
                    .extend_with_higher_dependencies(std::mem::take(&mut removed_size_deps))?;
            }
        }

        // If removed_size_deps was not drained (into the preceding entry's dependencies),
        // then those dependencies also need to be invalidated.
        invalidated_dependencies.extend(removed_size_deps);
        Ok(invalidated_dependencies.take())
    }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L531-549)
```rust
        let superset_tags = self
            .group_tags
            .get(group_key)
            .expect("Group tags must be set")
            .clone();

        let committed_group = superset_tags
            .into_iter()
            .map(
                |tag| match self.fetch_tagged_data_no_record(group_key, &tag, txn_idx + 1) {
                    Ok((_, value)) => Ok((value.write_op_kind() != WriteOpKind::Deletion)
                        .then(|| (tag, value.clone()))),
                    Err(MVGroupError::TagNotFound) => Ok(None),
                    Err(e) => Err(code_invariant_error(format!(
                        "Unexpected error in finalize group fetching value {:?}",
                        e
                    ))),
                },
            )
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L592-608)
```rust
    fn remove_impl<const V2: bool>(
        &self,
        group_key: &K,
        txn_idx: TxnIndex,
        tags: HashSet<&T>,
        invalidated_deps: &mut RegisteredReadDependencies,
    ) -> Result<(), PanicError> {
        for tag in tags {
            let key_ref = GroupKeyRef { group_key, tag };
            if V2 {
                invalidated_deps.extend(self.values.remove_v2::<_, false>(&key_ref, txn_idx)?);
            } else {
                self.values.remove(&key_ref, txn_idx);
            }
        }
        Ok(())
    }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L635-638)
```rust
            for (tag, (value, layout)) in values.into_iter() {
                if !superset_tags.contains(&tag) {
                    tags_to_write.push(tag.clone());
                }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L662-668)
```rust
        if !tags_to_write.is_empty() {
            // We extend here while acquiring a write access (implicit lock), while the
            // processing above only requires a read access.
            self.group_tags
                .get_mut(group_key)
                .expect("Group must be initialized")
                .extend(tags_to_write);
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L856-860)
```rust
    fn num_write_ops(&self) -> usize {
        // Note: we only use resources and aggregators because they use write ops directly,
        // and deltas & events are not part of these.
        self.resource_write_set().len() + self.aggregator_v1_write_set().len()
    }
```

**File:** aptos-move/aptos-vm-types/src/abstract_write_op.rs (L166-166)
```rust
    pub(crate) inner_ops: BTreeMap<StructTag, (WriteOp, Option<TriompheArc<MoveTypeLayout>>)>,
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L159-161)
```rust
            max_bytes_all_write_ops_per_transaction: NumBytes,
            { 5.. => "max_bytes_all_write_ops_per_transaction" },
            10 << 20, // all write ops from a single transaction are 10MB max
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L174-176)
```rust
            max_write_ops_per_transaction: NumSlots,
            { 11.. => "max_write_ops_per_transaction" },
            8192,
```

**File:** aptos-move/block-executor/src/executor.rs (L1741-1741)
```rust
        let mut versioned_cache = MVHashMap::new();
```
