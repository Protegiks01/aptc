# Audit Report

## Title
Unauthenticated Metrics Scraping Enables MITM Injection of Fake Consensus Health Data

## Summary
The Node Health Checker's `ConsensusTimeoutsChecker` scrapes metrics over unauthenticated HTTP connections without validating the metrics source identity. A man-in-the-middle attacker can inject arbitrary consensus timeout metrics, causing the checker to make incorrect health assessments about validator nodes.

## Finding Description

The `ConsensusTimeoutsChecker.check()` function obtains metrics from target nodes through an unauthenticated HTTP client that lacks any mechanism to verify the metrics source is legitimate. [1](#0-0) 

The metrics provider is created via `get_metrics_client()` which builds a basic `reqwest::Client` with no authentication or TLS certificate validation: [2](#0-1) 

The metrics scraping itself is a plain HTTP GET request without any signature verification or authentication: [3](#0-2) 

The inspection service serves metrics over plain HTTP without requiring any credentials: [4](#0-3) [5](#0-4) 

**Attack Path:**
1. Node operator submits their node URL (typically `http://node.example.com:9101`) to Node Health Checker for qualification (e.g., AIT participation)
2. Attacker positions themselves on the network path between NHC and the target node
3. When NHC scrapes `/metrics`, attacker intercepts the HTTP request
4. Attacker responds with fabricated `aptos_consensus_timeout_count` values
5. NHC makes health assessment decisions based on fake data

**Malicious Scenarios:**
- **Healthy node appears unhealthy**: Inject increasing timeout counts → node rejected from validator set
- **Unhealthy node appears healthy**: Inject low/static timeout counts → node with real consensus issues passes qualification

This breaks the trust model where NHC results are used for critical validator qualification decisions in Aptos Incentivized Testnets and network operations monitoring.

## Impact Explanation

This vulnerability enables **significant protocol violations** (High severity per Aptos bug bounty) by undermining the integrity of validator qualification processes:

1. **Adversary infiltration**: Malicious actors can make their dysfunctional nodes appear healthy, gaining entry to validator sets where they can later attack consensus
2. **Denial of service**: Legitimate validators can be falsely flagged as unhealthy, preventing their participation in the network
3. **Monitoring compromise**: Network operators receive misleading health data, potentially masking real consensus issues or triggering false alerts

While this doesn't directly break blockchain consensus, it compromises the operational security layer that protects validator set integrity. Other parts of the codebase demonstrate proper TLS validation practices that node-checker should adopt: [6](#0-5) 

## Likelihood Explanation

**High likelihood** in realistic deployment scenarios:

- Node-checker is designed to assess **untrusted third-party nodes** across the internet
- Metrics endpoints default to HTTP (as shown in node configuration output)
- No authentication mechanism exists at any layer (client, transport, or application)
- MITM positioning is feasible in many network topologies (ISP-level, compromised routers, DNS hijacking)
- The attack requires no special privileges or validator access

The vulnerability is inherent in the current architecture - every metrics scrape is vulnerable.

## Recommendation

Implement mutual TLS authentication with certificate validation for metrics scraping:

```rust
// In ecosystem/node-checker/src/configuration/node_address.rs
pub fn get_metrics_client(&self, timeout: Duration) -> Result<reqwest::Client> {
    match self.metrics_port {
        Some(_) => {
            let client = reqwest::ClientBuilder::new()
                .timeout(timeout)
                .cookie_provider(self.cookie_store.clone())
                .tls_built_in_root_certs(true)  // Enable certificate validation
                .https_only(true)  // Reject non-HTTPS connections
                .build()
                .context("Failed to build metrics client")?;
            Ok(client)
        },
        None => Err(anyhow!("Cannot build metrics client without a metrics port")),
    }
}
```

Additionally:
1. Serve metrics over HTTPS with valid certificates in production environments
2. Implement cryptographic signing of metrics payloads with validator identity keys
3. Add cross-validation by comparing metrics against on-chain state (e.g., committed block heights)
4. Document security requirements for node operators submitting to NHC

## Proof of Concept

```rust
// Demonstration of MITM attack on node-checker metrics scraping
// Place this in ecosystem/node-checker/src/bin/

use tokio::net::TcpListener;
use hyper::{Body, Request, Response, Server};
use hyper::service::{make_service_fn, service_fn};

#[tokio::main]
async fn main() {
    // MITM server that intercepts metrics requests
    let addr = ([127, 0, 0, 1], 9101).into();
    
    let make_svc = make_service_fn(|_conn| async {
        Ok::<_, hyper::Error>(service_fn(fake_metrics_handler))
    });
    
    let server = Server::bind(&addr).serve(make_svc);
    println!("MITM server running on {}", addr);
    
    if let Err(e) = server.await {
        eprintln!("Server error: {}", e);
    }
}

async fn fake_metrics_handler(_req: Request<Body>) -> Result<Response<Body>, hyper::Error> {
    // Inject fake consensus timeout metrics
    let fake_metrics = r#"
# HELP aptos_consensus_timeout_count Number of consensus timeouts
# TYPE aptos_consensus_timeout_count counter
aptos_consensus_timeout_count 0
"#;
    
    Ok(Response::new(Body::from(fake_metrics)))
}

// When node-checker scrapes this MITM server, it receives fake metrics
// showing zero timeouts, making even a broken node appear healthy
```

**Notes:**
- The lack of authentication affects ALL checkers that rely on `MetricsProvider`, not just `ConsensusTimeoutsChecker`
- Similar vulnerabilities exist in `ConsensusRoundChecker`, `TpsChecker`, and other metrics-based health checks
- The codebase already has examples of proper TLS validation (governance metadata fetching) but node-checker doesn't use them
- This is an ecosystem tool vulnerability that impacts validator operational security rather than core consensus protocol

### Citations

**File:** ecosystem/node-checker/src/checker/consensus_timeouts.rs (L95-133)
```rust
    async fn check(
        &self,
        providers: &ProviderCollection,
    ) -> Result<Vec<CheckResult>, CheckerError> {
        let target_metrics_provider = get_provider!(
            providers.target_metrics_provider,
            self.config.common.required,
            MetricsProvider
        );

        let first_scrape = match target_metrics_provider.provide().await {
            Ok(scrape) => scrape,
            Err(e) => {
                return Ok(vec![Self::build_result(
                    "Failed to check consensus timeouts".to_string(),
                    0,
                    format!(
                        "Failed to scrape metrics from your node (1st time): {:#}",
                        e
                    ),
                )])
            },
        };

        tokio::time::sleep(target_metrics_provider.config.common.check_delay()).await;

        let second_scrape = match target_metrics_provider.provide().await {
            Ok(scrape) => scrape,
            Err(e) => {
                return Ok(vec![Self::build_result(
                    "Failed to check consensus timeouts".to_string(),
                    0,
                    format!(
                        "Failed to scrape metrics from your node (2nd time): {:#}",
                        e
                    ),
                )])
            },
        };
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L94-105)
```rust
    pub fn get_metrics_client(&self, timeout: Duration) -> Result<reqwest::Client> {
        match self.metrics_port {
            Some(_) => Ok(reqwest::ClientBuilder::new()
                .timeout(timeout)
                .cookie_provider(self.cookie_store.clone())
                .build()
                .unwrap()),
            None => Err(anyhow!(
                "Cannot build metrics client without a metrics port"
            )),
        }
    }
```

**File:** ecosystem/node-checker/src/provider/metrics.rs (L59-85)
```rust
    pub async fn get_scrape(&self) -> Result<Scrape, ProviderError> {
        let response = self
            .client
            .get(self.metrics_url.clone())
            .send()
            .await
            .with_context(|| format!("Failed to get data from {}", self.metrics_url))
            .map_err(|e| ProviderError::RetryableEndpointError("/metrics", e))?;
        let body = response
            .text()
            .await
            .with_context(|| {
                format!(
                    "Failed to process response body from {} as text",
                    self.metrics_url
                )
            })
            .map_err(|e| ProviderError::ParseError(anyhow!(e)))?;
        Scrape::parse(body.lines().map(|l| Ok(l.to_string())))
            .with_context(|| {
                format!(
                    "Failed to parse response text from {} as a Prometheus scrape",
                    self.metrics_url
                )
            })
            .map_err(|e| ProviderError::ParseError(anyhow!(e)))
    }
```

**File:** aptos-node/src/lib.rs (L359-362)
```rust
    println!(
        "\tMetrics endpoint: http://{}:{}/metrics",
        &config.inspection_service.address, &config.inspection_service.port
    );
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L142-146)
```rust
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
```

**File:** crates/aptos/src/governance/mod.rs (L420-425)
```rust
/// Retrieve the Metadata from the given URL
async fn get_metadata_from_url(metadata_url: &Url) -> CliTypedResult<Vec<u8>> {
    let client = reqwest::ClientBuilder::default()
        .tls_built_in_root_certs(true)
        .build()
        .map_err(|err| CliError::UnexpectedError(format!("Failed to build HTTP client {}", err)))?;
```
