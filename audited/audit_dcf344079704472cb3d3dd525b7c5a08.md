# Audit Report

## Title
Authorization Scheme Validation Bypass in Aptos Faucet Auth Token Bypasser

## Summary
The `request_can_bypass()` function in the `AuthTokenBypasser` does not validate that the Authorization header uses the "Bearer" scheme specifically. Any authorization scheme (Basic, Digest, or custom schemes) can bypass security checks if the token portion matches an allowlisted value, enabling unauthorized access to privileged faucet operations.

## Finding Description

The `AuthTokenBypasser` is designed to allow certain requests to bypass all security checkers (rate limiting, CAPTCHA, IP blocklists, referer blocklists) and access higher funding limits. It validates requests by extracting a token from the Authorization header and checking it against an allowlist. [1](#0-0) 

The vulnerability lies in how the token is extracted. The code splits the Authorization header by whitespace and takes the second element without verifying the first element is "Bearer". This means:

- `Authorization: Bearer abc123` → extracts `abc123` ✓ (intended)
- `Authorization: Basic abc123` → extracts `abc123` ✓ (bypass!)
- `Authorization: Digest abc123` → extracts `abc123` ✓ (bypass!)
- `Authorization: CustomScheme abc123` → extracts `abc123` ✓ (bypass!)

The system documentation and error messages explicitly expect the "Bearer" scheme: [2](#0-1) 

When a bypasser allows a request to bypass checks, the request skips all security validations and can receive elevated privileges: [3](#0-2) 

Additionally, bypassed requests can access higher funding amounts: [4](#0-3) 

**Attack Scenario:**
1. Attacker obtains a valid bypass token (through interception, leaked configuration, or social engineering)
2. Instead of using `Authorization: Bearer <token>`, attacker uses `Authorization: Basic <token>` or any other scheme
3. The bypasser extracts the token portion and validates it successfully
4. All rate limiting, CAPTCHA, IP blocks, and referer checks are bypassed
5. Attacker can drain the faucet or cause denial of service through resource exhaustion

## Impact Explanation

This vulnerability is classified as **High Severity** based on Aptos bug bounty criteria:

- **API functionality compromise**: Allows bypass of multiple security controls (rate limiting, CAPTCHA, IP/referer blocklists)
- **Resource exhaustion**: Enables unlimited requests that can drain faucet funds or cause service degradation
- **Significant protocol violation**: Breaks the intended authorization model where only Bearer tokens should be accepted

While the faucet distributes test tokens without direct monetary value, the service availability is critical for testnet/devnet operations. Draining the faucet or making it unavailable disrupts developer workflows and blockchain testing infrastructure.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires:
- Knowledge of a valid bypass token (feasible through configuration leaks, network interception, or insider knowledge)
- Simple HTTP request with modified Authorization scheme (trivial to execute)

No special privileges, infrastructure access, or complex exploitation techniques are needed. Once a token is obtained, the attack is straightforward and repeatable.

## Recommendation

Validate that the Authorization header uses the "Bearer" scheme specifically before extracting the token:

```rust
async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
    // Don't check if the request has X_IS_JWT_HEADER set.
    if data.headers.contains_key(X_IS_JWT_HEADER) {
        return Ok(false);
    }

    let auth_header = match data
        .headers
        .get(AUTHORIZATION)
        .and_then(|v| v.to_str().ok())
    {
        Some(header) => header,
        None => return Ok(false),
    };

    // Validate Bearer scheme
    if !auth_header.starts_with("Bearer ") {
        return Ok(false);
    }

    let auth_token = match auth_header.strip_prefix("Bearer ").map(|s| s.trim()) {
        Some(token) if !token.is_empty() => token,
        _ => return Ok(false),
    };

    Ok(self.manager.contains(auth_token))
}
```

Apply the same fix to `AuthTokenChecker::check()` in `checkers/auth_token.rs`: [5](#0-4) 

## Proof of Concept

```rust
#[tokio::test]
async fn test_authorization_scheme_bypass() {
    use poem::http::HeaderMap;
    use std::sync::Arc;
    
    // Setup: Create bypasser with token "test_token" in allowlist
    let config = ListManagerConfig {
        values: Some(vec!["test_token".to_string()]),
        file_path: None,
    };
    let bypasser = AuthTokenBypasser::new(config).unwrap();
    
    let mut headers = HeaderMap::new();
    headers.insert("source-ip", "127.0.0.1".parse().unwrap());
    
    let checker_data = CheckerData {
        source_ip: "127.0.0.1".to_string(),
        receiver: AccountAddress::ZERO,
        headers: Arc::new(headers.clone()),
        time_request_received_secs: 0,
    };
    
    // Test 1: Bearer scheme (intended) - should pass
    headers.insert(AUTHORIZATION, "Bearer test_token".parse().unwrap());
    let result1 = bypasser.request_can_bypass(CheckerData {
        headers: Arc::new(headers.clone()),
        ..checker_data.clone()
    }).await.unwrap();
    assert!(result1, "Bearer token should bypass");
    
    // Test 2: Basic scheme (vulnerability) - currently passes, should fail
    headers.insert(AUTHORIZATION, "Basic test_token".parse().unwrap());
    let result2 = bypasser.request_can_bypass(CheckerData {
        headers: Arc::new(headers.clone()),
        ..checker_data.clone()
    }).await.unwrap();
    assert!(result2, "VULNERABILITY: Basic scheme bypasses check!");
    
    // Test 3: Digest scheme (vulnerability) - currently passes, should fail
    headers.insert(AUTHORIZATION, "Digest test_token".parse().unwrap());
    let result3 = bypasser.request_can_bypass(CheckerData {
        headers: Arc::new(headers.clone()),
        ..checker_data.clone()
    }).await.unwrap();
    assert!(result3, "VULNERABILITY: Digest scheme bypasses check!");
    
    // Test 4: Custom scheme (vulnerability) - currently passes, should fail
    headers.insert(AUTHORIZATION, "MaliciousScheme test_token".parse().unwrap());
    let result4 = bypasser.request_can_bypass(CheckerData {
        headers: Arc::new(headers.clone()),
        ..checker_data.clone()
    }).await.unwrap();
    assert!(result4, "VULNERABILITY: Custom scheme bypasses check!");
}
```

## Notes

This vulnerability also affects `AuthTokenChecker` which has identical scheme validation logic. Both components should be fixed to properly validate the "Bearer" scheme. The issue breaks the access control invariant that only properly authenticated Bearer token requests should bypass security controls or pass authentication checks.

### Citations

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L32-49)
```rust
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(false);
        }

        let auth_token = match data
            .headers
            .get(AUTHORIZATION)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.split_whitespace().nth(1))
        {
            Some(auth_token) => auth_token,
            None => return Ok(false),
        };

        Ok(self.manager.contains(auth_token))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L42-53)
```rust
        let auth_token = match data
            .headers
            .get(AUTHORIZATION)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.split_whitespace().nth(1))
        {
            Some(auth_token) => auth_token,
            None => return Ok(vec![RejectionReason::new(
                "Either the Authorization header is missing or it is not in the form of 'Bearer <token>'".to_string(),
                RejectionReasonCode::AuthTokenInvalid,
            )]),
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L244-259)
```rust
        // See if this request meets the criteria to bypass checkers / storage.
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L173-185)
```rust
    /// If a Bypasser let the request bypass the Checkers and
    /// maximum_amount_with_bypass is set, this function will return
    /// that. Otherwise it will return maximum_amount.
    pub fn get_maximum_amount(
        &self,
        // True if a Bypasser let the request bypass the Checkers.
        did_bypass_checkers: bool,
    ) -> Option<u64> {
        match (self.maximum_amount_with_bypass, did_bypass_checkers) {
            (Some(max), true) => Some(max),
            _ => self.maximum_amount,
        }
    }
```
