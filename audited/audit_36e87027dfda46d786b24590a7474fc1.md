# Audit Report

## Title
Symlink Following in Package Digest Computation Enables Integrity Bypass and Information Disclosure

## Summary
The `compute_digest()` function follows symbolic links without validation when computing package digests, allowing attackers to manipulate digest values and potentially access sensitive files on developers' systems through malicious git dependencies.

## Finding Description

The package digest computation system has a critical flaw in how it processes source files. While the security question asks about config-based path manipulation, the investigation reveals that **BuildConfig does not directly control source paths** [1](#0-0) . Source paths are hardcoded from `SourcePackageLayout` enum values (Sources, Scripts, Examples, Tests), with only `dev_mode` affecting whether optional directories are included.

However, a more severe vulnerability exists: the `compute_digest()` function unconditionally follows symbolic links when traversing directories [2](#0-1) . This same behavior exists in `find_move_filenames()` [3](#0-2) .

**Attack Vector:**

1. Attacker publishes a malicious Move package to a git repository
2. The package contains symlinks in `sources/` directory pointing to:
   - Files outside the package directory to manipulate digest values
   - Sensitive system files (e.g., `~/.ssh/id_rsa`, `~/.aws/credentials`)
3. Developer adds this as a dependency and builds their package
4. During build, `get_package_digest_for_config()` is called [4](#0-3) 
5. The digest computation follows symlinks and reads arbitrary files
6. Dependency digest verification in `process_dependency()` can be bypassed [5](#0-4) 

**No Validation Exists:** Grep search confirms zero symlink validation in the entire move-package codebase.

## Impact Explanation

This qualifies as **High Severity** under Aptos bug bounty criteria:

1. **Significant Protocol Violation**: Package integrity verification is a core security guarantee. The `source_digest` field in `PackageMetadata` is used for on-chain verification [6](#0-5)  and dependency validation [7](#0-6) . Bypassing this breaks Critical Invariant #10 (Cryptographic Correctness).

2. **Information Disclosure**: Unauthorized file access during build violates least privilege principle. While digest values don't directly leak file contents, this enables reconnaissance attacks.

3. **Supply Chain Risk**: Malicious dependencies can compromise the build process of dependent packages, affecting the broader Aptos ecosystem.

4. **Deterministic Build Violation**: Breaks Critical Invariant #1 (Deterministic Execution) - different developers building the same package get different digests based on their filesystem.

## Likelihood Explanation

**High Likelihood:**
- Git dependencies are a standard practice in Move development
- No warnings or validation alerts developers to this risk
- Social engineering can easily trick developers into adding malicious dependencies
- Attack requires no privileged access or validator collusion
- Symlinks are legitimate filesystem features that won't trigger suspicion
- Attack is silent - developers won't notice until verification failures occur

## Recommendation

**Immediate Fix: Disable symlink following in digest computation and file discovery**

```rust
// In third_party/move/tools/move-package/src/resolution/digest.rs
pub fn compute_digest(paths: &[PathBuf]) -> Result<PackageDigest> {
    let mut hashed_files = Vec::new();
    let mut hash = |path: &Path| {
        // ADD: Validate path is not a symlink
        if path.is_symlink() {
            bail!("Symlinks are not allowed in package sources: {}", path.display());
        }
        let contents = std::fs::read(path)?;
        hashed_files.push(format!("{:X}", Sha256::digest(&contents)));
        Ok(())
    };
    // ... rest of function
    for entry in walkdir::WalkDir::new(path)
        .follow_links(false)  // CHANGE: Disable symlink following
        .into_iter()
        .filter_map(|e| e.ok())
    {
        if entry.file_type().is_file() {
            maybe_hash_file(entry.path())?
        }
    }
}
```

**Secondary Fix: Add validation in find_move_filenames** [3](#0-2) 

Change `follow_links(true)` to `follow_links(false)` and add explicit symlink rejection.

## Proof of Concept

```bash
# Create malicious package with symlinks
mkdir -p malicious_package/sources
cd malicious_package

# Create Move.toml
cat > Move.toml << 'EOF'
[package]
name = "MaliciousPackage"
version = "1.0.0"

[addresses]
malicious = "0x42"
EOF

# Create symlink to sensitive file
ln -s ~/.ssh/id_rsa sources/stolen.move

# Create actual move file
cat > sources/real.move << 'EOF'
module malicious::test {
    public fun dummy() {}
}
EOF

# When this package is built, compute_digest() will:
# 1. Follow the symlink to ~/.ssh/id_rsa
# 2. Read and hash the private key
# 3. Include it in the package digest
# 4. Developer unknowingly exposes information about their system

# Verify the vulnerability
cd ..
mkdir -p victim_package/sources
cd victim_package

cat > Move.toml << 'EOF'
[package]
name = "VictimPackage"
version = "1.0.0"

[dependencies]
MaliciousPackage = { local = "../malicious_package" }
EOF

# Build will succeed but digest includes external files
aptos move compile --save-metadata
# Digest will be different on different machines
# depending on what ~/.ssh/id_rsa contains
```

## Notes

While the original security question specifically asked about **config-based path manipulation**, the investigation reveals that BuildConfig does NOT control source paths directly - they are hardcoded from SourcePackageLayout. However, this investigation uncovered a more severe vulnerability: unchecked symlink following in digest computation that enables integrity bypass and information disclosure attacks through malicious dependencies. This represents a significant supply chain security risk in the Move package ecosystem.

### Citations

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L456-472)
```rust
        match dep.digest {
            None => (),
            Some(fixed_digest) => {
                let resolved_pkg = self
                    .package_table
                    .get(&dep_name_in_pkg)
                    .context("Unable to find resolved package by name")?;
                if fixed_digest != resolved_pkg.source_digest {
                    bail!(
                        "Source digest mismatch in dependency '{}'. Expected '{}' but got '{}'.",
                        dep_name_in_pkg,
                        fixed_digest,
                        resolved_pkg.source_digest
                    )
                }
            },
        }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L652-673)
```rust
    fn get_source_paths_for_config(
        package_path: &Path,
        config: &BuildConfig,
    ) -> Result<Vec<PathBuf>> {
        let mut places_to_look = Vec::new();
        let mut add_path = |layout_path: SourcePackageLayout| {
            let path = package_path.join(layout_path.path());
            if layout_path.is_optional() && !path.exists() {
                return;
            }
            places_to_look.push(path)
        };

        add_path(SourcePackageLayout::Sources);
        add_path(SourcePackageLayout::Scripts);

        if config.dev_mode {
            add_path(SourcePackageLayout::Examples);
            add_path(SourcePackageLayout::Tests);
        }
        Ok(places_to_look)
    }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L684-691)
```rust
    fn get_package_digest_for_config(
        package_path: &Path,
        config: &BuildConfig,
    ) -> Result<PackageDigest> {
        let mut source_paths = Self::get_source_paths_for_config(package_path, config)?;
        source_paths.push(package_path.join(SourcePackageLayout::Manifest.path()));
        compute_digest(source_paths.as_slice())
    }
```

**File:** third_party/move/tools/move-package/src/resolution/digest.rs (L30-39)
```rust
            for entry in walkdir::WalkDir::new(path)
                .follow_links(true)
                .into_iter()
                .filter_map(|e| e.ok())
            {
                if entry.file_type().is_file() {
                    maybe_hash_file(entry.path())?
                }
            }
        }
```

**File:** third_party/move/move-command-line-common/src/files.rs (L80-84)
```rust
        for entry in walkdir::WalkDir::new(path)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok())
        {
```

**File:** aptos-move/framework/src/built_package.rs (L516-522)
```rust
    pub fn extract_metadata(&self) -> anyhow::Result<PackageMetadata> {
        let source_digest = self
            .package
            .compiled_package_info
            .source_digest
            .map(|s| s.to_string())
            .unwrap_or_default();
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L234-239)
```rust
        } else if self_metadata.source_digest != package_metadata.source_digest {
            bail!(
                "Source digests doesn't match {:?} : {:?}",
                package_metadata.source_digest,
                self_metadata.source_digest
            )
```
