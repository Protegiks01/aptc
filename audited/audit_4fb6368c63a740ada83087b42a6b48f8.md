# Audit Report

## Title
Transaction Version Sequence Validation Bypass in Indexer-GRPC Data Service

## Summary
The `fetch_transactions()` function in the indexer-grpc data service validates only the first transaction's version but accepts all subsequent transactions in a batch without verification. A compromised GrpcManager server can inject transactions with arbitrary version numbers, causing data corruption in the indexer cache and serving incorrect historical transaction data to downstream clients.

## Finding Description

The vulnerability exists in the transaction fetching and caching flow of the indexer-grpc-data-service-v2: [1](#0-0) 

The `DataClient::fetch_transactions()` only validates that the first transaction has the expected version, but accepts the entire batch without checking subsequent transactions. This batch is then passed to `DataManager::update_data()`: [2](#0-1) 

The `DataManager` stores transactions in a circular buffer by calculating their version as `start_version + array_index`, completely ignoring each transaction's actual `version` field defined in the protobuf: [3](#0-2) 

**Attack Scenario:**
1. Attacker compromises a GrpcManager server instance
2. When DataClient requests transactions starting from version 1000, the malicious server responds with:
   - Transaction[0].version = 1000 (passes validation)
   - Transaction[1].version = 9999 (not checked)
   - Transaction[2].version = 5555 (not checked)
3. DataManager stores these at slots calculated as [1000, 1001, 1002]
4. Future queries for version 1001 return the transaction that actually has version 9999
5. Downstream indexers and applications receive corrupted transaction history

The vulnerability violates the transaction version monotonicity guarantee documented in the protobuf specification, which states transactions are "ordered by a transactions monotonically increasing `version` field": [4](#0-3) 

## Impact Explanation

This vulnerability enables **data integrity attacks** on the indexer-grpc infrastructure with **High Severity** impact:

- **Significant Protocol Violations**: The indexer protocol's fundamental assumption of consecutive transaction versions is violated, breaking data integrity guarantees
- **Downstream Data Corruption**: Applications, analytics systems, and blockchain explorers consuming this data will operate on incorrect transaction history
- **Cache Poisoning**: The in-memory cache serves corrupted data until eviction, affecting all clients during that period
- **Silent Failures**: No error or warning is generated when corrupted data is stored or served

While this does not directly affect blockchain consensus or validator operations, it compromises the indexer infrastructure that many ecosystem applications depend on for accurate historical data. This fits the **High Severity** category of "Significant protocol violations" per the Aptos bug bounty program.

## Likelihood Explanation

**Likelihood: Medium-to-Low**

The attack requires:
- Compromising a GrpcManager server instance (requires insider access or infrastructure compromise)
- GrpcManager servers are typically operated by trusted entities (Aptos Foundation, validator operators)
- However, once compromised, exploitation is trivial and undetected

The security question explicitly mentions "malicious server," indicating this threat model is within scope despite requiring compromise of trusted infrastructure.

## Recommendation

Implement comprehensive version validation for all transactions in a batch:

```rust
pub(super) async fn fetch_transactions(&self, starting_version: u64) -> Vec<Transaction> {
    // ... existing code ...
    
    if let Ok(response) = response {
        let transactions = response.into_inner().transactions;
        if transactions.is_empty() {
            return vec![];
        }
        
        // Validate first transaction version
        if transactions.first().unwrap().version != starting_version {
            continue; // Retry with different server
        }
        
        // NEW: Validate all transactions have consecutive versions
        for (i, txn) in transactions.iter().enumerate() {
            let expected_version = starting_version + i as u64;
            if txn.version != expected_version {
                warn!(
                    "Version mismatch at index {}: expected {}, got {}",
                    i, expected_version, txn.version
                );
                // Discard batch and retry
                continue 'outer_loop; 
            }
        }
        
        return transactions;
    }
}
```

Additionally, add validation in `DataManager::update_data()` as defense-in-depth:

```rust
for (i, transaction) in transactions.into_iter().enumerate().skip(num_to_skip as usize) {
    let expected_version = start_version + i as u64;
    
    // NEW: Validate transaction version matches expected
    if transaction.version != expected_version {
        error!(
            "Transaction version mismatch: expected {}, got {}",
            expected_version, transaction.version
        );
        return; // Reject entire batch
    }
    
    // ... existing storage logic ...
}
```

## Proof of Concept

**Scenario:** Malicious GrpcManager serving corrupted batch

```rust
// Malicious GrpcManager response construction
let malicious_batch = vec![
    Transaction { version: 1000, /* ... */ }, // Passes single check
    Transaction { version: 9999, /* ... */ }, // Injected wrong version
    Transaction { version: 5555, /* ... */ }, // Injected wrong version
];

// DataClient accepts this because only first is checked
// Result: DataManager stores at slots [1000, 1001, 1002]
// But actual versions are [1000, 9999, 5555]

// Later query for version 1001:
let result = data_manager.get_data(1001); 
// Returns transaction with version=9999 (INCORRECT)
```

**Impact:** Clients querying for transaction at version 1001 receive transaction that actually belongs at version 9999, causing complete data corruption for that version range.

---

**Notes:**
- This vulnerability is specific to the indexer-grpc-data-service-v2 component
- The core blockchain consensus and validation layers are not affected
- The GrpcManager-side validation at [5](#0-4)  also only checks the first transaction
- Proper fix requires validation at both fetch and storage layers

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_client.rs (L37-38)
```rust
                if transactions.first().unwrap().version == starting_version {
                    return transactions;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L75-86)
```rust
        for (i, transaction) in transactions
            .into_iter()
            .enumerate()
            .skip(num_to_skip as usize)
        {
            let version = start_version + i as u64;
            let slot_index = version as usize % self.num_slots;
            if let Some(transaction) = self.data[slot_index].take() {
                size_decreased += transaction.encoded_len();
            }
            size_increased += transaction.encoded_len();
            self.data[version as usize % self.num_slots] = Some(Box::new(transaction));
```

**File:** protos/proto/aptos/transaction/v1/transaction.proto (L10-10)
```text
// A block on Aptos holds transactions in chronological order (ordered by a transactions monotonically increasing `version` field)
```

**File:** protos/proto/aptos/transaction/v1/transaction.proto (L40-42)
```text
message Transaction {
  aptos.util.timestamp.Timestamp timestamp = 1;
  uint64 version = 2 [jstype = JS_STRING];
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L359-363)
```rust
            let first_version = transactions.first().unwrap().version;
            ensure!(
                first_version == start_version,
                "Version doesn't match, something is wrong."
            );
```
