# Audit Report

## Title
Stale Verification Cache Allows Invalid Modules After Feature Flag Changes on Chains with gas_feature_version < 38

## Summary
The Move bytecode verifier uses a global static cache (`VERIFIED_MODULES_CACHE`) to avoid re-verifying modules, but the cache is keyed only by module hash without including verification configuration. On chains running `gas_feature_version < 38`, the cache is not flushed when verifier configuration changes (e.g., when feature flags like `enable_function_values` are toggled via governance), allowing modules verified under old rules to be incorrectly accepted under new rules, breaking the **Deterministic Execution** invariant and potentially causing consensus splits.

## Finding Description

The verification result caching system has a critical design flaw in how it handles configuration changes: [1](#0-0) 

The cache stores only module hashes (32-byte SHA3-256 of module bytes) as keys, with no consideration for the verification configuration used. [2](#0-1) 

When `build_locally_verified_module` is called, it checks if the module hash exists in the global cache. If found, verification is entirely skipped regardless of the current verification configuration.

The verification configuration can change dynamically through on-chain governance by toggling feature flags: [3](#0-2) 

These feature flags control whether certain bytecode features are allowed, such as `enable_function_values` for function closures and `enable_enum_types` for enum types.

The critical vulnerability is that cache invalidation only occurs on chains with sufficiently recent gas feature versions: [4](#0-3) 

On chains where `gas_feature_version < RELEASE_V1_34` (which equals 38), the verified module cache is **never flushed** when the verifier configuration changes. [5](#0-4) 

**Attack Scenario:**

1. Chain is running with `gas_feature_version < 38` and `enable_function_values = true`
2. Attacker publishes module `M` containing `PackClosure` bytecode instructions
3. Module `M` passes verification (function values are allowed) and its hash is cached globally
4. Governance proposes and executes a change to set `enable_function_values = false` via `change_feature_flags_for_next_epoch()`
5. New epoch begins with updated feature flags
6. Due to `gas_feature_version < 38`, the `VERIFIED_MODULES_CACHE` is NOT flushed
7. When any validator loads module `M` from storage (e.g., during block execution)
8. Cache check passes (hash is still present), verification is skipped
9. Module `M` with illegal `PackClosure` instructions is accepted, violating the new verifier configuration
10. Different nodes with different cache states may accept/reject the same module, causing consensus divergence

This breaks the **Deterministic Execution** invariant: validators will produce different results for the same blocks depending on their cache state, leading to chain splits.

## Impact Explanation

**Critical Severity** - This qualifies for the highest severity category for the following reasons:

1. **Consensus/Safety Violation**: Different validators can reach different conclusions about module validity based on cache state, directly violating consensus safety. This can cause non-recoverable chain splits requiring a hard fork.

2. **Deterministic Execution Broken**: The fundamental invariant that "all validators must produce identical state roots for identical blocks" is violated. Validators with warm caches will accept modules that validators with cold caches (or flushed caches) will reject.

3. **Feature Flag Bypass**: Security controls implemented via feature flags can be completely bypassed, allowing dangerous bytecode to execute even when the feature is disabled.

4. **Network Partition Risk**: As validators diverge on which modules are valid, the network can partition into incompatible subsets, requiring emergency intervention and potentially a hard fork to resolve.

This directly maps to the Critical Severity impact category: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Medium-High Likelihood** on affected chains:

**Affected Chains:**
- Any Aptos-based chain running `gas_feature_version < 38`
- This includes older testnet instances, private deployments, or forks that haven't upgraded
- While mainnet likely runs version 45 (latest), the vulnerability affects any chain in the ecosystem below version 38

**Attacker Requirements:**
- Ability to publish Move modules (standard transaction)
- Monitoring of governance proposals for feature flag changes (publicly visible)
- Timing the module publication around feature flag transitions (straightforward)
- No validator access or special privileges required

**Triggering Conditions:**
- Feature flag changes occur regularly through governance for protocol upgrades
- The vulnerability is automatically exploited whenever feature flags change, requiring no active attacker intervention after initial module publication
- Cache persistence across the configuration change is guaranteed since the cache is in-memory and only cleared on node restart or explicit flush

**Complexity:**
- Low technical complexity - just publish a module and wait for governance action
- No need for precise timing or complex exploit chains
- Exploitation is deterministic once conditions are met

The main limiting factor is the requirement that the chain be running `gas_feature_version < 38`. However, even one affected chain represents a critical security risk to that ecosystem.

## Recommendation

**Immediate Fix for gas_feature_version < 38 chains:**

1. Upgrade to gas_feature_version >= 38 to enable the cache flush protection
2. Manually flush the verified module cache after any feature flag change using: [6](#0-5) 

**Long-term Architectural Improvements:**

1. **Include verifier config hash in cache key**: Modify the cache to use `(module_hash, verifier_config_hash)` as the key instead of just `module_hash`. This would make the cache intrinsically safe against configuration changes.

```rust
// Modified cache structure
pub(crate) struct VerifiedModuleCache(Mutex<lru::LruCache<([u8; 32], [u8; 32]), ()>>);

pub(crate) fn contains(&self, module_hash: &[u8; 32], config_hash: &[u8; 32]) -> bool {
    verifier_cache_enabled() && self.0.lock().get(&(*module_hash, *config_hash)).is_some()
}
```

2. **Remove version gate on cache flush**: The cache flush logic should apply to ALL gas feature versions, not just >= 38:

```rust
// Remove the version check
let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
});
if flush_verifier_cache {
    RuntimeEnvironment::flush_verified_module_cache();
}
```

3. **Add cache version invalidation**: Serialize and hash the entire `VerifierConfig` into the environment hash, ensuring any config change forces environment invalidation and cache flush.

## Proof of Concept

```rust
// Proof of Concept demonstrating the vulnerability
// This would need to be run on a chain with gas_feature_version < 38

#[test]
fn test_stale_cache_accepts_invalid_module() {
    use aptos_types::on_chain_config::{FeatureFlag, Features};
    use move_bytecode_verifier::verify_module_with_config;
    use move_binary_format::file_format::Bytecode;
    
    // Step 1: Create environment with enable_function_values = true
    let mut features_enabled = Features::default();
    features_enabled.enable(FeatureFlag::ENABLE_FUNCTION_VALUES);
    
    let config_enabled = aptos_prod_verifier_config(
        37, // gas_feature_version < 38, no cache flush protection
        &features_enabled
    );
    
    // Step 2: Create a module with PackClosure instruction
    let mut module = create_test_module_with_function_values();
    let module_bytes = serialize_module(&module);
    let module_hash = sha3_256(&module_bytes);
    
    // Step 3: Verify with enable_function_values = true (should pass)
    let env_enabled = RuntimeEnvironment::new_with_config(
        vec![],
        VMConfig { verifier_config: config_enabled, ..Default::default() }
    );
    
    let result = env_enabled.build_locally_verified_module(
        Arc::new(module.clone()),
        module_bytes.len(),
        &module_hash,
    );
    assert!(result.is_ok(), "Module should verify with function values enabled");
    // Module hash is now cached in VERIFIED_MODULES_CACHE
    
    // Step 4: Change feature flags to disable function values
    let mut features_disabled = Features::default();
    features_disabled.disable(FeatureFlag::ENABLE_FUNCTION_VALUES);
    
    let config_disabled = aptos_prod_verifier_config(
        37, // Still < 38, cache NOT flushed
        &features_disabled
    );
    
    // Step 5: Create new environment with disable_function_values = false
    let env_disabled = RuntimeEnvironment::new_with_config(
        vec![],
        VMConfig { verifier_config: config_disabled, ..Default::default() }
    );
    
    // Step 6: Try to load the same module - should fail but doesn't due to cache
    let result = env_disabled.build_locally_verified_module(
        Arc::new(module),
        module_bytes.len(),
        &module_hash,
    );
    
    // BUG: This passes due to stale cache even though it should fail!
    assert!(result.is_ok(), "Module incorrectly accepted from stale cache");
    
    // Step 7: Verify that without cache, it would correctly fail
    RuntimeEnvironment::flush_verified_module_cache();
    let result_no_cache = env_disabled.build_locally_verified_module(
        Arc::new(module),
        module_bytes.len(),
        &module_hash,
    );
    assert!(result_no_cache.is_err(), "Module correctly rejected without cache");
}

fn create_test_module_with_function_values() -> CompiledModule {
    // Create a module containing PackClosure bytecode
    // This would contain actual Move bytecode with function value instructions
    // that are only valid when enable_function_values = true
    unimplemented!("Create module with PackClosure instruction")
}
```

**Notes:**

This vulnerability affects chains running gas_feature_version < 38. The fix was introduced at version 38 but the version gate means older chains remain vulnerable. Any chain upgrade path must ensure the verified module cache is explicitly flushed when crossing the version 38 boundary to prevent exploitation of pre-cached modules. The recommended long-term fix is to remove the version dependency entirely and include the verifier config hash in the cache key for intrinsic safety.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L13-13)
```rust
pub(crate) struct VerifiedModuleCache(Mutex<lru::LruCache<[u8; 32], ()>>);
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L184-198)
```rust
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L373-377)
```rust
    /// Flushes the global verified module cache. Should be used when verifier configuration has
    /// changed.
    pub fn flush_verified_module_cache() {
        VERIFIED_MODULES_CACHE.flush();
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-193)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    // Note: we reuse the `enable_function_values` flag to set various stricter limits on types.

    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
        _use_signature_checker_v2: true,
        sig_checker_v2_fix_script_ty_param_count,
        sig_checker_v2_fix_function_signatures,
        enable_enum_types,
        enable_resource_access_control,
        enable_function_values,
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
    }
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L117-125)
```rust
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L104-104)
```rust
    pub const RELEASE_V1_34: u64 = 38;
```
