# Audit Report

## Title
Consensus Config Deserialization Error Suppression Leading to Potential Consensus Divergence

## Summary
The `validator_txn_enabled` native function suppresses BCS deserialization errors and returns success with a default configuration instead of propagating the error, violating the VM's error handling contract and potentially causing consensus divergence during network upgrades or state corruption scenarios. [1](#0-0) 

## Finding Description
The Move VM documentation explicitly states that "an execution that causes an invariant violation would not return a NativeResult but return a PartialVMError error directly." [2](#0-1) 

However, the `validator_txn_enabled` native function violates this principle by catching all deserialization errors and converting them to successful results with default values. When `bcs::from_bytes` fails, the function uses `unwrap_or_default()` to return a configuration with validator transactions DISABLED rather than propagating the error. [3](#0-2) [4](#0-3) [5](#0-4) 

This function is called in critical consensus code path during governance reconfiguration: [6](#0-5) 

## Impact Explanation
This vulnerability enables consensus divergence during version upgrades or state corruption scenarios:

1. **Version Mismatch Scenario**: During a rolling upgrade, upgraded nodes may serialize `OnChainConsensusConfig` in a format incompatible with older nodes. Upgraded nodes successfully deserialize and proceed with correct consensus behavior, while old nodes fail deserialization, receive the default (validator txns disabled), and follow incorrect consensus paths.

2. **State Corruption**: If on-chain consensus config bytes become corrupted through storage bugs or malformed governance proposals, different validator implementations or versions may handle the corruption differently, causing some to use defaults while others potentially recover or fail differently.

This breaks the **Deterministic Execution** invariant: validators must produce identical state roots for identical blocks. It qualifies as **High Severity** under "Significant protocol violations" - consensus path divergence during epoch transitions can cause liveness failures or chain splits.

## Likelihood Explanation
**Likelihood: Medium**

This issue manifests during:
- Network upgrades with serialization format changes (common during major releases)
- Malformed consensus config updates via governance (rare but possible if proposal validation is insufficient)  
- Storage corruption affecting the `@aptos_framework::ConsensusConfig` resource

The aptos-framework's BCS native implementation demonstrates awareness of this pattern - it explicitly handles lazy loading vs. non-lazy loading modes differently to avoid error suppression: [7](#0-6) 

The consensus_config native lacks this sophistication, making error suppression more likely to cause issues.

## Recommendation
**Fix**: Propagate deserialization errors as PartialVMError instead of suppressing them:

```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes)
        .map_err(|e| SafeNativeError::InvariantViolation(
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message(format!("Failed to deserialize ConsensusConfig: {}", e))
        ))?;
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

This ensures deserialization failures halt execution consistently across all validators.

## Proof of Concept

```rust
#[test]
fn test_consensus_config_error_suppression() {
    use bcs;
    use aptos_types::on_chain_config::OnChainConsensusConfig;
    
    // Simulate corrupted or incompatible config bytes
    let invalid_bytes = vec![0xFF, 0xFF, 0xFF, 0xFF];
    
    // Current behavior: unwrap_or_default() hides the error
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&invalid_bytes)
        .unwrap_or_default();
    
    // Returns false (disabled) instead of propagating error
    assert_eq!(config.is_vtxn_enabled(), false);
    
    // This means different nodes could get different results:
    // - Nodes that successfully deserialize: actual config value
    // - Nodes that fail deserialize: false (default)
    // => Consensus divergence
}
```

**Notes**

The vulnerability demonstrates that native functions CAN catch errors and convert them to success, violating the documented error handling contract. While direct exploitation by unprivileged attackers is limited (requires state corruption or version mismatches), the consensus divergence risk during upgrades makes this a significant protocol robustness issue affecting the Deterministic Execution invariant.

### Citations

**File:** aptos-move/framework/src/natives/consensus_config.rs (L13-21)
```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).unwrap_or_default();
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

**File:** third_party/move/move-vm/types/src/natives/function.rs (L26-34)
```rust
/// Result of a native function execution requires charges for execution cost.
///
/// An execution that causes an invariant violation would not return a `NativeResult` but
/// return a `PartialVMError` error directly.
/// All native functions must return a `PartialVMResult<NativeResult>` where an `Err` is returned
/// when an error condition is met that should not charge for the execution. A common example
/// is a VM invariant violation which should have been forbidden by the verifier.
/// Errors (typically user errors and aborts) that are logically part of the function execution
/// must be expressed in a `NativeResult` with a cost and a VMStatus.
```

**File:** types/src/on_chain_config/consensus_config.rs (L147-149)
```rust
    pub fn default_if_missing() -> Self {
        Self::V0
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L162-166)
```rust
    pub fn enabled(&self) -> bool {
        match self {
            ValidatorTxnConfig::V0 => false,
            ValidatorTxnConfig::V1 { .. } => true,
        }
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L67-89)
```rust
    let layout = if context.get_feature_flags().is_lazy_loading_enabled() {
        // With lazy loading, propagate the error directly. This is because errors here are likely
        // from metering, so we should not remap them in any way. Note that makes it possible to
        // fail on constructing a very deep / large layout and not be charged, but this is already
        // the case for regular execution, so we keep it simple. Also, charging more gas after
        // out-of-gas failure in layout construction does not make any sense.
        //
        // Example:
        //   - Constructing layout runs into dependency limit.
        //   - We cannot do `context.charge(BCS_TO_BYTES_FAILURE)?;` because then we can end up in
        //     the state where out of gas and dependency limit are hit at the same time.
        context.type_to_type_layout(arg_type)?
    } else {
        match context.type_to_type_layout(arg_type) {
            Ok(layout) => layout,
            Err(_) => {
                context.charge(BCS_TO_BYTES_FAILURE)?;
                return Err(SafeNativeError::Abort {
                    abort_code: NFE_BCS_SERIALIZATION_FAILURE,
                });
            },
        }
    };
```
