# Audit Report

## Title
Stale State Value Index Schema Incompatibility Causes Pruning Failure After Node Downgrade

## Summary
When a node downgrades from sharding-enabled mode to non-sharding mode (or to a version without sharding support), historical stale state value indices become inaccessible due to schema incompatibility. This causes the pruning mechanism to fail, leading to unbounded database growth and eventual node failure due to disk exhaustion.

## Finding Description

The Aptos storage layer uses two different schemas for tracking stale state values depending on whether sharding is enabled:

1. **Non-sharded mode**: `StaleStateValueIndexSchema` stores full `StateKey` objects
   - Column family: `"stale_state_value_index"`
   - Key encoding: `stale_since_version (8 bytes) | version (8 bytes) | state_key (variable length)` [1](#0-0) 

2. **Sharded mode**: `StaleStateValueIndexByKeyHashSchema` stores only the hash of `StateKey`
   - Column family: `"stale_state_value_index_by_key_hash"`
   - Key encoding: `stale_since_version (8 bytes) | version (8 bytes) | state_key_hash (32 bytes)` [2](#0-1) 

The system conditionally writes to one schema or the other based on the `enable_sharding` flag: [3](#0-2) 

Similarly, the pruning logic conditionally reads from one schema or the other: [4](#0-3) 

**The Vulnerability**: When sharding is disabled, the `StateKvDb` uses the ledger database which only has the `STALE_STATE_VALUE_INDEX_CF_NAME` column family: [5](#0-4) [6](#0-5) 

If a node downgrades from sharded to non-sharded mode:
1. Historical indices exist in `STALE_STATE_VALUE_INDEX_BY_KEY_HASH_CF_NAME` in separate shard databases
2. The downgraded node's `StateKvDb` now points to `ledger_db`
3. The `ledger_db` does not contain the sharded column family
4. Pruning reads from `STALE_STATE_VALUE_INDEX_CF_NAME` which is empty or only has new entries
5. Historical stale state values are never pruned
6. Database grows unbounded until disk exhaustion

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:

- **Validator node slowdowns**: Unbounded database growth degrades I/O performance, slowing down state reads/writes
- **Significant protocol violations**: Pruning is a critical maintenance operation; its failure violates the storage layer's design invariants
- **Requires intervention**: Node operators must manually clean up the database or resync from scratch

While mainnet/testnet have safeguards that panic if sharding is not enabled, this vulnerability could still affect: [7](#0-6) 

1. **Private deployments** that don't enforce the sharding requirement
2. **Emergency rollbacks** where the panic might be bypassed to restore service
3. **Development/testing environments** running non-standard configurations

## Likelihood Explanation

**Likelihood: Medium-Low**

The vulnerability requires:
1. A node downgrade from sharded to non-sharded mode to occur
2. On mainnet/testnet, this is actively prevented by configuration validation
3. However, private deployments and emergency scenarios remain vulnerable

An attacker could potentially amplify the impact by:
1. Monitoring for announced rollback events
2. Submitting many state-changing transactions before the rollback
3. Creating numerous stale state values that won't be pruned post-downgrade
4. Accelerating database growth across the network

## Recommendation

**Solution 1: Implement Cross-Schema Migration**

Add logic to check both column families during pruning when the node detects a schema mismatch:

```rust
pub(in crate::pruner) fn prune(
    &self,
    current_progress: Version,
    target_version: Version,
) -> Result<()> {
    let mut batch = SchemaBatch::new();

    if self.state_kv_db.enabled_sharding() {
        // Current logic for sharded mode
        // ...
    } else {
        // Check if there are orphaned entries in the sharded schema
        // from a previous sharded configuration
        if self.has_sharded_indices() {
            self.migrate_sharded_indices_to_non_sharded(&mut batch)?;
        }
        
        // Continue with normal non-sharded pruning
        let mut iter = self
            .state_kv_db
            .metadata_db()
            .iter::<StaleStateValueIndexSchema>()?;
        // ... rest of existing logic
    }
    // ...
}
```

**Solution 2: Prevent Downgrades More Robustly**

Store a schema version marker in the database metadata and refuse to start if the current version is incompatible with the stored schema:

```rust
// In StateKvDb::new()
let stored_schema_version = self.get_schema_version()?;
if rocksdb_configs.enable_storage_sharding && stored_schema_version == SchemaVersion::NonSharded {
    panic!("Cannot enable sharding on a database with non-sharded schema. Migration required.");
}
if !rocksdb_configs.enable_storage_sharding && stored_schema_version == SchemaVersion::Sharded {
    panic!("Cannot disable sharding on a database with sharded schema. Migration required.");
}
```

**Solution 3: Universal Schema**

Future schema changes should use a single column family that can accommodate both formats, with a version tag in each key to identify the encoding format.

## Proof of Concept

**Reproduction Steps:**

1. Initialize a node with `enable_storage_sharding = true`
2. Run the node and execute transactions that create stale state values:
   ```bash
   # Node writes indices to STALE_STATE_VALUE_INDEX_BY_KEY_HASH_CF_NAME
   # in shard databases at: state_kv_db/shard_{0..15}/
   ```

3. Stop the node and modify configuration to disable sharding:
   ```yaml
   # In node config, comment out or bypass the panic check
   rocksdb_configs:
     enable_storage_sharding: false
   ```

4. Restart the node:
   ```rust
   // StateKvDb::new() with enable_storage_sharding = false
   // Returns early, using ledger_db for all operations
   // ledger_db does not have STALE_STATE_VALUE_INDEX_BY_KEY_HASH_CF_NAME
   ```

5. Trigger pruning:
   ```rust
   // StateKvMetadataPruner::prune() executes
   // Reads from STALE_STATE_VALUE_INDEX_CF_NAME in ledger_db
   // This column family is empty (no historical indices)
   // Historical stale state values remain unpruned
   ```

6. Monitor database size:
   ```bash
   # Database continues growing as new stale values accumulate
   # Historical stale values from step 2 are never deleted
   # Eventually leads to disk exhaustion
   ```

**Expected Result**: Pruning should clean up all stale state values regardless of when they were created.

**Actual Result**: Only stale state values created after the downgrade are pruned. Historical values remain forever, causing unbounded database growth.

## Notes

While this vulnerability is mitigated on mainnet/testnet through configuration validation, it represents a fundamental schema design flaw. The lack of a migration path between schema versions violates backward compatibility principles and could cause operational issues in:

- Private Aptos deployments
- Emergency network recovery scenarios
- Future protocol upgrades requiring schema changes

The fix should include both immediate mitigation (preventing incompatible downgrades) and long-term solution (cross-schema migration support or unified schema design).

### Citations

**File:** storage/aptosdb/src/schema/stale_state_value_index/mod.rs (L41-49)
```rust
impl KeyCodec<StaleStateValueIndexSchema> for StaleStateValueIndex {
    fn encode_key(&self) -> Result<Vec<u8>> {
        let mut encoded = vec![];
        encoded.write_u64::<BigEndian>(self.stale_since_version)?;
        encoded.write_u64::<BigEndian>(self.version)?;
        encoded.write_all(self.state_key.encoded())?;

        Ok(encoded)
    }
```

**File:** storage/aptosdb/src/schema/stale_state_value_index_by_key_hash/mod.rs (L39-47)
```rust
impl KeyCodec<StaleStateValueIndexByKeyHashSchema> for StaleStateValueByKeyHashIndex {
    fn encode_key(&self) -> Result<Vec<u8>> {
        let mut encoded = vec![];
        encoded.write_u64::<BigEndian>(self.stale_since_version)?;
        encoded.write_u64::<BigEndian>(self.version)?;
        encoded.write_all(self.state_key_hash.as_ref())?;

        Ok(encoded)
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L985-1015)
```rust
    fn put_state_kv_index(
        batch: &mut NativeBatch,
        enable_sharding: bool,
        stale_since_version: Version,
        version: Version,
        key: &StateKey,
    ) {
        if enable_sharding {
            batch
                .put::<StaleStateValueIndexByKeyHashSchema>(
                    &StaleStateValueByKeyHashIndex {
                        stale_since_version,
                        version,
                        state_key_hash: key.hash(),
                    },
                    &(),
                )
                .unwrap();
        } else {
            batch
                .put::<StaleStateValueIndexSchema>(
                    &StaleStateValueIndex {
                        stale_since_version,
                        version,
                        state_key: (*key).clone(),
                    },
                    &(),
                )
                .unwrap();
        }
    }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_metadata_pruner.rs (L28-65)
```rust
    pub(in crate::pruner) fn prune(
        &self,
        current_progress: Version,
        target_version: Version,
    ) -> Result<()> {
        let mut batch = SchemaBatch::new();

        if self.state_kv_db.enabled_sharding() {
            let num_shards = self.state_kv_db.num_shards();
            // NOTE: This can be done in parallel if it becomes the bottleneck.
            for shard_id in 0..num_shards {
                let mut iter = self
                    .state_kv_db
                    .db_shard(shard_id)
                    .iter::<StaleStateValueIndexByKeyHashSchema>()?;
                iter.seek(&current_progress)?;
                for item in iter {
                    let (index, _) = item?;
                    if index.stale_since_version > target_version {
                        break;
                    }
                }
            }
        } else {
            let mut iter = self
                .state_kv_db
                .metadata_db()
                .iter::<StaleStateValueIndexSchema>()?;
            iter.seek(&current_progress)?;
            for item in iter {
                let (index, _) = item?;
                if index.stale_since_version > target_version {
                    break;
                }
                batch.delete::<StaleStateValueIndexSchema>(&index)?;
                batch.delete::<StateValueSchema>(&(index.state_key, index.version))?;
            }
        }
```

**File:** storage/aptosdb/src/state_kv_db.rs (L62-70)
```rust
        let sharding = rocksdb_configs.enable_storage_sharding;
        if !sharding {
            info!("State K/V DB is not enabled!");
            return Ok(Self {
                state_kv_metadata_db: Arc::clone(&ledger_db),
                state_kv_db_shards: arr![Arc::clone(&ledger_db); 16],
                hot_state_kv_db_shards: None,
                enabled_sharding: false,
            });
```

**File:** storage/aptosdb/src/db_options.rs (L14-40)
```rust
pub(super) fn ledger_db_column_families() -> Vec<ColumnFamilyName> {
    vec![
        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,
        BLOCK_BY_VERSION_CF_NAME,
        BLOCK_INFO_CF_NAME,
        EPOCH_BY_VERSION_CF_NAME,
        EVENT_ACCUMULATOR_CF_NAME,
        EVENT_BY_KEY_CF_NAME,
        EVENT_BY_VERSION_CF_NAME,
        EVENT_CF_NAME,
        LEDGER_INFO_CF_NAME,
        PERSISTED_AUXILIARY_INFO_CF_NAME,
        STALE_STATE_VALUE_INDEX_CF_NAME,
        STATE_VALUE_CF_NAME,
        TRANSACTION_CF_NAME,
        TRANSACTION_ACCUMULATOR_CF_NAME,
        TRANSACTION_ACCUMULATOR_HASH_CF_NAME,
        TRANSACTION_AUXILIARY_DATA_CF_NAME,
        ORDERED_TRANSACTION_BY_ACCOUNT_CF_NAME,
        TRANSACTION_SUMMARIES_BY_ACCOUNT_CF_NAME,
        TRANSACTION_BY_HASH_CF_NAME,
        TRANSACTION_INFO_CF_NAME,
        VERSION_DATA_CF_NAME,
        WRITE_SET_CF_NAME,
        DB_METADATA_CF_NAME,
    ]
}
```

**File:** config/src/config/storage_config.rs (L664-668)
```rust
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["rocksdb_configs"]["enable_storage_sharding"].as_bool() != Some(true)
            {
                panic!("Storage sharding (AIP-97) is not enabled in node config. Please follow the guide to migration your node, and set storage.rocksdb_configs.enable_storage_sharding to true explicitly in your node config. https://aptoslabs.notion.site/DB-Sharding-Migration-Public-Full-Nodes-1978b846eb7280b29f17ceee7d480730");
            }
```
