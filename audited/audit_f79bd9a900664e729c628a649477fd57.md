# Audit Report

## Title
Missing Consensus Data Hash Validation in Merged Quorum Certificate Creation Causes Verification Failures

## Summary
The `create_merged_with_executed_state()` function in both `QuorumCert` and `WrappedLedgerInfo` fails to validate that the `consensus_data_hash` in the executed ledger info matches the `vote_data` hash before creating a merged certificate. This can produce invalid certificates that will fail verification, causing consensus liveness failures during recovery or state synchronization. [1](#0-0) 

## Finding Description
The AptosBFT consensus protocol requires that for any valid Quorum Certificate (QC), the `consensus_data_hash` field in the ledger info must equal the hash of the `vote_data`. This invariant is enforced during verification: [2](#0-1) 

However, when creating a merged QC via `create_merged_with_executed_state()`, the function only validates that the commit info fields match (epoch, round, id, timestamp) using `match_ordered_only()`: [3](#0-2) 

This validation is insufficient because it doesn't check whether the `consensus_data_hash` in the `executed_ledger_info` matches the hash of the original `vote_data`. The function proceeds to create a new QC by combining:
- The original `vote_data` (with hash H1)
- The new `executed_ledger_info` (with potentially different `consensus_data_hash` H2)

**Attack Path:**

During consensus recovery when `order_vote_enabled` is false, the system calls this vulnerable function: [4](#0-3) 

If database inconsistencies exist (due to crashes, corruption, or manual intervention), the `latest_ledger_info_sig` from storage may have a stale or incorrect `consensus_data_hash` that doesn't match the `vote_data.hash()` from the QC in consensus DB. The merged certificate will be created without validation, and later verification will fail when:

1. `QuorumCert::verify()` is called during block processing
2. `WrappedLedgerInfo::into_quorum_cert()` is called during state sync: [5](#0-4) 

The `into_quorum_cert()` method calls `verify_consensus_data_hash()`: [6](#0-5) [7](#0-6) 

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty criteria for the following reasons:

1. **State Inconsistencies Requiring Intervention**: Invalid merged QCs prevent proper consensus recovery, requiring manual database cleanup or rollback
2. **Consensus Liveness Degradation**: Affected validators cannot participate in consensus until the issue is resolved
3. **No Direct Fund Loss**: The issue causes operational failures but doesn't enable theft or unauthorized minting
4. **Requires Database Inconsistency**: Exploitation requires pre-existing database corruption or specific failure scenarios

If multiple validators encounter this issue simultaneously (e.g., after a coordinated network partition or widespread database corruption), the network could experience temporary liveness degradation until operators intervene.

## Likelihood Explanation
**Moderate Likelihood:**

- **Triggering Conditions**: Database inconsistency between consensus DB and storage DB, which can occur during:
  - Validator crashes during block commit phase
  - Storage corruption or hardware failures
  - Manual database manipulation or recovery operations
  - Race conditions during epoch transitions

- **Frequency**: While database inconsistencies are rare in normal operation, they become more likely during:
  - Network partitions or large-scale outages
  - Software upgrades with schema changes
  - Disaster recovery scenarios

- **Detection**: The issue will be detected immediately upon verification attempt, causing `.expect()` panics or errors that prevent the validator from starting

## Recommendation
Add explicit validation of the `consensus_data_hash` in `create_merged_with_executed_state()` before creating the merged certificate:

**For `QuorumCert`:**
```rust
pub fn create_merged_with_executed_state(
    &self,
    executed_ledger_info: LedgerInfoWithSignatures,
) -> anyhow::Result<QuorumCert> {
    let self_commit_info = self.commit_info();
    let executed_commit_info = executed_ledger_info.ledger_info().commit_info();
    ensure!(
        self_commit_info.match_ordered_only(executed_commit_info),
        "Block info from QC and executed LI need to match, {:?} and {:?}",
        self_commit_info,
        executed_commit_info
    );
    
    // Add validation for consensus_data_hash
    let vote_hash = self.vote_data.hash();
    ensure!(
        executed_ledger_info.ledger_info().consensus_data_hash() == vote_hash,
        "Consensus data hash mismatch: vote_data hash {:?} != executed ledger info consensus_data_hash {:?}",
        vote_hash,
        executed_ledger_info.ledger_info().consensus_data_hash()
    );
    
    Ok(Self::new(self.vote_data.clone(), executed_ledger_info))
}
```

**For `WrappedLedgerInfo`:**
```rust
pub fn create_merged_with_executed_state(
    &self,
    executed_ledger_info: LedgerInfoWithSignatures,
) -> anyhow::Result<WrappedLedgerInfo> {
    let self_commit_info = self.commit_info();
    let executed_commit_info = executed_ledger_info.ledger_info().commit_info();
    ensure!(
        self_commit_info.match_ordered_only(executed_commit_info),
        "Block info from QC and executed LI need to match, {:?} and {:?}",
        self_commit_info,
        executed_commit_info
    );
    
    // Add validation for consensus_data_hash
    let vote_hash = self.vote_data.hash();
    ensure!(
        executed_ledger_info.ledger_info().consensus_data_hash() == vote_hash,
        "Consensus data hash mismatch: vote_data hash {:?} != executed ledger info consensus_data_hash {:?}",
        vote_hash,
        executed_ledger_info.ledger_info().consensus_data_hash()
    );
    
    Ok(Self::new(self.vote_data.clone(), executed_ledger_info))
}
```

This ensures that merged certificates are only created when the `consensus_data_hash` is consistent with the `vote_data`, preventing invalid QCs from being created and providing clear error messages for debugging database inconsistencies.

## Proof of Concept
The vulnerability can be demonstrated through the following scenario:

**Setup:**
1. Configure a validator with `order_vote_enabled = false`
2. Allow normal consensus operation to commit several blocks
3. Simulate database corruption by modifying the `consensus_data_hash` in the latest stored ledger info to a random value
4. Trigger validator restart to initiate recovery

**Expected Behavior:**
The recovery process in `persistent_liveness_storage.rs` will call `create_merged_with_executed_state()` which will succeed (missing validation), but subsequent calls to `into_quorum_cert()` or `verify()` will fail with "Quorum Cert's hash mismatch LedgerInfo" error.

**Rust Test Case:**
```rust
#[test]
fn test_merged_qc_with_mismatched_consensus_data_hash() {
    use aptos_consensus_types::{quorum_cert::QuorumCert, vote_data::VoteData};
    use aptos_types::{block_info::BlockInfo, ledger_info::{LedgerInfo, LedgerInfoWithSignatures}};
    use aptos_crypto::{HashValue, bls12381};
    
    // Create a valid QC with vote_data
    let block_info = BlockInfo::new(1, 1, HashValue::random(), HashValue::random(), 100, 1000, None);
    let vote_data = VoteData::new(block_info.clone(), block_info.clone());
    let vote_hash = vote_data.hash();
    
    let ledger_info = LedgerInfo::new(block_info.clone(), vote_hash);
    let original_qc = QuorumCert::new(
        vote_data.clone(),
        LedgerInfoWithSignatures::new(ledger_info, AggregateSignature::empty())
    );
    
    // Create executed ledger info with DIFFERENT consensus_data_hash
    let executed_block_info = BlockInfo::new(1, 1, block_info.id(), HashValue::random(), 200, 1000, None);
    let wrong_hash = HashValue::zero(); // Intentionally wrong hash
    let executed_ledger_info = LedgerInfo::new(executed_block_info, wrong_hash);
    let executed_li_with_sig = LedgerInfoWithSignatures::new(executed_ledger_info, AggregateSignature::empty());
    
    // create_merged_with_executed_state() succeeds (BUG - missing validation)
    let merged_qc = original_qc.create_merged_with_executed_state(executed_li_with_sig).unwrap();
    
    // But verification fails
    let validator_verifier = /* create validator verifier */;
    let result = merged_qc.verify(&validator_verifier);
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("hash mismatch"));
}
```

## Notes
- The vulnerability is present in both `QuorumCert` and `WrappedLedgerInfo` implementations with identical root cause
- The issue only manifests when `order_vote_enabled = false`, as the true case bypasses `create_merged_with_executed_state()`
- Early detection through validation prevents silent creation of invalid certificates that would fail later
- The fix maintains backward compatibility while adding necessary safety checks

### Citations

**File:** consensus/consensus-types/src/quorum_cert.rs (L119-124)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "Quorum Cert's hash mismatch LedgerInfo"
        );
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L150-163)
```rust
    pub fn create_merged_with_executed_state(
        &self,
        executed_ledger_info: LedgerInfoWithSignatures,
    ) -> anyhow::Result<QuorumCert> {
        let self_commit_info = self.commit_info();
        let executed_commit_info = executed_ledger_info.ledger_info().commit_info();
        ensure!(
            self_commit_info.match_ordered_only(executed_commit_info),
            "Block info from QC and executed LI need to match, {:?} and {:?}",
            self_commit_info,
            executed_commit_info
        );
        Ok(Self::new(self.vote_data.clone(), executed_ledger_info))
    }
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/src/persistent_liveness_storage.rs (L252-261)
```rust
            let root_ordered_cert = quorum_certs
                .iter()
                .find(|qc| qc.commit_info().id() == root_block.id())
                .ok_or_else(|| format_err!("No LI found for root: {}", root_id))?
                .clone()
                .into_wrapped_ledger_info();
            let root_commit_cert = root_ordered_cert
                .create_merged_with_executed_state(latest_ledger_info_sig)
                .expect("Inconsistent commit proof and evaluation decision, cannot commit block");
            (root_ordered_cert, root_commit_cert)
```

**File:** consensus/src/block_storage/sync_manager.rs (L453-457)
```rust
                quorum_certs.push(
                    highest_commit_cert
                        .clone()
                        .into_quorum_cert(order_vote_enabled)?,
                );
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L53-62)
```rust
    fn verify_consensus_data_hash(&self) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "WrappedLedgerInfo's vote data hash mismatch LedgerInfo, {} {}",
            self.ledger_info(),
            self.vote_data
        );
        Ok(())
    }
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L125-135)
```rust
    pub fn into_quorum_cert(self, order_vote_enabled: bool) -> anyhow::Result<QuorumCert> {
        ensure!(
            !order_vote_enabled,
            "wrapped_ledger_info.into_quorum_cert should not be called when order votes are enabled"
        );
        self.verify_consensus_data_hash()?;
        Ok(QuorumCert::new(
            self.vote_data.clone(),
            self.signed_ledger_info.clone(),
        ))
    }
```
