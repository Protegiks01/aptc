# Audit Report

## Title
Local Configuration Override Causes Consensus Validation Inconsistency in Validator Transaction Processing

## Summary
The `is_vtxn_expected` function in `consensus/src/util/mod.rs` relies on cached randomness and JWK consensus configurations that can differ across validators in the same epoch due to a local configuration override mechanism. When validators have different `randomness_override_seq_num` values in their node configs, they will disagree on whether DKGResult validator transactions are expected, causing proposal validation to fail inconsistently and breaking consensus safety.

## Finding Description
The vulnerability occurs through the following mechanism:

The `is_vtxn_expected` function validates whether validator transactions (DKGResult or ObservedJWKUpdate) should be included in proposals based on feature enablement configs: [1](#0-0) 

These configs are cached in the RoundManager when entering each epoch and loaded via: [2](#0-1) 

The critical issue is in `OnChainRandomnessConfig::from_configs` which implements a local override mechanism: [3](#0-2) 

The `randomness_override_seq_num` is a node-level configuration parameter: [4](#0-3) 

**Attack Scenario:**

1. On-chain `RandomnessConfigSeqNum.seq_num = 50` with randomness enabled
2. Validator A has `randomness_override_seq_num = 0` (default - no override)
3. Validator B has `randomness_override_seq_num = 100` (emergency override set)
4. Both validators enter epoch N and cache their configs:
   - Validator A: `local(0) <= onchain(50)` → uses on-chain config (randomness enabled)
   - Validator B: `local(100) > onchain(50)` → force-disables randomness
5. A proposer creates a block containing a DKGResult validator transaction
6. Validator A validation: `randomness_config.randomness_enabled()` = true → accepts DKGResult as expected
7. Validator B validation: `randomness_config.randomness_enabled()` = false → rejects with "unexpected validator txn" error [5](#0-4) 

This causes validators in the same epoch to disagree on block validity, violating consensus safety.

## Impact Explanation
**Severity: Critical** - This breaks the fundamental "Deterministic Execution" and "Consensus Safety" invariants. When validators disagree on whether a block is valid:

- Consensus cannot make progress on that block
- Network may partition if subset of validators vote differently
- Requires coordination and potential hardfork to recover
- Can cause total loss of liveness if triggered during critical randomness operations

This meets the **Critical Severity** criteria per Aptos Bug Bounty: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation
**Likelihood: Medium to High**

While this requires validators to have different node configurations, realistic trigger scenarios include:

1. **Emergency Recovery Misconfiguration**: The override is explicitly designed for "randomness stall" recovery. During an actual emergency, validators may set different override values due to communication failures or phased deployment.

2. **Operational Errors**: Validators may accidentally leave override values set after previous incidents or set them incorrectly during configuration updates.

3. **Coordination Failures**: No protocol-level enforcement ensures all validators use the same override value. The comment indicates operators should coordinate, but the protocol doesn't verify this.

4. **Gradual Rollout**: During emergency response, some validators may apply the override before others, creating a window of vulnerability.

This doesn't require malicious intent - honest validators following emergency procedures could trigger this through timing differences or miscommunication.

## Recommendation
Implement one of the following fixes:

**Option 1: Protocol-Level Override Coordination**
- Include `randomness_override_seq_num` in epoch state that all validators must agree on
- Reject proposals from validators with mismatched override values
- Force override changes to trigger epoch changes

**Option 2: Remove Local Override Mechanism**  
- Replace with on-chain governance mechanism for emergency randomness disablement
- Requires supermajority vote to disable, ensuring coordination
- Changes take effect only at epoch boundaries

**Option 3: Add Validation Layer**
Add validation that override values match across validators:

```rust
// In epoch_manager.rs start_new_epoch
let onchain_randomness_config = OnChainRandomnessConfig::from_configs(
    self.randomness_override_seq_num,
    onchain_randomness_config_seq_num.seq_num,
    randomness_config_move_struct.ok(),
);

// Add validation: if override is active, verify it's part of epoch state
if self.randomness_override_seq_num > onchain_randomness_config_seq_num.seq_num {
    ensure!(
        epoch_state.contains_override_consensus(),
        "Override active but not in epoch consensus"
    );
}
```

## Proof of Concept

```rust
// Reproduction test in consensus/src/round_manager_tests/mod.rs
#[test]
fn test_validator_transaction_validation_inconsistency() {
    // Setup two validators with different override configs
    let mut validator_a_config = NodeConfig::default();
    validator_a_config.randomness_override_seq_num = 0; // No override
    
    let mut validator_b_config = NodeConfig::default();  
    validator_b_config.randomness_override_seq_num = 100; // Override active
    
    // Create epoch state with on-chain seq_num = 50, randomness enabled
    let epoch_state = create_epoch_state_with_randomness(50, true);
    
    // Both validators enter same epoch
    let rm_a = RoundManager::new(/* validator_a_config params */);
    let rm_b = RoundManager::new(/* validator_b_config params */);
    
    // Create proposal with DKGResult validator transaction
    let proposal = create_proposal_with_dkg_result();
    
    // Validator A should accept (randomness enabled)
    assert!(rm_a.process_proposal(&proposal).is_ok());
    
    // Validator B should reject (randomness disabled by override)
    assert!(rm_b.process_proposal(&proposal).is_err());
    // Error: "unexpected validator txn: DKGResult"
    
    // This demonstrates consensus safety violation
}
```

## Notes

This vulnerability specifically addresses the stated security question about config synchronization. While the override mechanism appears intentional for emergency recovery, it fundamentally violates consensus determinism by allowing validators in the same epoch to have different validation logic without protocol-level coordination or verification. The design assumes perfect operational coordination across independent validator operators, which is unrealistic in emergency scenarios when this feature is most likely to be used.

### Citations

**File:** consensus/src/util/mod.rs (L15-24)
```rust
pub fn is_vtxn_expected(
    randomness_config: &OnChainRandomnessConfig,
    jwk_consensus_config: &OnChainJWKConsensusConfig,
    vtxn: &ValidatorTransaction,
) -> bool {
    match vtxn {
        ValidatorTransaction::DKGResult(_) => randomness_config.randomness_enabled(),
        ValidatorTransaction::ObservedJWKUpdate(_) => jwk_consensus_config.jwk_consensus_enabled(),
    }
}
```

**File:** consensus/src/epoch_manager.rs (L1217-1221)
```rust
        let onchain_randomness_config = OnChainRandomnessConfig::from_configs(
            self.randomness_override_seq_num,
            onchain_randomness_config_seq_num.seq_num,
            randomness_config_move_struct.ok(),
        );
```

**File:** types/src/on_chain_config/randomness_config.rs (L139-151)
```rust
    pub fn from_configs(
        local_seqnum: u64,
        onchain_seqnum: u64,
        onchain_raw_config: Option<RandomnessConfigMoveStruct>,
    ) -> Self {
        if local_seqnum > onchain_seqnum {
            Self::default_disabled()
        } else {
            onchain_raw_config
                .and_then(|onchain_raw| OnChainRandomnessConfig::try_from(onchain_raw).ok())
                .unwrap_or_else(OnChainRandomnessConfig::default_if_missing)
        }
    }
```

**File:** config/src/config/node_config.rs (L78-81)
```rust
    /// In a randomness stall, set this to be on-chain `RandomnessConfigSeqNum` + 1.
    /// Once enough nodes restarted with the new value, the chain should unblock with randomness disabled.
    #[serde(default)]
    pub randomness_override_seq_num: u64,
```

**File:** consensus/src/round_manager.rs (L1129-1133)
```rust
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
```
