# Audit Report

## Title
Gas Schedule Feature Version Mismatch Causes Network-Wide Denial of Service

## Summary
The gas schedule serialization mechanism allows creating a `GasScheduleV2` with mismatched `feature_version` and `entries` fields, where the feature version indicates support for parameters that are absent from the entries array. When such a malformed gas schedule is stored on-chain and validators attempt to load it, deserialization fails network-wide, causing complete loss of availability. [1](#0-0) 

## Finding Description

The vulnerability stems from three interconnected issues:

**1. Version-Dependent Parameter Serialization**

Gas parameters use version-specific key bindings. The `to_on_chain_gas_schedule` implementation conditionally includes parameters based on the feature version. For example, parameters like `u16`, `u32`, `u256` are only serialized for version >= 5, while signed integer parameters (`i8` through `i256`) are only included for version >= RELEASE_V1_38. [2](#0-1) 

**2. Strict Deserialization Requirements**

When deserializing with `from_on_chain_gas_schedule`, the implementation expects ALL parameters applicable for the given feature version to exist in the on-chain map. If any expected parameter is missing, deserialization returns an error rather than defaulting to zero. [3](#0-2) 

**3. No On-Chain Consistency Validation**

The on-chain gas schedule update functions accept a BCS-serialized `GasScheduleV2` blob but perform NO validation that the `entries` field is consistent with the `feature_version` field. The code explicitly acknowledges this gap with TODO comments. [4](#0-3) [5](#0-4) 

**Attack Scenario:**

1. Attacker constructs a `GasScheduleV2` with:
   - `feature_version: 15` (claiming support for latest parameters)
   - `entries: to_on_chain_gas_schedule(5)` (only contains parameters from version 5)

2. BCS-serializes this malformed structure and submits as governance proposal

3. Governance approves without validating internal consistency (only checks version >= current)

4. At next epoch, all validator nodes attempt to load the gas schedule: [6](#0-5) 

5. Deserialization fails when trying to find missing version 15 parameters in the map containing only version 5 parameters

6. All nodes fail to initialize gas parameters, cannot process transactions

7. Network halts completely

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty program because it causes **"Total loss of liveness/network availability"**:

- **All validator nodes affected**: Every node attempting to load the malformed gas schedule will fail deserialization
- **Complete network halt**: Without valid gas parameters, nodes cannot process any transactions
- **Requires governance intervention**: Recovery requires either rolling back to previous gas schedule or deploying a corrected schedule through emergency governance procedures
- **Potential hard fork requirement**: If the malformed schedule becomes the canonical state, chain continuity may be broken

The vulnerability breaks the **State Consistency** invariant (state transitions must be atomic and verifiable) and the **Deterministic Execution** invariant (all validators must produce identical results).

## Likelihood Explanation

**Likelihood: Medium-to-High**

**Factors increasing likelihood:**
- Governance proposals are the primary update mechanism for gas schedules
- Proposal reviewers may not manually validate the consistency between feature_version and entries fields
- The attack is non-obvious - the malformed structure appears valid to BCS deserialization
- Tools like `aptos-gas-schedule-updator` correctly generate schedules, but custom scripts could create malformed ones

**Factors decreasing likelihood:**
- Requires governance approval (multiple participants must vote)
- Honest governance participants would likely test proposals before voting
- The `aptos-gas-schedule-updator` library correctly constructs schedules when used properly [7](#0-6) 

## Recommendation

**Immediate Fix:** Implement validation in the on-chain gas schedule update functions to verify entries match the declared feature_version.

Add a validation function to the Move contract:

```move
// In gas_schedule.move
fun validate_gas_schedule_consistency(gas_schedule: &GasScheduleV2): bool {
    // Attempt to deserialize using the claimed feature_version
    // This should be done in native Rust function since Move cannot perform
    // the complex version-specific key matching
    
    // For now, add a native function that:
    // 1. Converts entries to BTreeMap
    // 2. Calls FromOnChainGasSchedule::from_on_chain_gas_schedule
    // 3. Returns true if successful, false if any parameters are missing
    native_validate_gas_schedule(gas_schedule)
}
```

Modify the update functions:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD THIS VALIDATION
    assert!(
        validate_gas_schedule_consistency(&new_gas_schedule),
        error::invalid_argument(EINVALID_GAS_SCHEDULE)
    );
    
    // ... rest of function
}
```

**Alternative approach:** Modify the Rust deserialization to be more forgiving - if a versioned parameter is missing, default to zero instead of returning an error. However, this masks legitimate configuration errors and is not recommended.

## Proof of Concept

```rust
use aptos_gas_schedule::{AptosGasParameters, InitialGasSchedule, ToOnChainGasSchedule};
use aptos_types::on_chain_config::GasScheduleV2;

fn demonstrate_vulnerability() {
    // Create initial gas parameters with all fields populated
    let gas_params = AptosGasParameters::initial();
    
    // Serialize with OLD feature version (e.g., 5)
    // This omits parameters that require version >= 6
    let entries_from_v5 = gas_params.to_on_chain_gas_schedule(5);
    
    // Create GasScheduleV2 with MISMATCHED version
    let malformed_schedule = GasScheduleV2 {
        feature_version: 15,  // Claims support for v15 parameters
        entries: entries_from_v5,  // But only contains v5 parameters!
    };
    
    // Serialize as BCS blob (this is what goes on-chain)
    let blob = bcs::to_bytes(&malformed_schedule).unwrap();
    
    // Now simulate what happens when nodes load this schedule
    let loaded: GasScheduleV2 = bcs::from_bytes(&blob).unwrap();
    let map = loaded.into_btree_map();
    
    // Try to deserialize with the claimed feature_version
    let result = AptosGasParameters::from_on_chain_gas_schedule(
        &map, 
        15  // Using feature_version from the schedule
    );
    
    // This WILL FAIL with missing parameter errors!
    assert!(result.is_err());
    println!("Deserialization failed as expected: {:?}", result.unwrap_err());
    println!("Network would halt if this schedule is deployed!");
}
```

This demonstrates that a `GasScheduleV2` with `feature_version=15` but `entries` from version 5 passes BCS serialization/deserialization but fails when the gas parameters are parsed for actual use, causing network-wide failure.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L32-46)
```rust
        impl $crate::traits::FromOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
        }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L48-61)
```rust
        impl $crate::traits::ToOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn to_on_chain_gas_schedule(&self, feature_version: u64) -> Vec<(String, u64)> {
                let mut output = vec![];

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        output.push((format!("{}.{}", $prefix, key), self.$name.into()))
                    }
                )*

                output
            }
        }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L27-74)
```rust
crate::gas_schedule::macros::define_gas_parameters!(
    AbstractValueSizeGasParameters,
    "misc.abs_val",
    VMGasParameters => .misc.abs_val,
    [
        // abstract value size
        [u8: AbstractValueSize, "u8", 40],
        [u16: AbstractValueSize, { 5.. => "u16" }, 40],
        [u32: AbstractValueSize, { 5.. => "u32" }, 40],
        [u64: AbstractValueSize, "u64", 40],
        [u128: AbstractValueSize, "u128", 40],
        [u256: AbstractValueSize, { 5.. => "u256" }, 40],
        [i8: AbstractValueSize, { RELEASE_V1_38.. => "i8" }, 40],
        [i16: AbstractValueSize, { RELEASE_V1_38.. => "i16" }, 40],
        [i32: AbstractValueSize, { RELEASE_V1_38.. => "i32" }, 40],
        [i64: AbstractValueSize, { RELEASE_V1_38.. => "i64" }, 40],
        [i128: AbstractValueSize, { RELEASE_V1_38.. => "i128" }, 40],
        [i256: AbstractValueSize, { RELEASE_V1_38.. => "i256" }, 40],
        [bool: AbstractValueSize, "bool", 40],
        [address: AbstractValueSize, "address", 40],
        [struct_: AbstractValueSize, "struct", 40],
        [closure: AbstractValueSize, { RELEASE_V1_33.. => "closure" }, 40],
        [vector: AbstractValueSize, "vector", 40],
        [reference: AbstractValueSize, "reference", 40],
        [per_u8_packed: AbstractValueSizePerArg, "per_u8_packed", 1],
        [per_u16_packed: AbstractValueSizePerArg, { 5.. => "per_u16_packed" }, 2],
        [per_u32_packed: AbstractValueSizePerArg, { 5.. => "per_u32_packed" }, 4],
        [per_u64_packed: AbstractValueSizePerArg, "per_u64_packed", 8],
        [per_u128_packed: AbstractValueSizePerArg, "per_u128_packed", 16],
        [per_u256_packed: AbstractValueSizePerArg, { 5.. => "per_u256_packed" }, 32],
        [per_i8_packed: AbstractValueSizePerArg, { RELEASE_V1_38.. => "per_i8_packed" }, 1],
        [per_i16_packed: AbstractValueSizePerArg, { RELEASE_V1_38.. => "per_i16_packed" }, 2],
        [per_i32_packed: AbstractValueSizePerArg, { RELEASE_V1_38.. => "per_i32_packed" }, 4],
        [per_i64_packed: AbstractValueSizePerArg, { RELEASE_V1_38.. => "per_i64_packed" }, 8],
        [per_i128_packed: AbstractValueSizePerArg, { RELEASE_V1_38.. => "per_i128_packed" }, 16],
        [per_i256_packed: AbstractValueSizePerArg, { RELEASE_V1_38.. => "per_i256_packed" }, 32],
        [
            per_bool_packed: AbstractValueSizePerArg,
            "per_bool_packed",
            1
        ],
        [
            per_address_packed: AbstractValueSizePerArg,
            "per_address_packed",
            32
        ],
    ]
);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L43-50)
```text
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L23-36)
```rust
fn get_gas_config_from_storage(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> (Result<AptosGasParameters, String>, u64) {
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Some((gas_schedule, bytes)) => {
            sha3_256.update(&bytes);
            let feature_version = gas_schedule.feature_version;
            let map = gas_schedule.into_btree_map();
            (
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            )
        },
```

**File:** aptos-move/aptos-gas-schedule-updator/src/lib.rs (L116-121)
```rust
pub fn current_gas_schedule(feature_version: u64) -> GasScheduleV2 {
    GasScheduleV2 {
        feature_version,
        entries: AptosGasParameters::initial().to_on_chain_gas_schedule(feature_version),
    }
}
```
