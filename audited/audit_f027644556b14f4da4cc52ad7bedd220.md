# Audit Report

## Title
Unauthenticated Backup Metadata Enables Complete Blockchain State Compromise When Trusted Waypoints Are Omitted

## Summary
Backup metadata files are loaded without cryptographic verification, and trusted waypoints are optional during backup verification/restore. When no genesis waypoint is provided, an attacker who compromises backup storage can inject a completely fake blockchain history that passes all verification checks, leading to total state compromise.

## Finding Description

The backup/restore system loads metadata files (`.meta` files) from backup storage without any cryptographic authentication. These metadata files contain pointers to manifest files that describe the actual backup content. [1](#0-0) 

The metadata files are parsed as JSON without signature verification, checksums, or any authentication mechanism. The `TrustedWaypointOpt` structure allows users to provide trusted waypoints for verification, but this is completely optional: [2](#0-1) 

During epoch ending backup restoration, the verification logic checks if a trusted waypoint exists for each epoch. For epoch 0 (genesis), if no trusted waypoint is provided AND there is no previous epoch (first epoch), **no cryptographic verification occurs**: [3](#0-2) 

The code checks `if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version())` first, and if no waypoint exists, falls back to `else if let Some(pre_li) = previous_li`. For epoch 0, both conditions are false, so the genesis LedgerInfo is accepted without any verification.

**Attack Path:**

1. Attacker gains write access to backup storage (S3 bucket misconfiguration, stolen credentials, or compromised system)
2. Attacker creates malicious metadata files pointing to malicious manifests
3. Attacker creates fake epoch ending manifests with:
   - Fake genesis (epoch 0) with attacker-controlled validator set
   - Fake epoch history with valid signatures from the fake validator set
   - Fake state snapshots and transactions
4. User runs `aptos-db-tool backup verify` **without providing `--trust-waypoint` arguments**
5. The verification process:
   - Loads unauthenticated metadata files [4](#0-3) 
   - Extracts manifest handles from metadata [5](#0-4) 
   - For epoch 0, no waypoint check and no signature verification occurs
   - Fake genesis is accepted as valid
   - Subsequent epochs are verified using the fake genesis's validator set
   - Complete fake blockchain passes verification
6. User restores from this backup, loading completely fake state into their node

This breaks the **Cryptographic Correctness** invariant: the system accepts blockchain state without proper cryptographic authentication when trusted waypoints are omitted.

## Impact Explanation

**Severity: Critical** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability enables multiple critical impacts:

1. **Loss of Funds**: Attacker can create fake account balances, stealing all funds in the restored state
2. **Consensus/Safety Violation**: Different nodes restoring from different fake backups would commit to incompatible states, causing permanent network partition
3. **Validator Set Manipulation**: Attacker controls the validator set in the fake genesis, enabling complete consensus control
4. **Governance Compromise**: Fake governance state allows attacker to execute arbitrary proposals
5. **Non-recoverable Network Partition**: If some nodes restore fake state while others have real state, the network permanently splits (requires hardfork to recover)

The impact is total blockchain compromise - every security guarantee is violated when a fake genesis is accepted.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited in practice:

1. **Common Attack Vector**: Backup storage compromise is realistic through:
   - Cloud storage bucket misconfigurations (public S3/GCS buckets)
   - Stolen AWS/GCS credentials
   - Compromised backup servers
   - Man-in-the-middle attacks on backup transfers

2. **No Security Warning**: The system does not warn users if they run verification without trusted waypoints. Users may not understand the security implications.

3. **Optional Security Control**: The CLI accepts verification without waypoints [6](#0-5) , making the security control opt-in rather than mandatory.

4. **Realistic Scenario**: Node operators performing disaster recovery may simply run restore commands from backup storage without providing genesis waypoints, especially if they don't understand the security model.

## Recommendation

**Immediate Fix**: Make genesis trusted waypoint mandatory for backup verification and restore operations.

**Implementation:**

1. Modify `TrustedWaypointOpt::verify()` to require at least one waypoint:

```rust
impl TrustedWaypointOpt {
    pub fn verify(self) -> Result<HashMap<Version, Waypoint>> {
        ensure!(
            !self.trust_waypoint.is_empty(),
            "At least one trusted waypoint must be provided for backup verification. \
            Provide the genesis waypoint with --trust-waypoint to verify backup authenticity."
        );
        
        let mut trusted_waypoints = HashMap::new();
        for w in self.trust_waypoint {
            trusted_waypoints
                .insert(w.version(), w)
                .map_or(Ok(()), |w| {
                    Err(AptosDbError::Other(format!(
                        "Duplicated waypoints at version {}",
                        w.version()
                    )))
                })?;
        }
        
        // Ensure genesis waypoint (version 0) is provided
        ensure!(
            trusted_waypoints.contains_key(&0),
            "Genesis waypoint (version 0) must be provided for backup verification"
        );
        
        Ok(trusted_waypoints)
    }
}
```

2. **Long-term Fix**: Implement cryptographic signing of metadata files:
   - Sign metadata files with validator keys or dedicated backup signing keys
   - Verify signatures before loading metadata
   - Include metadata hash chains in ledger for additional verification

3. **Defense in Depth**: Add warnings when waypoints are not provided, and document the security model clearly in user guides.

## Proof of Concept

**Setup:**
1. Create fake backup storage with malicious metadata files
2. Run verification without trusted waypoints

**Exploitation Steps:**

```bash
# Attacker creates malicious backup in /tmp/malicious-backup/
# with fake metadata files pointing to fake manifests containing
# fake genesis and fake epoch history

# Victim runs verification without waypoints:
aptos-db-tool backup verify \
  --local-fs-dir /tmp/malicious-backup \
  --metadata-cache-dir /tmp/cache

# Expected: Verification FAILS with "trusted waypoint required"
# Actual: Verification SUCCEEDS, accepting fake blockchain

# If victim then restores:
aptos-db-tool backup restore \
  --local-fs-dir /tmp/malicious-backup \
  --target-db-dir /tmp/restored-db

# Result: Complete fake blockchain state restored to node
```

**Demonstration Code:**

Create a test backup with fake genesis:

```rust
#[tokio::test]
async fn test_fake_genesis_accepted_without_waypoint() {
    let storage = Arc::new(LocalFs::new_with_opt(/* ... */));
    
    // Create fake metadata pointing to fake genesis
    let fake_metadata = Metadata::new_epoch_ending_backup(
        0, // first_epoch
        10, // last_epoch  
        0, // first_version
        1000, // last_version
        fake_manifest_handle, // Points to attacker-controlled manifest
    );
    
    storage.save_metadata_line(
        &"epoch_ending_0-10.meta".parse().unwrap(),
        &fake_metadata.to_text_line().unwrap()
    ).await.unwrap();
    
    // Run verification WITHOUT trusted waypoints
    let coordinator = VerifyCoordinator::new(
        storage,
        MetadataCacheOpt::default(),
        TrustedWaypointOpt::default(), // Empty waypoints!
        1, // concurrent_downloads
        0, // start_version
        Version::MAX, // end_version
        Version::MAX, // state_snapshot_before
        false, // skip_epoch_endings
        false, // validate_modules
        None, // output_analysis
    ).unwrap();
    
    // This should FAIL but currently SUCCEEDS
    let result = coordinator.run().await;
    
    assert!(result.is_ok(), "Fake genesis was accepted without verification!");
}
```

**Notes:**
- The vulnerability requires backup storage compromise, but this is a realistic threat
- Backup storage is typically less secured than validator nodes
- Users may not understand the importance of providing trusted waypoints
- The security control (waypoints) is optional, not enforced
- Complete blockchain state can be fabricated without detection

### Citations

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L196-207)
```rust
        metadata_vec.extend(
            OpenOptions::new()
                .read(true)
                .open(&cached_file)
                .await
                .err_notes(&cached_file)?
                .load_metadata_lines()
                .await
                .err_notes(&cached_file)?
                .into_iter(),
        )
    }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L332-346)
```rust
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L85-90)
```rust
        let metadata_view = metadata::cache::sync_and_load(
            &self.metadata_cache_opt,
            Arc::clone(&self.storage),
            self.concurrent_downloads,
        )
        .await?;
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L110-120)
```rust
                EpochHistoryRestoreController::new(
                    epoch_endings
                        .into_iter()
                        .map(|backup| backup.manifest)
                        .collect(),
                    global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
```

**File:** storage/db-tool/src/backup.rs (L125-130)
```rust
pub struct VerifyOpt {
    #[clap(flatten)]
    metadata_cache_opt: MetadataCacheOpt,
    #[clap(flatten)]
    trusted_waypoints_opt: TrustedWaypointOpt,
    #[clap(flatten)]
```
