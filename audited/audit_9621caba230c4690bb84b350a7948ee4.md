# Audit Report

## Title
Missing Checksum Validation in AccountAddress Encoding Enables Permanent Fund Loss Through Address Typos

## Summary
Aptos AccountAddress encoding lacks checksum validation, allowing bit errors and typos in address strings to go undetected. When users submit addresses with typos to the faucet or other funding mechanisms, funds are irreversibly sent to unintended addresses with no error detection. This violates basic user fund safety guarantees present in other major blockchains.

## Finding Description
The Aptos AccountAddress implementation uses basic hexadecimal string parsing without any checksum or error detection mechanism. This affects all address input paths across the ecosystem, including the faucet client, CLI tools, and REST APIs.

**Vulnerable Code Path:**

The faucet's `fund()` function accepts an `AccountAddress` parameter that gets serialized to a string and sent to the faucet server: [1](#0-0) 

The faucet server parses incoming address strings using `AccountAddress::from_hex_literal()` or `AccountAddress::from_hex()`: [2](#0-1) 

The core parsing implementation performs no checksum validation: [3](#0-2) [4](#0-3) 

The relaxed `FromStr` implementation also lacks checksum validation: [5](#0-4) 

**Attack Scenarios:**

1. **Accidental Typo:** User intends to fund `0xca843279e3427144cead5e4d5999a3d0ca843279e3427144cead5e4d5999a3d0` but mistypes one character as `0xca843279e3427144cead5e4d5999a3d0ca843279e3427144cead5e4d5999a3d1`. The faucet accepts this, and funds are permanently lost.

2. **Social Engineering:** Attacker provides victim with address containing subtle typo (e.g., replacing `0` with `O`, `1` with `l`). Victim copies address and loses funds.

3. **Clipboard Hijacking:** Malware modifies copied addresses in clipboard. Without checksum validation, modified addresses parse successfully.

The AIP-40 address standard defines formatting rules but explicitly omits checksum validation: [6](#0-5) 

## Impact Explanation
This qualifies as **Medium to High Severity** under the Aptos bug bounty program ("Limited funds loss or manipulation"). 

**Impact:**
- Users can permanently lose funds through simple typos with no recovery mechanism
- Affects all address input mechanisms: faucet, CLI, APIs, wallets
- No warning or error is generated for typo'd addresses
- Attackers can exploit this through social engineering and phishing

**Comparison to Industry Standards:**
- Bitcoin uses Base58Check with 4-byte checksum (detects ~99.9% of typos)
- Ethereum uses EIP-55 mixed-case checksum encoding
- Aptos has zero error detection for address typos

While this doesn't break consensus or core protocol invariants, it violates fundamental user fund safety expectations and enables both accidental loss and attacker exploitation.

## Likelihood Explanation
**Likelihood: High**

Address typos are extremely common in cryptocurrency:
- Manual address entry is error-prone (64 hexadecimal characters)
- Copy-paste errors occur frequently
- Social engineering attacks exploiting this are trivial to execute
- No existing mitigation exists in the codebase

The vulnerability affects:
- Faucet funding operations
- CLI transfer commands  
- API-based transfers
- Any manual address entry point

Every address input is vulnerable until checksum validation is implemented.

## Recommendation
Implement checksum validation for AccountAddress encoding using one of these approaches:

**Option 1: Implement EIP-55-style mixed-case checksum:**
- Compute Keccak256 hash of lowercase address
- Capitalize hex digits where corresponding hash nibble ≥ 8
- Validate input addresses match expected casing

**Option 2: Implement Aptos-specific checksum scheme:**
- Add 4-byte checksum suffix to addresses (similar to Base58Check)
- Compute checksum as SHA3-256(address)[0..4]
- Validate checksum on parsing, reject mismatches

**Recommended Implementation:**
Add a new `from_str_with_checksum()` method to AccountAddress and update all user-facing address parsing to use it:

```rust
// In account_address.rs
pub fn from_str_with_checksum(s: &str) -> Result<Self, AccountAddressParseError> {
    // Parse address
    let address = Self::from_str(s)?;
    
    // Validate checksum (implement chosen scheme)
    if !validate_address_checksum(s, &address) {
        return Err(AccountAddressParseError::InvalidChecksum);
    }
    
    Ok(address)
}
```

Update the faucet, CLI, and APIs to use checksummed addresses by default while maintaining backward compatibility for programmatic use.

## Proof of Concept

```rust
use move_core_types::account_address::AccountAddress;
use std::str::FromStr;

#[test]
fn test_address_typo_undetected() {
    // Original intended address
    let original = "0xca843279e3427144cead5e4d5999a3d0ca843279e3427144cead5e4d5999a3d0";
    
    // Address with single character typo (changed last '0' to '1')
    let typo = "0xca843279e3427144cead5e4d5999a3d0ca843279e3427144cead5e4d5999a3d1";
    
    // Both addresses parse successfully
    let addr1 = AccountAddress::from_str(original).expect("Original should parse");
    let addr2 = AccountAddress::from_str(typo).expect("Typo should parse");
    
    // They are different addresses
    assert_ne!(addr1, addr2, "Typo created different address");
    
    // No error was raised - funds would be sent to wrong address
    println!("Original: {}", addr1);
    println!("Typo:     {}", addr2);
    println!("❌ Typo undetected - funds would be permanently lost!");
}

#[test]
fn test_multiple_typos_undetected() {
    let test_cases = vec![
        ("0x1", "0x2"),  // Changed digit
        ("0xabcd", "0xabce"),  // Changed last digit
        ("0xa000", "0xb000"),  // Changed first digit
    ];
    
    for (original, typo) in test_cases {
        let addr1 = AccountAddress::from_str(original).unwrap();
        let addr2 = AccountAddress::from_str(typo).unwrap();
        assert_ne!(addr1, addr2);
        println!("✓ {} vs {} - Both valid, no error detection", original, typo);
    }
}
```

This PoC demonstrates that any single-character typo in an address string parses successfully without error, enabling permanent fund loss.

## Notes
While this issue doesn't break consensus or core protocol invariants, it represents a critical user safety vulnerability that enables both accidental fund loss and attacker exploitation. The lack of checksum validation is inconsistent with industry standards (Bitcoin, Ethereum) and should be addressed to protect users. The fix requires adding checksum validation to address parsing while maintaining backward compatibility for existing on-chain addresses.

### Citations

**File:** crates/aptos-rest-client/src/faucet.rs (L84-87)
```rust
    pub async fn fund(&self, address: AccountAddress, amount: u64) -> Result<()> {
        let mut url = self.faucet_url.clone();
        url.set_path("mint");
        let query = format!("auth_key={}&amount={}&return_txns=true", address, amount);
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L55-76)
```rust
    pub fn receiver(&self) -> Option<AccountAddress> {
        if let Some(auth_key) = self.auth_key.as_ref() {
            return match AccountAddress::from_hex_literal(auth_key) {
                Ok(auth_key) => Some(auth_key),
                Err(_) => AccountAddress::from_hex(auth_key).ok(),
            };
        }
        if let Some(address) = self.address.as_ref() {
            return match AccountAddress::from_hex_literal(address) {
                Ok(address) => Some(address),
                Err(_) => AccountAddress::from_hex(address).ok(),
            };
        }
        if let Some(pub_key) = self.pub_key.as_ref() {
            return match Ed25519PublicKey::from_encoded_string(pub_key) {
                Ok(pub_key) => Some(AuthenticationKey::ed25519(&pub_key).account_address()),
                Err(_) => None,
            };
        }
        None
    }
}
```

**File:** third_party/move/move-core/types/src/account_address.rs (L86-108)
```rust
    /// Represent an account address in a way that is compliant with the v1 address
    /// standard. The standard is defined as part of AIP-40, read more here:
    /// <https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md>
    ///
    /// In short, all special addresses MUST be represented in SHORT form, e.g.
    ///
    /// 0x1
    ///
    /// All other addresses MUST be represented in LONG form, e.g.
    ///
    /// 0x002098630cfad4734812fa37dc18d9b8d59242feabe49259e26318d468a99584
    ///
    /// For an explanation of what defines a "special" address, see `is_special`.
    ///
    /// All string representations of addresses MUST be prefixed with 0x.
    pub fn to_standard_string(&self) -> String {
        let suffix = if self.is_special() {
            self.short_str_lossless()
        } else {
            self.to_canonical_string()
        };
        format!("0x{}", suffix)
    }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L160-178)
```rust
    pub fn from_hex_literal(literal: &str) -> Result<Self, AccountAddressParseError> {
        if !literal.starts_with("0x") {
            return Err(AccountAddressParseError::LeadingZeroXRequired);
        }

        let hex_len = literal.len() - 2;

        // If the string is too short, pad it
        if hex_len < Self::LENGTH * 2 {
            let mut hex_str = String::with_capacity(Self::LENGTH * 2);
            for _ in 0..Self::LENGTH * 2 - hex_len {
                hex_str.push('0');
            }
            hex_str.push_str(&literal[2..]);
            AccountAddress::from_hex(hex_str)
        } else {
            AccountAddress::from_hex(&literal[2..])
        }
    }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L187-191)
```rust
    pub fn from_hex<T: AsRef<[u8]>>(hex: T) -> Result<Self, AccountAddressParseError> {
        <[u8; Self::LENGTH]>::from_hex(hex)
            .map_err(|e| AccountAddressParseError::InvalidHexChars(format!("{:#}", e)))
            .map(Self)
    }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L369-403)
```rust
impl FromStr for AccountAddress {
    type Err = AccountAddressParseError;

    /// NOTE: This function has relaxed parsing behavior. For strict behavior, please use
    /// the `from_str_strict` function. Where possible use `from_str_strict` rather than
    /// this function.
    ///
    /// Create an instance of AccountAddress by parsing a hex string representation.
    ///
    /// This function allows all formats defined by AIP-40. In short this means the
    /// following formats are accepted:
    ///
    /// - LONG, with or without leading 0x
    /// - SHORT, with or without leading 0x
    ///
    /// Where:
    ///
    /// - LONG is 64 hex characters.
    /// - SHORT is 1 to 63 hex characters inclusive.
    ///
    /// Learn more about the different address formats by reading AIP-40:
    /// <https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md>.
    fn from_str(s: &str) -> Result<Self, AccountAddressParseError> {
        if !s.starts_with("0x") {
            if s.is_empty() {
                return Err(AccountAddressParseError::TooShort);
            }
            AccountAddress::from_hex_literal(&format!("0x{}", s))
        } else {
            if s.len() == 2 {
                return Err(AccountAddressParseError::TooShort);
            }
            AccountAddress::from_hex_literal(s)
        }
    }
```
