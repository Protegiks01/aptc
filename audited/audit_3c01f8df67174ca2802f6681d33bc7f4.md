# Audit Report

## Title
Indexer Block Height Assignment Lacks Validation, Causing Persistent Data Inconsistency

## Summary
The Aptos indexer's `Signature` model stores `transaction_block_height` based on manually tracked block height rather than querying an authoritative source for each transaction. This manual tracking lacks validation and can become inconsistent with the actual blockchain state under error conditions, breaking block-based queries and requiring manual database intervention.

## Finding Description

The indexer's transaction fetcher manually tracks block height using a counter that is initialized once per batch and incremented when `BlockMetadata` transactions are encountered. This tracked value is then assigned to all transactions without cross-validation against the authoritative blockchain state. [1](#0-0) 

The initial block height is determined by calling `get_block_info_by_version(starting_version)`, which retrieves block information from the database. However, if this returns stale or incorrect data due to database corruption, read inconsistencies, or race conditions during reorganizations, all subsequent transactions in the batch inherit this incorrect value. [2](#0-1) 

The block height is incremented only when encountering `BlockMetadata` transactions. If a `BlockMetadata` transaction is missing, corrupted, or the batch processing encounters an error, the block height counter will not advance correctly, causing all subsequent transactions to be assigned to the wrong block. [3](#0-2) 

This manually tracked block height is then propagated to the `Signature` model through the transaction processing pipeline: [4](#0-3) [5](#0-4) [6](#0-5) 

The `Signature` struct stores this value in the `transaction_block_height` field without any validation: [7](#0-6) 

Critically, the database schema has no foreign key constraint or validation check to ensure the `transaction_block_height` in the signatures table matches the actual `block_height` in the transactions table: [8](#0-7) 

The insert operation uses `on_conflict().do_nothing()` with no validation: [9](#0-8) 

**Breaking Invariant:** This violates the **State Consistency** invariant - the indexer's state should accurately reflect the blockchain state. Once incorrect block heights are written to the database, they persist indefinitely, breaking block-based queries and requiring manual database correction.

## Impact Explanation

This issue falls under **Medium Severity** per the Aptos bug bounty program:
- **State inconsistencies requiring intervention**: Incorrect block heights in the signatures table create persistent data inconsistency that cannot self-correct
- **Breaking block-based queries**: Applications and analytics tools that query signatures by block height will receive incorrect results
- **No automatic recovery**: Unlike transient errors, this persists in the database until manually corrected

While this does not directly affect consensus or allow fund theft, it compromises the integrity of the indexerâ€”a critical infrastructure component that applications rely on for querying blockchain data. Incorrect block associations could lead to:
- Analytics dashboards showing wrong block statistics
- Applications making incorrect decisions based on block-grouped transaction data
- Auditing and compliance issues when block associations are inaccurate

## Likelihood Explanation

**Medium to High Likelihood** of occurrence under certain conditions:

1. **Database read inconsistencies**: During high load or concurrent writes, `get_block_info_by_version` could return stale data
2. **Blockchain reorganizations**: Race conditions during reorgs could cause the initial block height determination to be incorrect
3. **Database corruption**: Storage layer corruption could provide incorrect block height information
4. **Indexer restarts**: If the indexer crashes and restarts mid-batch, it may reinitialize with incorrect block height
5. **Data migration or recovery**: Database restoration from backups could create temporary inconsistencies

The special case handling for the first transaction in a batch increases risk: [10](#0-9) 

If the first transaction is a `BlockMetadata` but `get_block_info_by_version` returns the previous block's height, the entire batch gets assigned wrong block heights.

## Recommendation

Implement validation to cross-check the manually tracked block height against the authoritative blockchain state:

1. **Add per-transaction validation**: For each transaction, query the actual block height from the database and compare it against the tracked value:

```rust
// In fetch_nexts function, after assigning block_height
let actual_block_height = context
    .db
    .metadata_db()
    .get_block_height_by_version(raw_txn.version)
    .expect("Failed to get actual block height");

if actual_block_height != block_height {
    error!(
        version = raw_txn.version,
        tracked_height = block_height,
        actual_height = actual_block_height,
        "Block height mismatch detected!"
    );
    // Either panic to force investigation, or use actual_block_height
    block_height = actual_block_height;
    block_height_bcs = aptos_api_types::U64::from(block_height);
}
```

2. **Add database constraint**: Create a foreign key or check constraint in the database schema to validate `transaction_block_height` against the transactions table.

3. **Add reconciliation process**: Implement a periodic job that validates signatures table block heights against the transactions table and reports/fixes inconsistencies.

4. **Improve error handling**: Instead of manual tracking, query the authoritative block height for each transaction directly from the storage layer.

## Proof of Concept

```rust
// Reproduction scenario (conceptual - would require database mocking)
// 
// 1. Set up indexer with starting_version = 1000
// 2. Mock get_block_info_by_version(1000) to return block_height = 99
//    (simulating database corruption or stale read)
// 3. Feed transactions to indexer:
//    - Version 1000: BlockMetadata for block 100
//    - Versions 1001-1009: User transactions in block 100
//    - Version 1010: BlockMetadata for block 101
//    - Versions 1011-1019: User transactions in block 101
//
// Expected behavior (correct):
//    - All signatures for versions 1000-1009 should have transaction_block_height = 100
//    - All signatures for versions 1010-1019 should have transaction_block_height = 101
//
// Actual behavior (buggy):
//    - All signatures for versions 1000-1009 have transaction_block_height = 99 (WRONG!)
//    - All signatures for versions 1010-1019 have transaction_block_height = 100 (WRONG!)
//
// Verification query:
// SELECT s.transaction_version, s.transaction_block_height, t.block_height
// FROM signatures s
// JOIN transactions t ON s.transaction_version = t.version
// WHERE s.transaction_block_height != t.block_height;
//
// This query would return mismatched rows, proving the data inconsistency.
```

## Notes

This vulnerability is specific to the indexer component and does not affect consensus or the blockchain itself. However, the indexer is critical infrastructure that applications depend on for reliable data access. The lack of validation creates a **silent data corruption** risk where incorrect block heights persist in the database without triggering any alerts, potentially affecting all downstream applications and analytics that rely on block-based queries.

### Citations

**File:** crates/indexer/src/indexer/fetcher.rs (L229-242)
```rust
    let (_, _, block_event) = context
        .db
        .get_block_info_by_version(starting_version)
        .unwrap_or_else(|_| {
            panic!(
                "Could not get block_info for start version {}",
                starting_version,
            )
        });
    let mut timestamp = block_event.proposed_time();
    let mut epoch = block_event.epoch();
    let mut epoch_bcs = aptos_api_types::U64::from(epoch);
    let mut block_height = block_event.height();
    let mut block_height_bcs = aptos_api_types::U64::from(block_height);
```

**File:** crates/indexer/src/indexer/fetcher.rs (L250-265)
```rust
        // Do not update block_height if first block is block metadata
        if ind > 0 {
            // Update the timestamp if the next block occurs
            if let Some(txn) = raw_txn.transaction.try_as_block_metadata_ext() {
                timestamp = txn.timestamp_usecs();
                epoch = txn.epoch();
                epoch_bcs = aptos_api_types::U64::from(epoch);
                block_height += 1;
                block_height_bcs = aptos_api_types::U64::from(block_height);
            } else if let Some(txn) = raw_txn.transaction.try_as_block_metadata() {
                timestamp = txn.timestamp_usecs();
                epoch = txn.epoch();
                epoch_bcs = aptos_api_types::U64::from(epoch);
                block_height += 1;
                block_height_bcs = aptos_api_types::U64::from(block_height);
            }
```

**File:** crates/indexer/src/indexer/fetcher.rs (L274-297)
```rust
                    Transaction::UserTransaction(ref mut ut) => {
                        ut.info.block_height = Some(block_height_bcs);
                        ut.info.epoch = Some(epoch_bcs);
                    },
                    Transaction::GenesisTransaction(ref mut gt) => {
                        gt.info.block_height = Some(block_height_bcs);
                        gt.info.epoch = Some(epoch_bcs);
                    },
                    Transaction::BlockMetadataTransaction(ref mut bmt) => {
                        bmt.info.block_height = Some(block_height_bcs);
                        bmt.info.epoch = Some(epoch_bcs);
                    },
                    Transaction::StateCheckpointTransaction(ref mut sct) => {
                        sct.info.block_height = Some(block_height_bcs);
                        sct.info.epoch = Some(epoch_bcs);
                    },
                    Transaction::BlockEpilogueTransaction(ref mut bet) => {
                        bet.info.block_height = Some(block_height_bcs);
                        bet.info.epoch = Some(epoch_bcs);
                    },
                    Transaction::ValidatorTransaction(ref mut st) => {
                        let info = st.transaction_info_mut();
                        info.block_height = Some(block_height_bcs);
                        info.epoch = Some(epoch_bcs);
```

**File:** crates/indexer/src/models/transactions.rs (L112-122)
```rust
        let block_height = transaction
            .transaction_info()
            .unwrap()
            .block_height
            .unwrap()
            .0 as i64;
        let epoch = transaction.transaction_info().unwrap().epoch.unwrap().0 as i64;
        match transaction {
            APITransaction::UserTransaction(user_txn) => {
                let (user_txn_output, signatures) =
                    UserTransaction::from_transaction(user_txn, block_height, epoch);
```

**File:** crates/indexer/src/models/user_transactions.rs (L100-118)
```rust
    pub fn get_signatures(
        txn: &APIUserTransaction,
        version: i64,
        block_height: i64,
    ) -> Vec<Signature> {
        txn.request
            .signature
            .as_ref()
            .map(|s| {
                Signature::from_user_transaction(
                    s,
                    &txn.request.sender.to_string(),
                    version,
                    block_height,
                )
                .unwrap()
            })
            .unwrap_or_default()
    }
```

**File:** crates/indexer/src/models/signatures.rs (L30-42)
```rust
pub struct Signature {
    pub transaction_version: i64,
    pub multi_agent_index: i64,
    pub multi_sig_index: i64,
    pub transaction_block_height: i64,
    pub signer: String,
    pub is_sender_primary: bool,
    pub type_: String,
    pub public_key: String,
    pub signature: String,
    pub threshold: i64,
    pub public_key_indices: serde_json::Value,
}
```

**File:** crates/indexer/src/models/signatures.rs (L46-62)
```rust
    pub fn from_user_transaction(
        s: &APITransactionSignature,
        sender: &String,
        transaction_version: i64,
        transaction_block_height: i64,
    ) -> Result<Vec<Self>> {
        match s {
            APITransactionSignature::Ed25519Signature(sig) => {
                Ok(vec![Self::parse_ed25519_signature(
                    sig,
                    sender,
                    transaction_version,
                    transaction_block_height,
                    true,
                    0,
                    None,
                )])
```

**File:** crates/indexer/src/schema.rs (L642-660)
```rust
    signatures (transaction_version, multi_agent_index, multi_sig_index, is_sender_primary) {
        transaction_version -> Int8,
        multi_agent_index -> Int8,
        multi_sig_index -> Int8,
        transaction_block_height -> Int8,
        #[max_length = 66]
        signer -> Varchar,
        is_sender_primary -> Bool,
        #[sql_name = "type"]
        type_ -> Varchar,
        #[max_length = 66]
        public_key -> Varchar,
        #[max_length = 200]
        signature -> Varchar,
        threshold -> Int8,
        public_key_indices -> Jsonb,
        inserted_at -> Timestamp,
    }
}
```

**File:** crates/indexer/src/processors/default_processor.rs (L230-250)
```rust
fn insert_signatures(
    conn: &mut PgConnection,
    items_to_insert: &[Signature],
) -> Result<(), diesel::result::Error> {
    use schema::signatures::dsl::*;
    let chunks = get_chunks(items_to_insert.len(), Signature::field_count());
    for (start_ind, end_ind) in chunks {
        execute_with_better_error(
            conn,
            diesel::insert_into(schema::signatures::table)
                .values(&items_to_insert[start_ind..end_ind])
                .on_conflict((
                    transaction_version,
                    multi_agent_index,
                    multi_sig_index,
                    is_sender_primary,
                ))
                .do_nothing(),
            None,
        )?;
    }
```
