# Audit Report

## Title
Compiler Pipeline Ordering Vulnerability: `seqs_in_binop_checker` Bypass via `inlining_optimization`

## Summary
The Move compiler v2 contains a pipeline ordering vulnerability where the `seqs_in_binop_checker` runs before the initial inlining pass but a second optimization pass (`inlining_optimization`) runs afterward without re-checking. This allows Move language version < 2.0 code with sequences in binary operations to bypass the language specification enforcement when `OPTIMIZE_EXTRA` is enabled.

## Finding Description

The Move compiler v2 implements a checker (`seqs_in_binop_checker`) to enforce language semantics for sequences within binary operations. For Move language versions < 2.0, sequences in binary operations are explicitly prohibited because the v1 compiler had undefined evaluation order semantics. [1](#0-0) 

The checker's documentation explicitly states it must run before inlining. [2](#0-1) 

However, the compiler pipeline has TWO separate inlining systems:

1. **First inlining pass** (`inliner.rs`): Handles functions marked with the `inline` keyword, runs at line 405 of the pipeline [3](#0-2) 

2. **Second inlining pass** (`inlining_optimization.rs`): An optimization that can inline ANY regular function (not just `inline` functions), runs at line 479 in the optimization pipeline [4](#0-3) 

The `seqs_in_binop_checker` only runs ONCE before the first inlining pass: [5](#0-4) 

The problem occurs in the compilation flow:
1. Line 102: `seqs_in_binop_checker` runs and validates code
2. Line 110-123: Stackless bytecode generation and checks
3. Line 129: **Optimization pipeline runs** including `inlining_optimization` [6](#0-5) 

The `inlining_optimization` pass transforms function calls into Block expressions containing sequences: [7](#0-6) 

When a function containing sequences with side effects is inlined into a binary operation context, the result is a sequence within a binary operation—exactly what the checker is designed to prevent.

**Attack Scenario:**

```move
module test::exploit {
    // Regular function (NOT marked inline) with sequences and side effects
    public fun helper(x: &mut u64): u64 {
        *x = *x + 1;  // Sequence with mutation
        *x
    }
    
    // Called multiple times in binary operation
    public fun vulnerable(): u64 {
        let x = 0;
        helper(&mut x) + helper(&mut x)  // Passes seqs_in_binop_checker
    }
}
```

Before `seqs_in_binop_checker`: Sees only function calls, no error
After `inlining_optimization` (if enabled): Results in `{*x = *x + 1; *x} + {*x = *x + 1; *x}` - sequences in binary operation!

## Impact Explanation

This constitutes a **High Severity** issue under "Significant protocol violations" because:

1. **Language Specification Violation**: For Move language version < 2.0, sequences in binary operations are explicitly prohibited by specification. This bypass allows code that violates language semantics to be compiled.

2. **Compiler Inconsistency**: Different optimization levels (OPTIMIZE_EXTRA on/off) produce different compilation results—code rejected vs accepted—for the same source file.

3. **Version Compatibility Break**: Undermines Move's language version guarantees where < 2.0 should uniformly reject these patterns.

However, this does NOT directly cause:
- Consensus divergence (bytecode generation remains deterministic)
- Funds loss
- State corruption
- Network partition

The `inlining_optimization` is controlled by the `OPTIMIZE_EXTRA` flag which defaults to OFF: [8](#0-7) 

## Likelihood Explanation

**Likelihood: Low to Medium**

Required conditions:
1. Move language version < 2.0
2. `OPTIMIZE_EXTRA` flag explicitly enabled (defaults to OFF) OR `INLINING_OPTIMIZATION` explicitly enabled
3. Code pattern with functions containing sequences that meet inlining criteria (code size < 128, no returns, no aborts, etc.)
4. These functions called in binary operation contexts

The `OPTIMIZE_EXTRA` flag defaults to false, significantly reducing likelihood: [9](#0-8) 

## Recommendation

**Solution 1: Re-run checker after optimization pipeline**

Add a second invocation of `seqs_in_binop_checker` after the optimization pipeline in `env_optimization_pipeline`:

```rust
pub fn env_optimization_pipeline<'a, 'b>(options: &'a Options) -> EnvProcessorPipeline<'b> {
    let mut env_pipeline = EnvProcessorPipeline::<'b>::default();
    
    // ... existing optimization passes ...
    
    // Re-check sequences in binops after optimizations that may have inlined code
    let check_seqs_in_binops = !options
        .language_version
        .unwrap_or_default()
        .is_at_least(LanguageVersion::V2_0)
        && options.experiment_on(Experiment::SEQS_IN_BINOPS_CHECK);
    if check_seqs_in_binops {
        env_pipeline.add("binop side effect check after optimization", |env| {
            seqs_in_binop_checker::checker(env)
        });
    }
    
    env_pipeline
}
```

**Solution 2: Guard inlining_optimization**

Prevent `inlining_optimization` from inlining functions that would create sequences in binary operations when language version < 2.0.

## Proof of Concept

```move
// File: test_seqs_bypass.move
module 0x1::seqs_bypass_test {
    
    // Helper function with sequence and side effect
    fun increment_and_return(x: &mut u64): u64 {
        *x = *x + 1;  // Side effect: mutation
        *x            // Return modified value
    }
    
    // This should be rejected for Move < 2.0 but passes when
    // compiled without OPTIMIZE_EXTRA, then fails when 
    // OPTIMIZE_EXTRA inlines increment_and_return
    public fun test_bypass(): u64 {
        let value = 0;
        // After inlining, this becomes:
        // {value = value + 1; value} + {value = value + 1; value}
        // which is a sequence in binary operation
        increment_and_return(&mut value) + increment_and_return(&mut value)
    }
}
```

**Compilation steps to reproduce:**
1. Compile with Move compiler v2, language version 1.x, without `OPTIMIZE_EXTRA`: Code compiles (checker sees only function calls)
2. Compile same code with `OPTIMIZE_EXTRA` enabled: Code still compiles but now contains sequences in binops
3. Expected: Should be rejected in both cases for language version < 2.0

**Note**: While this violates language semantics, the generated bytecode remains deterministic, so it does not cause consensus divergence in practice.

### Citations

**File:** third_party/move/move-compiler-v2/src/env_pipeline/seqs_in_binop_checker.rs (L4-19)
```rust
//! Pre-requisites: this checker should be run before inlining in its current
//! incarnation.
//
//! This module implements a checker that looks for non-trivial sequences
//! within binary operations. The v1 compiler's evaluation order semantics
//! in the presence of sequences within binary operations are not easily
//! understood or explainable (see examples below).
//!
//! Therefore, in compiler v2 (and above), if the language version is less than
//! 2.0, we will emit an error in such cases. We expect such uses to be rare,
//! and the user can easily rewrite the code to get explicit evaluation order
//! that they want.
//!
//! In language version 2.0 and above, we will allow sequences within binary
//! operations, but the evaluation order will be consistently left-to-right,
//! following the evaluation order semantics used in normal function calls.
```

**File:** third_party/move/move-compiler-v2/src/lib.rs (L126-130)
```rust
    // AST to perform other AST-transforming optimizations.
    // If we do such AST-transforming optimizations before the stackless bytecode
    // checks, it can result in missed and/or incorrect warnings.
    env_optimization_pipeline(&options).run(&mut env);
    check_errors(&env, emitter, "env optimization errors")?;
```

**File:** third_party/move/move-compiler-v2/src/lib.rs (L365-375)
```rust
    let check_seqs_in_binops = !options
        .language_version
        .unwrap_or_default()
        .is_at_least(LanguageVersion::V2_0)
        && options.experiment_on(Experiment::SEQS_IN_BINOPS_CHECK);
    if check_seqs_in_binops {
        env_pipeline.add("binop side effect check", |env| {
            // This check should be done before inlining.
            seqs_in_binop_checker::checker(env)
        });
    }
```

**File:** third_party/move/move-compiler-v2/src/lib.rs (L397-410)
```rust
    if options.experiment_on(Experiment::INLINING) {
        let rewriting_scope = if options.whole_program {
            RewritingScope::Everything
        } else {
            RewritingScope::CompilationTarget
        };
        let keep_inline_funs = options.experiment_on(Experiment::KEEP_INLINE_FUNS);
        let lift_inline_funs = options.experiment_on(Experiment::LIFT_INLINE_FUNS);
        env_pipeline.add("inlining", {
            move |env| {
                inliner::run_inlining(env, rewriting_scope, keep_inline_funs, lift_inline_funs)
            }
        });
    }
```

**File:** third_party/move/move-compiler-v2/src/lib.rs (L472-484)
```rust
    let do_inlining_optimization = options.experiment_on(Experiment::INLINING_OPTIMIZATION);
    if do_inlining_optimization {
        // This allows inlining a call that comes from a different package
        let across_package = options.experiment_on(Experiment::ACROSS_PACKAGE_INLINING);
        // This allows performing an inlining optimization to a function that does not belong to the primary target package
        let allow_non_primary_targets =
            options.experiment_on(Experiment::INLINING_OPTIMIZATION_TO_NON_PRIMARY_TARGETS);
        env_pipeline.add("inlining optimization", {
            move |env: &mut GlobalEnv| {
                inlining_optimization::optimize(env, across_package, allow_non_primary_targets)
            }
        });
    }
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inlining_optimization.rs (L628-667)
```rust
    fn construct_inlined_call_expression(
        &self,
        call_site_loc: &Loc,
        body: Exp,
        params_pattern: Pattern,
        args: Vec<Exp>,
    ) -> Exp {
        let body_node_id = body.as_ref().node_id();
        let body_type = self.env.get_node_type(body_node_id);
        let body_loc = self
            .env
            .get_node_loc(body_node_id)
            .inlined_from(call_site_loc);

        let new_block_id = self.env.new_node(body_loc, body_type);

        let optional_binding_exp = if args.is_empty() {
            None
        } else {
            let args_node_ids = args
                .iter()
                .map(|e| e.as_ref().node_id())
                .collect::<Vec<_>>();
            let args_types = args_node_ids
                .iter()
                .map(|id| self.env.get_node_type(*id))
                .collect::<Vec<_>>();
            let args_loc = Loc::enclosing(
                args_node_ids
                    .iter()
                    .map(|id| self.env.get_node_loc(*id))
                    .collect::<Vec<_>>()
                    .as_slice(),
            );
            let new_binding_id = self.env.new_node(args_loc, Type::Tuple(args_types));
            Some(ExpData::Call(new_binding_id, Operation::Tuple, args).into_exp())
        };

        ExpData::Block(new_block_id, params_pattern, optional_binding_exp, body).into_exp()
    }
```

**File:** third_party/move/move-compiler-v2/src/experiments.rs (L110-113)
```rust
            name: Experiment::INLINING_OPTIMIZATION.to_string(),
            description: "Turns on or off inlining optimizations".to_string(),
            default: Inherited(Experiment::OPTIMIZE_EXTRA.to_string()),
        },
```

**File:** third_party/move/move-compiler-v2/src/experiments.rs (L156-159)
```rust
            name: Experiment::OPTIMIZE_EXTRA.to_string(),
            description: "Use extra optimizations".to_string(),
            default: Given(false),
        },
```
