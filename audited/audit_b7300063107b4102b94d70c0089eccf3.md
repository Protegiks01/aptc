# Audit Report

## Title
Missing Signature Verification on Incoming CommitDecision Messages Enables Validator DoS Attack

## Summary
The consensus pipeline accepts `CommitDecision` messages containing commit proofs (`LedgerInfoWithSignatures`) from network peers without verifying the BLS aggregate signatures. When order votes are enabled and blocks are in the Ordered state, these unverified commit proofs are accepted using only weak validation (`match_ordered_only()`), which checks epoch/round/block ID but not the state root. When execution completes with a different state root, an assertion failure crashes the validator node. [1](#0-0) 

## Finding Description

The `commit_info()` function returns the `BlockInfo` from the inner `LedgerInfo` without any validation, relying on upstream validation that is missing in a critical code path. [2](#0-1) 

The `match_ordered_only()` function only validates epoch, round, block ID, and timestamp - **it explicitly does not validate the `executed_state_id` (state root) or `version` fields**. [3](#0-2) 

When receiving a `CommitMessage::Decision`, the `process_commit_message()` function accepts the commit proof and forwards it to `try_advance_to_aggregated_with_ledger_info()` **without calling `verify()` to check signatures**. [4](#0-3) 

When the buffer item is in the `Ordered` state (before execution completes), `try_advance_to_aggregated_with_ledger_info()` uses `match_ordered_only()` to validate the incoming commit proof, allowing arbitrary state roots to be accepted. [5](#0-4) 

Later, when execution completes and `advance_to_executed_or_aggregated()` is called, line 149 performs `assert_eq!(commit_proof.commit_info().clone(), commit_info)` which compares **all fields including the state root**. If the attacker's injected state root doesn't match the locally computed one, this assertion fails and the validator process crashes. [6](#0-5) 

While `CommitDecision::verify()` exists and properly validates signatures, it is never invoked on incoming network messages in the consensus pipeline.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria because it enables "Validator node slowdowns" and crashes. An attacker can:

1. Target multiple validators simultaneously
2. Cause validators in the Ordered state to crash when execution completes
3. Potentially disrupt network liveness if enough validators are affected
4. Repeat the attack as validators restart

The vulnerability does NOT allow successful state root manipulation of committed blocks (which would be Critical severity), as the assertion failure prevents the bad state from being committed. However, it creates a reliable denial-of-service vector against validator nodes when order votes are enabled.

## Likelihood Explanation

**High likelihood** of occurrence when order votes are enabled:

1. **No authentication required**: Any network peer can send `CommitDecision` messages
2. **Wide attack window**: All validators processing blocks in the Ordered state are vulnerable
3. **Deterministic trigger**: The assertion failure is guaranteed when state roots mismatch
4. **Simple exploit**: Attacker only needs to craft a `CommitDecision` with an arbitrary state root for an in-progress block

The attack is straightforward and doesn't require validator compromise, making it easily exploitable by external attackers.

## Recommendation

Add signature verification for incoming `CommitDecision` messages before accepting them. Modify `process_commit_message()` in `buffer_manager.rs`:

```rust
CommitMessage::Decision(commit_proof) => {
    // Verify signatures before processing
    if let Err(e) = commit_proof.verify(&self.epoch_state.verifier) {
        error!("Invalid commit proof signature: {:?}", e);
        reply_nack(protocol, response_sender);
        return None;
    }
    
    let target_block_id = commit_proof.ledger_info().commit_info().id();
    // ... rest of existing logic
}
```

Additionally, replace the `assert_eq!` at line 149 of `buffer_item.rs` with proper error handling:

```rust
if commit_proof.commit_info().clone() != commit_info {
    error!("Commit proof state root mismatch: expected {:?}, got {:?}", 
           commit_info, commit_proof.commit_info());
    // Return error instead of panicking
    return Err(anyhow!("State root mismatch"));
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// Place in consensus/src/pipeline/tests/buffer_manager_tests.rs

#[test]
fn test_unverified_commit_decision_causes_crash() {
    // Setup: Create a validator with order votes enabled
    let (validator_signers, validator_verifier) = create_validators();
    let mut buffer_manager = create_buffer_manager(true); // order_vote_enabled = true
    
    // Step 1: Insert an ordered block (not yet executed)
    let block = create_test_block();
    let ordered_proof = create_ordered_proof(&block);
    buffer_manager.add_ordered_block(block.clone(), ordered_proof);
    
    // Step 2: Attacker crafts malicious CommitDecision with wrong state root
    let malicious_block_info = BlockInfo::new(
        block.epoch(),
        block.round(),
        block.id(),
        HashValue::random(), // WRONG STATE ROOT
        0,
        block.timestamp_usecs(),
        None,
    );
    let malicious_ledger_info = LedgerInfo::new(
        malicious_block_info,
        HashValue::zero(),
    );
    let malicious_commit_proof = LedgerInfoWithSignatures::new(
        malicious_ledger_info,
        AggregateSignature::empty(), // No valid signatures!
    );
    
    // Step 3: Send malicious CommitDecision (accepted without verification)
    let commit_msg = IncomingCommitRequest {
        req: CommitMessage::Decision(CommitDecision::new(malicious_commit_proof)),
        protocol: RPC[0],
        response_sender: oneshot::channel().0,
    };
    
    // This should verify signatures but doesn't!
    buffer_manager.process_commit_message(commit_msg);
    
    // Step 4: Execute the block with correct state root
    let executed_blocks = execute_block_locally(&block);
    
    // Step 5: Advance to executed - THIS PANICS due to assert_eq! failure
    // Because malicious state root != actual state root
    buffer_manager.process_execution_response(ExecutionResponse {
        block_id: block.id(),
        inner: Ok(executed_blocks),
    });
    
    // Expected: Validator process crashes with assertion failure
    // Actual: Should reject unverified commit decision
}
```

**Notes:**
- This vulnerability specifically affects the order vote optimization path where blocks are ordered before execution
- The missing signature verification violates the fundamental security property that commit proofs must have valid quorum signatures
- The issue demonstrates why defense-in-depth is critical: even though `commit_info()` itself doesn't validate, the system should validate at message receipt boundaries

### Citations

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L81-83)
```rust
    pub fn commit_info(&self) -> &BlockInfo {
        self.ledger_info().ledger_info().commit_info()
    }
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L786-812)
```rust
            CommitMessage::Decision(commit_proof) => {
                let target_block_id = commit_proof.ledger_info().commit_info().id();
                info!(
                    "Receive commit decision {}",
                    commit_proof.ledger_info().commit_info()
                );
                let cursor = self
                    .buffer
                    .find_elem_by_key(*self.buffer.head_cursor(), target_block_id);
                if cursor.is_some() {
                    let item = self.buffer.take(&cursor);
                    let new_item = item.try_advance_to_aggregated_with_ledger_info(
                        commit_proof.ledger_info().clone(),
                    );
                    let aggregated = new_item.is_aggregated();
                    self.buffer.set(&cursor, new_item);

                    reply_ack(protocol, response_sender);
                    if aggregated {
                        return Some(target_block_id);
                    }
                } else if self.try_add_pending_commit_proof(commit_proof.into_inner()) {
                    reply_ack(protocol, response_sender);
                } else {
                    reply_nack(protocol, response_sender); // TODO: send_commit_proof() doesn't care about the response and this should be direct send not RPC
                }
            },
```

**File:** consensus/src/pipeline/buffer_item.rs (L146-157)
```rust
                if let Some(commit_proof) = commit_proof {
                    // We have already received the commit proof in fast forward sync path,
                    // we can just use that proof and proceed to aggregated
                    assert_eq!(commit_proof.commit_info().clone(), commit_info);
                    debug!(
                        "{} advance to aggregated from ordered",
                        commit_proof.commit_info()
                    );
                    Self::Aggregated(Box::new(AggregatedItem {
                        executed_blocks,
                        commit_proof,
                    }))
```

**File:** consensus/src/pipeline/buffer_item.rs (L272-286)
```rust
            Self::Ordered(ordered_item) => {
                let ordered = *ordered_item;
                assert!(ordered
                    .ordered_proof
                    .commit_info()
                    .match_ordered_only(commit_proof.commit_info()));
                // can't aggregate it without execution, only store the signatures
                debug!(
                    "{} received commit decision in ordered stage",
                    commit_proof.commit_info()
                );
                Self::Ordered(Box::new(OrderedItem {
                    commit_proof: Some(commit_proof),
                    ..ordered
                }))
```

**File:** consensus/consensus-types/src/pipeline/commit_decision.rs (L49-59)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            !self.ledger_info.commit_info().is_ordered_only(),
            "Unexpected ordered only commit info"
        );
        // We do not need to check the author because as long as the signature tree
        // is valid, the message should be valid.
        self.ledger_info
            .verify_signatures(validator)
            .context("Failed to verify Commit Decision")
    }
```
