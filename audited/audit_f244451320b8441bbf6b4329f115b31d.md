# Audit Report

## Title
Unbounded Staking Contracts Growth Enables Rosetta API Denial of Service

## Summary
The Rosetta API's balance query endpoint is vulnerable to a resource exhaustion attack due to unbounded growth of the `staking_contracts` vector in the `Store` resource. An attacker can create hundreds or thousands of staking contracts with different operators, causing the balance query to iterate through all contracts and make thousands of RPC calls, leading to service degradation or complete API unavailability.

## Finding Description

The vulnerability exists in the interaction between the on-chain staking contract storage and the Rosetta API's balance query implementation.

**On-Chain Component:**
The `Store` struct in the staking contract module uses a `SimpleMap` to store staking contracts, which is backed by an unbounded vector: [1](#0-0) 

The `SimpleMap` implementation has no size limits and simply uses a vector to store elements: [2](#0-1) 

The staking contract module explicitly supports multiple contracts per staker with different operators: [3](#0-2) 

**Rosetta API Component:**
When querying an account balance, the Rosetta API retrieves the entire `Store` resource and iterates through ALL staking contracts without any pagination or limits: [4](#0-3) 

For each staking contract, the API makes multiple RPC calls to fetch stake balances: [5](#0-4) 

Each `get_stake_balances` call performs at least two RPC operations - retrieving the StakePool resource and calling the `staking_contract_amounts` view function: [6](#0-5) [7](#0-6) 

**Attack Path:**
1. Attacker funds an account with sufficient APT (e.g., 100M APT for 100 contracts)
2. Attacker repeatedly calls `create_staking_contract` with different operator addresses
3. Each contract requires minimum stake (1M APT on mainnet), but attacker can reuse capital after lockup or use multiple parallel contracts
4. Once N contracts exist (e.g., N=1000), any Rosetta balance query for that account will:
   - Deserialize a Store resource containing 1000 entries
   - Iterate through all 1000 contracts
   - Make 2000+ RPC calls to the underlying full node
   - Consume excessive CPU, memory, and network resources
5. This renders the Rosetta API unusable for that account and potentially affects other users if the service is overloaded

The same issue affects the transaction construction endpoint: [8](#0-7) 

## Impact Explanation

**Severity: High** (API crashes, Validator node slowdowns)

This vulnerability meets the High severity criteria from the Aptos bug bounty program:
- **API crashes**: The Rosetta API can become unresponsive or crash when processing balance queries for accounts with many staking contracts
- **Validator node slowdowns**: If the Rosetta service queries a validator node's full node, the excessive RPC calls (2N calls for N contracts) can degrade the validator's performance

The attack causes:
1. **Service unavailability**: Rosetta API becomes unusable for affected accounts
2. **Resource exhaustion**: Excessive memory usage from deserializing large Store resources
3. **Network congestion**: Thousands of RPC calls overwhelm the underlying full node
4. **Collateral damage**: If Rosetta shares infrastructure with validators, it can impact block production

While this doesn't directly affect consensus or cause fund loss, it violates the **Resource Limits** invariant which states "All operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is feasible for well-funded attackers:

**Capital Requirements:**
- Minimum stake: 1M APT per contract
- For 100 contracts: 100M APT (~$1M-10M USD depending on APT price)
- For 1000 contracts: 1B APT (~$10M-100M USD)

**Attack Complexity:**
- Low - simply call `create_staking_contract` repeatedly with different operator addresses
- No special privileges required
- No complex transaction sequencing needed

**Mitigation Factors:**
- Requires significant capital
- Capital is locked during stake lockup period (though can be withdrawn later)
- Attacker's own funds are at risk if APT price drops

**Amplification:**
- An attacker could use multiple accounts to spread the attack
- Once contracts are created, they persist indefinitely
- Every balance query triggers the DoS, not just the attacker's queries

## Recommendation

Implement pagination and limits in the Rosetta API's staking contract iteration:

**Option 1: Add Maximum Contract Limit**
```rust
// In crates/aptos-rosetta/src/account.rs
const MAX_STAKING_CONTRACTS_TO_PROCESS: usize = 100;

async fn get_staking_info(...) -> ApiResult<...> {
    // ... existing code ...
    if let Ok(response) = rest_client
        .get_account_resource_at_version_bcs(owner_address, "0x1::staking_contract::Store", version)
        .await
    {
        let store: Store = response.into_inner();
        maybe_operators = Some(vec![]);
        
        // Limit processing to prevent DoS
        let contracts_to_process = store.staking_contracts
            .iter()
            .take(MAX_STAKING_CONTRACTS_TO_PROCESS);
            
        for (operator, contract) in contracts_to_process {
            // ... existing processing logic ...
        }
        
        // Warn if there are more contracts than we processed
        if store.staking_contracts.len() > MAX_STAKING_CONTRACTS_TO_PROCESS {
            warn!(
                "Account {} has {} staking contracts, only processing first {}",
                owner_address, 
                store.staking_contracts.len(), 
                MAX_STAKING_CONTRACTS_TO_PROCESS
            );
        }
    }
}
```

**Option 2: Add On-Chain Limit (Stronger Fix)**
Add a maximum contract limit in the staking_contract.move module:
```move
// In staking_contract.move
const MAX_STAKING_CONTRACTS_PER_STAKER: u64 = 50;

public fun create_staking_contract_with_coins(...) {
    // ... existing validation ...
    
    let store = borrow_global_mut<Store>(staker_address);
    let staking_contracts = &mut store.staking_contracts;
    
    // Add limit check
    assert!(
        simple_map::length(staking_contracts) < MAX_STAKING_CONTRACTS_PER_STAKER,
        error::invalid_state(ETOO_MANY_STAKING_CONTRACTS)
    );
    
    // ... rest of function ...
}
```

**Recommended Approach:** Implement both options - add an on-chain limit for new contracts (Option 2) to prevent future abuse, and add API-level protection (Option 1) to handle existing accounts that may already have many contracts.

## Proof of Concept

**Move Test (Simplified):**
```move
#[test(aptos_framework = @0x1, staker = @0x100)]
public fun test_unbounded_staking_contracts(
    aptos_framework: &signer,
    staker: &signer,
) {
    // Initialize framework and fund staker
    // ... setup code ...
    
    // Create many staking contracts
    let num_contracts = 100;
    let i = 0;
    while (i < num_contracts) {
        let operator = @0x1000 + i;
        staking_contract::create_staking_contract(
            staker,
            operator,
            operator, // voter
            1_000_000 * 100_000_000, // 1M APT
            10, // 10% commission
            b"seed"
        );
        i = i + 1;
    };
    
    // At this point, Store has 100 staking contracts
    // Rosetta balance query would iterate all 100 and make 200+ RPC calls
}
```

**Rust Reproduction (Conceptual):**
```rust
// 1. Setup test account with sufficient APT
// 2. Loop to create N staking contracts:
for i in 0..1000 {
    let operator = AccountAddress::from_hex_literal(format!("0x{:x}", 0x1000 + i));
    // Call create_staking_contract via transaction
    // Each requires 1M APT minimum stake
}
// 3. Query Rosetta balance endpoint
// 4. Observe: 2000+ RPC calls, high latency, potential timeout/crash
```

**Notes**
- This vulnerability specifically affects the Rosetta API layer, not the core Aptos blockchain consensus
- The on-chain staking contract module functions correctly per its design - it intentionally allows multiple contracts per staker
- The issue is in the Rosetta implementation's assumption that the number of contracts would be small
- Existing accounts with many legitimate staking contracts may already trigger degraded performance
- The construction API endpoint has the same vulnerability when filling in operator information for accounts with multiple contracts

### Citations

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L90-91)
```text
    struct Store has key {
        staking_contracts: SimpleMap<address, StakingContract>,
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L439-440)
```text
        // Initialize the stake pool in a new resource account. This allows the same staker to contract with multiple
        // different operators.
```

**File:** aptos-move/framework/aptos-stdlib/sources/simple_map.move (L22-24)
```text
    struct SimpleMap<Key, Value> has copy, drop, store {
        data: vector<Element<Key, Value>>,
    }
```

**File:** crates/aptos-rosetta/src/account.rs (L218-224)
```rust
    if let Ok(response) = rest_client
        .get_account_resource_at_version_bcs(owner_address, "0x1::staking_contract::Store", version)
        .await
    {
        let store: Store = response.into_inner();
        maybe_operators = Some(vec![]);
        for (operator, contract) in store.staking_contracts {
```

**File:** crates/aptos-rosetta/src/account.rs (L227-243)
```rust
            match get_stake_balances(rest_client, account, contract.pool_address, version).await {
                Ok(Some(balance_result)) => {
                    if let Some(balance) = balance_result.balance {
                        has_staking = true;
                        total_balance += u64::from_str(&balance.value).unwrap_or_default();
                    }
                    // TODO: This seems like it only works if there's only one staking contract (hopefully it stays that way)
                    lockup_expiration = balance_result.lockup_expiration;
                },
                result => {
                    warn!(
                        "Failed to retrieve requested balance for account: {}, address: {}: {:?}",
                        owner_address, contract.pool_address, result
                    )
                },
            }
        }
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L297-299)
```rust
    if let Ok(response) = rest_client
        .get_account_resource_at_version_bcs::<StakePool>(pool_address, STAKE_POOL, version)
        .await
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L325-337)
```rust
        let staking_contract_amounts_response = view::<Vec<u64>>(
            rest_client,
            version,
            AccountAddress::ONE,
            ident_str!(STAKING_CONTRACT_MODULE),
            ident_str!("staking_contract_amounts"),
            vec![],
            vec![
                bcs::to_bytes(&owner_address)?,
                bcs::to_bytes(&operator_address)?,
            ],
        )
        .await?;
```

**File:** crates/aptos-rosetta/src/construction.rs (L246-255)
```rust
                let store = rest_client
                    .get_account_resource_bcs::<Store>(op.owner, "0x1::staking_contract::Store")
                    .await?
                    .into_inner();
                let staking_contracts = store.staking_contracts;
                if staking_contracts.len() != 1 {
                    let operators: Vec<_> = staking_contracts
                        .iter()
                        .map(|(address, _)| *address)
                        .collect();
```
