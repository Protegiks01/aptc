# Audit Report

## Title
Malicious Proposers Can Selectively Withhold Votes to Manipulate Leader Reputation and Election

## Summary
A Byzantine proposer can selectively exclude votes from specific validators when forming Quorum Certificates (QCs), causing those validators to appear non-participatory in committed block metadata. This manipulates the LeaderReputation scoring system, gradually reducing targeted validators' probability of being elected as future leaders, enabling leader election manipulation and potential censorship.

## Finding Description

The vulnerability exists in the vote aggregation and leader reputation system. When a validator votes on a proposal, the vote is sent to the next round's proposer: [1](#0-0) 

The proposer processes incoming votes and adds them to `PendingVotes`: [2](#0-1) 

A malicious proposer can simply **not call** `process_vote()` for targeted validators' votes. The `PendingVotes::insert_vote()` aggregates only the votes that were processed: [3](#0-2) 

When quorum (2f+1) is reached, a QC is formed with a BitVec indicating which validators voted. This BitVec is created from only the votes that were added to the aggregator: [4](#0-3) 

The QC's BitVec becomes part of the committed block metadata: [5](#0-4) 

This metadata is emitted as a `NewBlockEvent`: [6](#0-5) 

The `LeaderReputation` system reads these events and counts votes per validator using the BitVec: [7](#0-6) 

**The Attack Path:**

1. Validator A sends a vote to proposer P (the next round's leader)
2. Proposer P is Byzantine and wants to reduce A's reputation
3. P receives votes from A, B, C, D, E (enough for 2f+1 quorum)
4. P deliberately does **not** call `process_vote()` for A's vote
5. P waits for 2f+1 votes from B, C, D, E and forms a QC
6. The QC's BitVec shows votes from B, C, D, E but **not** A
7. P broadcasts a proposal with this QC
8. Other validators verify the QC - it passes because it has ≥2f+1 voting power: [8](#0-7) 

9. The block commits with metadata showing A didn't vote
10. `LeaderReputation` counts this as A not participating
11. A's reputation score decreases over repeated rounds
12. A's probability of being elected as future leader decreases

**Why This Works:**

The QC verification only checks:
- Hash consistency between vote data and ledger info
- Cryptographic signature validity  
- Voting power ≥ quorum threshold (2f+1)

It does **not** check whether all available votes were included or if votes beyond the threshold were excluded. Even with `broadcast_vote=true` (default), validators accept any valid QC with sufficient voting power: [9](#0-8) [10](#0-9) 

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program as a "Significant protocol violation."

**Impact on Leader Election:**
- A malicious proposer can systematically exclude specific validators' votes across multiple rounds
- This causes targeted validators' reputation scores to decrease artificially  
- Lower reputation translates to lower probability in leader election (reputation-based proposer selection)
- Over time, this enables gradual centralization of leadership among colluding validators

**Impact on Decentralization:**
- Enables censorship of specific validators from leadership roles
- Undermines the fairness guarantees of reputation-based leader election
- Allows a single Byzantine proposer to manipulate future consensus participation
- Can be used to favor validators controlled by the same entity

**Scope:**
- Affects all validators in the epoch
- Does not require validator collusion (single Byzantine proposer sufficient)
- Works within the f < n/3 Byzantine fault tolerance assumption
- Persists across rounds until detection (no automatic detection mechanism exists)

## Likelihood Explanation

**Likelihood: Medium-High**

**Requirements:**
- Attacker must be an active validator (part of the validator set)
- Attacker must be elected as proposer for at least some rounds
- With reputation-based leader election, even reduced reputation doesn't eliminate a validator from ever being proposer

**Complexity:**
- Attack is trivially simple: just don't call `process_vote()` for targeted votes
- No special timing, cryptography, or coordination required
- Can be executed passively by simply dropping votes

**Detection Difficulty:**
- With `broadcast_vote=false`: Other validators have no visibility into which votes the proposer received
- With `broadcast_vote=true`: Other validators see votes but cannot prove the proposer received them
- No built-in monitoring or accountability mechanism for vote withholding
- The excluded validator cannot prove they sent a vote to the proposer

**Incentives:**
- Validator operators may want to reduce competition for leader selection
- Validators with multiple nodes could favor their own nodes
- Economic incentive exists (proposers earn transaction fees and MEV)

## Recommendation

Implement **mandatory vote inclusion verification**:

**Option 1: Require maximum vote inclusion**
```rust
// In PendingVotes::insert_vote() or when forming QC
// Check that the QC includes close to total_voting_power, not just quorum

pub fn check_vote_completeness(&self, verifier: &ValidatorVerifier) -> Result<(), VerifyError> {
    let total_possible = verifier.total_voting_power();
    let included = self.get_current_voting_power();
    
    // Require at least 90% of total voting power (allows for network delays)
    let min_expected = (total_possible * 9) / 10;
    
    if included < min_expected {
        return Err(VerifyError::InsufficientVoteInclusion { 
            included, 
            expected: min_expected 
        });
    }
    Ok(())
}
```

**Option 2: Commit vote receipts separately**

Validators could gossip vote receipts/acknowledgments to all other validators, creating a separate accountability layer that tracks which votes were received vs included.

**Option 3: Penalize proposers with incomplete QCs**

Track QC completeness in the reputation system and penalize proposers who consistently form QCs with minimal votes (just above 2f+1) when more votes were likely available.

**Option 4: Disable reputation-based leader election**

Switch to a more deterministic leader election mechanism (e.g., round-robin) that doesn't rely on historical participation metrics that can be manipulated.

## Proof of Concept

```rust
// Consensus integration test demonstrating vote withholding

#[tokio::test]
async fn test_malicious_proposer_withholds_votes() {
    // Setup: 4 validators (f=1), validator 0 is malicious proposer
    let (signers, validator_verifier) = random_validator_verifier(4, Some(2), false);
    let mut malicious_round_manager = create_round_manager(/* ... */);
    
    // Round N: Validator 0 proposes a block
    let block_n = create_test_block(/* round=n, proposer=validator[0] */);
    
    // All validators (1,2,3) send votes to next proposer (validator 0)
    let vote1 = create_vote(&block_n, &signers[1]);
    let vote2 = create_vote(&block_n, &signers[2]);  
    let vote3 = create_vote(&block_n, &signers[3]); // TARGET: exclude this vote
    
    // Malicious proposer receives all votes but only processes votes 1 and 2
    malicious_round_manager.process_vote_msg(vote1.into()).await.unwrap();
    malicious_round_manager.process_vote_msg(vote2.into()).await.unwrap();
    // DELIBERATELY SKIP: process_vote_msg(vote3) - this is the attack
    
    // Wait for QC formation (2f+1 = 3 votes, but we only have 2+proposer's own vote)
    // In practice, proposer waits for its own vote + 2 others = 3 total = 2f+1
    
    // Proposer creates block for round N+1 with QC from round N
    let qc = malicious_round_manager.round_state.get_qc(); // QC with only votes 1,2
    
    // Verify QC passes validation despite missing vote 3
    assert!(qc.verify(&validator_verifier).is_ok()); // Passes! Has 2f+1
    
    // Check the BitVec - validator 3 is NOT included
    let bitvec = qc.ledger_info().get_voters_bitvec();
    assert!(bitvec.is_set(1)); // Validator 1 voted
    assert!(bitvec.is_set(2)); // Validator 2 voted  
    assert!(!bitvec.is_set(3)); // Validator 3 "didn't vote" (actually excluded!)
    
    // This QC gets committed, and validator 3's reputation decreases
    // Repeat over multiple rounds to see cumulative reputation impact
}
```

**Notes**

The default configuration has `broadcast_vote=true`, which broadcasts votes to all validators. However, this doesn't prevent the attack because:

1. Non-proposer validators process votes but don't form their own QCs (they only aggregate for verification)
2. When the proposer broadcasts a proposal with a QC, other validators verify it has ≥2f+1 votes, not that it includes ALL available votes
3. There's no challenge mechanism for validators to dispute incomplete QCs
4. The reputation system trusts the `previous_block_votes_bitvec` in committed blocks without verification

This vulnerability affects the **fairness** of leader election rather than consensus **safety** or **liveness**. The blockchain continues to operate correctly, but leadership becomes manipulable by Byzantine proposers, enabling gradual centralization.

### Citations

**File:** consensus/src/round_manager.rs (L1411-1418)
```rust
            let recipient = self
                .proposer_election
                .get_valid_proposer(proposal_round + 1);
            info!(
                self.new_log(LogEvent::Vote).remote_peer(recipient),
                "{}", vote
            );
            self.network.send_vote(vote_msg, vec![recipient]).await;
```

**File:** consensus/src/round_manager.rs (L1746-1756)
```rust
        if !self.local_config.broadcast_vote && !vote.is_timeout() {
            // Unlike timeout votes regular votes are sent to the leaders of the next round only.
            let next_round = round + 1;
            ensure!(
                self.proposer_election
                    .is_valid_proposer(self.proposal_generator.author(), next_round),
                "[RoundManager] Received {}, but I am not a valid proposer for round {}, ignore.",
                vote,
                next_round
            );
        }
```

**File:** consensus/src/round_manager.rs (L1767-1772)
```rust
        let vote_reception_result = self
            .round_state
            .insert_vote(vote, &self.epoch_state.verifier);
        self.process_vote_reception_result(vote, vote_reception_result)
            .await
    }
```

**File:** consensus/src/pending_votes.rs (L275-329)
```rust
    pub fn insert_vote(
        &mut self,
        vote: &Vote,
        validator_verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        // derive data from vote
        let li_digest = vote.ledger_info().hash();

        //
        // 1. Has the author already voted for this round?
        //

        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }

        //
        // 2. Store new vote (or update, in case it's a new timeout vote)
        //

        self.author_to_vote
            .insert(vote.author(), (vote.clone(), li_digest));

        //
        // 3. Let's check if we can create a QC
        //

        let len = self.li_digest_to_votes.len() + 1;
        // obtain the ledger info with signatures associated to the vote's ledger info
        let (hash_index, status) = self.li_digest_to_votes.entry(li_digest).or_insert_with(|| {
            (
                len,
                VoteStatus::NotEnoughVotes(SignatureAggregator::new(vote.ledger_info().clone())),
            )
        });
```

**File:** types/src/validator_verifier.rs (L316-335)
```rust
    pub fn aggregate_signatures<'a>(
        &self,
        signatures: impl Iterator<Item = (&'a AccountAddress, &'a bls12381::Signature)>,
    ) -> Result<AggregateSignature, VerifyError> {
        let mut sigs = vec![];
        let mut masks = BitVec::with_num_bits(self.len() as u16);
        for (addr, sig) in signatures {
            let index = *self
                .address_to_validator_index
                .get(addr)
                .ok_or(VerifyError::UnknownAuthor)?;
            masks.set(index as u16);
            sigs.push(sig.clone());
        }
        // Perform an optimistic aggregation of the signatures without verification.
        let aggregated_sig = bls12381::Signature::aggregate(sigs)
            .map_err(|_| VerifyError::FailedToAggregateSignature)?;

        Ok(AggregateSignature::new(masks, Some(aggregated_sig)))
    }
```

**File:** consensus/consensus-types/src/block.rs (L570-594)
```rust
    fn previous_bitvec(&self) -> BitVec {
        match self.block_data.block_type() {
            BlockType::DAGBlock { parents_bitvec, .. } => parents_bitvec.clone(),
            BlockType::OptimisticProposal(p) => {
                p.grandparent_qc().ledger_info().get_voters_bitvec().clone()
            },
            _ => self.quorum_cert().ledger_info().get_voters_bitvec().clone(),
        }
    }

    pub fn new_block_metadata(&self, validators: &[AccountAddress]) -> BlockMetadata {
        BlockMetadata::new(
            self.id(),
            self.epoch(),
            self.round(),
            self.author().unwrap_or(AccountAddress::ZERO),
            self.previous_bitvec().into(),
            // For nil block, we use 0x0 which is convention for nil address in move.
            self.block_data()
                .failed_authors()
                .map_or(vec![], |failed_authors| {
                    Self::failed_authors_to_indices(validators, failed_authors)
                }),
            self.timestamp_usecs(),
        )
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L154-199)
```text
    fun block_prologue_common(
        vm: &signer,
        hash: address,
        epoch: u64,
        round: u64,
        proposer: address,
        failed_proposer_indices: vector<u64>,
        previous_block_votes_bitvec: vector<u8>,
        timestamp: u64
    ): u64 acquires BlockResource, CommitHistory {
        // Operational constraint: can only be invoked by the VM.
        system_addresses::assert_vm(vm);

        // Blocks can only be produced by a valid proposer or by the VM itself for Nil blocks (no user txs).
        assert!(
            proposer == @vm_reserved || stake::is_current_epoch_validator(proposer),
            error::permission_denied(EINVALID_PROPOSER),
        );

        let proposer_index = option::none();
        if (proposer != @vm_reserved) {
            proposer_index = option::some(stake::get_validator_index(proposer));
        };

        let block_metadata_ref = borrow_global_mut<BlockResource>(@aptos_framework);
        block_metadata_ref.height = event::counter(&block_metadata_ref.new_block_events);

        let new_block_event = NewBlockEvent {
            hash,
            epoch,
            round,
            height: block_metadata_ref.height,
            previous_block_votes_bitvec,
            proposer,
            failed_proposer_indices,
            time_microseconds: timestamp,
        };
        emit_new_block_event(vm, &mut block_metadata_ref.new_block_events, new_block_event);

        // Performance scores have to be updated before the epoch transition as the transaction that triggers the
        // transition is the last block in the previous epoch.
        stake::update_performance_statistics(proposer_index, failed_proposer_indices);
        state_storage::on_new_block(reconfiguration::current_epoch());

        block_metadata_ref.epoch_interval
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L366-397)
```rust
    pub fn count_votes_custom(
        epoch_to_candidates: &HashMap<u64, Vec<Author>>,
        history: &[NewBlockEvent],
        window_size: usize,
        from_stale_end: bool,
    ) -> HashMap<Author, u32> {
        Self::history_iter(history, epoch_to_candidates, window_size, from_stale_end).fold(
            HashMap::new(),
            |mut map, meta| {
                match Self::bitvec_to_voters(
                    &epoch_to_candidates[&meta.epoch()],
                    &meta.previous_block_votes_bitvec().clone().into(),
                ) {
                    Ok(voters) => {
                        for &voter in voters {
                            let count = map.entry(voter).or_insert(0);
                            *count += 1;
                        }
                    },
                    Err(msg) => {
                        error!(
                            "Voter conversion from bitmap failed at epoch {}, round {}: {}",
                            meta.epoch(),
                            meta.round(),
                            msg
                        )
                    },
                }
                map
            },
        )
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L119-148)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "Quorum Cert's hash mismatch LedgerInfo"
        );
        // Genesis's QC is implicitly agreed upon, it doesn't have real signatures.
        // If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore
        // because of the round constraint.
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
        }
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify QuorumCert")?;
        self.vote_data.verify()?;
        Ok(())
    }
```

**File:** config/src/config/consensus_config.rs (L371-371)
```rust
            broadcast_vote: true,
```
