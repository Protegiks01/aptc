# Audit Report

## Title
Subscription Stream Livelock via Malicious Error Responses Causing State Synchronization Denial of Service

## Summary
A malicious storage service peer can craft error responses for subscription requests to cause a livelock condition in the data streaming service, preventing nodes from synchronizing state. The vulnerability exists because subscription errors reset the subscription stream without incrementing the failure counter, allowing the attack to continue indefinitely until peer scoring eventually ignores the malicious peer (after ~14 cycles) or the progress checker panics (after 24 hours).

## Finding Description

The vulnerability exists in the error handling logic for subscription requests in the data streaming service. When a subscription request receives an error response from a storage service peer, the following sequence occurs:

**Error Flow for Subscription Requests:**

1. The storage service returns an error response (InvalidRequest, InternalError, or TooManyInvalidRequests) [1](#0-0) 

2. These errors are converted to `UnexpectedErrorEncountered` at the data client layer [2](#0-1) 

3. In the data stream, subscription requests are identified as "new data requests" and trigger `notify_new_data_request_error()` [3](#0-2) 

4. This calls the stream engine's `handle_subscription_error()` which resets the active subscription stream to None [4](#0-3) 

5. All pending requests are cleared [5](#0-4) 

6. A new subscription stream is immediately created and new requests are sent [6](#0-5) 

**The Critical Bug:**

Unlike regular data request errors which increment `request_failure_count` via `resend_data_client_request()` [7](#0-6) , subscription errors do NOT increment this counter. The stream termination check relies on `request_failure_count >= max_request_retry` [8](#0-7) , which means the stream never terminates due to repeated subscription failures.

**Attack Execution:**
A malicious peer continuously sends error responses for all subscription requests, causing an infinite loop of:
1. Send subscription request
2. Receive error response  
3. Reset subscription stream
4. Create new subscription stream
5. Return to step 1

**Mitigation Limitations:**

While peer scoring provides some protection, it has significant limitations:
- Starting score is 50.0, NOT_USEFUL_MULTIPLIER is 0.95, IGNORE_PEER_THRESHOLD is 25.0 [9](#0-8) 
- Calculation: 50.0 × (0.95^n) ≤ 25.0 requires n ≥ 14 error responses before the peer is ignored
- The progress checker timeout is 86400 seconds (24 hours) [10](#0-9) , far too long to provide effective protection
- With multiple malicious peers or peer identity rotation, the attack window extends significantly

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per the Aptos bug bounty criteria for the following reasons:

1. **State Inconsistencies Requiring Intervention**: The affected node cannot synchronize state while stuck in the livelock, leading to state divergence from the network that may require manual intervention to resolve.

2. **Validator Liveness Impact**: If exploited against validator nodes, this could affect their ability to participate in consensus due to falling behind on state synchronization, though it doesn't directly break consensus safety.

3. **Temporary Denial of Service**: The node's state synchronization is effectively disabled during the attack period, preventing it from catching up to the latest blockchain state.

4. **Resource Exhaustion**: Repeatedly creating and destroying subscription streams wastes computational resources and network bandwidth.

The impact is mitigated from High to Medium because:
- The attack is temporary (peer scoring eventually ignores the malicious peer after ~14 cycles)
- It doesn't directly cause loss of funds or consensus safety violations
- It doesn't cause permanent network partition or require a hardfork
- Multiple peers can still serve data, reducing single-point-of-failure risk

## Likelihood Explanation

The likelihood of this attack is **Medium** for the following reasons:

**Factors Increasing Likelihood:**
- The attack is trivial to execute—simply return error responses for subscription requests
- No special privileges or validator access required
- The malicious peer only needs to be selected for serving subscription data
- Error responses are legitimate protocol messages, making detection difficult
- Subscription streaming is enabled by default in the configuration

**Factors Decreasing Likelihood:**
- Requires the attacker to operate a peer node in the network
- The peer must be discovered and selected by the victim node
- Peer scoring mechanism provides eventual mitigation after ~14 error cycles
- Nodes can potentially switch to other peers for data

The attack is realistic and feasible but requires some network positioning by the attacker.

## Recommendation

**Immediate Fix**: Track subscription request failures separately and enforce termination limits.

Add a subscription-specific failure counter and check it during stream termination:

```rust
// In DataStream struct (data_stream.rs)
pub struct DataStream<T> {
    // ... existing fields ...
    
    // The current failure count for subscription/optimistic fetch requests
    new_data_request_failure_count: u64,
}

// Update notify_new_data_request_error to increment the counter
fn notify_new_data_request_error(
    &mut self,
    client_request: &DataClientRequest,
    error: aptos_data_client::error::Error,
) -> Result<(), Error> {
    // Increment the failure counter for new data requests
    self.new_data_request_failure_count += 1;
    
    // Notify the stream engine and clear the requests queue
    self.stream_engine
        .notify_new_data_request_error(client_request, error)?;
    self.clear_sent_data_requests_queue();
    
    Ok(())
}

// Update the termination check
pub async fn process_data_responses(
    &mut self,
    global_data_summary: GlobalDataSummary,
) -> Result<(), Error> {
    if self.stream_engine.is_stream_complete()
        || self.request_failure_count >= self.streaming_service_config.max_request_retry
        || self.new_data_request_failure_count >= self.streaming_service_config.max_request_retry
        || self.send_failure
    {
        // ... existing termination logic ...
    }
    // ... rest of method ...
}
```

**Additional Hardening:**
1. Reduce `progress_check_max_stall_time_secs` from 24 hours to a more reasonable value (e.g., 5-10 minutes)
2. Implement a circuit breaker for rapid subscription stream resets (e.g., if >3 resets occur within 30 seconds, terminate the stream)
3. Add logging/metrics for subscription stream reset events to aid detection
4. Consider more aggressive peer scoring penalties specifically for subscription errors

## Proof of Concept

```rust
#[tokio::test]
async fn test_subscription_error_livelock() {
    use aptos_config::config::{AptosDataClientConfig, DataStreamingServiceConfig};
    use aptos_data_client::interface::AptosDataClientInterface;
    use aptos_storage_service_types::StorageServiceError;
    use std::time::Duration;
    
    // Mock data client that always returns errors for subscription requests
    struct MaliciousDataClient;
    
    impl AptosDataClientInterface for MaliciousDataClient {
        async fn subscribe_transactions_with_proof(
            &self,
            _known_version: u64,
            _known_epoch: u64,
            _include_events: bool,
        ) -> Result<Response<ResponsePayload>, aptos_data_client::error::Error> {
            // Always return an error
            Err(aptos_data_client::error::Error::UnexpectedErrorEncountered(
                StorageServiceError::InvalidRequest("malicious error".to_string()).to_string()
            ))
        }
        // ... implement other required methods ...
    }
    
    // Create data stream with malicious client
    let config = DataStreamingServiceConfig::default();
    let client_config = AptosDataClientConfig::default();
    let malicious_client = MaliciousDataClient;
    
    // Create continuous transaction stream
    let stream_request = StreamRequest::ContinuouslyStreamTransactions(
        ContinuouslyStreamTransactionsRequest {
            known_version: 0,
            known_epoch: 0,
            target: None,
            include_events: false,
        }
    );
    
    let (mut data_stream, _listener) = DataStream::new(
        client_config,
        config,
        1,
        &stream_request,
        // ... other parameters ...
    ).unwrap();
    
    // Initialize and process requests
    data_stream.initialize_data_requests(global_data_summary).unwrap();
    
    // Verify that the stream keeps resetting without terminating
    let start = Instant::now();
    let mut reset_count = 0;
    
    while start.elapsed() < Duration::from_secs(10) {
        data_stream.process_data_responses(global_data_summary).await.unwrap();
        
        // Check if subscription stream was reset (would need access to internal state)
        // In practice, verify that request_failure_count never increments
        // and the stream doesn't terminate despite repeated errors
        
        reset_count += 1;
        tokio::time::sleep(Duration::from_millis(100)).await;
    }
    
    // Assert: The stream should have terminated after max_request_retry failures,
    // but due to the bug, it continues indefinitely
    assert!(reset_count > 14, "Stream should have reset many times without terminating");
    assert!(!data_stream.stream_engine.is_stream_complete(), "Stream should not be complete");
}
```

**Notes:**
- The PoC demonstrates how repeated subscription errors cause continuous stream resets without triggering termination
- In a real scenario, monitor node logs for repeated "Subscription error" messages [11](#0-10)  combined with no state sync progress
- The attack can be detected by observing the `CREATE_SUBSCRIPTION_STREAM` metric repeatedly incrementing [12](#0-11)  without corresponding progress in synced versions

### Citations

**File:** state-sync/storage-service/types/src/lib.rs (L29-37)
```rust
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
pub enum StorageServiceError {
    #[error("Internal service error: {0}")]
    InternalError(String),
    #[error("Invalid storage request: {0}")]
    InvalidRequest(String),
    #[error("Too many invalid requests! Back off required: {0}")]
    TooManyInvalidRequests(String),
}
```

**File:** state-sync/aptos-data-client/src/client.rs (L844-846)
```rust
                    aptos_storage_service_client::Error::StorageServiceError(err) => {
                        Error::UnexpectedErrorEncountered(err.to_string())
                    },
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L446-454)
```rust
        if self.stream_engine.is_stream_complete()
            || self.request_failure_count >= self.streaming_service_config.max_request_retry
            || self.send_failure
        {
            if !self.send_failure && self.stream_end_notification_id.is_none() {
                self.send_end_of_stream_notification().await?;
            }
            return Ok(()); // There's nothing left to do
        }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L523-538)
```rust
                Err(error) => {
                    // Handle the error depending on the request type
                    if client_request.is_new_data_request() {
                        // The request was for new data. We should notify the
                        // stream engine and clear the requests queue.
                        self.notify_new_data_request_error(client_request, error)?;
                    } else {
                        // Decrease the prefetching limit on an error
                        self.dynamic_prefetching_state
                            .decrease_max_concurrent_requests();

                        // Handle the error and simply retry
                        self.handle_data_client_error(client_request, &error)?;
                    }
                    break; // We're now head of line blocked on the failed request
                },
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L634-644)
```rust
    fn notify_new_data_request_error(
        &mut self,
        client_request: &DataClientRequest,
        error: aptos_data_client::error::Error,
    ) -> Result<(), Error> {
        // Notify the stream engine and clear the requests queue
        self.stream_engine
            .notify_new_data_request_error(client_request, error)?;
        self.clear_sent_data_requests_queue();

        Ok(())
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L729-744)
```rust
    fn resend_data_client_request(
        &mut self,
        data_client_request: &DataClientRequest,
    ) -> Result<(), Error> {
        // Increment the number of client failures for this request
        self.request_failure_count += 1;

        // Resend the client request
        let pending_client_response = self.send_client_request(true, data_client_request.clone());

        // Push the pending response to the head of the sent requests queue
        self.get_sent_data_requests()?
            .push_front(pending_client_response);

        Ok(())
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L937-1003)
```rust
    /// Handles a subscription error for the specified client request
    fn handle_subscription_error(
        &mut self,
        client_request: &DataClientRequest,
        request_error: aptos_data_client::error::Error,
    ) -> Result<(), Error> {
        // We should only receive an error notification if we have an active stream
        if self.active_subscription_stream.is_none() {
            return Err(Error::UnexpectedErrorEncountered(format!(
                "Received a subscription notification error but no active subscription stream exists! Error: {:?}, request: {:?}",
                request_error, client_request
            )));
        }

        // Reset the active subscription stream and update the metrics
        self.active_subscription_stream = None;
        update_terminated_subscription_metrics(request_error.get_label());

        // Log the error based on the request type
        if matches!(
            self.request,
            StreamRequest::ContinuouslyStreamTransactions(_)
        ) && matches!(
            client_request,
            DataClientRequest::SubscribeTransactionsWithProof(_)
        ) {
            info!(
                (LogSchema::new(LogEntry::RequestError).message(&format!(
                    "Subscription error for new transactions: {:?}",
                    request_error
                )))
            );
        } else if matches!(
            self.request,
            StreamRequest::ContinuouslyStreamTransactionOutputs(_)
        ) && matches!(
            client_request,
            DataClientRequest::SubscribeTransactionOutputsWithProof(_)
        ) {
            info!(
                (LogSchema::new(LogEntry::RequestError).message(&format!(
                    "Subscription error for new transaction outputs: {:?}",
                    request_error
                )))
            );
        } else if matches!(
            self.request,
            StreamRequest::ContinuouslyStreamTransactionsOrOutputs(_)
        ) && matches!(
            client_request,
            DataClientRequest::SubscribeTransactionsOrOutputsWithProof(_)
        ) {
            info!(
                (LogSchema::new(LogEntry::RequestError).message(&format!(
                    "Subscription error for new transactions or outputs: {:?}",
                    request_error
                )))
            );
        } else {
            return Err(Error::UnexpectedErrorEncountered(format!(
                "Received a subscription request error but the request did not match the expected type for the stream! \
                Error: {:?}, request: {:?}, stream: {:?}", request_error, client_request, self.request
            )));
        }

        Ok(())
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1030-1030)
```rust
        metrics::CREATE_SUBSCRIPTION_STREAM.inc();
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1271-1278)
```rust
            if self.data_streaming_config.enable_subscription_streaming {
                // Start a new subscription stream and send the first set of requests
                self.start_active_subscription_stream(unique_id_generator)?;
                self.create_subscription_stream_requests(
                    max_number_of_requests,
                    max_in_flight_requests,
                    num_in_flight_requests,
                )?
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L32-43)
```rust
/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** config/src/config/state_sync_config.rs (L479-479)
```rust
            progress_check_max_stall_time_secs: 86400, // 24 hours (long enough to debug any issues at runtime)
```
