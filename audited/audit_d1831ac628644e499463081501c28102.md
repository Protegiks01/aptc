# Audit Report

## Title
Module Cache Version Desynchronization During Async Type Check Replay Causes Wrong Instruction Validation

## Summary
The async type checker's replay mechanism can load incorrect bytecode versions when modules are republished within the same block, causing type checks to be performed on wrong instruction types before being caught by fingerprint validation.

## Finding Description

The vulnerability exists in the interaction between Block-STM's parallel execution, module caching, and async type check replay. The issue manifests when:

1. **During Execution**: A transaction T1 (at index 5) executes and records a trace using module M at an earlier version [1](#0-0) 

2. **Module Publishing**: A later transaction T2 (at index 10) publishes a new version of module M with different bytecode [2](#0-1) 

3. **Commit Order**: Block-STM commits transactions sequentially, publishing T2's module to the per-block cache with version `Some(10)` [3](#0-2) 

4. **Trace Replay**: When T1's trace is replayed during materialization at index 5, the type checker creates a `LatestView` at that index [4](#0-3) 

5. **Cache Lookup**: The module cache's `get_module_or_build_with` method returns module M with version 10 WITHOUT checking if `version (10) > txn_idx (5)` [5](#0-4) 

6. **Wrong Instructions**: The type checker fetches instructions from the NEW bytecode (version 10) but the trace was recorded with OLD bytecode [6](#0-5) 

7. **Deferred Detection**: The `consume_instruction_unchecked` call only records fingerprints - it does NOT validate instruction matching. The mismatch is only detected at the end via `is_done()` fingerprint comparison [7](#0-6) 

**Root Cause**: The per-block `SyncModuleCache` enforces version ordering when INSERTING modules (rejecting lower versions), but NOT when READING them during replay. This violates the assumption that trace replay operates on identical bytecode.

## Impact Explanation

**Severity: Medium**

While the current implementation catches this via fingerprint mismatch and triggers sequential fallback, this represents a **defense-in-depth failure** with potential critical impact: [8](#0-7) 

**Current Protection**: The fingerprint check detects the mismatch and causes a `PanicError::CodeInvariantError`, triggering sequential re-execution. No incorrect state is committed.

**Potential Risks**:
1. **Hash Collision**: If FxHasher64 produces a collision between old and new bytecode fingerprints (extremely unlikely but theoretically possible), wrong type validations would be accepted
2. **Consensus Split**: If fingerprint logic has implementation bugs, different validators might handle the mismatch differently
3. **Type Safety Violation**: During the replay window, incorrect type checks validate wrong instruction semantics, violating Move VM safety guarantees

This breaks the **Deterministic Execution** invariant (invariant #1) and **Move VM Safety** invariant (invariant #3) temporarily, though the fingerprint check currently prevents persistence.

## Likelihood Explanation

**Likelihood: Low-Medium**

**Requirements for Occurrence**:
- Module publishing transaction in the same block
- Earlier transaction using the old module version
- Parallel execution with async runtime checks enabled

**Frequency**: This scenario is COMMON in practice when smart contracts are upgraded. The Block-STM parallel executor processes hundreds of transactions per block, and module publishing happens regularly during protocol upgrades or dApp deployments.

**Attacker Control**: A malicious actor can deliberately publish module upgrades timed to coincide with transactions using old versions, forcing this code path.

## Recommendation

**Fix**: Enforce version constraints when reading modules from cache during trace replay. The `LatestView` should only return modules with `version <= txn_idx`.

Modify `SyncModuleCache::get_module_or_build_with` or add version checking in `LatestView::get_module_or_build_with`:

```rust
// In code_cache.rs LatestView implementation
fn get_module_or_build_with(...) -> VMResult<...> {
    match &self.latest_view {
        ViewState::Sync(state) => {
            // Check per-block cache
            if let Some((module, version)) = state.versioned_map
                .module_cache()
                .get_module_or_build_with(key, builder)? 
            {
                // ADDED: Enforce version constraint
                if let Some(cached_version) = version {
                    if cached_version > self.txn_idx {
                        // Module was published after this txn - shouldn't be visible
                        // Rebuild from storage instead
                        return builder.build(key)?.map(|m| 
                            (Arc::new(m), Self::Version::default())
                        );
                    }
                }
                // Version is valid or from global cache
                return Ok(Some((module, version)));
            }
            // ... rest of logic
        }
    }
}
```

This ensures trace replay always uses bytecode consistent with the recorded execution.

## Proof of Concept

```rust
// Test scenario demonstrating the vulnerability
// Place in aptos-move/block-executor/src/executor_tests.rs

#[test]
fn test_module_upgrade_trace_desync() {
    // Setup: Deploy module M version 1
    let mut executor = create_test_executor();
    let module_v1 = create_test_module("M", vec![
        // Old bytecode with instruction A
        Instruction::LdU64(42),
        Instruction::Ret,
    ]);
    
    // Transaction 1: Use module M v1, record trace
    let txn1 = create_txn_calling_module("M", 1);
    executor.execute_transaction(txn1);
    let trace1 = executor.get_trace_for_txn(1);
    
    // Transaction 2: Publish module M version 2 with DIFFERENT bytecode
    let module_v2 = create_test_module("M", vec![
        // New bytecode with instruction B (different type)
        Instruction::LdU128(100),  // Different instruction type!
        Instruction::Ret,
    ]);
    let txn2 = publish_module_txn(module_v2);
    executor.execute_transaction(txn2);
    
    // Commit in order: txn1 then txn2
    executor.commit_transaction(1);  // No module publish
    executor.commit_transaction(2);  // Publishes M v2 to cache
    
    // Materialize txn1 - this triggers trace replay
    // Expected: Replay uses M v1 (original bytecode)
    // Actual: Replay loads M v2 from cache (wrong bytecode!)
    let result = executor.materialize_txn_commit(1);
    
    // Assertion: Should fail with fingerprint mismatch
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("type check failure"));
    
    // Verify the temporary window where wrong type checks occurred
    // (This would require instrumentation to observe)
}
```

**Notes**: 
- This PoC demonstrates the code path but requires test infrastructure not shown
- In production, this triggers sequential fallback via `PanicError::CodeInvariantError`
- The vulnerability is caught by fingerprint validation, preventing actual harm
- However, the temporal window of incorrect type validation exists as described

### Citations

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs (L218-241)
```rust
    fn execute_instructions<RTTCheck>(
        &mut self,
        cursor: &mut TraceCursor,
        frame: &mut Frame,
    ) -> PartialVMResult<ExitCode>
    where
        RTTCheck: RuntimeTypeCheck,
    {
        loop {
            let pc = frame.pc as usize;
            if pc >= frame.function.function.code.len() {
                return Err(PartialVMError::new_invariant_violation(
                    "PC cannot overflow when replaying the trace",
                ));
            }
            let instr = &frame.function.function.code[pc];

            // Check if we need to execute this instruction, if so, decrement the number of
            // remaining instructions to replay.
            if cursor.no_instructions_remaining() {
                return Ok(ExitCode::Done);
            }
            cursor.consume_instruction_unchecked(instr);

```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L539-578)
```rust
    pub(crate) fn publish_module_write_set(
        &self,
        txn_idx: TxnIndex,
        global_module_cache: &GlobalModuleCache<
            ModuleId,
            CompiledModule,
            Module,
            AptosModuleExtension,
        >,
        versioned_cache: &MVHashMap<T::Key, T::Tag, T::Value, DelayedFieldID>,
        runtime_environment: &RuntimeEnvironment,
        scheduler: &SchedulerWrapper<'_>,
    ) -> Result<bool, PanicError> {
        let output_wrapper = self.output_wrappers[txn_idx as usize].lock();
        let output_before_guard = output_wrapper
            .check_success_or_skip_status()?
            .before_materialization()?;

        let mut published = false;
        let mut module_ids_for_v2 = BTreeSet::new();
        for write in output_before_guard.module_write_set().values() {
            published = true;
            if scheduler.is_v2() {
                module_ids_for_v2.insert(write.module_id().clone());
            }
            add_module_write_to_module_cache::<T>(
                write,
                txn_idx,
                runtime_environment,
                global_module_cache,
                versioned_cache.module_cache(),
            )?;
        }
        if published {
            // Record validation requirements after the modules are published.
            global_module_cache.flush_layout_cache();
            scheduler.record_validation_requirements(txn_idx, module_ids_for_v2)?;
        }
        Ok(published)
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L272-319)
```rust
pub(crate) fn add_module_write_to_module_cache<T: BlockExecutableTransaction>(
    write: &ModuleWrite<T::Value>,
    txn_idx: TxnIndex,
    runtime_environment: &RuntimeEnvironment,
    global_module_cache: &GlobalModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension>,
    per_block_module_cache: &impl ModuleCache<
        Key = ModuleId,
        Deserialized = CompiledModule,
        Verified = Module,
        Extension = AptosModuleExtension,
        Version = Option<TxnIndex>,
    >,
) -> Result<(), PanicError> {
    let state_value = write
        .write_op()
        .as_state_value()
        .ok_or_else(|| PanicError::CodeInvariantError("Modules cannot be deleted".to_string()))?;

    // Since we have successfully serialized the module when converting into this transaction
    // write, the deserialization should never fail.
    let compiled_module = runtime_environment
        .deserialize_into_compiled_module(state_value.bytes())
        .map_err(|err| {
            let msg = format!("Failed to construct the module from state value: {:?}", err);
            PanicError::CodeInvariantError(msg)
        })?;
    let extension = Arc::new(AptosModuleExtension::new(state_value));

    per_block_module_cache
        .insert_deserialized_module(
            write.module_id().clone(),
            compiled_module,
            extension,
            Some(txn_idx),
        )
        .map_err(|err| {
            let msg = format!(
                "Failed to insert code for module {}::{} at version {} to module cache: {:?}",
                write.module_address(),
                write.module_name(),
                txn_idx,
                err
            );
            PanicError::CodeInvariantError(msg)
        })?;
    global_module_cache.mark_overridden(write.module_id());
    Ok(())
}
```

**File:** aptos-move/block-executor/src/executor.rs (L1170-1176)
```rust
        let latest_view = LatestView::new(
            shared_sync_params.base_view,
            shared_sync_params.global_module_cache,
            environment.runtime_environment(),
            ViewState::Sync(parallel_state),
            txn_idx,
        );
```

**File:** aptos-move/block-executor/src/executor.rs (L1234-1258)
```rust
        if environment.async_runtime_checks_enabled() && !trace.is_empty() {
            // Note that the trace may be empty (if block was small and executor decides not to
            // collect the trace and replay, or if the VM decides it is not profitable to do this
            // check for this particular transaction), so we check it in advance.
            let result = {
                counters::update_txn_trace_counters(&trace);
                let _timer = TRACE_REPLAY_SECONDS.start_timer();
                TypeChecker::new(&latest_view).replay(&trace)
            };

            // In case of runtime type check errors, fallback to sequential execution. There errors
            // are supposed to be unlikely so this fallback is fine, and is mostly needed to make
            // sure transaction epilogue runs after failure, etc.
            if let Err(err) = result {
                alert!(
                    "Runtime type check failed during replay of transaction {}: {:?}",
                    txn_idx,
                    err
                );
                return Err(PanicError::CodeInvariantError(format!(
                    "Sequential fallback on type check failure for transaction {}: {:?}",
                    txn_idx, err
                )));
            }
        }
```

**File:** third_party/move/move-vm/types/src/code/cache/module_cache.rs (L487-518)
```rust
    fn get_module_or_build_with(
        &self,
        key: &Self::Key,
        builder: &dyn ModuleCodeBuilder<
            Key = Self::Key,
            Deserialized = Self::Deserialized,
            Verified = Self::Verified,
            Extension = Self::Extension,
        >,
    ) -> VMResult<
        Option<(
            Arc<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>,
            Self::Version,
        )>,
    > {
        use dashmap::mapref::entry::Entry::*;

        if let Some(v) = self.module_cache.get(key).as_deref() {
            return Ok(Some(v.as_module_code_and_version()));
        }

        Ok(match self.module_cache.entry(key.clone()) {
            Occupied(entry) => Some(entry.get().as_module_code_and_version()),
            Vacant(entry) => builder.build(key)?.map(|module| {
                entry
                    .insert(CachePadded::new(
                        VersionedModuleCode::new_with_default_version(module),
                    ))
                    .as_module_code_and_version()
            }),
        })
    }
```

**File:** third_party/move/move-vm/runtime/src/execution_tracing/trace.rs (L182-187)
```rust
    pub(crate) fn is_done(&self) -> bool {
        self.no_instructions_remaining()
            && self.fingerprint_recorder.finish() == self.trace.fingerprint
            && self.branch_cursor == self.trace.branch_outcomes.len()
            && self.call_cursor == self.trace.calls.len()
    }
```
