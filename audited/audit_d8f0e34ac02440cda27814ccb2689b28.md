# Audit Report

## Title
Integer Cast Overflow in Rosetta API Transfer Amount Validation Allows Malformed Transaction Construction

## Summary
The Rosetta API's `Transfer::extract_transfer` function contains an unchecked cast from `i128` to `u64` that allows negative deposit amounts to wrap around to large positive values, bypassing amount validation and enabling construction of malformed transactions with incorrect transfer amounts. [1](#0-0) 

## Finding Description
The vulnerability exists in the transfer operation extraction logic that converts Rosetta API operations into internal transfer objects. The code parses withdraw and deposit amounts as `i128` values, validates that they are negatives of each other, checks that the deposit value doesn't exceed `u64::MAX`, but critically **fails to validate that the deposit value is positive** before performing an unchecked cast to `u64`.

**Attack Vector:**

An attacker can craft a malicious `ConstructionPayloadsRequest` with swapped operation signs:
- Withdraw operation: value = "100" (positive, when it should be negative)
- Deposit operation: value = "-100" (negative, when it should be positive) [2](#0-1) 

**Validation Bypass:**

The validation at line 2905 checks: `-withdraw_value != deposit_value`
- With swapped signs: `-(100) != -100` → `-100 != -100` → FALSE (passes!)

The validation at line 2913 checks: `deposit_value > u64::MAX as i128`  
- With negative deposit: `-100 > 18446744073709551615` → FALSE (passes!)

**Overflow Occurs:**

At line 2919, the code performs: `let transfer_amount = deposit_value as u64;`

In Rust, casting a negative `i128` to `u64` wraps around via two's complement:
- `-1 as u64` = `18446744073709551615` (u64::MAX)
- `-100 as u64` = `18446744073709551516`

This wrapped value is then used to construct the transaction payload: [3](#0-2) 

The resulting transaction attempts to transfer the wrapped (huge) amount instead of the intended amount.

## Impact Explanation
**Severity: Medium**

While this vulnerability allows bypassing Rosetta API validation and constructing malformed transactions, the actual **impact is limited** because:

1. **Blockchain Layer Protection**: The Aptos blockchain's balance checks will reject transactions where the sender has insufficient funds, preventing actual theft or minting.

2. **No Direct Fund Loss**: The vulnerability cannot directly cause loss of funds or unlimited minting because wrapped amounts (near u64::MAX) will always exceed any legitimate account balance.

3. **Protocol Violation**: However, this represents a **significant protocol violation** in the Rosetta API layer, which is part of the Aptos Core codebase and trusted infrastructure for blockchain integration.

**Actual Harms:**
- Violates Rosetta API specification invariants
- Enables construction of malformed transactions
- Could cause integration bugs in systems relying on Rosetta API
- May lead to confusion, errors, or unexpected behavior in client applications
- Represents a validation failure that could be chained with other vulnerabilities

This meets **Medium Severity** criteria per the bug bounty program: "State inconsistencies requiring intervention" - the Rosetta API layer produces inconsistent transaction representations that violate the API specification.

## Likelihood Explanation
**Likelihood: High**

The vulnerability is easily exploitable because:
1. **No Authentication Required**: Any client can call the Rosetta API construction endpoints
2. **Simple Attack**: Requires only crafting a JSON request with swapped operation signs
3. **No Special Access**: Does not require validator privileges or insider access
4. **Deterministic**: The vulnerability triggers reliably with crafted inputs

The exploitation path is straightforward:
```
Client → /construction/preprocess → InternalOperation::extract → 
Transfer::extract_transfer → Unchecked cast → Malformed transaction
```

## Recommendation
Add explicit validation to ensure deposit amounts are positive and withdraw amounts are negative before the cast operation:

```rust
// After line 2909, add these checks:

// Validate that withdraw is negative and deposit is positive
if withdraw_value >= 0 {
    return Err(ApiError::InvalidTransferOperations(Some(
        "Withdraw amount must be negative"
    )));
}

if deposit_value <= 0 {
    return Err(ApiError::InvalidTransferOperations(Some(
        "Deposit amount must be positive"
    )));
}

// Then check deposit_value is within u64 range (existing check at line 2913)
if deposit_value > u64::MAX as i128 {
    return Err(ApiError::InvalidTransferOperations(Some(
        "Transfer amount must not be greater than u64 max",
    )));
}

// Now safe to cast
let transfer_amount = deposit_value as u64;
```

Alternatively, use a checked cast with explicit error handling:
```rust
let transfer_amount = u64::try_from(deposit_value)
    .map_err(|_| ApiError::InvalidTransferOperations(Some(
        "Deposit amount must be a valid positive u64 value"
    )))?;
```

## Proof of Concept

**Rust Test Case:**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_negative_deposit_overflow() {
        // Create operations with swapped signs
        let withdraw_op = Operation {
            operation_type: "withdraw".to_string(),
            account: Some(AccountIdentifier::base_account(AccountAddress::ONE)),
            amount: Some(Amount {
                value: "100".to_string(), // Positive (should be negative)
                currency: native_coin(),
            }),
            // ... other fields
        };
        
        let deposit_op = Operation {
            operation_type: "deposit".to_string(),
            account: Some(AccountIdentifier::base_account(AccountAddress::TWO)),
            amount: Some(Amount {
                value: "-100".to_string(), // Negative (should be positive)
                currency: native_coin(),
            }),
            // ... other fields
        };
        
        let operations = vec![withdraw_op, deposit_op];
        
        // This should fail but currently passes validation
        let result = Transfer::extract_transfer(&server_context, &operations);
        
        // Verify the vulnerability: amount wraps to huge value
        if let Ok(transfer) = result {
            assert_eq!(transfer.amount.0, 18446744073709551516u64);
            println!("VULNERABILITY CONFIRMED: -100 wrapped to {}", transfer.amount.0);
        }
    }
}
```

**Manual API Test:**
```bash
curl -X POST http://rosetta-api/construction/payloads \
  -H "Content-Type: application/json" \
  -d '{
    "network_identifier": {"blockchain": "aptos", "network": "mainnet"},
    "operations": [
      {
        "operation_identifier": {"index": 0},
        "type": "withdraw",
        "account": {"address": "0x1"},
        "amount": {"value": "100", "currency": {"symbol": "APT", "decimals": 8}}
      },
      {
        "operation_identifier": {"index": 1},
        "type": "deposit", 
        "account": {"address": "0x2"},
        "amount": {"value": "-100", "currency": {"symbol": "APT", "decimals": 8}}
      }
    ],
    "metadata": { /* ... */ }
  }'
```

The API will construct a transaction attempting to transfer 18446744073709551516 coins instead of 100.

## Notes
- The vulnerability exists in the Rosetta API layer, not the core blockchain consensus or Move VM
- Blockchain validation prevents actual fund theft, but the Rosetta API is producing incorrect transaction representations
- This violates the Rosetta API specification which requires accurate amount representation
- Systems integrating with Aptos via Rosetta API may experience unexpected behavior
- The fix is straightforward: add sign validation before the cast operation

### Citations

**File:** crates/aptos-rosetta/src/types/objects.rs (L2641-2650)
```rust
            InternalOperation::Transfer(transfer) => {
                // Check if the currency is known
                let currency = &transfer.currency;

                // We special case APT, because we don't want the behavior to change
                if currency == &native_coin() {
                    return Ok((
                        aptos_stdlib::aptos_account_transfer(transfer.receiver, transfer.amount.0),
                        transfer.sender,
                    ));
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L2840-2859)
```rust
        let (sender, withdraw_amount) = if let Some(withdraw) = op_map.get(&OperationType::Withdraw)
        {
            if let (Some(account), Some(amount)) = (&withdraw.account, &withdraw.amount) {
                if account.is_base_account() {
                    (account.account_address()?, amount)
                } else {
                    return Err(ApiError::InvalidInput(Some(
                        "Transferring stake amounts is not supported".to_string(),
                    )));
                }
            } else {
                return Err(ApiError::InvalidTransferOperations(Some(
                    "Invalid withdraw account provided",
                )));
            }
        } else {
            return Err(ApiError::InvalidTransferOperations(Some(
                "Must have a withdraw",
            )));
        };
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L2899-2919)
```rust
        let withdraw_value = i128::from_str(&withdraw_amount.value)
            .map_err(|_| ApiError::InvalidTransferOperations(Some("Withdraw amount is invalid")))?;
        let deposit_value = i128::from_str(&deposit_amount.value)
            .map_err(|_| ApiError::InvalidTransferOperations(Some("Deposit amount is invalid")))?;

        // We can't create or destroy coins, they must be negatives of each other
        if -withdraw_value != deposit_value {
            return Err(ApiError::InvalidTransferOperations(Some(
                "Withdraw amount must be equal to negative of deposit amount",
            )));
        }

        // We converted to u128 to ensure no loss of precision in comparison,
        // but now we actually have to check it's a u64
        if deposit_value > u64::MAX as i128 {
            return Err(ApiError::InvalidTransferOperations(Some(
                "Transfer amount must not be greater than u64 max",
            )));
        }

        let transfer_amount = deposit_value as u64;
```
