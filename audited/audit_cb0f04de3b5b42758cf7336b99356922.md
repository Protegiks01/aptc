# Audit Report

## Title
Missing Chain ID Validation in Indexer gRPC Fullnode Ping and Transaction Streaming Allows Cross-Chain Data Poisoning

## Summary
The indexer-grpc system's `ping()` function and transaction streaming logic fail to validate the `chain_id` returned by fullnodes. An attacker can register malicious fullnodes advertising different chain IDs, which are accepted into the fullnode pool without validation. When the GrpcManager falls back to fetching transactions from fullnodes, it may select a malicious node and serve cross-chain transactions to indexers, leading to complete corruption of indexed blockchain state.

## Finding Description

The vulnerability exists in the indexer-grpc metadata and data management system, which coordinates between fullnodes and indexers.

**Missing Validation #1: Ping Response Handling**

The `ping()` RPC returns `FullnodeInfo` containing a `chain_id` field: [1](#0-0) 

When the metadata manager receives ping responses, it stores the `FullnodeInfo` without validating that the returned `chain_id` matches the expected chain: [2](#0-1) 

The `MetadataManager` has its own `chain_id` field that should be validated against: [3](#0-2) 

**Missing Validation #2: Transaction Streaming Fallback**

When the GrpcManager is lagging, the data manager falls back to fetching transactions directly from fullnodes. This code path does NOT validate the `chain_id` in the streaming responses: [4](#0-3) 

The `TransactionsFromNodeResponse` includes a `chain_id` field that goes unvalidated: [5](#0-4) 

**Attack Masking**

The GrpcManagerService then serves these potentially malicious transactions to clients, labeling them with its own `chain_id`, effectively masking the attack: [6](#0-5) 

**Contrast with Cache Worker**

The cache worker DOES validate chain_id properly, but the data_manager bypass this validation entirely: [7](#0-6) [8](#0-7) 

**Attack Path:**

1. Attacker deploys malicious fullnodes configured with genesis from a different chain/fork (different `chain_id`)
2. These fullnodes respond to ping requests with the malicious `chain_id`
3. `MetadataManager.handle_fullnode_info()` accepts them without validating `chain_id`
4. Malicious fullnodes are added to the fullnode pool
5. When `DataManager.get_transactions()` is lagging and falls back to fullnode fetch, it may randomly select a malicious fullnode via `get_fullnode_for_request()`
6. Transactions are fetched from the malicious fullnode without `chain_id` validation
7. `GrpcManagerService.get_transactions()` serves these cross-chain transactions to indexers with the correct `chain_id` label
8. Indexers process and persist transactions from the wrong chain, corrupting their databases

## Impact Explanation

**Severity: HIGH**

This vulnerability breaks the **Deterministic Execution** and **State Consistency** invariants. Indexers are critical infrastructure that power wallets, explorers, analytics platforms, and dApps. Corrupting indexer data has cascading effects:

- **Incorrect balances and NFT ownership**: Indexers would show wrong account states
- **Fraudulent transaction history**: Transactions from a fork/different chain appear as legitimate
- **Smart contract state corruption**: dApp frontends relying on indexed data would malfunction
- **Security incident response failure**: Compromised indexers cannot be trusted for forensics

While this doesn't directly cause **Loss of Funds** on-chain, it enables fraud and manipulation at the application layer. Per Aptos Bug Bounty criteria, this qualifies as **High Severity** due to "Significant protocol violations" - the indexer protocol's fundamental assumption that all fullnodes serve data from the same chain is violated.

The attack becomes more effective over time as more malicious fullnodes are added, increasing the probability of selection, hence the "gradual migration" characterization is accurate.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attacker Requirements:**
- Ability to run fullnode instances (low barrier - public software)
- Network connectivity to the metadata manager
- No privileged access or stake required

**Complexity: LOW**
- Simply configure fullnodes with different genesis
- No sophisticated cryptographic attacks needed
- No timing requirements

**Detection Difficulty: HIGH**
- Malicious transactions appear legitimate with correct chain_id label
- No obvious errors or crashes
- Silent data corruption

The attack is highly feasible and difficult to detect until significant damage occurs.

## Recommendation

**Fix 1: Validate chain_id in ping response handling**

```rust
fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
    // Validate chain_id matches expected value
    if info.chain_id != self.chain_id {
        bail!(
            "[Metadata Manager] Chain ID mismatch for fullnode {}: expected {}, got {}",
            address,
            self.chain_id,
            info.chain_id
        );
    }
    
    let mut entry = self
        .fullnodes
        .entry(address.clone())
        .or_insert(Fullnode::new(address.clone()));
    entry.value_mut().recent_states.push_back(info);
    if let Some(known_latest_version) = info.known_latest_version {
        trace!(
            "Received known_latest_version ({known_latest_version}) from fullnode {address}."
        );
        self.update_known_latest_version(known_latest_version);
    }
    if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
        entry.value_mut().recent_states.pop_front();
    }

    Ok(())
}
```

**Fix 2: Validate chain_id in data_manager transaction fetch fallback**

```rust
if self.lagging(cache_next_version) && self.allow_fn_fallback {
    debug!("GrpcManager is lagging, getting data from FN...");
    let request = GetTransactionsFromNodeRequest {
        starting_version: Some(start_version),
        transactions_count: Some(5000),
    };

    let (_, mut fullnode_client) =
        self.metadata_manager.get_fullnode_for_request(&request);
    let response = fullnode_client.get_transactions_from_node(request).await?;
    let mut response = response.into_inner();
    
    while let Some(Ok(response_item)) = response.next().await {
        // Validate chain_id for each response
        if response_item.chain_id as u64 != self.file_store_reader.chain_id {
            bail!(
                "[Data Manager] Chain ID mismatch in transaction stream: expected {}, got {}",
                self.file_store_reader.chain_id,
                response_item.chain_id
            );
        }
        
        if let Some(response) = response_item.response {
            match response {
                Response::Data(data) => {
                    return Ok(data.transactions);
                },
                Response::Status(_) => continue,
            }
        }
    }
}
```

**Fix 3: Add chain_id field to DataManager and validate during construction**

The `DataManager` should store and validate `chain_id` consistently across all data sources.

## Proof of Concept

**Setup:**
1. Deploy legitimate Aptos fullnode on mainnet (chain_id = 1)
2. Deploy malicious fullnode configured with testnet genesis (chain_id = 2)
3. Configure indexer-grpc-manager to connect to both fullnodes

**Attack Execution:**

```rust
// Malicious fullnode responds to ping with wrong chain_id
// In fullnode_data_service.rs, attacker's node returns:
let info = FullnodeInfo {
    chain_id: 2, // Testnet chain_id instead of mainnet (1)
    timestamp: Some(timestamp),
    known_latest_version: Some(12345678),
};

// Metadata manager accepts this without validation
// Malicious fullnode is now in the pool

// When GrpcManager falls back to fullnode fetch:
// 1. get_fullnode_for_request() may select malicious node
// 2. Transactions from testnet are fetched
// 3. No chain_id validation occurs in data_manager
// 4. GrpcManagerService serves them labeled as mainnet (chain_id=1)
```

**Verification:**
1. Monitor indexer database for transactions with hashes that don't exist on mainnet
2. Check for accounts with impossible balances (from testnet state)
3. Verify transaction signatures against mainnet accounts (will fail)

**Expected Result:**
Indexer processes testnet transactions as if they were mainnet, corrupting all indexed state including balances, NFT ownership, and smart contract events.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L207-242)
```rust
    async fn ping(
        &self,
        _request: Request<PingFullnodeRequest>,
    ) -> Result<Response<PingFullnodeResponse>, Status> {
        let timestamp = timestamp_now_proto();
        let known_latest_version = self
            .service_context
            .context
            .db
            .get_synced_version()
            .map_err(|e| Status::internal(format!("{e}")))?;

        let table_info_version = self
            .service_context
            .context
            .indexer_reader
            .as_ref()
            .and_then(|r| r.get_latest_table_info_ledger_version().ok().flatten());

        if known_latest_version.is_some() && table_info_version.is_some() {
            let version = std::cmp::min(known_latest_version.unwrap(), table_info_version.unwrap());
            if let Ok(timestamp_us) = self.service_context.context.db.get_block_timestamp(version) {
                let latency = SystemTime::now().duration_since(UNIX_EPOCH).unwrap()
                    - Duration::from_micros(timestamp_us);
                LATENCY_MS.set(latency.as_millis() as i64);
            }
        }

        let info = FullnodeInfo {
            chain_id: self.service_context.context.chain_id().id() as u64,
            timestamp: Some(timestamp),
            known_latest_version,
        };
        let response = PingFullnodeResponse { info: Some(info) };
        Ok(Response::new(response))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L127-138)
```rust
pub(crate) struct MetadataManager {
    chain_id: u64,
    self_advertised_address: GrpcAddress,
    grpc_managers: DashMap<GrpcAddress, Peer>,
    fullnodes: DashMap<GrpcAddress, Fullnode>,
    live_data_services: DashMap<GrpcAddress, LiveDataService>,
    historical_data_services: DashMap<GrpcAddress, HistoricalDataService>,
    known_latest_version: AtomicU64,
    // NOTE: We assume the master is statically configured for now.
    master_address: Mutex<Option<GrpcAddress>>,
}

```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-550)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L302-323)
```rust
                if self.lagging(cache_next_version) && self.allow_fn_fallback {
                    debug!("GrpcManager is lagging, getting data from FN, requested_version: {start_version}, cache_next_version: {cache_next_version}.");
                    let request = GetTransactionsFromNodeRequest {
                        starting_version: Some(start_version),
                        transactions_count: Some(5000),
                    };

                    let (_, mut fullnode_client) =
                        self.metadata_manager.get_fullnode_for_request(&request);
                    let response = fullnode_client.get_transactions_from_node(request).await?;
                    let mut response = response.into_inner();
                    while let Some(Ok(response_item)) = response.next().await {
                        if let Some(response) = response_item.response {
                            match response {
                                Response::Data(data) => {
                                    return Ok(data.transactions);
                                },
                                Response::Status(_) => continue,
                            }
                        }
                    }
                }
```

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.rs (L78-96)
```rust
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionsFromNodeResponse {
    /// Making sure that all the responses include a chain id
    #[prost(uint32, tag="3")]
    pub chain_id: u32,
    #[prost(oneof="transactions_from_node_response::Response", tags="1, 2")]
    pub response: ::core::option::Option<transactions_from_node_response::Response>,
}
/// Nested message and enum types in `TransactionsFromNodeResponse`.
pub mod transactions_from_node_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag="1")]
        Status(super::StreamStatus),
        #[prost(message, tag="2")]
        Data(super::TransactionsOutput),
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L129-146)
```rust
    async fn get_transactions(
        &self,
        request: Request<GetTransactionsRequest>,
    ) -> Result<Response<TransactionsResponse>, Status> {
        let request = request.into_inner();
        let transactions = self
            .data_manager
            .get_transactions(request.starting_version(), MAX_SIZE_BYTES_FROM_CACHE)
            .await
            .map_err(|e| Status::internal(format!("{e}")))?;

        Ok(Response::new(TransactionsResponse {
            transactions,
            chain_id: Some(self.chain_id),
            // Not used.
            processed_range: None,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L310-324)
```rust
    // Guaranteed that chain id is here at this point because we already ensure that fileworker did the set up
    let chain_id = cache_operator.get_chain_id().await?.unwrap();
    if chain_id != fullnode_chain_id as u64 {
        bail!("[Indexer Cache] Chain ID mismatch between fullnode init signal and cache.");
    }

    // It's required to start the worker with the same version as file store.
    if file_store_metadata.version != starting_version {
        bail!("[Indexer Cache] Starting version mismatch between filestore metadata and fullnode init signal.");
    }
    if file_store_metadata.chain_id != fullnode_chain_id as u64 {
        bail!("[Indexer Cache] Chain id mismatch between filestore metadata and fullnode.");
    }

    Ok((fullnode_chain_id, starting_version))
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L382-384)
```rust
        if received.chain_id as u64 != fullnode_chain_id as u64 {
            panic!("[Indexer Cache] Chain id mismatch happens during data streaming.");
        }
```
