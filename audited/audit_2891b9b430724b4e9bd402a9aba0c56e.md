# Audit Report

## Title
Resource Exhaustion via Unlimited BCS Deserialization Errors Without Connection Closure

## Summary
The network peer manager treats BCS deserialization errors as "recoverable" and maintains open connections indefinitely without tracking or limiting consecutive deserialization failures, enabling resource exhaustion attacks against validator nodes.

## Finding Description

The `PeerManagerError::BcsError` handling path has a critical design flaw where BCS deserialization failures do not trigger connection closure or error counting. [1](#0-0) 

When a malformed message arrives that fails BCS deserialization, the code path:
1. Receives a `ReadError::DeserializeError` containing the BCS error and frame metadata
2. Extracts raw bytes (message_type and protocol_id) from the malformed frame without validation
3. Constructs and sends an error response back to the malicious peer  
4. **Crucially**: Returns an error but does NOT close the connection (unlike `IoError` which calls `self.shutdown()`)
5. Allows the malicious peer to continue sending malformed frames indefinitely [2](#0-1) 

The deserialization occurs in `MultiplexMessageStream::poll_next()` where `bcs::from_bytes(&frame)` is called on each received frame. When this fails, a `DeserializeError` is created but the connection remains open.

**Attack Vector:**
An attacker controlling multiple IP addresses can:
1. Establish connections to validator nodes (up to `MAX_INBOUND_CONNECTIONS = 100`)
2. Send large frames (up to `MAX_FRAME_SIZE = 4 MiB`) containing malformed BCS data
3. Each frame passes the framing layer successfully but fails BCS deserialization
4. The victim node repeatedly attempts to deserialize the malformed data, consuming CPU
5. The connection remains open with no circuit breaker or error limit
6. Health checks continue to pass because ping messages use valid BCS encoding

**Why This Is NOT a Security Check Bypass:**
Importantly, the malformed messages do NOT bypass security checks in application handlers - they fail completely at the BCS deserialization layer and never reach consensus, mempool, or other protocol handlers. However, the question is whether the BCS error handling itself properly validates failures, and the answer is NO - it does not implement any validation or limiting of repeated failures.

## Impact Explanation

**Severity: High** - Validator Node Slowdowns

With default rate limiting (`IP_BYTE_BUCKET_RATE = 100 KiB/s`), an attacker with 100 different IP addresses can generate sustained load:
- 100 IPs × 100 KiB/s = 10 MiB/s aggregate inbound traffic
- At 4 MiB per frame ≈ 2.5 deserialization attempts per second per IP
- Total: ~250 deserialization attempts/second across all connections
- Each attempt processes up to 4 MiB of malformed data through the BCS deserializer

While BCS has recursion limits that prevent exponential CPU costs, the linear cost of processing 10 MiB/s of malformed data continuously can cause measurable CPU degradation on validator nodes, particularly under existing consensus load. [3](#0-2) 

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires:
- Multiple IP addresses (easily obtainable via cloud providers, botnets, or VPNs)
- Basic understanding of Aptos network framing protocol (length-delimited frames)
- Ability to send malformed BCS data (trivial - random bytes work)
- No authentication or validator privileges needed

The attack is practical because:
1. No circuit breaker exists for deserialization errors
2. Health checks operate independently using valid messages
3. Rate limiting applies per-IP, so distributing across IPs is effective
4. The vulnerability affects all validator nodes equally

## Recommendation

Implement a circuit breaker pattern that tracks consecutive deserialization errors and closes connections that exceed a threshold:

```rust
// In Peer struct, add:
consecutive_deser_errors: u32,
const MAX_CONSECUTIVE_DESER_ERRORS: u32 = 10;

// In handle_inbound_message:
ReadError::DeserializeError(_, _, ref frame_prefix) => {
    self.consecutive_deser_errors += 1;
    
    if self.consecutive_deser_errors >= Self::MAX_CONSECUTIVE_DESER_ERRORS {
        warn!(/* log error */);
        self.shutdown(DisconnectReason::InputOutputError);
        return Err(err.into());
    }
    
    let message_type = frame_prefix.as_ref().first().unwrap_or(&0);
    let protocol_id = frame_prefix.as_ref().get(1).unwrap_or(&0);
    let error_code = ErrorCode::parsing_error(*message_type, *protocol_id);
    let message = NetworkMessage::Error(error_code);
    
    write_reqs_tx.push((), message)?;
    return Err(err.into());
}

// Reset counter on successful deserialization:
Ok(message) => {
    self.consecutive_deser_errors = 0;
    // continue processing...
}
```

Additionally, add metrics to track deserialization error rates per peer for monitoring and alerting.

## Proof of Concept

```rust
#[tokio::test]
async fn test_deser_error_exhaustion() {
    use network::protocols::wire::messaging::v1::{network_message_frame_codec, MultiplexMessageStream};
    use tokio_util::codec::FramedWrite;
    use bytes::Bytes;
    
    // Create a mock socket pair
    let (client, server) = tokio::io::duplex(8192);
    
    // Client sends malformed frames
    let codec = network_message_frame_codec(4 * 1024 * 1024);
    let mut writer = FramedWrite::new(client, codec);
    
    // Server attempts to read
    let mut reader = MultiplexMessageStream::new(server, 4 * 1024 * 1024);
    
    // Send 100 malformed frames
    for i in 0..100 {
        // Valid frame structure but invalid BCS content
        let malformed_data = vec![0xFF; 1024]; // Invalid BCS data
        let frame = Bytes::from(malformed_data);
        writer.send(frame).await.unwrap();
        
        // Verify deserialization error occurs but connection stays open
        if let Some(result) = reader.next().await {
            assert!(result.is_err()); // Deserialization should fail
            match result {
                Err(ReadError::DeserializeError(..)) => {
                    // Connection is still alive - can continue sending
                    println!("Frame {} failed deserialization, connection open", i);
                }
                _ => panic!("Expected DeserializeError"),
            }
        }
    }
    
    // Connection remains open after 100 consecutive failures
    // This demonstrates the lack of circuit breaker
}
```

## Notes

This vulnerability exists because the design philosophy treats deserialization errors as "recoverable" to maintain connection resilience. However, the lack of any threshold or circuit breaker allows abuse. While rate limiting provides some protection, it is insufficient to prevent resource exhaustion attacks distributed across multiple IP addresses.

The issue specifically affects the invariant: **"Resource Limits: All operations must respect gas, storage, and computational limits"** - the unlimited deserialization retry behavior violates reasonable resource limit expectations for network operations.

### Citations

**File:** network/framework/src/peer/mod.rs (L576-587)
```rust
                ReadError::DeserializeError(_, _, ref frame_prefix) => {
                    // DeserializeError's are recoverable so we'll let the other
                    // peer know about the error and log the issue, but we won't
                    // close the connection.
                    let message_type = frame_prefix.as_ref().first().unwrap_or(&0);
                    let protocol_id = frame_prefix.as_ref().get(1).unwrap_or(&0);
                    let error_code = ErrorCode::parsing_error(*message_type, *protocol_id);
                    let message = NetworkMessage::Error(error_code);

                    write_reqs_tx.push((), message)?;
                    return Err(err.into());
                },
```

**File:** network/framework/src/protocols/wire/messaging/v1/mod.rs (L230-240)
```rust
                match bcs::from_bytes(&frame) {
                    Ok(message) => Poll::Ready(Some(Ok(message))),
                    // Failed to deserialize the NetworkMessage
                    Err(err) => {
                        let mut frame = frame;
                        let frame_len = frame.len();
                        // Keep a few bytes from the frame for debugging
                        frame.truncate(8);
                        let err = ReadError::DeserializeError(err, frame_len, frame);
                        Poll::Ready(Some(Err(err)))
                    },
```

**File:** config/src/config/network_config.rs (L49-53)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
pub const CONNECTION_BACKOFF_BASE: u64 = 2;
pub const IP_BYTE_BUCKET_RATE: usize = 102400 /* 100 KiB */;
pub const IP_BYTE_BUCKET_SIZE: usize = IP_BYTE_BUCKET_RATE;
```
