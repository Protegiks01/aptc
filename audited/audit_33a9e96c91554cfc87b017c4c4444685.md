# Audit Report

## Title
Inconsistent KeylessSignature Size Limit Enforcement Between JSON and BCS Submission Paths Enables Resource Exhaustion

## Summary
The `KeylessSignature::MAX_LEN` size limit (4000 bytes) is enforced only for JSON transaction submissions but bypassed for BCS submissions, allowing attackers to submit oversized keyless signatures that consume excessive resources during validation before being rejected.

## Finding Description

The keyless authentication system defines a maximum size limit for signatures that is documented as being "enforced by our full nodes when they receive TXNs" [1](#0-0) , yet enforcement is inconsistent across submission paths.

**JSON Submission Path (Enforced):**
For JSON submissions, the validation chain enforces size limits: `SubmitTransactionPost::Json` calls `SubmitTransactionRequest::verify()` [2](#0-1) , which delegates to `TransactionSignature::verify()` [3](#0-2) , then to `AccountSignature::verify()` [4](#0-3) , and finally to `SingleKeySignature::verify()` [5](#0-4)  which validates keyless signatures [6](#0-5) . The keyless signature verification checks that signature length does not exceed `MAX_LEN` [7](#0-6) .

**BCS Submission Path (Bypassed):**
For BCS submissions, the `VerifyInput` implementation returns `Ok(())` without any validation [8](#0-7) . BCS transactions are deserialized directly using `bcs::from_bytes_with_limit` with only a depth limit [9](#0-8) , which does not constrain string field sizes.

**Attack Flow:**
1. Attacker crafts `KeylessSignature` with large variable-length fields (e.g., 100KB `jwt_header_json`)
2. Submits via BCS endpoint (`application/x.aptos.signed_transaction+bcs`)
3. BCS deserialization allocates memory for the oversized strings without size validation
4. Transaction proceeds to VM validation [10](#0-9) 
5. Keyless validation attempts to compute public inputs hash [11](#0-10) 
6. Eventually rejected when `jwt_header_json` exceeds circuit limit (300 bytes) during hash computation [12](#0-11)  which validates against `max_jwt_header_b64_bytes` [13](#0-12)  by checking `len > max_bytes` [14](#0-13) 

The validation occurs before mempool admission [15](#0-14)  and only successful validations are added to mempool [16](#0-15) .

## Impact Explanation

**Severity: Medium** - Validator node slowdowns through resource exhaustion

While transactions are rejected before mempool admission, the vulnerability enables:

1. **Memory Exhaustion**: BCS deserialization allocates memory for arbitrarily large string fields (jwt_header_json, extra_field, etc.) without checking against `MAX_LEN`, allowing up to HTTP payload limits
2. **CPU Waste**: Validation processing (signature checks, deserialization, hash computations) is performed on transactions that will ultimately be rejected due to circuit constraints
3. **DoS Amplification**: Attackers can flood API endpoints with oversized signatures, consuming validator API resources before rejection
4. **Inconsistent Security Boundary**: The documented enforcement in the comment "enforced by our full nodes when they receive TXNs" is not uniformly applied across submission paths

The impact is classified as Medium rather than High because validation rejects transactions before mempool admission, limiting the scope of resource exhaustion to the API validation phase rather than affecting consensus or state commitment.

## Likelihood Explanation

**Likelihood: High** - Attack is trivial to execute:
- No authentication required beyond standard transaction submission
- BCS encoding libraries are widely available in multiple languages
- HTTP payload limits allow significant amplification (100KB+ signatures vs. expected ~300-1000 bytes)
- Attacker can sustain continuous attack with modest resources by repeatedly submitting oversized BCS transactions
- No rate limiting specifically prevents this attack vector

## Recommendation

Enforce `MAX_LEN` validation for BCS submissions by modifying the `VerifyInput` implementation:

```rust
impl VerifyInput for SubmitTransactionPost {
    fn verify(&self) -> anyhow::Result<()> {
        match self {
            SubmitTransactionPost::Json(inner) => inner.0.verify(),
            SubmitTransactionPost::Bcs(data) => {
                // Add size check for BCS submissions
                if data.0.len() > SignedTransaction::MAX_SIZE {
                    bail!("BCS transaction exceeds maximum size");
                }
                Ok(())
            },
        }
    }
}
```

Additionally, consider validating signature component sizes during BCS deserialization or immediately after, before expensive validation operations.

## Proof of Concept

```rust
// Create oversized KeylessSignature
let mut oversized_jwt_header = String::new();
for _ in 0..100_000 {
    oversized_jwt_header.push('a');
}

let sig = KeylessSignature {
    cert: EphemeralCertificate::ZeroKnowledgeSig(/* valid ZK proof */),
    jwt_header_json: oversized_jwt_header,
    exp_date_secs: current_time + 3600,
    ephemeral_pubkey: /* valid ephemeral key */,
    ephemeral_signature: /* valid signature */,
};

// BCS encode transaction with oversized signature
let txn = SignedTransaction::new(/* ... with sig ... */);
let bcs_bytes = bcs::to_bytes(&txn).unwrap();

// Submit via BCS endpoint - bypasses MAX_LEN check
// POST /transactions with Content-Type: application/x.aptos.signed_transaction+bcs
// Body: bcs_bytes
// 
// Result: Transaction consumes memory during deserialization and validation
// before being rejected for exceeding circuit limits
```

### Citations

**File:** types/src/keyless/mod.rs (L193-195)
```rust
    /// A reasonable upper bound for the number of bytes we expect in a keyless signature. This is
    /// enforced by our full nodes when they receive TXNs.
    pub const MAX_LEN: usize = 4000;
```

**File:** api/types/src/transaction.rs (L453-457)
```rust
impl VerifyInput for SubmitTransactionRequest {
    fn verify(&self) -> anyhow::Result<()> {
        self.user_transaction_request.verify()?;
        self.signature.verify()
    }
```

**File:** api/types/src/transaction.rs (L1215-1225)
```rust
impl VerifyInput for TransactionSignature {
    fn verify(&self) -> anyhow::Result<()> {
        match self {
            TransactionSignature::Ed25519Signature(inner) => inner.verify(),
            TransactionSignature::MultiEd25519Signature(inner) => inner.verify(),
            TransactionSignature::MultiAgentSignature(inner) => inner.verify(),
            TransactionSignature::FeePayerSignature(inner) => inner.verify(),
            TransactionSignature::SingleSender(inner) => inner.verify(),
            TransactionSignature::NoAccountSignature(inner) => inner.verify(),
        }
    }
```

**File:** api/types/src/transaction.rs (L1530-1534)
```rust
        } else if signature_len > keyless::KeylessSignature::MAX_LEN {
            bail!(
                "Keyless signature length is greater than the maximum number of {} bytes: found {} bytes",
                keyless::KeylessSignature::MAX_LEN, signature_len
            )
```

**File:** api/types/src/transaction.rs (L1738-1777)
```rust
impl VerifyInput for SingleKeySignature {
    fn verify(&self) -> anyhow::Result<()> {
        match (&self.public_key, &self.signature) {
            (PublicKey::Ed25519(p), Signature::Ed25519(s)) => Ed25519Signature {
                public_key: p.value.clone(),
                signature: s.value.clone(),
            }
            .verify(),
            (PublicKey::Secp256k1Ecdsa(p), Signature::Secp256k1Ecdsa(s)) => {
                Secp256k1EcdsaSignature {
                    public_key: p.value.clone(),
                    signature: s.value.clone(),
                }
                .verify()
            },
            (PublicKey::SlhDsa_Sha2_128s(p), Signature::SlhDsa_Sha2_128s(s)) => {
                SlhDsa_Sha2_128sSignature {
                    public_key: p.value.clone(),
                    signature: s.value.clone(),
                }
                .verify()
            },
            (PublicKey::Secp256r1Ecdsa(p), Signature::WebAuthn(s)) => WebAuthnSignature {
                public_key: p.value.clone(),
                signature: s.value.clone(),
            }
            .verify(),
            (PublicKey::Keyless(p), Signature::Keyless(s)) => KeylessSignature {
                public_key: p.value.clone(),
                signature: s.value.clone(),
            }
            .verify(),
            (PublicKey::FederatedKeyless(p), Signature::Keyless(s)) => KeylessSignature {
                public_key: p.value.clone(),
                signature: s.value.clone(),
            }
            .verify(),
            _ => bail!("Invalid public key, signature match."),
        }
    }
```

**File:** api/types/src/transaction.rs (L2093-2103)
```rust
impl VerifyInput for AccountSignature {
    fn verify(&self) -> anyhow::Result<()> {
        match self {
            AccountSignature::Ed25519Signature(inner) => inner.verify(),
            AccountSignature::MultiEd25519Signature(inner) => inner.verify(),
            AccountSignature::SingleKeySignature(inner) => inner.verify(),
            AccountSignature::MultiKeySignature(inner) => inner.verify(),
            AccountSignature::NoAccountSignature(inner) => inner.verify(),
            AccountSignature::AbstractSignature(inner) => inner.verify(),
        }
    }
```

**File:** api/src/transactions.rs (L98-105)
```rust
impl VerifyInput for SubmitTransactionPost {
    fn verify(&self) -> anyhow::Result<()> {
        match self {
            SubmitTransactionPost::Json(inner) => inner.0.verify(),
            SubmitTransactionPost::Bcs(_) => Ok(()),
        }
    }
}
```

**File:** api/src/transactions.rs (L1223-1232)
```rust
                let signed_transaction: SignedTransaction =
                    bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
                        .context("Failed to deserialize input into SignedTransaction")
                        .map_err(|err| {
                            SubmitTransactionError::bad_request_with_code(
                                err,
                                AptosErrorCode::InvalidInput,
                                ledger_info,
                            )
                        })?;
```

**File:** mempool/src/shared_mempool/tasks.rs (L490-503)
```rust
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
```

**File:** mempool/src/shared_mempool/tasks.rs (L512-523)
```rust
                    None => {
                        let ranking_score = validation_result.score();
                        let mempool_status = mempool.add_txn(
                            transaction.clone(),
                            ranking_score,
                            account_sequence_number,
                            timeline_state,
                            client_submitted,
                            ready_time_at_sender,
                            priority.clone(),
                        );
                        statuses.push((transaction, (mempool_status, None)));
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L307-316)
```rust
                        let public_inputs_hash = get_public_inputs_hash(
                            signature,
                            public_key.inner_keyless_pk(),
                            rsa_jwk,
                            config,
                        )
                        .map_err(|_| {
                            // println!("[aptos-vm][groth16] PIH computation failed");
                            invalid_signature!("Could not compute public inputs hash")
                        })?;
```

**File:** types/src/keyless/bn254_circom.rs (L312-315)
```rust
    let jwt_header_hash = cached_pad_and_hash_string(
        &jwt_header_b64_with_separator,
        config.max_jwt_header_b64_bytes as usize,
    )?;
```

**File:** types/src/keyless/circuit_constants.rs (L21-21)
```rust
pub(crate) const MAX_JWT_HEADER_B64_BYTES: u32 = 300;
```

**File:** crates/aptos-crypto/src/poseidon_bn254/keyless.rs (L97-100)
```rust
    if len > max_bytes {
        bail!(
            "Byte array length of {} is NOT <= max length of {} bytes.",
            bytes.len(),
```
