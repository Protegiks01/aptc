# Audit Report

## Title
Pending Active Validators Can Bypass Stake Lockup Period Through Early Exit

## Summary
Validators who join the validator set but call `leave_validator_set()` before the first epoch transition can immediately withdraw their stake without waiting for the lockup period, completely bypassing the stake lockup mechanism designed to prevent immediate unstaking attacks.

## Finding Description

The Aptos staking system enforces a lockup period (defined by `recurring_lockup_duration_secs`) to prevent validators from immediately unstaking after joining the validator set. This lockup mechanism is critical for network security, as it ensures validators have "skin in the game" and cannot rapidly enter/exit to manipulate voting power or avoid penalties.

However, a critical vulnerability exists in the validator lifecycle:

When a stake pool is initialized, the `locked_until_secs` field is set to 0. [1](#0-0) 

The lockup is only set when a validator becomes active during the `on_new_epoch()` epoch transition, which automatically renews lockup for active validators. [2](#0-1) 

The `leave_validator_set()` function has special handling for validators still in PENDING_ACTIVE status - it directly removes them from the pending_active list without moving them to pending_inactive. [3](#0-2) 

This means if a validator leaves before their first epoch as an active validator, their `locked_until_secs` remains 0.

The `withdraw_with_cap()` function has an edge case handler that allows immediate withdrawal when a validator is INACTIVE and the lockup has expired. [4](#0-3)  Since `timestamp::now_seconds() >= 0` is always true, this condition is satisfied immediately.

**Attack Path:**

1. Attacker initializes a validator stake pool (lockup = 0)
2. Attacker calls `join_validator_set()` → status becomes PENDING_ACTIVE
3. Attacker calls `add_stake(X)` → X coins added to active pool. For PENDING_ACTIVE validators, stake goes to `active` not `pending_active` because PENDING_ACTIVE validators are not considered "current epoch validators". [5](#0-4) [6](#0-5) 
4. Before the next epoch, attacker calls `leave_validator_set()` → removed from pending_active, status becomes INACTIVE, lockup still 0
5. Attacker calls `unlock(X)` → moves stake from active to pending_inactive. The `unlock_with_cap()` function does NOT check `locked_until_secs` before allowing the unlock operation. [7](#0-6)  This is confirmed by the formal specification which has no abort condition for lockup. [8](#0-7)  The test suite even demonstrates that validators can unlock stake while lockup is still active. [9](#0-8) 
6. Attacker calls `withdraw(X)` → edge case handler moves pending_inactive to inactive (because validator is INACTIVE AND timestamp >= 0), withdrawal succeeds immediately

## Impact Explanation

**Severity: HIGH (up to $50,000)**

This vulnerability breaks the fundamental staking security invariant that validator stake must remain locked for a minimum duration. The lockup mechanism serves several critical purposes:

1. **Prevent rapid validator churn** - Attackers could join/leave repeatedly to manipulate the validator set
2. **Ensure accountability** - Validators should have locked stake during their tenure to be penalized for misbehavior
3. **Voting power stability** - Prevents manipulation of governance voting power through rapid stake movements
4. **Economic security** - Creates a commitment period that aligns validator incentives with network health

This qualifies as a "Significant protocol violation" under the High Severity category, as it completely bypasses a core security mechanism of the staking system. The vulnerability affects the Aptos Framework staking module, which is a critical component for validator management and network security.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is:
- **Easy to discover**: The attack path is straightforward - the code review clearly shows `unlock_with_cap()` has no lockup validation
- **Simple to execute**: Only requires calling standard public entry functions (`join_validator_set`, `add_stake`, `leave_validator_set`, `unlock`, `withdraw`) in sequence
- **No special conditions**: Works for any validator at any time before their first epoch transition
- **Deterministic**: Always succeeds when executed correctly - the edge case handler condition is always satisfied when lockup = 0
- **Undetectable**: Appears as normal validator operations with no abnormal patterns

The only requirement is having enough stake to meet the minimum validator requirements, which is publicly known configuration data easily achievable by any attacker with sufficient capital.

## Recommendation

Add a lockup check to the `unlock_with_cap()` function to enforce that stake cannot be unlocked before the lockup period expires:

```move
public fun unlock_with_cap(amount: u64, owner_cap: &OwnerCapability) acquires StakePool {
    assert_reconfig_not_in_progress();
    // Short-circuit if amount to unlock is 0 so we don't emit events.
    if (amount == 0) {
        return
    };
    
    let pool_address = owner_cap.pool_address;
    assert_stake_pool_exists(pool_address);
    let stake_pool = borrow_global_mut<StakePool>(pool_address);
    
    // ADD THIS CHECK: Ensure lockup has expired before allowing unlock
    assert!(
        timestamp::now_seconds() >= stake_pool.locked_until_secs,
        error::invalid_state(ELOCKUP_HAS_NOT_EXPIRED)
    );
    
    // Rest of the function remains the same...
    let amount = min(amount, coin::value(&stake_pool.active));
    let unlocked_stake = coin::extract(&mut stake_pool.active, amount);
    coin::merge<AptosCoin>(&mut stake_pool.pending_inactive, unlocked_stake);
    // ...
}
```

Alternatively, ensure that validators in PENDING_ACTIVE state get their lockup set when they join the validator set, not just when they become active:

```move
public(friend) fun join_validator_set_internal(
    operator: &signer,
    pool_address: address
) acquires StakePool, ValidatorConfig, ValidatorSet {
    // ... existing code ...
    
    // ADD THIS: Set lockup immediately when joining validator set
    let config = staking_config::get();
    let recurring_lockup_duration_secs = staking_config::get_recurring_lockup_duration(&config);
    stake_pool.locked_until_secs = timestamp::now_seconds() + recurring_lockup_duration_secs;
    
    // ... rest of the function ...
}
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, validator = @0x123)]
public entry fun test_pending_active_validator_bypass_lockup(
    aptos_framework: &signer,
    validator: &signer,
) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, StakePool, ValidatorConfig, ValidatorSet {
    initialize_for_test(aptos_framework);
    
    // Step 1: Initialize validator with 100 coins
    let (_sk, pk, pop) = generate_identity();
    initialize_test_validator(&pk, &pop, validator, 100, true, false);
    let validator_address = signer::address_of(validator);
    
    // Step 2: Verify in PENDING_ACTIVE status and lockup = 0
    assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_PENDING_ACTIVE, 0);
    assert!(get_lockup_secs(validator_address) == 0, 1);
    
    // Step 3: Leave validator set before epoch ends
    leave_validator_set(validator, validator_address);
    assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_INACTIVE, 2);
    assert!(get_lockup_secs(validator_address) == 0, 3);
    
    // Step 4: Unlock all stake (should fail if lockup is enforced, but succeeds due to bug)
    unlock(validator, 100);
    let (active, inactive, pending_active, pending_inactive) = get_stake(validator_address);
    assert!(pending_inactive == 100, 4);
    
    // Step 5: Withdraw immediately (should fail if lockup is enforced, but succeeds due to bug)
    withdraw(validator, 100);
    let (active, inactive, pending_active, pending_inactive) = get_stake(validator_address);
    assert!(inactive == 0, 5); // All withdrawn successfully
    
    // Attack succeeded: validator bypassed lockup completely
}
```

## Notes

The vulnerability stems from a design flaw where:
1. The `unlock_with_cap()` function's comment states "Only possible if the lockup has expired" but this is not enforced in the implementation
2. PENDING_ACTIVE validators never receive a lockup because lockup is only set during `on_new_epoch()` for active validators
3. The edge case handler in `withdraw_with_cap()` was designed to handle stuck funds but inadvertently enables immediate withdrawal when lockup = 0

This is a genuine security vulnerability that completely bypasses the staking lockup mechanism for a specific validator lifecycle path.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L700-705)
```text
        move_to(owner, StakePool {
            active: coin::zero<AptosCoin>(),
            pending_active: coin::zero<AptosCoin>(),
            pending_inactive: coin::zero<AptosCoin>(),
            inactive: coin::zero<AptosCoin>(),
            locked_until_secs: 0,
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L837-841)
```text
        if (is_current_epoch_validator(pool_address)) {
            coin::merge<AptosCoin>(&mut stake_pool.pending_active, coins);
        } else {
            coin::merge<AptosCoin>(&mut stake_pool.active, coins);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1117-1132)
```text
    public fun unlock_with_cap(amount: u64, owner_cap: &OwnerCapability) acquires StakePool {
        assert_reconfig_not_in_progress();
        // Short-circuit if amount to unlock is 0 so we don't emit events.
        if (amount == 0) {
            return
        };

        // Unlocked coins are moved to pending_inactive. When the current lockup cycle expires, they will be moved into
        // inactive in the earliest possible epoch transition.
        let pool_address = owner_cap.pool_address;
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        // Cap amount to unlock by maximum active stake.
        let amount = min(amount, coin::value(&stake_pool.active));
        let unlocked_stake = coin::extract(&mut stake_pool.active, amount);
        coin::merge<AptosCoin>(&mut stake_pool.pending_inactive, unlocked_stake);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1177-1181)
```text
        if (get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE &&
            timestamp::now_seconds() >= stake_pool.locked_until_secs) {
            let pending_inactive_stake = coin::extract_all(&mut stake_pool.pending_inactive);
            coin::merge(&mut stake_pool.inactive, pending_inactive_stake);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1231-1235)
```text
        // If the validator is still pending_active, directly kick the validator out.
        let maybe_pending_active_index = find_validator(&validator_set.pending_active, pool_address);
        if (option::is_some(&maybe_pending_active_index)) {
            vector::swap_remove(
                &mut validator_set.pending_active, option::extract(&mut maybe_pending_active_index));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1274-1277)
```text
    public fun is_current_epoch_validator(pool_address: address): bool acquires ValidatorSet {
        assert_stake_pool_exists(pool_address);
        let validator_state = get_validator_state(pool_address);
        validator_state == VALIDATOR_STATUS_ACTIVE || validator_state == VALIDATOR_STATUS_PENDING_INACTIVE
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1444-1448)
```text
            if (stake_pool.locked_until_secs <= reconfig_start_secs) {
                spec {
                    assume now_secs + recurring_lockup_duration_secs <= MAX_U64;
                };
                stake_pool.locked_until_secs = now_secs + recurring_lockup_duration_secs;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L2443-2445)
```text
        assert!(get_remaining_lockup_secs(validator_address) == LOCKUP_CYCLE_SECONDS, 1);
        unlock(validator, 50);
        assert_validator_state(validator_address, 50, 0, 0, 50, 0);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.spec.move (L333-347)
```text
    spec unlock_with_cap(amount: u64, owner_cap: &OwnerCapability) {
        // TODO: set because of timeout (property proved)
        pragma verify_duration_estimate = 300;
        let pool_address = owner_cap.pool_address;
        let pre_stake_pool = global<StakePool>(pool_address);
        let post stake_pool = global<StakePool>(pool_address);
        aborts_if reconfiguration_state::spec_is_in_progress();
        aborts_if amount != 0 && !exists<StakePool>(pool_address);
        modifies global<StakePool>(pool_address);
        include StakedValueNochange;
        let min_amount = aptos_std::math64::min(amount,pre_stake_pool.active.value);

        ensures stake_pool.active.value == pre_stake_pool.active.value - min_amount;
        ensures stake_pool.pending_inactive.value == pre_stake_pool.pending_inactive.value + min_amount;
    }
```
