# Audit Report

## Title
Race Condition in Indexer Status Tracking Allows Newer Records to be Overwritten by Older Ones

## Summary
The `apply_processor_status()` function in the transaction processor lacks temporal ordering guards in its database upsert operation, allowing out-of-order writes to corrupt version tracking in the `processor_statuses` table. This can lead to indexer data inconsistencies and incorrect gap detection during recovery.

## Finding Description

The `apply_processor_status()` function performs an upsert operation without checking whether the incoming data is actually newer than existing records: [1](#0-0) 

The critical issue is at the `on_conflict` clause which unconditionally overwrites all fields without any temporal ordering check. Compare this with the safe implementation in the same codebase: [2](#0-1) 

This safer version includes a WHERE clause (`WHERE processor_status.last_success_version <= EXCLUDED.last_success_version`) to prevent overwriting newer data.

The vulnerability can be triggered when:
1. Multiple indexer instances process overlapping transaction versions
2. Clock skew exists between machines running indexer instances  
3. Database write reordering occurs under high load
4. The concurrent processing architecture spawns multiple tasks: [3](#0-2) 

Each concurrent task independently calls `process_next_batch()`, and during processing, status updates are written via `apply_processor_status()`. If two processes handle overlapping versions with out-of-order completion times, the last write wins regardless of logical ordering.

The corrupted `processor_statuses` table is used by `get_start_version_long()` for gap detection: [4](#0-3) 

## Impact Explanation

This issue qualifies as **Medium Severity** under Aptos bug bounty criteria: "State inconsistencies requiring intervention."

However, it's important to note that the indexer is a **read-only auxiliary service** separate from blockchain consensus. This vulnerability affects indexer database integrity, not blockchain state or consensus. The blockchain itself continues to operate correctly; only the indexed view becomes inconsistent.

Impact includes:
- Corrupted version tracking leading to missing or duplicate indexed data
- Failed gap detection causing incomplete query results
- Applications relying on indexer receiving incorrect data
- Manual database intervention required to restore consistency

This does **NOT** affect:
- Blockchain consensus or safety
- Transaction validation or execution
- Fund security or availability
- Validator operations

## Likelihood Explanation

Likelihood is **Low to Medium** because it requires:
- Multiple indexer instances running concurrently (operational misconfiguration or high-availability setup)
- Clock skew between machines OR database write reordering
- Overlapping version processing windows

In production, a single indexer instance would typically be deployed, making this less likely. However, the vulnerability exists in the code and could manifest in distributed deployments.

## Recommendation

Add a WHERE clause to the upsert operation to prevent overwriting records with newer timestamps:

```rust
fn apply_processor_status(&self, psms: &[ProcessorStatusModel]) {
    let mut conn = self.get_conn();
    let chunks = get_chunks(psms.len(), ProcessorStatusModel::field_count());
    for (start_ind, end_ind) in chunks {
        execute_with_better_error(
            &mut conn,
            diesel::insert_into(processor_statuses::table)
                .values(&psms[start_ind..end_ind])
                .on_conflict((dsl::name, dsl::version))
                .do_update()
                .set((
                    dsl::success.eq(excluded(dsl::success)),
                    dsl::details.eq(excluded(dsl::details)),
                    dsl::last_updated.eq(excluded(dsl::last_updated)),
                )),
            Some(" WHERE processor_statuses.last_updated <= EXCLUDED.last_updated "),
        )
        .expect("Error updating Processor Status!");
    }
}
```

This ensures updates only occur if the new record's timestamp is equal to or newer than the existing record.

## Proof of Concept

```rust
// Simulation of race condition
// Thread A: Processes versions 100-110, starts at T1, completes at T5
// Thread B: Processes versions 100-110, starts at T3, completes at T4

// At T1: Thread A writes mark_versions_started (success=false, last_updated=T1)
// At T3: Thread B writes mark_versions_started (success=false, last_updated=T3) - overwrites A
// At T4: Thread B completes successfully (success=true, last_updated=T4)
// At T5: Thread A completes with error (success=false, last_updated=T5) - overwrites B's success!

// Final state: Versions 100-110 marked as failed despite Thread B succeeding
// This corruption affects get_start_version_long() gap detection
```

## Notes

While this is a valid race condition in the codebase, its security impact is limited because:
1. The indexer is not part of blockchain consensus or transaction validation
2. It's a read-only service that can be disabled without affecting blockchain operation
3. The blockchain state itself remains correct; only the indexed view is affected
4. This represents a data quality issue in an auxiliary service rather than a core security vulnerability

The issue should be fixed to ensure data integrity, but it does not constitute a critical blockchain security vulnerability.

### Citations

**File:** crates/indexer/src/indexer/transaction_processor.rs (L146-165)
```rust
    fn apply_processor_status(&self, psms: &[ProcessorStatusModel]) {
        let mut conn = self.get_conn();
        let chunks = get_chunks(psms.len(), ProcessorStatusModel::field_count());
        for (start_ind, end_ind) in chunks {
            execute_with_better_error(
                &mut conn,
                diesel::insert_into(processor_statuses::table)
                    .values(&psms[start_ind..end_ind])
                    .on_conflict((dsl::name, dsl::version))
                    .do_update()
                    .set((
                        dsl::success.eq(excluded(dsl::success)),
                        dsl::details.eq(excluded(dsl::details)),
                        dsl::last_updated.eq(excluded(dsl::last_updated)),
                    )),
                None,
            )
            .expect("Error updating Processor Status!");
        }
    }
```

**File:** crates/indexer/src/indexer/tailer.rs (L177-189)
```rust
        execute_with_better_error(
            &mut conn,
            diesel::insert_into(processor_status::table)
                .values(&status)
                .on_conflict(processor_status::processor)
                .do_update()
                .set((
                    processor_status::last_success_version
                        .eq(excluded(processor_status::last_success_version)),
                    processor_status::last_updated.eq(excluded(processor_status::last_updated)),
                )),
            Some(" WHERE processor_status.last_success_version <= EXCLUDED.last_success_version "),
        )?;
```

**File:** crates/indexer/src/indexer/tailer.rs (L205-288)
```rust
    pub fn get_start_version_long(
        &self,
        processor_name: &String,
        lookback_versions: i64,
    ) -> Option<i64> {
        let mut conn = self
            .connection_pool
            .get()
            .expect("DB connection should be available to get starting version");

        // This query gets the first version that isn't equal to the next version (versions would be sorted of course).
        // There's also special handling if the gap happens in the beginning.
        let sql = "
        WITH raw_boundaries AS
        (
            SELECT
                MAX(version) AS MAX_V,
                MIN(version) AS MIN_V
            FROM
                processor_statuses
            WHERE
                name = $1
                AND success = TRUE
        ),
        boundaries AS
        (
            SELECT
                MAX(version) AS MAX_V,
                MIN(version) AS MIN_V
            FROM
                processor_statuses, raw_boundaries
            WHERE
                name = $1
                AND success = true
                and version >= GREATEST(MAX_V - $2, 0)
        ),
        gap AS
        (
            SELECT
                MIN(version) + 1 AS maybe_gap
            FROM
                (
                    SELECT
                        version,
                        LEAD(version) OVER (
                    ORDER BY
                        version ASC) AS next_version
                    FROM
                        processor_statuses,
                        boundaries
                    WHERE
                        name = $1
                        AND success = TRUE
                        AND version >= GREATEST(MAX_V - $2, 0)
                ) a
            WHERE
                version + 1 <> next_version
        )
        SELECT
            CASE
                WHEN
                    MIN_V <> GREATEST(MAX_V - $2, 0)
                THEN
                    GREATEST(MAX_V - $2, 0)
                ELSE
                    COALESCE(maybe_gap, MAX_V + 1)
            END
            AS version
        FROM
            gap, boundaries
        ";
        #[derive(Debug, QueryableByName)]
        pub struct Gap {
            #[diesel(sql_type = BigInt)]
            pub version: i64,
        }
        let mut res: Vec<Option<Gap>> = sql_query(sql)
            .bind::<Text, _>(processor_name)
            // This is the number used to determine how far we look back for gaps. Increasing it may result in slower startup
            .bind::<BigInt, _>(lookback_versions)
            .get_results(&mut conn)
            .unwrap();
        res.pop().unwrap().map(|g| g.version)
    }
```

**File:** crates/indexer/src/runtime.rs (L209-215)
```rust
    loop {
        let mut tasks = vec![];
        for _ in 0..processor_tasks {
            let other_tailer = tailer.clone();
            let task = tokio::spawn(async move { other_tailer.process_next_batch().await });
            tasks.push(task);
        }
```
