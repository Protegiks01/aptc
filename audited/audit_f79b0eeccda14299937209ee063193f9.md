# Audit Report

## Title
State Version Mismatch in CachedStateView Leads to Incorrect Usage Calculation and Potential Consensus Split

## Summary
The `CachedStateView::new_impl()` function creates a `StateDelta` from `state` and `persisted_state` parameters that may have inconsistent version relationships. The LayeredMap's `is_descendant_of()` check only validates layer number ordering, not actual parent-child lineage, allowing states from divergent execution branches to pass validation. This leads to incorrect cache baseline versions and wrong state storage usage calculations, potentially causing validators to compute different state roots. [1](#0-0) 

## Finding Description

The vulnerability occurs when `CachedStateView::new()` is called during block execution with a `state` parameter that was built on a different persisted snapshot than what `get_persisted_state()` currently returns. [2](#0-1) 

**Attack Scenario:**

1. **Parent Block Execution (T1):** Parent block executes based on persisted state at version 100 (layer 10), creating result state at version 110 (layer 12, with parent at layer 10).

2. **Concurrent Commit (T2):** Another execution path commits state at version 105 (layer 11, also built on v100 at layer 10) to the database, updating the persisted state.

3. **Child Block Execution (T3):** Child block calls `CachedStateView::new()` with parent's v110 state. The `get_persisted_state()` call returns the newly committed v105 state.

4. **Validation Bypass:** The `StateDelta::new()` creates a delta with current=v110 and base=v105. The `is_descendant_of()` check passes because it only validates layer numbers: [3](#0-2) 

The check evaluates: `v110.layer (12) >= v105.layer (11)` â†’ TRUE, even though v110 was never built on v105.

5. **Incorrect Delta Construction:** When `into_layers_view_after()` is called to create the LayeredMap view, the assertions pass: [4](#0-3) 

However, the `inner_maps()` function reveals the actual problem - it traverses the parent chain: [5](#0-4) 

Starting from layer 12 (v110) with base_layer at 11 (v105), it follows the parent link to layer 10 (v100), not layer 11, creating a view from layer 10 to 12 instead of 11 to 12. The speculative delta contains ALL updates from v100 to v110, not just v105 to v110, while reporting `base_version()` as v105.

6. **Cache Poisoning:** When state values are read through `get_unmemorized()`: [6](#0-5) 

Keys modified between v100 and v105 incorrectly appear in the speculative delta, returning values as of v110 when they should reflect the v105 baseline.

7. **Usage Calculation Error:** The cached values are then used in `State::update()` for usage calculation: [7](#0-6) 

The `expect_old_slot()` function retrieves values from the cache: [8](#0-7) 

Since the cache contains values computed with the wrong baseline (v100 instead of v105), the storage usage delta is calculated incorrectly.

## Impact Explanation

This vulnerability breaks the **Deterministic Execution** invariant - all validators must produce identical state roots for identical blocks. When different validators execute blocks with different timing relative to state commits, they may:

1. Create `CachedStateView` with different version pairings
2. Compute different state storage usage values
3. Produce different state roots for the same block
4. Cause a consensus split requiring manual intervention or hard fork

**Severity: Critical** - This meets the criteria for "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)" as it can cause validators to diverge on state computation without any malicious actor involvement.

## Likelihood Explanation

**High Likelihood** - This can occur naturally in production without any malicious behavior:

- Concurrent block execution is normal in validator operations
- State commits happen asynchronously via background threads (see `HotState::enqueue_commit`)
- The timing window exists between when a parent block completes execution and when a child block starts
- The vulnerability is triggered by legitimate concurrent operations, not by crafted attacks [9](#0-8) 

## Recommendation

**Fix 1: Strengthen the is_descendant_of check**

The `is_descendant_of()` method should verify actual parent-child lineage, not just layer number ordering. Add validation that traverses the parent chain:

```rust
pub fn is_descendant_of(&self, other: &Self) -> bool {
    if !self.is_family(other) {
        return false;
    }
    
    // Traverse parent chain to verify actual lineage
    let mut current = self.clone();
    while current.inner.layer > other.inner.layer {
        match current.parent() {
            Some(parent) => {
                if parent.inner.layer == other.inner.layer {
                    return parent.is_the_same(other);
                }
                current = parent;
            }
            None => return false,
        }
    }
    
    current.is_the_same(other)
}
```

**Fix 2: Validate state consistency in CachedStateView::new()**

Add validation that the `state` parameter is actually built on or after the persisted state:

```rust
pub fn new(id: StateViewId, reader: Arc<dyn DbReader>, state: State) -> StateViewResult<Self> {
    let (hot_state, persisted_state) = reader.get_persisted_state()?;
    
    // Ensure state is actually built on or after persisted_state
    ensure!(
        state.is_descendant_of(&persisted_state),
        "State must be a true descendant of persisted state"
    );
    
    Ok(Self::new_impl(id, reader, hot_state, persisted_state, state))
}
```

**Fix 3: Use consistent persisted snapshot**

Modify block execution to capture and pass the persisted snapshot explicitly, ensuring the same baseline is used throughout:

```rust
// In block_executor, capture persisted state when parent executes
let (persisted_hot, persisted_state) = reader.get_persisted_state()?;
// Pass this same persisted_state to child block execution
```

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[test]
fn test_version_mismatch_consensus_split() {
    // Setup: Initial persisted state at v100 (layer 10)
    let config = HotStateConfig::default();
    let persisted_v100 = State::new_at_version(Some(100), StateStorageUsage::zero(), config);
    
    // Scenario: Two execution paths from v100
    // Path A: Execute to v110 (layer 12)
    let state_v110 = execute_block_on_state(&persisted_v100, &transactions_a);
    
    // Path B: Execute to v105 (layer 11) and commit
    let state_v105 = execute_block_on_state(&persisted_v100, &transactions_b);
    commit_to_db(&state_v105); // Updates persisted state
    
    // Bug trigger: Create CachedStateView with v110 state
    // but get_persisted_state() now returns v105
    let view = CachedStateView::new(
        StateViewId::Miscellaneous,
        reader.clone(),
        state_v110,
    ).unwrap();
    
    // The view's base_version reports v105 but actually contains data from v100
    assert_eq!(view.base_version(), Some(105));
    
    // Read a key modified between v100 and v105
    let key_modified_at_v103 = StateKey::mock();
    let value = view.get_state_value(&key_modified_at_v103).unwrap();
    
    // BUG: Value reflects v110's view (includes v103 modification)
    // but base_version claims v105, causing incorrect usage calculation
    
    // Two validators executing with different timing will compute different
    // state roots due to different cached baselines
}
```

## Notes

The root cause is an insufficient validation in the LayeredMap's descendant check that allows states from divergent branches to be treated as if they have a linear parent-child relationship. This is exacerbated by the asynchronous state commit process in `PersistedState` where background threads update the persisted state while execution is ongoing.

The vulnerability requires no malicious behavior - it emerges naturally from concurrent operations in a production environment, making it particularly dangerous for consensus stability.

### Citations

**File:** storage/storage-interface/src/state_store/state_view/cached_state_view.rs (L126-135)
```rust
    pub fn new(id: StateViewId, reader: Arc<dyn DbReader>, state: State) -> StateViewResult<Self> {
        let (hot_state, persisted_state) = reader.get_persisted_state()?;
        Ok(Self::new_impl(
            id,
            reader,
            hot_state,
            persisted_state,
            state,
        ))
    }
```

**File:** storage/storage-interface/src/state_store/state_view/cached_state_view.rs (L137-163)
```rust
    pub fn new_impl(
        id: StateViewId,
        reader: Arc<dyn DbReader>,
        hot_state: Arc<dyn HotStateView>,
        persisted_state: State,
        state: State,
    ) -> Self {
        Self::new_with_config(id, reader, hot_state, persisted_state, state)
    }

    pub fn new_with_config(
        id: StateViewId,
        reader: Arc<dyn DbReader>,
        hot_state: Arc<dyn HotStateView>,
        persisted_state: State,
        state: State,
    ) -> Self {
        let version = state.version();

        Self {
            id,
            speculative: state.into_delta(persisted_state),
            hot: hot_state,
            cold: reader,
            memorized: ShardedStateCache::new_empty(version),
        }
    }
```

**File:** storage/storage-interface/src/state_store/state_view/cached_state_view.rs (L233-253)
```rust
    fn get_unmemorized(&self, state_key: &StateKey) -> Result<StateSlot> {
        COUNTER.inc_with(&["sv_unmemorized"]);

        let ret = if let Some(slot) = self.speculative.get_state_slot(state_key) {
            COUNTER.inc_with(&["sv_hit_speculative"]);
            slot
        } else if let Some(slot) = self.hot.get_state_slot(state_key) {
            COUNTER.inc_with(&["sv_hit_hot"]);
            slot
        } else if let Some(base_version) = self.base_version() {
            COUNTER.inc_with(&["sv_cold"]);
            StateSlot::from_db_get(
                self.cold
                    .get_state_value_with_version_by_version(state_key, base_version)?,
            )
        } else {
            StateSlot::ColdVacant
        };

        Ok(ret)
    }
```

**File:** experimental/storage/layered-map/src/layer.rs (L121-129)
```rust
    pub fn into_layers_view_after(self, base_layer: MapLayer<K, V>) -> LayeredMap<K, V> {
        assert!(base_layer.is_family(&self));
        assert!(base_layer.inner.layer >= self.inner.base_layer);
        assert!(base_layer.inner.layer <= self.inner.layer);

        self.log_layer("view");
        base_layer.log_layer("as_view_base");

        LayeredMap::new(base_layer, self)
```

**File:** experimental/storage/layered-map/src/layer.rs (L148-150)
```rust
    pub fn is_descendant_of(&self, other: &Self) -> bool {
        self.is_family(other) && self.inner.layer >= other.inner.layer
    }
```

**File:** experimental/storage/layered-map/src/map/mod.rs (L118-139)
```rust
    /// For example, if `self` is `(2, 5]`, this returns `(2, 3], (3, 4], (4, 5]` as a list.
    pub fn inner_maps(&self) -> Vec<Self> {
        let num_layers = (self.top_layer.layer() - self.base_layer.layer()) as usize;
        let mut ret = Vec::with_capacity(num_layers);

        let mut current = self.top_layer.clone();
        while current.layer() > self.base_layer.layer() {
            let parent = current.parent().expect("The lower layer must exist.");
            ret.push(Self::new(parent.clone(), current));
            current = parent;
        }
        ret.reverse();

        assert_eq!(
            ret.len(),
            num_layers,
            "The number of inner maps ({}) does not match num_layers ({})",
            ret.len(),
            num_layers
        );
        ret
    }
```

**File:** storage/storage-interface/src/state_store/state.rs (L340-368)
```rust
    fn usage_delta_for_shard<'kv>(
        cache: &StateCacheShard,
        overlay: &LayeredMap<StateKey, StateSlot>,
        updates: &HashMap<&'kv StateKey, StateUpdateRef<'kv>>,
    ) -> (i64, i64) {
        let mut items_delta: i64 = 0;
        let mut bytes_delta: i64 = 0;
        for (k, v) in updates {
            let state_value_opt = match v.state_op.as_state_value_opt() {
                Some(value_opt) => value_opt,
                None => continue,
            };

            let key_size = k.size();
            if let Some(value) = state_value_opt {
                items_delta += 1;
                bytes_delta += (key_size + value.size()) as i64;
            }

            // n.b. all updated state items must be read and recorded in the state cache,
            // otherwise we can't calculate the correct usage.
            let old_slot = Self::expect_old_slot(overlay, cache, k);
            if old_slot.is_occupied() {
                items_delta -= 1;
                bytes_delta -= (key_size + old_slot.size()) as i64;
            }
        }
        (items_delta, bytes_delta)
    }
```

**File:** storage/storage-interface/src/state_store/state.rs (L370-385)
```rust
    fn expect_old_slot(
        overlay: &LayeredMap<StateKey, StateSlot>,
        cache: &StateCacheShard,
        key: &StateKey,
    ) -> StateSlot {
        if let Some(slot) = overlay.get(key) {
            return slot;
        }

        // TODO(aldenhu): avoid cloning the state value (by not using DashMap)
        cache
            .get(key)
            .unwrap_or_else(|| panic!("Key {:?} must exist in the cache.", key))
            .value()
            .clone()
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L138-144)
```rust
    pub fn enqueue_commit(&self, to_commit: State) {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["hot_state_enqueue_commit"]);

        self.commit_tx
            .send(to_commit)
            .expect("Failed to queue for hot state commit.")
    }
```
