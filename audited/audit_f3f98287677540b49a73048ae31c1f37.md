# Audit Report

## Title
Batch Author Verification Bypass in OptQuorumStore Payload Availability Check

## Summary
The `check_payload_availability()` function in the quorum store payload manager fails to verify that the batch author claimed in a block payload matches the actual batch author stored in the batch store. A malicious block proposer can reference existing batch digests but falsely attribute them to different validators, causing incorrect batch authorship metadata to be accepted by all validators.

## Finding Description

The vulnerability exists in the `check_payload_availability()` method when processing `OptQuorumStore` payloads. The function calls `batch_reader.exists()` which returns `Option<PeerId>` containing the actual author of the batch, but only checks whether the result is `Some` or `None` without verifying that the returned author matches the claimed author in the payload. [1](#0-0) [2](#0-1) 

The correct implementation exists in `proof_coordinator.rs` where author verification is properly performed: [3](#0-2) 

**Attack Flow:**

1. Validator A creates and broadcasts a batch with digest D, author A, batch_id 100
2. All validators store this batch in their local batch stores
3. Malicious validator B (as block proposer) creates an `OptQuorumStorePayload` containing opt_batches with: `{author: C, batch_id: 999, digest: D, ...}` (falsely claiming validator C created the batch)
4. When validators receive this block:
   - `Payload::verify()` calls `verify_opt_batches()` which only checks that author C is a valid validator [4](#0-3) 
   - `check_payload_availability()` calls `exists(D)` which returns `Some(A)`, so the check passes (not `None`)
   - The code never compares the returned author A with the claimed author C
   - Block processing continues with incorrect authorship metadata
5. During transaction fetching, `process_optqs_payload()` retrieves transactions by digest D [5](#0-4) 
6. No digest re-verification occurs to confirm that `hash(author_C, transactions) == D`
7. Validator A's batch is included but attributed to validator C in all consensus metadata

**Key Missing Verification:**

Unlike inline batches which verify digest integrity [6](#0-5) , opt_batches undergo no such verification after transaction fetching in the main consensus path. The digest verification in the consensus observer is not part of the critical consensus validation path [7](#0-6) .

## Impact Explanation

**Severity: High** - This constitutes a significant protocol violation per Aptos bug bounty criteria.

While this vulnerability does not directly cause loss of funds or execution state inconsistencies (transactions are correctly fetched by digest), it enables:

1. **Batch Attribution Fraud**: Malicious proposers can systematically misattribute batches from honest validators to other validators, corrupting consensus metadata
2. **Reputation System Manipulation**: If future features implement reputation tracking based on batch quality or contribution metrics, this allows unfair attribution
3. **Monitoring and Metrics Corruption**: All batch-related metrics and telemetry become unreliable, hindering network health assessment
4. **Quota Enforcement Concerns**: While current quota enforcement happens at batch creation time, future per-validator quota mechanisms at the consensus level could be manipulated
5. **Protocol Integrity Violation**: This breaks the fundamental principle that batch authorship should be cryptographically verifiable and immutable

This qualifies as a "Significant protocol violation" under High severity criteria, as it undermines the integrity of the consensus metadata layer that validators rely upon for batch attribution.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Easy to Execute**: Any malicious block proposer can exploit this with minimal effortâ€”simply reference existing batch digests with falsified author fields
2. **No Detection Mechanism**: There is no validation or logging that would detect this misattribution
3. **Economic Incentive**: If reputation or future reward mechanisms depend on batch creation metrics, malicious validators have clear incentives to exploit this
4. **Silent Failure**: The attack leaves no trace and affects all validators uniformly, making detection nearly impossible
5. **Byzantine Fault Model**: The Aptos consensus operates under a BFT model where up to 1/3 of validators may be Byzantine, making malicious proposer behavior a realistic threat scenario

## Recommendation

Add author verification in `check_payload_availability()` to match the pattern used in `proof_coordinator.rs`:

```rust
Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
    let mut missing_authors = BitVec::with_num_bits(self.ordered_authors.len() as u16);
    for batch in p.opt_batches().deref() {
        match self.batch_reader.exists(batch.digest()) {
            None => {
                // Batch doesn't exist locally
                let index = *self
                    .address_to_validator_index
                    .get(&batch.author())
                    .expect("Payload author should have been verified");
                missing_authors.set(index as u16);
            },
            Some(actual_author) => {
                // Verify the claimed author matches the actual author
                if actual_author != batch.author() {
                    return Err(anyhow::anyhow!(
                        "Batch author mismatch: digest {:?} belongs to {:?} but payload claims {:?}",
                        batch.digest(),
                        actual_author,
                        batch.author()
                    ).into());
                }
            },
        }
    }
    if missing_authors.all_zeros() {
        Ok(())
    } else {
        Err(missing_authors)
    }
},
```

Additionally, consider adding digest re-verification after fetching transactions for opt_batches to ensure `BatchPayload::new(batch.author(), transactions).hash() == batch.digest()`.

## Proof of Concept

```rust
// Reproduction steps for consensus integration test:

// Step 1: Setup - Validator A creates a legitimate batch
let validator_a = validators[0];
let batch_a = create_batch(validator_a, transactions_set_1);
let digest_a = batch_a.digest();
broadcast_and_store_batch(&batch_a); // All validators store this

// Step 2: Malicious validator B creates a block with misattributed batch
let malicious_proposer_b = validators[1];
let innocent_validator_c = validators[2];

// Create OptQuorumStore payload with false attribution
let malicious_payload = OptQuorumStorePayload::V1(
    OptQuorumStorePayloadV1::new(
        /* opt_batches */ vec![
            BatchInfo::new(
                innocent_validator_c, // FALSE: claiming validator C created it
                BatchId::new(999),
                epoch,
                expiration,
                digest_a, // CORRECT: digest from validator A's batch
                num_txns,
                num_bytes,
                gas_bucket_start,
            )
        ],
        /* inline_batches */ InlineBatches::new(vec![]),
        /* proof_with_data */ ProofWithData::new(vec![]),
        /* max_txns */ None,
        /* block_gas_limit */ None,
    )
);

// Step 3: Validators process the block
let block = Block::new_proposal(
    malicious_payload,
    round,
    timestamp,
    quorum_cert,
    malicious_proposer_b,
);

// Step 4: Verify vulnerability - check passes despite wrong author
assert!(payload_manager.check_payload_availability(&block).is_ok());
// Expected: Should fail with author mismatch error
// Actual: Passes because exists(digest_a) returns Some(validator_a) but comparison is never performed

// Step 5: Observe incorrect attribution in consensus observer messages
let tx_payload = payload_manager.get_transactions(&block, None).await.unwrap();
let batch_infos = tx_payload.optqs_and_inline_batches();
assert_eq!(batch_infos[0].author(), innocent_validator_c); // WRONG!
// The batch is attributed to validator C instead of the true creator validator A
```

**Notes:**

This vulnerability requires a malicious validator to exploit, which is within the Byzantine fault tolerance threat model where up to 1/3 of validators may be adversarial. While the transactions themselves remain correct (ensuring deterministic execution), the metadata corruption undermines batch attribution integrity and could enable future attacks as the protocol evolves.

### Citations

**File:** consensus/src/quorum_store/batch_store.rs (L727-732)
```rust
    fn exists(&self, digest: &HashValue) -> Option<PeerId> {
        self.batch_store
            .get_batch_from_local(digest)
            .map(|v| v.author())
            .ok()
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L409-424)
```rust
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
                let mut missing_authors = BitVec::with_num_bits(self.ordered_authors.len() as u16);
                for batch in p.opt_batches().deref() {
                    if self.batch_reader.exists(batch.digest()).is_none() {
                        let index = *self
                            .address_to_validator_index
                            .get(&batch.author())
                            .expect("Payload author should have been verified");
                        missing_authors.set(index as u16);
                    }
                }
                if missing_authors.all_zeros() {
                    Ok(())
                } else {
                    Err(missing_authors)
                }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L601-637)
```rust
async fn process_optqs_payload<T: TDataInfo>(
    data_ptr: &BatchPointer<T>,
    batch_reader: Arc<dyn BatchReader>,
    block: &Block,
    ordered_authors: &[PeerId],
    additional_peers_to_request: Option<&BitVec>,
) -> ExecutorResult<Vec<SignedTransaction>> {
    let mut signers = Vec::new();
    if let Some(peers) = additional_peers_to_request {
        for i in peers.iter_ones() {
            if let Some(author) = ordered_authors.get(i) {
                signers.push(*author);
            }
        }
    }
    if let Some(author) = block.author() {
        signers.push(author);
    }

    let batches_and_responders = data_ptr
        .batch_summary
        .iter()
        .map(|summary| {
            let mut signers = signers.clone();
            signers.append(&mut summary.signers(ordered_authors));

            (summary.info().clone(), signers)
        })
        .collect();

    QuorumStorePayloadManager::request_and_wait_transactions(
        batches_and_responders,
        block.timestamp_usecs(),
        batch_reader,
    )
    .await
}
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L277-283)
```rust
        let batch_author = self
            .batch_reader
            .exists(signed_batch_info.digest())
            .ok_or(SignedBatchInfoError::NotFound)?;
        if batch_author != signed_batch_info.author() {
            return Err(SignedBatchInfoError::WrongAuthor);
        }
```

**File:** consensus/consensus-types/src/common.rs (L541-556)
```rust
    pub fn verify_inline_batches<'a, T: TBatchInfo + 'a>(
        inline_batches: impl Iterator<Item = (&'a T, &'a Vec<SignedTransaction>)>,
    ) -> anyhow::Result<()> {
        for (batch, payload) in inline_batches {
            // TODO: Can cloning be avoided here?
            let computed_digest = BatchPayload::new(batch.author(), payload.clone()).hash();
            ensure!(
                computed_digest == *batch.digest(),
                "Hash of the received inline batch doesn't match the digest value for batch {:?}: {} != {}",
                batch,
                computed_digest,
                batch.digest()
            );
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/common.rs (L558-572)
```rust
    pub fn verify_opt_batches<T: TBatchInfo>(
        verifier: &ValidatorVerifier,
        opt_batches: &OptBatches<T>,
    ) -> anyhow::Result<()> {
        let authors = verifier.address_to_validator_index();
        for batch in &opt_batches.batch_summary {
            ensure!(
                authors.contains_key(&batch.author()),
                "Invalid author {} for batch {}",
                batch.author(),
                batch.digest()
            );
        }
        Ok(())
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L1019-1038)
```rust
fn verify_batch(
    expected_batch_info: &BatchInfo,
    batch_transactions: Vec<SignedTransaction>,
) -> Result<(), Error> {
    // Calculate the batch digest
    let batch_payload = BatchPayload::new(expected_batch_info.author(), batch_transactions);
    let batch_digest = batch_payload.hash();

    // Verify the reconstructed digest against the expected digest
    let expected_digest = expected_batch_info.digest();
    if batch_digest != *expected_digest {
        return Err(Error::InvalidMessageError(format!(
            "The reconstructed batch digest does not match the expected digest! \
             Batch: {:?}, Expected digest: {:?}, Reconstructed digest: {:?}",
            expected_batch_info, expected_digest, batch_digest
        )));
    }

    Ok(())
}
```
