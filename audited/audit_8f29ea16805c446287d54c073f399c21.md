# Audit Report

## Title
Comment Injection Vulnerability in Gas Schedule Governance Proposal Generator Allows Code Injection into Move Scripts

## Summary
The `aptos-release-builder` tool's gas schedule proposal generation functions (`emit_full_gas_schedule` and `emit_gas_schedule_diff`) embed gas parameter names directly into Move script comments without sanitization. When the tool loads gas schedules from external JSON files or URLs (via `GasScheduleLocator::LocalFile` or `GasScheduleLocator::RemoteFile`), malicious entry names containing newline characters and comment terminators can break out of comments and inject arbitrary Move code into generated governance proposal scripts. [1](#0-0) 

## Finding Description

The vulnerability exists in two locations where gas schedule entry names are embedded into Move comments without sanitization:

**Primary Vulnerable Function:** [2](#0-1) 

**Secondary Vulnerable Function:** [3](#0-2) 

The tool supports loading gas schedules from external sources: [4](#0-3) 

**Attack Path:**

1. Attacker creates a malicious `gas_schedule.json` file with crafted entry names:
```json
{
  "feature_version": 10,
  "entries": [
    ["legitimate_param", 100],
    ["malicious\n*/ use std::signer; let malicious_code = 1; /*", 200]
  ]
}
```

2. Attacker either:
   - Compromises a repository/server hosting gas schedule files
   - Social engineers a developer to use the malicious file
   - Exploits the `RemoteFile` locator with a compromised URL

3. Developer creates a release config referencing the malicious gas schedule: [5](#0-4) 

4. Developer runs: `aptos-release-builder generate-proposals --release-config config.yaml`

5. The tool fetches the malicious gas schedule and generates a Move script where the malicious entry name breaks out of the comment block, injecting executable Move code:

```move
// Full gas schedule
//   Feature version: 10
//   Parameters:
//     legitimate_param : 100
//     malicious
*/ use std::signer; let malicious_code = 1; /* : 200
```

6. If the developer doesn't carefully review the generated script and submits it as a governance proposal, the injected code could execute with framework signer privileges.

The vulnerability affects the proposal generation flow: [6](#0-5) 

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos Bug Bounty)

This vulnerability represents a significant protocol violation through code injection in governance proposal generation tooling. While it requires social engineering or supply chain compromise, the potential consequences are severe:

1. **Governance Integrity Violation**: Malicious code could be injected into governance proposals that execute with `@aptos_framework` signer privileges, potentially:
   - Modifying critical on-chain configurations
   - Manipulating validator sets
   - Altering gas schedules maliciously
   - Executing arbitrary framework operations

2. **Supply Chain Attack Vector**: The tool explicitly supports loading gas schedules from:
   - Local files (which could be in shared repositories)
   - Remote URLs (which could be compromised)
   - This creates a realistic attack surface for supply chain attacks

3. **Developer Trust Exploitation**: Developers expect the tool to generate safe Move code from structured data. The lack of input sanitization violates this expectation.

While this doesn't directly cause consensus violations or fund loss without human error in the review process, it represents a critical weakness in governance tooling that could lead to CRITICAL impact if exploited successfully.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The likelihood depends on several factors:

**Increasing Likelihood:**
- The tool is designed to accept external files and URLs
- Gas schedules are legitimate data that developers would reasonably fetch from external sources
- Supply chain attacks targeting build/deployment tools are increasingly common
- Developers may trust gas schedule files from "official" sources without deep inspection
- The generated Move scripts are complex, making malicious injections harder to spot in code review

**Decreasing Likelihood:**
- Requires compromising a trusted source or social engineering
- Generated proposals should undergo code review before submission
- Most developers would use the "current" gas schedule option rather than external files

However, given the trend of supply chain attacks and the explicit support for external data sources, this represents a realistic attack vector that should be mitigated.

## Recommendation

**Immediate Fix: Sanitize all gas parameter names before embedding them in comments**

Add input validation/sanitization in both vulnerable functions:

```rust
fn sanitize_for_comment(s: &str) -> String {
    s.replace('\n', " ")
     .replace('\r', " ")
     .replace("*/", "* /")
     .replace("/*", "/ *")
}

fn emit_full_gas_schedule(writer: &CodeWriter, gas_schedule: &GasScheduleV2) -> Result<()> {
    emitln!(writer, "// Full gas schedule");
    emitln!(writer, "//   Feature version: {}", gas_schedule.feature_version);
    emitln!(writer, "//   Parameters:");
    let max_len = gas_schedule
        .entries
        .iter()
        .fold(0, |acc, (name, _)| usize::max(acc, name.len()));
    for (name, val) in &gas_schedule.entries {
        let sanitized_name = sanitize_for_comment(name);  // ADD THIS
        let name_with_spaces = format!("{}{}", sanitized_name, " ".repeat(max_len - sanitized_name.len()));
        emitln!(writer, "//     {} : {}", name_with_spaces, val);
    }
    emitln!(writer);
    Ok(())
}
```

Apply the same fix to `emit_gas_schedule_diff` function.

**Additional Recommendations:**
1. Add validation when deserializing `GasScheduleV2` to reject entries with suspicious characters
2. Add warnings when loading gas schedules from external sources
3. Include checksums/signatures for gas schedule files to detect tampering
4. Add automated tests to detect comment injection attempts

## Proof of Concept

**Step 1: Create malicious gas schedule file** (`malicious_gas.json`):
```json
{
  "feature_version": 10,
  "entries": [
    ["instr.nop", 100],
    ["injected\n*/ use aptos_framework::aptos_account; let x = 1; /*", 999]
  ]
}
```

**Step 2: Create release config** (`release_config.yaml`):
```yaml
name: "Malicious Release"
remote_endpoint: null
proposals:
  - name: "Gas Schedule Update"
    metadata:
      title: "Update Gas Schedule"
      description: "Routine gas schedule update"
      source_code_url: "https://github.com/aptos-labs/aptos-core"
      discussion_url: "https://github.com/aptos-labs/aptos-core"
    execution_mode: MultiStep
    update_sequence:
      - Gas:
          old: null
          new: "malicious_gas.json"
```

**Step 3: Run the tool:**
```bash
cargo run --bin aptos-release-builder -- generate-proposals \
  --release-config release_config.yaml \
  --output-dir ./output
```

**Expected Result:** The generated Move script in `./output/` will contain:
```move
// Full gas schedule
//   Feature version: 10
//   Parameters:
//     instr.nop : 100
//     injected
*/ use aptos_framework::aptos_account; let x = 1; /* : 999
```

The comment is broken, and `use aptos_framework::aptos_account; let x = 1;` becomes executable code in the script, demonstrating successful code injection.

## Notes

While the originally mentioned function in `aptos-gas-schedule-updator/src/lib.rs` contains the same vulnerable pattern, it only processes hardcoded gas parameters and is not directly exploitable. The exploitable vulnerability exists in the `aptos-release-builder` tool which accepts external gas schedule data.

The vulnerability violates the **Governance Integrity** invariant and represents a supply chain security risk in critical governance tooling. Even though it requires social engineering or repository compromise, the explicit support for external data sources and the potential for CRITICAL impact if exploited warrants immediate remediation.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/gas.rs (L12-57)
```rust
fn emit_gas_schedule_diff(
    writer: &CodeWriter,
    old_gas_schedule: &GasScheduleV2,
    new_gas_schedule: &GasScheduleV2,
) -> Result<()> {
    emitln!(writer, "// Changes");
    if old_gas_schedule.feature_version != new_gas_schedule.feature_version {
        emitln!(
            writer,
            "//   Feature version: {} -> {}",
            old_gas_schedule.feature_version,
            new_gas_schedule.feature_version
        );
    }
    let changes = GasScheduleV2::diff(old_gas_schedule, new_gas_schedule);
    if !changes.is_empty() {
        let max_len = changes
            .iter()
            .fold(0, |acc, (name, _)| usize::max(acc, name.len()));

        emitln!(writer, "//   Parameters");
        for (param_name, delta) in &changes {
            let name_with_spaces =
                format!("{}{}", param_name, " ".repeat(max_len - param_name.len()));
            match delta {
                DiffItem::Add { new_val } => {
                    emitln!(writer, "//      +  {} :  {}", name_with_spaces, new_val);
                },
                DiffItem::Delete { old_val } => {
                    emitln!(writer, "//      -  {} :  {}", name_with_spaces, old_val);
                },
                DiffItem::Modify { old_val, new_val } => {
                    emitln!(
                        writer,
                        "//         {} :  {} -> {}",
                        name_with_spaces,
                        old_val,
                        new_val
                    );
                },
            }
        }
    }

    Ok(())
}
```

**File:** aptos-move/aptos-release-builder/src/components/gas.rs (L59-78)
```rust
fn emit_full_gas_schedule(writer: &CodeWriter, gas_schedule: &GasScheduleV2) -> Result<()> {
    emitln!(writer, "// Full gas schedule");
    emitln!(
        writer,
        "//   Feature version: {}",
        gas_schedule.feature_version
    );
    emitln!(writer, "//   Parameters:");
    let max_len = gas_schedule
        .entries
        .iter()
        .fold(0, |acc, (name, _)| usize::max(acc, name.len()));
    for (name, val) in &gas_schedule.entries {
        let name_with_spaces = format!("{}{}", name, " ".repeat(max_len - name.len()));
        emitln!(writer, "//     {} : {}", name_with_spaces, val);
    }
    emitln!(writer);

    Ok(())
}
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L132-147)
```rust
pub enum ReleaseEntry {
    Framework(FrameworkReleaseConfig),
    Gas {
        old: Option<GasScheduleLocator>,
        new: GasScheduleLocator,
    },
    Version(AptosVersion),
    FeatureFlag(Features),
    Consensus(OnChainConsensusConfig),
    Execution(OnChainExecutionConfig),
    RawScript(PathBuf),
    /// Deprecated by `OnChainJwkConsensusConfig`.
    OidcProviderOps(Vec<OidcProviderOp>),
    JwkConsensus(OnChainJWKConsensusConfig),
    Randomness(ReleaseFriendlyRandomnessConfig),
}
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L196-214)
```rust
impl GasScheduleLocator {
    async fn fetch_gas_schedule(&self) -> Result<GasScheduleV2> {
        println!("{:?}", self);
        match self {
            GasScheduleLocator::LocalFile(path) => {
                let file_contents = fs::read_to_string(path)?;
                let gas_schedule: GasScheduleV2 = serde_json::from_str(&file_contents)?;
                Ok(gas_schedule)
            },
            GasScheduleLocator::RemoteFile(url) => {
                let response = reqwest::get(url.as_str()).await?;
                let gas_schedule: GasScheduleV2 = response.json().await?;
                Ok(gas_schedule)
            },
            GasScheduleLocator::Current => Ok(aptos_gas_schedule_updator::current_gas_schedule(
                LATEST_GAS_FEATURE_VERSION,
            )),
        }
    }
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L244-290)
```rust
            ReleaseEntry::Gas { old, new } => {
                let new_gas_schedule = new
                    .fetch_gas_schedule()
                    .await
                    .map_err(|err| anyhow!("Failed to fetch new gas schedule: {}", err))?;
                let old_gas_schedule = match old {
                    Some(old) => Some(
                        old.fetch_gas_schedule()
                            .await
                            .map_err(|err| anyhow!("Failed to fetch old gas schedule: {}", err))?,
                    ),
                    None => {
                        match client {
                            Some(_client) => {
                                // We could return `Some(fetch_config::<GasScheduleV2>(client)?)`,
                                // but this makes certain test scenarios flaky, so just return
                                // None here
                                None
                            },
                            None => {
                                println!("!!! WARNING !!!");
                                println!("Generating gas schedule upgrade without a base for comparison.");
                                println!("It is strongly recommended you specify an old gas schedule or a remote end point where it can be fetched.");
                                println!("!!! WARNING !!!");
                                None
                            },
                        }
                    },
                };

                if old_gas_schedule
                    .as_ref()
                    .map(|old| old != &new_gas_schedule)
                    .unwrap_or(true)
                {
                    result.append(&mut gas::generate_gas_upgrade_proposal(
                        old_gas_schedule.as_ref(),
                        &new_gas_schedule,
                        is_testnet,
                        if is_multi_step {
                            get_execution_hash(result)
                        } else {
                            None
                        },
                        is_multi_step,
                    )?);
                }
```
