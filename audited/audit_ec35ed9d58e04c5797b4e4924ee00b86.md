# Audit Report

## Title
Unvalidated Root Key in Genesis Allows Permanent Loss of Administrative Capabilities on Test Networks

## Summary
The `GenesisInfo::new()` function accepts an `Ed25519PublicKey` as the `root_key` parameter without validating its cryptographic correctness. An invalid or zero key can be provided, which will successfully complete genesis but permanently lock the `@core_resources` account's mint capabilities, as no valid signature can be produced to perform administrative operations post-genesis.

## Finding Description

The vulnerability exists in the genesis initialization flow for test networks (`is_test = true`). When `GenesisInfo::new()` is called, it accepts an `Ed25519PublicKey` as the `root_key` parameter without any validation: [1](#0-0) 

The `root_key` can originate from a deserialized layout configuration file, where `Ed25519PublicKey` is deserialized via the `TryFrom<&[u8]>` trait: [2](#0-1) [3](#0-2) 

The critical issue is that `Ed25519PublicKey::try_from()` explicitly does NOT validate the public key for cryptographic correctness: [4](#0-3) 

The implementation calls `from_bytes_unchecked()` which only checks if the bytes represent a valid curve point, but NOT whether the point is in a small subgroup or is cryptographically weak: [5](#0-4) 

During genesis, this unvalidated key is converted to an `AuthenticationKey` via simple SHA3-256 hashing, without any validation: [6](#0-5) [7](#0-6) 

The authentication key is then used to initialize the `@core_resources` account during genesis: [8](#0-7) [9](#0-8) 

The `@core_resources` account receives critical capabilities including `MintCapStore` with unlimited minting power: [10](#0-9) 

**The Attack Path:**
1. An operator creates a genesis layout YAML file with an invalid `Ed25519PublicKey` (e.g., 32 zero bytes, or a small subgroup point)
2. The key is deserialized without validation via `Ed25519PublicKey::try_from()`
3. Genesis completes successfully, creating the `@core_resources` account with an authentication key derived from the invalid public key
4. The account holds `MintCapStore` and maximum APT balance
5. Post-genesis, no one can sign valid transactions as `@core_resources` because the corresponding private key either doesn't exist or cannot produce valid Ed25519 signatures
6. Authentication key rotation requires a valid signature from the current key, which is impossible: [11](#0-10) 

7. Administrative operations like `mint()` and `delegate_mint_capability()` are permanently inaccessible: [12](#0-11) [13](#0-12) 

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty classification)

This vulnerability causes permanent loss of administrative capabilities on test networks:

- **Permanent DoS of Mint Capabilities**: The `@core_resources` account holds unlimited minting capabilities but becomes permanently inaccessible
- **Network Restart Required**: Recovery requires a complete network restart with new genesis, losing all historical state
- **Testing Infrastructure Impact**: Breaks test network functionality, preventing proper testing of mainnet deployments
- **Governance Impact**: Affects ability to test governance proposals and administrative operations

While this only affects test networks (not production mainnet, which uses `encode_aptos_mainnet_genesis_transaction` without the root_key parameter), test networks are critical infrastructure for:
- Pre-production testing
- Developer testnets
- Integration testing environments
- Validator testing

The impact qualifies as "Significant protocol violations" under HIGH severity, as it breaks the fundamental assumption that administrative accounts remain accessible for their intended purpose.

## Likelihood Explanation

**Likelihood: MEDIUM**

This vulnerability can occur through:

1. **Operational Error**: Typo or corruption in genesis configuration file (accidental)
2. **Configuration Management**: Using default/placeholder values during setup
3. **Supply Chain Attack**: Malicious modification of genesis configuration during distribution
4. **Testing Mistakes**: Using test vectors or invalid keys copied from documentation

The likelihood is MEDIUM because:
- Genesis configuration is typically created by trusted operators (reduces likelihood)
- But the configuration may pass through multiple hands and systems (increases likelihood)
- No validation exists to catch the error before permanent damage occurs
- The error is not immediately obvious (genesis succeeds, problems appear later)

## Recommendation

Add explicit validation of the `root_key` in `GenesisInfo::new()`:

```rust
pub fn new(
    chain_id: ChainId,
    root_key: Ed25519PublicKey,
    configs: Vec<ValidatorConfiguration>,
    framework: ReleaseBundle,
    genesis_config: &GenesisConfiguration,
) -> anyhow::Result<GenesisInfo> {
    // Validate root_key if this is a test genesis
    if genesis_config.is_test {
        // Attempt to verify the key is cryptographically valid
        // by checking it can be used for signature verification
        validate_ed25519_public_key(&root_key)?;
    }
    
    let mut validators = Vec::new();
    for config in configs {
        validators.push(config.try_into()?)
    }

    Ok(GenesisInfo { /* ... */ })
}

fn validate_ed25519_public_key(key: &Ed25519PublicKey) -> anyhow::Result<()> {
    // Check that the key bytes are not all zeros
    let key_bytes = key.to_bytes();
    if key_bytes.iter().all(|&b| b == 0) {
        anyhow::bail!("Root key cannot be all zeros");
    }
    
    // Check the point is not in a small subgroup
    use curve25519_dalek::edwards::CompressedEdwardsY;
    let compressed = CompressedEdwardsY::from_slice(&key_bytes);
    if let Some(point) = compressed.decompress() {
        if point.is_small_order() {
            anyhow::bail!("Root key is in a small subgroup and is cryptographically weak");
        }
    } else {
        anyhow::bail!("Root key is not a valid Ed25519 point");
    }
    
    Ok(())
}
```

Additionally, consider adding validation at deserialization time by creating a validated wrapper type for genesis-critical keys.

## Proof of Concept

```rust
#[test]
fn test_genesis_with_invalid_root_key() {
    use aptos_crypto::ed25519::Ed25519PublicKey;
    use aptos_genesis::{GenesisInfo, builder::GenesisConfiguration};
    use aptos_types::chain_id::ChainId;
    use aptos_framework::ReleaseBundle;
    
    // Create an invalid Ed25519PublicKey with all zeros
    let invalid_key_bytes = [0u8; 32];
    let invalid_root_key = Ed25519PublicKey::try_from(&invalid_key_bytes[..])
        .expect("Zero bytes should be accepted without validation");
    
    // Attempt to create GenesisInfo with the invalid key
    let genesis_config = GenesisConfiguration {
        is_test: true,
        // ... other config fields
    };
    
    let result = GenesisInfo::new(
        ChainId::test(),
        invalid_root_key,
        vec![],
        ReleaseBundle::default(),
        &genesis_config,
    );
    
    // Currently this succeeds (vulnerability)
    assert!(result.is_ok(), "Invalid key was accepted");
    
    // After fix, this should fail with validation error
    // assert!(result.is_err(), "Invalid key should be rejected");
}

#[test]
fn test_small_subgroup_key_accepted() {
    // Test with a known small-order point (identity point)
    let identity_point_bytes = [
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    
    let weak_key = Ed25519PublicKey::try_from(&identity_point_bytes[..])
        .expect("Small subgroup point accepted without validation");
    
    // This key cannot be used to create valid signatures
    // but it will be accepted during genesis
}
```

**Notes:**

- This vulnerability only affects test networks where `is_test = true`
- Mainnet genesis uses a different code path that doesn't involve the `root_key` parameter
- The vulnerability breaks the invariant that "Access Control: System addresses (@core_resources) must be protected" - the account exists but becomes permanently inaccessible
- Recovery requires complete network restart, making this a significant operational issue for test infrastructure

### Citations

**File:** crates/aptos-genesis/src/lib.rs (L86-125)
```rust
    pub fn new(
        chain_id: ChainId,
        root_key: Ed25519PublicKey,
        configs: Vec<ValidatorConfiguration>,
        framework: ReleaseBundle,
        genesis_config: &GenesisConfiguration,
    ) -> anyhow::Result<GenesisInfo> {
        let mut validators = Vec::new();

        for config in configs {
            validators.push(config.try_into()?)
        }

        Ok(GenesisInfo {
            chain_id,
            root_key,
            validators,
            framework,
            genesis: None,
            allow_new_validators: genesis_config.allow_new_validators,
            epoch_duration_secs: genesis_config.epoch_duration_secs,
            is_test: genesis_config.is_test,
            min_stake: genesis_config.min_stake,
            min_voting_threshold: genesis_config.min_voting_threshold,
            max_stake: genesis_config.max_stake,
            recurring_lockup_duration_secs: genesis_config.recurring_lockup_duration_secs,
            required_proposer_stake: genesis_config.required_proposer_stake,
            rewards_apy_percentage: genesis_config.rewards_apy_percentage,
            voting_duration_secs: genesis_config.voting_duration_secs,
            voting_power_increase_limit: genesis_config.voting_power_increase_limit,
            consensus_config: genesis_config.consensus_config.clone(),
            execution_config: genesis_config.execution_config.clone(),
            gas_schedule: genesis_config.gas_schedule.clone(),
            initial_features_override: genesis_config.initial_features_override.clone(),
            randomness_config_override: genesis_config.randomness_config_override.clone(),
            jwk_consensus_config_override: genesis_config.jwk_consensus_config_override.clone(),
            initial_jwks: genesis_config.initial_jwks.clone(),
            keyless_groth16_vk: genesis_config.keyless_groth16_vk.clone(),
        })
    }
```

**File:** crates/aptos-genesis/src/config.rs (L30-33)
```rust
pub struct Layout {
    /// Root key for the blockchain only for test chains
    #[serde(default)]
    pub root_key: Option<Ed25519PublicKey>,
```

**File:** crates/aptos/src/genesis/mod.rs (L283-287)
```rust
    Ok(GenesisInfo::new(
        layout.chain_id,
        layout.root_key.unwrap(),
        validators,
        framework,
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L100-111)
```rust
    /// Deserialize an Ed25519PublicKey without any validation checks apart from expected key size
    /// and valid curve point, although not necessarily in the prime-order subgroup.
    ///
    /// This function does NOT check the public key for membership in a small subgroup.
    pub(crate) fn from_bytes_unchecked(
        bytes: &[u8],
    ) -> std::result::Result<Ed25519PublicKey, CryptoMaterialError> {
        match ed25519_dalek::PublicKey::from_bytes(bytes) {
            Ok(dalek_public_key) => Ok(Ed25519PublicKey(dalek_public_key)),
            Err(_) => Err(CryptoMaterialError::DeserializationError),
        }
    }
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L295-305)
```rust
impl TryFrom<&[u8]> for Ed25519PublicKey {
    type Error = CryptoMaterialError;

    /// Deserialize an Ed25519PublicKey. This method will NOT check for key validity, which means
    /// the returned public key could be in a small subgroup. Nonetheless, our signature
    /// verification implicitly checks if the public key lies in a small subgroup, so canonical
    /// uses of this library will not be susceptible to small subgroup attacks.
    fn try_from(bytes: &[u8]) -> std::result::Result<Ed25519PublicKey, CryptoMaterialError> {
        Ed25519PublicKey::from_bytes_unchecked(bytes)
    }
}
```

**File:** types/src/transaction/authenticator.rs (L884-887)
```rust
    pub fn from_preimage(mut public_key_bytes: Vec<u8>, scheme: Scheme) -> AuthenticationKey {
        public_key_bytes.push(scheme as u8);
        AuthenticationKey::new(*HashValue::sha3_256_of(&public_key_bytes).as_ref())
    }
```

**File:** types/src/transaction/authenticator.rs (L914-916)
```rust
    pub fn ed25519(public_key: &Ed25519PublicKey) -> AuthenticationKey {
        Self::from_preimage(public_key.to_bytes().to_vec(), Scheme::Ed25519)
    }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L864-883)
```rust
fn initialize_core_resources_and_aptos_coin(
    session: &mut SessionExt<impl AptosMoveResolver>,
    module_storage: &impl AptosModuleStorage,
    traversal_context: &mut TraversalContext,
    core_resources_key: &Ed25519PublicKey,
) {
    let core_resources_auth_key = AuthenticationKey::ed25519(core_resources_key);
    exec_function(
        session,
        module_storage,
        traversal_context,
        GENESIS_MODULE_NAME,
        "initialize_core_resources_and_aptos_coin",
        vec![],
        serialize_values(&vec![
            MoveValue::Signer(CORE_CODE_ADDRESS),
            MoveValue::vector_u8(core_resources_auth_key.to_vec()),
        ]),
    );
}
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L153-173)
```text
    fun initialize_core_resources_and_aptos_coin(
        aptos_framework: &signer,
        core_resources_auth_key: vector<u8>,
    ) {
        let (burn_cap, mint_cap) = aptos_coin::initialize(aptos_framework);

        coin::create_coin_conversion_map(aptos_framework);
        coin::create_pairing<AptosCoin>(aptos_framework);

        // Give stake module MintCapability<AptosCoin> so it can mint rewards.
        stake::store_aptos_coin_mint_cap(aptos_framework, mint_cap);
        // Give transaction_fee module BurnCapability<AptosCoin> so it can burn gas.
        transaction_fee::store_aptos_coin_burn_cap(aptos_framework, burn_cap);
        // Give transaction_fee module MintCapability<AptosCoin> so it can mint refunds.
        transaction_fee::store_aptos_coin_mint_cap(aptos_framework, mint_cap);

        let core_resources = account::create_account(@core_resources);
        account::rotate_authentication_key_internal(&core_resources, core_resources_auth_key);
        aptos_account::register_apt(&core_resources); // registers APT store
        aptos_coin::configure_accounts_for_test(aptos_framework, &core_resources, mint_cap);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L73-89)
```text
    public(friend) fun configure_accounts_for_test(
        aptos_framework: &signer,
        core_resources: &signer,
        mint_cap: MintCapability<AptosCoin>,
    ) {
        system_addresses::assert_aptos_framework(aptos_framework);

        // Mint the core resource account AptosCoin for gas so it can execute system transactions.
        let coins = coin::mint<AptosCoin>(
            18446744073709551615,
            &mint_cap,
        );
        coin::deposit<AptosCoin>(signer::address_of(core_resources), coins);

        move_to(core_resources, MintCapStore { mint_cap });
        move_to(core_resources, Delegations { inner: vector::empty() });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L93-108)
```text
    public entry fun mint(
        account: &signer,
        dst_addr: address,
        amount: u64,
    ) acquires MintCapStore {
        let account_addr = signer::address_of(account);

        assert!(
            exists<MintCapStore>(account_addr),
            error::not_found(ENO_CAPABILITIES),
        );

        let mint_cap = &borrow_global<MintCapStore>(account_addr).mint_cap;
        let coins_minted = coin::mint<AptosCoin>(amount, mint_cap);
        coin::deposit<AptosCoin>(dst_addr, coins_minted);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L112-120)
```text
    public entry fun delegate_mint_capability(account: signer, to: address) acquires Delegations {
        system_addresses::assert_core_resource(&account);
        let delegations = &mut borrow_global_mut<Delegations>(@core_resources).inner;
        vector::for_each_ref(delegations, |element| {
            let element: &DelegatedMintCapability = element;
            assert!(element.to != to, error::invalid_argument(EALREADY_DELEGATED));
        });
        vector::push_back(delegations, DelegatedMintCapability { to });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L604-625)
```text
    public entry fun rotate_authentication_key(
        account: &signer,
        from_scheme: u8,
        from_public_key_bytes: vector<u8>,
        to_scheme: u8,
        to_public_key_bytes: vector<u8>,
        cap_rotate_key: vector<u8>,
        cap_update_table: vector<u8>,
    ) acquires Account, OriginatingAddress {
        let addr = signer::address_of(account);
        ensure_resource_exists(addr);
        check_rotation_permission(account);
        let account_resource = &mut Account[addr];
        let old_auth_key = account_resource.authentication_key;
        // Verify the given `from_public_key_bytes` matches this account's current authentication key.
        if (from_scheme == ED25519_SCHEME) {
            let from_pk = ed25519::new_unvalidated_public_key_from_bytes(from_public_key_bytes);
            let from_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
            assert!(
                account_resource.authentication_key == from_auth_key,
                error::unauthenticated(EWRONG_CURRENT_PUBLIC_KEY)
            );
```
