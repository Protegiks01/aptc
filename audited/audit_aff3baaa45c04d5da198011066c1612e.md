# Audit Report

## Title
Memory Exhaustion DoS in Aptos Rosetta API Through Unbounded Address String Length

## Summary
The Aptos Rosetta API does not enforce content length limits on incoming JSON requests, allowing attackers to send arbitrarily long address strings that cause memory exhaustion. While the underlying `AccountAddress::from_str()` validation will eventually reject invalid addresses, the deserialization process allocates memory proportional to the input string length before any validation occurs.

## Finding Description

The vulnerability exists in the Aptos Rosetta API's request handling flow. All Rosetta endpoints use `warp::body::json()` without applying `warp::body::content_length_limit()`, allowing unbounded request sizes. [1](#0-0) 

The `AccountIdentifier` struct contains a `String` field for addresses that gets deserialized from incoming JSON: [2](#0-1) 

When an attacker sends a request with an extremely long address string (e.g., `{"address": "0x" + "a" * 10000000}`), the following occurs:

1. **Deserialization**: Serde allocates a `String` containing the entire address value (10MB+)
2. **Memory Allocation**: This happens BEFORE any validation in `account_address()`
3. **Late Validation**: Only after memory allocation does the code call `str_to_account_address()`: [3](#0-2) [4](#0-3) 

The underlying `AccountAddress::from_str()` will eventually reject addresses longer than 64 hex characters, but this validation occurs post-allocation: [5](#0-4) 

**Configuration Gap**: While the Rosetta service accepts a `content_length_limit` command-line argument, it is never enforced: [6](#0-5) 

The `WebServer::from(ApiConfig)` conversion drops this configuration: [7](#0-6) 

The same issue affects multiple endpoints accepting `AccountIdentifier` fields including `/construction/preprocess`, `/construction/payloads`, and others. [8](#0-7) 

## Impact Explanation

**Severity: Medium to High**

This qualifies as **High Severity** per Aptos bug bounty criteria: "API crashes, Validator node slowdowns."

While the Rosetta API is not part of critical consensus infrastructure, this vulnerability enables:

1. **Service Disruption**: Multiple concurrent requests with 10MB+ address strings can exhaust server memory
2. **Resource Starvation**: Legitimate requests may be rejected or experience delays
3. **Complete Service Unavailability**: Sustained attacks can crash the Rosetta API process

The attack requires minimal resources (simple HTTP POST requests) and can impact all users of the Rosetta API service, which is commonly used by exchanges and blockchain explorers for Aptos integration.

## Likelihood Explanation

**Likelihood: High**

- **Ease of Exploitation**: Trivial - requires only HTTP POST capability
- **No Authentication**: Public endpoints accept requests from any source
- **Amplification**: Each malicious request can allocate 10-100MB of memory
- **Discovery**: Easy to identify through basic API testing
- **Prerequisites**: None - any network peer can exploit this

The vulnerability will be triggered whenever an attacker sends crafted JSON payloads to any Rosetta endpoint accepting `AccountIdentifier` fields.

## Recommendation

Apply `warp::body::content_length_limit()` to all Rosetta API routes. Follow the pattern used in the telemetry service: [9](#0-8) 

**Recommended Fix**:

1. Define a reasonable maximum content length (e.g., 1MB) in the Rosetta configuration
2. Apply `.and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))` before all `.and(warp::body::json())` calls
3. Ensure the `content_length_limit` from `ApiConfig` is actually used

Example fix for `/account/balance`:

```rust
// In account.rs
warp::path!("account" / "balance")
    .and(warp::body::content_length_limit(1024 * 1024)) // 1MB limit
    .and(warp::body::json())
    .and(with_context(server_context))
    .and_then(handle_request(account_balance))
```

Additionally, implement the content length enforcement in `WebServer` or pass the limit through route construction.

## Proof of Concept

```bash
# Generate a large JSON payload with 10MB address string
python3 -c "
import json
payload = {
    'network_identifier': {
        'blockchain': 'aptos',
        'network': 'testnet'
    },
    'account_identifier': {
        'address': '0x' + 'a' * 10000000  # 10MB address
    }
}
print(json.dumps(payload))
" > large_payload.json

# Send to Rosetta API (repeat multiple times concurrently)
for i in {1..10}; do
    curl -X POST http://localhost:8082/account/balance \
         -H "Content-Type: application/json" \
         -d @large_payload.json &
done

# Monitor server memory usage - should show rapid increase
# Eventually the server may crash or become unresponsive
```

**Rust Test Reproduction**:

```rust
#[tokio::test]
async fn test_memory_exhaustion_via_long_address() {
    let long_address = format!("0x{}", "a".repeat(10_000_000));
    let request = AccountBalanceRequest {
        network_identifier: NetworkIdentifier {
            blockchain: "aptos".to_string(),
            network: "testnet".to_string(),
        },
        account_identifier: AccountIdentifier {
            address: long_address,
            sub_account: None,
        },
        block_identifier: None,
        currencies: None,
    };
    
    // This should fail with payload too large, not succeed in allocation
    // Without content_length_limit, this allocates ~10MB
    let json = serde_json::to_string(&request).unwrap();
    assert!(json.len() > 9_000_000);
}
```

## Notes

The vulnerability affects all Rosetta API endpoints that accept `AccountIdentifier`, `SubAccountIdentifier`, or related structures in request bodies. The same pattern applies to `pool_address` fields in `SubAccountIdentifierMetadata`: [10](#0-9) 

While `AccountAddress::from_str()` provides eventual validation, the defense-in-depth principle requires rejecting oversized requests at the HTTP layer before deserialization. The current implementation violates the documented invariant: "Resource Limits: All operations must respect gas, storage, and computational limits."

### Citations

**File:** crates/aptos-rosetta/src/account.rs (L40-40)
```rust
            .and(warp::body::json())
```

**File:** crates/aptos-rosetta/src/types/identifiers.rs (L24-31)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct AccountIdentifier {
    /// Hex encoded AccountAddress beginning with 0x
    pub address: String,
    /// Sub account only used for staking
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sub_account: Option<SubAccountIdentifier>,
}
```

**File:** crates/aptos-rosetta/src/types/identifiers.rs (L35-37)
```rust
    pub fn account_address(&self) -> ApiResult<AccountAddress> {
        str_to_account_address(self.address.as_str())
    }
```

**File:** crates/aptos-rosetta/src/types/identifiers.rs (L219-222)
```rust
fn str_to_account_address(address: &str) -> Result<AccountAddress, ApiError> {
    AccountAddress::from_str(address)
        .map_err(|_| ApiError::InvalidInput(Some("Invalid account address".to_string())))
}
```

**File:** crates/aptos-rosetta/src/types/identifiers.rs (L397-401)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct SubAccountIdentifierMetadata {
    /// Hex encoded Pool beginning with 0x
    pub pool_address: String,
}
```

**File:** third_party/move/move-core/types/src/account_address.rs (L391-403)
```rust
    fn from_str(s: &str) -> Result<Self, AccountAddressParseError> {
        if !s.starts_with("0x") {
            if s.is_empty() {
                return Err(AccountAddressParseError::TooShort);
            }
            AccountAddress::from_hex_literal(&format!("0x{}", s))
        } else {
            if s.len() == 2 {
                return Err(AccountAddressParseError::TooShort);
            }
            AccountAddress::from_hex_literal(s)
        }
    }
```

**File:** crates/aptos-rosetta/src/main.rs (L183-184)
```rust
    #[clap(long)]
    content_length_limit: Option<u64>,
```

**File:** crates/aptos-warp-webserver/src/webserver.rs (L15-19)
```rust
impl From<ApiConfig> for WebServer {
    fn from(cfg: ApiConfig) -> Self {
        Self::new(cfg.address, cfg.tls_cert_path, cfg.tls_key_path)
    }
}
```

**File:** crates/aptos-rosetta/src/construction.rs (L62-62)
```rust
        .and(warp::body::json())
```

**File:** crates/aptos-telemetry-service/src/log_ingest.rs (L35-36)
```rust
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))
        .and(warp::body::aggregate())
```
