# Audit Report

## Title
Write Buffer Memory Bypass: VMChangeSet Serialization Bypasses Memory Quota Enforcement

## Summary
The `charge_io_gas_for_write()` function delegates directly to the base gas meter without charging memory quota for write operation buffers. This allows transactions to consume up to 2x the intended memory limit by allocating heap memory during execution (tracked) plus write buffer memory during serialization (untracked), enabling potential memory exhaustion attacks on validator nodes. [1](#0-0) 

## Finding Description
The memory quota system is designed to limit per-transaction memory consumption to 10 MB to prevent resource exhaustion. [2](#0-1) 

However, write operations bypass this protection through the following flow:

1. During transaction execution, Move VM operations charge heap memory via `use_heap_memory()` which enforces the quota limit. [3](#0-2) 

2. When writing resources via `move_to<T>()`, only a fixed base gas cost is charged, not memory quota. [4](#0-3) 

3. During session finalization, values are serialized into `Bytes` and accumulated in `VMChangeSet.resource_write_set`. [5](#0-4) 

4. These write buffers are stored in `BTreeMap<StateKey, AbstractResourceWriteOp>` where each operation contains `StateValue` with serialized bytes. [6](#0-5) 

5. When `charge_io_gas_for_write()` is called to charge for writes, it is delegated to the base gas meter WITHOUT calling `use_heap_memory()`. [7](#0-6) 

This creates a memory accounting gap where:
- Heap allocations during execution: up to 10 MB (tracked)
- Write buffer allocations during serialization: up to 10 MB (untracked) [8](#0-7) 
- **Total potential memory consumption: 20 MB per transaction**

The attack vector allows an adversary to:
1. Allocate 10 MB heap memory (vectors, nested structs) during execution
2. Create large resources (up to 1 MB each) and write via `move_to<T>()`
3. When `finish()` serializes these resources to bytes, both heap values and serialized bytes coexist
4. This bypasses the 10 MB memory quota, allowing 2x memory consumption

## Impact Explanation
**Medium Severity** - This vulnerability enables memory exhaustion attacks that can degrade validator node performance or cause crashes:

- **Resource Exhaustion**: Each transaction can consume 20 MB instead of the intended 10 MB limit
- **Amplification Factor**: 2x memory consumption per transaction
- **Node Impact**: Multiple concurrent transactions could exhaust node memory, leading to crashes or severe performance degradation
- **Scope**: Affects all validator nodes processing malicious transactions

While limited by the 10 MB write buffer cap and requiring gas payment, this still represents a significant violation of the resource limits invariant and could be used for targeted DoS attacks against the network.

## Likelihood Explanation
**High Likelihood** - This vulnerability is easily exploitable:

- **Attacker Requirements**: Only requires ability to submit transactions (no special privileges)
- **Complexity**: Low - straightforward to create large resources and vectors in Move
- **Cost**: Requires gas payment for both execution and writes, but the memory amplification provides asymmetric advantage
- **Detection**: Difficult to distinguish from legitimate large transactions
- **Mitigation**: No existing protection against this specific attack vector

The vulnerability is inherent in the delegation pattern where `charge_io_gas_for_write()` bypasses memory tracking, making it reliably exploitable by any attacker.

## Recommendation
Modify `charge_io_gas_for_write()` in the `MemoryTrackedGasMeterImpl` to charge memory quota for write buffer allocations instead of delegating directly to base:

```rust
fn charge_io_gas_for_write(&mut self, key: &StateKey, op: &WriteOpSize) -> VMResult<()> {
    // Charge memory quota for write buffer size
    if let Some(write_len) = op.write_len() {
        let total_size = write_len + (key.size() as u64);
        self.use_heap_memory(AbstractValueSize::new(total_size))
            .map_err(|e| e.finish(Location::Undefined))?;
    }
    
    // Delegate to base for IO gas charging
    self.base.charge_io_gas_for_write(key, op)
}
```

This ensures write buffer memory is tracked against the memory quota, preventing the 2x memory amplification attack while maintaining existing IO gas charging behavior.

## Proof of Concept

```move
module 0xCAFE::memory_attack {
    use std::vector;
    use std::signer;
    
    struct LargeResource has key {
        data: vector<u8>
    }
    
    /// Attack: Consume 20 MB total memory (10 MB heap + 10 MB write buffer)
    public entry fun exploit_memory_gap(account: &signer) {
        // Step 1: Allocate 10 MB in vectors (counted toward memory quota)
        let temp_vector = vector::empty<u8>();
        let i = 0;
        while (i < 10_000_000) {
            vector::push_back(&mut temp_vector, 0u8);
            i = i + 1;
        };
        
        // Step 2: Create large resource for writing (serialization bypasses quota)
        let large_data = vector::empty<u8>();
        let j = 0;
        while (j < 10_000_000) {
            vector::push_back(&mut large_data, 0u8);
            j = j + 1;
        };
        
        let resource = LargeResource { data: large_data };
        
        // Step 3: Write resource - serialization creates 10 MB write buffer (untracked)
        move_to(account, resource);
        
        // At this point, both temp_vector (10 MB) and serialized resource (10 MB)
        // exist in memory, totaling 20 MB despite 10 MB quota
        
        // Clean up temp vector
        vector::destroy_empty(temp_vector);
    }
}
```

**Expected Result**: Transaction should fail with `MEMORY_LIMIT_EXCEEDED` when write buffer is created, but currently succeeds because write buffer memory is not tracked.

**Actual Result**: Transaction succeeds, consuming ~20 MB peak memory during serialization phase.

## Notes
The vulnerability specifically affects non-table write operations. Table operations through native functions DO properly charge memory quota via `use_heap_memory()` calls. [9](#0-8) 

The write size limits (`max_bytes_per_write_op` and `max_bytes_all_write_ops_per_transaction`) are enforced AFTER execution completes, not during the memory-critical serialization phase. [10](#0-9)

### Citations

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L48-63)
```rust
    fn use_heap_memory(&mut self, amount: AbstractValueSize) -> PartialVMResult<()> {
        if self.feature_version >= 3 {
            match self.remaining_memory_quota.checked_sub(amount) {
                Some(remaining_quota) => {
                    self.remaining_memory_quota = remaining_quota;
                    Ok(())
                },
                None => {
                    self.remaining_memory_quota = 0.into();
                    Err(PartialVMError::new(StatusCode::MEMORY_LIMIT_EXCEEDED))
                },
            }
        } else {
            Ok(())
        }
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L693-713)
```rust
    delegate_mut! {
        fn algebra_mut(&mut self) -> &mut Self::Algebra;

        fn charge_io_gas_for_transaction(&mut self, txn_size: NumBytes) -> VMResult<()>;

        fn charge_io_gas_for_event(&mut self, event: &ContractEvent) -> VMResult<()>;

        fn charge_io_gas_for_write(&mut self, key: &StateKey, op: &WriteOpSize) -> VMResult<()>;

        fn charge_storage_fee(
            &mut self,
            amount: Fee,
            gas_unit_price: FeePerGasUnit,
        ) -> PartialVMResult<()>;

        fn charge_intrinsic_gas_for_transaction(&mut self, txn_size: NumBytes) -> VMResult<()>;

        fn charge_keyless(&mut self) -> VMResult<()>;

        fn charge_slh_dsa_sha2_128s(&mut self) -> VMResult<()>;
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L142-142)
```rust
        [memory_quota: AbstractValueSize, { 1.. => "memory_quota" }, 10_000_000],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L159-162)
```rust
            max_bytes_all_write_ops_per_transaction: NumBytes,
            { 5.. => "max_bytes_all_write_ops_per_transaction" },
            10 << 20, // all write ops from a single transaction are 10MB max
        ],
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L470-481)
```rust
    fn charge_move_to(
        &mut self,
        is_generic: bool,
        _ty: impl TypeView,
        _val: impl ValueView,
        _is_success: bool,
    ) -> PartialVMResult<()> {
        match is_generic {
            false => self.algebra.charge_execution(MOVE_TO_BASE),
            true => self.algebra.charge_execution(MOVE_TO_GENERIC_BASE),
        }
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L212-214)
```rust
        let change_set = data_cache
            .into_custom_effects(&resource_converter)
            .map_err(|e| e.finish(Location::Undefined))?;
```

**File:** types/src/state_store/state_value.rs (L183-187)
```rust
pub struct StateValue {
    data: Bytes,
    metadata: StateValueMetadata,
    maybe_rapid_hash: Option<(u64, usize)>,
}
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L439-441)
```rust
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L86-128)
```rust
    pub fn check_change_set(&self, change_set: &impl ChangeSetInterface) -> Result<(), VMStatus> {
        let storage_write_limit_reached = |maybe_message: Option<&str>| {
            let mut err = PartialVMError::new(StatusCode::STORAGE_WRITE_LIMIT_REACHED);
            if let Some(message) = maybe_message {
                err = err.with_message(message.to_string())
            }
            Err(err.finish(Location::Undefined).into_vm_status())
        };

        if self.max_write_ops_per_transaction != 0
            && change_set.num_write_ops() as u64 > self.max_write_ops_per_transaction
        {
            return storage_write_limit_reached(Some("Too many write ops."));
        }

        let mut write_set_size = 0;
        for (key, op_size) in change_set.write_set_size_iter() {
            if let Some(len) = op_size.write_len() {
                let write_op_size = len + (key.size() as u64);
                if write_op_size > self.max_bytes_per_write_op {
                    return storage_write_limit_reached(None);
                }
                write_set_size += write_op_size;
            }
            if write_set_size > self.max_bytes_all_write_ops_per_transaction {
                return storage_write_limit_reached(None);
            }
        }

        let mut total_event_size = 0;
        for event in change_set.events_iter() {
            let size = event.event_data().len() as u64;
            if size > self.max_bytes_per_event {
                return storage_write_limit_reached(None);
            }
            total_event_size += size;
            if total_event_size > self.max_bytes_all_events_per_transaction {
                return storage_write_limit_reached(None);
            }
        }

        Ok(())
    }
```
