# Audit Report

## Title
Critical Edge Handling Vulnerability Causes False Negatives in Reference Safety Checks

## Summary
The `LiveVarAnalysisProcessor` has a documented prerequisite that the control flow graph (CFG) must not contain critical edges. However, the `SplitCriticalEdgesProcessor` that eliminates these edges is conditionally added based on the `SPLIT_CRITICAL_EDGES` experiment flag, which can be disabled by users. When disabled, liveness analysis runs on a CFG with critical edges, producing incorrect liveness information that causes reference safety checks to miss memory safety violations, potentially leading to consensus splits and runtime failures.

## Finding Description

The vulnerability exists in the interaction between three components in the Move compiler v2 bytecode checking pipeline:

1. **Critical Edge Splitting (Conditional)**: The `SplitCriticalEdgesProcessor` is only added if `options.experiment_on(Experiment::SPLIT_CRITICAL_EDGES)` returns true. [1](#0-0) 

2. **Liveness Analysis (Always Runs)**: The `LiveVarAnalysisProcessor` is unconditionally added at lines 518 and 523, but it explicitly documents: "This processor assumes that the CFG of the code has no critical edges." [2](#0-1) 

3. **Reference Safety Dependency**: The reference safety processor depends critically on liveness information to make safety decisions. [3](#0-2) 

**The Attack Path:**

A user can disable the `SPLIT_CRITICAL_EDGES` experiment via:
- Command line: `--experiment split-critical-edges=off`
- Environment variable: `MVC_EXP=split-critical-edges=off`  
- Programmatically via `set_experiment()` [4](#0-3) 

When disabled, the liveness analysis runs with critical edges present in the CFG. The algorithm has special handling for branch instructions that assumes no critical edges exist: [5](#0-4) 

This can produce **false negatives** in liveness informationâ€”incorrectly reporting that variables are NOT live when they actually ARE.

**Critical Dependencies on Liveness:**

The reference safety processor uses liveness information in two critical locations:

1. **Premature Reference Release**: References are released from the borrow graph if liveness analysis says they're not alive: [6](#0-5) 

2. **Move vs Copy Decision**: When assignment kind is inferred, the decision between move and copy semantics depends on liveness: [7](#0-6) 

If liveness analysis incorrectly reports a reference as NOT live, the compiler will:
- Prematurely release it from the borrow graph tracking
- Incorrectly treat assignments as moves instead of copies
- Miss subsequent reference safety violations

Match expressions (new in Move v2) are specifically documented as the primary source of critical edges: [8](#0-7) 

## Impact Explanation

**Severity: CRITICAL**

This vulnerability breaks multiple critical invariants:

1. **Deterministic Execution Violation**: Different validators compiling with different compiler flags will produce different bytecode that behaves differently, causing state root divergence and consensus splits.

2. **Move VM Safety Violation**: Memory-unsafe Move code can pass compilation and be deployed on-chain, potentially causing:
   - Use-after-free errors
   - Dangling reference access
   - Violation of Rust/Move memory safety guarantees
   - Runtime crashes or undefined behavior

3. **Consensus Safety Impact**: If different validators use different compiler configurations:
   - They will accept/reject different transaction sets
   - State transitions will diverge
   - Network will fork without Byzantine fault

The impact qualifies as **Critical Severity** under Aptos Bug Bounty criteria:
- **Consensus/Safety violations**: Allows consensus splits
- **Move VM Safety**: Breaks memory safety guarantees
- **Non-recoverable network partition**: Could require hard fork to resolve divergent state

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

While `SPLIT_CRITICAL_EDGES` defaults to `true`, several factors increase exploitability:

1. **User Control**: Any user can disable the experiment when compiling their own modules
2. **No Validation**: There's no check ensuring critical dependencies are met
3. **Silent Failure**: The liveness analysis doesn't verify its prerequisites
4. **Match Expressions**: New Move v2 match expressions specifically create critical edges
5. **Testing Scenarios**: Test frameworks actively use `exp_off()` to disable experiments

The attack doesn't require:
- Validator access
- Network manipulation
- Cryptographic breaks
- Only requires: compiling Move code with a flag disabled

## Recommendation

**Immediate Fix**: Make `SplitCriticalEdgesProcessor` mandatory when `LiveVarAnalysisProcessor` is used:

```rust
pub fn stackless_bytecode_check_pipeline(options: &Options) -> FunctionTargetPipeline {
    let mut pipeline = FunctionTargetPipeline::default();

    // MANDATORY: Many passes require the absence of critical edges.
    // This is not optional and cannot be disabled.
    pipeline.add_processor(Box::new(SplitCriticalEdgesProcessor {}));

    // ... rest of pipeline
```

**Better Fix**: Add validation in `LiveVarAnalysisProcessor::process()`:

```rust
fn process(&self, ...) -> FunctionData {
    if fun_env.is_native() {
        return data;
    }
    
    // Verify prerequisite
    let cfg = StacklessControlFlowGraph::new_forward(&data.code);
    assert!(
        !has_critical_edges(&cfg),
        "LiveVarAnalysis prerequisite violated: CFG contains critical edges. \
         Enable SPLIT_CRITICAL_EDGES experiment."
    );
    
    // ... continue processing
}
```

**Comprehensive Fix**: 
1. Remove the experiment flag for `SPLIT_CRITICAL_EDGES` entirely - make it always on
2. Add compile-time dependency validation in the pipeline builder
3. Add runtime assertions in processors that depend on critical edge removal
4. Document all processor prerequisites clearly and enforce them

## Proof of Concept

Create a Move module with nested match expressions that introduce critical edges:

```move
module 0x42::exploit {
    enum Result has drop {
        Ok(u64),
        Err
    }
    
    public fun vulnerable(x: &mut u64, cond1: bool, cond2: bool): u64 {
        let r1 = &mut *x;
        
        // This creates critical edges when inlined
        let val = match (cond1) {
            true => match (cond2) {
                true => {
                    *r1 = 10;  // Use r1
                    Result::Ok(*r1)
                },
                false => Result::Err
            },
            false => Result::Err
        };
        
        // With incorrect liveness, r1 may be treated as not-live here
        // allowing another mutable borrow despite r1 still being in scope
        let r2 = &mut *x;  // Should be rejected but may be accepted
        *r2 = 20;
        
        match (val) {
            Result::Ok(v) => v,
            Result::Err => 0
        }
    }
}
```

**Compilation steps to trigger:**
```bash
# Compile with SPLIT_CRITICAL_EDGES disabled
aptos move compile --experiment split-critical-edges=off

# The code should be REJECTED by reference safety but may be ACCEPTED
# due to incorrect liveness analysis causing false negative
```

**Expected behavior**: Compilation error - cannot have two mutable borrows

**Actual behavior with flag disabled**: May compile successfully due to liveness analysis false negative causing reference safety to miss the violation

**Notes**

This is a **design flaw** in the pipeline dependency management rather than a traditional bug. The issue arises from:

1. Making safety-critical preprocessing optional via experiments
2. Not validating prerequisites before running dependent processors  
3. Silent assumption violations that only manifest under specific configurations

The vulnerability is particularly concerning because it affects **compiler correctness**, meaning malicious or misconfigured compilation could produce bytecode that:
- Passes all runtime checks (since the bytecode verifier only sees the final bytecode)
- Executes with undefined behavior
- Causes validator disagreement if different validators use different compiler configurations

While the default configuration is safe, the **ability to disable** critical safety preprocessing without validation creates an exploitable attack surface.

### Citations

**File:** third_party/move/move-compiler-v2/src/lib.rs (L506-509)
```rust
    // Preprocessing of the stackless bytecode. Many passes expect the absence of critical edges.
    if options.experiment_on(Experiment::SPLIT_CRITICAL_EDGES) {
        pipeline.add_processor(Box::new(SplitCriticalEdgesProcessor {}));
    }
```

**File:** third_party/move/move-compiler-v2/src/pipeline/livevar_analysis_processor.rs (L11-11)
```rust
//! This processor assumes that the CFG of the code has no critical edges.
```

**File:** third_party/move/move-compiler-v2/src/pipeline/livevar_analysis_processor.rs (L249-251)
```rust
        // This problem of values which "are lost on the edge" of the control graph can be dealt with by
        // introducing extra edges. However, assuming that there are no critical edges, a simpler
        // solution is the join `pre(L1) := pre(L1) join after(L0)`, and similar for `L2`.
```

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs (L8-8)
```rust
//! Prerequisite: livevar annotation is available by performing liveness analysis.
```

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs (L1109-1110)
```rust
            if self.is_ref(temp) && !self.alive.after.contains_key(&temp) {
                self.state.release_ref(temp)
```

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs (L1534-1542)
```rust
                AssignKind::Inferred => {
                    if self.state.label_for_temp_with_children(src).is_none()
                        && !self.alive.after.contains_key(&src)
                    {
                        self.state.move_ref(dest, src)
                    } else {
                        self.state.copy_ref(dest, src)
                    }
                },
```

**File:** third_party/move/move-compiler-v2/src/experiments.rs (L146-149)
```rust
            name: Experiment::SPLIT_CRITICAL_EDGES.to_string(),
            description: "Turns on or off splitting of critical edges".to_string(),
            default: Given(true),
        },
```

**File:** third_party/move/move-compiler-v2/transactional-tests/tests/no-v1-comparison/enum/bug_14733_match_critical_edge.move (L1-4)
```text
// This source tests various scenarios of matches which introduce critical edges, which
// are eliminated by the split-critical-edge-processor. This kind of matches
// are also the only kind of code which can introduce those edges, so we are also
// testing functionality of the processor here.
```
