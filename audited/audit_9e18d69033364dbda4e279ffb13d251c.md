# Audit Report

## Title
Size Validation Race: First-Write Estimate Bypass Allows Non-Deterministic Execution in BlockSTM

## Summary
A logic flaw in the `write()` function of `versioned_group_data.rs` prevents the `size_has_changed` flag from being set when a transaction's first incarnation writes a resource group size different from the storage base. This allows estimate reads to succeed when they should fail validation, potentially causing non-deterministic execution across validators and breaking consensus safety.

## Finding Description

The vulnerability exists in the size validation logic of BlockSTM's multi-version data structure. When a transaction writes resource group data, the system tracks whether group sizes have changed using a heuristic flag `size_has_changed` to determine if reads from estimate entries are safe. [1](#0-0) 

The critical flaw is in the `write()` function's logic for updating this flag: [2](#0-1) 

The `update_flag` at line 241 is only set to `true` if either:
1. The previous entry is NOT the base storage entry (`*idx != ShiftedTxnIndex::zero_idx()`), OR
2. The current incarnation is greater than 0 (`incarnation > 0`)

This means when a transaction's **first incarnation** (incarnation 0) compares against the **base storage entry** (index 0), the `update_flag` will be `false` even if the size actually changed. Consequently, at lines 247-249, `size_has_changed` is NOT set to `true` despite the size difference.

**Attack Scenario:**
1. Storage base has resource group with size 100
2. Transaction 5, incarnation 0 writes size 200 (different from base)
3. The comparison finds size_changed=true, but update_flag=false (idx=0, incarnation=0)
4. `size_has_changed` remains false
5. Transaction 5 gets aborted due to validation failure and marked as estimate
6. Transaction 10 reads the group size at index 12

At the read path in `get_group_size_no_record()`: [3](#0-2) 

The check at line 471 evaluates `size.is_estimate() && g.size_has_changed`:
- `is_estimate()` = true (marked after abort)
- `size_has_changed` = false (never set due to the bug)
- Condition is false, so returns `Ok(200)` instead of `Err(MVGroupError::Dependency(...))`

This allows the read to proceed with an estimate value when it should block on a dependency. Different validators may have different timing in parallel execution, causing some to read the estimate (size 200) and others to wait for re-execution (potentially reading a different size). This leads to non-deterministic execution results.

## Impact Explanation

**Severity: Critical** - Consensus/Safety Violation

This vulnerability breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

In Aptos's BlockSTM parallel execution engine, when validators process the same block:
- Validator A's timing may cause Transaction 10 to read the estimate entry (size 200) and proceed with execution
- Validator B's timing may cause Transaction 10 to properly block and wait for Transaction 5's re-execution (potentially size 100)
- The two validators compute different state transitions from the same block
- This leads to divergent state roots and a consensus safety violation

This meets the **Critical Severity** criteria per the Aptos bug bounty: "Consensus/Safety violations" and could require a hardfork to resolve if validators have committed divergent states.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability will trigger whenever:
1. A transaction's first incarnation writes a resource group with a size different from storage
2. That transaction gets aborted (common in parallel execution due to conflicts)
3. A higher transaction reads the size while the estimate is pending

These conditions occur regularly during normal BlockSTM operation, especially under high transaction load where:
- Initial executions frequently differ from storage state (common pattern)
- Validation failures and aborts are expected (part of optimistic execution)
- Parallel reads racing with re-executions are routine

No special attacker privileges are required - this is triggered by normal transaction flow.

## Recommendation

Modify the `update_flag` logic to set `size_has_changed` whenever the size actually changes, regardless of incarnation number or comparison index. The flag should reflect actual size divergence, not just non-initial writes.

**Proposed Fix:**

```rust
if !(group_sizes.size_has_changed && ret) {
    let (size_changed, update_flag) = Self::get_latest_entry(
        &group_sizes.size_entries,
        txn_idx,
        ReadPosition::AfterCurrentTxn,
    )
    .ok_or_else(|| {
        code_invariant_error("Initialized group sizes must contain storage version")
    })
    .map(|(idx, prev_size)| {
        let size_changed = prev_size.value.size != size;
        (
            size_changed,
            // Set update_flag to true whenever size actually changed,
            // OR if this is not the first incarnation (for consistency)
            size_changed || incarnation > 0,
        )
    })?;

    if size_changed {
        ret = true;
        if update_flag {
            group_sizes.size_has_changed = true;
        }
    }
}
```

Alternatively, always set `size_has_changed` when `size_changed` is true, making the flag unconditionally track any size divergence.

## Proof of Concept

```rust
#[test]
fn test_first_incarnation_estimate_bypass() {
    use aptos_types::write_set::WriteOpKind;
    use std::collections::HashSet;
    
    // Initialize group with base size 100
    let group_key = KeyType(b"/group/test".to_vec());
    let tag: usize = 1;
    let group_data = VersionedGroupData::<KeyType<Vec<u8>>, usize, TestValue>::empty();
    
    let base_value = TestValue::creation_with_len(10); // Size contributes to 100
    let base_size = ResourceGroupSize::Combined {
        num_tagged_resources: 1,
        all_tagged_resources_size: 100,
    };
    
    assert_ok!(group_data.set_raw_base_values(
        group_key.clone(),
        vec![(tag, base_value.clone())]
    ));
    
    // Transaction 5, incarnation 0 writes different size
    let new_value = TestValue::creation_with_len(20); // Different size
    let new_size = ResourceGroupSize::Combined {
        num_tagged_resources: 1,
        all_tagged_resources_size: 200, // Different from base!
    };
    
    let txn_idx: TxnIndex = 5;
    let incarnation: Incarnation = 0; // FIRST incarnation
    
    // Write with different size
    let result = group_data.write(
        group_key.clone(),
        txn_idx,
        incarnation,
        vec![(tag, (new_value.clone(), None))],
        new_size,
        HashSet::new(),
    );
    assert_ok!(result);
    
    // Check that size_has_changed is FALSE (this is the bug!)
    let group_sizes = group_data.group_sizes.get(&group_key).unwrap();
    assert_eq!(group_sizes.size_has_changed, false); // BUG: Should be true!
    
    // Mark transaction 5 as estimate (simulating abort)
    group_data.mark_estimate(&group_key, txn_idx, HashSet::from([&tag]));
    
    // Transaction 10 reads the size
    let read_txn_idx: TxnIndex = 10;
    let read_result = group_data.get_group_size_no_record(&group_key, read_txn_idx);
    
    // BUG: Read succeeds with estimate value when it should fail!
    assert_ok_eq!(read_result, new_size); // Should be Err(MVGroupError::Dependency(5))
    
    // The read should have returned a dependency error, but it didn't
    // This allows non-deterministic execution across validators
}
```

## Notes

This vulnerability is particularly insidious because it only affects the **first incarnation** of transactions writing sizes different from storage. The subsequent incarnations work correctly, making this bug intermittent and timing-dependent - exactly the kind of issue that causes consensus divergence in production under load.

The fix must ensure that `size_has_changed` is set whenever actual size divergence is detected, not just on non-initial writes. The current logic appears to assume that first writes are "establishing" sizes rather than "changing" them, but this assumption breaks the safety guarantees needed for estimate read validation in BlockSTM's optimistic parallel execution model.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L62-71)
```rust
#[derive(Default)]
struct VersionedGroupSize {
    size_entries: BTreeMap<ShiftedTxnIndex, SizeEntry<SizeAndDependencies>>,
    // Determines whether it is safe for size queries to read the value from an entry marked as
    // ESTIMATE. The heuristic checks on every write, whether the same size would be returned
    // after the respective write took effect. Once set, the flag remains set to true.
    // TODO: Handle remove similarly. May want to depend on transaction indices, i.e. if size
    // has changed early in the block, it may not have an influence on much later transactions.
    size_has_changed: bool,
}
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L227-251)
```rust
        if !(group_sizes.size_has_changed && ret) {
            let (size_changed, update_flag) = Self::get_latest_entry(
                &group_sizes.size_entries,
                txn_idx,
                ReadPosition::AfterCurrentTxn,
            )
            .ok_or_else(|| {
                code_invariant_error("Initialized group sizes must contain storage version")
            })
            .map(|(idx, prev_size)| {
                (
                    prev_size.value.size != size,
                    // Update the size_has_changed flag if the entry isn't the base value
                    // (which may be non-existent) or if the incarnation > 0.
                    *idx != ShiftedTxnIndex::zero_idx() || incarnation > 0,
                )
            })?;

            if size_changed {
                ret = true;
                if update_flag {
                    group_sizes.size_has_changed = true;
                }
            }
        }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L462-482)
```rust
    pub fn get_group_size_no_record(
        &self,
        group_key: &K,
        txn_idx: TxnIndex,
    ) -> Result<ResourceGroupSize, MVGroupError> {
        match self.group_sizes.get(group_key) {
            Some(g) => {
                Self::get_latest_entry(&g.size_entries, txn_idx, ReadPosition::BeforeCurrentTxn)
                    .map_or(Err(MVGroupError::Uninitialized), |(idx, size)| {
                        if size.is_estimate() && g.size_has_changed {
                            Err(MVGroupError::Dependency(
                                idx.idx().expect("May not depend on storage version"),
                            ))
                        } else {
                            Ok(size.value.size)
                        }
                    })
            },
            None => Err(MVGroupError::Uninitialized),
        }
    }
```
