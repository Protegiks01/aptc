# Audit Report

## Title
Incomplete Genesis Resource Validation Allows Chain-Halting Attack via Missing Critical Framework Resources

## Summary
The genesis bootstrapping process fails to validate that critical framework resources (`TimestampResource`, `StakingConfig`, `StakingRewardsConfig`) are properly initialized, only checking for `ValidatorSet` and `ConfigurationResource`. A malicious or malformed genesis transaction can pass all validation checks but omit these resources, causing immediate consensus failure when the first block attempts to access them, resulting in a non-recoverable network partition requiring a hardfork.

## Finding Description
The `Command::run()` function in the db-tool bootstrap loads a genesis transaction from a user-provided file and validates it through `calculate_genesis()`. [1](#0-0) 

The validation process in `calculate_genesis()` only verifies that execution succeeded and a reconfiguration event was produced: [2](#0-1) 

The critical check `ensure_next_epoch_state()` only validates the presence of `ValidatorSet` and `ConfigurationResource` in the write set: [3](#0-2) 

**Missing validations:**
- `TimestampResource` (CurrentTimeMicroseconds) - NOT checked
- `StakingConfig` - NOT checked  
- `StakingRewardsConfig` - NOT checked

These resources are required by block execution. The first block calls `timestamp::update_global_time()` which requires `CurrentTimeMicroseconds`: [4](#0-3) 

This function acquires the resource globally: [5](#0-4) 

Similarly, epoch changes require `StakingConfig` through `stake::on_new_epoch()` called during reconfiguration: [6](#0-5) 

**Attack path:**
1. Attacker crafts a `WriteSetPayload::Direct` containing:
   - `ValidatorSet` resource ✓
   - `ConfigurationResource` resource ✓
   - `NewBlockEvent` and `NewEpochEvent` ✓
   - **Omits** `TimestampResource`, `StakingConfig`, `StakingRewardsConfig` ✗
2. Serializes to `genesis.blob` file
3. Victim uses it with db-tool: `aptos-db-bootstrapper --db-dir /path --genesis-txn-file malicious.blob`
4. Node bootstraps successfully (passes all validation)
5. First block execution panics with "resource not found" when accessing missing resources
6. All validators crash simultaneously → consensus failure → chain halt

## Impact Explanation
This vulnerability meets **Critical Severity** ($1,000,000 bounty) criteria under "Non-recoverable network partition (requires hardfork)". 

When the missing resources are accessed:
- All validator nodes crash with Move VM panic
- The entire network halts (total loss of liveness)
- No blocks can be produced or committed
- Requires coordinated hardfork with corrected genesis to recover
- All nodes must wipe state and re-bootstrap

This breaks the **State Consistency** and **Consensus Safety** invariants, as validators cannot produce blocks with identical state roots when resources are missing.

## Likelihood Explanation
**Likelihood: Low to Medium**

Scenarios where this could occur:
1. **Test/Private Networks:** Developers creating custom genesis files with bugs in initialization logic
2. **Supply Chain Attack:** Malicious actor compromises genesis file distribution
3. **Social Engineering:** Validators tricked into using modified genesis files
4. **Configuration Error:** Operator accidentally uses incomplete/corrupted genesis file

While requiring social engineering or misconfiguration, the impact is catastrophic. The attack is feasible because:
- Genesis files are externally provided (not embedded in binary)
- No runtime validation of missing resources exists
- The db-tool accepts any BCS-serialized `Transaction::GenesisTransaction`

## Recommendation
Add comprehensive resource validation in `calculate_genesis()` after genesis execution:

```rust
// In execution/executor/src/db_bootstrapper/mod.rs, after line 154
if genesis_version == 0 {
    // Validate all critical resources exist in the result state
    let state_view = CachedStateView::new(
        StateViewId::Miscellaneous,
        Arc::clone(&db.reader),
        output.result_state().latest().clone(),
    )?;
    
    // Check TimestampResource
    ensure!(
        state_view.get_state_value_bytes(&StateKey::resource_typed::<TimestampResource>(
            &CORE_CODE_ADDRESS,
        )?)?.is_some(),
        "Genesis validation failed: TimestampResource not initialized"
    );
    
    // Check StakingConfig
    ensure!(
        state_view.get_state_value_bytes(&StateKey::on_chain_config::<StakingConfig>()?)?.is_some(),
        "Genesis validation failed: StakingConfig not initialized"
    );
    
    // Check StakingRewardsConfig
    ensure!(
        state_view.get_state_value_bytes(&StateKey::on_chain_config::<StakingRewardsConfig>()?)?.is_some(),
        "Genesis validation failed: StakingRewardsConfig not initialized"
    );
}
```

Additionally, update `ensure_next_epoch_state()` to validate these resources are in the write set for all epoch changes.

## Proof of Concept

```rust
// Proof of Concept: Craft malicious genesis transaction
use aptos_types::{
    transaction::{Transaction, WriteSetPayload},
    write_set::{WriteSet, WriteSetMut, WriteOp},
    state_store::state_key::StateKey,
    on_chain_config::{ValidatorSet, ConfigurationResource},
    account_config::CORE_CODE_ADDRESS,
};
use move_core_types::account_address::AccountAddress;

fn create_malicious_genesis() -> Transaction {
    let mut write_set_mut = WriteSetMut::default();
    
    // Add ValidatorSet (passes validation)
    let validator_set = ValidatorSet::new(vec![]);
    write_set_mut.push((
        StateKey::on_chain_config::<ValidatorSet>().unwrap(),
        WriteOp::legacy_modification(bcs::to_bytes(&validator_set).unwrap().into()),
    ));
    
    // Add ConfigurationResource (passes validation)
    let config = ConfigurationResource::new(0, 0);
    write_set_mut.push((
        StateKey::on_chain_config::<ConfigurationResource>().unwrap(),
        WriteOp::legacy_modification(bcs::to_bytes(&config).unwrap().into()),
    ));
    
    // OMIT TimestampResource - this will cause failure
    // OMIT StakingConfig - this will cause failure
    // OMIT StakingRewardsConfig - this will cause failure
    
    let write_set = write_set_mut.freeze().unwrap();
    let change_set = /* construct ChangeSet with write_set and events */;
    
    Transaction::GenesisTransaction(WriteSetPayload::Direct(change_set))
}

// This transaction will:
// 1. Pass validate_waypoint_change_set (has required events)
// 2. Pass ensure_next_epoch_state (has ValidatorSet + ConfigurationResource)
// 3. Bootstrap successfully
// 4. Crash on first block when timestamp::update_global_time() panics
```

**Notes**
The formal verification specifications document these resources should exist but runtime validation is incomplete. The vulnerability is in the gap between formal specifications and runtime enforcement, allowing malformed genesis transactions to break critical protocol invariants.

### Citations

**File:** storage/db-tool/src/bootstrap.rs (L41-47)
```rust
    pub fn run(self) -> Result<()> {
        let genesis_txn = load_genesis_txn(&self.genesis_txn_file)
            .with_context(|| format_err!("Failed loading genesis txn."))?;
        assert!(
            matches!(genesis_txn, Transaction::GenesisTransaction(_)),
            "Not a GenesisTransaction"
        );
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L147-154)
```rust
    ensure!(
        execution_output.num_transactions_to_commit() != 0,
        "Genesis txn execution failed."
    );
    ensure!(
        execution_output.next_epoch_state.is_some(),
        "Genesis txn didn't output reconfig event."
    );
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L520-540)
```rust
    fn ensure_next_epoch_state(to_commit: &TransactionsWithOutput) -> Result<EpochState> {
        let last_write_set = to_commit
            .transaction_outputs
            .last()
            .ok_or_else(|| anyhow!("to_commit is empty."))?
            .write_set();

        let write_set_view = WriteSetStateView {
            write_set: last_write_set,
        };

        let validator_set = ValidatorSet::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("ValidatorSet not touched on epoch change"))?;
        let configuration = ConfigurationResource::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("Configuration resource not touched on epoch change"))?;

        Ok(EpochState::new(
            configuration.epoch(),
            (&validator_set).into(),
        ))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L281-281)
```text
        timestamp::update_global_time(vm, new_block_event.proposer, new_block_event.time_microseconds);
```

**File:** aptos-move/framework/aptos-framework/sources/timestamp.move (L32-49)
```text
    public fun update_global_time(
        account: &signer,
        proposer: address,
        timestamp: u64
    ) acquires CurrentTimeMicroseconds {
        // Can only be invoked by AptosVM signer.
        system_addresses::assert_vm(account);

        let global_timer = borrow_global_mut<CurrentTimeMicroseconds>(@aptos_framework);
        let now = global_timer.microseconds;
        if (proposer == @vm_reserved) {
            // NIL block with null address as proposer. Timestamp must be equal.
            assert!(now == timestamp, error::invalid_argument(EINVALID_TIMESTAMP));
        } else {
            // Normal block. Time must advance
            assert!(now < timestamp, error::invalid_argument(EINVALID_TIMESTAMP));
            global_timer.microseconds = timestamp;
        };
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L131-135)
```text
        reconfiguration_state::on_reconfig_start();

        // Call stake to compute the new validator set and distribute rewards and transaction fees.
        stake::on_new_epoch();
        storage_gas::on_reconfig();
```
