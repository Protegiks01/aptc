# Audit Report

## Title
IPv4/IPv6 Protocol Confusion Enables IP Blocklist Bypass in Aptos Faucet

## Summary
The `IpRangeManager` implementation in the Aptos faucet does not handle IPv4-mapped IPv6 addresses, creating a protocol confusion vulnerability. An attacker whose IPv4 address is blocklisted can bypass the IP blocklist by connecting via the IPv6-mapped representation (e.g., `::ffff:203.0.113.50`), allowing them to evade rate limits and drain faucet funds.

## Finding Description

The `IpRangeManager` maintains separate lists for IPv4 and IPv6 ranges and only checks addresses against their matching protocol type: [1](#0-0) [2](#0-1) 

When an IPv4 address like `203.0.113.50` is blocklisted in the range `203.0.113.0/24`, the system only adds it to the `ipv4_list`. However, in dual-stack network environments, this same address can be represented as an IPv6-mapped address `::ffff:203.0.113.50`. The Rust standard library's `IpAddr` type treats this as `IpAddr::V6`, causing the blocklist check to fail: [3](#0-2) 

**Attack Flow:**
1. Attacker's IPv4 address `203.0.113.50` gets blocklisted after abuse
2. Attacker establishes connection via dual-stack network
3. Proxy/load balancer forwards connection with IPv6-mapped address `::ffff:203.0.113.50`
4. `RealIp` extractor parses this as `IpAddr::V6` variant
5. `IpBlocklistChecker` checks `ipv6_list.contains()` which is empty (only IPv4 ranges configured)
6. Check returns empty vector (not blocked)
7. Attacker proceeds through rate limit checks using the same IPv6-mapped address
8. Rate limit checkers treat `::ffff:203.0.113.50` as different from `203.0.113.50`
9. Attacker successfully bypasses both blocklist and rate limits [4](#0-3) 

The same vulnerability affects `IpAllowlistBypasser`, though with reversed impact (legitimate users may fail to bypass when connecting via different protocol). [5](#0-4) 

## Impact Explanation

This vulnerability enables **faucet fund drainage** through abuse of the testnet/devnet funding mechanism. The severity is **High** based on:

1. **Financial Impact**: Attackers can repeatedly request maximum funding amounts by evading IP-based rate limits, draining faucet reserves intended for legitimate developers
2. **Abuse Prevention Bypass**: Completely negates IP blocklist security controls designed to prevent known abusive actors
3. **Rate Limit Evasion**: The same IP address can be treated as two different addresses (IPv4 vs IPv6-mapped), effectively doubling or bypassing rate limits
4. **Operational Impact**: Faucet service degradation affects legitimate users and developer onboarding

While this doesn't directly compromise the blockchain consensus or validator funds, it represents a significant protocol violation in the faucet's access control system and enables limited but repeated fund loss.

## Likelihood Explanation

**Likelihood: High**

1. **Infrastructure Prevalence**: Modern cloud infrastructure commonly supports dual-stack networking (AWS, GCP, Azure all support IPv6)
2. **Attacker Knowledge**: IPv4-mapped IPv6 addresses are well-known in security research
3. **Easy Exploitation**: Attacker only needs to configure their client or proxy to use IPv6
4. **No Special Privileges**: Any external user can exploit this without insider access
5. **Difficulty of Detection**: Protocol confusion attacks are harder to detect in logs since they appear as legitimate IPv6 connections

The attack is trivial to execute once an attacker's IPv4 is blocklisted, requiring only basic network configuration knowledge.

## Recommendation

Normalize IP addresses to their canonical form before performing range checks. Specifically, convert IPv4-mapped IPv6 addresses to their IPv4 equivalents:

```rust
pub fn contains_ip(&self, ip: &IpAddr) -> bool {
    match ip {
        IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
        IpAddr::V6(ipv6) => {
            // Check if this is an IPv4-mapped IPv6 address
            if let Some(ipv4) = ipv6.to_ipv4_mapped() {
                // Check against IPv4 list for mapped addresses
                self.ipv4_list.contains(&ipv4)
            } else {
                // Regular IPv6 address
                self.ipv6_list.contains(ipv6)
            }
        }
    }
}
```

Additionally, consider normalizing the source IP at extraction time in the request preprocessing:

```rust
// In preprocess_request
let source_ip = match source_ip.0 {
    Some(IpAddr::V6(ipv6)) => {
        // Normalize IPv4-mapped IPv6 to IPv4
        if let Some(ipv4) = ipv6.to_ipv4_mapped() {
            IpAddr::V4(ipv4)
        } else {
            IpAddr::V6(ipv6)
        }
    }
    Some(ip) => ip,
    None => {
        return Err(AptosTapError::new(
            "No source IP found in the request".to_string(),
            AptosTapErrorCode::SourceIpMissing,
        ))
    }
};
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_ipv4_mapped_ipv6_bypass() {
        // Create a blocklist with IPv4 range
        let mut file = NamedTempFile::new().unwrap();
        writeln!(file, "203.0.113.0/24").unwrap();
        
        let config = IpRangeManagerConfig {
            file: file.path().to_path_buf(),
        };
        
        let manager = IpRangeManager::new(config).unwrap();
        
        // IPv4 address that should be blocked
        let blocked_ipv4 = IpAddr::V4(Ipv4Addr::new(203, 0, 113, 50));
        assert!(manager.contains_ip(&blocked_ipv4), "IPv4 should be blocked");
        
        // Same IP as IPv4-mapped IPv6 - BYPASSES the block!
        let ipv6_mapped = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xcb00, 0x7132));
        // This is ::ffff:203.0.113.50 in hex notation
        assert_eq!(ipv6_mapped.to_string(), "::ffff:203.0.113.50");
        
        // VULNERABILITY: IPv4-mapped IPv6 bypasses the blocklist
        assert!(!manager.contains_ip(&ipv6_mapped), 
            "VULNERABILITY: IPv4-mapped IPv6 bypasses IPv4 blocklist!");
    }
    
    #[test]
    fn test_rate_limit_bypass() {
        // Demonstrates that rate limiters see these as different IPs
        let ipv4 = IpAddr::V4(Ipv4Addr::new(203, 0, 113, 50));
        let ipv6_mapped = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xcb00, 0x7132));
        
        // These are the same real-world IP but different Rust values
        assert_ne!(ipv4, ipv6_mapped, 
            "Rate limiters using IpAddr as key will treat these as different users!");
    }
}
```

## Notes

This vulnerability affects both the `IpAllowlistBypasser` and `IpBlocklistChecker` components since they share the same `IpRangeManager` implementation. While the question specifically mentions the allowlist bypasser, the primary security impact manifests through blocklist bypass, enabling attackers to evade abuse prevention mechanisms and drain faucet funds.

The vulnerability is particularly concerning because:
1. It completely negates IP-based access control
2. The same attacker can appear as multiple distinct users to rate limiters
3. It's invisible in standard logging since IPv6 connections appear legitimate
4. It requires no special tools or sophisticated techniques to exploit

### Citations

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L18-21)
```rust
pub struct IpRangeManager {
    pub ipv4_list: IpRange<Ipv4Net>,
    pub ipv6_list: IpRange<Ipv6Net>,
}
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L55-60)
```rust
    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(ipv6),
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L32-49)
```rust
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L37-37)
```rust
    pub ip_to_requests_today: Mutex<LruCache<IpAddr, u32>>,
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L26-28)
```rust
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
```
