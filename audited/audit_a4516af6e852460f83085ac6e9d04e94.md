# Audit Report

## Title
Insufficient Gas Metering for Bytecode Verification Enables Validator CPU Exhaustion DoS

## Summary
Gas charged for module publishing is proportional to bytecode size, but verification cost scales with instruction count multiplied by the number of verification passes. Two critical verification passes (control flow and stack usage) do not meter their work at all, despite TODO comments indicating this was intended. An attacker can publish maximum-size modules filled with simple instructions (e.g., 60,000 Nop instructions) to force disproportionate CPU consumption relative to gas paid, enabling a denial-of-service attack on validator nodes.

## Finding Description

When a Move module is published, gas is charged based on bytecode size using `CODE_REQUEST_PUBLISH_PER_BYTE` (7 gas units per byte). [1](#0-0) 

However, bytecode verification requires multiple O(n) passes through all instructions, where n is the instruction count. The critical issue is that several verification passes either don't meter their work or meter it inadequately:

**Control Flow Verification** - Does NOT meter despite accepting a meter parameter: [2](#0-1) 

**Stack Usage Verification** - Does NOT meter despite accepting a meter parameter: [3](#0-2) 

These TODO comments indicate metering was intended but never implemented.

**Locals Safety Verification** - Meters only 15 units per instruction: [4](#0-3) 

**Type Safety Verification** - Iterates through all instructions with minimal metering for simple operations: [5](#0-4) 

Simple instructions like `Nop` perform no work in type safety: [6](#0-5) 

**Attack Scenario:**
1. Attacker creates a module with 60,000 `Nop` instructions (maximum module size)
2. Each `Nop` serializes to 1 byte (opcode 0x28): [7](#0-6) 

3. Gas charged: `1838 + 60000 * 7 = 421,838` gas units
4. Verification work: 60,000 instructions × 5+ passes = 300,000+ iteration operations
5. Only ~900,000 verification meter units consumed (1.1% of 80M limit): [8](#0-7) 

6. Attacker submits many such transactions with different module names/addresses (different hashes) to bypass verification cache: [9](#0-8) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria: "Validator node slowdowns."

An attacker can submit module publishing transactions that consume disproportionate validator CPU time relative to gas paid. While each individual module stays within verification meter limits, the gas charged does not adequately compensate for the CPU work required. By continuously submitting different maximum-size modules filled with simple instructions, an attacker can:

- Slow down validator block processing
- Increase transaction confirmation times
- Potentially cause validators to fall behind consensus
- Create a sustained DoS with relatively low attack cost

The attack is economically viable because gas charged (~420K units) is based on bytecode size, not the actual computational work of iterating through 60K instructions multiple times.

## Likelihood Explanation

**Likelihood: High**

- Attacker only needs ability to submit transactions (no special permissions)
- Module size limit is 60,000 bytes, allowing 60K simple instructions
- Verification is mandatory and cannot be skipped
- Attack can be sustained by creating modules with different hashes
- Two critical verification passes have NO metering (unimplemented)
- Production verification meter limit (80M units) is far from being exhausted

## Recommendation

Implement complete metering for all verification passes proportional to the actual work performed:

1. **Implement metering in control_flow verification** - Remove TODO and add proper metering for CFG construction and reducibility checking
2. **Implement metering in stack_usage verification** - Remove TODO and charge per instruction analyzed
3. **Increase per-instruction costs** in locals_safety to better reflect actual CPU work
4. **Add per-instruction base cost** in check_module_complexity to charge for iteration itself, not just type complexity:

```rust
// In check_module_complexity::meter_code()
const INSTRUCTION_ITERATION_COST: u64 = 1; // Base cost per instruction

fn meter_code(&self, code: &CodeUnit) -> PartialVMResult<()> {
    self.meter_signature(code.locals)?;
    
    // Charge for iterating through all instructions
    self.charge(code.code.len() as u64 * INSTRUCTION_ITERATION_COST)?;
    
    for instr in &code.code {
        // existing type complexity charging...
    }
    Ok(())
}
```

5. **Adjust gas formula** to ensure gas charged ≥ verification meter units consumed

## Proof of Concept

```rust
// Create a Move module with maximum Nop instructions
use move_binary_format::{
    file_format::{
        Bytecode, CodeUnit, CompiledModule, FunctionDefinition,
        FunctionHandle, FunctionHandleIndex, IdentifierIndex,
        ModuleHandle, ModuleHandleIndex, Signature, SignatureIndex,
        Visibility,
    },
    CompiledModule,
};

fn create_max_nop_module() -> CompiledModule {
    let mut module = CompiledModule::default();
    
    // Add maximum number of Nop instructions (u16::MAX - 1)
    let mut code = vec![];
    for _ in 0..65534 {
        code.push(Bytecode::Nop);
    }
    code.push(Bytecode::Ret);
    
    let code_unit = CodeUnit {
        locals: SignatureIndex(0),
        code,
    };
    
    // Add function with max Nops
    let func_def = FunctionDefinition {
        function: FunctionHandleIndex(0),
        visibility: Visibility::Public,
        is_entry: true,
        acquires_global_resources: vec![],
        code: Some(code_unit),
    };
    
    module.function_defs = vec![func_def];
    // ... complete module construction
    
    module
}

// Measure verification time
use std::time::Instant;

let module = create_max_nop_module();
let start = Instant::now();
move_bytecode_verifier::verify_module(&module).unwrap();
let duration = start.elapsed();

println!("Verification time for 65534 Nops: {:?}", duration);
// Expected: Significant time despite low gas charge

// Attacker submits many such modules with different names
for i in 0..100 {
    let mut attack_module = create_max_nop_module();
    attack_module.address_identifiers[0] = /* unique address */;
    // Publish via transaction - forces validators to verify each one
}
```

## Notes

The vulnerability stems from incomplete implementation of verification metering, as evidenced by TODO comments in critical verification passes. The gas formula assumes that bytecode size adequately proxies for verification cost, but this breaks down when modules contain many simple instructions that require iteration without complex type analysis. The attack is particularly effective because the verification meter limit (80M units) is never approached, even though significant CPU work is performed.

### Citations

**File:** aptos-move/framework/src/natives/code.rs (L299-299)
```rust
        context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(module_code.len() as u64))?;
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L41-41)
```rust
    _meter: &mut impl Meter, // TODO: metering
```

**File:** third_party/move/move-bytecode-verifier/src/stack_usage_verifier.rs (L33-33)
```rust
        _meter: &mut impl Meter, // TODO: metering
```

**File:** third_party/move/move-bytecode-verifier/src/locals_safety/abstract_state.rs (L30-30)
```rust
pub(crate) const STEP_BASE_COST: u128 = 15;
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L113-127)
```rust
pub(crate) fn verify<'a>(
    resolver: &'a BinaryIndexedView<'a>,
    function_view: &'a FunctionView<'a>,
    meter: &mut impl Meter, // currently unused
) -> PartialVMResult<()> {
    let verifier = &mut TypeSafetyChecker::new(resolver, function_view);

    for block_id in function_view.cfg().blocks() {
        for offset in function_view.cfg().instr_indexes(block_id) {
            let instr = &verifier.function_view.code().code[offset as usize];
            verify_instr(verifier, instr, offset, meter)?
        }
    }

    Ok(())
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L663-663)
```rust
        Bytecode::Branch(_) | Bytecode::Nop => (),
```

**File:** third_party/move/move-binary-format/src/serializer.rs (L1172-1172)
```rust
        Bytecode::Nop => binary.push(Opcodes::NOP as u8),
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L175-176)
```rust
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L184-197)
```rust
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
```
