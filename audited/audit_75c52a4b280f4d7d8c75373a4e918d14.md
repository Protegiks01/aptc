# Audit Report

## Title
Quorum Store V2 Messages Silently Dropped Due to Unhandled Message Types in NetworkTask

## Summary
The `NetworkTask::start()` function's Event::Message handler does not match the V2 variants of quorum store messages (BatchMsgV2, SignedBatchInfoMsgV2, ProofOfStoreMsgV2), causing them to fall through to the default case where they are silently dropped with only a warning. This breaks quorum store functionality when V2 batches are enabled, leading to consensus liveness failures.

## Finding Description
The vulnerability exists in the message routing logic of the consensus network layer. The ConsensusMsg enum defines V2 variants for quorum store messages to support the extended BatchInfoExt type. [1](#0-0) 

However, the NetworkTask::start() function's Event::Message handler only matches the V1 variants (BatchMsg, SignedBatchInfo, ProofOfStoreMsg) in the pattern match. [2](#0-1) 

The V2 variants are not included in this pattern match, causing them to fall through to the default case which simply logs a warning and drops the message without processing. [3](#0-2) 

This is problematic because production code actively sends these V2 messages when the `enable_batch_v2` configuration flag is enabled. The batch generator broadcasts BatchMsgV2 when V2 is enabled. [4](#0-3) 

Similarly, the batch coordinator sends SignedBatchInfoMsgV2 when persisting V2 batches (determined by checking `batch_info().is_v2()`). [5](#0-4) 

And the proof coordinator broadcasts ProofOfStoreMsgV2 when proofs use the V2 format. [6](#0-5) 

The network sender implementations correctly create and broadcast these V2 messages: [7](#0-6) [8](#0-7) [9](#0-8) 

The enable_batch_v2 configuration flag is a legitimate production feature. [10](#0-9) 

**Attack Path**: When enable_batch_v2 is enabled:
1. Batch generator creates V2 batches and broadcasts BatchMsgV2
2. Receiving validators' NetworkTask receives these messages via Event::Message
3. Messages fail to match any pattern in the Event::Message handler (only V1 variants are matched)
4. Messages hit the default case and are silently dropped with a warning
5. Validators never receive batch data, breaking the quorum store protocol
6. Consensus cannot progress without a functioning quorum store

Importantly, the UnverifiedEvent enum and its From<ConsensusMsg> implementation DO support V2 messages and could process them correctly. [11](#0-10) 

However, the V2 messages never reach this processing stage because they are dropped at the NetworkTask routing layer before being pushed to the quorum_store_messages_tx channel.

## Impact Explanation
This is a **High Severity** vulnerability that causes significant protocol violations:

1. **Consensus Liveness Failure**: When V2 batches are enabled, validators cannot receive batch information, signed batch info, or proofs of store. This breaks the quorum store protocol which is critical for consensus operation, leading to inability to create or commit blocks.

2. **Protocol Violation**: The issue violates the consensus invariant that all validators must be able to participate in the consensus protocol. Validators that enable V2 support effectively become unable to participate because they cannot exchange quorum store messages.

3. **Network Partition Risk**: If only some validators enable V2 support while others don't, this creates a de-facto network partition where V2-enabled nodes cannot communicate quorum store data with each other.

This meets the **High Severity** criteria per the Aptos bug bounty program: "Validator node slowdowns" and "Significant protocol violations." While it doesn't directly cause fund loss or permanent network halts (since the flag can be disabled), it completely breaks consensus liveness for validators with V2 enabled, which is a critical system function.

## Likelihood Explanation
**Likelihood: High (Conditional)**

This vulnerability will automatically trigger whenever:
1. The `enable_batch_v2` configuration flag is enabled (which is the intended upgrade path for this feature)
2. Any validator creates V2 batches (automatically determined by checking `batch_info().is_v2()`)

The issue is not an edge case but a systematic failure in the message routing code. Every V2 quorum store message sent will be silently dropped. This is highly likely to occur during:
- Testing of V2 batch support
- Gradual rollout of V2 batches to production
- Any environment where V2 is enabled

The code shows this is production-ready functionality (not experimental) with explicit configuration flags and feature detection logic, making the likelihood of occurrence very high once V2 support is enabled. The vulnerability triggers automatically without any additional preconditions beyond the configuration flag.

## Recommendation
Add the V2 message variants to the pattern match in NetworkTask::start() Event::Message handler:

```rust
quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
| ConsensusMsg::BatchMsg(_)
| ConsensusMsg::ProofOfStoreMsg(_)
| ConsensusMsg::SignedBatchInfoMsgV2(_)  // Add V2 variant
| ConsensusMsg::BatchMsgV2(_)             // Add V2 variant
| ConsensusMsg::ProofOfStoreMsgV2(_)) => { // Add V2 variant
    Self::push_msg(
        peer_id,
        quorum_store_msg,
        &self.quorum_store_messages_tx,
    );
}
```

This ensures V2 messages are routed to the quorum_store_messages_tx channel where they will be processed by EpochManager, converted to UnverifiedEvent (which already supports V2 variants), verified, and forwarded to the appropriate quorum store components.

## Proof of Concept
This vulnerability can be demonstrated by:

1. Set `enable_batch_v2 = true` in the quorum store configuration
2. Start a validator node
3. Monitor network logs for "Unexpected direct send msg" warnings
4. Observe that all BatchMsgV2, SignedBatchInfoMsgV2, and ProofOfStoreMsgV2 messages are dropped
5. Observe that the quorum store cannot function and consensus fails to progress

The vulnerability is evident from static code analysis - the pattern match in the NetworkTask explicitly excludes V2 variants while the sending code explicitly creates them when V2 is enabled, creating a guaranteed message drop scenario.

## Notes
- This is a message routing bug in the consensus network layer, not a network DoS attack
- The vulnerability only affects validators with `enable_batch_v2=true` (not enabled by default)
- Once enabled, the failure is automatic and guaranteed - no additional conditions needed
- The downstream processing code (UnverifiedEvent) already supports V2 messages correctly
- The fix is straightforward: add V2 variants to the pattern match

### Citations

**File:** consensus/src/network_interface.rs (L97-102)
```rust
    BatchMsgV2(Box<BatchMsg<BatchInfoExt>>),
    /// Quorum Store: Send a signed batch digest with BatchInfoExt. This is a vote for the batch and a promise that
    /// the batch of transactions was received and will be persisted until batch expiration.
    SignedBatchInfoMsgV2(Box<SignedBatchInfoMsg<BatchInfoExt>>),
    /// Quorum Store: Broadcast a certified proof of store (a digest that received 2f+1 votes) with BatchInfoExt.
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
```

**File:** consensus/src/network.rs (L599-608)
```rust
    async fn send_signed_batch_info_msg_v2(
        &self,
        signed_batch_infos: Vec<SignedBatchInfo<BatchInfoExt>>,
        recipients: Vec<Author>,
    ) {
        fail_point!("consensus::send::signed_batch_info", |_| ());
        let msg = ConsensusMsg::SignedBatchInfoMsgV2(Box::new(SignedBatchInfoMsg::new(
            signed_batch_infos,
        )));
        self.send(msg, recipients).await
```

**File:** consensus/src/network.rs (L617-620)
```rust
    async fn broadcast_batch_msg_v2(&mut self, batches: Vec<Batch<BatchInfoExt>>) {
        fail_point!("consensus::send::broadcast_batch", |_| ());
        let msg = ConsensusMsg::BatchMsgV2(Box::new(BatchMsg::new(batches)));
        self.broadcast(msg).await
```

**File:** consensus/src/network.rs (L629-632)
```rust
    async fn broadcast_proof_of_store_msg_v2(&mut self, proofs: Vec<ProofOfStore<BatchInfoExt>>) {
        fail_point!("consensus::send::proof_of_store", |_| ());
        let msg = ConsensusMsg::ProofOfStoreMsgV2(Box::new(ProofOfStoreMsg::new(proofs)));
        self.broadcast(msg).await
```

**File:** consensus/src/network.rs (L823-830)
```rust
                        quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
                        | ConsensusMsg::BatchMsg(_)
                        | ConsensusMsg::ProofOfStoreMsg(_)) => {
                            Self::push_msg(
                                peer_id,
                                quorum_store_msg,
                                &self.quorum_store_messages_tx,
                            );
```

**File:** consensus/src/network.rs (L937-940)
```rust
                        _ => {
                            warn!(remote_peer = peer_id, "Unexpected direct send msg");
                            continue;
                        },
```

**File:** consensus/src/quorum_store/batch_generator.rs (L494-495)
```rust
                            if self.config.enable_batch_v2 {
                                network_sender.broadcast_batch_msg_v2(batches).await;
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L102-110)
```rust
            if persist_requests[0].batch_info().is_v2() {
                let signed_batch_infos = batch_store.persist(persist_requests);
                if !signed_batch_infos.is_empty() {
                    if approx_created_ts_usecs > 0 {
                        observe_batch(approx_created_ts_usecs, peer_id, BatchStage::SIGNED);
                    }
                    network_sender
                        .send_signed_batch_info_msg_v2(signed_batch_infos, vec![peer_id])
                        .await;
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L485-487)
```rust
                                    if proofs_iter.peek().is_some_and(|p| p.info().is_v2()) {
                                        let proofs: Vec<_> = proofs_iter.collect();
                                        network_sender.broadcast_proof_of_store_msg_v2(proofs).await;
```

**File:** config/src/config/quorum_store_config.rs (L102-144)
```rust
    pub enable_batch_v2: bool,
}

impl Default for QuorumStoreConfig {
    fn default() -> QuorumStoreConfig {
        QuorumStoreConfig {
            channel_size: 1000,
            proof_timeout_ms: 10000,
            batch_generation_poll_interval_ms: 25,
            batch_generation_min_non_empty_interval_ms: 50,
            batch_generation_max_interval_ms: 250,
            sender_max_batch_txns: DEFEAULT_MAX_BATCH_TXNS,
            // TODO: on next release, remove BATCH_PADDING_BYTES
            sender_max_batch_bytes: 1024 * 1024 - BATCH_PADDING_BYTES,
            sender_max_num_batches: DEFAULT_MAX_NUM_BATCHES,
            sender_max_total_txns: 1500,
            // TODO: on next release, remove DEFAULT_MAX_NUM_BATCHES * BATCH_PADDING_BYTES
            sender_max_total_bytes: 4 * 1024 * 1024 - DEFAULT_MAX_NUM_BATCHES * BATCH_PADDING_BYTES,
            receiver_max_batch_txns: 100,
            receiver_max_batch_bytes: 1024 * 1024 + BATCH_PADDING_BYTES,
            receiver_max_num_batches: 20,
            receiver_max_total_txns: 2000,
            receiver_max_total_bytes: 4 * 1024 * 1024
                + DEFAULT_MAX_NUM_BATCHES
                + BATCH_PADDING_BYTES,
            batch_request_num_peers: 5,
            batch_request_retry_limit: 10,
            batch_request_retry_interval_ms: 500,
            batch_request_rpc_timeout_ms: 5000,
            batch_expiry_gap_when_init_usecs: Duration::from_secs(60).as_micros() as u64,
            remote_batch_expiry_gap_when_init_usecs: Duration::from_millis(500).as_micros() as u64,
            memory_quota: 120_000_000,
            db_quota: 300_000_000,
            batch_quota: 300_000,
            back_pressure: QuorumStoreBackPressureConfig::default(),
            // number of batch coordinators to handle QS batch messages, should be >= 1
            num_workers_for_remote_batches: 10,
            batch_buckets: DEFAULT_BUCKETS.to_vec(),
            allow_batches_without_pos_in_proposal: true,
            enable_opt_quorum_store: true,
            opt_qs_minimum_batch_age_usecs: Duration::from_millis(50).as_micros() as u64,
            enable_payload_v2: false,
            enable_batch_v2: false,
```

**File:** consensus/src/round_manager.rs (L263-265)
```rust
            ConsensusMsg::BatchMsgV2(m) => UnverifiedEvent::BatchMsgV2(m),
            ConsensusMsg::SignedBatchInfoMsgV2(m) => UnverifiedEvent::SignedBatchInfoMsgV2(m),
            ConsensusMsg::ProofOfStoreMsgV2(m) => UnverifiedEvent::ProofOfStoreMsgV2(m),
```
