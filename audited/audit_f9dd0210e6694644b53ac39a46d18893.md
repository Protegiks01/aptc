# Audit Report

## Title
SafetyData Field Migration Causes Consensus Safety State Loss During Validator Upgrades

## Summary
When validators upgrade to a new version of Aptos Core that adds fields to `SafetyData` (such as `one_chain_round`), the `#[serde(default)]` migration strategy causes critical consensus safety state to be reset to default values (0), allowing validators to operate with incomplete safety information and potentially sign conflicting timeouts that violate consensus safety.

## Finding Description

The `SafetyData` struct stores critical consensus safety state that prevents validators from violating safety rules. When new fields like `one_chain_round` are added to this struct, they use `#[serde(default)]` for backward compatibility during deserialization. [1](#0-0) 

The `one_chain_round` field tracks the highest 1-chain (certified block) round the validator has observed. This is critical for the `safe_to_timeout` safety check in the 2-chain consensus protocol: [2](#0-1) 

**The vulnerability occurs during validator upgrades:**

1. **Pre-upgrade state (old code without `one_chain_round`)**: A validator operates for rounds 1-100 in epoch 5, observing QCs up to round 100. The persisted `SafetyData` contains: `{epoch: 5, last_voted_round: 98, preferred_round: 97}`. The validator has observed certified blocks up to round 100, but this information isn't persisted because the field doesn't exist yet.

2. **Upgrade**: The validator restarts with new code containing the `one_chain_round` field. During deserialization, `#[serde(default)]` sets `one_chain_round: 0`, resulting in: `{epoch: 5, last_voted_round: 98, preferred_round: 97, one_chain_round: 0}`.

3. **State corruption**: The validator has now "forgotten" that it observed certified blocks up to round 100. The safety state is incomplete and inconsistent.

4. **Exploitation**: A Byzantine actor can craft a `TwoChainTimeout` for round 99 with:
   - `hqc_round: 50` (an old but valid QC)
   - `tc_round: 98` (valid timeout certificate)

5. **Safety check bypass**: The `safe_to_timeout` function validates:
   - `round (99) == next_round(tc_round=98)` ✓ (99 == 99)
   - `qc_round (50) >= one_chain_round (0)` ✓ (should fail with actual value ~98-100)

6. **Consensus safety violation**: The validator signs a timeout for round 99 based on a stale QC from round 50, despite having previously observed certified blocks at rounds 51-100. This regresses the validator to an older certified state, violating the fundamental safety invariant.

The existing test only verifies successful deserialization but doesn't validate the safety of defaulted values: [3](#0-2) 

Note how the test creates an inconsistent state with `preferred_round: 100` but implicitly `one_chain_round: 0` after deserialization, yet this inconsistency is never detected.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria for "Significant protocol violations":

- **Consensus Safety Violation**: Validators can sign timeouts based on stale QCs, regressing to older certified states they've already observed
- **Chain Fork Risk**: If multiple validators upgrade simultaneously and are exploited, conflicting consensus branches can be constructed
- **Network Integrity**: Compromises the fundamental safety guarantee that AptosBFT prevents chain splits under < 1/3 Byzantine validators

While not Critical severity, this is serious because:
- It directly violates consensus safety invariants
- Can occur during routine network upgrades
- Affects all validators that upgrade with persisted `SafetyData`
- Could enable Byzantine validators to cause chain forks during upgrade windows

## Likelihood Explanation

**Medium to High likelihood** because:

- **Triggering condition**: Occurs during any validator upgrade when `SafetyData` schema changes (which has already happened with `one_chain_round` and `highest_timeout_round`)
- **Exploitation window**: All validators upgrading from pre-`one_chain_round` code to post-`one_chain_round` code are vulnerable
- **Attacker requirements**: Requires Byzantine validator participation but no special privileges beyond normal validator operations
- **Coordination needed**: More impactful if coordinated during network-wide upgrades when many validators restart simultaneously
- **Detection difficulty**: The inconsistent state is not validated, so validators operate normally without detecting the corruption

The likelihood is lower than Critical because it requires:
1. A version upgrade with `SafetyData` schema changes
2. Byzantine validators actively exploiting the migration window
3. Multiple validators to be affected for significant impact

## Recommendation

Implement a proper migration mechanism for `SafetyData` that validates and repairs inconsistent state:

**Fix 1: Add migration validation logic**

```rust
// In consensus/consensus-types/src/safety_data.rs
impl SafetyData {
    /// Validates and repairs SafetyData after deserialization
    pub fn validate_and_repair(&mut self) {
        // If one_chain_round is suspiciously low compared to preferred_round,
        // use preferred_round as a conservative lower bound
        if self.one_chain_round < self.preferred_round {
            warn!(
                "Detected inconsistent SafetyData during migration: \
                 one_chain_round ({}) < preferred_round ({}). \
                 Setting one_chain_round = preferred_round for safety.",
                self.one_chain_round, self.preferred_round
            );
            self.one_chain_round = self.preferred_round;
        }
        
        // Similarly for highest_timeout_round
        if self.highest_timeout_round < self.last_voted_round {
            warn!(
                "Detected inconsistent SafetyData during migration: \
                 highest_timeout_round ({}) < last_voted_round ({}). \
                 Setting highest_timeout_round = last_voted_round for safety.",
                self.highest_timeout_round, self.last_voted_round
            );
            self.highest_timeout_round = self.last_voted_round;
        }
    }
}
```

**Fix 2: Call validation during load** [4](#0-3) 

Modify the `safety_data()` method to validate after loading:

```rust
pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
    if !self.enable_cached_safety_data {
        let _timer = counters::start_timer("get", SAFETY_DATA);
        let mut data: SafetyData = self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
        data.validate_and_repair(); // Add this
        return Ok(data);
    }

    if let Some(cached_safety_data) = self.cached_safety_data.clone() {
        Ok(cached_safety_data)
    } else {
        let _timer = counters::start_timer("get", SAFETY_DATA);
        let mut safety_data: SafetyData = self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
        safety_data.validate_and_repair(); // Add this
        self.cached_safety_data = Some(safety_data.clone());
        Ok(safety_data)
    }
}
```

**Fix 3: Add explicit version field for future migrations**

```rust
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    #[serde(default)]
    pub version: u32,  // Add version field for explicit migration tracking
    pub epoch: u64,
    pub last_voted_round: u64,
    pub preferred_round: u64,
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod safety_data_migration_vulnerability_test {
    use super::*;
    use serde_json;

    #[test]
    fn test_safety_data_migration_creates_unsafe_state() {
        // Simulate old SafetyData without one_chain_round
        #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
        struct OldSafetyData {
            pub epoch: u64,
            pub last_voted_round: u64,
            pub preferred_round: u64,
            pub last_vote: Option<Vote>,
        }
        
        // Validator has operated up to round 100
        // Has voted on round 98, observed QC certifying round 99 (making preferred_round 98)
        // Has actually seen QCs up to round 100 but can't persist this without one_chain_round
        let old_data = OldSafetyData {
            epoch: 5,
            last_voted_round: 98,
            preferred_round: 97,  // 2-chain head
            last_vote: None,
        };
        
        // Serialize old data
        let serialized = serde_json::to_value(old_data).unwrap();
        
        // Deserialize as new SafetyData with one_chain_round field
        let new_data: SafetyData = serde_json::from_value(serialized).unwrap();
        
        // VULNERABILITY: one_chain_round is 0, but validator has seen QCs up to ~98-100
        assert_eq!(new_data.epoch, 5);
        assert_eq!(new_data.last_voted_round, 98);
        assert_eq!(new_data.preferred_round, 97);
        assert_eq!(new_data.one_chain_round, 0);  // UNSAFE: Should be ~97-100
        
        // This inconsistent state allows safe_to_timeout to pass with old QCs
        // A timeout for round 99 with qc_round=50 would satisfy:
        // - qc_round (50) >= one_chain_round (0) ✓ (SHOULD FAIL)
        // - timeout.round (99) >= last_voted_round (98) ✓
        
        // Demonstrates the safety violation: validator can accept timeouts
        // based on stale QCs (round 50) despite having observed much higher rounds
        println!(
            "VULNERABILITY: Validator at round {} with preferred_round {} \
             has one_chain_round reset to {}. Can now accept timeouts with \
             stale QCs from round 50+, violating consensus safety!",
            new_data.last_voted_round,
            new_data.preferred_round,
            new_data.one_chain_round
        );
    }
}
```

## Notes

This vulnerability specifically affects the migration path when validators upgrade from versions without `one_chain_round` to versions with it. The same issue applies to `highest_timeout_round` and any future fields added with `#[serde(default)]`.

The root cause is using serde's default mechanism without post-deserialization validation to ensure the safety-critical invariants are maintained. While `preferred_round` is preserved during migration, it becomes inconsistent with `one_chain_round = 0`, creating a validator state that violates fundamental consensus safety assumptions.

### Citations

**File:** consensus/consensus-types/src/safety_data.rs (L10-21)
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/consensus-types/src/safety_data.rs (L53-70)
```rust
#[test]
fn test_safety_data_upgrade() {
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    let old_data = OldSafetyData {
        epoch: 1,
        last_voted_round: 10,
        preferred_round: 100,
        last_vote: None,
    };
    let value = serde_json::to_value(old_data).unwrap();
    let _: SafetyData = serde_json::from_value(value).unwrap();
}
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L124-145)
```rust
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L134-148)
```rust
    pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
        if !self.enable_cached_safety_data {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            return self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
        }

        if let Some(cached_safety_data) = self.cached_safety_data.clone() {
            Ok(cached_safety_data)
        } else {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            let safety_data: SafetyData = self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
            self.cached_safety_data = Some(safety_data.clone());
            Ok(safety_data)
        }
    }
```
