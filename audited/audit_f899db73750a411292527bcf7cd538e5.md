# Audit Report

## Title
State Corruption Risk via Unvalidated ValueToIdentifierMapping Returns

## Summary
The `identifier_to_value` method in the delayed fields serialization system returns values that are directly written to blockchain state without any validation or integrity checks. If this implementation contains a bug (e.g., off-by-one error, race condition, or stale cache), incorrect values would be silently committed to storage, corrupting the blockchain state and breaking consensus determinism.

## Finding Description

The vulnerability exists in the delayed fields value exchange mechanism used during transaction finalization. The system performs a two-phase conversion:

**Phase 1 - Reading from Storage:** [1](#0-0) 

During deserialization, `value_to_identifier` converts concrete aggregator values (e.g., u128) into DelayedFieldIDs and stores the values in the versioned delayed fields map.

**Phase 2 - Writing to Storage (CRITICAL PATH):** [2](#0-1) 

The `replace_ids_with_values` function calls `identifier_to_value` to retrieve values for each DelayedFieldID before serialization: [3](#0-2) 

**The Critical Issue:**
The value returned by `identifier_to_value` is **directly serialized and written to blockchain state** without any validation that it matches the original value or is otherwise correct: [4](#0-3) 

**No Validation Exists:**
There is no mechanism to verify that the value returned by `identifier_to_value` is correct. The system blindly trusts the returned value and commits it to the Jellyfish Merkle Tree, making it part of the canonical blockchain state.

**Potential Bug Scenarios:**

1. **Off-by-one error in conversion logic**: A bug in `try_into_move_value` could systematically return `value - 1` instead of `value`

2. **Race condition in parallel execution**: The `read_latest_predicted_value` call with `ReadPosition::AfterCurrentTxn` could read a stale or inconsistent version in edge cases

3. **Width mismatch handling**: If DelayedFieldID width doesn't match actual value size due to a bug, the conversion could produce incorrect results: [5](#0-4) 

## Impact Explanation

**Severity: CRITICAL (up to $1,000,000)**

This vulnerability breaks multiple critical invariants:

1. **Deterministic Execution Violation**: If different validators have slightly different versions of conversion logic (or timing-dependent bugs), they will compute different state roots for the same block, breaking consensus.

2. **State Consistency Violation**: Corrupted aggregator values (e.g., account balances, token supplies) would be permanently written to storage and committed to the Merkle tree.

3. **Consensus Safety Violation**: Validators disagreeing on state roots cannot reach consensus, causing network partition requiring a hardfork to recover.

4. **Fund Loss**: Incorrect balance calculations could result in:
   - User funds appearing lower than actual (theft by underreporting)
   - Token supply miscalculation
   - Reward distribution errors

**Real-World Impact:**
- A bug returning `value - 1` for all aggregators would silently steal 1 unit from every aggregator operation
- Over millions of transactions, this could result in massive fund loss
- Recovery would require network hardfork and manual state correction
- User trust in the blockchain would be severely damaged

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

While the current implementation appears correct, the lack of validation creates a single point of failure:

1. **Complexity**: The conversion logic involves multiple layers (DelayedFieldID → DelayedFieldValue → Move Value) with width and layout matching requirements

2. **Parallel Execution Risks**: The Block-STM parallel execution environment introduces potential race conditions in reading versioned values

3. **Future Changes**: Any modification to the conversion logic or versioned data structure could introduce subtle bugs that would go undetected until after deployment

4. **No Safety Net**: The absence of validation means bugs would be discovered only after state corruption has occurred, not before

## Recommendation

**Implement Roundtrip Validation:**

Add a validation check that ensures the value returned by `identifier_to_value` matches expectations. This could be done by:

1. **Store value hash with ID**: When `value_to_identifier` creates an ID, store a hash of the serialized value alongside it

2. **Validate on retrieval**: When `identifier_to_value` returns a value, recompute its hash and verify it matches the stored hash

3. **Add explicit validation in materialization**: Before finalizing outputs, verify that delayed field values haven't been corrupted

**Proposed Fix Location:** [6](#0-5) 

Add validation after `identifier_to_value` returns but before serialization to storage:

```rust
// After replace_identifiers_with_values completes, validate roundtrip
let (patched_bytes, identifiers) = self.replace_identifiers_with_values(bytes, layout)?;

// VALIDATION: Re-extract and verify identifiers match
let extracted_ids = self.extract_identifiers_from_value(&patched_bytes, layout)?;
if extracted_ids != identifiers {
    return Err(code_invariant_error(
        "Delayed field identifier mismatch after value replacement - possible corruption"
    ));
}
```

## Proof of Concept

**Note:** This vulnerability requires a bug in the Aptos Core codebase itself to exploit. An external attacker cannot inject a malicious implementation. However, to demonstrate the risk, here's a hypothetical scenario:

**Scenario: Introduce an off-by-one bug in conversion**

If the following bug were introduced in `try_into_move_value`:

```rust
// BUGGY CODE (for demonstration only)
(Aggregator(v) | Snapshot(v), U128) => {
    if width != 16 {
        return Err(...);
    }
    Value::u128(v.saturating_sub(1)) // BUG: subtracts 1
}
```

**Exploitation Steps:**
1. User deposits 1000 tokens, aggregator value = 1000
2. Transaction executes, creates DelayedFieldID for value 1000
3. During finalization, buggy `identifier_to_value` returns 999
4. Value 999 is serialized and written to storage
5. Merkle tree commits wrong value
6. User's balance is now 999 instead of 1000 (1 token stolen)

**Impact:**
- Affects all aggregator operations across all transactions
- Silent corruption - no error raised
- Compounds over time with each transaction
- Requires hardfork to fix once discovered

---

## Notes

This is a **defense-in-depth issue** rather than a currently exploitable bug. The current implementation of `TemporaryValueToIdentifierMapping` appears correct, but the **lack of validation** creates significant risk:

- Any future bug in conversion logic would corrupt state silently
- No mechanism to detect corruption before commitment
- Recovery requires hardfork (highest severity outcome)

The security principle "don't trust, verify" is violated here. Critical state transitions should be validated, especially those affecting consensus and blockchain state integrity.

### Citations

**File:** aptos-move/block-executor/src/view.rs (L1229-1265)
```rust
    fn replace_values_with_identifiers(
        &self,
        state_value: StateValue,
        layout: &MoveTypeLayout,
    ) -> anyhow::Result<(StateValue, HashSet<DelayedFieldID>)> {
        let mapping = TemporaryValueToIdentifierMapping::new(self, self.txn_idx);
        let function_value_extension = self.as_function_value_extension();

        state_value
            .map_bytes(|bytes| {
                // This call will replace all occurrences of aggregator / snapshot
                // values with unique identifiers with the same type layout.
                // The values are stored in aggregators multi-version data structure,
                // see the actual trait implementation for more details.
                let patched_value =
                    ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
                        .with_delayed_fields_replacement(&mapping)
                        .with_func_args_deserialization(&function_value_extension)
                        .deserialize(bytes.as_ref(), layout)
                        .ok_or_else(|| {
                            anyhow::anyhow!("Failed to deserialize resource during id replacement")
                        })?;

                ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
                    .with_delayed_fields_serde()
                    .with_func_args_deserialization(&function_value_extension)
                    .serialize(&patched_value, layout)?
                    .ok_or_else(|| {
                        anyhow::anyhow!(
                            "Failed to serialize value {} after id replacement",
                            patched_value
                        )
                    })
                    .map(|b| b.into())
            })
            .map(|v| (v, mapping.into_inner()))
    }
```

**File:** aptos-move/block-executor/src/view.rs (L1269-1335)
```rust
    pub(crate) fn replace_identifiers_with_values(
        &self,
        bytes: &Bytes,
        layout: &MoveTypeLayout,
    ) -> anyhow::Result<(Bytes, HashSet<DelayedFieldID>)> {
        // Cfg due to deserialize_to_delayed_field_id use.
        #[cfg(test)]
        fail_point!("delayed_field_test", |_| {
            assert_eq!(
                layout,
                &mock_layout(),
                "Layout does not match expected mock layout"
            );

            // Replicate the logic of identifier_to_value.
            let (delayed_field_id, txn_idx) = deserialize_to_delayed_field_id(bytes)
                .expect("Mock deserialization failed in delayed field test.");
            let delayed_field = match &self.latest_view {
                ViewState::Sync(state) => state
                    .versioned_map
                    .delayed_fields()
                    .read_latest_predicted_value(
                        &delayed_field_id,
                        self.txn_idx,
                        ReadPosition::AfterCurrentTxn,
                    )
                    .expect("Committed value for ID must always exist"),
                ViewState::Unsync(state) => state
                    .read_delayed_field(delayed_field_id)
                    .expect("Delayed field value for ID must always exist in sequential execution"),
            };

            // Note: Test correctness relies on the fact that current proptests use the
            // same layout for all values ever stored at any key, given that some value
            // at the key contains a delayed field.
            Ok((
                serialize_from_delayed_field_u128(
                    delayed_field.into_aggregator_value().unwrap(),
                    txn_idx,
                ),
                HashSet::from([delayed_field_id]),
            ))
        });

        // This call will replace all occurrences of aggregator / snapshot
        // identifiers with values with the same type layout.
        let function_value_extension = self.as_function_value_extension();
        let value = ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
            .with_func_args_deserialization(&function_value_extension)
            .with_delayed_fields_serde()
            .deserialize(bytes, layout)
            .ok_or_else(|| {
                anyhow::anyhow!(
                    "Failed to deserialize resource during id replacement: {:?}",
                    bytes
                )
            })?;

        let mapping = TemporaryValueToIdentifierMapping::new(self, self.txn_idx);
        let patched_bytes = ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
            .with_delayed_fields_replacement(&mapping)
            .with_func_args_deserialization(&function_value_extension)
            .serialize(&value, layout)?
            .ok_or_else(|| anyhow::anyhow!("Failed to serialize resource during id replacement"))?
            .into();
        Ok((patched_bytes, mapping.into_inner()))
    }
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L280-306)
```rust
// Parse the input `value` and replace delayed field identifiers with corresponding values
fn replace_ids_with_values<T: Transaction, S: TStateView<Key = T::Key> + Sync>(
    value: &TriompheArc<T::Value>,
    layout: &MoveTypeLayout,
    latest_view: &LatestView<T, S>,
) -> Result<T::Value, PanicError> {
    let mut value = (**value).clone();

    if let Some(value_bytes) = value.bytes() {
        let patched_bytes = latest_view
            .replace_identifiers_with_values(value_bytes, layout)
            .map_err(|_| {
                code_invariant_error(format!(
                    "Failed to replace identifiers with values in a resource {:?}",
                    layout
                ))
            })?
            .0;
        value.set_bytes(patched_bytes);
        Ok(value)
    } else {
        Err(code_invariant_error(format!(
            "Value to be exchanged doesn't have bytes: {:?}",
            value,
        )))
    }
}
```

**File:** aptos-move/block-executor/src/value_exchange.rs (L86-108)
```rust
    fn identifier_to_value(
        &self,
        layout: &MoveTypeLayout,
        identifier: DelayedFieldID,
    ) -> PartialVMResult<Value> {
        self.delayed_field_ids.borrow_mut().insert(identifier);
        let delayed_field = match &self.latest_view.latest_view {
            ViewState::Sync(state) => state
                .versioned_map
                .delayed_fields()
                .read_latest_predicted_value(
                    &identifier,
                    self.txn_idx,
                    ReadPosition::AfterCurrentTxn,
                )
                .expect("Committed value for ID must always exist"),
            ViewState::Unsync(state) => state
                .read_delayed_field(identifier)
                .expect("Delayed field value for ID must always exist in sequential execution"),
        };
        delayed_field.try_into_move_value(layout, identifier.extract_width())
    }
}
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4960-4999)
```rust
            (L::Native(kind, layout), Value::DelayedFieldID { id }) => {
                match &self.ctx.delayed_fields_extension {
                    Some(delayed_fields_extension) => {
                        delayed_fields_extension
                            .inc_and_check_delayed_fields_count()
                            .map_err(S::Error::custom)?;

                        let value = match delayed_fields_extension.mapping {
                            Some(mapping) => mapping
                                .identifier_to_value(layout, *id)
                                .map_err(|e| S::Error::custom(format!("{}", e)))?,
                            None => id.try_into_move_value(layout).map_err(|_| {
                                S::Error::custom(format!(
                                    "Custom serialization failed for {:?} with layout {}",
                                    kind, layout
                                ))
                            })?,
                        };

                        // The resulting value should not contain any delayed fields, we disallow
                        // this by using a context without the delayed field extension.
                        let ctx = self.ctx.clone_without_delayed_fields();
                        let value = SerializationReadyValue {
                            ctx: &ctx,
                            layout: layout.as_ref(),
                            value: &value,
                            depth: self.depth,
                        };
                        value.serialize(serializer)
                    },
                    None => {
                        // If no delayed field extension, it is not known how the delayed value
                        // should be serialized. So, just return an error.
                        Err(invariant_violation::<S>(format!(
                            "no custom serializer for delayed value ({:?}) with layout {}",
                            kind, layout
                        )))
                    },
                }
            },
```

**File:** aptos-move/aptos-aggregator/src/types.rs (L138-173)
```rust
    pub fn try_into_move_value(
        self,
        layout: &MoveTypeLayout,
        width: u32,
    ) -> Result<Value, PartialVMError> {
        use DelayedFieldValue::*;
        use MoveTypeLayout::*;

        Ok(match (self, layout) {
            (Aggregator(v) | Snapshot(v), U64) => {
                if width != 8 {
                    return Err(PartialVMError::new(StatusCode::VM_EXTENSION_ERROR)
                        .with_message(format!("Expected width 8 for U64, got {}", width)));
                }
                Value::u64(v as u64)
            },
            (Aggregator(v) | Snapshot(v), U128) => {
                if width != 16 {
                    return Err(PartialVMError::new(StatusCode::VM_EXTENSION_ERROR)
                        .with_message(format!("Expected width 16 for U128, got {}", width)));
                }
                Value::u128(v)
            },
            (Derived(bytes), layout) if is_derived_string_struct_layout(layout) => {
                bytes_and_width_to_derived_string_struct(bytes, width as usize)?
            },
            (value, layout) => {
                return Err(
                    PartialVMError::new(StatusCode::VM_EXTENSION_ERROR).with_message(format!(
                        "Failed to convert {:?} into Move value with {} layout",
                        value, layout
                    )),
                )
            },
        })
    }
```
