# Audit Report

## Title
SSRF Vulnerability in NFT Metadata Crawler Asset Uploader - Missing URL Validation Allows Credential Leakage and Internal Network Probing

## Summary
The `upload_asset()` function in the NFT metadata crawler's asset uploader worker accepts URLs without validating for userinfo (credentials with @ symbols), private IP addresses, or localhost, enabling Server-Side Request Forgery (SSRF) attacks via Cloudflare as a proxy.

## Finding Description
The asset uploader worker accepts user-provided URLs through the `/upload` API endpoint and forwards them to Cloudflare's image upload service without validation. [1](#0-0) 

The `upload_asset()` function receives a URL and converts it directly to a string without validation: [2](#0-1) 

The API endpoint has no authentication: [3](#0-2) 

And accepts URLs as a vector: [4](#0-3) 

The service binds to all network interfaces: [5](#0-4) 

**Attack Path:**
1. Attacker sends POST request to `/upload` with `BatchUploadRequest` containing malicious URLs
2. URLs like `http://attacker.com@192.168.1.1/admin` or `http://user:pass@internal-service/api` are parsed as valid by `url::Url`
3. URLs are stored in database and picked up by throttler
4. Worker sends URL string to Cloudflare API which fetches from the target
5. This enables: credential leakage in logs, internal network reconnaissance via Cloudflare, potential access to services Cloudflare can reach

## Impact Explanation
This vulnerability has **LIMITED** impact as it affects only the off-chain NFT metadata crawler service, not the blockchain itself. It does NOT:
- Affect blockchain consensus or validator operations
- Compromise on-chain funds or state
- Break any blockchain invariants

However, it could enable:
- Information disclosure about internal network topology
- Credential leakage if URLs contain authentication information
- Service disruption if internal services are targeted
- Use of Cloudflare infrastructure to probe networks

Per the Aptos bug bounty criteria, this falls under **Low Severity**: "Minor information leaks, non-critical implementation bugs" rather than Medium, as it's isolated to an ecosystem tool with no blockchain impact.

## Likelihood Explanation
**High likelihood** of exploitation:
- No authentication required on API endpoints
- Straightforward HTTP POST with malicious URLs
- url::Url type accepts URLs with userinfo without validation
- Service potentially exposed via `0.0.0.0` binding

## Recommendation
Add URL validation before accepting uploads:

```rust
fn validate_url(url: &Url) -> anyhow::Result<()> {
    // Reject URLs with userinfo
    if url.username() != "" || url.password().is_some() {
        return Err(anyhow::anyhow!("URLs with credentials are not allowed"));
    }
    
    // Reject non-http(s) schemes
    if url.scheme() != "http" && url.scheme() != "https" {
        return Err(anyhow::anyhow!("Only http and https schemes are allowed"));
    }
    
    // Reject private IPs and localhost
    if let Some(host) = url.host_str() {
        if host == "localhost" || host == "127.0.0.1" || host == "::1" 
            || host.starts_with("192.168.") || host.starts_with("10.") 
            || host.starts_with("172.16.") {
            return Err(anyhow::anyhow!("Private IPs and localhost are not allowed"));
        }
    }
    
    Ok(())
}
```

Apply validation in `upload_asset()` before line 76 and in the API handler before accepting URLs.

Additionally, implement authentication on the API endpoints to prevent unauthorized access.

## Proof of Concept
```rust
#[tokio::test]
async fn test_ssrf_with_credentials() {
    use url::Url;
    
    // Attacker-controlled URL with credentials
    let malicious_url = Url::parse("http://attacker@192.168.1.1:8080/admin").unwrap();
    
    // URL is accepted without validation
    assert_eq!(malicious_url.username(), "attacker");
    assert_eq!(malicious_url.host_str(), Some("192.168.1.1"));
    
    // When converted to string, credentials are preserved
    let url_string = malicious_url.to_string();
    assert!(url_string.contains("attacker@192.168.1.1"));
    
    // This string would be sent to Cloudflare API, enabling SSRF
}
```

## Notes
**Important Clarification**: This vulnerability exists in the NFT metadata crawler, which is an **off-chain ecosystem tool** for indexing NFT metadata, NOT a core blockchain component. It does not affect:
- Blockchain consensus (AptosBFT)
- Move VM execution
- On-chain state or storage
- Validator operations
- On-chain governance or staking

The actual SSRF would occur on Cloudflare's infrastructure when they fetch the provided URL, not on Aptos blockchain nodes. The security impact is limited to the metadata crawler service itself.

### Citations

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/worker/mod.rs (L57-59)
```rust
pub struct UploadRequest {
    pub url: Url,
}
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/worker/mod.rs (L69-82)
```rust
    async fn upload_asset(&self, url: &Url) -> anyhow::Result<impl IntoResponse + use<>> {
        let hashed_url = sha256::digest(url.to_string());
        let client = Client::builder()
            .timeout(Duration::from_secs(MAX_ASSET_UPLOAD_RETRY_SECONDS))
            .build()
            .context("Error building reqwest client")?;
        let form = Form::new()
            .text("id", hashed_url.clone())
            .text(
                // Save the asset_uri in the upload metadata to enable retrieval by asset_uri later
                "metadata",
                format!("{{\"asset_uri\": \"{}\"}}", url),
            )
            .text("url", url.to_string());
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/api/mod.rs (L37-42)
```rust
#[derive(Debug, Deserialize)]
struct BatchUploadRequest {
    #[serde(flatten)]
    idempotency_tuple: IdempotencyTuple,
    urls: Vec<Url>,
}
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/api/mod.rs (L87-106)
```rust
    async fn handle_upload_batch(
        Extension(context): Extension<Arc<AssetUploaderApiContext>>,
        Json(request): Json<BatchUploadRequest>,
    ) -> impl IntoResponse {
        match upload_batch(context.pool.clone(), &request) {
            Ok(idempotency_tuple) => (
                StatusCode::OK,
                Json(BatchUploadResponse::Success { idempotency_tuple }),
            ),
            Err(e) => {
                error!(error = ?e, "Error uploading asset");
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(BatchUploadResponse::Error {
                        error: format!("Error uploading asset: {}", e),
                    }),
                )
            },
        }
    }
```

**File:** ecosystem/nft-metadata-crawler/src/config.rs (L100-100)
```rust
        let listener = TcpListener::bind(format!("0.0.0.0:{}", self.server_port)).await?;
```
