# Audit Report

## Title
Read-Before-Write Enforcement Bypass in Parallel Module Publishing Due to `read_state_value` Not Tracking Reads

## Summary
The `read_state_value` method intended to enforce read-before-write semantics for module republication bypasses the parallel execution's read tracking mechanism. In BlockSTM's parallel execution, `read_state_value` directly calls the base StateView without recording the read in `CapturedReads`, preventing proper dependency tracking and validation. This allows concurrent module publishing transactions to commit without detecting write conflicts, violating deterministic execution guarantees.

## Finding Description

The Aptos blockchain uses BlockSTM for parallel transaction execution with optimistic concurrency control. A critical invariant is that all writes must be preceded by reads so the system can detect dependencies and validate transactions correctly.

When modules are republished, the system enforces read-before-write by calling `read_state_value`: [1](#0-0) 

The comment explicitly states this is to enforce read-before-write because "modules can live in global cache, and so the DB may not see a module read even when it gets republished."

However, in the parallel execution context (`LatestView`), `read_state_value` is implemented as: [2](#0-1) 

This implementation **directly calls the base view** without:
1. Recording the read in `CapturedReads.module_reads` or `CapturedReads.data_reads`
2. Interacting with the MVHashMap that tracks speculative reads/writes
3. Creating any dependency that would be validated during parallel execution

In contrast, proper resource reads go through `read_cached_data_by_kind` which captures reads: [3](#0-2) 

During validation, only reads recorded in `CapturedReads` are checked: [4](#0-3) 

**Attack Scenario:**

1. Module M exists at address A in the base state
2. Transaction T1 (index 1) publishes new version M_v2
   - During execution: May not read M (depends on transaction logic)
   - At finish: `convert_modules_into_write_ops` calls `read_state_value(M)`
   - This reads from base_view but **does NOT add M to T1's module_reads**
3. Transaction T2 (index 2) also publishes new version M_v3 (executes in parallel)
   - Similarly, `read_state_value(M)` doesn't add M to T2's module_reads
4. During validation:
   - T1 validates: `validate_module_reads` checks only entries in T1's `module_reads` - M is absent, validation passes
   - T2 validates: M is also absent from T2's `module_reads`, validation passes
5. Both transactions commit, but only one version survives

This violates the documented invariant: [5](#0-4) 

## Impact Explanation

**Severity: High (up to $50,000) - Significant Protocol Violation**

This vulnerability breaks the **Deterministic Execution** invariant (Critical Invariant #1). While it doesn't directly cause immediate consensus divergence (because module writes go to the per-block cache and are committed sequentially), it creates several serious issues:

1. **Protocol Invariant Violation**: The read-before-write enforcement mechanism is completely bypassed in parallel execution
2. **Non-deterministic Ordering**: Without proper read dependencies, the system cannot correctly detect conflicts between concurrent module publications
3. **Validation Ineffectiveness**: The explicit enforcement call serves no purpose in parallel execution context
4. **Potential State Inconsistencies**: If different validators process parallel module publications differently, state divergence could occur

The impact is classified as **High** because it represents a significant protocol violation that undermines the parallel execution system's correctness guarantees, though it requires specific conditions (parallel module publishing to the same address) to manifest.

## Likelihood Explanation

**Likelihood: Medium**

Required conditions:
- Multiple transactions publishing modules to the same address executing in parallel
- BlockSTM parallel execution enabled (production configuration)
- Transactions not reading the target module during normal execution

This scenario is realistic but not常見 because:
- Module publishing is less frequent than normal transactions
- Most module publishers test locally before deploying
- However, during framework upgrades or coordinated deployments, this could occur

The vulnerability is deterministically exploitable once conditions are met.

## Recommendation

The `read_state_value` implementation for `LatestView` must integrate with the parallel execution's read tracking mechanism. Specifically, it should record a read in the MVHashMap data structures to create a proper dependency.

**Recommended Fix:**

Modify the `StateStorageView` implementation for `LatestView` to track the read properly: [6](#0-5) 

Replace with an implementation that calls through the existing read tracking infrastructure:

```rust
fn read_state_value(&self, state_key: &Self::Key) -> Result<(), StateViewError> {
    // Use get_resource_state_value_impl to ensure read is tracked in MVHashMap
    self.get_resource_state_value_impl(
        state_key,
        UnknownOrLayout::Unknown,
        ReadKind::Value,
    )
    .map(|_| ())
    .map_err(|e| StateViewError::new(e.to_string()))
}
```

Alternatively, add a specific method to `CapturedReads` to record module state reads and call it from `read_state_value`.

## Proof of Concept

The following test would demonstrate the issue (pseudo-code):

```rust
#[test]
fn test_parallel_module_publish_conflict() {
    // Setup: Create a baseline with module M at address A
    let mut executor = ParallelExecutor::new();
    let module_m_v1 = compile_module("module 0x1::M { public fun v1() {} }");
    executor.publish_module_at_genesis(module_m_v1);
    
    // Transaction 1: Publish M version 2
    let tx1 = create_module_publish_txn(
        "module 0x1::M { public fun v2() {} }", 
        sender_1
    );
    
    // Transaction 2: Publish M version 3 (different code, same address)
    let tx2 = create_module_publish_txn(
        "module 0x1::M { public fun v3() {} }", 
        sender_2  // Must have publishing capability for 0x1
    );
    
    // Execute in parallel
    let output = executor.execute_block(vec![tx1, tx2]);
    
    // Expected: One transaction should abort due to conflict
    // Actual: Both may commit (depending on execution order)
    
    // Verify: Check if read_state_value actually created read dependency
    assert!(output.transaction_outputs[0].captured_reads.module_reads.contains_key(&module_key));
    // This assertion would FAIL, exposing the bug
}
```

**Note**: A complete PoC would require access to the BlockSTM test infrastructure and the ability to create transactions with module publishing capabilities to the same address, which is restricted in production but possible in test environments.

### Citations

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L110-123)
```rust
            // Enforce read-before-write:
            //   Modules can live in global cache, and so the DB may not see a module read even
            //   when it gets republished. This violates read-before-write property. Here, we on
            //   purpose enforce this by registering a read to the DB directly.
            //   Note that we also do it here so that in case of storage errors, only a  single
            //   transaction fails (e.g., if doing this read before commit in block executor we
            //   have no way to alter the transaction outputs at that point).
            self.remote.read_state_value(&state_key).map_err(|err| {
                let msg = format!(
                    "Error when enforcing read-before-write for module {}::{}: {:?}",
                    addr, name, err
                );
                PartialVMError::new(StatusCode::STORAGE_ERROR).with_message(msg)
            })?;
```

**File:** aptos-move/block-executor/src/view.rs (L669-673)
```rust
                    return self.captured_reads.borrow_mut().capture_data_read(
                        key.clone(),
                        DataRead::from_value_with_layout(version, value),
                        &target_kind,
                    );
```

**File:** aptos-move/block-executor/src/view.rs (L1792-1807)
```rust
impl<T: Transaction, S: TStateView<Key = T::Key>> StateStorageView for LatestView<'_, T, S> {
    type Key = T::Key;

    fn id(&self) -> StateViewId {
        self.base_view.id()
    }

    fn read_state_value(&self, state_key: &Self::Key) -> Result<(), StateViewError> {
        self.base_view.get_state_value(state_key)?;
        Ok(())
    }

    fn get_usage(&self) -> Result<StateStorageUsage, StateViewError> {
        self.base_view.get_usage()
    }
}
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1050-1089)
```rust
    pub(crate) fn validate_module_reads(
        &self,
        global_module_cache: &GlobalModuleCache<K, DC, VC, S>,
        per_block_module_cache: &SyncModuleCache<K, DC, VC, S, Option<TxnIndex>>,
        maybe_updated_module_keys: Option<&BTreeSet<K>>,
    ) -> bool {
        if self.non_delayed_field_speculative_failure {
            return false;
        }

        let validate = |key: &K, read: &ModuleRead<DC, VC, S>| match read {
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
            ModuleRead::PerBlockCache(previous) => {
                let current_version = per_block_module_cache.get_module_version(key);
                let previous_version = previous.as_ref().map(|(_, version)| *version);
                current_version == previous_version
            },
        };

        match maybe_updated_module_keys {
            Some(updated_module_keys) if updated_module_keys.len() <= self.module_reads.len() => {
                // When updated_module_keys is smaller, iterate over it and lookup in module_reads
                updated_module_keys
                    .iter()
                    .filter(|&k| self.module_reads.contains_key(k))
                    .all(|key| validate(key, self.module_reads.get(key).unwrap()))
            },
            Some(updated_module_keys) => {
                // When module_reads is smaller, iterate over it and filter by updated_module_keys
                self.module_reads
                    .iter()
                    .filter(|(k, _)| updated_module_keys.contains(k))
                    .all(|(key, read)| validate(key, read))
            },
            None => self
                .module_reads
                .iter()
                .all(|(key, read)| validate(key, read)),
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/module_write_set.rs (L107-111)
```rust
            // INVARIANT:
            //   If there is a write to the module at key K, it means the module at K has been read
            //   (in order to perform backward-compatibility checks) if it existed.
            //   If module at K previously did not exist, the read of previous size returns None.
            //   Because module with key K has been read, it must have been loaded and metered.
```
