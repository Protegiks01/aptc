# Audit Report

## Title
Integer Truncation in InstantiationLoopChecker Allows Bypass of Generic Instantiation Loop Detection via Function Index Overflow

## Summary
The Move bytecode verifier's `InstantiationLoopChecker` uses integer casts from `usize` to `u16` when processing function definition indices, causing index wraparound for modules with more than 65,535 function definitions. Combined with the production configuration that sets `max_function_definitions: None`, an attacker can craft a malicious module where generic functions with instantiation loops are positioned at indices â‰¥65536, causing them to alias to lower indices (0, 1, 2...) and completely bypassing the loop detection mechanism.

## Finding Description

The `InstantiationLoopChecker` is a critical security component that prevents infinite generic instantiation loops in Move modules. [1](#0-0) 

The vulnerability stems from three key issues:

**1. Integer Truncation in Node Construction:**

The `Node` struct represents type formals of generic functions using `FunctionDefinitionIndex` and `TypeParameterIndex`: [2](#0-1) 

`FunctionDefinitionIndex` is defined as a wrapper around `TableIndex` which is `u16`: [3](#0-2)  and [4](#0-3) 

When building the function handle map, the code casts `usize` to `u16`: [5](#0-4) 

Similarly, when building the instantiation graph by iterating function definitions: [6](#0-5) 

**2. Missing Validation in Production Configuration:**

The production Aptos verifier configuration explicitly sets `max_function_definitions` to `None`: [7](#0-6) 

This causes the `LimitsVerifier` check to be skipped: [8](#0-7) 

**3. Deserialization Allows Arbitrary Function Count:**

The deserializer loads function definitions without enforcing a count limit, only bounded by the table byte size (4GB): [9](#0-8) 

**Attack Scenario:**

1. Attacker creates a malicious module with 65,537 function definitions
2. Functions 0-65,535: Non-generic dummy functions
3. Function 65,536: `foo<T>() { bar<Vec<T>>(); }` - calls bar with wrapped type
4. Function 65,537: `bar<T>() { foo<Vec<T>>(); }` - calls foo with wrapped type

When the verifier runs:
- Function 65,536's index is cast to `u16`: `65536 as u16 = 0`
- Function 65,537's index is cast to `u16`: `65537 as u16 = 1`
- The graph builder creates nodes for what it thinks are functions 0 and 1 (the dummy functions)
- The actual instantiation loop between the generic functions at indices 65,536 and 65,537 is invisible
- Module passes verification

At runtime, calling function 65,536 with type `T` instantiates function 65,537 with `Vec<T>`, which calls back with `Vec<Vec<T>>`, creating an infinite instantiation cascade that bypasses gas limits and exhausts memory.

## Impact Explanation

**Critical Severity** - This vulnerability enables multiple critical impacts:

1. **Consensus Safety Violation**: Different validators could have different memory/resource limits, causing some to crash during instantiation while others continue, leading to chain splits and consensus failure. This breaks the **Deterministic Execution** invariant.

2. **Resource Exhaustion / DoS**: Infinite generic instantiation bypasses gas metering as type instantiation happens during module loading before execution gas is charged. This can cause validator node crashes, breaking the **Move VM Safety** invariant.

3. **Loss of Liveness**: If a malicious module is published to the blockchain, any transaction that triggers execution of the vulnerable functions causes validator crashes, potentially bringing down the network if enough validators are affected.

Per Aptos bug bounty criteria, this qualifies as Critical because it enables:
- Consensus/Safety violations (different execution paths on different validators)
- Total loss of liveness (validator crashes prevent block production)
- Bypasses fundamental VM safety mechanisms (gas limits, memory constraints)

## Likelihood Explanation

**High Likelihood** - The attack is straightforward to execute:

1. **Low Barrier**: Attacker only needs to publish a single malicious module with carefully structured function definitions
2. **No Special Privileges**: Any user can publish modules to accounts they control
3. **Deterministic**: The integer overflow is guaranteed when function count exceeds 65,535
4. **Bypasses All Checks**: Production configuration disables the only safeguard (`max_function_definitions: None`)
5. **Minimal Size**: A function definition has a minimum size of ~5 bytes (native function), so 65,537 minimal functions = ~328KB, well within transaction limits

The only requirement is publishing a module, which is a standard blockchain operation.

## Recommendation

Implement a hard limit check on function definitions count during module deserialization and verification:

1. **Add validation in deserializer** - After loading function definitions, check count: [10](#0-9) 

Add after line 808:
```rust
if module.function_defs.len() > TABLE_INDEX_MAX as usize {
    return Err(PartialVMError::new(StatusCode::MAX_FUNCTION_DEFINITIONS_REACHED)
        .with_message(format!(
            "Module has {} function definitions, exceeding maximum of {}",
            module.function_defs.len(), TABLE_INDEX_MAX
        )));
}
```

2. **Set explicit limit in production config** - Update the production verifier config: [11](#0-10) 

Change line 171 from:
```rust
max_function_definitions: None,
```
to:
```rust
max_function_definitions: Some(TABLE_INDEX_MAX as usize), // 65535
```

3. **Add defensive checks** - In InstantiationLoopChecker, add assertion: [12](#0-11) 

Add before line 353:
```rust
debug_assert!(
    def_idx <= TableIndex::MAX as usize,
    "Function definition index {} exceeds u16::MAX", 
    def_idx
);
```

## Proof of Concept

```rust
// Create a malicious Move module builder
use move_binary_format::file_format::*;

fn create_malicious_module() -> CompiledModule {
    let mut module = CompiledModule::default();
    
    // Add necessary module metadata
    module.version = 6;
    module.self_module_handle_idx = ModuleHandleIndex(0);
    
    // Add module handle
    module.module_handles.push(ModuleHandle {
        address: AddressIdentifierIndex(0),
        name: IdentifierIndex(0),
    });
    
    // Add 65537 function definitions
    for i in 0..65537 {
        if i < 65536 {
            // Dummy non-generic native functions
            module.function_defs.push(FunctionDefinition {
                function: FunctionHandleIndex(i as u16),
                visibility: Visibility::Private,
                is_entry: false,
                acquires_global_resources: vec![],
                code: None, // Native function
            });
            
            module.function_handles.push(FunctionHandle {
                module: ModuleHandleIndex(0),
                name: IdentifierIndex(i as u16),
                parameters: SignatureIndex(0),
                return_: SignatureIndex(0),
                type_parameters: vec![],
                access_specifiers: None,
            });
        } else if i == 65536 {
            // foo<T>() { bar<Vec<T>>(); }
            module.function_defs.push(create_generic_function_foo());
            module.function_handles.push(create_generic_handle_foo());
        } else {
            // bar<T>() { foo<Vec<T>>(); }
            module.function_defs.push(create_generic_function_bar());
            module.function_handles.push(create_generic_handle_bar());
        }
    }
    
    module
}

// When this module is verified:
// 1. InstantiationLoopChecker iterates functions 0-65536
// 2. At index 65536, casts to u16: 65536 % 65536 = 0
// 3. At index 65537, casts to u16: 65537 % 65536 = 1  
// 4. Graph nodes created for indices 0,1 (dummy functions) instead of 65536,65537
// 5. Real instantiation loop between generic functions is invisible
// 6. Module passes verification
// 7. Runtime: calling foo<u64>() triggers infinite Vec<Vec<...<u64>...>> instantiation
```

**Notes**

The TypeParameterIndex cast at line 192 is NOT vulnerable because `TYPE_PARAMETER_COUNT_MAX` is enforced at 255 during deserialization: [13](#0-12)  and [14](#0-13) 

Since 255 < 65536, the cast to `TypeParameterIndex` (which is `u16`) at line 192 of instantiation_loops.rs cannot overflow.

The vulnerability is specific to `FunctionDefinitionIndex` where no such limit is enforced in production.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/instantiation_loops.rs (L5-14)
```rust
//! This implements an algorithm that detects loops during the instantiation of generics.
//!
//! It builds a graph from the given `CompiledModule` and converts the original problem into
//! finding strongly connected components in the graph with certain properties. Read the
//! documentation of the types/functions below for details of how it works.
//!
//! Note: We're doing generics only up to specialization, and are doing a conservative check of
//! generic call sites to eliminate those which could lead to an infinite number of specialized
//! instances. We do reject recursive functions that create a new type upon each call but do
//! terminate eventually.
```

**File:** third_party/move/move-bytecode-verifier/src/instantiation_loops.rs (L33-36)
```rust
/// Data attached to each node.
/// Each node corresponds to a type formal of a generic function in the module.
#[derive(Eq, PartialEq, Hash, Copy, Clone)]
struct Node(FunctionDefinitionIndex, TypeParameterIndex);
```

**File:** third_party/move/move-bytecode-verifier/src/instantiation_loops.rs (L79-85)
```rust
            func_handle_def_map: module
                .function_defs()
                .iter()
                .enumerate()
                .map(|(def_idx, def)| (def.function, FunctionDefinitionIndex::new(def_idx as u16)))
                .collect(),
        }
```

**File:** third_party/move/move-bytecode-verifier/src/instantiation_loops.rs (L345-355)
```rust
    fn build_graph(&mut self) {
        for (def_idx, func_def) in self
            .module
            .function_defs()
            .iter()
            .enumerate()
            .filter(|(_, def)| !def.is_native())
        {
            self.build_graph_function_def(FunctionDefinitionIndex::new(def_idx as u16), func_def)
        }
    }
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L55-56)
```rust
/// Generic index into one of the tables in the binary format.
pub type TableIndex = u16;
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L161-165)
```rust
define_index! {
    name: FunctionDefinitionIndex,
    kind: FunctionDefinition,
    doc: "Index into the `FunctionDefinition` table.",
}
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L155-171)
```rust
    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L197-206)
```rust
    fn verify_definitions(&self, config: &VerifierConfig) -> PartialVMResult<()> {
        if let Some(defs) = self.resolver.function_defs() {
            if let Some(max_function_definitions) = config.max_function_definitions {
                if defs.len() > max_function_definitions {
                    return Err(PartialVMError::new(
                        StatusCode::MAX_FUNCTION_DEFINITIONS_REACHED,
                    ));
                }
            }
        }
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L370-372)
```rust
fn load_type_parameter_count(cursor: &mut VersionedCursor) -> BinaryLoaderResult<usize> {
    read_uleb_internal(cursor, TYPE_PARAMETER_COUNT_MAX)
}
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L575-588)
```rust
    fn load<T>(
        &self,
        binary: &VersionedBinary,
        result: &mut Vec<T>,
        deserializer: impl Fn(&mut VersionedCursor) -> BinaryLoaderResult<T>,
    ) -> BinaryLoaderResult<()> {
        let start = self.offset as usize;
        let end = start + self.count as usize;
        let mut cursor = binary.new_cursor(start, end);
        while cursor.position() < self.count as u64 {
            result.push(deserializer(&mut cursor)?)
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L807-809)
```rust
            TableType::FUNCTION_DEFS => {
                table.load(binary, &mut module.function_defs, load_function_def)?;
            },
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L83-83)
```rust
pub const TYPE_PARAMETER_COUNT_MAX: u64 = 255;
```
