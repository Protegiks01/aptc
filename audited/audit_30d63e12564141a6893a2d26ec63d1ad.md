# Audit Report

## Title
Panic-Induced API DoS via Unchecked `full_block_txns` Zero Value in Gas Estimation

## Summary
The `GasEstimationConfig.full_block_txns` parameter lacks validation in the config sanitizer and has no tests for edge cases (0, 1, usize::MAX). When set to zero, the API node panics when encountering nil blocks (blocks with only metadata transactions), causing a Denial of Service. [1](#0-0) 

## Finding Description

The `full_block_txns` configuration parameter determines the threshold for considering a block "full" during gas price estimation. However, the config sanitizer only validates block history parameters but completely omits validation for `full_block_txns`: [2](#0-1) 

When `full_block_txns` is set to 0, the condition `prices_and_used.len() >= 0` in the gas estimation logic always evaluates to true: [3](#0-2) 

This causes `is_full_block` to be true even for empty transaction lists. The code then attempts to find the minimum gas price from an empty iterator and calls `.unwrap()` on `None`: [4](#0-3) 

**Attack Path:**
1. Node operator sets `full_block_txns = 0` in configuration (accidentally or due to misunderstanding)
2. Blockchain produces a nil block (block with only `BlockMetadataTransaction`, no user transactions) - this is normal and expected behavior in Aptos
3. API endpoint calls `estimate_gas_price()` 
4. `get_gas_prices_and_used()` returns empty vector when `limit = last - first = 0`: [5](#0-4) 

5. `.min().unwrap()` panics on empty iterator, crashing the API node

Nil blocks are explicitly supported in Aptos (confirmed by Move framework comments about "Nil blocks (no user txs)"), making this scenario inevitable rather than edge-case.

## Impact Explanation

This is a **High Severity** vulnerability under the Aptos Bug Bounty program criteria:
- **"API crashes"** - Direct panic causes complete API node termination
- Affects all gas estimation API endpoints exposed to users
- No user transactions can get gas price estimates while node is down
- Requires manual restart to restore service

The impact is amplified because:
- Nil blocks are a normal part of the protocol, not an anomaly
- Config validation is specifically designed to prevent such misconfigurations
- The sanitizer validates all other similar parameters (block_history values) but omits this one

## Likelihood Explanation

**Medium-High Likelihood:**
- Node operators may set `full_block_txns = 0` thinking it means "unlimited" or "disabled"
- No validation prevents this misconfiguration despite explicit checks for other zero values
- Nil blocks occur regularly in production (when mempool is empty during consensus rounds)
- Tests only use valid values (3, 250) and never test edge cases: [6](#0-5) 

The absence of both runtime validation and test coverage indicates this bug could easily reach production.

## Recommendation

Add validation in the config sanitizer to ensure `full_block_txns > 0`:

```rust
impl ConfigSanitizer for GasEstimationConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let gas_estimation_config = &node_config.api.gas_estimation;

        // ADD THIS CHECK:
        if gas_estimation_config.full_block_txns == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "full_block_txns must be > 0".to_string(),
            ));
        }

        // Existing checks...
        if gas_estimation_config.low_block_history == 0
            || gas_estimation_config.market_block_history == 0
            || gas_estimation_config.aggressive_block_history == 0
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "low {}, market {}, aggressive {} block history must be > 0",
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history,
                    gas_estimation_config.aggressive_block_history
                ),
            ));
        }

        Ok(())
    }
}
```

Additionally, add defensive handling in the gas estimation code to prevent panic:

```rust
if is_full_block {
    if let Some(min_price) = prices_and_used.iter().map(|(price, _)| *price).min() {
        Some(self.next_bucket(min_price))
    } else {
        None  // Empty block, no price data
    }
} else {
    None
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::ApiConfig;

    #[test]
    fn test_sanitize_zero_full_block_txns() {
        // Create a node config with full_block_txns = 0
        let node_config = NodeConfig {
            api: ApiConfig {
                gas_estimation: GasEstimationConfig {
                    full_block_txns: 0,  // Invalid edge case
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };

        // Sanitize should fail but currently passes
        let result = GasEstimationConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet()),
        );
        
        // This assertion will FAIL with current code (demonstrating the bug)
        assert!(result.is_err(), "full_block_txns = 0 should be rejected");
    }

    #[test]
    fn test_sanitize_edge_case_full_block_txns_one() {
        let node_config = NodeConfig {
            api: ApiConfig {
                gas_estimation: GasEstimationConfig {
                    full_block_txns: 1,
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };

        // Should pass - 1 is technically valid (though poor for estimation)
        assert!(GasEstimationConfig::sanitize(
            &node_config,
            NodeType::Validator,
            None
        ).is_ok());
    }
}
```

To trigger the panic in integration testing, configure an API node with `full_block_txns: 0` and query gas estimation during a period with nil blocks.

## Notes

- Edge case `full_block_txns = 1` is technically valid but results in poor gas estimation (all blocks with â‰¥1 transaction considered full)
- Edge case `full_block_txns = usize::MAX` is valid but renders the "full block" check effectively disabled (no realistic block can reach this size)
- Only `full_block_txns = 0` causes a panic due to the `.unwrap()` on an empty iterator
- The vulnerability requires node operator misconfiguration, not external attack, but the lack of validation violates defensive programming principles
- This breaks the **Resource Limits** invariant by failing to prevent operations that crash the API service

### Citations

**File:** config/src/config/gas_estimation_config.rs (L25-25)
```rust
    pub full_block_txns: usize,
```

**File:** config/src/config/gas_estimation_config.rs (L53-95)
```rust
impl ConfigSanitizer for GasEstimationConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let gas_estimation_config = &node_config.api.gas_estimation;

        // Validate aggressive price takes the most history
        if gas_estimation_config.low_block_history > gas_estimation_config.aggressive_block_history
            || gas_estimation_config.market_block_history
                > gas_estimation_config.aggressive_block_history
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "aggressive block history {} must be > low {}, market {}",
                    gas_estimation_config.aggressive_block_history,
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history
                ),
            ));
        }

        if gas_estimation_config.low_block_history == 0
            || gas_estimation_config.market_block_history == 0
            || gas_estimation_config.aggressive_block_history == 0
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "low {}, market {}, aggressive {} block history must be > 0",
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history,
                    gas_estimation_config.aggressive_block_history
                ),
            ));
        }

        Ok(())
    }
}
```

**File:** api/src/context.rs (L1175-1177)
```rust
        if start_version > ledger_version || limit == 0 {
            return Ok((vec![], vec![], None));
        }
```

**File:** api/src/context.rs (L1253-1254)
```rust
                    } else if prices_and_used.len() >= gas_estimation_config.full_block_txns {
                        true
```

**File:** api/src/context.rs (L1267-1276)
```rust
                if is_full_block {
                    Some(
                        self.next_bucket(
                            prices_and_used
                                .iter()
                                .map(|(price, _)| *price)
                                .min()
                                .unwrap(),
                        ),
                    )
```

**File:** testsuite/smoke-test/src/rest_api.rs (L194-194)
```rust
            conf.api.gas_estimation.full_block_txns = max_block_txns as usize;
```
