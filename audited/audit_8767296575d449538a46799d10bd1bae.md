# Audit Report

## Title
Resource Group Validation Allows Forged StructTag Type Arguments Leading to Type System Violation and State Fragmentation

## Summary
The resource group validation in the Aptos VM verifier only validates the struct name when checking resource_group_member metadata, but does not verify that the StructTag's type arguments match the actual struct definition. This allows attackers to forge metadata with invalid type arguments, bypassing Move's type system and causing resource group fragmentation.

## Finding Description

When a module declares a struct as a `resource_group_member`, the container is specified as a StructTag in the module's metadata. During module publishing, the validation process extracts this StructTag and validates it in `validate_resource_groups()`. [1](#0-0) 

The critical flaw occurs at the validation step where only the struct **name** is checked: [2](#0-1) 

The StructTag structure includes a `type_args` field that is never validated against the actual struct definition: [3](#0-2) 

An attacker can exploit this by:

1. Compiling a module normally with a valid `#[resource_group_member]` attribute
2. Modifying the compiled bytecode to change the metadata string (e.g., from `0x1::object::ObjectGroup` to `0x1::object::ObjectGroup<u8>`)
3. Publishing the modified module

The metadata parsing simply converts the string to a StructTag without validation: [4](#0-3) 

At runtime, when accessing resources, the system uses the forged StructTag to create storage keys: [5](#0-4) 

This creates a StateKey for `ObjectGroup<u8>` which is distinct from the legitimate `ObjectGroup`, causing resources to be stored at incorrect locations and violating Move's type system, since ObjectGroup is defined without type parameters: [6](#0-5) 

## Impact Explanation

This is a **Medium Severity** vulnerability based on Aptos bug bounty criteria:

1. **State Inconsistencies**: Creates multiple resource group instances per address (e.g., `ObjectGroup`, `ObjectGroup<u8>`, `ObjectGroup<bool>`), fragmenting state across different storage locations.

2. **Type System Violation**: Allows instantiation of structs with incorrect type arguments, breaking Move's core type safety guarantees. A struct defined without type parameters can be instantiated with arbitrary type arguments through metadata forgery.

3. **Storage Fragmentation**: Resources that should be grouped together are split across multiple storage locations, affecting storage organization and potentially gas accounting models.

While this does not directly cause fund loss or consensus breaks, it creates state inconsistencies requiring manual intervention and violates fundamental type system invariants that are critical to Move's security model. This aligns with the Medium severity category: "State inconsistencies requiring manual intervention."

## Likelihood Explanation

**Likelihood: Medium**

The attack is feasible for moderately skilled attackers who can:
- Compile Move code using the standard compiler
- Parse and modify BCS-serialized metadata in compiled bytecode
- Reserialize and publish the modified module through standard APIs

Key factors:
- **No special permissions required**: Any user can publish modules
- **Moderate technical difficulty**: Requires bytecode manipulation but no deep system access
- **Deterministic**: Once bytecode is correctly modified, the attack succeeds reliably
- **Affects global resources**: Global-scope groups like ObjectGroup are particularly vulnerable
- **Validation bypass**: The current validation only checks struct names, not type arguments

The compilation-time checks ensure valid modules produce correct metadata, but post-compilation modification bypasses these safeguards: [7](#0-6) 

## Recommendation

Add validation in `validate_resource_groups()` to verify that the StructTag's type arguments match the actual struct definition:

1. After extracting the group StructTag, retrieve the struct definition from the module
2. Compare the number of type arguments in the StructTag with the struct's type parameter count
3. Reject if they don't match

The validation should occur after line 91 in `resource_groups.rs`, checking that `group_tag.type_args.len()` equals the actual type parameter count of the referenced struct.

Additionally, consider adding a check in `verify_module_metadata_for_module_publishing()` to validate that all StructTag references in metadata have type arguments matching their struct definitions.

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the validation gap
// In validate_resource_groups(), line 91 only checks:
// inner_group.get(group_tag.name.as_ident_str().as_str())
// 
// But group_tag is a StructTag with potentially forged type_args:
// pub struct StructTag {
//     pub address: AccountAddress,
//     pub module: Identifier,
//     pub name: Identifier,
//     pub type_args: Vec<TypeTag>,  // <- Never validated!
// }
//
// Attack flow:
// 1. Compile module with: #[resource_group_member(group = 0x1::object::ObjectGroup)]
// 2. Modify bytecode metadata: "0x1::object::ObjectGroup" â†’ "0x1::object::ObjectGroup<u8>"
// 3. Publish module (passes validation because only "ObjectGroup" name is checked)
// 4. Runtime creates StateKey using forged StructTag with type_args = [U8]
// 5. Resources stored at wrong location, fragmenting ObjectGroup
```

## Notes

This vulnerability exploits the trust boundary between compile-time validation (which checks struct definitions) and runtime validation (which only checks metadata strings). The metadata parsing trusts that type arguments are valid without cross-referencing the actual struct definition. While compilation-time checks in `extended_checks.rs` prevent developers from accidentally creating invalid metadata, they don't prevent malicious post-compilation modification of the serialized bytecode.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L36-104)
```rust
pub(crate) fn validate_resource_groups(
    features: &Features,
    module_storage: &impl ModuleStorage,
    traversal_context: &mut TraversalContext,
    gas_meter: &mut impl GasMeter,
    new_modules: &[CompiledModule],
) -> Result<(), VMError> {
    let mut groups = BTreeMap::new();
    let mut members = BTreeMap::new();

    for new_module in new_modules {
        let (new_groups, new_members) = validate_module_and_extract_new_entries(
            module_storage,
            new_module,
            features,
            traversal_context,
        )?;
        groups.insert(new_module.self_id(), new_groups);
        members.insert(new_module.self_id(), new_members);
    }

    for (module_id, inner_members) in members {
        for group_tag in inner_members.values() {
            let group_module_id = group_tag.module_id();
            if !groups.contains_key(&group_module_id) {
                // Note: module must exist for the group member to refer to it! Also, we need to
                // charge gas because this module is not in a bundle.
                if features.is_lazy_loading_enabled()
                    && traversal_context.visit_if_not_special_module_id(&group_module_id)
                {
                    let size = module_storage.unmetered_get_existing_module_size(
                        group_module_id.address(),
                        group_module_id.name(),
                    )?;
                    gas_meter
                        .charge_dependency(
                            DependencyKind::Existing,
                            group_module_id.address(),
                            group_module_id.name(),
                            NumBytes::new(size as u64),
                        )
                        .map_err(|err| err.finish(Location::Undefined))?;
                }
                let old_module = module_storage.unmetered_get_existing_deserialized_module(
                    group_module_id.address(),
                    group_module_id.name(),
                )?;

                let (inner_groups, _, _) =
                    extract_resource_group_metadata_from_module(&old_module)?;
                groups.insert(group_tag.module_id(), inner_groups);
            }

            let scope = if let Some(inner_group) = groups.get(&group_module_id) {
                inner_group
                    .get(group_tag.name.as_ident_str().as_str())
                    .ok_or_else(|| metadata_validation_error("Invalid resource_group attribute"))?
            } else {
                return Err(metadata_validation_error("No such resource_group"));
            };

            if !scope.are_equal_module_ids(&module_id, &group_module_id) {
                metadata_validation_err("Scope mismatch")?;
            }
        }
    }

    Ok(())
}
```

**File:** third_party/move/move-core/types/src/language_storage.rs (L216-223)
```rust
pub struct StructTag {
    pub address: AccountAddress,
    pub module: Identifier,
    pub name: Identifier,
    // alias for compatibility with old json serialized data.
    #[serde(rename = "type_args", alias = "type_params")]
    pub type_args: Vec<TypeTag>,
}
```

**File:** types/src/vm/module_metadata.rs (L138-144)
```rust
    pub fn get_resource_group_member(&self) -> Option<StructTag> {
        if self.kind == KnownAttributeKind::ResourceGroupMember as u8 {
            self.args.first()?.parse().ok()
        } else {
            None
        }
    }
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L105-107)
```rust
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L121-123)
```text
    #[resource_group(scope = global)]
    /// A shared resource group for storing object resources together in storage.
    struct ObjectGroup {}
```

**File:** aptos-move/framework/src/extended_checks.rs (L449-455)
```rust
        if !struct_.get_type_parameters().is_empty() {
            self.env.error(
                &struct_.get_loc(),
                "resource_group should not have type parameters",
            );
            return None;
        }
```
