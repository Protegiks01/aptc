# Audit Report

## Title
Indexer Fails to Detect Critical Pool Accounting Invariant Violation Leading to Potential Fund Theft Masking

## Summary
The indexer code in `delegator_pools.rs` does not validate a critical invariant: when `total_coins > 0`, `total_shares` must also be `> 0`. This state represents on-chain corruption that could enable fund theft, but the indexer silently accepts and records it, preventing early detection of accounting errors that violate the pool's fundamental invariants.

## Finding Description

The indexer function `get_inactive_pool_metadata_from_write_table_item()` reads pool state from on-chain data without validating the fundamental invariant that `total_coins` and `total_shares` must be consistent. [1](#0-0) 

The underlying Move implementation explicitly handles the case where either field is zero: [2](#0-1) 

When `total_shares == 0`, the `amount_to_shares` function treats the pool as empty, returning `coins_amount * scaling_factor` regardless of `total_coins`. This creates a severe vulnerability:

**Exploitation Scenario if Corrupted State Exists:**
1. Pool state becomes corrupted: `(total_coins=1000, total_shares=0)` due to synchronization bug
2. Next delegator calls unlock with 100 coins
3. `amount_to_shares` returns `100 * scaling_factor` (treating pool as empty)
4. Pool becomes `(1100, 100*scaling_factor)`
5. Delegator redeems their shares and receives all 1100 coins
6. **Result: 1000 coins stolen from the pool** [3](#0-2) 

The delegation pool synchronization logic uses `update_total_coins` to reflect rewards: [4](#0-3) 

If `pending_inactive - commission_pending_inactive` is non-zero when the pool has zero shares (due to accounting bugs or edge cases during lockup cycle transitions), this creates the exploitable corrupted state. [5](#0-4) 

## Impact Explanation

**Primary Impact: Critical Vulnerability Masking (Medium Severity)**
- The indexer failing to detect and alert on this invariant violation allows corrupted state to persist unnoticed
- Applications and users relying on indexer data would see incorrect pool balances
- Early detection could prevent exploitation before the corrupted state is leveraged

**Secondary Impact: If Corruption Exists (Critical Severity)**
- Direct fund theft through the exploitation path described above
- Violates **Staking Security** invariant: "Validator rewards and penalties must be calculated correctly"
- Breaks pool accounting, enabling theft of rewards/principal from other delegators

However, the indexer code itself is OFF-CHAIN infrastructure and does not directly cause the corruption. The severity is Medium for the indexer's lack of validation, though the underlying on-chain state corruption (if achievable) would be Critical.

## Likelihood Explanation

**Likelihood: Low to Medium**
- The corrupted state should NOT occur in normal pool operations
- Would require a bug in delegation pool synchronization logic or edge case during lockup transitions
- The delegation pool uses resource accounts, preventing external manipulation
- However, complex synchronization logic with multiple pools and lockup cycles increases bug surface area
- If the state can be created (even inadvertently through bugs), exploitation is straightforward

The indexer not detecting this acts as a **missing safety net** rather than the root cause.

## Recommendation

Add invariant validation in the indexer code:

```rust
pub fn get_inactive_pool_metadata_from_write_table_item(
    write_table_item: &WriteTableItem,
    txn_version: i64,
) -> anyhow::Result<Option<PoolBalanceMetadata>> {
    // ... existing code ...
    
    if let Some(StakeTableItem::Pool(inner)) = StakeTableItem::from_table_item_type(...) {
        let total_coins = inner.total_coins;
        let total_shares = &inner.total_shares / &inner.scaling_factor;
        
        // VALIDATION: Detect invariant violation
        if (total_coins > BigDecimal::from(0) && total_shares == BigDecimal::from(0)) ||
           (total_coins == BigDecimal::from(0) && total_shares > BigDecimal::from(0)) {
            anyhow::bail!(
                "CRITICAL: Pool invariant violation at txn {}: total_coins={} but total_shares={}. \
                 This indicates state corruption that could enable fund theft.",
                txn_version, total_coins, total_shares
            );
        }
        
        Ok(Some(PoolBalanceMetadata {
            // ... rest of struct ...
        }))
    } else {
        Ok(None)
    }
}
```

Additionally, the on-chain Move code should add defensive checks in `update_total_coins`:

```move
public fun update_total_coins(self: &mut Pool, new_total_coins: u64) {
    // Invariant: If setting total_coins > 0, must have total_shares > 0
    assert!(
        new_total_coins == 0 || self.total_shares > 0,
        error::invalid_state(EPOOL_ACCOUNTING_CORRUPTION)
    );
    self.total_coins = new_total_coins;
}
```

## Proof of Concept

Due to the off-chain nature of the indexer, I cannot provide a complete PoC that creates the corrupted state. However, the exploitation path IF corruption exists can be demonstrated:

```move
#[test(delegator = @0x123, pool_owner = @0x456)]
fun test_exploit_corrupted_pool_state(delegator: &signer, pool_owner: &signer) {
    // Assume corrupted state exists: pool has 1000 coins but 0 shares
    // This simulates what would happen if synchronization bug creates this state
    
    let pool = create_pool_with_corrupted_state(1000, 0); // Hypothetical helper
    
    // Attacker unlocks 100 coins
    let new_shares = pool_u64::amount_to_shares(&pool, 100);
    // new_shares = 100 * scaling_factor (treats pool as empty!)
    
    pool_u64::buy_in(&mut pool, signer::address_of(delegator), 100);
    // Pool now: total_coins=1100, total_shares=100*scaling_factor
    
    // Attacker redeems all their shares
    let redeemed = pool_u64::redeem_shares(&mut pool, signer::address_of(delegator), new_shares);
    
    // Attacker receives ALL 1100 coins despite only depositing 100
    assert!(redeemed == 1100, 0); // THEFT: 1000 coins stolen
}
```

The actual vulnerability requires demonstrating how the corrupted state can be created through delegation pool synchronization, which I cannot definitively prove without deeper analysis of all edge cases.

## Notes

This finding highlights that the state `(total_coins > 0, total_shares = 0)` represents **CORRUPTION**, not valid state. While the indexer's lack of validation is a data integrity issue (Medium severity), the underlying ability to create this state on-chain would be Critical severity. The indexer should serve as a detection layer for such invariant violations to enable early intervention before exploitation.

### Citations

**File:** crates/indexer/src/models/stake_models/delegator_pools.rs (L159-160)
```rust
            let total_coins = inner.total_coins;
            let total_shares = &inner.total_shares / &inner.scaling_factor;
```

**File:** aptos-move/framework/aptos-stdlib/sources/pool_u64_unbound.move (L211-223)
```text
    public fun amount_to_shares_with_total_coins(self: &Pool, coins_amount: u64, total_coins: u64): u128 {
        // No shares yet so amount is worth the same number of shares.
        if (self.total_coins == 0 || self.total_shares == 0) {
            // Multiply by scaling factor to minimize rounding errors during internal calculations for buy ins/redeems.
            // This can overflow but scaling factor is expected to be chosen carefully so this would not overflow.
            (coins_amount as u128) * (self.scaling_factor as u128)
        } else {
            // Shares price = total_coins / total existing shares.
            // New number of shares = new_amount / shares_price = new_amount * existing_shares / total_amount.
            // We rearrange the calc and do multiplication first to avoid rounding errors.
            self.multiply_then_divide(coins_amount as u128, self.total_shares, total_coins as u128)
        }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/pool_u64_unbound.move (L233-243)
```text
    public fun shares_to_amount_with_total_coins(self: &Pool, shares: u128, total_coins: u64): u64 {
        // No shares or coins yet so shares are worthless.
        if (self.total_coins == 0 || self.total_shares == 0) {
            0
        } else {
            // Shares price = total_coins / total existing shares.
            // Shares worth = shares * shares price = shares * total_coins / total existing shares.
            // We rearrange the calc and do multiplication first to avoid rounding errors.
            (self.multiply_then_divide(shares, total_coins as u128, self.total_shares) as u64)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L2079-2084)
```text
        pool_u64::update_total_coins(&mut pool.active_shares, active - commission_active);
        // update total coins accumulated by `pending_inactive` shares at current observed lockup cycle
        pool_u64::update_total_coins(
            pending_inactive_shares_pool_mut(pool),
            pending_inactive - commission_pending_inactive
        );
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L2122-2126)
```text
            table::add(
                &mut pool.inactive_shares,
                pool.observed_lockup_cycle,
                pool_u64::create_with_scaling_factor(SHARES_SCALING_FACTOR)
            );
```
