# Audit Report

## Title
Network Partition via Lack of Forward Compatibility in PersistedAuxiliaryInfo Enum Evolution

## Summary
The `PersistedAuxiliaryInfo` enum lacks forward compatibility mechanisms for adding new variants. When governance activates a new `persisted_auxiliary_info_version` before all validators upgrade their code, non-upgraded validators become permanently unable to execute blocks or sync state, causing an irrecoverable network partition.

## Finding Description

The `PersistedAuxiliaryInfo` enum is serialized using BCS and stored in the database keyed by transaction version. [1](#0-0) 

The enum currently has three variants: `None`, `V1`, and `TimestampNotYetAssignedV1`. [2](#0-1) 

The variant used during block execution is controlled by the on-chain `persisted_auxiliary_info_version` parameter which can be modified through governance. [3](#0-2) 

During block execution, the execution code creates auxiliary info variants based on this version parameter. For unsupported versions, the code explicitly calls `unimplemented!()` causing a panic. [4](#0-3) 

The auxiliary info is hashed and included in `TransactionInfo`, affecting the transaction accumulator root. [5](#0-4) 

**Attack Scenario:**

1. Governance upgrades `OnChainExecutionConfig` to set `persisted_auxiliary_info_version = 2`
2. Some validators upgrade code to support hypothetical V2 variant, others remain on old code
3. At epoch boundary, all validators read the new config with version=2
4. **Non-upgraded validators cannot execute**: They hit `unimplemented!()` and panic when attempting to execute any blocks
5. **Non-upgraded validators cannot sync**: When attempting state synchronization from upgraded validators, BCS deserialization fails when encountering V2 variants (unknown enum index), propagating errors through the multizip iterator. [6](#0-5) 
6. **Network partition**: Non-upgraded validators are completely unable to operate (cannot execute or sync), while upgraded validators continue if they form >2/3 majority

## Impact Explanation

**Critical Severity** - This vulnerability meets Critical severity criteria:

1. **Non-Recoverable Network Partition**: Non-upgraded validators cannot deserialize V2 entries from storage and cannot sync state from upgraded validators. The network permanently splits into incompatible validator cohorts. Recovery requires emergency intervention (hardfork or forced validator upgrades) beyond normal protocol recovery mechanisms. This matches the Aptos bug bounty criterion: "Network split requiring hardfork to resolve."

2. **Total Loss of Liveness**: If >1/3 of validators fail to upgrade before the governance proposal takes effect, the network loses its BFT quorum and cannot make progress. This matches the criterion: "Network halts due to protocol bug; All validators unable to progress."

The vulnerability does NOT constitute a traditional consensus safety violation (different validators producing different valid state roots for the same input), but rather a liveness and availability failure where a subset of validators becomes permanently unable to participate.

## Likelihood Explanation

**High Likelihood** during version upgrades:

- **Trigger Condition**: Requires governance proposal to increment `persisted_auxiliary_info_version` combined with incomplete validator code deployment
- **Realistic Scenario**: This is a standard upgrade procedure risk - not an active exploit but a protocol design gap that manifests during normal operations
- **No Attack Required**: Triggered by coordination failure during legitimate upgrades
- **No Protection Mechanism**: The codebase has no safeguards preventing governance from activating a version before all validators support it

The vulnerability becomes exploitable whenever:
1. Development adds a new `PersistedAuxiliaryInfo` variant
2. Governance votes to enable it via config change  
3. Validator upgrade coordination is imperfect (inevitable in decentralized networks)

## Recommendation

Implement forward compatibility mechanisms:

1. **Version Gating**: Add on-chain checks that prevent `persisted_auxiliary_info_version` from being incremented until a minimum percentage of validators signal support for the new version
2. **Graceful Degradation**: Replace `unimplemented!()` with graceful handling that allows validators to continue operating in read-only or sync mode
3. **Unknown Variant Handling**: Consider using a versioned serialization format that allows old validators to skip unknown fields rather than failing deserialization
4. **Coordination Period**: Implement a mandatory waiting period between governance approval and activation, ensuring validators have time to upgrade

## Proof of Concept

The vulnerability can be demonstrated through the following sequence:

1. Deploy a governance proposal that sets `persisted_auxiliary_info_version = 2` in `OnChainExecutionConfig`
2. Ensure some validators upgrade to code supporting V2 variant while others remain on current code
3. Observe that upon epoch transition:
   - Non-upgraded validators panic at the `unimplemented!()` when attempting block execution
   - Non-upgraded validators attempting to sync encounter BCS deserialization errors
   - Network partitions if upgraded validators achieve >2/3 majority

Due to the nature of this vulnerability requiring governance actions and network-wide validator behavior, a complete executable PoC would require a full testnet setup with multiple validator nodes and governance simulation, which is beyond the scope of a code-level proof of concept.

## Notes

While the original report described this as "consensus divergence" where different cohorts compute different state roots, the actual mechanism is different: non-upgraded validators cannot operate at all (they panic during execution and fail during sync). This is a liveness failure rather than a safety violation, but it still meets Critical severity criteria through "Non-Recoverable Network Partition" and "Total Loss of Liveness" categories.

### Citations

**File:** storage/aptosdb/src/schema/persisted_auxiliary_info/mod.rs (L44-50)
```rust
    fn encode_value(&self) -> Result<Vec<u8>> {
        bcs::to_bytes(self).map_err(Into::into)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        bcs::from_bytes(data).map_err(Into::into)
    }
```

**File:** types/src/transaction/mod.rs (L3307-3318)
```rust
pub enum PersistedAuxiliaryInfo {
    None,
    // The index of the transaction in a block (after shuffler, before execution).
    // Note that this would be slightly different from the index of transactions that get committed
    // onchain, as this considers transactions that may get discarded.
    V1 { transaction_index: u32 },
    // When we are doing a simulation or validation of transactions, the transaction is not executed
    // within the context of a block. The timestamp is not yet assigned, but we still track the
    // transaction index for multi-transaction simulations. For single transaction simulation or
    // validation, the transaction index is set to 0.
    TimestampNotYetAssignedV1 { transaction_index: u32 },
}
```

**File:** types/src/on_chain_config/execution_config.rs (L86-97)
```rust
    pub fn persisted_auxiliary_info_version(&self) -> u8 {
        match self {
            OnChainExecutionConfig::Missing
            | OnChainExecutionConfig::V1(_)
            | OnChainExecutionConfig::V2(_)
            | OnChainExecutionConfig::V3(_)
            | OnChainExecutionConfig::V4(_)
            | OnChainExecutionConfig::V5(_)
            | OnChainExecutionConfig::V6(_) => 0,
            OnChainExecutionConfig::V7(config) => config.persisted_auxiliary_info_version,
        }
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L835-841)
```rust
                let persisted_auxiliary_info = match persisted_auxiliary_info_version {
                    0 => PersistedAuxiliaryInfo::None,
                    1 => PersistedAuxiliaryInfo::V1 {
                        transaction_index: txn_index as u32,
                    },
                    _ => unimplemented!("Unsupported persisted auxiliary info version"),
                };
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L61-67)
```rust
                let auxiliary_info_hash = match persisted_auxiliary_info {
                    PersistedAuxiliaryInfo::None => None,
                    PersistedAuxiliaryInfo::V1 { .. } => {
                        Some(CryptoHash::hash(persisted_auxiliary_info))
                    },
                    PersistedAuxiliaryInfo::TimestampNotYetAssignedV1 { .. } => None,
                };
```

**File:** state-sync/storage-service/server/src/storage.rs (L451-456)
```rust
                Some((Err(error), _, _, _))
                | Some((_, Err(error), _, _))
                | Some((_, _, Err(error), _))
                | Some((_, _, _, Err(error))) => {
                    return Err(Error::StorageErrorEncountered(error.to_string()));
                },
```
