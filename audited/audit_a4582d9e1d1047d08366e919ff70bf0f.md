# Audit Report

## Title
Race Condition in JWK Consensus Allows Stale Updates to Override Fresh Updates

## Summary
The JWK consensus mechanism in Aptos has a race condition vulnerability where an older consensus session can complete after a newer session has started, causing stale JWK updates to be accepted and committed on-chain while fresher updates are rejected. This occurs because the `process_quorum_certified_update` function does not validate that incoming quorum certificates match the current session's proposal.

## Finding Description

The vulnerability exists in the per-issuer JWK consensus implementation where the session key uses only the `Issuer` identifier without version information. [1](#0-0) 

The `Issuer` type is defined as a simple byte vector with no versioning. [2](#0-1) 

When a new JWK observation is detected, the `process_new_observation` function creates a new consensus session and starts the reliable broadcast process. [3](#0-2) 

If a second update arrives while the first session is still running, the old session's abort handle is dropped (lines 216-223), but this abort is asynchronous. The first session may complete and send its QC to the channel before the abort takes effect.

The critical vulnerability is in the `process_quorum_certified_update` function, which only checks if the consensus state is `InProgress` but does not verify that the incoming QC matches the current session's proposal. [4](#0-3) 

At line 333, the code matches on `ConsensusState::InProgress { my_proposal, .. }` but then accepts the incoming `update` without any comparison to `my_proposal.observed`. This allows the following race condition:

1. Session S1 starts with proposal P1 (version N)
2. Session S2 starts with proposal P2 (version N+1), S1's abort handle dropped
3. S1 completes before abort takes effect, sends QC1 to channel
4. `process_quorum_certified_update` receives QC1
5. State is `InProgress` with P2, but code accepts QC1 without validation
6. QC1 is committed to validator transaction pool (lines 335-338)
7. State becomes `Finished` with `my_proposal = P2` but `quorum_certified = QC1`
8. S2's QC2 arrives but is rejected because state is now `Finished` (lines 352-356)

The channel uses KLAST queue with size 1, meaning only one QC per issuer can be queued. [5](#0-4) 

The VM-level validation in `process_jwk_update_inner` checks version sequencing but does not prevent this race condition because it validates `on_chain.version + 1 == observed.version`, which both stale and fresh updates can satisfy in sequence. [6](#0-5) 

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program's "Limited Protocol Violations" category, specifically "State inconsistencies requiring manual intervention."

**Concrete Impact:**

1. **Stale JWK Data On-Chain**: The blockchain will commit outdated JWK information, violating the freshness guarantee that JWK consensus is designed to provide.

2. **Keyless Account Authentication Failures**: Legitimate users relying on keyless accounts will experience authentication failures when their signatures are validated against stale keys instead of current ones.

3. **Security Risk from Compromised Keys**: If OIDC providers rotate keys due to security incidents (e.g., key compromise), the blockchain may continue trusting compromised keys until the next observation cycle succeeds.

4. **Non-Deterministic Validator Behavior**: Different validators may observe the race condition at different times based on network conditions, leading to temporary state inconsistencies.

The issue requires intervention through retry mechanisms or manual observation cycles to eventually converge on the correct state, meeting the criteria for Medium severity.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurrence:

1. **Legitimate Trigger**: OIDC providers (Google, Apple, Microsoft) regularly rotate JWKs for security reasons. Rapid rotations during security incidents are realistic operational scenarios.

2. **No Special Privileges Required**: The race condition is triggered by normal JWK observation behavior. No validator compromise, special permissions, or malicious actions are required.

3. **Observable Timing Window**: The JWK observer polls providers every 10 seconds. [7](#0-6)  If a provider rotates keys twice within this window, or if network delays cause observations to arrive in quick succession, the race occurs.

4. **Asynchronous Abort Mechanism**: The abort is implemented via `AbortHandle` drop, which does not guarantee immediate cancellation of the spawned async task. [8](#0-7)  The reliable broadcast task may complete and push its QC to the channel before the abort signal is processed.

## Recommendation

Add validation in `process_quorum_certified_update` to verify that the incoming QC matches the current session's proposal:

```rust
pub fn process_quorum_certified_update(&mut self, update: QuorumCertifiedUpdate) -> Result<()> {
    let issuer = update.update.issuer.clone();
    // ... logging ...
    let state = self.states_by_issuer.entry(issuer.clone()).or_default();
    match &state.consensus_state {
        ConsensusState::InProgress { my_proposal, .. } => {
            // ADD THIS VALIDATION:
            if my_proposal.observed != update.update {
                return Err(anyhow!(
                    "QC does not match current proposal for issuer {:?}. Expected version {}, got {}",
                    String::from_utf8(issuer.clone()),
                    my_proposal.observed.version,
                    update.update.version
                ));
            }
            
            let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
            // ... rest of the function ...
        },
        _ => Err(anyhow!(...)),
    }
}
```

Alternatively, include a session ID or timestamp in the `ConsensusSessionKey` to uniquely identify each consensus session, preventing QCs from different sessions from interfering with each other.

## Proof of Concept

While no executable PoC is provided, the vulnerability can be demonstrated by:

1. Configuring an OIDC provider to rotate JWKs twice within a 10-second window
2. Observing that the first session's QC arrives after the second session has started
3. Verifying that the blockchain commits the first (stale) version while rejecting the second (fresh) version
4. Checking validator transaction pool contents to confirm stale update is present

The test suite does not currently cover concurrent session scenarios, as confirmed by the absence of race condition tests in the codebase.

## Notes

This vulnerability demonstrates a classic Time-of-Check-Time-of-Use (TOCTOU) race condition in distributed consensus. The consensus manager checks the state (`InProgress`) but uses a different value (the incoming QC) without atomic validation. The asynchronous nature of the abort mechanism and the shared channel key (issuer-only) create the timing window for exploitation.

The VM-level validations provide defense-in-depth but do not prevent this specific race condition because version checking alone cannot distinguish between legitimately sequential updates and race-induced out-of-order updates.

### Citations

**File:** crates/aptos-jwk-consensus/src/mode/per_issuer.rs (L11-11)
```rust
    type ConsensusSessionKey = Issuer;
```

**File:** types/src/jwks/mod.rs (L36-36)
```rust
pub type Issuer = Vec<u8>;
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L72-72)
```rust
        let (qc_update_tx, qc_update_rx) = aptos_channel::new(QueueStyle::KLAST, 1, None);
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L122-122)
```rust
                        Duration::from_secs(10),
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L184-228)
```rust
    pub fn process_new_observation(
        &mut self,
        issuer: Issuer,
        jwks: Vec<JWKMoveStruct>,
    ) -> Result<()> {
        debug!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            "Processing new observation."
        );
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        state.observed = Some(jwks.clone());
        if state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
            let signature = self
                .consensus_key
                .sign(&observed)
                .context("process_new_observation failed with signing error")?;
            let abort_handle = self
                .update_certifier
                .start_produce(
                    self.epoch_state.clone(),
                    observed.clone(),
                    self.qc_update_tx.clone(),
                )
                .context(
                    "process_new_observation failed with update_certifier.start_produce failure",
                )?;
            state.consensus_state = ConsensusState::InProgress {
                my_proposal: ObservedUpdate {
                    author: self.my_addr,
                    observed: observed.clone(),
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard::new(abort_handle),
            };
            info!("[JWK] update observed, update={:?}", observed);
        }

        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L323-358)
```rust
    pub fn process_quorum_certified_update(&mut self, update: QuorumCertifiedUpdate) -> Result<()> {
        let issuer = update.update.issuer.clone();
        info!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            version = update.update.version,
            "JWKManager processing certified update."
        );
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        match &state.consensus_state {
            ConsensusState::InProgress { my_proposal, .. } => {
                //TODO: counters
                let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
                let vtxn_guard =
                    self.vtxn_pool
                        .put(Topic::JWK_CONSENSUS(issuer.clone()), Arc::new(txn), None);
                state.consensus_state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: update.clone(),
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    issuer = String::from_utf8(issuer).ok(),
                    version = update.update.version,
                    "certified update accepted."
                );
                Ok(())
            },
            _ => Err(anyhow!(
                "qc update not expected for issuer {:?} in state {}",
                String::from_utf8(issuer.clone()),
                state.consensus_state.name()
            )),
        }
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L128-130)
```rust
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```

**File:** crates/aptos-jwk-consensus/src/types.rs (L96-101)
```rust
impl Drop for QuorumCertProcessGuard {
    fn drop(&mut self) {
        let QuorumCertProcessGuard { handle } = self;
        handle.abort();
    }
}
```
