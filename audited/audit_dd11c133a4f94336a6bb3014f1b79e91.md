# Audit Report

## Title
Missing Derivation Path Validation Allows Use of Non-Aptos Coin Types in Hardware Wallet Operations

## Summary
The `validate_derivation_path()` function exists and properly validates that the coin type is 637 (Aptos), but this validation is bypassed when users provide custom derivation paths via the `--derivation-path` CLI argument or config file. This allows users to inadvertently use derivation paths for other cryptocurrencies (e.g., `m/44'/999'/0'/0'/0'`), violating BIP44 standards and potentially leading to key reuse across blockchains. [1](#0-0) 

## Finding Description
The Aptos codebase defines a proper validation function that checks derivation paths start with the correct prefix `m/44'/637'/`. However, this validation is not called in the critical path where users specify custom derivation paths.

When users provide a custom derivation path through the `--derivation-path` argument, the `extract_derivation_path()` function returns it without any validation: [2](#0-1) 

This unvalidated path is then used directly in hardware wallet operations: [3](#0-2) [4](#0-3) [5](#0-4) 

The validation function is only called in one location, and only for auto-generated paths using `--derivation-index`: [6](#0-5) 

**Attack Scenarios:**
1. **CLI-based**: User runs `aptos account rotate-key --new-derivation-path "m/44'/60'/0'/0'/0'"` (Ethereum coin type)
2. **Config-based**: User manually edits `.aptos/config.yaml` to set `derivation_path: "m/44'/0'/0'/0'/0'"` (Bitcoin coin type)

The malicious or incorrect derivation path propagates through to the Ledger device without validation, potentially causing users to:
- Derive Ethereum or Bitcoin keys for Aptos transactions
- Reuse keys across different blockchain networks
- Violate BIP44 coin type separation standards

## Impact Explanation
This is a **Low severity** issue per the Aptos bug bounty criteria because:

1. **Limited Direct Impact**: While users can provide incorrect derivation paths, the Ledger device displays the derivation path for user approval, providing a secondary safeguard
2. **No Consensus Impact**: This is a client-side validation issue that doesn't affect consensus, state management, or validator operations
3. **User Error Protection**: The primary impact is lack of user protection against accidental misuse rather than an exploitable security vulnerability
4. **BIP44 Standard Violation**: Using the wrong coin type violates cryptocurrency key derivation best practices and could lead to key reuse across chains

This fits the "Non-critical implementation bugs" category in the Low severity tier (up to $1,000).

## Likelihood Explanation
**Likelihood: Medium**

This issue can occur in two realistic scenarios:
1. **User Error**: Users unfamiliar with BIP44 paths might copy derivation paths from other cryptocurrency wallets
2. **Social Engineering**: Attackers could trick users into using specific derivation paths through phishing or malicious tutorials
3. **Config Manipulation**: If an attacker gains access to a user's configuration file, they could modify the derivation path

However, the Ledger device's display of the derivation path provides a safeguard, though users may not understand the security implications of approving an incorrect coin type.

## Recommendation
Add validation in the `extract_derivation_path()` function to ensure all derivation paths use the correct Aptos coin type (637):

```rust
impl HardwareWalletOptions {
    pub fn extract_derivation_path(&self) -> CliTypedResult<Option<String>> {
        if let Some(derivation_path) = &self.derivation_path {
            // Validate the custom derivation path
            if !aptos_ledger::validate_derivation_path(derivation_path) {
                return Err(CliError::CommandArgumentError(
                    format!(
                        "Invalid derivation path '{}'. Must use Aptos coin type 637 (e.g., m/44'/637'/0'/0'/0')",
                        derivation_path
                    )
                ));
            }
            Ok(Some(derivation_path.clone()))
        } else if let Some(derivation_index) = &self.derivation_index {
            let derivation_path = format!("m/44'/637'/{}'/0'/0'", derivation_index);
            Ok(Some(derivation_path))
        } else {
            Ok(None)
        }
    }
}
```

Additionally, validate derivation paths loaded from the config file when they are first retrieved.

## Proof of Concept
```bash
# Step 1: Attempt to use a Bitcoin derivation path (coin type 0)
aptos account rotate-key \
  --new-derivation-path "m/44'/0'/0'/0'/0'" \
  --profile default

# Expected behavior (current): Command proceeds without validation error
# Expected behavior (after fix): Error message about invalid coin type

# Step 2: Manually edit config file
cat > ~/.aptos/config.yaml << EOF
profiles:
  default:
    network: Mainnet
    derivation_path: "m/44'/60'/0'/0'/0'"  # Ethereum coin type
EOF

# Step 3: Try to use the profile
aptos account list --profile default

# Expected behavior (current): Uses Ethereum derivation path
# Expected behavior (after fix): Error on config load or path usage
```

## Notes
This vulnerability exists because the validation function is implemented but not consistently applied across all code paths where derivation paths can be specified. The fix is straightforward - call the existing validation function in `extract_derivation_path()` before returning custom paths. This will ensure BIP44 compliance and prevent cross-chain key reuse, aligning with cryptocurrency security best practices.

### Citations

**File:** crates/aptos-ledger/src/lib.rs (L207-235)
```rust
pub fn validate_derivation_path(input: &str) -> bool {
    let prefix = "m/44'/637'/";
    let suffix = "'";

    if input.starts_with(prefix) && input.ends_with(suffix) {
        let inner_input = &input[prefix.len()..input.len()];

        // Sample: 0'/0'/0'
        let sections: Vec<&str> = inner_input.split('/').collect();
        if sections.len() != 3 {
            return false;
        }

        for section in sections {
            if !section.ends_with(suffix) {
                return false;
            }

            let section_value = &section.trim_end_matches('\'');
            if section_value.parse::<u32>().is_ok() {
                continue;
            }
            return false;
        }

        return true;
    }
    false
}
```

**File:** crates/aptos/src/common/types.rs (L764-773)
```rust
    pub fn extract_derivation_path(&self) -> CliTypedResult<Option<String>> {
        if let Some(derivation_path) = &self.derivation_path {
            Ok(Some(derivation_path.clone()))
        } else if let Some(derivation_index) = &self.derivation_index {
            let derivation_path = format!("m/44'/637'/{}'/0'/0'", derivation_index);
            Ok(Some(derivation_path))
        } else {
            Ok(None)
        }
    }
```

**File:** crates/aptos/src/account/key_rotation.rs (L172-172)
```rust
                aptos_ledger::get_public_key(new_derivation_path.clone().unwrap().as_str(), false)?,
```

**File:** crates/aptos/src/account/key_rotation.rs (L214-216)
```rust
                let challenge_signature = aptos_ledger::sign_message(
                    current_derivation_path.as_str(),
                    &rotation_msg.clone(),
```

**File:** crates/aptos/src/account/key_rotation.rs (L231-233)
```rust
                let challenge_signature = aptos_ledger::sign_message(
                    new_derivation_path.clone().as_str(),
                    &rotation_msg.clone(),
```

**File:** crates/aptos/src/common/init.rs (L191-199)
```rust
            let path = aptos_ledger::DERIVATION_PATH.replace("{index}", input_index);

            // Validate the path
            if !aptos_ledger::validate_derivation_path(&path) {
                return Err(CliError::UnexpectedError(
                    "Invalid index input. Please make sure the input is a valid number index"
                        .to_owned(),
                ));
            }
```
