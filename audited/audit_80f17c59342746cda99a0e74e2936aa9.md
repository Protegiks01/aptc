# Audit Report

## Title
State Corruption via Write Set Deduplication in Native Executor Self-Transfers

## Summary
The native transaction executor's write set accumulation mechanism silently discards earlier writes when multiple operations target the same `StateKey` during a single transaction. This causes state corruption in self-transfer scenarios where the sender and recipient are identical, allowing users to bypass gas fees and create tokens out of thin air.

## Finding Description

The vulnerability exists in how the native executor accumulates and commits write operations during transaction execution. The write set is collected as a `Vec<(StateKey, WriteOp)>` and converted to a `WriteSet` via `WriteSetMut::new()`, which internally uses a `BTreeMap<StateKey, WriteOp>`. [1](#0-0) [2](#0-1) [3](#0-2) 

When the `Vec` is collected into a `BTreeMap`, **only the last value for duplicate keys is retained**, with no proper squashing logic applied within a single transaction.

**Attack Scenario: Self-Transfer**

When `sender == recipient` in a Transfer transaction:

1. **Sequence Number Update** - Updates sender's account: [4](#0-3) 

2. **Withdraw Operation** - Reads sender's store from `state_view`, computes `balance - amount - gas`, pushes write: [5](#0-4) 

3. **Deposit Operation** - Reads recipient's store (same as sender) from `state_view` again (not seeing the withdraw), computes `balance + amount`, pushes write: [6](#0-5) 

Both `withdraw_fa_apt_from_signer` and `deposit_fa_apt` read from `state_view` using `DbAccessUtil::get_resource_group()`, which returns the **original blockchain state**, not any accumulated writes in the current transaction.

When collected into `BTreeMap`, the deposit write (balance + amount) **overwrites** the withdraw write (balance - amount - gas).

**Example:**
- Original balance: 1000 APT
- Transfer amount: 100 APT  
- Gas: 10 APT
- Expected final balance: 1000 - 10 = 990 APT (amount cancels out in self-transfer, only gas paid)
- **Actual final balance: 1000 + 100 = 1100 APT**
- User gains: 110 APT (100 from duplicated amount + 10 from avoided gas)

This breaks the **Deterministic Execution** invariant (#1) and **State Consistency** invariant (#4). If production code had similar patterns, different execution paths could produce different state roots for identical transactions.

## Impact Explanation

**Severity Assessment: Low (Non-Production Impact)**

While the vulnerability demonstrates a critical pattern of state corruption through write set mishandling, this code exists in `execution/executor-benchmark`, which is a **benchmarking tool** used for performance testing, not production consensus execution. [7](#0-6) 

The actual production execution uses the Move VM with proper atomic operations: [8](#0-7) 

**Impact Limitations:**
- No actual blockchain funds at risk
- No production consensus affected
- Does not affect validator operations
- Limited to incorrect benchmark results

However, the pattern is **educationally significant** as it demonstrates how write set ordering assumptions can cause state corruption if similar logic existed in production paths.

## Likelihood Explanation

**In Benchmark Context: High**
- Self-transfers are valid user operations
- No validation prevents `sender == recipient`
- Automatically exploitable when benchmark processes self-transfer transactions

**In Production Context: Not Applicable**
- Production Move VM uses atomic store operations
- The `primary_fungible_store::transfer` implementation creates proper store references that handle self-transfers correctly
- No similar vulnerable pattern identified in production execution paths

## Recommendation

**For the Benchmark Code:**

Implement write set squashing logic before BTreeMap collection to properly handle duplicate StateKey writes:

```rust
fn squash_duplicate_writes(writes: Vec<(StateKey, WriteOp)>) -> Result<Vec<(StateKey, WriteOp)>> {
    let mut map: BTreeMap<StateKey, WriteOp> = BTreeMap::new();
    
    for (key, op) in writes {
        match map.entry(key) {
            btree_map::Entry::Occupied(mut entry) => {
                // Squash with existing write
                if !WriteOp::squash(entry.get_mut(), op)? {
                    entry.remove();
                }
            }
            btree_map::Entry::Vacant(entry) => {
                entry.insert(op);
            }
        }
    }
    
    Ok(map.into_iter().collect())
}
```

Apply this before freezing the WriteSet in `into_success_output()`.

Alternatively, accumulate writes directly into a `BTreeMap` with proper squashing instead of using a `Vec`.

## Proof of Concept

Create a test case in the benchmark suite:

```rust
#[test]
fn test_self_transfer_state_corruption() {
    let sender = AccountAddress::random();
    let initial_balance = 1000u64;
    let transfer_amount = 100u64;
    let gas = 10u64;
    
    // Setup state with sender having initial_balance
    let mut state = setup_test_state(sender, initial_balance);
    
    // Execute self-transfer: sender sends to sender
    let txn = NativeTransaction::Transfer {
        sender,
        sequence_number: 0,
        recipient: sender, // Same as sender!
        amount: transfer_amount,
        fail_on_recipient_account_existing: false,
        fail_on_recipient_account_missing: false,
    };
    
    let output = executor.execute_transaction(txn, &state, &true).unwrap();
    
    // Check final balance from write set
    let final_balance = extract_balance_from_writeset(&output, sender);
    
    // Expected: initial_balance - gas = 990
    // Actual: initial_balance + amount = 1100 (BUG!)
    assert_eq!(final_balance, initial_balance - gas, 
        "Self-transfer should only deduct gas, but got {}", final_balance);
}
```

## Notes

**Critical Context:** This vulnerability exists in benchmarking infrastructure (`executor-benchmark`), not production consensus code. The production Move VM handles transfers atomically through proper store references. While the bug pattern is significant for understanding write set consistency requirements, **it does not present an exploitable security risk to the Aptos blockchain in production**.

The issue serves as an important reminder that state accumulation logic must properly handle duplicate writes through squashing rather than silent last-write-wins semantics, but this specific instance does not meet bug bounty criteria due to its non-production context.

### Citations

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L130-141)
```rust
pub struct IncrementalOutput {
    write_set: Vec<(StateKey, WriteOp)>,
    events: Vec<ContractEvent>,
}

impl IncrementalOutput {
    fn new() -> Self {
        IncrementalOutput {
            write_set: vec![],
            events: vec![],
        }
    }
```

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L143-159)
```rust
    fn into_success_output(mut self, gas: u64) -> Result<TransactionOutput> {
        if gas != 0 {
            self.events.push(
                FeeStatement::new(gas, gas, 0, 0, 0)
                    .create_event_v2()
                    .expect("Creating FeeStatement should always succeed"),
            );
        }

        Ok(TransactionOutput::new(
            WriteSetMut::new(self.write_set).freeze()?,
            self.events,
            /*gas_used=*/ gas,
            TransactionStatus::Keep(ExecutionStatus::Success),
            TransactionAuxiliaryData::default(),
        ))
    }
```

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L359-367)
```rust
                self.update_sequence_number(sender, sequence_number, state_view, &mut output)?;
                self.withdraw_apt_from_signer(
                    fa_migration_complete,
                    sender,
                    amount,
                    gas,
                    state_view,
                    &mut output,
                )?;
```

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L528-566)
```rust
    fn withdraw_fa_apt_from_signer(
        &self,
        sender_address: AccountAddress,
        transfer_amount: u64,
        gas: u64,
        state_view: &(impl StateView + Sync),
        output: &mut IncrementalOutput,
    ) -> Result<()> {
        let sender_store_address = primary_apt_store(sender_address);

        let sender_fa_store_object_key = self
            .db_util
            .new_state_key_object_resource_group(&sender_store_address);
        let mut sender_fa_store_object = {
            let _timer = TIMER.timer_with(&["read_sender_fa_store"]);
            match DbAccessUtil::get_resource_group(&sender_fa_store_object_key, state_view)? {
                Some(sender_fa_store_object) => sender_fa_store_object,
                None => bail!("sender fa store missing"),
            }
        };

        let fungible_store_rg_tag = &self.db_util.common.fungible_store;
        let mut sender_fa_store = bcs::from_bytes::<FungibleStoreResource>(
            &sender_fa_store_object
                .remove(fungible_store_rg_tag)
                .unwrap(),
        )?;

        sender_fa_store.balance -= transfer_amount + gas;

        sender_fa_store_object.insert(
            fungible_store_rg_tag.clone(),
            bcs::to_bytes(&sender_fa_store)?,
        );

        output.write_set.push((
            sender_fa_store_object_key,
            WriteOp::legacy_modification(bcs::to_bytes(&sender_fa_store_object)?.into()),
        ));
```

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L626-677)
```rust
    fn deposit_fa_apt(
        &self,
        recipient_address: AccountAddress,
        transfer_amount: u64,
        state_view: &(impl StateView + Sync),
        output: &mut IncrementalOutput,
    ) -> Result<bool> {
        let recipient_store_address = primary_apt_store(recipient_address);
        let recipient_fa_store_object_key = self
            .db_util
            .new_state_key_object_resource_group(&recipient_store_address);
        let fungible_store_rg_tag = &self.db_util.common.fungible_store;

        let (mut recipient_fa_store, mut recipient_fa_store_object, recipient_fa_store_existed) =
            match DbAccessUtil::get_resource_group(&recipient_fa_store_object_key, state_view)? {
                Some(mut recipient_fa_store_object) => {
                    let recipient_fa_store = bcs::from_bytes::<FungibleStoreResource>(
                        &recipient_fa_store_object
                            .remove(fungible_store_rg_tag)
                            .unwrap(),
                    )?;
                    (recipient_fa_store, recipient_fa_store_object, true)
                },
                None => {
                    let receipeint_fa_store =
                        FungibleStoreResource::new(AccountAddress::TEN, 0, false);
                    let receipeint_fa_store_object = BTreeMap::from([(
                        self.db_util.common.object_core.clone(),
                        bcs::to_bytes(&DbAccessUtil::new_object_core(
                            recipient_store_address,
                            recipient_address,
                        ))?,
                    )]);
                    (receipeint_fa_store, receipeint_fa_store_object, false)
                },
            };

        recipient_fa_store.balance += transfer_amount;

        recipient_fa_store_object.insert(
            fungible_store_rg_tag.clone(),
            bcs::to_bytes(&recipient_fa_store)?,
        );

        output.write_set.push((
            recipient_fa_store_object_key,
            if recipient_fa_store_existed {
                WriteOp::legacy_modification(bcs::to_bytes(&recipient_fa_store_object)?.into())
            } else {
                WriteOp::legacy_creation(bcs::to_bytes(&recipient_fa_store_object)?.into())
            },
        ));
```

**File:** types/src/write_set.rs (L746-756)
```rust
pub struct WriteSetMut {
    // TODO: Change to HashMap with a stable iterator for serialization.
    write_set: BTreeMap<StateKey, WriteOp>,
}

impl WriteSetMut {
    pub fn new(write_ops: impl IntoIterator<Item = (StateKey, WriteOp)>) -> Self {
        Self {
            write_set: write_ops.into_iter().collect(),
        }
    }
```

**File:** execution/executor-benchmark/src/lib.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

mod account_generator;
pub mod block_preparation;
pub mod db_access;
pub mod db_generator;
mod db_reliable_submitter;
mod indexer_grpc_waiter;
mod ledger_update_stage;
pub mod measurements;
mod metrics;
pub mod native;
pub mod pipeline;
pub mod transaction_committer;
pub mod transaction_executor;
pub mod transaction_generator;

use crate::{
    db_access::DbAccessUtil,
    pipeline::Pipeline,
    transaction_committer::TransactionCommitter,
    transaction_executor::TransactionExecutor,
    transaction_generator::{create_block_metadata_transaction, TransactionGenerator},
};
use aptos_api::context::Context;
use aptos_config::config::{
    get_default_processor_task_count, HotStateConfig, NodeConfig, PrunerConfig,
    NO_OP_STORAGE_PRUNER_CONFIG,
};
use aptos_db::AptosDB;
use aptos_db_indexer::{db_ops::open_db, db_v2::IndexerAsyncV2, indexer_reader::IndexerReaders};
use aptos_executor::block_executor::BlockExecutor;
use aptos_indexer_grpc_fullnode::{fullnode_data_service::FullnodeDataService, ServiceContext};
use aptos_indexer_grpc_table_info::table_info_service::TableInfoService;
use aptos_jellyfish_merkle::metrics::{
    APTOS_JELLYFISH_INTERNAL_ENCODED_BYTES, APTOS_JELLYFISH_LEAF_ENCODED_BYTES,
};
use aptos_logger::{info, warn};
use aptos_protos::internal::fullnode::v1::{
    fullnode_data_server::FullnodeData, transactions_from_node_response::Response,
    GetTransactionsFromNodeRequest,
};
use aptos_sdk::types::LocalAccount;
use aptos_storage_interface::{
    state_store::state_view::db_state_view::LatestDbStateCheckpointView, DbReader, DbReaderWriter,
};
use aptos_transaction_generator_lib::{
    create_txn_generator_creator, AlwaysApproveRootAccountHandle, TransactionGeneratorCreator,
    TransactionType::{self, CoinTransfer},
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L220-231)
```text
    public entry fun transfer<T: key>(
        sender: &signer,
        metadata: Object<T>,
        recipient: address,
        amount: u64,
    ) acquires DeriveRefPod {
        let sender_store = ensure_primary_store_exists(signer::address_of(sender), metadata);
        // Check if the sender store object has been burnt or not. If so, unburn it first.
        may_be_unburn(sender, sender_store);
        let recipient_store = ensure_primary_store_exists(recipient, metadata);
        dispatchable_fungible_asset::transfer(sender, sender_store, recipient_store, amount);
    }
```
