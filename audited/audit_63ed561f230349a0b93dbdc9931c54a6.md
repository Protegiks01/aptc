# Audit Report

## Title
Missing Gas Parameter Validation Enables Network-Wide Resource Exhaustion via Governance

## Summary
The gas schedule update mechanism in `aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move` lacks validation for gas parameter values. This allows governance proposals to set critical gas parameters (including `AbstractValueSizeGasParameters`) to zero or extremely low values, enabling free transaction execution and network-wide resource exhaustion. Despite TODO comments acknowledging the need for validation, no checks are implemented in either the Move or Rust layers.

## Finding Description

The vulnerability exists across multiple layers of the gas schedule update system:

**Layer 1: Move Smart Contract (Missing Validation)**

The `gas_schedule::set_for_next_epoch()` function accepts arbitrary gas parameter values without validation: [1](#0-0) 

The function only validates that the blob is non-empty and the feature version is non-decreasing. Critically, it contains an unimplemented TODO comment indicating validation should exist: [2](#0-1) 

**Layer 2: Rust Deserialization (No Validation)**

When validators load gas parameters from on-chain storage, the macro-generated code directly converts values without any range checking: [3](#0-2) 

The conversion uses `.into()` which performs no validation on parameter values.

**Layer 3: Gas Metering (Direct Multiplication)**

The `AbstractValueSizeGasParameters` are used directly in gas calculations throughout the VM. For example, in equality checks: [4](#0-3) 

Similar patterns exist in `charge_neq`, `charge_copy_loc`, and `charge_read_ref`: [5](#0-4) [6](#0-5) 

**Attack Path:**

1. An attacker (or compromised governance) creates a proposal calling `gas_schedule::set_for_next_epoch()` with a malicious gas schedule blob where `AbstractValueSizeGasParameters.u8 = 0`, `u16 = 0`, `u32 = 0`, etc.

2. The proposal passes governance voting (requires >50% voting power).

3. Upon resolution, the malicious gas schedule is buffered via `config_buffer::upsert()`: [7](#0-6) 

4. At the next epoch transition, `on_new_epoch()` applies the malicious schedule: [8](#0-7) 

5. All validators load the zero-valued gas parameters through the macro without validation.

6. Operations like value copying, equality checks, and reference reads now cost zero gas (multiplication by zero).

7. Attackers submit transactions with massive computations, large data structures, and expensive operations that execute for free.

8. Validator nodes exhaust CPU, memory, and I/O resources processing free transactions, causing network-wide DoS.

**Invariant Violations:**

This breaks Critical Invariant #9: **"Resource Limits: All operations must respect gas, storage, and computational limits"**

When abstract value size parameters are zero, operations no longer respect gas limits because:
- `charge_eq` cost = `EQ_BASE + EQ_PER_ABS_VAL_UNIT * 0 = EQ_BASE` (missing per-value cost)
- `charge_copy_loc` cost = base cost only (missing heap size cost)
- Large vectors, structs, and nested data become nearly free to process

## Impact Explanation

**Severity: Critical** (per Aptos Bug Bounty criteria)

This vulnerability enables:

1. **Total Loss of Network Availability**: All validators can be overwhelmed simultaneously by free computation attacks, causing complete network liveness failure. This meets the Critical severity criterion of "Total loss of liveness/network availability."

2. **Non-Recoverable State**: Once the malicious gas schedule is applied, it persists until a new governance proposal passes AND a new epoch occurs. During this window, the network is vulnerable to continuous DoS attacks.

3. **Consensus Impact**: Resource exhaustion on validators can cause:
   - Block production delays or failures
   - State synchronization issues
   - Potential validator crashes leading to reduced validator set
   - Risk of consensus safety violations if >1/3 validators fail

4. **Defense-in-Depth Violation**: Even though governance is a trusted mechanism, critical system parameters should have validation to prevent catastrophic misconfigurations (either accidental or through compromise).

The impact extends to all network participants:
- Users cannot submit transactions
- dApps become unavailable
- Cross-chain bridges may fail
- Economic activity halts

## Likelihood Explanation

**Likelihood: Medium-to-High**

While the attack requires governance control (>50% voting power), several factors increase likelihood:

1. **Known Gap**: The TODO comments in the codebase explicitly acknowledge this validation is missing, indicating it was recognized but never implemented.

2. **Accidental Misconfiguration**: Even without malicious intent, governance could accidentally propose incorrect gas values due to:
   - Scripting errors in proposal generation
   - Copy-paste mistakes in parameter configuration
   - Misunderstanding of parameter units or scaling

3. **Governance Compromise Scenarios**:
   - Validator key compromises affecting majority stakeholders
   - Coordinated attack by malicious governance participants
   - Social engineering targeting governance voters

4. **No Secondary Safeguards**: Unlike transaction validation which has multiple layers (mempool, VM, execution), gas schedule updates have zero validation layers.

5. **Persistent Effect**: Once activated, the malicious schedule persists across all transactions until governance passes a corrective proposal, amplifying the attack window.

The likelihood is elevated because the attack surface (missing validation) is permanent and the impact is deterministic once exploited.

## Recommendation

Implement comprehensive gas parameter validation at multiple layers:

**Move Layer Validation** (in `gas_schedule.move`):

Replace the TODO comments with actual validation logic in all gas schedule update functions (`initialize`, `set_gas_schedule`, `set_for_next_epoch`, `set_for_next_epoch_check_hash`):

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    
    // ADD THIS VALIDATION
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    config_buffer::upsert(new_gas_schedule);
}

// Add new validation function
fun validate_gas_schedule_consistency(schedule: &GasScheduleV2) {
    // Validate critical gas parameters have minimum values
    let i = 0;
    let len = vector::length(&schedule.entries);
    while (i < len) {
        let entry = vector::borrow(&schedule.entries, i);
        
        // Abstract value size parameters must be > 0
        if (string::bytes(&entry.key).contains(b"misc.abs_val")) {
            assert!(entry.val > 0, error::invalid_argument(EINVALID_GAS_SCHEDULE));
        };
        
        // Storage gas parameters must be reasonable
        if (string::bytes(&entry.key).contains(b"storage")) {
            assert!(entry.val > 0, error::invalid_argument(EINVALID_GAS_SCHEDULE));
        };
        
        i = i + 1;
    };
}
```

**Rust Layer Validation** (in `macros.rs`):

Add validation after parameter loading:

```rust
impl $crate::traits::FromOnChainGasSchedule for $params_name {
    fn from_on_chain_gas_schedule(
        gas_schedule: &std::collections::BTreeMap<String, u64>, 
        feature_version: u64
    ) -> Result<Self, String> {
        let mut params = $params_name::zeros();

        $(
            if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!(
                $key_bindings, 
                feature_version
            ) {
                let name = format!("{}.{}", $prefix, key);
                let value = gas_schedule
                    .get(&name)
                    .cloned()
                    .ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?;
                
                // ADD VALIDATION
                if value == 0 {
                    return Err(format!("Gas parameter {} cannot be zero", name));
                }
                
                params.$name = value.into();
            }
        )*

        Ok(params)
    }
}
```

**Additional Safeguards:**

1. Add formal verification specs for gas parameter bounds
2. Implement rate limiting on gas schedule updates (e.g., max one per epoch)
3. Add monitoring/alerting for abnormal gas parameter values
4. Create a gas schedule "safe mode" that reverts to known-good defaults on validation failure

## Proof of Concept

**Move Test Case** (add to `aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move`):

```move
#[test(fx = @aptos_framework)]
#[expected_failure(abort_code = 0x010001, location = Self)]
fun test_zero_gas_parameters_should_abort(fx: signer) acquires GasScheduleV2 {
    // Setup initial gas schedule
    let initial_schedule = GasScheduleV2 {
        feature_version: 1,
        entries: vector[
            GasEntry { key: utf8(b"misc.abs_val.u8"), val: 40 },
            GasEntry { key: utf8(b"misc.abs_val.u64"), val: 40 },
        ],
    };
    move_to(&fx, initial_schedule);
    
    // Attempt to set gas schedule with zero values (should fail)
    let malicious_schedule = GasScheduleV2 {
        feature_version: 2,
        entries: vector[
            GasEntry { key: utf8(b"misc.abs_val.u8"), val: 0 },  // ZERO!
            GasEntry { key: utf8(b"misc.abs_val.u64"), val: 0 }, // ZERO!
        ],
    };
    let malicious_bytes = bcs::to_bytes(&malicious_schedule);
    
    // This should abort with EINVALID_GAS_SCHEDULE
    set_for_next_epoch(&fx, malicious_bytes);
}

#[test(fx = @aptos_framework)]
fun test_valid_gas_parameters_should_succeed(fx: signer) acquires GasScheduleV2 {
    // Setup initial gas schedule
    let initial_schedule = GasScheduleV2 {
        feature_version: 1,
        entries: vector[
            GasEntry { key: utf8(b"misc.abs_val.u8"), val: 40 },
        ],
    };
    move_to(&fx, initial_schedule);
    
    // Set gas schedule with valid values (should succeed)
    let valid_schedule = GasScheduleV2 {
        feature_version: 2,
        entries: vector[
            GasEntry { key: utf8(b"misc.abs_val.u8"), val: 50 },
        ],
    };
    let valid_bytes = bcs::to_bytes(&valid_schedule);
    
    set_for_next_epoch(&fx, valid_bytes);
    // Should succeed without abort
}
```

**Exploitation Demonstration** (Rust):

```rust
// In aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs
#[test]
fn test_zero_abstract_value_size_causes_free_operations() {
    use move_vm_types::values::Value;
    
    // Create gas parameters with zero values (simulating malicious governance)
    let mut malicious_params = AbstractValueSizeGasParameters::zeros();
    // All parameters are now 0
    
    // Create a large vector value
    let large_vec = Value::vector_u8((0..10000).map(|_| 0u8).collect());
    
    // Calculate abstract size with zero parameters
    let size = malicious_params
        .abstract_value_size(&large_vec, 3)
        .unwrap();
    
    // Size will be minimal (just vector overhead) even for 10KB of data
    // Operations on this value will cost nearly zero gas
    assert!(size.into(): u64 < 100); // Should be much larger normally!
    
    // This demonstrates that with zero gas parameters,
    // massive data structures cost almost nothing to process
}
```

---

**Notes:**

This vulnerability represents a critical gap in defense-in-depth security. While governance is a trusted mechanism, the complete absence of validation for gas-critical parameters violates fundamental safety principles. The explicit TODO comments in the codebase confirm this was a known gap that should have been addressed. The fix requires implementing validation at both Move and Rust layers to prevent catastrophic network-wide resource exhaustion.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L38-42)
```rust
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L303-311)
```rust
    fn charge_copy_loc(&mut self, val: impl ValueView) -> PartialVMResult<()> {
        let (stack_size, heap_size) = self
            .vm_gas_params()
            .misc
            .abs_val
            .abstract_value_size_stack_and_heap(val, self.feature_version())?;

        self.charge_copy_loc_cached(stack_size, heap_size)
    }
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L378-386)
```rust
    fn charge_read_ref(&mut self, val: impl ValueView) -> PartialVMResult<()> {
        let (stack_size, heap_size) = self
            .vm_gas_params()
            .misc
            .abs_val
            .abstract_value_size_stack_and_heap(val, self.feature_version())?;

        self.charge_read_ref_cached(stack_size, heap_size)
    }
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L398-408)
```rust
    fn charge_eq(&mut self, lhs: impl ValueView, rhs: impl ValueView) -> PartialVMResult<()> {
        let abs_val_params = &self.vm_gas_params().misc.abs_val;

        let cost = EQ_BASE
            + EQ_PER_ABS_VAL_UNIT
                * (abs_val_params.abstract_value_size_dereferenced(lhs, self.feature_version())?
                    + abs_val_params
                        .abstract_value_size_dereferenced(rhs, self.feature_version())?);

        self.algebra.charge_execution(cost)
    }
```
