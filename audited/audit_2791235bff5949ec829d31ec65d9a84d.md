# Audit Report

## Title
SafetyData Upgrade Vulnerability: one_chain_round Defaults to Zero, Bypassing 2-Chain Timeout Safety Rule

## Summary
When upgrading from an old SafetyData format to the new format with the `one_chain_round` field, the `#[serde(default)]` attribute causes `one_chain_round` to initialize to 0 instead of deriving it from existing consensus state. This creates a critical window where validators can sign timeouts with ancient quorum certificates, violating the 2-chain consensus safety rule and potentially causing chain forks.

## Finding Description

The SafetyData structure stores critical consensus safety state for validators. The `one_chain_round` field tracks the highest 1-chain round (the round of the highest QC observed) and is essential for enforcing the 2-chain timeout safety rule. [1](#0-0) 

The field is marked with `#[serde(default)]`, which means when deserializing old SafetyData that lacks this field, it defaults to 0: [2](#0-1) 

The 2-chain timeout safety rule enforces that validators can only sign timeouts if the timeout's QC round is at least as high as the highest QC they've seen: [3](#0-2) 

The critical check at line 134 compares `qc_round >= safety_data.one_chain_round`. When `one_chain_round` is incorrectly set to 0 after an upgrade, this check becomes trivially satisfied by any QC, even ancient ones from hundreds of rounds ago.

**Attack Scenario:**

1. **Pre-Upgrade State**: Network is at epoch 5, round 1000. All validators have:
   - `last_voted_round: 1000`
   - `preferred_round: 998` (highest 2-chain)
   - Implicit `one_chain_round: 999` (not stored in old format)

2. **Upgrade Event**: All validators upgrade to the new software version. SafetyData is deserialized with:
   - `last_voted_round: 1000` ✓
   - `preferred_round: 998` ✓
   - `one_chain_round: 0` ✗ (WRONG! Should be ≥998)

3. **Exploitation**: A Byzantine leader (or honest leader with historical data) sends a TwoChainTimeout message:
   - `epoch: 5`
   - `round: 100`
   - `quorum_cert`: QC for round 99 (from historical data)

4. **Safety Rule Bypass**: Honest validators call `safe_to_timeout`:
   - Check: `qc_round (99) >= one_chain_round (0)` ✓ **INCORRECTLY PASSES**
   - Validators sign the timeout with ancient QC

5. **Consensus Violation**: If ≥2/3 validators sign, a TwoChainTimeoutCertificate is created for round 100 with QC round 99. This TC can justify voting on blocks at round 101 that fork from round 99, creating two competing chains (one from round 999, one from round 99).

The vulnerability violates the fundamental invariant that `one_chain_round` should always be ≥ `preferred_round`, since the certified block is always at a round equal to or higher than its parent block: [4](#0-3) 

## Impact Explanation

This is a **Critical Severity** vulnerability per Aptos bug bounty criteria:

- **Consensus Safety Violation**: The core invariant that prevents chain forks is bypassed. Validators can sign conflicting timeout certificates, leading to multiple valid chains.

- **Double-Spending Potential**: With forked chains, transactions committed on one fork may not appear on another, enabling double-spending attacks.

- **Network-Wide Impact**: Affects all validators simultaneously during an upgrade within an epoch, not just a single node.

- **No Recovery Without Intervention**: Once divergent timeout certificates are signed and distributed, resolving the fork may require manual coordination or a hard fork.

The impact directly matches the Critical category: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)."

## Likelihood Explanation

**Likelihood: HIGH**

- **Automatic Trigger**: Occurs automatically on every software upgrade within an epoch. No attacker interaction required—honest validators will exhibit the vulnerability simply by upgrading.

- **Window of Vulnerability**: From the moment of upgrade until the node observes a new QC (by voting or signing an order vote). This could span multiple rounds if the validator only signs timeouts during this period.

- **No Mitigation Present**: No code exists to migrate `one_chain_round` from `preferred_round` or validate the invariant post-deserialization: [5](#0-4) 

- **Realistic Exploitation**: A Byzantine actor or network partition exposing historical data could trigger this immediately after an upgrade.

## Recommendation

Implement a post-deserialization validation and migration in the SafetyData structure or in the persistent storage layer:

```rust
// In PersistentSafetyStorage::safety_data()
pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
    let mut safety_data = if !self.enable_cached_safety_data {
        self.internal_store.get(SAFETY_DATA).map(|v| v.value)?
    } else if let Some(cached) = self.cached_safety_data.clone() {
        cached
    } else {
        let data: SafetyData = self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
        self.cached_safety_data = Some(data.clone());
        data
    };
    
    // MIGRATION: Ensure one_chain_round is at least preferred_round
    // Since one_chain (certified block round) must be >= two_chain (parent round)
    if safety_data.one_chain_round < safety_data.preferred_round {
        safety_data.one_chain_round = safety_data.preferred_round;
        // Persist the corrected value
        self.set_safety_data(safety_data.clone())?;
    }
    
    Ok(safety_data)
}
```

Alternatively, add a custom Deserialize implementation for SafetyData that enforces the invariant:

```rust
impl<'de> Deserialize<'de> for SafetyData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct SafetyDataRaw {
            epoch: u64,
            last_voted_round: u64,
            preferred_round: u64,
            #[serde(default)]
            one_chain_round: u64,
            last_vote: Option<Vote>,
            #[serde(default)]
            highest_timeout_round: u64,
        }
        
        let raw = SafetyDataRaw::deserialize(deserializer)?;
        let one_chain_round = raw.one_chain_round.max(raw.preferred_round);
        
        Ok(SafetyData {
            epoch: raw.epoch,
            last_voted_round: raw.last_voted_round,
            preferred_round: raw.preferred_round,
            one_chain_round,
            last_vote: raw.last_vote,
            highest_timeout_round: raw.highest_timeout_round,
        })
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_safety_data_upgrade_vulnerability() {
    use aptos_consensus_types::{
        safety_data::SafetyData,
        vote::Vote,
    };
    use serde::{Deserialize, Serialize};
    
    // Old SafetyData format without one_chain_round
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    
    // Simulate validator state before upgrade
    let old_data = OldSafetyData {
        epoch: 5,
        last_voted_round: 1000,
        preferred_round: 998,  // Highest 2-chain round
        last_vote: None,
    };
    
    // Serialize old format
    let serialized = serde_json::to_value(old_data).unwrap();
    
    // Deserialize into new format (simulating upgrade)
    let new_data: SafetyData = serde_json::from_value(serialized).unwrap();
    
    // VULNERABILITY: one_chain_round is 0, but should be at least 998
    assert_eq!(new_data.one_chain_round, 0, "one_chain_round defaults to 0");
    assert_eq!(new_data.preferred_round, 998);
    
    // This violates the invariant: one_chain_round >= preferred_round
    assert!(
        new_data.one_chain_round < new_data.preferred_round,
        "VULNERABILITY: one_chain_round ({}) < preferred_round ({})",
        new_data.one_chain_round,
        new_data.preferred_round
    );
    
    // Now safe_to_timeout will accept timeouts with QC rounds as low as 0,
    // even though the validator has seen QCs up to round 998+
    // This allows signing timeouts with ancient QCs, violating consensus safety
}
```

## Notes

The vulnerability is particularly insidious because:

1. **Epoch changes are safe**: The `guarded_initialize` function correctly resets all fields to 0 when starting a new epoch, so this only affects in-epoch upgrades. [6](#0-5) 

2. **Test exists but insufficient**: The existing `test_safety_data_upgrade` test only validates deserialization succeeds, not that the resulting state maintains consensus safety invariants. [7](#0-6) 

3. **Silent failure**: Validators continue operating normally after upgrade, with no error or warning that safety invariants are violated.

### Citations

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/consensus-types/src/safety_data.rs (L54-70)
```rust
fn test_safety_data_upgrade() {
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    let old_data = OldSafetyData {
        epoch: 1,
        last_voted_round: 10,
        preferred_round: 100,
        last_vote: None,
    };
    let value = serde_json::to_value(old_data).unwrap();
    let _: SafetyData = serde_json::from_value(value).unwrap();
}
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L121-145)
```rust
    /// Core safety timeout rule for 2-chain protocol. Return success if 1 and 2 are true
    /// 1. round == timeout.qc.round + 1 || round == tc.round + 1
    /// 2. timeout.qc.round >= one_chain_round
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L294-303)
```rust
            Ordering::Less => {
                // start new epoch
                self.persistent_storage.set_safety_data(SafetyData::new(
                    epoch_state.epoch,
                    0,
                    0,
                    0,
                    None,
                    0,
                ))?;
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L134-148)
```rust
    pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
        if !self.enable_cached_safety_data {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            return self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
        }

        if let Some(cached_safety_data) = self.cached_safety_data.clone() {
            Ok(cached_safety_data)
        } else {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            let safety_data: SafetyData = self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
            self.cached_safety_data = Some(safety_data.clone());
            Ok(safety_data)
        }
    }
```
