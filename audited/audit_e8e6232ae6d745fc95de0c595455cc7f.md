# Audit Report

## Title
State Merkle Pruner Progress Not Reset During Consensus Fork Rollback Leading to Total Node Liveness Failure

## Summary
During blockchain rollback triggered by consensus fork resolution, the state merkle pruner progress metadata is not reset to match the new ledger version. This causes the pruner's `min_readable_version` to be set ahead of the current ledger version, making all state queries fail with "pruned" errors even though the data exists and is current, resulting in total loss of node liveness.

## Finding Description

The vulnerability occurs in the rollback/truncation flow when a node restarts after a consensus fork:

**Step 1: Rollback Mechanism**

During node restart, `StateStore::new()` invokes `sync_commit_progress()` to synchronize database commit states. [1](#0-0)  This function truncates the state merkle database to match the authoritative `overall_commit_progress` version. [2](#0-1) 

**Step 2: Incomplete Progress Reset**

The truncation function calls `delete_nodes_and_stale_indices_at_or_after_version()` which invokes `StateMerkleDb::put_progress()` to record the new progress. [3](#0-2)  However, `put_progress()` only updates **commit progress** metadata keys (`StateMerkleCommitProgress` or `StateMerkleShardCommitProgress`), not **pruner progress** keys. [4](#0-3) 

**Step 3: Stale Pruner Progress Keys**

There are separate metadata keys defined for commit progress and pruner progress. The commit progress keys are `StateMerkleCommitProgress` and `StateMerkleShardCommitProgress`. [5](#0-4)  The pruner progress keys are `StateMerklePrunerProgress` and `StateMerkleShardPrunerProgress`. [6](#0-5) [7](#0-6)  Only the commit progress keys are reset during rollback - the pruner progress keys remain untouched.

**Step 4: Invalid min_readable_version Initialization**

On subsequent initialization, `StateMerklePrunerManager::new()` reads the stale pruner progress from the database and uses it to initialize `min_readable_version`. [8](#0-7)  This results in `min_readable_version` being set to a version ahead of the current ledger version after rollback.

**Step 5: Read Rejection**

All state merkle read operations check whether the requested version is pruned by calling `error_if_state_merkle_pruned()`. [9](#0-8) [10](#0-9)  This function compares the requested version against `min_readable_version` and rejects the read if the version is below this threshold. [11](#0-10)  The error message falsely claims the data is pruned even though it exists and is current.

**Step 6: Total Liveness Loss**

Critical APIs like `get_state_proof_by_version_ext` and `get_state_value_with_proof_by_version_ext` fail for all versions at or below the current ledger version, breaking consensus participation, state sync, and API serving. The node becomes completely non-functional for all state operations.

**Concrete Scenario:**
1. Node at ledger version 1000, pruner has pruned up to version 800 (StateMerklePrunerProgress = 800)
2. Consensus fork requires rollback to version 600
3. Node restarts, `sync_commit_progress()` truncates state merkle DB to version 600
4. `StateMerkleCommitProgress` → 600 (reset ✓)
5. `StateMerklePrunerProgress` → 800 (NOT reset ✗)
6. Pruner manager initializes `min_readable_version` = 800
7. All reads at versions 0-600 fail: "State merkle at version X is pruned, snapshots are available at >= 800"
8. Node cannot participate in consensus, serve state queries, or sync state

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program:

**Total Loss of Liveness/Network Availability**: The affected node becomes completely non-functional for all state operations. It cannot:
- Participate in consensus (cannot read state to execute blocks)
- Serve API requests (all state queries fail)
- Sync state (cannot provide or verify state proofs)

This satisfies the "Total loss of liveness/network availability" criterion worth up to $1,000,000.

**Consensus Safety Impact**: If multiple validators experience simultaneous rollbacks during network partitions (a common scenario during temporary network issues), a significant portion of the validator set may become unavailable, threatening consensus liveness and potentially requiring manual intervention or coordinated restart procedures.

**State Consistency Violation**: The system falsely reports existing, current data as "pruned," violating the fundamental invariant that committed state must be readable and verifiable via Merkle proofs.

## Likelihood Explanation

**High Likelihood**:
- Consensus forks occur naturally under < 1/3 Byzantine assumptions during network partitions or temporary validator disagreements
- Every node restart after experiencing a rollback triggers the vulnerability automatically
- No attacker action required - just normal network conditions
- The bug is deterministic and reproducible

**Automatic Triggering**: The vulnerability activates on any node that:
1. Experiences a consensus fork requiring rollback (common during network issues)
2. Restarts for any reason (crash, upgrade, maintenance)
3. Has pruning enabled with a gap between pruner progress and the rollback target version

## Recommendation

During truncation in `truncate_state_merkle_db()` or `delete_nodes_and_stale_indices_at_or_after_version()`, the pruner progress metadata must also be reset to match the new target version. Specifically:

1. After calling `StateMerkleDb::put_progress()` to update commit progress, also call `write_pruner_progress()` to reset the pruner progress metadata keys.

2. Add logic similar to:
```rust
// Reset pruner progress to match the new commit progress
state_merkle_db.write_pruner_progress(
    &DbMetadataKey::StateMerklePrunerProgress,
    target_version
)?;
```

3. For sharded databases, reset all shard-specific pruner progress keys as well.

4. Add validation during `StateMerklePrunerManager::new()` to ensure `min_readable_version` cannot exceed the current ledger version, and reset it if this invariant is violated.

## Proof of Concept

The vulnerability can be demonstrated through the following scenario:

1. Start a node with pruning enabled and let it accumulate data to version 1000
2. Allow the pruner to run and prune data up to version 800
3. Trigger a consensus fork that requires rollback to version 600 (can be simulated using the db_debugger truncate command)
4. Restart the node
5. Observe that `StateMerkleCommitProgress` = 600 but `StateMerklePrunerProgress` = 800
6. Attempt to read state at version 600 (current version)
7. Observe error: "State merkle at version 600 is pruned, snapshots are available at >= 800"
8. All state operations fail, node is non-functional

This can be verified by examining the database metadata keys before and after truncation, and attempting state reads at the rolled-back version.

## Notes

The root cause is the separation of concerns between commit progress tracking (for data integrity) and pruner progress tracking (for read validation), without proper synchronization during exceptional rollback scenarios. While this separation is architecturally sound for normal operations, the truncation/rollback path fails to maintain the invariant that `min_readable_version <= current_ledger_version`.

### Citations

**File:** storage/aptosdb/src/state_store/mod.rs (L354-359)
```rust
            Self::sync_commit_progress(
                Arc::clone(&ledger_db),
                Arc::clone(&state_kv_db),
                Arc::clone(&state_merkle_db),
                /*crash_if_difference_is_too_large=*/ true,
            );
```

**File:** storage/aptosdb/src/state_store/mod.rs (L490-498)
```rust
            if state_merkle_target_version < state_merkle_max_version {
                info!(
                    state_merkle_max_version = state_merkle_max_version,
                    target_version = state_merkle_target_version,
                    "Start state merkle truncation..."
                );
                truncate_state_merkle_db(&state_merkle_db, state_merkle_target_version)
                    .expect("Failed to truncate state merkle db.");
            }
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L621-621)
```rust
    StateMerkleDb::put_progress(version.checked_sub(1), shard_id, batch)
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L393-409)
```rust
    pub(crate) fn put_progress(
        version: Option<Version>,
        shard_id: Option<usize>,
        batch: &mut impl WriteBatch,
    ) -> Result<()> {
        let key = if let Some(shard_id) = shard_id {
            DbMetadataKey::StateMerkleShardCommitProgress(shard_id)
        } else {
            DbMetadataKey::StateMerkleCommitProgress
        };

        if let Some(version) = version {
            batch.put::<DbMetadataSchema>(&key, &DbMetadataValue::Version(version))
        } else {
            batch.delete::<DbMetadataSchema>(&key)
        }
    }
```

**File:** storage/aptosdb/src/schema/db_metadata/mod.rs (L51-51)
```rust
    StateMerklePrunerProgress,
```

**File:** storage/aptosdb/src/schema/db_metadata/mod.rs (L59-60)
```rust
    StateMerkleCommitProgress,
    StateMerkleShardCommitProgress(ShardId),
```

**File:** storage/aptosdb/src/schema/db_metadata/mod.rs (L66-66)
```rust
    StateMerkleShardPrunerProgress(ShardId),
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs (L119-130)
```rust
        let min_readable_version = pruner_utils::get_state_merkle_pruner_progress(&state_merkle_db)
            .expect("Must succeed.");

        PRUNER_VERSIONS
            .with_label_values(&[S::name(), "min_readable"])
            .set(min_readable_version as i64);

        Self {
            state_merkle_db,
            prune_window: state_merkle_pruner_config.prune_window,
            pruner_worker,
            min_readable_version: AtomicVersion::new(min_readable_version),
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L666-666)
```rust
            self.error_if_state_merkle_pruned("State merkle", version)?;
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L685-685)
```rust
            self.error_if_state_merkle_pruned("State merkle", version)?;
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L273-302)
```rust
    pub(super) fn error_if_state_merkle_pruned(
        &self,
        data_type: &str,
        version: Version,
    ) -> Result<()> {
        let min_readable_version = self
            .state_store
            .state_db
            .state_merkle_pruner
            .get_min_readable_version();
        if version >= min_readable_version {
            return Ok(());
        }

        let min_readable_epoch_snapshot_version = self
            .state_store
            .state_db
            .epoch_snapshot_pruner
            .get_min_readable_version();
        if version >= min_readable_epoch_snapshot_version {
            self.ledger_db.metadata_db().ensure_epoch_ending(version)
        } else {
            bail!(
                "{} at version {} is pruned. snapshots are available at >= {}, epoch snapshots are available at >= {}",
                data_type,
                version,
                min_readable_version,
                min_readable_epoch_snapshot_version,
            )
        }
```
