# Audit Report

## Title
TOCTOU Race Condition in Block Payload Insertion Allows Denial of Service via Payload Replacement

## Summary
A Time-of-Check-Time-of-Use (TOCTOU) race condition in `process_block_payload_message()` allows an attacker to replace verified block payloads with unverified ones, causing consensus observer nodes to reject valid ordered blocks and triggering denial of service.

## Finding Description

The `process_block_payload_message()` function contains a critical TOCTOU vulnerability between the payload existence check and payload insertion. The function performs these operations non-atomically:

1. **Check phase** (lines 370-373): Acquires lock, checks if payload exists, releases lock [1](#0-0) 

2. **Insert phase** (lines 428-430): Acquires lock again, inserts payload, releases lock [2](#0-1) 

The underlying `insert_block_payload()` uses `BTreeMap::insert()` which **replaces existing values** when the key already exists: [3](#0-2) 

**Attack Vector 1: TOCTOU Payload Replacement**

Two threads processing payloads for the same (epoch, round) can race:
- Thread A (honest): Checks existence → FALSE, verifies signatures → PASS, inserts as `AvailableAndVerified`
- Thread B (malicious): Checks existence → FALSE (before Thread A inserts), verification depends on epoch matching
  - If epoch doesn't match current: skips signature verification (lines 416-418), inserts as `AvailableAndUnverified`
  - Thread B's insert **overwrites** Thread A's verified payload [4](#0-3) 

**Attack Vector 2: Future Epoch Front-Running**

An attacker can pre-emptively insert unverified payloads for future epochs:
1. Attacker sends payload for epoch E+1, round R (before epoch E+1 starts)
2. Payload bypasses signature verification (epoch mismatch), inserted as `AvailableAndUnverified`
3. Honest validator sends payload for epoch E+1, round R
4. The `existing_payload_entry` check returns TRUE, honest payload is **rejected** [5](#0-4) 

**Consequence:** When an ordered block arrives, `verify_payloads_against_ordered_block()` expects `AvailableAndVerified` but finds `AvailableAndUnverified`, causing the ordered block to be rejected: [6](#0-5) 

This breaks the consensus observer's ability to process blocks, forcing it into fallback/state sync mode.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria: "Validator node slowdowns" / "Significant protocol violations")

The vulnerability enables:
1. **Consensus Observer DoS**: Attacker can prevent observer nodes from processing ordered blocks by poisoning their payload stores
2. **Forced State Sync**: Affected nodes must repeatedly enter fallback mode and re-sync via state sync
3. **Network-Wide Impact**: If exploited against multiple observer nodes simultaneously, degrades overall network observability
4. **Sustained Attack**: Attacker can continuously send malicious payloads to maintain DoS condition

The attack does NOT require:
- Validator keys or stake
- Insider access
- Complex cryptographic attacks

It only requires the ability to send consensus observer network messages, which any connected peer can do.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly exploitable because:

1. **Race Window**: The time between lock releases at lines 373 and 428 provides a wide race window for concurrent message processing
2. **Concurrency Model**: Consensus observer processes messages from multiple peers concurrently, making races inevitable under load
3. **No Retry Mechanism**: Once an honest payload is rejected, validators don't automatically retry, leaving the poisoned entry in place
4. **Future Epoch Attack**: Attacker can pre-position malicious payloads before honest payloads arrive, guaranteeing the attack succeeds

The attack requires only:
- Network connectivity to send consensus observer messages
- Ability to predict or observe upcoming epoch/round numbers (publicly visible)
- Basic timing control over message transmission

## Recommendation

**Fix: Implement atomic check-and-insert operation with proper verification state handling**

```rust
// In consensus_observer.rs, process_block_payload_message()
// Replace lines 370-430 with:

// Atomically check existence and insert payload
let should_process = {
    let mut block_data = self.observer_block_data.lock();
    
    // Check if already exists WHILE holding lock
    if block_data.existing_payload_entry(&block_payload) {
        false // Already exists, don't process
    } else {
        // Only insert verified payloads atomically
        if block_epoch == epoch_state.epoch {
            // Current epoch: must verify signatures before insertion
            if let Err(error) = block_payload.verify_payload_signatures(&epoch_state) {
                error!(LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payload signatures! Ignoring block: {:?}, Error: {:?}",
                    block_payload.block(), error
                )));
                increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
                return;
            }
            // Insert as verified immediately
            block_data.insert_block_payload(block_payload.clone(), true);
            true
        } else {
            // Future epoch: defer verification until epoch starts
            // Insert as unverified but mark for later verification
            block_data.insert_block_payload(block_payload.clone(), false);
            false // Don't process pending blocks yet
        }
    }
};

if should_process {
    self.order_ready_pending_block(block_epoch, block_round).await;
}
```

**Additional Mitigation**: Add validation in `insert_block_payload()` to prevent replacement of verified payloads:

```rust
// In payload_store.rs, insert_block_payload()
// Before line 106, add:

// Never replace verified payloads with unverified ones
if let Some(existing) = self.block_payloads.lock().get(&epoch_and_round) {
    if matches!(existing, BlockPayloadStatus::AvailableAndVerified(_)) 
        && !verified_payload_signatures {
        warn!(LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Attempted to replace verified payload with unverified one! Ignoring: {:?}",
            block_payload.block(),
        )));
        return; // Reject replacement
    }
}
```

## Proof of Concept

```rust
// Test demonstrating the TOCTOU vulnerability
#[tokio::test]
async fn test_payload_replacement_race_condition() {
    use std::sync::{Arc, Mutex as StdMutex};
    use tokio::task::JoinSet;
    
    // Setup consensus observer with payload store
    let observer = setup_consensus_observer();
    let epoch = 10;
    let round = 5;
    
    // Create two payloads for same epoch/round
    let honest_payload = create_valid_payload(epoch, round);
    let malicious_payload = create_malicious_payload(epoch, round);
    
    // Track which payload ends up in store
    let result = Arc::new(StdMutex::new(None));
    let mut tasks = JoinSet::new();
    
    // Thread 1: Process honest payload (verified)
    let observer1 = observer.clone();
    let result1 = result.clone();
    tasks.spawn(async move {
        observer1.process_block_payload_message(
            peer_network_id(),
            Instant::now(),
            honest_payload,
        ).await;
        *result1.lock().unwrap() = Some("honest");
    });
    
    // Thread 2: Process malicious payload (unverified, future epoch)
    let observer2 = observer.clone();
    let result2 = result.clone();
    tasks.spawn(async move {
        observer2.process_block_payload_message(
            peer_network_id(),
            Instant::now(),
            malicious_payload,
        ).await;
        *result2.lock().unwrap() = Some("malicious");
    });
    
    // Wait for both to complete
    while tasks.join_next().await.is_some() {}
    
    // Check final state - if malicious payload won the race,
    // the store contains an unverified payload
    let payloads = observer.observer_block_data.lock().get_block_payloads();
    let stored = payloads.lock().get(&(epoch, round));
    
    // VULNERABILITY: Unverified payload may have replaced verified one
    assert!(matches!(
        stored,
        Some(BlockPayloadStatus::AvailableAndUnverified(_))
    ), "Race condition allowed unverified payload to replace verified!");
    
    // When ordered block arrives, it will be rejected
    let ordered_block = create_ordered_block(epoch, round);
    let result = observer.observer_block_data.lock()
        .verify_payloads_against_ordered_block(&ordered_block);
    
    assert!(result.is_err(), "Ordered block should be rejected due to unverified payload");
}
```

## Notes

This vulnerability affects the **consensus observer** component specifically, not the core consensus protocol itself. However, it significantly degrades network functionality by:
- Preventing observer nodes from tracking consensus in real-time
- Forcing repeated state sync operations (bandwidth intensive)
- Creating potential for cascading failures if many observers are affected simultaneously

The fix requires ensuring atomic check-and-insert operations while properly handling the distinction between current-epoch (immediately verifiable) and future-epoch (defer verification) payloads.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L370-373)
```rust
        let payload_exists = self
            .observer_block_data
            .lock()
            .existing_payload_entry(&block_payload);
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L375-380)
```rust
        // If the payload is out of date or already exists, ignore it
        if payload_out_of_date || payload_exists {
            // Update the metrics for the dropped block payload
            update_metrics_for_dropped_block_payload_message(peer_network_id, &block_payload);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L399-418)
```rust
        // If the payload is for the current epoch, verify the proof signatures
        let epoch_state = self.get_epoch_state();
        let verified_payload = if block_epoch == epoch_state.epoch {
            // Verify the block proof signatures
            if let Err(error) = block_payload.verify_payload_signatures(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify block payload signatures! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                        block_payload.block(), peer_network_id, error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
                return;
            }

            true // We have successfully verified the signatures
        } else {
            false // We can't verify the signatures yet
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L428-430)
```rust
        self.observer_block_data
            .lock()
            .insert_block_payload(block_payload, verified_payload);
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L105-109)
```rust
        // Insert the new payload status
        self.block_payloads
            .lock()
            .insert(epoch_and_round, payload_status);
    }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L176-183)
```rust
                        BlockPayloadStatus::AvailableAndUnverified(_) => {
                            // The payload should have already been verified
                            return Err(Error::InvalidMessageError(format!(
                                "Payload verification failed! Block payload for epoch: {:?} and round: {:?} is unverified.",
                                ordered_block.epoch(),
                                ordered_block.round()
                            )));
                        },
```
