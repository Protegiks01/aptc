# Audit Report

## Title
Incomplete Transaction Verification Coverage Due to Partial Job Generation in Replay-Verify System

## Summary
The `gen_replay_verify_jobs.rs` tool generates incomplete verification coverage when transaction ranges exceed `max_versions_per_range`. Large ranges between state snapshots result in only the first portion being verified, leaving millions of transactions unverified. This allows transactions with potential invalid signatures or execution bugs in omitted ranges to remain undetected by the replay-verify system.

## Finding Description

The vulnerability exists in the job generation logic for the replay-verify system. [1](#0-0) 

When processing transaction ranges between state snapshots, if a range is larger than `max_versions_per_range`, the code creates a "partial" job covering only the first `max_versions_per_range` transactions and then returns immediately. The remaining transactions in that range are never added to any verification job.

**Example scenario:**
- State snapshot at epoch 100, version 1,000,000
- State snapshot at epoch 150, version 5,000,000 (4M transactions between)
- `max_versions_per_range` = 1,000,000

The code creates a single job for versions [1,000,000 - 1,999,999], leaving versions [2,000,000 - 4,999,999] completely unverified.

The workflow execution confirms this: [2](#0-1) 

The replay-verify command receives only the job-specified ranges, with no `--txns-to-skip` parameter to account for the omitted transactions.

During replay execution, signature verification occurs when transactions are converted to `SignatureVerifiedTransaction`: [3](#0-2) 

However, this verification only happens for transactions that are actually replayed. Transactions in omitted ranges are never replayed, so their signatures are never verified by this system.

## Impact Explanation

This constitutes a **HIGH severity** issue under the "Significant protocol violations" category. While this bug does not directly affect consensus or allow malicious transactions to be committed, it fundamentally undermines the integrity verification protocol:

1. **Verification Protocol Violation**: The replay-verify system is intended to provide comprehensive verification of historical transactions, but systematically skips large portions of the transaction history.

2. **Signature Verification Gaps**: Transactions with invalid signatures in omitted ranges would never be detected by this verification system. While such transactions shouldn't exist (they should be caught during consensus), this tool is meant to provide defense-in-depth verification.

3. **Execution Bug Detection Failure**: Any execution bugs, state transition errors, or other anomalies in the omitted ranges would go undetected, defeating the purpose of the replay-verify system.

4. **False Confidence**: The system reports successful verification while actually providing incomplete coverage, creating false confidence in the integrity of the historical blockchain state.

## Likelihood Explanation

**Likelihood: HIGH**

This bug triggers automatically whenever:
- Transaction ranges between state snapshots exceed `max_versions_per_range`
- For mainnet/testnet with `range_size` of 2-5 million transactions, any epoch with heavy load will trigger this
- The configuration shows this is actively used in production workflows

The omitted ranges can span millions of transactions, representing significant portions of blockchain history that receive no verification.

## Recommendation

Modify the batching logic to recursively create multiple jobs for large ranges instead of creating only one partial job:

```rust
// In the batching closure, around line 96-117
if end.version - begin.version >= self.max_versions_per_range {
    // Split large range into multiple jobs
    let mut current = begin.version;
    let mut jobs = vec![];
    
    while current < end.version {
        let chunk_end = (current + self.max_versions_per_range - 1).min(end.version - 1);
        jobs.push((
            true, // mark as partial
            current,
            chunk_end,
            format!("Partial replay epoch {} - {}, {} txns from version {}",
                begin.epoch, end.epoch - 1, chunk_end - current + 1, current)
        ));
        current = chunk_end + 1;
    }
    
    // Return all jobs (may need to adjust the batching approach)
    // This requires restructuring to emit multiple items
    ...
}
```

Alternatively, modify the workflow to iterate over large ranges and create multiple sequential jobs, ensuring complete coverage.

## Proof of Concept

**Steps to reproduce:**

1. Set up a test with state snapshots that have a large gap:
```bash
# Generate jobs for a range with gaps > max_versions_per_range
./aptos-debugger aptos-db gen-replay-verify-jobs \
  --metadata-cache-dir ./metadata_cache \
  --command-adapter-config <config> \
  --start-version 0 \
  --max-versions-per-range 1000000 \
  --max-ranges-per-job 16 \
  --output-json-file jobs.json
```

2. Examine the output `jobs.json` - observe that for large ranges, only partial coverage is generated with messages like "another X versions omitted"

3. Count total versions covered in jobs vs. total versions in the blockchain - the gap represents unverified transactions

4. The unverified transactions never undergo signature verification that occurs here: [4](#0-3) 

**Expected behavior:** All transaction versions should be included in at least one verification job.

**Actual behavior:** Large ranges result in only partial coverage, with millions of transactions omitted from all verification jobs.

## Notes

This vulnerability specifically affects the **replay-verify tooling system**, not the core consensus or execution layers. Transactions with invalid signatures should not be committable to the blockchain in the first place due to validation during consensus and execution. However, the replay-verify system is designed to provide defense-in-depth verification and catch any bugs in those systems. This gap undermines that assurance and could allow execution bugs or anomalies in omitted ranges to go undetected indefinitely.

### Citations

**File:** storage/db-tool/src/gen_replay_verify_jobs.rs (L96-117)
```rust
                        if end.version - begin.version >= self.max_versions_per_range {
                            // cut big range short, this hopefully automatically skips load tests
                            let msg = if end.epoch - begin.epoch > 15 {
                                "!!! Need more snapshots !!!"
                            } else {
                                ""
                            };
                            Some((
                                true,
                                begin.version,
                                begin.version + self.max_versions_per_range - 1,
                                format!(
                                    "Partial replay epoch {} - {}, {} txns starting from version {}, another {} versions omitted, until {}. {}",
                                    begin.epoch,
                                    end.epoch - 1,
                                    self.max_versions_per_range,
                                    begin.version,
                                    end.version - begin.version - self.max_versions_per_range,
                                    end.version,
                                    msg
                                )
                            ))
```

**File:** .github/workflows/workflow-run-replay-verify.yaml (L248-259)
```yaml
                ./aptos-debugger aptos-db replay-verify \
                  --metadata-cache-dir $MC \
                  --command-adapter-config ${{ inputs.BACKUP_CONFIG_TEMPLATE_PATH }} \
                  --start-version $begin \
                  --end-version $end \
                  \
                  --lazy-quit \
                  --enable-storage-sharding \
                  --target-db-dir $DB \
                  --concurrent-downloads 8 \
                  --replay-concurrency-level 4 \
                  || res=$?
```

**File:** types/src/transaction/signature_verified_transaction.rs (L129-138)
```rust
impl From<Transaction> for SignatureVerifiedTransaction {
    fn from(txn: Transaction) -> Self {
        match txn {
            Transaction::UserTransaction(txn) => match txn.verify_signature() {
                Ok(_) => SignatureVerifiedTransaction::Valid(Transaction::UserTransaction(txn)),
                Err(_) => SignatureVerifiedTransaction::Invalid(Transaction::UserTransaction(txn)),
            },
            _ => SignatureVerifiedTransaction::Valid(txn),
        }
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L606-611)
```rust
        let txns = transactions
            .iter()
            .take((end_version - begin_version) as usize)
            .cloned()
            .map(|t| t.into())
            .collect::<Vec<SignatureVerifiedTransaction>>();
```
