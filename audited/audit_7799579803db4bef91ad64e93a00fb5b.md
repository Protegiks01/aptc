# Audit Report

## Title
Missing Per-Author Deduplication in OrderVoteMsg Processing Enables CPU Amplification Attack

## Summary
The `PendingOrderVotes` structure lacks per-author vote tracking that exists in `PendingVotes` for regular votes. This design asymmetry allows a malicious validator to repeatedly send `OrderVoteMsg` instances with re-signed signatures, forcing all receiving validators to perform expensive BLS signature verifications for each duplicate message before deduplication occurs at the `SignatureAggregator` level.

## Finding Description

The consensus layer implements different duplicate detection mechanisms for regular votes versus order votes, creating an exploitable vulnerability.

**Regular Votes Protection:**

`PendingVotes` maintains per-author tracking via the `author_to_vote` HashMap [1](#0-0) , which enables early duplicate and equivocation detection [2](#0-1) . This check occurs BEFORE signature aggregation, preventing redundant cryptographic operations.

**Order Votes Vulnerability:**

`PendingOrderVotes` only maintains a `li_digest_to_votes` HashMap with no per-author tracking [3](#0-2) . The structure cannot detect when the same author sends multiple order votes for the same LedgerInfo.

**Attack Execution Path:**

1. When an `OrderVoteMsg` is received, it undergoes signature verification BEFORE any deduplication [4](#0-3) 

2. The `verify_order_vote` method performs BLS signature verification [5](#0-4)  by calling the `OrderVote::verify` method [6](#0-5) , which uses expensive cryptographic operations.

3. Only after verification does `process_order_vote_msg` check if enough votes exist [7](#0-6) , but this only prevents processing when a QC is already formed, not duplicate votes from the same author.

4. During vote insertion, `SignatureAggregator::add_signature` merely overwrites previous signatures from the same author [8](#0-7) , providing no early rejection or error.

**Attack Scenario:**

A malicious validator creates M `OrderVoteMsg` instances for the same `LedgerInfo`, each with a re-generated signature. When broadcast to N validators, this triggers M × N signature verifications across the network. Each verification is an expensive BLS operation, causing significant CPU exhaustion on all validators.

## Impact Explanation

**Severity: High** (Validator Node Slowdowns - up to $50,000 per bug bounty)

This vulnerability aligns with the Aptos bug bounty category: "Validator Node Slowdowns (High): Significant performance degradation affecting consensus, DoS through resource exhaustion."

Impact quantification:
- **CPU Exhaustion**: M duplicate messages × N validators = M×N BLS signature verifications consuming validator CPU resources
- **Consensus Performance Degradation**: CPU cycles wasted on redundant cryptographic operations reduce capacity for legitimate consensus activities
- **No Natural Limit**: Before QC formation, there is no bound on how many duplicate order votes from the same author will be processed
- **Sustained Attack**: A malicious validator can maintain this behavior across multiple rounds

This is NOT a pure network DoS attack - it is a protocol-level vulnerability where missing validation logic causes unbounded expensive cryptographic operations, degrading consensus performance.

## Likelihood Explanation

**Likelihood: High**

Requirements for exploitation:
- Attacker must be a validator (within BFT < 1/3 Byzantine assumption) - standard threat model
- No collusion required - single malicious validator sufficient
- Trivial execution: repeatedly broadcast order votes with re-generated signatures
- Low detection difficulty: messages appear as valid signatures from a valid validator

The attack is sustainable and can continue across multiple consensus rounds, providing continuous performance degradation.

## Recommendation

Add per-author tracking to `PendingOrderVotes` similar to `PendingVotes`:

1. Add an `author_to_vote` HashMap to track which authors have already submitted order votes for each LedgerInfo
2. In `insert_order_vote`, check if the author has already voted before calling `add_signature`
3. Return appropriate error results (e.g., `DuplicateOrderVote` or `EquivocateOrderVote`) for duplicate submissions
4. Implement this check BEFORE the expensive signature aggregation operations

This would align order vote processing with the existing secure pattern used for regular votes, preventing redundant signature verifications.

## Proof of Concept

The vulnerability can be demonstrated by:

1. A validator creating multiple `OrderVoteMsg` instances for the same `LedgerInfo` with different signatures
2. Broadcasting all messages to other validators
3. Observing that each message triggers signature verification at line 158 of `round_manager.rs`
4. Confirming that `SignatureAggregator::add_signature` only overwrites at line 461 of `ledger_info.rs` without rejecting duplicates
5. Measuring CPU time spent on redundant BLS signature verifications

The code evidence demonstrates that no per-author deduplication exists in the order vote path, unlike the regular vote path which has explicit duplicate detection.

## Notes

The core issue is a design inconsistency: `PendingVotes` correctly implements per-author tracking to prevent redundant work, but `PendingOrderVotes` lacks this protection. This is a consensus protocol vulnerability that enables resource exhaustion through a single Byzantine validator exploiting missing validation logic, qualifying it as "Validator Node Slowdowns" rather than a pure network DoS attack.

### Citations

**File:** consensus/src/pending_votes.rs (L173-173)
```rust
    author_to_vote: HashMap<Author, (Vote, HashValue)>,
```

**File:** consensus/src/pending_votes.rs (L287-309)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }
```

**File:** consensus/src/pending_order_votes.rs (L39-45)
```rust
pub struct PendingOrderVotes {
    /// Maps LedgerInfo digest to associated signatures.
    /// Order vote status stores caches the information on whether the votes are enough to form a QC.
    /// We also store the QC that the order votes certify.
    li_digest_to_votes:
        HashMap<HashValue /* LedgerInfo digest */, (QuorumCert, OrderVoteStatus)>,
}
```

**File:** consensus/src/round_manager.rs (L156-163)
```rust
            UnverifiedEvent::OrderVoteMsg(v) => {
                if !self_message {
                    v.verify_order_vote(peer_id, validator)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["order_vote"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::OrderVoteMsg(v)
```

**File:** consensus/src/round_manager.rs (L1561-1566)
```rust
            if self
                .pending_order_votes
                .has_enough_order_votes(order_vote_msg.order_vote().ledger_info())
            {
                return Ok(());
            }
```

**File:** consensus/consensus-types/src/order_vote_msg.rs (L48-67)
```rust
    pub fn verify_order_vote(
        &self,
        sender: Author,
        validator: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(
            self.order_vote.author() == sender,
            "Order vote author {:?} is different from the sender {:?}",
            self.order_vote.author(),
            sender
        );
        ensure!(
            self.quorum_cert().certified_block() == self.order_vote().ledger_info().commit_info(),
            "QuorumCert and OrderVote do not match"
        );
        self.order_vote
            .verify(validator)
            .context("[OrderVoteMsg] OrderVote verification failed")?;
        Ok(())
    }
```

**File:** consensus/consensus-types/src/order_vote.rs (L83-93)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.ledger_info.consensus_data_hash() == HashValue::zero(),
            "Failed to verify OrderVote. Consensus data hash is not Zero"
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify OrderVote")?;

        Ok(())
    }
```

**File:** types/src/ledger_info.rs (L460-462)
```rust
    pub fn add_signature(&mut self, validator: AccountAddress, signature: &SignatureWithStatus) {
        self.signatures.insert(validator, signature.clone());
    }
```
