# Audit Report

## Title
Hardcoded Event V2 Translation Config Causes Metadata Inconsistency During Database Restore

## Summary
The `get_indexer_db_for_restore()` function uses hardcoded configuration values that enable event V2 translation indexing, but the restore process fails to write the corresponding `EventV2TranslationVersion` metadata. This creates an inconsistent database state that causes node startup failures with a panic, requiring manual intervention to recover.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Hardcoded Configuration** [1](#0-0) 

The `get_indexer_db_for_restore()` function creates an `InternalIndexerDBConfig` with all indexing features enabled, including `enable_event_v2_translation: true` and `event_v2_translation_ignores_below_version: 0`.

**2. Missing Metadata Write During Restore** [2](#0-1) 

During state restore, the `kv_finish()` method writes metadata for `LatestVersion`, `StateVersion`, `TransactionVersion`, and `EventVersion` based on which features are enabled. However, it **never writes `EventV2TranslationVersion`**, even when `event_v2_translation_enabled()` is true.

**3. Version Consistency Check Fails at Startup** [3](#0-2) 

When the node attempts to start with the restored database, `get_start_version()` performs version consistency checks. For event V2 translation, it retrieves `event_v2_translation_start_version` which defaults to 0 when the metadata doesn't exist. With the hardcoded `event_v2_translation_ignores_below_version: 0` and a non-zero `start_version` from the restored data, the check `0 < start_version && start_version != event_v2_translation_start_version` evaluates to true, causing a panic.

**Attack Scenario:**
1. Node operator performs database restore using backup-cli with `--enable-state-indices` flag
2. Restore completes at version 1,000,000, creating metadata: `LatestVersion=999999`, `StateVersion=999999`, but no `EventV2TranslationVersion`
3. Operator attempts to start node with internal indexer enabled and event V2 translation configured
4. During startup, `get_start_version()` calculates: `start_version=1000000`, `event_v2_translation_start_version=0`
5. Consistency check triggers panic: "Cannot start event v2 translation indexer because the progress doesn't match"
6. Node fails to start, requiring manual metadata correction or feature disabling

## Impact Explanation

This is a **Medium Severity** vulnerability according to Aptos bug bounty criteria:

- **State Inconsistency Requiring Intervention**: The restored database has incomplete metadata, violating the State Consistency invariant. Operators cannot start their nodes without manual database manipulation or configuration changes.
- **Node Availability Loss**: Affected nodes cannot start until the issue is resolved, impacting network participation for validator nodes and API availability for fullnodes.
- **No Data Corruption**: The underlying state data remains intact; only indexer metadata is missing.
- **Limited Scope**: Only affects nodes performing restores with the state indices feature enabled.

This meets the Medium severity category of "State inconsistencies requiring intervention" worth up to $10,000.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Common Operation**: Database restore is a standard operational procedure for nodes recovering from failures or bootstrapping new infrastructure.
- **Feature Adoption**: The `--enable-state-indices` flag is used by operators who want to support account-based API queries, making this a realistic scenario.
- **Automatic Trigger**: The vulnerability triggers automatically during normal restore operations when using the provided flags—no attacker action required.
- **Difficult to Diagnose**: Operators may not immediately understand the root cause, as the panic message doesn't clearly indicate the metadata inconsistency.

## Recommendation

**Fix 1: Add EventV2TranslationVersion to kv_finish()** [4](#0-3) 

After the EventVersion write block, add:

```rust
if internal_indexer_db.event_v2_translation_enabled() {
    batch.put::<InternalIndexerMetadataSchema>(
        &MetadataKey::EventV2TranslationVersion,
        &MetadataValue::Version(version - 1),
    )?;
}
```

**Fix 2: Use Conservative Defaults in get_indexer_db_for_restore()** [1](#0-0) 

Change the hardcoded configuration to only enable state keys (the minimum needed for restore):

```rust
let internal_indexer_db_config =
    InternalIndexerDBConfig::new(false, false, false, 0, true, 10_000);
```

This ensures only the features properly handled by `kv_finish()` are enabled during restore.

**Fix 3: Improve Version Consistency Validation**

Add a more informative error message and potentially relax the check to handle missing metadata gracefully when appropriate.

## Proof of Concept

**Reproduction Steps:**

1. Create a state snapshot backup of an Aptos node at version N > 0
2. Use backup-cli to restore with the state indices flag:
   ```bash
   aptos-db-tool restore --enable-state-indices --db-dir /path/to/restored/db --target-version N
   ```
3. Attempt to start a node using the restored database with configuration:
   ```yaml
   indexer_db_config:
     enable_event: true
     enable_event_v2_translation: true
     event_v2_translation_ignores_below_version: 0
     enable_statekeys: true
   ```
4. Observe panic during startup: "Cannot start event v2 translation indexer because the progress doesn't match. start_version: N, event_v2_translation_start_version: 0"

**Expected Result:** Node fails to start with panic
**Root Cause:** Missing EventV2TranslationVersion metadata in restored database

**Verification:**
Query the internal indexer DB for metadata keys—EventV2TranslationVersion will be absent while other version metadata exists, confirming the inconsistency.

## Notes

The vulnerability stems from a mismatch between the comprehensive hardcoded configuration used during restore and the incomplete metadata initialization in the `kv_finish()` method. The missing `EventV2TranslationVersion` write appears to be an oversight, as all other indexer feature versions are properly initialized. This issue specifically affects the restore code path and would not occur during normal node operation where the indexer processes transactions incrementally and maintains all version metadata consistently [5](#0-4) .

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L54-55)
```rust
        let internal_indexer_db_config =
            InternalIndexerDBConfig::new(true, true, true, 0, true, 10_000);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L141-158)
```rust
        if node_config.indexer_db_config.enable_event_v2_translation() {
            let event_v2_translation_start_version = self
                .db_indexer
                .indexer_db
                .get_event_v2_translation_version()?
                .map_or(0, |v| v + 1);
            if node_config
                .indexer_db_config
                .event_v2_translation_ignores_below_version()
                < start_version
                && start_version != event_v2_translation_start_version
            {
                panic!(
                    "Cannot start event v2 translation indexer because the progress doesn't match. \
                    start_version: {}, event_v2_translation_start_version: {}",
                    start_version, event_v2_translation_start_version
                );
            }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1281-1314)
```rust
    fn kv_finish(&self, version: Version, usage: StateStorageUsage) -> Result<()> {
        self.ledger_db.metadata_db().put_usage(version, usage)?;
        if let Some(internal_indexer_db) = self.internal_indexer_db.as_ref() {
            if version > 0 {
                let mut batch = SchemaBatch::new();
                batch.put::<InternalIndexerMetadataSchema>(
                    &MetadataKey::LatestVersion,
                    &MetadataValue::Version(version - 1),
                )?;
                if internal_indexer_db.statekeys_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::StateVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                if internal_indexer_db.transaction_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::TransactionVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                if internal_indexer_db.event_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::EventVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                internal_indexer_db
                    .get_inner_db_ref()
                    .write_schemas(batch)?;
            }
        }

        Ok(())
```

**File:** storage/indexer/src/db_indexer.rs (L505-509)
```rust
        if self.indexer_db.event_v2_translation_enabled() {
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::EventV2TranslationVersion,
                &MetadataValue::Version(version - 1),
            )?;
```
