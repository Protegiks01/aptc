# Audit Report

## Title
Missing Block Validation During Fast-Forward Sync Allows Genesis Block Type Injection

## Summary
During fast-forward sync operations, blocks retrieved from remote peers bypass critical validation checks that would normally reject blocks with `BlockType::Genesis`. A malicious peer can inject a crafted block with the genesis type, which receives special treatment during block tree reconstruction, potentially corrupting the consensus state.

## Finding Description

The `is_genesis_block()` function identifies blocks based on their `BlockType` enum variant [1](#0-0) . Normal proposal validation explicitly rejects genesis blocks from network peers through two checks:

1. `validate_signature()` immediately fails with "We should not accept genesis from others" [2](#0-1) 

2. `verify_well_formed()` ensures `!self.is_genesis_block()` with the same error message [3](#0-2) 

However, the block retrieval path has a critical validation gap. The `BlockRetrievalResponse` struct includes a `verify()` method that calls both validation functions on each block [4](#0-3) , but this method is **never invoked** during fast-forward sync.

**Attack Path:**

1. When a node falls behind, it initiates `fast_forward_sync()` [5](#0-4) 

2. Blocks are retrieved via `retrieve_block_chunk()`, which sends RPC requests to peers [6](#0-5) 

3. When a response is received, it is returned directly on line 728 **without calling `verify()`** [7](#0-6) 

4. These unvalidated blocks are saved directly to storage [8](#0-7) 

5. During recovery, `find_root_with_window()` traverses blocks backward and uses `is_genesis_block()` as a stopping condition [9](#0-8) 

6. The injected fake genesis block causes premature termination, selecting an incorrect `window_start_block`

While honest nodes filter out genesis blocks when serving retrieval requests [10](#0-9) , a malicious peer can construct arbitrary `BlockRetrievalResponse` messages since the `BlockType::Genesis` variant is deserializable (unlike `DAGBlock` which has `#[serde(skip_deserializing)]`) [11](#0-10) .

## Impact Explanation

This vulnerability breaks **Consensus Safety** (Critical Invariant #2) by allowing malicious peers to corrupt a syncing node's view of the block tree. The incorrect window root selection can lead to:

- **Consensus divergence**: The victim node operates with a corrupted block tree structure
- **Liveness failures**: Incorrect root selection may prevent proper block ordering and execution
- **State inconsistencies**: The node's view of committed blocks may diverge from the network

This qualifies as **High Severity** under the Aptos bug bounty program as it constitutes a "significant protocol violation" that affects consensus integrity without requiring validator collusion.

## Likelihood Explanation

**Likelihood: Medium-High**

- **Trigger condition**: Occurs whenever a node falls behind and syncs from a malicious peer
- **Attacker requirements**: Must operate a network peer (no validator privileges needed)
- **Complexity**: Low - simply craft a `BlockRetrievalResponse` with `BlockType::Genesis`
- **Detection difficulty**: The injection may go unnoticed until consensus failures occur
- **Network exposure**: Any syncing node can request blocks from arbitrary peers

The attack is feasible for any malicious actor running a network peer, and syncing operations are common in blockchain networks.

## Recommendation

**Fix: Enforce validation of all retrieved blocks**

Add validation to `retrieve_block_chunk()` in `sync_manager.rs`:

```rust
async fn retrieve_block_chunk(
    &mut self,
    block_id: HashValue,
    target_block_retrieval_payload: TargetBlockRetrieval,
    retrieve_batch_size: u64,
    mut peers: Vec<AccountAddress>,
) -> anyhow::Result<BlockRetrievalResponse> {
    // ... existing code ...
    
    loop {
        tokio::select! {
            Some((peer, response)) = futures.next() => {
                match response {
                    Ok(result) => {
                        // ADD VALIDATION HERE
                        result.verify(request.clone(), &self.validator_verifier)?;
                        return Ok(result);
                    },
                    // ... rest of match ...
                }
            },
            // ... rest of select ...
        }
    }
}
```

The `BlockRetriever` struct should be modified to include a reference to the `ValidatorVerifier` for signature validation.

Additionally, consider making `BlockType::Genesis` non-deserializable by adding `#[serde(skip_deserializing)]` as an additional defense-in-depth measure.

## Proof of Concept

```rust
// Proof of Concept: Malicious peer crafting fake genesis block

use aptos_consensus_types::{
    block::Block,
    block_data::{BlockData, BlockType},
    block_retrieval::{BlockRetrievalResponse, BlockRetrievalStatus},
    quorum_cert::QuorumCert,
};
use aptos_crypto::HashValue;

// Step 1: Malicious peer receives BlockRetrievalRequest
// Step 2: Instead of returning honest blocks, craft a fake genesis block

fn craft_malicious_response(request_block_id: HashValue) -> BlockRetrievalResponse {
    // Create a block with Genesis type (normally only created locally)
    let fake_genesis_data = BlockData::new_for_testing(
        1,                          // epoch
        10,                         // round (not 0!)
        1234567890,                 // timestamp
        QuorumCert::dummy(),        // QC
        BlockType::Genesis,         // MALICIOUS: Genesis type on non-genesis block
    );
    
    let fake_genesis = Block::new_for_testing(
        request_block_id,
        fake_genesis_data,
        None,  // No signature needed for genesis
    );
    
    // Return response that will bypass validation
    BlockRetrievalResponse::new(
        BlockRetrievalStatus::SucceededWithTarget,
        vec![fake_genesis],
    )
}

// Step 3: When victim's find_root_with_window() encounters this block:
// - is_genesis_block() returns true (line 172 of persistent_liveness_storage.rs)
// - Loop terminates prematurely
// - Wrong window_start_block is selected
// - Block tree is corrupted

// Expected behavior: Response should be validated via BlockRetrievalResponse::verify()
// Actual behavior: No validation occurs, fake genesis block is accepted
```

**Notes**

The vulnerability stems from an architectural inconsistency: while the validation infrastructure exists (`BlockRetrievalResponse::verify()`), it is not integrated into the actual sync code path. This creates a bypass where blocks retrieved during sync receive different security treatment than blocks received through normal proposal flow.

### Citations

**File:** consensus/consensus-types/src/block_data.rs (L46-70)
```rust
    /// A genesis block is the first committed block in any epoch that is identically constructed on
    /// all validators by any (potentially different) LedgerInfo that justifies the epoch change
    /// from the previous epoch.  The genesis block is used as the first root block of the
    /// BlockTree for all epochs.
    Genesis,

    /// Proposal with extensions (e.g. system transactions).
    ProposalExt(ProposalExt),

    /// Optimistic proposal.
    OptimisticProposal(OptBlockBody),

    /// A virtual block that's constructed by nodes from DAG, this is purely a local thing so
    /// we hide it from serde
    #[serde(skip_deserializing)]
    DAGBlock {
        author: Author,
        failed_authors: Vec<(Round, Author)>,
        validator_txns: Vec<ValidatorTransaction>,
        payload: Payload,
        node_digests: Vec<HashValue>,
        parent_block_id: HashValue,
        parents_bitvec: BitVec,
    },
}
```

**File:** consensus/consensus-types/src/block_data.rs (L211-213)
```rust
    pub fn is_genesis_block(&self) -> bool {
        matches!(self.block_type, BlockType::Genesis)
    }
```

**File:** consensus/consensus-types/src/block.rs (L425-427)
```rust
    pub fn validate_signature(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        match self.block_data.block_type() {
            BlockType::Genesis => bail!("We should not accept genesis from others"),
```

**File:** consensus/consensus-types/src/block.rs (L469-473)
```rust
    pub fn verify_well_formed(&self) -> anyhow::Result<()> {
        ensure!(
            !self.is_genesis_block(),
            "We must not accept genesis from others"
        );
```

**File:** consensus/consensus-types/src/block_retrieval.rs (L260-281)
```rust
    pub fn verify(
        &self,
        retrieval_request: BlockRetrievalRequest,
        sig_verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        self.verify_inner(&retrieval_request)?;

        self.blocks
            .iter()
            .try_fold(retrieval_request.block_id(), |expected_id, block| {
                block.validate_signature(sig_verifier)?;
                block.verify_well_formed()?;
                ensure!(
                    block.id() == expected_id,
                    "blocks doesn't form a chain: expect {}, get {}",
                    expected_id,
                    block.id()
                );
                Ok(block.parent_id())
            })
            .map(|_| ())
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L365-403)
```rust
    pub async fn fast_forward_sync<'a>(
        highest_quorum_cert: &'a QuorumCert,
        highest_commit_cert: &'a WrappedLedgerInfo,
        retriever: &'a mut BlockRetriever,
        storage: Arc<dyn PersistentLivenessStorage>,
        execution_client: Arc<dyn TExecutionClient>,
        payload_manager: Arc<dyn TPayloadManager>,
        order_vote_enabled: bool,
        window_size: Option<u64>,
        maybe_block_store: Option<&'a BlockStore>,
    ) -> anyhow::Result<RecoveryData> {
        info!(
            LogSchema::new(LogEvent::StateSync).remote_peer(retriever.preferred_peer),
            "Start state sync to commit cert: {}, quorum cert: {}",
            highest_commit_cert,
            highest_quorum_cert,
        );

        let (target_block_retrieval_payload, num_blocks) =
            Self::generate_target_block_retrieval_payload_and_num_blocks(
                highest_quorum_cert,
                highest_commit_cert,
                window_size,
            );

        // although unlikely, we might wrap num_blocks around on a 32-bit machine
        assert!(num_blocks < usize::MAX as u64);

        BLOCKS_FETCHED_FROM_NETWORK_WHILE_FAST_FORWARD_SYNC.inc_by(num_blocks);
        let mut blocks = retriever
            .retrieve_blocks_in_range(
                highest_quorum_cert.certified_block().id(),
                num_blocks,
                target_block_retrieval_payload,
                highest_quorum_cert
                    .ledger_info()
                    .get_voters(&retriever.validator_addresses()),
            )
            .await?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L503-503)
```rust
        storage.save_tree(blocks.clone(), quorum_certs.clone())?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L570-572)
```rust
                        if !executed_block.block().is_genesis_block() {
                            blocks.push(executed_block.block().clone());
                        }
```

**File:** consensus/src/block_storage/sync_manager.rs (L667-778)
```rust
    async fn retrieve_block_chunk(
        &mut self,
        block_id: HashValue,
        target_block_retrieval_payload: TargetBlockRetrieval,
        retrieve_batch_size: u64,
        mut peers: Vec<AccountAddress>,
    ) -> anyhow::Result<BlockRetrievalResponse> {
        let mut failed_attempt = 0_u32;
        let mut cur_retry = 0;

        let num_retries = NUM_RETRIES;
        let request_num_peers = NUM_PEERS_PER_RETRY;
        let retry_interval = Duration::from_millis(RETRY_INTERVAL_MSEC);
        let rpc_timeout = Duration::from_millis(RPC_TIMEOUT_MSEC);

        monitor!("retrieve_block_for_id_chunk", {
            let mut interval = time::interval(retry_interval);
            let mut futures = FuturesUnordered::new();
            if retrieve_batch_size == 1 {
                let (tx, rx) = oneshot::channel();
                self.pending_blocks
                    .lock()
                    .insert_request(target_block_retrieval_payload, tx);
                let author = self.network.author();
                futures.push(
                    async move {
                        let response = match timeout(rpc_timeout, rx).await {
                            Ok(Ok(block)) => Ok(BlockRetrievalResponse::new(
                                BlockRetrievalStatus::SucceededWithTarget,
                                vec![block],
                            )),
                            Ok(Err(_)) => Err(anyhow!("self retrieval cancelled")),
                            Err(_) => Err(anyhow!("self retrieval timeout")),
                        };
                        (author, response)
                    }
                    .boxed(),
                )
            }
            let request = match target_block_retrieval_payload {
                TargetBlockRetrieval::TargetBlockId(target_block_id) => {
                    BlockRetrievalRequest::V1(BlockRetrievalRequestV1::new_with_target_block_id(
                        block_id,
                        retrieve_batch_size,
                        target_block_id,
                    ))
                },
                TargetBlockRetrieval::TargetRound(target_round) => {
                    BlockRetrievalRequest::V2(BlockRetrievalRequestV2::new_with_target_round(
                        block_id,
                        retrieve_batch_size,
                        target_round,
                    ))
                },
            };

            loop {
                tokio::select! {
                    biased;
                    Some((peer, response)) = futures.next() => {
                        match response {
                            Ok(result) => return Ok(result),
                            e => {
                                warn!(
                                    remote_peer = peer,
                                    block_id = block_id,
                                    "{:?}, Failed to fetch block",
                                    e,
                                );
                                failed_attempt += 1;
                            },
                        }
                    },
                    _ = interval.tick() => {
                        // send batch request to a set of peers of size request_num_peers (or 1 for the first time)
                        let next_peers = if cur_retry < num_retries {
                            let first_attempt = cur_retry == 0;
                            cur_retry += 1;
                            self.pick_peers(
                                first_attempt,
                                &mut peers,
                                if first_attempt { 1 } else {request_num_peers}
                            )
                        } else {
                            Vec::new()
                        };

                        if next_peers.is_empty() && futures.is_empty() {
                            bail!("Couldn't fetch block")
                        }

                        for peer in next_peers {
                            debug!(
                                LogSchema::new(LogEvent::RetrieveBlock).remote_peer(peer),
                                block_id = block_id,
                                "Fetching {} blocks, retry {}, failed attempts {}",
                                retrieve_batch_size,
                                cur_retry,
                                failed_attempt
                            );
                            let remote_peer = peer;
                            let future = self.network.request_block(
                                request.clone(),
                                peer,
                                rpc_timeout,
                            );
                            futures.push(async move { (remote_peer, future.await) }.boxed());
                        }
                    }
                }
            }
        })
```

**File:** consensus/src/persistent_liveness_storage.rs (L172-174)
```rust
        while !current_block.is_genesis_block()
            && current_block.quorum_cert().certified_block().round() >= window_start_round
        {
```
