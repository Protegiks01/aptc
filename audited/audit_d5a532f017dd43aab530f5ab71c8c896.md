# Audit Report

## Title
Signature Verification Bypass in Waypoint-Based Epoch Change Validation

## Summary
The `Waypoint::verify()` implementation in the `Verifier` trait does not validate BLS signatures on `LedgerInfoWithSignatures`, only checking hash and version matching. This allows an attacker to construct an `EpochChangeProof` with unsigned or incorrectly signed ledger information that passes waypoint verification, bypassing the fundamental BFT requirement that epoch changes must be approved by 2f+1 validators.

## Finding Description

The vulnerability exists in the implementation of the `Verifier` trait for `Waypoint`: [1](#0-0) 

The `verify()` method calls `ledger_info.ledger_info()`, which is a simple getter that extracts the inner `LedgerInfo` without performing any signature validation: [2](#0-1) 

In contrast, the `EpochState` implementation of the `Verifier` trait correctly validates signatures: [3](#0-2) 

The critical usage occurs in `SafetyRules::guarded_initialize()`, which validates epoch change proofs during validator initialization: [4](#0-3) 

The `EpochChangeProof::verify()` method uses the provided verifier (waypoint in this case) to validate each ledger info: [5](#0-4) 

**Attack Path:**
1. Attacker obtains a legitimate `LedgerInfo` that corresponds to a known waypoint (version + hash match)
2. Attacker constructs a `LedgerInfoWithSignatures` with this legitimate `LedgerInfo` but with empty or invalid signatures
3. Attacker creates an `EpochChangeProof` starting with this crafted entry
4. When a node verifies this proof using the waypoint verifier:
   - Waypoint verification only checks hash and version (no signature check)
   - The proof is accepted without proper 2f+1 validator consensus
   - The node updates its epoch state based on this unverified epoch change

**Invariant Violation:**
This breaks the **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine". The system assumes that epoch changes have been properly signed by 2f+1 validators, but waypoint verification allows accepting epoch changes without any signature validation.

## Impact Explanation

**Critical Severity** - This vulnerability breaks fundamental consensus safety guarantees:

1. **Consensus Safety Violation**: The BFT protocol requires that epoch changes be approved by 2f+1 validators through their signatures. By bypassing signature validation, an attacker can cause nodes to accept epoch changes that never achieved proper consensus.

2. **Network Partition Risk**: During node synchronization or validator initialization, different nodes could accept different unsigned epoch changes, leading to chain splits and consensus failures.

3. **Trust Model Violation**: Waypoints are designed to be cryptographic commitments to known-good states, but the code incorrectly assumes that matching a waypoint hash implies valid signatures. This misuse allows complete bypass of the signature validation requirement.

4. **Bootstrap Attack Surface**: Any node bootstrapping from a waypoint is vulnerable. An attacker controlling network traffic during sync can provide unsigned epoch change proofs that will be accepted.

The test suite even validates that invalid signatures should fail verification with `EpochState`, but no equivalent test exists for waypoint verification: [6](#0-5) 

## Likelihood Explanation

**High Likelihood** - This vulnerability is easily exploitable:

1. **Attack Surface**: Triggered during node synchronization, validator initialization, and any time `SafetyRules::initialize()` is called with an `EpochChangeProof`

2. **Attacker Requirements**: 
   - Knowledge of a legitimate waypoint (publicly available)
   - Ability to construct or intercept an `EpochChangeProof`
   - No validator private keys required
   - No collusion with honest validators needed

3. **Detection Difficulty**: The attack produces correctly formed data structures that pass validation checks, making it difficult to detect without deep inspection of signature validity

4. **Deployment Frequency**: Every node sync, every validator restart, and every epoch initialization creates an opportunity for exploitation

## Recommendation

The `Waypoint::verify()` implementation must validate signatures before accepting a `LedgerInfoWithSignatures`. However, waypoints don't contain validator set information, so they cannot directly verify signatures.

**Option 1: Reject waypoint-only verification for LedgerInfoWithSignatures**
```rust
impl Verifier for Waypoint {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> Result<()> {
        // Waypoints cannot verify signatures - they should only be used
        // as a starting point, with subsequent verification using EpochState
        Err(format_err!(
            "Waypoint verification requires signature validation which waypoints cannot perform. \
             Use EpochState verifier after establishing initial trust."
        ))
    }
    // ... rest of implementation
}
```

**Option 2: Add a separate method for hash-only verification**
```rust
impl Waypoint {
    /// Verify only the hash and version, NOT signatures
    /// Should only be used when signatures are verified separately
    pub fn verify_hash_only(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
}

impl Verifier for Waypoint {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> Result<()> {
        // Verify hash matches
        self.verify_hash_only(ledger_info.ledger_info())?;
        
        // Waypoints cannot verify signatures themselves
        // Return error to force caller to explicitly handle signature verification
        Err(format_err!(
            "Waypoint matched but signatures must be verified separately with a ValidatorVerifier"
        ))
    }
}
```

**Option 3: Modify EpochChangeProof::verify() to require signature verification**

The most secure fix is to ensure that even when starting from a waypoint, the first ledger info's signatures are verified using information from the waypoint itself or through an alternative trust mechanism.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::{
        aggregate_signature::AggregateSignature,
        block_info::BlockInfo,
        epoch_change::EpochChangeProof,
        epoch_state::EpochState,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        validator_verifier::random_validator_verifier,
    };
    use aptos_crypto::hash::HashValue;

    #[test]
    fn test_waypoint_accepts_unsigned_epoch_change() {
        // Create a validator set and generate a legitimate epoch-ending ledger info
        let (signers, verifier) = random_validator_verifier(4, None, true);
        let verifier = std::sync::Arc::new(verifier);
        
        let next_epoch_state = EpochState {
            epoch: 2,
            verifier: verifier.clone(),
        };
        
        let ledger_info = LedgerInfo::new(
            BlockInfo::new(
                1,
                0,
                HashValue::zero(),
                HashValue::zero(),
                100,
                0,
                Some(next_epoch_state),
            ),
            HashValue::zero(),
        );
        
        // Create waypoint from this ledger info
        let waypoint = Waypoint::new_epoch_boundary(&ledger_info).unwrap();
        
        // Create unsigned LedgerInfoWithSignatures (ATTACK)
        let unsigned_li = LedgerInfoWithSignatures::new(
            ledger_info.clone(),
            AggregateSignature::empty(), // NO VALID SIGNATURES!
        );
        
        // Verify with EpochState (should FAIL)
        let epoch_state = EpochState {
            epoch: 1,
            verifier: verifier.clone(),
        };
        assert!(
            unsigned_li.verify_signatures(&verifier).is_err(),
            "Unsigned ledger info should fail signature verification"
        );
        
        // Verify with Waypoint (currently SUCCEEDS - this is the bug!)
        assert!(
            waypoint.verify(&unsigned_li).is_ok(),
            "BUG: Waypoint accepts unsigned ledger info!"
        );
        
        // Create epoch change proof with unsigned ledger info
        let malicious_proof = EpochChangeProof::new(vec![unsigned_li], false);
        
        // Proof verification with waypoint succeeds (BUG!)
        assert!(
            malicious_proof.verify(&waypoint).is_ok(),
            "BUG: EpochChangeProof with unsigned ledger info accepted by waypoint!"
        );
        
        // But same proof should fail with EpochState
        assert!(
            malicious_proof.verify(&epoch_state).is_err(),
            "Unsigned proof correctly rejected by EpochState"
        );
    }
}
```

This proof of concept demonstrates that:
1. A `LedgerInfoWithSignatures` with empty signatures fails `verify_signatures()` 
2. The same unsigned object passes `Waypoint::verify()` 
3. An `EpochChangeProof` containing this unsigned ledger info is accepted by waypoint verification but rejected by epoch state verification

This shows the signature validation bypass is real and exploitable.

## Notes

The vulnerability stems from a fundamental design issue: waypoints are cryptographic hash commitments that cannot inherently verify signatures (they don't contain validator public keys). However, the `Verifier` trait interface assumes all verifiers can validate complete `LedgerInfoWithSignatures` objects including signatures. This mismatch allows the waypoint implementation to silently skip signature validation, breaking the BFT security model.

The fix requires either:
1. Changing the `Verifier` trait to make signature validation explicit and mandatory
2. Preventing waypoints from being used as standalone verifiers for `LedgerInfoWithSignatures`
3. Ensuring callers of waypoint verification explicitly validate signatures separately

The current test suite [7](#0-6)  only tests waypoint verification with properly signed ledger infos, missing the critical test case where signatures are invalid or missing.

### Citations

**File:** types/src/waypoint.rs (L82-85)
```rust
impl Verifier for Waypoint {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> Result<()> {
        self.verify(ledger_info.ledger_info())
    }
```

**File:** types/src/ledger_info.rs (L283-285)
```rust
    pub fn ledger_info(&self) -> &LedgerInfo {
        &self.ledger_info
    }
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L265-269)
```rust
    fn guarded_initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error> {
        let waypoint = self.persistent_storage.waypoint()?;
        let last_li = proof
            .verify(&waypoint)
            .map_err(|e| Error::InvalidEpochChangeProof(format!("{}", e)))?;
```

**File:** types/src/epoch_change.rs (L66-118)
```rust
    pub fn verify(&self, verifier: &dyn Verifier) -> Result<&LedgerInfoWithSignatures> {
        ensure!(
            !self.ledger_info_with_sigs.is_empty(),
            "The EpochChangeProof is empty"
        );
        ensure!(
            !verifier
                .is_ledger_info_stale(self.ledger_info_with_sigs.last().unwrap().ledger_info()),
            "The EpochChangeProof is stale as our verifier is already ahead \
             of the entire EpochChangeProof"
        );
        let mut verifier_ref = verifier;

        for ledger_info_with_sigs in self
            .ledger_info_with_sigs
            .iter()
            // Skip any stale ledger infos in the proof prefix. Note that with
            // the assertion above, we are guaranteed there is at least one
            // non-stale ledger info in the proof.
            //
            // It's useful to skip these stale ledger infos to better allow for
            // concurrent client requests.
            //
            // For example, suppose the following:
            //
            // 1. My current trusted state is at epoch 5.
            // 2. I make two concurrent requests to two validators A and B, who
            //    live at epochs 9 and 11 respectively.
            //
            // If A's response returns first, I will ratchet my trusted state
            // to epoch 9. When B's response returns, I will still be able to
            // ratchet forward to 11 even though B's EpochChangeProof
            // includes a bunch of stale ledger infos (for epochs 5, 6, 7, 8).
            //
            // Of course, if B's response returns first, we will reject A's
            // response as it's completely stale.
            .skip_while(|&ledger_info_with_sigs| {
                verifier.is_ledger_info_stale(ledger_info_with_sigs.ledger_info())
            })
        {
            // Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof.
            verifier_ref.verify(ledger_info_with_sigs)?;
            // While the original verification could've been via waypoints,
            // all the next epoch changes are verified using the (already
            // trusted) validator sets.
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
        }

        Ok(self.ledger_info_with_sigs.last().unwrap())
    }
```

**File:** types/src/epoch_change.rs (L256-269)
```rust
        // Test proof with invalid signatures will fail
        let proof_6 = EpochChangeProof::new(
            vec![LedgerInfoWithSignatures::new(
                valid_ledger_info[0].ledger_info().clone(),
                AggregateSignature::empty(),
            )],
            /* more = */ false,
        );
        assert!(proof_6
            .verify(&EpochState {
                epoch: all_epoch[0],
                verifier: validator_verifier[0].clone(),
            })
            .is_err());
```

**File:** types/src/epoch_change.rs (L271-279)
```rust
        // Test proof with waypoint corresponding to the first epoch change succeeds.
        let waypoint_for_1_to_2 =
            Waypoint::new_epoch_boundary(valid_ledger_info[0].ledger_info()).unwrap();
        assert!(proof_1.verify(&waypoint_for_1_to_2).is_ok());

        // Test proof with stale prefix will verify with a Waypoint
        let waypoint_for_5_to_6 =
            Waypoint::new_epoch_boundary(valid_ledger_info[4].ledger_info()).unwrap();
        assert!(proof_1.verify(&waypoint_for_5_to_6).is_ok());
```
