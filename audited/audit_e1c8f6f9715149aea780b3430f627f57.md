# Audit Report

## Title
Silent DKG Failure: Missing Identity Validation in Convert::to() Allows Cryptographically Trivial Keys

## Summary
The `Convert::to()` trait implementation for transforming `InputSecret` to `DealtSecretKey` lacks validation to ensure the resulting group element is non-identity. A zero input secret (whether from malicious dealing or potential bugs) produces an identity element that passes all PVSS verification checks but yields a cryptographically trivial key, breaking the randomness generation system only when the key is used.

## Finding Description

The DKG system's `Convert` trait defines a conversion from `InputSecret` to `DealtSecretKey` without any error handling mechanism: [1](#0-0) 

The DAS PVSS implementation converts input secrets by multiplying a base group element by the secret scalar: [2](#0-1) 

**Critical Issue**: If `self.get_secret_a()` returns `Scalar::ZERO`, the multiplication produces the identity element in G1. The `DealtSecretKey::new()` constructor accepts this without validation: [3](#0-2) 

**Attack Path:**

1. **Input Creation**: While `random_scalar()` theoretically could return zero (probability ~2^-255), a malicious validator could deliberately construct `InputSecret { a: Scalar::ZERO }` [4](#0-3) 

2. **Transcript Dealing**: The zero secret passes through dealing successfully because:
   - Schnorr PoK with secret=0 verifies correctly: `g^0 = identity` and proof equation `g^r = g^r * identity^e` holds
   - Low-degree test passes (zero polynomial is valid low-degree)
   - Encryption correctness checks pass (encryptions are well-formed) [5](#0-4) 

3. **Silent Conversion**: `dealt_secret_from_input()` silently converts the zero secret to an identity element: [6](#0-5) 

4. **Failure at Usage**: The vulnerability only manifests when the VUF evaluation occurs. The pairing of an identity element with any message produces the identity in the target group (a constant predictable value): [7](#0-6) 

Since `pairing(identity_G1, h) = identity_GT` for any hash `h`, the randomness generation returns a constant predictable value, completely breaking the cryptographic security.

## Impact Explanation

**Severity: CRITICAL** (per Aptos Bug Bounty criteria)

This vulnerability breaks **Cryptographic Correctness** (Invariant #10), specifically the security of the VUF-based randomness generation system:

1. **Randomness Predictability**: The VUF evaluation with an identity secret key produces `identity_GT` regardless of input, yielding predictable "random" values
2. **Consensus Impact**: Compromised randomness affects leader election, transaction ordering, and other consensus-critical operations
3. **Silent Failure Mode**: The DKG completes without errors, making detection difficult until randomness is used
4. **Network-Wide Effect**: All validators using shares from the compromised DKG would generate the same predictable randomness

This qualifies as "Consensus/Safety violations" and "Significant protocol violations," potentially reaching Critical severity due to the fundamental compromise of the randomness system that underpins consensus security.

## Likelihood Explanation

**Likelihood: Low-Medium**

While random generation returning zero is astronomically unlikely (probability ~2^-255), the vulnerability has realistic attack vectors:

1. **Malicious Validator**: A compromised validator could deliberately deal a zero secret during DKG
2. **Software Bugs**: Future code changes might inadvertently create zero secrets through logic errors
3. **Defense in Depth**: The lack of validation violates defense-in-depth principlesâ€”critical cryptographic operations should validate their inputs

The `random_scalar_internal()` function supports an `exclude_zero` parameter, indicating the developers recognized that zero values are problematic: [8](#0-7) 

However, this protection is not enabled for `InputSecret` generation, and more critically, no validation exists in the conversion or verification paths.

## Recommendation

Implement multi-layered validation to prevent identity elements in dealt secrets:

1. **At Conversion**: Add validation in `Convert::to()` implementations:
```rust
impl traits::Convert<DealtSecretKey, das::PublicParameters> for InputSecret {
    fn to(&self, pp: &das::PublicParameters) -> DealtSecretKey {
        // Validate input secret is non-zero
        if self.get_secret_a().is_zero_vartime() {
            panic!("InputSecret cannot be zero");
        }
        
        let dealt_sk = DealtSecretKey::new(
            pp.get_encryption_public_params()
                .message_base()
                .mul(self.get_secret_a()),
        );
        
        // Validate result is non-identity
        if dealt_sk.as_group_element().is_identity().into() {
            panic!("DealtSecretKey cannot be identity element");
        }
        
        dealt_sk
    }
}
```

2. **At Verification**: Add identity checks in transcript verification to catch malformed transcripts:
```rust
// In verify() method after line 259
if self.V[sc.n].is_identity().into() {
    bail!("Dealt public key commitment cannot be identity element");
}
```

3. **At Generation**: Use `random_scalar_internal(rng, true)` to exclude zero when generating input secrets.

4. **At Reconstruction**: Validate reconstructed keys before use in VUF evaluation.

## Proof of Concept

```rust
#[cfg(test)]
mod test_zero_secret_vulnerability {
    use super::*;
    use crate::pvss::input_secret::InputSecret;
    use crate::pvss::traits::Convert;
    use blstrs::Scalar;
    use ff::Field;
    
    #[test]
    #[should_panic(expected = "identity")]  // This will NOT panic currently
    fn test_zero_input_secret_produces_identity() {
        // Create zero input secret (malicious case)
        let zero_secret = InputSecret::zero();
        assert!(zero_secret.is_zero());
        
        // Setup public parameters
        let pp = das::PublicParameters::default_with_bls_base();
        
        // Convert to dealt secret - currently NO validation!
        let dealt_secret: DealtSecretKey = zero_secret.to(&pp);
        
        // Verify the dealt secret is the identity element
        assert!(dealt_secret.as_group_element().is_identity().into(),
                "Zero input secret produced identity dealt secret key");
        
        // When used in VUF, this produces constant predictable output
        let msg = b"test message";
        let vuf_output = PinkasWUF::eval(&dealt_secret, msg);
        assert!(vuf_output.is_identity().into(),
                "VUF with identity key produces identity output");
    }
}
```

**Expected Behavior**: The system should panic or return an error when attempting to convert a zero secret or when verifying a transcript with identity commitments.

**Actual Behavior**: The conversion succeeds silently, allowing a cryptographically broken key to propagate through the system.

---

**Notes**

While the probability of accidental occurrence is negligible, this represents a critical defense-in-depth violation. Cryptographic systems should validate inputs at every layer, especially when dealing with group elements that have special properties like the identity element. The existence of the `exclude_zero` parameter in `random_scalar_internal()` suggests awareness of this issue, but the protection is not consistently applied throughout the DKG pipeline.

### Citations

**File:** crates/aptos-dkg/src/pvss/traits/mod.rs (L10-12)
```rust
pub trait Convert<ToType, AuxType> {
    fn to(&self, with: &AuxType) -> ToType;
}
```

**File:** crates/aptos-dkg/src/pvss/das/input_secret.rs (L14-21)
```rust
impl traits::Convert<DealtSecretKey, das::PublicParameters> for InputSecret {
    fn to(&self, pp: &das::PublicParameters) -> DealtSecretKey {
        DealtSecretKey::new(
            pp.get_encryption_public_params()
                .message_base()
                .mul(self.get_secret_a()),
        )
    }
```

**File:** crates/aptos-dkg/src/pvss/dealt_secret_key.rs (L58-61)
```rust
        impl DealtSecretKey {
            pub fn new(h_hat: $GTProjective) -> Self {
                Self { h_hat }
            }
```

**File:** crates/aptos-crypto/src/input_secret.rs (L53-60)
```rust
impl Zero for InputSecret {
    fn zero() -> Self {
        InputSecret { a: Scalar::ZERO }
    }

    fn is_zero(&self) -> bool {
        self.a.is_zero_vartime()
    }
```

**File:** crates/aptos-dkg/src/pvss/das/unweighted_protocol.rs (L226-313)
```rust
    fn verify<A: Serialize + Clone>(
        &self,
        sc: &<Self as traits::Transcript>::SecretSharingConfig,
        pp: &Self::PublicParameters,
        spks: &[Self::SigningPubKey],
        eks: &[Self::EncryptPubKey],
        auxs: &[A],
    ) -> anyhow::Result<()> {
        if eks.len() != sc.n {
            bail!("Expected {} encryption keys, but got {}", sc.n, eks.len());
        }

        if self.C.len() != sc.n {
            bail!("Expected {} ciphertexts, but got {}", sc.n, self.C.len());
        }

        if self.V.len() != sc.n + 1 {
            bail!(
                "Expected {} (polynomial) commitment elements, but got {}",
                sc.n + 1,
                self.V.len()
            );
        }

        // Deriving challenges by flipping coins: less complex to implement & less likely to get wrong. Creates bad RNG risks but we deem that acceptable.
        let mut rng = thread_rng();
        let extra = random_scalars(2, &mut rng);

        // Verify signature(s) on the secret commitment, player ID and `aux`
        let g_2 = *pp.get_commitment_base();
        batch_verify_soks::<G2Projective, A>(
            self.soks.as_slice(),
            &g_2,
            &self.V[sc.n],
            spks,
            auxs,
            &extra[0],
        )?;

        // Verify the committed polynomial is of the right degree
        let ldt = LowDegreeTest::random(
            &mut rng,
            sc.t,
            sc.n + 1,
            true,
            sc.get_batch_evaluation_domain(),
        );
        ldt.low_degree_test_on_g2(&self.V)?;

        //
        // Correctness of encryptions check
        //
        // (see [WVUF Overleaf](https://www.overleaf.com/project/63a1c2c222be94ece7c4b862) for
        //  explanation of how batching works)
        //

        // TODO(Performance): Change the Fiat-Shamir transform to use 128-bit random exponents.
        // r_i = \tau^i, \forall i \in [n]
        // TODO: benchmark this
        let taus = get_nonzero_powers_of_tau(&extra[1], sc.n);

        // Compute the multiexps from above.
        let v = g2_multi_exp(&self.V[..self.V.len() - 1], taus.as_slice());
        let ek = g1_multi_exp(
            eks.iter()
                .map(|ek| Into::<G1Projective>::into(ek))
                .collect::<Vec<G1Projective>>()
                .as_slice(),
            taus.as_slice(),
        );
        let c = g1_multi_exp(self.C.as_slice(), taus.as_slice());

        // Fetch some public parameters
        let h_1 = *pp.get_encryption_public_params().message_base();
        let g_1_inverse = pp.get_encryption_public_params().pubkey_base().neg();

        // The vector of left-hand-side ($\mathbb{G}_1$) inputs to each pairing in the multi-pairing.
        let lhs = vec![h_1, ek.add(g_1_inverse), self.C_0.add(c.neg())];
        // The vector of right-hand-side ($\mathbb{G}_2$) inputs to each pairing in the multi-pairing.
        let rhs = vec![v, self.hat_w, g_2];

        let res = multi_pairing(lhs.iter(), rhs.iter());
        if res != Gt::identity() {
            bail!("Expected zero, but got {} during multi-pairing check", res);
        }

        return Ok(());
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L234-239)
```rust
    fn dealt_secret_from_input(
        pub_params: &Self::PublicParams,
        input: &Self::InputSecret,
    ) -> Self::DealtSecret {
        input.to(&pub_params.pvss_config.pp)
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L185-189)
```rust
    fn eval(sk: &Self::SecretKey, msg: &[u8]) -> Self::Evaluation {
        let h = Self::hash_to_curve(msg).to_affine();

        pairing(&sk.as_group_element().to_affine(), &h)
    }
```

**File:** crates/aptos-crypto/src/blstrs/mod.rs (L174-194)
```rust
/// Returns a random `blstrs::Scalar`, optionally restricted to be non-zero.
pub fn random_scalar_internal<R>(rng: &mut R, exclude_zero: bool) -> Scalar
where
    R: rand_core::RngCore + rand::Rng + rand_core::CryptoRng + rand::CryptoRng,
{
    let mut big_uint;

    loop {
        // NOTE(Alin): This uses rejection-sampling (e.g., https://cs.stackexchange.com/a/2578/54866)
        // An alternative would be to sample twice the size of the scalar field and use
        // `random_scalar_from_uniform_bytes`, but that is actually slower (950ns vs 623ns)
        big_uint = rng.gen_biguint_below(&SCALAR_FIELD_ORDER);

        // Some key material cannot be zero since it needs to have an inverse in the scalar field.
        if !exclude_zero || !big_uint.is_zero() {
            break;
        }
    }

    biguint_to_scalar(&big_uint)
}
```
