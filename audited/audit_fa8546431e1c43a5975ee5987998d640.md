# Audit Report

## Title
Governance-Triggered Network Halt via VM Binary Format Version Downgrade

## Summary
Disabling all VM binary format version feature flags through governance causes the `get_max_binary_format_version()` function to return VERSION_5, which is incompatible with the VERSION_9 bytecode of the Aptos Framework modules. This results in complete network failure as all transactions fail during module deserialization, requiring a hardfork to recover.

## Finding Description

The vulnerability exists in the cascading logic of `get_max_binary_format_version()`: [1](#0-0) 

When all VM version feature flags (VM_BINARY_FORMAT_V6, V7, V8, V9, V10) are disabled through governance, this function returns VERSION_5. This value is then used to configure the deserializer: [2](#0-1) 

The deserializer validates bytecode versions during module loading: [3](#0-2) 

This check only validates the **upper bound** - it rejects bytecode with `version > min(max_version, VERSION_MAX)`, but does **not** check against VERSION_MIN. When max_version is set to VERSION_5, any bytecode with version 6+ is rejected with `UNKNOWN_VERSION` error.

The critical issue is that the Aptos Framework is compiled with VERSION_DEFAULT: [4](#0-3) [5](#0-4) 

This means the framework is VERSION_9 bytecode. The governance system has **no validation** preventing disabling these flags: [6](#0-5) 

The `change_feature_flags_for_next_epoch()` function applies enable/disable vectors without any checks on which flags can be disabled.

**Attack Path:**
1. Malicious actor creates governance proposal to disable VM_BINARY_FORMAT_V6, V7, V8, V9, V10
2. Proposal passes governance voting
3. At next epoch, `on_new_epoch()` applies the changes
4. All validators create new `AptosEnvironment` fetching updated Features config
5. `get_max_binary_format_version()` now returns VERSION_5
6. Any transaction attempting to load framework modules (VERSION_9) fails during deserialization
7. All transactions fail with `CODE_DESERIALIZATION_ERROR`
8. Network completely halts - no blocks can be produced with valid transactions [7](#0-6) 

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per Aptos bug bounty:

- **Total loss of liveness/network availability**: No transactions can execute as all framework module loads fail
- **Non-recoverable network partition (requires hardfork)**: The only recovery path is a hardfork to either:
  1. Re-enable the version flags (but governance can't execute if transactions fail)
  2. Override the feature flags at the node level (requires coordinated validator action)
  3. Recompile the framework to VERSION_5 (requires hardfork)

The network would be completely non-functional, unable to process any transactions including governance proposals to reverse the change. This represents the highest severity impact category with up to $1,000,000 bounty value.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Ability to create and pass a governance proposal
- Sufficient voting power or social engineering to convince governance participants
- No special validator access required

**Complexity:**
- Attack is straightforward - single governance proposal
- No technical exploit complexity
- The feature flags appear to be "safe" configuration changes, making social engineering plausible
- Could be disguised as "performance optimization" or "security rollback"

**Mitigating Factors:**
- Requires governance approval (but this is by design, not a security barrier)
- Community might notice suspicious proposal
- However, the flags have documentation comments like "transient" and "needs to stay on" which are not enforced [8](#0-7) 

The comment "needs to stay on" is purely advisory with no enforcement.

## Recommendation

Implement mandatory validation in the feature flag change functions to prevent disabling VM version flags once the framework depends on them:

```move
// In features.move, modify change_feature_flags_for_next_epoch():
fun apply_diff(features: &mut vector<u8>, enable: vector<u64>, disable: vector<u64>) {
    enable.for_each(|feature| {
        set(features, feature, true);
    });
    disable.for_each(|feature| {
        // Prevent disabling VM version flags that framework depends on
        assert!(
            feature != VM_BINARY_FORMAT_V6 &&
            feature != VM_BINARY_FORMAT_V7 &&
            feature != VM_BINARY_FORMAT_V8 &&
            feature != VM_BINARY_FORMAT_V9 &&
            feature != VM_BINARY_FORMAT_V10,
            error::invalid_argument(EFEATURE_CANNOT_BE_DISABLED)
        );
        set(features, feature, false);
    });
}
```

Alternatively, add validation based on the current framework version:

```rust
// In aptos_features.rs, add validation:
pub fn get_max_binary_format_version(&self) -> u32 {
    let version = if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10) {
        file_format_common::VERSION_10
    } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V9) {
        file_format_common::VERSION_9
    } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V8) {
        file_format_common::VERSION_8
    } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V7) {
        file_format_common::VERSION_7
    } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V6) {
        file_format_common::VERSION_6
    } else {
        file_format_common::VERSION_5
    };
    
    // Ensure version is at least VERSION_MIN
    std::cmp::max(version, file_format_common::VERSION_MIN)
}
```

However, the Move-level validation is preferred as it prevents the dangerous configuration from being set in the first place.

## Proof of Concept

**Move Test to Demonstrate Configuration:**

```move
#[test(framework = @std)]
fun test_vm_version_flags_disable_causes_failure(framework: signer) {
    use std::features;
    
    // Simulate disabling all VM version flags
    features::change_feature_flags_for_testing(
        &framework,
        vector[], // enable nothing
        vector[
            features::get_vm_binary_format_v6(),
            40, // VM_BINARY_FORMAT_V7
            86, // VM_BINARY_FORMAT_V8  
            102, // VM_BINARY_FORMAT_V9
            106, // VM_BINARY_FORMAT_V10
        ]
    );
    
    // After this, get_max_binary_format_version() would return VERSION_5
    // Any attempt to load VERSION_6+ modules would fail
}
```

**Rust Reproduction Steps:**

1. Create a test that modifies Features config to disable all version flags
2. Construct a CompiledModule with VERSION_9 bytecode
3. Create DeserializerConfig with max_binary_format_version = VERSION_5
4. Attempt to deserialize the module with this config
5. Observe `UNKNOWN_VERSION` error

```rust
#[test]
fn test_version_5_rejects_version_9_modules() {
    use move_binary_format::{CompiledModule, file_format_common};
    use move_binary_format::deserializer::DeserializerConfig;
    
    // Create module with VERSION_9
    let module_v9 = create_test_module_with_version(file_format_common::VERSION_9);
    let bytes = serialize_module(&module_v9);
    
    // Create config with VERSION_5 as max
    let config = DeserializerConfig::new(
        file_format_common::VERSION_5,
        file_format_common::IDENTIFIER_SIZE_MAX
    );
    
    // This should fail with UNKNOWN_VERSION
    let result = CompiledModule::deserialize_with_config(&bytes, &config);
    assert!(result.is_err());
    assert_eq!(result.unwrap_err().major_status(), StatusCode::UNKNOWN_VERSION);
}
```

## Notes

This vulnerability demonstrates a critical gap between governance flexibility and system invariant enforcement. While VERSION_5 is technically the minimum supported version, the framework's reliance on VERSION_9 creates an implicit dependency that is not validated. The comment "needs to stay on" for V6 acknowledges the issue but provides no enforcement mechanism, leaving the network vulnerable to accidental or malicious misconfiguration through governance.

### Citations

**File:** types/src/on_chain_config/aptos_features.rs (L177-180)
```rust
            // Feature flag V6 is used to enable metadata v1 format and needs to stay on, even
            // if we enable a higher version.
            FeatureFlag::VM_BINARY_FORMAT_V6,
            FeatureFlag::VM_BINARY_FORMAT_V7,
```

**File:** types/src/on_chain_config/aptos_features.rs (L485-499)
```rust
    pub fn get_max_binary_format_version(&self) -> u32 {
        if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10) {
            file_format_common::VERSION_10
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V9) {
            file_format_common::VERSION_9
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V8) {
            file_format_common::VERSION_8
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V7) {
            file_format_common::VERSION_7
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V6) {
            file_format_common::VERSION_6
        } else {
            file_format_common::VERSION_5
        }
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L137-142)
```rust
pub fn aptos_prod_deserializer_config(features: &Features) -> DeserializerConfig {
    DeserializerConfig::new(
        features.get_max_binary_format_version(),
        features.get_max_identifier_size(),
    )
}
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L571-571)
```rust
pub const VERSION_DEFAULT: u32 = VERSION_9;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L617-620)
```rust
            if version == 0 || version > u32::min(max_version, VERSION_MAX) {
                Err(PartialVMError::new(StatusCode::UNKNOWN_VERSION)
                    .with_message(format!("bytecode version {} unsupported", version)))
            } else {
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L775-778)
```rust
                    update_sequence: vec![ReleaseEntry::Framework(FrameworkReleaseConfig {
                        bytecode_version: VERSION_DEFAULT,
                        git_hash: None,
                    })],
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L805-828)
```text
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L248-256)
```rust
    pub fn deserialize_into_compiled_module(&self, bytes: &Bytes) -> VMResult<CompiledModule> {
        CompiledModule::deserialize_with_config(bytes, &self.vm_config().deserializer_config)
            .map_err(|err| {
                let msg = format!("Deserialization error: {:?}", err);
                PartialVMError::new(StatusCode::CODE_DESERIALIZATION_ERROR)
                    .with_message(msg)
                    .finish(Location::Undefined)
            })
    }
```
