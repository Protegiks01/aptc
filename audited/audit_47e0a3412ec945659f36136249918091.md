# Audit Report

## Title
Event Notification System Failure Due to Orphaned Subscriptions Breaking State Synchronization

## Summary
The `EventSubscriptionService` lacks an unsubscribe mechanism, causing dead subscriptions to accumulate when components crash or stop. When notifications are sent to these orphaned subscriptions, the closed channel error propagates and terminates event processing for ALL active subscribers, breaking critical consensus and state synchronization features.

## Finding Description

The vulnerability exists in the event notification system's design, which has no mechanism to remove subscriptions when their receivers are dropped. [1](#0-0) 

The `subscribe_to_events()` function creates subscriptions by storing them in HashMaps without any corresponding unsubscribe mechanism. When a component crashes or its task completes, the `EventNotificationListener` (receiver end) is dropped, but the subscription data remains: [2](#0-1) 

When a receiver is dropped, the underlying channel's `receiver_dropped` flag is set: [3](#0-2) 

Subsequently, when the service attempts to send notifications to the orphaned subscription, the channel's push operation fails: [4](#0-3) 

This error propagates through the notification chain. The critical flaw is in the error handling during subscriber notification: [5](#0-4) 

The `?` operator causes early return when ANY subscriber fails, preventing remaining subscribers from receiving notifications. This breaks the entire event notification system as demonstrated in the state sync commit notification flow: [6](#0-5) 

**Attack Scenario:**
1. Node starts with DKG and JWK consensus subscriptions active
2. DKG component task panics due to a bug or resource issue
3. DKG's `EventNotificationListener` is dropped, closing the channel
4. Subscription remains in `event_v2_tag_subscriptions` and `subscription_id_to_event_subscription` HashMaps
5. Next event notification for `"0x1::dkg::DKGStartEvent"` attempts to send to dead DKG subscription
6. Channel push fails with "Channel is closed" error
7. Error propagates up, stopping ALL event processing
8. JWK consensus (and other active subscribers) never receive their events
9. Critical consensus features fail silently

## Impact Explanation

**Severity: High**

This vulnerability meets the High severity criteria per Aptos bug bounty program:

1. **Validator Node Issues**: The bug causes validator nodes to fail processing critical consensus events. When DKG or JWK consensus subscriptions become orphaned, these security-critical systems stop receiving updates.

2. **State Inconsistency**: The commit notification handler has already notified storage service and mempool before the event notification fails. This creates inconsistent state where some components are updated but event subscribers are not. [7](#0-6) 

3. **Consensus Impact**: Both DKG (Distributed Key Generation) and JWK consensus are critical for validator security. Loss of event notifications can prevent epoch transitions and security updates. [8](#0-7) 

4. **No Recovery Mechanism**: Once a subscription becomes orphaned, there's no automatic recovery. The error persists until node restart, affecting long-running validators.

## Likelihood Explanation

**Likelihood: Medium to High**

1. **Component Failures Are Common**: The codebase includes failpoint tests demonstrating component crashes during operation:
   - Validators can restart during DKG operations
   - Tasks can panic due to bugs, resource exhaustion, or edge cases

2. **Long-Running Validators**: Production validators run for extended periods, increasing the probability of at least one component experiencing a failure that drops its listener.

3. **No Defensive Programming**: The system has no error recovery, retry logic, or stale subscription cleanup, making the issue inevitable over time.

4. **Single Point of Failure**: Only ONE orphaned subscription is needed to break ALL event notifications for events it's subscribed to.

## Recommendation

Implement a comprehensive subscription lifecycle management system:

**Solution 1: Add Unsubscribe Mechanism**
```rust
// Add to EventSubscriptionService
pub fn unsubscribe_events(&mut self, subscription_id: SubscriptionId) -> Result<(), Error> {
    // Remove from subscription maps
    if let Some(subscription) = self.subscription_id_to_event_subscription.remove(&subscription_id) {
        // Clean up event key subscriptions
        self.event_key_subscriptions.retain(|_, ids| {
            ids.remove(&subscription_id);
            !ids.is_empty()
        });
        self.event_v2_tag_subscriptions.retain(|_, ids| {
            ids.remove(&subscription_id);
            !ids.is_empty()
        });
        Ok(())
    } else {
        Err(Error::MissingEventSubscription(subscription_id))
    }
}
```

**Solution 2: Detect and Skip Dead Subscriptions**
```rust
// Modify notify_subscriber_of_events to return Option<Result<>>
fn notify_subscriber_of_events(&mut self, version: Version) -> Option<Result<(), Error>> {
    let event_notification = EventNotification {
        subscribed_events: self.event_buffer.drain(..).collect(),
        version,
    };
    
    match self.notification_sender.push((), event_notification) {
        Ok(_) => Some(Ok(())),
        Err(e) if e.to_string().contains("Channel is closed") => {
            // Channel closed - mark for cleanup
            None
        },
        Err(e) => Some(Err(Error::UnexpectedErrorEncountered(format!("{:?}", e))))
    }
}

// In notify_event_subscribers, collect dead subscriptions
let mut dead_subscriptions = Vec::new();
for event_subscription_id in event_subscription_ids_to_notify {
    if let Some(event_subscription) = self.subscription_id_to_event_subscription.get_mut(&event_subscription_id) {
        match event_subscription.notify_subscriber_of_events(version) {
            Some(Ok(_)) => {},  // Success
            None => dead_subscriptions.push(event_subscription_id),  // Dead channel
            Some(Err(e)) => return Err(e),  // Real error
        }
    }
}

// Clean up dead subscriptions
for id in dead_subscriptions {
    self.unsubscribe_events(id)?;
}
```

**Solution 3: Use Weak References**
Instead of storing `Sender` directly, use a mechanism to check if receivers are still alive before attempting sends.

## Proof of Concept

```rust
#[test]
fn test_orphaned_subscription_breaks_notifications() {
    use crate::{EventSubscriptionService, EventNotificationSender};
    use aptos_types::contract_event::ContractEvent;
    use move_core_types::language_storage::TypeTag;
    use std::str::FromStr;
    
    // Create event subscription service
    let mut event_service = create_event_subscription_service();
    
    // Create two subscriptions for the same event tag
    let event_tag = "0x1::test::TestEvent".to_string();
    let mut listener_1 = event_service
        .subscribe_to_events(vec![], vec![event_tag.clone()])
        .unwrap();
    let mut listener_2 = event_service
        .subscribe_to_events(vec![], vec![event_tag.clone()])
        .unwrap();
    
    // Verify both listeners work
    let test_event = ContractEvent::new_v2(
        TypeTag::from_str(&event_tag).unwrap(),
        vec![1, 2, 3]
    ).unwrap();
    
    event_service.notify_events(1, vec![test_event.clone()]).unwrap();
    
    // Both should receive notification
    assert!(listener_1.select_next_some().now_or_never().is_some());
    assert!(listener_2.select_next_some().now_or_never().is_some());
    
    // Drop listener_1 (simulating component crash)
    drop(listener_1);
    
    // Try to send another notification
    let result = event_service.notify_events(2, vec![test_event.clone()]);
    
    // This will FAIL because listener_1's channel is closed
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Channel is closed"));
    
    // listener_2 NEVER receives the notification even though it's alive!
    assert!(listener_2.select_next_some().now_or_never().is_none());
    
    // This demonstrates the vulnerability: one dead subscription breaks all others
}
```

## Notes

This vulnerability demonstrates a critical design flaw where lack of subscription lifecycle management creates a single point of failure. The impact extends beyond memory leaks to actively breaking the event notification system for all subscribers when any one subscriber fails. Given that event notifications are used for critical consensus features (DKG, JWK consensus), this represents a significant validator reliability and security issue.

The fix requires either defensive error handling (skip dead subscriptions) or proper lifecycle management (unsubscribe mechanism), combined with automatic cleanup of orphaned subscriptions detected during notification attempts.

### Citations

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L75-89)
```rust
pub struct EventSubscriptionService {
    // Event subscription registry
    event_key_subscriptions: HashMap<EventKey, HashSet<SubscriptionId>>,
    event_v2_tag_subscriptions: HashMap<String, HashSet<SubscriptionId>>,
    subscription_id_to_event_subscription: HashMap<SubscriptionId, EventSubscription>,

    // Reconfig subscription registry
    reconfig_subscriptions: HashMap<SubscriptionId, ReconfigSubscription>,

    // Database to fetch on-chain configuration data
    storage: Arc<RwLock<DbReaderWriter>>,

    // Internal subscription ID generator
    subscription_id_generator: U64IdGenerator,
}
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L110-163)
```rust
    pub fn subscribe_to_events(
        &mut self,
        event_keys: Vec<EventKey>,
        event_v2_tags: Vec<String>,
    ) -> Result<EventNotificationListener, Error> {
        if event_keys.is_empty() && event_v2_tags.is_empty() {
            return Err(Error::CannotSubscribeToZeroEventKeys);
        }

        let (notification_sender, notification_receiver) =
            aptos_channel::new(QueueStyle::KLAST, EVENT_NOTIFICATION_CHANNEL_SIZE, None);

        // Create a new event subscription
        let subscription_id = self.get_new_subscription_id();
        let event_subscription = EventSubscription {
            notification_sender,
            event_buffer: vec![],
        };

        // Store the new subscription
        if let Some(old_subscription) = self
            .subscription_id_to_event_subscription
            .insert(subscription_id, event_subscription)
        {
            return Err(Error::UnexpectedErrorEncountered(format!(
                "Duplicate event subscription found! This should not occur! ID: {}, subscription: {:?}",
                subscription_id, old_subscription
            )));
        }

        // Update the event key subscriptions to include the new subscription
        for event_key in event_keys {
            self.event_key_subscriptions
                .entry(event_key)
                .and_modify(|subscriptions| {
                    subscriptions.insert(subscription_id);
                })
                .or_insert_with(|| HashSet::from_iter([subscription_id].iter().cloned()));
        }

        // Update the event v2 tag subscriptions to include the new subscription
        for event_tag in event_v2_tags {
            self.event_v2_tag_subscriptions
                .entry(event_tag)
                .and_modify(|subscriptions| {
                    subscriptions.insert(subscription_id);
                })
                .or_insert_with(|| HashSet::from_iter([subscription_id].iter().cloned()));
        }

        Ok(EventNotificationListener {
            notification_receiver,
        })
    }
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L247-257)
```rust
        // Notify event subscribers of the new events
        for event_subscription_id in event_subscription_ids_to_notify {
            if let Some(event_subscription) = self
                .subscription_id_to_event_subscription
                .get_mut(&event_subscription_id)
            {
                event_subscription.notify_subscriber_of_events(version)?;
            } else {
                return Err(Error::MissingEventSubscription(event_subscription_id));
            }
        }
```

**File:** crates/channel/src/aptos_channel.rs (L85-112)
```rust
    pub fn push(&self, key: K, message: M) -> Result<()> {
        self.push_with_feedback(key, message, None)
    }

    /// Same as `push`, but this function also accepts a oneshot::Sender over which the sender can
    /// be notified when the message eventually gets delivered or dropped.
    pub fn push_with_feedback(
        &self,
        key: K,
        message: M,
        status_ch: Option<oneshot::Sender<ElementStatus<M>>>,
    ) -> Result<()> {
        let mut shared_state = self.shared_state.lock();
        ensure!(!shared_state.receiver_dropped, "Channel is closed");
        debug_assert!(shared_state.num_senders > 0);

        let dropped = shared_state.internal_queue.push(key, (message, status_ch));
        // If this or an existing message had to be dropped because of the queue being full, we
        // notify the corresponding status channel if it was registered.
        if let Some((dropped_val, Some(dropped_status_ch))) = dropped {
            // Ignore errors.
            let _err = dropped_status_ch.send(ElementStatus::Dropped(dropped_val));
        }
        if let Some(w) = shared_state.waker.take() {
            w.wake();
        }
        Ok(())
    }
```

**File:** crates/channel/src/aptos_channel.rs (L157-163)
```rust
impl<K: Eq + Hash + Clone, M> Drop for Receiver<K, M> {
    fn drop(&mut self) {
        let mut shared_state = self.shared_state.lock();
        debug_assert!(!shared_state.receiver_dropped);
        shared_state.receiver_dropped = true;
    }
}
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L96-111)
```rust
        // Notify the storage service of the committed transactions
        storage_service_notification_handler
            .notify_storage_service_of_committed_transactions(latest_synced_version)
            .await?;

        // Notify mempool of the committed transactions
        mempool_notification_handler
            .notify_mempool_of_committed_transactions(transactions, blockchain_timestamp_usecs)
            .await?;

        // Notify the event subscription service of the events
        event_subscription_service
            .lock()
            .notify_events(latest_synced_version, events)?;

        Ok(())
```

**File:** aptos-node/src/state_sync.rs (L92-115)
```rust
    let dkg_subscriptions = if node_config.base.role.is_validator() {
        let reconfig_events = event_subscription_service
            .subscribe_to_reconfigurations()
            .expect("DKG must subscribe to reconfigurations");
        let dkg_start_events = event_subscription_service
            .subscribe_to_events(vec![], vec!["0x1::dkg::DKGStartEvent".to_string()])
            .expect("Consensus must subscribe to DKG events");
        Some((reconfig_events, dkg_start_events))
    } else {
        None
    };

    // Create reconfiguration subscriptions for JWK consensus
    let jwk_consensus_subscriptions = if node_config.base.role.is_validator() {
        let reconfig_events = event_subscription_service
            .subscribe_to_reconfigurations()
            .expect("JWK consensus must subscribe to reconfigurations");
        let jwk_updated_events = event_subscription_service
            .subscribe_to_events(vec![], vec!["0x1::jwks::ObservedJWKsUpdated".to_string()])
            .expect("JWK consensus must subscribe to DKG events");
        Some((reconfig_events, jwk_updated_events))
    } else {
        None
    };
```
