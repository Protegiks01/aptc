# Audit Report

## Title
Batch Serving Task Crash and Consensus Liveness Failure Due to Improper BatchResponse::BatchV2 Handling

## Summary
The `request_batch()` function in `batch_requester.rs` and the batch serving logic in `quorum_store_builder.rs` fail to properly handle `BatchResponse::BatchV2` according to protocol specification. When a V2 batch exists in storage, the serving node panics and crashes its batch serving task. When a requesting node receives a `BatchV2` response, it ignores the valid data and continues retrying until timeout, causing consensus liveness degradation.

## Finding Description

The quorum store protocol defines three `BatchResponse` variants: `Batch`, `NotFound`, and `BatchV2`. [1](#0-0) 

However, the implementation contains two critical flaws:

**Flaw 1: Server-Side Panic on V2 Batches**

In the batch serving logic, when a batch retrieval request is received, the code unconditionally attempts to convert any retrieved batch from `Batch<BatchInfoExt>` to `Batch<BatchInfo>` (V1 only) using `.expect()`: [2](#0-1) 

The `TryFrom` implementation will fail when the batch is V2: [3](#0-2) 

This causes a panic that crashes the entire batch serving task, preventing the node from serving any further batch retrieval requests for the remainder of the epoch.

**Flaw 2: Client-Side Silent Failure**

On the requesting side, when a `BatchResponse::BatchV2` is received, the code merely logs an error and continues the retry loop without returning the batch data: [4](#0-3) 

This means valid V2 batch data is ignored, causing the requester to retry until timeout even though the data was successfully received.

**Attack Scenario:**

V2 batches can be created when the `enable_batch_v2` configuration flag is set: [5](#0-4) 

The default is `false`, but this can be changed: [6](#0-5) 

1. A validator (maliciously or during legitimate upgrade) sets `enable_batch_v2: true`
2. The node creates V2 batches and broadcasts them to the network
3. Other validators receive and store these V2 batches
4. When any node requests such a batch:
   - The serving node's batch task panics and crashes permanently
   - The requesting node ignores valid V2 responses and times out
5. Result: Consensus cannot proceed as batches cannot be retrieved

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **Validator node crashes**: The batch serving task panic causes permanent DoS for batch retrieval
- **Consensus liveness degradation**: Nodes cannot retrieve batches needed for consensus, blocking progress
- **Network-wide impact during upgrades**: If multiple validators enable V2 during a rollout, cascading failures occur

The spawned task uses `spawn_named!` macro which doesn't recover from panics: [7](#0-6) 

Once crashed, the batch serving functionality remains unavailable until the node restarts and enters a new epoch.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Requires configuration change**: An operator must set `enable_batch_v2: true`, but this is a legitimate configuration option
- **Likely during upgrades**: When the network transitions to V2 batches, this will naturally occur
- **Incomplete implementation**: The code has a TODO comment about V2 support, indicating this is a known transitional state
- **No validation**: There's no check to prevent V1-only nodes from receiving V2 batches

This is not a theoretical issueâ€”it will occur during any V2 batch rollout unless fixed.

## Recommendation

**Fix 1: Handle V2 batches properly in batch serving**

Replace the forced V1 conversion with proper variant handling:

```rust
let response = if let Ok(value) = batch_store.get_batch_from_local(&rpc_request.req.digest()) {
    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
    // Check if it's V1 or V2 and return appropriate response
    if batch.is_v2() {
        BatchResponse::BatchV2(batch)
    } else {
        let batch_v1: Batch<BatchInfo> = batch.try_into()
            .expect("V1 batch conversion should succeed");
        BatchResponse::Batch(batch_v1)
    }
} else {
    // ... NotFound logic
};
```

**Fix 2: Handle BatchV2 responses properly in batch requester**

Replace the error log with actual data extraction:

```rust
Ok(BatchResponse::BatchV2(batch)) => {
    counters::RECEIVED_BATCH_V2_RESPONSE_COUNT.inc();
    let payload = batch.into_transactions();
    return Ok(payload);
}
```

**Fix 3: Add version negotiation**

Implement protocol version negotiation to ensure compatibility between V1 and V2 nodes during transitions.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_consensus_types::proof_of_store::{BatchInfo, BatchInfoExt, BatchKind};
    use aptos_types::PeerId;
    
    #[test]
    #[should_panic(expected = "Batch must be V1 type")]
    fn test_v2_batch_causes_panic() {
        // Create a V2 batch
        let batch = Batch::new_v2(
            BatchId::new(1),
            vec![],
            0,
            1000,
            PeerId::random(),
            0,
            BatchKind::Normal,
        );
        
        // Attempt to convert to V1 as the serving code does
        // This will panic with "Batch must be V1 type"
        let _batch_v1: Batch<BatchInfo> = batch.try_into().unwrap();
    }
    
    #[tokio::test]
    async fn test_batch_v2_response_ignored() {
        // Setup batch requester
        let requester = /* initialize with test parameters */;
        
        // Mock network to return BatchV2 response
        let response = BatchResponse::BatchV2(/* valid V2 batch */);
        
        // The request_batch will ignore this valid response
        // and keep retrying until timeout
        let result = requester.request_batch(digest, expiration, responders, rx).await;
        
        // Should succeed but will timeout instead
        assert!(result.is_err());
    }
}
```

The vulnerability can be triggered by:
1. Setting `enable_batch_v2: true` in `QuorumStoreConfig`
2. Creating batches that get stored as V2
3. Requesting those batches from another node
4. Observing the panic in batch serving task and timeout in requesting node

### Citations

**File:** consensus/src/quorum_store/types.rs (L336-353)
```rust
impl TryFrom<Batch<BatchInfoExt>> for Batch<BatchInfo> {
    type Error = anyhow::Error;

    fn try_from(batch: Batch<BatchInfoExt>) -> Result<Self, Self::Error> {
        ensure!(
            matches!(batch.batch_info(), &BatchInfoExt::V1 { .. }),
            "Batch must be V1 type"
        );
        let Batch {
            batch_info,
            payload,
        } = batch;
        Ok(Self {
            batch_info: batch_info.unpack_info(),
            payload,
        })
    }
}
```

**File:** consensus/src/quorum_store/types.rs (L416-421)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum BatchResponse {
    Batch(Batch<BatchInfo>),
    NotFound(LedgerInfoWithSignatures),
    BatchV2(Batch<BatchInfoExt>),
}
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L408-415)
```rust
                let response = if let Ok(value) =
                    batch_store.get_batch_from_local(&rpc_request.req.digest())
                {
                    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
                    let batch: Batch<BatchInfo> = batch
                        .try_into()
                        .expect("Batch retieval requests must be for V1 batch");
                    BatchResponse::Batch(batch)
```

**File:** consensus/src/quorum_store/batch_requester.rs (L153-155)
```rust
                            Ok(BatchResponse::BatchV2(_)) => {
                                error!("Batch V2 response is not supported");
                            }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L190-201)
```rust
        if self.config.enable_batch_v2 {
            // TODO(ibalajiarun): Specify accurate batch kind
            let batch_kind = BatchKind::Normal;
            Batch::new_v2(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
                batch_kind,
            )
```

**File:** config/src/config/quorum_store_config.rs (L102-144)
```rust
    pub enable_batch_v2: bool,
}

impl Default for QuorumStoreConfig {
    fn default() -> QuorumStoreConfig {
        QuorumStoreConfig {
            channel_size: 1000,
            proof_timeout_ms: 10000,
            batch_generation_poll_interval_ms: 25,
            batch_generation_min_non_empty_interval_ms: 50,
            batch_generation_max_interval_ms: 250,
            sender_max_batch_txns: DEFEAULT_MAX_BATCH_TXNS,
            // TODO: on next release, remove BATCH_PADDING_BYTES
            sender_max_batch_bytes: 1024 * 1024 - BATCH_PADDING_BYTES,
            sender_max_num_batches: DEFAULT_MAX_NUM_BATCHES,
            sender_max_total_txns: 1500,
            // TODO: on next release, remove DEFAULT_MAX_NUM_BATCHES * BATCH_PADDING_BYTES
            sender_max_total_bytes: 4 * 1024 * 1024 - DEFAULT_MAX_NUM_BATCHES * BATCH_PADDING_BYTES,
            receiver_max_batch_txns: 100,
            receiver_max_batch_bytes: 1024 * 1024 + BATCH_PADDING_BYTES,
            receiver_max_num_batches: 20,
            receiver_max_total_txns: 2000,
            receiver_max_total_bytes: 4 * 1024 * 1024
                + DEFAULT_MAX_NUM_BATCHES
                + BATCH_PADDING_BYTES,
            batch_request_num_peers: 5,
            batch_request_retry_limit: 10,
            batch_request_retry_interval_ms: 500,
            batch_request_rpc_timeout_ms: 5000,
            batch_expiry_gap_when_init_usecs: Duration::from_secs(60).as_micros() as u64,
            remote_batch_expiry_gap_when_init_usecs: Duration::from_millis(500).as_micros() as u64,
            memory_quota: 120_000_000,
            db_quota: 300_000_000,
            batch_quota: 300_000,
            back_pressure: QuorumStoreBackPressureConfig::default(),
            // number of batch coordinators to handle QS batch messages, should be >= 1
            num_workers_for_remote_batches: 10,
            batch_buckets: DEFAULT_BUCKETS.to_vec(),
            allow_batches_without_pos_in_proposal: true,
            enable_opt_quorum_store: true,
            opt_qs_minimum_batch_age_usecs: Duration::from_millis(50).as_micros() as u64,
            enable_payload_v2: false,
            enable_batch_v2: false,
```

**File:** crates/aptos-logger/src/macros.rs (L6-14)
```rust
#[macro_export]
macro_rules! spawn_named {
      ($name:expr, $func:expr) => { tokio::spawn($func); };
      ($name:expr, $handler:expr, $func:expr) => { $handler.spawn($func); };
      ($name:expr, $async:ident = async; $clojure:block) => { tokio::spawn( async $clojure); };
      ($name:expr, $handler:expr, $async:ident = async; $clojure:block) => { $handler.spawn( async $clojure); };
      ($name:expr, $async:ident = async ; $move:ident = move; $clojure:block) => { tokio::spawn( async move $clojure); };
      ($name:expr, $handler:expr, $async:ident = async ; $move:ident = move; $clojure:block) => { $handler.spawn( async move $clojure); };
  }
```
