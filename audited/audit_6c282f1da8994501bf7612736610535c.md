# Audit Report

## Title
Non-Atomic Key Rotation in CryptoStorage Trait Enables Race Conditions in Validator Network Identity Management

## Summary
The `CryptoStorage` trait does not enforce atomic operations for key rotation. The default implementation in `CryptoKVStorage` performs key rotation through three separate non-atomic storage operations, creating a race condition window where concurrent calls to `rotate_key()` can result in lost key versions. While consensus signing itself uses BLS12381 keys (not managed by `CryptoStorage`), validator network identity keys are stored as Ed25519 keys in the same storage system and could be corrupted by concurrent rotation attempts, potentially preventing validators from authenticating to the network and participating in consensus. [1](#0-0) 

## Finding Description

The `CryptoStorage` trait interface provides no atomicity guarantees for the `rotate_key()` operation. The default implementation used by `InMemoryStorage` and `OnDiskStorage` performs three separate storage operations: [2](#0-1) 

This implementation:
1. Reads the current private key via `self.get(name)` (line 81)
2. Writes the old key to `{name}_previous` via `self.set()` (line 83)  
3. Writes the new key to `{name}` via `self.set()` (line 84)

Both `InMemoryStorage` and `OnDiskStorage` explicitly document they are not thread-safe: [3](#0-2) [4](#0-3) 

For `OnDiskStorage`, the situation is worse because each `set()` operation performs a full read-modify-write of the entire storage file: [5](#0-4) 

**Connection to Consensus**: While consensus signing uses BLS12381 keys stored separately, validator network identity keys ARE managed as Ed25519 keys through this same storage system and converted to x25519 at runtime: [6](#0-5) 

If concurrent `rotate_key()` calls occur on a network identity key, the race condition can:
- Cause one key version to be permanently lost
- Corrupt the storage file (in `OnDiskStorage` case, where concurrent writes can overwrite each other)
- Result in the validator being unable to authenticate to the network with any key version
- Prevent the validator from receiving or sending consensus messages
- Break the validator's ability to participate in consensus voting and block signing

## Impact Explanation

**Critical Severity** - This constitutes a consensus safety violation under the following scenario:

1. **Validator Network Partition**: A corrupted network identity key prevents the validator from authenticating to other validators. Without network connectivity, the validator cannot:
   - Receive block proposals from the leader
   - Send votes to form quorum certificates
   - Participate in leader election
   - Synchronize state with other validators

2. **Non-Deterministic Failure**: If multiple validators experience this race condition during network key rotation (e.g., during a coordinated key rotation event), the network could lose more than 1/3 of validators simultaneously, causing:
   - Loss of liveness (unable to form quorums)
   - Potential for network partition if different subsets of validators maintain connectivity

3. **Storage Corruption**: In `OnDiskStorage`, concurrent operations can corrupt the entire storage file, potentially affecting:
   - Consensus private keys (BLS12381) stored in the same file
   - Safety data required for consensus safety rules
   - Waypoint data for validator synchronization

While the trait primarily manages Ed25519 keys, the shared storage backend means corruption can cascade to affect BLS consensus keys stored via `KVStorage::set()`. [7](#0-6) [8](#0-7) 

## Likelihood Explanation

**Low to Medium Likelihood** in current implementation:

**Mitigating Factors:**
- `SafetyRules` wraps storage in `Arc<RwLock<>>` in local mode, providing mutual exclusion: [9](#0-8) 

- Current codebase shows no concurrent `rotate_key()` calls in production paths

**Risk Factors:**
- The trait interface provides NO documentation or type-level guarantees about atomicity
- Future code changes could introduce concurrent access patterns
- Key rotation procedures (manual or automated) could inadvertently trigger concurrent calls
- Custom storage implementations may not be aware of the atomicity requirement

The vulnerability is a **design flaw** rather than an immediate exploit - the trait interface fails to enforce a critical safety property.

## Recommendation

**1. Enforce Atomicity in the Trait Interface:**

Add documentation and consider a `&mut self` requirement with clear atomicity guarantees:

```rust
/// CryptoStorage provides an abstraction for secure generation and handling of cryptographic keys.
/// 
/// # Thread Safety
/// All mutating operations (create_key, rotate_key, import_private_key) must be atomic.
/// Implementations MUST ensure that concurrent calls do not result in data loss or inconsistent
/// key versions. Consider wrapping implementations in Arc<Mutex<>> or Arc<RwLock<>> if
/// concurrent access is possible.
pub trait CryptoStorage {
    // ... existing methods ...
    
    /// Rotates an Ed25519 private key atomically. Future calls without version to this 'named' 
    /// key will return the rotated key instance. The previous key is retained and can be accessed
    /// via the version. At most two versions are expected to be retained.
    /// 
    /// # Atomicity Guarantee
    /// This operation MUST be atomic. If rotation fails partway through, the original key
    /// must remain unchanged. Concurrent calls to rotate_key for the same name MUST be
    /// serialized to prevent data loss.
    fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error>;
}
```

**2. Fix the Default Implementation:**

For `OnDiskStorage`, implement atomic file operations using a write-ahead log or transactional approach:

```rust
fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
    // Acquire a file lock for the entire operation
    let mut data = self.read()?;
    
    let private_key: Ed25519PrivateKey = data
        .remove(name)
        .ok_or_else(|| Error::KeyNotSet(name.to_string()))
        .and_then(|value| serde_json::from_value(value).map_err(|e| e.into()))?;
    
    let (new_private_key, new_public_key) = new_ed25519_key_pair();
    let now = self.time_service.now_secs();
    
    // Perform both updates in a single write
    data.insert(
        get_previous_version_name(name),
        serde_json::to_value(GetResponse::new(private_key, now))?,
    );
    data.insert(
        name.to_string(),
        serde_json::to_value(GetResponse::new(new_private_key, now))?,
    );
    
    self.write(&data)?;
    Ok(new_public_key)
}
```

**3. Add Runtime Assertions:**

Wrap critical storage instances in synchronization primitives and add assertions:

```rust
// In safety rules initialization
let storage = Arc::new(RwLock::new(storage));
```

## Proof of Concept

```rust
#[cfg(test)]
mod race_condition_test {
    use super::*;
    use aptos_temppath::TempPath;
    use std::sync::{Arc, Barrier};
    use std::thread;

    #[test]
    fn test_concurrent_rotate_key_race_condition() {
        let path = TempPath::new().path().to_path_buf();
        let storage = Arc::new(std::sync::Mutex::new(
            OnDiskStorage::new(path)
        ));
        
        // Create initial key
        storage.lock().unwrap().create_key("test_key").unwrap();
        let initial_key = storage.lock().unwrap()
            .export_private_key("test_key").unwrap();
        
        // Spawn two threads that rotate concurrently
        let barrier = Arc::new(Barrier::new(2));
        let storage1 = Arc::clone(&storage);
        let storage2 = Arc::clone(&storage);
        let barrier1 = Arc::clone(&barrier);
        let barrier2 = Arc::clone(&barrier);
        
        let handle1 = thread::spawn(move || {
            barrier1.wait();
            storage1.lock().unwrap().rotate_key("test_key")
        });
        
        let handle2 = thread::spawn(move || {
            barrier2.wait();
            storage2.lock().unwrap().rotate_key("test_key")
        });
        
        let result1 = handle1.join().unwrap();
        let result2 = handle2.join().unwrap();
        
        // Both rotations should succeed
        assert!(result1.is_ok());
        assert!(result2.is_ok());
        
        let key1 = result1.unwrap();
        let key2 = result2.unwrap();
        
        // Keys should be different
        assert_ne!(key1, key2);
        
        // Current key should be one of them
        let current = storage.lock().unwrap()
            .export_private_key("test_key").unwrap();
        let current_pub = current.public_key();
        
        // Previous key should be accessible
        let previous = storage.lock().unwrap()
            .export_private_key("test_key_previous").unwrap();
        let previous_pub = previous.public_key();
        
        // VULNERABILITY: One of the rotated keys is lost!
        // Either key1 or key2 is not accessible anymore
        assert!(current_pub == key1 || current_pub == key2);
        
        // The previous key might be the initial key OR one of the rotated keys
        // If both rotations read the initial key before either wrote,
        // then key1 is lost entirely
        println!("Current: {:?}", current_pub);
        println!("Previous: {:?}", previous_pub);
        println!("Key1: {:?}", key1);
        println!("Key2: {:?}", key2);
        println!("Initial: {:?}", initial_key.public_key());
        
        // This assertion will fail, demonstrating the lost key:
        let all_accessible_keys = vec![current_pub, previous_pub];
        assert!(all_accessible_keys.contains(&key1) && all_accessible_keys.contains(&key2),
                "One of the rotated keys was lost due to race condition!");
    }
}
```

**Note**: This PoC demonstrates the race condition exists in the implementation. The actual exploitability depends on whether concurrent `rotate_key()` calls occur in production deployments.

### Citations

**File:** secure/storage/src/crypto_storage.rs (L42-45)
```rust
    /// Rotates an Ed25519 private key. Future calls without version to this 'named' key will
    /// return the rotated key instance. The previous key is retained and can be accessed via
    /// the version. At most two versions are expected to be retained.
    fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error>;
```

**File:** secure/storage/src/crypto_kv_storage.rs (L80-86)
```rust
    fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        let private_key: Ed25519PrivateKey = self.get(name)?.value;
        let (new_private_key, new_public_key) = new_ed25519_key_pair();
        self.set(&get_previous_version_name(name), private_key)?;
        self.set(name, new_private_key)?;
        Ok(new_public_key)
    }
```

**File:** secure/storage/src/in_memory.rs (L9-14)
```rust
/// InMemoryStorage represents a key value store that is purely in memory and intended for single
/// threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission checks and simply
/// is a proof of concept to unblock building of applications without more complex data stores.
/// Internally, it retains all data, which means that it must make copies of all key material which
/// violates the code base. It violates it because the anticipation is that data stores would
/// securely handle key material. This should not be used in production.
```

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```

**File:** secure/storage/src/on_disk.rs (L85-93)
```rust
    fn set<V: Serialize>(&mut self, key: &str, value: V) -> Result<(), Error> {
        let now = self.time_service.now_secs();
        let mut data = self.read()?;
        data.insert(
            key.to_string(),
            serde_json::to_value(GetResponse::new(value, now))?,
        );
        self.write(&data)
    }
```

**File:** config/src/config/network_config.rs (L187-206)
```rust
    pub fn identity_key(&self) -> x25519::PrivateKey {
        let key = match &self.identity {
            Identity::FromConfig(config) => Some(config.key.private_key()),
            Identity::FromStorage(config) => {
                let storage: Storage = (&config.backend).into();
                let key = storage
                    .export_private_key(&config.key_name)
                    .expect("Unable to read key");
                let key = x25519::PrivateKey::from_ed25519_private_bytes(&key.to_bytes())
                    .expect("Unable to convert key");
                Some(key)
            },
            Identity::FromFile(config) => {
                let identity_blob: IdentityBlob = IdentityBlob::from_file(&config.path).unwrap();
                Some(identity_blob.network_private_key)
            },
            Identity::None => None,
        };
        key.expect("identity key should be present")
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L24-28)
```rust
pub struct PersistentSafetyStorage {
    enable_cached_safety_data: bool,
    cached_safety_data: Option<SafetyData>,
    internal_store: Storage,
}
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-81)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }

        internal_store.set(OWNER_ACCOUNT, author)?;
        Ok(())
    }
```

**File:** consensus/safety-rules/src/local_client.rs (L24-31)
```rust
pub struct LocalClient {
    internal: Arc<RwLock<SafetyRules>>,
}

impl LocalClient {
    pub fn new(internal: Arc<RwLock<SafetyRules>>) -> Self {
        Self { internal }
    }
```
