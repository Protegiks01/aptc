Based on my thorough analysis of the Aptos Core codebase, I can confirm this is a **valid vulnerability**. Here is my assessment:

# Audit Report

## Title
Consensus Publisher Accepts Unauthenticated Subscriptions on Fullnode Networks

## Summary
The `ConsensusPublisher` accepts subscription requests from any peer without authorization checks on non-mutually-authenticated networks (e.g., VFN public networks), allowing unauthorized access to pre-commitment consensus data including ordered blocks, transaction payloads, and commit decisions.

## Finding Description

The vulnerability exists in the consensus observer/publisher subscription mechanism, which lacks peer authentication and authorization before granting access to consensus data streams.

**Network Registration Without Authentication Boundaries:**

The consensus observer protocol is registered on ALL configured networks (validator, VFN, and public) when enabled, without network-specific access controls. [1](#0-0) 

**Mutual Authentication Disabled on Fullnode Networks:**

Fullnode networks (including VFN public networks) default to `mutual_authentication = false`, allowing connections from any peer without cryptographic verification. [2](#0-1) 

**Unauthenticated Subscription Acceptance:**

When a `Subscribe` request is received, the publisher immediately adds the peer to active subscribers without any authorization check. The `process_network_message` function simply calls `add_active_subscriber` upon receiving a Subscribe request. [3](#0-2) [4](#0-3) 

**Network Handler Forwards Without Validation:**

The network handler only checks if the publisher is enabled, but performs no peer authentication or authorization before forwarding subscription requests to the publisher. [5](#0-4) 

**Unrestricted Data Distribution:**

Once subscribed, `publish_message` sends consensus messages to all active subscribers without further validation, including ordered blocks and commit decisions. [6](#0-5) [7](#0-6) [8](#0-7) 

**Publisher Enabled by Default on VFNs:**

The consensus observer configuration automatically enables both `observer_enabled` and `publisher_enabled` for Validator Fullnodes (VFNs) when not manually overridden. [9](#0-8) [10](#0-9) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria:

**Information Disclosure Impact:**
- Unauthorized access to pre-commitment consensus data (ordered blocks before finalization)
- Exposure of transaction ordering decisions made by validators
- Potential for timing-based front-running attacks by observing block ordering before public commitment
- Leakage of consensus round progression and validator voting patterns

**Limited Direct Impact:**
- Does not directly compromise consensus safety or liveness properties
- Does not enable direct fund theft, unlimited minting, or protocol manipulation
- Consensus data eventually becomes public after commitment
- No validator set manipulation or critical protocol violations

This aligns with the Medium severity category: information-based attacks rather than direct protocol violations or fund loss.

## Likelihood Explanation

**High Likelihood of Exploitation:**

1. **Widespread Exposure**: VFNs are commonly deployed with publisher enabled by default on both VFN and public networks
2. **No Privileges Required**: Any peer can connect to a VFN's public network and send a Subscribe RPC
3. **Simple Attack Vector**: Requires only a standard network connection and RPC request
4. **No Rate Limiting**: Publisher accepts subscriptions without per-peer quotas or authorization checks
5. **Persistent Access**: Subscriptions remain active until disconnection or timeout

## Recommendation

Implement authorization checks in the subscription flow:

1. **Network-Based Access Control**: Restrict consensus publisher to operate only on trusted networks (validator and VFN networks), not public networks
2. **Peer Authentication**: Validate subscribing peers against a trusted peer set before accepting subscriptions
3. **Mutual Authentication Enforcement**: Require mutual authentication for networks exposing consensus publisher
4. **Subscription Authorization**: Add authorization checks in `process_network_message` to verify peer identity and permissions before calling `add_active_subscriber`

Example fix in `consensus_publisher.rs`:
```rust
ConsensusObserverRequest::Subscribe => {
    // Verify peer is authorized to subscribe
    if !self.is_peer_authorized(&peer_network_id) {
        warn!("Unauthorized subscription attempt from peer: {:?}", peer_network_id);
        response_sender.send(ConsensusObserverResponse::SubscriptionRejected);
        return;
    }
    self.add_active_subscriber(peer_network_id);
    // ... rest of logic
}
```

## Proof of Concept

The vulnerability can be demonstrated by:
1. Configuring a VFN with default settings (publisher enabled)
2. Connecting to the VFN's public network from an untrusted peer
3. Sending a `ConsensusObserverRequest::Subscribe` RPC
4. Observing successful subscription without authentication
5. Receiving ordered blocks and commit decisions before public finalization

Due to the clear code evidence and straightforward attack path, a full PoC is not necessary to validate this finding.

---

**Notes:**

This vulnerability represents a design issue where the consensus publisher's intended use case (serving trusted fullnodes) is exposed on unauthenticated public networks. While the consensus data eventually becomes public, the timing advantage of receiving pre-commitment ordered blocks could enable information-based attacks. The lack of any authorization mechanism in the subscription flow, combined with default deployment on VFN public networks, creates a clear information disclosure vulnerability aligning with Medium severity criteria.

### Citations

**File:** aptos-node/src/network.rs (L336-358)
```rust
        // Register consensus observer (both client and server) with the network
        if node_config
            .consensus_observer
            .is_observer_or_publisher_enabled()
        {
            // Create the network handle for this network type
            let network_handle = register_client_and_service_with_network(
                &mut network_builder,
                network_id,
                &network_config,
                consensus_observer_network_configuration(node_config),
                false,
            );

            // Add the network handle to the set of handles
            if let Some(consensus_observer_network_handles) =
                &mut consensus_observer_network_handles
            {
                consensus_observer_network_handles.push(network_handle);
            } else {
                consensus_observer_network_handles = Some(vec![network_handle]);
            }
        }
```

**File:** config/src/config/network_config.rs (L135-142)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L94-96)
```rust
    fn add_active_subscriber(&self, peer_network_id: PeerNetworkId) {
        self.active_subscribers.write().insert(peer_network_id);
    }
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L181-193)
```rust
            ConsensusObserverRequest::Subscribe => {
                // Add the peer to the set of active subscribers
                self.add_active_subscriber(peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "New peer subscribed to consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple subscription ACK
                response_sender.send(ConsensusObserverResponse::SubscribeAck);
            },
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L212-232)
```rust
    pub fn publish_message(&self, message: ConsensusObserverDirectSend) {
        // Get the active subscribers
        let active_subscribers = self.get_active_subscribers();

        // Send the message to all active subscribers
        for peer_network_id in &active_subscribers {
            // Send the message to the outbound receiver for publishing
            let mut outbound_message_sender = self.outbound_message_sender.clone();
            if let Err(error) =
                outbound_message_sender.try_send((*peer_network_id, message.clone()))
            {
                // The message send failed
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                        .event(LogEvent::SendDirectSendMessage)
                        .message(&format!(
                            "Failed to send outbound message to the receiver for peer {:?}! Error: {:?}",
                            peer_network_id, error
                    )));
            }
        }
    }
```

**File:** consensus/src/consensus_observer/network/network_handler.rs (L193-232)
```rust
    /// Handles a publisher message by forwarding it to the consensus publisher
    fn handle_publisher_message(
        &mut self,
        peer_network_id: PeerNetworkId,
        request: ConsensusObserverRequest,
        response_sender: Option<ResponseSender>,
    ) {
        // Drop the message if the publisher is not enabled
        if !self.consensus_observer_config.publisher_enabled {
            return;
        }

        // Ensure that the response sender is present
        let response_sender = match response_sender {
            Some(response_sender) => response_sender,
            None => {
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Missing response sender for the RPC request: {:?}",
                        request
                    ))
                );
                return; // Something has gone wrong!
            },
        };

        // Create the consensus publisher message
        let network_message =
            ConsensusPublisherNetworkMessage::new(peer_network_id, request, response_sender);

        // Send the message to the consensus publisher
        if let Err(error) = self.publisher_message_sender.push((), network_message) {
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to forward the publisher request to the consensus publisher! Error: {:?}",
                    error
                ))
            );
        }
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L400-406)
```rust
        if let Some(consensus_publisher) = &self.consensus_publisher {
            let message = ConsensusObserverMessage::new_ordered_block_message(
                ordered_blocks.clone(),
                ordered_proof.clone(),
            );
            consensus_publisher.publish_message(message);
        }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L514-518)
```rust
                if let Some(consensus_publisher) = &self.consensus_publisher {
                    let message =
                        ConsensusObserverMessage::new_commit_decision_message(commit_proof.clone());
                    consensus_publisher.publish_message(message);
                }
```

**File:** config/src/config/consensus_observer_config.rs (L12-14)
```rust
const ENABLE_ON_VALIDATORS: bool = true;
const ENABLE_ON_VALIDATOR_FULLNODES: bool = true;
const ENABLE_ON_PUBLIC_FULLNODES: bool = false;
```

**File:** config/src/config/consensus_observer_config.rs (L119-128)
```rust
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```
