# Audit Report

## Title
Stale Verified Module Cache Allows Execution with Mismatched Native Function Implementations After Timed Feature Activation

## Summary
The verified module cache uses only the module bytecode hash (SHA3-256) as the cache key, without including native function implementation versions or timed feature flag states. When native function behaviors change due to timed feature activations (e.g., `FixTableNativesMemoryDoubleCounting`), previously cached modules are incorrectly treated as verified under the new native behavior, leading to gas metering bypasses and memory accounting violations.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Module Hash Computation** - Module hashes include only bytecode, not native function versions: [1](#0-0) 

The hash is computed as `sha3_256(&bytes)` where `bytes` is just the serialized module bytecode, containing no information about native function implementations.

**2. Verified Module Cache** - Uses module hash to skip re-verification: [2](#0-1) 

When `contains()` returns true, verification is completely skipped: [3](#0-2) 

**3. Native Function Resolution** - Happens at module load time with current runtime state: [4](#0-3) 

**The Attack Path:**

1. **Before timed feature activation**: Module M using table natives is verified and cached with the OLD native behavior (double-counting memory)

2. **Timed feature activates**: On October 16, 2025 (testnet) or October 21, 2025 (mainnet), the `FixTableNativesMemoryDoubleCounting` flag activates: [5](#0-4) [6](#0-5) 

3. **Native behavior changes**: The table native functions now check this flag and skip memory charging for certain operations: [7](#0-6) [8](#0-7) 

4. **Module loaded from cache**: Module M's hash matches, so it's treated as verified under the OLD behavior

5. **But executes with NEW behavior**: The resolved native functions use the NEW memory counting logic

6. **Cache not invalidated**: The cache flush only happens when verifier config bytes change, which doesn't include timed feature flags: [9](#0-8) 

The `VerifierConfig` struct does not include native function versions or timed feature states: [10](#0-9) 

## Impact Explanation

This is **HIGH severity** per Aptos bug bounty criteria due to:

**Gas Metering Bypass**: Modules verified under old native behavior (charging memory twice) can execute with new behavior (charging once), resulting in undercharging for memory usage. This violates the "Move VM Safety: Bytecode execution must respect gas limits and memory constraints" invariant.

**Memory Accounting Errors**: The old verification assumptions about memory tracking no longer hold. Operations that were verified to properly account for memory usage may now skip accounting, leading to potential node memory exhaustion.

**Consensus Risk**: Different validator nodes may have different cache states depending on when they last verified the module. Nodes that cached before the feature activation vs. after could have inconsistent execution results, threatening "Deterministic Execution" invariant.

**Protocol Violation**: This represents a significant protocol violation where the verification guarantees are silently invalidated by runtime changes, meeting the "High Severity" criteria of "Significant protocol violations."

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability **will occur automatically** without any attacker action when:

1. Any module using table natives (common in DeFi applications) is deployed and verified before the timed feature activates
2. The timed feature activates on the scheduled date (October 2025)
3. The module is subsequently loaded from cache

The activation is **guaranteed** to happen on the specified dates for testnet and mainnet. There are no special conditions or attacker actions required - the system will naturally encounter this issue as part of normal operation.

## Recommendation

**Immediate Fix**: Include timed feature flag states in the cache key or flush the cache when timed features activate.

**Option 1 - Include Feature State in Hash**:
Modify `AptosModuleExtension::new()` to include active timed feature flags in the hash computation:

```rust
pub fn new(state_value: StateValue, timed_features: &TimedFeatures) -> Self {
    let (state_value_metadata, bytes) = state_value.unpack();
    let mut hasher = Sha3_256::new();
    hasher.update(&bytes);
    // Include timed features affecting natives
    hasher.update(&timed_features.serialize_native_affecting_flags());
    let hash = hasher.finalize().into();
    // ...
}
```

**Option 2 - Flush Cache on Timed Feature Activation** (simpler):
In `ModuleCacheManager::mark_new_transaction_slice_start()`, detect timed feature changes and flush the verified module cache:

```rust
let timed_features_changed = self.environment.as_ref().is_none_or(|e| {
    e.timed_features_affecting_natives() != storage_environment.timed_features_affecting_natives()
});
if timed_features_changed {
    RuntimeEnvironment::flush_verified_module_cache();
}
```

**Option 3 - Version-Based Native Registry**:
Include a version number in the `NativeFunctions` registry that changes when any native implementation changes, and include this version in the cache key.

## Proof of Concept

**Reproduction Steps:**

1. **Deploy a module using table natives before October 2025**:
```move
module 0x1::vulnerable_module {
    use std::table::{Self, Table};
    
    struct MyResource has key {
        data: Table<u64, vector<u8>>
    }
    
    public entry fun add_data(account: &signer, key: u64, value: vector<u8>) {
        let addr = signer::address_of(account);
        if (!exists<MyResource>(addr)) {
            move_to(account, MyResource { data: table::new() });
        };
        let resource = borrow_global_mut<MyResource>(addr);
        table::add(&mut resource.data, key, value); // Uses native_add_box
    }
}
```

2. **Execute transaction calling `add_data`**:
   - Module is verified with OLD native behavior (double-counting memory)
   - Module hash is cached
   - Transaction charges for memory twice

3. **Wait for FixTableNativesMemoryDoubleCounting to activate** (October 2025)

4. **Execute same transaction again**:
   - Module hash matches cache â†’ verification skipped
   - Native function now uses NEW behavior (single-counting)
   - Transaction charges for memory once (undercharged)
   - Gas cost is now ~50% of what was verified

5. **Observe gas discrepancy**:
   - Same module, same operation
   - Different gas costs before vs after feature activation
   - Cached verification allows undercharging

**Validation Test**:
```rust
#[test]
fn test_cache_stale_after_timed_feature() {
    // Deploy and verify module before feature activation
    let module_bytes = compile_module("vulnerable_module");
    let hash_before = sha3_256(&module_bytes);
    
    // Verify and cache
    verify_module_with_old_natives(&module_bytes);
    assert!(VERIFIED_MODULES_CACHE.contains(&hash_before));
    
    // Activate timed feature
    enable_timed_feature(FixTableNativesMemoryDoubleCounting);
    
    // Hash unchanged, cache still has it
    assert_eq!(hash_before, sha3_256(&module_bytes));
    assert!(VERIFIED_MODULES_CACHE.contains(&hash_before));
    
    // But natives now behave differently - VULNERABILITY!
    let gas_charged = execute_with_cached_module(&module_bytes);
    assert!(gas_charged < expected_gas_with_new_natives());
}
```

## Notes

This vulnerability affects all modules using native functions whose implementations can change (via timed features, feature flags, or VM upgrades). The `FixTableNativesMemoryDoubleCounting` example is scheduled to activate in October 2025, making this a **time-critical issue** requiring fixes before that date.

The root cause is that the verification cache assumes module behavior depends only on bytecode, but native function implementations are a hidden dependency that can change the module's execution semantics without changing its bytecode or hash.

### Citations

**File:** types/src/vm/modules.rs (L24-32)
```rust
    pub fn new(state_value: StateValue) -> Self {
        let (state_value_metadata, bytes) = state_value.unpack();
        let hash = sha3_256(&bytes);
        Self {
            bytes,
            hash,
            state_value_metadata,
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L24-29)
```rust
    /// Returns true if the module hash is contained in the cache. For tests, the cache is treated
    /// as empty at all times.
    pub(crate) fn contains(&self, module_hash: &[u8; 32]) -> bool {
        // Note: need to use get to update LRU queue.
        verifier_cache_enabled() && self.0.lock().get(module_hash).is_some()
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L184-198)
```rust
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L647-656)
```rust
        let (native, is_native) = if def.is_native() {
            let native = natives.resolve(
                module_id.address(),
                module_id.name().as_str(),
                name.as_str(),
            );
            (native, true)
        } else {
            (None, false)
        };
```

**File:** types/src/on_chain_config/timed_features.rs (L26-27)
```rust
    /// Fixes the bug that table natives double count the memory usage of the global values.
    FixTableNativesMemoryDoubleCounting,
```

**File:** types/src/on_chain_config/timed_features.rs (L128-135)
```rust
            (FixTableNativesMemoryDoubleCounting, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2025, 10, 16, 17, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (FixTableNativesMemoryDoubleCounting, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2025, 10, 21, 10, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L395-396)
```rust
    let fix_memory_double_counting =
        context.timed_feature_enabled(TimedFeatureFlag::FixTableNativesMemoryDoubleCounting);
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L416-426)
```rust
    let mem_usage = if !fix_memory_double_counting || loaded.is_some() {
        gv.view()
            .map(|val| {
                abs_val_gas_params
                    .abstract_heap_size(&val, gas_feature_version)
                    .map(u64::from)
            })
            .transpose()?
    } else {
        None
    };
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L118-125)
```rust
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L35-67)
```rust
#[derive(Debug, Clone, Eq, PartialEq, Serialize)]
pub struct VerifierConfig {
    pub scope: VerificationScope,
    pub max_loop_depth: Option<usize>,
    pub max_function_parameters: Option<usize>,
    pub max_generic_instantiation_length: Option<usize>,
    pub max_basic_blocks: Option<usize>,
    pub max_value_stack_size: usize,
    pub max_type_nodes: Option<usize>,
    pub max_push_size: Option<usize>,
    pub max_struct_definitions: Option<usize>,
    pub max_struct_variants: Option<usize>,
    pub max_fields_in_struct: Option<usize>,
    pub max_function_definitions: Option<usize>,
    pub max_back_edges_per_function: Option<usize>,
    pub max_back_edges_per_module: Option<usize>,
    pub max_basic_blocks_in_script: Option<usize>,
    pub max_per_fun_meter_units: Option<u128>,
    pub max_per_mod_meter_units: Option<u128>,
    // signature checker v2 is enabled on mainnet and cannot be disabled
    pub _use_signature_checker_v2: bool,
    pub sig_checker_v2_fix_script_ty_param_count: bool,
    pub enable_enum_types: bool,
    pub enable_resource_access_control: bool,
    pub enable_function_values: bool,
    /// Maximum number of function return values.
    pub max_function_return_values: Option<usize>,
    /// Maximum depth of a type node.
    pub max_type_depth: Option<usize>,
    /// If enabled, signature checker V2 also checks parameter and return types in function
    /// signatures.
    pub sig_checker_v2_fix_function_signatures: bool,
}
```
