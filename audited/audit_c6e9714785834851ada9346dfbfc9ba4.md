# Audit Report

## Title
Language Version Feature Gate Bypass via Compilation Metadata Tampering

## Summary
The `language_version_for_public_struct()` function correctly checks language versions at compile-time, but the public struct feature can be bypassed on mainnet by tampering with compilation metadata post-compilation, as there is no runtime validation of struct visibility or language version verification.

## Finding Description

The public struct feature is gated behind language version V2_4 (currently unstable) via the `language_version_for_public_struct()` function. [1](#0-0) 

However, this security gate has three critical weaknesses:

**1. Compile-time only enforcement:** Struct visibility checks only occur during compilation via the model layer. [2](#0-1)  The check only generates a WARNING, not an error.

**2. No runtime validation:** The Move VM's runtime type checks do not validate struct visibility during Pack/Unpack operations. [3](#0-2)  Struct visibility is not encoded in the bytecode's `StructHandle`. [4](#0-3) 

**3. Metadata tampering possible:** The `CompilationMetadata` is BCS-serialized data with no cryptographic signature. The validation only checks format correctness, not authenticity. [5](#0-4) 

**Attack path:**
1. Compile module with language version V2_4 using public structs
2. Deserialize the compiled bytecode [6](#0-5) 
3. Modify `CompilationMetadata`: change `language_version` from "2.4" to "2.3" and `unstable` from `true` to `false`
4. Re-serialize and deploy on mainnet
5. Module passes `reject_unstable_bytecode()` check since metadata claims V2_3 (stable) [7](#0-6) 
6. Pack/Unpack bytecodes execute successfully as they exist in all bytecode versions [8](#0-7) 

## Impact Explanation

This constitutes a **High Severity** vulnerability under "Significant protocol violations" as it completely undermines the language versioning system's security guarantees. The impact includes:

- **Protocol version enforcement broken**: Unstable features can be deployed on mainnet, violating the safety invariant that "unstable code should not run on production networks"
- **Feature gate bypass**: Any language feature gated by version checks can be enabled prematurely
- **Deterministic execution risk**: While execution itself is deterministic, deploying untested features risks introducing consensus-breaking bugs through paths not validated in testnet

This does not directly cause fund loss or consensus violations, but it breaks a fundamental security control mechanism.

## Likelihood Explanation

**Likelihood: Medium** - Requires:
- Knowledge of Move compilation and bytecode format
- Ability to deserialize/reserialize CompiledModule
- Access to module publishing (any account holder)

No special privileges or validator access required. The test infrastructure already demonstrates metadata modification is possible. [9](#0-8) 

## Recommendation

Implement runtime validation of language version requirements:

1. **Add language version to bytecode**: Include the claimed language version in a tamper-evident location (e.g., as part of the module hash calculation)

2. **Runtime feature validation**: During module loading, verify that the bytecode version and features used are consistent with the claimed language version

3. **Struct visibility validation**: Add runtime checks in Pack/Unpack instruction handlers to validate struct visibility matches the module's declared language version support

4. **Cryptographic metadata binding**: Sign the compilation metadata with the module publisher's key to prevent post-compilation tampering

## Proof of Concept

```rust
// Simplified PoC demonstrating the bypass
// File: metadata_bypass_poc.rs

use move_binary_format::CompiledModule;
use move_model::metadata::{CompilationMetadata, LanguageVersion};
use move_core_types::metadata::Metadata;

fn bypass_language_version_gate(mut module: CompiledModule) -> CompiledModule {
    // Find and modify compilation metadata
    for metadata in &mut module.metadata {
        if metadata.key == b"compilation_metadata" {
            // Deserialize existing metadata
            let mut comp_meta: CompilationMetadata = 
                bcs::from_bytes(&metadata.value).unwrap();
            
            // Bypass: Change V2_4 to V2_3, mark as stable
            comp_meta.language_version = "2.3".to_string();
            comp_meta.unstable = false;
            
            // Re-serialize
            metadata.value = bcs::to_bytes(&comp_meta).unwrap();
            break;
        }
    }
    module
}

// The modified module will:
// 1. Pass reject_unstable_bytecode() check (claims V2_3)
// 2. Execute Pack/Unpack instructions for public structs
// 3. No runtime validation prevents this
```

**Notes:**
- This vulnerability exists because struct visibility is purely a compile-time concept with no runtime enforcement
- The `language_version_for_public_struct()` function itself is correct, but the system lacks validation beyond compilation
- Public struct features in bytecode use standard Pack/Unpack opcodes that exist across all bytecode versions, making version-based filtering impossible at the VM level

### Citations

**File:** third_party/move/move-model/src/metadata.rs (L311-313)
```rust
    pub fn language_version_for_public_struct(&self) -> bool {
        self.is_at_least(lang_feature_versions::LANGUAGE_VERSION_FOR_PUBLIC_STRUCT)
    }
```

**File:** third_party/move/move-model/src/builder/module_builder.rs (L3628-3640)
```rust
            if entry.visibility != Visibility::Private
                && !self
                    .parent
                    .env
                    .language_version()
                    .language_version_for_public_struct()
            {
                self.parent.env.warning(
                        &loc,
                        &format!("structs/enums with visibility modifier are only supported at version {} or later",
                        LANGUAGE_VERSION_FOR_PUBLIC_STRUCT)
                    );
            }
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L576-623)
```rust
            Instruction::Pack(idx) => {
                let field_count = frame.field_count(*idx);
                let args_ty = frame.get_struct(*idx);
                let field_tys = args_ty.fields(None)?.iter().map(|(_, ty)| ty);
                let output_ty = frame.get_struct_ty(*idx);
                verify_pack(operand_stack, field_count, field_tys, output_ty)?;
            },
            Instruction::PackGeneric(idx) => {
                let field_count = frame.field_instantiation_count(*idx);
                let output_ty = ty_cache.get_struct_type(*idx, frame)?.0.clone();
                let args_ty = ty_cache.get_struct_fields_types(*idx, frame)?;

                if field_count as usize != args_ty.len() {
                    // This is an inconsistency between the cache and the actual
                    // type declaration. We would crash if for some reason this invariant does
                    // not hold. It seems impossible to hit, but we keep it here for safety
                    // reasons, as a previous version of this code had this too.
                    return Err(
                        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                            .with_message("Args count mismatch".to_string()),
                    );
                }

                verify_pack(
                    operand_stack,
                    field_count,
                    args_ty.iter().map(|(ty, _)| ty),
                    output_ty,
                )?;
            },
            Instruction::Unpack(idx) => {
                let struct_ty = operand_stack.pop_ty()?;
                struct_ty.paranoid_check_eq(&frame.get_struct_ty(*idx))?;
                let struct_decl = frame.get_struct(*idx);
                for (_name, ty) in struct_decl.fields(None)?.iter() {
                    operand_stack.push_ty(ty.clone())?;
                }
            },
            Instruction::UnpackGeneric(idx) => {
                let struct_ty = operand_stack.pop_ty()?;

                struct_ty.paranoid_check_eq(ty_cache.get_struct_type(*idx, frame)?.0)?;

                let struct_fields_types = ty_cache.get_struct_fields_types(*idx, frame)?;
                for (ty, _) in struct_fields_types {
                    operand_stack.push_ty(ty.clone())?;
                }
            },
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L279-290)
```rust
pub struct StructHandle {
    /// The module that defines the type.
    pub module: ModuleHandleIndex,
    /// The name of the type.
    pub name: IdentifierIndex,
    /// Contains the abilities for this struct
    /// For any instantiation of this type, the abilities of this type are predicated on
    /// that ability being satisfied for all type parameters.
    pub abilities: AbilitySet,
    /// The type formals (identified by their index into the vec)
    pub type_parameters: Vec<StructTypeParameter>,
}
```

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** aptos-move/e2e-move-tests/src/tests/metadata.rs (L104-138)
```rust
fn test_metadata_with_changes(f: impl Fn() -> Vec<Metadata>) -> TransactionStatus {
    let mut h = MoveHarness::new();
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    let mut builder = PackageBuilder::new("Package");
    builder.add_source(
        "m.move",
        r#"
        module 0xf00d::M {
            #[view]
            fun foo(value: u64): u64 { value }
        }
        "#,
    );
    let path = builder.write_to_temp().unwrap();

    let package = BuiltPackage::build(path.path().to_path_buf(), BuildOptions::default())
        .expect("building package must succeed");
    let origin_code = package.extract_code();
    let mut compiled_module = CompiledModule::deserialize(&origin_code[0]).unwrap();
    let metadata = f();
    let mut invalid_code = vec![];
    compiled_module.metadata = metadata;
    compiled_module.serialize(&mut invalid_code).unwrap();

    let package_metadata = package
        .extract_metadata()
        .expect("extracting package metadata must succeed");
    h.run_transaction_payload(
        &account,
        aptos_stdlib::code_publish_package_txn(
            bcs::to_bytes(&package_metadata).expect("PackageMetadata has BCS"),
            vec![invalid_code],
        ),
    )
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L250-251)
```rust
    PACK                        = 0x12,
    UNPACK                      = 0x13,
```
