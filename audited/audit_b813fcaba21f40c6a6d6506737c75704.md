# Audit Report

## Title
ZeroKnowledgeSig Proof Lacks Transaction-Specific Binding Enabling Ephemeral Key Compromise Attack

## Summary
The keyless authentication system allows the same `ZeroKnowledgeSig` proof to be reused for unlimited transactions during the ephemeral key's validity period. If an attacker compromises the ephemeral private key (via malware, XSS, or local storage access), they can construct and sign arbitrary transactions using the victim's existing proof, enabling unauthorized fund transfers until the ephemeral key expires.

## Finding Description

The `build_keyless_signature()` function creates a two-level signature scheme where the ZK proof is transaction-independent: [1](#0-0) 

The ZK proof proves only JWT validity for an ephemeral key and identity, but does NOT commit to any transaction-specific data: [2](#0-1) 

The public inputs hash includes ephemeral public key, identity commitment, expiration data, issuer, JWT header, and JWK—but no transaction content. Transaction binding comes solely from the ephemeral signature: [3](#0-2) 

**Attack Vector:**
1. Attacker compromises user's client (malware/XSS) and extracts ephemeral private key + ZK proof
2. Attacker constructs malicious Transaction B (e.g., transfer victim's funds to attacker)
3. Attacker creates `txn_and_zkp = { message: Transaction B, proof: stolen_zk_proof }`
4. Attacker signs: `ephemeral_sig_B = Sign(stolen_esk, Transaction B || ZK proof)`
5. Both ephemeral signature and ZK proof verification pass during validation

The verification logic confirms this flow: [4](#0-3) 

Sequence numbers/nonces prevent replay of identical transactions but cannot prevent an attacker with the ephemeral key from creating DIFFERENT transactions using the same proof: [5](#0-4) 

## Impact Explanation

**Critical Severity - Loss of Funds**

This vulnerability enables direct theft of funds through:
- Complete account control during ephemeral key validity (typically hours/days)
- Unlimited unauthorized transactions with different sequence numbers
- Bypass of intended one-proof-per-transaction security model

Client compromise scenarios are realistic (browser extensions, mobile malware, debug mode exploitation). A single ephemeral key compromise grants full transaction authority until expiration, affecting all users storing ephemeral keys client-side.

## Likelihood Explanation

**High Likelihood**

Client-side key storage is inherently vulnerable to:
- Cross-site scripting (XSS) attacks extracting localStorage/sessionStorage
- Browser extension malware accessing web app memory
- Mobile app reverse engineering and memory dumps
- Debug console access in development builds
- Compromised dependencies in npm/cargo supply chain

The ephemeral key MUST be stored client-side for transaction signing, creating an unavoidable attack surface. Unlike hardware wallets or secure enclaves, browser/mobile storage offers minimal protection against determined attackers.

## Recommendation

**Implement transaction-specific commitments in the ZK proof public inputs:**

1. Include a transaction hash or nonce in the public inputs hash computation
2. Require proof generation for each transaction (not reusable)
3. Verify the proof commits to the specific transaction during validation

**Alternative mitigation (if per-transaction proofs are too expensive):**

1. Implement proof refresh mechanism with shorter validity periods (seconds, not hours)
2. Add on-chain tracking of proof usage to prevent reuse
3. Require client attestation/hardware-backed key storage for ephemeral keys
4. Implement rate limiting on transactions per proof

The fundamental issue is architectural: separating proof generation (transaction-independent) from transaction signing (transaction-specific) creates a gap where key compromise enables full account control.

## Proof of Concept

```rust
// Simulate attacker with stolen ephemeral key and proof
let stolen_esk = victim_account.ephemeral_key_pair.private_key;
let stolen_proof = victim_account.zk_sig.proof;

// Attacker creates malicious transaction
let malicious_txn = RawTransaction::new(
    victim_address,
    next_sequence_number,
    TransactionPayload::Script(Script::new(
        // Transfer funds to attacker
        aptos_stdlib::aptos_account_transfer(attacker_address, 1_000_000_000),
        vec![],
        vec![],
    )),
    max_gas,
    gas_price,
    expiration_time,
    chain_id,
);

// Attacker signs with stolen key
let txn_and_zkp = TransactionAndProof {
    message: malicious_txn.clone(),
    proof: Some(stolen_proof),
};
let malicious_ephemeral_sig = stolen_esk.sign(&txn_and_zkp).unwrap();

// Construct valid KeylessSignature with reused proof
let malicious_signature = KeylessSignature {
    cert: EphemeralCertificate::ZeroKnowledgeSig(victim_account.zk_sig.clone()),
    jwt_header_json: victim_account.jwt_header_json.clone(),
    exp_date_secs: victim_account.expiry_date_secs,
    ephemeral_pubkey: stolen_esk.public_key(),
    ephemeral_signature: malicious_ephemeral_sig,
};

// Transaction passes all validation checks
let signed_txn = SignedTransaction::new_keyless(
    malicious_txn,
    victim_account.public_key.clone(),
    malicious_signature,
);

// Submit to blockchain - verification passes, funds transferred
```

**Notes**

The vulnerability stems from an architectural design choice: transaction-independent ZK proofs combined with client-side ephemeral key storage. While the two-level signature scheme (ZK proof + ephemeral signature) provides correctness, it concentrates security on ephemeral key secrecy—a single point of failure vulnerable to common client-side attacks. Traditional transaction-specific proofs would prevent this attack vector by cryptographically binding each proof to its intended transaction, making stolen proofs unusable for other transactions even if the ephemeral key is compromised.

### Citations

**File:** sdk/src/types.rs (L92-113)
```rust
    fn build_keyless_signature(
        &self,
        txn: RawTransaction,
        account: &impl CommonKeylessAccount,
    ) -> KeylessSignature {
        let proof = account.zk_sig().proof;
        let txn_and_zkp = keyless::TransactionAndProof {
            message: txn,
            proof: Some(proof),
        };

        let esk = account.ephem_private_key();
        let ephemeral_signature = esk.sign(&txn_and_zkp).unwrap();

        KeylessSignature {
            cert: EphemeralCertificate::ZeroKnowledgeSig(account.zk_sig().clone()),
            jwt_header_json: account.jwt_header_json().clone(),
            exp_date_secs: account.expiry_date_secs(),
            ephemeral_pubkey: account.ephem_public_key().clone(),
            ephemeral_signature,
        }
    }
```

**File:** types/src/keyless/bn254_circom.rs (L279-369)
```rust
pub fn hash_public_inputs(
    config: &Configuration,
    epk: &EphemeralPublicKey,
    idc: &IdCommitment,
    exp_timestamp_secs: u64,
    exp_horizon_secs: u64,
    iss: &str,
    extra_field: Option<&str>,
    jwt_header_json: &str,
    jwk: &RSA_JWK,
    override_aud_val: Option<&str>,
) -> anyhow::Result<Fr> {
    let (has_extra_field, extra_field_hash) = match extra_field {
        None => (Fr::zero(), *EMPTY_EXTRA_FIELD_HASH),
        Some(extra_field) => (
            Fr::one(),
            poseidon_bn254::keyless::pad_and_hash_string(
                extra_field,
                config.max_extra_field_bytes as usize,
            )?,
        ),
    };

    let (override_aud_val_hash, use_override_aud) = match override_aud_val {
        Some(override_aud_val) => (
            cached_pad_and_hash_string(override_aud_val, IdCommitment::MAX_AUD_VAL_BYTES)?,
            ark_bn254::Fr::from(1),
        ),
        None => (*EMPTY_OVERRIDE_AUD_FIELD_HASH, ark_bn254::Fr::from(0)),
    };

    // Add the hash of the jwt_header with the "." separator appended
    let jwt_header_b64_with_separator = format!("{}.", base64url_encode_str(jwt_header_json));
    let jwt_header_hash = cached_pad_and_hash_string(
        &jwt_header_b64_with_separator,
        config.max_jwt_header_b64_bytes as usize,
    )?;

    let jwk_hash = cached_jwk_hash(jwk)?;

    // Add the hash of the value of the `iss` field
    let iss_field_hash = cached_pad_and_hash_string(iss, config.max_iss_val_bytes as usize)?;

    // Add the id_commitment as a scalar
    let idc = Fr::from_le_bytes_mod_order(&idc.0);

    // Add the exp_timestamp_secs as a scalar
    let exp_timestamp_secs = Fr::from(exp_timestamp_secs);

    // Add the epk lifespan as a scalar
    let exp_horizon_secs = Fr::from(exp_horizon_secs);

    let mut epk_frs = poseidon_bn254::keyless::pad_and_pack_bytes_to_scalars_with_len(
        epk.to_bytes().as_slice(),
        config.max_commited_epk_bytes as usize,
    )?;

    // println!("Num EPK scalars:    {}", epk_frs.len());
    // for (i, e) in epk_frs.iter().enumerate() {
    //     println!("EPK Fr[{}]:          {}", i, e.to_string())
    // }
    // println!("IDC:                {}", idc);
    // println!("exp_timestamp_secs: {}", exp_timestamp_secs);
    // println!("exp_horizon_secs:   {}", exp_horizon_secs);
    // println!("iss field:          {}", pk.iss_val);
    // println!("iss field hash:     {}", iss_field_hash);
    // println!("Has extra field:    {}", has_extra_field);
    // println!("Extra field val:    {:?}", proof.extra_field);
    // println!("Extra field hash:   {}", extra_field_hash);
    // println!("JWT header val:     {}", jwt_header_b64_with_separator);
    // println!("JWT header hash:    {}", jwt_header_hash);
    // println!("JWK hash:           {}", jwk_hash);
    // println!("Override aud hash:  {}", override_aud_val_hash);
    // println!("Use override aud:   {}", use_override_aud.to_string());

    let mut frs = vec![];
    frs.append(&mut epk_frs);
    frs.push(idc);
    frs.push(exp_timestamp_secs);
    frs.push(exp_horizon_secs);
    frs.push(iss_field_hash);
    frs.push(has_extra_field);
    frs.push(extra_field_hash);
    frs.push(jwt_header_hash);
    frs.push(jwk_hash);
    frs.push(override_aud_val_hash);
    frs.push(use_override_aud);
    // TODO(keyless): If we plan on avoiding verifying the same PIH twice, there should be no
    //  need for caching here. If we do not, we should cache the result here too.
    poseidon_bn254::hash_scalars(frs)
}
```

**File:** types/src/transaction/authenticator.rs (L1319-1347)
```rust
    fn verify_keyless_ephemeral_signature<T: Serialize + CryptoHash>(
        message: &T,
        signature: &KeylessSignature,
    ) -> Result<()> {
        // Verifies the ephemeral signature on (TXN [+ ZKP]). The rest of the verification,
        // i.e., [ZKPoK of] OpenID signature verification is done in
        // `AptosVM::run_prologue`.
        //
        // This is because the JWK, under which the [ZKPoK of an] OpenID signature verifies,
        // can only be fetched from on chain inside the `AptosVM`.
        //
        // This deferred verification is what actually ensures the `signature.ephemeral_pubkey`
        // used below is the right pubkey signed by the OIDC provider.

        let mut txn_and_zkp = TransactionAndProof {
            message,
            proof: None,
        };

        // Add the ZK proof into the `txn_and_zkp` struct, if we are in the ZK path
        match &signature.cert {
            EphemeralCertificate::ZeroKnowledgeSig(proof) => txn_and_zkp.proof = Some(proof.proof),
            EphemeralCertificate::OpenIdSig(_) => {},
        }

        signature
            .ephemeral_signature
            .verify(&txn_and_zkp, &signature.ephemeral_pubkey)
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L275-402)
```rust
pub fn verify_keyless_signature_without_ephemeral_signature_check(
    public_key: &AnyKeylessPublicKey,
    signature: &KeylessSignature,
    jwk: &JWK,
    onchain_timestamp_microseconds: u64,
    training_wheels_pk: &Option<EphemeralPublicKey>,
    config: &Configuration,
    pvk: Option<&PreparedVerifyingKey<Bn254>>,
) -> Result<(), VMStatus> {
    signature
        .verify_expiry(onchain_timestamp_microseconds)
        .map_err(|_| {
            // println!("[aptos-vm][groth16] ZKP expired");

            invalid_signature!("The ephemeral keypair has expired")
        })?;
    match &signature.cert {
        EphemeralCertificate::ZeroKnowledgeSig(zksig) => match jwk {
            JWK::RSA(rsa_jwk) => {
                if zksig.exp_horizon_secs > config.max_exp_horizon_secs {
                    // println!("[aptos-vm][groth16] Expiration horizon is too long");
                    return Err(invalid_signature!("The expiration horizon is too long"));
                }

                // If an `aud` override was set for account recovery purposes, check that it is
                // in the allow-list on-chain.
                if zksig.override_aud_val.is_some() {
                    config.is_allowed_override_aud(zksig.override_aud_val.as_ref().unwrap())?;
                }
                match &zksig.proof {
                    ZKP::Groth16(groth16proof) => {
                        // let start = std::time::Instant::now();
                        let public_inputs_hash = get_public_inputs_hash(
                            signature,
                            public_key.inner_keyless_pk(),
                            rsa_jwk,
                            config,
                        )
                        .map_err(|_| {
                            // println!("[aptos-vm][groth16] PIH computation failed");
                            invalid_signature!("Could not compute public inputs hash")
                        })?;
                        // println!("Public inputs hash time: {:?}", start.elapsed());

                        let groth16_and_stmt =
                            Groth16ProofAndStatement::new(*groth16proof, public_inputs_hash);

                        // The training wheels signature is only checked if a training wheels PK is set on chain
                        if training_wheels_pk.is_some() {
                            match &zksig.training_wheels_signature {
                                Some(training_wheels_sig) => {
                                    training_wheels_sig
                                        .verify(
                                            &groth16_and_stmt,
                                            training_wheels_pk.as_ref().unwrap(),
                                        )
                                        .map_err(|_| {
                                            // println!("[aptos-vm][groth16] TW sig verification failed");
                                            invalid_signature!(
                                                "Could not verify training wheels signature"
                                            )
                                        })?;
                                },
                                None => {
                                    // println!("[aptos-vm][groth16] Expected TW sig to be set");
                                    return Err(invalid_signature!(
                                        "Training wheels signature expected but it is missing"
                                    ));
                                },
                            }
                        }

                        let result = zksig.verify_groth16_proof(public_inputs_hash, pvk.unwrap());

                        result.map_err(|_| {
                            // println!("[aptos-vm][groth16] ZKP verification failed");
                            // println!("[aptos-vm][groth16] PIH: {}", public_inputs_hash);
                            // match zksig.proof {
                            //     ZKP::Groth16(proof) => {
                            //         println!("[aptos-vm][groth16] ZKP: {}", proof.hash());
                            //     },
                            // }
                            // println!(
                            //     "[aptos-vm][groth16] PVK: {}",
                            //     Groth16VerificationKey::from(pvk).hash()
                            // );
                            invalid_signature!("Proof verification failed")
                        })?;
                    },
                }
            },
            JWK::Unsupported(_) => return Err(invalid_signature!("JWK is not supported")),
        },
        EphemeralCertificate::OpenIdSig(openid_sig) => {
            match jwk {
                JWK::RSA(rsa_jwk) => {
                    openid_sig
                        .verify_jwt_claims(
                            signature.exp_date_secs,
                            &signature.ephemeral_pubkey,
                            public_key.inner_keyless_pk(),
                            config,
                        )
                        .map_err(|_| invalid_signature!("OpenID claim verification failed"))?;

                    // TODO(OpenIdSig): Implement batch verification for all RSA signatures in
                    //  one TXN.
                    // Note: Individual OpenID RSA signature verification will be fast when the
                    // RSA public exponent is small (e.g., 65537). For the same TXN, batch
                    // verification of all RSA signatures will be even faster even when the
                    // exponent is the same. Across different TXNs, batch verification will be
                    // (1) more difficult to implement and (2) not very beneficial since, when
                    // it fails, bad signature identification will require re-verifying all
                    // signatures assuming an adversarial batch.
                    //
                    // We are now ready to verify the RSA signature
                    openid_sig
                        .verify_jwt_signature(rsa_jwk, &signature.jwt_header_json)
                        .map_err(|_| {
                            invalid_signature!("RSA signature verification failed for OpenIdSig")
                        })?;
                },
                JWK::Unsupported(_) => return Err(invalid_signature!("JWK is not supported")),
            }
        },
    }
    Ok(())
}
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L29-37)
```text
    // We need to ensure that a transaction can't be replayed.
    // There are two ways to prevent replay attacks:
    // 1. Use a nonce. Orderless transactions use this.
    // 2. Use a sequence number. Regular transactions use this.
    // A replay protector of a transaction signifies which of the above methods is used.
    enum ReplayProtector {
        Nonce(u64),
        SequenceNumber(u64),
    }
```
