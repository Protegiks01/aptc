# Audit Report

## Title
Consensus Observer Verification Failure Due to Inconsistent Expired Batch Handling in OptQuorumStore Payloads

## Summary
A critical inconsistency exists between how the consensus publisher and consensus observer handle expired batches in OptQuorumStore payloads. The publisher filters out transactions from expired optimistic batches when creating BlockPayload messages, but the observer attempts to reconstruct all batches without checking expiration, causing verification to fail for valid blocks containing expired opt batches.

## Finding Description

The vulnerability lies in the divergent handling of expired batches between the publisher and observer:

**Publisher Behavior:**
When the QuorumStorePayloadManager processes OptQuorumStore payloads to send to observers, it filters expired opt batches during transaction retrieval: [1](#0-0) 

The `request_transactions()` function explicitly skips expired batches (when `block_timestamp > batch_info.expiration()`), preventing their transactions from being fetched. However, when creating the final BlockTransactionPayload, the publisher includes ALL batch infos from the original payload: [2](#0-1) 

Notice line 536: `opt_qs_payload.opt_batches().deref().clone()` includes batch infos from the original payload, regardless of expiration status.

**Observer Behavior:**
When the observer verifies the BlockPayload, it processes opt/inline batches with `skip_expired_batches = false`: [3](#0-2) 

The `reconstruct_batch()` function is called with `skip_expired_batches = false`, which means it will NOT check batch expiration and will attempt to consume transactions: [4](#0-3) 

When `skip_expired_batches = false`, the expiration check is bypassed, and the function attempts to consume `num_txns` transactions. If the publisher didn't send these transactions (due to filtering), reconstruction fails at line 1006-1010.

**The Vulnerability:**
1. A block contains an OptQuorumStore payload with opt batches
2. Some opt batches have `expiration < block_timestamp` (expired)
3. Publisher filters out expired opt batches when fetching transactions (no transactions sent)
4. Publisher includes all batch infos (including expired ones) in the BlockTransactionPayload
5. Observer receives payload with transactions missing for expired batches
6. Observer attempts to reconstruct all batches without checking expiration
7. Observer fails with "Failed to extract transaction during batch reconstruction!"

This violates the **Deterministic Execution** invariant because different nodes may accept or reject the same block depending on timing and network conditions.

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos bug bounty)

This vulnerability causes:

1. **Significant Protocol Violations**: The consensus observer subsystem fails to correctly verify valid blocks, breaking the integrity of the observation mechanism.

2. **Denial of Service**: Observers that receive blocks with expired opt batches will continuously fail verification, preventing them from staying synchronized with consensus.

3. **Network Partition Risk**: Different observers may have different views of which blocks are valid based on when they receive and process the payload, potentially causing inconsistent states across the network.

4. **Consensus Observer Reliability**: The consensus observer is a critical component for network scalability and light clients. Its failure undermines the reliability of the entire subsystem.

While this doesn't directly cause fund loss or consensus safety violations in the main consensus protocol, it represents a **significant protocol violation** that affects the availability and reliability of the consensus observer infrastructure, meeting the HIGH severity criteria.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

This vulnerability will occur whenever:
- A block contains OptQuorumStore payloads with opt batches
- The opt batches expire between block creation and observer verification
- Network delays, processing latency, or system load causes timing discrepancies

The likelihood increases when:
- Network latency is high
- Batch expiration times are short
- System is under heavy load
- Many optimistic batches are used in payloads

Given that optimistic batches are a standard feature of the quorum store and expiration is a built-in mechanism, this vulnerability can occur naturally without any malicious intent, making it a **realistic and recurring issue** in production environments.

## Recommendation

The fix requires ensuring consistency between publisher and observer expired batch handling. There are two approaches:

**Option 1: Filter batch infos in publisher (Recommended)**
Modify the publisher to exclude expired opt batch infos when creating the BlockTransactionPayload:

```rust
// In quorum_store_payload_manager.rs, around line 530-540
let filtered_opt_batches: Vec<_> = opt_qs_payload.opt_batches()
    .iter()
    .filter(|batch| block.timestamp_usecs() <= batch.expiration())
    .cloned()
    .collect();

BlockTransactionPayload::new_opt_quorum_store(
    all_txns,
    opt_qs_payload.proof_with_data().deref().clone(),
    opt_qs_payload.max_txns_to_execute(),
    opt_qs_payload.block_gas_limit(),
    [
        filtered_opt_batches,  // Only include non-expired opt batches
        opt_qs_payload.inline_batches().batch_infos(),
    ]
    .concat(),
)
```

**Option 2: Enable expiration check in observer**
Modify the observer to skip expired opt batches by passing `skip_expired_batches = true`:

```rust
// In observer_message.rs, around line 914
match reconstruct_batch(&block_info, &mut transactions_iter, batch_info, true) {  // Changed to true
    Ok(Some(batch_transactions)) => {
        batches_and_transactions.push((batch_info.clone(), batch_transactions));
    },
    Ok(None) => { /* Batch was expired, skip it */ },
    Err(error) => { /* Handle error */ }
}
```

**Option 1 is recommended** because it maintains the invariant that all batch infos in the BlockTransactionPayload should have corresponding transactions, making the data structure consistent and easier to reason about.

## Proof of Concept

The following scenario demonstrates the vulnerability:

```rust
// Proof of Concept: Expired Opt Batch Verification Failure

// 1. Setup: Create a block with OptQuorumStore payload
let block_timestamp = 1000000; // microseconds
let opt_batch_expiration = 999999; // Expires before block timestamp

// 2. Publisher creates payload
// opt_batch will be filtered out during request_transactions()
// because block_timestamp (1000000) > opt_batch_expiration (999999)

let batch_info = BatchInfo::new(
    author,
    batch_id,
    epoch,
    opt_batch_expiration,  // Expired!
    digest,
    num_txns: 10,
    num_bytes: 1000,
    gas_bucket_start: 0,
);

// 3. Publisher sends BlockTransactionPayload with:
// - transactions: [] (empty, because expired batch was filtered)
// - batch_infos: [batch_info] (includes expired batch)

// 4. Observer receives and attempts verification
let block_payload = BlockPayload::new(block_info, transaction_payload);
let result = block_payload.verify_payload_digests();

// 5. Observer fails with error:
// Error::InvalidMessageError("Failed to extract transaction during batch reconstruction! 
//                             Batch: {:?}, transaction index: 0")
// 
// Because:
// - Observer tries to reconstruct batch with skip_expired_batches=false
// - Observer attempts to consume 10 transactions
// - No transactions available (publisher filtered them out)
// - Verification fails

assert!(result.is_err());
```

The vulnerability can be triggered by creating a test block with expired opt batches and observing the verification failure in the consensus observer's block payload verification logic.

**Notes:**

This vulnerability affects the consensus observer subsystem specifically, which is used for improving scalability and enabling light clients. The main consensus protocol itself is not directly affected, but the reliability of the observation infrastructure is compromised. The issue stems from a logic inconsistency where two parts of the codebase make different assumptions about how expired batches should be handled, leading to verification failures for otherwise valid blocks.

### Citations

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L89-109)
```rust
    fn request_transactions(
        batches: Vec<(BatchInfo, Vec<PeerId>)>,
        block_timestamp: u64,
        batch_reader: Arc<dyn BatchReader>,
    ) -> Vec<Shared<Pin<Box<dyn Future<Output = ExecutorResult<Vec<SignedTransaction>>> + Send>>>>
    {
        let mut futures = Vec::new();
        for (batch_info, responders) in batches {
            trace!(
                "QSE: requesting batch {:?}, time = {}",
                batch_info,
                block_timestamp
            );
            if block_timestamp <= batch_info.expiration() {
                futures.push(batch_reader.get_batch(batch_info, responders.clone()));
            } else {
                debug!("QSE: skipped expired batch {}", batch_info.digest());
            }
        }
        futures
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L511-540)
```rust
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(opt_qs_payload)) => {
                let opt_batch_txns = process_optqs_payload(
                    opt_qs_payload.opt_batches(),
                    self.batch_reader.clone(),
                    block,
                    &self.ordered_authors,
                    block_signers.as_ref(),
                )
                .await?;
                let proof_batch_txns = process_optqs_payload(
                    opt_qs_payload.proof_with_data(),
                    self.batch_reader.clone(),
                    block,
                    &self.ordered_authors,
                    None,
                )
                .await?;
                let inline_batch_txns = opt_qs_payload.inline_batches().transactions();
                let all_txns = [proof_batch_txns, opt_batch_txns, inline_batch_txns].concat();
                BlockTransactionPayload::new_opt_quorum_store(
                    all_txns,
                    opt_qs_payload.proof_with_data().deref().clone(),
                    opt_qs_payload.max_txns_to_execute(),
                    opt_qs_payload.block_gas_limit(),
                    [
                        opt_qs_payload.opt_batches().deref().clone(),
                        opt_qs_payload.inline_batches().batch_infos(),
                    ]
                    .concat(),
                )
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L913-931)
```rust
        for batch_info in opt_and_inline_batches.iter() {
            match reconstruct_batch(&block_info, &mut transactions_iter, batch_info, false) {
                Ok(Some(batch_transactions)) => {
                    batches_and_transactions.push((batch_info.clone(), batch_transactions));
                },
                Ok(None) => {
                    return Err(Error::UnexpectedError(format!(
                        "Failed to reconstruct inline/opt batch! Batch was unexpectedly skipped: {:?}",
                        batch_info
                    )));
                },
                Err(error) => {
                    return Err(Error::InvalidMessageError(format!(
                        "Failed to reconstruct inline/opt batch! Num transactions: {:?}, \
                        num batches: {:?}, num opt/inline batches: {:?}, failed batch: {:?}, Error: {:?}",
                        num_transactions, num_payload_proofs, num_opt_and_inline_batches, batch_info, error
                    )));
                },
            }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L987-1016)
```rust
fn reconstruct_batch(
    block_info: &BlockInfo,
    transactions_iter: &mut IntoIter<SignedTransaction>,
    expected_batch_info: &BatchInfo,
    skip_expired_batches: bool,
) -> Result<Option<Vec<SignedTransaction>>, Error> {
    // If the batch is expired we should skip reconstruction (as the
    // transactions for the expired batch won't be sent in the payload).
    // Note: this should only be required for QS batches (not inline batches).
    if skip_expired_batches && block_info.timestamp_usecs() > expected_batch_info.expiration() {
        return Ok(None);
    }

    // Gather the transactions for the batch
    let mut batch_transactions = vec![];
    for i in 0..expected_batch_info.num_txns() {
        let batch_transaction = match transactions_iter.next() {
            Some(transaction) => transaction,
            None => {
                return Err(Error::InvalidMessageError(format!(
                    "Failed to extract transaction during batch reconstruction! Batch: {:?}, transaction index: {:?}",
                    expected_batch_info, i
                )));
            },
        };
        batch_transactions.push(batch_transaction);
    }

    Ok(Some(batch_transactions))
}
```
