# Audit Report

## Title
Undefined Behavior in Chunky PVSS Due to Insufficient Chunk Size Validation

## Summary
The assertion in `scalar_to_le_chunks()` and `le_chunks_to_scalar()` allows `num_bits = 64`, but dependent code in `compute_powers_of_radix()` performs `1u64 << 64` which is undefined behavior in Rust. This creates an inconsistency where the validation accepts a value that causes UB in production code, violating the Deterministic Execution invariant.

## Finding Description
The chunky PVSS implementation has inconsistent handling of the maximum chunk size: [1](#0-0) 

This assertion allows `num_bits <= 64`, including the edge case of exactly 64 bits. The `le_chunks_to_scalar()` function handles this case correctly using `1u128 << num_bits`: [2](#0-1) 

However, when `PublicParameters` is instantiated with `ell = 64`, the `compute_powers_of_radix()` function is called: [3](#0-2) 

This function uses `1u64 << ell`. When `ell = 64`, this becomes `1u64 << 64`, which is **undefined behavior** in Rust (shifting a 64-bit value by 64 bits). According to Rust's semantics:
- In debug mode: this panics
- In release mode: behavior is implementation-defined (typically wraps to 0)

The same pattern appears in the range proof setup, where `powers_of_two()` is called: [4](#0-3) 

When `j` reaches 63 (the last iteration when `ell = 64`), `1u64 << 63` is still valid, but if `ell` were somehow increased beyond 64, this would also trigger UB.

**Attack Path:**
1. During DKG setup, if `ell` parameter is set to 64 (either through misconfiguration or malicious parameter injection)
2. `PublicParameters::new(n, 64, max_aggregation, rng)` is called
3. `compute_powers_of_radix::<E>(64)` invokes `1u64 << 64` → UB
4. Different compiler versions, optimization levels, or build modes produce different results
5. Validators computing DKG parameters get inconsistent results
6. DKG ceremony fails or produces inconsistent transcripts

## Impact Explanation
This is a **Medium severity** vulnerability per Aptos bug bounty criteria:

**State Inconsistencies Requiring Intervention:** If triggered, this causes:
- Non-deterministic behavior across different build configurations
- Debug builds panic, release builds may produce zero or wrap-around values
- Validators could disagree on computed public parameters
- DKG ceremony could fail or produce inconsistent results

**Why Not Critical:**
- Chunky PVSS appears to be experimental (production uses DAS PVSS)
- Test cases only use `ell ≤ 16`, not 64
- Requires privileged action (DKG parameter selection) rather than unprivileged attacker access

**Why Not Low:**
- Violates the **Deterministic Execution** invariant (Critical Invariant #1)
- Could cause consensus splits if validators disagree on DKG parameters
- UB can have unpredictable security consequences

## Likelihood Explanation
**Low-to-Medium likelihood:**

**Factors reducing likelihood:**
- Current production code uses DAS PVSS, not chunky PVSS
- Default test value is `ell = 16`, far below the problematic threshold
- No observed production configurations using `ell = 64`

**Factors increasing likelihood:**
- The assertion explicitly allows this value, suggesting it may be considered valid
- No validation exists between the assertion layer and the UB-inducing code
- Future migrations to chunky PVSS could inadvertently trigger this
- Parameter validation gaps could allow external influence on `ell` values

## Recommendation
Add explicit maximum bounds that account for the `u64` limitation in dependent code:

```rust
// In chunks.rs - tighten the upper bound
pub fn scalar_to_le_chunks<F: PrimeField>(num_bits: u8, scalar: &F) -> Vec<F> {
    assert!(
        num_bits.is_multiple_of(8) && num_bits > 0 && num_bits < 64, // Changed <= to <
        "Invalid chunk size: num_bits must be multiple of 8, positive, and strictly less than 64"
    );
    // ... rest of implementation
}

// In public_parameters.rs - use u128 for consistency
fn compute_powers_of_radix<E: Pairing>(ell: u8) -> Vec<E::ScalarField> {
    assert!(ell < 64, "ell must be strictly less than 64 to avoid shift overflow");
    utils::powers(
        E::ScalarField::from(1u128 << ell), // Changed from u64 to u128
        num_chunks_per_scalar::<E::ScalarField>(ell) as usize,
    )
}

// In arkworks/mod.rs - use u128 for safety
pub fn powers_of_two<F: Field>(ell: usize) -> Vec<F> {
    assert!(ell < 64, "ell must be strictly less than 64");
    (0..ell).map(|j| F::from(1u128 << j)).collect() // Changed from u64 to u128
}
```

Alternatively, document that `ell` must be strictly less than 64 and add runtime validation at the entry point of `PublicParameters::new()`.

## Proof of Concept
```rust
#[test]
#[should_panic(expected = "attempt to shift left with overflow")]
fn test_ub_with_ell_64() {
    use ark_bls12_381::Bls12_381;
    use aptos_dkg::pvss::chunky::public_parameters::PublicParameters;
    use rand::thread_rng;
    
    let mut rng = thread_rng();
    // This will trigger UB in debug mode (panic)
    // and undefined behavior in release mode
    let _pp = PublicParameters::<Bls12_381>::new(
        1,    // max_num_shares
        64,   // ell - the problematic value
        1,    // max_aggregation
        &mut rng,
    );
}

#[test]
fn test_inconsistent_behavior_across_builds() {
    // Demonstrates that the assertion allows what the implementation cannot handle
    use ark_bls12_381::Fr;
    use aptos_dkg::pvss::chunky::chunks::{scalar_to_le_chunks, le_chunks_to_scalar};
    use ark_ff::UniformRand;
    use rand::thread_rng;
    
    let mut rng = thread_rng();
    let scalar = Fr::rand(&mut rng);
    
    // This passes the assertion
    let chunks = scalar_to_le_chunks(64, &scalar);
    let reconstructed = le_chunks_to_scalar(64, &chunks);
    
    // But if we try to use this with PublicParameters, we get UB
    assert_eq!(scalar, reconstructed);
}
```

## Notes
While the chunky PVSS implementation may not be actively used in current production deployments, this vulnerability represents a **validation gap** where the assertion layer permits values that cause undefined behavior in dependent code. This violates secure coding principles and the Deterministic Execution invariant. The fix is straightforward: either tighten the assertion to `num_bits < 64` or upgrade all shift operations to use `u128` consistently.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/chunks.rs (L8-11)
```rust
    assert!(
        num_bits.is_multiple_of(8) && num_bits > 0 && num_bits <= 64,
        "Invalid chunk size"
    );
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunks.rs (L38-38)
```rust
    let base = F::from(1u128 << num_bits); // need u128 in the case where `num_bits` is 64, because of `chunk * multiplier`
```

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L35-40)
```rust
fn compute_powers_of_radix<E: Pairing>(ell: u8) -> Vec<E::ScalarField> {
    utils::powers(
        E::ScalarField::from(1u64 << ell),
        num_chunks_per_scalar::<E::ScalarField>(ell) as usize,
    )
}
```

**File:** crates/aptos-crypto/src/arkworks/mod.rs (L43-45)
```rust
pub fn powers_of_two<F: Field>(ell: usize) -> Vec<F> {
    (0..ell).map(|j| F::from(1u64 << j)).collect()
}
```
