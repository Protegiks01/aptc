# Audit Report

## Title
QC-TC Inconsistency in sign_timeout_with_qc Allows Bypass of 2-Chain Safety Rules

## Summary
The `safe_to_timeout` function in the 2-chain consensus safety rules fails to validate that a timeout's QC round is at least as high as the timeout certificate's (TC's) highest HQC round. This inconsistency with the analogous `safe_to_vote` check allows validators to sign timeouts that regress the network's knowledge of certified blocks, violating the monotonicity invariant required for 2-chain consensus safety.

## Finding Description
The Aptos 2-chain consensus protocol requires strict monotonicity of certified block rounds to maintain safety. When a timeout certificate (TC) is formed at round R with `highest_hqc_round = H`, all subsequent timeouts at round R+1 must reference a QC with round ≥ H to preserve the network's progress invariant. [1](#0-0) 

The `safe_to_vote` function correctly enforces this invariant: when voting on a block following a TC, it requires `qc_round >= hqc_round` (line 160). [2](#0-1) 

However, `safe_to_timeout` lacks this critical check. When signing a timeout following a TC (condition `round == next_round(tc_round)`), it only verifies `qc_round >= safety_data.one_chain_round` but **never checks** `qc_round >= tc.highest_hqc_round()`. [3](#0-2) 

The vulnerability manifests in `guarded_sign_timeout_with_qc` which calls `safe_to_timeout` without additional validation (line 36).

**Attack Scenario:**
1. Network forms TC₁₀ at round 10 with `highest_hqc_round = 10`
2. Malicious validator creates timeout for round 11 with QC at round 5
3. Calls `sign_timeout_with_qc(timeout₁₁, Some(TC₁₀))`
4. `safe_to_timeout` checks:
   - `round == next_round(tc_round)` → 11 == 11 ✓
   - `qc_round >= one_chain_round` → 5 ≥ one_chain_round (may pass) ✓
   - **MISSING:** `qc_round >= tc.highest_hqc_round()` → 5 ≥ 10 (should FAIL!)
5. Validator successfully signs regressed timeout
6. If enough validators sign such timeouts, TC₁₁ forms with `highest_hqc_round < 10`
7. Subsequent votes at round 12 can now reference QCs < 10, violating safety [4](#0-3) 

The TC's `highest_hqc_round()` method (line 196-198) returns the embedded timeout's HQC round, which aggregation logic (line 259) updates to the maximum observed across all signers.

## Impact Explanation
**Severity: Critical** - This is a consensus safety violation that breaks the fundamental invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine validators."

The vulnerability enables:
1. **QC Regression**: Validators can sign timeouts with older QCs than what the network has certified, breaking monotonicity
2. **Safety Rule Bypass**: Subsequent TCs with regressed `highest_hqc_round` allow voting on blocks that don't acknowledge latest certified state
3. **Potential Chain Splits**: Different validators may have inconsistent views of safe votes, enabling equivocation
4. **2-Chain Commit Rule Violation**: The 2-chain commit rule assumes monotonic QC progression; regression undermines this assumption [5](#0-4) 

The 2-chain commit rule (line 204) depends on strict round ordering. QC regression could enable committing conflicting blocks.

## Likelihood Explanation
**Likelihood: Medium-High**

- **Exploitable by any validator**: Does not require Byzantine majority or collusion
- **No special privileges needed**: Standard timeout signing process
- **Realistic scenario**: Validators naturally experience network partitions or state synchronization delays that could legitimately result in holding older QCs
- **Accidental exploitation**: Even non-malicious validators with stale state could trigger this
- **Detection difficulty**: The signed timeout appears valid unless the QC-TC consistency is explicitly checked

The main barrier is that honest validators would typically hold current QCs, but Byzantine or network-partitioned validators can deliberately exploit this.

## Recommendation

Add the missing consistency check in `safe_to_timeout` to mirror the `safe_to_vote` logic:

```rust
fn safe_to_timeout(
    &self,
    timeout: &TwoChainTimeout,
    maybe_tc: Option<&TwoChainTimeoutCertificate>,
    safety_data: &SafetyData,
) -> Result<(), Error> {
    let round = timeout.round();
    let qc_round = timeout.hqc_round();
    let tc_round = maybe_tc.map_or(0, |tc| tc.round());
    
    // NEW: Check QC-TC consistency when following a TC
    if let Some(tc) = maybe_tc {
        let tc_hqc_round = tc.highest_hqc_round();
        if round == next_round(tc_round)? && qc_round < tc_hqc_round {
            return Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ));
        }
    }
    
    if (round == next_round(qc_round)? || round == next_round(tc_round)?)
        && qc_round >= safety_data.one_chain_round
    {
        Ok(())
    } else {
        Err(Error::NotSafeToTimeout(
            round,
            qc_round,
            tc_round,
            safety_data.one_chain_round,
        ))
    }
}
```

This ensures that when a validator signs a timeout following a TC, the timeout's QC round must be at least as high as the TC's highest HQC round, maintaining the monotonicity invariant required for 2-chain safety.

## Proof of Concept

```rust
#[test]
fn test_timeout_qc_tc_inconsistency_exploit() {
    use crate::{test_utils, TSafetyRules};
    use aptos_consensus_types::timeout_2chain::TwoChainTimeout;
    
    let (mut safety_rules, signer) = test_utils::make_safety_rules();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();
    
    // Build chain: genesis(0) -> a1(1) -> a2(2) -> ... -> a10(10)
    let mut qc = genesis_qc.clone();
    for round in 1..=10 {
        let proposal = test_utils::make_proposal_with_qc(round, qc.clone(), &signer);
        let vote = safety_rules.construct_and_sign_vote_two_chain(&proposal, None).unwrap();
        qc = test_utils::make_qc_from_vote(&vote, &signer);
    }
    
    // QC at round 10 is now the highest
    // Form TC at round 10 with highest_hqc_round = 10
    let tc_10 = test_utils::make_timeout_cert(10, &qc, &signer);
    assert_eq!(tc_10.highest_hqc_round(), 10);
    
    // EXPLOIT: Try to sign timeout for round 11 with OLD QC at round 5
    let old_qc = genesis_qc.clone(); // Round 0
    let malicious_timeout = TwoChainTimeout::new(1, 11, old_qc);
    
    // This SHOULD fail because qc_round (0) < tc.highest_hqc_round() (10)
    // But it currently PASSES due to the missing check
    let result = safety_rules.sign_timeout_with_qc(
        &malicious_timeout,
        Some(&tc_10)
    );
    
    // VULNERABILITY: This succeeds when it should fail
    assert!(result.is_ok(), "VULNERABILITY: Regressed timeout was signed!");
    
    // Expected behavior: Should return Error::NotSafeToTimeout
    // assert_eq!(result.unwrap_err(), Error::NotSafeToTimeout(11, 0, 10, 10));
}
```

This PoC demonstrates that a validator can successfully sign a timeout for round 11 with a QC from round 0, even when a TC at round 10 with `highest_hqc_round = 10` exists. The signed timeout violates the monotonicity invariant and could be used to form a regressed TC₁₁, enabling subsequent safety violations.

## Notes

The vulnerability exists because the timeout safety rule (`safe_to_timeout`) was not updated to match the voting safety rule (`safe_to_vote`) when the 2-chain protocol requires identical consistency guarantees for both operations. The fix ensures that both voting and timeout signing enforce the same QC-TC monotonicity invariant, preserving 2-chain consensus safety. [6](#0-5) 

The `one_chain_round` field (line 17) tracks the highest 1-chain round but is insufficient for validating QC-TC consistency when a TC is present.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L19-51)
```rust
    pub(crate) fn guarded_sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(timeout.epoch(), &safety_data)?;
        if !self.skip_sig_verify {
            timeout
                .verify(&self.epoch_state()?.verifier)
                .map_err(|e| Error::InvalidTimeout(e.to_string()))?;
        }
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }

        self.safe_to_timeout(timeout, timeout_cert, &safety_data)?;
        if timeout.round() < safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                timeout.round(),
                safety_data.last_voted_round,
            ));
        }
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
        }
        self.update_highest_timeout_round(timeout, &mut safety_data);
        self.persistent_storage.set_safety_data(safety_data)?;

        let signature = self.sign(&timeout.signing_format())?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L124-145)
```rust
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L147-166)
```rust
    /// Core safety voting rule for 2-chain protocol. Return success if 1 or 2 is true
    /// 1. block.round == block.qc.round + 1
    /// 2. block.round == tc.round + 1 && block.qc.round >= tc.highest_hqc.round
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L190-214)
```rust
    /// Produces a LedgerInfo that either commits a block based upon the 2-chain
    /// commit rule or an empty LedgerInfo for no commit. The 2-chain commit rule is: B0 and its
    /// prefixes can be committed if there exist certified block B1 that satisfy:
    /// 1) B0 <- B1 <--
    /// 2) round(B0) + 1 = round(B1)
    fn construct_ledger_info_2chain(
        &self,
        proposed_block: &Block,
        consensus_data_hash: HashValue,
    ) -> Result<LedgerInfo, Error> {
        let block1 = proposed_block.round();
        let block0 = proposed_block.quorum_cert().certified_block().round();

        // verify 2-chain rule
        let commit = next_round(block0)? == block1;

        // create a ledger info
        let commit_info = if commit {
            proposed_block.quorum_cert().certified_block().clone()
        } else {
            BlockInfo::empty()
        };

        Ok(LedgerInfo::new(commit_info, consensus_data_hash))
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L108-203)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq)]
pub struct TwoChainTimeoutCertificate {
    timeout: TwoChainTimeout,
    signatures_with_rounds: AggregateSignatureWithRounds,
}

impl Display for TwoChainTimeoutCertificate {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        write!(
            f,
            "TimeoutCertificate[epoch: {}, round: {}, hqc_round: {}]",
            self.timeout.epoch(),
            self.timeout.round(),
            self.timeout.hqc_round(),
        )
    }
}

impl TwoChainTimeoutCertificate {
    /// Creates new TimeoutCertificate
    pub fn new(timeout: TwoChainTimeout) -> Self {
        Self {
            timeout,
            signatures_with_rounds: AggregateSignatureWithRounds::empty(),
        }
    }

    /// Verifies the signatures for each validator, the signature is on the TimeoutSigningRepr where the
    /// hqc_round is in the signature map.
    /// We verify the following:
    /// 1. the highest quorum cert is valid
    /// 2. all signatures are properly formed (timeout.epoch, timeout.round, round)
    /// 3. timeout.hqc_round == max(signed round)
    pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
        let hqc_round = self.timeout.hqc_round();
        // Verify the highest timeout validity.
        let (timeout_result, sig_result) = rayon::join(
            || self.timeout.verify(validators),
            || {
                let timeout_messages: Vec<_> = self
                    .signatures_with_rounds
                    .get_voters_and_rounds(
                        &validators
                            .get_ordered_account_addresses_iter()
                            .collect_vec(),
                    )
                    .into_iter()
                    .map(|(_, round)| TimeoutSigningRepr {
                        epoch: self.timeout.epoch(),
                        round: self.timeout.round(),
                        hqc_round: round,
                    })
                    .collect();
                let timeout_messages_ref: Vec<_> = timeout_messages.iter().collect();
                validators.verify_aggregate_signatures(
                    &timeout_messages_ref,
                    self.signatures_with_rounds.sig(),
                )
            },
        );
        timeout_result?;
        sig_result?;
        let signed_hqc = self
            .signatures_with_rounds
            .rounds()
            .iter()
            .max()
            .ok_or_else(|| anyhow::anyhow!("Empty rounds"))?;
        ensure!(
            hqc_round == *signed_hqc,
            "Inconsistent hqc round, qc has round {}, highest signed round {}",
            hqc_round,
            *signed_hqc
        );
        Ok(())
    }

    /// The epoch of the timeout.
    pub fn epoch(&self) -> u64 {
        self.timeout.epoch()
    }

    /// The round of the timeout.
    pub fn round(&self) -> Round {
        self.timeout.round()
    }

    /// The highest hqc round of the 2f+1 participants
    pub fn highest_hqc_round(&self) -> Round {
        self.timeout.hqc_round()
    }

    pub fn signatures_with_rounds(&self) -> &AggregateSignatureWithRounds {
        &self.signatures_with_rounds
    }
}
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```
