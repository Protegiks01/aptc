# Audit Report

## Title
Timeout-Vote Equivocation: SafetyRules Allows Both Vote and Timeout Signatures for Same Round

## Summary
The SafetyRules implementation contains a logic error in `guarded_sign_timeout_with_qc()` that fails to prevent timeout signatures when a vote has already been signed for the same round. This allows a validator to equivocate by both voting for a proposal AND signing a timeout in the same consensus round, violating BFT consensus safety guarantees.

## Finding Description

The AptosBFT consensus protocol requires that validators behave consistently within each round: they should either vote for a specific proposal OR timeout if no valid proposal is seen, but never both. This mutual exclusivity is critical for consensus safety.

The vulnerability exists in the interaction between two SafetyRules functions:

**Vote Path:** [1](#0-0) 

When voting, `guarded_construct_and_sign_vote_two_chain()` updates `last_voted_round` to the proposal's round and signs the vote. [2](#0-1) 

**Timeout Path:** [3](#0-2) 

The critical flaw is at lines 37-45 of `guarded_sign_timeout_with_qc()`. The logic only errors if `timeout.round() < last_voted_round`, but allows the case where `timeout.round() == last_voted_round`:

- If `timeout.round() < last_voted_round`: Error (correct)
- If `timeout.round() > last_voted_round`: Updates `last_voted_round` (correct)  
- If `timeout.round() == last_voted_round`: **Neither errors nor updates** (BUG)

This gap allows a timeout signature to be generated for a round where a vote was already signed.

**Attack Scenario:**

1. Validator receives valid proposal for round 10
2. RoundManager calls `vote_block()` which invokes SafetyRules
3. SafetyRules updates `last_voted_round = 10` and signs vote
4. Vote is recorded in round state [4](#0-3) 
5. Local timeout fires for round 10
6. When `enable_round_timeout_msg = true`, RoundManager checks only `timeout_sent()`, not `vote_sent()` [5](#0-4) 
7. SafetyRules is called with `sign_timeout_with_qc(timeout_round_10)`
8. Check: `10 < 10`? No → No error
9. Check: `10 > 10`? No → No update
10. Timeout signature is generated for round 10

**Result:** The validator has both a vote signature for a specific block AND a timeout signature for the same round, enabling equivocation. [6](#0-5) 

The SafetyData structure tracks `last_voted_round` and `highest_timeout_round` separately, but the timeout signing logic fails to enforce mutual exclusion when these values are equal.

## Impact Explanation

**Severity: Critical** (Consensus Safety Violation)

This vulnerability breaks **Consensus Safety** (Critical Invariant #2): AptosBFT must prevent chain splits under < 1/3 Byzantine validators.

By allowing validators to equivocate (vote + timeout in same round), this weakens the consensus safety guarantees:

- Validators can vote for conflicting proposals by voting for one and timing out to participate in alternative leader rounds
- Potential for consensus splits if multiple validators exploit this
- Violates the fundamental BFT assumption that honest validators maintain consistent views within rounds
- Could enable Byzantine validators to amplify attacks beyond the theoretical 1/3 threshold

While the bug requires validator-level control to exploit, it represents a **logic error in the consensus safety layer** that could be triggered accidentally during network partitions or delays, or intentionally by compromised validators.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability can be triggered through:

1. **Accidental**: Network delays causing a proposal to arrive just before a timeout fires
2. **Malicious validator**: Intentional exploitation by compromised validator nodes
3. **Edge cases**: Race conditions during round transitions or network instability

The RoundManager's async event loop processes proposals and timeouts concurrently [7](#0-6) , making the timing window exploitable under normal network conditions.

## Recommendation

**Fix:** Add explicit mutual exclusion check in `guarded_sign_timeout_with_qc()`:

```rust
pub(crate) fn guarded_sign_timeout_with_qc(
    &mut self,
    timeout: &TwoChainTimeout,
    timeout_cert: Option<&TwoChainTimeoutCertificate>,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;
    let mut safety_data = self.persistent_storage.safety_data()?;
    self.verify_epoch(timeout.epoch(), &safety_data)?;
    // ... existing verification ...

    self.safe_to_timeout(timeout, timeout_cert, &safety_data)?;
    
    // FIX: Reject timeouts for rounds where we already voted
    if timeout.round() <= safety_data.last_voted_round {
        return Err(Error::IncorrectLastVotedRound(
            timeout.round(),
            safety_data.last_voted_round,
        ));
    }
    
    self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
    self.update_highest_timeout_round(timeout, &mut safety_data);
    self.persistent_storage.set_safety_data(safety_data)?;

    let signature = self.sign(&timeout.signing_format())?;
    Ok(signature)
}
```

Change line 37's condition from `<` to `<=` to enforce strict mutual exclusion.

**Alternative:** Add a check in RoundManager's timeout path to verify no vote was sent for that round when `enable_round_timeout_msg = true`.

## Proof of Concept

```rust
#[test]
fn test_vote_timeout_equivocation() {
    use aptos_consensus_types::{
        block::Block, 
        vote_proposal::VoteProposal,
        timeout_2chain::TwoChainTimeout,
    };
    
    // Setup SafetyRules with test epoch
    let mut safety_rules = test_utils::make_safety_rules();
    safety_rules.initialize(&test_epoch_proof()).unwrap();
    
    let round = 10;
    
    // Step 1: Vote for round 10
    let block = test_utils::make_block(round, test_qc());
    let vote_proposal = VoteProposal::new(...);
    let vote = safety_rules
        .construct_and_sign_vote_two_chain(&vote_proposal, None)
        .expect("Should sign vote");
    
    // Verify last_voted_round is now 10
    let state = safety_rules.consensus_state().unwrap();
    assert_eq!(state.last_voted_round(), round);
    
    // Step 2: Try to sign timeout for same round 10
    let timeout = TwoChainTimeout::new(
        state.epoch(),
        round,  // Same round as vote!
        test_qc(),
    );
    
    // BUG: This should fail but currently succeeds
    let timeout_sig = safety_rules
        .sign_timeout_with_qc(&timeout, None);
        
    // Vulnerability: Both vote and timeout signatures exist for round 10
    assert!(timeout_sig.is_ok(), "VULNERABILITY: Timeout signed after vote in same round!");
}
```

**Notes:**
- While the logical vulnerability exists in the code, exploitation requires validator-level access which may place it outside the scope of the bug bounty program's "unprivileged attacker" requirement
- The issue represents a consensus safety layer defect that should be patched regardless of external exploitability
- The fix is straightforward and should have minimal performance impact

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L19-51)
```rust
    pub(crate) fn guarded_sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(timeout.epoch(), &safety_data)?;
        if !self.skip_sig_verify {
            timeout
                .verify(&self.epoch_state()?.verifier)
                .map_err(|e| Error::InvalidTimeout(e.to_string()))?;
        }
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }

        self.safe_to_timeout(timeout, timeout_cert, &safety_data)?;
        if timeout.round() < safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                timeout.round(),
                safety_data.last_voted_round,
            ));
        }
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
        }
        self.update_highest_timeout_round(timeout, &mut safety_data);
        self.persistent_storage.set_safety_data(safety_data)?;

        let signature = self.sign(&timeout.signing_format())?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L53-95)
```rust
    pub(crate) fn guarded_construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        // Exit early if we cannot sign
        self.signer()?;

        let vote_data = self.verify_proposal(vote_proposal)?;
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
        let proposed_block = vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }

        // Two voting rules
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;

        Ok(vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** consensus/src/round_manager.rs (L1005-1021)
```rust
        if self.local_config.enable_round_timeout_msg {
            let timeout = if let Some(timeout) = self.round_state.timeout_sent() {
                timeout
            } else {
                let timeout = TwoChainTimeout::new(
                    self.epoch_state.epoch,
                    round,
                    self.block_store.highest_quorum_cert().as_ref().clone(),
                );
                let signature = self
                    .safety_rules
                    .lock()
                    .sign_timeout_with_qc(
                        &timeout,
                        self.block_store.highest_2chain_timeout_cert().as_deref(),
                    )
                    .context("[RoundManager] SafetyRules signs 2-chain timeout")?;
```

**File:** consensus/src/round_manager.rs (L1399-1400)
```rust
        let vote = self.create_vote(proposal).await?;
        self.round_state.record_vote(vote.clone());
```

**File:** consensus/src/round_manager.rs (L2110-2181)
```rust
                    if self.round_state.current_round() + 1 < get_round(&proposals[0]) {
                        proposals = vec![proposals.pop().unwrap()];
                    }
                    for proposal in proposals {
                        let result = match proposal {
                            VerifiedEvent::ProposalMsg(proposal_msg) => {
                                monitor!(
                                    "process_proposal",
                                    self.process_proposal_msg(*proposal_msg).await
                                )
                            }
                            VerifiedEvent::VerifiedProposalMsg(proposal_msg) => {
                                monitor!(
                                    "process_verified_proposal",
                                    self.process_delayed_proposal_msg(*proposal_msg).await
                                )
                            }
                            VerifiedEvent::OptProposalMsg(proposal_msg) => {
                                monitor!(
                                    "process_opt_proposal",
                                    self.process_opt_proposal_msg(*proposal_msg).await
                                )
                            }
                            unexpected_event => unreachable!("Unexpected event: {:?}", unexpected_event),
                        };
                        let round_state = self.round_state();
                        match result {
                            Ok(_) => trace!(RoundStateLogSchema::new(round_state)),
                            Err(e) => {
                                counters::ERROR_COUNT.inc();
                                warn!(kind = error_kind(&e), RoundStateLogSchema::new(round_state), "Error: {:#}", e);
                            }
                        }
                    }
                },
                Some((result, block, start_time)) = self.futures.next() => {
                    let elapsed = start_time.elapsed().as_secs_f64();
                    let id = block.id();
                    match result {
                        Ok(()) => {
                            counters::CONSENSUS_PROPOSAL_PAYLOAD_FETCH_DURATION.with_label_values(&["success"]).observe(elapsed);
                            if let Err(e) = monitor!("payload_fetch_proposal_process", self.check_backpressure_and_process_proposal(block)).await {
                                warn!("failed process proposal after payload fetch for block {}: {}", id, e);
                            }
                        },
                        Err(err) => {
                            counters::CONSENSUS_PROPOSAL_PAYLOAD_FETCH_DURATION.with_label_values(&["error"]).observe(elapsed);
                            warn!("unable to fetch payload for block {}: {}", id, err);
                        },
                    };
                },
                (peer_id, event) = event_rx.select_next_some() => {
                    let result = match event {
                        VerifiedEvent::VoteMsg(vote_msg) => {
                            monitor!("process_vote", self.process_vote_msg(*vote_msg).await)
                        }
                        VerifiedEvent::RoundTimeoutMsg(timeout_msg) => {
                            monitor!("process_round_timeout", self.process_round_timeout_msg(*timeout_msg).await)
                        }
                        VerifiedEvent::OrderVoteMsg(order_vote_msg) => {
                            monitor!("process_order_vote", self.process_order_vote_msg(*order_vote_msg).await)
                        }
                        VerifiedEvent::UnverifiedSyncInfo(sync_info) => {
                            monitor!(
                                "process_sync_info",
                                self.process_sync_info_msg(*sync_info, peer_id).await
                            )
                        }
                        VerifiedEvent::LocalTimeout(round) => monitor!(
                            "process_local_timeout",
                            self.process_local_timeout(round).await
                        ),
```

**File:** consensus/consensus-types/src/safety_data.rs (L10-21)
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```
