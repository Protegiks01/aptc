# Audit Report

## Title
Protocol ID Authorization Bypass Allowing Unauthorized RPC Message Processing

## Summary
The network layer fails to validate that incoming RPC messages use protocols that were negotiated during the connection handshake. This allows attackers to send RpcRequest messages with arbitrary protocol_id values, bypassing protocol-level access control and potentially injecting consensus messages they are not authorized to use.

## Finding Description
During connection establishment, two peers negotiate a set of mutually supported protocols via the handshake exchange. This negotiated set is stored in `ConnectionMetadata.application_protocols` and represents which protocols both peers agreed to use on this connection. [1](#0-0) 

However, when processing incoming RpcRequest messages, the Peer actor only validates whether a local handler exists for the requested protocol_id, without checking if that protocol was actually negotiated during the handshake. [2](#0-1) 

The validation logic uses `self.upstream_handlers.get(&request.protocol_id)` which contains ALL protocols the local node supports, not just the protocols negotiated with this specific peer. There is no check against `self.connection_metadata.application_protocols` which holds the negotiated protocol set. [3](#0-2) 

**Attack Scenario:**

1. Attacker connects to a validator node and completes Noise authentication
2. During protocol negotiation, attacker advertises minimal protocols (e.g., only HealthCheckerRpc) in their HandshakeMsg
3. Peers negotiate the intersection: only HealthCheckerRpc is agreed upon
4. After connection establishment, attacker sends RpcRequest with `protocol_id = ConsensusRpcBcs`
5. Validator's Peer actor checks `upstream_handlers` - finds a handler for ConsensusRpcBcs
6. Message is forwarded to InboundRpcs and then routed to consensus module [4](#0-3) 
7. Consensus processes the message without protocol-level authorization check [5](#0-4) 

The RpcRequest structure itself has no validation - the protocol_id field is simply deserialized from the network without verification. [6](#0-5) 

## Impact Explanation
This vulnerability qualifies as **HIGH to CRITICAL** severity:

**Protocol Violation (High Severity - Confirmed):**
- Breaks the protocol negotiation security model, which is designed as capability-based access control
- Allows peers to bypass protocol-specific access controls and rate limiting
- Violates the invariant that peers should only communicate using negotiated protocols

**Potential Consensus Impact (Critical Severity - Conditional):**
- Enables injection of consensus messages (ConsensusRpcBcs, ConsensusRpcCompressed, DAGMessage, CommitMessage, RandGenMessage) from unauthorized peers
- Could be exploited to send malicious block retrieval requests, DAG proposals, commit votes, or randomness generation messages
- If consensus message handlers lack sufficient signature verification or sender validation, this could lead to consensus safety violations or liveness issues
- Breaks Access Control invariant: unauthorized message routing to critical consensus components

The actual consensus impact depends on whether individual consensus message handlers perform adequate authentication beyond network-level checks.

## Likelihood Explanation
**High Likelihood:**

- **Trivial to Exploit**: Attacker only needs to:
  1. Establish a network connection (authenticated in Mutual mode, or unrestricted in MaybeMutual mode)
  2. Send a crafted RpcRequest with arbitrary protocol_id
  
- **No Special Privileges Required in MaybeMutual Mode**: On networks using MaybeMutual authentication (e.g., VFN networks), any peer can connect and exploit this

- **Exploitable by Malicious Validators**: In Mutual authentication mode (validator network), a compromised or malicious validator can advertise minimal protocols to evade monitoring while still sending consensus messages

- **No Rate Limiting or Detection**: The vulnerability leaves no obvious traces as the messages appear to come from authenticated peers

## Recommendation
Add protocol authorization validation in the message processing pipeline. The fix should validate that incoming messages only use protocols that were negotiated during the handshake:

```rust
// In network/framework/src/peer/mod.rs::handle_inbound_network_message
NetworkMessage::RpcRequest(request) => {
    // ADDED: Validate protocol was negotiated
    if !self.connection_metadata.application_protocols.contains(request.protocol_id) {
        warn!(
            NetworkSchema::new(&self.network_context)
                .connection_metadata(&self.connection_metadata),
            protocol_id = ?request.protocol_id,
            "Peer {} attempted to use non-negotiated protocol {:?}",
            self.remote_peer_id().short_str(),
            request.protocol_id
        );
        
        // Send error response
        let error_msg = NetworkMessage::Error(
            ErrorCode::NotSupported(NotSupportedType::RpcRequest(request.protocol_id))
        );
        let _ = self.write_reqs_tx.push((), error_msg);
        
        counters::direct_send_messages(&self.network_context, "protocol_not_negotiated").inc();
        return Ok(());
    }
    
    // Existing handler lookup logic...
    match self.upstream_handlers.get(&request.protocol_id) {
        // ... rest of the code
    }
}
```

Apply similar validation for DirectSendMsg messages.

## Proof of Concept
```rust
// Proof of Concept: Protocol ID Spoofing Attack
// This demonstrates that RpcRequest processing doesn't validate against negotiated protocols

use aptos_network::protocols::wire::messaging::v1::{NetworkMessage, RpcRequest};
use aptos_network::protocols::wire::handshake::v1::ProtocolId;

// Attacker's malicious test
#[test]
fn test_protocol_id_spoofing() {
    // 1. Attacker connects and negotiates only HealthCheckerRpc
    let negotiated_protocols = ProtocolIdSet::from_iter([ProtocolId::HealthCheckerRpc]);
    
    // 2. Attacker crafts RpcRequest with ConsensusRpcBcs (not negotiated)
    let malicious_request = RpcRequest {
        protocol_id: ProtocolId::ConsensusRpcBcs,  // NOT in negotiated set!
        request_id: 1,
        priority: 0,
        raw_request: vec![0u8; 100],  // Malicious consensus payload
    };
    
    let message = NetworkMessage::RpcRequest(malicious_request);
    
    // 3. Current implementation will process this message if local node has
    //    a ConsensusRpcBcs handler, without checking negotiated_protocols
    // 
    // Expected: Should be rejected with NotSupported error
    // Actual: Will be forwarded to consensus handler (VULNERABILITY)
}
```

**Demonstration Steps:**
1. Set up two validator nodes (Node A and Node B)
2. Modify Node A to advertise only `[HealthCheckerRpc]` in HandshakeMsg
3. After connection establishment, have Node A send RpcRequest with `protocol_id = ConsensusRpcBcs`
4. Observe that Node B processes the message and forwards it to consensus module
5. Confirm that no validation error occurs despite protocol not being negotiated

**Notes**
The vulnerability exists at the protocol negotiation enforcement layer. While consensus message handlers may have additional signature verification that could mitigate some attacks, the protocol-level access control is completely bypassed. The PeerMetadata struct provides a `supports_protocol()` method that SHOULD be used for validation but is never called during message processing. [3](#0-2)

### Citations

**File:** network/framework/src/transport/mod.rs (L98-108)
```rust
/// Metadata associated with an established and fully upgraded connection.
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** network/framework/src/peer/mod.rs (L505-530)
```rust
            NetworkMessage::RpcRequest(request) => {
                match self.upstream_handlers.get(&request.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(request.raw_request.len() as u64);
                    },
                    Some(handler) => {
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        if let Err(err) = self
                            .inbound_rpcs
                            .handle_inbound_request(handler, ReceivedMessage::new(message, sender))
                        {
                            warn!(
                                NetworkSchema::new(&self.network_context)
                                    .connection_metadata(&self.connection_metadata),
                                error = %err,
                                "{} Error handling inbound rpc request: {}",
                                self.network_context,
                                err
                            );
                        }
                    },
                }
```

**File:** network/framework/src/application/metadata.rs (L55-60)
```rust
    /// Returns true iff the peer has advertised support for the given protocol
    pub fn supports_protocol(&self, protocol_id: ProtocolId) -> bool {
        self.connection_metadata
            .application_protocols
            .contains(protocol_id)
    }
```

**File:** network/framework/src/protocols/rpc/mod.rs (L205-249)
```rust
    pub fn handle_inbound_request(
        &mut self,
        peer_notifs_tx: &aptos_channel::Sender<(PeerId, ProtocolId), ReceivedMessage>,
        mut request: ReceivedMessage,
    ) -> Result<(), RpcError> {
        let network_context = &self.network_context;

        // Drop new inbound requests if our completion queue is at capacity.
        if self.inbound_rpc_tasks.len() as u32 == self.max_concurrent_inbound_rpcs {
            // Increase counter of declined requests
            counters::rpc_messages(
                network_context,
                REQUEST_LABEL,
                INBOUND_LABEL,
                DECLINED_LABEL,
            )
            .inc();
            return Err(RpcError::TooManyPending(self.max_concurrent_inbound_rpcs));
        }

        let peer_id = request.sender.peer_id();
        let NetworkMessage::RpcRequest(rpc_request) = &request.message else {
            return Err(RpcError::InvalidRpcResponse);
        };
        let protocol_id = rpc_request.protocol_id;
        let request_id = rpc_request.request_id;
        let priority = rpc_request.priority;

        trace!(
            NetworkSchema::new(network_context).remote_peer(&self.remote_peer_id),
            "{} Received inbound rpc request from peer {} with request_id {} and protocol_id {}",
            network_context,
            self.remote_peer_id.short_str(),
            request_id,
            protocol_id,
        );
        self.update_inbound_rpc_request_metrics(protocol_id, rpc_request.raw_request.len() as u64);

        let timer =
            counters::inbound_rpc_handler_latency(network_context, protocol_id).start_timer();

        // Forward request to PeerManager for handling.
        let (response_tx, response_rx) = oneshot::channel();
        request.rpc_replier = Some(Arc::new(response_tx));
        if let Err(err) = peer_notifs_tx.push((peer_id, protocol_id), request) {
```

**File:** consensus/src/epoch_manager.rs (L1806-1894)
```rust
    fn process_rpc_request(
        &mut self,
        peer_id: Author,
        request: IncomingRpcRequest,
    ) -> anyhow::Result<()> {
        fail_point!("consensus::process::any", |_| {
            Err(anyhow::anyhow!("Injected error in process_rpc_request"))
        });

        match request.epoch() {
            Some(epoch) if epoch != self.epoch() => {
                monitor!(
                    "process_different_epoch_rpc_request",
                    self.process_different_epoch(epoch, peer_id)
                )?;
                return Ok(());
            },
            None => {
                // TODO: @bchocho @hariria can change after all nodes upgrade to release with enum BlockRetrievalRequest (not struct)
                ensure!(matches!(
                    request,
                    IncomingRpcRequest::DeprecatedBlockRetrieval(_)
                        | IncomingRpcRequest::BlockRetrieval(_)
                ));
            },
            _ => {},
        }

        match request {
            // TODO @bchocho @hariria can remove after all nodes upgrade to release with enum BlockRetrievalRequest (not struct)
            IncomingRpcRequest::DeprecatedBlockRetrieval(
                DeprecatedIncomingBlockRetrievalRequest {
                    req,
                    protocol,
                    response_sender,
                },
            ) => {
                if let Some(tx) = &self.block_retrieval_tx {
                    let incoming_block_retrieval_request = IncomingBlockRetrievalRequest {
                        req: BlockRetrievalRequest::V1(req),
                        protocol,
                        response_sender,
                    };
                    tx.push(peer_id, incoming_block_retrieval_request)
                } else {
                    error!("Round manager not started (in IncomingRpcRequest::DeprecatedBlockRetrieval)");
                    Ok(())
                }
            },
            IncomingRpcRequest::BatchRetrieval(request) => {
                if let Some(tx) = &self.batch_retrieval_tx {
                    tx.push(peer_id, request)
                } else {
                    Err(anyhow::anyhow!("Quorum store not started"))
                }
            },
            IncomingRpcRequest::DAGRequest(request) => {
                if let Some(tx) = &self.dag_rpc_tx {
                    tx.push(peer_id, request)
                } else {
                    Err(anyhow::anyhow!("DAG not bootstrapped"))
                }
            },
            IncomingRpcRequest::CommitRequest(request) => {
                self.execution_client.send_commit_msg(peer_id, request)
            },
            IncomingRpcRequest::RandGenRequest(request) => {
                if let Some(tx) = &self.rand_manager_msg_tx {
                    tx.push(peer_id, request)
                } else {
                    bail!("Rand manager not started");
                }
            },
            IncomingRpcRequest::BlockRetrieval(request) => {
                if let Some(tx) = &self.block_retrieval_tx {
                    tx.push(peer_id, request)
                } else {
                    error!("Round manager not started");
                    Ok(())
                }
            },
            IncomingRpcRequest::SecretShareRequest(request) => {
                let Some(tx) = &self.secret_share_manager_tx else {
                    bail!("Secret share manager not started");
                };
                tx.push(peer_id, request)
            },
        }
    }
```

**File:** network/framework/src/protocols/wire/messaging/v1/mod.rs (L116-128)
```rust
#[derive(Clone, Debug, PartialEq, Eq, Deserialize, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct RpcRequest {
    /// `protocol_id` is a variant of the ProtocolId enum.
    pub protocol_id: ProtocolId,
    /// RequestId for the RPC Request.
    pub request_id: RequestId,
    /// Request priority in the range 0..=255.
    pub priority: Priority,
    /// Request payload. This will be parsed by the application-level handler.
    #[serde(with = "serde_bytes")]
    pub raw_request: Vec<u8>,
}
```
