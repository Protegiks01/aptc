# Audit Report

## Title
Stack Overflow Vulnerability in Move Package Dependency Resolution via Unbounded Recursion

## Summary
The `transitive_dependencies()` function in Move package resolution contains an unbounded recursive call pattern that can be exploited via deep dependency chains to cause stack overflow, despite the presence of cycle detection during graph building.

## Finding Description

The vulnerability exists in `transitive_dependencies()` which uses a recursive closure to traverse package dependencies. [1](#0-0) 

The closure calls `transitive_dependencies()` recursively for each dependency, creating a call stack depth equal to the longest dependency chain. While cycle detection prevents infinite loops from circular dependencies [2](#0-1) , it does not prevent stack overflow from deep linear dependency chains (A → B → C → ... → Z).

The `seen` BTreeSet created at the start of each invocation is local to that call and does not prevent recursion across the dependency tree. [3](#0-2) 

This function is invoked during package compilation [4](#0-3) , making it exploitable when building packages with malicious dependency structures.

Notably, the codebase elsewhere explicitly avoids recursive algorithms for untrusted data. [5](#0-4) 

## Impact Explanation

This is a **High Severity** issue classified as an API crash. An attacker who can craft a malicious package dependency structure with sufficient depth (estimated 2,000-10,000+ packages based on typical stack sizes) can cause stack overflow during package resolution, resulting in build process crashes and denial of service for package compilation operations.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires:
1. Creating a deep chain of package dependencies (A depends on B, B depends on C, etc.)
2. Getting a victim to include the head of this chain as a dependency

In permissionless package ecosystems with Git-based dependencies, an attacker could:
- Create repositories with malicious dependency chains
- Convince developers to add them as dependencies through social engineering
- Inject them into transitive dependency trees of popular packages

## Recommendation

Replace the recursive implementation with an iterative approach using explicit stack management or topological sorting, similar to the pattern used in `struct_defs.rs`:

```rust
pub fn transitive_dependencies(&self, resolved_graph: &ResolvedGraph) -> BTreeSet<PackageName> {
    let mut result = BTreeSet::new();
    let mut stack = vec![self.resolution_graph_index];
    let mut visited = BTreeSet::new();
    
    while let Some(current) = stack.pop() {
        if visited.insert(current) {
            let package = &resolved_graph.package_table[&current];
            for dep in package.immediate_dependencies(resolved_graph) {
                if !visited.contains(&dep) {
                    stack.push(dep);
                    result.insert(dep);
                }
            }
        }
    }
    
    result
}
```

Additionally, consider adding a maximum dependency depth limit (e.g., 100 packages) with clear error messaging.

## Proof of Concept

```rust
// Create a test that generates a deep dependency chain
#[test]
fn test_deep_dependency_stack_overflow() {
    use std::fs;
    use std::path::PathBuf;
    
    const DEPTH: usize = 5000; // Adjust based on stack size
    
    // Create DEPTH packages where each depends on the next
    for i in 0..DEPTH {
        let pkg_name = format!("pkg_{}", i);
        let pkg_dir = PathBuf::from(format!("/tmp/deep_deps/{}", pkg_name));
        fs::create_dir_all(&pkg_dir).unwrap();
        
        let manifest = if i < DEPTH - 1 {
            format!(
                "[package]\nname = \"{}\"\nversion = \"0.1.0\"\n\n[dependencies]\npkg_{} = {{ local = \"../pkg_{}\" }}",
                pkg_name, i + 1, i + 1
            )
        } else {
            format!("[package]\nname = \"{}\"\nversion = \"0.1.0\"", pkg_name)
        };
        
        fs::write(pkg_dir.join("Move.toml"), manifest).unwrap();
    }
    
    // Try to build pkg_0 which has a 5000-deep dependency chain
    let root_pkg = PathBuf::from("/tmp/deep_deps/pkg_0");
    let manifest = parse_move_manifest_string(
        fs::read_to_string(root_pkg.join("Move.toml")).unwrap()
    ).unwrap();
    
    let build_config = BuildConfig::default();
    
    // This should cause stack overflow
    let result = ResolvingGraph::new(
        manifest,
        root_pkg,
        build_config,
        &mut std::io::stdout()
    );
    
    // If this doesn't panic, transitive_dependencies() will when called
    if let Ok(graph) = result {
        let resolved = graph.resolve().unwrap();
        let root_package = &resolved.package_table[&Symbol::from("pkg_0")];
        // This call will cause stack overflow
        let _ = root_package.transitive_dependencies(&resolved);
    }
}
```

## Notes

This vulnerability affects the Move package build tooling infrastructure, which is used off-chain during development and compilation. While it does not directly impact on-chain consensus, execution, or validator operations (as modules are published as bytecode, not source packages), it represents a denial-of-service vector against development environments, CI/CD systems, and package building infrastructure that could disrupt the Move development ecosystem.

### Citations

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L480-497)
```rust
    fn get_or_add_node(&mut self, package_name: PackageName) -> Result<GraphIndex> {
        if self.graph.contains_node(package_name) {
            // If we encounter a node that we've already added we should check for cycles
            if algo::is_cyclic_directed(&self.graph) {
                // get the first cycle. Exists because we found a cycle above.
                let mut cycle = algo::kosaraju_scc(&self.graph)[0]
                    .iter()
                    .map(|node| node.as_str().to_string())
                    .collect::<Vec<_>>();
                // Add offending node at end to complete the cycle for display
                cycle.push(package_name.as_str().to_string());
                bail!("Found cycle between packages: {}", cycle.join(" -> "));
            }
            Ok(package_name)
        } else {
            Ok(self.graph.add_node(package_name))
        }
    }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L786-815)
```rust
    pub fn transitive_dependencies(&self, resolved_graph: &ResolvedGraph) -> BTreeSet<PackageName> {
        let mut seen = BTreeSet::new();
        let resolve_package = |package_name: PackageName| {
            let mut package_deps = resolved_graph
                .package_table
                .get(&package_name)
                .unwrap()
                .transitive_dependencies(resolved_graph);
            package_deps.insert(package_name);
            package_deps
        };

        let immediate_deps = self.immediate_dependencies(resolved_graph);
        let transitive_deps: Vec<_> = immediate_deps
            .into_iter()
            .flat_map(resolve_package)
            .collect();

        transitive_deps
            .into_iter()
            .filter(|ident| {
                if !seen.contains(ident) {
                    seen.insert(*ident);
                    true
                } else {
                    false
                }
            })
            .collect()
    }
```

**File:** third_party/move/tools/move-package/src/compilation/build_plan.rs (L99-100)
```rust
        let transitive_dependencies = root_package
            .transitive_dependencies(&self.resolution_graph)
```

**File:** third_party/move/move-bytecode-verifier/src/struct_defs.rs (L36-37)
```rust
        // toposort is iterative while petgraph::algo::is_cyclic_directed is recursive. Prefer
        // the iterative solution here as this code may be dealing with untrusted data.
```
