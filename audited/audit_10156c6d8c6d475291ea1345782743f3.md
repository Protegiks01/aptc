# Audit Report

## Title
Cache Worker Denial of Service via Gap Detection on First Batch After Redis State Loss

## Summary
The indexer-grpc cache worker contains a critical flaw in its version update logic that causes the service to crash when processing the first batch of transactions after Redis is restarted or cleared, if the starting version is non-zero. This vulnerability results in persistent denial of service for the indexer API until manual intervention.

## Finding Description

The vulnerability exists in the Lua script used to update the cache's latest version in Redis. When the cache worker processes its first batch after the Init signal, it calls `update_cache_latest_version(transaction_count, current_version)` to record progress. [1](#0-0) 

This invokes a Lua script that performs gap detection to ensure sequential version updates: [2](#0-1) 

**The bug manifests in two scenarios:**

**Scenario 1: Redis initialized with latest_version = "0"**

When the file worker initializes the cache, it sets `latest_version` to "0": [3](#0-2) 

If the blockchain has progressed beyond genesis (e.g., current version is 1,000,000), and the cache worker needs to resume from this point:

1. Cache worker receives Init signal with starting_version = 1,000,000
2. Processes first batch of 100 transactions (versions 1,000,000 - 1,000,099)
3. Calls `update_cache_latest_version(100, 1,000,100)`
4. Lua script checks: `0 + 100 < 1,000,100` → **TRUE** (gap detected!)
5. Returns error code 2, causing the cache worker to crash [4](#0-3) 

**Scenario 2: Redis key missing (latest_version = nil)**

If the `latest_version` key doesn't exist in Redis (manual deletion, corruption):

1. First batch calls `update_cache_latest_version(100, 1,000,100)`
2. Lua script's else branch executes, setting `latest_version = ARGV[1] = 100` (WRONG! Should be 1,000,100)
3. Second batch calls `update_cache_latest_version(100, 1,000,200)`
4. Lua script checks: `100 + 100 < 1,000,200` → **TRUE** (gap detected!)
5. Returns error code 2, causing crash on second batch

The cache worker's retry loop cannot recover from this state: [5](#0-4) 

Each retry attempt will hit the same gap detection error, creating a crash loop.

## Impact Explanation

This vulnerability meets **High Severity** criteria under the Aptos bug bounty program for "API crashes". 

The indexer-grpc service provides critical API infrastructure for querying blockchain data. When this bug triggers:

- **Complete indexer API unavailability**: Users cannot query recent transactions
- **Persistent denial of service**: Automatic retry loops cannot resolve the issue
- **Manual intervention required**: Operators must manually fix Redis state or modify code
- **Service disruption duration**: Extended downtime until diagnosis and remediation

While this does not affect consensus or validator operations, it severely impacts the ecosystem's ability to serve blockchain data to applications, explorers, and users.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

This vulnerability triggers in realistic operational scenarios:

1. **Redis maintenance/restart**: Standard operational procedures that clear volatile memory
2. **Redis configuration without persistence**: Default Redis configurations may not persist data
3. **System crashes**: Power failures or crashes that lose Redis state
4. **Initial deployment**: First-time setup when file store exists but cache is fresh
5. **Recovery scenarios**: Any situation requiring cache reinitialization after blockchain progression

The vulnerability does not require malicious actors - it occurs naturally during normal operations when Redis state is lost or reset while the blockchain has progressed beyond genesis.

## Recommendation

**Fix the Lua script to handle first-batch initialization correctly:**

**Option 1: Initialize cache latest_version before streaming**
Before entering the streaming loop, explicitly set the cache latest_version to the starting version:

```rust
// In process_streaming_response(), after verify_fullnode_init_signal()
cache_operator.update_cache_latest_version(0, starting_version).await?;
```

**Option 2: Fix the Lua script's else branch and add special-case logic**
Correct the initialization bug and allow first-batch gaps:

```lua
const CACHE_SCRIPT_UPDATE_LATEST_VERSION: &str = r#"
    local latest_version = redis.call("GET", KEYS[1])
    local num_of_versions = tonumber(ARGV[1])
    local current_version = tonumber(ARGV[2])
    if latest_version then
        if tonumber(latest_version) + num_of_versions < current_version then
            return 2
        elseif tonumber(latest_version) + num_of_versions == current_version then
            redis.call("SET", KEYS[1], current_version)
            return 0
        else
            redis.call("SET", KEYS[1], math.max(current_version, tonumber(latest_version)))
            return 1
        end
    else
        -- Fix: Set to current_version, not num_of_versions
        redis.call("SET", KEYS[1], ARGV[2])
        return 0
    end
"#;
```

**Recommended: Option 1** - It's clearer, safer, and ensures the cache state matches the expected starting point before processing begins.

## Proof of Concept

```rust
#[cfg(test)]
mod test_first_batch_vulnerability {
    use super::*;
    use redis_test::{MockCmd, MockRedisConnection};
    
    #[tokio::test]
    async fn test_first_batch_gap_detection_bug() {
        // Simulate Redis with latest_version = "0" (from cache_setup_if_needed)
        let cmds = vec![
            // First call: update_cache_latest_version(100, 1000100)
            MockCmd::new(
                redis::Script::new(CACHE_SCRIPT_UPDATE_LATEST_VERSION)
                    .key(CACHE_KEY_LATEST_VERSION)
                    .arg(100)
                    .arg(1000100),
                Ok(2), // Returns 2 = gap detected!
            ),
        ];
        let mock_connection = MockRedisConnection::new(cmds);
        let mut cache_operator: CacheOperator<MockRedisConnection> =
            CacheOperator::new(mock_connection, StorageFormat::Base64UncompressedProto);
        
        // This simulates the first batch after Init when:
        // - File store is at version 1,000,000
        // - Redis latest_version was initialized to "0"
        // - Cache worker starts from version 1,000,000 and processes 100 transactions
        let result = cache_operator
            .update_cache_latest_version(100, 1_000_100)
            .await;
        
        // Bug: This returns an error due to gap detection!
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Version is not right"));
    }
    
    #[tokio::test]
    async fn test_nil_latest_version_wrong_initialization() {
        // Simulate Redis with no latest_version key (nil)
        let cmds = vec![
            // First call: Sets latest_version = 100 instead of 1000100 (BUG!)
            MockCmd::new(
                redis::Script::new(CACHE_SCRIPT_UPDATE_LATEST_VERSION)
                    .key(CACHE_KEY_LATEST_VERSION)
                    .arg(100)
                    .arg(1000100),
                Ok(0),
            ),
            // Second call will detect gap
            MockCmd::new(
                redis::Script::new(CACHE_SCRIPT_UPDATE_LATEST_VERSION)
                    .key(CACHE_KEY_LATEST_VERSION)
                    .arg(100)
                    .arg(1000200),
                Ok(2), // Gap detected: 100 + 100 < 1000200
            ),
        ];
        // ... test implementation showing second batch fails
    }
}
```

## Notes

**Important Clarifications:**

1. **Scope**: This vulnerability affects the indexer-grpc ecosystem service, not core consensus components. However, it causes significant API availability issues.

2. **Attack Vector**: While not directly exploitable by network attackers, this bug is triggered by operational events (Redis restarts, maintenance) and results in persistent service denial.

3. **Recovery**: The crash loop cannot self-recover. Operators must either:
   - Manually set Redis `latest_version` to match the file store version
   - Deploy a code fix
   - Clear file store metadata (losing indexing progress)

4. **Root Cause**: The Lua script assumes `latest_version` always exists and is close to the current processing version. It doesn't handle the first-batch-after-restart case where a large gap is legitimate.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L111-112)
```rust
        loop {
            let conn = self
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L444-447)
```rust
                    cache_operator
                        .update_cache_latest_version(transaction_count, current_version)
                        .await
                        .context("Failed to update the latest version in the cache")?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L39-57)
```rust
const CACHE_SCRIPT_UPDATE_LATEST_VERSION: &str = r#"
    local latest_version = redis.call("GET", KEYS[1])
    local num_of_versions = tonumber(ARGV[1])
    local current_version = tonumber(ARGV[2])
    if latest_version then
        if tonumber(latest_version) + num_of_versions < current_version then
            return 2
        elseif tonumber(latest_version) + num_of_versions == current_version then
            redis.call("SET", KEYS[1], current_version)
            return 0
        else
            redis.call("SET", KEYS[1], math.max(current_version, tonumber(latest_version)))
            return 1
        end
    else
        redis.call("SET", KEYS[1], ARGV[1])
        return 0
    end
"#;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L115-130)
```rust
    pub async fn cache_setup_if_needed(&mut self) -> anyhow::Result<bool> {
        let version_inserted: bool = redis::cmd("SET")
            .arg(CACHE_KEY_LATEST_VERSION)
            .arg(CACHE_DEFAULT_LATEST_VERSION_NUMBER)
            .arg("NX")
            .query_async(&mut self.conn)
            .await
            .context("Redis latest_version check failed.")?;
        if version_inserted {
            tracing::info!(
                initialized_latest_version = CACHE_DEFAULT_LATEST_VERSION_NUMBER,
                "Cache latest version is initialized."
            );
        }
        Ok(version_inserted)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L359-362)
```rust
            2 => {
                tracing::error!(version=version, "Redis latest version update failed. The version is beyond the next expected version.");
                Err(anyhow::anyhow!("Version is not right."))
            },
```
