# Audit Report

## Title
Integer Overflow in script_into_module() Creates Invalid Module Self-Reference

## Summary
The `script_into_module()` function in the Move binary format conversion module contains an integer overflow vulnerability when processing scripts with 65536 or more module handles. When casting `module_handles.len()` to `u16`, values of 65536+ wrap to 0, causing the module's self-reference to point to an incorrect module handle.

## Finding Description

The vulnerability exists in the `script_into_module()` function which converts a `CompiledScript` to a `CompiledModule`. At line 139, when a script has exactly 65536 module handles, an integer overflow occurs: [1](#0-0) 

The attack flow:

1. **Overflow Trigger**: When `script.module_handles.len()` equals 65536, casting to `u16` wraps to 0
   - `ModuleHandleIndex::new(65536 as u16)` → `ModuleHandleIndex(0)`

2. **Wrong Module Reference**: The returned `self_module_handle_idx` points to index 0 (first module handle) instead of the newly added module at index 65536

3. **Type System Definition**: `ModuleHandleIndex` wraps a `u16` with maximum value 65535: [2](#0-1) [3](#0-2) 

4. **No Table Size Validation**: The deserializer allows loading 65536+ elements without enforcing u16 limits on table size: [4](#0-3) 

5. **Index Validation Only**: The constant defines maximum index value but not table size: [5](#0-4) 

6. **Corrupted Module Creation**: The incorrect self-reference propagates to the function handle and module structure: [6](#0-5) [7](#0-6) 

7. **Bounds Check Passes**: The `BoundsChecker` validates index 0 is within bounds of 65537 elements, allowing the corrupted module through.

**Critical Impact**: The resulting module has identity corruption - it believes it belongs to a different module (the one at index 0), breaking Move's security model where module identity determines access control and type checking.

## Impact Explanation

**Severity Assessment: HIGH** (but NOT EXPLOITABLE in production)

While the vulnerability could theoretically cause:
- **Module Identity Corruption**: Module self-reference points to wrong module
- **Type System Bypass**: Type checks use incorrect module identity  
- **Access Control Failure**: Resource/capability checks against wrong module
- **Consensus Violation**: Deterministic execution breaks if modules are misidentified

**Critical Limitation**: The `script_into_module()` function is only called in testing infrastructure: [8](#0-7) 

**Out of Scope**: Per audit guidelines, test files and testing infrastructure are explicitly excluded. Without evidence of production code paths calling `script_into_module()` on untrusted input, this vulnerability cannot be exploited by unprivileged attackers in the live network.

## Likelihood Explanation

**Likelihood: LOW (Not Exploitable)**

Requirements for exploitation:
1. Attacker crafts CompiledScript with exactly 65536 module handles
2. Production code path must call `script_into_module()` on attacker's script
3. No such production path was identified in the codebase

The function appears to be legacy conversion utility used only in test runners, not transaction processing.

## Recommendation

Despite being out of scope for production exploitation, this should be fixed to prevent potential future issues:

```rust
let self_module_handle_idx = match script
    .module_handles
    .iter()
    .position(|handle| handle.address == dummy_addr_idx && handle.name == self_ident_idx)
{
    Some(idx) => ModuleHandleIndex::new(idx as u16),
    None => {
        // Validate table size before casting
        if script.module_handles.len() >= TableIndex::MAX as usize {
            panic!("module_handles table exceeds maximum size");
        }
        let idx = ModuleHandleIndex::new(script.module_handles.len() as u16);
        script.module_handles.push(ModuleHandle {
            address: dummy_addr_idx,
            name: self_ident_idx,
        });
        idx
    },
};
```

Apply similar fixes to lines 108, 125, and 153 with `identifiers`, `address_identifiers`, and `signatures` vectors.

## Proof of Concept

**Cannot provide exploitable PoC** - this function is not reachable through production attack vectors. A test demonstrating the overflow would require:

```rust
// This only works in test environment - NOT production exploit
#[test]
fn test_module_handle_overflow() {
    let mut script = create_minimal_script();
    // Add 65536 module handles
    for i in 0..65536 {
        script.module_handles.push(create_dummy_handle(i));
    }
    let module = script_into_module(script, "test");
    // self_module_handle_idx incorrectly points to index 0
    assert_ne!(module.self_module_handle_idx.0, 65536);
}
```

However, this is testing infrastructure code, not a production exploit path.

---

## Notes

While the integer overflow vulnerability is technically present and could cause module identity corruption, **I cannot validate this as an exploitable production vulnerability** because:

1. ❌ **Fails "Exploitable by unprivileged attacker" check** - No production code path identified
2. ❌ **Testing infrastructure is out of scope** per audit guidelines
3. ✅ Technical vulnerability exists (overflow is real)
4. ❌ Cannot demonstrate realistic attack scenario

The vulnerability should be fixed as defense-in-depth, but does not meet the criteria for a valid bug bounty submission under the current scope definition.

### Citations

**File:** third_party/move/move-binary-format/src/module_script_conversion.rs (L132-146)
```rust
    let self_module_handle_idx = match script
        .module_handles
        .iter()
        .position(|handle| handle.address == dummy_addr_idx && handle.name == self_ident_idx)
    {
        Some(idx) => ModuleHandleIndex::new(idx as u16),
        None => {
            let idx = ModuleHandleIndex::new(script.module_handles.len() as u16);
            script.module_handles.push(ModuleHandle {
                address: dummy_addr_idx,
                name: self_ident_idx,
            });
            idx
        },
    };
```

**File:** third_party/move/move-binary-format/src/module_script_conversion.rs (L160-169)
```rust
    let main_handle_idx = FunctionHandleIndex::new(script.function_handles.len() as u16);
    script.function_handles.push(FunctionHandle {
        module: self_module_handle_idx,
        name: self_ident_idx,
        parameters: script.parameters,
        return_: return_sig_idx,
        type_parameters: script.type_parameters,
        access_specifiers: None, // TODO: access specifiers for script functions
        attributes: vec![],
    });
```

**File:** third_party/move/move-binary-format/src/module_script_conversion.rs (L180-209)
```rust
    let module = CompiledModule {
        version: script.version,
        module_handles: script.module_handles,
        self_module_handle_idx,
        struct_handles: script.struct_handles,
        function_handles: script.function_handles,
        field_handles: vec![],
        friend_decls: vec![],

        struct_def_instantiations: vec![],
        function_instantiations: script.function_instantiations,
        field_instantiations: vec![],

        signatures: script.signatures,

        identifiers: script.identifiers,
        address_identifiers: script.address_identifiers,
        constant_pool: script.constant_pool,
        metadata: script.metadata,

        struct_defs: vec![],
        function_defs: vec![main_def],

        struct_variant_handles: vec![],
        struct_variant_instantiations: vec![],
        variant_field_handles: vec![],
        variant_field_instantiations: vec![],
    };
    BoundsChecker::verify_module(&module).expect("invalid bounds in module");
    module
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L55-56)
```rust
/// Generic index into one of the tables in the binary format.
pub type TableIndex = u16;
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L101-105)
```rust
define_index! {
    name: ModuleHandleIndex,
    kind: ModuleHandle,
    doc: "Index into the `ModuleHandle` table.",
}
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L573-588)
```rust
impl Table {
    /// Generic function to deserialize a table into a vector of given type.
    fn load<T>(
        &self,
        binary: &VersionedBinary,
        result: &mut Vec<T>,
        deserializer: impl Fn(&mut VersionedCursor) -> BinaryLoaderResult<T>,
    ) -> BinaryLoaderResult<()> {
        let start = self.offset as usize;
        let end = start + self.count as usize;
        let mut cursor = binary.new_cursor(start, end);
        while cursor.position() < self.count as u64 {
            result.push(deserializer(&mut cursor)?)
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L43-47)
```rust
pub const TABLE_INDEX_MAX: u64 = 65535;
pub const SIGNATURE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const ADDRESS_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const IDENTIFIER_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const MODULE_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
```

**File:** third_party/move/testing-infra/transactional-test-runner/src/transactional_ops.rs (L310-369)
```rust
                    .map(|s| adapter.compiled_state().resolve_address(&s))
                    .collect();
                let exec_group = exec_group.unwrap_or(0);

                let target_compiled_module = published_modules
                    .iter()
                    .find(|m| m.self_id() == module_id)
                    .ok_or_else(|| {
                        anyhow::anyhow!("Module {} not found for function call", module_id)
                    })?;

                let (target_func_def, target_func_handle, func_idx) = target_compiled_module
                    .function_defs
                    .iter()
                    .enumerate()
                    .find_map(|(idx, f_def)| {
                        let f_handle =
                            &target_compiled_module.function_handles[f_def.function.0 as usize];
                        if target_compiled_module.identifier_at(f_handle.name).as_str()
                            == function_name.as_str()
                        {
                            Some((f_def, f_handle, FunctionDefinitionIndex::new(idx as u16)))
                        } else {
                            None
                        }
                    })
                    .ok_or_else(|| {
                        anyhow::anyhow!(
                            "Function {} not found in module {}",
                            function_name,
                            module_id
                        )
                    })?;

                let return_sig = target_compiled_module.signature_at(target_func_handle.return_);
                // Transactional test runner does works mainly with public functions, so we need to wrap them in a script
                // to make it runnable in the VM flow used by the fuzzer.
                let needs_wrapper = !return_sig.0.is_empty() || !target_func_def.is_entry;

                if needs_wrapper {
                    if std::env::var("DEBUG").is_ok() {
                        println!(
                            "[transactional_ops] Wrapper needed for {}::{}",
                            module_id, function_name
                        );
                    }
                    let wrapper_script_source = generate_script_wrapper_for_non_entry_function(
                        &module_id,
                        target_compiled_module,
                        target_func_def,
                        target_func_handle,
                        &resolved_type_args,
                    )?;
                    // store the wrapper script source in a temp file
                    let mut temp_file = tempfile::NamedTempFile::new()?;
                    temp_file.write_all(wrapper_script_source.as_bytes())?;

                    let (compiled_wrapper_script, _warnings_opt) =
                        adapter.compile_script(SyntaxChoice::Source, Some(temp_file), 0, 0)?;

```
