# Audit Report

## Title
Mixed Transaction and Output Proofs Bypass Verification in State Sync Client

## Summary
The `get_transactions_or_outputs_with_proof()` function and its response processing logic contain a critical flaw where malicious peers can send responses containing BOTH transaction proofs and output proofs simultaneously. The client-side conversion logic silently accepts only one type and completely ignores the other without verification, allowing unverified malicious data to be smuggled into responses and potentially causing state inconsistencies.

## Finding Description

The vulnerability exists in how `TransactionOrOutputListWithProofV2` responses are converted to `ResponsePayload` in the data client. The type is defined as a tuple of two optional values: [1](#0-0) 

When converting this type to `ResponsePayload`, the implementation uses a flawed if-else chain: [2](#0-1) 

And similarly for the non-ledger-info variant: [3](#0-2) 

The same flawed pattern appears in subscription handling: [4](#0-3) 

**The Critical Flaw**: When both `transaction_list` and `output_list` are `Some()`, the code takes the first branch and returns only the transaction list. The output list is **completely ignored** without any verification that it's `None`, and without any validation or warning.

**Attack Scenario**:
1. A malicious storage service peer receives a `GetTransactionsOrOutputsWithProof` request
2. The peer crafts a `DataResponse::TransactionsOrOutputsWithProof` with BOTH fields populated:
   - `transaction_list_with_proof`: `Some(valid_transactions_with_correct_proofs)`
   - `output_list_with_proof`: `Some(malicious_outputs_with_invalid_proofs)`
3. The response is serialized and sent to the requesting client
4. The client's `TryFrom` implementation processes the response, takes the first branch, and returns only the transaction list
5. The malicious output list is **silently dropped** without verification
6. No error is raised, no warning is logged, and the protocol invariant (exactly one type present) is violated

This breaks the protocol's fundamental assumption that a response contains EITHER transactions OR outputs, never both.

## Impact Explanation

**Severity: Medium to High**

This vulnerability has several concerning implications:

1. **Verification Bypass**: Malicious peers can smuggle unverified proof data into responses. While the immediate data isn't used, the lack of validation means invalid proofs bypass all checks.

2. **Resource Exhaustion**: A malicious peer can send responses with both fields populated, each containing maximum-sized data. The client deserializes and processes both fields, but only uses one, wasting CPU and memory resources.

3. **State Inconsistency Risk**: If any code path accesses the raw `TransactionOrOutputListWithProofV2` tuple before conversion (or uses a different conversion path), it might process different parts of the mixed response, leading to inconsistent state between components.

4. **Protocol Invariant Violation**: The protocol design assumes mutual exclusivity (transaction proofs XOR output proofs), but this invariant is never enforced. This violates the "State Consistency" critical invariant.

5. **Silent Failure**: The most dangerous aspect is the complete lack of error handling or logging when both fields are present, making attacks difficult to detect.

Under the Aptos bug bounty categories, this qualifies as **Medium Severity** (state inconsistencies requiring intervention) with potential for **High Severity** if exploitable for node slowdowns through resource exhaustion.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is highly feasible:

1. **Low Complexity**: A malicious peer simply needs to populate both optional fields in a response struct - trivial to implement
2. **No Special Access Required**: Any peer serving state sync data can perform this attack
3. **Undetectable**: No validation or logging exists to detect this condition
4. **Broad Attack Surface**: Affects multiple endpoints (GetTransactionsOrOutputsWithProof, GetNewTransactionsOrOutputsWithProof, subscriptions)

The likelihood is reduced only by the fact that honest implementations don't populate both fields, but the lack of defensive validation makes this a realistic attack vector for malicious actors.

## Recommendation

**Immediate Fix**: Add explicit validation to ensure mutual exclusivity:

```rust
impl TryFrom<(TransactionOrOutputListWithProofV2, LedgerInfoWithSignatures)> for ResponsePayload {
    type Error = Error;

    fn try_from(
        inner: (TransactionOrOutputListWithProofV2, LedgerInfoWithSignatures),
    ) -> error::Result<Self, Error> {
        let ((transaction_list, output_list), ledger_info) = inner;
        
        // Enforce mutual exclusivity
        match (transaction_list, output_list) {
            (Some(transaction_list), None) => {
                Ok(Self::NewTransactionsWithProof((transaction_list, ledger_info)))
            }
            (None, Some(output_list)) => {
                Ok(Self::NewTransactionOutputsWithProof((output_list, ledger_info)))
            }
            (None, None) => {
                Err(Error::InvalidResponse(
                    "Invalid response! No transaction or output list was returned!".into(),
                ))
            }
            (Some(_), Some(_)) => {
                Err(Error::InvalidResponse(
                    "Invalid response! Both transaction and output lists were returned! \
                     Protocol violation: exactly one must be present.".into(),
                ))
            }
        }
    }
}
```

Apply the same pattern to:
- The other `TryFrom` implementation at lines 386-400
- The subscription handler at lines 482-498

**Additional Safeguards**:
1. Add validation in the server-side handler to ensure only one field is populated before sending
2. Add metrics to track occurrences of this violation for monitoring
3. Consider making the type an enum instead of a tuple to enforce mutual exclusivity at the type level

## Proof of Concept

```rust
#[cfg(test)]
mod test_mixed_proof_vulnerability {
    use super::*;
    use aptos_storage_service_types::responses::{
        TransactionOrOutputListWithProofV2, DataResponse, StorageServiceResponse
    };
    use aptos_types::{
        ledger_info::LedgerInfoWithSignatures,
        transaction::{TransactionListWithProofV2, TransactionOutputListWithProofV2},
    };

    #[test]
    fn test_mixed_proofs_bypass_verification() {
        // Create valid transaction proofs
        let valid_transaction_list = TransactionListWithProofV2::new_empty();
        
        // Create potentially malicious output proofs (could be invalid/unverified)
        let malicious_output_list = TransactionOutputListWithProofV2::new_empty();
        
        // Create a mixed response with BOTH types present (protocol violation)
        let mixed_response: TransactionOrOutputListWithProofV2 = (
            Some(valid_transaction_list.clone()),
            Some(malicious_output_list.clone()), // This should cause an error but doesn't!
        );
        
        let ledger_info = LedgerInfoWithSignatures::new(
            /* create test ledger info */
        );
        
        // Attempt conversion - this should FAIL but actually SUCCEEDS
        let result = ResponsePayload::try_from((mixed_response, ledger_info));
        
        // Current behavior: succeeds and silently drops the output list
        assert!(result.is_ok());
        
        // Expected behavior: should return an error for protocol violation
        // assert!(result.is_err());
        // assert!(result.unwrap_err().to_string().contains("Both transaction and output"));
        
        // The malicious output list was completely ignored without verification!
        match result.unwrap() {
            ResponsePayload::NewTransactionsWithProof((txns, _)) => {
                // Only transaction list was returned
                assert_eq!(txns, valid_transaction_list);
                // The malicious output list was silently dropped - VULNERABILITY!
            }
            _ => panic!("Unexpected response type"),
        }
    }
}
```

This test demonstrates that responses with both fields populated are silently accepted, violating the protocol's mutual exclusivity invariant and allowing unverified data to bypass validation checks.

### Citations

**File:** state-sync/storage-service/types/src/responses.rs (L136-139)
```rust
pub type TransactionOrOutputListWithProofV2 = (
    Option<TransactionListWithProofV2>,
    Option<TransactionOutputListWithProofV2>,
);
```

**File:** state-sync/aptos-data-client/src/interface.rs (L343-365)
```rust
impl TryFrom<(TransactionOrOutputListWithProofV2, LedgerInfoWithSignatures)> for ResponsePayload {
    type Error = Error;

    fn try_from(
        inner: (TransactionOrOutputListWithProofV2, LedgerInfoWithSignatures),
    ) -> error::Result<Self, Error> {
        let ((transaction_list, output_list), ledger_info) = inner;
        if let Some(transaction_list) = transaction_list {
            Ok(Self::NewTransactionsWithProof((
                transaction_list,
                ledger_info,
            )))
        } else if let Some(output_list) = output_list {
            Ok(Self::NewTransactionOutputsWithProof((
                output_list,
                ledger_info,
            )))
        } else {
            Err(Error::InvalidResponse(
                "Invalid response! No transaction or output list was returned!".into(),
            ))
        }
    }
```

**File:** state-sync/aptos-data-client/src/interface.rs (L386-400)
```rust
impl TryFrom<TransactionOrOutputListWithProofV2> for ResponsePayload {
    type Error = Error;

    fn try_from(inner: TransactionOrOutputListWithProofV2) -> error::Result<Self, Error> {
        let (transaction_list, output_list) = inner;
        if let Some(transaction_list) = transaction_list {
            Ok(Self::TransactionsWithProof(transaction_list))
        } else if let Some(output_list) = output_list {
            Ok(Self::TransactionOutputsWithProof(output_list))
        } else {
            Err(Error::InvalidResponse(
                "Invalid response! No transaction or output list was returned!".into(),
            ))
        }
    }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L482-498)
```rust
            DataResponse::NewTransactionsOrOutputsWithProof((
                (transaction_list, transaction_output_list),
                target_ledger_info,
            )) => {
                if let Some(transaction_list) = transaction_list {
                    (transaction_list.get_num_transactions(), target_ledger_info)
                } else if let Some(transaction_output_list) = transaction_output_list {
                    (
                        transaction_output_list.get_num_outputs(),
                        target_ledger_info,
                    )
                } else {
                    return Err(Error::UnexpectedErrorEncountered(format!(
                        "New transactions or outputs response is missing data: {:?}",
                        data_response
                    )));
                }
```
