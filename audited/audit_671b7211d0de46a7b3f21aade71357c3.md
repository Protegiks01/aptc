# Audit Report

## Title
TypeTag Depth Validation Gap Between Bytecode Verifier and BCS Serialization Causes Transaction Failures

## Summary
A critical mismatch exists between the Move bytecode verifier's type depth limit (20) and the BCS serialization depth limit (8), allowing modules to be published with deeply nested generic types that cannot be serialized for events or storage keys, causing deterministic transaction failures and potential denial-of-service conditions.

## Finding Description

The Aptos codebase has a validation gap between three different depth enforcement mechanisms:

1. **Property Testing**: TypeTag proptest generation uses depth limit of 8 [1](#0-0) 

2. **BCS Serialization**: MAX_TYPE_TAG_NESTING enforces depth limit of 8 during TypeTag serialization [2](#0-1) 

3. **Bytecode Verifier**: Production configuration allows type depth up to 20 [3](#0-2) 

4. **VM Type-to-TypeTag Converter**: Uses pseudo-gas metering allowing depths up to ~49 based on cost limits (type_max_cost: 5000, type_base_cost: 100) [4](#0-3) 

**Attack Path:**

1. Attacker publishes a Move module containing a struct with deeply nested generic type parameters (depth 9-20), which passes bytecode verification.

2. The module includes functions that emit events or store resources using these deeply nested types.

3. When executed, the VM's type-to-TypeTag converter successfully creates TypeTag representations with depth > 8.

4. **Event Emission Failure**: When `ContractEvent::new_v2()` is called, it attempts to calculate the event size by serializing the TypeTag: [5](#0-4) 

5. **Storage Key Creation Failure**: When creating resource storage keys, `AccessPath::resource_path_vec()` serializes the StructTag: [6](#0-5) 

6. Both serialization attempts fail with "type tag nesting exceeded during serialization" when depth > 8, causing the transaction to abort.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program: "State inconsistencies requiring intervention."

**Concrete Impact:**

1. **Denial of Service**: Any function attempting to emit events or store resources with deeply nested types (depth 9-20) will deterministically fail, even though the module passed verification. This enables:
   - Making protocol functions permanently unusable
   - Locking funds in contracts that require event emission for withdrawals
   - Breaking composability where one contract calls another with deeply nested types

2. **Broken Invariant**: Violates the fundamental assumption that "modules accepted by the bytecode verifier should be executable." This breaks **Resource Limits** and **Deterministic Execution** invariants.

3. **Validation Gap**: Types tested in proptests (depth ≤ 8) don't cover types allowed by production verifier (depth ≤ 20), creating untested code paths that fail in production.

4. **Storage Failures**: Resources with deeply nested generic types cannot be stored using `move_to` or accessed via `borrow_global`, despite passing all static verification checks.

## Likelihood Explanation

**High Likelihood** due to:

1. **Easy Exploitation**: Any user can publish modules with deeply nested generic types using standard Move compilation tools.

2. **No Special Privileges Required**: Requires only ability to publish modules, which is available to any account with sufficient gas.

3. **Deterministic Failure**: The vulnerability triggers consistently whenever deeply nested types are used in events or storage operations.

4. **Discoverable**: Developers using legitimate deeply nested generics (e.g., `Option<Result<Option<T>>>` patterns) will encounter this unexpectedly.

**Exploitation Complexity**: Low - requires only writing Move code with nested generics at depth 9+.

## Recommendation

**Immediate Fix**: Align the bytecode verifier's `max_type_depth` with `MAX_TYPE_TAG_NESTING` to prevent publishing modules that cannot execute:

```rust
// In aptos-move/aptos-vm-environment/src/prod_configs.rs
max_type_depth: if enable_function_values {
    Some(8)  // Changed from 20 to match MAX_TYPE_TAG_NESTING
} else {
    None
},
```

**Alternative Solution**: If deeper nesting is required, increase `MAX_TYPE_TAG_NESTING` to match verifier limits, but this requires careful analysis of serialization stack depth and performance implications:

```rust
// In third_party/move/move-core/types/src/safe_serialize.rs
pub(crate) const MAX_TYPE_TAG_NESTING: u8 = 20;  // Increased from 8
```

**Long-term Fix**: Implement consistent depth validation across all layers:
1. Update proptest generators to test full depth range allowed by verifier
2. Add validation in `ty_tag_converter` to enforce MAX_TYPE_TAG_NESTING before TypeTag construction
3. Document the relationship between verifier limits and serialization limits

## Proof of Concept

```move
// File: sources/deep_nest_exploit.move
module deployer::deep_nest_exploit {
    use std::event;
    
    // Struct with depth 9 - exceeds serialization limit but passes verifier
    struct Level9<T> has key, drop, copy { v: T }
    struct Level8<T> has key, drop, copy { v: Level9<T> }
    struct Level7<T> has key, drop, copy { v: Level8<T> }
    struct Level6<T> has key, drop, copy { v: Level7<T> }
    struct Level5<T> has key, drop, copy { v: Level6<T> }
    struct Level4<T> has key, drop, copy { v: Level5<T> }
    struct Level3<T> has key, drop, copy { v: Level4<T> }
    struct Level2<T> has key, drop, copy { v: Level3<T> }
    struct Level1<T> has key, drop, copy { v: Level2<T> }
    struct DeepEvent has key, drop, copy { v: Level1<u8> }
    
    // This function will pass compilation but fail at runtime
    public entry fun emit_deep_event() {
        // Attempt to emit event with depth 9
        // This will fail with ECANNOT_CREATE_EVENT when 
        // ContractEvent::new_v2() tries to serialize the TypeTag
        event::emit(DeepEvent { 
            v: Level1 { v: Level2 { v: Level3 { v: Level4 { 
                v: Level5 { v: Level6 { v: Level7 { v: Level8 { 
                    v: Level9 { v: 0 }
                }}}}
            }}}}
        });
    }
    
    // This function will also fail when trying to store resource
    public entry fun store_deep_resource(account: &signer) {
        // Attempt to store resource with depth 9
        // This will fail when AccessPath::resource_path_vec()
        // tries to serialize the StructTag
        move_to(account, DeepEvent { 
            v: Level1 { v: Level2 { v: Level3 { v: Level4 { 
                v: Level5 { v: Level6 { v: Level7 { v: Level8 { 
                    v: Level9 { v: 0 }
                }}}}
            }}}}
        });
    }
}
```

**Expected Behavior**: Module compiles and publishes successfully (passes bytecode verifier with depth limit 20).

**Actual Behavior**: When calling `emit_deep_event()` or `store_deep_resource()`, transaction aborts with error code 1 (ECANNOT_CREATE_EVENT) or serialization error, despite module being validated and published.

**Notes**

This vulnerability represents a fundamental inconsistency in the Move type system's depth validation across different layers. The gap between testing limits (8), serialization limits (8), and verification limits (20) creates an exploitable surface where valid modules cannot execute core operations like event emission and resource storage. This affects the **Deterministic Execution** invariant since validators accept modules that cannot deterministically complete basic operations, potentially leading to consensus issues if error handling varies across implementations.

### Citations

**File:** third_party/move/move-core/types/src/proptest_types.rs (L29-31)
```rust
        leaf.prop_recursive(
            8,  // levels deep
            16, // max size
```

**File:** third_party/move/move-core/types/src/safe_serialize.rs (L11-11)
```rust
pub(crate) const MAX_TYPE_TAG_NESTING: u8 = 8;
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L188-192)
```rust
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L247-249)
```rust
        type_max_cost: 5000,
        type_base_cost: 100,
        type_byte_cost: 1,
```

**File:** types/src/contract_event.rs (L268-270)
```rust
    pub fn size(&self) -> anyhow::Result<usize> {
        let size = bcs::serialized_size(&self.type_tag)? + self.event_data.len();
        Ok(size)
```

**File:** types/src/access_path.rs (L111-114)
```rust
    pub fn resource_path_vec(tag: StructTag) -> Result<Vec<u8>> {
        let r = bcs::to_bytes(&Path::Resource(tag))?;
        Ok(r)
    }
```
