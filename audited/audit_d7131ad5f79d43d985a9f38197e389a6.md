# Audit Report

## Title
Missing URL Scheme Validation in Node Checker Client Enables SSRF Attacks

## Summary
The `fn-check-client` tool in the node-checker ecosystem component fails to validate URL schemes when processing Public Full Node (PFN) addresses from input files. This allows attackers to inject URLs with dangerous protocols (e.g., `file://`, `ftp://`, `gopher://`) that are subsequently forwarded to the Node Health Checker (NHC) service, creating a Server-Side Request Forgery (SSRF) vulnerability.

## Finding Description

The vulnerability exists in the Public Full Node address processing path. When the tool reads PFN information from a JSON input file, it accepts user-provided URLs without validating their schemes. [1](#0-0) 

The URL is parsed directly from the input without any scheme validation. The parsed URL is then passed to the Node Health Checker service as a query parameter: [2](#0-1) 

An attacker can provide a malicious JSON input file with entries containing dangerous URL schemes:

```json
{
  "account_address": "0x1",
  "url": "file:///etc/passwd",
  "api_port": 8080,
  "noise_port": 6180,
  "metrics_port": 9101,
  "public_key": "0x..."
}
```

This malicious URL propagates through the system:
1. Parsed without validation in `get_pfns.rs`
2. Stored in `NodeInfo` struct
3. Sent as query parameter to NHC service
4. NHC may attempt to fetch the URL, causing SSRF

In contrast, the Validator Full Node (VFN) path is safe because it hardcodes the HTTP scheme: [3](#0-2) 

## Impact Explanation

This vulnerability is rated as **Medium Severity** because:

1. **SSRF Attack Surface**: An attacker can force the NHC service to make requests to arbitrary URLs, potentially:
   - Reading local files via `file://` protocol
   - Scanning internal network services
   - Accessing cloud metadata services
   - Bypassing firewall restrictions

2. **Scope Limitation**: The impact is limited to the operational monitoring infrastructure (node-checker ecosystem tool), not core blockchain consensus, execution, or state management components.

3. **Access Requirements**: The attacker needs the ability to provide input files to the `fn-check-client` tool, limiting the attack surface to operational infrastructure operators or compromised systems running monitoring tools.

This aligns with the **Medium Severity** category (up to $10,000) for "State inconsistencies requiring intervention" or operational security issues affecting infrastructure but not core protocol integrity.

## Likelihood Explanation

The likelihood of exploitation is **Medium** because:

1. **Required Access**: The attacker must be able to provide input files to the fn-check-client tool, which is typically run by node operators or monitoring infrastructure
2. **Ease of Exploitation**: Once access is obtained, exploitation is trivialâ€”simply craft a malicious JSON file
3. **Detection**: The attack may go unnoticed if NHC logs are not monitored for suspicious URL patterns
4. **Real-world Scenario**: Compromised operational systems or malicious insiders could exploit this

## Recommendation

Implement strict URL scheme validation to allow only `http://` and `https://` protocols. Add validation in the `TryInto<NodeInfo>` implementation:

```rust
impl TryInto<NodeInfo> for Entry {
    type Error = anyhow::Error;

    fn try_into(self) -> Result<NodeInfo> {
        let url = Url::parse(&self.url).context("Failed to parse URL")?;
        
        // Validate URL scheme
        match url.scheme() {
            "http" | "https" => {},
            scheme => {
                return Err(anyhow::anyhow!(
                    "Invalid URL scheme '{}'. Only http:// and https:// are allowed",
                    scheme
                ));
            }
        }
        
        Ok(NodeInfo {
            node_url: url,
            api_port: Some(self.api_port),
            noise_port: self.noise_port,
            public_key: Some(
                x25519::PublicKey::from_encoded_string(&self.public_key)
                    .context("Failed to parse public key")?,
            ),
        })
    }
}
```

## Proof of Concept

**Step 1**: Create a malicious input file `malicious_pfns.json`:

```json
[
  {
    "account_address": "0x0000000000000000000000000000000000000000000000000000000000000001",
    "url": "file:///etc/passwd",
    "api_port": 8080,
    "noise_port": 6180,
    "metrics_port": 9101,
    "public_key": "0x0000000000000000000000000000000000000000000000000000000000000000"
  }
]
```

**Step 2**: Run the fn-check-client tool:

```bash
cargo run --bin fn-check-client -- \
  check-public-full-nodes \
  --input-file malicious_pfns.json \
  --nhc-address http://nhc-service:20121 \
  --nhc-baseline-config-name default
```

**Step 3**: Observe that the tool sends a request to NHC with `node_url=file:///etc/passwd` as a query parameter, which NHC may attempt to fetch, resulting in SSRF.

## Notes

- The vulnerability only affects the Public Full Node checking path (`CheckPublicFullNodes` command), not the Validator Full Node path which hardcodes HTTP schemes
- The impact is limited to operational/monitoring infrastructure rather than core blockchain security
- Defense-in-depth should also be applied at the NHC service level to validate incoming URLs
- Consider implementing similar validation for the `nhc_address` parameter in `NodeHealthCheckerArgs` to prevent attacks on the NHC service URL itself

### Citations

**File:** ecosystem/node-checker/fn-check-client/src/get_pfns.rs (L94-107)
```rust
impl TryInto<NodeInfo> for Entry {
    type Error = anyhow::Error;

    fn try_into(self) -> Result<NodeInfo> {
        Ok(NodeInfo {
            node_url: Url::parse(&self.url).context("Failed to parse URL")?,
            api_port: Some(self.api_port),
            noise_port: self.noise_port,
            public_key: Some(
                x25519::PublicKey::from_encoded_string(&self.public_key)
                    .context("Failed to parse public key")?,
            ),
        })
    }
```

**File:** ecosystem/node-checker/fn-check-client/src/check.rs (L198-210)
```rust
        // Build up query params.
        let mut params = HashMap::new();
        params.insert("node_url", node_url.to_string());
        params.insert("api_port", api_port.to_string());
        params.insert("noise_port", noise_port.to_string());
        params.insert(
            "baseline_configuration_name",
            self.nhc_baseline_config_name.clone(),
        );
        if let Some(public_key) = public_key {
            params.insert("public_key", public_key.to_encoded_string().unwrap());
        }

```

**File:** ecosystem/node-checker/fn-check-client/src/helpers.rs (L20-24)
```rust
        SocketAddr::V4(addr) => Ok((
            Url::parse(&format!("http://{}", addr.ip()))
                .context("Failed to parse address as URL")?,
            addr.port(),
        )),
```
