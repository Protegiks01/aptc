# Audit Report

## Title
Stale Timeout Certificates Persist Indefinitely Due to Missing Quorum Certificate Comparison Check

## Summary
The `insert_2chain_timeout_certificate()` function in BlockStore fails to validate that incoming timeout certificates are not already stale compared to the node's highest quorum certificate. This allows old timeout certificates from lagging peers to be permanently stored in memory and persistent storage, violating the invariant that outdated consensus artifacts should be cleared when superseded by higher rounds.

## Finding Description

The vulnerability exists in the timeout certificate insertion logic. When a validator receives a `SyncInfo` message from another node containing a timeout certificate, the receiving node calls `insert_2chain_timeout_certificate()` to store it. [1](#0-0) 

The function only checks if the incoming TC round is higher than the currently stored TC round, but crucially **does not check** if the TC round is already outdated compared to the node's own highest quorum certificate (HQC) round.

The correct filtering happens when creating `SyncInfo` for outbound messages: [2](#0-1) 

However, this filtering is bypassed during TC insertion. When a node processes certificates from received `SyncInfo`: [3](#0-2) 

**Exploitation Path:**

1. Node A is at round 50 with HQC=50 and TC=51 (valid: 51 > 50)
2. Node A creates `SyncInfo` including TC=51 and sends it to Node B
3. Node B is at round 100 with HQC=100 and no TC stored (cur_tc_round=0)
4. Node B receives Node A's `SyncInfo` and calls `add_certs()`
5. `insert_2chain_timeout_certificate(TC51)` checks: 51 > 0 → **passes**
6. TC51 is persisted to ConsensusDB and stored in BlockTree
7. TC51 remains indefinitely despite HQC=100, only cleared on epoch change [4](#0-3) 

The stale TC persists across node restarts since recovery only filters by epoch, not by round comparison with QC.

While the stale TC is correctly filtered when Node B creates its own `SyncInfo`, it permanently occupies storage and memory resources. The invariant that "consensus artifacts become obsolete when superseded by higher rounds and should be cleared" is violated.

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **State Inconsistencies**: Stale consensus data persists indefinitely in both memory (BlockTree) and persistent storage (ConsensusDB), violating data consistency invariants
- **Resource Inefficiency**: Unnecessary storage consumption that accumulates over time as nodes receive stale TCs from various lagging peers
- **Monitoring/Debugging Confusion**: Persistent stale TCs can mislead operators during incident investigation or health monitoring

The vulnerability does not cause immediate consensus failure because:
- Outbound `SyncInfo` correctly filters stale TCs before propagation
- Safety rules use OR logic that allows voting/timeout signing even with stale TCs
- Round progression uses filtered `SyncInfo` from received messages

However, it represents a clear violation of system invariants around data lifecycle management.

## Likelihood Explanation

**High Likelihood** of occurrence in production:
- Normal network conditions produce scenarios where nodes have different HQC/TC rounds
- No special attacker capability required—happens naturally with network latency or temporary node lag
- Any validator can trigger this by sending legitimate `SyncInfo` that happens to contain a TC lower than the receiver's HQC
- Persists across restarts and accumulates over time within an epoch

## Recommendation

Add a validation check in `insert_2chain_timeout_certificate()` to reject timeout certificates that are already stale compared to the highest quorum certificate:

```rust
pub fn insert_2chain_timeout_certificate(
    &self,
    tc: Arc<TwoChainTimeoutCertificate>,
) -> anyhow::Result<()> {
    let cur_tc_round = self
        .highest_2chain_timeout_cert()
        .map_or(0, |tc| tc.round());
    
    // NEW CHECK: Reject TC if already stale compared to HQC
    let hqc_round = self.highest_quorum_cert().certified_block().round();
    if tc.round() <= hqc_round {
        return Ok(()); // TC is obsolete, don't store it
    }
    
    if tc.round() <= cur_tc_round {
        return Ok(());
    }
    
    self.storage
        .save_highest_2chain_timeout_cert(tc.as_ref())
        .context("Timeout certificate insert failed when persisting to DB")?;
    self.inner.write().replace_2chain_timeout_cert(tc);
    Ok(())
}
```

Additionally, consider adding a cleanup mechanism during QC insertion:

```rust
pub fn insert_single_quorum_cert(&self, qc: QuorumCert) -> anyhow::Result<()> {
    // ... existing validation ...
    
    // Clear stale TC when new QC surpasses it
    if let Some(tc) = self.highest_2chain_timeout_cert() {
        if tc.round() <= qc.certified_block().round() {
            self.inner.write().replace_2chain_timeout_cert(None);
            self.storage.consensus_db().delete_highest_2chain_timeout_certificate()?;
        }
    }
    
    // ... rest of function ...
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_stale_timeout_certificate_persistence() {
    // Setup: Create two nodes with different rounds
    let (storage_a, block_store_a) = create_test_block_store(50); // Node A at round 50
    let (storage_b, block_store_b) = create_test_block_store(100); // Node B at round 100
    
    // Node A creates TC at round 51
    let tc_51 = create_timeout_certificate(51, 50);
    block_store_a.insert_2chain_timeout_certificate(Arc::new(tc_51.clone())).unwrap();
    
    // Node A creates SyncInfo (TC will be included since 51 > 50)
    let sync_info_a = block_store_a.sync_info();
    assert!(sync_info_a.highest_2chain_timeout_cert().is_some());
    
    // Node B receives SyncInfo from Node A and processes it
    let retriever = create_test_retriever();
    block_store_b.add_certs(&sync_info_a, retriever).await.unwrap();
    
    // VULNERABILITY: Node B now has stale TC (51 < 100)
    let stored_tc = block_store_b.highest_2chain_timeout_cert();
    assert!(stored_tc.is_some());
    assert_eq!(stored_tc.unwrap().round(), 51);
    
    // Verify HQC is at round 100 but TC is at round 51
    let hqc_round = block_store_b.highest_quorum_cert().certified_block().round();
    assert_eq!(hqc_round, 100);
    
    // TC persists despite being stale
    assert!(stored_tc.unwrap().round() < hqc_round);
    
    // When Node B creates its own SyncInfo, TC is filtered correctly
    let sync_info_b = block_store_b.sync_info();
    assert!(sync_info_b.highest_2chain_timeout_cert().is_none());
    
    // But the stale TC remains in storage
    let persisted_tc = storage_b.get_highest_2chain_timeout_certificate();
    assert!(persisted_tc.is_some());
    assert_eq!(persisted_tc.unwrap().round(), 51);
}
```

## Notes

This vulnerability represents a data consistency issue where stale consensus artifacts persist beyond their useful lifetime. While it doesn't immediately break consensus safety (due to filtering at the `SyncInfo` boundary), it violates the invariant that outdated data should be proactively cleared. The fix is straightforward: add HQC round comparison during TC insertion to prevent stale TCs from being stored in the first place.

### Citations

**File:** consensus/src/block_storage/block_store.rs (L560-575)
```rust
    pub fn insert_2chain_timeout_certificate(
        &self,
        tc: Arc<TwoChainTimeoutCertificate>,
    ) -> anyhow::Result<()> {
        let cur_tc_round = self
            .highest_2chain_timeout_cert()
            .map_or(0, |tc| tc.round());
        if tc.round() <= cur_tc_round {
            return Ok(());
        }
        self.storage
            .save_highest_2chain_timeout_cert(tc.as_ref())
            .context("Timeout certificate insert failed when persisting to DB")?;
        self.inner.write().replace_2chain_timeout_cert(tc);
        Ok(())
    }
```

**File:** consensus/consensus-types/src/sync_info.rs (L57-59)
```rust
        // No need to include HTC if it's lower than HQC
        let highest_2chain_timeout_cert = highest_2chain_timeout_cert
            .filter(|tc| tc.round() > highest_quorum_cert.certified_block().round());
```

**File:** consensus/src/block_storage/sync_manager.rs (L169-171)
```rust
        if let Some(tc) = sync_info.highest_2chain_timeout_cert() {
            self.insert_2chain_timeout_certificate(Arc::new(tc.clone()))?;
        }
```

**File:** consensus/src/persistent_liveness_storage.rs (L414-417)
```rust
            highest_2chain_timeout_certificate: match highest_2chain_timeout_cert {
                Some(tc) if tc.epoch() == epoch => Some(tc),
                _ => None,
            },
```
