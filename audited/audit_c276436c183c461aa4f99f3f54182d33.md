# Audit Report

## Title
Unvalidated Package Names in On-Chain PackageMetadata Enable Filesystem Manipulation in Package Cache

## Summary
The on-chain `code.move` contract does not validate package names when publishing packages, allowing arbitrary Unicode, emoji, control characters, and filesystem-unsafe characters. When such packages are fetched via the package cache, these malicious names are used directly in filesystem paths without sanitization, potentially causing directory traversal, filesystem errors, or display corruption.

## Finding Description

The vulnerability exists across two layers:

**Layer 1: Missing On-Chain Validation**

The `publish_package` function in `code.move` accepts `PackageMetadata` with a `name: String` field but performs no validation on the package name format. [1](#0-0) 

While off-chain tooling uses `PackageName` type with strict ASCII validation (alphanumeric, hyphens, underscores only): [2](#0-1) 

An attacker can bypass this by directly calling `publish_package_txn` entry function with manually crafted BCS-serialized `PackageMetadata` containing arbitrary characters in the name field: [3](#0-2) 

**Layer 2: Unsanitized Filesystem Usage**

When fetching on-chain packages, the package cache directly concatenates the package name into a filesystem path without sanitization: [4](#0-3) 

Note that while git repository names are percent-encoded for safety: [5](#0-4) 

This sanitization is NOT applied to on-chain package names.

**Attack Scenario:**

1. Attacker crafts `PackageMetadata` with malicious name (e.g., `"../../../evil"`, `"pkg:name"`, `"pkg\x00name"`)
2. Serializes to BCS and calls `publish_package_txn` directly
3. Package is published on-chain without validation
4. When legitimate users try to fetch this dependency, the malicious name is used in `Path::join()` operations
5. Results in directory traversal, filesystem errors, or display corruption

## Impact Explanation

This qualifies as **Low Severity** per Aptos bug bounty criteria as a "Non-critical implementation bug" because:

- **No consensus impact**: Does not affect blockchain state validation or execution
- **No funds at risk**: Cannot steal or mint tokens
- **Limited to tooling**: Only affects off-chain package resolution tools
- **Denial of Service**: Prevents users from fetching malicious packages, causing filesystem errors
- **Potential file corruption**: Directory traversal could theoretically overwrite cache files (limited by OS permissions)
- **Display corruption**: Control characters or Unicode could corrupt terminal output

This is NOT Critical/High/Medium because it does not break consensus, execution, or core blockchain functionality.

## Likelihood Explanation

**Likelihood: Medium**

- **Easy to exploit**: Attacker only needs to craft BCS-serialized metadata and submit transaction
- **No special privileges required**: Any account can publish packages (subject to gas fees)
- **Requires victim interaction**: Users must attempt to fetch the malicious package
- **Limited real-world impact**: Most developers use standard tooling which validates package names before publishing
- **Detection**: Malicious package names would be visible on-chain to potential victims

## Recommendation

**On-Chain Validation (Primary Fix):**

Add package name validation in `code.move` before publishing:

```move
// In code.move, add validation function
fun is_valid_package_name(name: &String): bool {
    let bytes = string::bytes(name);
    let len = vector::length(bytes);
    if (len == 0) return false;
    
    // First char must be letter or underscore
    let first = *vector::borrow(bytes, 0);
    if (!((first >= 65 && first <= 90) || (first >= 97 && first <= 122) || first == 95)) {
        return false;
    };
    
    // All chars must be alphanumeric, hyphen, or underscore
    let i = 1;
    while (i < len) {
        let c = *vector::borrow(bytes, i);
        if (!((c >= 65 && c <= 90) || (c >= 97 && c <= 122) || 
              (c >= 48 && c <= 57) || c == 45 || c == 95)) {
            return false;
        };
        i = i + 1;
    };
    true
}

// In publish_package function, add validation
assert!(is_valid_package_name(&pack.name), error::invalid_argument(EINVALID_PACKAGE_NAME));
```

**Off-Chain Sanitization (Defense in Depth):**

Add sanitization in `fetch_on_chain_package`: [6](#0-5) 

Replace direct concatenation with percent-encoding:

```rust
let sanitized_package_name = percent_encode_for_filename(package_name);
let canonical_name = format!(
    "{}+{}+{}+{}",
    &*canonical_node_identity, network_version, address, sanitized_package_name
);
```

## Proof of Concept

```move
// PoC: Publish package with malicious name
script {
    use std::vector;
    use aptos_framework::code;
    use aptos_framework::util;
    
    fun publish_malicious_package(publisher: &signer) {
        // Craft PackageMetadata with directory traversal in name
        let malicious_name = b"../../../evil";
        
        // Create minimal PackageMetadata struct
        // (In practice, serialize full struct with bcs::to_bytes)
        let metadata_bytes = vector::empty<u8>();
        // ... BCS serialization of PackageMetadata with malicious_name ...
        
        let code_bytes = vector::empty<vector<u8>>();
        
        // This will succeed because no validation exists
        code::publish_package_txn(publisher, metadata_bytes, code_bytes);
        
        // Package is now on-chain with name "../../../evil"
        // When fetched, will cause path: /cache/on-chain/node+version+addr+../../../evil
        // Which resolves outside cache directory
    }
}
```

## Notes

- This vulnerability exists because on-chain Move code trusts package names without validation, while off-chain Rust tooling assumes names were validated
- The issue is exacerbated by the package cache using direct string concatenation instead of the existing `percent_encode_for_filename` function
- Impact is limited to off-chain tooling and does not affect blockchain consensus or state
- The validation gap between on-chain (no validation) and off-chain (strict validation) creates this attack surface

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L168-228)
```text
    public fun publish_package(owner: &signer, pack: PackageMetadata, code: vector<vector<u8>>) acquires PackageRegistry {
        check_code_publishing_permission(owner);
        // Disallow incompatible upgrade mode. Governance can decide later if this should be reconsidered.
        assert!(
            pack.upgrade_policy.policy > upgrade_policy_arbitrary().policy,
            error::invalid_argument(EINCOMPATIBLE_POLICY_DISABLED),
        );

        let addr = signer::address_of(owner);
        if (!exists<PackageRegistry>(addr)) {
            move_to(owner, PackageRegistry { packages: vector::empty() })
        };

        // Checks for valid dependencies to other packages
        let allowed_deps = check_dependencies(addr, &pack);

        // Check package against conflicts
        // To avoid prover compiler error on spec
        // the package need to be an immutable variable
        let module_names = get_module_names(&pack);
        let package_immutable = &borrow_global<PackageRegistry>(addr).packages;
        let len = vector::length(package_immutable);
        let index = len;
        let upgrade_number = 0;
        vector::enumerate_ref(package_immutable
        , |i, old| {
            let old: &PackageMetadata = old;
            if (old.name == pack.name) {
                upgrade_number = old.upgrade_number + 1;
                check_upgradability(old, &pack, &module_names);
                index = i;
            } else {
                check_coexistence(old, &module_names)
            };
        });

        // Assign the upgrade counter.
        pack.upgrade_number = upgrade_number;

        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;
        // Update registry
        let policy = pack.upgrade_policy;
        if (index < len) {
            *vector::borrow_mut(packages, index) = pack
        } else {
            vector::push_back(packages, pack)
        };

        event::emit(PublishPackage {
            code_address: addr,
            is_upgrade: upgrade_number > 0
        });

        // Request publish
        if (features::code_dependency_check_enabled())
            request_publish_with_allowed_deps(addr, module_names, allowed_deps, code, policy.policy)
        else
        // The new `request_publish_with_allowed_deps` has not yet rolled out, so call downwards
        // compatible code.
            request_publish(addr, module_names, code, policy.policy)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L256-259)
```text
    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)
    acquires PackageRegistry {
        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)
    }
```

**File:** third_party/move/tools/move-package-manifest/src/package_name.rs (L58-67)
```rust
fn is_valid_package_name(s: &str) -> bool {
    let mut chars = s.chars();

    match chars.next() {
        Some(c) if c.is_ascii_alphabetic() || c == '_' => (),
        _ => return false,
    }

    chars.all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_')
}
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L63-77)
```rust
fn percent_encode_for_filename(s: &str) -> String {
    const ASCII_SET: AsciiSet = CONTROLS
        .add(b'<')
        .add(b'>')
        .add(b':')
        .add(b'"')
        .add(b'/')
        .add(b'\\')
        .add(b'/')
        .add(b'|')
        .add(b'?')
        .add(b'*');

    percent_encoding::utf8_percent_encode(s, &ASCII_SET).to_string()
}
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L280-298)
```rust
    pub async fn fetch_on_chain_package(
        &self,
        fullnode_url: &Url,
        network_version: u64,
        address: AccountAddress,
        package_name: &str,
    ) -> Result<PathBuf>
    where
        L: PackageCacheListener,
    {
        let on_chain_packages_path = self.root.join("on-chain");

        let canonical_node_identity = CanonicalNodeIdentity::new(fullnode_url)?;
        let canonical_name = format!(
            "{}+{}+{}+{}",
            &*canonical_node_identity, network_version, address, package_name
        );

        let cached_package_path = on_chain_packages_path.join(&canonical_name);
```
