# Audit Report

## Title
Epoch Mismatch Vulnerability in Consensus Observer: Missing Validation of Individual Block Epochs Against Ordered Proof

## Summary
The consensus observer's `OrderedBlock` validation logic fails to verify that individual blocks' epochs match the epoch claimed in the ordered proof's `BlockInfo`. This allows malicious validators to package blocks from previous epochs with a proof from the current epoch, bypassing epoch isolation guarantees in the consensus protocol.

## Finding Description

The `ObservedOrderedBlock` structure wraps an `OrderedBlock` containing multiple `PipelinedBlock` instances and a `LedgerInfoWithSignatures` proof. Each component carries epoch information, but the validation logic only checks the proof's epoch against the current `EpochState`, not the individual blocks' epochs. [1](#0-0) 

The `verify_ordered_blocks()` method validates block structure and chaining but does not check epochs: [2](#0-1) 

The `process_ordered_block()` method only validates the proof's epoch: [3](#0-2) 

**Critical Gap**: Line 729 checks `ordered_block.proof_block_info().epoch() == epoch_state.epoch`, validating only the proof's claimed epoch. There is no verification that each block in `ordered_block.blocks()` has `block.epoch()` equal to `proof_block_info().epoch()`.

The `EpochState::verify()` method also only checks the proof's internal consistency: [4](#0-3) 

**Attack Scenario**:
1. Malicious validator(s) from current epoch N create blocks containing transactions from epoch N-1 (or maintain references to old blocks)
2. They construct a `BlockInfo` with the last block's ID but claim `epoch = N`
3. They create a `LedgerInfoWithSignatures` with this `BlockInfo` and obtain signatures from colluding validators in epoch N
4. They package the epoch N-1 blocks with the epoch N proof into an `OrderedBlock`
5. The consensus observer validates: ✓ proof epoch matches current epoch N, ✓ block IDs match, ✓ blocks are chained
6. The epoch N-1 blocks are accepted and forwarded to execution pipeline despite epoch mismatch

This breaks the fundamental invariant that blocks within an epoch must belong to that epoch, violating consensus safety across epoch boundaries.

## Impact Explanation

**Severity: High** per Aptos bug bounty criteria (Significant Protocol Violation)

This vulnerability enables:
- **Epoch Isolation Breach**: Blocks from different epochs can be mixed, violating temporal consensus boundaries
- **State Inconsistency**: Different observers may accept blocks from different epochs depending on when they receive messages
- **Consensus Safety Violation**: The consensus protocol assumes epoch boundaries are enforced; breaking this can lead to divergent ledger states
- **Transaction Replay**: Old epoch transactions could be re-executed in new epochs with different validator sets and configurations

While this does not directly cause fund loss or network partition, it represents a significant protocol violation that undermines consensus safety guarantees across epoch transitions.

## Likelihood Explanation

**Likelihood: Medium**

Exploitation requires:
- One or more malicious validators in the current epoch with sufficient stake to create valid signatures
- Ability to convince other validators to sign the fraudulent proof (or sufficient stake to meet signature threshold alone)
- Access to blocks from previous epochs (which are publicly available)

While requiring validator compromise, the validation gap is clear and the attack is straightforward once a validator is malicious. Byzantine fault tolerance assumptions allow for up to 1/3 malicious validators, making this scenario within the threat model for consensus protocols.

## Recommendation

Add explicit validation in `verify_ordered_blocks()` to ensure all blocks have matching epochs with the proof:

```rust
// In consensus/src/consensus_observer/network/observer_message.rs
// Add this validation in verify_ordered_blocks() method after line 245

// Verify all blocks have the same epoch as the proof
let proof_epoch = self.proof_block_info().epoch();
for block in self.blocks.iter() {
    if block.epoch() != proof_epoch {
        return Err(Error::InvalidMessageError(
            format!(
                "Block epoch mismatch! Block epoch: {:?}, Proof epoch: {:?}, Block ID: {:?}",
                block.epoch(),
                proof_epoch,
                block.id()
            )
        ));
    }
}
```

Additionally, add a defensive check in `process_ordered_block()` before line 729:

```rust
// Verify blocks are from the current epoch
let proof_epoch = ordered_block.proof_block_info().epoch();
for block in ordered_block.blocks() {
    if block.epoch() != proof_epoch {
        error!(/*...error logging with block and proof epoch mismatch...*/);
        return;
    }
}
```

## Proof of Concept

**Rust Test Demonstrating the Vulnerability**:

```rust
#[test]
fn test_epoch_mismatch_attack() {
    use aptos_types::block_info::BlockInfo;
    use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
    use consensus_types::pipelined_block::PipelinedBlock;
    use std::sync::Arc;

    // Create blocks from epoch 10
    let old_epoch = 10u64;
    let current_epoch = 15u64;
    
    // Create a block from old epoch
    let mut old_block_data = BlockData::new_for_testing(old_epoch, 100, HashValue::random());
    let old_block = Block::new_from_block_data(old_block_data);
    let old_pipelined_block = Arc::new(PipelinedBlock::new_ordered(old_block));
    
    // Create BlockInfo claiming current epoch but using old block's ID
    let malicious_block_info = BlockInfo::new(
        current_epoch,  // Claim current epoch
        old_pipelined_block.round(),
        old_pipelined_block.id(),  // But use old block's ID
        HashValue::zero(),
        0,
        old_pipelined_block.timestamp_usecs(),
        None,
    );
    
    // Create proof with malicious BlockInfo
    let ledger_info = LedgerInfo::new(malicious_block_info, HashValue::zero());
    let proof = LedgerInfoWithSignatures::new(ledger_info, BTreeMap::new());
    
    // Create OrderedBlock with epoch mismatch
    let ordered_block = OrderedBlock::new(
        vec![old_pipelined_block.clone()],
        proof,
    );
    
    // Verify ordered blocks passes (only checks IDs and chaining, not epochs)
    assert!(ordered_block.verify_ordered_blocks().is_ok());
    
    // Create epoch state for current epoch
    let epoch_state = EpochState::new(current_epoch, ValidatorVerifier::new(vec![]));
    
    // The epoch check would pass: proof_block_info().epoch() == epoch_state.epoch
    assert_eq!(ordered_block.proof_block_info().epoch(), epoch_state.epoch);
    
    // But individual block has wrong epoch - THIS IS NOT CHECKED!
    assert_ne!(old_pipelined_block.epoch(), current_epoch);
    assert_eq!(old_pipelined_block.epoch(), old_epoch);
    
    // This demonstrates the vulnerability: ordered_block passes basic validation
    // despite containing blocks from a different epoch than claimed in the proof
}
```

**Notes**

This vulnerability specifically violates the consensus safety invariant: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine". By allowing epoch boundary violations, malicious validators within the Byzantine threshold can compromise epoch-based consensus guarantees. The fix requires adding epoch consistency validation between blocks and their ordering proofs at multiple validation points in the consensus observer.

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L181-184)
```rust
pub struct OrderedBlock {
    blocks: Vec<Arc<PipelinedBlock>>,
    ordered_proof: LedgerInfoWithSignatures,
}
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L227-266)
```rust
    pub fn verify_ordered_blocks(&self) -> Result<(), Error> {
        // Verify that we have at least one ordered block
        if self.blocks.is_empty() {
            return Err(Error::InvalidMessageError(
                "Received empty ordered block!".to_string(),
            ));
        }

        // Verify the last block ID matches the ordered proof block ID
        if self.last_block().id() != self.proof_block_info().id() {
            return Err(Error::InvalidMessageError(
                format!(
                    "Last ordered block ID does not match the ordered proof ID! Number of blocks: {:?}, Last ordered block ID: {:?}, Ordered proof ID: {:?}",
                    self.blocks.len(),
                    self.last_block().id(),
                    self.proof_block_info().id()
                )
            ));
        }

        // Verify the blocks are correctly chained together (from the last block to the first)
        let mut expected_parent_id = None;
        for block in self.blocks.iter().rev() {
            if let Some(expected_parent_id) = expected_parent_id {
                if block.id() != expected_parent_id {
                    return Err(Error::InvalidMessageError(
                        format!(
                            "Block parent ID does not match the expected parent ID! Block ID: {:?}, Expected parent ID: {:?}",
                            block.id(),
                            expected_parent_id
                        )
                    ));
                }
            }

            expected_parent_id = Some(block.parent_id());
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L728-752)
```rust
        let epoch_state = self.get_epoch_state();
        if ordered_block.proof_block_info().epoch() == epoch_state.epoch {
            if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify ordered proof! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        ordered_block.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
                return;
            }
        } else {
            // Drop the block and log an error (the block should always be for the current epoch)
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received ordered block for a different epoch! Ignoring: {:?}",
                    ordered_block.proof_block_info()
                ))
            );
            return;
        };
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```
