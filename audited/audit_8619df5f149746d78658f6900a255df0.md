# Audit Report

## Title
Asymmetric Transaction Filter Validation Enables Quorum Store Batch Filter Bypass

## Summary
The block transaction filter implementation applies validation inconsistently between proposal acceptance and block execution. During proposal validation, only inline transactions are checked via `check_denied_inline_transactions()`, while quorum store batch transactions bypass this check. However, during execution, ALL transactions (both inline and quorum store batches) are filtered. This asymmetry allows proposers to include denied transactions via quorum store batches that pass proposal validation but get filtered during execution, wasting validator resources.

## Finding Description

The block transaction filter system has two critical integration points:

1. **Proposal Validation** (consensus layer): When validators receive a block proposal, `check_denied_inline_transactions()` is called to validate the proposal before voting. [1](#0-0) 

2. **Block Execution** (execution layer): During block preparation, `filter_block_transactions()` filters all transactions before execution. [2](#0-1) 

The critical flaw is that proposal validation only checks **inline transactions**, not quorum store batch references: [3](#0-2) 

The `get_inline_transactions()` function explicitly returns empty vectors for quorum store batch payloads (line 596), meaning transactions referenced via `ProofWithData` batches are never validated during proposal acceptance.

Additionally, the filter configuration uses **separate filters** for consensus and execution: [4](#0-3) 

These filters are **locally configured per validator** with no consensus-level validation of consistency: [5](#0-4) [6](#0-5) 

**Attack Scenario:**

1. Network operators configure filters to deny transactions from address `0xBAD`
2. Attacker submits transaction from `0xBAD` to quorum store (gets batched)
3. Malicious proposer creates block with legitimate inline transactions but references quorum store batch containing denied transaction
4. Validators check only inline transactions â†’ validation passes
5. Validators vote and certify the block (quorum reached)
6. During execution, ALL validators filter the denied transaction from `0xBAD`
7. Block executes with fewer transactions than proposed

This breaks the implicit assumption that certified blocks contain only valid transactions that will execute as proposed.

## Impact Explanation

This vulnerability falls under **Medium Severity** based on:

1. **Resource Waste**: Validators expend computational resources processing, validating, and voting on blocks containing transactions that will be filtered during execution
2. **Protocol Manipulation**: Proposers can force the network to certify blocks with known-bad transactions, undermining the proposal validation mechanism
3. **Potential Liveness Issues**: If validators configure inconsistent `execution_filter` settings, they could produce different state roots, causing consensus stalls
4. **Censorship Implications**: The `BlockMatcher::Author` feature enables proposer-specific filtering rules, allowing validators to selectively execute transactions based on block author identity [7](#0-6) 

While this doesn't directly cause fund loss or permanent chain splits (validators would detect state root mismatches), it represents a significant protocol violation requiring operational intervention.

## Likelihood Explanation

**Likelihood: Medium-High**

This issue will manifest whenever:
1. Transaction filters are enabled (`filter_enabled = true`)
2. Filters are configured to deny certain transaction types
3. Quorum store is active (default configuration)
4. Proposers include filtered transactions via quorum store batches

The attack requires minimal sophistication - any transaction sender can submit to quorum store, and any proposer can reference those batches. No validator collusion or special privileges are needed beyond normal block proposal rights.

## Recommendation

**Fix 1: Validate All Transactions During Proposal Acceptance**

Modify `check_denied_inline_transactions()` to validate ALL transactions in the payload, not just inline ones. For quorum store payloads, this requires fetching and validating batch contents before voting:

```rust
// In QuorumStorePayloadManager::check_denied_inline_transactions
fn check_denied_inline_transactions(
    &self,
    block: &Block,
    block_txn_filter_config: &BlockTransactionFilterConfig,
) -> anyhow::Result<()> {
    if !block_txn_filter_config.is_enabled() {
        return Ok(());
    }

    // Validate ALL transactions, including quorum store batches
    let all_transactions = match block.payload() {
        Some(Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _)) => {
            let mut txns = get_inline_transactions(block);
            // Fetch and validate quorum store batch transactions
            for proof in &proof_with_data.proofs {
                let batch_txns = self.batch_reader
                    .get_batch_sync(proof.info().clone())?;
                txns.extend(batch_txns);
            }
            txns
        },
        _ => get_inline_transactions(block),
    };

    // Apply filter to all transactions
    let denied_transactions = block_txn_filter_config
        .block_transaction_filter()
        .get_denied_block_transactions(
            block.id(),
            block.author(),
            block.epoch(),
            block.timestamp_usecs(),
            all_transactions,
        );
    
    if !denied_transactions.is_empty() {
        return Err(anyhow::anyhow!("Proposal contains denied transactions"));
    }
    
    Ok(())
}
```

**Fix 2: Enforce Filter Consistency**

Add validation to ensure `consensus_filter` and `execution_filter` are identical, preventing configuration mismatches:

```rust
// In config validation
impl TransactionFiltersConfig {
    pub fn validate(&self) -> Result<(), ConfigError> {
        if self.consensus_filter != self.execution_filter {
            return Err(ConfigError::new(
                "consensus_filter and execution_filter must be identical"
            ));
        }
        Ok(())
    }
}
```

**Fix 3: Remove Block Author-Based Filtering**

The `BlockMatcher::Author` feature enables non-deterministic behavior based on proposer identity. Remove this matcher type or add strict validation preventing author-dependent rules.

## Proof of Concept

```rust
#[cfg(test)]
mod test_filter_bypass {
    use super::*;
    use aptos_types::transaction::SignedTransaction;
    
    #[test]
    fn test_quorum_store_bypass_inline_check() {
        // Create filter that denies transactions from 0xBAD
        let bad_sender = AccountAddress::from_hex_literal("0xBAD").unwrap();
        let filter = BlockTransactionFilter::empty()
            .add_multiple_matchers_filter(
                false,
                vec![BlockTransactionMatcher::Transaction(
                    TransactionMatcher::Sender(bad_sender)
                )]
            );
        
        // Create block with quorum store payload containing denied transaction
        let denied_txn = create_test_transaction(bad_sender);
        let block = create_block_with_quorum_store_batch(vec![denied_txn]);
        
        // Inline check passes (no inline transactions)
        let inline_txns = get_inline_transactions(&block);
        assert_eq!(inline_txns.len(), 0);
        
        // But execution would filter the transaction
        let all_txns = get_all_transactions(&block); // includes QS batches
        let filtered = filter.filter_block_transactions(
            block.id(),
            block.author(),
            block.epoch(),
            block.timestamp_usecs(),
            all_txns,
        );
        
        // Transaction gets filtered during execution despite passing proposal validation
        assert_eq!(filtered.len(), 0, "Denied transaction bypassed proposal check");
    }
}
```

## Notes

This vulnerability requires the transaction filter feature to be enabled and configured. If filters are disabled (default configuration), the issue does not manifest. However, the asymmetric validation design creates a latent security risk that activates when filters are deployed, making it a protocol-level design flaw rather than a simple configuration issue.

### Citations

**File:** consensus/src/round_manager.rs (L1202-1214)
```rust
        // If the proposal contains any inline transactions that need to be denied
        // (e.g., due to filtering) drop the message and do not vote for the block.
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** consensus/src/block_preparer.rs (L89-98)
```rust
        // Transaction filtering, deduplication and shuffling are CPU intensive tasks, so we run them in a blocking task.
        let result = tokio::task::spawn_blocking(move || {
            let filtered_txns = filter_block_transactions(
                txn_filter_config,
                block_id,
                block_author,
                block_epoch,
                block_timestamp_usecs,
                txns,
            );
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L568-599)
```rust
fn get_inline_transactions(block: &Block) -> Vec<SignedTransaction> {
    // If the block has no payload, return an empty vector
    let Some(payload) = block.payload() else {
        return vec![];
    };

    // Fetch the inline transactions from the payload
    match payload {
        Payload::QuorumStoreInlineHybrid(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::QuorumStoreInlineHybridV2(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => p.inline_batches().transactions(),
        Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
            error!("OptQSPayload V2 is not expected");
            Vec::new()
        },
        _ => {
            vec![] // Other payload types do not have inline transactions
        },
    }
}
```

**File:** config/src/config/transaction_filters_config.rs (L12-17)
```rust
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
```

**File:** consensus/src/epoch_manager.rs (L211-211)
```rust
        let consensus_txn_filter_config = node_config.transaction_filters.consensus_filter.clone();
```

**File:** consensus/src/consensus_provider.rs (L69-69)
```rust
        node_config.transaction_filters.execution_filter.clone(),
```

**File:** crates/aptos-transaction-filters/src/block_transaction_filter.rs (L252-260)
```rust
pub enum BlockMatcher {
    All,                            // Matches any block
    Author(AccountAddress),         // Matches blocks proposed by the specified author
    BlockId(HashValue),             // Matches blocks with the specified ID
    BlockEpochGreaterThan(u64),     // Matches blocks with epochs greater than the specified value
    BlockEpochLessThan(u64),        // Matches blocks with epochs less than the specified value
    BlockTimeStampGreaterThan(u64), // Matches blocks with timestamps greater than the specified value
    BlockTimeStampLessThan(u64),    // Matches blocks with timestamps less than the specified value
}
```
