# Audit Report

## Title
Missing Subgroup Membership Validation in Chunky PVSS PublicParameters Deserialization

## Summary
The `PublicParameters<E>` struct in the chunky PVSS implementation has an empty `Valid::check()` method that performs no validation on deserialized group elements. This creates a potential vulnerability where malicious public parameters containing group elements in small subgroups (rather than the prime-order subgroup) could pass validation if arkworks' deserialization doesn't enforce subgroup checks, compromising the discrete log problem's hardness.

## Finding Description
The chunky PVSS `PublicParameters` struct contains critical group elements including G (from `pp_elgamal`), G_2, and range proof generators. When these parameters are created via `PublicParameters::new()`, proper subgroup confinement is ensured:

- G and G_2 are created using `unsafe_hash_to_affine()` which includes cofactor multiplication to ensure prime-order subgroup membership [1](#0-0) 

- The generator H uses `C::Affine::generator()` which should return a prime-order subgroup element [2](#0-1) 

However, the deserialization path has a critical weakness. The `Valid` trait implementation for `PublicParameters<E>` contains an empty `check()` method: [3](#0-2) 

When `PublicParameters` are deserialized using `ark_de()`, the function calls `deserialize_with_mode()` with `Validate::Yes`: [4](#0-3) 

This empty validation means that if arkworks' internal deserialization doesn't perform subgroup membership checks for the specific elliptic curve being used, malicious parameters with small-subgroup elements would pass validation.

**Attack Scenario:**
1. An attacker crafts malicious `PublicParameters` where group elements (G, H, G_2, or range proof generators) lie in small subgroups of the curve (not the prime-order subgroup)
2. The attacker serializes these parameters
3. When nodes deserialize the parameters, `ark_de()` is called with `Validate::Yes`
4. If arkworks only checks curve membership (not subgroup membership) for the given curve, validation passes
5. The empty `Valid::check()` provides no additional defense
6. DKG operations using these parameters become vulnerable as discrete log in small subgroups is computationally easy

This violates the **Cryptographic Correctness** invariant requiring secure cryptographic operations.

## Impact Explanation
If exploitable, this would be **Critical Severity** as it could lead to:

- **Consensus/Safety violations**: Compromised DKG could enable malicious validators to predict or manipulate randomness
- **Loss of Funds**: Compromised randomness could enable theft through predictable validator selection or transaction ordering
- **Non-recoverable network partition**: If different validators use different public parameters, they could produce incompatible DKG outputs

However, the actual impact is **significantly mitigated** by two factors:

1. **Not used in production**: The chunky PVSS implementation is NOT used in the actual Aptos DKG. Production uses the DAS implementation which properly validates subgroup membership [5](#0-4) 

2. **Arkworks likely validates**: The Move-level documentation indicates arkworks does perform subgroup checks during deserialization [6](#0-5) 

Given production doesn't use this code, this represents a **defense-in-depth weakness** rather than an immediately exploitable vulnerability.

## Likelihood Explanation
The likelihood is **LOW to NONE** because:

1. The chunky PVSS implementation is only used in tests and benchmarks, not production
2. Arkworks' deserialization likely includes subgroup checks (though this depends on the specific curve implementation)
3. An attacker would need to convince nodes to accept malicious parameters through an undefined attack vector

For this to be exploitable, an attacker would need:
- A way to inject custom `PublicParameters` into the system
- Confirmation that arkworks doesn't validate subgroup membership for the target curve
- The chunky implementation to be deployed in production (currently it is not)

## Recommendation
Despite low likelihood, this should be fixed as a defense-in-depth measure:

**Add explicit subgroup validation in the `Valid::check()` method:**

```rust
impl<E: Pairing> Valid for PublicParameters<E> {
    fn check(&self) -> Result<(), SerializationError> {
        // Verify all group elements are in the prime-order subgroup
        if !self.G_2.is_in_correct_subgroup_assuming_on_curve() {
            return Err(SerializationError::InvalidData);
        }
        
        // Check pp_elgamal generators
        if !self.pp_elgamal.G.is_in_correct_subgroup_assuming_on_curve() {
            return Err(SerializationError::InvalidData);
        }
        
        if !self.pp_elgamal.H.is_in_correct_subgroup_assuming_on_curve() {
            return Err(SerializationError::InvalidData);
        }
        
        // Validate range proof generators
        if !self.pk_range_proof.vk.xi_1.is_in_correct_subgroup_assuming_on_curve() {
            return Err(SerializationError::InvalidData);
        }
        
        // Add checks for other generators in pk_range_proof as needed
        
        Ok(())
    }
}
```

Additionally, consider adding similar validation to the DAS implementation to ensure consistency.

## Proof of Concept
A complete PoC cannot be provided without:
1. Confirming arkworks' exact deserialization behavior for specific curves
2. Finding a curve/configuration where arkworks doesn't check subgroup membership
3. Creating test parameters with small-subgroup elements

However, the vulnerability pattern can be demonstrated:

```rust
#[test]
fn test_subgroup_validation_missing() {
    use ark_bn254::{Bn254, G1Affine, G2Affine};
    
    // This test would need to:
    // 1. Create PublicParameters with a point in a small subgroup (not prime-order)
    // 2. Serialize the parameters
    // 3. Deserialize and verify it passes (demonstrating the missing check)
    // 4. Show that cryptographic operations become weak
    
    // Note: This requires finding a point in a small subgroup for the target curve
    // which depends on the curve's cofactor structure
}
```

Due to the empty `Valid::check()` implementation being a clear violation of secure coding practices and the uncertainty around arkworks' internal validation behavior, this issue should be addressed despite not being currently exploitable in production.

### Citations

**File:** crates/aptos-crypto/src/arkworks/hashing.rs (L46-46)
```rust
            return p.mul_by_cofactor(); // is needed to ensure that `p` lies in the prime order subgroup
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L81-81)
```rust
        let H = C::Affine::generator();
```

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L120-124)
```rust
impl<E: Pairing> Valid for PublicParameters<E> {
    fn check(&self) -> Result<(), SerializationError> {
        Ok(())
    }
}
```

**File:** crates/aptos-crypto/src/arkworks/serialization.rs (L36-36)
```rust
    let a = A::deserialize_with_mode(s.reader(), Compress::Yes, Validate::Yes);
```

**File:** types/src/dkg/real_dkg/mod.rs (L38-39)
```rust
pub type WTrx = pvss::das::WeightedTranscript;
pub type DkgPP = <WTrx as Transcript>::PublicParameters;
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381_algebra.move (L136-138)
```text
    struct G2 {}

    /// A serialization scheme for `G2` elements derived from
```
