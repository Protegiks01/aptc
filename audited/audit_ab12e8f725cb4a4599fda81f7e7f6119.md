# Audit Report

## Title
Missing ChainId Validation Allows Compromised Node to Accept Wrong Chain Database

## Summary
After `chain_id()` returns a ChainId from the database, there is no validation at the node level to verify it matches the expected production chain. A node with a compromised database could start with an incorrect ChainId without immediate detection, though network-level handshake validation provides significant mitigation.

## Finding Description

The Aptos node startup flow fetches the ChainId from on-chain storage in the database without validating it against any expected value: [1](#0-0) 

This ChainId is then set globally and used throughout the node: [2](#0-1) 

The `chain_id()` function simply returns the stored value without validation: [3](#0-2) 

**Attack Scenario:**
1. Attacker gains filesystem access to a validator node
2. Replaces the production database with a testnet database (or modifies RocksDB files to change the ChainId resource)
3. Node restarts and fetches ChainId from the compromised database
4. Node operates with incorrect ChainId without detecting the mismatch

**Mitigating Controls:**
The network handshake layer DOES validate chain_id between peers: [4](#0-3) 

This prevents the compromised node from successfully connecting to legitimate network peers. Additionally, transaction validation enforces chain_id matching: [5](#0-4) 

## Impact Explanation

This issue is classified as **Medium Severity** because:
- Network handshake provides strong mitigation by rejecting connections from nodes with mismatched ChainIds
- The attack requires filesystem/database access, indicating a pre-existing compromise
- Cannot directly cause consensus violations due to network-layer protections
- Could cause operational issues, confusion, and delayed detection of database compromise
- Violates defense-in-depth principles by treating database as trusted without validation

## Likelihood Explanation

**Moderate likelihood** of occurrence because:
- Requires attacker to gain filesystem access to the node (moderate barrier)
- Database replacement or corruption is feasible for an attacker with such access
- No automatic detection mechanisms at the node level
- Operators may not immediately realize the node is using wrong chain data
- Could occur accidentally through misconfiguration or backup restore errors

## Recommendation

Add validation during node startup to verify the ChainId from the database matches the expected chain. The expected ChainId should be derived from the genesis transaction in the node configuration:

```rust
// In aptos-node/src/lib.rs, after fetching chain_id:
let chain_id = utils::fetch_chain_id(&db_rw)?;

// Extract expected chain_id from genesis transaction
if let Some(expected_chain_id) = utils::get_expected_chain_id(&node_config) {
    if chain_id != expected_chain_id {
        return Err(anyhow!(
            "ChainId mismatch detected! Database contains ChainId {} but genesis specifies {}. \
            This indicates database corruption or misconfiguration.",
            chain_id, expected_chain_id
        ));
    }
}

aptos_node_identity::set_chain_id(chain_id)?;
```

Implement `get_expected_chain_id()` in utils.rs using the existing `get_chain_id()` logic from the config loader: [6](#0-5) 

## Proof of Concept

```rust
// Reproduction steps:
// 1. Start a mainnet validator node (ChainId = 1)
// 2. Stop the node
// 3. Use db-tool to modify the ChainId resource in the database:
//    - Locate the ChainId state key in RocksDB
//    - Change the stored value from 1 to 2 (testnet)
// 4. Restart the node
// 5. Observe: Node starts successfully without error
// 6. Observe: Network connections fail with "InvalidChainId" errors
// 7. No explicit warning that database ChainId doesn't match expected value

// Expected behavior: Node should fail to start with clear error message
// Actual behavior: Node starts, attempts connections, fails silently
```

**Notes:**

While the network handshake provides critical protection against consensus violations, the lack of node-level validation creates operational risks and violates defense-in-depth principles. The database should not be treated as unconditionally trusted - validating its ChainId against the genesis configuration would provide early detection of corruption, misconfiguration, or compromise.

### Citations

**File:** aptos-node/src/utils.rs (L42-50)
```rust
pub fn fetch_chain_id(db: &DbReaderWriter) -> anyhow::Result<ChainId> {
    let db_state_view = db
        .reader
        .latest_state_checkpoint_view()
        .map_err(|err| anyhow!("[aptos-node] failed to create db state view {}", err))?;
    Ok(ChainIdResource::fetch_config(&db_state_view)
        .expect("[aptos-node] missing chain ID resource")
        .chain_id())
}
```

**File:** aptos-node/src/lib.rs (L712-716)
```rust
    // Obtain the chain_id from the DB
    let chain_id = utils::fetch_chain_id(&db_rw)?;

    // Set the chain_id in global AptosNodeIdentity
    aptos_node_identity::set_chain_id(chain_id)?;
```

**File:** crates/aptos-node-identity/src/lib.rs (L60-65)
```rust
/// Returns the [ChainId] from the global `APTOS_NODE_IDENTITY`
pub fn chain_id() -> Option<ChainId> {
    APTOS_NODE_IDENTITY
        .get()
        .and_then(|identity| identity.chain_id.get().cloned())
}
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L435-441)
```rust
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L143-143)
```text
        assert!(chain_id::get() == chain_id, error::invalid_argument(PROLOGUE_EBAD_CHAIN_ID));
```

**File:** config/src/config/node_config_loader.rs (L158-198)
```rust
fn get_chain_id(node_config: &NodeConfig) -> Result<ChainId, Error> {
    // TODO: can we make this less hacky?

    // Load the genesis transaction from disk
    let genesis_txn = get_genesis_txn(node_config).ok_or_else(|| {
        Error::InvariantViolation("The genesis transaction was not found!".to_string())
    })?;

    // Extract the chain ID from the genesis transaction
    match genesis_txn {
        Transaction::GenesisTransaction(WriteSetPayload::Direct(change_set)) => {
            let chain_id_state_key = StateKey::on_chain_config::<ChainId>()?;

            // Get the write op from the write set
            let write_set_mut = change_set.clone().write_set().clone().into_mut();
            let write_op = write_set_mut.get(&chain_id_state_key).ok_or_else(|| {
                Error::InvariantViolation(
                    "The genesis transaction does not contain the write op for the chain id!"
                        .into(),
                )
            })?;

            // Extract the chain ID from the write op
            let write_op_bytes = write_op.bytes().ok_or_else(|| Error::InvariantViolation(
                "The genesis transaction does not contain the correct write op for the chain ID!".into(),
            ))?;
            let chain_id = ChainId::deserialize_into_config(write_op_bytes).map_err(|error| {
                Error::InvariantViolation(format!(
                    "Failed to deserialize the chain ID: {:?}",
                    error
                ))
            })?;

            Ok(chain_id)
        },
        _ => Err(Error::InvariantViolation(format!(
            "The genesis transaction has the incorrect type: {:?}!",
            genesis_txn
        ))),
    }
}
```
