# Audit Report

## Title
Consensus Divergence Risk from Ungated Native Function Implementation Changes During Rolling Upgrades

## Summary
Native function implementations in Aptos are compiled into validator binaries as `RawSafeNative` function pointers. While the codebase provides feature flags and timed features for gating behavior changes, there is no runtime enforcement preventing validators from running different binary versions with divergent native function implementations. If a developer modifies a native function without proper feature gating, validators on different binaries during a rolling upgrade will execute transactions differently, causing consensus divergence.

## Finding Description

Native functions are defined as function pointers in the Aptos VM: [1](#0-0) 

These functions are registered at VM initialization and compiled directly into the validator binary: [2](#0-1) 

The system provides mitigation mechanisms through feature flags and timed features: [3](#0-2) [4](#0-3) 

Examples of proper feature gating include the table natives memory double counting fix: [5](#0-4) 

And the ED25519 public key validation behavior change: [6](#0-5) 

**However**, the critical issue is that there is **no automated enforcement** preventing a developer from making native function changes without proper feature flags. The protocol version system manages on-chain version numbers but does not validate binary compatibility: [7](#0-6) [8](#0-7) 

During rolling upgrades, validators can run different binaries: [9](#0-8) 

**Attack Scenario:**
1. Developer implements a bug fix or optimization in a native function (e.g., changing validation logic, fixing edge case handling)
2. Change is not gated behind a feature flag or timed feature (oversight in code review)
3. New binary version is released and validators begin rolling upgrade
4. During upgrade window: Validator Set A runs old binary, Validator Set B runs new binary
5. Transaction executes calling the modified native function
6. Set A produces state root X using old implementation
7. Set B produces state root Y using new implementation  
8. **Consensus safety violation**: Network cannot agree on correct state root
9. Chain halts or forks, requiring emergency hardfork to recover

This breaks **Invariant #1: Deterministic Execution** - all validators must produce identical state roots for identical blocks.

## Impact Explanation

This qualifies as **Critical Severity** under Aptos bug bounty criteria:
- **Consensus/Safety violations**: Different validators produce different state roots for the same block
- **Non-recoverable network partition (requires hardfork)**: The network splits into two factions that cannot reconcile their state without manual intervention

The impact affects the entire network - all validators and users are impacted when consensus breaks.

## Likelihood Explanation

**Likelihood: MEDIUM** 

While the codebase demonstrates extensive use of proper feature gating (all examined native functions use feature flags or timed features), the likelihood is non-zero because:

1. **Human Error**: Depends on developer discipline and code review catching every behavior change
2. **No Automated Prevention**: No compiler or runtime check enforces feature gating
3. **Complex Codebase**: With dozens of native function modules, subtle behavior changes can be overlooked
4. **Historical Precedent**: The existence of multiple timed features for "fixes" (FixMemoryUsageTracking, FixTableNativesMemoryDoubleCounting) indicates past instances where behavior needed retroactive gating

The system relies entirely on process controls rather than technical enforcement.

## Recommendation

Implement a **Native Function Versioning Registry** with automated enforcement:

```rust
// In aptos-native-interface/src/versioned_native.rs
pub struct VersionedNativeFunction {
    pub min_version: u64,
    pub max_version: Option<u64>,
    pub implementation: RawSafeNative,
    pub feature_flag: Option<FeatureFlag>,
    pub timed_feature: Option<TimedFeatureFlag>,
}

impl VersionedNativeFunction {
    pub fn should_execute(&self, context: &SafeNativeContext) -> bool {
        // Check feature flags
        if let Some(flag) = self.feature_flag {
            if !context.get_feature_flags().is_enabled(flag) {
                return false;
            }
        }
        // Check timed features
        if let Some(flag) = self.timed_feature {
            if !context.timed_feature_enabled(flag) {
                return false;
            }
        }
        // Check version range
        let current_version = context.gas_feature_version();
        current_version >= self.min_version && 
            self.max_version.map_or(true, |max| current_version <= max)
    }
}
```

**Enforcement at compile-time**: Require all native function registrations to declare their versioning constraints:

```rust
// This would fail to compile without explicit versioning
pub fn make_all(builder: &SafeNativeBuilder) -> impl Iterator<Item = (String, NativeFunction)> {
    builder.make_versioned_natives([
        ("function_name", VersionedNativeFunction {
            min_version: RELEASE_V1_38,
            max_version: None,
            implementation: native_impl,
            feature_flag: Some(FeatureFlag::NEW_BEHAVIOR),
            timed_feature: None,
        })
    ])
}
```

**Runtime validation**: Add assertion in consensus to verify all validators are executing compatible native function versions by including a native function table hash in block metadata.

## Proof of Concept

This is a process vulnerability rather than code-level exploit. A reproduction would require:

1. Fork the Aptos codebase
2. Modify a native function implementation without adding feature flags (e.g., change `native_public_key_validate` to always return `false` for empty keys)
3. Build two binary versions (old and new)
4. Run local testnet with validators split between versions
5. Submit transaction calling the modified native function
6. Observe: Validators produce different state roots and consensus fails

**Conceptual PoC** (cannot be executed without intentionally introducing the bug):

```rust
// BAD: Unguarded behavior change in ed25519.rs
fn native_public_key_validate(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let key_bytes = safely_pop_arg!(arguments, Vec<u8>);
    
    // VULNERABILITY: Changed validation logic without feature flag
    // Old version: returned error for empty keys
    // New version: returns false for empty keys
    if key_bytes.is_empty() {
        return Ok(smallvec![Value::bool(false)]); // New behavior - ungated!
    }
    
    // ... rest of validation
}
```

Validators on old binary: abort transaction
Validators on new binary: transaction succeeds with `false` result
Result: State divergence

---

**Notes**

While all examined native function implementations in the current codebase demonstrate proper use of feature flags and timed features, the absence of automated enforcement creates systemic risk. The vulnerability manifests through development process failure rather than exploitable code paths, but the impact (consensus divergence requiring hardfork) is critical. The recommendation focuses on defense-in-depth through technical enforcement rather than relying solely on process controls.

### Citations

**File:** aptos-move/aptos-native-interface/src/native.rs (L9-14)
```rust
/// Type alias representing a raw native function.
///
/// A raw native needs to be made into a closure that carries various configurations before
/// it can be used in the VM.
pub type RawSafeNative =
    fn(&mut SafeNativeContext, &[Type], VecDeque<Value>) -> SafeNativeResult<SmallVec<[Value; 1]>>;
```

**File:** aptos-move/framework/src/natives/mod.rs (L41-115)
```rust
pub fn all_natives(
    framework_addr: AccountAddress,
    builder: &SafeNativeBuilder,
    inject_create_signer_for_gov_sim: bool,
) -> NativeFunctionTable {
    let mut natives = vec![];

    macro_rules! add_natives_from_module {
        ($module_name:expr, $natives:expr) => {
            natives.extend(
                $natives.map(|(func_name, func)| ($module_name.to_string(), func_name, func)),
            );
        };
    }

    add_natives_from_module!("account", account::make_all(builder));
    add_natives_from_module!("create_signer", create_signer::make_all(builder));
    add_natives_from_module!("ed25519", ed25519::make_all(builder));
    add_natives_from_module!("crypto_algebra", cryptography::algebra::make_all(builder));
    add_natives_from_module!("genesis", create_signer::make_all(builder));
    add_natives_from_module!("multi_ed25519", multi_ed25519::make_all(builder));
    add_natives_from_module!("bls12381", cryptography::bls12381::make_all(builder));
    add_natives_from_module!("secp256k1", cryptography::secp256k1::make_all(builder));
    add_natives_from_module!("aptos_hash", hash::make_all(builder));
    add_natives_from_module!(
        "ristretto255",
        cryptography::ristretto255::make_all(builder)
    );
    add_natives_from_module!("type_info", type_info::make_all(builder));
    add_natives_from_module!("util", util::make_all(builder));
    add_natives_from_module!("from_bcs", util::make_all(builder));
    add_natives_from_module!("randomness", randomness::make_all(builder));
    add_natives_from_module!(
        "ristretto255_bulletproofs",
        cryptography::bulletproofs::make_all(builder)
    );
    add_natives_from_module!(
        "transaction_context",
        transaction_context::make_all(builder)
    );
    add_natives_from_module!("code", code::make_all(builder));
    add_natives_from_module!("event", event::make_all(builder));
    add_natives_from_module!("state_storage", state_storage::make_all(builder));
    add_natives_from_module!("aggregator", aggregator::make_all(builder));
    add_natives_from_module!("aggregator_factory", aggregator_factory::make_all(builder));
    add_natives_from_module!("aggregator_v2", aggregator_v2::make_all(builder));
    add_natives_from_module!("object", object::make_all(builder));
    add_natives_from_module!("debug", debug::make_all(builder));
    add_natives_from_module!("string_utils", string_utils::make_all(builder));
    add_natives_from_module!("consensus_config", consensus_config::make_all(builder));
    add_natives_from_module!("function_info", function_info::make_all(builder));
    add_natives_from_module!(
        "dispatchable_fungible_asset",
        dispatchable_fungible_asset::make_all(builder)
    );
    add_natives_from_module!(
        "permissioned_signer",
        permissioned_signer::make_all(builder)
    );
    add_natives_from_module!(
        "account_abstraction",
        account_abstraction::make_all(builder)
    );

    if inject_create_signer_for_gov_sim {
        add_natives_from_module!(
            "aptos_governance",
            builder.make_named_natives([(
                "create_signer",
                create_signer::native_create_signer as RawSafeNative
            )])
        );
    }

    make_table_from_iter(framework_addr, natives)
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L188-196)
```rust
    /// Returns a reference to the struct representing on-chain features.
    pub fn get_feature_flags(&self) -> &Features {
        self.features
    }

    /// Checks if the timed feature corresponding to the given flag is enabled.
    pub fn timed_feature_enabled(&self, flag: TimedFeatureFlag) -> bool {
        self.timed_features.is_enabled(flag)
    }
```

**File:** types/src/on_chain_config/timed_features.rs (L11-28)
```rust
#[derive(Debug, EnumCountMacro, EnumIter, Clone, Copy, Eq, PartialEq)]
pub enum TimedFeatureFlag {
    // Was always enabled.
    _LimitTypeTagSize,
    // Enabled on mainnet, cannot be disabled.
    _ModuleComplexityCheck,
    EntryCompatibility,
    ChargeBytesForPrints,

    // Fixes the bug of table natives not tracking the memory usage of the global values they create.
    FixMemoryUsageTracking,
    // Disable checking for captured option types.
    // Only when this feature is turned on, feature flag ENABLE_CAPTURE_OPTION can control whether the option type can be captured.
    DisabledCaptureOption,

    /// Fixes the bug that table natives double count the memory usage of the global values.
    FixTableNativesMemoryDoubleCounting,
}
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L395-426)
```rust
    let fix_memory_double_counting =
        context.timed_feature_enabled(TimedFeatureFlag::FixTableNativesMemoryDoubleCounting);

    let (extensions, mut loader_context, abs_val_gas_params, gas_feature_version) =
        context.extensions_with_loader_context_and_gas_params();
    let table_context = extensions.get::<NativeTableContext>();
    let mut table_data = table_context.table_data.borrow_mut();

    let val = args.pop_back().unwrap();
    let key = args.pop_back().unwrap();
    let handle = get_table_handle(&safely_pop_arg!(args, StructRef))?;

    let table =
        table_data.get_or_create_table(&mut loader_context, handle, &ty_args[0], &ty_args[2])?;

    let function_value_extension = loader_context.function_value_extension();
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);

    let (gv, loaded) =
        table.get_or_create_global_value(&function_value_extension, table_context, key_bytes)?;
    let mem_usage = if !fix_memory_double_counting || loaded.is_some() {
        gv.view()
            .map(|val| {
                abs_val_gas_params
                    .abstract_heap_size(&val, gas_feature_version)
                    .map(u64::from)
            })
            .transpose()?
    } else {
        None
    };
```

**File:** aptos-move/framework/src/natives/cryptography/ed25519.rs (L51-64)
```rust
    let key_bytes_slice = match <[u8; ED25519_PUBLIC_KEY_LENGTH]>::try_from(key_bytes) {
        Ok(slice) => slice,
        Err(_) => {
            if context
                .get_feature_flags()
                .is_enabled(FeatureFlag::ED25519_PUBKEY_VALIDATE_RETURN_FALSE_WRONG_LENGTH)
            {
                return Ok(smallvec![Value::bool(false)]);
            } else {
                return Err(SafeNativeError::Abort {
                    abort_code: abort_codes::E_WRONG_PUBKEY_SIZE,
                });
            }
        },
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L14-34)
```text
    struct Version has drop, key, store {
        major: u64,
    }

    struct SetVersionCapability has key {}

    /// Specified major version number must be greater than current version number.
    const EINVALID_MAJOR_VERSION_NUMBER: u64 = 1;
    /// Account is not authorized to make this change.
    const ENOT_AUTHORIZED: u64 = 2;

    /// Only called during genesis.
    /// Publishes the Version config.
    public(friend) fun initialize(aptos_framework: &signer, initial_version: u64) {
        system_addresses::assert_aptos_framework(aptos_framework);

        move_to(aptos_framework, Version { major: initial_version });
        // Give aptos framework account capability to call set version. This allows on chain governance to do it through
        // control of the aptos framework account.
        move_to(aptos_framework, SetVersionCapability {});
    }
```

**File:** types/src/on_chain_config/aptos_version.rs (L7-16)
```rust
/// Defines the version of Aptos Validator software.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, PartialOrd, Ord, Serialize)]
pub struct AptosVersion {
    pub major: u64,
}

impl OnChainConfig for AptosVersion {
    const MODULE_IDENTIFIER: &'static str = "version";
    const TYPE_IDENTIFIER: &'static str = "Version";
}
```

**File:** testsuite/testcases/src/compatibility_test.rs (L104-147)
```rust
        // Update the first Validator
        let msg = format!(
            "2. Upgrading first Validator to new version: {}",
            new_version
        );
        info!("{}", msg);
        ctxa.report_text(msg).await;
        batch_update_gradually(
            ctxa.clone(),
            &[first_node],
            &new_version,
            upgrade_wait_for_healthy,
            upgrade_node_delay,
            upgrade_max_wait,
        )
        .await?;
        // Generate some traffic
        {
            let mut ctx_locker = ctxa.ctx.lock().await;
            let ctx = ctx_locker.deref_mut();
            let txn_stat_one = generate_traffic(ctx, &[first_node], duration).await?;
            ctx.report.report_txn_stats(
                format!("{}::single-validator-upgrade", self.name()),
                &txn_stat_one,
            );

            // Update the rest of the first batch
            let msg = format!(
                "3. Upgrading rest of first batch to new version: {}",
                new_version
            );
            info!("{}", msg);
            ctx.report.report_text(msg);
        }

        // upgrade the rest of the first half
        batch_update_gradually(
            ctxa.clone(),
            &first_batch,
            &new_version,
            upgrade_wait_for_healthy,
            upgrade_node_delay,
            upgrade_max_wait,
        )
```
