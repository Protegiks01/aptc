# Audit Report

## Title
Unbounded Memory Growth in CaptchaManager Leading to Denial of Service

## Summary
The `CaptchaManager` struct in the Aptos faucet service stores captcha challenges in an unbounded `HashMap` without any expiration mechanism or size limits. Legitimate users who request captchas but abandon them, or attackers who deliberately request many captchas without solving them, can cause orphaned entries to accumulate indefinitely, eventually exhausting available memory and crashing the faucet service.

## Finding Description

The `CaptchaManager` maintains a `HashMap<u32, String>` to track active captcha challenges. [1](#0-0) 

When a user requests a captcha via the `/request_captcha` endpoint, a new entry is inserted into this HashMap. [2](#0-1) 

The critical issue is that captcha entries are only removed when a user submits a **correct** answer. [3](#0-2) 

This creates multiple scenarios for memory leaks:
1. **Abandoned requests**: Users who request captchas but never submit answers leave permanent entries
2. **Incorrect answers**: Users who submit wrong answers multiple timesâ€”the entry remains in the HashMap
3. **Malicious exploitation**: Attackers can deliberately request thousands of captchas without ever solving them

The developers are aware of this issue, as evidenced by an explicit warning comment. [4](#0-3) 

The `/request_captcha` endpoint has no rate limiting protection. [5](#0-4) 

The CaptchaManager is instantiated as a shared singleton across the faucet service. [6](#0-5) 

**Attack Path:**
1. Attacker sends repeated GET requests to `/request_captcha`
2. Each request creates a new HashMap entry (key: random u32, value: 5-character string)
3. Attacker never submits answers, so entries are never removed
4. Memory grows unbounded until OOM condition occurs
5. Faucet service crashes or becomes unresponsive

**Invariant Violation:**
This breaks the documented invariant: "Resource Limits: All operations must respect gas, storage, and computational limits." The captcha system allows unlimited memory consumption without bounds.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty criteria because it enables "API crashes." 

The faucet service is a critical infrastructure component for the Aptos testnet and devnet, used by developers to obtain initial tokens for testing. A crash of this service would:
- Prevent new developers from onboarding
- Disrupt CI/CD pipelines that depend on faucet availability
- Require manual intervention to restart the service
- Potentially cause data loss if the OOM killer terminates the process abruptly

While this doesn't directly affect consensus or mainnet funds, it significantly impacts the developer ecosystem and network usability.

## Likelihood Explanation

The likelihood of this vulnerability being exploited is **HIGH**:

1. **No authentication required**: The endpoint is publicly accessible
2. **No rate limiting**: Attackers can make unlimited requests
3. **Trivial exploitation**: Simple HTTP GET requests, no complex setup needed
4. **Low resource cost for attacker**: Each request is lightweight for the attacker
5. **Cumulative effect**: Even legitimate usage patterns cause gradual memory growth

Even without malicious intent, normal operational patterns can trigger this issue:
- Users who open the captcha page but navigate away
- Browser refresh/back button actions
- Automated testing that doesn't complete the captcha flow

Notably, other parts of the faucet codebase demonstrate awareness of this pattern by using `LruCache` with bounded capacity. [7](#0-6) 

## Recommendation

Implement one or more of the following mitigations:

**Option 1: Use LruCache with bounded capacity** (matches existing pattern in codebase)
```rust
use lru::LruCache;
use std::num::NonZeroUsize;

pub struct CaptchaManager {
    // Replace HashMap with LruCache
    challenges: LruCache<u32, String>,
}

impl CaptchaManager {
    pub fn new() -> Self {
        Self {
            // Limit to 10,000 concurrent captchas
            challenges: LruCache::new(NonZeroUsize::new(10000).unwrap()),
        }
    }
}
```

**Option 2: Add timestamp-based expiration**
```rust
pub struct CaptchaManager {
    challenges: HashMap<u32, (String, u64)>, // (solution, timestamp)
}

impl CaptchaManager {
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Cleanup expired entries (e.g., > 5 minutes old)
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();
        self.challenges.retain(|_, (_, ts)| now - ts < 300);
        
        // ... rest of implementation
    }
}
```

**Option 3: Add rate limiting to /request_captcha endpoint**

Apply the existing rate limiting infrastructure to protect the captcha endpoint, not just the `/fund` endpoint.

**Recommended approach**: Combine Option 1 (immediate protection) with Option 3 (defense in depth).

## Proof of Concept

```bash
#!/bin/bash
# PoC: Demonstrate memory exhaustion via captcha requests

FAUCET_URL="http://localhost:8081/request_captcha"
REQUEST_COUNT=100000

echo "Starting captcha memory exhaustion attack..."
echo "Target: $FAUCET_URL"
echo "Requests: $REQUEST_COUNT"

for i in $(seq 1 $REQUEST_COUNT); do
    curl -s "$FAUCET_URL" > /dev/null &
    
    if [ $((i % 1000)) -eq 0 ]; then
        echo "Sent $i requests..."
        # Check faucet process memory usage
        ps aux | grep aptos-faucet | grep -v grep
    fi
done

wait
echo "Attack complete. Monitor faucet service for OOM conditions."
```

**Expected behavior**: After several thousand requests, the faucet process memory usage will grow continuously. With sufficient requests (depending on available system memory), the service will either:
- Crash with OOM error
- Become unresponsive due to memory pressure
- Be killed by the OS OOM killer

**Verification**: Monitor memory usage with `ps aux` or `top` while running the PoC. Observe that memory consumption grows linearly with the number of captcha requests and never decreases (unless correct answers are submitted).

---

**Notes**

This vulnerability is particularly concerning because:
1. The developers explicitly documented awareness of the issue but haven't implemented a fix
2. The same codebase contains the correct pattern (`LruCache` in `MemoryRatelimitChecker`) that could be applied here
3. The faucet is a public-facing service with no authentication, making it an easy target
4. The impact compounds over time, potentially causing issues during periods of high legitimate usage

The fix is straightforward and should be prioritized given the public nature of the faucet service and its importance to the developer ecosystem.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L4-6)
```rust
//! Warning: This could be attacked and cause the server to OOM because we
//! don't throw out captchas info if it has been sitting there for too long /
//! the map grows too large.
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L125-131)
```rust
#[derive(Debug, Default)]
pub struct CaptchaManager {
    /// When a challenge is created, we return to the client the captcha itself
    /// and a random key they must make the second request with. This is a map
    /// from that random key to the value of the captcha.
    challenges: HashMap<u32, String>,
}
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L142-162)
```rust
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Generate a random key.
        let key = rand::thread_rng().gen_range(0, u32::MAX - 1);

        // Generate a captcha.
        let (name, image) = Captcha::new()
            .add_chars(5)
            .apply_filter(Noise::new(0.4))
            .apply_filter(Wave::new(4.0, 6.0).vertical())
            .apply_filter(Wave::new(3.0, 2.0).horizontal())
            .apply_filter(Grid::new(10, 6))
            .apply_filter(Dots::new(8))
            .as_tuple()
            .context("Failed to generate captcha")?;

        // Store the captcha information.
        self.challenges.insert(key, name);

        // Return (key, <captcha as base64>).
        Ok((key, image))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L165-177)
```rust
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L40-58)
```rust
    async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
        if !self.enabled {
            return Err(AptosTapError::new(
                "The CaptchaChecker is not enabled".to_string(),
                AptosTapErrorCode::EndpointNotEnabled,
            )
            .into());
        }
        let mut captcha_manager = self.captcha_manager.lock().await;
        let (key, image) = match captcha_manager.create_challenge() {
            Ok((key, image)) => (key, image),
            Err(e) => {
                return Err(
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
                );
            },
        };
        Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L111-112)
```rust
        // Create a CaptchaManager.
        let captcha_manager = Arc::new(Mutex::new(CaptchaManager::new()));
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L29-42)
```rust
/// Simple in memory storage that rejects if we've ever seen a request from an
/// IP that has succeeded. This does not support JWT-based ratelimiting.
pub struct MemoryRatelimitChecker {
    pub max_requests_per_day: u32,

    /// Map of IP to how many requests they've submitted today (where the
    /// response wasn't a 500). To avoid OOMing the server, we set a limit
    /// on how many entries we have in the table.
    pub ip_to_requests_today: Mutex<LruCache<IpAddr, u32>>,

    /// Used for tracking daily ratelimit. See the comment in RedisRatelimitChecker
    /// for more information on how we track daily limits.
    pub current_day: AtomicU64,
}
```
