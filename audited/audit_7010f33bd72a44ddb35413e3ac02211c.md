# Audit Report

## Title
Transaction Hash Collision Causes Permanent Data Accessibility Loss Through Storage Index Corruption

## Summary
When two transactions produce the same SHA3-256 hash (H), the `TransactionByHashSchema` index overwrites the version mapping, making the first transaction permanently unfindable via hash-based lookups. Additionally, when the first transaction is pruned, it incorrectly deletes the hash index for the second transaction, causing permanent accessibility loss for both transactions.

## Finding Description

The Aptos storage layer uses `TransactionByHashSchema` to map transaction hashes to their versions for fast lookup. [1](#0-0) 

When transactions are committed, the system stores a mapping from hash to version without collision detection. [2](#0-1) 

The underlying storage uses RocksDB's key-value semantics where subsequent `put` operations with the same key overwrite previous values. [3](#0-2) 

**Attack Scenario:**
1. Transaction A is committed at version 100 with hash H
2. `TransactionByHashSchema[H] = 100` is stored
3. Transaction B is committed at version 200 with the same hash H (collision)
4. `TransactionByHashSchema[H] = 200` overwrites the previous mapping
5. `get_transaction_by_hash(H)` now returns Transaction B instead of Transaction A

**Pruning Amplifies the Issue:**

When Transaction A is pruned, the pruner computes its hash and deletes the index entry. [4](#0-3) 

The deletion operation removes `TransactionByHashSchema[H]` entirely. [5](#0-4) 

This makes Transaction B (version 200) also unfindable by hash, even though it remains stored and unpruned.

**Why This Breaks System Guarantees:**

The `get_transaction_by_hash` API is documented as "best-effort" but is relied upon by:
- REST API endpoints serving transaction data [6](#0-5) 
- Block explorers and indexers
- Transaction confirmation workflows
- Wallets verifying transaction status

Transaction data remains stored by version and is not corrupted, but becomes effectively lost to users querying by hash.

## Impact Explanation

**Severity: Medium**

Per Aptos bug bounty criteria, this qualifies as Medium severity:
- **Data accessibility loss**: Transactions become unfindable via hash lookup
- **State inconsistency requiring intervention**: Manual recovery requires finding transactions by version range search
- **Limited service disruption**: APIs return wrong transaction or no transaction

This does NOT qualify as Critical or High because:
- No funds are lost or stolen
- No consensus safety violation occurs (transaction accumulator remains intact)
- Both transactions remain stored and retrievable by version
- No validator node slowdown or crashes

## Likelihood Explanation

**Current Likelihood: Negligible (computationally infeasible)**

SHA3-256 collision requires approximately 2^128 hash computations (birthday bound), which is:
- Beyond capability of any known adversary
- Would take billions of years with current supercomputers
- Infeasible even with anticipated quantum computers

**However, likelihood could increase if:**
- Cryptographic vulnerabilities are discovered in SHA3-256/Keccak
- Quantum computing advances dramatically
- Pre-image or collision attacks become practical

The vulnerability represents a **latent design flaw** that would manifest if hash collisions become feasible.

## Recommendation

Implement collision-resistant storage design:

**Option 1: Composite Key (Recommended)**
Change `TransactionByHashSchema` to use `(HashValue, Version)` as the key, storing all versions that map to the same hash.

**Option 2: Append-Only List**
Store `Vec<Version>` as the value, appending new versions instead of overwriting:
```rust
pub(crate) fn put_transaction(...) {
    let mut versions = self.db.get::<TransactionByHashSchema>(&transaction_hash)?
        .unwrap_or_default();
    versions.push(version);
    batch.put::<TransactionByHashSchema>(&transaction_hash, &versions)?;
}
```

**Option 3: Collision Detection**
Add validation to reject transactions with duplicate hashes:
```rust
if let Some(existing_version) = self.db.get::<TransactionByHashSchema>(&transaction_hash)? {
    return Err(AptosDbError::HashCollision(transaction_hash, existing_version, version));
}
```

## Proof of Concept

Due to the computational infeasibility of generating SHA3-256 collisions, a realistic PoC cannot be demonstrated. A synthetic test would require:

```rust
#[test]
fn test_hash_collision_overwrites_index() {
    // This test would require artificially creating two transactions
    // with the same hash, which is not possible with SHA3-256
    // 
    // Pseudocode:
    // 1. Create Transaction A at version 100
    // 2. Artificially set its hash to H (bypassing hash computation)
    // 3. Commit to database
    // 4. Create Transaction B at version 200  
    // 5. Artificially set its hash to H
    // 6. Commit to database
    // 7. Assert get_transaction_by_hash(H) returns version 200, not 100
    // 8. Prune version 100
    // 9. Assert get_transaction_by_hash(H) returns None
}
```

The issue is **theoretically valid** but **practically unexploitable** with current cryptography.

## Notes

While this represents a design weakness in the storage layer, it does **not** constitute an immediately exploitable vulnerability due to the cryptographic strength of SHA3-256. The issue should be considered a **low-priority hardening opportunity** rather than an urgent security fix, unless:

1. Cryptographic research reveals SHA3-256 weaknesses
2. The system needs to maintain long-term (>50 year) security guarantees
3. Quantum-resistant cryptography becomes necessary

The transaction accumulator and consensus mechanisms remain secure because they hash `TransactionInfo` objects (which include execution results), not raw transaction hashes, ensuring consensus safety is maintained even in the theoretical collision scenario.

### Citations

**File:** storage/aptosdb/src/schema/transaction_by_hash/mod.rs (L23-28)
```rust
define_schema!(
    TransactionByHashSchema,
    HashValue,
    Version,
    TRANSACTION_BY_HASH_CF_NAME
);
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L162-162)
```rust
        batch.put::<TransactionByHashSchema>(&transaction_hash, &version)?;
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L182-190)
```rust
    pub(crate) fn prune_transaction_by_hash_indices(
        &self,
        transaction_hashes: impl Iterator<Item = HashValue>,
        db_batch: &mut SchemaBatch,
    ) -> Result<()> {
        for hash in transaction_hashes {
            db_batch.delete::<TransactionByHashSchema>(&hash)?;
        }
        Ok(())
```

**File:** storage/schemadb/src/batch.rs (L99-106)
```rust
    fn put<S: Schema>(&mut self, key: &S::Key, value: &S::Value) -> DbResult<()> {
        let key = <S::Key as KeyCodec<S>>::encode_key(key)?;
        let value = <S::Value as ValueCodec<S>>::encode_value(value)?;

        self.stats()
            .put(S::COLUMN_FAMILY_NAME, key.len() + value.len());
        self.raw_put(S::COLUMN_FAMILY_NAME, key, value)
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L41-46)
```rust
        self.ledger_db
            .transaction_db()
            .prune_transaction_by_hash_indices(
                candidate_transactions.iter().map(|(_, txn)| txn.hash()),
                &mut batch,
            )?;
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L231-245)
```rust
    /// This API is best-effort in that it CANNOT provide absence proof.
    fn get_transaction_by_hash(
        &self,
        hash: HashValue,
        ledger_version: Version,
        fetch_events: bool,
    ) -> Result<Option<TransactionWithProof>> {
        gauged_api("get_transaction_by_hash", || {
            self.ledger_db
                .transaction_db()
                .get_transaction_version_by_hash(&hash, ledger_version)?
                .map(|v| self.get_transaction_with_proof(v, ledger_version, fetch_events))
                .transpose()
        })
    }
```
