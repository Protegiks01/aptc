# Audit Report

## Title
Missing Ciphertext Verification in Consensus Decryption Pipeline Allows Stale Proof Retrieval

## Summary
The `eval_proof_for_ct()` function does not verify ciphertext integrity before retrieving eval proofs, and the consensus decryption pipeline fails to call `verify_ct()` as required by the trait documentation. This violates defense-in-depth principles, though exploitation is mitigated by upstream validation layers.

## Finding Description

The batch threshold encryption scheme has a critical design flaw where `eval_proof_for_ct()` retrieves proofs based solely on the ciphertext's ID field without any integrity verification. [1](#0-0) 

The ciphertext ID is stored as a mutable struct field, not derived cryptographically from the ciphertext content at lookup time: [2](#0-1) [3](#0-2) 

The trait documentation explicitly states that validators MUST verify ciphertexts before decryption: [4](#0-3) 

However, the consensus decryption pipeline does NOT call `verify_ct()` before using ciphertexts: [5](#0-4) 

While the API layer does perform verification at submission time: [6](#0-5) 

The consensus layer has no re-verification, creating a single point of failure if upstream validation is bypassed.

## Impact Explanation

**Severity Assessment: Medium**

The vulnerability violates stated security invariants and defense-in-depth principles, but practical exploitation is significantly constrained by:

1. **Ed25519 signatures** binding the entire bibe_ct structure to the ciphertext wrapper [7](#0-6) 

2. **Transaction sender signatures** preventing proposers from modifying transaction payloads

3. **API-level verification** catching malformed ciphertexts at submission [8](#0-7) 

However, this design creates risk if:
- A bug exists in upstream validation layers
- A Byzantine validator finds an alternative injection path
- Future code changes weaken validation elsewhere

The lack of verification violates the "Validators *must* verify" requirement and breaks **defense-in-depth**, a critical security principle for consensus systems.

## Likelihood Explanation

**Likelihood: Low-Medium**

Direct exploitation requires bypassing multiple protection layers (API validation, transaction signatures, Ed25519 ciphertext signatures). No known bypass exists currently.

However, the violation of stated requirements and missing verification in a critical consensus path increases risk of future exploitation if:
- Validation bugs are introduced elsewhere
- New transaction submission paths are added
- Signature schemes are modified

## Recommendation

Add mandatory ciphertext verification in the consensus decryption pipeline:

```rust
// In decrypt_encrypted_txns function, before line 92:
for (txn, ct) in encrypted_txns.iter().zip(&txn_ciphertexts) {
    let sender = txn.sender();
    let associated_data = PayloadAssociatedData::new(sender);
    FPTXWeighted::verify_ct(&ct, &associated_data)
        .context("Ciphertext verification failed during decryption")?;
}
```

Additionally, consider modifying `eval_proof_for_ct()` to perform verification or return `Result<Option<EvalProof>, Error>` instead of `Option<EvalProof>` to make verification mandatory at the API level.

## Proof of Concept

The vulnerability cannot be exploited with current protections in place. To demonstrate the design flaw:

```rust
#[test]
fn test_eval_proof_for_ct_no_verification() {
    // This test shows eval_proof_for_ct() retrieves proofs without verification
    let mut rng = thread_rng();
    let tc = ShamirThresholdConfig::new(1, 1);
    let (ek, dk, _, _) = FPTX::setup_for_testing(rng.gen(), 8, 1, &tc).unwrap();
    
    let ct = ek.encrypt(&mut rng, &"msg".to_string(), &"data".to_string()).unwrap();
    let (digest, pfs_promise) = FPTX::digest(&dk, &vec![ct.clone()], 0).unwrap();
    let pfs = FPTX::eval_proofs_compute_all(&pfs_promise, &dk);
    
    // Proof retrieval succeeds without any verification call
    let proof = FPTX::eval_proof_for_ct(&pfs, &ct);
    assert!(proof.is_some()); // Succeeds without verify_ct() call
    
    // If ciphertext could be modified (hypothetically, ignoring signatures),
    // the same proof would still be retrieved based on ID alone
}
```

**Note:** This demonstrates the design flaw but cannot bypass the signature protections that prevent actual exploitation in production.

### Citations

**File:** crates/aptos-batch-encryption/src/schemes/fptx.rs (L137-142)
```rust
    fn eval_proof_for_ct(
        proofs: &Self::EvalProofs,
        ct: &Self::Ciphertext,
    ) -> Option<Self::EvalProof> {
        proofs.get(&ct.id())
    }
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L41-48)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, Hash, Eq, PartialEq)]
pub struct BIBECiphertext {
    pub id: Id,
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    ct_g2: [G2Affine; 3],
    padded_key: OneTimePaddedKey,
    symmetric_ciphertext: SymmetricCiphertext,
}
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L80-82)
```rust
    fn id(&self) -> Id {
        self.id
    }
```

**File:** crates/aptos-batch-encryption/src/traits.rs (L106-109)
```rust
    /// Validators *must* verify each ciphertext before approving it to be decrypted, in order to
    /// prevent malleability attacks. Verification happens w.r.t. some associated data that was
    /// passed into the encrypt fn.
    fn verify_ct(ct: &Self::Ciphertext, associated_data: &impl AssociatedData) -> Result<()>;
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L121-148)
```rust
        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```

**File:** api/src/transactions.rs (L1340-1346)
```rust
                if let Err(e) = payload.verify(signed_transaction.sender()) {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        e.context("Encrypted transaction payload could not be verified"),
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L23-31)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, Eq, PartialEq)]
#[serde(bound(deserialize = "PCT: DeserializeOwned"))]
pub struct Ciphertext<PCT: InnerCiphertext> {
    vk: VerifyingKey,
    bibe_ct: PCT,
    #[serde(with = "serde_bytes")]
    associated_data_bytes: Vec<u8>,
    signature: Signature,
}
```

**File:** types/src/transaction/encrypted_payload.rs (L147-150)
```rust
    pub fn verify(&self, sender: AccountAddress) -> anyhow::Result<()> {
        let associated_data = PayloadAssociatedData::new(sender);
        self.ciphertext().verify(&associated_data)
    }
```
