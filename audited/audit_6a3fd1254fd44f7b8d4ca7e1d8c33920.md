# Audit Report

## Title
Critical Information Disclosure: Validator Private Key Leakage via Symlink Following in Move CLI

## Summary
The Move CLI's file discovery mechanism unconditionally follows symbolic links when collecting `.move` source files, allowing an attacker to create a malicious Move package that exfiltrates sensitive files (including validator private keys) through compilation error messages when tested on a validator node.

## Finding Description

The vulnerability exists in the Move CLI's file collection mechanism, which uses `walkdir` with symlink following enabled. When combined with the compiler's diagnostic system that includes source file contents in error messages, this creates a critical information disclosure vulnerability.

**Vulnerable Code Path:**

The `find_filenames()` function unconditionally follows symbolic links: [1](#0-0) 

When the Move compiler encounters a parsing error, it reports diagnostics that include the source file contents: [2](#0-1) 

**Attack Scenario:**

1. Attacker creates a malicious Move package and adds a symbolic link in the `sources/` directory:
   ```bash
   ln -s /opt/aptos/genesis/validator-identity.yaml sources/validator_keys.move
   ```

2. Attacker publishes this package to GitHub as a "useful validator utility library"

3. A validator operator clones the repository to their validator node to evaluate or test the package

4. When they run `move test` or `move build`, the Move CLI:
   - Discovers `sources/validator_keys.move` (the symlink)
   - Follows the symlink to `/opt/aptos/genesis/validator-identity.yaml`
   - Reads the validator's private key file
   - Attempts to parse the YAML content as Move code
   - Fails with compilation errors
   - **Displays the file contents in the error message**

5. The attacker now has access to the validator's private keys displayed in the terminal output or CI/CD logs

**Exposed Sensitive Data:**

The `validator-identity.yaml` file contains critical cryptographic material: [3](#0-2) 

This includes:
- `account_private_key` (Ed25519) - used to sign transactions as the validator
- `consensus_private_key` (BLS12-381) - used to sign consensus votes and proposals  
- `network_private_key` (x25519) - used for authenticated network communication

## Impact Explanation

**Severity: Critical ($1,000,000 tier)**

This vulnerability enables complete validator compromise through the following attack vectors:

1. **Consensus Safety Violation**: With the consensus private key, an attacker can:
   - Sign malicious votes and proposals
   - Participate in Byzantine attacks
   - Violate BFT safety assumptions if combined with other compromised validators

2. **Loss of Funds**: With the account private key, an attacker can:
   - Sign transactions to withdraw staked funds
   - Transfer validator rewards
   - Manipulate on-chain validator registration

3. **Network Impersonation**: With the network private key, an attacker can:
   - Impersonate the validator to other nodes
   - Inject malicious messages into the validator network
   - Disrupt consensus communication

This breaks the **Access Control** invariant (Invariant #8): "System addresses (@aptos_framework, @core_resources) must be protected." While the invariant focuses on on-chain addresses, the underlying principle of protecting critical security materials is violated when validator keys are exposed.

The vulnerability also enables a **supply chain attack** vector against the Aptos validator ecosystem, as malicious packages can be disguised as legitimate utilities or libraries.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is feasible because:

1. **No Code Changes Required**: The Move CLI behavior is as-designed; symlink following is explicitly enabled [4](#0-3) 

2. **Common Workflow**: Validator operators routinely:
   - Test Move packages for governance proposals
   - Evaluate third-party libraries
   - Run CI/CD pipelines with `move test`
   - Clone and build packages from community repositories

3. **Git Preserves Symlinks**: When a symlink is committed to Git, cloning preserves the link target, making distribution trivial

4. **No Warning or Validation**: The CLI provides no indication that symlinks are being followed or that non-Move files are being read

5. **Standard File Paths**: Validator identity files use predictable paths: [5](#0-4) 

The primary barrier is social engineering (convincing the operator to test the malicious package), but this is realistic in the context of supply chain attacks where packages are presented as legitimate utilities.

## Recommendation

**Immediate Mitigation:**

1. **Disable Symlink Following**: Modify `find_filenames()` to not follow symlinks, or at minimum, detect and warn when symlinks point outside the package directory:

```rust
pub fn find_filenames<Predicate: FnMut(&Path) -> bool>(
    paths: &[impl AsRef<Path>],
    mut is_file_desired: Predicate,
) -> anyhow::Result<Vec<String>> {
    let mut result = vec![];

    for s in paths {
        let path = s.as_ref();
        if !path.exists() {
            bail!("No such file or directory '{}'", path.to_string_lossy())
        }
        if path.is_file() && is_file_desired(path) {
            result.push(path_to_string(path)?);
            continue;
        }
        if !path.is_dir() {
            continue;
        }
        for entry in walkdir::WalkDir::new(path)
            .follow_links(false)  // CHANGE: Disable symlink following
            .into_iter()
            .filter_map(|e| e.ok())
        {
            let entry_path = entry.path();
            
            // Reject symlinks
            if entry_path.is_symlink() {
                bail!("Symbolic links are not allowed in Move packages: {}", 
                      entry_path.display());
            }
            
            if !entry.file_type().is_file() || !is_file_desired(entry_path) {
                continue;
            }

            result.push(path_to_string(entry_path)?);
        }
    }
    Ok(result)
}
```

2. **Validate Package Integrity**: Before reading any files, verify that all `.move` files are:
   - Real files (not symlinks)
   - Contained within the package directory tree
   - Have reasonable file sizes

3. **Sanitize Error Messages**: Consider limiting the amount of source code shown in error messages, or implement a mechanism to detect and redact sensitive patterns (though this is defense-in-depth, not a primary fix).

**Long-term Solutions:**

1. **Package Signing**: Implement cryptographic signing for Move packages to establish trust chains
2. **Sandboxing**: Run Move compilation in a sandboxed environment with restricted filesystem access
3. **Security Scanning**: Develop tooling to scan Move packages for suspicious patterns (symlinks, unusual file access, etc.)

## Proof of Concept

**Setup:**
1. On a system with Move CLI installed, create a test validator identity file:
```bash
mkdir -p /tmp/fake-validator-keys
cat > /tmp/fake-validator-keys/validator-identity.yaml << 'EOF'
account_address: "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef"
account_private_key: "0x1111111111111111111111111111111111111111111111111111111111111111"
consensus_private_key: "0x2222222222222222222222222222222222222222222222222222222222222222"
network_private_key: "0x3333333333333333333333333333333333333333333333333333333333333333"
EOF
```

2. Create a malicious Move package:
```bash
mkdir -p /tmp/malicious-package/sources
cd /tmp/malicious-package

cat > Move.toml << 'EOF'
[package]
name = "MaliciousPackage"
version = "0.1.0"

[addresses]
malicious = "0x1"

[dependencies]
MoveStdlib = { git = "https://github.com/aptos-labs/aptos-core.git", subdir = "aptos-move/framework/move-stdlib", rev = "main" }
EOF

# Create the symlink attack
ln -s /tmp/fake-validator-keys/validator-identity.yaml sources/keys.move
```

3. Run the Move CLI:
```bash
cd /tmp/malicious-package
move test
```

**Expected Result:**
The compilation will fail with errors that include the contents of `validator-identity.yaml`, displaying all the private keys in the error message output.

**Actual Output Example:**
```
error: unexpected token
   ┌─ sources/keys.move:1:1
   │
 1 │ account_address: "0xdeadbeef..."
 2 │ account_private_key: "0x1111..."
 3 │ consensus_private_key: "0x2222..."
   │ ^^^^^^^ unexpected token
```

This demonstrates that the symlink is followed, the sensitive file is read, and its contents are displayed in compilation errors, confirming the vulnerability.

**Notes:**

- This attack works regardless of whether the validator keys are stored in the standard locations (`/opt/aptos/genesis/`) or custom paths, as the attacker can create multiple symlinks targeting common paths
- The vulnerability affects all Move CLI commands that compile code: `build`, `test`, `prove`, `disassemble`, etc.
- The issue is exacerbated by CI/CD pipelines that may automatically log all output, persisting the leaked keys in build logs
- While the example uses fake keys, the same attack works against real validator nodes with actual private keys

### Citations

**File:** third_party/move/move-command-line-common/src/files.rs (L80-91)
```rust
        for entry in walkdir::WalkDir::new(path)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok())
        {
            let entry_path = entry.path();
            if !entry.file_type().is_file() || !is_file_desired(entry_path) {
                continue;
            }

            result.push(path_to_string(entry_path)?);
        }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/mod.rs (L122-134)
```rust
fn output_diagnostics<W: WriteColor>(
    writer: &mut W,
    sources: &FilesSourceText,
    diags: Diagnostics,
) {
    let mut files = SimpleFiles::new();
    let mut file_mapping = HashMap::new();
    for (fhash, (fname, source)) in sources {
        let id = files.add(*fname, source.as_str());
        file_mapping.insert(*fhash, id);
    }
    render_diagnostics(writer, &files, &file_mapping, diags);
}
```

**File:** config/src/config/identity_config.rs (L24-37)
```rust
#[derive(Deserialize, Serialize)]
pub struct IdentityBlob {
    /// Optional account address. Used for validators and validator full nodes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_address: Option<AccountAddress>,
    /// Optional account key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_private_key: Option<Ed25519PrivateKey>,
    /// Optional consensus key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consensus_private_key: Option<bls12381::PrivateKey>,
    /// Network private key. Peer id is derived from this if account address is not present
    pub network_private_key: x25519::PrivateKey,
}
```

**File:** docker/compose/aptos-node/validator.yaml (L1-5)
```yaml
base:
  role: "validator"
  data_dir: "/opt/aptos/data"
  waypoint:
    from_file: "/opt/aptos/genesis/waypoint.txt"
```
