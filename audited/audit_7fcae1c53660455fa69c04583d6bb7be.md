# Audit Report

## Title
Referer Blocklist Bypass via URL Scheme and Path Manipulation in Aptos Faucet

## Summary
The `RefererBlocklistChecker` in the Aptos faucet performs exact string matching on the full Referer header value without extracting the domain name. If administrators populate the blocklist with domain names only (e.g., "malicious.com"), attackers can bypass the check by including URL schemes, paths, or query parameters (e.g., "https://malicious.com/page").

## Finding Description
The vulnerability exists in the referer validation logic that is intended to prevent abuse of the Aptos testnet faucet by blocking requests from specific domains.

The `RefererBlocklistChecker.check()` function extracts the raw Referer header value and passes it directly to `ListManager.contains()` for validation: [1](#0-0) 

The `ListManager` uses a `HashSet<String>` for exact string matching: [2](#0-1) 

**Attack Scenario:**

1. Administrator adds "malicious.com" to the blocklist file, intending to block all requests from that domain
2. A webpage at `https://malicious.com/abuse` makes a request to the faucet  
3. The browser sends `Referer: https://malicious.com/abuse`
4. The checker compares `"https://malicious.com/abuse"` against `"malicious.com"`
5. The exact string match fails, returning false
6. The request is allowed through, bypassing the blocklist

**Bypass Variations:**
- Different schemes: `http://malicious.com`, `https://malicious.com`, `ftp://malicious.com`, `//malicious.com`
- With paths: `https://malicious.com/page`, `https://malicious.com/abuse/endpoint`
- With query parameters: `https://malicious.com?param=value`
- With fragments: `https://malicious.com#section`

## Impact Explanation
This is classified as **Medium Severity** (up to $10,000) under "Limited funds loss or manipulation" because:

- The faucet dispenses testnet tokens that have no monetary value on mainnet
- The bypass allows increased abuse of faucet resources beyond intended rate limits
- Persistent abuse could deplete testnet faucet reserves faster than intended, affecting legitimate developer access
- Does not impact mainnet funds, consensus, validator operations, or core blockchain functionality
- Faucet can be refilled and does not require a hardfork to remediate

The vulnerability is limited to the faucet's abuse prevention mechanism and does not break any of the critical blockchain invariants related to consensus safety, Move VM execution, state consistency, or governance integrity.

## Likelihood Explanation
**High Likelihood** - This bypass will occur whenever:

1. Administrators use domain-only entries in the blocklist (a natural and intuitive approach)
2. Browsers automatically include full URLs with schemes in Referer headers (standard behavior)
3. Attackers discover the blocklist is bypassable (requires minimal reconnaissance)

The attack requires no special privileges, complex timing, or validator accessâ€”just making HTTP requests with standard browser Referer headers.

## Recommendation
Extract and normalize the domain name from the Referer header before checking against the blocklist:

```rust
use url::Url;

async fn check(
    &self,
    data: CheckerData,
    _dry_run: bool,
) -> Result<Vec<RejectionReason>, AptosTapError> {
    let referer = match data.headers.get(REFERER).and_then(|v| v.to_str().ok()) {
        Some(referer) => referer,
        None => return Ok(vec![]),
    };
    
    // Parse the URL and extract the host/domain
    let domain = match Url::parse(referer) {
        Ok(url) => match url.host_str() {
            Some(host) => host,
            None => return Ok(vec![]), // No host in URL, allow through
        },
        Err(_) => {
            // If parsing fails, try checking the raw string as fallback
            // for backwards compatibility with exact URL entries
            referer
        }
    };
    
    if self.manager.contains(domain) {
        Ok(vec![RejectionReason::new(
            format!(
                "The provided referer domain is not allowed by the server: {}",
                domain
            ),
            RejectionReasonCode::RefererBlocklisted,
        )])
    } else {
        Ok(vec![])
    }
}
```

This approach:
- Extracts the domain from full URLs
- Maintains backward compatibility with exact URL entries in the blocklist
- Normalizes different schemes to the same domain
- Handles malformed URLs gracefully

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::common::ListManagerConfig;
    use std::fs::File;
    use std::io::Write;
    use std::sync::Arc;
    use poem::http::HeaderMap;
    
    #[tokio::test]
    async fn test_referer_blocklist_bypass() {
        // Create a temporary blocklist file with domain-only entry
        let blocklist_path = "/tmp/test_referer_blocklist.txt";
        let mut file = File::create(blocklist_path).unwrap();
        writeln!(file, "malicious.com").unwrap();
        drop(file);
        
        // Initialize the checker
        let config = ListManagerConfig {
            file: blocklist_path.into(),
        };
        let checker = RefererBlocklistChecker::new(config).unwrap();
        
        // Test 1: Exact domain match (should block)
        let mut headers = HeaderMap::new();
        headers.insert(REFERER, "malicious.com".parse().unwrap());
        let data = CheckerData {
            time_request_received_secs: 0,
            receiver: AccountAddress::random(),
            source_ip: "127.0.0.1".parse().unwrap(),
            headers: Arc::new(headers),
        };
        let result = checker.check(data, false).await.unwrap();
        assert!(!result.is_empty(), "Exact domain should be blocked");
        
        // Test 2: URL with https scheme (BYPASSES - vulnerability)
        let mut headers = HeaderMap::new();
        headers.insert(REFERER, "https://malicious.com".parse().unwrap());
        let data = CheckerData {
            time_request_received_secs: 0,
            receiver: AccountAddress::random(),
            source_ip: "127.0.0.1".parse().unwrap(),
            headers: Arc::new(headers),
        };
        let result = checker.check(data, false).await.unwrap();
        assert!(result.is_empty(), "https:// scheme BYPASSES the blocklist!");
        
        // Test 3: URL with http scheme (BYPASSES - vulnerability)
        let mut headers = HeaderMap::new();
        headers.insert(REFERER, "http://malicious.com/page".parse().unwrap());
        let data = CheckerData {
            time_request_received_secs: 0,
            receiver: AccountAddress::random(),
            source_ip: "127.0.0.1".parse().unwrap(),
            headers: Arc::new(headers),
        };
        let result = checker.check(data, false).await.unwrap();
        assert!(result.is_empty(), "http:// scheme with path BYPASSES the blocklist!");
        
        std::fs::remove_file(blocklist_path).ok();
    }
}
```

## Notes

This vulnerability is specific to the **Aptos Faucet** service, which is a testnet developer tool and not part of the core blockchain consensus, execution, or state management systems. While the bug is real and exploitable, it has limited security impact because:

1. It only affects testnet token distribution, not mainnet funds
2. It does not compromise consensus safety, Move VM execution, or blockchain state integrity  
3. It is an operational abuse prevention bypass rather than a critical protocol vulnerability

The fix should be prioritized for operational reasons (preventing faucet abuse), but this does not rise to the level of critical blockchain security issues like consensus violations or fund theft on mainnet.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/referer_blocklist.rs (L36-40)
```rust
        let referer = match data.headers.get(REFERER).and_then(|v| v.to_str().ok()) {
            Some(referer) => referer,
            None => return Ok(vec![]),
        };
        if self.manager.contains(referer) {
```

**File:** crates/aptos-faucet/core/src/common/list_manager.rs (L35-37)
```rust
    pub fn contains(&self, item: &str) -> bool {
        self.items.contains(item)
    }
```
