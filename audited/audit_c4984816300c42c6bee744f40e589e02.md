# Audit Report

## Title
Layout Cache Race Condition Causes Non-Deterministic Execution and Consensus Divergence

## Summary
A race condition in the Move VM's layout cache allows validators to execute transactions with different struct layouts for the same `StructKey` when modules are published during block execution. The race occurs between cache flushes (during sequential commit) and cache insertions (during parallel execution), causing validators with different thread scheduling to compute different state roots for identical blocks, violating consensus safety.

## Finding Description

The vulnerability exists in the interaction between parallel transaction execution and the global layout cache. The critical flaw is that `store_layout_to_cache()` can insert stale layouts into the cache **after** the cache has been flushed due to module publishing, and these stale layouts lack version information to detect they were computed from outdated module definitions.

### Architecture Overview

The layout cache stores computed struct layouts keyed by `(StructNameIndex, TypeArgsId)`. [1](#0-0) 

The cache uses `DashMap` for concurrent access: [2](#0-1) 

### The Race Condition Mechanism

**Step 1**: Layout computation and caching happens during parallel transaction execution via `store_layout_to_cache`: [3](#0-2) 

**Step 2**: Cache flush happens during sequential commit when modules are published: [4](#0-3) 

**Step 3**: The actual cache store uses `DashMap::entry()` which only inserts if vacant: [5](#0-4) 

### The Critical Flaw

The `StructNameIndex` is reused across module versions - it represents the struct NAME, not a specific module version. The index is based solely on (address, module_name, struct_name) without version information: [6](#0-5) 

When a layout is loaded from cache, modules are re-read for gas charging but the **layout structure itself is not recomputed**: [7](#0-6) 

The `LayoutCacheEntry` stores only the layout and module IDs, with **no version information**: [8](#0-7) 

### Exploitation Scenario

Consider a block with transactions where T15 publishes module M v2:

**Validator A** (unlucky thread timing):
1. Thread 1 starts executing T5, computes layout `L_old` from module M v1
2. T15 commits sequentially, publishes M v2, marks M as overridden: [9](#0-8) 
3. T15 flushes layout cache: [10](#0-9) 
4. Thread 1's `store_layout_to_cache(L_old)` completes - cache is vacant after flush, **inserts L_old**
5. Thread 2 executes T20, loads `L_old` from cache
6. T20 re-reads module M from per-block cache (gets M v2): [11](#0-10) 
7. T5 validation fails because M was overridden: [12](#0-11) 
8. T20 validation passes because it read M v2 from per-block cache: [13](#0-12) 
9. **T20 commits with L_old layout structure but M v2 module bytecode**

**Validator B** (lucky thread timing):
1. Cache flush completes before Thread 1's store
2. Thread 2 computes fresh layout `L_new` from M v2
3. All transactions use correct layout

**Result**: Validator A and Validator B compute **different state roots** for the same block!

## Impact Explanation

This is a **Critical Severity** vulnerability (Consensus/Safety violation) per Aptos bug bounty categories because:

1. **Breaks Deterministic Execution Invariant**: Validators produce different state roots for identical blocks based on non-deterministic thread scheduling
2. **Consensus Safety Violation**: Different validators commit different states, causing potential chain splits without any Byzantine behavior
3. **Affects All Validators**: Any validator can be affected during normal operation
4. **No Byzantine Behavior Required**: Occurs during legitimate parallel execution of valid transactions
5. **Silent Corruption**: The module read validation passes even with stale layouts because it only checks if modules are overridden or versions match, not if layouts were computed from those module versions

The vulnerability manifests whenever:
- A block contains module publishing transactions (common during framework upgrades)
- Parallel execution is enabled (default in production)
- Transactions after the module publish use structs from the published module
- Different validators have different thread scheduling patterns

## Likelihood Explanation

**High Likelihood** of occurrence:

1. **Common Trigger**: Module upgrades are regular operations on Aptos (framework upgrades, dapp deployments)
2. **Parallel Execution Default**: All production validators use parallel execution (BlockSTM)
3. **Non-Deterministic Timing**: Thread scheduling varies between validator hardware, OS scheduling, and system load
4. **No Special Crafting Required**: Any normal block with module publishing can trigger this
5. **Persistent Once Cached**: Once a stale layout enters the cache, it persists until the next flush, affecting multiple subsequent blocks

The race window exists between cache flush completion and pending `store_layout_to_cache()` calls from transactions that started before the flush.

## Recommendation

Add version tracking to layout cache entries to detect when layouts were computed from outdated module definitions:

1. **Store module versions in LayoutCacheEntry**: Include transaction indices or version numbers for all modules used to construct the layout
2. **Validate layout versions on cache hit**: When loading from cache, verify that all modules used to construct the layout match their current versions
3. **Invalidate stale layouts**: If module versions don't match, treat it as a cache miss and recompute the layout
4. **Alternative**: Use a versioned cache key that includes module hashes or versions, not just `(StructNameIndex, TypeArgsId)`

## Proof of Concept

The vulnerability can be demonstrated with a Rust test that:
1. Spawns parallel threads executing transactions
2. Has one thread publish a module with modified struct layout
3. Introduces timing delays to trigger the race condition
4. Verifies that different execution orders produce different results

```rust
// Pseudocode structure (full PoC would require extensive test harness):
// 1. Execute transaction T1 that computes layout from Module M v1
// 2. During T1's store_layout_to_cache, publish M v2 and flush cache
// 3. Ensure T1's store completes after flush (timing-dependent)
// 4. Execute T2 that loads stale layout from cache
// 5. Verify T2 uses wrong layout but passes validation
// 6. Compare state roots between different execution orders
```

Due to the complexity of reproducing exact thread timing and the infrastructure requirements, a complete executable PoC requires access to the full Aptos test framework with parallel execution capabilities enabled.

## Notes

This vulnerability affects the core consensus safety guarantee of Aptos. The comment in the code suggests awareness that layout caching with module publishing is complex: [14](#0-13)  However, the current flush mechanism is insufficient because it doesn't prevent stale layouts from being inserted after the flush completes.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/layout_cache.rs (L59-64)
```rust
/// An entry into layout cache: layout and a set of modules used to construct it.
#[derive(Debug, Clone)]
pub struct LayoutCacheEntry {
    layout: LayoutWithDelayedFields,
    modules: TriompheArc<DefiningModules>,
}
```

**File:** third_party/move/move-vm/runtime/src/storage/layout_cache.rs (L79-83)
```rust
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub struct StructKey {
    pub idx: StructNameIndex,
    pub ty_args_id: TypeVecId,
}
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L96-96)
```rust
    struct_layouts: DashMap<StructKey, LayoutCacheEntry>,
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L163-168)
```rust
    pub fn flush_layout_cache(&self) {
        // TODO(layouts):
        //   Flushing is only needed because of enums. Once we refactor layouts to store a single
        //   variant instead, this can be removed.
        self.struct_layouts.clear();
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L186-189)
```rust
        if let dashmap::Entry::Vacant(e) = self.struct_layouts.entry(*key) {
            e.insert(entry);
        }
        Ok(())
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L317-317)
```rust
    global_module_cache.mark_overridden(write.module_id());
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L203-221)
```rust
    fn load_layout_from_cache(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        key: &StructKey,
    ) -> Option<PartialVMResult<LayoutWithDelayedFields>> {
        let entry = self.module_storage.get_struct_layout(key)?;
        let (layout, modules) = entry.unpack();
        for module_id in modules.iter() {
            // Re-read all modules for this layout, so that transaction gets invalidated
            // on module publish. Also, we re-read them in exactly the same way as they
            // were traversed during layout construction, so gas charging should be exactly
            // the same as on the cache miss.
            if let Err(err) = self.charge_module(gas_meter, traversal_context, module_id) {
                return Some(Err(err));
            }
        }
        Some(Ok(layout))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L223-229)
```rust
    fn store_layout_to_cache(
        &self,
        key: &StructKey,
        entry: LayoutCacheEntry,
    ) -> PartialVMResult<()> {
        self.module_storage.store_struct_layout(key, entry)
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L2117-2131)
```rust
        let mut modules_published = false;
        for write in output_before_guard.module_write_set().values() {
            add_module_write_to_module_cache::<T>(
                write,
                txn_idx,
                runtime_environment,
                global_module_cache,
                unsync_map.module_cache(),
            )?;
            modules_published = true;
        }
        // For simplicity, flush layout cache on module publish.
        if modules_published {
            global_module_cache.flush_layout_cache();
        }
```

**File:** third_party/move/move-vm/types/src/loaded_data/struct_name_indexing.rs (L46-49)
```rust
/// A data structure to cache struct identifiers (address, module name, struct name) and use
/// indices instead, to save on the memory consumption and avoid unnecessary cloning. It
/// guarantees that the same struct name identifier always corresponds to a unique index.
pub struct StructNameIndexMap(RwLock<IndexMap<StructIdentifier>>);
```

**File:** aptos-move/block-executor/src/code_cache.rs (L148-174)
```rust
        match &self.latest_view {
            ViewState::Sync(state) => {
                // Check the transaction-level cache with already read modules first.
                if let CacheRead::Hit(read) = state.captured_reads.borrow().get_module_read(key) {
                    return Ok(read);
                }

                // Otherwise, it is a miss. Check global cache.
                if let Some(module) = self.global_module_cache.get(key) {
                    state
                        .captured_reads
                        .borrow_mut()
                        .capture_global_cache_read(key.clone(), module.clone());
                    return Ok(Some((module, Self::Version::default())));
                }

                // If not global cache, check per-block cache.
                let _timer = GLOBAL_MODULE_CACHE_MISS_SECONDS.start_timer();
                let read = state
                    .versioned_map
                    .module_cache()
                    .get_module_or_build_with(key, builder)?;
                state
                    .captured_reads
                    .borrow_mut()
                    .capture_per_block_cache_read(key.clone(), read.clone());
                Ok(read)
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1060-1061)
```rust
        let validate = |key: &K, read: &ModuleRead<DC, VC, S>| match read {
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1062-1066)
```rust
            ModuleRead::PerBlockCache(previous) => {
                let current_version = per_block_module_cache.get_module_version(key);
                let previous_version = previous.as_ref().map(|(_, version)| *version);
                current_version == previous_version
            },
```
