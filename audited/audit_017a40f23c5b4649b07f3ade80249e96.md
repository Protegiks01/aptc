# Audit Report

## Title
Unbounded Memory Growth in State Sync Driver Due to Unbound Consensus Notification Channel

## Summary
The ConsensusNotificationHandler uses an unbounded channel to receive notifications from consensus, while downstream handlers (MempoolNotificationHandler and StorageServiceNotificationHandler) use bounded channels. When the state sync driver is blocked waiting to forward notifications to these bounded channels, consensus can continue sending notifications to the unbounded channel, causing unbounded memory growth and eventual node crash.

## Finding Description

The state sync driver creates three notification handlers in the driver factory: [1](#0-0) 

The critical vulnerability lies in how these channels are implemented:

**ConsensusNotificationHandler: UNBOUNDED** [2](#0-1) 

**MempoolNotificationHandler: BOUNDED (configurable)** [3](#0-2) 

**StorageServiceNotificationHandler: BOUNDED (size 1)** [4](#0-3) 

The attack flow occurs as follows:

1. Consensus commits blocks and sends commit notifications through the unbounded channel: [5](#0-4) 

2. The state sync driver processes these notifications and must forward them to both mempool and storage service: [6](#0-5) 

3. If the storage service channel (size 1) or mempool channel (bounded) is full, the `.await` on line 98 blocks until space becomes available.

4. While the state sync driver is blocked, it cannot process new messages from its event loop: [7](#0-6) 

5. Consensus continues sending notifications via the unbounded channel. Each notification is queued immediately before waiting for response: [8](#0-7) 

6. The unbounded channel grows without limit, consuming memory until the node runs out of memory and crashes.

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

- **Validator node slowdowns**: As memory pressure increases, the node performance degrades
- **Node crashes**: Eventually leads to out-of-memory crashes
- **Network availability**: Affects both validator and full node availability

The vulnerability can cause:
- Node to become unresponsive under heavy load
- Memory exhaustion leading to node crash
- Potential cascading failures if multiple nodes are affected simultaneously
- Degraded network performance during high transaction throughput periods

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability can be triggered in several realistic scenarios:

1. **High Transaction Throughput**: During periods of sustained high transaction volume, the mempool may become backlogged, causing its notification channel to fill up.

2. **Resource Contention**: If the storage service is slow due to disk I/O bottlenecks, the size-1 channel quickly fills, blocking the state sync driver.

3. **Cascading Effects**: Once the state sync driver is blocked, each new block commitment adds to the unbounded queue, accelerating memory growth.

4. **Consensus Observer Nodes**: Full nodes running consensus observer are particularly vulnerable as they process commit notifications from network peers.

The attack doesn't require privileged access - it can occur naturally under heavy load or be triggered indirectly by causing mempool/storage service slowdowns through legitimate transaction submission.

## Recommendation

Replace the unbounded consensus notification channel with a bounded channel. The recommended fix:

**In `state-sync/inter-component/consensus-notifications/src/lib.rs`:**

```rust
pub fn new_consensus_notifier_listener_pair(
    timeout_ms: u64,
    max_pending_consensus_notifications: usize, // Add new parameter
) -> (ConsensusNotifier, ConsensusNotificationListener) {
    // Use bounded channel instead of unbounded
    let (notification_sender, notification_receiver) = 
        mpsc::channel(max_pending_consensus_notifications);

    let consensus_notifier = ConsensusNotifier::new(notification_sender, timeout_ms);
    let consensus_listener = ConsensusNotificationListener::new(notification_receiver);

    (consensus_notifier, consensus_listener)
}
```

Add configuration parameter in `StateSyncDriverConfig`:
```rust
pub max_pending_consensus_notifications: u64, // e.g., default 100
```

This provides backpressure: if the bounded channel is full, consensus will block on sending (or fail fast if using `try_send`), preventing unbounded memory growth. Consensus can then handle the backpressure appropriately by slowing down or alerting operators.

## Proof of Concept

```rust
#[tokio::test]
async fn test_unbounded_consensus_channel_memory_growth() {
    use futures::StreamExt;
    use std::sync::Arc;
    use std::time::Duration;
    
    // Create consensus notifier/listener pair (unbounded)
    let (consensus_notifier, mut consensus_listener) = 
        aptos_consensus_notifications::new_consensus_notifier_listener_pair(1000);
    
    // Create slow mempool that never processes notifications
    let (mempool_notifier, _mempool_listener) = 
        aptos_mempool_notifications::new_mempool_notifier_listener_pair(1);
    
    // Simulate state sync driver processing with blocked mempool
    let driver_task = tokio::spawn(async move {
        while let Some(notification) = consensus_listener.next().await {
            match notification {
                ConsensusNotification::NotifyCommit(commit_notification) => {
                    // Try to forward to mempool (will block since channel is full)
                    let _ = mempool_notifier
                        .notify_new_commit(
                            commit_notification.get_transactions().clone(),
                            0
                        )
                        .await;
                    
                    // Respond to consensus
                    let _ = consensus_listener
                        .respond_to_commit_notification(commit_notification, Ok(()));
                }
                _ => {}
            }
        }
    });
    
    // Simulate consensus rapidly sending commit notifications
    let mut memory_usage = Vec::new();
    for i in 0..10000 {
        let transactions = vec![create_test_transaction()];
        
        // Send notification (won't block - goes to unbounded channel)
        tokio::spawn(async move {
            let _ = consensus_notifier.notify_new_commit(transactions, vec![]).await;
        });
        
        // Track memory usage every 1000 iterations
        if i % 1000 == 0 {
            let current_memory = get_process_memory_usage();
            memory_usage.push(current_memory);
            
            // Verify memory is growing
            if memory_usage.len() > 1 {
                assert!(
                    memory_usage.last() > memory_usage.first(),
                    "Memory should be growing due to unbounded channel"
                );
            }
        }
        
        tokio::time::sleep(Duration::from_millis(1)).await;
    }
    
    // Memory should have grown significantly
    assert!(
        memory_usage.last().unwrap() - memory_usage.first().unwrap() > 10_000_000,
        "Expected significant memory growth from unbounded channel"
    );
}
```

## Notes

This vulnerability demonstrates a classic resource exhaustion pattern where an unbounded queue accepts input faster than downstream consumers can process it. The issue is exacerbated by the storage service channel having a size of only 1, making it trivial to block the state sync driver. The consensus timeout mechanism provides some backpressure but doesn't prevent notifications from queuing in the unbounded channel before the timeout is checked.

The fix requires careful coordination between the state sync driver configuration and consensus to ensure appropriate bounded channel sizes that balance throughput with memory safety.

### Citations

**File:** state-sync/state-sync-driver/src/driver_factory.rs (L126-133)
```rust
        let consensus_notification_handler =
            ConsensusNotificationHandler::new(consensus_listener, time_service.clone());
        let (error_notification_sender, error_notification_listener) =
            ErrorNotificationListener::new();
        let mempool_notification_handler =
            MempoolNotificationHandler::new(mempool_notification_sender);
        let storage_service_notification_handler =
            StorageServiceNotificationHandler::new(storage_service_notification_sender);
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L59-62)
```rust
pub fn new_consensus_notifier_listener_pair(
    timeout_ms: u64,
) -> (ConsensusNotifier, ConsensusNotificationListener) {
    let (notification_sender, notification_receiver) = mpsc::unbounded();
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L108-119)
```rust
        // Send the notification to state sync
        if let Err(error) = self
            .notification_sender
            .clone()
            .send(commit_notification)
            .await
        {
            return Err(Error::NotificationError(format!(
                "Failed to notify state sync of committed transactions! Error: {:?}",
                error
            )));
        }
```

**File:** state-sync/inter-component/mempool-notifications/src/lib.rs (L49-53)
```rust
pub fn new_mempool_notifier_listener_pair(
    max_pending_mempool_notifications: u64,
) -> (MempoolNotifier, MempoolNotificationListener) {
    let (notification_sender, notification_receiver) =
        mpsc::channel(max_pending_mempool_notifications as usize);
```

**File:** state-sync/inter-component/storage-service-notifications/src/lib.rs (L17-21)
```rust
// Note: we limit the queue depth to 1 because it doesn't make sense for the storage service
// to execute for every notification (because it reads the latest version in the DB). Thus,
// if there are X pending notifications, the first one will refresh using the latest DB and
// the next X-1 will execute with an unchanged DB (thus, becoming a no-op and wasting the CPU).
const STORAGE_SERVICE_NOTIFICATION_CHANNEL_SIZE: usize = 1;
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1167-1174)
```rust
        if let Err(e) = monitor!(
            "notify_state_sync",
            state_sync_notifier
                .notify_new_commit(txns, subscribable_events)
                .await
        ) {
            error!(error = ?e, "Failed to notify state synchronizer");
        }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L96-99)
```rust
        // Notify the storage service of the committed transactions
        storage_service_notification_handler
            .notify_storage_service_of_committed_transactions(latest_synced_version)
            .await?;
```

**File:** state-sync/state-sync-driver/src/driver.rs (L222-239)
```rust
            ::futures::select! {
                notification = self.client_notification_listener.select_next_some() => {
                    self.handle_client_notification(notification).await;
                },
                notification = self.commit_notification_listener.select_next_some() => {
                    self.handle_snapshot_commit_notification(notification).await;
                }
                notification = self.consensus_notification_handler.select_next_some() => {
                    self.handle_consensus_or_observer_notification(notification).await;
                }
                notification = self.error_notification_listener.select_next_some() => {
                    self.handle_error_notification(notification).await;
                }
                _ = progress_check_interval.select_next_some() => {
                    self.drive_progress().await;
                }
            }
        }
```
