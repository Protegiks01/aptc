# Audit Report

## Title
Missing Point-at-Infinity Validation in EncryptPubKey Deserialization Allows Trivial Decryption of DKG Shares

## Summary
The `EncryptPubKey` struct in the chunky PVSS implementation fails to validate that the deserialized elliptic curve point is not the point at infinity (identity element). This missing validation violates the cryptographic requirements of ElGamal-style encryption used in the DKG protocol, where encryption keys must be non-identity group elements to ensure confidentiality.

## Finding Description

The `TryFrom<&[u8]>` implementation for `EncryptPubKey` uses arkworks' `deserialize_compressed` method without validating that the resulting point is not the identity element: [1](#0-0) 

The arkworks library's `CanonicalDeserialize` accepts the point at infinity as a valid curve point, as confirmed by test code that explicitly includes identity points: [2](#0-1) 

In the ElGamal-style encryption used by chunky PVSS, ciphertexts are computed as `C_i,j = z_{i,j} * G + r_j * ek_i`: [3](#0-2) 

If `ek` is the point at infinity, then `r_j * ek = O` (the identity), reducing the ciphertext to `C_i,j = z_{i,j} * G`. This is simply the plaintext multiplied by the generator with no randomness—anyone can decrypt this by solving a discrete logarithm without possessing the corresponding private key.

While BLS public keys used in validator registration undergo proof-of-possession (PoP) verification that checks for the identity element, the subsequent conversion to `EncryptPubKey` happens through serialization/deserialization without re-validating this property: [4](#0-3) 

The BLS `PublicKey::subgroup_check()` method explicitly verifies the key is not the identity element: [5](#0-4) 

However, the `TryFrom<&[u8]>` implementation for BLS `PublicKey` does NOT perform this check—it only validates the point is on the curve: [6](#0-5) 

## Impact Explanation

**Severity: Medium**

While this represents a violation of cryptographic best practices, the current codebase provides defense-in-depth through PoP verification during validator registration. However, this qualifies as Medium severity because:

1. **Missing Validation Layer**: The lack of validation in `EncryptPubKey` deserialization creates a single point of failure—if PoP verification is bypassed or future code changes introduce alternative paths for key registration, the encryption scheme would completely fail.

2. **Confidentiality Break**: If exploited, this would break the confidentiality guarantee of the DKG protocol, allowing an attacker to decrypt secret shares without the corresponding private key.

3. **State Inconsistency Risk**: According to Aptos bug bounty criteria, this represents a "state inconsistency requiring intervention" as it could compromise the integrity of the distributed key generation process.

## Likelihood Explanation

**Likelihood: Low (in current codebase)**

In the current implementation, exploitation requires bypassing the PoP verification layer during validator registration. While the BLS-to-EncryptPubKey conversion path includes the vulnerable deserialization, validators' BLS keys are expected to have undergone PoP verification before reaching this point.

However, the likelihood increases if:
- Future code introduces alternative registration or key update mechanisms
- Network protocol changes allow direct submission of `EncryptPubKey` values
- Bugs in PoP verification allow identity keys to slip through

## Recommendation

Add explicit validation in the `TryFrom<&[u8]>` implementation for `EncryptPubKey` to reject the point at infinity:

```rust
impl<E: Pairing> TryFrom<&[u8]> for EncryptPubKey<E> {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        let ek = <E::G1Affine as CanonicalDeserialize>::deserialize_compressed(bytes)
            .map_err(|_| CryptoMaterialError::DeserializationError)?;
        
        // Validate that the point is not the identity element
        if ek.is_zero() {
            return Err(CryptoMaterialError::ValidationError);
        }

        Ok(EncryptPubKey { ek })
    }
}
```

Additionally, apply the same validation to the DAS PVSS implementation in the `encryption_dlog` module.

## Proof of Concept

```rust
#[test]
fn test_encrypt_pubkey_rejects_identity() {
    use ark_bls12_381::Bls12_381;
    use ark_ec::AffineRepr;
    use ark_serialize::CanonicalSerialize;
    
    // Serialize the point at infinity (identity element)
    let identity = <Bls12_381 as Pairing>::G1Affine::zero();
    let mut bytes = Vec::new();
    identity.serialize_compressed(&mut bytes).unwrap();
    
    // Attempt to deserialize as EncryptPubKey
    let result = EncryptPubKey::<Bls12_381>::try_from(bytes.as_slice());
    
    // This should fail but currently succeeds
    assert!(result.is_err(), "EncryptPubKey should reject point at infinity");
}
```

## Notes

This vulnerability demonstrates the importance of validating cryptographic assumptions at every deserialization boundary. While the current implementation benefits from defense-in-depth through PoP verification, the missing validation in `EncryptPubKey` represents a latent security risk that violates the principle of least privilege and could become exploitable through future code changes or alternative attack vectors.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/keys.rs (L35-44)
```rust
impl<E: Pairing> TryFrom<&[u8]> for EncryptPubKey<E> {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        let ek = <E::G1Affine as CanonicalDeserialize>::deserialize_compressed(bytes)
            .map_err(|_| CryptoMaterialError::DeserializationError)?;

        Ok(EncryptPubKey { ek })
    }
}
```

**File:** crates/aptos-crypto/src/arkworks/serialization.rs (L72-86)
```rust
        let mut points = vec![G1Affine::zero()]; // Include zero
        let mut g = G1Projective::generator();

        for _ in 0..MAX_DOUBLINGS {
            points.push(g.into());
            g += g; // double for next
        }

        for p in points {
            let serialized = bcs::to_bytes(&A(p)).expect("Serialization failed");
            let deserialized: A = bcs::from_bytes(&serialized).expect("Deserialization failed");

            assert_eq!(deserialized.0, p, "G1 point round-trip failed for {:?}", p);
        }
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L186-200)
```rust
fn chunks_msm_terms<C: CurveGroup>(
    pp: &PublicParameters<C>,
    ek: C::Affine,
    chunks: &[Scalar<C::ScalarField>],
    correlated_randomness: &[Scalar<C::ScalarField>],
) -> Vec<MsmInput<C::Affine, C::ScalarField>> {
    chunks
        .iter()
        .zip(correlated_randomness.iter())
        .map(|(&z_ij, &r_j)| MsmInput {
            bases: vec![pp.G, ek],
            scalars: vec![z_ij.0, r_j.0],
        })
        .collect()
}
```

**File:** types/src/dkg/real_dkg/mod.rs (L124-127)
```rust
    let consensus_keys: Vec<EncPK> = validator_consensus_keys
        .iter()
        .map(|k| k.to_bytes().as_slice().try_into().unwrap())
        .collect::<Vec<_>>();
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L61-69)
```rust
    /// Subgroup-checks the public key (i.e., verifies the public key is an element of the prime-order
    /// subgroup and it is not the identity element).
    ///
    /// WARNING: Subgroup-checking is done implicitly when verifying the proof-of-possession (PoP) for
    /// this public key  in `ProofOfPossession::verify`, so this function should not be called
    /// separately for most use-cases. We leave it here just in case.
    pub fn subgroup_check(&self) -> Result<()> {
        self.pubkey.validate().map_err(|e| anyhow!("{:?}", e))
    }
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L227-247)
```rust
impl TryFrom<&[u8]> for PublicKey {
    type Error = CryptoMaterialError;

    /// Deserializes a PublicKey from a sequence of bytes.
    ///
    /// WARNING: Does NOT subgroup-check the public key! Instead, the caller is responsible for
    /// verifying the public key's proof-of-possession (PoP) via `ProofOfPossession::verify`,
    /// which implicitly subgroup-checks the public key.
    ///
    /// NOTE: This function will only check that the PK is a point on the curve:
    ///  - `blst::min_pk::PublicKey::from_bytes(bytes)` calls `blst::min_pk::PublicKey::deserialize(bytes)`,
    ///    which calls `$pk_deser` in <https://github.com/supranational/blst/blob/711e1eec747772e8cae15d4a1885dd30a32048a4/bindings/rust/src/lib.rs#L734>,
    ///    which is mapped to `blst_p1_deserialize` in <https://github.com/supranational/blst/blob/711e1eec747772e8cae15d4a1885dd30a32048a4/bindings/rust/src/lib.rs#L1652>
    ///  - `blst_p1_deserialize` eventually calls `POINTonE1_Deserialize_BE`, which checks
    ///    the point is on the curve: <https://github.com/supranational/blst/blob/711e1eec747772e8cae15d4a1885dd30a32048a4/src/e1.c#L296>
    fn try_from(bytes: &[u8]) -> std::result::Result<Self, CryptoMaterialError> {
        Ok(Self {
            pubkey: blst::min_pk::PublicKey::from_bytes(bytes)
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
        })
    }
```
