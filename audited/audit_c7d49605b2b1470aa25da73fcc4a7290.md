# Audit Report

## Title
Move Prover Denial of Service via Unchecked Array Access in Intrinsic Map Type Instantiation

## Summary
The Move Prover lacks validation that intrinsic map types must have exactly two type parameters. Multiple code paths access `targs[0]` and `targs[1]` without bounds checking, allowing an attacker to crash the prover by declaring an intrinsic map type with an incorrect number of type parameters.

## Finding Description

The `mk_map_quant_opt()` function creates type instantiations assuming exactly 2 type parameters exist without validation: [1](#0-0) 

The intrinsic registration process explicitly defers type signature validation: [2](#0-1) 

When processing data invariants, the code accesses array elements without bounds checking: [3](#0-2) 

Similarly, in the Boogie spec translator: [4](#0-3) 

**Attack Vector**: An attacker publishes a Move module declaring an intrinsic map type with only 1 type parameter (or 0, or 3+) instead of the required 2. When the prover attempts verification, it panics with an index out of bounds error.

**Affected Security Guarantee**: This violates the prover's robustness and could block formal verification workflows if governance or deployment processes depend on successful prover execution.

## Impact Explanation

**Severity: Low to Medium** (depending on deployment process integration)

This issue causes a **Denial of Service on the Move Prover**, not the runtime blockchain. However:

1. **Development Disruption**: Crashes the prover for any module containing the malicious declaration
2. **Governance Blocking**: If on-chain governance requires prover verification for module upgrades, this could block proposal execution
3. **CI/CD Pipeline Failure**: Automated deployment systems depending on prover verification would fail

This does **not** meet Critical or High severity because:
- No consensus impact (prover runs offline)
- No funds loss
- No runtime execution vulnerability
- No validator node compromise

## Likelihood Explanation

**Likelihood: Medium**

- **Ease of Exploitation**: Trivial - requires only publishing a Move module with incorrect type parameter count
- **Detection**: Low - no validation occurs until prover execution
- **Prerequisites**: Attacker needs ability to submit modules for verification (standard developer access)

The exploit is straightforward but limited to disrupting verification workflows rather than blockchain operation.

## Recommendation

Add validation in the intrinsic declaration processing to enforce that map types must have exactly 2 type parameters:

```rust
// In intrinsics.rs, around line 114
let type_entry = builder.parent.struct_table.get(&type_qsym).expect("struct");
let move_type = type_entry.module_id.qualified(type_entry.struct_id);

// ADD THIS VALIDATION:
if target.as_str() == INTRINSIC_TYPE_MAP {
    let struct_env = builder.parent.env.get_module(type_entry.module_id)
        .into_struct(type_entry.struct_id);
    if struct_env.get_type_parameters().len() != 2 {
        builder.parent.error(
            loc,
            &format!(
                "intrinsic map type must have exactly 2 type parameters, found {}",
                struct_env.get_type_parameters().len()
            )
        );
        return;
    }
}
```

Additionally, add defensive bounds checking before array access:

```rust
// In data_invariant_instrumentation.rs, before line 206
if targs.len() < 2 {
    // Report error or skip processing
    return vec![];
}
let quant = self.builder.mk_map_quant_opt(
    QuantKind::Forall,
    value,
    spec_fun_get,
    &targs[0],
    &targs[1],
    // ...
);
```

## Proof of Concept

```move
module 0x42::ProverCrasher {
    // Declare map with only 1 type parameter instead of required 2
    struct MaliciousMap<phantom K> {}
    
    spec native fun bad_get<K>(t: MaliciousMap<K>, k: K): K;
    
    spec MaliciousMap {
        pragma intrinsic = map,
            map_spec_get = bad_get;
    }
    
    struct Container has key {
        data: MaliciousMap<u64>
    }
    
    // This invariant triggers data invariant instrumentation
    spec Container {
        invariant true;
    }
    
    public fun create_container(): Container {
        Container { data: MaliciousMap {} }
    }
}
```

**Expected Result**: Move Prover crashes with "index out of bounds: the len is 1 but the index is 1" when attempting to verify this module.

**Actual Impact**: While this demonstrates the robustness issue, it does not constitute a critical blockchain security vulnerability as the prover operates offline in development environments.

## Notes

While this is a valid implementation bug causing prover crashes, it does **not** meet the Critical, High, or Medium severity thresholds for the Aptos bug bounty program because:

1. The vulnerability affects development tooling, not blockchain runtime
2. No consensus, funds, or validator operations are compromised
3. The prover is not part of the transaction execution or state commitment path
4. Impact is limited to disrupting verification workflows

The more concerning theoretical risk—that mismatched arities could cause **unsound verification** (accepting invalid code as valid)—remains unproven. The crashes occur before verification completes, preventing unsound results.

### Citations

**File:** third_party/move/move-model/src/exp_generator.rs (L237-242)
```rust
        let val = self.mk_call_with_inst(
            val_ty,
            vec![key_ty.clone(), val_ty.clone()],
            Operation::SpecFunction(spec_fun_get.module_id, spec_fun_get.id, None),
            vec![map.clone(), key.clone()],
        );
```

**File:** third_party/move/move-model/src/intrinsics.rs (L232-234)
```rust
                    // TODO: in theory, we should also do some type checking on the function
                    // signature. This is implicitly done by Boogie right now, but we may want to
                    // make it more explicit and do the checking ourselves.
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs (L206-207)
```rust
                        &targs[0],
                        &targs[1],
```

**File:** third_party/move/move-prover/boogie-backend/src/spec_translator.rs (L1695-1695)
```rust
                            ty_str(&targs[0])
```
