# Audit Report

## Title
Insecure Storage of Validator Private Keys in Genesis Generation Process

## Summary
The `ConfigKey` wrapper from `aptos_config` provides no security features (no zeroization, no access control) and is used to handle validator private keys during genesis generation. These keys are subsequently written to disk in plaintext YAML files with default (world-readable) file permissions, creating a key leakage vulnerability in development and test environments.

## Finding Description

The `ConfigKey<T>` struct is a plain wrapper that provides no cryptographic hygiene features: [1](#0-0) 

**Key Security Deficiencies:**

1. **No Zeroization**: The struct does not implement `Drop` with secure memory clearing, leaving key material in memory after use.

2. **No Access Control**: The `private_key()` method freely returns a copy of the wrapped key without any access restrictions: [2](#0-1) 

3. **Insecure Cloning**: Keys are cloned via serialization/deserialization, creating multiple copies in memory: [3](#0-2) 

**Critical Leakage Point:**

During genesis generation, validator private keys (including consensus BLS keys) are written to disk in plaintext YAML format: [4](#0-3) 

The `write_yaml` function uses `File::create()` with default permissions (typically 0644 on Unix systems, making files world-readable): [5](#0-4) 

The `PrivateIdentity` struct contains all validator cryptographic material: [6](#0-5) 

## Impact Explanation

**Severity: Medium**

This qualifies as Medium severity under "Limited funds loss or manipulation" or "State inconsistencies requiring intervention" because:

1. **Key Compromise Scenario**: An attacker with read access to the file system can extract validator consensus keys (BLS12-381), account keys (Ed25519), and network keys (X25519).

2. **Limited Scope**: The documentation explicitly states this is "for testing or for low security requirements," limiting impact to development/test environments: [7](#0-6) 

3. **Acknowledged Limitation**: A TODO comment indicates awareness: [8](#0-7) 

However, compromise of validator keys—even in test environments—could enable Byzantine attacks if those environments are used for testnet validation or if keys are inadvertently reused.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is exploitable when:
- An attacker gains local read access to the genesis generation directory
- Shared development environments expose key files to multiple users
- Backup systems inadvertently copy world-readable key files
- Memory dumps expose keys (no zeroization)

The explicit documentation as "testing/low-security" reduces production impact, but testnets and development environments remain at risk.

## Recommendation

**Immediate Fix:**

1. **Set Secure File Permissions**: Explicitly set restrictive permissions (0600) when writing sensitive key files:

```rust
use std::fs::{File, OpenOptions};
use std::os::unix::fs::PermissionsExt;

fn write_yaml_secure<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    // Create file with restricted permissions
    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .mode(0o600)  // Owner read/write only
        .open(path)?;
    file.write_all(serde_yaml::to_string(object)?.as_bytes())?;
    Ok(())
}
```

2. **Implement Zeroization**: Use the `zeroize` crate to clear key material from memory:

```rust
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(ZeroizeOnDrop)]
pub struct ConfigKey<T: PrivateKey + Serialize> {
    #[serde(bound(deserialize = "T: Deserialize<'de>"))]
    key: T,
}
```

3. **Add Warning Comments**: Enhance documentation warning about the security limitations and proper usage.

4. **Implement the TODO**: Migrate to secure storage backends (HSM, key management services) as indicated by the TODO comment.

## Proof of Concept

**File System Access PoC:**

```bash
# After genesis generation, read world-readable key file
cd /path/to/genesis/output/0
cat private-identity.yaml

# Output will contain plaintext validator keys:
# account_address: "0x..."
# account_private_key: "ed25519-priv-..."
# consensus_private_key: "bls12381-priv-..."
# ...
```

**Memory Leak PoC (Rust):**

```rust
use aptos_config::keys::ConfigKey;
use aptos_crypto::ed25519::Ed25519PrivateKey;
use aptos_keygen::KeyGen;

fn main() {
    let mut keygen = KeyGen::from_os_rng();
    let key = keygen.generate_ed25519_private_key();
    
    // Create ConfigKey wrapper
    let config_key = ConfigKey::new(key);
    
    // Extract key multiple times (no access control)
    let key1 = config_key.private_key();
    let key2 = config_key.private_key();
    
    // Keys remain in memory after drop (no zeroization)
    drop(config_key);
    
    // Memory still contains key material - vulnerable to dumps/forensics
    println!("Keys extracted and left in memory without zeroization");
}
```

## Notes

While this finding demonstrates real security weaknesses in `ConfigKey` and the genesis key handling process, the impact is intentionally limited by design to test/development scenarios. The developers have documented this limitation and planned migration to secure storage. Organizations using Aptos should:

1. Never use `ConfigKey`-based genesis generation for production validators
2. Use hardware security modules (HSMs) or key management services for production keys
3. Ensure test environment keys are never reused in production
4. Apply strict file permissions even in development environments

### Citations

**File:** config/src/keys.rs (L20-29)
```rust
/// ConfigKey places a clonable wrapper around PrivateKeys for config purposes only. The only time
/// configs have keys is either for testing or for low security requirements. We recommend that
/// keys be stored in key managers. If we make keys unclonable, then the configs must be mutable
/// and that becomes a requirement strictly as a result of supporting test environments, which is
/// undesirable. Hence this internal wrapper allows for keys to be clonable but only from configs.
#[derive(Debug, Deserialize, Serialize)]
pub struct ConfigKey<T: PrivateKey + Serialize> {
    #[serde(bound(deserialize = "T: Deserialize<'de>"))]
    key: T,
}
```

**File:** config/src/keys.rs (L36-38)
```rust
    pub fn private_key(&self) -> T {
        self.clone().key
    }
```

**File:** config/src/keys.rs (L49-53)
```rust
impl<T: DeserializeOwned + PrivateKey + Serialize> Clone for ConfigKey<T> {
    fn clone(&self) -> Self {
        bcs::from_bytes(&bcs::to_bytes(self).unwrap()).unwrap()
    }
}
```

**File:** crates/aptos-genesis/src/builder.rs (L96-98)
```rust
    /// Initializes keys and identities for a validator config
    /// TODO: Put this all in storage rather than files?
    fn init_keys(&mut self, seed: Option<[u8; 32]>) -> anyhow::Result<()> {
```

**File:** crates/aptos-genesis/src/builder.rs (L144-148)
```rust
            // Write identities in files
            write_yaml(val_identity_file.as_path(), &validator_identity)?;
            write_yaml(vfn_identity_file.as_path(), &vfn_identity)?;
            write_yaml(private_identity_file.as_path(), &private_identity)?;
            write_yaml(public_identity_file.as_path(), &public_identity)?;
```

**File:** crates/aptos-genesis/src/builder.rs (L418-421)
```rust
fn write_yaml<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    File::create(path)?.write_all(serde_yaml::to_string(object)?.as_bytes())?;
    Ok(())
}
```

**File:** crates/aptos-genesis/src/keys.rs (L16-22)
```rust
pub struct PrivateIdentity {
    pub account_address: AccountAddress,
    pub account_private_key: Ed25519PrivateKey,
    pub consensus_private_key: bls12381::PrivateKey,
    pub full_node_network_private_key: x25519::PrivateKey,
    pub validator_network_private_key: x25519::PrivateKey,
}
```
