# Audit Report

## Title
Inconsistent PeerId String Format Validation in Custom Contract Telemetry Ingestion

## Summary
The custom contract telemetry service performs string comparison of PeerId values instead of parsing and comparing PeerId objects, causing legitimate requests with valid but non-canonical string formats to be rejected. This creates an interoperability issue for clients using AIP-40 compliant address formats.

## Finding Description

The `handle_custom_event_ingest` function in the custom contract ingestion endpoint validates that the user-provided `user_id` matches the authenticated `peer_id` by performing a direct string comparison. [1](#0-0) 

This approach is flawed because AccountAddress (PeerId's underlying type) has multiple valid string representations per AIP-40:
- **SHORT form** for special addresses (0x0 to 0xf): e.g., "0x1"
- **LONG form** for all addresses: e.g., "0x0000000000000000000000000000000000000000000000000000000000000001"

The `Display` trait implementation uses `to_standard_string()`, which returns SHORT form for special addresses and LONG form for others. [2](#0-1) 

Special addresses are defined as those in the range 0x0 to 0xf inclusive. [3](#0-2) 

When a client with a special address authenticates, the server's cached representation uses SHORT form. If the client sends the LONG form representation in the request body, the string comparison fails and the request is rejected.

In contrast, the standard custom event endpoint correctly parses the string to a PeerId before comparison. [4](#0-3) 

The test suite demonstrates that multiple valid formats successfully parse to the same PeerId. [5](#0-4) 

## Impact Explanation

**Severity Assessment: Low to Medium**

This vulnerability affects the telemetry service's custom contract ingestion endpoint, not core blockchain functionality. The impact is:

1. **Denial of Service**: Legitimate clients using valid LONG form addresses for special PeerIds (0x0-0xf) will have their telemetry uploads rejected
2. **Interoperability Issues**: Creates inconsistent behavior across different Aptos SDK implementations that may use different canonical forms
3. **Limited Scope**: Only affects custom contract telemetry, not consensus, execution, or state management

This does not meet Critical or High severity criteria as it does not impact:
- Funds or asset security
- Consensus safety or liveness
- Validator operations
- Core protocol functionality

However, it does cause legitimate operations to fail and creates unpredictable behavior for developers, qualifying as a Medium severity implementation bug per the bug bounty program.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability will only manifest when:
1. A client has a special address (0x0 to 0xf) as their PeerId
2. The client uses the LONG form representation in their request
3. The custom contract ingestion endpoint is being used (not the standard endpoint)

Special addresses are less common in production systems, but the issue is trivially triggered once conditions are met. The bug is deterministic and will consistently reject valid requests meeting the above criteria.

## Recommendation

Replace the string comparison with proper PeerId parsing and comparison, following the pattern used in `custom_event.rs`:

```rust
// Parse the user_id string to a PeerId
let body_peer_id = PeerId::from_str(&body.user_id).map_err(|_| {
    record_custom_contract_error(
        &contract_name,
        CustomContractEndpoint::EventsIngest,
        CustomContractErrorType::InvalidPayload,
    );
    reject::custom(ServiceError::bad_request(
        CustomEventIngestError::InvalidEvent(body.user_id.clone(), peer_id).into(),
    ))
})?;

// Compare PeerId objects, not strings
if body_peer_id != peer_id {
    record_custom_contract_error(
        &contract_name,
        CustomContractEndpoint::EventsIngest,
        CustomContractErrorType::InvalidPayload,
    );
    return Err(reject::custom(ServiceError::bad_request(
        CustomEventIngestError::InvalidEvent(body.user_id.clone(), peer_id).into(),
    )));
}
```

This ensures all valid AIP-40 compliant string formats are accepted and correctly validated.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::{chain_id::ChainId, PeerId};

    #[test]
    fn test_string_comparison_bug() {
        // Special address that displays as SHORT form
        let peer_id = PeerId::from_hex_literal("0x1").unwrap();
        
        // Server uses to_string() which returns SHORT form for special addresses
        let server_representation = peer_id.to_string();
        assert_eq!(server_representation, "0x1");
        
        // Client sends LONG form (valid per AIP-40)
        let client_user_id = "0x0000000000000000000000000000000000000000000000000000000000000001";
        
        // String comparison FAILS even though they represent the same PeerId
        assert_ne!(client_user_id, server_representation);
        
        // But parsing shows they ARE the same PeerId
        let client_peer_id = PeerId::from_str(client_user_id).unwrap();
        assert_eq!(client_peer_id, peer_id);
        
        // This demonstrates the bug: string comparison rejects valid requests
    }
}
```

## Notes

**Important Context**: While this is a real implementation bug causing request rejections, it must be noted that:

1. The original security question specifically asked about the `aptos-node-identity` crate and whether format inconsistencies could cause **peer discovery failures or security checks to fail** in the network layer.

2. My investigation of the core networking and authentication systems shows that:
   - All peer discovery mechanisms use PeerId types directly, not string comparisons [6](#0-5) 
   - Authentication checks parse and compare PeerId objects [7](#0-6) 
   - The noise handshake rejects self-dials using direct PeerId comparison [8](#0-7) 
   - The `peer_id_as_str()` function is only used for logging [9](#0-8) 

3. Therefore, **for the specific security question asked**: Different string representations of PeerId do NOT cause peer discovery failures or security checks to fail in the core Aptos network layer, because all such operations use typed PeerId comparisons.

The bug I found is in a peripheral telemetry service and represents an implementation inconsistency rather than a core security vulnerability affecting consensus, peer discovery, or network security checks.

### Citations

**File:** crates/aptos-telemetry-service/src/custom_contract_ingest.rs (L347-347)
```rust
    if body.user_id != peer_id.to_string() {
```

**File:** third_party/move/move-core/types/src/account_address.rs (L101-108)
```rust
    pub fn to_standard_string(&self) -> String {
        let suffix = if self.is_special() {
            self.short_str_lossless()
        } else {
            self.to_canonical_string()
        };
        format!("0x{}", suffix)
    }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L120-122)
```rust
    pub fn is_special(&self) -> bool {
        self.0[..Self::LENGTH - 1].iter().all(|x| *x == 0) && self.0[Self::LENGTH - 1] < 0b10000
    }
```

**File:** crates/aptos-telemetry-service/src/custom_event.rs (L47-52)
```rust
    let body_peer_id = PeerId::from_str(&body.user_id).map_err(|_| {
        reject::custom(ServiceError::bad_request(
            CustomEventIngestError::InvalidEvent(body.user_id.clone(), claims.peer_id).into(),
        ))
    })?;
    if body_peer_id != claims.peer_id {
```

**File:** crates/aptos-telemetry-service/src/custom_event.rs (L192-232)
```rust
            user_id: String::from("0x1234"),
            timestamp_micros: String::new(),
            events: vec![TelemetryEvent {
                name: "test".into(),
                params: BTreeMap::new(),
            }],
        };
        assert_ok!(validate_custom_event_body(&claims, &body));

        let body = TelemetryDump {
            client_id: String::new(),
            user_id: String::from("1234"),
            timestamp_micros: String::new(),
            events: vec![TelemetryEvent {
                name: "test".into(),
                params: BTreeMap::new(),
            }],
        };
        assert_ok!(validate_custom_event_body(&claims, &body));

        let body = TelemetryDump {
            client_id: String::new(),
            user_id: String::from("0x00001234"),
            timestamp_micros: String::new(),
            events: vec![TelemetryEvent {
                name: "test".into(),
                params: BTreeMap::new(),
            }],
        };
        assert_ok!(validate_custom_event_body(&claims, &body));

        let body = TelemetryDump {
            client_id: String::new(),
            user_id: String::from("00001234"),
            timestamp_micros: String::new(),
            events: vec![TelemetryEvent {
                name: "test".into(),
                params: BTreeMap::new(),
            }],
        };
        assert_ok!(validate_custom_event_body(&claims, &body));
```

**File:** network/framework/src/peer_manager/mod.rs (L564-578)
```rust
    fn simultaneous_dial_tie_breaking(
        own_peer_id: PeerId,
        remote_peer_id: PeerId,
        existing_origin: ConnectionOrigin,
        new_origin: ConnectionOrigin,
    ) -> bool {
        match (existing_origin, new_origin) {
            // If the remote dials while an existing connection is open, the older connection is
            // dropped.
            (ConnectionOrigin::Inbound, ConnectionOrigin::Inbound) => true,
            // We should never dial the same peer twice, but if we do drop the old connection
            (ConnectionOrigin::Outbound, ConnectionOrigin::Outbound) => true,
            (ConnectionOrigin::Inbound, ConnectionOrigin::Outbound) => remote_peer_id < own_peer_id,
            (ConnectionOrigin::Outbound, ConnectionOrigin::Inbound) => own_peer_id < remote_peer_id,
        }
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L90-92)
```rust
                    let derived_remote_peer_id =
                        aptos_types::account_address::from_identity_public_key(remote_public_key);
                    if derived_remote_peer_id != body.peer_id {
```

**File:** network/framework/src/noise/handshake.rs (L345-346)
```rust
        if remote_peer_id == self.network_context.peer_id() {
            return Err(NoiseHandshakeError::SelfDialDetected);
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L214-214)
```rust
            peer_id = aptos_node_identity::peer_id_as_str();
```
