# Audit Report

## Title
Waypoint Verification Bypasses BFT Quorum Check, Accepting Unsigned Epoch Change LedgerInfo

## Summary
The waypoint verification mechanism in Aptos Core accepts epoch-ending LedgerInfo without verifying that it was signed by the required 2f+1 validator quorum. The `Ledger2WaypointConverter` struct excludes signature data from waypoint hash computation, allowing nodes to trust epoch state transitions based solely on data hash matching, bypassing the fundamental BFT consensus guarantee that committed blocks require validator agreement.

## Finding Description

The waypoint system is designed to enable nodes to bootstrap trust from a known checkpoint. However, the implementation violates a critical BFT consensus invariant: **all committed blocks must be verified to have 2f+1 validator signatures.**

The vulnerability exists across three layers:

**Layer 1: Waypoint Hash Excludes Signatures** [1](#0-0) 

The `Ledger2WaypointConverter` computes the waypoint hash from only: epoch, root_hash, version, timestamp_usecs, and next_epoch_state. Signature data is completely excluded.

**Layer 2: Waypoint Verifier Trait Implementation** [2](#0-1) 

When `Waypoint` implements the `Verifier` trait, it extracts only the `LedgerInfo` from `LedgerInfoWithSignatures`, discarding signatures, and performs verification without cryptographic proof of validator agreement. [3](#0-2) 

The `verify` method only checks version and hash matchingâ€”no signature validation occurs.

**Layer 3: Critical Usage in Consensus Safety Rules** [4](#0-3) 

The consensus `SafetyRules::guarded_initialize` method uses waypoint to verify `EpochChangeProof` without any signature checks for the initial epoch change.

**Layer 4: EpochChangeProof Verification Delegates to Waypoint** [5](#0-4) 

The `EpochChangeProof::verify` method calls `verifier_ref.verify(ledger_info_with_sigs)` on line 107. When the verifier is a `Waypoint`, this bypasses all signature verification for the first LedgerInfo in the proof. Only subsequent epoch changes are verified with signatures after extracting the epoch_state from the unverified first LedgerInfo.

**Attack Path:**

1. Attacker obtains a valid waypoint value (typically public in node configurations)
2. Attacker constructs a `LedgerInfo` with correct data fields that hash to the waypoint value
3. Attacker creates `LedgerInfoWithSignatures` with empty or invalid signatures using `AggregateSignature::empty()`
4. Attacker sends this in an `EpochChangeProof` to a bootstrapping node
5. Node's waypoint verification passes (data hash matches)
6. Node accepts the epoch state transition without proof of 2f+1 validator agreement
7. Node's safety rules now trust a validator set from an unverified epoch change

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This vulnerability breaks **Critical Invariant #2: Consensus Safety**. The AptosBFT protocol guarantees that under < 1/3 Byzantine validators, all committed blocks have been agreed upon by 2f+1 validators. This signature verification bypass allows nodes to accept epoch-ending blocks without cryptographic proof of quorum agreement.

Impact includes:
- **Consensus Safety Break**: Nodes can accept state transitions without BFT quorum proof
- **Network Partition Risk**: Different nodes with different waypoints could accept different unsigned epoch changes, causing irreconcilable forks
- **Validator Set Manipulation Foundation**: While the attacker cannot change the next_epoch_state (it's bound by waypoint hash), accepting unverified epoch changes undermines the trust chain
- **Accountability Loss**: No record of which validators actually agreed to the epoch change

This meets the **Critical Severity** category (up to $1,000,000) under "Consensus/Safety violations" in the Aptos Bug Bounty program.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
1. **Public Information**: Waypoint values are typically public (in genesis configs, documentation)
2. **Network Position**: Attacker must be able to send EpochChangeProofs to bootstrapping nodes (achievable as a network peer)
3. **No Validator Compromise Required**: Attack works without compromising any validators

The attack is realistic because:
- Nodes regularly bootstrap (new nodes, restarts, state sync)
- Waypoints are public configuration values
- The EpochChangeProof mechanism accepts data from any network peer during bootstrap
- No cryptographic verification prevents the attack at the waypoint verification stage

However, likelihood is not "High" because:
- Requires targeting nodes during bootstrap phase
- Other network security measures may detect anomalous proofs
- Nodes may have additional out-of-band verification

## Recommendation

**Fix: Add signature verification requirement to waypoint verification for epoch-ending LedgerInfo**

The waypoint should verify that the LedgerInfoWithSignatures contains valid signatures from the validator set at the waypoint's epoch. This requires:

1. **Store validator set in waypoint or require it as verification input**:
   - Modify `Waypoint` to include or reference the validator set at that version
   - Or require `EpochChangeProof::verify` to provide pre-waypoint validator set

2. **Modify `Waypoint::verify` implementation**:

```rust
impl Verifier for Waypoint {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> Result<()> {
        // Existing checks
        self.verify(ledger_info.ledger_info())?;
        
        // NEW: Verify signatures if we're at an epoch boundary
        if ledger_info.ledger_info().ends_epoch() {
            // Require validator set to be provided or cached
            // This is the validator set from the PREVIOUS epoch
            let prev_epoch_verifier = self.get_validator_verifier()?;
            ledger_info.verify_signatures(prev_epoch_verifier)?;
        }
        
        Ok(())
    }
}
```

3. **Alternative: Explicit signature check in EpochChangeProof::verify**: [6](#0-5) 

Add explicit signature verification before accepting the first ledger info:

```rust
// Before line 107, add:
if let Some(waypoint) = verifier_ref.as_waypoint() {
    // For waypoint verification, we still need signatures
    // Use the validator set from genesis or configuration
    let genesis_verifier = get_genesis_validator_verifier()?;
    ledger_info_with_sigs.verify_signatures(genesis_verifier)?;
}
verifier_ref.verify(ledger_info_with_sigs)?;
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_waypoint_signature_bypass {
    use super::*;
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        block_info::BlockInfo,
        epoch_change::EpochChangeProof,
        epoch_state::EpochState,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        waypoint::Waypoint,
    };
    use aptos_crypto::hash::HashValue;

    #[test]
    fn test_waypoint_accepts_unsigned_ledger_info() {
        // Create a valid epoch-ending LedgerInfo
        let epoch_state = EpochState::empty();
        let ledger_info = LedgerInfo::new(
            BlockInfo::new(
                1,
                10,
                HashValue::random(),
                HashValue::random(),
                100,
                1000,
                Some(epoch_state),
            ),
            HashValue::zero(),
        );
        
        // Create waypoint from this ledger info
        let waypoint = Waypoint::new_epoch_boundary(&ledger_info).unwrap();
        
        // Create LedgerInfoWithSignatures with EMPTY signatures (unsigned!)
        let unsigned_li = LedgerInfoWithSignatures::new(
            ledger_info.clone(),
            AggregateSignature::empty(), // NO SIGNATURES!
        );
        
        // Waypoint verification should fail but SUCCEEDS
        assert!(waypoint.verify(&unsigned_li).is_ok());
        
        // Create EpochChangeProof with unsigned LedgerInfo
        let proof = EpochChangeProof::new(vec![unsigned_li], false);
        
        // Proof verification with waypoint SUCCEEDS without signatures!
        assert!(proof.verify(&waypoint).is_ok());
        
        println!("VULNERABILITY CONFIRMED: Waypoint accepts unsigned LedgerInfo!");
    }
}
```

This PoC demonstrates that:
1. A `LedgerInfoWithSignatures` with `AggregateSignature::empty()` (no signatures)
2. Passes waypoint verification successfully
3. Can be used in an `EpochChangeProof` to advance epoch state
4. Completely bypassing the BFT quorum requirement

**Notes**

While waypoints are designed as trust anchors for bootstrapping, the complete absence of signature verification for epoch-ending blocks violates the fundamental BFT safety property. Even if the waypoint data is trusted, the cryptographic proof of validator agreement should still be required to maintain consensus accountability and prevent accepting blocks that were never actually committed by the validator set. The fix should balance bootstrap flexibility with consensus safety guarantees.

### Citations

**File:** types/src/waypoint.rs (L62-79)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
```

**File:** types/src/waypoint.rs (L82-85)
```rust
impl Verifier for Waypoint {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> Result<()> {
        self.verify(ledger_info.ledger_info())
    }
```

**File:** types/src/waypoint.rs (L129-136)
```rust
#[derive(Deserialize, Serialize, CryptoHasher, BCSCryptoHash)]
struct Ledger2WaypointConverter {
    epoch: u64,
    root_hash: HashValue,
    version: Version,
    timestamp_usecs: u64,
    next_epoch_state: Option<EpochState>,
}
```

**File:** consensus/safety-rules/src/safety_rules.rs (L265-269)
```rust
    fn guarded_initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error> {
        let waypoint = self.persistent_storage.waypoint()?;
        let last_li = proof
            .verify(&waypoint)
            .map_err(|e| Error::InvalidEpochChangeProof(format!("{}", e)))?;
```

**File:** types/src/epoch_change.rs (L66-118)
```rust
    pub fn verify(&self, verifier: &dyn Verifier) -> Result<&LedgerInfoWithSignatures> {
        ensure!(
            !self.ledger_info_with_sigs.is_empty(),
            "The EpochChangeProof is empty"
        );
        ensure!(
            !verifier
                .is_ledger_info_stale(self.ledger_info_with_sigs.last().unwrap().ledger_info()),
            "The EpochChangeProof is stale as our verifier is already ahead \
             of the entire EpochChangeProof"
        );
        let mut verifier_ref = verifier;

        for ledger_info_with_sigs in self
            .ledger_info_with_sigs
            .iter()
            // Skip any stale ledger infos in the proof prefix. Note that with
            // the assertion above, we are guaranteed there is at least one
            // non-stale ledger info in the proof.
            //
            // It's useful to skip these stale ledger infos to better allow for
            // concurrent client requests.
            //
            // For example, suppose the following:
            //
            // 1. My current trusted state is at epoch 5.
            // 2. I make two concurrent requests to two validators A and B, who
            //    live at epochs 9 and 11 respectively.
            //
            // If A's response returns first, I will ratchet my trusted state
            // to epoch 9. When B's response returns, I will still be able to
            // ratchet forward to 11 even though B's EpochChangeProof
            // includes a bunch of stale ledger infos (for epochs 5, 6, 7, 8).
            //
            // Of course, if B's response returns first, we will reject A's
            // response as it's completely stale.
            .skip_while(|&ledger_info_with_sigs| {
                verifier.is_ledger_info_stale(ledger_info_with_sigs.ledger_info())
            })
        {
            // Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof.
            verifier_ref.verify(ledger_info_with_sigs)?;
            // While the original verification could've been via waypoints,
            // all the next epoch changes are verified using the (already
            // trusted) validator sets.
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
        }

        Ok(self.ledger_info_with_sigs.last().unwrap())
    }
```
