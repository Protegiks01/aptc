# Audit Report

## Title
Consensus Split During Gas Schedule Feature Version Upgrades Due to Incompatible Parameter Parsing

## Summary
During protocol upgrades that update the on-chain gas schedule to a new feature version, validators running different software versions will produce different execution results for the same blocks, causing a consensus split. Old validators fail to parse renamed gas parameters and mark all transactions as failed, while new validators execute transactions normally, resulting in divergent state roots.

## Finding Description

The vulnerability occurs in the gas parameter parsing mechanism during feature version upgrades. The core issue is that:

1. **Gas parameter names are version-dependent**: The `define_gas_parameters!` macro uses pattern matching on `feature_version` to determine which parameter names to extract from the on-chain gas schedule. [1](#0-0) 

2. **Parameters are renamed between versions**: Multiple gas parameters have different names across feature versions. For example, `storage_io_per_state_slot_read` was named `"load_data.base"` in versions 0-9 but renamed to `"storage_io_per_state_slot_read"` in version 10+. [2](#0-1) 

3. **Feature version comes from on-chain schedule**: When validators parse gas parameters, they call `from_on_chain_gas_schedule(&map, feature_version)` where `feature_version` is read from the on-chain `GasScheduleV2` resource, not from the validator's software version. [3](#0-2) 

4. **Old validators cannot parse new parameter names**: When a validator compiled with support for feature versions 0-N tries to parse a gas schedule with feature version N+1, its compiled macro code attempts to extract parameters using version N naming conventions. If those parameter names don't exist in the version N+1 schedule (because they were renamed), the parsing fails with an error. [4](#0-3) 

5. **Parse failures cause VM_STARTUP_FAILURE**: When gas parameter parsing fails, the error is stored in the `AptosEnvironment`. Later, when transactions attempt to access gas parameters via `gas_params()`, the function returns `VM_STARTUP_FAILURE`, causing all transactions to fail. [5](#0-4) 

6. **Consensus split occurs**: After a gas schedule update to version N+1:
   - Old validators (software version N): Parse fails → all transactions return `VM_STARTUP_FAILURE` → specific state root
   - New validators (software version N+1): Parse succeeds → transactions execute normally → different state root
   - **Result**: Validators cannot agree on block state, causing consensus split

The environment creation happens once per block from the committed state. [6](#0-5)  When the on-chain gas schedule is updated via `gas_schedule::on_new_epoch()`, all validators in the next epoch read the same on-chain schedule but parse it with their respective software versions, leading to divergent results.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty program for the following reasons:

1. **Consensus/Safety Violation**: Breaks the fundamental invariant that "all validators must produce identical state roots for identical blocks." Different validators executing the same block with the same transactions produce different state roots due to parsing differences.

2. **Non-recoverable Network Partition**: When validators split into two groups (old vs new software), the network partitions. Neither group can achieve >2/3 consensus because they're validating different state roots. This requires a hard fork to resolve, as there's no automatic recovery mechanism.

3. **Total Loss of Liveness**: Once the split occurs, the blockchain cannot make progress. No new blocks can be finalized because validators cannot reach consensus on state roots.

The impact is maximized because it affects the entire validator set during any gas schedule feature version upgrade where parameters are renamed.

## Likelihood Explanation

**Likelihood: Medium-to-High** during protocol upgrades

This vulnerability WILL occur whenever:
1. A gas schedule update changes the feature version from N to N+1
2. The new version renames any gas parameters (common based on historical evidence)
3. Not all validators have upgraded their software to support version N+1 before the on-chain gas schedule is updated

While Aptos likely has operational procedures to coordinate validator upgrades before governance proposals, the code itself provides no enforcement mechanism. The on-chain validation only checks that `new_gas_schedule.feature_version >= cur_gas_schedule.feature_version`. [7](#0-6) 

There is no check to verify that all active validators support the new feature version before allowing the update. A premature governance proposal, mistiming in validator upgrades, or validators failing to upgrade could trigger this vulnerability.

## Recommendation

Implement a feature version compatibility check in the gas schedule update process:

1. **Add validator software version tracking**: Store each validator's maximum supported gas feature version in their validator configuration on-chain.

2. **Add pre-update validation**: Modify `set_for_next_epoch()` to check that all active validators support the new feature version before accepting the update:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    
    // NEW: Verify all validators support the new version
    assert!(
        stake::all_validators_support_feature_version(new_gas_schedule.feature_version),
        error::invalid_state(EVALIDATORS_NOT_READY)
    );
    
    config_buffer::upsert(new_gas_schedule);
}
```

3. **Graceful fallback in parsing**: Modify the macro to support backward-compatible parameter extraction when the exact version-specific name isn't found, falling back to checking previous version names before failing.

## Proof of Concept

While a full PoC requires setting up multiple validators with different software versions, the vulnerability can be demonstrated through the following sequence:

1. **Setup**: Deploy a gas schedule with feature_version 13
2. **Validator A**: Runs software compiled with support for versions 0-13
3. **Validator B**: Runs software compiled with support for versions 0-14
4. **Trigger**: Governance proposal updates gas schedule to feature_version 14 with renamed parameters
5. **Execution in next epoch**:
   - Validator A creates environment, calls `from_on_chain_gas_schedule(&map, 14)`
   - Its macro tries to extract `"txn.free_event_bytes_quota"` (version 13 name)
   - On-chain schedule only has `"txn.legacy_free_event_bytes_quota"` (version 14 name)
   - Returns error: `"Gas parameter txn.free_event_bytes_quota does not exist. Feature version: 14"`
   - All transactions fail with `VM_STARTUP_FAILURE`
   
   - Validator B creates environment, calls `from_on_chain_gas_schedule(&map, 14)`
   - Its macro matches version 14 pattern, extracts `"txn.legacy_free_event_bytes_quota"`
   - Succeeds, transactions execute normally
   
6. **Result**: Different state roots → consensus split

The vulnerability is inherent in the version-dependent parameter naming system combined with the lack of validator software version verification before gas schedule updates.

## Notes

This vulnerability represents a critical design flaw in the gas schedule upgrade mechanism. While operational procedures may mitigate the risk in practice (coordinated upgrades, staged rollouts), the code itself does not prevent the consensus split scenario. The issue becomes particularly severe in emergency situations where rapid gas schedule updates might be needed, as there's no grace period enforcement or compatibility verification at the protocol level.

The rename patterns seen in the codebase (versions 0-9 to 10+, versions 7-13 to 14+) demonstrate that parameter renaming is a recurring pattern in Aptos upgrades, making this a persistent risk with every feature version increase.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L4-16)
```rust
macro_rules! define_gas_parameters_extract_key_at_version {
    ($key: literal, $cur_ver: expr) => {
        Some($key)
    };

    ({ $($ver: pat => $key: literal),+ }, $cur_ver: expr) => {
        match $cur_ver {
            $($ver => Some($key)),+,
            #[allow(unreachable_patterns)]
            _ => None,
        }
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L34-45)
```rust
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L88-96)
```rust
        [
            storage_io_per_state_slot_read: InternalGasPerArg,
            { 0..=9 => "load_data.base", 10.. => "storage_io_per_state_slot_read"},
            // At the current mainnet scale, we should assume most levels of the (hexary) JMT nodes
            // in cache, hence target charging 1-2 4k-sized pages for each read. Notice the cost
            // of seeking for the leaf node is covered by the first page of the "value size fee"
            // (storage_io_per_state_byte_read) defined below.
            302_385,
        ],
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L23-46)
```rust
fn get_gas_config_from_storage(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> (Result<AptosGasParameters, String>, u64) {
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Some((gas_schedule, bytes)) => {
            sha3_256.update(&bytes);
            let feature_version = gas_schedule.feature_version;
            let map = gas_schedule.into_btree_map();
            (
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            )
        },
        None => match GasSchedule::fetch_config_and_bytes(state_view) {
            Some((gas_schedule, bytes)) => {
                sha3_256.update(&bytes);
                let map = gas_schedule.into_btree_map();
                (AptosGasParameters::from_on_chain_gas_schedule(&map, 0), 0)
            },
            None => (Err("Neither gas schedule v2 nor v1 exists.".to_string()), 0),
        },
    }
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-282)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
}
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L205-231)
```rust
    fn try_lock_inner(
        &self,
        state_view: &impl StateView,
        config: &BlockExecutorModuleCacheLocalConfig,
        transaction_slice_metadata: TransactionSliceMetadata,
    ) -> Result<AptosModuleCacheManagerGuard<'_>, VMStatus> {
        // Get the current environment from storage.
        let storage_environment =
            AptosEnvironment::new_with_delayed_field_optimization_enabled(&state_view);

        Ok(match self.inner.try_lock() {
            Some(mut guard) => {
                guard.check_ready(storage_environment, config, transaction_slice_metadata)?;
                AptosModuleCacheManagerGuard::Guard { guard }
            },
            None => {
                alert_or_println!("Locking module cache manager failed, fallback to empty caches");

                // If this is true, we failed to acquire a lock, and so default storage environment
                // and empty (thread-local) module caches will be used.
                AptosModuleCacheManagerGuard::None {
                    environment: storage_environment,
                    module_cache: GlobalModuleCache::empty(),
                }
            },
        })
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```
