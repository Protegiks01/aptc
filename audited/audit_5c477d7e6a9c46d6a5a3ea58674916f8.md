# Audit Report

## Title
Inconsistent SyncInfo Validation Allows Proposals to Bypass Highest Certified Block Requirement

## Summary
The `verify_well_formed()` function in `ProposalMsg` fails to validate that a timeout certificate's internal quorum certificate (QC) is consistent with the `SyncInfo`'s highest quorum certificate (HQC). This allows a malicious proposer to craft proposals that extend an older certified block while using a timeout certificate containing a newer QC, bypassing the consensus invariant that proposals must extend the highest known certified block.

## Finding Description

The vulnerability exists in the interaction between two validation checks in `ProposalMsg::verify_well_formed()`: [1](#0-0) 

This check enforces that the proposal must extend the block certified by `sync_info.highest_quorum_cert()`. [2](#0-1) 

This check validates that `previous_round == max(proposal.qc.round, sync_info.highest_timeout_round())`.

The issue is that `TwoChainTimeoutCertificate` contains an internal quorum certificate (`timeout.quorum_cert`) that certifies a block: [3](#0-2) 

When validators timeout, they aggregate their signatures and the TC contains the highest QC among all 2f+1 signers: [4](#0-3) 

**The Critical Gap**: Nowhere in the codebase is there validation that `tc.quorum_cert.round <= sync_info.HQC.round`. The `SyncInfo` constructor only filters based on the timeout round, not the internal QC round: [5](#0-4) 

**Attack Scenario:**
1. A Byzantine proposer obtains a legitimate QC for block B₅ at round 5
2. The proposer obtains a legitimate TC for round 9 that internally contains a QC for block B₈ at round 8 (where B₈ ≠ B₅)
3. The proposer crafts a `ProposalMsg` for round 10 with:
   - Block extending B₅ (parent_id = B₅.id)
   - Block's QC = QC for B₅
   - SyncInfo(HQC = QC_B₅ at round 5, TC at round 9 with internal QC_B₈ at round 8)

**Validation Bypass:**
- Parent check: `B₅.id == HQC.certified_block.id` ✓ (passes)
- Certified round check: `9 == max(5, 9)` ✓ (passes)  
- TC verification: Signatures valid ✓ (passes)
- **Missing check**: No validation that TC's internal QC (round 8) ≤ HQC (round 5)

The proposal extends block at round 5 while ignoring the certified block at round 8 contained in the TC, violating the consensus invariant that proposals must build on the highest certified block.

## Impact Explanation

**Severity: Medium**

This vulnerability breaks the **Consensus Safety** invariant (#2) by allowing proposals that don't extend the highest certified block. However, actual exploitation requires:

1. **Byzantine proposer**: Must be selected as proposer for the target round
2. **Certificate availability**: Must obtain both an old QC and a newer TC with higher internal QC
3. **Validator state**: Honest validators must not have locally processed the higher QC, otherwise their safety rules prevent voting

While the validation gap is real and violates protocol invariants, full exploitation leading to consensus forks is mitigated by:
- Honest validators' local safety rules checking their own highest certified block
- The requirement that 2f+1 validators signed the TC, meaning ≥f+1 honest validators know about the higher QC
- Network synchronization making it unlikely validators are unaware of recent certified blocks

Impact classification: **Medium severity** - Significant protocol violation that could lead to temporary state inconsistencies requiring intervention, but unlikely to cause permanent consensus failure or fund loss due to honest validator safeguards.

## Likelihood Explanation

**Likelihood: Low to Medium**

Required conditions:
1. **Proposer selection**: Attacker must be chosen as proposer (1/n probability per round where n = validator count)
2. **Certificate timing**: Requires network conditions where validators have different certificate knowledge
3. **Synchronization gap**: Honest validators must not have processed the TC's internal QC yet

The likelihood is reduced by:
- Continuous state synchronization in the consensus protocol
- Safety rules at each validator checking their local highest certified block
- The fact that 2f+1 validators created the TC, so majority awareness of the higher QC

However, during network partitions, epoch transitions, or after prolonged timeout periods, such conditions could temporarily exist.

## Recommendation

Add validation in `SyncInfo::verify()` to ensure the timeout certificate's internal QC doesn't exceed the HQC:

```rust
// In sync_info.rs, add to SyncInfo::verify() after line 165:
if let Some(tc) = &self.highest_2chain_timeout_cert {
    ensure!(
        tc.highest_hqc_round() <= self.highest_certified_round(),
        "TC's internal QC round ({}) exceeds SyncInfo's HQC round ({})",
        tc.highest_hqc_round(),
        self.highest_certified_round()
    );
}
```

Additionally, in `SyncInfo::new_decoupled()`, update the HQC if the TC contains a higher QC:

```rust
// In sync_info.rs, modify lines 57-59:
let (highest_quorum_cert, highest_2chain_timeout_cert) = 
    if let Some(tc) = highest_2chain_timeout_cert {
        if tc.round() > highest_quorum_cert.certified_block().round() {
            // If TC's QC is higher than HQC, update HQC
            if tc.quorum_cert().certified_block().round() > 
               highest_quorum_cert.certified_block().round() {
                (tc.quorum_cert().clone(), Some(tc))
            } else {
                (highest_quorum_cert, Some(tc))
            }
        } else {
            (highest_quorum_cert, None)
        }
    } else {
        (highest_quorum_cert, None)
    };
```

## Proof of Concept

```rust
// This PoC demonstrates the validation gap (requires consensus test framework)
#[cfg(test)]
mod timeout_manipulation_test {
    use super::*;
    use aptos_types::validator_verifier::random_validator_verifier;
    
    #[test]
    fn test_inconsistent_syncinfo_accepted() {
        // Setup: Create validator set
        let (signers, validators) = random_validator_verifier(4, None, false);
        
        // Create QC for block at round 5
        let qc_round_5 = generate_test_qc(5, &signers, &validators);
        
        // Create TC for round 9 with internal QC at round 8
        let tc_round_9_with_qc_8 = generate_test_tc(9, 8, &signers, &validators);
        
        // Create SyncInfo with inconsistent certificates
        let sync_info = SyncInfo::new(
            qc_round_5.clone(),
            qc_round_5.clone().into_wrapped_ledger_info(),
            Some(tc_round_9_with_qc_8),
        );
        
        // Create proposal for round 10 extending round 5
        let proposal = create_test_proposal(
            10,                    // round
            qc_round_5.clone(),   // extends round 5
            sync_info.clone(),
        );
        
        // Verify - THIS SHOULD FAIL but currently passes
        let result = proposal.verify_well_formed();
        
        // VULNERABILITY: This passes even though TC contains QC for round 8
        // but proposal extends round 5
        assert!(result.is_ok(), "Inconsistent SyncInfo was accepted!");
        
        // The certified round check allows this because:
        // previous_round (9) == max(qc_round(5), tc_round(9)) = 9 ✓
        // But proposal extends round 5, ignoring the certified round 8 in TC
    }
}
```

**Note**: Full PoC implementation requires the Aptos consensus test framework with helper functions for generating valid QCs, TCs, and proposals. The above demonstrates the logical flow of the exploit.

### Citations

**File:** consensus/consensus-types/src/proposal_msg.rs (L52-57)
```rust
            self.proposal.parent_id()
                == self.sync_info.highest_quorum_cert().certified_block().id(),
            "Proposal HQC in SyncInfo certifies {}, but block parent id is {}",
            self.sync_info.highest_quorum_cert().certified_block().id(),
            self.proposal.parent_id(),
        );
```

**File:** consensus/consensus-types/src/proposal_msg.rs (L64-73)
```rust
        let highest_certified_round = std::cmp::max(
            self.proposal.quorum_cert().certified_block().round(),
            self.sync_info.highest_timeout_round(),
        );
        ensure!(
            previous_round == highest_certified_round,
            "Proposal {} does not have a certified round {}",
            self.proposal,
            previous_round
        );
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L25-32)
```rust
pub struct TwoChainTimeout {
    /// Epoch number corresponds to the set of validators that are active for this round.
    epoch: u64,
    /// The consensus protocol executes proposals (blocks) in rounds, which monotonically increase per epoch.
    round: Round,
    /// The highest quorum cert the signer has seen.
    quorum_cert: QuorumCert,
}
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L258-262)
```rust
        let hqc_round = timeout.hqc_round();
        if timeout.hqc_round() > self.timeout.hqc_round() {
            self.timeout = timeout;
        }
        self.signatures.add_signature(author, hqc_round, signature);
```

**File:** consensus/consensus-types/src/sync_info.rs (L57-59)
```rust
        // No need to include HTC if it's lower than HQC
        let highest_2chain_timeout_cert = highest_2chain_timeout_cert
            .filter(|tc| tc.round() > highest_quorum_cert.certified_block().round());
```
