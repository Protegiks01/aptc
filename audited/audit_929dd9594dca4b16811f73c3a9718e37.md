# Audit Report

## Title
Unbounded Script Cache Memory Exhaustion Can Cause Validator Node Crashes During Block Execution

## Summary
The Move VM's script cache implementations (`SyncScriptCache` and `UnsyncScriptCache`) have no maximum size limit or eviction policy, allowing unbounded memory growth during block execution. An attacker can exploit this by submitting many unique script transactions within a single block, potentially exhausting memory and causing validator node crashes.

## Finding Description

The script cache is used to store deserialized and verified Move scripts during block execution to avoid redundant processing. The cache is implemented using unbounded hash maps with no size limits: [1](#0-0) [2](#0-1) 

The cache is created fresh for each block as part of the `MVHashMap` structure: [3](#0-2) [4](#0-3) 

When a script transaction is executed, the `unmetered_deserialize_and_cache_script` function deserializes the script bytecode and inserts it into the cache without checking cache size: [5](#0-4) [6](#0-5) 

**Attack Vector:**

1. An attacker submits up to 10,000 unique script transactions (the maximum block size): [7](#0-6) 

2. Each script can be up to 64 KB (or 1 MB for governance scripts): [8](#0-7) 

3. During parallel block execution, all scripts are deserialized and cached, consuming approximately:
   - Serialized bytecode: 10,000 Ã— 64 KB = 640 MB
   - Deserialized + verified structures (estimated 2-3x overhead): 1.3-1.9 GB

4. This memory is allocated directly in Rust's heap and is NOT tracked by the Move VM's memory quota system: [9](#0-8) 

The memory tracking only applies to operations that explicitly call `use_heap_memory()`, but script deserialization happens in "unmetered" functions that bypass this tracking.

5. Script transactions are still fully supported in the Aptos transaction execution flow: [10](#0-9) [11](#0-10) 

If memory allocation fails, Rust will panic/abort, crashing the validator node.

**Security Guarantee Broken:**

This violates the **Resource Limits invariant**: "All operations must respect gas, storage, and computational limits." While gas is charged for script execution, the unbounded cache growth is not subject to any resource limit, allowing memory exhaustion beyond what gas metering controls.

## Impact Explanation

**Severity: Medium**

This qualifies as Medium severity per the Aptos bug bounty criteria:

1. **State inconsistencies requiring intervention**: If validator nodes crash during block execution due to OOM, they must restart and resynchronize state, causing temporary inconsistencies across the network.

2. **Limited but real impact**: While modern validators typically have sufficient RAM (32+ GB), the attack could affect:
   - Resource-constrained validator nodes
   - Nodes under memory pressure from other operations
   - Multiple concurrent blocks being processed

3. **Does not reach High severity** because it doesn't guarantee validator slowdowns or crashes (depends on hardware and memory availability), and recovery is automatic through node restart and state sync.

4. **Does not reach Critical severity** because it doesn't cause permanent consensus breaks, fund loss, or require hardforks. The impact is temporary and recoverable.

## Likelihood Explanation

**Likelihood: Low to Medium**

The attack is feasible but has significant practical barriers:

**Barriers:**
- Requires crafting 10,000 unique script bytecode sequences
- Requires paying transaction fees and gas for all 10,000 transactions
- Requires getting all transactions into a single block (requires mempool flooding or block proposer coordination)
- Modern validators typically have sufficient memory to handle 1-2 GB cache

**Enabling Factors:**
- Scripts are still enabled in Aptos (not deprecated)
- No cache size limit or eviction policy exists
- Memory allocation failures cause node crashes
- Attack targets consensus availability, not requiring validator privileges

## Recommendation

Implement a bounded cache with eviction policy:

1. Add a maximum cache size parameter (e.g., 100 MB or 1000 scripts per block)
2. Implement LRU or FIFO eviction when limit is reached
3. Track cache memory usage and enforce limits
4. Consider integrating script cache memory into the Move VM's memory quota system

Alternatively, charge gas proportional to script size during deserialization to make large-scale attacks economically prohibitive.

## Proof of Concept

A complete PoC would require:
1. Generating 10,000 unique Move script bytecode sequences
2. Submitting them as transactions to the network
3. Monitoring validator memory usage during block execution
4. Observing OOM conditions on resource-constrained nodes

The technical feasibility is confirmed by the code analysis showing unbounded cache growth without memory tracking.

## Notes

This vulnerability represents a **protocol-level resource exhaustion bug** rather than a network-level DoS attack. The unbounded script cache is an implementation oversight where memory allocation bypasses the Move VM's quota system. While modern validators may have sufficient memory to withstand this attack, the lack of any bounds or tracking represents a security gap that should be addressed. The vulnerability is correctly categorized as Medium severity given the practical barriers to exploitation and automatic recovery mechanisms.

### Citations

**File:** third_party/move/move-vm/types/src/code/cache/script_cache.rs (L54-58)
```rust
    pub fn empty() -> Self {
        Self {
            script_cache: RefCell::new(HashMap::new()),
        }
    }
```

**File:** third_party/move/move-vm/types/src/code/cache/script_cache.rs (L131-135)
```rust
    pub fn empty() -> Self {
        Self {
            script_cache: DashMap::new(),
        }
    }
```

**File:** aptos-move/mvhashmap/src/lib.rs (L48-48)
```rust
    script_cache: SyncScriptCache<[u8; 32], CompiledScript, Script>,
```

**File:** aptos-move/mvhashmap/src/lib.rs (L59-68)
```rust
    pub fn new() -> MVHashMap<K, T, V, I> {
        #[allow(deprecated)]
        MVHashMap {
            data: VersionedData::empty(),
            group_data: VersionedGroupData::empty(),
            delayed_fields: VersionedDelayedFields::empty(),

            module_cache: SyncModuleCache::empty(),
            script_cache: SyncScriptCache::empty(),
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L89-104)
```rust
    fn unmetered_deserialize_and_cache_script(
        &self,
        serialized_script: &[u8],
    ) -> VMResult<Arc<CompiledScript>> {
        let hash = sha3_256(serialized_script);
        Ok(match self.module_storage.get_script(&hash) {
            Some(script) => script.deserialized().clone(),
            None => {
                let deserialized_script = self
                    .runtime_environment()
                    .deserialize_into_script(serialized_script)?;
                self.module_storage
                    .insert_deserialized_script(hash, deserialized_script)
            },
        })
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L334-344)
```rust
            let compiled_script = self.unmetered_deserialize_and_cache_script(serialized_script)?;
            let compiled_script = traversal_context.referenced_scripts.alloc(compiled_script);

            // TODO(Gas): Should we charge dependency gas for the script itself?
            check_dependencies_and_charge_gas(
                self.module_storage,
                gas_meter,
                traversal_context,
                compiled_script.immediate_dependencies_iter(),
            )?;
        }
```

**File:** config/src/config/consensus_config.rs (L23-24)
```rust
pub(crate) static MAX_RECEIVING_BLOCK_TXNS: Lazy<u64> =
    Lazy::new(|| 10000.max(2 * MAX_SENDING_BLOCK_TXNS));
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-81)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
        [
            max_transaction_size_in_bytes_gov: NumBytes,
            { RELEASE_V1_13.. => "max_transaction_size_in_bytes.gov" },
            1024 * 1024
        ],
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L38-62)
```rust
impl MemoryAlgebra for StandardMemoryAlgebra {
    fn new(memory_quota: AbstractValueSize, feature_version: u64) -> Self {
        Self {
            initial_memory_quota: memory_quota,
            remaining_memory_quota: memory_quota,
            feature_version,
        }
    }

    #[inline]
    fn use_heap_memory(&mut self, amount: AbstractValueSize) -> PartialVMResult<()> {
        if self.feature_version >= 3 {
            match self.remaining_memory_quota.checked_sub(amount) {
                Some(remaining_quota) => {
                    self.remaining_memory_quota = remaining_quota;
                    Ok(())
                },
                None => {
                    self.remaining_memory_quota = 0.into();
                    Err(PartialVMError::new(StatusCode::MEMORY_LIMIT_EXCEEDED))
                },
            }
        } else {
            Ok(())
        }
```

**File:** types/src/transaction/mod.rs (L815-815)
```rust
            TransactionPayload::Script(script) => Ok(TransactionExecutable::Script(script.clone())),
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1048-1060)
```rust
        match executable {
            TransactionExecutableRef::Script(script) => {
                session.execute(|session| {
                    self.validate_and_execute_script(
                        session,
                        serialized_signers,
                        code_storage,
                        gas_meter,
                        traversal_context,
                        script,
                        trace_recorder,
                    )
                })?;
```
