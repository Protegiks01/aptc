# Audit Report

## Title
Validator Initialization Failure Due to Missing VersionData at Critical Versions Without Recovery Path

## Summary
Validators cannot recover from situations where VersionData is missing for critical versions (including epoch boundaries). When `skip_usage=false` (default in non-sharded mode), the absence of VersionData causes StateStore initialization to fail permanently, preventing validator startup and requiring manual intervention.

## Finding Description

The vulnerability occurs in the StateStore initialization path. When a validator restarts, `create_buffered_state_from_latest_snapshot` must read state storage usage for the latest snapshot version: [1](#0-0) 

This calls `get_state_storage_usage` which retrieves VersionData from the database: [2](#0-1) 

When VersionData is missing and `skip_usage=false`, this fails with an error. The `get_usage` call in LedgerMetadataDb returns: [3](#0-2) 

**Critical scenarios where VersionData can be missing:**

1. **Pruner Race Condition**: The ledger pruner deletes VersionData entries while state merkle snapshots are preserved, particularly at epoch boundaries which must maintain snapshots: [4](#0-3) 

2. **Truncation Mismatch**: During crash recovery, `sync_commit_progress` may truncate VersionData but fail to properly truncate corresponding state merkle snapshots: [5](#0-4) 

3. **Backup/Restore Inconsistency**: State snapshot restoration via `StateValueRestore` writes usage data separately, creating windows where snapshots exist without VersionData: [6](#0-5) 

**Why recovery fails:**

The system has `get_usage_before_or_at` which could find the nearest previous version with usage data: [7](#0-6) 

However, this fallback is **not used** during initialization. The `skip_usage` flag is static (set by storage sharding config) rather than dynamic: [8](#0-7) 

**Cascading failures:**

1. StateStore initialization fails
2. AptosDB initialization fails  
3. Validator cannot start
4. Validator cannot participate in consensus
5. Validator cannot run state sync to recover
6. Requires manual database repair or restore

**Epoch boundary criticality:**

Epoch boundaries are particularly vulnerable because they mandate state snapshots: [9](#0-8) 

The recovery logic specifically targets epoch endings, but assumes VersionData exists: [10](#0-9) 

## Impact Explanation

**Severity: High** - Validator node unable to start/recover

This issue causes **total loss of liveness** for affected validators, meeting the High severity criteria. While it doesn't directly cause consensus violations or fund loss, it creates a non-recoverable state requiring manual intervention. Multiple validators experiencing this simultaneously could:

- Reduce network validator participation below safety threshold
- Require emergency hardfork if widespread
- Violate the **State Consistency** invariant (state transitions must be atomic and verifiable)

The check_usage_consistency verification after snapshot commit shows the system expects VersionData to always exist: [11](#0-10) 

## Likelihood Explanation

**Likelihood: Medium-Low** 

This requires specific conditions:
- Database corruption or inconsistency (low probability in normal operations)
- Pruner race conditions (possible but should be prevented by proper locking)
- Backup/restore procedures not atomic (operational risk)

However, likelihood increases with:
- Long-running validators with extensive pruning
- Complex backup/restore scenarios
- Storage sharding transitions

The deterministic nature means once triggered, 100% of affected validators fail permanently until manual recovery.

## Recommendation

Implement graceful degradation in `create_buffered_state_from_latest_snapshot`:

```rust
let usage = match state_db.get_state_storage_usage(latest_snapshot_version) {
    Ok(usage) => usage,
    Err(_) if !state_db.skip_usage => {
        warn!(
            "VersionData missing at snapshot version {:?}, attempting fallback",
            latest_snapshot_version
        );
        // Fallback: try to find nearest previous version with usage
        if let Some(version) = latest_snapshot_version {
            if let Ok((_, usage)) = state_db.ledger_db.metadata_db()
                .get_usage_before_or_at(version) {
                warn!("Using usage from earlier version for recovery");
                usage
            } else {
                // Last resort: use untracked if we can't find any usage data
                warn!("No usage data found, using untracked for recovery");
                StateStorageUsage::new_untracked()
            }
        } else {
            StateStorageUsage::zero()
        }
    },
    Err(e) => return Err(e),
};
```

Additionally, enhance `sync_commit_progress` to verify VersionData exists for all preserved snapshots before completing recovery.

## Proof of Concept

```rust
// Reproduction steps (requires validator access):
// 1. Start validator and let it commit several epochs
// 2. Identify latest epoch boundary snapshot version (e.g., 10000)
// 3. Stop validator
// 4. Manually delete VersionData entry for version 10000:
//    - Open RocksDB with aptos-db-tool
//    - Delete from VersionDataSchema column family at key 10000
// 5. Restart validator
// 
// Expected: StateStore initialization fails with:
// "VersionData at 10000 is missing"
//
// Observed: Validator cannot start, requires database restore

// Test case demonstrating the initialization path:
#[test]
fn test_missing_version_data_at_snapshot() {
    let tmpdir = TempPath::new();
    let db = AptosDB::new_for_test(&tmpdir);
    
    // Commit some transactions to create a snapshot
    // ... commit logic ...
    
    // Manually delete VersionData for snapshot version
    // ... deletion logic ...
    
    // Attempt to reopen database
    let result = AptosDB::open(/* ... */);
    
    // Should fail with VersionData missing error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("VersionData"));
}
```

## Notes

This represents a **resilience gap** rather than an exploitable vulnerability. No external attacker can trigger missing VersionData through normal transaction submission or network interaction. However, under operational failures (corruption, restore issues) or implementation bugs (pruner races), validators lose the ability to self-recover, violating availability guarantees and requiring manual intervention potentially at critical epoch boundaries.

### Citations

**File:** storage/aptosdb/src/state_store/mod.rs (L238-248)
```rust
    fn get_state_storage_usage(&self, version: Option<Version>) -> Result<StateStorageUsage> {
        version.map_or(Ok(StateStorageUsage::zero()), |version| {
            Ok(match self.ledger_db.metadata_db().get_usage(version) {
                Ok(data) => data,
                _ => {
                    ensure!(self.skip_usage, "VersionData at {version} is missing.");
                    StateStorageUsage::new_untracked()
                },
            })
        })
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L448-449)
```rust
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");
```

**File:** storage/aptosdb/src/state_store/mod.rs (L586-586)
```rust
        let usage = state_db.get_state_storage_usage(latest_snapshot_version)?;
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L314-320)
```rust
    pub(crate) fn get_usage(&self, version: Version) -> Result<StateStorageUsage> {
        Ok(self
            .db
            .get::<VersionDataSchema>(&version)?
            .ok_or_else(|| anyhow!("VersionData missing for version {version}"))?
            .get_state_storage_usage())
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L327-341)
```rust
    pub(crate) fn get_usage_before_or_at(
        &self,
        version: Version,
    ) -> Result<(Version, StateStorageUsage)> {
        let mut iter = self.db.iter::<VersionDataSchema>()?;
        iter.seek_for_prev(&version)?;
        match iter.next().transpose()? {
            Some((previous_version, data)) => {
                Ok((previous_version, data.get_state_storage_usage()))
            },
            None => Err(AptosDbError::NotFound(
                "Unable to find a version before the given version with usage.".to_string(),
            )),
        }
    }
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L233-240)
```rust
            // epoch ending:
            let mut iter = ledger_metadata_db.db().iter::<EpochByVersionSchema>()?;
            iter.seek_for_prev(&version)?;
            if let Some((closest_epoch_version, _)) = iter.next().transpose()? {
                if root_exists_at_version(state_merkle_db, closest_epoch_version)? {
                    return Ok(Some(closest_epoch_version));
                }
            }
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L450-454)
```rust
    delete_per_version_data_impl::<VersionDataSchema>(
        &ledger_db.metadata_db_arc(),
        start_version,
        &mut batch.ledger_metadata_db_batches,
    )?;
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L129-135)
```rust
    pub fn finish(self) -> Result<()> {
        let progress = self.db.get_progress(self.version)?;
        self.db.kv_finish(
            self.version,
            progress.map_or(StateStorageUsage::zero(), |p| p.usage),
        )
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L148-160)
```rust
        let mut myself = Self::new_with_dbs(
            ledger_db,
            hot_state_merkle_db,
            state_merkle_db,
            state_kv_db,
            pruner_config,
            buffered_state_target_items,
            readonly,
            empty_buffered_state_for_restore,
            rocksdb_configs.enable_storage_sharding,
            internal_indexer_db,
            hot_state_config,
        );
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L585-594)
```rust
        if ledger_info_with_sig.ledger_info().ends_epoch() {
            let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
            ensure!(
                state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
                "State checkpoint not persisted at the end of the epoch, version {}, next_epoch {}, snapshot in db: {:?}",
                version,
                ledger_info_with_sig.ledger_info().next_block_epoch(),
                state_snapshot,
            );
        }
```

**File:** storage/aptosdb/src/state_store/state_merkle_batch_committer.rs (L136-168)
```rust
    fn check_usage_consistency(&self, state: &State) -> Result<()> {
        let version = state
            .version()
            .ok_or_else(|| anyhow!("Committing without version."))?;

        let usage_from_ledger_db = self.state_db.ledger_db.metadata_db().get_usage(version)?;
        let leaf_count_from_jmt = self
            .state_db
            .state_merkle_db
            .metadata_db()
            .get::<JellyfishMerkleNodeSchema>(&NodeKey::new_empty_path(version))?
            .ok_or_else(|| anyhow!("Root node missing at version {}", version))?
            .leaf_count();

        ensure!(
            usage_from_ledger_db.items() == leaf_count_from_jmt,
            "State item count inconsistent, {} from ledger db and {} from state tree.",
            usage_from_ledger_db.items(),
            leaf_count_from_jmt,
        );

        let usage_from_in_mem_state = state.usage();
        if !usage_from_in_mem_state.is_untracked() {
            ensure!(
                usage_from_in_mem_state == usage_from_ledger_db,
                "State storage usage info inconsistent. from smt: {:?}, from ledger_db: {:?}",
                usage_from_in_mem_state,
                usage_from_ledger_db,
            );
        }

        Ok(())
    }
```
