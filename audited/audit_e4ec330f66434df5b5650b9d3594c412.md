# Audit Report

## Title
Unbounded Memory Allocation in JWK Fetching Can Cause Validator Node DoS

## Summary
The `fetch_jwks_from_jwks_uri()` function fetches JWKs from external OIDC provider URLs without size limits, content-length validation, or timeout configuration. When combined with the `UnsupportedJWK::from()` conversion that stringifies entire JSON payloads, this creates a memory exhaustion vector where validators can be forced to allocate unbounded memory when processing maliciously large or malformed JWK responses from compromised OIDC providers.

## Finding Description

The JWK consensus system in Aptos periodically fetches JSON Web Keys from external OIDC provider URLs to support keyless authentication. The vulnerability exists in the JWK fetching and parsing pipeline:

**Step 1: Unbounded HTTP Fetching** [1](#0-0) 

The function creates a default `reqwest::Client` with no size limits, timeouts, or response validation. The `.json().await?` call will attempt to deserialize the entire HTTP response body into memory regardless of size.

**Step 2: Conversion to UnsupportedJWK for Non-RSA Keys** [2](#0-1) 

When a JWK cannot be parsed as a valid RSA key (e.g., due to missing required fields, invalid `kty`, or containing only unsupported fields like `x5c`), it falls back to `UnsupportedJWK`.

**Step 3: Unbounded String Conversion** [3](#0-2) 

The `UnsupportedJWK::from()` implementation converts the entire JSON value to a string without any size validation. For a JWK containing extremely long fields (e.g., a malicious `x5c` certificate chain with gigabytes of data), this will allocate and copy the entire payload into memory.

**Step 4: Consensus Processing** [4](#0-3) 

The `JWKObserver` runs this fetch operation periodically on all validator nodes. A compromised OIDC provider in the `SupportedOIDCProviders` list can serve malicious responses to all validators simultaneously.

**Attack Scenario:**
1. An OIDC provider in `SupportedOIDCProviders` is compromised (supply chain attack, DNS hijacking, BGP attack, or provider vulnerability)
2. The provider serves JWK responses with multi-gigabyte field values (e.g., `{"kty": "EC", "x5c": ["AAAA...gigabytes...AAAA"]}`)
3. All validators fetch and attempt to parse this response every fetch interval
4. Each validator allocates gigabytes of memory for string conversion and JSON processing
5. Validators experience memory exhaustion, slowdowns, or crashes (OOM)
6. JWK consensus fails as the resulting `ValidatorTransaction` would exceed the 2MB per-block limit [5](#0-4) 

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:
- **Validator node slowdowns**: Memory exhaustion and garbage collection pressure degrade validator performance
- **API crashes**: Out-of-memory conditions can crash validator processes
- **Network availability impact**: If enough validators are affected simultaneously, JWK consensus becomes unavailable

This breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits." The JWK fetching operation has no memory or bandwidth limits despite being a critical validator function.

While this doesn't directly threaten consensus safety or fund security, it creates a high-severity availability attack vector against the validator network.

## Likelihood Explanation

**Medium-to-High Likelihood:**

**Requirements:**
- Compromise of an OIDC provider in `SupportedOIDCProviders` list

**Realistic Attack Vectors:**
1. **Supply chain attack**: Compromise of legitimate OIDC provider infrastructure (e.g., Google, Facebook OAuth systems)
2. **DNS/BGP hijacking**: Redirect JWK fetch requests to attacker-controlled servers
3. **Provider vulnerability**: Exploit in OIDC provider software allowing response manipulation
4. **Insider threat**: Malicious actor at the OIDC provider

**Mitigating Factors:**
- Requires governance approval to add providers (but existing providers are targets)
- May be detected before widespread impact if monitoring is in place

**Amplifying Factors:**
- All validators fetch simultaneously every epoch
- Single compromised provider affects entire network
- No automatic recovery mechanism

## Recommendation

Implement defense-in-depth protections for external HTTP requests:

```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    // Add size and timeout limits
    const MAX_RESPONSE_SIZE: usize = 1024 * 1024; // 1MB
    const REQUEST_TIMEOUT: Duration = Duration::from_secs(10);
    
    let client = reqwest::Client::builder()
        .timeout(REQUEST_TIMEOUT)
        .build()?;
        
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    
    // Fetch response and check content-length
    let response = request_builder.send().await?;
    
    if let Some(content_length) = response.content_length() {
        ensure!(
            content_length <= MAX_RESPONSE_SIZE as u64,
            "JWK response too large: {} bytes", 
            content_length
        );
    }
    
    // Read with size limit
    let bytes = response.bytes().await?;
    ensure!(
        bytes.len() <= MAX_RESPONSE_SIZE,
        "JWK response exceeded size limit"
    );
    
    // Parse JSON with size-validated bytes
    let jwks_response: JWKsResponse = serde_json::from_slice(&bytes)?;
    let jwks = jwks_response.keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

Additionally, add a size limit to `UnsupportedJWK::from()`:

```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        const MAX_PAYLOAD_SIZE: usize = 10 * 1024; // 10KB
        let payload = json_value.to_string().into_bytes();
        
        // Truncate or reject oversized payloads
        let payload = if payload.len() > MAX_PAYLOAD_SIZE {
            // Option 1: Truncate
            payload[..MAX_PAYLOAD_SIZE].to_vec()
            // Option 2: Hash instead
            // HashValue::sha3_256_of(&payload).to_vec()
        } else {
            payload
        };
        
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_jwk_memory_exhaustion() {
    use wiremock::{Mock, MockServer, ResponseTemplate};
    use wiremock::matchers::{method, path};
    
    // Start mock server
    let mock_server = MockServer::start().await;
    
    // Create malicious JWK response with gigabyte-sized field
    let malicious_x5c = "A".repeat(1024 * 1024 * 1024); // 1GB string
    let malicious_jwk = serde_json::json!({
        "keys": [{
            "kty": "UNKNOWN", // Not RSA, will become UnsupportedJWK
            "x5c": [malicious_x5c],
            "kid": "malicious"
        }]
    });
    
    Mock::given(method("GET"))
        .and(path("/jwks"))
        .respond_with(ResponseTemplate::new(200).set_body_json(malicious_jwk))
        .mount(&mock_server)
        .await;
    
    // This will attempt to allocate 1GB+ of memory
    let result = fetch_jwks_from_jwks_uri(
        None,
        &format!("{}/jwks", mock_server.uri())
    ).await;
    
    // Without size limits, this succeeds but exhausts memory
    // With proper limits, this should fail gracefully
    assert!(result.is_err(), "Should reject oversized response");
}
```

## Notes

This vulnerability demonstrates the **critical importance of validating all external inputs**, especially when those inputs come from semi-trusted third parties like OIDC providers. While OIDC providers are added through governance and generally trustworthy, they represent a significant attack surface:

1. **Supply chain risk**: Major OAuth providers (Google, Facebook, Apple) are high-value targets for nation-state actors
2. **Blast radius**: Compromise of a single provider affects all validators simultaneously
3. **Detection difficulty**: Malicious responses may appear legitimate until memory exhaustion occurs

The lack of size limits violates defense-in-depth principles and creates unnecessary fragility in the validator network's availability guarantees.

### Citations

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** types/src/jwks/jwk/mod.rs (L80-90)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
}
```

**File:** types/src/jwks/unsupported/mod.rs (L51-59)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L51-90)
```rust
    async fn start(
        fetch_interval: Duration,
        my_addr: AccountAddress,
        issuer: String,
        open_id_config_url: String,
        observation_tx: aptos_channel::Sender<(), (Issuer, Vec<JWK>)>,
        close_rx: oneshot::Receiver<()>,
    ) {
        let mut interval = tokio::time::interval(fetch_interval);
        interval.set_missed_tick_behavior(MissedTickBehavior::Delay);
        let mut close_rx = close_rx.into_stream();
        let my_addr = if cfg!(feature = "smoke-test") {
            // Include self validator address in JWK request,
            // so dummy OIDC providers in smoke tests can do things like "key A for validator 1, key B for validator 2".
            Some(my_addr)
        } else {
            None
        };

        loop {
            tokio::select! {
                _ = interval.tick().fuse() => {
                    let timer = Instant::now();
                    let result = fetch_jwks(open_id_config_url.as_str(), my_addr).await;
                    debug!(issuer = issuer, "observe_result={:?}", result);
                    let secs = timer.elapsed().as_secs_f64();
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
                    } else {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "err"]).observe(secs);
                    }
                },
                _ = close_rx.select_next_some() => {
                    break;
                }
            }
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```
