# Audit Report

## Title
IndexerAsyncV2 Missing Schema Version Validation Enables Database Corruption on Incompatible Upgrades

## Summary
The `IndexerAsyncV2::new()` function lacks schema version validation when loading an existing database, allowing a node running a newer version with modified schemas to load a database created by an incompatible older version, potentially causing API failures, data corruption, or service crashes.

## Finding Description

The `bootstrap()` function in `runtime.rs` initializes `IndexerAsyncV2` at line 79 without any schema compatibility checks: [1](#0-0) 

The `IndexerAsyncV2::new()` implementation only reads the transaction version metadata, not any schema version: [2](#0-1) 

The `MetadataKey` enum contains no schema version field: [3](#0-2) 

The `open_db()` function performs no version validation: [4](#0-3) 

**Exploitation Scenario:**
1. An Aptos release modifies the `TableInfo` structure (e.g., adds fields, changes semantics) defined at: [5](#0-4) 

2. Node operator upgrades to the new version without wiping the indexer database
3. `IndexerAsyncV2::new()` successfully loads the old database
4. BCS deserialization either fails (crashes) or silently misinterprets data
5. The `get_table_info()` methods return corrupted data used by the API: [6](#0-5) 

6. API endpoints crash or return incorrect table item data: [7](#0-6) 

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria for "API crashes" and "significant protocol violations." While the indexer is optional and only required when `indexer_grpc.enabled` is true (as enforced by config sanitization): [8](#0-7) 

When enabled, corrupted indexer data causes:
- **API Service Disruption**: Fullnodes serving API queries will crash or return incorrect data
- **Data Integrity Violation**: External indexer services receive corrupted table metadata
- **Operational Impact**: Requires manual intervention to detect and resolve

Importantly, this does NOT affect consensus operations, as the indexer is not in the consensus-critical path and validators can operate without it enabled.

## Likelihood Explanation

**Likelihood: Medium** - This occurs when:
1. A release includes schema changes (infrequent but possible as noted in migration comments)
2. Node operators upgrade without wiping the indexer database (common operational practice if not documented)
3. The node has `indexer_grpc.enabled = true` (typical for API-serving fullnodes)

The comment in `db_v2.rs` indicates this is part of an ongoing migration: [9](#0-8) 

## Recommendation

Add schema version tracking to the metadata system:

1. **Add `SchemaVersion` to `MetadataKey` enum**
2. **Implement version validation in `IndexerAsyncV2::new()`**:
   - Check stored schema version matches expected version
   - Return clear error if mismatch detected
   - Include migration instructions in error message

3. **Write schema version on database creation**
4. **Document upgrade procedures** requiring database wipe when schema changes

Example fix for `IndexerAsyncV2::new()`:

```rust
const CURRENT_SCHEMA_VERSION: u64 = 1;

pub fn new(db: DB) -> Result<Self> {
    // Check schema version
    let stored_version = db
        .get::<IndexerMetadataSchema>(&MetadataKey::SchemaVersion)?
        .map_or(0, |v| v.expect_version());
    
    if stored_version != CURRENT_SCHEMA_VERSION {
        bail!(
            "Indexer schema version mismatch. Found: {}, Expected: {}. \
             Please wipe the indexer database and restart.",
            stored_version, CURRENT_SCHEMA_VERSION
        );
    }
    
    let next_version = db
        .get::<IndexerMetadataSchema>(&MetadataKey::LatestVersion)?
        .map_or(0, |v| v.expect_version());

    Ok(Self {
        db,
        next_version: AtomicU64::new(next_version),
        pending_on: DashMap::new(),
    })
}
```

## Proof of Concept

This requires a multi-version scenario that cannot be demonstrated in a single test file. However, the vulnerability is confirmed by code inspection showing:

1. No schema version field exists in `MetadataKey`
2. No version validation in `IndexerAsyncV2::new()` 
3. No version validation in `open_db()`
4. Schema structures use BCS serialization without version tags

To reproduce in practice:
1. Run Aptos node version N with indexer enabled
2. Modify `TableInfo` structure in version N+1 (add/remove field)
3. Upgrade to version N+1 without wiping indexer DB
4. Observe initialization succeeds without validation
5. Query API endpoints using table items to trigger deserialization
6. Observe crashes or data corruption

## Notes

This vulnerability affects availability and data integrity but **not consensus safety**, as confirmed by the indexer being optional and separate from the consensus critical path as shown in the config validation logic. The severity is High rather than Critical due to this limitation.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/runtime.rs (L78-79)
```rust
    let indexer_async_v2 =
        Arc::new(IndexerAsyncV2::new(db).expect("Failed to initialize indexer async v2"));
```

**File:** storage/indexer/src/db_v2.rs (L4-7)
```rust
/// This file is a copy of the file storage/indexer/src/lib.rs.
/// At the end of the migration to migrate table info mapping
/// from storage critical path to indexer, the other file will be removed
/// and this file will be moved to /ecosystem/indexer-grpc/indexer-grpc-table-info.
```

**File:** storage/indexer/src/db_v2.rs (L61-71)
```rust
    pub fn new(db: DB) -> Result<Self> {
        let next_version = db
            .get::<IndexerMetadataSchema>(&MetadataKey::LatestVersion)?
            .map_or(0, |v| v.expect_version());

        Ok(Self {
            db,
            next_version: AtomicU64::new(next_version),
            pending_on: DashMap::new(),
        })
    }
```

**File:** storage/indexer_schemas/src/metadata.rs (L31-42)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize, Hash, PartialOrd, Ord)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
pub enum MetadataKey {
    LatestVersion,
    EventPrunerProgress,
    TransactionPrunerProgress,
    StateSnapshotRestoreProgress(Version),
    EventVersion,
    StateVersion,
    TransactionVersion,
    EventV2TranslationVersion,
}
```

**File:** storage/indexer/src/db_ops.rs (L14-35)
```rust
pub fn open_db<P: AsRef<Path>>(
    db_path: P,
    rocksdb_config: &RocksdbConfig,
    readonly: bool,
) -> Result<DB> {
    let env = None;
    if readonly {
        Ok(DB::open_readonly(
            db_path,
            TABLE_INFO_DB_NAME,
            column_families(),
            &gen_rocksdb_options(rocksdb_config, env, readonly),
        )?)
    } else {
        Ok(DB::open(
            db_path,
            TABLE_INFO_DB_NAME,
            column_families(),
            &gen_rocksdb_options(rocksdb_config, env, readonly),
        )?)
    }
}
```

**File:** types/src/state_store/table.rs (L42-47)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
pub struct TableInfo {
    pub key_type: TypeTag,
    pub value_type: TypeTag,
}
```

**File:** storage/indexer/src/indexer_reader.rs (L47-52)
```rust
    fn get_table_info(&self, handle: TableHandle) -> anyhow::Result<Option<TableInfo>> {
        if let Some(table_info_reader) = &self.table_info_reader {
            return Ok(table_info_reader.get_table_info_with_retry(handle)?);
        }
        anyhow::bail!("Table info reader is not available")
    }
```

**File:** api/types/src/convert.rs (L561-577)
```rust
        let table_info = match self.get_table_info(handle)? {
            Some(ti) => ti,
            None => {
                log_missing_table_info(handle);
                return Ok(None); // if table item not found return None anyway to avoid crash
            },
        };

        let key = self.try_into_move_value(&table_info.key_type, key)?;
        let value = self.try_into_move_value(&table_info.value_type, value)?;

        Ok(Some(DecodedTableData {
            key: key.json().unwrap(),
            key_type: table_info.key_type.to_canonical_string(),
            value: value.json().unwrap(),
            value_type: table_info.value_type.to_canonical_string(),
        }))
```

**File:** config/src/config/indexer_grpc_config.rs (L115-125)
```rust
        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }
```
