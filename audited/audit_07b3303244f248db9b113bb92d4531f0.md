# Audit Report

## Title
Seed Peer Configuration with Missing Role Field Causes Node Isolation via Deserialization Default

## Summary
The `Peer` struct uses `#[serde(default)]` allowing partial deserialization where missing fields get default values. When the `role` field is missing, it defaults to `PeerRole::Unknown`. The seed validation function `verify_seeds()` does not check the role field, allowing Unknown-role seeds to pass validation. However, the connectivity manager filters peers by role when selecting which peers to dial, and `PeerRole::Unknown` is not included in the dialable roles list for any network type. This causes nodes with misconfigured seed peers to never dial them, resulting in network isolation and loss of liveness.

## Finding Description

The vulnerability exists in the interaction between configuration deserialization and peer selection logic: [1](#0-0) 

The `Peer` struct has `#[serde(default)]` which allows partial JSON configurations to be deserialized with default values for missing fields. The `role` field defaults to `PeerRole::Unknown`: [2](#0-1) 

The seed validation function only checks for addresses and keys, but does NOT validate the role field: [3](#0-2) 

When seeds are processed by the connectivity manager, they are added to the discovered peers set with their configured role: [4](#0-3) 

However, when the connectivity manager selects peers to dial, it filters by role using `upstream_roles()`: [5](#0-4) 

For Public (fullnode) networks, the dialable upstream roles are defined as: [6](#0-5) 

`PeerRole::Unknown` is NOT included in this list. This means seed peers with Unknown role will be filtered out at line 584 and never dialed.

**Attack Scenario:**
1. Node operator creates a seed peer configuration file with partial JSON (missing `role` field)
2. During deserialization, `role` defaults to `PeerRole::Unknown`
3. Seeds pass `verify_seeds()` validation (only checks addresses/keys)
4. Seeds are added to discovered peers and trusted peers set
5. When connectivity manager attempts to select peers to dial, it filters by `roles_to_dial.contains(&peer.role)`
6. Seeds with Unknown role are excluded from dialing
7. If these are the only seeds configured, the node cannot dial any peers and becomes isolated
8. Node cannot sync state, participate in consensus, or serve requests

There's even a TODO comment acknowledging this should be prevented: [7](#0-6) 

## Impact Explanation

**Severity: Medium** - This vulnerability causes loss of network liveness/availability for affected nodes.

According to the Aptos Bug Bounty program, Medium severity issues include "State inconsistencies requiring intervention." A node that cannot connect to the network due to misconfigured seeds cannot sync state and requires manual intervention (config correction and restart) to recover.

While this doesn't directly affect funds or consensus safety, it can:
- Isolate fullnodes from the network, preventing state synchronization
- Cause service unavailability for users relying on the affected node
- Affect multiple nodes if the same misconfiguration is distributed widely
- Be exploited through social engineering by distributing malicious seed configurations

The impact is limited because:
- It requires node operator misconfiguration (not directly exploitable)
- Only affects the misconfigured node, not the entire network
- Can be remediated by correcting the configuration and restarting

## Likelihood Explanation

**Likelihood: Medium-High** 

This issue is likely to occur because:
- Partial JSON configurations are a common configuration pattern
- Node operators may copy example configs that are incomplete
- The validation function gives a false sense of security by not catching this error
- The error is silent - seeds appear to load successfully but are never used
- Documentation may not clearly specify that all fields are required

The issue could be triggered by:
- Honest mistakes by node operators creating configurations
- Copying partial example configurations from documentation
- Social engineering attacks distributing malicious seed configs
- Automated config generation tools that omit optional-looking fields

## Recommendation

**Fix 1: Add role validation to `verify_seeds()`**

Add explicit validation to reject seeds with `PeerRole::Unknown` in the `verify_seeds()` function in `config/src/config/network_config.rs`:

```rust
pub fn verify_seeds(&self) -> Result<(), Error> {
    for (peer_id, addrs) in self.seed_addrs.iter() {
        for addr in addrs {
            Self::verify_address(peer_id, addr)?;
        }
    }

    for (peer_id, seed) in self.seeds.iter() {
        for addr in seed.addresses.iter() {
            Self::verify_address(peer_id, addr)?;
        }

        // Require there to be a pubkey somewhere
        if seed.keys.is_empty() && seed.addresses.is_empty() {
            return Err(Error::InvariantViolation(format!(
                "Seed peer {} has no pubkeys",
                peer_id.short_str(),
            )));
        }

        // NEW: Validate that role is not Unknown for seed peers
        if seed.role == PeerRole::Unknown {
            return Err(Error::InvariantViolation(format!(
                "Seed peer {} has invalid role 'Unknown'. Seed peers must have an explicit role (Upstream, PreferredUpstream, ValidatorFullNode, etc.)",
                peer_id.short_str(),
            )));
        }
    }
    Ok(())
}
```

**Fix 2: Remove `#[serde(default)]` from Peer struct**

Remove the default attribute to require all fields to be explicitly specified:

```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
// Remove: #[serde(default)]
pub struct Peer {
    pub addresses: Vec<NetworkAddress>,
    pub keys: HashSet<x25519::PublicKey>,
    pub role: PeerRole,
}
```

**Recommended approach:** Implement both fixes for defense in depth - require explicit field specification and validate the role field.

## Proof of Concept

Create a test configuration file demonstrating the vulnerability:

```rust
#[cfg(test)]
mod test_seed_role_validation {
    use super::*;
    use serde_json;

    #[test]
    fn test_partial_peer_config_defaults_to_unknown() {
        // Simulate a partial JSON config missing the role field
        let partial_json = r#"{
            "addresses": ["/ip4/1.2.3.4/tcp/6180"],
            "keys": []
        }"#;
        
        // Deserialize the partial config
        let peer: Peer = serde_json::from_str(partial_json).unwrap();
        
        // The role defaults to Unknown due to serde(default)
        assert_eq!(peer.role, PeerRole::Unknown);
        
        // Create a network config with this seed
        let mut config = NetworkConfig::default();
        let peer_id = PeerId::random();
        config.seeds.insert(peer_id, peer);
        
        // verify_seeds() should FAIL but currently PASSES (the bug)
        // After fix, this should return an error
        assert!(config.verify_seeds().is_ok()); // Currently passes incorrectly
        
        // Demonstrate that such a peer won't be dialed
        let network_id = NetworkId::Public;
        let role = RoleType::FullNode;
        let dialable_roles = network_id.upstream_roles(&role);
        
        // Unknown is not in the dialable roles list
        assert!(!dialable_roles.contains(&PeerRole::Unknown));
        
        println!("BUG: Seed with Unknown role passes validation but will never be dialed!");
    }
}
```

**Notes**

This vulnerability demonstrates a defense-in-depth failure where multiple validation layers all have gaps:
1. Deserialization accepts partial configs via `serde(default)`
2. Seed validation doesn't check the role field
3. Peer selection logic silently filters out Unknown role peers

The combination creates a situation where misconfigured nodes appear to have valid seeds but cannot actually connect to the network. This is particularly dangerous because the failure is silent - the node starts successfully but simply never establishes connections.

### Citations

**File:** config/src/config/network_config.rs (L318-340)
```rust
    // Verifies both the `seed_addrs` and `seeds` before they're merged
    pub fn verify_seeds(&self) -> Result<(), Error> {
        for (peer_id, addrs) in self.seed_addrs.iter() {
            for addr in addrs {
                Self::verify_address(peer_id, addr)?;
            }
        }

        for (peer_id, seed) in self.seeds.iter() {
            for addr in seed.addresses.iter() {
                Self::verify_address(peer_id, addr)?;
            }

            // Require there to be a pubkey somewhere, either in the address (assumed by `is_aptosnet_addr`)
            if seed.keys.is_empty() && seed.addresses.is_empty() {
                return Err(Error::InvariantViolation(format!(
                    "Seed peer {} has no pubkeys",
                    peer_id.short_str(),
                )));
            }
        }
        Ok(())
    }
```

**File:** config/src/config/network_config.rs (L438-443)
```rust
impl Default for PeerRole {
    /// Default to least trusted
    fn default() -> Self {
        PeerRole::Unknown
    }
}
```

**File:** config/src/config/network_config.rs (L458-464)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default)]
pub struct Peer {
    pub addresses: Vec<NetworkAddress>,
    pub keys: HashSet<x25519::PublicKey>,
    pub role: PeerRole,
}
```

**File:** network/framework/src/connectivity_manager/mod.rs (L492-503)
```rust
                    // If we're using server only auth, we need to not evict unknown peers
                    // TODO: We should prevent `Unknown` from discovery sources
                    if !self.mutual_authentication
                        && metadata.origin == ConnectionOrigin::Inbound
                        && (metadata.role == PeerRole::ValidatorFullNode
                            || metadata.role == PeerRole::Unknown)
                    {
                        None
                    } else {
                        Some(*peer_id) // The peer is stale
                    }
                });
```

**File:** network/framework/src/connectivity_manager/mod.rs (L572-586)
```rust
    async fn choose_peers_to_dial(&mut self) -> Vec<(PeerId, DiscoveredPeer)> {
        // Get the eligible peers to dial
        let network_id = self.network_context.network_id();
        let role = self.network_context.role();
        let roles_to_dial = network_id.upstream_roles(&role);
        let discovered_peers = self.discovered_peers.read().peer_set.clone();
        let eligible_peers: Vec<_> = discovered_peers
            .into_iter()
            .filter(|(peer_id, peer)| {
                peer.is_eligible_to_be_dialed() // The node is eligible to dial
                    && !self.connected.contains_key(peer_id) // The node is not already connected
                    && !self.dial_queue.contains_key(peer_id) // There is no pending dial to this node
                    && roles_to_dial.contains(&peer.role) // We can dial this role
            })
            .collect();
```

**File:** network/framework/src/connectivity_manager/mod.rs (L936-941)
```rust
            let mut discovered_peers = self.discovered_peers.write();
            let peer = discovered_peers
                .peer_set
                .entry(peer_id)
                .or_insert_with(|| DiscoveredPeer::new(discovered_peer.role));

```

**File:** config/src/network_id.rs (L173-186)
```rust
    pub fn upstream_roles(&self, role: &RoleType) -> &'static [PeerRole] {
        match self {
            NetworkId::Validator => &[PeerRole::Validator],
            NetworkId::Public => &[
                PeerRole::PreferredUpstream,
                PeerRole::Upstream,
                PeerRole::ValidatorFullNode,
            ],
            NetworkId::Vfn => match role {
                RoleType::Validator => &[],
                RoleType::FullNode => &[PeerRole::Validator],
            },
        }
    }
```
