# Audit Report

## Title
State Snapshot Restoration Bypasses Cryptographic Proof Verification in KvOnly Mode, Enabling TOCTOU File Swap Attacks

## Summary
The state snapshot restoration system fails to verify cryptographic proofs when operating in `KvOnly` mode, creating a time-of-check-time-of-use (TOCTOU) vulnerability. An attacker with access to backup storage can swap chunk files between manifest validation and file reading, causing corrupted state to be written directly to the database without detection, violating the State Consistency invariant.

## Finding Description

The `StateSnapshotChunk` structure stores `FileHandle` paths to blob and proof files as plain strings without integrity protection. [1](#0-0) 

During restoration, the manifest is loaded and its embedded proof is verified to confirm the root hash is valid. [2](#0-1) 

However, this validation only checks that the manifest's declared `root_hash` is cryptographically validâ€”it does NOT authenticate the `FileHandle` paths themselves. The actual chunk files are opened later in the restoration flow. [3](#0-2) 

**TOCTOU Window**: Between manifest validation (time-of-check) and file access (time-of-use), an attacker with write access to backup storage can swap the chunk files to point to malicious or incorrect data.

**Critical Vulnerability in KvOnly Mode**: When `restore_mode` is set to `StateSnapshotRestoreMode::KvOnly`, the restoration system completely bypasses cryptographic proof verification. [4](#0-3) 

The `KvOnly` code path only executes `kv_fn()`, which calls `StateValueRestore::add_chunk`. This method writes chunks directly to the database WITHOUT verifying the `SparseMerkleRangeProof` parameter. [5](#0-4) 

In contrast, `Default` and `TreeOnly` modes call `tree_fn()`, which invokes `JellyfishMerkleRestore::add_chunk_impl` that performs cryptographic verification. [6](#0-5) 

**Exploitation Path**:
1. Validator operator initiates KV snapshot restoration using legitimate manifest
2. Manifest validation passes (root hash proof is valid)
3. Attacker swaps chunk blob/proof files on backup storage between validation and file read
4. Restoration reads malicious chunks from swapped files
5. Because KvOnly mode skips proof verification, corrupted data is written to StateKV database
6. State inconsistency persists, potentially corrupting account balances, resource states, or other critical data

**Production Usage**: KvOnly mode is actively used in the restore coordinator for KV snapshot restoration. [7](#0-6) 

## Impact Explanation

**Severity: Medium** 

This vulnerability causes **state inconsistencies requiring intervention**, meeting the Medium severity criteria per the Aptos bug bounty program. Corrupted state data written during KV-only restoration could lead to:

- Incorrect account balances or resource states persisting in the database
- Consensus divergence if multiple nodes restore from differently-tampered backups
- Potential loss of funds if account states are manipulated to favor an attacker
- Violation of the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs"

The impact is not Critical because:
- Exploitation requires access to backup storage (semi-trusted environment)
- Subsequent tree restoration may expose inconsistencies in some scenarios
- Does not directly cause immediate consensus safety violations or RCE

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
1. Access to modify backup storage files (cloud storage buckets, file systems, etc.)
2. Timing the attack during the TOCTOU window between manifest load and chunk file reads
3. Knowledge that KvOnly mode restoration is being performed

While backup storage is typically controlled by validator operators (trusted role), realistic threat scenarios include:
- Compromised cloud storage credentials (S3, GCS buckets)
- Insider threats from validators or infrastructure providers
- Supply chain attacks on backup infrastructure
- Restoration from partially-trusted or archived backup sources

The vulnerability is particularly concerning because defense-in-depth principles dictate that cryptographic verification should occur regardless of storage source trust level.

## Recommendation

**Immediate Fix**: Remove the KvOnly mode bypass and enforce cryptographic proof verification for ALL restoration modes.

Modify `StateSnapshotRestore::add_chunk` to always verify proofs:

```rust
fn add_chunk(&mut self, chunk: Vec<(K, V)>, proof: SparseMerkleRangeProof) -> Result<()> {
    // ALWAYS verify proof first, regardless of mode
    let tree_verification = self.tree_restore
        .lock()
        .as_mut()
        .unwrap()
        .add_chunk_impl(chunk.iter().map(|(k, v)| (k, v.hash())).collect(), proof)?;
    
    // Then write KV if needed
    match self.restore_mode {
        StateSnapshotRestoreMode::KvOnly | StateSnapshotRestoreMode::Default => {
            self.kv_restore.lock().as_mut().unwrap().add_chunk(chunk)?;
        },
        StateSnapshotRestoreMode::TreeOnly => {
            // Tree already written via verification above
        },
    }
    Ok(())
}
```

**Additional Hardening**:
1. Sign the entire manifest file (including FileHandles) with validator keys, not just the embedded root hash proof
2. Implement path canonicalization and validation for FileHandles to prevent directory traversal
3. Add FileHandle integrity checksums to the manifest that are verified before file opening

## Proof of Concept

```rust
// Reproduction steps (conceptual - requires backup storage setup):

// 1. Create legitimate KV snapshot backup at version 100
//    - Manifest contains root_hash_100 with valid proof
//    - Chunks contain correct state data

// 2. Create malicious KV snapshot at different version 200  
//    - Contains attacker-controlled state (e.g., inflated balances)

// 3. Start restoration with version 100 manifest in KvOnly mode
//    StateSnapshotRestoreController::new(
//        StateSnapshotRestoreOpt {
//            manifest_handle: "backup/v100/manifest.json",
//            version: 100,
//            validate_modules: false,
//            restore_mode: StateSnapshotRestoreMode::KvOnly, // Vulnerable mode
//        },
//        ...
//    )

// 4. Between manifest load (line 123-136) and chunk file open (line 191-192):
//    - Attacker swaps files: backup/v100/chunk_0.blob -> backup/v200/chunk_0.blob
//    - OR modifies manifest beforehand to point FileHandles at v200 chunks

// 5. Restoration proceeds:
//    - read_state_value() reads malicious chunks from v200
//    - add_chunk() called with proof parameter (line 213)
//    - StateSnapshotRestore routes to kv_fn() only (line 247)
//    - StateValueRestore::add_chunk() writes WITHOUT verification (line 88-127)
//    - Corrupted state persists in database

// 6. Verification: Query restored state shows attacker-controlled values
//    - Account balances, module bytecode, or resource data differs from legitimate v100
//    - No error occurred during restoration despite data corruption
```

**Notes**

This vulnerability exemplifies a critical failure in defense-in-depth: cryptographic verification mechanisms are present in the codebase but are bypassed in KvOnly mode. The TOCTOU window exists because the manifest validation occurs separately from chunk file access, and FileHandles lack integrity protection. While the attack requires semi-privileged access to backup storage, the complete absence of verification in KvOnly mode violates fundamental security principles for state restoration systems.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/manifest.rs (L12-27)
```rust
pub struct StateSnapshotChunk {
    /// index of the first account in this chunk over all accounts.
    pub first_idx: usize,
    /// index of the last account in this chunk over all accounts.
    pub last_idx: usize,
    /// key of the first account in this chunk.
    pub first_key: HashValue,
    /// key of the last account in this chunk.
    pub last_key: HashValue,
    /// Repeated `len(record) + record` where `record` is BCS serialized tuple
    /// `(key, state_value)`
    pub blobs: FileHandle,
    /// BCS serialized `SparseMerkleRangeProof` that proves this chunk adds up to the root hash
    /// indicated in the backup (`StateSnapshotBackup::root_hash`).
    pub proof: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-136)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L187-197)
```rust
        let futs_iter = chunks.into_iter().enumerate().map(|(chunk_idx, chunk)| {
            let storage = storage.clone();
            async move {
                tokio::spawn(async move {
                    let blobs = Self::read_state_value(&storage, chunk.blobs.clone()).await?;
                    let proof = storage.load_bcs_file(&chunk.proof).await?;
                    Result::<_>::Ok((chunk_idx, chunk, blobs, proof))
                })
                .await?
            }
        });
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L88-127)
```rust
    pub fn add_chunk(&mut self, mut chunk: Vec<(K, V)>) -> Result<()> {
        // load progress
        let progress_opt = self.db.get_progress(self.version)?;

        // skip overlaps
        if let Some(progress) = progress_opt {
            let idx = chunk
                .iter()
                .position(|(k, _v)| CryptoHash::hash(k) > progress.key_hash)
                .unwrap_or(chunk.len());
            chunk = chunk.split_off(idx);
        }

        // quit if all skipped
        if chunk.is_empty() {
            return Ok(());
        }

        // save
        let mut usage = progress_opt.map_or(StateStorageUsage::zero(), |p| p.usage);
        let (last_key, _last_value) = chunk.last().unwrap();
        let last_key_hash = CryptoHash::hash(last_key);

        // In case of TreeOnly Restore, we only restore the usage of KV without actually writing KV into DB
        for (k, v) in chunk.iter() {
            usage.add_item(k.key_size() + v.value_size());
        }

        // prepare the sharded kv batch
        let kv_batch: StateValueBatch<K, Option<V>> = chunk
            .into_iter()
            .map(|(k, v)| ((k, self.version), Some(v)))
            .collect();

        self.db.write_kv_batch(
            self.version,
            &kv_batch,
            StateSnapshotProgress::new(last_key_hash, usage),
        )
    }
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L228-247)
```rust
    fn add_chunk(&mut self, chunk: Vec<(K, V)>, proof: SparseMerkleRangeProof) -> Result<()> {
        let kv_fn = || {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["state_value_add_chunk"]);
            self.kv_restore
                .lock()
                .as_mut()
                .unwrap()
                .add_chunk(chunk.clone())
        };

        let tree_fn = || {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["jmt_add_chunk"]);
            self.tree_restore
                .lock()
                .as_mut()
                .unwrap()
                .add_chunk_impl(chunk.iter().map(|(k, v)| (k, v.hash())).collect(), proof)
        };
        match self.restore_mode {
            StateSnapshotRestoreMode::KvOnly => kv_fn()?,
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L339-391)
```rust
    pub fn add_chunk_impl(
        &mut self,
        mut chunk: Vec<(&K, HashValue)>,
        proof: SparseMerkleRangeProof,
    ) -> Result<()> {
        if self.finished {
            info!("State snapshot restore already finished, ignoring entire chunk.");
            return Ok(());
        }

        if let Some(prev_leaf) = &self.previous_leaf {
            let skip_until = chunk
                .iter()
                .find_position(|(key, _hash)| key.hash() > *prev_leaf.account_key());
            chunk = match skip_until {
                None => {
                    info!("Skipping entire chunk.");
                    return Ok(());
                },
                Some((0, _)) => chunk,
                Some((num_to_skip, next_leaf)) => {
                    info!(
                        num_to_skip = num_to_skip,
                        next_leaf = next_leaf,
                        "Skipping leaves."
                    );
                    chunk.split_off(num_to_skip)
                },
            }
        };
        if chunk.is_empty() {
            return Ok(());
        }

        for (key, value_hash) in chunk {
            let hashed_key = key.hash();
            if let Some(ref prev_leaf) = self.previous_leaf {
                ensure!(
                    &hashed_key > prev_leaf.account_key(),
                    "State keys must come in increasing order.",
                )
            }
            self.previous_leaf.replace(LeafNode::new(
                hashed_key,
                value_hash,
                (key.clone(), self.version),
            ));
            self.add_one(key, value_hash);
            self.num_keys_received += 1;
        }

        // Verify what we have added so far is all correct.
        self.verify(proof)?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L247-259)
```rust
                StateSnapshotRestoreController::new(
                    StateSnapshotRestoreOpt {
                        manifest_handle: kv_snapshot.manifest,
                        version: kv_snapshot.version,
                        validate_modules: false,
                        restore_mode: StateSnapshotRestoreMode::KvOnly,
                    },
                    self.global_opt.clone(),
                    Arc::clone(&self.storage),
                    epoch_history.clone(),
                )
                .run()
                .await?;
```
