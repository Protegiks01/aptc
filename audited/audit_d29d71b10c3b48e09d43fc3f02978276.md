# Audit Report

## Title
Critical Liveness Failure in Consensus Observer When Execution Pool Is Enabled

## Summary
The consensus observer component has incomplete implementation of `OrderedBlockWithWindow` message processing. When execution pool is enabled via on-chain configuration, observer nodes reject regular `OrderedBlock` messages but never receive `OrderedBlockWithWindow` messages (as they are never published), resulting in complete failure to process any blocks.

## Finding Description

The consensus observer operates in two mutually exclusive modes based on the `execution_pool_window_size` configuration:

**Mode 1: Execution Pool Disabled** (`window_size = None`)
- Accepts `OrderedBlock` messages
- Rejects `OrderedBlockWithWindow` messages

**Mode 2: Execution Pool Enabled** (`window_size = Some(value)`)
- Rejects `OrderedBlock` messages
- Should accept `OrderedBlockWithWindow` messages

However, three critical implementation gaps create a complete liveness failure:

**Gap 1: No Publisher Implementation**
The consensus publisher only creates and sends `OrderedBlock` messages, never `OrderedBlockWithWindow` messages. [1](#0-0) 

There is no helper method to create `OrderedBlockWithWindow` messages, only methods for `OrderedBlock`, `CommitDecision`, and `BlockPayload`: [2](#0-1) 

**Gap 2: Unimplemented Window Validation**
The `verify_window_contents()` method that should validate the execution pool window is not implemented - it simply returns `Ok(())` with a TODO comment, accepting any window including empty `vec![]`: [3](#0-2) 

**Gap 3: Unimplemented Message Processing**
Even if `OrderedBlockWithWindow` messages were received and validated, they would be immediately dropped without processing: [4](#0-3) 

**The Liveness Failure:**

When execution pool is enabled (`window_size.is_some()`):
1. Publisher sends `OrderedBlock` messages (the only type it can send)
2. Observer receives them and immediately rejects them: [5](#0-4) 

3. Observer expects `OrderedBlockWithWindow` messages but never receives them
4. Even if manually sent, observer would verify them (with no actual validation) then drop them
5. **Result: NO BLOCKS ARE PROCESSED**

## Impact Explanation

This represents a **Critical Severity** vulnerability meeting the criteria for "Total loss of liveness/network availability" in the Aptos bug bounty program.

When the execution pool feature is enabled via on-chain governance configuration, consensus observer nodes experience complete block processing failure. While this affects observer nodes rather than validating nodes, it still represents a significant protocol-level implementation failure that could impact:

- Fullnode operators running consensus observers
- Services depending on real-time consensus data
- Network monitoring and observability infrastructure

The vulnerability violates the **Consensus Liveness** invariant - nodes must be able to process and order blocks to maintain chain progress.

## Likelihood Explanation

**Current State:** Low likelihood - The execution pool feature is disabled by default: [6](#0-5) 

**Future Risk:** High likelihood if feature is enabled - The feature can be activated through on-chain governance by setting `window_size` in `OnChainConsensusConfig`: [7](#0-6) 

The presence of `DEFAULT_ENABLED_WINDOW_SIZE = Some(1)` and extensive test coverage indicates this feature is intended for production use, making accidental or intentional enablement a realistic scenario.

## Recommendation

**Fix 1: Implement Publisher Support**
Add a helper method to create `OrderedBlockWithWindow` messages and modify the buffer manager to publish them when execution pool is enabled:

```rust
// In observer_message.rs
impl ConsensusObserverMessage {
    pub fn new_ordered_block_with_window_message(
        blocks: Vec<Arc<PipelinedBlock>>,
        ordered_proof: LedgerInfoWithSignatures,
        execution_pool_window: ExecutionPoolWindow,
    ) -> ConsensusObserverDirectSend {
        let ordered_block = OrderedBlock::new(blocks, ordered_proof);
        let ordered_block_with_window = OrderedBlockWithWindow::new(
            ordered_block,
            execution_pool_window,
        );
        ConsensusObserverDirectSend::OrderedBlockWithWindow(ordered_block_with_window)
    }
}

// In buffer_manager.rs
if let Some(consensus_publisher) = &self.consensus_publisher {
    let message = if let Some(window_size) = self.window_size {
        // Get execution pool window from block_tree
        let window = self.block_tree.get_ordered_block_window(...);
        ConsensusObserverMessage::new_ordered_block_with_window_message(
            ordered_blocks.clone(),
            ordered_proof.clone(),
            window,
        )
    } else {
        ConsensusObserverMessage::new_ordered_block_message(
            ordered_blocks.clone(),
            ordered_proof.clone(),
        )
    };
    consensus_publisher.publish_message(message);
}
```

**Fix 2: Implement Window Validation**
Replace the TODO with actual validation logic:

```rust
pub fn verify_window_contents(&self, expected_window_size: u64) -> Result<(), Error> {
    // Reject empty windows when execution pool is enabled
    if expected_window_size > 0 && self.block_ids.is_empty() {
        return Err(Error::InvalidMessageError(
            "ExecutionPoolWindow cannot be empty when execution pool is enabled".to_string()
        ));
    }
    
    // Verify window size matches expected size
    if self.block_ids.len() as u64 != expected_window_size {
        return Err(Error::InvalidMessageError(format!(
            "ExecutionPoolWindow size mismatch: expected {}, got {}",
            expected_window_size,
            self.block_ids.len()
        )));
    }
    
    Ok(())
}
```

**Fix 3: Implement Message Processing**
Replace the TODO with actual block processing logic similar to the regular `OrderedBlock` path:

```rust
// In consensus_observer.rs, replace line 895:
let observed_ordered_block = ObservedOrderedBlock::new_with_window(ordered_block_with_window);
let pending_block_with_metadata = PendingBlockWithMetadata::new_with_arc(
    peer_network_id,
    message_received_time,
    observed_ordered_block,
);

if self.all_payloads_exist(pending_block_with_metadata.ordered_block().blocks()) {
    self.process_ordered_block(pending_block_with_metadata).await;
} else {
    self.observer_block_data
        .lock()
        .insert_pending_block(pending_block_with_metadata);
}
```

## Proof of Concept

To reproduce this issue:

1. **Enable execution pool via governance:**
```rust
// In a governance proposal
let new_config = OnChainConsensusConfig::V5 {
    alg: ConsensusAlgorithmConfig::default_for_genesis(),
    vtxn: ValidatorTxnConfig::default_for_genesis(),
    window_size: Some(1), // Enable execution pool
    rand_check_enabled: true,
};
// Submit and execute governance proposal
```

2. **Observer node behavior:**
```rust
// Start a consensus observer node
// Monitor logs - you will see:

// When OrderedBlock arrives:
"Received ordered block message from peer: {:?}, but execution pool is enabled! Ignoring"

// When OrderedBlockWithWindow arrives (if manually injected):
// Message is validated, metrics updated, then:
// TODO: process the ordered block with window message (instead of just dropping it!)
// [Block is dropped, no processing occurs]
```

3. **Verification:**
    - Query observer node's last processed block - it remains stuck
    - Check block processing metrics - no blocks processed after feature enablement
    - Observer node cannot sync or provide consensus data

**Note:** This PoC demonstrates incomplete feature implementation rather than an exploitable attack vector, as it requires governance action to enable the broken feature.

### Citations

**File:** consensus/src/pipeline/buffer_manager.rs (L401-405)
```rust
            let message = ConsensusObserverMessage::new_ordered_block_message(
                ordered_blocks.clone(),
                ordered_proof.clone(),
            );
            consensus_publisher.publish_message(message);
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L40-63)
```rust
    pub fn new_ordered_block_message(
        blocks: Vec<Arc<PipelinedBlock>>,
        ordered_proof: LedgerInfoWithSignatures,
    ) -> ConsensusObserverDirectSend {
        let ordered_block = OrderedBlock::new(blocks, ordered_proof);
        ConsensusObserverDirectSend::OrderedBlock(ordered_block)
    }

    /// Creates and returns a new commit decision message using the given commit decision
    pub fn new_commit_decision_message(
        commit_proof: LedgerInfoWithSignatures,
    ) -> ConsensusObserverDirectSend {
        let commit_decision = CommitDecision::new(commit_proof);
        ConsensusObserverDirectSend::CommitDecision(commit_decision)
    }

    /// Creates and returns a new block payload message using the given block, transactions and limit
    pub fn new_block_payload_message(
        block: BlockInfo,
        transaction_payload: BlockTransactionPayload,
    ) -> ConsensusObserverDirectSend {
        let block_payload = BlockPayload::new(block, transaction_payload);
        ConsensusObserverDirectSend::BlockPayload(block_payload)
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L329-332)
```rust
    /// Verifies the execution pool window contents and returns an error if the data is invalid
    pub fn verify_window_contents(&self, _expected_window_size: u64) -> Result<(), Error> {
        Ok(()) // TODO: Implement this method!
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L645-656)
```rust
        // If execution pool is enabled, ignore the message
        if self.get_execution_pool_window_size().is_some() {
            // Log the failure and update the invalid message counter
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received ordered block message from peer: {:?}, but execution pool is enabled! Ignoring: {:?}",
                    peer_network_id, ordered_block.proof_block_info()
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L895-895)
```rust
        // TODO: process the ordered block with window message (instead of just dropping it!)
```

**File:** types/src/on_chain_config/consensus_config.rs (L10-13)
```rust
/// Default Window Size for Execution Pool.
/// This describes the number of blocks in the Execution Pool Window
pub const DEFAULT_WINDOW_SIZE: Option<u64> = None;
pub const DEFAULT_ENABLED_WINDOW_SIZE: Option<u64> = Some(1);
```

**File:** consensus/src/consensus_observer/observer/epoch_state.rs (L101-101)
```rust
        self.execution_pool_window_size = consensus_config.window_size();
```
