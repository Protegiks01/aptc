# Audit Report

## Title
Unmetered UTF-8 Validation Enables Validator CPU Griefing via Large Invalid String Arguments

## Summary
Attackers can submit transactions with large string arguments (up to 1 MB) containing invalid UTF-8 sequences. During transaction execution, validators perform CPU-intensive O(n) UTF-8 validation without charging gas for this work. When validation fails, the transaction is kept and the attacker pays only minimal intrinsic gas, enabling a griefing attack that wastes validator CPU resources.

## Finding Description

The vulnerability exists in the transaction argument validation flow where UTF-8 string validation is performed without proper gas metering.

**Transaction Flow and Validation Timing:**

The transaction validation documentation explicitly shows that "verify arguments" happens in the Verify phase, after the Validate phase completes: [1](#0-0) 

The `VMValidator::validate_transaction` method, used by mempool for transaction acceptance, explicitly defers argument validation to execution time: [2](#0-1) 

**The Vulnerable UTF-8 Validation Code:**

During transaction execution, string arguments undergo UTF-8 validation using Rust's standard library without gas metering: [3](#0-2) 

The code comment acknowledges this is a "HACK mitigation of performance attack" but the mitigation (shortcutting) doesn't prevent the CPU cost—it only avoids the constructor invocation limit. The actual `std::str::from_utf8` call at line 466 performs byte-by-byte UTF-8 validation without interacting with the gas meter.

**Size Limits Allow Large Payloads:**

Arguments can be up to 1 MB in size: [4](#0-3) 

**Missing Gas Metering Acknowledged:**

The codebase contains a comment acknowledging the lack of gas metering for argument construction: [5](#0-4) 

**Attack Execution Path:**

1. Attacker creates a transaction with string arguments approaching 1 MB containing invalid UTF-8 sequences
2. Transaction passes mempool validation (argument validation is deferred)
3. Transaction is included in a block and reaches execution phase
4. Intrinsic gas is charged based on transaction size: [6](#0-5) 

5. The `validate_and_execute_entry_function` is called which triggers argument validation: [7](#0-6) 

6. UTF-8 validation is performed (O(n) CPU work, no gas charged)
7. Validation fails with `FAILED_TO_DESERIALIZE_ARGUMENT`
8. Transaction cleanup is executed, keeping the transaction and charging gas: [8](#0-7) 

The key issue: `FAILED_TO_DESERIALIZE_ARGUMENT` results in a kept transaction (gas is charged), but the attacker only pays intrinsic gas based on transaction size, not for the CPU-intensive UTF-8 validation work performed.

## Impact Explanation

**Severity: Medium (Validator node slowdowns)**

This vulnerability meets the **High Severity** criteria for "Validator node slowdowns" under the Aptos bug bounty program. The impact includes:

1. **Resource Griefing**: Attackers can force validators to waste significant CPU time validating large invalid UTF-8 strings
2. **Cost Asymmetry**: Attacker pays minimal gas (intrinsic cost only) while validators perform O(n) validation work on up to 1 MB payloads
3. **Amplification**: Multiple such transactions can be included in each block, multiplying the effect
4. **All Validators Affected**: Every validator must independently perform the same validation, amplifying network-wide impact

**Quantified Impact:**
- UTF-8 validation scans every byte: 1 MB = 1,048,576 bytes to validate
- With 100 validators, a single transaction causes ~100 MB of validation work network-wide
- At 10 such transactions per block, that's 1 GB of wasted validation work per block
- The attacker pays only the intrinsic transaction gas, not proportional to validation cost

## Likelihood Explanation

**Likelihood: High**

This attack is highly likely to occur because:

1. **No Special Access Required**: Any user can submit transactions with string arguments
2. **Trivial to Execute**: Simply craft a transaction with a large `vector<u8>` marked as a string constructor argument
3. **Low Cost**: Only intrinsic gas is charged, making the attack economically viable
4. **No Detection**: Appears as normal failed transactions in the system
5. **Repeatable**: Can be executed continuously across multiple blocks

The attack is limited only by:
- Transaction size limits (but 1 MB is sufficient for significant impact)
- Mempool spam protections (which are based on account balance, not this specific attack)

## Recommendation

**Immediate Fix: Charge gas proportional to UTF-8 validation work**

Modify the UTF-8 validation shortcut to charge gas based on the byte length being validated. The native `STRING_CHECK_UTF8` function already has proper gas metering—the argument validation should use similar charging:

```rust
// In validate_and_construct function, replace the shortcut at line 433:
if constructor.func_name.as_str() == "utf8" {
    let len = get_len(cursor)?;
    if cursor.position().checked_add(len as u64).is_none_or(|l| l > initial_cursor_len as u64) {
        return Err(VMStatus::error(
            StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
            Some("String argument is too long".to_string()),
        ));
    }

    // ADD: Charge gas for UTF-8 validation work
    let utf8_validation_cost = base_cost + per_byte_cost * len;
    gas_meter.charge(utf8_validation_cost)?;

    let mut arg = vec![];
    read_n_bytes(len, cursor, &mut arg)?;
    std::str::from_utf8(&arg).map_err(|_| constructor_error())?;
    return bcs::to_bytes(&arg)
        .map_err(|_| VMStatus::error(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT, None));
}
```

**Alternative Fix: Validate arguments during mempool acceptance**

Move argument validation to `VMValidator::validate_transaction` so invalid arguments are rejected before reaching the mempool, preventing resource waste entirely.

## Proof of Concept

```rust
// PoC: Create transaction with large invalid UTF-8 string
use aptos_types::transaction::{EntryFunction, TransactionPayload};
use move_core_types::{identifier::Identifier, language_storage::ModuleId};

// Create a 1 MB invalid UTF-8 sequence (lone continuation bytes)
let mut invalid_utf8 = vec![0x80u8; 1_000_000];

// Construct entry function with string argument
let module_id = ModuleId::new(
    AccountAddress::from_hex_literal("0x1").unwrap(),
    Identifier::new("test_module").unwrap(),
);

let entry_fn = EntryFunction::new(
    module_id,
    Identifier::new("process_string").unwrap(),
    vec![],
    vec![bcs::to_bytes(&invalid_utf8).unwrap()], // BCS-encoded invalid UTF-8
);

// Submit transaction with this payload
// Validator will:
// 1. Accept into mempool (no argument validation)
// 2. Include in block
// 3. Charge intrinsic gas (~few thousand gas)
// 4. Perform 1 MB UTF-8 validation (expensive CPU work, NO gas charged)
// 5. Fail with FAILED_TO_DESERIALIZE_ARGUMENT
// 6. Keep transaction and charge the minimal gas
// Result: Attacker pays ~few thousand gas, validator wastes CPU on 1 MB validation
```

**Test to reproduce:**
1. Create a Move module with an entry function accepting `String` argument
2. Submit transaction with 1 MB `vector<u8>` of invalid UTF-8 (e.g., all 0x80 bytes)
3. Observe transaction fails with `FAILED_TO_DESERIALIZE_ARGUMENT`
4. Verify gas charged is only intrinsic cost (~transaction size), not proportional to validation work
5. Profile validator CPU time—should show significant time in `std::str::from_utf8`

## Notes

This vulnerability violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The UTF-8 validation is a computational operation that does not respect gas limits—it performs O(n) work without charging proportional gas.

The issue is particularly severe because:
- The comment "Perhaps in a future we should do proper gas metering here" indicates awareness but no fix
- The "HACK mitigation" comment shows performance concerns were considered but inadequately addressed
- The native `STRING_CHECK_UTF8` function already has correct per-byte gas charging—this code path bypasses it

### Citations

**File:** aptos-move/aptos-vm/src/lib.rs (L13-100)
```rust
//! ```text
//!                   SignedTransaction
//!                            +
//!                            |
//! +--------------------------|-------------------+
//! | Validate  +--------------+--------------+    |
//! |           |                             |    |
//! |           |       check signature       |    |
//! |           |                             |    |
//! |           +--------------+--------------+    |
//! |                          |                   |
//! |                          |                   |
//! |                          v                   |
//! |           +--------------+--------------+    |
//! |           |                             |    |
//! |           |      check size and gas     |    |
//! |           |                             |    +---------------------------------+
//! |           +--------------+--------------+    |         validation error        |
//! |                          |                   |                                 |
//! |                          |                   |                                 |
//! |                          v                   |                                 |
//! |           +--------------+--------------+    |                                 |
//! |           |                             |    |                                 |
//! |           |         run prologue        |    |                                 |
//! |           |                             |    |                                 |
//! |           +--------------+--------------+    |                                 |
//! |                          |                   |                                 |
//! +--------------------------|-------------------+                                 |
//!                            |                                                     |
//! +--------------------------|-------------------+                                 |
//! |                          v                   |                                 |
//! |  Verify   +--------------+--------------+    |                                 |
//! |           |                             |    |                                 |
//! |           |     deserialize script,     |    |                                 |
//! |           |     verify arguments        |    |                                 |
//! |           |                             |    |                                 |
//! |           +--------------+--------------+    |                                 |
//! |                          |                   |                                 |
//! |                          |                   |                                 v
//! |                          v                   |                    +----------------+------+
//! |           +--------------+--------------+    |                    |                       |
//! |           |                             |    +------------------->+ discard, no write set |
//! |           |     deserialize modules     |    | verification error |                       |
//! |           |                             |    |                    +----------------+------+
//! |           +--------------+--------------+    |                                 ^
//! |                          |                   |                                 |
//! |                          |                   |                                 |
//! |                          v                   |                                 |
//! |           +--------------+--------------+    |                                 |
//! |           |                             |    |                                 |
//! |           | verify scripts and modules  |    |                                 |
//! |           |                             |    |                                 |
//! |           +--------------+--------------+    |                                 |
//! |                          |                   |                                 |
//! +--------------------------|-------------------+                                 |
//!                            |                                                     |
//! +--------------------------|-------------------+                                 |
//! |                          v                   |                                 |
//! | Execute   +--------------+--------------+    |                                 |
//! |           |                             |    |                                 |
//! |           |        execute main         |    |                                 |
//! |           |                             |    |                                 |
//! |           +--------------+--------------+    |                                 |
//! |                          |                   |                                 |
//! |      success or failure  |                   |                                 |
//! |                          v                   |                                 |
//! |           +--------------+--------------+    |                                 |
//! |           |                             |    +---------------------------------+
//! |           |        run epilogue         |    | invariant violation (internal panic)
//! |           |                             |    |
//! |           +--------------+--------------+    |
//! |                          |                   |
//! |                          |                   |
//! |                          v                   |
//! |           +--------------+--------------+    |                    +-----------------------+
//! |           |                             |    | execution failure  |                       |
//! |           |       make write set        +------------------------>+ keep, only charge gas |
//! |           |                             |    |                    |                       |
//! |           +--------------+--------------+    |                    +-----------------------+
//! |                          |                   |
//! +--------------------------|-------------------+
//!                            |
//!                            v
//!             +--------------+--------------+
//!             |                             |
//!             |  keep, transaction executed |
//!             |        + gas charged        |
//!             |                             |
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L561-632)
```rust
    pub(crate) fn failed_transaction_cleanup(
        &self,
        prologue_session_change_set: SystemSessionChangeSet,
        error_vm_status: VMStatus,
        gas_meter: &mut impl AptosGasMeter,
        txn_data: &TransactionMetadata,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        serialized_signers: &SerializedSigners,
        log_context: &AdapterLogSchema,
        change_set_configs: &ChangeSetConfigs,
        traversal_context: &mut TraversalContext,
    ) -> (VMStatus, VMOutput) {
        if self.gas_feature_version() >= 12 {
            // Check if the gas meter's internal counters are consistent.
            //
            // Since we are already in the failure epilogue, there is not much we can do
            // other than logging the inconsistency.
            //
            // This is a tradeoff. We have to either
            //   1. Continue to calculate the gas cost based on the numbers we have.
            //   2. Discard the transaction.
            //
            // Option (2) does not work, since it would enable DoS attacks.
            // Option (1) is not ideal, but optimistically, it should allow the network
            // to continue functioning, less the transactions that run into this problem.
            if let Err(err) = gas_meter.algebra().check_consistency() {
                println!(
                    "[aptos-vm][gas-meter][failure-epilogue] {}",
                    err.message()
                        .unwrap_or("No message found -- this should not happen.")
                );
            }
        }

        let txn_status = TransactionStatus::from_vm_status(
            error_vm_status.clone(),
            self.features(),
            self.gas_feature_version() >= RELEASE_V1_38,
        );

        match txn_status {
            TransactionStatus::Keep(status) => {
                // The transaction should be kept. Run the appropriate post transaction workflows
                // including epilogue. This runs a new session that ignores any side effects that
                // might abort the execution (e.g., spending additional funds needed to pay for
                // gas). Even if the previous failure occurred while running the epilogue, it
                // should not fail now. If it somehow fails here, there is no choice but to
                // discard the transaction.
                let output = self
                    .finish_aborted_transaction(
                        prologue_session_change_set,
                        gas_meter,
                        txn_data,
                        resolver,
                        module_storage,
                        serialized_signers,
                        status,
                        log_context,
                        change_set_configs,
                        traversal_context,
                    )
                    .unwrap_or_else(|status| discarded_output(status.status_code()));
                (error_vm_status, output)
            },
            TransactionStatus::Discard(status_code) => {
                let discarded_output = discarded_output(status_code);
                (error_vm_status, discarded_output)
            },
            TransactionStatus::Retry => unreachable!(),
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L945-1016)
```rust
    fn validate_and_execute_entry_function(
        &self,
        module_storage: &impl AptosModuleStorage,
        session: &mut SessionExt<impl AptosMoveResolver>,
        serialized_signers: &SerializedSigners,
        gas_meter: &mut impl AptosGasMeter,
        traversal_context: &mut TraversalContext,
        entry_fn: &EntryFunction,
        trace_recorder: &mut impl TraceRecorder,
    ) -> Result<(), VMStatus> {
        dispatch_loader!(module_storage, loader, {
            let legacy_loader_config = LegacyLoaderConfig {
                charge_for_dependencies: self.gas_feature_version() >= RELEASE_V1_10,
                charge_for_ty_tag_dependencies: self.gas_feature_version() >= RELEASE_V1_27,
            };
            let function = loader.load_instantiated_function(
                &legacy_loader_config,
                gas_meter,
                traversal_context,
                entry_fn.module(),
                entry_fn.function(),
                entry_fn.ty_args(),
            )?;

            // Native entry function is forbidden.
            if function.is_native() {
                return Err(
                    PartialVMError::new(StatusCode::USER_DEFINED_NATIVE_NOT_ALLOWED)
                        .with_message(
                            "Executing user defined native entry function is not allowed"
                                .to_string(),
                        )
                        .finish(Location::Module(entry_fn.module().clone()))
                        .into_vm_status(),
                );
            }

            // The check below should have been feature-gated in 1.11...
            if function.is_friend_or_private() {
                let maybe_randomness_annotation = get_randomness_annotation_for_entry_function(
                    entry_fn,
                    &function.owner_as_module()?.metadata,
                );
                if maybe_randomness_annotation.is_some() {
                    session.mark_unbiasable();
                }
            }

            let args = dispatch_transaction_arg_validation!(
                session,
                &loader,
                gas_meter,
                traversal_context,
                serialized_signers,
                entry_fn.args().to_vec(),
                &function,
                self.features().is_enabled(FeatureFlag::STRUCT_CONSTRUCTORS),
            )?;

            // Execute the function. The function also must be an entry function!
            function.is_entry_or_err()?;
            session.execute_loaded_function(
                function,
                args,
                gas_meter,
                traversal_context,
                &loader,
                trace_recorder,
            )?;
            Ok(())
        })
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1018-1080)
```rust
    fn execute_script_or_entry_function<'a, 'r>(
        &self,
        resolver: &'r impl AptosMoveResolver,
        code_storage: &impl AptosCodeStorage,
        mut session: UserSession<'r>,
        serialized_signers: &SerializedSigners,
        gas_meter: &mut impl AptosGasMeter,
        traversal_context: &mut TraversalContext<'a>,
        txn_data: &TransactionMetadata,
        executable: TransactionExecutableRef<'a>, // TODO[Orderless]: Check what's the right lifetime to use here.
        log_context: &AdapterLogSchema,
        change_set_configs: &ChangeSetConfigs,
        trace_recorder: &mut impl TraceRecorder,
    ) -> Result<(VMStatus, VMOutput), VMStatus> {
        fail_point!("aptos_vm::execute_script_or_entry_function", |_| {
            Err(VMStatus::Error {
                status_code: StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                sub_status: Some(move_core_types::vm_status::sub_status::unknown_invariant_violation::EPARANOID_FAILURE),
                message: None,
            })
        });

        gas_meter.charge_intrinsic_gas_for_transaction(txn_data.transaction_size())?;
        if txn_data.is_keyless() {
            gas_meter.charge_keyless()?;
        }
        if txn_data.is_slh_dsa_sha2_128s() {
            gas_meter.charge_slh_dsa_sha2_128s()?;
        }

        match executable {
            TransactionExecutableRef::Script(script) => {
                session.execute(|session| {
                    self.validate_and_execute_script(
                        session,
                        serialized_signers,
                        code_storage,
                        gas_meter,
                        traversal_context,
                        script,
                        trace_recorder,
                    )
                })?;
            },
            TransactionExecutableRef::EntryFunction(entry_fn) => {
                session.execute(|session| {
                    self.validate_and_execute_entry_function(
                        code_storage,
                        session,
                        serialized_signers,
                        gas_meter,
                        traversal_context,
                        entry_fn,
                        trace_recorder,
                    )
                })?;
            },

            // Not reachable as this function should only be invoked for entry or script
            // transaction payload.
            _ => unreachable!("Only scripts or entry functions are executed"),
        };

```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3160-3162)
```rust
    /// TBD:
    /// 1. Transaction arguments matches the main function's type signature.
    ///    We don't check this item for now and would execute the check at execution time.
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L228-265)
```rust
// Construct arguments. Walk through the arguments and according to the signature
// construct arguments that require so.
// TODO: This needs a more solid story and a tighter integration with the VM.
pub(crate) fn construct_args(
    session: &mut SessionExt<impl AptosMoveResolver>,
    loader: &impl Loader,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    types: &[Type],
    args: Vec<Vec<u8>>,
    ty_args: &[Type],
    allowed_structs: &ConstructorMap,
    is_view: bool,
) -> Result<Vec<Vec<u8>>, VMStatus> {
    // Perhaps in a future we should do proper gas metering here
    let mut res_args = vec![];
    if types.len() != args.len() {
        return Err(invalid_signature());
    }

    let ty_builder = &loader.runtime_environment().vm_config().ty_builder;
    for (ty, arg) in types.iter().zip(args) {
        let subst_res = ty_builder.create_ty_with_subst(ty, ty_args);
        let ty = subst_res.map_err(|e| e.finish(Location::Undefined).into_vm_status())?;
        let arg = construct_arg(
            session,
            loader,
            gas_meter,
            traversal_context,
            &ty,
            allowed_structs,
            arg,
            is_view,
        )?;
        res_args.push(arg);
    }
    Ok(res_args)
}
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L429-468)
```rust
    // HACK mitigation of performance attack
    // To maintain compatibility with vector<string> or so on, we need to allow unlimited strings.
    // So we do not count the string constructor against the max_invocations, instead we
    // shortcut the string case to avoid the performance attack.
    if constructor.func_name.as_str() == "utf8" {
        let constructor_error = || {
            // A slight hack, to prevent additional piping of the feature flag through all
            // function calls. We know the feature is active when more structs then just strings are
            // allowed.
            let are_struct_constructors_enabled = allowed_structs.len() > 1;
            if are_struct_constructors_enabled {
                PartialVMError::new(StatusCode::ABORTED)
                    .with_sub_status(1)
                    .at_code_offset(FunctionDefinitionIndex::new(0), 0)
                    .finish(Location::Module(constructor.module_id.clone()))
                    .into_vm_status()
            } else {
                VMStatus::error(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT, None)
            }
        };
        // Short cut for the utf8 constructor, which is a special case.
        let len = get_len(cursor)?;
        if cursor
            .position()
            .checked_add(len as u64)
            .is_none_or(|l| l > initial_cursor_len as u64)
        {
            // We need to make sure we do not allocate more bytes than
            // needed.
            return Err(VMStatus::error(
                StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
                Some("String argument is too long".to_string()),
            ));
        }

        let mut arg = vec![];
        read_n_bytes(len, cursor, &mut arg)?;
        std::str::from_utf8(&arg).map_err(|_| constructor_error())?;
        return bcs::to_bytes(&arg)
            .map_err(|_| VMStatus::error(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT, None));
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L546-571)
```rust
fn read_n_bytes(n: usize, src: &mut Cursor<&[u8]>, dest: &mut Vec<u8>) -> Result<(), VMStatus> {
    let deserialization_error = |msg: &str| -> VMStatus {
        VMStatus::error(
            StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
            Some(msg.to_string()),
        )
    };
    let len = dest.len();

    // It is safer to limit the length under some big (but still reasonable
    // number).
    const MAX_NUM_BYTES: usize = 1_000_000;
    if len.checked_add(n).is_none_or(|s| s > MAX_NUM_BYTES) {
        return Err(deserialization_error(&format!(
            "Couldn't read bytes: maximum limit of {} bytes exceeded",
            MAX_NUM_BYTES
        )));
    }

    // Ensure we have enough capacity for resizing.
    dest.try_reserve(len + n)
        .map_err(|e| deserialization_error(&format!("Couldn't read bytes: {}", e)))?;
    dest.resize(len + n, 0);
    src.read_exact(&mut dest[len..])
        .map_err(|_| deserialization_error("Couldn't read bytes"))
}
```
