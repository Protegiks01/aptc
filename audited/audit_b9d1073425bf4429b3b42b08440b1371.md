# Audit Report

## Title
Empty JWK Key ID (kid) Validation Bypass in Keyless Authentication

## Summary
The keyless authentication system allows JWKs (JSON Web Keys) to be registered with empty string key IDs (`kid=""`), and permits JWTs with empty kid values to match these JWKs during signature verification. This creates undefined behavior that violates RFC 7517 semantics and enables potential authentication confusion in federated keyless scenarios.

## Finding Description

The vulnerability exists in the JWK lookup mechanism used during keyless transaction validation. When a JWT header contains an empty string for the `kid` (key ID) field, the system will successfully match any JWK that also has `kid=""` for the same issuer.

**Attack Flow:**

1. **JWK Installation with Empty kid**: A federated keyless dapp owner can install a JWK with an empty key ID through `update_federated_jwk_set()`. The function validates that the `kid_vec` is not empty (at least one kid provided) but does NOT validate that individual kid strings are non-empty. [1](#0-0) 

2. **JWT with Empty kid**: When a keyless signature contains a JWT header with `kid=""`, it successfully parses: [2](#0-1) 

3. **JWK Matching**: The `get_jwk_for_authenticator()` function retrieves the kid from the JWT header and uses it for lookup without validation: [3](#0-2) 

4. **Empty String Matching**: The `ProviderJWKs::get_jwk()` method performs string equality comparison, which will match `kid=""` against JWKs with empty kid: [4](#0-3) 

**Security Implications:**

While signature verification provides defense-in-depth, this undefined behavior creates several concerning scenarios:

- **Authentication Confusion**: If an OIDC provider has a bug/misconfiguration that produces JWTs with `kid=""`, users could be authenticated against the wrong JWK
- **Semantic Violation**: RFC 7517 specifies that kid should uniquely identify a key; an empty string violates this semantic requirement  
- **Federated Keyless Risk**: Malicious dapp owners could install JWKs with `kid=""` to exploit edge cases in OIDC provider implementations

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: Creates undefined authentication behavior in edge cases
- **Limited manipulation**: While signature verification prevents full authentication bypass, the ambiguous JWK matching could lead to unexpected authentication states in federated keyless deployments

The issue does NOT rise to High/Critical because:
- Signature verification still occurs (defense-in-depth prevents direct exploit)
- No direct path to fund loss or consensus violation
- Requires specific conditions (OIDC provider issuing `kid=""` + matching JWK installed)

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

- **Attack Prerequisites**:
  - Federated keyless dapp owner must install JWK with `kid=""` (easily done, no validation)
  - OIDC provider must issue JWT with `kid=""` (unusual but possible due to bugs/misconfigurations)
  - Even with both conditions met, signature must still validate (limits exploit surface)

- **Realistic Scenarios**:
  - Accidental: Dapp owner makes configuration error, OIDC provider has bug
  - Malicious: Compromised dapp owner installs `kid=""` JWK to exploit OIDC provider edge cases

## Recommendation

Implement validation to reject empty kid strings at both JWK installation and JWT processing:

**1. Validate kid during JWK creation (Move):**
```move
public entry fun update_federated_jwk_set(...) {
    assert!(!vector::is_empty(&kid_vec), error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
    // Add validation for each kid
    vector::for_each_ref(&kid_vec, |kid_ref| {
        let kid: &String = kid_ref;
        assert!(!string::is_empty(kid), error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
    });
    // ... rest of function
}
```

**2. Validate kid during JWT parsing (Rust):**
```rust
pub fn parse_jwt_header(&self) -> anyhow::Result<JWTHeader> {
    let header: JWTHeader = serde_json::from_str(&self.jwt_header_json)?;
    ensure!(!header.kid.is_empty(), "JWT header kid must not be empty");
    ensure!(!header.alg.is_empty(), "JWT header alg must not be empty");
    Ok(header)
}
```

**3. Additional validation in get_jwk:**
```rust
pub fn get_jwk(&self, id: &str) -> anyhow::Result<&JWKMoveStruct> {
    ensure!(!id.is_empty(), "JWK key ID must not be empty");
    // ... rest of function
}
```

## Proof of Concept

**Move Test (demonstrates empty kid matching):**

```move
#[test(jwk_owner = @0x123)]
fun test_empty_kid_matching(jwk_owner: &signer) {
    // Setup: Install federated JWK with empty kid
    let iss = b"https://malicious.example.com";
    let kid_vec = vector[utf8(b"")];  // Empty kid!
    let alg_vec = vector[utf8(b"RS256")];
    let e_vec = vector[utf8(b"AQAB")];
    let n_vec = vector[utf8(b"test_modulus_value")];
    
    // This should fail but currently succeeds
    aptos_framework::jwks::update_federated_jwk_set(
        jwk_owner, 
        iss, 
        kid_vec, 
        alg_vec, 
        e_vec, 
        n_vec
    );
    
    // JWK with empty kid is now installed
    // Any JWT with kid="" for this issuer will match it
}
```

**Rust Test (demonstrates JWT with empty kid parsing):**

```rust
#[test]
fn test_empty_kid_in_jwt_header() {
    let jwt_header_json = r#"{"kid":"","alg":"RS256"}"#;
    let sig = KeylessSignature {
        jwt_header_json: jwt_header_json.to_string(),
        // ... other fields
    };
    
    // This currently succeeds but should fail
    let header = sig.parse_jwt_header().unwrap();
    assert_eq!(header.kid, "");  // Empty kid parses successfully
    
    // This empty kid will be used for JWK lookup
    // and will match any JWK with kid=""
}
```

## Notes

The vulnerability is confirmed to exist in the codebase with no validation preventing empty kid strings. However, the **exploitability is limited** by signature verification which still occurs after JWK matching. The primary security concern is **undefined behavior** in edge cases rather than a direct authentication bypass. Defense-in-depth should be improved by rejecting semantically invalid empty kid values at all validation points.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L258-277)
```text
    public entry fun update_federated_jwk_set(jwk_owner: &signer, iss: vector<u8>, kid_vec: vector<String>, alg_vec: vector<String>, e_vec: vector<String>, n_vec: vector<String>) acquires FederatedJWKs {
        assert!(!vector::is_empty(&kid_vec), error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        let num_jwk = vector::length<String>(&kid_vec);
        assert!(vector::length(&alg_vec) == num_jwk , error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&e_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&n_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));

        let remove_all_patch = new_patch_remove_all();
        let patches = vector[remove_all_patch];
        while (!vector::is_empty(&kid_vec)) {
            let kid = vector::pop_back(&mut kid_vec);
            let alg = vector::pop_back(&mut alg_vec);
            let e = vector::pop_back(&mut e_vec);
            let n = vector::pop_back(&mut n_vec);
            let jwk = new_rsa_jwk(kid, alg, e, n);
            let patch = new_patch_upsert_jwk(iss, jwk);
            vector::push_back(&mut patches, patch)
        };
        patch_federated_jwks(jwk_owner, patches);
    }
```

**File:** types/src/keyless/mod.rs (L186-200)
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct JWTHeader {
    pub kid: String,
    pub alg: String,
}

impl KeylessSignature {
    /// A reasonable upper bound for the number of bytes we expect in a keyless signature. This is
    /// enforced by our full nodes when they receive TXNs.
    pub const MAX_LEN: usize = 4000;

    pub fn parse_jwt_header(&self) -> anyhow::Result<JWTHeader> {
        let header: JWTHeader = serde_json::from_str(&self.jwt_header_json)?;
        Ok(header)
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L117-126)
```rust
    let jwt_header = sig
        .parse_jwt_header()
        .map_err(|_| invalid_signature!("Failed to parse JWT header"))?;

    let jwk_move_struct = jwks.get_jwk(&pk.iss_val, &jwt_header.kid).map_err(|_| {
        invalid_signature!(format!(
            "JWK for {} with KID {} was not found",
            pk.iss_val, jwt_header.kid
        ))
    })?;
```

**File:** types/src/jwks/mod.rs (L169-186)
```rust
    pub fn get_jwk(&self, id: &str) -> anyhow::Result<&JWKMoveStruct> {
        for jwk_move in self.jwks() {
            let jwk = JWK::try_from(jwk_move)?;
            match jwk {
                JWK::RSA(rsa_jwk) => {
                    if rsa_jwk.kid.eq(id) {
                        return Ok(jwk_move);
                    }
                },
                JWK::Unsupported(unsupported_jwk) => {
                    if unsupported_jwk.id.eq(id.as_bytes()) {
                        return Ok(jwk_move);
                    }
                },
            }
        }
        bail!("JWK with id {} not found", id);
    }
```
