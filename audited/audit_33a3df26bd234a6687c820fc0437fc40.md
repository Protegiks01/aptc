# Audit Report

## Title
Configuration Sanitizer Bypass Allows Production Deployment with Insecure Test Settings

## Summary
The Aptos node configuration system includes a `skip_config_sanitizer` flag that can be set in YAML configuration files to bypass all security validation checks. This allows mainnet validators to start with dangerous test configurations including in-memory key storage, disabled paranoid verification, and test-mode safety rules, without generating any errors or preventing startup.

## Finding Description

The configuration sanitization system in Aptos is designed to enforce critical security requirements for production deployments, particularly for mainnet validators. However, the sanitizer includes a bypass mechanism that can be trivially enabled via configuration file. [1](#0-0) [2](#0-1) 

When `node_startup.skip_config_sanitizer` is set to `true` in a node configuration file, the `NodeConfig::sanitize()` function returns immediately without performing any validation checks. This bypasses critical mainnet security validations including:

**1. SafetyRules Configuration Validation:** [3](#0-2) 

The sanitizer normally prevents:
- Using `InMemoryStorage` backend for consensus keys (keys would be lost on restart)
- Enabling test configuration mode on mainnet
- Using non-local SafetyRules service

**2. Execution Configuration Validation:** [4](#0-3) 

The sanitizer normally enforces:
- `paranoid_hot_potato_verification` must be enabled on mainnet
- `paranoid_type_verification` must be enabled on mainnet

**3. Production Startup Path:** [5](#0-4) [6](#0-5) 

The production startup path calls `NodeConfig::load_from_path()` which internally uses `NodeConfigLoader::load_and_sanitize_config()`, but if the loaded config has `skip_config_sanitizer: true`, all validations are bypassed.

**Attack Scenario:**

A mainnet validator operator could deploy a configuration file containing:
```yaml
node_startup:
  skip_config_sanitizer: true

consensus:
  safety_rules:
    backend:
      type: in_memory_storage
    test:
      author: "0x..."
      consensus_key: "..."
    service: serializer

execution:
  paranoid_hot_potato_verification: false
  paranoid_type_verification: false
```

This configuration would:
1. Successfully load without errors
2. Bypass all sanitization checks
3. Start a mainnet validator with consensus keys stored only in volatile memory
4. Disable critical VM verification checks
5. Enable test-mode safety rules on production

## Impact Explanation

This vulnerability has **Medium severity** with potential escalation to **High/Critical** impact:

**Immediate Risks:**
- **Consensus Key Loss**: InMemoryStorage means consensus keys exist only in RAM. A node restart causes permanent key loss, requiring re-initialization. This could lead to missed blocks and validator penalties.
- **Double-Signing Risk**: If a validator loses its safety rules state on restart and re-initializes with the same keys, it may violate AptosBFT safety guarantees by signing conflicting blocks.
- **Consensus Splits**: Disabled `paranoid_type_verification` and `paranoid_hot_potato_verification` could allow VM execution divergence between nodes, violating the Deterministic Execution invariant.

**Systemic Risks:**
- **Reduced Security Posture**: Test configurations may have relaxed security assumptions not suitable for production adversarial environments.
- **Silent Failures**: No warnings or errors are generated, making detection difficult until operational failures occur.

This meets the **Medium Severity** criteria: "State inconsistencies requiring intervention" and potentially escalates to **High Severity** if consensus safety is actually violated.

## Likelihood Explanation

The likelihood is **Medium to High**:

**Factors Increasing Likelihood:**
- The bypass flag can be set via a simple YAML configuration entry
- No documentation warns against using this flag in production
- Template configurations or automated deployment tools could accidentally include this flag
- The default value is `false`, but nothing prevents it from being overridden
- Operators copying test configurations as production templates might include this flag

**Factors Decreasing Likelihood:**
- Requires operator error or malicious insider action
- Well-managed validator operations would detect the issue through monitoring
- Experienced operators familiar with the codebase would avoid this [7](#0-6) 

The existing test `test_disable_config_sanitizer()` demonstrates this exact behavior: a mainnet validator config with `paranoid_hot_potato_verification: false` fails validation normally but passes when `skip_config_sanitizer: true`.

## Recommendation

**Primary Fix**: Remove the ability to disable the config sanitizer entirely, or make it only available in debug builds:

```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // SECURITY: Config sanitizer cannot be disabled in production
        #[cfg(not(debug_assertions))]
        if node_config.node_startup.skip_config_sanitizer {
            return Err(Error::ConfigSanitizerFailed(
                "NodeConfig".to_string(),
                "Config sanitizer cannot be disabled in production builds!".to_string(),
            ));
        }
        
        #[cfg(debug_assertions)]
        if node_config.node_startup.skip_config_sanitizer {
            warn!("Config sanitizer is disabled! This should only be used for testing.");
            return Ok(());
        }

        // Sanitize all of the sub-configs
        // ... existing validation code ...
    }
}
```

**Alternative Fix**: If the bypass must exist for operational flexibility, add explicit chain ID validation:

```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // Never allow sanitizer bypass on mainnet
        if node_config.node_startup.skip_config_sanitizer {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet() {
                    return Err(Error::ConfigSanitizerFailed(
                        "NodeConfig".to_string(),
                        "Config sanitizer cannot be disabled on mainnet!".to_string(),
                    ));
                }
            }
            warn!("Config sanitizer is disabled!");
            return Ok(());
        }
        
        // ... existing validation code ...
    }
}
```

## Proof of Concept

The vulnerability can be demonstrated using the existing test framework. Create a file `config/src/config/test_sanitizer_bypass.rs`:

```rust
#[cfg(test)]
mod test_mainnet_sanitizer_bypass {
    use crate::config::{
        ConsensusConfig, Error, ExecutionConfig, NodeConfig, NodeStartupConfig,
        SafetyRulesConfig, SecureBackend, SafetyRulesTestConfig,
        config_sanitizer::ConfigSanitizer,
        node_config_loader::NodeType,
    };
    use aptos_types::{chain_id::ChainId, PeerId};

    #[test]
    fn test_mainnet_validator_with_insecure_config_bypasses_validation() {
        // Create a mainnet validator config with dangerous settings
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,  // THE BYPASS
                ..Default::default()
            },
            consensus: ConsensusConfig {
                safety_rules: SafetyRulesConfig {
                    backend: SecureBackend::InMemoryStorage,  // DANGEROUS: Keys in RAM
                    test: Some(SafetyRulesTestConfig::new(PeerId::random())),  // TEST MODE ON MAINNET
                    ..Default::default()
                },
                ..Default::default()
            },
            execution: ExecutionConfig {
                paranoid_hot_potato_verification: false,  // DANGEROUS: Verification disabled
                paranoid_type_verification: false,         // DANGEROUS: Verification disabled
                ..Default::default()
            },
            ..Default::default()
        };

        // This should fail for a mainnet validator, but it doesn't!
        let result = NodeConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet())
        );

        // VULNERABILITY: The sanitizer passes despite dangerous mainnet config
        assert!(result.is_ok(), "Sanitizer should have failed but passed!");

        // Now test with sanitizer enabled - it correctly fails
        node_config.node_startup.skip_config_sanitizer = false;
        let result = NodeConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet())
        );

        // This correctly fails with sanitizer enabled
        assert!(matches!(result, Err(Error::ConfigSanitizerFailed(_, _))));
    }
}
```

This test demonstrates that a mainnet validator with:
- In-memory consensus key storage
- Test configuration enabled  
- Paranoid verification disabled

...successfully passes validation when `skip_config_sanitizer: true`, but correctly fails when sanitization is enabled.

## Notes

The `skip_config_sanitizer` flag appears to be a deliberate design choice for operational flexibility, but it creates a significant security risk by allowing production deployments to bypass all safety validations. The flag should either be removed entirely or protected with additional safeguards to prevent mainnet usage.

### Citations

**File:** config/src/config/node_startup_config.rs (L6-11)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** config/src/config/config_sanitizer.rs (L39-48)
```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L211-239)
```rust
    #[test]
    fn test_disable_config_sanitizer() {
        // Create a default node config (with sanitization enabled)
        let mut node_config = NodeConfig::default();

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer fails
        let error =
            NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
                .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
    }
```

**File:** config/src/config/safety_rules_config.rs (L71-116)
```rust
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        // If the node is not a validator, there's nothing to be done
        if !node_type.is_validator() {
            return Ok(());
        }

        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }

            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }

            // Verify that the safety rules test config is not enabled in mainnet
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** config/src/config/execution_config.rs (L157-186)
```rust
impl ConfigSanitizer for ExecutionConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let execution_config = &node_config.execution;

        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }

        Ok(())
    }
```

**File:** aptos-node/src/lib.rs (L166-187)
```rust
        } else {
            // Get the config file path
            let config_path = self.config.expect("Config is required to launch node");
            if !config_path.exists() {
                panic!(
                    "The node config file could not be found! Ensure the given path is correct: {:?}",
                    config_path.display()
                )
            }

            // A config file exists, attempt to parse the config
            let config = NodeConfig::load_from_path(config_path.clone()).unwrap_or_else(|error| {
                panic!(
                    "Failed to load the node config file! Given file path: {:?}. Error: {:?}",
                    config_path.display(),
                    error
                )
            });

            // Start the node
            start(config, None, true).expect("Node should start correctly");
        };
```

**File:** config/src/config/node_config.rs (L140-143)
```rust
    pub fn load_from_path<P: AsRef<Path>>(input_path: P) -> Result<Self, Error> {
        let node_config_loader = NodeConfigLoader::new(input_path);
        node_config_loader.load_and_sanitize_config()
    }
```
