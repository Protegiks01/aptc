# Audit Report

## Title
Directory Traversal and File Access Vulnerability in Transaction Backup Restore via Unchecked FileHandles

## Summary
The `verify()` function in transaction backup manifests fails to validate `FileHandle` paths for the `transactions` and `proof` fields. This allows an attacker who can provide a malicious manifest to perform directory traversal attacks, read arbitrary files on the validator node filesystem, or cause crashes during restore operations.

## Finding Description

The vulnerability exists in the transaction backup manifest verification flow. When a transaction restore operation is initiated, the system loads a manifest file that contains `TransactionChunk` objects with `FileHandle` references to transaction data and proof files. [1](#0-0) 

The `verify()` function only validates version ranges and chunk continuity but completely ignores the `transactions` and `proof` FileHandle fields: [2](#0-1) 

During restore operations, these unchecked FileHandles are directly used to open files: [3](#0-2) 

In the LocalFs storage backend, the FileHandle is joined directly with the base directory without any path validation: [4](#0-3) 

**Attack Path:**
1. Attacker gains access to backup storage or compromises manifest distribution
2. Attacker crafts a malicious manifest JSON with path traversal sequences:
   ```json
   {
     "first_version": 0,
     "last_version": 100,
     "chunks": [{
       "first_version": 0,
       "last_version": 100,
       "transactions": "../../../../etc/passwd",
       "proof": "../../../../etc/shadow",
       "format": "V1"
     }]
   }
   ```
3. When restore operation runs with `--transaction-manifest malicious.json`, the system:
   - Loads the manifest and calls `verify()` which passes
   - Attempts to open `backup_dir/../../../../etc/passwd`
   - Reads sensitive system files or crashes with deserialization errors

In the CommandAdapter backend, the FileHandle is passed directly to shell commands, potentially enabling command injection: [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:

1. **Validator Node Compromise**: An attacker can read arbitrary files from validator nodes, potentially accessing:
   - Private keys from the filesystem
   - Configuration files with credentials
   - Database files with sensitive chain data
   - System files revealing node architecture

2. **Validator Node Crashes**: Attempting to deserialize arbitrary files as BCS-encoded transactions will cause parsing errors and crash the restore process, potentially preventing validator recovery from backups.

3. **Command Injection (CommandAdapter)**: If using the CommandAdapter backend with improperly sanitized commands, this could escalate to Remote Code Execution on validator nodes.

The impact is limited to restore operations rather than live consensus, but compromising validator node security during disaster recovery scenarios represents a significant attack vector.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is exploitable when:
1. **Compromised Backup Storage**: Attacker gains write access to S3 buckets, cloud storage, or file servers hosting backups
2. **MITM Attacks**: Manifest files downloaded over insecure channels can be intercepted and modified
3. **Insider Threats**: Malicious operators with restore access can craft malicious manifests locally
4. **Supply Chain Attacks**: Compromised backup automation tools could inject malicious manifests

Validators regularly perform restore operations when:
- Setting up new validator nodes
- Recovering from hardware failures
- Testing disaster recovery procedures
- Migrating to new infrastructure

Given the operational necessity of restore operations and the multiple attack vectors for manifest manipulation, this vulnerability has a realistic exploitation probability.

## Recommendation

Add comprehensive FileHandle validation in the `verify()` function:

```rust
impl TransactionBackup {
    pub fn verify(&self) -> Result<()> {
        // Existing version range checks...
        ensure!(
            self.first_version <= self.last_version,
            "Bad version range: [{}, {}]",
            self.first_version,
            self.last_version,
        );

        ensure!(!self.chunks.is_empty(), "No chunks.");

        let mut next_version = self.first_version;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_version == next_version,
                "Chunk ranges not continuous. Expected first version: {}, actual: {}.",
                next_version,
                chunk.first_version,
            );
            ensure!(
                chunk.last_version >= chunk.first_version,
                "Chunk range invalid. [{}, {}]",
                chunk.first_version,
                chunk.last_version,
            );
            
            // NEW: Validate FileHandles
            Self::validate_file_handle(&chunk.transactions)?;
            Self::validate_file_handle(&chunk.proof)?;
            
            next_version = chunk.last_version + 1;
        }

        ensure!(
            next_version - 1 == self.last_version,
            "Last version in chunks: {}, in manifest: {}",
            next_version - 1,
            self.last_version,
        );

        Ok(())
    }

    fn validate_file_handle(handle: &str) -> Result<()> {
        // Reject absolute paths
        ensure!(
            !handle.starts_with('/') && !handle.starts_with('\\'),
            "FileHandle must be a relative path: {}",
            handle
        );
        
        // Reject directory traversal sequences
        ensure!(
            !handle.contains("../") && !handle.contains("..\\"),
            "FileHandle contains directory traversal: {}",
            handle
        );
        
        // Reject null bytes and control characters
        ensure!(
            !handle.contains('\0') && handle.chars().all(|c| !c.is_control() || c == '/'),
            "FileHandle contains invalid characters: {}",
            handle
        );
        
        // Ensure handle is not empty
        ensure!(
            !handle.is_empty(),
            "FileHandle cannot be empty"
        );
        
        Ok(())
    }
}
```

Additionally, implement path canonicalization in the storage backends to ensure FileHandles remain within the backup directory.

## Proof of Concept

```rust
// This PoC demonstrates the vulnerability by creating a malicious manifest
// and showing it passes verify() but could access arbitrary files

use anyhow::Result;
use serde_json;

// From manifest.rs
#[derive(Clone, serde::Deserialize, serde::Serialize, Debug)]
pub enum TransactionChunkFormat {
    V0,
    V1,
}

#[derive(Clone, serde::Deserialize, serde::Serialize, Debug)]
pub struct TransactionChunk {
    pub first_version: u64,
    pub last_version: u64,
    pub transactions: String,  // FileHandle
    pub proof: String,          // FileHandle
    pub format: TransactionChunkFormat,
}

#[derive(serde::Deserialize, serde::Serialize)]
pub struct TransactionBackup {
    pub first_version: u64,
    pub last_version: u64,
    pub chunks: Vec<TransactionChunk>,
}

impl TransactionBackup {
    // Current vulnerable verify() implementation
    pub fn verify(&self) -> Result<()> {
        use anyhow::ensure;
        ensure!(
            self.first_version <= self.last_version,
            "Bad version range"
        );
        ensure!(!self.chunks.is_empty(), "No chunks.");
        
        let mut next_version = self.first_version;
        for chunk in &self.chunks {
            ensure!(chunk.first_version == next_version, "Not continuous");
            ensure!(chunk.last_version >= chunk.first_version, "Invalid range");
            next_version = chunk.last_version + 1;
        }
        
        ensure!(next_version - 1 == self.last_version, "Version mismatch");
        Ok(())
    }
}

fn main() {
    // Create malicious manifest with path traversal
    let malicious_manifest = TransactionBackup {
        first_version: 0,
        last_version: 100,
        chunks: vec![TransactionChunk {
            first_version: 0,
            last_version: 100,
            transactions: "../../../../etc/passwd".to_string(),  // Path traversal!
            proof: "../../../../etc/shadow".to_string(),          // Path traversal!
            format: TransactionChunkFormat::V1,
        }],
    };
    
    // This should fail but currently passes
    match malicious_manifest.verify() {
        Ok(_) => println!("VULNERABILITY: Malicious manifest passed verification!"),
        Err(e) => println!("Safe: Validation caught the issue: {}", e),
    }
    
    // Serialize to show what would be stored
    let json = serde_json::to_string_pretty(&malicious_manifest).unwrap();
    println!("\nMalicious manifest JSON:\n{}", json);
    
    println!("\nWhen restore operation runs, it would attempt to open:");
    println!("  backup_dir/{}", malicious_manifest.chunks[0].transactions);
    println!("  backup_dir/{}", malicious_manifest.chunks[0].proof);
    println!("\nWhich resolves to system files outside the backup directory!");
}
```

**Expected Output:**
```
VULNERABILITY: Malicious manifest passed verification!

Malicious manifest JSON:
{
  "first_version": 0,
  "last_version": 100,
  "chunks": [
    {
      "first_version": 0,
      "last_version": 100,
      "transactions": "../../../../etc/passwd",
      "proof": "../../../../etc/shadow",
      "format": "V1"
    }
  ]
}

When restore operation runs, it would attempt to open:
  backup_dir/../../../../etc/passwd
  backup_dir/../../../../etc/shadow

Which resolves to system files outside the backup directory!
```

## Notes

This vulnerability is particularly concerning because:

1. **Silent Failure Mode**: The manifest passes validation, so operators have no warning that a malicious manifest is being used until file access fails or succeeds in reading unintended files.

2. **Backup System Trust**: Backup/restore operations are typically run with elevated privileges, and operators may trust manifests from "official" backup storage without scrutiny.

3. **Multiple Backend Vulnerability**: Both LocalFs and CommandAdapter backends are affected, with CommandAdapter potentially exposing additional command injection vectors depending on configuration.

4. **Limited Blast Radius**: While not a consensus-level vulnerability, compromising validator nodes during restore operations can lead to key theft, which subsequently enables consensus attacks.

The fix should be implemented at the manifest validation layer to provide defense-in-depth, with additional path sanitization in storage backend implementations as a secondary control.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L20-34)
```rust
pub struct TransactionChunk {
    pub first_version: Version,
    pub last_version: Version,
    /// Repeated `len(record) + record`, where `record` is BCS serialized tuple
    /// `(Transaction, TransactionInfo)`
    pub transactions: FileHandle,
    /// BCS serialized `(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)`.
    /// The `TransactionAccumulatorRangeProof` links the transactions to the
    /// `LedgerInfoWithSignatures`, and the `LedgerInfoWithSignatures` can be verified by the
    /// signatures it carries, against the validator set in the epoch. (Hence proper
    /// `EpochEndingBackup` is needed for verification.)
    pub proof: FileHandle,
    #[serde(default = "default_to_v0")]
    pub format: TransactionChunkFormat,
}
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L50-88)
```rust
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints
        ensure!(
            self.first_version <= self.last_version,
            "Bad version range: [{}, {}]",
            self.first_version,
            self.last_version,
        );

        // check chunk ranges
        ensure!(!self.chunks.is_empty(), "No chunks.");

        let mut next_version = self.first_version;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_version == next_version,
                "Chunk ranges not continuous. Expected first version: {}, actual: {}.",
                next_version,
                chunk.first_version,
            );
            ensure!(
                chunk.last_version >= chunk.first_version,
                "Chunk range invalid. [{}, {}]",
                chunk.first_version,
                chunk.last_version,
            );
            next_version = chunk.last_version + 1;
        }

        // check last version in chunk matches manifest
        ensure!(
            next_version - 1 == self.last_version, // okay to -1 because chunks is not empty.
            "Last version in chunks: {}, in manifest: {}",
            next_version - 1,
            self.last_version,
        );

        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L100-151)
```rust
    async fn load(
        manifest: TransactionChunk,
        storage: &Arc<dyn BackupStorage>,
        epoch_history: Option<&Arc<EpochHistory>>,
    ) -> Result<Self> {
        let mut file = BufReader::new(storage.open_for_read(&manifest.transactions).await?);
        let mut txns = Vec::new();
        let mut persisted_aux_info = Vec::new();
        let mut txn_infos = Vec::new();
        let mut event_vecs = Vec::new();
        let mut write_sets = Vec::new();

        while let Some(record_bytes) = file.read_record_bytes().await? {
            let (txn, aux_info, txn_info, events, write_set): (
                _,
                PersistedAuxiliaryInfo,
                _,
                _,
                WriteSet,
            ) = match manifest.format {
                TransactionChunkFormat::V0 => {
                    let (txn, txn_info, events, write_set) = bcs::from_bytes(&record_bytes)?;
                    (
                        txn,
                        PersistedAuxiliaryInfo::None,
                        txn_info,
                        events,
                        write_set,
                    )
                },
                TransactionChunkFormat::V1 => bcs::from_bytes(&record_bytes)?,
            };
            txns.push(txn);
            persisted_aux_info.push(aux_info);
            txn_infos.push(txn_info);
            event_vecs.push(events);
            write_sets.push(write_set);
        }

        ensure!(
            manifest.first_version + (txns.len() as Version) == manifest.last_version + 1,
            "Number of items in chunks doesn't match that in manifest. first_version: {}, last_version: {}, items in chunk: {}",
            manifest.first_version,
            manifest.last_version,
            txns.len(),
        );

        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L114-124)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let child = self
            .cmd(&self.config.commands.open_for_read, vec![
                EnvVar::file_handle(file_handle.to_string()),
            ])
            .spawn()?;
        Ok(Box::new(child.into_data_source()))
    }
```
