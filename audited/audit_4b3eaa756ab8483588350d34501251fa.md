# Audit Report

## Title
ModuleAddress Filter Bypass via Cross-Module Call Delegation

## Summary
The `ModuleAddress` transaction filter only examines the entry function's module address in the transaction payload and has no visibility into cross-module calls during execution. Attackers can deploy proxy modules that internally call functions from blocked modules, completely bypassing module-based filtering at all stages (mempool, consensus, and execution).

## Finding Description

The transaction filtering system implements module-based filtering through `TransactionMatcher::ModuleAddress(address)`. This matcher is used across all filtering stages: mempool, consensus, and execution. [1](#0-0) 

The filtering logic only checks the module address specified in the transaction payload's entry function: [2](#0-1) 

The critical comparison happens at the payload level: [3](#0-2) 

This design has no visibility into which modules are called during execution. In Move, modules can freely call functions from other modules, as demonstrated throughout the Aptos framework: [4](#0-3) 

**Attack Scenario:**

1. Operators block module `VulnerableModule` at address `0xBLOCKED` due to a discovered exploit
2. Attacker deploys `ProxyModule` at address `0xPROXY` containing:
```move
module 0xPROXY::proxy {
    use 0xBLOCKED::vulnerable_module;
    
    public entry fun bypass_filter(user: &signer, args: ...) {
        // Filter only sees 0xPROXY, not 0xBLOCKED
        vulnerable_module::exploitable_function(user, args);
    }
}
```
3. Attacker submits transaction calling `0xPROXY::proxy::bypass_filter`
4. Filter checks only see module address `0xPROXY` (not blocked) and allow the transaction
5. During execution, the proxy calls into `0xBLOCKED::vulnerable_module`, bypassing the filter entirely

This bypass works at all filtering stages because they all use the same `TransactionMatcher` logic: [5](#0-4) [6](#0-5) 

## Impact Explanation

This vulnerability breaks the security guarantee of module-based filtering, which is designed for emergency response scenarios such as:
- Blocking vulnerable modules to prevent ongoing exploitation
- Enforcing governance decisions to restrict module access
- Emergency response to security incidents

When operators block a module expecting to prevent all interactions with it, attackers can continue exploitation through proxy modules. This could lead to:
- Continued fund theft from vulnerable modules operators attempted to block
- Bypass of governance restrictions on module access
- False sense of security for operators using module filters

**Severity: Medium** - This qualifies as "state inconsistencies requiring intervention" and enables "limited funds loss or manipulation" through bypassing security controls. The actual damage depends on why the module was blocked, but the bypass completely undermines the filtering mechanism's purpose.

## Likelihood Explanation

**Likelihood: High**

The attack is trivial to execute:
1. No privileged access required - any user can deploy modules
2. No complex exploitation techniques needed
3. Standard Move module deployment and function calls
4. Works across all filtering stages (mempool, consensus, execution)
5. No way for operators to detect proxy modules without analyzing all deployed code

The only barrier is the gas cost of deploying a proxy module, which is minimal compared to potential gains from exploiting a blocked vulnerable module.

## Recommendation

The transaction filter system requires fundamental redesign to provide meaningful security guarantees. Recommended approaches:

**Option 1: Runtime Call Graph Tracking (Most Secure)**
Modify the Move VM to track all module addresses accessed during transaction execution and apply filters to the entire call graph, not just the entry point.

**Option 2: Static Analysis Integration**
Before allowing module deployment, perform static analysis to identify all potential cross-module calls and automatically extend filter rules to include proxy modules.

**Option 3: Documentation and Operator Guidance (Minimum)**
Clearly document this limitation and provide guidance that:
- Module filters only block direct calls, not indirect calls through proxies
- Complete module blocking requires on-chain governance to disable modules
- Filters should be considered temporary emergency measures only

**Recommended Fix (Option 1 - Conceptual):**

Extend the VM execution context to track accessed modules:

```rust
// In aptos-move/aptos-vm/src/aptos_vm.rs
fn execute_with_filter_validation(
    &self,
    txn: &SignedTransaction,
    filter: &BlockTransactionFilter,
    // ... other params
) -> Result<VMOutput> {
    let mut accessed_modules = HashSet::new();
    
    // Execute transaction with module tracking
    let output = self.execute_transaction_with_tracking(txn, &mut accessed_modules)?;
    
    // Validate all accessed modules against filter
    for module_addr in accessed_modules {
        if !filter.allows_module_access(module_addr) {
            return Err(VMStatus::error(
                StatusCode::ABORTED,
                Some("Transaction accessed blocked module".to_string())
            ));
        }
    }
    
    Ok(output)
}
```

## Proof of Concept

```move
// File: vulnerable_module.move (deployed at 0xBLOCKED)
module 0xBLOCKED::vulnerable {
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    
    // This function has a vulnerability that allows theft
    public fun exploitable_transfer(from: &signer, to: address, amount: u64) {
        // Vulnerability: missing authorization checks
        coin::transfer<AptosCoin>(from, to, amount);
    }
}

// File: proxy_module.move (deployed at 0xPROXY by attacker)
module 0xPROXY::bypass {
    use 0xBLOCKED::vulnerable;
    
    // Entry function that bypasses the ModuleAddress filter
    public entry fun steal_via_proxy(victim: &signer, attacker: address, amount: u64) {
        // Filter only checks 0xPROXY (this module's address)
        // but execution calls into 0xBLOCKED
        vulnerable::exploitable_transfer(victim, attacker, amount);
    }
}

// Test demonstrating the bypass
#[test_only]
module 0xTEST::filter_bypass_test {
    use aptos_framework::account;
    use 0xPROXY::bypass;
    
    #[test(victim = @0x1, attacker = @0x2)]
    public entry fun test_filter_bypass(victim: signer, attacker: signer) {
        // Setup: Assume 0xBLOCKED::vulnerable is blocked by filter
        // but 0xPROXY::bypass is not blocked
        
        // This transaction would pass all filter checks
        // because it calls 0xPROXY (not blocked)
        bypass::steal_via_proxy(&victim, @attacker, 1000);
        
        // Result: Funds transferred despite module filter
        // blocking direct calls to 0xBLOCKED::vulnerable
    }
}
```

**Rust Test Demonstrating Filter Bypass:**

```rust
#[test]
fn test_module_address_filter_bypass() {
    // Create a filter that blocks module at 0xBLOCKED
    let blocked_address = AccountAddress::from_hex_literal("0xBLOCKED").unwrap();
    let filter = TransactionFilter::empty()
        .add_module_address_filter(false, blocked_address);
    
    // Create transaction calling proxy at 0xPROXY
    // (which internally calls 0xBLOCKED during execution)
    let proxy_address = AccountAddress::from_hex_literal("0xPROXY").unwrap();
    let txn = create_entry_function_transaction(
        proxy_address,
        "bypass",
        "steal_via_proxy",
        vec![],
    );
    
    // Filter check passes because it only sees 0xPROXY
    assert!(filter.allows_transaction(&txn));
    
    // But during execution, transaction calls into blocked 0xBLOCKED
    // Filter has no visibility into this cross-module call
}
```

## Notes

This vulnerability represents a fundamental design limitation in how transaction filters are implemented. The filter operates at the transaction payload level (pre-execution) rather than during VM execution, making it impossible to detect cross-module calls without significant architectural changes. 

Operators relying on `ModuleAddress` filters for security-critical blocking should be aware this provides only surface-level protection and can be trivially bypassed. The filtering system should be considered a convenience feature for rate limiting or basic access control, not a security boundary for preventing access to vulnerable or restricted modules.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L191-193)
```rust
            TransactionMatcher::ModuleAddress(address) => {
                matches_entry_function_module_address(signed_transaction, address)
            },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L239-245)
```rust
/// Returns true iff the entry function's module address matches the given account address
fn compare_entry_function_module_address(
    entry_function: &EntryFunction,
    address: &AccountAddress,
) -> bool {
    entry_function.module().address() == address
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L377-418)
```rust
/// Returns true iff the transaction's module address matches the given account address
fn matches_entry_function_module_address(
    signed_transaction: &SignedTransaction,
    module_address: &AccountAddress,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.payload() {
        TransactionPayload::Script(_) | TransactionPayload::ModuleBundle(_) => false,
        TransactionPayload::Multisig(multisig) => multisig
            .transaction_payload
            .as_ref()
            .map(|payload| match payload {
                MultisigTransactionPayload::EntryFunction(entry_function) => {
                    compare_entry_function_module_address(entry_function, module_address)
                },
            })
            .unwrap_or(false),
        TransactionPayload::EntryFunction(entry_function) => {
            compare_entry_function_module_address(entry_function, module_address)
        },
        TransactionPayload::Payload(TransactionPayloadInner::V1 { executable, .. }) => {
            match executable.as_ref() {
                TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                TransactionExecutableRef::EntryFunction(entry_function) => {
                    compare_entry_function_module_address(entry_function, module_address)
                },
            }
        },
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function_module_address(entry_function, module_address)
                    },
                }
            } else {
                false
            }
        },
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L80-97)
```text
    /// Convenient function to transfer APT to a recipient account that might not exist.
    /// This would create the recipient account first, which also registers it to receive APT, before transferring.
    public entry fun transfer(source: &signer, to: address, amount: u64) {
        if (!account::exists_at(to)) {
            create_account(to)
        };

        if (features::operations_default_to_fa_apt_store_enabled()) {
            fungible_transfer_only(source, to, amount)
        } else {
            // Resource accounts can be created without registering them to receive APT.
            // This conveniently does the registration if necessary.
            if (!coin::is_account_registered<AptosCoin>(to)) {
                coin::register<AptosCoin>(&create_signer(to));
            };
            coin::transfer<AptosCoin>(source, to, amount)
        }
    }
```

**File:** crates/aptos-transaction-filters/src/block_transaction_filter.rs (L224-227)
```rust
pub enum BlockTransactionMatcher {
    Block(BlockMatcher),
    Transaction(TransactionMatcher),
}
```

**File:** mempool/src/shared_mempool/tasks.rs (L408-439)
```rust
fn filter_transactions(
    transaction_filter_config: &TransactionFilterConfig,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(
    SignedTransaction,
    Option<u64>,
    Option<BroadcastPeerPriority>,
)> {
    // If the filter is not enabled, return early
    if !transaction_filter_config.is_enabled() {
        return transactions;
    }

    // Start the filter processing timer
    let transaction_filter_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FILTER_TRANSACTIONS_LABEL])
        .start_timer();

    // Filter the transactions and update the statuses accordingly
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
```
