# Audit Report

## Title
Verified Module Cache Lacks Configuration Version Tracking, Allowing Stale Verification Results on Pre-V34 Networks

## Summary
The global verified module cache (`VERIFIED_MODULES_CACHE`) does not track which verifier configuration was used to verify cached modules. On networks with `gas_feature_version < 38` (RELEASE_V1_34), the cache is never flushed when verifier configuration changes, allowing modules verified under outdated (potentially less restrictive) configurations to execute without re-verification under the current stricter rules.

## Finding Description

The `contains()` function in the verified module cache only checks if a module hash exists in the cache, without validating that the cached module was verified using the current verifier configuration. [1](#0-0) 

The cache stores only a 32-byte hash with no version metadata: [2](#0-1) 

When building a locally verified module, if the cache contains the module hash, verification is completely skipped: [3](#0-2) 

The critical flaw is in the cache invalidation logic, which only flushes the cache when verifier config changes **if** the gas feature version is at least V34: [4](#0-3) 

The verifier configuration can change through multiple mechanisms even when gas_feature_version remains constant, including feature flag toggles: [5](#0-4) 

Note that at gas_feature_version 34, a security-critical verification fix is enabled: [6](#0-5) 

**Attack Scenario:**

1. Network operates with `gas_feature_version = 33` (or any value < 38)
2. Feature flag `ENABLE_RESOURCE_ACCESS_CONTROL` is disabled, so verifier has `enable_resource_access_control = false`
3. Module M is published and verified with this configuration; hash H is cached in `VERIFIED_MODULES_CACHE`
4. Governance enables `ENABLE_RESOURCE_ACCESS_CONTROL` via on-chain proposal
5. Verifier configuration now has `enable_resource_access_control = true`, enforcing stricter access control checks
6. Because `gas_feature_version < 38`, the cache flush logic is skipped entirely
7. Module M's hash H remains in the cache
8. When Module M is loaded for execution, `contains(H)` returns true
9. Verification is skipped, Module M executes without access control checks that should now apply
10. This breaks the "Move VM Safety" and potentially "Deterministic Execution" invariants

## Impact Explanation

**Severity: HIGH**

This vulnerability enables bypass of security-critical verification checks on networks with `gas_feature_version < 38`. The impacts include:

1. **Verification Bypass**: Modules verified under less restrictive configurations continue executing without re-verification when stricter rules are enabled, potentially violating new security guarantees

2. **Consensus Risk**: If cache states diverge between nodes (e.g., some nodes restarted and cleared cache, others didn't), different nodes may execute modules with different verification assumptions, potentially causing consensus divergence

3. **Protocol Upgrade Failures**: Protocol upgrades that rely on stricter verification rules may not be enforced uniformly, as cached modules bypass the new checks

4. **Access Control Violations**: Specifically for the `enable_resource_access_control` flag, modules could bypass resource access checks that should protect system resources

While modern mainnet likely operates at gas_feature_version â‰¥ 38, this vulnerability affects:
- Any testnet or devnet still on older gas versions
- Historical blocks before V34 deployment
- Custom Aptos deployments
- Genesis/bootstrap scenarios where gas_feature_version may default to 0 [7](#0-6) 

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability manifests whenever:
1. Network operates with `gas_feature_version < 38` (prerequisite)
2. Verifier configuration changes via feature flags or other governance actions (common during protocol upgrades)
3. Modules remain in cache across the configuration change (highly likely for frequently-used framework modules)

While production mainnet has likely progressed beyond gas_feature_version 38, the vulnerability remains in the codebase and affects any deployment scenario where the gas feature version is below this threshold. The verifier configuration is explicitly designed to change over time, as indicated by the comment: [8](#0-7) 

## Recommendation

**Immediate Fix**: Remove the gas feature version check from the cache flush logic to ensure the cache is always invalidated when verifier configuration changes:

```rust
// In code_cache_global_manager.rs, lines 117-126
if environment_requires_update {
    // Remove the gas_feature_version check
    let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
        e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
    });
    if flush_verifier_cache {
        RuntimeEnvironment::flush_verified_module_cache();
    }
    
    self.environment = Some(storage_environment);
    self.module_cache.flush();
}
```

**Long-term Fix**: Augment the cache key to include a hash of the verifier configuration:

```rust
// In verified_module_cache.rs
pub(crate) struct VerifiedModuleCache(Mutex<lru::LruCache<[u8; 64], ()>>);

// Cache key becomes: [module_hash (32 bytes) || verifier_config_hash (32 bytes)]
pub(crate) fn contains(&self, module_hash: &[u8; 32], verifier_hash: &[u8; 32]) -> bool {
    let mut key = [0u8; 64];
    key[..32].copy_from_slice(module_hash);
    key[32..].copy_from_slice(verifier_hash);
    verifier_cache_enabled() && self.0.lock().get(&key).is_some()
}
```

## Proof of Concept

```rust
// Reproduction steps (conceptual test):

use aptos_types::on_chain_config::{Features, FeatureFlag};
use move_vm_runtime::RuntimeEnvironment;

#[test]
fn test_cache_not_flushed_on_config_change_pre_v34() {
    // 1. Create environment with gas_feature_version = 33 (< RELEASE_V1_34)
    let mut features = Features::default();
    features.disable(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    
    let state_view = create_state_view_with_gas_version(33, features.clone());
    let env1 = AptosEnvironment::new(&state_view);
    
    // 2. Verify and cache a module
    let module = compile_test_module();
    let hash = compute_module_hash(&module);
    env1.runtime_environment().build_locally_verified_module(
        Arc::new(module.clone()),
        module_size,
        &hash
    ).unwrap();
    
    // Verify module is cached
    assert!(VERIFIED_MODULES_CACHE.contains(&hash));
    
    // 3. Change verifier config by enabling feature flag
    features.enable(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let state_view2 = create_state_view_with_gas_version(33, features);
    let env2 = AptosEnvironment::new(&state_view2);
    
    // 4. Verify configs are different
    assert_ne!(env1.verifier_config_bytes(), env2.verifier_config_bytes());
    
    // 5. BUG: Module is still cached despite config change
    // because gas_feature_version < 34
    assert!(VERIFIED_MODULES_CACHE.contains(&hash)); // Should be false!
    
    // 6. Module loads from cache without re-verification under new config
    let result = env2.runtime_environment().build_locally_verified_module(
        Arc::new(module),
        module_size,
        &hash
    );
    assert!(result.is_ok()); // Loaded from cache, bypassing new access control checks
}
```

## Notes

This vulnerability was partially addressed in gas feature version 34 by adding the conditional cache flush logic, but the fix is incomplete because it doesn't apply retroactively to networks operating below that version. The architecture fundamentally lacks version tracking in the cache itself, making it susceptible to configuration mismatches whenever the flush logic is bypassed or fails to execute.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L13-13)
```rust
pub(crate) struct VerifiedModuleCache(Mutex<lru::LruCache<[u8; 32], ()>>);
```

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L26-29)
```rust
    pub(crate) fn contains(&self, module_hash: &[u8; 32]) -> bool {
        // Note: need to use get to update LRU queue.
        verifier_cache_enabled() && self.0.lock().get(module_hash).is_some()
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L184-198)
```rust
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L117-126)
```rust
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
            }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-152)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L15-19)
```rust
pub fn get_gas_feature_version(state_view: &impl StateView) -> u64 {
    GasScheduleV2::fetch_config(state_view)
        .map(|gas_schedule| gas_schedule.feature_version)
        .unwrap_or(0)
}
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L32-34)
```rust
/// Always add new fields to the end, as we rely on the hash or serialized bytes of config to
/// detect if it has changed (e.g., new feature flag was enabled). Also, do not delete existing
/// fields, or change the type of existing field.
```
