# Audit Report

## Title
Validator Crash Due to Unprotected Concurrent Identity File Access During Initialization

## Summary
The identity file loading mechanism in `IdentityBlob::from_file()` lacks file locking or atomic read operations, allowing concurrent file modifications (e.g., by backup software) to cause partial reads. When optional fields like `consensus_private_key` are missing due to incomplete YAML deserialization, the validator panics during safety rules initialization, causing an availability failure. [1](#0-0) 

## Finding Description

During validator startup, the consensus safety rules system loads cryptographic keys from an identity blob file. The loading process uses standard `fs::read_to_string()` without file locking: [1](#0-0) 

The `IdentityBlob` struct defines critical consensus fields as optional: [2](#0-1) 

During validator initialization, the safety rules manager expects these fields to be present and uses `.expect()` to unwrap them: [3](#0-2) 

**Attack Scenario:**
1. Validator starts/restarts and begins reading `/opt/aptos/genesis/validator-identity.yaml`
2. Concurrently, backup software or configuration management tool writes to the same file
3. The `fs::read_to_string()` call reads partial file content (e.g., file truncated mid-read)
4. YAML deserializer successfully parses incomplete YAML with `consensus_private_key: None`
5. The `.expect()` call on line 68-69 panics: "Consensus key needed for safety rules"
6. Validator process crashes and cannot restart without manual intervention

The same file is also used for network identity initialization, creating a second crash point: [4](#0-3) 

Production deployments confirm this configuration pattern: [5](#0-4) [6](#0-5) 

## Impact Explanation

**Severity: Medium** (as specified in the security question)

This issue causes validator unavailability but does not affect:
- Consensus safety or network-wide liveness (only single validator affected)
- Cryptographic key material integrity (keys are not corrupted, only read fails)
- Fund security or state consistency

According to Aptos bug bounty criteria, this falls under **Medium severity** as it causes "State inconsistencies requiring intervention" - the validator cannot self-recover and requires manual operator intervention to restart.

The impact is limited because:
- Only affects validators using file-based identity (not Vault/secure backends)
- Requires specific timing during startup phase
- Does not cascade to other validators
- Recovery requires only process restart (no data loss)

## Likelihood Explanation

**Likelihood: Low to Medium**

Factors increasing likelihood:
- Common operational practices: Backup software, configuration management tools (Ansible/Chef), log rotation utilities regularly access validator files
- No file locking mechanism exists despite availability in codebase for other operations (Move package cache uses `fs2::FileExt`)
- Startup phase is particularly vulnerable as files are read synchronously during initialization
- The race window exists even with fast reads due to non-atomic multi-syscall read operations

Factors decreasing likelihood:
- Identity files are typically written once during genesis/setup and rarely modified afterward
- Production deployments increasingly use secure backends (Vault) instead of file-based storage
- Window of vulnerability is narrow (only during validator startup/restart)
- Requires precise timing coincidence

## Recommendation

Implement file locking for identity blob operations using the existing `fs2` crate already present in the dependency tree:

```rust
use fs2::FileExt;

impl IdentityBlob {
    pub fn from_file(path: &Path) -> anyhow::Result<IdentityBlob> {
        let file = File::open(path)?;
        // Acquire shared lock for reading
        file.lock_shared()?;
        let contents = std::io::read_to_string(file)?;
        // Lock automatically released on drop
        Ok(serde_yaml::from_str(&contents)?)
    }
    
    pub fn to_file(&self, path: &Path) -> anyhow::Result<()> {
        // Fix existing bug: should be create(), not open()
        let file = File::create(path)?;
        // Acquire exclusive lock for writing
        file.lock_exclusive()?;
        file.write_all(serde_yaml::to_string(self)?.as_bytes())?;
        file.sync_all()?; // Ensure data written to disk
        Ok(())
    }
}
```

Alternative mitigation: Validate required fields immediately after deserialization with descriptive error messages rather than panicking:

```rust
let identity_blob = config
    .initial_safety_rules_config
    .identity_blob()
    .context("Failed to load identity blob")?;

let consensus_key = identity_blob.consensus_private_key
    .ok_or_else(|| anyhow!("Consensus key missing from identity blob - file may be corrupted"))?;
    
let account_address = identity_blob.account_address
    .ok_or_else(|| anyhow!("Account address missing from identity blob - file may be corrupted"))?;
```

## Proof of Concept

```rust
use std::fs::{File, write};
use std::io::Write;
use std::path::Path;
use std::thread;
use std::time::Duration;
use tempfile::tempdir;
use aptos_config::config::IdentityBlob;

#[test]
fn test_concurrent_identity_file_modification_crash() {
    let temp_dir = tempdir().unwrap();
    let identity_path = temp_dir.path().join("validator-identity.yaml");
    
    // Write valid identity file
    let valid_yaml = r#"
account_address: "0x1"
consensus_private_key: "0x123..."
network_private_key: "0x456..."
"#;
    write(&identity_path, valid_yaml).unwrap();
    
    // Spawn thread to continuously overwrite file
    let path_clone = identity_path.clone();
    let writer_thread = thread::spawn(move || {
        for _ in 0..100 {
            // Truncate file then write incomplete data
            let mut file = File::create(&path_clone).unwrap();
            file.write_all(b"network_private_key: \"0x789...\"\n").unwrap();
            thread::sleep(Duration::from_millis(1));
        }
    });
    
    // Attempt multiple reads - some will get partial data
    let mut panic_occurred = false;
    for _ in 0..100 {
        match IdentityBlob::from_file(&identity_path) {
            Ok(blob) => {
                // If we got None for required fields, this would panic in real code
                if blob.consensus_private_key.is_none() {
                    panic_occurred = true;
                    break;
                }
            },
            Err(_) => {
                // Parse errors are also problematic but expected
            }
        }
        thread::sleep(Duration::from_millis(1));
    }
    
    writer_thread.join().unwrap();
    assert!(panic_occurred, "Expected to observe partial read scenario");
}
```

## Notes

While this is a genuine bug that should be fixed, its security impact is limited because:

1. **Limited Attack Surface**: Requires access to the validator host filesystem - not exploitable by external network attackers
2. **Operational Context**: The scenario described (backup software interference) represents accidental operational issues rather than deliberate attacks
3. **Availability Only**: Does not compromise consensus safety, cryptographic keys, or fund security
4. **Single Validator Impact**: Does not cause network-wide failures

The codebase already uses file locking mechanisms elsewhere (Move package cache uses `fs2::FileExt`), indicating awareness of concurrent access issues. The identity file handling should adopt the same protection.

### Citations

**File:** config/src/config/identity_config.rs (L24-37)
```rust
#[derive(Deserialize, Serialize)]
pub struct IdentityBlob {
    /// Optional account address. Used for validators and validator full nodes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_address: Option<AccountAddress>,
    /// Optional account key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_private_key: Option<Ed25519PrivateKey>,
    /// Optional consensus key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consensus_private_key: Option<bls12381::PrivateKey>,
    /// Network private key. Peer id is derived from this if account address is not present
    pub network_private_key: x25519::PrivateKey,
}
```

**File:** config/src/config/identity_config.rs (L40-42)
```rust
    pub fn from_file(path: &Path) -> anyhow::Result<IdentityBlob> {
        Ok(serde_yaml::from_str(&fs::read_to_string(path)?)?)
    }
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L54-72)
```rust
            let identity_blob = config
                .initial_safety_rules_config
                .identity_blob()
                .expect("No identity blob in initial safety rules config");
            let waypoint = config.initial_safety_rules_config.waypoint();

            let backend = &config.backend;
            let internal_storage: Storage = backend.into();
            PersistentSafetyStorage::initialize(
                internal_storage,
                identity_blob
                    .account_address
                    .expect("AccountAddress needed for safety rules"),
                identity_blob
                    .consensus_private_key
                    .expect("Consensus key needed for safety rules"),
                waypoint,
                config.enable_cached_safety_data,
            )
```

**File:** config/src/config/network_config.rs (L199-202)
```rust
            Identity::FromFile(config) => {
                let identity_blob: IdentityBlob = IdentityBlob::from_file(&config.path).unwrap();
                Some(identity_blob.network_private_key)
            },
```

**File:** docker/compose/aptos-node/validator.yaml (L15-19)
```yaml
    initial_safety_rules_config:
      from_file:
        waypoint:
          from_file: /opt/aptos/genesis/waypoint.txt
        identity_blob_path: /opt/aptos/genesis/validator-identity.yaml
```

**File:** docker/compose/aptos-node/validator.yaml (L31-33)
```yaml
  identity:
    type: "from_file"
    path: /opt/aptos/genesis/validator-identity.yaml
```
