# Audit Report

## Title
Unencrypted Cross-Shard Messages Expose Sensitive Blockchain State to Network Observers

## Summary
Cross-shard messages in the remote executor service are transmitted over unencrypted HTTP connections, allowing network observers to intercept and read sensitive blockchain state information including account balances, resource values, and transaction write operations.

## Finding Description

The `send_cross_shard_msg()` function in `RemoteCrossShardClient` transmits cross-shard messages containing sensitive blockchain state without encryption. The vulnerability exists across multiple layers:

**1. Message Content**: The cross-shard messages contain highly sensitive data: [1](#0-0) 

These `RemoteTxnWrite` messages include `StateKey` (identifying blockchain storage locations such as account addresses and table handles) and `WriteOp` (containing actual state values in bytes, including account balances and resource data).

**2. Unencrypted Transport**: The messages are serialized and sent over the network: [2](#0-1) 

The underlying `NetworkController` creates gRPC connections using plain HTTP without TLS: [3](#0-2) 

Note the explicit use of `format!("http://{}", remote_addr)` on line 128, establishing an unencrypted connection.

**3. Sensitive Data Flow**: The system sends complete transaction write sets across shards: [4](#0-3) 

This function iterates through all write operations and sends state keys with their corresponding values to dependent shards.

**Attack Scenario**:
1. Attacker gains network access between executor shards (e.g., datacenter employee, compromised router, ISP)
2. Attacker uses packet capture tools (tcpdump, Wireshark) to intercept gRPC traffic
3. Attacker deserializes the BCS-encoded messages to extract `StateKey` and `WriteOp` data
4. Attacker obtains real-time visibility into blockchain state updates, account balances, and resource modifications

## Impact Explanation

This vulnerability represents a **High Severity** information disclosure issue:

- **Confidentiality Breach**: All cross-shard state updates are exposed to network observers, violating the confidentiality of blockchain operations
- **Privacy Violation**: Account balances, resource states, and transaction effects are visible to unauthorized parties
- **MEV/Frontrunning Risk**: Real-time visibility into state changes could enable sophisticated MEV attacks or frontrunning strategies
- **Regulatory Concerns**: Unencrypted transmission of financial data may violate compliance requirements

While this does not directly cause consensus violations or funds loss, it constitutes a "significant protocol violation" under the High Severity category, as secure communication between critical blockchain components is a fundamental security requirement.

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity**: Minimal - passive network sniffing requires no authentication or authorization bypass
- **Attacker Requirements**: Basic network access between executor shards (common in cloud/datacenter environments)
- **Detection Difficulty**: Passive attacks leave no traces and are nearly impossible to detect
- **Deployment Context**: The remote executor service is designed for distributed deployment across multiple machines, increasing network exposure

The attack is realistic and easily executable by attackers with network-level access.

## Recommendation

Implement TLS encryption for all cross-shard communication:

**1. Update gRPC Connection to Use TLS**:

Modify the `get_channel` function to use HTTPS with proper TLS configuration:
- Replace `format!("http://{}", remote_addr)` with `format!("https://{}", remote_addr)`
- Configure TLS certificates using `tonic::transport::Endpoint::tls_config()`
- Implement mutual TLS authentication to verify both client and server identities

**2. Certificate Management**:
- Deploy a PKI infrastructure for certificate generation and rotation
- Use validator node certificates or generate dedicated certificates for executor shards
- Implement certificate validation to prevent man-in-the-middle attacks

**3. Configuration Options**:
- Add TLS configuration parameters to `NetworkController::new()`
- Allow operators to specify certificate paths, CA roots, and TLS versions
- Provide secure defaults while maintaining flexibility for different deployment scenarios

**Example Fix** (conceptual):
```rust
// In get_channel function:
let tls_config = tonic::transport::ClientTlsConfig::new()
    .ca_certificate(ca_cert)
    .identity(client_identity);

let conn = tonic::transport::Endpoint::new(format!("https://{}", remote_addr))
    .unwrap()
    .tls_config(tls_config)
    .unwrap()
    .connect_lazy();
```

## Proof of Concept

**Network Capture PoC**:

```bash
# Step 1: Deploy remote executor service with multiple shards
# (using the existing executor-benchmark with sharding enabled)

# Step 2: On a machine with network access between shards, capture traffic
sudo tcpdump -i any -w cross_shard_capture.pcap 'tcp and (port 50051 or port 50052)'

# Step 3: While capture is running, execute transactions that trigger cross-shard updates

# Step 4: Analyze captured packets
tshark -r cross_shard_capture.pcap -T json -e data.data | \
  python3 -c "
import sys, json, bcs
for line in sys.stdin:
    packet = json.loads(line)
    if 'data.data' in packet:
        # Extract gRPC message payload
        payload = bytes.fromhex(packet['data.data'][0])
        # Deserialize BCS-encoded CrossShardMsg
        msg = bcs.deserialize(payload, CrossShardMsg)
        # Extract StateKey and WriteOp
        if hasattr(msg, 'RemoteTxnWriteMsg'):
            state_key, write_op = msg.RemoteTxnWriteMsg.take()
            print(f'Intercepted state update: {state_key} -> {write_op}')
"

# Expected Output:
# Intercepted state update: StateKey::AccessPath(0x1::...) -> WriteOp::Modification([...])
# [Sensitive blockchain state values visible in cleartext]
```

**Verification Steps**:
1. Deploy the remote executor service with sharding enabled
2. Run packet capture on network interface
3. Execute transactions that modify state across multiple shards
4. Observe that gRPC messages contain unencrypted BCS-serialized `CrossShardMsg` data
5. Successfully deserialize and extract `StateKey` and `WriteOp` values from captured packets

## Notes

- This vulnerability affects only the remote executor service deployment mode, not the standard validator network which uses the separate `aptos-network` crate with its own security mechanisms
- The issue is specific to the `aptos-secure-net` networking substrate used for remote execution
- While the crate is named "secure-net", it currently provides no encryption or authentication
- The remote executor service appears to be designed for trusted datacenter environments, but the lack of encryption still represents a significant security gap

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L13-18)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteTxnWrite {
    state_key: StateKey,
    // The write op is None if the transaction is aborted.
    write_op: Option<WriteOp>,
}
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-59)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L124-138)
```rust
    pub fn new(rt: &Runtime, remote_addr: SocketAddr) -> Self {
        Self {
            remote_addr: remote_addr.to_string(),
            remote_channel: rt
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }

    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L103-134)
```rust
    fn send_remote_update_for_success(
        &self,
        txn_idx: TxnIndex,
        txn_output: &OnceCell<TransactionOutput>,
    ) {
        let edges = self.dependent_edges.get(&txn_idx).unwrap();
        let write_set = txn_output
            .get()
            .expect("Committed output must be set")
            .write_set();

        for (state_key, write_op) in write_set.expect_write_op_iter() {
            if let Some(dependent_shard_ids) = edges.get(state_key) {
                for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                    trace!("Sending remote update for success for shard id {:?} and txn_idx: {:?}, state_key: {:?}, dependent shard id: {:?}", self.shard_id, txn_idx, state_key, dependent_shard_id);
                    let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                        state_key.clone(),
                        Some(write_op.clone()),
                    ));
                    if *round_id == GLOBAL_ROUND_ID {
                        self.cross_shard_client.send_global_msg(message);
                    } else {
                        self.cross_shard_client.send_cross_shard_msg(
                            *dependent_shard_id,
                            *round_id,
                            message,
                        );
                    }
                }
            }
        }
    }
```
