# Audit Report

## Title
Identity Element Attack Bypasses Cryptographic Validation in Pinkas WVUF `augment_pubkey()`

## Summary
The `augment_pubkey()` function in the Pinkas Weighted VUF implementation fails to validate that `delta.pi` and `delta.rks` elements are non-identity. An attacker can bypass cryptographic validation by providing identity elements, allowing them to get a malformed augmented public key certified without proving possession of the corresponding secret key.

## Finding Description

The `augment_pubkey()` function is designed to cryptographically verify that a delta (randomized public keys) was correctly generated using the legitimate secret key. The validation uses a pairing check to ensure the relationship between the randomized keys and original public keys. [1](#0-0) 

The pairing check at lines 134-140 verifies: `e(delta.pi, pks_combined) * e(rks_combined, -g_hat) = identity`

**Attack Vector:**

A malicious validator can construct a delta with:
- `delta.pi = G1::identity()`  
- All `delta.rks[i] = G1::identity()`

When this delta is validated:

1. `pks_combined = sum_i tau^i * pk_i` (non-identity, legitimate public keys)
2. `rks_combined = sum_i tau^i * identity = identity`
3. The pairing check becomes: `e(identity, pks_combined) * e(identity, -g_hat) = identity * identity = identity` ✓

**The validation passes**, even though the attacker did not use their secret key to generate the delta.

**Attack Flow:** [2](#0-1) 

1. Malicious validator participates in DKG and receives legitimate `pk_share`
2. Instead of calling `augment_key_pair()` with their secret key, they construct malicious delta with identity elements
3. They broadcast the delta to other validators
4. Honest validators call `add_certified_delta()` which invokes `augment_pubkey()`
5. The malformed delta passes validation and gets stored in `certified_apks` [3](#0-2) 

**Limitation of the Attack:**

While the attacker can get their malformed APK certified, they **cannot** participate in actual randomness generation because: [4](#0-3) 

The `verify_share()` function checks `e(delta.pi, proof) * e(-g, h) = identity`. With `delta.pi = identity`, this becomes `e(identity, proof) = e(g, h)`, which equals `identity = e(g, h)` - this **fails** since `e(g, h) ≠ identity`.

Therefore, any share the attacker creates will be rejected, preventing them from corrupting the randomness output.

## Impact Explanation

**Severity: Medium**

This vulnerability represents a **significant protocol violation** where cryptographic validation can be bypassed. The security property violated is: "Only validators possessing their secret key share should be able to have a certified augmented public key."

**Actual Impact:**
- **Resource Waste**: Honest validators expend CPU cycles verifying and storing malformed deltas
- **Storage Pollution**: Malformed APKs consume storage in the `certified_apks` vector
- **Protocol Integrity**: The assumption that all certified APKs are cryptographically bound to secret keys is violated
- **Potential Confusion**: The system believes a validator has a valid APK when they cannot actually contribute to randomness

**NO Critical Impact:**
- Consensus safety is NOT violated (malicious shares are rejected)
- Randomness generation continues with honest validators
- No fund theft or loss of liveness occurs
- The weighted threshold ensures quorum can still be reached

This qualifies as **Medium severity** under "State inconsistencies requiring intervention" - the certified APKs state contains invalid entries that violate cryptographic assumptions, though the system remains functional.

## Likelihood Explanation

**Likelihood: Medium**

**Attacker Requirements:**
- Must be a validator in the active set
- Must participate in DKG to receive legitimate `pk_share`
- Can execute the attack unilaterally (no collusion needed)

**Complexity:**
- Low - simply construct delta with identity elements instead of calling `augment_key_pair()`
- Attack is deterministic and reliable

**Detection:**
- Difficult to detect in real-time since validation passes
- Could be detected through monitoring if validators track whether peers contribute randomness shares

## Recommendation

Add explicit validation to reject identity elements in `augment_pubkey()`:

```rust
fn augment_pubkey(
    pp: &Self::PublicParameters,
    pk: Self::PubKeyShare,
    delta: Self::Delta,
) -> anyhow::Result<Self::AugmentedPubKeyShare> {
    if delta.rks.len() != pk.len() {
        bail!("Expected PKs and RKs to be of the same length. Got {} and {}, respectively.",
            delta.rks.len(), pk.len());
    }

    // SECURITY FIX: Reject identity elements
    if delta.pi.is_identity().into() {
        bail!("delta.pi cannot be the identity element");
    }
    
    for (i, rk) in delta.rks.iter().enumerate() {
        if rk.is_identity().into() {
            bail!("delta.rks[{}] cannot be the identity element", i);
        }
    }

    let tau = random_scalar(&mut thread_rng());
    let pks = pk.iter().map(|pk| *pk.as_group_element()).collect::<Vec<G2Projective>>();
    let taus = get_powers_of_tau(&tau, pks.len());

    let pks_combined = g2_multi_exp(&pks[..], &taus[..]);
    let rks_combined = g1_multi_exp(&delta.rks[..], &taus[..]);

    if multi_pairing(
        [&delta.pi, &rks_combined].into_iter(),
        [&pks_combined, &pp.g_hat.neg()].into_iter(),
    ) != Gt::identity()
    {
        bail!("RPKs were not correctly randomized.");
    }

    Ok((delta, pk))
}
```

## Proof of Concept

```rust
#[test]
fn test_identity_element_attack() {
    use aptos_dkg::{
        pvss::{self, WeightedConfigBlstrs},
        weighted_vuf::{pinkas::PinkasWUF, traits::WeightedVUF},
    };
    use blstrs::{G1Projective, G2Projective};
    use group::Group;

    // Setup: Create legitimate pk_share from DKG
    let wc = WeightedConfigBlstrs::new(3, vec![1, 1, 1]).unwrap();
    let mut rng = rand::thread_rng();
    
    // Simulate DKG output
    let (_, pk_shares, _, pp) = /* DKG setup code */;
    let vuf_pp = <PinkasWUF as WeightedVUF>::PublicParameters::from(&pp);
    
    // ATTACK: Construct malicious delta with identity elements
    let malicious_delta = RandomizedPKs {
        pi: G1Projective::identity(),
        rks: vec![G1Projective::identity(); pk_shares[0].len()],
    };
    
    // This should FAIL but currently PASSES
    let result = PinkasWUF::augment_pubkey(
        &vuf_pp,
        pk_shares[0].clone(),
        malicious_delta
    );
    
    assert!(result.is_ok(), "Identity element attack bypassed validation!");
    
    // Verify the attacker cannot create valid shares
    let (malicious_apk) = result.unwrap();
    // Any share created will fail verify_share() due to delta.pi = identity
}
```

## Notes

The vulnerability is a **cryptographic validation bypass** that allows malformed augmented public keys to be certified. While the practical impact is limited due to downstream validation in `verify_share()`, it represents a protocol integrity violation that should be fixed to maintain defense-in-depth and prevent potential future exploits if the verification logic changes.

### Citations

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L108-143)
```rust
    fn augment_pubkey(
        pp: &Self::PublicParameters,
        pk: Self::PubKeyShare,
        // lpk: &Self::BlsPubKey,
        delta: Self::Delta,
    ) -> anyhow::Result<Self::AugmentedPubKeyShare> {
        if delta.rks.len() != pk.len() {
            bail!(
                "Expected PKs and RKs to be of the same length. Got {} and {}, respectively.",
                delta.rks.len(),
                pk.len()
            );
        }

        // TODO: Fiat-Shamir transform instead of RNG
        let tau = random_scalar(&mut thread_rng());

        let pks = pk
            .iter()
            .map(|pk| *pk.as_group_element())
            .collect::<Vec<G2Projective>>();
        let taus = get_powers_of_tau(&tau, pks.len());

        let pks_combined = g2_multi_exp(&pks[..], &taus[..]);
        let rks_combined = g1_multi_exp(&delta.rks[..], &taus[..]);

        if multi_pairing(
            [&delta.pi, &rks_combined].into_iter(),
            [&pks_combined, &pp.g_hat.neg()].into_iter(),
        ) != Gt::identity()
        {
            bail!("RPKs were not correctly randomized.");
        }

        Ok((delta, pk))
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L153-170)
```rust
    fn verify_share(
        pp: &Self::PublicParameters,
        apk: &Self::AugmentedPubKeyShare,
        msg: &[u8],
        proof: &Self::ProofShare,
    ) -> anyhow::Result<()> {
        let delta = Self::get_public_delta(apk);

        let h = Self::hash_to_curve(msg);

        if multi_pairing([&delta.pi, &pp.g_neg].into_iter(), [proof, &h].into_iter())
            != Gt::identity()
        {
            bail!("PinkasWVUF ProofShare failed to verify.");
        }

        Ok(())
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L656-665)
```rust
    fn derive_apk(&self, peer: &Author, delta: Delta) -> anyhow::Result<APK> {
        let apk = WVUF::augment_pubkey(&self.vuf_pp, self.get_pk_share(peer).clone(), delta)?;
        Ok(apk)
    }

    pub fn add_certified_delta(&self, peer: &Author, delta: Delta) -> anyhow::Result<()> {
        let apk = self.derive_apk(peer, delta)?;
        self.add_certified_apk(peer, apk)?;
        Ok(())
    }
```

**File:** types/src/randomness.rs (L104-136)
```rust
pub struct RandKeys {
    // augmented secret / public key share of this validator, obtained from the DKG transcript of last epoch
    pub ask: ASK,
    pub apk: APK,
    // certified augmented public key share of all validators,
    // obtained from all validators in the new epoch,
    // which necessary for verifying randomness shares
    pub certified_apks: Vec<OnceCell<APK>>,
    // public key share of all validators, obtained from the DKG transcript of last epoch
    pub pk_shares: Vec<PKShare>,
}

impl RandKeys {
    pub fn new(ask: ASK, apk: APK, pk_shares: Vec<PKShare>, num_validators: usize) -> Self {
        let certified_apks = vec![OnceCell::new(); num_validators];

        Self {
            ask,
            apk,
            certified_apks,
            pk_shares,
        }
    }

    pub fn add_certified_apk(&self, index: usize, apk: APK) -> anyhow::Result<()> {
        assert!(index < self.certified_apks.len());
        if self.certified_apks[index].get().is_some() {
            return Ok(());
        }
        self.certified_apks[index].set(apk).unwrap();
        Ok(())
    }
}
```
