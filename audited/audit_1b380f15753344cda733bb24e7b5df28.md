# Audit Report

## Title
Self-Transfer Events Artificially Inflate Token Activity Metrics in Indexer

## Summary
The Aptos indexer's token activity tracking fails to filter self-transfers (where `from_address == to_address`), allowing users to artificially inflate transfer volume metrics by repeatedly transferring tokens to themselves.

## Finding Description

The indexer processes blockchain events and stores analytics data in PostgreSQL. When processing NFT transfer events in the `get_nft_v2_from_parsed_event` function, the code creates a `TokenActivityV2` record for every transfer without checking if it's a self-transfer: [1](#0-0) 

This contrasts with the token ownership tracking logic, which explicitly filters out self-transfers: [2](#0-1) 

The discrepancy means:
1. **Ownership records** correctly ignore self-transfers (no duplicate ownership created)
2. **Activity records** blindly record all transfers, including self-transfers

An attacker can exploit this by:
1. Owning a token (NFT or fungible token v2)
2. Repeatedly calling object transfer functions with `to_address == from_address`
3. Each self-transfer emits a valid `TransferEvent` on-chain
4. The indexer processes each event and creates a `token_activities_v2` database record
5. External analytics services querying this table count these as legitimate transfers, inflating metrics

## Impact Explanation

This vulnerability falls under **Low Severity** per the Aptos Bug Bounty program criteria:
- **Minor information leak**: Misleading analytics data
- **Non-critical implementation bug**: Data integrity issue in off-chain component

This does **NOT** qualify for higher severity because:
- No funds are at risk (no theft, minting, or freezing)
- Consensus remains unaffected (validators execute correctly)
- On-chain state is correct (only off-chain indexer data is affected)
- No protocol violations (the indexer is not part of consensus)
- No availability impact (nodes continue functioning normally)

## Likelihood Explanation

**High likelihood** of occurrence because:
- Requires no special privileges (any token owner can exploit)
- Trivial to execute (standard transfer calls)
- No cost barrier beyond gas fees
- Affects all NFT and fungible token v2 transfers
- No rate limiting on self-transfers

## Recommendation

Add a self-transfer check in `v2_token_activities.rs`, similar to the existing check in `v2_token_ownerships.rs`:

```rust
V2TokenEvent::TransferEvent(inner) => {
    // Skip self-transfers to prevent metric inflation
    if inner.get_from_address() == inner.get_to_address() {
        return Ok(None);
    }
    TokenActivityHelperV2 {
        from_address: Some(inner.get_from_address()),
        to_address: Some(inner.get_to_address()),
        token_amount: BigDecimal::one(),
        before_value: None,
        after_value: None,
    }
}
``` [1](#0-0) 

## Proof of Concept

```move
// Move script to exploit self-transfer metric inflation
script {
    use aptos_framework::object;
    
    fun exploit_self_transfer(owner: &signer, token_obj: address) {
        // Transfer token to self 100 times
        let i = 0;
        while (i < 100) {
            object::transfer(owner, token_obj, signer::address_of(owner));
            i = i + 1;
        };
        // Result: 100 transfer activity records in token_activities_v2
        // but ownership state unchanged (still owned by same address)
    }
}
```

**Notes**

While this is a valid implementation bug, it qualifies as **Low severity** only. The indexer is an off-chain analytics componentâ€”not part of the core consensus, execution, or state management systems. This issue:

- Does not affect any of the 10 critical invariants (deterministic execution, consensus safety, Move VM safety, etc.)
- Cannot be used to steal funds, manipulate consensus, or disrupt the network
- Only impacts derived analytics data consumed by external dashboards/APIs
- The on-chain state remains cryptographically correct

The inconsistency between ownership tracking (which filters self-transfers) and activity tracking (which doesn't) suggests this may be an oversight rather than intentional design. However, the security impact is limited to data quality for analytics purposes.

### Citations

**File:** crates/indexer/src/models/token_models/v2_token_activities.rs (L186-192)
```rust
                    V2TokenEvent::TransferEvent(inner) => TokenActivityHelperV2 {
                        from_address: Some(inner.get_from_address()),
                        to_address: Some(inner.get_to_address()),
                        token_amount: BigDecimal::one(),
                        before_value: None,
                        after_value: None,
                    },
```

**File:** crates/indexer/src/models/token_models/v2_token_ownerships.rs (L167-170)
```rust
            // If it's a self transfer then skip
            if transfer_event.get_to_address() == transfer_event.get_from_address() {
                return Ok(Some((ownership, current_ownership, None, None)));
            }
```
