# Audit Report

## Title
SafetyRules QC Verification Double-Bypass Allows Byzantine Validators to Corrupt Safety State

## Summary
A critical design flaw exists where `skip_sig_verify=true` in Local mode (mainnet default) combined with the `self_message` verification bypass allows Byzantine validators to vote on proposals with forged Quorum Certificates, corrupting their safety state and potentially enabling consensus safety violations.

## Finding Description

The SafetyRules component implements a `skip_sig_verify` flag intended for Local mode, based on the assumption that "consensus already verifies" signatures. [1](#0-0) 

However, this assumption is violated when validators process their own proposals. The consensus layer explicitly skips verification when `self_message=true` (when `peer_id == my_peer_id`): [2](#0-1) 

The self-message flag is set based on peer identity comparison: [3](#0-2) 

Additionally, mainnet validators are required to use Local mode where `skip_sig_verify=true`: [4](#0-3) 

In Local mode, SafetyRules is instantiated with signature verification disabled: [5](#0-4) 

This creates a double-bypass where:

1. **Consensus layer** skips QC verification for self-messages
2. **SafetyRules layer** skips QC verification when `skip_sig_verify=true`

The vulnerability manifests in `construct_and_sign_vote_two_chain()` where:
- `verify_proposal()` is called, which invokes `verify_qc()` [6](#0-5) 
- `verify_qc()` skips signature verification when `skip_sig_verify=true` [7](#0-6) 
- `observe_qc()` **unconditionally** updates safety state based on the unverified QC [8](#0-7) 

The `observe_qc()` method updates critical safety state (`one_chain_round`, `preferred_round`) without any verification: [9](#0-8) 

**Attack Scenario:**
1. Byzantine validator creates a proposal with a forged QC claiming arbitrary rounds or invalid parent chains
2. Validator processes it as self-message (bypassing consensus verification)
3. SafetyRules processes it with `skip_sig_verify=true` (bypassing QC verification)
4. `observe_qc()` corrupts safety state with data from the forged QC
5. Validator's future voting decisions are based on corrupted safety state
6. Validator can now violate 2-chain voting rules, enabling potential equivocation or unsafe votes

## Impact Explanation

**Critical Severity** - This vulnerability enables consensus safety violations under the AptosBFT threat model:

- **Breaks Invariant #2 (Consensus Safety)**: Byzantine validators can bypass the safety rules that prevent equivocation and unsafe voting
- **Enables f+1 Attacks**: If multiple Byzantine validators exploit this, coordinated attacks requiring f+1 participants become feasible
- **Corrupts Last Defense Layer**: SafetyRules is designed as the final defense against Byzantine behavior; this bypass removes that protection
- **Mainnet Affected**: The vulnerable configuration (`skip_sig_verify=true` in Local mode) is enforced for mainnet validators

While a single Byzantine validator exploiting this cannot directly break consensus (still requires 2f+1 for QC formation), it fundamentally weakens the protocol's Byzantine fault tolerance by allowing validators to violate their own safety constraints.

## Likelihood Explanation

**High Likelihood** - The vulnerability is actively exploitable on mainnet:

- **Default Configuration**: Mainnet validators use Local mode with `skip_sig_verify=true` by design
- **No Additional Vulnerabilities Required**: The double-bypass exists in the base implementation
- **Byzantine Validator Requirement**: Requires validator to be Byzantine (within scope of the security question)
- **Trivial to Exploit**: Byzantine validator simply needs to construct a proposal with forged QC and process it

## Recommendation

The design assumption must be corrected. SafetyRules should NOT skip verification for self-generated proposals, or the consensus layer should verify all proposals including self-messages.

**Option 1 (Preferred)**: Remove the `skip_sig_verify` optimization entirely, or restrict it only to test environments:

```rust
// In safety_rules_manager.rs, line 132
pub fn new_local(storage: PersistentSafetyStorage) -> Self {
    let safety_rules = SafetyRules::new(storage, false); // Always verify
    Self {
        internal_safety_rules: SafetyRulesWrapper::Local(Arc::new(RwLock::new(safety_rules))),
    }
}
```

**Option 2**: Make consensus verify self-messages when SafetyRules has `skip_sig_verify` enabled:

```rust
// In round_manager.rs, line 121
if !self_message || safety_rules_skips_verification {
    p.verify(peer_id, validator, proof_cache, quorum_store_enabled)?;
    // ...
}
```

**Option 3**: Make `observe_qc()` conditional on prior QC verification:

```rust
// Require verification before observe_qc
let qc_verified = self.verify_qc(proposed_block.quorum_cert())?;
if qc_verified {
    self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
}
```

## Proof of Concept

The following demonstrates the vulnerability path in Rust:

```rust
// Proof of Concept: Byzantine validator exploits double-bypass
// This would be added to consensus/safety-rules/src/tests/

#[test]
fn test_qc_verification_bypass_via_self_message() {
    // Setup: Create SafetyRules with skip_sig_verify=true (Local mode)
    let storage = test_storage();
    let mut safety_rules = SafetyRules::new(storage, true); // skip_sig_verify=true
    
    // Byzantine validator creates proposal with FORGED QC
    let forged_qc = create_forged_qc_with_invalid_signatures(
        certified_round: 1000, // Arbitrary high round
        parent_round: 999,
    );
    
    let malicious_block = Block::new_proposal_from_block_data(
        BlockData::new_proposal(
            Payload::empty(),
            Author::random(),
            round: 1001,
            timestamp: 0,
            forged_qc, // Invalid QC with fake signatures
            None,
        ),
        Author::random(),
        bls_private_key,
    );
    
    let vote_proposal = VoteProposal::new(malicious_block.gen_block_info());
    
    // Attack: Process as self-message (consensus skips verification)
    // Then SafetyRules processes with skip_sig_verify=true
    let result = safety_rules.construct_and_sign_vote_two_chain(
        &vote_proposal,
        None,
    );
    
    // Vulnerability: Vote succeeds despite forged QC
    assert!(result.is_ok(), "Byzantine validator successfully voted on forged QC");
    
    // Impact: Safety state is corrupted
    let consensus_state = safety_rules.consensus_state().unwrap();
    let safety_data = consensus_state.safety_data();
    assert_eq!(safety_data.one_chain_round, 1000, "Safety state corrupted by forged QC");
    
    // This validator can now make unsafe votes in future rounds
    // based on the corrupted preferred_round/one_chain_round values
}
```

## Notes

This vulnerability stems from a broken design assumption documented in the code comments. The `skip_sig_verify` flag was intended as an optimization assuming "consensus already verifies," but the self-message optimization creates a verification gap. The combination of these two optimizations creates a critical security hole that allows Byzantine validators to bypass the SafetyRules defense mechanism entirely when processing their own proposals.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L45-47)
```rust
    // Skip verification of signatures and well-formed, this can be set if it's used in local mode
    // where consensus already verifies.
    pub(crate) skip_sig_verify: bool,
```

**File:** consensus/safety-rules/src/safety_rules.rs (L63-72)
```rust
    pub(crate) fn verify_proposal(
        &mut self,
        vote_proposal: &VoteProposal,
    ) -> Result<VoteData, Error> {
        let proposed_block = vote_proposal.block();
        let safety_data = self.persistent_storage.safety_data()?;

        self.verify_epoch(proposed_block.epoch(), &safety_data)?;

        self.verify_qc(proposed_block.quorum_cert())?;
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L235-243)
```rust
    pub(crate) fn verify_qc(&self, qc: &QuorumCert) -> Result<(), Error> {
        let epoch_state = self.epoch_state()?;

        if !self.skip_sig_verify {
            qc.verify(&epoch_state.verifier)
                .map_err(|e| Error::InvalidQuorumCertificate(e.to_string()))?;
        }
        Ok(())
    }
```

**File:** consensus/src/round_manager.rs (L120-127)
```rust
            UnverifiedEvent::ProposalMsg(p) => {
                if !self_message {
                    p.verify(peer_id, validator, proof_cache, quorum_store_enabled)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["proposal"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::ProposalMsg(p)
```

**File:** consensus/src/epoch_manager.rs (L1591-1599)
```rust
                        unverified_event.clone().verify(
                            peer_id,
                            &epoch_state.verifier,
                            &proof_cache,
                            quorum_store_enabled,
                            peer_id == my_peer_id,
                            max_num_batches,
                            max_batch_expiry_gap_usecs,
                        )
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L131-135)
```rust
    pub fn new_local(storage: PersistentSafetyStorage) -> Self {
        let safety_rules = SafetyRules::new(storage, true);
        Self {
            internal_safety_rules: SafetyRulesWrapper::Local(Arc::new(RwLock::new(safety_rules))),
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L83-84)
```rust
        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
```
