# Audit Report

## Title
2-Chain Voting Rule Bypass for Round 1 Blocks Without Timeout Certificate

## Summary
The `safe_to_vote()` function in the 2-chain consensus protocol implementation incorrectly validates blocks at round 1 when no timeout certificate is provided. By defaulting `tc_round` to 0 using `map_or()`, the function accepts blocks at round 1 with ANY valid quorum certificate (qc_round >= 0), violating the fundamental 2-chain rule that requires `block.round == block.qc.round + 1` in the absence of a timeout certificate.

## Finding Description

The vulnerability exists in the `safe_to_vote()` function [1](#0-0) .

The 2-chain voting rule specifies two valid scenarios:
1. `block.round == block.qc.round + 1` (consecutive rounds)
2. `block.round == tc.round + 1 && block.qc.round >= tc.highest_hqc_round` (timeout recovery)

However, when `maybe_tc` is `None`, the implementation uses `map_or(0, ...)` to default both `tc_round` and `hqc_round` to 0 [2](#0-1) . This causes the conditional logic to evaluate as:

```
round == next_round(qc_round)? || (round == next_round(0)? && qc_round >= 0)
```

Which simplifies to:
```
round == qc_round + 1 || (round == 1 && qc_round >= 0)
```

For a block at round 1 with no timeout certificate:
- If `qc_round = 0`: First condition passes (1 == 0 + 1) ✓ **CORRECT**
- If `qc_round = 1`: First condition fails (1 != 2), but second condition passes (1 == 1 && 1 >= 0) ✓ **INCORRECT**
- If `qc_round = 5`: First condition fails (1 != 6), but second condition passes (1 == 1 && 5 >= 0) ✓ **INCORRECT**

The function `construct_and_sign_vote_two_chain()` calls this safety check [3](#0-2)  after only verifying signatures and round ordering [4](#0-3) , but does not validate QC round adjacency when no timeout certificate exists.

**Attack Scenario:**
1. At epoch start, validators have `last_voted_round = 0`
2. A Byzantine proposer constructs a malicious block at round 1 with a QC certifying round >= 1 (potentially from equivocation, previous epoch attempt, or network partition)
3. The QC signatures are valid (verified by `verify_qc()`) [5](#0-4) 
4. Fresh validators receive the proposal and call `construct_and_sign_vote_two_chain()`
5. `verify_and_update_last_vote_round(1, 0)` passes (1 > 0) [6](#0-5) 
6. `safe_to_vote()` incorrectly passes due to the bug
7. Honest validators vote on this consensus-rule-violating block
8. This could enable equivocation and consensus safety violations

## Impact Explanation

**Severity: Critical** - This vulnerability violates **Consensus Safety** invariant #2 from the Aptos specification, which states "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine."

The 2-chain voting rule is a fundamental safety guarantee documented in the code comments [7](#0-6) . By allowing validators to vote on blocks that violate this rule, the bug could enable:

- **Consensus equivocation**: Multiple valid blocks at the same round with different parents
- **Chain fork potential**: Different validators committing different blocks
- **Safety violation**: Breaks the fundamental guarantee that honest validators converge on a single chain

This meets the Critical Severity criteria: "Consensus/Safety violations" with potential impact on all validators in the network.

## Likelihood Explanation

**Likelihood: Low-to-Medium** - While the logic flaw definitely exists, exploitation requires specific conditions:

**Favorable factors for exploitation:**
- The bug is triggered on every block at round 1 without a timeout certificate
- Any Byzantine validator can attempt to propose malicious blocks
- Fresh validators at epoch start are vulnerable (last_voted_round = 0)

**Challenging factors:**
- Requires a valid QC for round >= 1 to exist at round 1 (unlikely in normal operation)
- May require network partitions, equivocation, or epoch transition edge cases
- The `verify_qc()` function still validates signatures [8](#0-7) , so the malicious QC must have valid signatures

Despite implementation challenges, the vulnerability represents a clear violation of documented protocol invariants and could be triggered in adversarial scenarios involving Byzantine validators and network anomalies.

## Recommendation

**Fix:** Explicitly check for the presence of a timeout certificate before evaluating the timeout-based voting condition. The second branch should only be considered when `maybe_tc.is_some()`.

Recommended code fix:

```rust
fn safe_to_vote(
    &self,
    block: &Block,
    maybe_tc: Option<&TwoChainTimeoutCertificate>,
) -> Result<(), Error> {
    let round = block.round();
    let qc_round = block.quorum_cert().certified_block().round();
    
    // Rule 1: consecutive rounds
    if round == next_round(qc_round)? {
        return Ok(());
    }
    
    // Rule 2: only applies with timeout certificate
    if let Some(tc) = maybe_tc {
        let tc_round = tc.round();
        let hqc_round = tc.highest_hqc_round();
        if round == next_round(tc_round)? && qc_round >= hqc_round {
            return Ok(());
        }
    }
    
    Err(Error::NotSafeToVote(
        round, 
        qc_round, 
        maybe_tc.map_or(0, |tc| tc.round()),
        maybe_tc.map_or(0, |tc| tc.highest_hqc_round())
    ))
}
```

This ensures the timeout-based condition is only evaluated when a timeout certificate is actually present, preventing the default value bypass.

## Proof of Concept

```rust
// Test case demonstrating the vulnerability
#[test]
fn test_2chain_rule_bypass_round_1() {
    let (mut safety_rules, signer) = constructor();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();
    
    // Create a block at round 1 with genesis QC (round 0) - this should work
    let block_valid = test_utils::make_proposal_with_qc(1, genesis_qc.clone(), &signer);
    
    // Vote on it to create a QC for round 1
    let vote = safety_rules.construct_and_sign_vote_two_chain(&block_valid, None).unwrap();
    
    // Simulate creating a QC for round 1 (in practice, this would need 2f+1 votes)
    // For PoC purposes, assume we have a valid QC certifying round 1
    
    // Reset safety rules to simulate a fresh validator
    let (mut safety_rules_fresh, _) = constructor();
    safety_rules_fresh.initialize(&proof).unwrap();
    
    // Create a malicious block at round 1 with a QC certifying round 1
    // This violates the 2-chain rule: 1 != 1 + 1
    let malicious_block = test_utils::make_proposal_with_qc(1, /* QC for round 1 */, &signer);
    
    // BUG: This should fail but passes due to the vulnerability
    // The safe_to_vote() check evaluates: (1 == 2) || (1 == 1 && 1 >= 0) = true
    let result = safety_rules_fresh.construct_and_sign_vote_two_chain(&malicious_block, None);
    
    // Expected: Err(Error::NotSafeToVote(1, 1, 0, 0))
    // Actual: Ok(Vote) - vulnerability confirmed
    assert!(result.is_err(), "Should reject block at round 1 with QC from round 1");
}
```

This test demonstrates that a block at round 1 with a non-adjacent QC round would incorrectly pass the `safe_to_vote()` check when no timeout certificate is provided.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L61-80)
```rust
        let vote_data = self.verify_proposal(vote_proposal)?;
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
        let proposed_block = vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }

        // Two voting rules
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L81-81)
```rust
        self.safe_to_vote(proposed_block, timeout_cert)?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L147-149)
```rust
    /// Core safety voting rule for 2-chain protocol. Return success if 1 or 2 is true
    /// 1. block.round == block.qc.round + 1
    /// 2. block.round == tc.round + 1 && block.qc.round >= tc.highest_hqc.round
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L150-166)
```rust
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L235-243)
```rust
    pub(crate) fn verify_qc(&self, qc: &QuorumCert) -> Result<(), Error> {
        let epoch_state = self.epoch_state()?;

        if !self.skip_sig_verify {
            qc.verify(&epoch_state.verifier)
                .map_err(|e| Error::InvalidQuorumCertificate(e.to_string()))?;
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L119-148)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "Quorum Cert's hash mismatch LedgerInfo"
        );
        // Genesis's QC is implicitly agreed upon, it doesn't have real signatures.
        // If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore
        // because of the round constraint.
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
        }
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify QuorumCert")?;
        self.vote_data.verify()?;
        Ok(())
    }
```
