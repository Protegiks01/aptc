# Audit Report

## Title
Integer Overflow in Epoch Ending Backup Manifest Verification Causes Panic and DoS

## Summary
The `verify()` function in the epoch ending backup manifest validation code contains an unchecked integer addition that causes a panic when processing malicious backup manifests with `chunk.last_epoch = u64::MAX`. This allows an attacker who can provide a malicious backup file to crash the restore/verification process, preventing node operators from restoring their database. [1](#0-0) 

## Finding Description

The vulnerability exists in the manifest verification logic that validates epoch ending backup chunks. During validation, the code iterates through chunks and calculates the next expected epoch using unchecked addition. [2](#0-1) 

**Attack Vector:**

1. An attacker compromises backup storage (e.g., misconfigured S3 bucket) or performs MITM on backup downloads
2. The attacker crafts a malicious `EpochEndingBackup` manifest with:
   - `first_epoch = u64::MAX`
   - `last_epoch = u64::MAX`  
   - One waypoint (to satisfy the check at line 31-38)
   - One chunk with `first_epoch = u64::MAX` and `last_epoch = u64::MAX`

3. When a node operator attempts to restore or verify this backup, the manifest is loaded from storage: [3](#0-2) 

4. The `verify()` call reaches line 56 where `u64::MAX + 1` causes an integer overflow
5. Due to Aptos's security configuration with `overflow-checks = true` in release builds, this causes a **panic** instead of wraparound: [4](#0-3) 

6. The panic terminates the restore process instead of returning a proper error

**Security Guarantee Broken:**

This violates Aptos's error handling guidelines which explicitly require using `Result` types instead of panics for recoverable errors: [5](#0-4) 

Additionally, it violates the integer arithmetic guidelines requiring checked operations: [6](#0-5) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

- **"Validator node slowdowns"** - The restore process crashes, preventing database restoration
- **"API crashes"** - The backup CLI tool panics and terminates abnormally  
- **"Significant protocol violations"** - Improper error handling through panic instead of Result

The impact is **Availability**: Node operators who need to restore from backups (e.g., setting up new validators, recovering from data loss) are unable to do so if their backup storage is compromised. This can prevent network expansion and delay recovery from incidents.

While epochs realistically cannot reach `u64::MAX` through normal operation (would take trillions of years), the vulnerability is exploitable through malicious external backup files, which are explicitly untrusted input sources.

## Likelihood Explanation

**Likelihood: Medium**

Prerequisites for exploitation:
1. Attacker must compromise the backup storage OR perform MITM on backup downloads OR socially engineer operators to use malicious backups
2. Node operator must attempt to restore/verify the malicious backup

This is realistic because:
- Backup storage is often in cloud services with potentially weak access controls
- Backup files are typically loaded from external sources without strong authentication
- The verification function processes untrusted data from deserialized JSON manifests [7](#0-6) 

## Recommendation

Replace unchecked integer addition with `checked_add()` and return a proper error instead of panicking:

```rust
// Before (line 56):
next_epoch = chunk.last_epoch + 1;

// After:
next_epoch = chunk.last_epoch.checked_add(1).ok_or_else(|| 
    anyhow!("Integer overflow: chunk.last_epoch ({}) + 1 exceeds u64::MAX", 
            chunk.last_epoch)
)?;
```

Apply the same pattern to line 33 which also performs addition that could overflow: [8](#0-7) 

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::waypoint::Waypoint;

    #[test]
    #[should_panic(expected = "attempt to add with overflow")]
    fn test_overflow_in_verify() {
        // Create a malicious manifest with last_epoch = u64::MAX
        let malicious_waypoint = Waypoint::new_any(&create_test_ledger_info());
        
        let manifest = EpochEndingBackup {
            first_epoch: u64::MAX,
            last_epoch: u64::MAX,
            waypoints: vec![malicious_waypoint],
            chunks: vec![EpochEndingChunk {
                first_epoch: u64::MAX,
                last_epoch: u64::MAX,
                ledger_infos: FileHandle::new("test".to_string()),
            }],
        };

        // This will panic with overflow due to line 56: next_epoch = u64::MAX + 1
        let result = manifest.verify();
        
        // Should return an error, not panic
        assert!(result.is_err());
    }
}
```

To reproduce:
1. Add the test to `storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs`
2. Run with `cargo test --package backup-cli test_overflow_in_verify`
3. Observe the panic occurs instead of returning an error

## Notes

The overflow is guaranteed to panic in both debug and release builds because Aptos explicitly enables overflow checks in production profiles for security. This prevents silent wraparound but introduces crash-on-invalid-input DoS vectors when proper error handling is not used. [9](#0-8) 

The fix aligns with existing patterns in the codebase where checked arithmetic is used extensively to handle edge cases properly: [10](#0-9)

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L31-38)
```rust
        ensure!(
            self.first_epoch <= self.last_epoch
                && self.last_epoch - self.first_epoch + 1 == self.waypoints.len() as u64,
            "Malformed manifest. first epoch: {}, last epoch {}, num waypoints {}",
            self.first_epoch,
            self.last_epoch,
            self.waypoints.len(),
        );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L40-57)
```rust
        // check chunk ranges
        ensure!(!self.chunks.is_empty(), "No chunks.");
        let mut next_epoch = self.first_epoch;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_epoch == next_epoch,
                "Chunk ranges not continuous. Expected first epoch: {}, actual: {}.",
                next_epoch,
                chunk.first_epoch,
            );
            ensure!(
                chunk.last_epoch >= chunk.first_epoch,
                "Chunk range invalid. [{}, {}]",
                chunk.first_epoch,
                chunk.last_epoch,
            );
            next_epoch = chunk.last_epoch + 1;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L80-83)
```rust
    async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
        let manifest: EpochEndingBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        manifest.verify()?;
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** RUST_SECURE_CODING.md (L17-20)
```markdown
Utilize Cargo for project management without overriding variables like `debug-assertions` and `overflow-checks`.

- **`debug-assertions`**: This variable controls whether debug assertions are enabled. Debug assertions are checks that are only present in debug builds. They are used to catch bugs during development by validating assumptions made in the code.
- **`overflow-checks`**: This variable determines whether arithmetic overflow checks are performed. In Rust, when overflow checks are enabled (which is the default in debug mode), an integer operation that overflows will cause a panic in debug builds, preventing potential security vulnerabilities like buffer overflows.
```

**File:** RUST_SECURE_CODING.md (L79-81)
```markdown
### Error Handling

Use `Result<T, E>` and `Option<T>` for error handling instead of _unwrapping_ or _expecting_, to avoid panics, more details on [coding-style](./RUST_CODING_STYLE.md#error-handling).
```

**File:** RUST_CODING_STYLE.md (L220-227)
```markdown
### Integer Arithmetic

As every integer operation (`+`, `-`, `/`, `*`, etc.) implies edge-cases (e.g. overflow `u64::MAX + 1`, underflow `0u64 -1`, division by zero, etc.),
we use checked arithmetic instead of directly using math symbols.
It forces us to think of edge-cases, and handle them explicitly.
This is a brief and simplified mini guide of the different functions that exist to handle integer arithmetic:

- [checked\_](https://doc.rust-lang.org/std/primitive.u32.html#method.checked_add): use this function if you want to handle overflow and underflow as a special edge-case. It returns `None` if an underflow or overflow has happened, and `Some(operation_result)` otherwise.
```
