# Audit Report

## Title
Memory Exhaustion in Bytecode Verifier Before Basic Block Limit Enforcement

## Summary
The Move bytecode verifier allocates memory for loop analysis structures before enforcing the `max_basic_blocks` configuration limit. An attacker can craft bytecode with a large number of basic blocks (up to 65,535) to force memory allocation during verification, bypassing the intended 1,024 block limit until after memory is consumed. This creates a resource exhaustion vector that can cause validator node slowdowns.

## Finding Description

The vulnerability exists in the bytecode verification ordering within the Move VM's code unit verifier. The critical issue is that `LoopSummary::new()` unconditionally allocates memory proportional to the number of basic blocks in the control flow graph **before** the `max_basic_blocks` limit is enforced. [1](#0-0) 

The function allocates four vectors sized to `num_blocks`: blocks, descs, backs, and preds. For the maximum 65,535 blocks (u16 limit), this results in approximately 3.4 MB allocation per function (blocks: 131KB, descs: 131KB, backs: ~1.57MB, preds: ~1.57MB).

The ordering issue occurs in the verification flow. In `CodeUnitVerifier::verify_function`, the control flow verification (which triggers the memory allocation) happens first: [2](#0-1) 

The `max_basic_blocks` limit check only happens **after** the control flow verification completes: [3](#0-2) 

Within `control_flow::verify_function`, the `verify_reducibility` function is called, which in turn calls `LoopSummary::new()`: [4](#0-3) [5](#0-4) 

**Attack Path:**

1. Attacker crafts Move bytecode with maximum basic blocks by strategically placing branch instructions. The only limit is `BYTECODE_COUNT_MAX` (65,535 instructions): [6](#0-5) 

2. Attacker submits the module via `code::publish_package_txn` entry function, which any user can call.

3. During transaction execution, bytecode verification is triggered when modules are loaded: [7](#0-6) 

4. `LoopSummary::new()` allocates ~3.4 MB per function before the limit check occurs.

5. With multiple functions per module and concurrent malicious transactions, memory pressure accumulates on validator nodes.

6. Eventually, the production `max_basic_blocks` limit (1,024) rejects the module: [8](#0-7) 

However, the memory has already been allocated and consumed during verification, even though the module is ultimately rejected.

## Impact Explanation

**High Severity** - This qualifies as "Validator node slowdowns" per the Aptos bug bounty criteria.

The vulnerability enables resource exhaustion attacks that bypass the intended `max_basic_blocks` protection:

- **Memory exhaustion**: Each malicious function forces ~3.4 MB allocation before limit enforcement
- **Node slowdowns**: Memory allocator performance degrades with large allocations, even if temporary
- **Amplification**: Multiple functions per module and concurrent transactions multiply the effect
- **Network liveness impact**: If multiple validators process malicious transactions simultaneously, network performance degrades

The key security violation is that resource consumption occurs **before** the protective limit is checked, allowing attackers to bypass the intended safeguard. While individual allocations are temporary (freed after verification fails), the ordering flaw enables resource exhaustion that affects validator performance.

## Likelihood Explanation

**High Likelihood** - The attack is trivially executable:

- **No privileges required**: Any user can call `code::publish_package_txn` to publish modules
- **Low complexity**: Crafting bytecode with many basic blocks only requires inserting branch instructions
- **Guaranteed trigger**: Every module publishing transaction undergoes bytecode verification with this vulnerable ordering
- **Deterministic behavior**: Memory allocation always precedes the limit check due to the fixed call order

The production configuration provides eventual rejection via `max_basic_blocks: Some(1024)`, but this occurs after the resource exhaustion has already been triggered, making it ineffective as a preventive control.

## Recommendation

Enforce the `max_basic_blocks` limit **before** performing expensive operations like `LoopSummary::new()`. Move the limit check earlier in the verification flow:

```rust
// In code_unit_verifier.rs, check limits BEFORE control flow verification
pub fn verify_function(...) -> PartialVMResult<usize> {
    // Check basic block limit FIRST
    let cfg = VMControlFlowGraph::new(&code.code);
    if let Some(limit) = verifier_config.max_basic_blocks {
        if cfg.num_blocks() as usize > limit {
            return Err(PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS)
                .at_code_offset(index, 0));
        }
    }
    
    // THEN proceed with control flow verification
    let function_view = control_flow::verify_function(
        verifier_config,
        module,
        index,
        function_definition,
        code,
        meter,
    )?;
    
    // Rest of verification continues...
}
```

This ensures limits are enforced before resource-intensive operations, preventing the resource exhaustion vector.

## Proof of Concept

A proof of concept would involve:

1. Creating a Move module with a function containing maximum branch instructions to generate ~65,000 basic blocks
2. Submitting this via `code::publish_package_txn` 
3. Monitoring validator memory allocation during verification
4. Observing that ~3.4 MB is allocated before the `TOO_MANY_BASIC_BLOCKS` error is returned

The vulnerability is confirmed by code analysis showing the ordering issue in the verification flow where `LoopSummary::new()` allocation precedes the `max_basic_blocks` enforcement.

## Notes

This vulnerability demonstrates a Time-of-Use-Time-of-Check (TOUTOC) issue where resource consumption happens before protective limits are enforced. While the memory is eventually freed after verification fails, the ordering allows attackers to force validators to allocate significant memory that bypasses the intended safeguards, enabling resource exhaustion attacks that can degrade validator performance and network liveness.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/loop_summary.rs (L74-80)
```rust
        let num_blocks = cfg.num_blocks() as usize;

        // Fields in LoopSummary that are filled via a depth-first traversal of `cfg`.
        let mut blocks = vec![0; num_blocks];
        let mut descs = vec![0; num_blocks];
        let mut backs = vec![vec![]; num_blocks];
        let mut preds = vec![vec![]; num_blocks];
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L138-145)
```rust
        let function_view = control_flow::verify_function(
            verifier_config,
            module,
            index,
            function_definition,
            code,
            meter,
        )?;
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L147-153)
```rust
        if let Some(limit) = verifier_config.max_basic_blocks {
            if function_view.cfg().blocks().len() > limit {
                return Err(
                    PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS).at_code_offset(index, 0)
                );
            }
        }
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L48-53)
```rust
    } else {
        verify_fallthrough(Some(index), code)?;
        let function_view = FunctionView::function(module, index, code, function_handle);
        verify_reducibility(verifier_config, &function_view)?;
        Ok(function_view)
    }
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L126-127)
```rust
    let summary = LoopSummary::new(function_view.cfg());
    let mut partition = LoopPartition::new(&summary);
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L61-61)
```rust
pub const BYTECODE_COUNT_MAX: u64 = 65535;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L192-195)
```rust
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L160-160)
```rust
        max_basic_blocks: Some(1024),
```
