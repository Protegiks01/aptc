# Audit Report

## Title
Eviction Loop Can Violate start_version <= end_version Invariant Leading to Cache Corruption in Indexer-GRPC Data Service

## Summary
The eviction logic in `DataManager::update_data()` unconditionally increments `start_version` without bounds checking, which can cause `start_version` to exceed `end_version`, violating a critical cache invariant. This can lead to cache corruption, incorrect data being served to clients, and potential service crashes.

## Finding Description

The `DataManager` struct maintains a circular buffer cache with an invariant that `start_version <= end_version`. The eviction logic triggered when `total_size >= size_limit_bytes` has a critical flaw: [1](#0-0) 

The eviction loop increments `start_version` unconditionally on every iteration, regardless of whether a transaction was actually evicted. If the cache contains empty slots (None values) while `total_size >= eviction_target`, the loop will increment `start_version` through these empty slots without decreasing `total_size`. This can cause the loop to run indefinitely or long enough to increment `start_version` beyond `end_version`.

**Root Cause**: Line 115 increments `start_version` unconditionally, with no check to ensure it doesn't exceed `end_version`.

**Contributing Factor**: There is also a bug in the version calculation logic that can create gaps in the cache: [2](#0-1) 

When `num_to_skip > 0`, the calculation `version = start_version + i` is incorrect because `i` includes the skipped indices. This causes transactions to be written to wrong slots, creating gaps that exacerbate the eviction bug.

**Attack Scenario**:
1. Cache is populated with transactions, some slots are overwritten or become empty due to the version calculation bug
2. Large transactions are added causing `total_size >= size_limit_bytes`  
3. Eviction triggers and the loop iterates through empty slots
4. `start_version` increments without `total_size` decreasing sufficiently
5. Loop continues until `start_version > end_version`, violating the invariant

**Consequences of Invariant Violation**:
- The `get_data()` function in the cache layer assumes `start_version < end_version` [3](#0-2) 
- If `start_version > end_version`, clients requesting data in valid version ranges will be incorrectly rejected
- The cache metrics will show inconsistent state [4](#0-3) 
- Subsequent calls to `update_data()` may panic at line 94 due to invalid state assumptions

## Impact Explanation

This is **High Severity** per Aptos bug bounty criteria for the following reasons:

1. **API Service Disruption**: The indexer-grpc-data-service-v2 is a critical API component for querying blockchain data. Cache corruption causes it to serve incorrect data or crash, directly impacting API availability.

2. **Data Correctness Violation**: Clients querying transaction history would receive incorrect or missing data, breaking the data integrity guarantee of the indexer service.

3. **Cascading Failures**: Once the invariant is violated, the cache enters an invalid state that can cause panics in subsequent operations, leading to service outages that require manual intervention.

4. **Silent Corruption**: The bug doesn't immediately crash the service; it causes silent data corruption that propagates to downstream systems relying on the indexer API.

## Likelihood Explanation

**Likelihood: Medium to High**

The bug can be triggered in production environments through the following conditions:

1. **Normal Operation with Version Calculation Bug**: The version calculation bug creates gaps in the cache during normal transaction ingestion, especially when processing historical data or catching up after downtime.

2. **Large Transaction Patterns**: Batches of large transactions that exceed `size_limit_bytes` trigger eviction. With gaps in the cache, the eviction loop can exceed bounds.

3. **High Load Scenarios**: During high transaction throughput, the service rapidly fills and evicts the cache, increasing the probability of hitting the edge case.

4. **No External Attacker Required**: While an attacker could potentially influence transaction patterns, the bug can manifest during legitimate operations without malicious intent.

The exact triggering conditions depend on transaction sizes, cache configuration, and data ingestion patterns, but these are common in production indexer deployments.

## Recommendation

**Fix 1: Add bounds check in eviction loop**

```rust
if self.total_size >= self.size_limit_bytes {
    while self.total_size >= self.eviction_target && self.start_version < self.end_version {
        if let Some(transaction) =
            self.data[self.start_version as usize % self.num_slots].take()
        {
            self.total_size -= transaction.encoded_len();
            drop(transaction);
        }
        self.start_version += 1;
    }
}
```

**Fix 2: Correct the version calculation bug**

```rust
for (idx, transaction) in transactions
    .into_iter()

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L75-86)
```rust
        for (i, transaction) in transactions
            .into_iter()
            .enumerate()
            .skip(num_to_skip as usize)
        {
            let version = start_version + i as u64;
            let slot_index = version as usize % self.num_slots;
            if let Some(transaction) = self.data[slot_index].take() {
                size_decreased += transaction.encoded_len();
            }
            size_increased += transaction.encoded_len();
            self.data[version as usize % self.num_slots] = Some(Box::new(transaction));
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L107-117)
```rust
        if self.total_size >= self.size_limit_bytes {
            while self.total_size >= self.eviction_target {
                if let Some(transaction) =
                    self.data[self.start_version as usize % self.num_slots].take()
                {
                    self.total_size -= transaction.encoded_len();
                    drop(transaction);
                }
                self.start_version += 1;
            }
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L122-126)
```rust
    fn update_cache_metrics(&self) {
        CACHE_START_VERSION.set(self.start_version as i64);
        CACHE_END_VERSION.set(self.end_version as i64);
        CACHE_SIZE_BYTES.set(self.total_size as i64);
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/in_memory_cache.rs (L69-71)
```rust
            if starting_version < data_manager.start_version {
                return None;
            }
```
