# Audit Report

## Title
Missing Execution State Validation in Commit Vote Signing Allows Ordered-Only to Ordered-Only Transition

## Summary
The `guarded_sign_commit_vote` function in SafetyRules fails to validate that the `new_ledger_info` parameter contains actual execution results. This allows signing commit votes for ledger infos that remain in the ordered-only state (with placeholder execution data), violating the critical consensus invariant that commit votes should only be signed for executed blocks.

## Finding Description

The `sign_commit_vote` function is responsible for signing commit votes that represent the transition from an ordered-only state (blocks that have reached consensus but not been executed) to an executed state (blocks with actual execution results). This is a critical part of Aptos's decoupled execution architecture. [1](#0-0) 

The function performs two validation checks:

**Check 1 (lines 381-393):** Validates that if `old_ledger_info` is NOT ordered-only, then it must match `new_ledger_info` exactly (special case for fast-forward sync).

**Check 2 (lines 395-403):** Validates that ordered-only fields (epoch, round, id, timestamp) match between old and new.

**Critical Missing Check:** The function never validates that `new_ledger_info` is NOT ordered-only. It should verify `!new_ledger_info.commit_info().is_ordered_only()` to ensure the new ledger info contains actual execution results. [2](#0-1) 

The `is_ordered_only()` function returns true when a BlockInfo has placeholder execution state (executed_state_id == ACCUMULATOR_PLACEHOLDER_HASH and version == 0), indicating it has been ordered but not executed.

**Attack Scenario:**

If an attacker can control the inputs to `sign_commit_vote` (through a compromised validator node, another bug in the pipeline, or malicious consensus messages), they could provide:

1. `ledger_info`: Contains ordered-only commit_info with:
   - epoch=1, round=5, id=0xABC
   - executed_state_id=ACCUMULATOR_PLACEHOLDER_HASH
   - version=0

2. `new_ledger_info`: Contains the SAME ordered-only commit_info with identical values

**Validation Bypass:**
- Check 1: `!is_ordered_only()` is FALSE (old IS ordered-only), so entire condition is FALSE → PASS
- Check 2: `match_ordered_only()` returns TRUE (all fields match) → PASS
- Signature check: Valid 2f+1 signatures on old_ledger_info → PASS
- Result: Function signs `new_ledger_info` which still has NO execution results

This violates the consensus safety invariant that commit votes should only represent blocks with actual execution results, potentially leading to state corruption where different validators commit different states.

## Impact Explanation

**Critical Severity** - This vulnerability enables consensus safety violations. If exploited, it could lead to:

1. **State Corruption**: Validators could sign commit votes for blocks that haven't been executed, causing divergent blockchain state across the network
2. **Consensus Safety Breach**: Different validators might commit different execution results for the same block
3. **Network Partition**: Could require a hardfork to recover if state corruption becomes widespread

This directly violates the **Deterministic Execution** and **Consensus Safety** invariants. Per Aptos bug bounty criteria, consensus/safety violations qualify as Critical severity (up to $1,000,000).

## Likelihood Explanation

**Medium-High Likelihood** - While the normal pipeline flow provides correct inputs, this vulnerability could be exploited through:

1. **Byzantine Validator**: A malicious validator node could craft invalid inputs internally
2. **Pipeline Bug**: Another bug in buffer manager or signing phase could cause incorrect inputs
3. **Deserialization Attack**: Malicious consensus messages could be crafted to trigger this path

The missing validation represents a defense-in-depth failure. Critical consensus safety functions must validate all inputs even when callers are expected to be correct, especially in a Byzantine fault-tolerant system.

## Recommendation

Add explicit validation that `new_ledger_info` is NOT ordered-only before signing:

```rust
fn guarded_sign_commit_vote(
    &mut self,
    ledger_info: LedgerInfoWithSignatures,
    new_ledger_info: LedgerInfo,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;
    
    let old_ledger_info = ledger_info.ledger_info();
    
    // Existing check 1
    if !old_ledger_info.commit_info().is_ordered_only()
        && old_ledger_info.commit_info() != new_ledger_info.commit_info()
    {
        return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
    }
    
    // NEW: Verify new_ledger_info contains execution results
    if new_ledger_info.commit_info().is_ordered_only() {
        return Err(Error::InvalidExecutedLedgerInfo(
            "new_ledger_info must contain execution results".to_string()
        ));
    }
    
    // Existing check 2
    if !old_ledger_info
        .commit_info()
        .match_ordered_only(new_ledger_info.commit_info())
    {
        return Err(Error::InconsistentExecutionResult(
            old_ledger_info.commit_info().to_string(),
            new_ledger_info.commit_info().to_string(),
        ));
    }
    
    // Rest of function unchanged...
}
```

Add corresponding error variant to the Error enum.

## Proof of Concept

```rust
#[test]
fn test_sign_commit_vote_ordered_only_to_ordered_only_should_fail() {
    let (mut safety_rules, signer) = constructor();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();
    
    let round = genesis_qc.certified_block().round();
    
    // Create a block proposal
    let a1 = test_utils::make_proposal_with_qc(round + 1, genesis_qc, &signer);
    let a2 = make_proposal_with_parent(round + 2, &a1, None, &signer);
    let a3 = make_proposal_with_parent(round + 3, &a2, Some(&a1), &signer);
    
    // Get ordered-only ledger info from QC
    let ordered_ledger_info = a3.block().quorum_cert().ledger_info();
    
    // Create another ordered-only ledger info with same ordered fields
    let ordered_only_commit_info = a1.block().gen_block_info(
        *ACCUMULATOR_PLACEHOLDER_HASH,
        0, // version = 0 (ordered-only)
        None,
    );
    let malicious_ledger_info = LedgerInfo::new(
        ordered_only_commit_info,
        ordered_ledger_info.ledger_info().consensus_data_hash(),
    );
    
    // Verify both are ordered-only
    assert!(ordered_ledger_info.ledger_info().commit_info().is_ordered_only());
    assert!(malicious_ledger_info.commit_info().is_ordered_only());
    
    // This SHOULD fail but currently SUCCEEDS - demonstrating the vulnerability
    let result = safety_rules.sign_commit_vote(
        ordered_ledger_info.clone(),
        malicious_ledger_info,
    );
    
    // With the fix, this should be an error
    assert!(matches!(result.unwrap_err(), Error::InvalidExecutedLedgerInfo(_)));
}
```

## Notes

This vulnerability demonstrates a critical gap in defense-in-depth validation. While the normal execution pipeline constructs correct inputs, the SafetyRules validation layer must independently verify all consensus safety invariants. The missing check for executed state allows the ordered-only to ordered-only transition, which should never occur in a correct system.

The test case at line 871-876 in `suite.rs` actually demonstrates passing identical ledger infos to both parameters, which is the fast-forward sync case mentioned in comments. However, this should only be allowed when both have actual execution results, not when both are ordered-only. [3](#0-2)

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```

**File:** types/src/block_info.rs (L209-214)
```rust
    pub fn is_ordered_only(&self) -> bool {
        *self != BlockInfo::empty()
            && self.next_epoch_state.is_none()
            && self.executed_state_id == *ACCUMULATOR_PLACEHOLDER_HASH
            && self.version == 0
    }
```

**File:** consensus/safety-rules/src/tests/suite.rs (L871-876)
```rust
    assert!(safety_rules
        .sign_commit_vote(
            ledger_info_with_sigs.clone(),
            ledger_info_with_sigs.ledger_info().clone()
        )
        .is_ok());
```
