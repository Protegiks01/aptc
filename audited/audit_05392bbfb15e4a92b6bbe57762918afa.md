# Audit Report

## Title
Network Configuration Mismatch Allows Users to Submit Transactions to Wrong Network

## Summary
The Aptos CLI does not validate that a profile's declared `network` field matches the actual chain ID returned by the configured REST endpoint. This allows users to accidentally submit transactions (including account creation) to the wrong network (e.g., mainnet instead of testnet), wasting real gas fees while being misled by incorrect explorer links.

## Finding Description

The `CreateAccount` struct uses `TransactionOptions` to submit account creation transactions. [1](#0-0) 

When a profile is configured via `aptos init`, it stores both a `network` field (enum) and a `rest_url` field (string) in `.aptos/config.yaml`. [2](#0-1) 

During transaction submission, the code retrieves the chain ID from the network endpoint's state but never validates it against the profile's expected network. [3](#0-2) 

After submission, the explorer link is generated by preferring the profile's `network` field over the actual chain ID, or by parsing the URL string if no network field exists. [4](#0-3) 

**Exploitation Scenario:**

1. User creates profile with `network: Testnet` and `rest_url: https://fullnode.testnet.aptoslabs.com`
2. User later manually edits config (or config is corrupted/misconfigured) to `rest_url: https://fullnode.mainnet.aptoslabs.com` while `network: Testnet` remains unchanged
3. User runs `aptos account create --account 0x123 --profile myprofile`
4. Transaction submits to **mainnet** (following rest_url)
5. User pays **mainnet gas fees** (real APT)
6. CLI shows "Transaction submitted: https://explorer.aptoslabs.com/txn/{hash}?**network=testnet**"
7. User believes transaction is on testnet, but it's actually on mainnet

Known chain ID mappings: MAINNET=1, TESTNET=2, DEVNET=3. [5](#0-4) 

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria: "Limited funds loss or manipulation". Users waste real APT on mainnet gas fees when they intended to use testnet. While the loss is limited to transaction gas costs (not unlimited theft), it represents actual monetary loss. Additionally, wrong-network deployment could lead to:
- Production Move modules deployed to wrong chains
- Loss of testnet-only safety guardrails
- Accounts created with real funds on unintended networks

## Likelihood Explanation

**High likelihood** due to multiple realistic scenarios:
- Users manually editing config files between development environments
- Copy-paste errors when setting up new profiles
- Scripts/tools generating configs with inconsistent values
- URL changes without updating network field
- Migration between different node providers
- Custom endpoint usage with wrong network label

The config file is plain-text YAML with no validation, making misconfiguration trivial.

## Recommendation

Add chain ID validation in `TransactionOptions::submit_transaction()`:

```rust
// After retrieving chain_id from state (line 1976)
let chain_id = ChainId::new(state.chain_id);

// Add validation
if let Some(profile_network) = self.profile_options.profile().ok().and_then(|p| p.network) {
    let expected_chain_id = match profile_network {
        Network::Mainnet => ChainId::mainnet(),
        Network::Testnet => ChainId::testnet(),
        Network::Devnet => ChainId::new(3), // DEVNET
        Network::Local => ChainId::new(4),  // TESTING
        Network::Custom => chain_id, // Skip validation for custom
    };
    
    if profile_network != Network::Custom && chain_id != expected_chain_id {
        return Err(CliError::CommandArgumentError(format!(
            "Network mismatch: profile configured for {:?} but endpoint returned chain_id {}. \
             Update your profile's rest_url or network field to match.",
            profile_network, chain_id
        )));
    }
}

// Use actual chain_id for explorer links instead of profile.network
let network = NamedChain::from_chain_id(&chain_id).ok().map(|nc| match nc {
    NamedChain::MAINNET => Network::Mainnet,
    NamedChain::TESTNET => Network::Testnet,
    NamedChain::DEVNET => Network::Devnet,
    NamedChain::TESTING => Network::Local,
    _ => Network::Custom,
});
```

## Proof of Concept

```bash
# Step 1: Initialize profile for testnet
aptos init --network testnet --profile test-profile

# Step 2: Manually edit .aptos/config.yaml
# Change rest_url to mainnet while keeping network: Testnet
cat > .aptos/config.yaml << EOF
profiles:
  test-profile:
    network: Testnet
    private_key: "0x..." # (your key)
    public_key: "0x..."
    account: "0x..."
    rest_url: "https://fullnode.mainnet.aptoslabs.com"
    faucet_url: null
EOF

# Step 3: Create account - will submit to MAINNET but show testnet link
aptos account create --account 0x1234567890abcdef --profile test-profile

# Output shows:
# "Transaction submitted: https://explorer.aptoslabs.com/txn/{hash}?network=testnet"
# But transaction is actually on MAINNET (check explorer with network=mainnet)
# User pays MAINNET gas fees unknowingly
```

**Notes:**

This vulnerability is specific to CLI user experience and configuration validation, not a blockchain consensus or Move VM issue. It represents a safety guardrail that should exist but doesn't. The impact is real monetary loss through wasted gas fees and potential wrong-network deployments, meeting the Medium severity threshold for "limited funds loss."

### Citations

**File:** crates/aptos/src/account/create.rs (L18-26)
```rust
#[derive(Debug, Parser)]
pub struct CreateAccount {
    /// Address of the new account
    #[clap(long, value_parser = crate::common::types::load_account_arg)]
    pub(crate) account: AccountAddress,

    #[clap(flatten)]
    pub(crate) txn_options: TransactionOptions,
}
```

**File:** crates/aptos/src/common/types.rs (L270-305)
```rust
#[derive(Debug, Default, Serialize, Deserialize)]
pub struct ProfileConfig {
    /// Name of network being used, if setup from aptos init
    #[serde(skip_serializing_if = "Option::is_none")]
    pub network: Option<Network>,
    /// Private key for commands.
    #[serde(
        skip_serializing_if = "Option::is_none",
        default,
        serialize_with = "serialize_material_with_prefix",
        deserialize_with = "deserialize_material_with_prefix"
    )]
    pub private_key: Option<Ed25519PrivateKey>,
    /// Public key for commands
    #[serde(
        skip_serializing_if = "Option::is_none",
        serialize_with = "serialize_material_with_prefix",
        deserialize_with = "deserialize_material_with_prefix"
    )]
    pub public_key: Option<Ed25519PublicKey>,
    /// Account for commands
    #[serde(
        skip_serializing_if = "Option::is_none",
        deserialize_with = "deserialize_address_str"
    )]
    pub account: Option<AccountAddress>,
    /// URL for the Aptos rest endpoint
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rest_url: Option<String>,
    /// URL for the Faucet endpoint (if applicable)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub faucet_url: Option<String>,
    /// Derivation path index of the account on ledger
    #[serde(skip_serializing_if = "Option::is_none")]
    pub derivation_path: Option<String>,
}
```

**File:** crates/aptos/src/common/types.rs (L1958-1976)
```rust
        // Get sequence number for account
        let (account, state) = get_account_with_state(&client, sender_address).await?;
        let sequence_number = account.sequence_number;

        // Retrieve local time, and ensure it's within an expected skew of the blockchain
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map_err(|err| CliError::UnexpectedError(err.to_string()))?
            .as_secs();
        let now_usecs = now * US_IN_SECS;

        // Warn local user that clock is skewed behind the blockchain.
        // There will always be a little lag from real time to blockchain time
        if now_usecs < state.timestamp_usecs - ACCEPTED_CLOCK_SKEW_US {
            eprintln!("Local clock is is skewed from blockchain clock.  Clock is more than {} seconds behind the blockchain {}", ACCEPTED_CLOCK_SKEW_US, state.timestamp_usecs / US_IN_SECS );
        }
        let expiration_time_secs = now + self.gas_options.expiration_secs;

        let chain_id = ChainId::new(state.chain_id);
```

**File:** crates/aptos/src/common/types.rs (L2090-2116)
```rust
        let network = self.profile_options.profile().ok().and_then(|profile| {
            if let Some(network) = profile.network {
                Some(network)
            } else {
                // Approximate network from URL
                match profile.rest_url {
                    None => None,
                    Some(url) => {
                        if url.contains("mainnet") {
                            Some(Network::Mainnet)
                        } else if url.contains("testnet") {
                            Some(Network::Testnet)
                        } else if url.contains("devnet") {
                            Some(Network::Devnet)
                        } else if url.contains("localhost") || url.contains("127.0.0.1") {
                            Some(Network::Local)
                        } else {
                            None
                        }
                    },
                }
            }
        });
        eprintln!(
            "Transaction submitted: {}",
            explorer_transaction_link(transaction_hash, network)
        );
```

**File:** types/src/chain_id.rs (L11-24)
```rust
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum NamedChain {
    /// Users might accidentally initialize the ChainId field to 0, hence reserving ChainId 0 for accidental
    /// initialization.
    /// MAINNET is the Aptos mainnet production chain and is reserved for 1
    MAINNET = 1,
    // Even though these CHAIN IDs do not correspond to MAINNET, changing them should be avoided since they
    // can break test environments for various organisations.
    TESTNET = 2,
    DEVNET = 3,
    TESTING = 4,
    PREMAINNET = 5,
}
```
