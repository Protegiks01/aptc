# Audit Report

## Title
DB Debugger Tool Lacks Pruning Boundary Check Leading to Misleading Audit Results

## Summary
The `get_value` db_debugger command does not check the `min_readable_version` pruning boundary before querying historical state values. This causes the tool to return misleading "Value not found" results for pruned data without warning users, potentially leading auditors to incorrect conclusions about state integrity during security investigations.

## Finding Description

The db_debugger's `get_value` command is designed to query historical state values for auditing and debugging purposes. However, it bypasses a critical safety check that the main AptosDB implementation enforces.

**The Missing Check:**

In the normal AptosDB read path, all state queries first verify the requested version is within the readable range: [1](#0-0) 

This check ensures users are warned when querying pruned data: [2](#0-1) 

**The Vulnerable Code:**

The db_debugger tool directly queries the StateKvDb without this protection: [3](#0-2) 

The tool opens StateKvDb and directly calls `get_state_value_with_version_by_version` without checking `min_readable_version`. While the pruning progress IS available in the metadata database: [4](#0-3) 

**Attack Scenario:**

1. An Aptos node runs with pruning enabled (prune_window = 100,000 versions)
2. Current ledger version is 500,000, min_readable_version is 400,000
3. Security auditor investigates a suspected issue at version 350,000
4. Auditor runs: `db-debugger state-kv get-value --address 0x1 --struct-tag "..." --version 350000`
5. Tool returns: "Value not found" 
6. Auditor incorrectly concludes: "State value didn't exist at version 350,000"
7. **Reality**: State value DID exist but was pruned - this is hidden from the auditor

**Partial History Problem:**

When the tool iterates backwards through versions, it shows partial history without explaining gaps: [5](#0-4) 

If min_readable_version = 1,000,000 and the user queries version 1,500,000, the tool will show values at versions 1,500,000, 1,400,000, 1,300,000, 1,200,000, 1,100,000, then suddenly "Value not found" for older versions without explaining the discontinuity.

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria - "State inconsistencies requiring intervention."

This vulnerability affects the integrity of security audits and debugging operations:

1. **Misleading Audit Conclusions**: Auditors investigating security incidents may draw incorrect conclusions about historical state, potentially missing real attacks or falsely identifying issues.

2. **Incomplete State History**: The partial history display without pruning boundaries creates false confidence in data completeness.

3. **Operational Impact**: DevOps teams debugging production issues may waste time investigating "missing" state that was simply pruned.

4. **No Consensus Impact**: This is a tooling issue that does not affect runtime blockchain operation, validator consensus, or fund security - hence Medium rather than High/Critical severity.

## Likelihood Explanation

**Likelihood: High** - This issue will occur in normal operations:

- All production Aptos nodes run with pruning enabled (prune_window configured)
- Auditors and developers regularly use db_debugger tools for investigation
- No special privileges or timing conditions are required
- The tool provides no indication that returned results may be incomplete due to pruning

The vulnerability is not a race condition - it's a missing validation check that consistently produces misleading results when querying pruned versions.

## Recommendation

Add a pruning boundary check to the db_debugger tool before querying state values:

```rust
// In storage/aptosdb/src/db_debugger/state_kv/get_value.rs
impl Cmd {
    pub fn run(self) -> Result<()> {
        let address = AccountAddress::from_hex_literal(&self.address).unwrap();
        let struct_tag = StructTag::from_str(&self.struct_tag)?;
        let key = StateKey::resource(&address, &struct_tag)?;

        let ledger_db = self.db_dir.open_ledger_db()?;
        let db = self.db_dir.open_state_kv_db()?;
        let latest_version = ledger_db
            .metadata_db()
            .get_synced_version()?
            .expect("DB is empty.");
        
        // ADD: Check min_readable_version
        let min_readable_version = crate::pruner::pruner_utils::get_state_kv_pruner_progress(&db)?;
        
        println!("latest version: {latest_version}");
        println!("min readable version: {min_readable_version}");
        
        if self.version != Version::MAX && self.version > latest_version {
            println!(
                "{}",
                format!(
                    "warning: version {} is greater than latest version {}",
                    self.version, latest_version
                )
                .red()
            );
        }
        
        // ADD: Warn if querying below pruning boundary
        if self.version < min_readable_version {
            println!(
                "{}",
                format!(
                    "ERROR: version {} is below min_readable_version {}. Data has been pruned and is not available.",
                    self.version, min_readable_version
                )
                .red()
            );
            return Ok(());
        }

        let mut start_version = self.version;
        let mut count = 0;
        while count < 10 {
            // ADD: Stop iteration if we hit pruning boundary
            if start_version < min_readable_version {
                println!(
                    "{}",
                    format!(
                        "Reached pruning boundary at version {}. Earlier versions are not available.",
                        min_readable_version
                    )
                    .yellow()
                );
                break;
            }
            
            match db.get_state_value_with_version_by_version(&key, start_version)? {
                // ... rest of implementation
            }
        }
        Ok(())
    }
}
```

## Proof of Concept

**Setup:**
1. Run an Aptos node with pruning enabled (default configuration)
2. Allow the node to process several hundred thousand transactions
3. Verify pruning has occurred by checking min_readable_version

**Reproduction Steps:**

```rust
// Test demonstrating the vulnerability
#[test]
fn test_db_debugger_missing_pruning_check() {
    use aptos_temppath::TempPath;
    use aptos_config::config::{RocksdbConfigs, StorageDirPaths};
    use crate::pruner::pruner_utils::get_state_kv_pruner_progress;
    
    // Setup test database with pruned data
    let tmpdir = TempPath::new();
    let db_path = tmpdir.path();
    
    // 1. Write state values for versions 0-1000
    // 2. Prune versions 0-500 (set min_readable_version = 500)
    // 3. Attempt to query version 300 with db_debugger
    
    // Open DB as db_debugger would
    let ledger_db = LedgerDb::new(db_path, RocksdbConfigs::default(), None, None, true).unwrap();
    let state_kv_db = StateKvDb::new(
        &StorageDirPaths::from_path(db_path),
        RocksdbConfigs::default(),
        None,
        None,
        true,
        ledger_db.metadata_db_arc(),
    ).unwrap();
    
    let min_readable = get_state_kv_pruner_progress(&state_kv_db).unwrap();
    println!("min_readable_version: {}", min_readable);
    
    // Query version below min_readable_version (simulating db_debugger behavior)
    let query_version = 300;
    let key = StateKey::raw(b"test_key");
    
    // This returns None without explaining why
    let result = state_kv_db.get_state_value_with_version_by_version(&key, query_version).unwrap();
    
    // Expected: Tool should warn user that version 300 < min_readable_version
    // Actual: Tool just says "Value not found" - misleading!
    assert!(result.is_none());
    assert!(query_version < min_readable);
    
    println!("BUG: Query for version {} returned None without warning about pruning boundary at version {}", 
             query_version, min_readable);
}
```

**Expected Output (Current Buggy Behavior):**
```
latest version: 500000
Value not found.
```

**Expected Output (After Fix):**
```
latest version: 500000
min readable version: 400000
ERROR: version 350000 is below min_readable_version 400000. Data has been pruned and is not available.
```

## Notes

This vulnerability specifically affects audit and debugging operations. While it does not directly impact blockchain consensus or runtime security, it can lead to incorrect conclusions during security investigations, potentially masking real attacks or causing false positives in security analyses. The fix is straightforward and should be implemented to maintain the integrity of debugging and auditing workflows.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L644-655)
```rust
    fn get_state_value_with_version_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<Option<(Version, StateValue)>> {
        gauged_api("get_state_value_with_version_by_version", || {
            self.error_if_state_kv_pruned("StateValue", version)?;

            self.state_store
                .get_state_value_with_version_by_version(state_key, version)
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-315)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/db_debugger/state_kv/get_value.rs (L52-89)
```rust
        let ledger_db = self.db_dir.open_ledger_db()?;
        let db = self.db_dir.open_state_kv_db()?;
        let latest_version = ledger_db
            .metadata_db()
            .get_synced_version()?
            .expect("DB is empty.");
        println!("latest version: {latest_version}");
        if self.version != Version::MAX && self.version > latest_version {
            println!(
                "{}",
                format!(
                    "warning: version {} is greater than latest version {}",
                    self.version, latest_version
                )
                .red()
            );
        }

        let mut start_version = self.version;
        let mut count = 0;
        while count < 10 {
            match db.get_state_value_with_version_by_version(&key, start_version)? {
                None => {
                    if count == 0 {
                        println!("{}", "Value not found.".to_string().yellow());
                    }
                    break;
                },
                Some((version, value)) => {
                    Self::print_value(version, value);
                    count += 1;
                    if version == 0 {
                        break;
                    }
                    start_version = version - 1;
                },
            }
        }
```

**File:** storage/aptosdb/src/pruner/pruner_utils.rs (L23-29)
```rust
pub(crate) fn get_state_kv_pruner_progress(state_kv_db: &StateKvDb) -> Result<Version> {
    Ok(get_progress(
        state_kv_db.metadata_db(),
        &DbMetadataKey::StateKvPrunerProgress,
    )?
    .unwrap_or(0))
}
```
