# Audit Report

## Title
Non-Atomic BlockReader Methods Enable Invalid SyncInfo Broadcast in Consensus Layer

## Summary
The `BlockReader` trait methods in the consensus layer acquire separate read locks for each method call, allowing partial state updates to be observed when constructing `SyncInfo` objects. This can result in honest validators broadcasting invalid `SyncInfo` that violates round ordering invariants, causing peer rejection and potential reputation damage.

## Finding Description

The `BlockReader` implementation in `BlockStore` uses separate read lock acquisitions for each method call to the underlying `BlockTree`: [1](#0-0) 

When `sync_info()` is called to construct a `SyncInfo` object, it invokes multiple `BlockReader` methods with separate lock acquisitions: [2](#0-1) 

This creates a race condition window where concurrent write operations can update the `BlockTree` state between these individual read calls. Specifically, when `insert_single_quorum_cert()` updates both `highest_quorum_cert` and `highest_ordered_cert` atomically within a single write lock: [3](#0-2) 

A concurrent `sync_info()` call can observe:
- Old `highest_quorum_cert` value (read before the update)
- New `highest_ordered_cert` value (read after the update)

This violates the `SyncInfo` invariant that requires `HQC.certified_block().round() >= HOC.commit_info().round()`: [4](#0-3) 

When this invalid `SyncInfo` is broadcast (e.g., during timeout processing), peers will reject it: [5](#0-4) [6](#0-5) 

## Impact Explanation

This issue qualifies as **High Severity** under the "Significant protocol violations" category because:

1. **Protocol Violation**: Honest validators broadcast invalid synchronization messages that violate documented consensus invariants
2. **Reputation Damage**: Peers log `SecurityEvent::InvalidSyncInfoMsg`, potentially marking honest validators as malicious
3. **Liveness Impact**: If a leader validator experiences this race during proposal generation, peers may reject its proposals, delaying consensus rounds
4. **Network Health**: Repeated occurrences could lead to validators being disconnected or ignored by peers

While this does not directly cause fund loss or consensus safety violations (because the verification catches the invalid data), it represents a significant deviation from expected protocol behavior that can impact validator operations and network coordination.

## Likelihood Explanation

The likelihood is **MEDIUM-HIGH** because:

1. **Frequent Occurrence**: In a high-throughput consensus system processing many blocks and QCs, write operations to `BlockTree` are common
2. **Narrow Race Window**: The race window between separate lock acquisitions is small but non-zero
3. **Normal Operation**: The race can occur during routine consensus operation without any malicious actors
4. **Multiple Call Sites**: `sync_info()` is called from several locations (timeouts, proposals, sync requests), increasing exposure

The race is not easily triggerable by an external attacker but will occur naturally during normal high-load consensus operation, particularly when many QCs are being processed simultaneously.

## Recommendation

Modify the `BlockStore` implementation to acquire a single read lock for the entire `sync_info()` operation, ensuring atomic reads of all components:

```rust
fn sync_info(&self) -> SyncInfo {
    let inner = self.inner.read();  // Single read lock for entire operation
    SyncInfo::new_decoupled(
        inner.highest_quorum_cert().as_ref().clone(),
        inner.highest_ordered_cert().as_ref().clone(),
        inner.highest_commit_cert().as_ref().clone(),
        inner.highest_2chain_timeout_cert().map(|tc| tc.as_ref().clone()),
    )
}
```

Similarly, ensure other methods that read multiple related values (like `vote_back_pressure()`) use a single lock acquisition: [7](#0-6) 

## Proof of Concept

```rust
#[tokio::test]
async fn test_sync_info_race_condition() {
    use std::sync::Arc;
    use std::sync::atomic::{AtomicBool, Ordering};
    
    // Setup: Create a BlockStore with initial state
    let block_store = /* initialize BlockStore */;
    
    let race_detected = Arc::new(AtomicBool::new(false));
    let race_detected_clone = race_detected.clone();
    
    // Thread 1: Continuously insert new QCs
    let block_store_clone = block_store.clone();
    let writer = tokio::spawn(async move {
        for round in 10..1000 {
            let qc = /* create QC for round */;
            let _ = block_store_clone.insert_single_quorum_cert(qc);
            tokio::time::sleep(Duration::from_micros(100)).await;
        }
    });
    
    // Thread 2: Continuously read sync_info and verify consistency
    let reader = tokio::spawn(async move {
        for _ in 0..1000 {
            let sync_info = block_store.sync_info();
            
            // Check if sync_info violates invariant
            if sync_info.highest_quorum_cert().certified_block().round() 
                < sync_info.highest_ordered_cert().commit_info().round() {
                race_detected_clone.store(true, Ordering::Relaxed);
                println!("Race detected: HQC round {} < HOC round {}", 
                    sync_info.highest_quorum_cert().certified_block().round(),
                    sync_info.highest_ordered_cert().commit_info().round());
                break;
            }
            tokio::time::sleep(Duration::from_micros(50)).await;
        }
    });
    
    let _ = tokio::join!(writer, reader);
    assert!(race_detected.load(Ordering::Relaxed), 
            "Race condition should be detectable under concurrent load");
}
```

## Notes

This vulnerability represents a classic time-of-check-time-of-use (TOCTOU) race condition in concurrent programming. While the individual `BlockTree` updates are atomic, the composition of multiple reads to create a `SyncInfo` object is not atomic. The fix is straightforward: ensure that related reads that must form a consistent snapshot are performed under a single lock acquisition. This is a correctness and protocol compliance issue that, while not directly causing consensus safety violations due to verification checks, can negatively impact validator reputation and network coordination.

### Citations

**File:** consensus/src/block_storage/block_store.rs (L639-645)
```rust
    fn ordered_root(&self) -> Arc<PipelinedBlock> {
        self.inner.read().ordered_root()
    }

    fn commit_root(&self) -> Arc<PipelinedBlock> {
        self.inner.read().commit_root()
    }
```

**File:** consensus/src/block_storage/block_store.rs (L680-688)
```rust
    fn sync_info(&self) -> SyncInfo {
        SyncInfo::new_decoupled(
            self.highest_quorum_cert().as_ref().clone(),
            self.highest_ordered_cert().as_ref().clone(),
            self.highest_commit_cert().as_ref().clone(),
            self.highest_2chain_timeout_cert()
                .map(|tc| tc.as_ref().clone()),
        )
    }
```

**File:** consensus/src/block_storage/block_store.rs (L698-703)
```rust
        let commit_round = self.commit_root().round();
        let ordered_round = self.ordered_root().round();
        counters::OP_COUNTERS
            .gauge("back_pressure")
            .set((ordered_round - commit_round) as i64);
        ordered_round > self.vote_back_pressure_limit + commit_round
```

**File:** consensus/src/block_storage/block_tree.rs (L368-383)
```rust
                if block.round() > self.highest_certified_block().round() {
                    self.highest_certified_block_id = block.id();
                    self.highest_quorum_cert = Arc::clone(&qc);
                }
            },
            None => bail!("Block {} not found", block_id),
        }

        self.id_to_quorum_cert
            .entry(block_id)
            .or_insert_with(|| Arc::clone(&qc));

        if self.highest_ordered_cert.commit_info().round() < qc.commit_info().round() {
            // Question: We are updating highest_ordered_cert but not highest_ordered_root. Is that fine?
            self.highest_ordered_cert = Arc::new(qc.into_wrapped_ledger_info());
        }
```

**File:** consensus/consensus-types/src/sync_info.rs (L152-156)
```rust
        ensure!(
            self.highest_quorum_cert.certified_block().round()
                >= self.highest_ordered_cert().commit_info().round(),
            "HQC has lower round than HOC"
        );
```

**File:** consensus/src/round_manager.rs (L888-896)
```rust
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
```

**File:** consensus/src/round_manager.rs (L998-1002)
```rust
        if self.sync_only() {
            self.network
                .broadcast_sync_info(self.block_store.sync_info())
                .await;
            bail!("[RoundManager] sync_only flag is set, broadcasting SyncInfo");
```
