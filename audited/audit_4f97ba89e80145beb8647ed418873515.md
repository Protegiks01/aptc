# Audit Report

## Title
Transaction Correctness Checker Only Validates Accumulator Hash, Not Full Transaction Data Integrity

## Summary

The `TransactionCorrectnessChecker` in the node checker only compares `accumulator_root_hash` values between nodes, but does not verify that the actual transaction data (transaction input, events, write set, gas used, execution status) returned by the node API is consistent with the cryptographic hashes contained in the `TransactionInfo`. This allows nodes with corrupted storage or malicious APIs to pass health checks while serving incorrect transaction data to clients. [1](#0-0) 

## Finding Description

The `check()` function fetches complete `TransactionOnChainData` from both baseline and target nodes, which includes the transaction, events, write set, `TransactionInfo`, and `accumulator_root_hash`. However, it only compares the `accumulator_root_hash` field and declares the transaction "valid" if this single field matches. [2](#0-1) 

The `TransactionOnChainData` structure contains multiple components that should all be cryptographically verified: [3](#0-2) 

The `TransactionInfo` structure contains hashes that represent commitments to the actual data: [4](#0-3) 

The critical issue is that while matching `accumulator_root_hash` values prove both nodes have the same `TransactionInfo` hashes in their transaction accumulator (because the accumulator is a Merkle tree of `hash(TransactionInfo)` values), it does NOT verify that the actual transaction data, events, and write set returned in the API response match those hashes. [5](#0-4) 

**Attack Scenarios:**

1. **Storage Corruption**: A node's storage is partially corrupted where transaction data or events are damaged, but the transaction accumulator database remains intact. The API returns corrupted data with a correct `accumulator_root_hash`, passing the check.

2. **API Bug**: The API has a bug in constructing responses (in `convert_into_transaction_on_chain_data`) where it fetches data from mismatched versions or sources. As long as the `accumulator_root_hash` field is correct, the checker passes. [6](#0-5) 

3. **Malicious API**: A compromised node intentionally returns manipulated events or write sets (e.g., to hide certain transactions from indexers) while returning the correct `accumulator_root_hash` from storage to pass health checks.

The Aptos codebase already provides a method to verify this consistency: `TransactionOutput::ensure_match_transaction_info()` which validates:
- Transaction status matches
- Gas used matches  
- Write set hash matches `state_change_hash`
- Event root hash matches `event_root_hash` [7](#0-6) 

This method is used throughout the codebase for transaction replay and verification, but the node checker does not utilize it.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program category "State inconsistencies requiring intervention."

The vulnerability enables:

1. **Indexer Data Corruption**: Indexers that rely on checker-verified nodes as data sources could index incorrect events or state changes, affecting all applications depending on that indexed data.

2. **Client Misinformation**: Clients querying "verified" nodes receive incorrect transaction effects, events, or gas information, causing application-level failures.

3. **False Health Signals**: Node operators with corrupted or buggy nodes receive false positive health checks, preventing them from identifying and fixing storage or API issues.

While this does not directly cause fund loss or consensus violations (validators use different verification mechanisms), it breaks the **State Consistency** invariant by allowing nodes to serve data that doesn't match their cryptographic commitments while passing verification checks.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is likely to manifest in practice because:

1. **Storage Corruption**: Database corruption is a common operational issue in distributed systems. Partial corruption affecting transaction data but not accumulator metadata is realistic.

2. **API Implementation Complexity**: The API retrieves data from multiple storage components and combines them. Bugs in this process are plausible. [8](#0-7) 

3. **Operational Reliance on Checker**: Node operators use this checker to validate their nodes are functioning correctly. A false positive has real operational impact.

The exploitation requires no special privileges - it occurs naturally when nodes have storage issues or API bugs.

## Recommendation

The `TransactionCorrectnessChecker` should verify the full integrity of transaction data by:

1. **Comparing TransactionInfo Fields**: Verify that both nodes return identical `TransactionInfo` (gas_used, status, transaction_hash, event_root_hash, state_change_hash).

2. **Validating Data Consistency**: Use `ensure_match_transaction_info()` or implement equivalent checks to verify:
   - Returned events hash to `event_root_hash`
   - Returned write set hashes to `state_change_hash`  
   - Gas used matches
   - Execution status matches

3. **Optional: Compare Actual Data**: For stronger verification, directly compare transaction data, events, and write sets between nodes.

**Code Fix:**

```rust
// In check() function, after line 194, add:

// Verify TransactionInfo consistency
let baseline_info = &middle_baseline_transaction.info;
let target_info = &middle_target_transaction.info;

if baseline_info.gas_used() != target_info.gas_used() {
    return Ok(vec![Self::build_result(
        "Transaction gas used mismatch".to_string(),
        0,
        format!("Gas used differs: baseline={}, target={}", 
            baseline_info.gas_used(), target_info.gas_used()),
    )]);
}

if baseline_info.transaction_hash() != target_info.transaction_hash() {
    return Ok(vec![Self::build_result(
        "Transaction hash mismatch".to_string(),
        0,
        format!("Transaction hashes differ"),
    )]);
}

if baseline_info.event_root_hash() != target_info.event_root_hash() {
    return Ok(vec![Self::build_result(
        "Event root hash mismatch".to_string(),
        0,
        format!("Event root hashes differ"),
    )]);
}

if baseline_info.state_change_hash() != target_info.state_change_hash() {
    return Ok(vec![Self::build_result(
        "State change hash mismatch".to_string(),
        0,
        format!("State change hashes differ"),
    )]);
}

// Verify data matches hashes (if events and write set are available)
// This would require accessing the actual TransactionOutput
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_accumulator_hash_insufficient_for_data_verification() {
    // Setup: Create two TransactionOnChainData objects with:
    // 1. Same accumulator_root_hash
    // 2. Different events (corrupted)
    
    let version = 100u64;
    let correct_accumulator_hash = HashValue::random();
    
    // Baseline transaction with correct data
    let baseline_events = vec![/* correct events */];
    let baseline_txn = TransactionOnChainData {
        version,
        transaction: /* ... */,
        info: TransactionInfo::new(
            /* ... */,
            event_root_hash_from_events(&baseline_events),
            /* ... */
        ),
        events: baseline_events.clone(),
        accumulator_root_hash: correct_accumulator_hash,
        changes: /* ... */,
    };
    
    // Target transaction with CORRUPTED events but SAME accumulator_root_hash
    let corrupted_events = vec![/* different/corrupted events */];
    let target_txn = TransactionOnChainData {
        version,
        transaction: /* ... */,
        info: baseline_txn.info.clone(), // Same TransactionInfo
        events: corrupted_events, // DIFFERENT events!
        accumulator_root_hash: correct_accumulator_hash, // SAME hash
        changes: /* ... */,
    };
    
    // Current checker only compares accumulator_root_hash
    assert_eq!(
        baseline_txn.accumulator_root_hash,
        target_txn.accumulator_root_hash
    ); // PASSES!
    
    // But events are different - checker doesn't detect this
    assert_ne!(baseline_txn.events, target_txn.events);
    
    // The checker would incorrectly report this as "valid transaction data"
    // when the target is actually serving corrupted events
}
```

**Notes**

The vulnerability stems from a design limitation where "transaction correctness" is conflated with "accumulator correctness". While the accumulator root hash proves the `TransactionInfo` is consistent across nodes, it does not prove that the actual data returned by the API matches those cryptographic commitments. This creates a verification gap that allows corrupted or malicious nodes to pass health checks while serving incorrect data to clients and indexers.

### Citations

**File:** ecosystem/node-checker/src/checker/transaction_correctness.rs (L173-204)
```rust
        let middle_baseline_transaction = Self::get_transaction_by_version(
            &baseline_api_index_provider.client,
            middle_shared_version,
            "baseline",
        )
        .await?;
        let middle_baseline_accumulator_root_hash =
            Self::unwrap_accumulator_root_hash(&middle_baseline_transaction)?;

        let evaluation = match Self::get_transaction_by_version(
            &target_api_index_provider.client,
            middle_shared_version,
            "latest",
        )
        .await
        {
            Ok(middle_target_transaction) => {
                match Self::unwrap_accumulator_root_hash(&middle_target_transaction) {
                    Ok(middle_target_accumulator_root_hash) => {
                        if middle_baseline_accumulator_root_hash
                            == middle_target_accumulator_root_hash
                        {
                            Self::build_result(
                                "Target node produced valid recent transaction".to_string(),
                                100,
                                format!(
                                    "We were able to pull the same transaction (version: {}) \
                                    from both your node and the baseline node. Great! This \
                                    implies that your node is returning valid transaction data.",
                                    middle_shared_version,
                                ),
                            )
```

**File:** api/types/src/transaction.rs (L102-115)
```rust
pub struct TransactionOnChainData {
    /// The ledger version of the transaction
    pub version: u64,
    /// The transaction submitted
    pub transaction: aptos_types::transaction::Transaction,
    /// Information about the transaction
    pub info: aptos_types::transaction::TransactionInfo,
    /// Events emitted by the transaction
    pub events: Vec<ContractEvent>,
    /// The accumulator root hash at this version
    pub accumulator_root_hash: aptos_crypto::HashValue,
    /// Final state of resources changed by the transaction
    pub changes: aptos_types::write_set::WriteSet,
}
```

**File:** types/src/transaction/mod.rs (L1869-1928)
```rust
    pub fn ensure_match_transaction_info(
        &self,
        version: Version,
        txn_info: &TransactionInfo,
        expected_write_set: Option<&WriteSet>,
        expected_events: Option<&[ContractEvent]>,
    ) -> Result<()> {
        const ERR_MSG: &str = "TransactionOutput does not match TransactionInfo";

        let expected_txn_status: TransactionStatus = txn_info.status().clone().into();
        ensure!(
            self.status() == &expected_txn_status,
            "{}: version:{}, status:{:?}, auxiliary data:{:?}, expected:{:?}",
            ERR_MSG,
            version,
            self.status(),
            self.auxiliary_data(),
            expected_txn_status,
        );

        ensure!(
            self.gas_used() == txn_info.gas_used(),
            "{}: version:{}, gas_used:{:?}, expected:{:?}",
            ERR_MSG,
            version,
            self.gas_used(),
            txn_info.gas_used(),
        );

        let write_set_hash = CryptoHash::hash(self.write_set());
        ensure!(
            write_set_hash == txn_info.state_change_hash(),
            "{}: version:{}, write_set_hash:{:?}, expected:{:?}, write_set: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            write_set_hash,
            txn_info.state_change_hash(),
            self.write_set,
            expected_write_set,
        );

        let event_hashes = self
            .events()
            .iter()
            .map(CryptoHash::hash)
            .collect::<Vec<_>>();
        let event_root_hash = InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash;
        ensure!(
            event_root_hash == txn_info.event_root_hash(),
            "{}: version:{}, event_root_hash:{:?}, expected:{:?}, events: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            event_root_hash,
            txn_info.event_root_hash(),
            self.events(),
            expected_events,
        );

        Ok(())
    }
```

**File:** types/src/transaction/mod.rs (L2023-2051)
```rust
#[derive(Clone, CryptoHasher, BCSCryptoHash, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct TransactionInfoV0 {
    /// The amount of gas used.
    gas_used: u64,

    /// The vm status. If it is not `Executed`, this will provide the general error class. Execution
    /// failures and Move abort's receive more detailed information. But other errors are generally
    /// categorized with no status code or other information
    status: ExecutionStatus,

    /// The hash of this transaction.
    transaction_hash: HashValue,

    /// The root hash of Merkle Accumulator storing all events emitted during this transaction.
    event_root_hash: HashValue,

    /// The hash value summarizing all changes caused to the world state by this transaction.
    /// i.e. hash of the output write set.
    state_change_hash: HashValue,

    /// The root hash of the Sparse Merkle Tree describing the world state at the end of this
    /// transaction. Depending on the protocol configuration, this can be generated periodical
    /// only, like per block.
    state_checkpoint_hash: Option<HashValue>,

    /// The hash value summarizing PersistedAuxiliaryInfo.
    auxiliary_info_hash: Option<HashValue>,
}
```

**File:** storage/aptosdb/src/ledger_db/transaction_accumulator_db.rs (L26-27)
```rust
pub(crate) type Accumulator =
    MerkleAccumulator<TransactionAccumulatorDb, TransactionAccumulatorHasher>;
```

**File:** api/src/context.rs (L992-1002)
```rust
    pub fn get_transaction_by_version(
        &self,
        version: u64,
        ledger_version: u64,
    ) -> Result<TransactionOnChainData> {
        let txn = self.convert_into_transaction_on_chain_data(
            self.db
                .get_transaction_by_version(version, ledger_version, true)?,
        )?;
        Ok(self.maybe_translate_v2_to_v1_events(txn))
    }
```

**File:** api/src/context.rs (L1070-1082)
```rust
    fn convert_into_transaction_on_chain_data(
        &self,
        txn: TransactionWithProof,
    ) -> Result<TransactionOnChainData> {
        // the type is Vec<(Transaction, TransactionOutput)> - given we have one transaction here, there should only ever be one value in this array
        let (_, txn_output) = &self
            .db
            .get_transaction_outputs(txn.version, 1, txn.version)?
            .consume_output_list_with_proof()
            .transactions_and_outputs[0];
        self.get_accumulator_root_hash(txn.version)
            .map(|h| (txn, h, txn_output).into())
    }
```
