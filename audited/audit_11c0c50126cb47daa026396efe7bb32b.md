# Audit Report

## Title
Transaction Filter Bypass in Indexer gRPC: Non-EntryFunction Payloads Bypass Payload Filters

## Summary
The `UserTransactionFilter::matches()` function in the indexer-grpc transaction filter system contains a logic error that allows user transactions with `ScriptPayload` or other non-entry-function payloads to bypass payload filters. When a client sets a payload filter to only receive specific entry function calls, transactions with ScriptPayload incorrectly pass through the filter and are streamed to the client. [1](#0-0) 

## Finding Description

The vulnerability exists in the filter matching logic. When a `UserTransactionFilter` has a `payload_filter` configured, the code attempts to extract an `EntryFunctionPayload` from the transaction. However, if this extraction returns `None` (which happens for `ScriptPayload`, `WriteSetPayload`, or malformed payloads), the function **incorrectly returns `true`**, allowing the transaction to bypass the filter.

The problematic flow:
1. A client configures a `UserTransactionFilter` with a `payload` filter to only receive transactions calling specific entry functions (e.g., `0x1::coin::transfer`)
2. An attacker submits a valid user transaction with `ScriptPayload` instead of `EntryFunctionPayload`
3. The filter processes the transaction at line 100, entering the conditional block because `payload_filter` is `Some`
4. The extraction at lines 102-105 returns `None` because the payload is a `ScriptPayload` (the helper function only extracts `EntryFunctionPayload` and `MultisigPayload` with `EntryFunctionPayload`) [2](#0-1) 

5. The inner `if let Some(payload)` at line 106 fails, skipping the filter check at lines 108-110
6. The function proceeds to line 114 and returns `true`, bypassing the payload filter entirely

The filter is applied during transaction streaming where each transaction is checked via `filter.matches(txn)`: [3](#0-2) 

This breaks the documented filtering guarantee that "Payload: we only support the entry function payload": [4](#0-3) 

ScriptPayload is a valid user transaction type, confirmed by test data: [5](#0-4) 

## Impact Explanation

This vulnerability affects the indexer-grpc system, which is used by off-chain clients to stream and filter blockchain transaction data. The impact includes:

1. **Filter Protocol Violation**: Clients explicitly setting payload filters to only receive specific entry function calls will incorrectly receive ScriptPayload transactions, violating their filtering expectations
2. **Client-Side Crashes**: If client code assumes all filtered transactions contain `EntryFunctionPayload` structures, receiving a `ScriptPayload` could cause parsing errors or application crashes, qualifying as **"API crashes"** under High Severity criteria
3. **Resource Waste**: The stated goal of filtering is "to be able to save resources downstream" - this bypass defeats that purpose by sending unwanted data to clients
4. **Security Boundary Violation**: If clients use filters as a security boundary (e.g., only processing trusted entry functions), this bypass undermines that assumption

While this does not affect consensus, on-chain state, or validator operations, it qualifies as **High Severity** per Aptos bug bounty criteria:
- **"API crashes"**: Can cause client application crashes due to unexpected payload types
- **"Significant protocol violations"**: The filter protocol is explicitly violated, breaking documented behavior

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurring because:

1. **No Special Privileges Required**: Any user can submit ScriptPayload transactions to the blockchain
2. **Common Use Case**: Indexer clients commonly use payload filters to reduce data volume and processing overhead
3. **Legitimate Feature**: ScriptPayload is a valid transaction type, not requiring any malicious construction
4. **Silent Failure**: The bypass occurs silently - clients receive unexpected data without any error indication
5. **Easy Exploitation**: An attacker simply needs to observe that a client has a payload filter set and submit a ScriptPayload transaction

## Recommendation

The fix is to **explicitly reject transactions when a payload filter is set but the payload type cannot be filtered**. The correct behavior should be: if a client sets a payload filter, only transactions with extractable entry function payloads should pass through.

**Recommended Fix:**

```rust
if let Some(payload_filter) = &self.payload {
    // Get the entry_function_payload from both UserPayload and MultisigPayload
    let entry_function_payload = user_request
        .payload
        .as_ref()
        .and_then(get_entry_function_payload_from_transaction_payload);
    
    // If we have a payload filter but no extractable entry function payload,
    // this transaction should be filtered out
    if let Some(payload) = entry_function_payload {
        // Here we have an actual EntryFunctionPayload - check if it matches
        if !payload_filter.matches(payload) {
            return false;
        }
    } else {
        // Payload filter is set but this transaction doesn't have an 
        // EntryFunctionPayload - filter it out
        return false;
    }
}

true
```

This ensures that when a payload filter is configured, **only** transactions with matching entry function payloads are allowed through, and all other transaction types (ScriptPayload, WriteSetPayload, etc.) are correctly filtered out.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_protos::transaction::v1::{
        transaction::{TxnData, TransactionType},
        transaction_payload::{Payload as TransactionPayloadEnum},
        Transaction, UserTransaction, UserTransactionRequest,
        TransactionPayload, ScriptPayload, MoveScriptBytecode,
    };

    #[test]
    fn test_script_payload_bypasses_entry_function_filter() {
        // Create a UserTransactionFilter with a payload filter
        let filter = UserTransactionFilterBuilder::default()
            .payload(
                UserTransactionPayloadFilterBuilder::default()
                    .function(
                        EntryFunctionFilterBuilder::default()
                            .address("0x1")
                            .module("coin")
                            .function("transfer")
                            .build()
                            .unwrap()
                    )
                    .build()
                    .unwrap()
            )
            .build()
            .unwrap();

        // Create a user transaction with ScriptPayload (not EntryFunctionPayload)
        let script_transaction = Transaction {
            version: 100,
            r#type: TransactionType::User as i32,
            txn_data: Some(TxnData::User(UserTransaction {
                request: Some(UserTransactionRequest {
                    sender: "0x1234".to_string(),
                    payload: Some(TransactionPayload {
                        r#type: 2, // TYPE_SCRIPT_PAYLOAD
                        payload: Some(TransactionPayloadEnum::ScriptPayload(ScriptPayload {
                            code: Some(MoveScriptBytecode {
                                bytecode: vec![0xa1, 0x1c, 0xeb, 0x0b], // dummy bytecode
                                abi: None,
                            }),
                            type_arguments: vec![],
                            arguments: vec![],
                        })),
                    }),
                    ..Default::default()
                }),
                ..Default::default()
            })),
            ..Default::default()
        };

        // BUG: This transaction should be filtered out because it doesn't match
        // the entry function filter, but it incorrectly passes through
        assert_eq!(
            filter.matches(&script_transaction),
            true, // Current behavior: INCORRECTLY returns true
            "ScriptPayload transaction should be filtered out when payload filter is set, but it bypasses the filter"
        );
        
        // Expected behavior: should return false
        // assert_eq!(filter.matches(&script_transaction), false);
    }
}
```

## Notes

This vulnerability is specific to the indexer-grpc filtering system and does not affect:
- Consensus mechanisms or validator operations
- On-chain state or transaction execution
- The core blockchain protocol
- Fund security or asset handling

The impact is limited to off-chain clients using the indexer-grpc system for transaction streaming. However, given that these clients may rely on filters for correctness and security assumptions, and that filter bypass can lead to client crashes, this qualifies as a High Severity issue under the "API crashes" and "Significant protocol violations" categories.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L100-114)
```rust
        if let Some(payload_filter) = &self.payload {
            // Get the entry_function_payload from both UserPayload and MultisigPayload
            let entry_function_payload = user_request
                .payload
                .as_ref()
                .and_then(get_entry_function_payload_from_transaction_payload);
            if let Some(payload) = entry_function_payload {
                // Here we have an actual EntryFunctionPayload
                if !payload_filter.matches(payload) {
                    return false;
                }
            }
        }

        true
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L274-295)
```rust
/// Get the entry_function_payload from both UserPayload and MultisigPayload
fn get_entry_function_payload_from_transaction_payload(
    payload: &TransactionPayload,
) -> Option<&EntryFunctionPayload> {
    if let Some(payload) = &payload.payload {
        match payload {
            transaction_payload::Payload::EntryFunctionPayload(ef_payload) => Some(ef_payload),
            transaction_payload::Payload::MultisigPayload(ms_payload) => ms_payload
                .transaction_payload
                .as_ref()
                .and_then(|tp| tp.payload.as_ref())
                .map(|payload| match payload {
                    multisig_transaction_payload::Payload::EntryFunctionPayload(ef_payload) => {
                        ef_payload
                    },
                }),
            _ => None,
        }
    } else {
        None
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L175-182)
```rust
                let pb_txns = if let Some(ref filter) = filter {
                    pb_txns
                        .into_iter()
                        .filter(|txn| filter.matches(txn))
                        .collect::<Vec<_>>()
                } else {
                    pb_txns
                };
```

**File:** ecosystem/indexer-grpc/transaction-filter/README.md (L18-22)
```markdown
2. User Transactions. Each user transaction has:
    - Sender
    - Payload: we only support the entry function payload
    - Entry function (address, module, name)
    - Entry function ID string
```

**File:** ecosystem/indexer-grpc/indexer-test-transactions/src/json_transactions/scripted_transactions/simple_user_script1.json (L104-126)
```json
      "payload": {
        "type": "TYPE_SCRIPT_PAYLOAD",
        "scriptPayload": {
          "code": {
            "bytecode": "oRzrCwcAAAoEBQAEBwQOCBIgEDIfAQYMAAg8U0VMRj5fMARtYWlu//////////////////////////////////////////8UY29tcGlsYXRpb25fbWV0YWRhdGEJAAMyLjADMi4xAAABAwsAAQI=",
            "abi": {
              "name": "main",
              "visibility": "VISIBILITY_PUBLIC",
              "isEntry": true,
              "params": [
                {
                  "type": "MOVE_TYPES_REFERENCE",
                  "reference": {
                    "to": {
                      "type": "MOVE_TYPES_SIGNER"
                    }
                  }
                }
              ]
            }
          }
        }
      },
```
