# Audit Report

## Title
Supply Chain Attack Vector: Lack of Cryptographic Integrity Verification for Release Configuration and Remote Resources

## Summary
The `aptos-release-builder` embeds a YAML configuration file at compile-time and fetches remote gas schedules via HTTP without any cryptographic signature or hash verification. This creates a supply chain attack vector where compromise of the build infrastructure, source repository, or remote resources could result in malicious blockchain configurations being deployed on-chain through governance proposals.

## Finding Description

The release builder system lacks integrity verification at multiple critical points:

**1. Compile-Time YAML Embedding Without Verification** [1](#0-0) 

The YAML configuration is embedded directly at compile-time using `include_str!` without any signature or hash verification. This configuration controls critical blockchain parameters.

**2. Remote Resource Fetching Without Integrity Checks** [2](#0-1) 

Gas schedules can be fetched from remote URLs via plain HTTP requests without verifying signatures or expected hashes of the downloaded content.

**3. Critical Parameters Controlled by Unverified Configuration** [3](#0-2) 

The release configuration controls multiple security-critical parameters including framework bytecode, gas schedules, feature flags, consensus configuration, execution configuration, and randomness configuration.

**Attack Propagation Path:**

1. **Compromise Point**: Attacker gains access to:
   - Build infrastructure during compilation
   - Source repository containing `release.yaml`
   - Remote servers hosting gas schedule JSON files
   - Network path between builder and remote resources (MitM)

2. **Injection**: Malicious configuration is injected into:
   - The YAML file before `include_str!` macro expansion
   - Remote JSON files fetched during proposal generation

3. **Proposal Generation**: [4](#0-3) 

The compromised configuration generates Move governance proposal scripts that appear legitimate.

4. **Governance Submission**: [5](#0-4) 

Proposals are submitted through the governance system. The malicious configuration is now encoded in Move scripts.

5. **On-Chain Execution**: If proposals pass governance voting, the malicious configurations are executed on-chain, affecting all validators.

**Concrete Exploitation Examples:**

- **Gas Schedule Manipulation**: Setting all gas costs to 0 enables unlimited free computation, violating invariant #9 (Resource Limits)
- **Consensus Config Tampering**: Modifying validator thresholds or timeout parameters breaks invariant #2 (Consensus Safety)
- **Framework Bytecode Injection**: Deploying malicious Move modules violates invariant #1 (Deterministic Execution) and #8 (Access Control)
- **Feature Flag Manipulation**: Enabling/disabling protocol features bypasses security controls, violating multiple invariants

## Impact Explanation

This vulnerability meets **High Severity** criteria, potentially escalating to **Critical** depending on the specific exploitation:

**Critical Impact Scenarios** (if successfully exploited):
- **Loss of Funds**: Malicious framework bytecode could enable unauthorized minting or theft
- **Consensus/Safety Violations**: Modified consensus configuration could break BFT safety guarantees
- **Network Availability**: Malicious gas schedules or execution configs could cause total network DoS
- **Remote Code Execution**: Compromised framework bytecode runs on all validator nodes

**Current Classification: High Severity** because exploitation requires:
- Compromise of trusted infrastructure (build systems, repositories, or network)
- The attack vector is supply chain, not protocol-level
- Additional barriers exist (governance voting, code review)

However, if successfully exploited, the impact would be catastrophic, affecting the entire network.

## Likelihood Explanation

**Likelihood: Medium-Low**

**Factors Reducing Likelihood:**
- Requires compromise of trusted infrastructure (Aptos build systems, GitHub repositories, or DNS/network infrastructure)
- Multiple security layers exist (repository access controls, CI/CD security, code review processes)
- Governance voting provides additional scrutiny
- Binary signatures and release processes add verification layers

**Factors Increasing Likelihood:**
- No cryptographic verification means a successful infrastructure compromise goes undetected
- Attack is silent until malicious config is deployed on-chain
- Remote resource fetching over HTTPS is susceptible to sophisticated adversaries with CA access or nation-state capabilities
- Supply chain attacks are increasingly common and sophisticated

**Realistic Attack Scenarios:**
1. Compromised developer credentials → Modified `release.yaml` in repository
2. Compromised CI/CD pipeline → Tampered files during build
3. DNS hijacking or BGP attacks → Malicious gas schedule served from fake endpoints
4. Compromised `aptos-networks` repository → Poisoned gas schedule files

## Recommendation

Implement multi-layered cryptographic integrity verification:

**1. Sign and Verify YAML Configuration:**
```rust
// In lib.rs
const RELEASE_CONFIG: &str = include_str!("../data/release.yaml");
const RELEASE_CONFIG_SIGNATURE: &str = include_str!("../data/release.yaml.sig");
const TRUSTED_PUBLIC_KEY: &str = "..."; // Aptos release signing key

static CURRENT_RELEASE_CONFIG: Lazy<ReleaseConfig> = Lazy::new(|| {
    // Verify signature before parsing
    verify_ed25519_signature(
        RELEASE_CONFIG.as_bytes(),
        RELEASE_CONFIG_SIGNATURE,
        TRUSTED_PUBLIC_KEY
    ).expect("Release config signature verification failed");
    
    ReleaseConfig::parse(RELEASE_CONFIG).expect("YAML NOT PARSABLE")
});
```

**2. Verify Remote Resources:**
```rust
// In components/mod.rs
impl GasScheduleLocator {
    async fn fetch_gas_schedule(&self) -> Result<GasScheduleV2> {
        match self {
            GasScheduleLocator::RemoteFile(url) => {
                let response = reqwest::get(url.as_str()).await?;
                let gas_schedule: GasScheduleV2 = response.json().await?;
                
                // Verify against expected hash
                let computed_hash = sha256(&bcs::to_bytes(&gas_schedule)?);
                let expected_hash = self.get_expected_hash()?; // From signed config
                ensure!(computed_hash == expected_hash, "Gas schedule hash mismatch");
                
                Ok(gas_schedule)
            },
            // ... other cases
        }
    }
}
```

**3. Add Hash Verification to YAML Schema:**
```yaml
proposals:
  - name: proposal_1_upgrade_framework
    update_sequence:
      - Gas:
          new: https://raw.githubusercontent.com/.../gas.json
          expected_sha256: "abc123..." # Verify downloaded content
```

**4. Additional Mitigations:**
- Sign all release binaries with Aptos release key
- Implement Sigstore/in-toto for build provenance
- Use content-addressed storage (IPFS/IPLD) for immutable resources
- Add runtime verification in governance proposal execution
- Implement continuous monitoring for configuration drift

## Proof of Concept

```rust
// PoC: Demonstrate lack of verification allows tampered config
#[tokio::test]
async fn test_tampered_release_config_undetected() {
    use aptos_release_builder::ReleaseConfig;
    use std::fs;
    use std::path::PathBuf;
    
    // Step 1: Create malicious YAML with zero gas costs
    let malicious_yaml = r#"
name: "malicious_release"
remote_endpoint: ~
proposals:
  - name: malicious_gas
    metadata:
      title: "Malicious Gas Schedule"
      description: "Sets all gas to 0"
    execution_mode: MultiStep
    update_sequence:
      - Gas:
          new: current
          # This would be modified to set all costs to 0
    "#;
    
    // Step 2: Parse malicious config - NO SIGNATURE CHECK
    let config = ReleaseConfig::parse(malicious_yaml)
        .expect("Malicious config parsed without verification");
    
    // Step 3: Generate proposals from malicious config
    let temp_dir = PathBuf::from("/tmp/malicious_proposals");
    fs::create_dir_all(&temp_dir).unwrap();
    
    config.generate_release_proposal_scripts(&temp_dir)
        .await
        .expect("Generated proposals from unverified config");
    
    // Step 4: Verify malicious proposals were generated
    assert!(temp_dir.join("sources").exists());
    println!("✗ VULNERABILITY: Malicious config processed without signature verification");
    println!("✗ Proposals generated that could set gas costs to 0");
    println!("✗ If submitted and approved, would enable unlimited free computation");
}

// PoC: Demonstrate remote resource fetching without verification
#[tokio::test]
async fn test_remote_gas_schedule_no_verification() {
    use aptos_release_builder::components::GasScheduleLocator;
    use url::Url;
    
    // Step 1: Remote URL with no hash verification
    let remote_url = Url::parse("https://example.com/malicious_gas.json")
        .unwrap();
    let locator = GasScheduleLocator::RemoteFile(remote_url);
    
    // Step 2: Fetch would occur without any integrity check
    // (will fail in test due to fake URL, but demonstrates lack of verification)
    match locator.fetch_gas_schedule().await {
        Ok(_) => {
            println!("✗ VULNERABILITY: Remote gas schedule fetched without hash verification");
            println!("✗ No signature or expected hash checked");
            panic!("Should have verified content integrity");
        },
        Err(e) => {
            // Expected to fail due to fake URL, but shows no verification code path
            println!("✓ Fetch failed (expected), but demonstrates no verification exists");
            println!("  Error: {:?}", e);
        }
    }
}
```

**Exploitation Steps for Real Attack:**

1. **Gain Infrastructure Access**: Compromise Aptos build server, GitHub repository, or DNS
2. **Modify Configuration**: Edit `release.yaml` or poison remote gas schedule files
3. **Build Binary**: Malicious config gets embedded in `aptos-release-builder` binary
4. **Generate Proposals**: Run `GenerateProposals` command to create Move scripts
5. **Submit to Governance**: Use `ValidateProposals` or manual submission
6. **Wait for Approval**: Malicious proposals go through governance voting
7. **Execute On-Chain**: Once approved, malicious configuration deploys network-wide

**Notes**

This vulnerability represents a **supply chain security gap** rather than a protocol-level vulnerability. While the absence of cryptographic verification is a significant security concern, exploitation requires compromise of trusted infrastructure (build systems, repositories, or network paths), which places it outside the typical threat model for protocol vulnerabilities.

The issue aligns more with **security hardening recommendations** than critical exploitable bugs, as it assumes adversarial control over components within the trust boundary (Aptos core developers and infrastructure). However, defense-in-depth principles suggest that cryptographic verification should be added regardless, as it provides protection against:
- Insider threats
- Compromised infrastructure
- Supply chain attacks
- Nation-state adversaries with CA or BGP access

Given the **critical nature of the configurations controlled** (consensus, gas, framework bytecode), implementing signature verification is a high-priority security enhancement, even if current infrastructure security is strong.

### Citations

**File:** aptos-move/aptos-release-builder/src/lib.rs (L17-17)
```rust
const RELEASE_CONFIG: &str = include_str!("../data/release.yaml");
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L132-147)
```rust
pub enum ReleaseEntry {
    Framework(FrameworkReleaseConfig),
    Gas {
        old: Option<GasScheduleLocator>,
        new: GasScheduleLocator,
    },
    Version(AptosVersion),
    FeatureFlag(Features),
    Consensus(OnChainConsensusConfig),
    Execution(OnChainExecutionConfig),
    RawScript(PathBuf),
    /// Deprecated by `OnChainJwkConsensusConfig`.
    OidcProviderOps(Vec<OidcProviderOp>),
    JwkConsensus(OnChainJWKConsensusConfig),
    Randomness(ReleaseFriendlyRandomnessConfig),
}
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L196-214)
```rust
impl GasScheduleLocator {
    async fn fetch_gas_schedule(&self) -> Result<GasScheduleV2> {
        println!("{:?}", self);
        match self {
            GasScheduleLocator::LocalFile(path) => {
                let file_contents = fs::read_to_string(path)?;
                let gas_schedule: GasScheduleV2 = serde_json::from_str(&file_contents)?;
                Ok(gas_schedule)
            },
            GasScheduleLocator::RemoteFile(url) => {
                let response = reqwest::get(url.as_str()).await?;
                let gas_schedule: GasScheduleV2 = response.json().await?;
                Ok(gas_schedule)
            },
            GasScheduleLocator::Current => Ok(aptos_gas_schedule_updator::current_gas_schedule(
                LATEST_GAS_FEATURE_VERSION,
            )),
        }
    }
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L581-716)
```rust
    pub async fn generate_release_proposal_scripts(&self, base_path: &Path) -> Result<()> {
        let client = self
            .remote_endpoint
            .as_ref()
            .map(|url| Client::new(url.clone()));

        // Create directories for source and metadata.
        let mut source_dir = base_path.to_path_buf();

        // If source dir doesnt exist create it, if it does exist error
        if !source_dir.exists() {
            println!("Creating source directory: {:?}", source_dir);
            std::fs::create_dir(source_dir.as_path()).map_err(|err| {
                anyhow!(
                    "Fail to create folder for source: {} {:?}",
                    source_dir.display(),
                    err
                )
            })?;
        }

        source_dir.push("sources");

        std::fs::create_dir(source_dir.as_path()).map_err(|err| {
            anyhow!(
                "Fail to create folder for source {}: {:?}",
                source_dir.display(),
                err
            )
        })?;

        source_dir.push(&self.name);
        std::fs::create_dir(source_dir.as_path()).map_err(|err| {
            anyhow!(
                "Fail to create folder for source {}: {:?}",
                source_dir.display(),
                err
            )
        })?;

        let mut metadata_dir = base_path.to_path_buf();
        metadata_dir.push("metadata");

        std::fs::create_dir(metadata_dir.as_path()).map_err(|err| {
            anyhow!(
                "Fail to create folder for metadata {}: {:?}",
                metadata_dir.display(),
                err
            )
        })?;
        metadata_dir.push(&self.name);
        std::fs::create_dir(metadata_dir.as_path()).map_err(|err| {
            anyhow!(
                "Fail to create folder for metadata {}: {:?}",
                metadata_dir.display(),
                err
            )
        })?;

        // If we are generating multi-step proposal files, we generate the files in reverse order,
        // since we need to pass in the hash of the next file to the previous file.
        for proposal in &self.proposals {
            let mut proposal_dir = base_path.to_path_buf();
            proposal_dir.push("sources");
            proposal_dir.push(&self.name);
            proposal_dir.push(proposal.name.as_str());

            std::fs::create_dir(proposal_dir.as_path()).map_err(|err| {
                anyhow!(
                    "Fail to create folder for proposal {}: {:?}",
                    proposal_dir.display(),
                    err
                )
            })?;

            let mut result: Vec<(String, String)> = vec![];
            if let ExecutionMode::MultiStep = &proposal.execution_mode {
                for entry in proposal.update_sequence.iter().rev() {
                    entry
                        .generate_release_script(
                            client.as_ref(),
                            &mut result,
                            proposal.execution_mode,
                        )
                        .await?;
                }
                result.reverse();
            } else {
                for entry in proposal.update_sequence.iter() {
                    entry
                        .generate_release_script(
                            client.as_ref(),
                            &mut result,
                            proposal.execution_mode,
                        )
                        .await?;
                }
            }

            for (idx, (script_name, script)) in result.into_iter().enumerate() {
                let mut script_path = proposal_dir.clone();
                let proposal_name = format!("{}-{}", idx, script_name);
                script_path.push(&proposal_name);
                script_path.set_extension("move");

                std::fs::write(script_path.as_path(), append_script_hash(script).as_bytes())
                    .map_err(|err| {
                        anyhow!(
                            "Failed to write to file {}: {:?}",
                            script_path.display(),
                            err
                        )
                    })?;
            }

            let mut metadata_path = base_path.to_path_buf();
            metadata_path.push("metadata");
            metadata_path.push(&self.name);
            metadata_path.push(proposal.name.as_str());
            metadata_path.set_extension("json");

            std::fs::write(
                metadata_path.as_path(),
                serde_json::to_string_pretty(&proposal.metadata)?,
            )
            .map_err(|err| {
                anyhow!(
                    "Failed to write to file {}: {:?}",
                    metadata_path.display(),
                    err
                )
            })?;
        }

        Ok(())
    }
```

**File:** aptos-move/aptos-release-builder/src/validate.rs (L183-245)
```rust
    pub async fn create_governance_proposal(
        &self,
        script_path: &Path,
        metadata: &ProposalMetadata,
        is_multi_step: bool,
        node_api_key: Option<String>,
    ) -> Result<u64> {
        println!("Creating proposal: {:?}", script_path);

        let address_string = format!("{}", self.validator_account);
        let privkey_string = self.get_hex_encoded_validator_key();

        let metadata_path = TempPath::new();
        metadata_path.create_as_file()?;
        fs::write(
            metadata_path.path(),
            serde_json::to_string_pretty(metadata)?,
        )?;

        let mut args = vec![
            "",
            "--pool-address",
            address_string.as_str(),
            "--script-path",
            script_path.to_str().unwrap(),
            "--metadata-path",
            metadata_path.path().to_str().unwrap(),
            "--metadata-url",
            "https://raw.githubusercontent.com/aptos-labs/aptos-core/b4fb9acfc297327c43d030def2b59037c4376611/testsuite/smoke-test/src/upgrade_multi_step_test_metadata.txt",
            "--sender-account",
            address_string.as_str(),
            "--private-key",
            privkey_string.as_str(),
            "--url",
            self.endpoint.as_str(),
            "--assume-yes",
        ];

        if let Some(api_key) = node_api_key.as_ref() {
            args.push("--node-api-key");
            args.push(api_key.as_str());
        }

        if is_multi_step {
            args.push("--is-multi-step");
        }

        let rev_string = self.framework_git_rev.clone();
        let framework_path = aptos_framework_path();
        let proposal_summary = if let Some(rev) = &rev_string {
            args.push("--framework-git-rev");
            args.push(rev.as_str());
            SubmitProposal::try_parse_from(args)?.execute().await?
        } else {
            args.push("--framework-local-dir");
            args.push(framework_path.as_os_str().to_str().unwrap());
            SubmitProposal::try_parse_from(args)?.execute().await?
        };

        Ok(proposal_summary
            .proposal_id
            .expect("Failed to extract proposal id"))
    }
```
