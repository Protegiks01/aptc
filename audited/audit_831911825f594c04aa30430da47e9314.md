# Audit Report

## Title
Memory Exhaustion via Oversized BitVec in CertifiedAugData Deserialization

## Summary
The randomness generation protocol's message verification process deserializes `CertifiedAugData` messages without enforcing size limits before memory allocation. An attacker can craft malicious `CertifiedAugData` objects containing `AggregateSignature` fields with extremely large `BitVec` objects (up to ~60 MiB each) that pass network layer checks but trigger excessive memory allocation during BCS deserialization, before validation rejects them. With up to 32 concurrent deserialization tasks, this enables a memory exhaustion attack causing validator node slowdowns or crashes.

## Finding Description

The vulnerability exists in the message verification pipeline for the randomness generation protocol. When a validator node receives a `RandGenMessage` containing `CertifiedAugData`, the following sequence occurs:

1. **Network Reception**: The message is received through the network layer, subject to the 64 MiB `MAX_MESSAGE_SIZE` limit. [1](#0-0) 

2. **Unbounded BCS Deserialization**: In the verification task, the message data is deserialized using `bcs::from_bytes` **without any size limit**: [2](#0-1) 

3. **BitVec Memory Allocation**: The `CertifiedAugData` contains an `AggregateSignature`, which contains a `BitVec` with an inner `Vec<u8>`: [3](#0-2) 

4. **Late Validation**: The `BitVec` custom deserializer allocates the `Vec<u8>` **first**, then checks if the length exceeds `MAX_BUCKETS` (8192 bytes) **afterward**: [4](#0-3) 

**Attack Path:**
- Attacker crafts a `CertifiedAugData` with an `AggregateSignature` containing a `BitVec` with 60 MiB of data (within the 64 MiB network limit)
- The message passes network layer validation
- During deserialization, the `BitVec`'s inner `Vec<u8>` allocates 60 MiB
- Only then does the validation check fail and reject the message
- The memory is freed, but the allocation cost has already been paid

**Amplification:**
The verification task uses a `BoundedExecutor` with capacity 32: [5](#0-4) 

This allows up to 32 concurrent deserialization tasks, enabling an attacker to cause temporary allocation of 32 × 60 MiB = ~1.9 GB of memory by sending multiple malicious messages simultaneously.

The verification happens **after** deserialization: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty criteria:

- **Validator node slowdowns**: ✓ Memory allocation/deallocation pressure causes CPU contention and reduces node performance
- **API crashes**: ✓ Potential for out-of-memory crashes if system memory is constrained
- **Significant protocol violations**: ✓ The randomness generation protocol can be disrupted, affecting consensus participation

While this doesn't cause direct loss of funds or permanent consensus safety violations, it enables denial-of-service attacks against validator nodes specifically targeting the randomness generation subsystem, which is critical for protocol operation.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Any network peer can send messages to consensus nodes; no special privileges required
- **Technical Complexity**: Low - attacker only needs to craft a BCS-encoded message with an oversized `BitVec`
- **Detection Difficulty**: The attack generates errors in logs but may be difficult to distinguish from legitimate malformed messages
- **Cost to Attacker**: Minimal - network bandwidth to send ~64 MiB messages
- **Repeatability**: High - attacker can continuously send malicious messages

## Recommendation

Implement size-limited deserialization using `bcs::from_bytes_with_limit` instead of unbounded `bcs::from_bytes`:

```rust
// In consensus/src/rand/rand_gen/rand_manager.rs, line 236:
// Replace:
match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {

// With:
const MAX_RAND_MESSAGE_SIZE: usize = 1_000_000; // 1 MB limit
match bcs::from_bytes_with_limit::<RandMessage<S, D>>(
    rand_gen_msg.req.data(),
    MAX_RAND_MESSAGE_SIZE
) {
```

Additionally, consider adding early validation in the `BitVec` deserializer to check the claimed length **before** allocation:

```rust
// In crates/aptos-bitvec/src/lib.rs, modify the deserializer:
impl<'de> Deserialize<'de> for BitVec {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let v = <Vec<u8>>::deserialize(deserializer)?;
        if v.len() > MAX_BUCKETS {
            return Err(D::Error::custom(format!("BitVec too long: {}", v.len())));
        }
        Ok(BitVec { inner: v })
    }
}
```

However, the proper fix requires serde to support length-prefixed validation, which is not trivial. The `bcs::from_bytes_with_limit` approach is the most practical solution.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_bitvec::BitVec;
    use aptos_types::aggregate_signature::AggregateSignature;
    use bcs;

    #[test]
    fn test_oversized_bitvec_memory_exhaustion() {
        // Create a BitVec with 60 MiB of data (exceeds MAX_BUCKETS of 8192)
        let oversized_vec = vec![0u8; 60 * 1024 * 1024];
        
        // Serialize it - this will succeed
        let serialized = bcs::to_bytes(&oversized_vec).unwrap();
        println!("Serialized size: {} bytes", serialized.len());
        
        // Attempt to deserialize as BitVec - this allocates memory first
        let start = std::time::Instant::now();
        let result = bcs::from_bytes::<BitVec>(&serialized);
        let duration = start.elapsed();
        
        // Deserialization should fail due to MAX_BUCKETS check
        assert!(result.is_err());
        println!("Deserialization failed after {:?}", duration);
        println!("Error: {:?}", result.unwrap_err());
        
        // BUT: Memory was allocated during deserialization before the check failed
        // Attacker can trigger this allocation repeatedly with concurrent messages
    }
    
    #[test]
    fn test_malicious_certified_aug_data() {
        // Create malicious AggregateSignature with oversized BitVec
        let oversized_vec = vec![0u8; 60 * 1024 * 1024];
        let malicious_bitvec = BitVec::from(oversized_vec);
        let malicious_sig = AggregateSignature::new(malicious_bitvec, None);
        
        // Serialize the AggregateSignature
        let serialized = bcs::to_bytes(&malicious_sig).unwrap();
        println!("Malicious signature size: {} bytes", serialized.len());
        
        // This would be wrapped in CertifiedAugData and sent over network
        // Each deserialization attempt allocates 60 MiB before rejecting
        // With 32 concurrent tasks: 32 * 60 MiB = 1.9 GB temporary allocation
    }
}
```

## Notes

The root cause is the combination of:
1. Unbounded BCS deserialization in the network message handler
2. BitVec's late validation (after allocation)
3. Concurrent task processing allowing amplification

While the network layer enforces a 64 MiB message size limit, this still allows oversized allocations relative to the expected `MAX_BUCKETS` limit of 8192 bytes for `BitVec` objects. The validation logic assumes deserialization won't allocate excessive memory before the check, which is incorrect for BCS's streaming deserialization model.

### Citations

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L236-236)
```rust
                    match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L238-245)
```rust
                            if msg
                                .verify(
                                    &epoch_state_clone,
                                    &config_clone,
                                    &fast_config_clone,
                                    rand_gen_msg.sender,
                                )
                                .is_ok()
```

**File:** consensus/src/rand/rand_gen/types.rs (L530-533)
```rust
pub struct CertifiedAugData<D> {
    aug_data: AugData<D>,
    signatures: AggregateSignature,
}
```

**File:** crates/aptos-bitvec/src/lib.rs (L246-250)
```rust
        let v = RawData::deserialize(deserializer)?.inner;
        if v.len() > MAX_BUCKETS {
            return Err(D::Error::custom(format!("BitVec too long: {}", v.len())));
        }
        Ok(BitVec { inner: v })
```

**File:** consensus/src/consensus_provider.rs (L168-169)
```rust
        let bounded_executor =
            BoundedExecutor::new(32, consensus_observer_runtime.handle().clone());
```
