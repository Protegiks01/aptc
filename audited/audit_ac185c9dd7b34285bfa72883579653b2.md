# Audit Report

## Title
Bytecode Corruption via Integer Overflow in Script Composer StLoc Generation

## Summary
The `TransactionComposer` in `aptos-move/script-composer/src/builder.rs` contains an inconsistent bounds check that allows the total number of parameters and locals to exceed 255, leading to integer overflow when generating `StLoc` bytecode instructions. This creates corrupted bytecode that stores return values to wrong local indices, potentially overwriting parameter values including signer references.

## Finding Description

The vulnerability exists due to an inconsistency between two bounds checks in the script composer: [1](#0-0) 

This check uses `parameters.len()` which excludes signer parameters (only contains raw parameters added via `CallArgument::Raw`).

However, the actual bytecode generation uses `parameters_ty.len()` which includes ALL parameters including signers: [2](#0-1) 

When generating `StLoc` instructions for return values, the code performs an unchecked cast: [3](#0-2) 

This cast operation is in Rust, where `as u8` performs truncating conversion. When `*arg + parameters_count >= 256`, the value wraps (e.g., 256 becomes 0, 257 becomes 1).

**Attack Path:**

1. Create `TransactionComposer` with `multi_signer(32)`:
   - `parameters_ty` contains 32 `&signer` entries
   - `parameters` is empty (0 entries)

2. Add function calls that return values until `locals_ty.len() = 225`:
   - Total locals: 32 + 225 = 257
   - Bounds check: `0 + 225 > 255` evaluates to FALSE (passes!)

3. During code generation, when storing the last return value (at local index 224):
   - Calculation: `(224 + 32) as u8 = 256 as u8 = 0`
   - Generates `StLoc(0)` instead of `StLoc(256)`
   - This stores the return value to parameter 0 instead of local 256

4. The bytecode verifier checks type compatibility of the operation. If the return type happens to be assignable to parameter 0's type, the script passes verification with corrupted semantics.

The `to_instruction()` function has a proper bounds check that would catch this: [4](#0-3) 

However, this check is bypassed because `StLoc` for return values is generated directly at line 401, not through `to_instruction()`.

## Impact Explanation

This vulnerability breaks the **Deterministic Execution** and **Move VM Safety** invariants:

- **Bytecode Corruption**: Return values are stored to incorrect local indices due to integer overflow
- **Parameter Overwriting**: Signer references and other parameters can be overwritten with return values
- **State Inconsistencies**: The corrupted script may execute with semantically incorrect behavior
- **Type System Bypass**: If return types happen to match parameter types, verification passes despite corruption

**Severity: Medium** - This qualifies as a state inconsistency requiring intervention per the Aptos bug bounty program. While not directly causing fund loss, it corrupts bytecode generation and can lead to unpredictable execution behavior, including potential signer reference manipulation.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is exploitable when:
- Using `multi_signer()` with 2+ signers (up to 32 maximum)
- Adding function calls with sufficient return values to exceed 256 total locals
- The check at line 331 incorrectly validates against `parameters.len()` instead of `parameters_ty.len()`

The maximum practical scenario:
- 32 signers + 224 locals = 256 total (edge case)
- 32 signers + 225+ locals = 257+ total (overflow occurs)

This is realistic for complex multi-agent transactions with many function calls and return values.

## Recommendation

Fix the inconsistent bounds check to use `parameters_ty.len()` instead of `parameters.len()`:

```rust
if self.parameters_ty.len() + self.locals_ty.len() > u8::MAX as usize {
    bail!("Too many locals being allocated, please truncate the transaction");
}
```

Additionally, add an explicit bounds check before the `StLoc` generation to provide defense in depth:

```rust
// Storing return values
for arg in call.returns.iter().rev() {
    let local_idx = arg + parameters_count;
    if local_idx >= u8::MAX as u16 {
        bail!("Local index {} exceeds u8::MAX", local_idx);
    }
    script
        .code
        .code
        .push(Bytecode::StLoc(local_idx as u8));
}
```

## Proof of Concept

```rust
#[test]
fn test_bytecode_corruption_via_overflow() {
    use aptos_move::script_composer::builder::TransactionComposer;
    
    // Create composer with 32 signers (maximum allowed)
    let mut composer = TransactionComposer::multi_signer(32);
    
    // Store a test module that has a function returning &signer
    let module_bytes = compile_test_module_with_signer_return();
    composer.store_module(module_bytes).unwrap();
    
    // Add multiple calls returning values to grow locals_ty
    for i in 0..225 {
        let result = composer.add_batched_call(
            "0x1::test_module".to_string(),
            "get_signer".to_string(),
            vec![],
            vec![CallArgument::Signer(0)], // Use first signer
        );
        // This should succeed even though we're exceeding 256 total locals
        assert!(result.is_ok(), "Call {} failed", i);
    }
    
    // Attempt to generate the script
    // This will create StLoc with wrapped indices
    let script_result = composer.generate_batched_calls(false);
    
    // The vulnerability allows this to succeed when it should fail
    // or generates corrupted StLoc instructions with wrapped indices
    match script_result {
        Ok(bytes) => {
            // Deserialize and inspect bytecode to see StLoc(0) instead of StLoc(256)
            println!("Generated corrupted bytecode with wrapped StLoc indices");
        },
        Err(e) => {
            // May fail during verification if types don't match
            println!("Failed during verification: {}", e);
        }
    }
}
```

**Note**: The actual exploitation depends on having functions that return types matching the parameter types at the wrapped indices. The core vulnerability is the inconsistent bounds checking allowing total locals to exceed 255, combined with the unchecked cast at line 401.

### Citations

**File:** aptos-move/script-composer/src/builder.rs (L331-333)
```rust
        if self.parameters.len() + self.locals_ty.len() > u8::MAX as usize {
            bail!("Too many locals being allocated, please truncate the transaction");
        }
```

**File:** aptos-move/script-composer/src/builder.rs (L364-364)
```rust
        let parameters_count = self.parameters_ty.len() as u16;
```

**File:** aptos-move/script-composer/src/builder.rs (L397-402)
```rust
            for arg in call.returns.iter().rev() {
                script
                    .code
                    .code
                    .push(Bytecode::StLoc((*arg + parameters_count) as u8));
            }
```

**File:** aptos-move/script-composer/src/builder.rs (L500-502)
```rust
        if local_idx >= u8::MAX as u16 {
            bail!("Too many locals");
        };
```
