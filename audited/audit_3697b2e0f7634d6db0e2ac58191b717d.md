# Audit Report

## Title
Admin Service Port Binding Information Disclosure When Disabled

## Summary
The AdminService in `crates/aptos-admin-service/src/server/mod.rs` binds to its configured network port even when `enabled=false`, allowing attackers to detect validator node locations through port scanning and HTTP fingerprinting.

## Finding Description
The AdminService implementation has a design flaw where the HTTP server binds to the configured port regardless of the `enabled` configuration flag. 

When a validator operator sets `enabled=false` in their configuration (which is the default for mainnet nodes [1](#0-0) ), they expect the admin service to be completely disabled with no network exposure. However, the `start()` function unconditionally binds to the port [2](#0-1) .

The `enabled` flag is only checked within the request handler [3](#0-2) , where it returns an HTTP 404 response with the message "AdminService is not enabled."

**Attack Path:**
1. Attacker scans port 9102 (default admin service port) across IP ranges
2. Open ports responding to HTTP requests reveal Aptos nodes
3. Specific 404 response "AdminService is not enabled" fingerprints the node as an Aptos validator
4. Attacker maps validator node locations for reconnaissance

This violates the security expectation that disabled services should not expose any network surface. The configuration value is read at initialization [4](#0-3)  and passed to `start()` [5](#0-4) , but the server binding occurs before any request-level checks.

## Impact Explanation
This is a **Low Severity** information disclosure vulnerability per Aptos Bug Bounty criteria. It enables:

- **Validator Network Mapping**: Attackers can enumerate validator node IP addresses through systematic port scanning
- **Node Fingerprinting**: The specific error message identifies nodes as Aptos validators
- **Reconnaissance Aid**: Provides attackers with network topology information for planning targeted attacks

However, it does NOT:
- Directly compromise funds or consensus
- Cause validator slowdowns or crashes  
- Enable protocol violations or state manipulation
- Provide access to sensitive data beyond network presence

The impact is limited to passive information gathering that aids attacker reconnaissance but does not directly exploit the system.

## Likelihood Explanation
This vulnerability has **high likelihood** of occurrence because:

1. **Default Behavior**: Mainnet validators are configured with `enabled=false` by default [1](#0-0) 
2. **Always Present**: Every node running AdminService exhibits this behavior
3. **Easy Detection**: Simple port scans and HTTP requests reveal the issue
4. **Operator Expectations**: Operators expect disabled services to have no network footprint

The vulnerability is trivially exploitable by any attacker with network access, requiring no authentication, specialized knowledge, or resource constraints.

## Recommendation
The service should only bind to the network port when `enabled=true`. Modify the `new()` function to conditionally start the server:

```rust
pub fn new(node_config: &NodeConfig) -> Self {
    let config = node_config.admin_service.clone();
    let enabled = config.enabled.unwrap_or(false);
    
    let admin_service = Self {
        runtime: aptos_runtimes::spawn_named_runtime("admin".into(), None),
        context: Arc::new(Context {
            config: config.clone(),
            ..Default::default()
        }),
    };
    
    // Only start the server if enabled
    if enabled {
        let service_port = config.port;
        let service_address = config.address.clone();
        let address: SocketAddr = (service_address.as_str(), service_port)
            .to_socket_addrs()
            .unwrap_or_else(|_| {
                panic!("Failed to parse {}:{} as address", service_address, service_port)
            })
            .next()
            .unwrap();
        
        admin_service.start(address, enabled);
    }
    
    admin_service
}
```

Alternatively, remove the `enabled` parameter from `start()` since it should only be called when the service is actually enabled.

## Proof of Concept

**Step 1: Port Scanning Detection**
```bash
# Scan for open admin service ports
nmap -p 9102 --open <validator-ip-range>

# Expected: Port 9102 open even with enabled=false
```

**Step 2: HTTP Fingerprinting**
```bash
# Send HTTP request to detected port
curl -v http://<validator-ip>:9102/

# Response when enabled=false:
# HTTP/1.1 404 Not Found
# Content: "AdminService is not enabled."

# This response confirms:
# 1. Port is open and accepting connections
# 2. Aptos AdminService is running
# 3. Node is an Aptos validator
```

**Step 3: Validator Enumeration**
```python
import requests
import ipaddress

# Scan subnet for Aptos validators
for ip in ipaddress.IPv4Network('10.0.0.0/24'):
    try:
        response = requests.get(f'http://{ip}:9102/', timeout=2)
        if 'AdminService' in response.text:
            print(f'Found Aptos validator at {ip}')
    except:
        pass
```

This demonstrates that even with `enabled=false`, the admin service port remains discoverable through network scanning, revealing validator node locations.

## Notes

While this vulnerability is classified as Low severity due to its limited impact (information disclosure only), it represents a violation of the principle of least exposure. Validator operators who explicitly disable the admin service expect zero network footprint for that component. The current implementation creates an unnecessary attack surface that aids reconnaissance efforts.

The vulnerability is particularly relevant for production mainnet validators where security-conscious operators may disable the admin service but unknowingly leave a fingerprinting vector open [6](#0-5) .

### Citations

**File:** config/src/config/admin_service_config.rs (L67-78)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }
```

**File:** config/src/config/admin_service_config.rs (L93-100)
```rust
        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L93-93)
```rust
        let enabled = config.enabled.unwrap_or(false);
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L101-101)
```rust
        admin_service.start(address, enabled);
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L136-136)
```rust
            let server = Server::bind(&address).serve(make_service);
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L147-152)
```rust
        if !enabled {
            return Ok(reply_with_status(
                StatusCode::NOT_FOUND,
                "AdminService is not enabled.",
            ));
        }
```
