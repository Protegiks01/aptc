# Audit Report

## Title
Transaction Backup Restore Allows Chain Fork via Unverified LedgerInfo from Minority Forks

## Summary
The transaction backup restoration system fails to verify that restored transactions belong to the canonical chain when epoch history verification is bypassed. Attackers can create backups from minority fork chains and restore them onto victim validators, causing those validators to diverge from the main network and participate in consensus with incorrect state roots, violating consensus safety guarantees.

## Finding Description

The `TransactionBackup` restore mechanism has multiple critical verification gaps:

**1. Optional Epoch History Verification**

The restoration process optionally verifies ledger infos against epoch history: [1](#0-0) 

When `epoch_history` is `None`, this verification is completely skipped.

**2. Two Attack Vectors for Bypassing Verification**

**Vector A: One-off Transaction Restore** [2](#0-1) 

The one-off transaction restore command always passes `None` for epoch history, disabling all chain validity checks.

**Vector B: Coordinator Restore with --skip-epoch-endings Flag** [3](#0-2) 

The `--skip-epoch-endings` flag causes epoch history to be set to `None`.

**3. Documentation Acknowledges the Issue** [4](#0-3) 

The code explicitly documents that LedgerInfos are NOT checked during one-shot transaction/state restores.

**4. Inadequate Transaction Verification** [5](#0-4) 

The verification only checks that transactions match the ledger info's accumulator root, not that the ledger info itself is from the canonical chain: [6](#0-5) 

**5. Weak Epoch Boundary Protection**

Even when epoch history is provided, epochs beyond the history are not verified: [7](#0-6) 

The function logs a warning but returns `Ok(())`, allowing unverified data.

**6. Skippable Waypoint Verification at Startup** [8](#0-7) 

If the restored database version doesn't exactly match `waypoint.version() - 1`, the waypoint check is skipped entirely.

**Attack Scenario:**

1. Attacker operates a validator that ends up on a minority fork (network partition, Byzantine behavior, or intentional)
2. The forked chain has valid BLS signatures from minority validators and different transaction history
3. Attacker creates a backup from the forked chain using standard backup tools
4. Victim operator restores using: `aptos-db-tool restore oneoff transaction` OR `aptos-db-tool restore bootstrap-db --skip-epoch-endings`
5. The restore process:
   - Skips epoch history verification (epoch_history = None)
   - Only verifies transactions match the ledger info (which they do, for the fork)
   - Never checks if the ledger info is from the canonical chain
   - Saves forked transactions into the database
6. When the node starts:
   - Waypoint check sees DB version ≠ waypoint.version() - 1
   - Skips waypoint verification
   - Node proceeds with forked state
7. Validator participates in consensus with incorrect state roots, disagrees with honest validators on block validity

**Broken Invariants:**
- **Deterministic Execution**: Validators no longer produce identical state roots for identical blocks
- **Consensus Safety**: Chain split occurs without requiring ≥1/3 Byzantine validators

## Impact Explanation

**Critical Severity** per Aptos Bug Bounty criteria:

1. **Consensus/Safety Violations**: The attack directly violates consensus safety by causing validators to fork from the canonical chain without requiring 1/3+ Byzantine validators. This is explicitly listed as a Critical impact.

2. **Non-recoverable Network Partition**: If multiple validators restore from the malicious backup, the network could partition into canonical and forked chains, potentially requiring a hardfork to resolve.

3. **State Divergence**: Affected validators have completely different state roots and transaction history, making them unable to participate meaningfully in consensus.

The vulnerability bypasses the fundamental security assumption that all validators agree on chain history and state, which is the core guarantee of Byzantine Fault Tolerant consensus.

## Likelihood Explanation

**High Likelihood:**

1. **Common Operations**: Both one-off transaction restore and `--skip-epoch-endings` are legitimate operational commands used for disaster recovery and database synchronization.

2. **Subtle Attack**: The backup appears valid - it has proper version ranges, valid BLS signatures (from minority validators), and correct cryptographic proofs. Standard validation passes.

3. **Operational Pressure**: During incidents, operators may use `--skip-epoch-endings` to speed up restoration, unknowingly accepting unverified data.

4. **No Warning**: The system doesn't clearly warn operators that bypassing epoch history verification accepts potentially forked chains. The only warning is a log message for epochs beyond history, not for missing history entirely.

5. **Realistic Attack Vector**: Network partitions naturally create minority forks with valid signatures. An attacker doesn't need to forge anything, just capture a backup during a partition event.

## Recommendation

**Immediate Fixes:**

1. **Make Epoch History Verification Mandatory**: Remove the ability to skip epoch history verification during transaction restore. Epoch ending backups must be restored first to establish trust chain.

2. **Fail on Missing Epoch History**: Change the conditional check to fail if epoch_history is None:

```rust
// In storage/backup/backup-cli/src/backup_types/transaction/restore.rs
let epoch_history = epoch_history.ok_or_else(|| 
    anyhow!("Epoch history is required for transaction restore. \
             Please restore epoch ending backups first to establish chain validity.")
)?;
epoch_history.verify_ledger_info(&ledger_info)?;
```

3. **Enforce Waypoint Verification**: Remove the early return in `maybe_bootstrap` and require explicit waypoint verification for any restored database, or at minimum log an ERROR instead of INFO.

4. **Remove --skip-epoch-endings Flag**: This flag should be removed entirely or restricted to development/testing environments only.

5. **Strict Epoch Boundary Enforcement**: Change the warning in `EpochHistory::verify_ledger_info` to an error:

```rust
if epoch > self.epoch_endings.len() as u64 {
    bail!(
        "Epoch {} cannot be verified. Epoch history only covers up to epoch {}. \
         Refusing to restore unverified data.",
        epoch,
        self.epoch_endings.len()
    );
}
```

6. **Update Documentation**: Add prominent warnings that transaction restores without epoch history accept ANY chain, including forks.

## Proof of Concept

**Step 1: Create Minority Fork Backup**

```bash
# On a validator that's on a minority fork (simulated via network partition)
aptos-db-tool backup transaction \
  --start-version 1000 \
  --num-transactions 1000 \
  --storage local \
  --dir /tmp/malicious_backup
```

**Step 2: Restore on Victim Validator**

```bash
# Victim operator performs one-off transaction restore
aptos-db-tool restore oneoff transaction \
  --transaction-manifest /tmp/malicious_backup/transaction.manifest \
  --target-db-dir /opt/aptos/data \
  --concurrent-downloads 4
```

**Step 3: Start Validator Node**

```bash
# Node starts with forked state, waypoint check skipped
aptos-node --config /opt/aptos/config/validator.yaml
# Node logs: "Skip genesis txn." (waypoint check bypassed)
# Validator participates in consensus with wrong state root
```

**Expected Result**: The restored validator has transaction history from the fork, different state roots than canonical chain validators, and attempts to participate in consensus, causing disagreement on block validity and potential liveness issues.

**Verification**: Compare state root hash at the same version between the restored validator and a canonical chain validator - they will differ, confirming the fork.

## Notes

This vulnerability is particularly dangerous because:
1. The backup itself appears valid with proper signatures and proofs
2. Operators may use these commands during legitimate disaster recovery
3. No clear warnings indicate the security implications of bypassing epoch history
4. The attack requires no cryptographic breaks, just a minority fork with valid signatures
5. Multiple validators could be affected if they all restore from the same compromised backup source

The fix requires making epoch history verification mandatory and removing options to bypass it, which may impact operational flexibility but is necessary for consensus safety.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L167-167)
```rust
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/db-tool/src/restore.rs (L102-107)
```rust
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L341-343)
```rust
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
```

**File:** types/src/transaction/mod.rs (L2335-2336)
```rust
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L279-287)
```rust
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L56-58)
```rust
    if ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version() {
        info!(waypoint = %waypoint, "Skip genesis txn.");
        return Ok(None);
```
