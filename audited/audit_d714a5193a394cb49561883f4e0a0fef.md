# Audit Report

## Title
Validator Fullnode Configuration Corruption via Unvalidated Network Address Submission

## Summary
The `update_network_and_fullnode_addresses()` function in the stake module lacks on-chain validation of network address structure, allowing validator operators to submit partial or malformed fullnode addresses that render the validator's fullnode unreachable, causing persistent state inconsistencies in the network discovery system. [1](#0-0) 

## Finding Description
The vulnerability exists in a validation gap between the CLI tool and the on-chain Move code:

**CLI-Level Protection (Bypassed):** The CLI enforces that fullnode host and public key must both be provided or both be omitted: [2](#0-1) 

**On-Chain Validation (Missing):** However, the on-chain `update_network_and_fullnode_addresses()` function accepts raw BCS-encoded bytes without validating their semantic correctness. It only checks operator authentication but does not validate that network addresses contain required components (NoiseIK public keys): [3](#0-2) 

**Exploitation Path:**
1. A validator operator bypasses the CLI and crafts a raw transaction directly
2. They encode a `NetworkAddress` containing only IP/TCP layers without the NoiseIK public key protocol layer (e.g., `/ip4/1.2.3.4/tcp/6180` instead of the required `/ip4/1.2.3.4/tcp/6180/noise-ik/<pubkey>/handshake/0`)
3. BCS encodes this incomplete address and submits it via `update_network_and_fullnode_addresses()`
4. The transaction succeeds and stores the malformed addresses on-chain
5. When the validator discovery system attempts to use these addresses, it extracts public keys via `find_noise_proto()`, which returns None for addresses lacking NoiseIK: [4](#0-3) 

6. This creates a Peer object with an empty keys HashSet
7. The connectivity manager marks such peers as ineligible because `is_eligible()` requires non-empty keys: [5](#0-4) 

8. The peer is filtered out during dial selection: [6](#0-5) 

**Result:** The validator's fullnode becomes permanently unreachable via the validator fullnode network until corrected configuration is submitted.

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Specific Impacts:**
- **Configuration Corruption:** ValidatorConfig resource on-chain contains unusable fullnode addresses
- **Network Degradation:** Other validators cannot connect to the affected validator's fullnode, reducing network redundancy
- **Persistent State:** The corruption persists across epochs until manually corrected
- **Discovery Failure:** Silent failure in validator discovery system (logged but not prevented)

The vulnerability breaks the **State Consistency** invariant: validator configuration should maintain valid, usable network addresses. While it doesn't affect consensus directly (fullnode addresses are not used for consensus), it degrades overall network health. [7](#0-6) 

## Likelihood Explanation
**Moderate Likelihood:**
- Requires validator operator key access (high barrier)
- However, realistic scenarios include:
  - Compromised operator keys
  - Malicious operator attempting network degradation
  - Operational mistakes when manually constructing transactions
  - Automated tooling bugs that bypass CLI validation

The lack of defense-in-depth (only CLI validation, no on-chain validation) increases risk when the outer layer is bypassed.

## Recommendation
Add on-chain validation to ensure network addresses contain required protocol components:

**Option 1: Validate address structure in Move**
Add native function to validate NetworkAddress structure before storing:

```move
public entry fun update_network_and_fullnode_addresses(
    operator: &signer,
    pool_address: address,
    new_network_addresses: vector<u8>,
    new_fullnode_addresses: vector<u8>,
) acquires StakePool, ValidatorConfig {
    // ... existing checks ...
    
    // NEW: Validate network addresses contain required components
    assert!(
        validate_network_addresses(new_network_addresses), 
        error::invalid_argument(EINVALID_NETWORK_ADDRESSES)
    );
    assert!(
        validate_fullnode_addresses(new_fullnode_addresses),
        error::invalid_argument(EINVALID_FULLNODE_ADDRESSES)
    );
    
    // ... rest of function ...
}
```

**Option 2: Require non-empty addresses**
At minimum, check that addresses are not malformed:

```move
// Ensure addresses can be BCS-deserialized to prevent obviously corrupt data
assert!(
    vector::length(&new_network_addresses) > 0,
    error::invalid_argument(EINVALID_NETWORK_ADDRESSES)
);
```

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[test]
fn test_partial_fullnode_address_corruption() {
    use aptos_types::network_address::{NetworkAddress, Protocol};
    use std::str::FromStr;
    
    // Step 1: Create incomplete fullnode address (missing NoiseIK)
    let incomplete_addr = NetworkAddress::from_str("/ip4/127.0.0.1/tcp/6180").unwrap();
    let incomplete_addrs = vec![incomplete_addr];
    let encoded_incomplete = bcs::to_bytes(&incomplete_addrs).unwrap();
    
    // Step 2: Submit via update_network_and_fullnode_addresses
    // (bypassing CLI which would reject this)
    let result = framework.execute_function(
        &operator_account,
        "stake",
        "update_network_and_fullnode_addresses",
        vec![],
        vec![
            bcs::to_bytes(&pool_address).unwrap(),
            bcs::to_bytes(&valid_validator_addrs).unwrap(),
            encoded_incomplete, // Invalid fullnode addresses
        ],
    );
    
    // Step 3: Transaction succeeds (vulnerability)
    assert!(result.is_ok());
    
    // Step 4: Verify addresses stored on-chain
    let validator_config = framework.read_resource::<ValidatorConfig>(pool_address);
    assert_eq!(validator_config.fullnode_addresses, encoded_incomplete);
    
    // Step 5: Attempt to extract addresses in discovery
    let addrs = validator_config.fullnode_network_addresses().unwrap();
    
    // Step 6: Extract keys from addresses
    let keys: HashSet<_> = addrs.iter()
        .filter_map(NetworkAddress::find_noise_proto)
        .collect();
    
    // Step 7: Verify peer becomes ineligible (keys empty)
    assert!(keys.is_empty()); // VULNERABILITY: No keys extracted
    
    let peer = Peer::from_addrs(PeerRole::ValidatorFullNode, addrs);
    assert!(peer.keys.is_empty()); // Peer has no keys
    
    let discovered_peer = DiscoveredPeer::new(PeerRole::ValidatorFullNode);
    assert!(!discovered_peer.is_eligible()); // Peer ineligible to dial
}
```

## Notes
While this vulnerability requires operator key access (limiting the attack surface to compromised operators or operational errors), it represents a genuine validation gap that violates defense-in-depth principles. The CLI validation alone is insufficient protection when operators can submit raw transactions. The on-chain Move code should enforce the same invariants to ensure validator configuration integrity regardless of how transactions are constructed.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-995)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** crates/aptos/src/node/mod.rs (L1128-1137)
```rust
            match (full_node_host.as_ref(), full_node_network_public_key) {
                (Some(host), Some(public_key)) => vec![host.as_network_address(public_key)?],
                (None, None) => vec![],
                _ => {
                    return Err(CliError::CommandArgumentError(
                        "If specifying fullnode addresses, both host and public key are required."
                            .to_string(),
                    ))
                },
            };
```

**File:** config/src/config/network_config.rs (L498-504)
```rust
    pub fn from_addrs(role: PeerRole, addresses: Vec<NetworkAddress>) -> Peer {
        let keys: HashSet<x25519::PublicKey> = addresses
            .iter()
            .filter_map(NetworkAddress::find_noise_proto)
            .collect();
        Peer::new(addresses, keys, role)
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L254-262)
```rust
    /// Peers without keys are not able to be mutually authenticated to
    pub fn is_eligible(&self) -> bool {
        !self.keys.is_empty()
    }

    /// Peers without addresses can't be dialed to
    pub fn is_eligible_to_be_dialed(&self) -> bool {
        self.is_eligible() && !self.addrs.is_empty()
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L578-586)
```rust
        let eligible_peers: Vec<_> = discovered_peers
            .into_iter()
            .filter(|(peer_id, peer)| {
                peer.is_eligible_to_be_dialed() // The node is eligible to dial
                    && !self.connected.contains_key(peer_id) // The node is not already connected
                    && !self.dial_queue.contains_key(peer_id) // There is no pending dial to this node
                    && roles_to_dial.contains(&peer.role) // We can dial this role
            })
            .collect();
```

**File:** network/discovery/src/validator_set.rs (L121-140)
```rust
            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();
```
