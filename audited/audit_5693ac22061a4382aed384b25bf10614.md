# Audit Report

## Title
Consensus Liveness Failure via Malicious Governance Proposal Setting Zero Reputation Weights

## Summary
The `choose_index()` function in the proposer election mechanism contains two panic points that can be triggered by malicious on-chain governance proposals. By setting all reputation weights to zero, an attacker with governance control can cause all validators to panic with a division-by-zero error during leader election, resulting in complete network liveness failure.

## Finding Description

The vulnerability exists in the `choose_index()` function which is called during every round of consensus to elect the next proposer. [1](#0-0) 

This function computes cumulative weights and uses randomness to select an index. However, it contains an unchecked division operation that panics when `total_weight` is zero. [2](#0-1) 

The `next_in_range()` function performs modulo operation with `max` as the divisor. When `max` (which equals `total_weight`) is zero, this triggers a division-by-zero panic.

The weights used in `choose_index()` are derived from reputation weights multiplied by voting power: [3](#0-2) 

The reputation weights come from on-chain configuration: [4](#0-3) 

These weights are defined in `ProposerAndVoterConfig`: [5](#0-4) 

The critical flaw is that there is **no validation** of these weight values. The Move code only checks that configuration bytes are non-empty: [6](#0-5) 

**Attack Path:**
1. Attacker gains control of on-chain governance (requires majority stake voting power)
2. Creates governance proposal to update consensus configuration setting:
   - `active_weight = 0`
   - `inactive_weight = 0`
   - `failed_weight = 0`
3. Proposal passes and is applied at next epoch via `consensus_config::set_for_next_epoch()`
4. At epoch boundary, all validators load new configuration
5. During first round of new epoch, all validators call `get_valid_proposer()` → `choose_index()`
6. All stake_weights become zero (0 × voting_power = 0)
7. `total_weight` remains 0 after the accumulation loop
8. `next_in_range(state, 0)` executes `u128::from_le_bytes(temp) % 0`
9. **Division by zero panic occurs on ALL validators simultaneously**
10. Network loses all liveness - no validator can elect a proposer
11. Blockchain halts indefinitely until manual intervention/hardfork

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program, specifically:
- **Total loss of liveness/network availability**: All validators panic simultaneously, preventing any new blocks from being proposed or committed
- **Non-recoverable network partition (requires hardfork)**: The network cannot self-recover because the malicious configuration persists on-chain; requires emergency governance action or hardfork to restore functionality

The impact affects:
- **All validators**: Every honest validator node crashes when attempting leader election
- **All transactions**: No new transactions can be processed during the outage
- **DeFi protocols**: All on-chain applications become unavailable
- **Network security**: Extended downtime creates opportunity for coordinated attacks

## Likelihood Explanation

**Likelihood: Medium-High**

**Requirements for exploitation:**
- Control of on-chain governance (typically requires >50% of voting power for proposal approval)
- Knowledge of the vulnerability
- Ability to craft malicious configuration bytes

**Factors increasing likelihood:**
1. No input validation on reputation weights - any u64 value is accepted
2. Governance control is achievable through:
   - Legitimate stake accumulation
   - Stake pool vulnerabilities
   - Validator collusion
   - Governance mechanism bugs
3. Attack is simple - just set three u64 values to 0
4. Attack is deterministic - guaranteed to succeed once configuration is applied

**Factors decreasing likelihood:**
- Requires significant stake to control governance
- Malicious proposal may raise suspicion during voting period
- Governance participants are typically aligned with network health

However, the barrier is lower than a 51% attack because it only requires governance control, not consensus control. Byzantine actors with governance stake are within the threat model.

## Recommendation

Implement validation of `ProposerAndVoterConfig` values to prevent zero or excessively large weights:

**Option 1: Validate in Move code**
Add validation in `consensus_config.move`:

```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // Add validation here before storing
    validate_consensus_config(&config);
    
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}

fun validate_consensus_config(config_bytes: &vector<u8>) {
    // Deserialize and validate that weights are non-zero and within reasonable bounds
    // This would require a native function or Move-side deserialization
}
```

**Option 2: Validate in Rust deserialization**
Add validation in `types/src/on_chain_config/consensus_config.rs`:

```rust
impl ProposerAndVoterConfig {
    pub fn validate(&self) -> Result<()> {
        ensure!(self.active_weight > 0, "active_weight must be non-zero");
        ensure!(self.inactive_weight > 0, "inactive_weight must be non-zero");
        ensure!(self.failed_weight > 0, "failed_weight must be non-zero");
        
        // Optional: add upper bounds to prevent overflow attacks
        const MAX_SAFE_WEIGHT: u64 = u64::MAX / 1000000; // Conservative bound
        ensure!(self.active_weight <= MAX_SAFE_WEIGHT, "active_weight too large");
        ensure!(self.inactive_weight <= MAX_SAFE_WEIGHT, "inactive_weight too large");
        ensure!(self.failed_weight <= MAX_SAFE_WEIGHT, "failed_weight too large");
        
        Ok(())
    }
}
```

**Option 3: Add defensive check in choose_index()**
Add immediate validation at entry:

```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    assert!(!weights.is_empty(), "weights vector cannot be empty");
    
    let mut total_weight = 0;
    for w in &mut weights {
        assert!(*w > 0, "individual weight cannot be zero");
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    
    assert!(total_weight > 0, "total_weight cannot be zero");
    // ... rest of function
}
```

**Recommended approach:** Implement Options 2 AND 3 for defense-in-depth:
- Option 2 prevents malicious configurations from being stored
- Option 3 provides runtime protection against edge cases

## Proof of Concept

```rust
// File: consensus/src/liveness/proposer_election_test.rs
#[test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
fn test_choose_index_zero_weights_causes_panic() {
    // Simulate scenario where all reputation weights are set to 0
    // and voting powers are non-zero
    let voting_powers = vec![1000000_u64, 2000000_u64, 3000000_u64];
    
    // All reputation weights are 0 (malicious governance config)
    let reputation_weights = vec![0_u64, 0_u64, 0_u64];
    
    // Calculate stake_weights (reputation × voting_power)
    let stake_weights: Vec<u128> = reputation_weights
        .iter()
        .zip(voting_powers.iter())
        .map(|(r, v)| (*r as u128) * (*v as u128))
        .collect();
    
    // All stake_weights will be 0
    assert_eq!(stake_weights, vec![0_u128, 0_u128, 0_u128]);
    
    // Arbitrary state for randomness
    let state = vec![1, 2, 3, 4];
    
    // This will panic with division by zero when next_in_range(state, 0) is called
    let _ = choose_index(stake_weights, state);
}
```

**To test the full attack:**

1. Create governance proposal with malicious configuration:
```rust
// Construct ProposerAndVoterConfig with zero weights
let malicious_config = ProposerAndVoterConfig {
    active_weight: 0,
    inactive_weight: 0,
    failed_weight: 0,
    failure_threshold_percent: 10,
    proposer_window_num_validators_multiplier: 10,
    voter_window_num_validators_multiplier: 100,
    weight_by_voting_power: true,
    use_history_from_previous_epoch_max_count: 5,
};

let consensus_config = OnChainConsensusConfig::V4(
    ConsensusAlgorithmConfig::JolteonV2 {
        main: ConsensusConfigV1 {
            leader_reputation_type: LeaderReputationType::ProposerAndVoterV2(malicious_config),
            // ... other fields
        },
        quorum_store_enabled: true,
        order_vote_enabled: true,
    }
);

let config_bytes = bcs::to_bytes(&consensus_config).unwrap();
```

2. Submit through governance and observe validator panic at next epoch

## Notes

A secondary attack vector exists using integer overflow instead of division by zero. By setting reputation weights to `u64::MAX`, an attacker can cause the checked addition on line 55-56 to overflow when total stake exceeds 2^64 units (≈184 billion APT). However, the zero-weight attack is simpler and has no preconditions on total stake, making it the primary concern.

Both attack vectors share the same root cause: lack of input validation on governance-controlled consensus parameters that directly affect consensus-critical code paths.

### Citations

**File:** consensus/src/liveness/proposer_election.rs (L38-46)
```rust
// next consumes seed and returns random deterministic u64 value in [0, max) range
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    // hash = SHA-3-256(state)
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    // return hash[0..16]
    u128::from_le_bytes(temp) % max
}
```

**File:** consensus/src/liveness/proposer_election.rs (L49-69)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
    weights
        .binary_search_by(|w| {
            if *w <= chosen_weight {
                Ordering::Less
            } else {
                Ordering::Greater
            }
        })
        .expect_err("Comparison never returns equals, so it's always guaranteed to be error")
}
```

**File:** consensus/src/liveness/leader_reputation.rs (L711-715)
```rust
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();
```

**File:** consensus/src/epoch_manager.rs (L318-328)
```rust
                        let heuristic: Box<dyn ReputationHeuristic> =
                            Box::new(ProposerAndVoterHeuristic::new(
                                self.author,
                                proposer_and_voter_config.active_weight,
                                proposer_and_voter_config.inactive_weight,
                                proposer_and_voter_config.failed_weight,
                                proposer_and_voter_config.failure_threshold_percent,
                                voter_window_size,
                                proposer_window_size,
                                leader_reputation_type.use_reputation_window_from_stale_end(),
                            ));
```

**File:** types/src/on_chain_config/consensus_config.rs (L552-575)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ProposerAndVoterConfig {
    // Selection weight for active validators with proposer failures below threshold
    pub active_weight: u64,
    // Selection weight for inactive validators with proposer failures below threshold
    pub inactive_weight: u64,
    // Selection weight for validators with proposer failures above threshold
    pub failed_weight: u64,
    // Thresholed of failures in the rounds validator was selected to be proposer
    // integer values representing percentages, i.e. 12 is 12%.
    pub failure_threshold_percent: u32,
    // Window into history considered for proposer statistics, multiplier
    // on top of number of validators
    pub proposer_window_num_validators_multiplier: usize,
    // Window into history considered for votre statistics, multiplier
    // on top of number of validators
    pub voter_window_num_validators_multiplier: usize,
    // Flag whether to use voting power as multiplier to the weights
    pub weight_by_voting_power: bool,
    // Flag whether to use history from previous epoch (0 if not),
    // representing a number of historical epochs (beyond the current one)
    // to consider.
    pub use_history_from_previous_epoch_max_count: u32,
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```
