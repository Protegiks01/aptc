# Audit Report

## Title
Epoch Validation Bypass in Backup Verification Allows Byzantine State Acceptance

## Summary
The backup verification coordinator's `skip_epoch_endings` flag completely bypasses cryptographic signature verification of state snapshots, allowing acceptance of unverified or malicious state snapshots that were never part of the legitimate blockchain.

## Finding Description

In the backup verification workflow, when the `--skip-epoch-endings` flag is set, the system skips all epoch history validation, which includes critical cryptographic signature verification of the `LedgerInfoWithSignatures` in state snapshot proofs. [1](#0-0) 

When `skip_epoch_endings` is true, `epoch_history` is set to `None` and passed to the `StateSnapshotRestoreController`: [2](#0-1) 

In the state snapshot restore process, epoch validation only occurs if `epoch_history` is present: [3](#0-2) 

When this validation is skipped, the `TransactionInfoWithProof.verify()` method only validates that the transaction info exists in the transaction accumulator of the provided `LedgerInfo`, but **never validates the signatures on the LedgerInfo itself**: [4](#0-3) 

The `verify_transaction_info` helper only checks the accumulator proof, not the LedgerInfo signatures: [5](#0-4) 

The proper signature verification would occur in `EpochHistory::verify_ledger_info()`, which verifies signatures against the validator set from the previous epoch or against trusted waypoints: [6](#0-5) 

**Attack Scenario:**
1. Attacker creates a malicious `LedgerInfoWithSignatures` with an arbitrary `transaction_accumulator_hash`
2. Attacker crafts a valid `TransactionInfoWithProof` that proves a transaction exists in that malicious accumulator
3. Attacker creates a state snapshot with this proof
4. Victim runs backup verification with `--skip-epoch-endings` flag
5. System accepts the malicious state snapshot without signature verification

The `backup.epoch` value logged at line 125-126 is never validated against the actual blockchain epoch history: [7](#0-6) 

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty criteria because it enables:

1. **Byzantine State Acceptance**: Nodes can be tricked into accepting state snapshots that were never part of the legitimate blockchain, violating the fundamental BFT consensus guarantees
2. **Consensus Safety Violation**: Different nodes could restore from different malicious state snapshots, leading to state divergence
3. **Cryptographic Security Bypass**: The entire purpose of `LedgerInfoWithSignatures` is to ensure state snapshots are authenticated by the validator set, but this is completely bypassed

While the `--skip-epoch-endings` flag is documented as "for debugging", it's accessible to any user and there are no warnings about the security implications. The same vulnerability exists in the `RestoreCoordinator`: [8](#0-7) 

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is easily exploitable because:
- The `--skip-epoch-endings` flag is a documented command-line option
- No special privileges are required to run the backup verification tool
- Users may legitimately use this flag for performance optimization without understanding the security implications
- The help text describes it as "used for debugging" without security warnings [9](#0-8) 

## Recommendation

**Option 1 (Recommended): Remove the flag entirely**
The `--skip-epoch-endings` flag provides no legitimate security use case and should be removed from production code. Epoch validation is a critical security control.

**Option 2: Require trusted waypoints when skipping epoch endings**
If the flag must be kept for debugging, enforce that trusted waypoints must be provided and validated even when `skip_epoch_endings` is true:

```rust
async fn run_impl(self) -> Result<()> {
    // ... existing code ...
    
    let epoch_history = if self.skip_epoch_endings {
        // Even when skipping, ensure we have trusted waypoints for validation
        ensure!(
            !self.trusted_waypoints_opt.trust_waypoint.is_empty(),
            "When skipping epoch endings validation, trusted waypoints must be provided for security"
        );
        None
    } else {
        Some(Arc::new(
            EpochHistoryRestoreController::new(
                epoch_endings.into_iter().map(|backup| backup.manifest).collect(),
                global_opt.clone(),
                self.storage.clone(),
            )
            .run()
            .await?,
        ))
    };
    
    if let Some(backup) = state_snapshot {
        // Always validate against trusted waypoints if present, even without epoch_history
        if epoch_history.is_none() && !global_opt.trusted_waypoints.is_empty() {
            let manifest: StateSnapshotBackup = self.storage.load_json_file(&backup.manifest).await?;
            let (_, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) = 
                self.storage.load_bcs_file(&manifest.proof).await?;
            
            if let Some(trusted_wp) = global_opt.trusted_waypoints.get(&li.ledger_info().version()) {
                let wp_li = Waypoint::new_any(li.ledger_info());
                ensure!(
                    *trusted_wp == wp_li,
                    "State snapshot LedgerInfo does not match trusted waypoint"
                );
            } else {
                bail!("No trusted waypoint found for version {}", li.ledger_info().version());
            }
        }
        
        StateSnapshotRestoreController::new(/* ... */).run().await?;
    }
    // ...
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_skip_epoch_endings_bypasses_signature_validation() {
    use aptos_crypto::HashValue;
    use aptos_types::{
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        transaction::TransactionInfo,
    };
    
    // Create a malicious LedgerInfo with arbitrary accumulator hash (no signatures)
    let malicious_accumulator_hash = HashValue::random();
    let malicious_ledger_info = LedgerInfo::new(
        /* block_info */ Default::default(),
        malicious_accumulator_hash,
    );
    let unsigned_li = LedgerInfoWithSignatures::new(
        malicious_ledger_info,
        BTreeMap::new(), // No signatures!
    );
    
    // Create a valid TransactionInfoWithProof against the malicious accumulator
    // This would normally fail signature verification, but with skip_epoch_endings=true
    // it will be accepted
    
    // When running VerifyCoordinator with --skip-epoch-endings:
    // 1. epoch_history will be None
    // 2. StateSnapshotRestoreController won't call verify_ledger_info()
    // 3. Only TransactionAccumulatorProof is checked, not signatures
    // 4. Malicious state snapshot is accepted
    
    // Expected: Should FAIL without proper signature verification
    // Actual: PASSES when skip_epoch_endings=true
}
```

To demonstrate in practice:
1. Create a backup with a crafted `LedgerInfoWithSignatures` (unsigned or invalid signatures)
2. Run: `aptos-db-tool backup verify --skip-epoch-endings --storage <backup-location>`
3. Observe that the malicious backup is accepted without signature verification

### Citations

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L106-121)
```rust
        let epoch_history = if self.skip_epoch_endings {
            None
        } else {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_endings
                        .into_iter()
                        .map(|backup| backup.manifest)
                        .collect(),
                    global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        };
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L123-128)
```rust
        if let Some(backup) = state_snapshot {
            info!(
                epoch = backup.epoch,
                version = backup.version,
                "State snapshot selected for verification."
            );
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L129-141)
```rust
            StateSnapshotRestoreController::new(
                StateSnapshotRestoreOpt {
                    manifest_handle: backup.manifest,
                    version: backup.version,
                    validate_modules: self.validate_modules,
                    restore_mode: StateSnapshotRestoreMode::Default,
                },
                global_opt.clone(),
                Arc::clone(&self.storage),
                epoch_history.clone(),
            )
            .run()
            .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** types/src/proof/definition.rs (L864-874)
```rust
    /// Verifies that the `TransactionInfo` exists in the ledger represented by the `LedgerInfo`
    /// at specified version.
    pub fn verify(&self, ledger_info: &LedgerInfo, transaction_version: Version) -> Result<()> {
        verify_transaction_info(
            ledger_info,
            transaction_version,
            &self.transaction_info,
            &self.ledger_info_to_transaction_info_proof,
        )?;
        Ok(())
    }
```

**File:** types/src/proof/mod.rs (L40-61)
```rust
fn verify_transaction_info(
    ledger_info: &LedgerInfo,
    transaction_version: Version,
    transaction_info: &TransactionInfo,
    ledger_info_to_transaction_info_proof: &TransactionAccumulatorProof,
) -> Result<()> {
    ensure!(
        transaction_version <= ledger_info.version(),
        "Transaction version {} is newer than LedgerInfo version {}.",
        transaction_version,
        ledger_info.version(),
    );

    let transaction_info_hash = transaction_info.hash();
    ledger_info_to_transaction_info_proof.verify(
        ledger_info.transaction_accumulator_hash(),
        transaction_info_hash,
        transaction_version,
    )?;

    Ok(())
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L42-43)
```rust
    #[clap(long, help = "Skip restoring epoch ending info, used for debugging.")]
    pub skip_epoch_endings: bool,
```

**File:** storage/db-tool/src/backup.rs (L153-154)
```rust
    #[clap(long, help = "Skip verifying epoch ending info.")]
    skip_epoch_endings: bool,
```
