# Audit Report

## Title
REST Discovery Empty ValidatorSet Network Partition Vulnerability

## Summary
The REST discovery mechanism in `network/discovery/src/rest.rs` accepts and processes empty ValidatorSets without validation, which when combined with `extract_validator_set_updates`, produces an empty PeerSet that clears all discovered peers from the REST source. For nodes configured with REST-only discovery, this causes a network partition where the node cannot discover any peers.

## Finding Description

The vulnerability exists in the REST-based peer discovery flow where an empty ValidatorSet can propagate through the system without validation:

1. **RestStream fetches ValidatorSet without validation**: [1](#0-0) 

The `poll_next()` function retrieves the ValidatorSet from the REST endpoint and directly passes it to `extract_validator_set_updates` without checking if it's empty.

2. **Empty ValidatorSet produces empty PeerSet**: [2](#0-1) 

The `extract_validator_set_updates` function iterates over the ValidatorSet (which includes `active_validators` and `pending_inactive`). If both are empty, the iterator is empty and `collect()` produces an empty PeerSet.

3. **ValidatorSet can be constructed empty**: [3](#0-2) 

The ValidatorSet struct has an explicit `empty()` method, meaning empty ValidatorSets are valid from a serialization/deserialization perspective.

4. **Empty PeerSets clear all peers from source**: [4](#0-3) 

The `handle_update_discovered_peers` function processes empty PeerSets by clearing addresses and keys from that discovery source. If the peer has no remaining state from other sources, it's removed entirely.

5. **REST-only configuration is supported**: [5](#0-4) 

Public Full Nodes (PFNs) can be configured with REST as their only discovery method, making them vulnerable to this issue.

**Attack Vector:**
- An attacker compromises or controls the REST endpoint that a node uses for discovery
- The attacker makes the REST API serve an empty ValidatorSet (bypassing on-chain protections through database corruption, API bugs, or malicious endpoint)
- Nodes using this endpoint receive the empty ValidatorSet
- The empty PeerSet clears all discovered peers
- Nodes with REST-only discovery lose all peers, causing network partition

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violation**: Causes network partition for affected nodes, violating the network availability invariant
2. **Validator Node Slowdowns**: Affected nodes cannot discover peers, leading to connectivity issues and potential slowdowns
3. **Liveness Impact**: Nodes lose ability to participate in consensus or sync state due to peer loss

While the on-chain ValidatorSet is protected by the `ELAST_VALIDATOR` check [6](#0-5) , the vulnerability exploits the fact that the REST endpoint could serve corrupted or malicious data that bypasses this protection.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires specific conditions:

1. **Node Configuration**: Target node must use REST discovery as primary/only source (demonstrated as valid configuration in tests)
2. **Compromised REST Endpoint**: Requires one of:
   - Database corruption on REST server serving empty ValidatorSet
   - Compromised/malicious REST endpoint
   - Bug in REST API implementation
   - Misconfiguration pointing to test/development endpoint

While these conditions limit exploitability, the lack of validation makes the system vulnerable to external data integrity issues.

## Recommendation

Add validation in the REST discovery flow to detect and reject empty ValidatorSets:

```rust
// In network/discovery/src/rest.rs, modify poll_next():
fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
    futures::ready!(self.interval.as_mut().poll_next(cx));

    let response = block_on(self.rest_client.get_account_resource_bcs::<ValidatorSet>(
        AccountAddress::ONE,
        "0x1::stake::ValidatorSet",
    ));
    Poll::Ready(match response {
        Ok(inner) => {
            let validator_set = inner.into_inner();
            
            // VALIDATION: Reject empty ValidatorSet
            if validator_set.active_validators.is_empty() && 
               validator_set.pending_inactive.is_empty() {
                warn!(
                    "REST Discovery received empty ValidatorSet from {}. This should never happen in production.",
                    self.rest_client.path_prefix_string()
                );
                return Poll::Ready(Some(Err(DiscoveryError::Rest(
                    anyhow::anyhow!("Received empty ValidatorSet from REST endpoint").into()
                ))));
            }
            
            Some(Ok(extract_validator_set_updates(
                self.network_context,
                validator_set,
            )))
        },
        Err(err) => {
            info!(
                "Failed to retrieve validator set by REST discovery {:?}",
                err
            );
            Some(Err(DiscoveryError::Rest(err)))
        },
    })
}
```

Additional recommendations:
1. Add monitoring/alerting when empty PeerSets are received from any discovery source
2. Require multiple discovery sources for production deployments
3. Add minimum peer threshold before clearing all peers from a source

## Proof of Concept

```rust
#[tokio::test]
async fn test_empty_validator_set_network_partition() {
    use aptos_types::on_chain_config::ValidatorSet;
    use network_discovery::rest::RestStream;
    
    // Setup: Create a mock REST endpoint that returns empty ValidatorSet
    let empty_validator_set = ValidatorSet::empty();
    let empty_validator_set_bytes = bcs::to_bytes(&empty_validator_set).unwrap();
    
    // Mock REST server returns empty ValidatorSet
    let mock_server = MockRestServer::new()
        .with_response("/accounts/0x1/resource/0x1::stake::ValidatorSet", 
                      empty_validator_set_bytes);
    
    // Create RestStream pointing to mock server
    let network_context = NetworkContext::mock();
    let mut rest_stream = RestStream::new(
        network_context,
        mock_server.url(),
        Duration::from_secs(1),
        TimeService::mock(),
    );
    
    // Poll the stream - should return empty PeerSet
    let result = rest_stream.next().await.unwrap();
    assert!(result.is_ok());
    let peer_set = result.unwrap();
    
    // Verify PeerSet is empty - this causes network partition
    assert!(peer_set.is_empty(), 
        "Empty ValidatorSet produced non-empty PeerSet - vulnerability not present");
    
    println!("VULNERABILITY CONFIRMED: Empty ValidatorSet → Empty PeerSet → Network Partition");
}
```

## Notes

The vulnerability is exacerbated by the intentional design where empty PeerSets are supported to clear peers from a discovery source [7](#0-6) . While this is valid for operational purposes (removing stale peers), it creates a security risk when combined with unvalidated REST discovery that could serve malicious or corrupted data.

### Citations

**File:** network/discovery/src/rest.rs (L42-68)
```rust
    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        // Wait for delay, or add the delay for next call
        futures::ready!(self.interval.as_mut().poll_next(cx));

        // Retrieve the onchain resource at the interval
        // TODO there should be a better way than converting this to a blocking call
        let response = block_on(self.rest_client.get_account_resource_bcs::<ValidatorSet>(
            AccountAddress::ONE,
            "0x1::stake::ValidatorSet",
        ));
        Poll::Ready(match response {
            Ok(inner) => {
                let validator_set = inner.into_inner();
                Some(Ok(extract_validator_set_updates(
                    self.network_context,
                    validator_set,
                )))
            },
            Err(err) => {
                info!(
                    "Failed to retrieve validator set by REST discovery {:?}",
                    err
                );
                Some(Err(DiscoveryError::Rest(err)))
            },
        })
    }
```

**File:** network/discovery/src/validator_set.rs (L108-150)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```

**File:** types/src/on_chain_config/validator_set.rs (L63-65)
```rust
    pub fn empty() -> Self {
        ValidatorSet::new(Vec::new())
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L886-926)
```rust
    fn handle_update_discovered_peers(
        &mut self,
        src: DiscoverySource,
        new_discovered_peers: PeerSet,
    ) {
        // Log the update event
        info!(
            NetworkSchema::new(&self.network_context),
            "{} Received updated list of discovered peers! Source: {:?}, num peers: {:?}",
            self.network_context,
            src,
            new_discovered_peers.len()
        );

        // Remove peers that no longer have relevant network information
        let mut keys_updated = false;
        let mut peers_to_check_remove = Vec::new();
        for (peer_id, peer) in self.discovered_peers.write().peer_set.iter_mut() {
            let new_peer = new_discovered_peers.get(peer_id);
            let check_remove = if let Some(new_peer) = new_peer {
                if new_peer.keys.is_empty() {
                    keys_updated |= peer.keys.clear_src(src);
                }
                if new_peer.addresses.is_empty() {
                    peer.addrs.clear_src(src);
                }
                new_peer.addresses.is_empty() && new_peer.keys.is_empty()
            } else {
                keys_updated |= peer.keys.clear_src(src);
                peer.addrs.clear_src(src);
                true
            };
            if check_remove {
                peers_to_check_remove.push(*peer_id);
            }
        }

        // Remove peers that no longer have state
        for peer_id in peers_to_check_remove {
            self.discovered_peers.write().remove_peer_if_empty(&peer_id);
        }
```

**File:** testsuite/smoke-test/src/network.rs (L145-170)
```rust
#[tokio::test]
async fn test_rest_discovery() {
    let mut swarm = SwarmBuilder::new_local(1).with_aptos().build().await;

    // Point to an already existing node
    let (version, rest_endpoint) = {
        let validator = swarm.validators().next().unwrap();
        (validator.version(), validator.rest_api_endpoint())
    };
    let mut full_node_config = NodeConfig::get_default_pfn_config();
    let network_config = full_node_config.full_node_networks.first_mut().unwrap();
    network_config.discovery_method = DiscoveryMethod::Rest(RestDiscovery {
        url: rest_endpoint,
        interval_secs: 1,
    });

    // Start a new node that should connect to the previous node only via REST
    // The startup wait time should check if it connects successfully
    swarm
        .add_full_node(
            &version,
            OverrideNodeConfig::new_with_default_base(full_node_config),
        )
        .await
        .unwrap();
}
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1255-1255)
```text
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**File:** network/framework/src/connectivity_manager/test.rs (L783-785)
```rust
    conn_mgr
        .handle_update_discovered_peers(DiscoverySource::OnChainValidatorSet, peers_empty.clone());
    verify_trusted_peers(&peers_and_metadata, &network_id, peers_empty.clone());
```
