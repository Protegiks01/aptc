# Audit Report

## Title
Authorization Bypass in Module Loading Due to Missing Validation Check and Conditional Security Enforcement

## Summary
The `load_function()` method in `SafeNativeContext` conditionally enforces the `check_is_special_or_visited()` validation only when lazy loading is enabled. Combined with a missing validation check in `native_check_dispatch_type_compatibility_impl`, this allows an attacker to load functions from unvisited modules without proper gas charging when the `ENABLE_LAZY_LOADING` feature flag is disabled.

## Finding Description

The vulnerability exists in two related components:

**Component 1: Conditional Security Check in `load_function()`** [1](#0-0) 

The `load_function()` method only calls `check_is_special_or_visited()` when lazy loading is enabled (lines 235-242). When lazy loading is disabled, it directly loads modules via `unmetered_get_existing_eagerly_verified_module()` without any validation (lines 243-249).

**Component 2: Missing Validation in Type Compatibility Check** [2](#0-1) 

The `native_check_dispatch_type_compatibility_impl` function defines a `check_visited` closure and applies it to the RHS module (line 102), but **fails to apply it to the LHS module** before calling `context.load_function()` (lines 115-117). This asymmetry creates an exploitable path.

**Invariant Violation:**

The code comment explicitly states the security invariant: [3](#0-2) 

This invariant assumes native implementations check module visiting status before dispatch, but the LHS module in `check_dispatch_type_compatibility_impl` violates this assumption.

**Attack Vector:**

1. Attacker waits for or proposes governance action to disable `ENABLE_LAZY_LOADING` feature flag
2. Attacker deploys a malicious or computationally expensive module at a non-special address (e.g., `0xBAD::expensive_module`)
3. Attacker calls `function_info::check_dispatch_type_compatibility_impl` with the LHS parameter pointing to `0xBAD::expensive_module::some_function`
4. The function does NOT check if `0xBAD::expensive_module` was visited (missing check at lines 112-120)
5. Since lazy loading is disabled, `load_function()` skips `check_is_special_or_visited()` and loads the unvisited module
6. Result: Module loaded without gas charging, breaking the gas metering invariant

**Underlying Loader Behavior:** [4](#0-3) 

The `EagerLoader` implementation ignores the `traversal_context` parameter (prefixed with `_`), performing no visitation checks. [5](#0-4) 

In contrast, `LazyLoader` properly meters and validates modules via `metered_load_module()`.

## Impact Explanation

**Severity: Medium**

This vulnerability breaks the critical invariant that "All operations must respect gas limits" and allows:

1. **Gas Metering Bypass**: Modules can be loaded without gas charging, violating the economic model
2. **Resource Exhaustion**: Attacker can load computationally expensive modules to exhaust node resources
3. **State Inconsistency**: Different nodes may have different visited sets if some exploit this bypass

The impact is classified as **Medium** severity because:
- Exploitation requires the `ENABLE_LAZY_LOADING` feature flag to be disabled (not the default state)
- Current default configuration has lazy loading enabled, providing defense-in-depth
- Does not directly lead to fund theft or consensus violation, but breaks resource limit invariants
- Could enable DoS attacks if feature flag state changes

This qualifies under the bug bounty's Medium category: "State inconsistencies requiring intervention" and "Limited funds loss or manipulation" (via gas theft).

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires specific conditions:

**Enabling Factors:**
- `ENABLE_LAZY_LOADING` must be disabled via governance action [6](#0-5) 

The feature is enabled by default on mainnet. [7](#0-6) 

However, it CAN be disabled through governance proposals, making this a real attack surface if governance decisions change the feature flag state.

**Attack Complexity:**
- Simple to execute once conditions are met (single function call)
- No special privileges required beyond normal transaction submission
- Repeatable attack vector

The bug represents a **defense-in-depth failure**: the safety check in `load_function()` was explicitly added as a fallback (per the comment), but it only works when lazy loading is enabled.

## Recommendation

**Fix 1: Add Missing Validation for LHS Module**

In `aptos-move/framework/src/natives/function_info.rs`, add the missing `check_visited` call before loading the LHS module:

```rust
let (lhs, lhs_id) = {
    let (module, func) = extract_function_info(&mut arguments)?;
    
    // ADD THIS CHECK:
    check_visited(module.address(), module.name())
        .map_err(|_| SafeNativeError::Abort { abort_code: 2 })?;
    
    (
        context
            .load_function(&module, &func)
            .map_err(|_| SafeNativeError::Abort { abort_code: 2 })?,
        module,
    )
};
```

**Fix 2: Enforce Invariant Check Regardless of Lazy Loading**

In `aptos-move/aptos-native-interface/src/context.rs`, enforce the security invariant unconditionally:

```rust
pub fn load_function(
    &mut self,
    module_id: &ModuleId,
    function_name: &Identifier,
) -> VMResult<Arc<Function>> {
    // ALWAYS enforce the invariant check, regardless of lazy loading mode
    self.inner
        .traversal_context()
        .check_is_special_or_visited(module_id.address(), module_id.name())
        .map_err(|err| err.finish(Location::Undefined))?;
    
    let module = if self.features.is_lazy_loading_enabled() {
        self.inner
            .module_storage()
            .unmetered_get_existing_lazily_verified_module(module_id)?
    } else {
        self.inner
            .module_storage()
            .unmetered_get_existing_eagerly_verified_module(
                module_id.address(),
                module_id.name(),
            )?
    };
    module.get_function(function_name)
}
```

Both fixes should be applied for defense-in-depth.

## Proof of Concept

**Move Test to Demonstrate the Vulnerability:**

```move
#[test_only]
module 0xBAD::expensive_module {
    // A module that should require gas charging
    public fun expensive_function(): u64 {
        let i = 0;
        let sum = 0;
        while (i < 1000) {
            sum = sum + i;
            i = i + 1;
        };
        sum
    }
}

#[test(framework = @0x1, attacker = @0xBAD)]
#[expected_failure(abort_code = 2, location = 0x1::function_info)]
fun test_unauthorized_module_load_bypass(framework: &signer, attacker: &signer) {
    // This test should FAIL if the vulnerability is present and lazy loading is disabled
    // It should ABORT with code 2 if the fix is applied
    
    use std::signer;
    use aptos_framework::function_info;
    
    // 1. Ensure lazy loading is disabled (requires test harness support)
    // 2. Deploy expensive_module without visiting it
    // 3. Call check_dispatch_type_compatibility_impl with:
    //    - lhs = 0xBAD::expensive_module::expensive_function
    //    - rhs = some_valid_function
    // 4. Observe that the module is loaded without gas charging
    
    let lhs = function_info::new_function_info(
        framework,
        signer::address_of(attacker),
        string::utf8(b"expensive_module"),
        string::utf8(b"expensive_function"),
    );
    
    let rhs = function_info::new_function_info(
        framework,
        @0x1,
        string::utf8(b"account"),
        string::utf8(b"create_account"),
    );
    
    // This should abort because expensive_module was never visited
    // But if lazy loading is disabled and the bug exists, it will succeed
    let _ = function_info::check_dispatch_type_compatibility(&lhs, &rhs);
}
```

**Notes:**
- The PoC demonstrates the attack flow but requires test harness modifications to disable lazy loading
- In production, the attack requires governance to disable the `ENABLE_LAZY_LOADING` feature flag
- The vulnerability is in the asymmetric validation: RHS is checked, LHS is not

### Citations

**File:** aptos-move/aptos-native-interface/src/context.rs (L226-234)
```rust
        // INVARIANT:
        //   There is no need to meter module loading due to function access. This is because this
        //   function is only called for native dynamic dispatch, which pre-charges gas before the
        //   dispatch logic:
        //      1. Native function to load & charge modules is called.
        //      2. Native is called to dispatch, which calls this function from native context.
        //   Currently, native implementations in step (2) check if the module loading was metered,
        //   but we still keep an invariant check here in case there is a mistake and the gas is
        //   not charged.
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L235-250)
```rust
        let module = if self.features.is_lazy_loading_enabled() {
            self.inner
                .traversal_context()
                .check_is_special_or_visited(module_id.address(), module_id.name())
                .map_err(|err| err.finish(Location::Undefined))?;
            self.inner
                .module_storage()
                .unmetered_get_existing_lazily_verified_module(module_id)?
        } else {
            self.inner
                .module_storage()
                .unmetered_get_existing_eagerly_verified_module(
                    module_id.address(),
                    module_id.name(),
                )?
        };
```

**File:** aptos-move/framework/src/natives/function_info.rs (L85-120)
```rust
    let (rhs, rhs_id) = {
        let (module, func) = extract_function_info(&mut arguments)?;

        let check_visited = |a, n| {
            let special_addresses_considered_visited =
                context.get_feature_flags().is_account_abstraction_enabled()
                    || context
                        .get_feature_flags()
                        .is_derivable_account_abstraction_enabled();
            if special_addresses_considered_visited {
                context
                    .traversal_context()
                    .check_is_special_or_visited(a, n)
            } else {
                context.traversal_context().legacy_check_visited(a, n)
            }
        };
        check_visited(module.address(), module.name())
            .map_err(|_| SafeNativeError::Abort { abort_code: 2 })?;

        (
            context
                .load_function(&module, &func)
                .map_err(|_| SafeNativeError::Abort { abort_code: 2 })?,
            module,
        )
    };
    let (lhs, lhs_id) = {
        let (module, func) = extract_function_info(&mut arguments)?;
        (
            context
                .load_function(&module, &func)
                .map_err(|_| SafeNativeError::Abort { abort_code: 2 })?,
            module,
        )
    };
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L184-203)
```rust
    fn load_function_definition(
        &self,
        _gas_meter: &mut impl DependencyGasMeter,
        _traversal_context: &mut TraversalContext,
        module_id: &ModuleId,
        function_name: &IdentStr,
    ) -> VMResult<(Arc<Module>, Arc<Function>)> {
        self.unmetered_get_function_definition(module_id, function_name)
            .map_err(|err| {
                // Note: legacy loader implementation used this error, so we need to remap.
                PartialVMError::new(StatusCode::FUNCTION_RESOLUTION_FAILURE)
                    .with_message(format!(
                        "Module or function do not exist for {}::{}::{}",
                        module_id.address(),
                        module_id.name(),
                        function_name
                    ))
                    .finish(err.location().clone())
            })
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L236-246)
```rust
    fn load_function_definition(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        module_id: &ModuleId,
        function_name: &IdentStr,
    ) -> VMResult<(Arc<Module>, Arc<Function>)> {
        let module = self.metered_load_module(gas_meter, traversal_context, module_id)?;
        let function = module.get_function(function_name)?;
        Ok((module, function))
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L266-266)
```rust
            FeatureFlag::ENABLE_LAZY_LOADING,
```

**File:** types/src/on_chain_config/aptos_features.rs (L437-439)
```rust
    pub fn is_lazy_loading_enabled(&self) -> bool {
        self.is_enabled(FeatureFlag::ENABLE_LAZY_LOADING)
    }
```
