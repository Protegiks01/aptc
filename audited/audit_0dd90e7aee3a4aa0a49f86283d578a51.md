# Audit Report

## Title
Event Sequence Number Duplication During module_event_migration_enabled Feature Flag Transitions

## Summary
During transitions of the `module_event_migration_enabled` feature flag, key rotation events (and other V1 events) can be duplicated with identical sequence numbers, breaking the uniqueness invariant for event keys. This occurs because the V2-to-V1 event translation layer maintains its own sequence number cache independently from the Move EventHandle counters, leading to synchronization failures when the feature flag is toggled.

## Finding Description

The Aptos event system is migrating from V1 events (using EventHandles with sequence numbers) to V2 events (module events without explicit sequence numbers). The migration uses a feature flag `module_event_migration_enabled` that controls which emission path is taken. [1](#0-0) 

When the feature flag is OFF, V1 events are emitted directly using the EventHandle counter, which gets incremented. When the feature flag is ON, V2 events are emitted without touching the EventHandle counter. [2](#0-1) 

For backward compatibility, the indexer translates V2 events back to V1 format using a separate sequence number cache: [3](#0-2) 

The critical bug is that this cache is ONLY updated when processing translated V2 events, not when processing native V1 events: [4](#0-3) 

Notice that lines 434-446 process V1 events without calling `cache_sequence_number`, while lines 448-462 process V2 events and DO call `cache_sequence_number` at line 462.

**Attack Scenario:**

1. **Initial State (Flag OFF)**: Transaction T1 rotates a key, emitting V1 KeyRotationEvent with sequence number 5. EventHandle counter becomes 6. Indexer stores event but does NOT update the translation cache.

2. **Flag Enabled**: Governance enables `module_event_migration_enabled`.

3. **Transition Period (Flag ON)**: Transaction T2 rotates a key, emitting V2 KeyRotation event. The translator reads the EventHandle counter (still 6), finds empty cache, creates synthetic V1 event with sequence number 6, caches it.

4. **Flag Disabled**: Governance disables `module_event_migration_enabled`.

5. **Post-Transition (Flag OFF)**: Transaction T3 rotates a key, emitting V1 KeyRotationEvent with the EventHandle counter value 6 (not incremented during T2). 

**Result**: Both T2's synthetic event and T3's native event have sequence number 6 for the same event key, violating the uniqueness invariant. [5](#0-4) 

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program:

- **State inconsistencies requiring intervention**: Event sequence number duplication breaks the fundamental guarantee that events for a given EventKey have unique, monotonically increasing sequence numbers
- **API crashes**: Systems querying events by key and sequence number may receive incorrect or duplicate data
- **Off-chain infrastructure failures**: Indexers, analytics platforms, and wallets relying on event ordering will malfunction
- **Consensus impact**: While this doesn't directly break consensus, it violates the deterministic execution invariant since different nodes' indexers may process events in different orders or states

The vulnerability affects ALL event types undergoing the V1-to-V2 migration, not just KeyRotationEvent: [6](#0-5) 

## Likelihood Explanation

**Likelihood: HIGH**

This bug will trigger AUTOMATICALLY whenever:
1. The `module_event_migration_enabled` feature flag is toggled by governance
2. The same account performs operations emitting the affected events before and after the toggle
3. The feature flag is toggled back to its original state

The Aptos governance roadmap includes enabling this feature flag for production migration, making this scenario inevitable. The vulnerability does not require any attacker actionâ€”it occurs naturally during the planned feature rollout.

The impact is amplified because:
- Multiple event types are affected (CoinDeposit, CoinWithdraw, KeyRotation, TokenMutation, etc.)
- High-activity accounts will immediately trigger duplications
- The bug is persistent once it occurs (duplicate events remain in storage)

## Recommendation

**Solution**: Synchronize the EventHandle counter with the translation cache by updating the cache for ALL processed events, not just translated V2 events.

In `storage/indexer/src/db_indexer.rs`, modify the V1 event processing to also update the cache:

```rust
if let ContractEvent::V1(v1) = event {
    let key = *v1.key();
    let sequence_number = v1.sequence_number();
    
    // Update cache for V1 events too
    if self.indexer_db.event_v2_translation_enabled() {
        self.event_v2_translation_engine
            .cache_sequence_number(&key, sequence_number);
        event_keys.insert(key);
    }
    
    batch.put::<EventByKeySchema>(
        &(key, sequence_number),
        &(version, idx as u64),
    )?;
    batch.put::<EventByVersionSchema>(
        &(key, version, sequence_number),
        &(idx as u64),
    )?;
}
```

**Alternative Solution**: During feature flag transitions, disable event translation temporarily and require a full re-index, or implement a migration script that properly synchronizes EventHandle counters with cached sequence numbers.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_event_duplication_during_migration() {
    // Setup: Create account with EventHandle counter = 5
    let account = create_test_account();
    assert_eq!(get_event_handle_counter(&account), 5);
    
    // Step 1: Feature flag OFF - emit V1 event
    set_feature_flag(MODULE_EVENT_MIGRATION, false);
    rotate_key(&account); // Emits V1 event seq=5, counter becomes 6
    let events_1 = get_events_by_key(&account.key_rotation_event_key());
    assert_eq!(events_1.last().unwrap().sequence_number, 5);
    assert_eq!(get_event_handle_counter(&account), 6);
    
    // Step 2: Enable feature flag
    set_feature_flag(MODULE_EVENT_MIGRATION, true);
    
    // Step 3: Feature flag ON - emit V2 event (translated to V1)
    rotate_key(&account); // Emits V2, translator creates synthetic V1 seq=6
    let events_2 = get_events_by_key(&account.key_rotation_event_key());
    assert_eq!(events_2.last().unwrap().sequence_number, 6);
    assert_eq!(get_event_handle_counter(&account), 6); // Unchanged!
    
    // Step 4: Disable feature flag
    set_feature_flag(MODULE_EVENT_MIGRATION, false);
    
    // Step 5: Feature flag OFF - emit V1 event again
    rotate_key(&account); // Emits V1 event seq=6 (DUPLICATE!)
    let events_3 = get_events_by_key(&account.key_rotation_event_key());
    
    // VULNERABILITY: Multiple events with sequence number 6
    let seq_6_events: Vec<_> = events_3.iter()
        .filter(|e| e.sequence_number == 6)
        .collect();
    assert_eq!(seq_6_events.len(), 2); // FAILS - proves duplication
}
```

This vulnerability represents a critical flaw in the event migration design that will manifest during production feature flag rollouts, affecting event sequence integrity across the entire Aptos ecosystem.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1083-1097)
```text
        if (std::features::module_event_migration_enabled()) {
            event::emit(KeyRotation {
                account: originating_addr,
                old_authentication_key: account_resource.authentication_key,
                new_authentication_key: new_auth_key_vector,
            });
        } else {
            event::emit_event<KeyRotationEvent>(
                &mut account_resource.key_rotation_events,
                KeyRotationEvent {
                    old_authentication_key: account_resource.authentication_key,
                    new_authentication_key: new_auth_key_vector,
                }
            );
        };
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L54-60)
```text
    public fun emit_event<T: drop + store>(handle_ref: &mut EventHandle<T>, msg: T) {
        write_to_event_store<T>(bcs::to_bytes(&handle_ref.guid), handle_ref.counter, msg);
        spec {
            assume handle_ref.counter + 1 <= MAX_U64;
        };
        handle_ref.counter += 1;
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L78-100)
```rust
        let translators: HashMap<TypeTag, Box<dyn EventV2Translator + Send + Sync>> = [
            (
                COIN_DEPOSIT_TYPE.clone(),
                Box::new(CoinDepositTranslator) as Box<dyn EventV2Translator + Send + Sync>,
            ),
            (COIN_WITHDRAW_TYPE.clone(), Box::new(CoinWithdrawTranslator)),
            (COIN_REGISTER_TYPE.clone(), Box::new(CoinRegisterTranslator)),
            (KEY_ROTATION_TYPE.clone(), Box::new(KeyRotationTranslator)),
            (TRANSFER_TYPE.clone(), Box::new(TransferTranslator)),
            (
                TOKEN_MUTATION_TYPE.clone(),
                Box::new(TokenMutationTranslator),
            ),
            (
                COLLECTION_MUTATION_TYPE.clone(),
                Box::new(CollectionMutationTranslator),
            ),
            (MINT_TYPE.clone(), Box::new(MintTranslator)),
            (BURN_TYPE.clone(), Box::new(BurnTranslator)),
            (TOKEN_DEPOSIT_TYPE.clone(), Box::new(TokenDepositTranslator)),
            (
                TOKEN_WITHDRAW_TYPE.clone(),
                Box::new(TokenWithdrawTranslator),
```

**File:** storage/indexer/src/event_v2_translator.rs (L190-200)
```rust
    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
        if let Some(seq) = self.get_cached_sequence_number(event_key) {
            Ok(seq + 1)
        } else {
            let seq = self
                .internal_indexer_db
                .get::<EventSequenceNumberSchema>(event_key)?
                .map_or(default, |seq| seq + 1);
            Ok(seq)
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L353-390)
```rust
struct KeyRotationTranslator;
impl EventV2Translator for KeyRotationTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let key_rotation = KeyRotation::try_from_bytes(v2.event_data())?;
        let struct_tag_str = "0x1::account::Account".to_string();
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(key_rotation.account(), &struct_tag)?
        {
            let account_resource: AccountResource = bcs::from_bytes(&state_value_bytes)?;
            let key = *account_resource.key_rotation_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, account_resource.key_rotation_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of KeyRotationEvent is deterministically 1.
            static KEY_ROTATION_EVENT_CREATION_NUMBER: u64 = 1;
            (
                EventKey::new(KEY_ROTATION_EVENT_CREATION_NUMBER, *key_rotation.account()),
                0,
            )
        };
        let key_rotation_event = KeyRotationEvent::new(
            key_rotation.old_authentication_key().clone(),
            key_rotation.new_authentication_key().clone(),
        );
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            KEY_ROTATION_EVENT_TYPE.clone(),
            bcs::to_bytes(&key_rotation_event)?,
        )?)
    }
}
```

**File:** storage/indexer/src/db_indexer.rs (L433-463)
```rust
                events.iter().enumerate().try_for_each(|(idx, event)| {
                    if let ContractEvent::V1(v1) = event {
                        batch
                            .put::<EventByKeySchema>(
                                &(*v1.key(), v1.sequence_number()),
                                &(version, idx as u64),
                            )
                            .expect("Failed to put events by key to a batch");
                        batch
                            .put::<EventByVersionSchema>(
                                &(*v1.key(), version, v1.sequence_number()),
                                &(idx as u64),
                            )
                            .expect("Failed to put events by version to a batch");
                    }
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
```
