# Audit Report

## Title
Case-Sensitive OIDC Provider Registration Allows Duplicate Providers and Resource Exhaustion

## Summary
The OIDC provider registration system treats provider names (issuer URLs) as case-sensitive strings without normalization. This allows `https://accounts.google.com` and `https://ACCOUNTS.GOOGLE.COM` to be registered as separate providers through governance proposals, causing validators to spawn duplicate JWK observers, waste network/storage resources, and create potential for resource exhaustion attacks.

## Finding Description

The vulnerability exists across multiple layers of the JWK consensus configuration system:

**1. Configuration Layer - No Duplicate Prevention:** [1](#0-0) 

The `new_v1` function checks for duplicate provider names using `simple_map::upsert`, which performs case-sensitive string comparison. This allows `https://accounts.google.com` and `https://ACCOUNTS.GOOGLE.COM` to both pass validation.

**2. Provider Lookup - Case-Sensitive Comparison:** [2](#0-1) 

The `issuer_from_str` function converts strings to bytes without any normalization, enabling case-sensitive comparisons. [3](#0-2) 

The `get_provider_jwks` function uses exact byte-level equality checks via `issuer_from_str`, treating case variants as completely different providers.

**3. Observer Spawning - Duplicates Per Provider:** [4](#0-3) 

Each registered OIDC provider spawns a dedicated `JWKObserver` thread that fetches JWKs every 10 seconds. Case variants spawn separate observers. [5](#0-4) 

**Attack Path:**
1. Attacker submits governance proposal to register `https://ACCOUNTS.GOOGLE.COM` (requires governance approval but is technically valid)
2. System accepts it as different from existing `https://accounts.google.com`
3. Two separate `JWKObserver` threads spawn, each fetching every 10 seconds
4. Duplicate JWKs stored under different issuer keys in `AllProvidersJWKs`
5. Scale attack: Register 10+ case variants of major providers (Google, Facebook, Apple) to multiply resource consumption 10x+

## Impact Explanation

This issue meets **Medium Severity** criteria per Aptos bug bounty guidelines due to "State inconsistencies requiring intervention":

- **Resource Exhaustion**: Each duplicate provider spawns a JWKObserver that fetches every 10 seconds, consuming network bandwidth, CPU for processing, and memory for storage
- **Storage Bloat**: `AllProvidersJWKs` stores duplicate JWK sets under different issuer keys, bloating on-chain state
- **Validator Impact**: All validators must process duplicate providers, multiplying operational costs
- **Potential DoS Vector**: While each provider requires governance approval, malicious governance actors could weaponize this to degrade network performance
- **State Inconsistency**: The system maintains inconsistent provider state where the same OIDC endpoint is represented multiple times

While this doesn't directly lead to funds loss or consensus violations, it creates state inconsistencies that require governance intervention to remediate and degrades overall network resource efficiency.

## Likelihood Explanation

**Likelihood: Medium**

- **Barrier to Entry**: Requires governance approval, which is a high barrier but not impossible
- **Accidental Occurrence**: Could happen unintentionally if different governance proposals use different URL casings
- **Malicious Exploitation**: A compromised or malicious governance participant could exploit this systematically
- **Detection Difficulty**: May not be immediately obvious that duplicate providers are registered until resource metrics show anomalies

The requirement for governance approval prevents arbitrary exploitation by unprivileged attackers, but governance participants are assumed to be trusted actors who may make mistakes or, in extreme scenarios, act maliciously within their privileges.

## Recommendation

Implement URL normalization for OIDC provider names before registration and lookup:

```rust
// In types/src/jwks/mod.rs
use url::Url;

pub fn normalize_issuer(s: &str) -> Result<String, url::ParseError> {
    let mut url = Url::parse(s)?;
    // Normalize hostname to lowercase per RFC 3986
    if let Some(host) = url.host_str() {
        url.set_host(Some(&host.to_ascii_lowercase()))?;
    }
    Ok(url.to_string())
}

pub fn issuer_from_str(s: &str) -> Issuer {
    normalize_issuer(s)
        .unwrap_or_else(|_| s.to_string())
        .as_bytes()
        .to_vec()
}
```

Add validation in Move:

```move
// In jwk_consensus_config.move
public fun new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {
    let name_set = simple_map::new<String, u64>();
    vector::for_each_ref(&oidc_providers, |provider| {
        let provider: &OIDCProvider = provider;
        // Normalize provider name to lowercase for comparison
        let normalized_name = string::to_lowercase(&provider.name);
        let (_, old_value) = simple_map::upsert(&mut name_set, normalized_name, 0);
        if (option::is_some(&old_value)) {
            abort(error::invalid_argument(EDUPLICATE_PROVIDERS))
        }
    });
    JWKConsensusConfig {
        variant: copyable_any::pack( ConfigV1 { oidc_providers } )
    }
}
```

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0x010001, location = aptos_framework::jwk_consensus_config)]
fun test_case_insensitive_duplicate_detection() {
    use std::string::utf8;
    use aptos_framework::jwk_consensus_config;
    
    // After fix, this should fail with EDUPLICATE_PROVIDERS
    // Currently, it incorrectly passes
    jwk_consensus_config::new_v1(vector[
        jwk_consensus_config::new_oidc_provider(
            utf8(b"https://accounts.google.com"),
            utf8(b"https://accounts.google.com/.well-known/openid-configuration")
        ),
        jwk_consensus_config::new_oidc_provider(
            utf8(b"https://ACCOUNTS.GOOGLE.COM"),
            utf8(b"https://ACCOUNTS.GOOGLE.COM/.well-known/openid-configuration")
        ),
    ]);
}
```

## Notes

While JWT verification itself is not compromised (since the `iss` claim in legitimate JWTs is immutable and signed), the case-sensitivity issue creates operational inefficiencies and potential resource exhaustion vectors. Per RFC 3986, URL schemes and hostnames are case-insensitive, so `https://accounts.google.com` and `https://ACCOUNTS.GOOGLE.COM` resolve to the same endpoint. The system should enforce this semantic equivalence at the configuration level to prevent duplicate resource consumption.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L90-98)
```text
    public fun new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {
        let name_set = simple_map::new<String, u64>();
        vector::for_each_ref(&oidc_providers, |provider| {
            let provider: &OIDCProvider = provider;
            let (_, old_value) = simple_map::upsert(&mut name_set, provider.name, 0);
            if (option::is_some(&old_value)) {
                abort(error::invalid_argument(EDUPLICATE_PROVIDERS))
            }
        });
```

**File:** types/src/jwks/mod.rs (L48-50)
```rust
pub fn issuer_from_str(s: &str) -> Issuer {
    s.as_bytes().to_vec()
}
```

**File:** types/src/jwks/mod.rs (L225-229)
```rust
    pub fn get_provider_jwks(&self, iss: &str) -> Option<&ProviderJWKs> {
        self.entries
            .iter()
            .find(|&provider_jwk_set| provider_jwk_set.issuer.eq(&issuer_from_str(iss)))
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L385-400)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L51-90)
```rust
    async fn start(
        fetch_interval: Duration,
        my_addr: AccountAddress,
        issuer: String,
        open_id_config_url: String,
        observation_tx: aptos_channel::Sender<(), (Issuer, Vec<JWK>)>,
        close_rx: oneshot::Receiver<()>,
    ) {
        let mut interval = tokio::time::interval(fetch_interval);
        interval.set_missed_tick_behavior(MissedTickBehavior::Delay);
        let mut close_rx = close_rx.into_stream();
        let my_addr = if cfg!(feature = "smoke-test") {
            // Include self validator address in JWK request,
            // so dummy OIDC providers in smoke tests can do things like "key A for validator 1, key B for validator 2".
            Some(my_addr)
        } else {
            None
        };

        loop {
            tokio::select! {
                _ = interval.tick().fuse() => {
                    let timer = Instant::now();
                    let result = fetch_jwks(open_id_config_url.as_str(), my_addr).await;
                    debug!(issuer = issuer, "observe_result={:?}", result);
                    let secs = timer.elapsed().as_secs_f64();
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
                    } else {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "err"]).observe(secs);
                    }
                },
                _ = close_rx.select_next_some() => {
                    break;
                }
            }
        }
    }
```
