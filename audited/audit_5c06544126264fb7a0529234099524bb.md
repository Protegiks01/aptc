# Audit Report

## Title
Randomness Share Generation Without Metadata Validation Allows Extraction of Shares for Non-Consensus Metadata

## Summary
The `get_self_share()` function in `RandStore` does not verify that requested metadata corresponds to previously stored consensus-derived metadata before generating and returning shares. This allows attackers to extract cryptographically valid randomness shares for arbitrary metadata values by sending `RequestShare` messages, violating the integrity of the randomness generation system.

## Finding Description

The randomness generation system is designed to produce deterministic, unpredictable randomness for each consensus block. When a block is processed through consensus, its metadata (epoch and round) is extracted and used to generate randomness shares. [1](#0-0) 

However, when handling incoming `RequestShare` messages, the code fails to verify that the requested metadata matches metadata that was previously derived from consensus blocks. [2](#0-1) 

The vulnerability occurs because:

1. **No verification of `RequestShare` messages**: The `verify()` method for `RequestShare` performs no validation beyond epoch matching. [3](#0-2) 

2. **Metadata filter returns None without rejection**: The `get_self_share()` function filters shares by metadata equality, returning `None` if no match exists, but doesn't distinguish between "metadata never existed" vs "metadata doesn't match". [4](#0-3) 

3. **Automatic share generation for unvalidated metadata**: When `None` is returned, the code unconditionally generates a new share using the attacker-provided metadata via `S::generate()`, which creates a cryptographically valid WVUF share. [5](#0-4) 

**Attack Scenario:**

1. Attacker identifies validators that were offline during certain rounds or never processed specific blocks
2. Attacker sends `RequestShare` with metadata `(epoch=E, round=R)` where `R ≤ highest_known_round` but metadata never went through consensus on that validator
3. The validator's `get_self_share()` returns `None` (no matching share)
4. A new cryptographic share is generated for the attacker's metadata
5. The share is added to `rand_store` and returned to the attacker
6. Attacker repeats for multiple validators, collecting shares for non-consensus metadata

## Impact Explanation

This is a **High Severity** vulnerability (protocol violation category) because:

1. **Integrity Violation**: Validators generate and store cryptographic commitments for metadata that was never part of consensus, violating the invariant that randomness shares should only exist for consensus-validated blocks.

2. **State Pollution**: The `rand_store` becomes polluted with shares for arbitrary metadata values, potentially causing state inconsistencies. Once added, these shares persist and could interfere with legitimate randomness processing. [6](#0-5) 

3. **Resource Exhaustion Vector**: Attackers can force validators to perform expensive WVUF share generation operations for arbitrary metadata, consuming CPU resources and polluting storage.

4. **Cryptographic Share Extraction**: Attackers can extract valid cryptographic shares from validators' secret keys for arbitrary inputs, which could potentially be used in future attacks if combined with other vulnerabilities.

While the shares themselves cannot be directly injected into consensus (due to metadata mismatch checks in `RandItem::add_share`), the ability to extract cryptographic material for arbitrary metadata from validator nodes represents a significant protocol violation.

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity**: Low - requires only sending network RPC messages, no special privileges needed
- **Attacker Requirements**: Network access to validator nodes (standard P2P connectivity)
- **Detection Difficulty**: Hard to detect - appears as legitimate share requests in logs
- **Preconditions**: None - works against any validator at any time for rounds ≤ `highest_known_round`

The only constraint is that `metadata.round ≤ highest_known_round`, which is easily satisfied by requesting shares for past rounds. [7](#0-6) 

## Recommendation

Add explicit validation that requested metadata corresponds to previously stored metadata before generating shares. The fix should:

1. Check if metadata was added via `add_rand_metadata()` before generating a share
2. Verify that the requested metadata exactly matches the stored metadata for that round
3. Reject requests for rounds where no consensus-derived metadata exists

**Proposed Fix:**

```rust
// In rand_store.rs, modify get_self_share():
pub fn get_self_share(
    &mut self,
    metadata: &RandMetadata,
) -> anyhow::Result<Option<RandShare<S>>> {
    ensure!(
        metadata.round <= self.highest_known_round,
        "Request share from future round {}, highest known round {}",
        metadata.round,
        self.highest_known_round
    );
    
    // NEW: Verify metadata exists and matches
    let stored_item = self.rand_map.get(&metadata.round);
    match stored_item {
        Some(RandItem::PendingDecision { metadata: stored_metadata, .. }) 
        | Some(RandItem::Decided { .. }) => {
            // Metadata was set via consensus, verify match
            ensure!(
                matches!(stored_item, Some(RandItem::PendingDecision { metadata: m, .. }) if &m.metadata == metadata),
                "Requested metadata does not match consensus metadata for round {}",
                metadata.round
            );
        },
        Some(RandItem::PendingMetadata(_)) | None => {
            // No consensus metadata for this round, reject
            bail!("No consensus metadata exists for round {}", metadata.round);
        }
    }
    
    Ok(self
        .rand_map
        .get(&metadata.round)
        .and_then(|item| item.get_self_share())
        .filter(|share| share.metadata() == metadata))
}
```

**In rand_manager.rs**, remove the automatic share regeneration logic:

```rust
RandMessage::RequestShare(request) => {
    let result = self.rand_store.lock().get_self_share(request.rand_metadata());
    match result {
        Ok(Some(share)) => {
            self.process_response(protocol, response_sender, RandMessage::Share(share));
        },
        Ok(None) => {
            // Share exists but filtered out - should not happen after fix
            warn!("[RandManager] Share exists but metadata mismatch");
        },
        Err(e) => {
            // Properly reject invalid requests
            warn!("[RandManager] Failed to get share: {}", e);
        }
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_metadata_validation {
    use super::*;
    use aptos_types::randomness::RandMetadata;
    
    #[test]
    fn test_request_share_without_consensus_metadata() {
        // Setup: Create a validator node with rand_store
        let (decision_tx, _decision_rx) = unbounded();
        let mut rand_store = RandStore::new(
            1, // epoch
            Author::ZERO,
            test_rand_config(),
            None,
            decision_tx,
        );
        
        // Simulate: highest_known_round = 100 (from some processed blocks)
        rand_store.update_highest_known_round(100);
        
        // Attack: Request share for round 50 with arbitrary metadata
        // Round 50 was never processed (validator was offline)
        let malicious_metadata = RandMetadata {
            epoch: 1,
            round: 50,
        };
        
        // VULNERABILITY: This should fail but currently succeeds
        let result = rand_store.get_self_share(&malicious_metadata);
        
        // Current behavior: Returns None (no share exists)
        assert!(result.is_ok());
        assert!(result.unwrap().is_none());
        
        // In rand_manager.rs, this triggers share generation:
        // let share = S::generate(&self.config, malicious_metadata.clone());
        // The attacker receives a valid cryptographic share for arbitrary metadata!
        
        // Expected behavior after fix: Should return error
        // assert!(result.is_err());
        // assert!(result.unwrap_err().to_string().contains("No consensus metadata"));
    }
}
```

To demonstrate the full attack, an attacker would:
1. Set up a network peer connection to validator nodes
2. Send `RequestShare` RPC messages with crafted metadata for rounds ≤ `highest_known_round`
3. Collect the returned shares
4. Observe that valid WVUF shares are generated and returned for non-consensus metadata

---

## Notes

The vulnerability fundamentally violates the design principle that randomness shares should only be generated for metadata derived from consensus blocks. The comment "reproduce previous share if not found" at line 402 suggests the intended behavior was to regenerate legitimately lost shares, but without proper validation, it becomes an oracle for extracting cryptographic shares for arbitrary metadata.

### Citations

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L145-165)
```rust
    fn process_incoming_metadata(&self, metadata: FullRandMetadata) -> DropGuard {
        let self_share = S::generate(&self.config, metadata.metadata.clone());
        info!(LogSchema::new(LogEvent::BroadcastRandShare)
            .epoch(self.epoch_state.epoch)
            .author(self.author)
            .round(metadata.round()));
        let mut rand_store = self.rand_store.lock();
        rand_store.update_highest_known_round(metadata.round());
        rand_store
            .add_share(self_share.clone(), PathType::Slow)
            .expect("Add self share should succeed");

        if let Some(fast_config) = &self.fast_config {
            let self_fast_share =
                FastShare::new(S::generate(fast_config, metadata.metadata.clone()));
            rand_store
                .add_share(self_fast_share.rand_share(), PathType::Fast)
                .expect("Add self share for fast path should succeed");
        }

        rand_store.add_rand_metadata(metadata.clone());
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L397-413)
```rust
                        RandMessage::RequestShare(request) => {
                            let result = self.rand_store.lock().get_self_share(request.rand_metadata());
                            match result {
                                Ok(maybe_share) => {
                                    let share = maybe_share.unwrap_or_else(|| {
                                        // reproduce previous share if not found
                                        let share = S::generate(&self.config, request.rand_metadata().clone());
                                        self.rand_store.lock().add_share(share.clone(), PathType::Slow).expect("Add self share should succeed");
                                        share
                                    });
                                    self.process_response(protocol, response_sender, RandMessage::Share(share));
                                },
                                Err(e) => {
                                    warn!("[RandManager] Failed to get share: {}", e);
                                }
                            }
                        }
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L44-45)
```rust
        match self {
            RandMessage::RequestShare(_) => Ok(()),
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L280-313)
```rust
    pub fn add_share(&mut self, share: RandShare<S>, path: PathType) -> anyhow::Result<bool> {
        ensure!(
            share.metadata().epoch == self.epoch,
            "Share from different epoch"
        );
        ensure!(
            share.metadata().round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );
        let rand_metadata = share.metadata().clone();

        let (rand_config, rand_item) = if path == PathType::Fast {
            match (self.fast_rand_config.as_ref(), self.fast_rand_map.as_mut()) {
                (Some(fast_rand_config), Some(fast_rand_map)) => (
                    fast_rand_config,
                    fast_rand_map
                        .entry(rand_metadata.round)
                        .or_insert_with(|| RandItem::new(self.author, path)),
                ),
                _ => anyhow::bail!("Fast path not enabled"),
            }
        } else {
            (
                &self.rand_config,
                self.rand_map
                    .entry(rand_metadata.round)
                    .or_insert_with(|| RandItem::new(self.author, PathType::Slow)),
            )
        };

        rand_item.add_share(share, rand_config)?;
        rand_item.try_aggregate(rand_config, self.decision_tx.clone());
        Ok(rand_item.has_decision())
    }
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L323-338)
```rust
    pub fn get_self_share(
        &mut self,
        metadata: &RandMetadata,
    ) -> anyhow::Result<Option<RandShare<S>>> {
        ensure!(
            metadata.round <= self.highest_known_round,
            "Request share from future round {}, highest known round {}",
            metadata.round,
            self.highest_known_round
        );
        Ok(self
            .rand_map
            .get(&metadata.round)
            .and_then(|item| item.get_self_share())
            .filter(|share| share.metadata() == metadata))
    }
```
