# Audit Report

## Title
Silent Object Deletion Skipping Causes Permanent Indexer State Inconsistency

## Summary
The `process_transactions()` function in the default indexer processor silently skips object deletions when database lookups fail, but proceeds to commit all other transaction data including records showing the deletion occurred. This creates permanent state inconsistency where the indexer database shows conflicting information about object state.

## Finding Description

The vulnerability exists in the object extraction logic that runs after `from_transactions()` completes successfully. When processing DeleteResource operations for ObjectGroup objects, the code must look up the previous object state to create the deletion record. [1](#0-0) 

The critical flaw is in how `Object::from_delete_resource()` handles lookup failures: [2](#0-1) 

When `get_object_owner()` fails after retries, the function returns `Ok(None)` instead of propagating the error: [3](#0-2) 

**Attack Sequence:**
1. A batch of transactions contains a DeleteResource operation for "0x1::object::ObjectGroup"
2. `from_transactions()` successfully processes ALL transactions and extracts transaction records, events, write_set_changes, etc.
3. Object extraction loop begins to extract additional object metadata
4. For the DeleteResource, `Object::from_delete_resource()` is called
5. The object address is not in the in-memory `object_mapping` (not created in current batch)
6. `get_object_owner()` queries the database but fails (object never indexed, or database connection issue)
7. After 5 retries with 500ms delays, `get_object_owner()` returns `Err("Failed to get object owner")`
8. `from_delete_resource()` catches the error, logs it, and returns `Ok(None)` 
9. The `.unwrap()` in `process_transactions` succeeds since the Result is Ok
10. The `if let Some(...)` pattern doesn't match, so the object deletion is **silently skipped**
11. Processing continues with all other data intact
12. `insert_to_db()` is called with complete transaction data BUT incomplete object data
13. Database transaction commits successfully [4](#0-3) 

**Resulting Database State:**
- `transactions` table: Contains the transaction record showing successful execution
- `write_set_changes` table: Contains the DeleteResource record for the object
- `objects` table: **MISSING** the object deletion record
- `current_objects` table: Either missing the object entirely, OR shows incorrect state (is_deleted=false)

This violates the fundamental invariant that indexer state must be internally consistent. Queries now show conflicting information: transactions indicate an object was deleted, but object tables suggest it still exists or was never tracked.

## Impact Explanation

**Severity: Medium** - State inconsistencies requiring intervention (per Aptos bug bounty criteria)

This vulnerability causes **permanent state corruption** in the indexer database:

1. **Data Integrity Violation**: The indexer database becomes internally inconsistent with no automatic recovery mechanism
2. **Service Impact**: Dependent services relying on object state queries receive incorrect information
3. **Accumulation Over Time**: Each missed deletion compounds the problem during normal operation
4. **Silent Failure**: Only logs an error message - operators may not notice until inconsistencies cause downstream failures

While this doesn't directly affect consensus or the blockchain itself (the indexer is a separate read-only component), it breaks critical infrastructure that applications and services depend on for accurate blockchain state information. The inconsistency is permanent and requires manual intervention to identify and correct affected records.

## Likelihood Explanation

**Likelihood: High** during certain operational scenarios:

1. **Initial Sync**: When indexer catches up from genesis, objects may be deleted before their creations are indexed (processing out of order)
2. **Database Performance Issues**: Transient database connection issues during the 2.5 second retry window (5 retries Ã— 500ms)
3. **Missing Historical Data**: Objects created before indexer deployment are never in the database
4. **Race Conditions**: Concurrent database operations may cause temporary inconsistencies

The code comment explicitly acknowledges this scenario: "You probably should backfill db" - indicating the developers are aware objects may be missing but chose error suppression over proper error handling.

## Recommendation

**Proper error handling is required** - deletion failures should either fail the entire batch or be handled explicitly:

```rust
// Option 1: Propagate the error (fail the batch)
pub fn from_delete_resource(
    delete_resource: &DeleteResource,
    txn_version: i64,
    write_set_change_index: i64,
    object_mapping: &HashMap<CurrentObjectPK, CurrentObject>,
    conn: &mut PgPoolConnection,
) -> anyhow::Result<Option<(Self, CurrentObject)>> {
    if delete_resource.resource.to_string() == "0x1::object::ObjectGroup" {
        let resource = MoveResource::from_delete_resource(/*...*/);
        let previous_object = if let Some(object) = object_mapping.get(&resource.address) {
            object.clone()
        } else {
            // Propagate error instead of suppressing it
            Self::get_object_owner(conn, &resource.address)?
        };
        // ... rest of function
    }
}
```

**OR Option 2: Store a placeholder deletion record:**

```rust
Err(_) => {
    aptos_logger::error!(
        transaction_version = txn_version,
        lookup_key = &resource.address,
        "Missing object owner - storing deletion with placeholder data",
    );
    // Return placeholder with known-missing marker
    return Ok(Some((
        Self {
            transaction_version: txn_version,
            write_set_change_index,
            object_address: resource.address.clone(),
            owner_address: "0x0".to_string(), // Placeholder
            state_key_hash: resource.state_key_hash.clone(),
            guid_creation_num: BigDecimal::from(0),
            allow_ungated_transfer: false,
            is_deleted: true,
        },
        CurrentObject {
            object_address: resource.address,
            owner_address: "0x0".to_string(),
            state_key_hash: resource.state_key_hash,
            last_guid_creation_num: BigDecimal::from(0),
            allow_ungated_transfer: false,
            last_transaction_version: txn_version,
            is_deleted: true,
        },
    )));
}
```

**Critical**: Remove the silent `Ok(None)` return that suppresses errors.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_api_types::{DeleteResource, MoveStructTag, U64};
    
    #[test]
    fn test_object_deletion_state_inconsistency() {
        // Setup: Empty database (object never indexed)
        let mut conn = setup_test_db_connection();
        let object_mapping = HashMap::new();
        
        // Create DeleteResource for an object that doesn't exist in DB
        let delete_resource = DeleteResource {
            address: "0x1234567890abcdef".parse().unwrap(),
            state_key_hash: "0xabc123".to_string(),
            resource: MoveStructTag {
                address: "0x1".parse().unwrap(),
                module: "object".parse().unwrap(),
                name: "ObjectGroup".parse().unwrap(),
                generic_type_params: vec![],
            },
        };
        
        // Call from_delete_resource - this should fail but returns Ok(None)
        let result = Object::from_delete_resource(
            &delete_resource,
            100, // txn_version
            0,   // write_set_change_index
            &object_mapping,
            &mut conn,
        );
        
        // Vulnerability: Returns Ok(None) instead of Err
        assert!(result.is_ok());
        assert!(result.unwrap().is_none());
        
        // Now simulate the full process_transactions flow
        // ... transaction would be committed to DB with write_set_changes showing deletion
        // ... but objects/current_objects tables would be missing the deletion record
        
        // Query would show inconsistency:
        let txn = get_transaction_from_db(&mut conn, 100);
        let wsc = get_write_set_changes_from_db(&mut conn, 100);
        let obj = get_object_from_db(&mut conn, "0x1234567890abcdef");
        
        assert!(txn.is_some()); // Transaction exists
        assert!(wsc.iter().any(|w| w.type_ == "delete_resource")); // Deletion recorded
        assert!(obj.is_none()); // But object deletion NOT recorded - INCONSISTENCY!
    }
}
```

## Notes

**Important Context:**
- This is an **indexer vulnerability**, not a consensus vulnerability
- The indexer is a separate off-chain component that indexes blockchain data into PostgreSQL
- The actual blockchain state remains correct - only the indexed view is corrupted
- However, many applications and services depend on the indexer for queries, making this a critical infrastructure issue

**Related Issues:**
The code contains a TODO comment acknowledging partial detection issues: [5](#0-4) 

**Additional Verification:**
The retry mechanism attempts to handle transient failures but uses a fixed retry count: [6](#0-5)

### Citations

**File:** crates/indexer/src/processors/default_processor.rs (L560-572)
```rust
                        if let Some((object, current_object)) = Object::from_delete_resource(
                            inner,
                            txn_version,
                            index,
                            &all_current_objects,
                            &mut conn,
                        )
                        .unwrap()
                        {
                            all_objects.push(object.clone());
                            all_current_objects
                                .insert(object.object_address.clone(), current_object.clone());
                        }
```

**File:** crates/indexer/src/processors/default_processor.rs (L593-610)
```rust
        let tx_result = insert_to_db(
            &mut conn,
            self.name(),
            start_version,
            end_version,
            txns,
            (user_transactions, signatures, block_metadata_transactions),
            events,
            write_set_changes,
            (
                move_modules,
                move_resources,
                table_items,
                current_table_items,
                table_metadata,
            ),
            (all_objects, all_current_objects),
        );
```

**File:** crates/indexer/src/models/v2_objects.rs (L109-110)
```rust
    /// TODO: We need to detect if an object is only partially deleted
    /// using KV store
```

**File:** crates/indexer/src/models/v2_objects.rs (L128-138)
```rust
                match Self::get_object_owner(conn, &resource.address) {
                    Ok(owner) => owner,
                    Err(_) => {
                        aptos_logger::error!(
                            transaction_version = txn_version,
                            lookup_key = &resource.address,
                            "Missing object owner for object. You probably should backfill db.",
                        );
                        return Ok(None);
                    },
                }
```

**File:** crates/indexer/src/models/v2_objects.rs (L167-192)
```rust
    fn get_object_owner(
        conn: &mut PgPoolConnection,
        object_address: &str,
    ) -> anyhow::Result<CurrentObject> {
        let mut retried = 0;
        while retried < QUERY_RETRIES {
            retried += 1;
            match CurrentObjectQuery::get_by_address(object_address, conn) {
                Ok(res) => {
                    return Ok(CurrentObject {
                        object_address: res.object_address,
                        owner_address: res.owner_address,
                        state_key_hash: res.state_key_hash,
                        allow_ungated_transfer: res.allow_ungated_transfer,
                        last_guid_creation_num: res.last_guid_creation_num,
                        last_transaction_version: res.last_transaction_version,
                        is_deleted: res.is_deleted,
                    })
                },
                Err(_) => {
                    std::thread::sleep(std::time::Duration::from_millis(QUERY_RETRY_DELAY_MS));
                },
            }
        }
        Err(anyhow::anyhow!("Failed to get object owner"))
    }
```

**File:** crates/indexer/src/models/token_models/collection_datas.rs (L23-24)
```rust
pub const QUERY_RETRIES: u32 = 5;
pub const QUERY_RETRY_DELAY_MS: u64 = 500;
```
