# Audit Report

## Title
Missing Cryptographic State Proofs in Raw State Value API Enables Man-in-the-Middle State Forgery

## Summary
The `/experimental/state_values/raw` API endpoint returns raw blockchain state values without any cryptographic proof of authenticity. This allows malicious full nodes or man-in-the-middle attackers to forge arbitrary state data, breaking the fundamental blockchain security guarantee that state must be verifiable against the consensus-committed state root.

## Finding Description

The `raw_value()` function in the State API retrieves state values from the database and returns them directly to clients without any cryptographic proof mechanism. [1](#0-0) 

The function calls `get_state_value()` which returns only a `StateValue` containing raw data and metadata. [2](#0-1) 

The `StateValue` struct has no proof field - it only contains the data bytes and metadata (deposit amounts, creation time). There is no mechanism for clients to cryptographically verify that the returned state value is actually part of the authenticated Jellyfish Merkle tree at the claimed ledger version.

The `DbStateView` used by the API is created with `maybe_verify_against_state_root_hash: None`, meaning no proof verification occurs even internally. [3](#0-2) 

While the storage layer provides proof-capable APIs like `get_state_value_with_proof_by_version`, [4](#0-3)  these are never exposed through the public API. The proof is only verified internally (if enabled) and never returned to the caller. [5](#0-4) 

**Attack Scenario:**
1. Attacker operates a malicious full node or intercepts API traffic
2. Client sends request to `/experimental/state_values/raw` for an account's balance
3. Attacker returns forged state value showing inflated balance
4. Client receives only BCS-serialized StateValue with ledger info headers [6](#0-5) 
5. Client has no cryptographic proof to verify authenticity
6. Client acts on forged data (e.g., credits fake tokens, approves fake governance vote)

This violates the critical invariant: **"State Consistency: State transitions must be atomic and verifiable via Merkle proofs"** - clients cannot verify state against Merkle proofs because no proofs are provided.

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Loss of Funds**: Attackers can forge account balances, causing applications to credit non-existent tokens or accept fake payments

2. **Consensus/Trust Model Violation**: Breaks the fundamental blockchain security model where clients should be able to verify all data against the consensus-committed state root via Merkle proofs

3. **State Integrity Compromise**: Any on-chain state can be arbitrarily forged:
   - Account balances and resources
   - Module bytecode
   - Governance voting states
   - Validator stakes and rewards
   - Table items and configuration data

4. **Wide Attack Surface**: Affects all applications using this API endpoint including:
   - Light clients
   - Wallets querying balances
   - DeFi protocols checking state
   - Indexers and explorers
   - Any off-chain service consuming state data

The impact is Critical per Aptos bug bounty criteria as it enables "Loss of Funds" and violates core "Consensus/Safety" guarantees by allowing undetectable state forgery.

## Likelihood Explanation

**High Likelihood** - This vulnerability is easily exploitable because:

1. **Low Barrier to Attack**: Any party can run a full node and provide API services, or perform network-level man-in-the-middle attacks on API traffic

2. **No Detection**: Clients have absolutely no way to detect forged state values since no proof is provided

3. **Active Usage**: The endpoint is functional and likely used by various applications despite being marked "experimental"

4. **No Special Permissions Required**: Unlike validator-level attacks, this requires no stake, consensus participation, or privileged access

5. **Silent Failure**: The attack succeeds silently - the forged data looks identical to legitimate data from the client's perspective

## Recommendation

Implement cryptographic state proofs for all state query APIs:

**1. Extend API Response Type** - Add proof field to state value responses:
```rust
pub struct StateValueWithProof {
    pub state_value: StateValue,
    pub proof: SparseMerkleProof,
    pub state_root_hash: HashValue,
}
```

**2. Modify `raw_value()` Function** - Use proof-capable storage APIs: [7](#0-6) 

Replace `get_state_value()` call with `get_state_value_with_proof_by_version()` and return both value and proof:
```rust
let (state_value_opt, proof) = state_view
    .get_state_value_with_proof_by_version(&state_key, version)?;

// Return value with proof for client verification
```

**3. Create Verified State View** - Use the verified state view variant: [8](#0-7) 

The Context should use `verified_state_view_at_version()` instead of `state_view_at_version()` to enable internal proof checking.

**4. Update API Documentation** - Clearly document that clients MUST verify proofs against the state root hash from the trusted LedgerInfo to ensure state authenticity.

**5. Add Client Helper Functions** - Provide SDK utilities to verify proofs, making secure usage the default.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_raw_state_value_lacks_proof() {
    // Setup: Create test node with API
    let (context, _) = setup_test_context().await;
    
    // Create a state key for some account resource
    let address = AccountAddress::from_hex_literal("0x1").unwrap();
    let state_key = StateKey::account_address(&address);
    
    // Query raw state value via API
    let request = RawStateValueRequest {
        key: HexEncodedBytes::from(bcs::to_bytes(&state_key).unwrap()),
    };
    
    let api = StateApi { context: Arc::new(context) };
    let response = api.raw_value(
        &AcceptType::Bcs,
        request,
        None
    ).unwrap();
    
    // Extract the response bytes
    let state_value_bytes = match response {
        BasicResponse::Ok(Bcs(bytes), _, _) => bytes,
        _ => panic!("Unexpected response"),
    };
    
    // Deserialize to StateValue
    let state_value: StateValue = bcs::from_bytes(&state_value_bytes).unwrap();
    
    // VULNERABILITY: No proof field exists in StateValue
    // Client cannot verify this data came from the authentic state tree
    assert_eq!(std::mem::size_of_val(&state_value.bytes()), 
               std::mem::size_of::<Bytes>());
    
    // A malicious node could return ANY forged StateValue here
    // and the client would have no way to detect the forgery
    
    // Demonstrate forgery is undetectable:
    let forged_value = StateValue::new_legacy(
        Bytes::from(vec![0xFF; 100]) // Arbitrary fake data
    );
    let forged_bytes = bcs::to_bytes(&forged_value).unwrap();
    
    // The forged response looks identical to legitimate response
    // No proof means no verification possible
    println!("Real response: {} bytes", state_value_bytes.len());
    println!("Forged response: {} bytes", forged_bytes.len());
    println!("Client cannot distinguish between them - NO PROOF PROVIDED");
}
```

## Notes

This vulnerability affects the core trust model of the Aptos blockchain. While the endpoint is marked "experimental", it provides critical functionality that should never be deployed without cryptographic proofs. The storage layer already has the infrastructure to provide proofs (`SparseMerkleProof`, `get_state_value_with_proof_by_version`), but this capability is inexplicably not exposed through the API.

All blockchain state queries to untrusted parties MUST include cryptographic proofs that clients can verify against the consensus-committed state root. Without this, the entire security model collapses to "trust the API server" - completely defeating the purpose of a decentralized, trustless blockchain system.

### Citations

**File:** api/src/state.rs (L525-591)
```rust
    pub fn raw_value(
        &self,
        accept_type: &AcceptType,
        request: RawStateValueRequest,
        ledger_version: Option<U64>,
    ) -> BasicResultWith404<MoveValue> {
        // Retrieve local state
        let (ledger_info, ledger_version, state_view) = self
            .context
            .state_view(ledger_version.map(|inner| inner.0))?;

        let state_key = bcs::from_bytes(&request.key.0)
            .context(format!(
                "Failed deserializing state value. key: {}",
                request.key
            ))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?;
        let state_value = state_view
            .get_state_value(&state_key)
            .context(format!("Failed fetching state value. key: {}", request.key,))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?
            .ok_or_else(|| {
                build_not_found(
                    "Raw State Value",
                    format!(
                        "StateKey({}) and Ledger version({})",
                        request.key, ledger_version
                    ),
                    AptosErrorCode::StateValueNotFound,
                    &ledger_info,
                )
            })?;
        let bytes = bcs::to_bytes(&state_value)
            .context(format!(
                "Failed serializing state value. key: {}",
                request.key
            ))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?;

        match accept_type {
            AcceptType::Json => Err(api_forbidden(
                "Get raw state value",
                "This serves only bytes. Use other APIs for Json.",
            )),
            AcceptType::Bcs => {
                BasicResponse::try_from_encoded((bytes, &ledger_info, BasicResponseStatus::Ok))
            },
        }
    }
```

**File:** types/src/state_store/state_value.rs (L182-187)
```rust
#[derive(Clone, Debug, BCSCryptoHash, CryptoHasher)]
pub struct StateValue {
    data: Bytes,
    metadata: StateValueMetadata,
    maybe_rapid_hash: Option<(u64, usize)>,
}
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L27-46)
```rust
    fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
        if let Some(version) = self.version {
            if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
                // TODO(aldenhu): sample-verify proof inside DB
                // DB doesn't support returning proofs for buffered state, so only optionally
                // verify proof.
                // TODO: support returning state proof for buffered state.
                if let Ok((value, proof)) =
                    self.db.get_state_value_with_proof_by_version(key, version)
                {
                    proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
                }
            }
            Ok(self
                .db
                .get_state_value_with_version_by_version(key, version)?)
        } else {
            Ok(None)
        }
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L98-104)
```rust
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version,
            maybe_verify_against_state_root_hash: None,
        })
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L107-147)
```rust
pub trait VerifiedStateViewAtVersion {
    fn verified_state_view_at_version(
        &self,
        version: Option<Version>,
        ledger_info: &LedgerInfo,
    ) -> StateViewResult<DbStateView>;
}

impl VerifiedStateViewAtVersion for Arc<dyn DbReader> {
    fn verified_state_view_at_version(
        &self,
        version: Option<Version>,
        ledger_info: &LedgerInfo,
    ) -> StateViewResult<DbStateView> {
        let db = self.clone();

        if let Some(version) = version {
            let txn_with_proof =
                db.get_transaction_by_version(version, ledger_info.version(), false)?;
            txn_with_proof.verify(ledger_info)?;

            let state_root_hash = txn_with_proof
                .proof
                .transaction_info
                .state_checkpoint_hash()
                .ok_or_else(|| StateViewError::NotFound("state_checkpoint_hash".to_string()))?;

            Ok(DbStateView {
                db,
                version: Some(version),
                maybe_verify_against_state_root_hash: Some(state_root_hash),
            })
        } else {
            Ok(DbStateView {
                db,
                version: None,
                maybe_verify_against_state_root_hash: None,
            })
        }
    }
}
```

**File:** storage/storage-interface/src/lib.rs (L546-559)
```rust
    fn get_state_value_with_proof_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<(Option<StateValue>, SparseMerkleProof)> {
        // TODO(HotState): check all callers and possibly query hot state first
        self.get_state_value_with_proof_by_version_ext(
            state_key.crypto_hash_ref(),
            version,
            /* root_depth = */ 0,
            /* use_hot_state = */ false,
        )
        .map(|(value, proof_ext)| (value, proof_ext.into()))
    }
```
