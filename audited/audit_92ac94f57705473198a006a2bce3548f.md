# Audit Report

## Title
Cloud Storage Credential Leakage in Backup Command Adapter Error Handling

## Summary
The `DBToolStorageOpt` configuration in the backup command adapter inadvertently logs cloud storage credentials (AWS access keys, Azure SAS tokens, GCP service account credentials) in error messages when command spawn operations fail. The vulnerability exists because `tokio::process::Command`'s Debug implementation includes all environment variables, and these credentials are passed as environment variables to spawned commands. [1](#0-0) 

## Finding Description

The backup system uses a command adapter pattern to interface with cloud storage providers (AWS S3, GCP Cloud Storage, Azure Blob Storage). Cloud credentials are configured in YAML files and loaded into the `CommandAdapterConfig` structure as environment variables. [2](#0-1) 

Sample configurations show sensitive credentials stored in `env_vars`: [3](#0-2) 

When commands are spawned, these credentials are set as environment variables on the `tokio::process::Command`: [4](#0-3) 

If the spawn operation fails (due to missing bash, permission issues, resource exhaustion, etc.), the `err_notes` error handler logs the full `tokio::process::Command` in Debug format: [5](#0-4) 

Rust's `std::process::Command` (which `tokio::process::Command` wraps) includes **all environment variables** in its Debug output. This means sensitive credentials from `config_env_vars` will be exposed in error logs.

The custom `Command` struct has a Debug implementation that only shows `param_env_vars`, deliberately excluding `config_env_vars`: [6](#0-5) 

However, this protection is bypassed at line 80 where the raw `tokio::process::Command` (not the custom wrapper) is passed to `err_notes`.

## Impact Explanation

This vulnerability constitutes a **High severity** operational security issue with the following impacts:

1. **Credential Exposure**: Cloud storage credentials (AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY, Azure SAS tokens, GCP service account keys) are written to error logs in plaintext

2. **Log Aggregation Risk**: Error logs are typically:
   - Collected by centralized logging systems (Splunk, ELK, CloudWatch)
   - Accessible to multiple operators and support staff
   - Retained for extended periods
   - Sometimes exported to third-party services

3. **Backup Integrity Compromise**: Exposed credentials could enable attackers to:
   - Access complete blockchain state backups
   - Tamper with or delete backup data
   - Prevent disaster recovery capabilities
   - Inject corrupted state for restoration attacks

4. **Privilege Escalation Path**: Operators with log access (but not config file access) gain credential access, violating least-privilege principles

While this doesn't directly cause consensus violations or fund loss, backup integrity is critical for:
- Disaster recovery after consensus failures
- State synchronization for new validators
- Historical state verification
- Compliance and audit requirements

## Likelihood Explanation

**Likelihood: Medium to High**

Spawn failures that trigger this vulnerability can occur due to:

1. **Resource Exhaustion**: System process limits, memory constraints
2. **Permission Issues**: Incorrect file permissions on bash, restrictive security policies
3. **Missing Dependencies**: Bash not available in minimal container environments
4. **Configuration Errors**: Invalid command strings causing shell parsing failures

These conditions are realistic in production environments, especially during:
- Container orchestration changes
- Security policy updates
- Resource constraint scenarios
- Initial deployment/configuration

Once the error occurs, credentials remain exposed in:
- Console output visible to operators
- Log files persisted on disk
- Centralized logging systems
- Monitoring and alerting services

## Recommendation

**Immediate Fix**: Modify the spawn error handling to avoid logging the raw `tokio::process::Command`:

```rust
// In command.rs, line 80, replace:
let child = cmd.spawn().err_notes(&cmd)?;

// With:
let child = cmd.spawn().map_err(|e| {
    error!(
        error = %e,
        cmd_str = %command.cmd_str,
        "Failed to spawn command. Check bash availability and permissions."
    );
    e
})?;
```

**Alternative Approaches**:

1. **Redact Environment Variables**: Create a wrapper type for `tokio::process::Command` with a custom Debug implementation that redacts env vars:

```rust
struct RedactedCommand<'a>(&'a tokio::process::Command);

impl Debug for RedactedCommand<'_> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "[Command with redacted environment]")
    }
}
```

2. **Avoid Environment Variables for Credentials**: Use alternative methods like:
   - Credential files with restricted permissions
   - Cloud provider instance roles/service accounts
   - Kubernetes secrets mounted as files
   - AWS IAM roles, GCP workload identity, Azure managed identities

3. **Sanitize Logs**: Implement log filtering at the logging layer to detect and redact credential patterns

**Long-term**: Migrate away from shell command execution with environment-based credentials toward native Rust cloud storage libraries with secure credential management.

## Proof of Concept

Create a test configuration that triggers spawn failure:

```rust
#[tokio::test]
async fn test_credential_leakage_on_spawn_failure() {
    use std::env;
    use std::path::PathBuf;
    use tempfile::NamedTempFile;
    use std::io::Write;
    
    // Create config with sensitive credential
    let mut config_file = NamedTempFile::new().unwrap();
    writeln!(config_file, "env_vars:").unwrap();
    writeln!(config_file, "  - key: \"SECRET_KEY\"").unwrap();
    writeln!(config_file, "    value: \"AKIAIOSFODNN7EXAMPLE\"").unwrap();
    writeln!(config_file, "commands:").unwrap();
    writeln!(config_file, "  create_backup: echo test").unwrap();
    writeln!(config_file, "  create_for_write: echo test").unwrap();
    writeln!(config_file, "  open_for_read: echo test").unwrap();
    writeln!(config_file, "  save_metadata_line: echo test").unwrap();
    writeln!(config_file, "  list_metadata_files: echo test").unwrap();
    config_file.flush().unwrap();
    
    // Set bash to non-existent path to trigger spawn failure
    env::set_var("PATH", "/nonexistent");
    
    let opt = CommandAdapterOpt {
        config: config_file.path().to_path_buf(),
    };
    
    // Attempt to create command adapter - this should fail at spawn
    // and the error log should contain SECRET_KEY in Debug output
    let result = CommandAdapter::new_with_opt(opt).await;
    
    // The error logs will contain: SECRET_KEY=AKIAIOSFODNN7EXAMPLE
    assert!(result.is_err());
}
```

To observe the credential leak in production-like scenario:
1. Deploy backup service with cloud credentials in config
2. Restrict bash access or exhaust process limits
3. Attempt backup operation
4. Observe error logs containing plaintext credentials

## Notes

This is primarily an **operational security vulnerability** rather than a blockchain protocol vulnerability. It doesn't directly impact consensus, execution, or state management. However, backup integrity is a critical security control for blockchain operations:

- Validators rely on backups for disaster recovery
- Compromised backups could enable state restoration attacks
- Deleted backups eliminate recovery options after failures

The vulnerability meets High severity criteria when considering:
- Scope: All nodes using cloud backup are affected
- Impact: Full credential exposure enabling backup compromise
- Exploitability: Occurs automatically on spawn failures
- Detectability: Credentials persist in log files and aggregation systems

The classification as "(High)" in the security question aligns with industry standards for credential exposure vulnerabilities, even though it doesn't fit traditional blockchain-specific bug bounty categories focused on protocol-level attacks.

### Citations

**File:** storage/backup/backup-cli/src/storage/command_adapter/command.rs (L44-57)
```rust
impl Debug for Command {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            r#""{}" with params [{}]"#,
            self.cmd_str,
            self.param_env_vars
                .iter()
                .map(|v| format!("{}={}", v.key, v.value))
                .collect::<Vec<_>>()
                .join(", "),
        )
    }
}
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/command.rs (L68-80)
```rust
        let mut cmd = tokio::process::Command::new("bash");
        cmd.args(["-c", &command.cmd_str]);
        cmd.stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::inherit());
        for v in command
            .config_env_vars
            .iter()
            .chain(command.param_env_vars.iter())
        {
            cmd.env(&v.key, &v.value);
        }
        let child = cmd.spawn().err_notes(&cmd)?;
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/config.rs (L74-80)
```rust
#[derive(Clone, Default, Deserialize)]
pub struct CommandAdapterConfig {
    /// Command lines that implements `BackupStorage` APIs.
    pub commands: Commands,
    /// Additional environment variables to be set when command lines are spawned.
    pub env_vars: Vec<EnvVar>,
}
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/sample_configs/azure.sample.yaml (L1-9)
```yaml
env_vars:
  - key: "ACCOUNT"
    value: "aptos-backup"
  - key: "CONTAINER"
    value: "backup-1"
  - key: "SUB_DIR"
    value: "e1"
  - key: "SAS"
    value: "?a=blah&b=blah&c=blah"
```

**File:** storage/backup/backup-cli/src/utils/error_notes.rs (L11-17)
```rust
impl<T, E: Display, N: Debug> ErrorNotes<T, E, N> for Result<T, E> {
    fn err_notes(self, notes: N) -> Result<T, E> {
        if let Err(e) = &self {
            error!(error = %e, notes = ?notes, "Error raised, see notes.");
        }
        self
    }
```
