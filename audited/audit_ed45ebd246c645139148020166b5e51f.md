# Audit Report

## Title
State Range Mismatch Causes Unverifiable State Proofs During State Sync

## Summary
The `DataSummary` struct in the state synchronization system independently tracks `states` and `transactions` ranges, allowing nodes to advertise state values at versions where corresponding transaction information is unavailable. This causes proof verification failures during state sync, breaking the critical invariant that advertised data must be cryptographically verifiable.

## Finding Description

The vulnerability exists in how `DataSummary` is constructed and validated: [1](#0-0) 

The `states` and `transactions` ranges are calculated independently: [2](#0-1) 

The `fetch_state_values_range()` method determines states range based on state pruning: [3](#0-2) 

While `fetch_transaction_range()` determines transactions range based on transaction pruning: [4](#0-3) 

When state and transaction pruning configurations differ, these ranges can diverge. The `can_service()` validation for `GetStateValuesWithProof` only checks if the states range contains the requested version: [5](#0-4) 

**The Critical Flaw**: This validation does NOT verify that the transactions range also contains the version, which is necessary for proof verification.

During state sync, clients verify state proofs by comparing the state root hash from `StateValueChunkWithProof` against the `state_checkpoint_hash` from the corresponding `TransactionInfo`: [6](#0-5) 

**Attack Scenario**:
1. A storage node has transaction pruning more aggressive than state pruning
2. Transactions range: [5000, 10000], States range: [3000, 10000]
3. A syncing node requests state values at version 3500
4. The storage node advertises it can serve this request (states range contains 3500)
5. The storage node returns `StateValueChunkWithProof` for version 3500
6. The syncing node attempts verification but needs `TransactionInfo` at version 3500
7. The `TransactionInfo` is unavailable (outside transactions range [5000, 10000])
8. **Proof verification fails - the syncing node cannot complete state sync**

The `TransactionInfo` contains the critical `state_checkpoint_hash` field needed for verification: [7](#0-6) 

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty criteria:

- **Validator node slowdowns**: Syncing nodes repeatedly fail verification, wasting CPU cycles and network bandwidth
- **Liveness issues**: New validators or full nodes cannot complete state sync, preventing them from joining the network
- **Resource exhaustion**: Repeated failed sync attempts consume storage I/O, memory, and network resources
- **Bootstrapping failures**: State sync bootstrapper gets stuck unable to verify proofs, requiring manual intervention

This breaks the fundamental invariant: **"State transitions must be atomic and verifiable via Merkle proofs"** - the system advertises data it cannot cryptographically prove.

## Likelihood Explanation

**HIGH likelihood** - This occurs naturally in production:

1. **Normal Operations**: Different pruning windows for states vs transactions are common for storage optimization
2. **No Attacker Required**: The vulnerability triggers during legitimate node operations
3. **Widespread Impact**: Affects all syncing nodes connecting to peers with mismatched ranges
4. **Deterministic**: Once pruning creates the mismatch, all subsequent sync requests for affected versions will fail

The vulnerability is triggered by:
- Nodes configured with aggressive transaction pruning for storage savings
- State pruning windows larger than transaction pruning windows
- Any syncing node requesting historical state at versions in the gap

## Recommendation

Add validation in `can_service()` to ensure the transactions range also contains the requested version when serving state values:

```rust
GetStateValuesWithProof(request) => {
    let proof_version = request.version;

    let can_serve_states = self
        .states
        .map(|range| range.contains(request.version))
        .unwrap_or(false);
    
    // NEW: Also verify transactions range contains the version
    let can_serve_transaction_info = self
        .transactions
        .map(|range| range.contains(request.version))
        .unwrap_or(false);

    let can_create_proof = self
        .synced_ledger_info
        .as_ref()
        .map(|li| li.ledger_info().version() >= proof_version)
        .unwrap_or(false);

    can_serve_states && can_serve_transaction_info && can_create_proof
}
```

Additionally, update `fetch_state_values_range()` to ensure the states range never exceeds the transactions range:

```rust
fn fetch_state_values_range(
    &self,
    latest_version: Version,
    transactions_range: &Option<CompleteDataRange<Version>>,
) -> Result<Option<CompleteDataRange<Version>>, Error> {
    let pruner_enabled = self.storage.is_state_merkle_pruner_enabled()?;
    if !pruner_enabled {
        return Ok(*transactions_range);
    }
    
    let pruning_window = self.storage.get_epoch_snapshot_prune_window()?;
    
    if latest_version > pruning_window as Version {
        let mut lowest_state_version = latest_version
            .checked_sub(pruning_window as Version)
            .and_then(|v| v.checked_add(1))
            .ok_or_else(|| Error::UnexpectedErrorEncountered("Overflow".into()))?;
        
        // NEW: Ensure states range doesn't exceed transactions range
        if let Some(tx_range) = transactions_range {
            lowest_state_version = lowest_state_version.max(tx_range.lowest());
        }
        
        let state_range = CompleteDataRange::new(lowest_state_version, latest_version)
            .map_err(|error| Error::UnexpectedErrorEncountered(error.to_string()))?;
        return Ok(Some(state_range));
    }
    
    Ok(*transactions_range)
}
```

## Proof of Concept

```rust
#[test]
fn test_state_transaction_range_mismatch() {
    use aptos_storage_service_types::responses::{CompleteDataRange, DataSummary};
    use aptos_types::ledger_info::LedgerInfoWithSignatures;
    
    // Create a DataSummary with mismatched ranges
    let mut summary = DataSummary::default();
    
    // Transactions pruned more aggressively: [5000, 10000]
    summary.transactions = Some(CompleteDataRange::new(5000, 10000).unwrap());
    
    // States pruned less aggressively: [3000, 10000]  
    summary.states = Some(CompleteDataRange::new(3000, 10000).unwrap());
    
    // Synced to version 10000
    summary.synced_ledger_info = Some(create_test_ledger_info(10000));
    
    // Create a request for state values at version 3500
    let request = StateValuesWithProofRequest {
        version: 3500,
        start_index: 0,
        end_index: 100,
    };
    
    let storage_request = StorageServiceRequest {
        data_request: DataRequest::GetStateValuesWithProof(request),
        use_compression: false,
    };
    
    // BUG: This returns TRUE even though verification will fail!
    let can_service = summary.can_service(
        &AptosDataClientConfig::default(),
        TimeService::mock(),
        &storage_request,
    );
    
    assert!(can_service); // Should be FALSE but returns TRUE
    
    // If a client requests this data, they'll get StateValueChunkWithProof
    // but won't be able to verify it because TransactionInfo at version 3500
    // is not available (outside transactions range [5000, 10000])
    
    // The fix: can_service should also check transactions.contains(3500)
    let has_transaction_info = summary.transactions
        .map(|range| range.contains(3500))
        .unwrap_or(false);
    
    assert!(!has_transaction_info); // Transaction info NOT available
    println!("Vulnerability confirmed: State advertised without verifiable proof!");
}
```

## Notes

This vulnerability demonstrates a fundamental design flaw in the state sync data advertisement protocol. The system assumes that if states exist, they can be verified, but verification requires transaction metadata (specifically `state_checkpoint_hash` from `TransactionInfo`) that may have been pruned independently.

The fix must be applied at both the validation layer (preventing advertisement of unverifiable data) and the construction layer (ensuring states range never exceeds what can be verified with available transactions).

### Citations

**File:** state-sync/storage-service/types/src/responses.rs (L666-686)
```rust
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct DataSummary {
    /// The ledger info corresponding to the highest synced version in storage.
    /// This indicates the highest version and epoch that storage can prove.
    pub synced_ledger_info: Option<LedgerInfoWithSignatures>,
    /// The range of epoch ending ledger infos in storage, e.g., if the range
    /// is [(X,Y)], it means all epoch ending ledger infos for epochs X->Y
    /// (inclusive) are held.
    pub epoch_ending_ledger_infos: Option<CompleteDataRange<Epoch>>,
    /// The range of states held in storage, e.g., if the range is
    /// [(X,Y)], it means all states are held for every version X->Y
    /// (inclusive).
    pub states: Option<CompleteDataRange<Version>>,
    /// The range of transactions held in storage, e.g., if the range is
    /// [(X,Y)], it means all transactions for versions X->Y (inclusive) are held.
    pub transactions: Option<CompleteDataRange<Version>>,
    /// The range of transaction outputs held in storage, e.g., if the range
    /// is [(X,Y)], it means all transaction outputs for versions X->Y
    /// (inclusive) are held.
    pub transaction_outputs: Option<CompleteDataRange<Version>>,
}
```

**File:** state-sync/storage-service/types/src/responses.rs (L727-742)
```rust
            GetStateValuesWithProof(request) => {
                let proof_version = request.version;

                let can_serve_states = self
                    .states
                    .map(|range| range.contains(request.version))
                    .unwrap_or(false);

                let can_create_proof = self
                    .synced_ledger_info
                    .as_ref()
                    .map(|li| li.ledger_info().version() >= proof_version)
                    .unwrap_or(false);

                can_serve_states && can_create_proof
            },
```

**File:** state-sync/storage-service/server/src/storage.rs (L143-176)
```rust
    /// Returns the state values range held in the database (lowest to highest).
    /// Note: it is currently assumed that if a node contains a transaction at a
    /// version, V, the node also contains all state values at V.
    fn fetch_state_values_range(
        &self,
        latest_version: Version,
        transactions_range: &Option<CompleteDataRange<Version>>,
    ) -> aptos_storage_service_types::Result<Option<CompleteDataRange<Version>>, Error> {
        let pruner_enabled = self.storage.is_state_merkle_pruner_enabled()?;
        if !pruner_enabled {
            return Ok(*transactions_range);
        }
        let pruning_window = self.storage.get_epoch_snapshot_prune_window()?;

        if latest_version > pruning_window as Version {
            // lowest_state_version = latest_version - pruning_window + 1;
            let mut lowest_state_version = latest_version
                .checked_sub(pruning_window as Version)
                .ok_or_else(|| {
                    Error::UnexpectedErrorEncountered("Lowest state version has overflown!".into())
                })?;
            lowest_state_version = lowest_state_version.checked_add(1).ok_or_else(|| {
                Error::UnexpectedErrorEncountered("Lowest state version has overflown!".into())
            })?;

            // Create the state range
            let state_range = CompleteDataRange::new(lowest_state_version, latest_version)
                .map_err(|error| Error::UnexpectedErrorEncountered(error.to_string()))?;
            return Ok(Some(state_range));
        }

        // No pruning has occurred. Return the transactions range.
        Ok(*transactions_range)
    }
```

**File:** state-sync/storage-service/server/src/storage.rs (L178-192)
```rust
    /// Returns the transaction range held in the database (lowest to highest).
    fn fetch_transaction_range(
        &self,
        latest_version: Version,
    ) -> aptos_storage_service_types::Result<Option<CompleteDataRange<Version>>, Error> {
        let first_transaction_version = self.storage.get_first_txn_version()?;
        if let Some(first_transaction_version) = first_transaction_version {
            let transaction_range =
                CompleteDataRange::new(first_transaction_version, latest_version)
                    .map_err(|error| Error::UnexpectedErrorEncountered(error.to_string()))?;
            Ok(Some(transaction_range))
        } else {
            Ok(None)
        }
    }
```

**File:** state-sync/storage-service/server/src/storage.rs (L1036-1073)
```rust
    fn get_data_summary(&self) -> aptos_storage_service_types::Result<DataSummary, Error> {
        // Fetch the latest ledger info
        let latest_ledger_info_with_sigs = self.storage.get_latest_ledger_info()?;

        // Fetch the epoch ending ledger info range
        let latest_ledger_info = latest_ledger_info_with_sigs.ledger_info();
        let epoch_ending_ledger_infos = if latest_ledger_info.ends_epoch() {
            let highest_ending_epoch = latest_ledger_info.epoch();
            Some(CompleteDataRange::from_genesis(highest_ending_epoch))
        } else if latest_ledger_info.epoch() > 0 {
            let highest_ending_epoch =
                latest_ledger_info.epoch().checked_sub(1).ok_or_else(|| {
                    Error::UnexpectedErrorEncountered("Highest ending epoch overflowed!".into())
                })?;
            Some(CompleteDataRange::from_genesis(highest_ending_epoch))
        } else {
            None // We haven't seen an epoch change yet
        };

        // Fetch the transaction and transaction output ranges
        let latest_version = latest_ledger_info.version();
        let transactions = self.fetch_transaction_range(latest_version)?;
        let transaction_outputs = self.fetch_transaction_output_range(latest_version)?;

        // Fetch the state values range
        let states = self.fetch_state_values_range(latest_version, &transactions)?;

        // Return the relevant data summary
        let data_summary = DataSummary {
            synced_ledger_info: Some(latest_ledger_info_with_sigs),
            epoch_ending_ledger_infos,
            transactions,
            transaction_outputs,
            states,
        };

        Ok(data_summary)
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1007-1031)
```rust
        // Verify the chunk root hash matches the expected root hash
        let first_transaction_info = transaction_output_to_sync
            .get_output_list_with_proof()
            .proof
            .transaction_infos
            .first()
            .ok_or_else(|| {
                Error::UnexpectedError("Target transaction info does not exist!".into())
            })?;
        let expected_root_hash = first_transaction_info
            .ensure_state_checkpoint_hash()
            .map_err(|error| {
                Error::UnexpectedError(format!("State checkpoint must exist! Error: {:?}", error))
            })?;
        if state_value_chunk_with_proof.root_hash != expected_root_hash {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::InvalidPayloadData,
            )))
            .await?;
            return Err(Error::VerificationError(format!(
                "The states chunk with proof root hash: {:?} didn't match the expected hash: {:?}!",
                state_value_chunk_with_proof.root_hash, expected_root_hash,
            )));
        }
```

**File:** types/src/transaction/mod.rs (L2040-2047)
```rust
    /// The hash value summarizing all changes caused to the world state by this transaction.
    /// i.e. hash of the output write set.
    state_change_hash: HashValue,

    /// The root hash of the Sparse Merkle Tree describing the world state at the end of this
    /// transaction. Depending on the protocol configuration, this can be generated periodical
    /// only, like per block.
    state_checkpoint_hash: Option<HashValue>,
```
