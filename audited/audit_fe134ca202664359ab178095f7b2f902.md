# Audit Report

## Title
Missing Application-Level Authorization in Genesis Setup Command

## Summary
The `SetupGit::execute()` function in `crates/aptos/src/genesis/git.rs` lacks application-level authorization checks to verify that only designated genesis coordinators can upload the layout configuration file. Authorization is delegated entirely to the underlying storage mechanism (GitHub token or filesystem permissions), without role-based access control, cryptographic signatures, or multi-party approval mechanisms.

## Finding Description

The `SetupGit` command is designed to initialize a shared repository for genesis coordination by uploading a `layout.yaml` file containing critical genesis parameters. [1](#0-0) 

The layout file contains sensitive genesis configuration including chain ID, validator list, governance parameters, consensus settings, and staking rules. [2](#0-1) 

**Authorization Model:**

The command relies solely on:
1. **GitHub token authentication** - Anyone with a valid GitHub token possessing repository write permissions can execute the operation [3](#0-2) 
2. **Filesystem permissions** - For local repositories, standard OS-level access controls apply [4](#0-3) 

**Missing Security Controls:**
- No cryptographic signature verification on the layout file
- No role-based access control beyond token possession
- No multi-party approval mechanism for distributed genesis
- No audit trail linking specific operators to configuration changes
- No distinction between test and production genesis flows in the code

**Attack Scenario:**

If a GitHub token with repository write access is compromised (through credential leak, phishing, or insider threat within the genesis coordination team), an attacker could:

1. Create a malicious `layout.yaml` with:
   - Modified `chain_id` (causing nodes to join wrong network)
   - Altered `users` list (excluding legitimate validators)
   - Manipulated governance parameters (`min_voting_threshold`, `voting_duration_secs`)
   - Reduced `min_stake` requirements (allowing easy validator entry)
   - Injected malicious `root_key` for test chains

2. Execute: `aptos genesis setup-git --layout-file malicious.yaml --github-repository org/repo --github-token-file stolen-token.txt`

3. The malicious layout overwrites the legitimate configuration in the shared repository

4. When `generate-genesis` is executed, it uses the compromised layout [5](#0-4) 

## Impact Explanation

**Severity Assessment: HIGH (in specific contexts)**

The impact is **context-dependent** based on deployment scenario:

**Production/Distributed Genesis (HIGH impact):**
- Manipulation of network parameters affecting consensus integrity
- Exclusion of legitimate validators from the initial validator set
- Governance parameter tampering enabling malicious proposal approval
- Economic parameter modification affecting staking security

However, documentation indicates that for production deployments, genesis is "generated by Aptos Labs," suggesting centralized control. [6](#0-5) 

**Test Networks (LOW impact):**
- Expected single-operator control model
- Contained environment with limited real-world impact

**Critical Limitation:**
Per the bug bounty exclusions, "social engineering, phishing, or key theft" are explicitly out of scope. Since exploiting this issue requires obtaining a valid GitHub token (through theft, leak, or insider access), the practical exploitability is **significantly constrained** under the stated threat model.

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

**Required Preconditions:**
1. Attacker must obtain a GitHub token with repository write permissions
2. Token must remain valid at time of attack
3. Genesis ceremony must be active/in-progress
4. No out-of-band verification of layout changes by coordinators

**Mitigating Factors:**
- Token theft/leak is explicitly out of scope per bug bounty rules
- Production genesis documented as centralized (Aptos Labs controlled)
- CLI tool design pattern commonly delegates auth to storage layer
- Limited time window during genesis ceremony
- Out-of-band verification typically occurs in production settings

## Recommendation

Implement defense-in-depth authorization controls for genesis initialization:

**1. Cryptographic Signatures:**
Require the layout file to be signed by designated genesis coordinators:
```rust
pub struct SignedLayout {
    layout: Layout,
    signatures: Vec<Ed25519Signature>,
    signers: Vec<Ed25519PublicKey>,
}
```

**2. Role-Based Access Control:**
Add application-level authorization checks:
```rust
async fn execute(self) -> CliTypedResult<()> {
    let layout = Layout::from_disk(&self.layout_file)?;
    
    // Verify caller is authorized coordinator
    if let Some(authorized_keys) = &layout.authorized_coordinators {
        verify_coordinator_authorization(&authorized_keys)?;
    }
    
    let client = self.git_options.get_client()?;
    client.put(Path::new(LAYOUT_FILE), &layout)?;
    Ok(())
}
```

**3. Multi-Party Approval:**
For distributed genesis, implement quorum-based approval before layout activation.

**4. Audit Trail:**
Log all layout modifications with operator identity and timestamp.

**5. Production vs Test Mode:**
Explicitly distinguish between test and production genesis flows in code, applying stricter controls for production.

## Proof of Concept

```bash
#!/bin/bash
# PoC: Unauthorized Genesis Layout Modification
# Prerequisites: Valid GitHub token with repo write access

# Step 1: Create malicious layout.yaml
cat > malicious_layout.yaml <<EOF
---
root_key: "0xMALICIOUS_ROOT_KEY_HERE"
users:
  - attacker-validator  # Excludes legitimate validators
chain_id: 999  # Wrong chain ID
min_stake: 1  # Drastically reduced from production values
min_voting_threshold: 1
voting_duration_secs: 60  # Very short voting window
EOF

# Step 2: Upload malicious layout (assumes token obtained)
aptos genesis setup-git \
  --layout-file malicious_layout.yaml \
  --github-repository target-org/genesis-repo \
  --github-token-file ./github-token.txt

# Result: Malicious layout is now in the shared repository
# Any subsequent generate-genesis will use these compromised parameters
```

**Notes:**

This vulnerability represents a **design-level authorization gap** rather than an implementation bug. The current design delegates all authorization to the storage layer (GitHub tokens or filesystem permissions), which is a common pattern for CLI tools but insufficient for the security-critical genesis initialization process, particularly in distributed multi-party scenarios. However, under the strict validation criteria and given that token compromise is out of scope per bug bounty rules, the practical exploitability is limited to insider threats within the genesis coordination team, which may be an accepted risk in the current trust model where "Aptos Labs generates genesis for production."

### Citations

**File:** crates/aptos/src/genesis/git.rs (L53-61)
```rust
    async fn execute(self) -> CliTypedResult<()> {
        let layout = Layout::from_disk(&self.layout_file)?;

        // Upload layout file to ensure we can read later
        let client = self.git_options.get_client()?;
        client.put(Path::new(LAYOUT_FILE), &layout)?;

        Ok(())
    }
```

**File:** crates/aptos/src/genesis/git.rs (L110-128)
```rust
    pub fn get_client(self) -> CliTypedResult<Client> {
        if self.github_repository.is_none()
            && self.github_token_file.is_none()
            && self.local_repository_dir.is_some()
        {
            Ok(Client::local(self.local_repository_dir.unwrap()))
        } else if self.github_repository.is_some()
            && self.github_token_file.is_some()
            && self.local_repository_dir.is_none()
        {
            Client::github(
                self.github_repository.unwrap(),
                self.github_branch,
                self.github_token_file.unwrap(),
            )
        } else {
            Err(CliError::CommandArgumentError("Must provide either only --local-repository-dir or both --github-repository and --github-token-path".to_string()))
        }
    }
```

**File:** crates/aptos-genesis/src/config.rs (L29-90)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct Layout {
    /// Root key for the blockchain only for test chains
    #[serde(default)]
    pub root_key: Option<Ed25519PublicKey>,
    /// List of usernames or identifiers
    pub users: Vec<String>,
    /// ChainId for the target network
    pub chain_id: ChainId,
    /// Whether to allow new validators to join the set after genesis
    ///
    /// Ignored for mainnet
    #[serde(default)]
    pub allow_new_validators: bool,
    /// Duration of an epoch
    pub epoch_duration_secs: u64,
    /// Whether this is a test network or not
    ///
    /// Ignored for mainnet
    #[serde(default)]
    pub is_test: bool,
    /// Minimum stake to be in the validator set
    pub min_stake: u64,
    /// Minimum number of votes to consider a proposal valid.
    pub min_voting_threshold: u128,
    /// Maximum stake to be in the validator set
    pub max_stake: u64,
    /// Minimum number of seconds to lockup staked coins
    pub recurring_lockup_duration_secs: u64,
    /// Required amount of stake to create proposals.
    pub required_proposer_stake: u64,
    /// Percentage of stake given out as rewards a year (0-100%).
    pub rewards_apy_percentage: u64,
    /// Voting duration for a proposal in seconds.
    pub voting_duration_secs: u64,
    /// % of current epoch's total voting power that can be added in this epoch.
    pub voting_power_increase_limit: u64,
    /// Total supply of coins
    pub total_supply: Option<u64>,
    /// Timestamp (in seconds) when employee vesting starts.
    pub employee_vesting_start: Option<u64>,
    /// Duration of each vesting period (in seconds).
    pub employee_vesting_period_duration: Option<u64>,
    /// Onchain Consensus Config
    #[serde(default = "OnChainConsensusConfig::default_for_genesis")]
    pub on_chain_consensus_config: OnChainConsensusConfig,
    /// Onchain Execution Config
    #[serde(default = "OnChainExecutionConfig::default_for_genesis")]
    pub on_chain_execution_config: OnChainExecutionConfig,

    /// An optional JWK consensus config to use, instead of `default_for_genesis()`.
    #[serde(default)]
    pub jwk_consensus_config_override: Option<OnChainJWKConsensusConfig>,

    /// JWKs to patch in genesis.
    #[serde(default)]
    pub initial_jwks: Vec<IssuerJWK>,

    /// Keyless Groth16 verification key to install in genesis.
    #[serde(default)]
    pub keyless_groth16_vk_override: Option<Groth16VerificationKey>,
}
```

**File:** crates/aptos-github-client/src/lib.rs (L168-188)
```rust
    pub fn put(&self, path: &str, content: &str) -> Result<(), Error> {
        let json = match self.get_sha(path) {
            Ok(hash) => {
                json!({ "branch": self.branch.to_string(), "content": content, "message": format!("[aptos-management] {}", path), "sha": hash })
            },
            Err(Error::NotFound(_)) => {
                json!({ "branch": self.branch.to_string(), "content": content, "message": format!("[aptos-management] {}", path) })
            },
            Err(e) => return Err(e),
        };

        let resp = self
            .upgrade_request(ureq::put(&self.post_url(path)))
            .send_json(json);

        match resp.status() {
            200 => Ok(()),
            201 => Ok(()),
            _ => Err(resp.into()),
        }
    }
```

**File:** crates/aptos/src/genesis/mod.rs (L270-281)
```rust
pub fn fetch_genesis_info(git_options: GitOptions) -> CliTypedResult<GenesisInfo> {
    let client = git_options.get_client()?;
    let layout: Layout = client.get(Path::new(LAYOUT_FILE))?;

    if layout.root_key.is_none() {
        return Err(CliError::UnexpectedError(
            "Layout field root_key was not set.  Please provide a hex encoded Ed25519PublicKey."
                .to_string(),
        ));
    }

    let validators = get_validator_configs(&client, &layout, false).map_err(parse_error)?;
```

**File:** terraform/aptos-node/gcp/README.md (L144-144)
```markdown
12. Create layout YAML file, which defines the node in the validatorSet. For test mode, we can create a genesis blob containing only one node. **Note: this step is only needed for starting the node in test mode, for production, it will be generated by Aptos Labs**
```
