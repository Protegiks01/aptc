# Audit Report

## Title
Partial Object Deletion Causes Indexer State Corruption Due to Undetected Resource Group Residuals

## Summary
The Aptos indexer fails to detect partial object deletions when custom resources remain in an `ObjectGroup` after the core object deletion. This creates a state inconsistency where the blockchain has deleted objects (no `ObjectCore`), but the indexer shows them as still existing, leading to corrupted indexer state.

## Finding Description

The vulnerability occurs due to a mismatch between the VM's resource group deletion semantics and the indexer's deletion detection logic.

**VM-Level Deletion Logic:**

When `object::delete()` is called, it only removes `ObjectCore` and optionally `Untransferable`: [1](#0-0) 

The VM's `convert_resource_group_v1()` function only marks a resource group as fully deleted when `post_group_size == 0`: [2](#0-1) 

If any resources remain in the `ObjectGroup` after deletion (e.g., custom application-specific resources), the group size is non-zero, and the operation becomes a `Modify` instead of `Delete`.

**Indexer Detection Logic:**

The indexer only detects object deletions when the entire `ObjectGroup` is deleted: [3](#0-2) 

The TODO comment explicitly acknowledges this limitation: [4](#0-3) 

**Exploitation Scenario:**

1. A developer creates a custom token with additional resources in the `ObjectGroup` (like `GuildToken` in the guild example): [5](#0-4) 

2. The guild token minting adds both `Token` and `GuildToken` resources to the object: [6](#0-5) 

3. If a burn path is implemented that calls `token::burn()` without removing `GuildToken`, the object becomes partially deleted: [7](#0-6) 

4. `token::burn()` removes `Token`, `TokenIdentifiers`, and `Royalty` resources, and calls `object::delete()` which removes `ObjectCore`
5. However, `GuildToken` remains in the `ObjectGroup`
6. The VM generates a `Modify` operation for the group (not `Delete`)
7. No `DeleteResource` event for `ObjectGroup` is emitted
8. The indexer never detects the deletion and continues showing the object as existing with `is_deleted = false`

**Result:** The blockchain state has an unusable object (no `ObjectCore`), but the indexer shows it as a valid existing object. Applications querying the indexer will display non-existent objects to users.

## Impact Explanation

This vulnerability creates **state inconsistencies requiring intervention**, qualifying as **Medium Severity** per the Aptos bug bounty program.

**Concrete Impact:**
- **Indexer Corruption**: The `current_objects` table becomes corrupted with "zombie" objects that appear to exist but are actually deleted
- **Application Layer Failures**: DApps and wallets relying on the indexer will display deleted objects as available, potentially allowing users to attempt transactions on non-existent objects (which will fail on-chain)
- **Storage Bloat**: Orphaned resources remain in blockchain storage indefinitely, consuming space without providing value
- **Trust Degradation**: Inconsistencies between indexer data and on-chain reality erode confidence in the indexer's reliability

The issue does not affect consensus, validator operation, or core blockchain security, limiting it to Medium severity rather than High or Critical.

## Likelihood Explanation

**High Likelihood** - This vulnerability will manifest in any custom token implementation that:
1. Adds custom resources to the `ObjectGroup` 
2. Implements token burning without explicitly removing all custom resources

The guild example demonstrates this pattern exists in official example code. Since the Move framework encourages developers to extend objects with custom resources using `ExtendRef`, this pattern is common. Any production token that follows this pattern without careful cleanup will trigger the vulnerability.

## Recommendation

**Immediate Fix for Indexer:**

Implement the TODO by detecting partial deletions using resource-level tracking:

```rust
// In Object::from_delete_resource
pub fn from_delete_resource(
    delete_resource: &DeleteResource,
    txn_version: i64,
    write_set_change_index: i64,
    object_mapping: &HashMap<CurrentObjectPK, CurrentObject>,
    conn: &mut PgPoolConnection,
) -> anyhow::Result<Option<(Self, CurrentObject)>> {
    // Detect deletion of any ObjectGroup member, not just the group itself
    let resource_type = delete_resource.resource.to_string();
    
    // Check if this is ObjectGroup or any ObjectCore deletion
    if resource_type == "0x1::object::ObjectGroup" || 
       resource_type == "0x1::object::ObjectCore" {
        // Mark as deleted even if group is only partially deleted
        // Use KV store to verify ObjectCore no longer exists
        // ... implementation
    }
}
```

**Framework-Level Prevention:**

Add a verification function in `object.move` to check for orphaned resources before allowing deletion:

```move
public fun verify_clean_deletion(object_addr: address) {
    // Enumerate all resources at object_addr in ObjectGroup
    // Assert that only ObjectCore and Untransferable exist
    // Abort if other resources remain
}
```

Call this verification in `object::delete()` to prevent partial deletions at the source.

## Proof of Concept

```move
#[test_only]
module test_addr::partial_deletion_poc {
    use aptos_framework::object::{Self, Object, ConstructorRef};
    use aptos_token_objects::token;
    use std::option;
    use std::string;
    
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct CustomData has key {
        value: u64,
    }
    
    #[test(creator = @0x123)]
    fun test_partial_deletion(creator: &signer) {
        // 1. Create a token with custom resource
        let constructor_ref = token::create_named_token(
            creator,
            string::utf8(b"Collection"),
            string::utf8(b"Description"),
            string::utf8(b"Token"),
            option::none(),
            string::utf8(b"uri"),
        );
        
        let object_signer = object::generate_signer(&constructor_ref);
        let token_addr = object::address_from_constructor_ref(&constructor_ref);
        
        // Add custom resource to ObjectGroup
        move_to(&object_signer, CustomData { value: 42 });
        
        // 2. Burn the token (but forget to remove CustomData)
        let burn_ref = token::generate_burn_ref(&constructor_ref);
        token::burn(burn_ref);
        
        // 3. Verify partial deletion state
        // ObjectCore is gone
        assert!(!exists<object::ObjectCore>(token_addr), 1);
        
        // But CustomData remains (orphaned!)
        assert!(exists<CustomData>(token_addr), 2);
        
        // Indexer would fail to detect this deletion because
        // ObjectGroup still exists (size > 0 due to CustomData)
    }
}
```

This PoC demonstrates that after `token::burn()`, the `ObjectCore` is deleted but custom resources remain, creating the partial deletion state that the indexer cannot detect.

**Notes:**

This vulnerability is explicitly acknowledged in the codebase via the TODO comment but remains unimplemented. The impact is limited to indexer state consistency and does not affect blockchain consensus or validator operations. However, it represents a genuine state corruption issue affecting all applications relying on the indexer for object existence queries. The vulnerability becomes more severe as more developers build custom token standards with extended resources in the `ObjectGroup`.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/object.move (L414-428)
```text
    public fun delete(self: DeleteRef) acquires Untransferable, ObjectCore {
        let object_core = move_from<ObjectCore>(self.self);
        let ObjectCore {
            guid_creation_num: _,
            owner: _,
            allow_ungated_transfer: _,
            transfer_events,
        } = object_core;

        if (exists<Untransferable>(self.self)) {
            let Untransferable {} = move_from<Untransferable>(self.self);
        };

        event::destroy_handle(transfer_events);
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L208-214)
```rust
        let metadata_op = if post_group_size.get() == 0 {
            MoveStorageOp::Delete
        } else if pre_group_size.get() == 0 {
            MoveStorageOp::New(Bytes::new())
        } else {
            MoveStorageOp::Modify(Bytes::new())
        };
```

**File:** crates/indexer/src/models/v2_objects.rs (L108-119)
```rust
    /// This handles the case where the entire object is deleted
    /// TODO: We need to detect if an object is only partially deleted
    /// using KV store
    pub fn from_delete_resource(
        delete_resource: &DeleteResource,
        txn_version: i64,
        write_set_change_index: i64,
        object_mapping: &HashMap<CurrentObjectPK, CurrentObject>,
        conn: &mut PgPoolConnection,
    ) -> anyhow::Result<Option<(Self, CurrentObject)>> {
        if delete_resource.resource.to_string() == "0x1::object::ObjectGroup" {
            let resource = MoveResource::from_delete_resource(
```

**File:** aptos-move/move-examples/token_objects/guild/sources/guild.move (L44-51)
```text
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    /// Guild token
    struct GuildToken has key {
        /// Used to get the signer of the token
        extend_ref: object::ExtendRef,
        /// Member collection name
        member_collection_name: String,
    }
```

**File:** aptos-move/move-examples/token_objects/guild/sources/guild.move (L138-142)
```text
        let guild_token = GuildToken {
            extend_ref,
            member_collection_name,
        };
        move_to(&object_signer, guild_token);
```

**File:** aptos-move/framework/aptos-token-objects/sources/token.move (L734-772)
```text
    public fun burn(burn_ref: BurnRef) acquires Token, TokenIdentifiers {
        let (addr, previous_owner) = if (burn_ref.inner.is_some()) {
            let delete_ref = burn_ref.inner.extract();
            let addr = object::address_from_delete_ref(&delete_ref);
            let previous_owner = object::owner(object::address_to_object<Token>(addr));
            object::delete(delete_ref);
            (addr, previous_owner)
        } else {
            let addr = burn_ref.self.extract();
            let previous_owner = object::owner(object::address_to_object<Token>(addr));
            (addr, previous_owner)
        };

        if (royalty::exists_at(addr)) {
            royalty::delete(addr)
        };

        let Token {
            collection,
            index: deprecated_index,
            description: _,
            name: _,
            uri: _,
            mutation_events,
        } = move_from<Token>(addr);

        let index = if (exists<TokenIdentifiers>(addr)) {
            let TokenIdentifiers {
                index,
                name: _,
            } = move_from<TokenIdentifiers>(addr);
            aggregator_v2::read_snapshot(&index)
        } else {
            deprecated_index
        };

        event::destroy_handle(mutation_events);
        collection::decrement_supply(&collection, addr, option::some(index), previous_owner);
    }
```
