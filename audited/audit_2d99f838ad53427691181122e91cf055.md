# Audit Report

## Title
Epoch-Timestamp State Snapshot Inconsistency in Genesis/Hard Fork Execution

## Summary
The `calculate_genesis` function in `db_bootstrapper/mod.rs` reads the epoch value from a pre-execution state snapshot but reads the timestamp from a post-execution state snapshot. This creates a BlockInfo where the epoch and timestamp come from two different, inconsistent states separated by a reconfiguration transaction that bumps the epoch, violating the fundamental state consistency invariant.

## Finding Description

In the genesis/hard fork execution flow, the system creates a `BlockInfo` structure that mixes values from two different state snapshots: [1](#0-0) 

The epoch is read from `base_state_view`, which represents the state **before** the genesis transaction execution. [2](#0-1) 

The timestamp is read from a newly created `state_view` that represents the state **after** the genesis transaction execution. This new state has been updated by the reconfiguration process. [3](#0-2) 

These inconsistent values are then combined into a single `BlockInfo` structure, where:
- `epoch` = N (from pre-execution state)
- `timestamp_usecs` = T (from post-execution state where epoch = N+1)
- `executed_state_id` = merkle root (from post-execution state where epoch = N+1)

**Why This Breaks Invariants:**

During reconfiguration, the on-chain `ConfigurationResource` atomically updates both `epoch` and `last_reconfiguration_time` together: [4](#0-3) 

This ensures that in any consistent state snapshot, the epoch and timestamp are synchronized. However, the `BlockInfo` violates this by mixing epoch N with the timestamp from epoch N+1.

**State Consistency Violation:**

At version V after the hard fork:
- **On-chain state**: `ConfigurationResource.epoch = N+1`, `TimestampResource.microseconds = T`
- **BlockInfo in LedgerInfo**: `epoch = N`, `timestamp_usecs = T`

The BlockInfo claims the block is at epoch N, but the merkle root (`executed_state_id`) proves a state at epoch N+1. Anyone verifying this block would see the epoch mismatch between the BlockInfo metadata and the actual on-chain state it represents.

## Impact Explanation

This qualifies as **High Severity** based on the following criteria:

1. **Significant Protocol Violation**: This is a fundamental violation of state consistency during critical epoch transitions (hard forks). The BlockInfo, which serves as the canonical metadata for a block, contains inconsistent data that misrepresents the actual state.

2. **Hard Fork Vulnerability**: This code path executes during hard forks (when `genesis_version != 0`), which are critical network-wide operations. State inconsistencies during hard forks can have cascading effects on the entire network.

3. **Waypoint Generation Affected**: The waypoint system hashes these inconsistent values together: [5](#0-4) 

This means waypoints generated during hard forks embed the inconsistency, potentially affecting all nodes that sync using these waypoints.

4. **Future Code Risk**: Any future code that assumes `BlockInfo.epoch` matches the on-chain state epoch at that version will fail or behave incorrectly. This creates a landmine for future development.

5. **Monitoring and Debugging Confusion**: The epoch mismatch between BlockInfo and actual state makes debugging and monitoring extremely difficult during hard forks.

## Likelihood Explanation

**Likelihood: High**

- This code path is **deterministically executed** during every hard fork (`genesis_version != 0`)
- Hard forks, while rare, are **critical operations** used for network upgrades
- The bug **always triggers** when the code path executes - it's not dependent on race conditions or timing
- All validators produce the same inconsistent result, so it propagates network-wide
- The bug has **already occurred** in any historical hard forks that used this code

## Recommendation

The fix is to read both epoch and timestamp from the **same consistent state snapshot**. Since the BlockInfo represents the block that **causes** the epoch transition, both values should come from the post-execution state:

```rust
let (epoch, timestamp_usecs) = if genesis_version == 0 {
    (GENESIS_EPOCH, GENESIS_TIMESTAMP_USECS)
} else {
    let state_view = CachedStateView::new(
        StateViewId::Miscellaneous,
        Arc::clone(&db.reader),
        output.result_state().latest().clone(),
    )?;
    
    let new_epoch = get_state_epoch(&state_view)?;
    let base_epoch = new_epoch
        .checked_sub(1)
        .ok_or_else(|| format_err!("epoch underflow"))?;
    
    // Verify reconfiguration occurred
    ensure!(
        new_epoch > base_epoch,
        "Genesis txn didn't bump epoch."
    );
    
    (base_epoch, get_state_timestamp(&state_view)?)
};
```

Alternatively, read both from the pre-execution state if the BlockInfo should represent the pre-transition state.

## Proof of Concept

To reproduce this issue:

1. Set up a test chain with epoch N at version V-1
2. Execute a hard fork transaction at version V that triggers reconfiguration
3. Observe that `calculate_genesis` creates BlockInfo with:
   - `epoch = N` (read from state at version V-1)
   - `timestamp = T` (read from state at version V where epoch = N+1)
4. Query the on-chain state at version V and observe:
   - `ConfigurationResource.epoch = N+1`
   - `ConfigurationResource.last_reconfiguration_time = T`
   - `TimestampResource.microseconds = T`
5. Compare: BlockInfo says epoch N with timestamp T, but state says epoch N+1 with timestamp T

The existing test framework in `execution/executor/tests/db_bootstrapper_test.rs` can be extended to verify this inconsistency by asserting that the epoch read from the committed state matches the epoch in the committed LedgerInfo (it won't match).

## Notes

This vulnerability demonstrates a **state snapshot consistency violation** during hard fork execution. While it doesn't immediately enable fund theft or consensus attacks, it violates fundamental state consistency invariants and creates a mismatch between BlockInfo metadata and the actual on-chain state. This is particularly concerning during hard forks, which are critical network-wide operations where correctness is paramount.

The issue affects the waypoint system, state synchronization, and any code that assumes epoch and timestamp in BlockInfo come from a consistent state snapshot. It should be fixed to maintain protocol integrity and prevent future issues.

### Citations

**File:** execution/executor/src/db_bootstrapper/mod.rs (L130-134)
```rust
    let epoch = if genesis_version == 0 {
        GENESIS_EPOCH
    } else {
        get_state_epoch(&base_state_view)?
    };
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L161-174)
```rust
        let state_view = CachedStateView::new(
            StateViewId::Miscellaneous,
            Arc::clone(&db.reader),
            output.result_state().latest().clone(),
        )?;
        let next_epoch = epoch
            .checked_add(1)
            .ok_or_else(|| format_err!("integer overflow occurred"))?;
        ensure!(
            next_epoch == get_state_epoch(&state_view)?,
            "Genesis txn didn't bump epoch."
        );
        get_state_timestamp(&state_view)?
    };
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L176-193)
```rust
    let ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        LedgerInfo::new(
            BlockInfo::new(
                epoch,
                GENESIS_ROUND,
                genesis_block_id(),
                output
                    .ensure_ledger_update_output()?
                    .transaction_accumulator
                    .root_hash(),
                genesis_version,
                timestamp_usecs,
                output.execution_output.next_epoch_state.clone(),
            ),
            genesis_block_id(), /* consensus_data_hash */
        ),
        AggregateSignature::empty(), /* signatures */
    );
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L137-142)
```text
        assert!(current_time > config_ref.last_reconfiguration_time, error::invalid_state(EINVALID_BLOCK_TIME));
        config_ref.last_reconfiguration_time = current_time;
        spec {
            assume config_ref.epoch + 1 <= MAX_U64;
        };
        config_ref.epoch = config_ref.epoch + 1;
```

**File:** types/src/waypoint.rs (L129-147)
```rust
#[derive(Deserialize, Serialize, CryptoHasher, BCSCryptoHash)]
struct Ledger2WaypointConverter {
    epoch: u64,
    root_hash: HashValue,
    version: Version,
    timestamp_usecs: u64,
    next_epoch_state: Option<EpochState>,
}

impl Ledger2WaypointConverter {
    pub fn new(ledger_info: &LedgerInfo) -> Self {
        Self {
            epoch: ledger_info.epoch(),
            root_hash: ledger_info.transaction_accumulator_hash(),
            version: ledger_info.version(),
            timestamp_usecs: ledger_info.timestamp_usecs(),
            next_epoch_state: ledger_info.next_epoch_state().cloned(),
        }
    }
```
