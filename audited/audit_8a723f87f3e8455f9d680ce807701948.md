# Audit Report

## Title
SafetyData Upgrade Path Allows Consensus Safety Violations via Field Reset to Zero

## Summary
The `test_safety_data_upgrade` test in `safety_data.rs` verifies only that old SafetyData format deserializes successfully, but does not verify that the resulting state maintains consensus safety invariants. The `one_chain_round` and `highest_timeout_round` fields are marked with `#[serde(default)]`, causing them to be set to `0` when deserializing old SafetyData that lacks these fields. This creates an internally inconsistent state that bypasses critical 2-chain consensus safety checks, potentially enabling validators to sign conflicting timeouts and participate in fork attacks. [1](#0-0) [2](#0-1) 

## Finding Description

The SafetyData structure contains two critical fields for 2-chain consensus safety:
- `one_chain_round`: Tracks the highest 1-chain round (highest QC round observed)
- `highest_timeout_round`: Tracks the highest round for which a timeout was signed [3](#0-2) 

These fields are used in critical safety checks:

**1. The `safe_to_timeout` check requires `qc_round >= one_chain_round`:** [4](#0-3) 

This prevents validators from signing timeouts with outdated QCs when they have already observed more recent chain progress.

**2. The `safe_for_order_vote` check requires `round > highest_timeout_round`:** [5](#0-4) 

This prevents validators from ordering blocks after they have timed out on that round.

**The Vulnerability:**

The upgrade test only verifies successful deserialization but does NOT verify safety: [6](#0-5) 

When old SafetyData (without `one_chain_round`/`highest_timeout_round`) is deserialized, these fields default to `0`, creating an inconsistent state where:

**Attack Scenario 1 - Timeout with Stale QC:**
1. Pre-upgrade: Validator has `last_voted_round = 50`, `one_chain_round = 100`, `preferred_round = 99` (observed chain up to round 100)
2. Post-upgrade: `last_voted_round = 50`, `one_chain_round = 0`, `preferred_round = 99`
3. Byzantine actor requests timeout for round 51 with `qc_round = 50`
4. Safety check: `qc_round (50) >= one_chain_round (0)` â†’ **PASSES** (should fail as 50 < 100)
5. Validator signs timeout based on outdated QC despite knowing chain is at round 100
6. This enables creation of timeout certificates for old rounds, facilitating fork attacks

**Attack Scenario 2 - Order Vote After Timeout:**
1. Pre-upgrade: Validator signed timeout for round 100, so `highest_timeout_round = 100`
2. Post-upgrade: `highest_timeout_round = 0`
3. Validator can now sign order votes for rounds 1-99 (any round > 0)
4. This violates the invariant that validators cannot order blocks after timing out on that round [7](#0-6) 

The `update_highest_timeout_round` call persists this state after processing timeouts: [8](#0-7) 

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This vulnerability enables consensus safety violations by allowing validators to:

1. **Sign conflicting timeouts**: Validators can sign timeouts with stale QCs (qc_round < actual observed round), enabling Byzantine actors to collect timeout signatures for old rounds and create timeout certificates that resurrect old forks

2. **Break timeout-ordering invariant**: Validators can sign order votes after timing out, allowing participation in conflicting consensus paths

3. **Facilitate chain splits**: Multiple validators upgrading simultaneously could collectively enable enough signatures for invalid timeout certificates, potentially causing honest validators to advance incompatible forks

This directly violates the **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine actors." The reset safety fields effectively make upgraded validators behave as if they haven't observed recent chain progress, making them exploitable by Byzantine actors to construct attack scenarios that would normally be prevented.

## Likelihood Explanation

**High Likelihood**

1. **Automatic Trigger**: The vulnerability automatically triggers during any node upgrade from old SafetyData format to new format - no attacker action needed to create the vulnerable state

2. **Realistic Deployment Scenario**: Production networks routinely upgrade validators, and if old persisted SafetyData exists (from before these fields were added), every validator will hit this code path

3. **Observable**: Byzantine actors can detect upgraded validators by attempting to send timeout requests with old QCs and observing whether they get signed

4. **Exploitable**: Once in the vulnerable state, validators respond to normal consensus messages (timeout requests, order vote proposals), making exploitation indistinguishable from legitimate traffic

5. **Persistent**: The vulnerable state persists until the validator observes new QCs (for `one_chain_round`) or signs new timeouts (for `highest_timeout_round`), which may take multiple rounds

## Recommendation

**Immediate Fix**: The upgrade test must verify safety invariants, and the deserialization must properly initialize these fields instead of using zero defaults.

**Recommended Code Changes:**

1. **Improve the upgrade test to verify safety:**

```rust
#[test]
fn test_safety_data_upgrade() {
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    let old_data = OldSafetyData {
        epoch: 1,
        last_voted_round: 10,
        preferred_round: 100,
        last_vote: None,
    };
    let value = serde_json::to_value(old_data).unwrap();
    let new_data: SafetyData = serde_json::from_value(value).unwrap();
    
    // CRITICAL: Verify safety invariants are maintained
    assert!(
        new_data.one_chain_round >= new_data.preferred_round,
        "one_chain_round must be at least preferred_round after upgrade"
    );
    assert_eq!(new_data.epoch, 1);
    assert_eq!(new_data.last_voted_round, 10);
    assert_eq!(new_data.preferred_round, 100);
}
```

2. **Use proper migration logic instead of `#[serde(default)]`:**

```rust
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone)]
#[serde(from = "SafetyDataHelper")]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    pub preferred_round: u64,
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    pub highest_timeout_round: u64,
}

#[derive(Deserialize)]
struct SafetyDataHelper {
    pub epoch: u64,
    pub last_voted_round: u64,
    pub preferred_round: u64,
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}

impl From<SafetyDataHelper> for SafetyData {
    fn from(helper: SafetyDataHelper) -> Self {
        Self {
            epoch: helper.epoch,
            last_voted_round: helper.last_voted_round,
            preferred_round: helper.preferred_round,
            // Initialize one_chain_round to at least preferred_round for safety
            one_chain_round: helper.one_chain_round.max(helper.preferred_round),
            last_vote: helper.last_vote,
            // Conservative: initialize to last_voted_round to prevent ordering old rounds
            highest_timeout_round: helper.highest_timeout_round.max(helper.last_voted_round),
        }
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_safety_data_upgrade_vulnerability() {
    use serde::{Deserialize, Serialize};
    use aptos_consensus_types::{safety_data::SafetyData, vote::Vote};
    
    // Simulate old SafetyData format (before one_chain_round/highest_timeout_round)
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    
    // Validator state before upgrade: has observed chain up to round 100
    let old_data = OldSafetyData {
        epoch: 1,
        last_voted_round: 50,  // Only voted up to round 50
        preferred_round: 99,   // But observed 2-chain up to round 99
        last_vote: None,
    };
    
    // Serialize old format
    let serialized = serde_json::to_value(old_data).unwrap();
    
    // Deserialize to new format (simulates upgrade)
    let new_data: SafetyData = serde_json::from_value(serialized).unwrap();
    
    // VULNERABILITY: Critical safety fields are reset to 0
    assert_eq!(new_data.one_chain_round, 0, "one_chain_round reset to 0 instead of preserving >= preferred_round");
    assert_eq!(new_data.highest_timeout_round, 0, "highest_timeout_round reset to 0");
    assert_eq!(new_data.preferred_round, 99, "preferred_round preserved");
    assert_eq!(new_data.last_voted_round, 50, "last_voted_round preserved");
    
    // SAFETY VIOLATION: Internal state is now inconsistent
    // one_chain_round (0) < preferred_round (99) violates the invariant that
    // one_chain_round >= preferred_round (since one_chain is the QC round and 
    // preferred is the parent round)
    
    println!("VULNERABILITY DEMONSTRATED:");
    println!("- Validator observed chain progress up to round 99/100");
    println!("- After upgrade: one_chain_round reset to 0");
    println!("- Validator can now sign timeouts with QCs from round 50, 60, etc.");
    println!("- This enables Byzantine actors to collect signatures for old rounds");
    println!("- Breaks consensus safety by allowing timeouts based on stale chain state");
}
```

**To run:**
```bash
cd consensus/consensus-types
cargo test test_safety_data_upgrade_vulnerability -- --nocapture
```

**Expected output demonstrating the vulnerability:**
```
VULNERABILITY DEMONSTRATED:
- Validator observed chain progress up to round 99/100  
- After upgrade: one_chain_round reset to 0
- Validator can now sign timeouts with QCs from round 50, 60, etc.
- This enables Byzantine actors to collect signatures for old rounds
- Breaks consensus safety by allowing timeouts based on stale chain state
```

## Notes

The vulnerability stems from prioritizing backward compatibility over safety. The `#[serde(default)]` attribute allows deserialization to succeed but creates an unsafe state. The existing test verifies only that "it doesn't crash" rather than "it's safe."

The proper approach requires a migration strategy that initializes `one_chain_round` to at least `preferred_round` (maintaining the invariant that one-chain >= two-chain) and `highest_timeout_round` to a conservative value like `last_voted_round`. Without this, every validator upgrade becomes a potential consensus safety vulnerability window exploitable by Byzantine actors.

### Citations

**File:** consensus/consensus-types/src/safety_data.rs (L10-21)
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/consensus-types/src/safety_data.rs (L53-70)
```rust
#[test]
fn test_safety_data_upgrade() {
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    let old_data = OldSafetyData {
        epoch: 1,
        last_voted_round: 10,
        preferred_round: 100,
        last_vote: None,
    };
    let value = serde_json::to_value(old_data).unwrap();
    let _: SafetyData = serde_json::from_value(value).unwrap();
}
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L19-51)
```rust
    pub(crate) fn guarded_sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(timeout.epoch(), &safety_data)?;
        if !self.skip_sig_verify {
            timeout
                .verify(&self.epoch_state()?.verifier)
                .map_err(|e| Error::InvalidTimeout(e.to_string()))?;
        }
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }

        self.safe_to_timeout(timeout, timeout_cert, &safety_data)?;
        if timeout.round() < safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                timeout.round(),
                safety_data.last_voted_round,
            ));
        }
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
        }
        self.update_highest_timeout_round(timeout, &mut safety_data);
        self.persistent_storage.set_safety_data(safety_data)?;

        let signature = self.sign(&timeout.signing_format())?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L124-145)
```rust
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L168-178)
```rust
    fn safe_for_order_vote(&self, block: &Block, safety_data: &SafetyData) -> Result<(), Error> {
        let round = block.round();
        if round > safety_data.highest_timeout_round {
            Ok(())
        } else {
            Err(Error::NotSafeForOrderVote(
                round,
                safety_data.highest_timeout_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L158-170)
```rust
    pub(crate) fn update_highest_timeout_round(
        &self,
        timeout: &TwoChainTimeout,
        safety_data: &mut SafetyData,
    ) {
        if timeout.round() > safety_data.highest_timeout_round {
            safety_data.highest_timeout_round = timeout.round();
            trace!(
                SafetyLogSchema::new(LogEntry::HighestTimeoutRound, LogEvent::Update)
                    .highest_timeout_round(safety_data.highest_timeout_round)
            );
        }
    }
```
