# Audit Report

## Title
Consensus Observer Accepts Unverified Blocks Into Pending Store Allowing DoS Attack

## Summary
The consensus observer accepts `OrderedBlock` messages into the pending block store without verifying their cryptographic proofs. An attacker can exploit this by sending structurally valid but cryptographically invalid blocks, filling the pending store and causing legitimate blocks to be evicted, disrupting consensus observation.

## Finding Description

The consensus observer implementation has a critical validation gap in how it processes incoming `OrderedBlock` messages. When an ordered block is received from the network, the system performs only structural validation before storing it in the pending block store.

**The Vulnerability Flow:**

1. When an `OrderedBlock` message arrives in `process_ordered_block_message`, only `verify_ordered_blocks()` is called, which explicitly does NOT verify cryptographic proofs: [1](#0-0) 

This method only checks structural properties (block chaining, ID matching) but the comment on line 226 explicitly states: **"Note: this does not check the ordered proof."**

2. If the block's payloads don't exist yet, it is wrapped in an `ObservedOrderedBlock` and inserted directly into the pending block store WITHOUT any cryptographic proof verification: [2](#0-1) 

3. The `ObservedOrderedBlock` itself is just a simple enum wrapper with no validation logic: [3](#0-2) 

4. The cryptographic proof verification via `verify_ordered_proof()` only happens much later in `process_ordered_block`, which is called AFTER payloads arrive: [4](#0-3) [5](#0-4) 

**The Attack:**

An attacker (subscribed peer) can:
1. Send many `OrderedBlock` messages with valid structure but **forged/invalid cryptographic signatures**
2. **Not send the corresponding payloads** for these blocks
3. These blocks accumulate in the pending block store (up to `max_num_pending_blocks` limit)
4. When the limit is reached, garbage collection evicts the **oldest blocks** (which may be legitimate): [6](#0-5) 

5. Legitimate blocks waiting for payloads get evicted, causing the observer to miss critical consensus updates

The default limit is 150 blocks (300 for test networks): [7](#0-6) 

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Denial of Service on Consensus Observers**: Attackers can prevent consensus observers from tracking the current consensus state by flooding the pending block store with invalid blocks, causing legitimate blocks to be evicted.

2. **Liveness Impact**: Consensus observers that miss critical blocks will fall back to state sync mode, degrading performance and potentially causing temporary unavailability of consensus observation services. [8](#0-7) 

3. **Resource Exhaustion**: The attack consumes memory and storage resources by forcing the observer to maintain up to 150-300 invalid blocks in memory.

4. **Cascading Failures**: If multiple observers are targeted simultaneously, validator fullnodes relying on consensus observation could experience degraded service or failover to less efficient state sync mechanisms.

This breaks the **Consensus Safety** and **Resource Limits** invariants by allowing unverified data to consume critical system resources and disrupt consensus tracking.

## Likelihood Explanation

**High Likelihood** - The attack is easily exploitable:

1. **Low Barrier to Entry**: Attacker only needs to establish a subscription with the observer (standard P2P connection)
2. **Simple Exploitation**: Attack requires only:
   - Sending structurally valid blocks (easy to craft)
   - Forging invalid signatures (blocks still pass structural validation)
   - Not sending payloads (omission, not active attack)
3. **No Detection**: Invalid blocks aren't discovered until payloads arrive, which may never happen
4. **Repeatable**: Attack can be sustained continuously to maintain DoS condition
5. **Multiple Targets**: Single attacker can target multiple observers simultaneously

The subscription check provides minimal protection: [9](#0-8) 

A malicious subscribed peer can exploit this freely.

## Recommendation

**Verify cryptographic proofs BEFORE inserting blocks into the pending store.**

Modify `process_ordered_block_message` to verify the ordered proof immediately for blocks in the current epoch:

```rust
// In process_ordered_block_message, after verify_ordered_blocks() passes:

// Verify the ordered block proof for current epoch BEFORE storing
let epoch_state = self.get_epoch_state();
if ordered_block.proof_block_info().epoch() == epoch_state.epoch {
    if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
        error!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Failed to verify ordered proof before storing! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                ordered_block.proof_block_info(),
                peer_network_id,
                error
            ))
        );
        increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
        return;
    }
}

// Only NOW create and store the pending block
let observed_ordered_block = ObservedOrderedBlock::new(ordered_block);
let pending_block_with_metadata = PendingBlockWithMetadata::new_with_arc(
    peer_network_id,
    message_received_time,
    observed_ordered_block,
);

// Store in pending blocks (now safe, proof already verified)
if self.all_payloads_exist(pending_block_with_metadata.ordered_block().blocks()) {
    self.process_ordered_block(pending_block_with_metadata).await;
} else {
    self.observer_block_data
        .lock()
        .insert_pending_block(pending_block_with_metadata);
}
```

This ensures only cryptographically valid blocks enter the pending store, preventing the DoS attack.

## Proof of Concept

**Attack Scenario:**

1. Attacker establishes subscription to consensus observer
2. Attacker crafts 150 `OrderedBlock` messages with:
   - Valid block structure (proper chaining, matching IDs)
   - **Forged signatures in `ordered_proof`** (invalid BLS signatures)
   - Valid epoch/round numbers
3. Attacker sends these blocks WITHOUT sending corresponding `BlockPayload` messages
4. Observer stores all 150 blocks in pending store (passes `verify_ordered_blocks` but not proof verification)
5. When legitimate block #151 arrives, garbage collection evicts block #1 (may be legitimate)
6. Legitimate blocks continue being evicted as attacker sends more invalid blocks
7. Observer misses consensus updates, eventually falls back to state sync

**Rust Test Outline:**

```rust
#[test]
fn test_unverified_blocks_dos_attack() {
    // Setup: Create consensus observer with max_num_pending_blocks = 10
    let observer = create_consensus_observer(10);
    
    // Attacker: Create 10 blocks with valid structure but FORGED proofs
    for i in 0..10 {
        let malicious_block = create_block_with_invalid_proof(epoch, round + i);
        // Send block WITHOUT sending payloads
        observer.process_network_message(malicious_block).await;
    }
    
    // Verify: Pending store is full of unverified blocks
    assert_eq!(observer.pending_block_count(), 10);
    
    // Attack impact: Legitimate block gets evicted
    let legitimate_block = create_valid_block(epoch, round + 10);
    observer.process_network_message(legitimate_block).await;
    
    // First malicious block was evicted instead of being rejected
    assert_eq!(observer.pending_block_count(), 10);
    // Observer missed legitimate consensus data
}
```

The vulnerability is confirmed by the code structure where proof verification is deferred until after storage, allowing unverified blocks to consume critical resources.

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L225-266)
```rust
    /// Verifies the ordered blocks and returns an error if the data is invalid.
    /// Note: this does not check the ordered proof.
    pub fn verify_ordered_blocks(&self) -> Result<(), Error> {
        // Verify that we have at least one ordered block
        if self.blocks.is_empty() {
            return Err(Error::InvalidMessageError(
                "Received empty ordered block!".to_string(),
            ));
        }

        // Verify the last block ID matches the ordered proof block ID
        if self.last_block().id() != self.proof_block_info().id() {
            return Err(Error::InvalidMessageError(
                format!(
                    "Last ordered block ID does not match the ordered proof ID! Number of blocks: {:?}, Last ordered block ID: {:?}, Ordered proof ID: {:?}",
                    self.blocks.len(),
                    self.last_block().id(),
                    self.proof_block_info().id()
                )
            ));
        }

        // Verify the blocks are correctly chained together (from the last block to the first)
        let mut expected_parent_id = None;
        for block in self.blocks.iter().rev() {
            if let Some(expected_parent_id) = expected_parent_id {
                if block.id() != expected_parent_id {
                    return Err(Error::InvalidMessageError(
                        format!(
                            "Block parent ID does not match the expected parent ID! Block ID: {:?}, Expected parent ID: {:?}",
                            block.id(),
                            expected_parent_id
                        )
                    ));
                }
            }

            expected_parent_id = Some(block.parent_id());
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L268-277)
```rust
    /// Verifies the ordered proof and returns an error if the proof is invalid
    pub fn verify_ordered_proof(&self, epoch_state: &EpochState) -> Result<(), Error> {
        epoch_state.verify(&self.ordered_proof).map_err(|error| {
            Error::InvalidMessageError(format!(
                "Failed to verify ordered proof ledger info: {:?}, Error: {:?}",
                self.proof_block_info(),
                error
            ))
        })
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L191-199)
```rust
        if let Err(error) = self.observer_fallback_manager.check_syncing_progress() {
            // Log the error and enter fallback mode
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to make syncing progress! Entering fallback mode! Error: {:?}",
                    error
                ))
            );
            self.enter_fallback_mode().await;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L578-594)
```rust
        // Verify the message is from the peers we've subscribed to
        if let Err(error) = self
            .subscription_manager
            .verify_message_for_subscription(peer_network_id)
        {
            // Update the rejected message counter
            increment_rejected_message_counter(&peer_network_id, &message);

            // Log the error and return
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received message that was not from an active subscription! Error: {:?}",
                    error,
                ))
            );
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L696-713)
```rust
        // Create a new pending block with metadata
        let observed_ordered_block = ObservedOrderedBlock::new(ordered_block);
        let pending_block_with_metadata = PendingBlockWithMetadata::new_with_arc(
            peer_network_id,
            message_received_time,
            observed_ordered_block,
        );

        // If all payloads exist, process the block. Otherwise, store it
        // in the pending block store and wait for the payloads to arrive.
        if self.all_payloads_exist(pending_block_with_metadata.ordered_block().blocks()) {
            self.process_ordered_block(pending_block_with_metadata)
                .await;
        } else {
            self.observer_block_data
                .lock()
                .insert_pending_block(pending_block_with_metadata);
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L727-742)
```rust
        // Verify the ordered block proof
        let epoch_state = self.get_epoch_state();
        if ordered_block.proof_block_info().epoch() == epoch_state.epoch {
            if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify ordered proof! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        ordered_block.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/execution_pool.rs (L10-28)
```rust
/// A simple enum wrapper that holds an observed ordered block, allowing
/// self-contained ordered blocks and ordered blocks with execution pool windows.
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum ObservedOrderedBlock {
    Ordered(OrderedBlock),
    OrderedWithWindow(OrderedBlockWithWindow),
}

impl ObservedOrderedBlock {
    /// Creates a new observed ordered block
    pub fn new(ordered_block: OrderedBlock) -> Self {
        Self::Ordered(ordered_block)
    }

    /// Creates a new observed ordered block with window
    pub fn new_with_window(ordered_block_with_window: OrderedBlockWithWindow) -> Self {
        Self::OrderedWithWindow(ordered_block_with_window)
    }

```

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L156-195)
```rust
    /// Garbage collects the pending blocks store by removing
    /// the oldest blocks if the store is too large.
    fn garbage_collect_pending_blocks(&mut self) {
        // Verify that both stores have the same number of entries.
        // If not, log an error as this should never happen.
        let num_pending_blocks = self.blocks_without_payloads.len() as u64;
        let num_pending_blocks_by_hash = self.blocks_without_payloads_by_hash.len() as u64;
        if num_pending_blocks != num_pending_blocks_by_hash {
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "The pending block stores have different numbers of entries: {} and {} (by hash)",
                    num_pending_blocks, num_pending_blocks_by_hash
                ))
            );
        }

        // Calculate the number of blocks to remove
        let max_pending_blocks = self.consensus_observer_config.max_num_pending_blocks;
        let num_blocks_to_remove = num_pending_blocks.saturating_sub(max_pending_blocks);

        // Remove the oldest blocks if the store is too large
        for _ in 0..num_blocks_to_remove {
            if let Some((oldest_epoch_round, pending_block)) =
                self.blocks_without_payloads.pop_first()
            {
                // Log a warning message for the removed block
                warn!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "The pending block store is too large: {:?} blocks. Removing the block for the oldest epoch and round: {:?}",
                        num_pending_blocks, oldest_epoch_round
                    ))
                );

                // Remove the block from the hash store
                let first_block = pending_block.ordered_block().first_block();
                self.blocks_without_payloads_by_hash
                    .remove(&first_block.id());
            }
        }
    }
```

**File:** config/src/config/consensus_observer_config.rs (L72-72)
```rust
            max_num_pending_blocks: 150, // 150 blocks (sufficient for existing production networks)
```
