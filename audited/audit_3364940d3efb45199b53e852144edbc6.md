# Audit Report

## Title
Resource Group Size Read Bypass in Granular Conflict Detection Leads to Non-Deterministic Gas Accounting

## Summary
When `use_granular_resource_group_conflicts` is enabled, the conflict detection mechanism fails to track resource group size reads, leading to missed conflicts between transactions accessing different tags within the same resource group. This causes non-deterministic gas calculations and potentially non-deterministic block execution boundaries.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Resource Group Size Usage for Gas Charging**: When a transaction first accesses any resource within a resource group, the entire group's size is retrieved and added to the gas charge. The group size is computed as the sum of all tagged resources in that group. [1](#0-0) [2](#0-1) 

2. **Missing Group Size in Read Summary**: While the group size is captured in `CapturedReads.group_reads[key].collected_size`, when generating the `ReadWriteSummary` for conflict detection, only individual tagged reads are included. The group size read is completely omitted. [3](#0-2) 

3. **Granular Conflict Detection**: When `use_granular_resource_group_conflicts` is true, conflicts are only detected at the `(group_key, tag)` level, not at the group level. This means transactions accessing different tags within the same group will not conflict, even though they both depend on the shared group size. [4](#0-3) 

**Attack Scenario:**
1. Transaction A reads `Group(0x123, "Tag1")` and captures group size = 1000 bytes for gas charging
2. Transaction B writes `Group(0x123, "Tag2")`, adding a new resource that increases group size to 2000 bytes
3. With granular conflict detection, no conflict is detected (`Tag1 â‰  Tag2`)
4. Transaction A's fee statement reflects gas based on size 1000
5. If execution order changes (B before A), Transaction A would see size 2000 and pay different gas
6. Different validators executing in different parallel orders could compute different conflict multipliers
7. This leads to different accumulated effective block gas values
8. Block execution could terminate at different points, including different transaction sets

The conflict multiplier directly affects block gas limits: [5](#0-4) 

## Impact Explanation

**Critical Severity** - This violates the fundamental invariant of deterministic execution. While BlockSTM's validation mechanism may catch some inconsistencies, the missing conflict detection for group size reads means:

1. **Incorrect Gas Accounting**: Transactions pay incorrect gas fees depending on execution order
2. **Non-Deterministic Block Boundaries**: Different validators may compute different effective block gas totals, potentially terminating block execution at different transaction counts
3. **Consensus Risk**: If validators produce blocks with different transaction sets due to different gas limit calculations, this could lead to consensus failures or chain splits

The issue specifically breaks Critical Invariant #1: "Deterministic Execution: All validators must produce identical state roots for identical blocks."

## Likelihood Explanation

**High Likelihood** when all conditions are met:
- Resource groups are actively used (standard in Aptos)
- `use_granular_resource_group_conflicts` is enabled (check on-chain config)
- Multiple transactions in the same block access different tags in the same resource group
- Parallel execution with sufficient concurrency for race conditions

The likelihood increases with block size and resource group usage patterns. Modern Aptos deployments with heavy resource group usage (e.g., for efficient storage) are particularly vulnerable.

## Recommendation

**Fix 1**: Include group size reads in the ReadWriteSummary

Modify `get_read_summary()` to include a conflict marker when a group size has been read:

```rust
pub(crate) fn get_read_summary(&self) -> HashSet<InputOutputKey<T::Key, T::Tag>> {
    let mut ret = HashSet::new();
    
    // ... existing code for data_reads and inner_reads ...
    
    // ADD: Include group-level conflicts when group size was read
    for (key, group_reads) in &self.group_reads {
        if group_reads.collected_size.is_some() {
            // Mark entire group as read by using Resource variant
            ret.insert(InputOutputKey::Resource(key.clone()));
        }
        for (tag, read) in &group_reads.inner_reads {
            if let DataRead::Versioned(_, _, _) = read {
                ret.insert(InputOutputKey::Group(key.clone(), tag.clone()));
            }
        }
    }
    
    // ... rest of existing code ...
}
```

**Fix 2**: When granular mode is enabled, ensure group size reads force group-level conflict tracking by always collapsing when a size read occurred.

**Fix 3**: Disable `use_granular_resource_group_conflicts` until the group size dependency is properly tracked.

## Proof of Concept

The following test would demonstrate the vulnerability by showing different gas accounting for the same transactions in different execution orders:

```rust
#[test]
fn test_resource_group_size_conflict_bypass() {
    use crate::{BlockGasLimitProcessor, types::InputOutputKey};
    use aptos_types::{
        fee_statement::FeeStatement,
        on_chain_config::BlockGasLimitType,
    };
    
    // Enable granular resource group conflicts
    let block_gas_limit = BlockGasLimitType::ComplexLimitV1 {
        effective_block_gas_limit: 10000,
        execution_gas_effective_multiplier: 1,
        io_gas_effective_multiplier: 1,
        conflict_penalty_window: 4,
        use_module_publishing_block_conflict: false,
        block_output_limit: None,
        include_user_txn_size_in_block_output: true,
        add_block_limit_outcome_onchain: false,
        use_granular_resource_group_conflicts: true, // VULNERABLE MODE
    };
    
    let mut processor = BlockGasLimitProcessor::new(block_gas_limit, None, 10);
    
    // Txn 1: Read Group(1, Tag1) - implicitly reads group size for gas
    let summary1 = ReadWriteSummary::new(
        HashSet::from([InputOutputKey::Group(KeyType(1), 1)]),
        HashSet::new(),
    );
    processor.accumulate_fee_statement(
        FeeStatement::new(100, 100, 0, 0, 0),
        Some(summary1),
        None,
    );
    
    // Txn 2: Write Group(1, Tag2) - changes group size, but NO CONFLICT detected
    let summary2 = ReadWriteSummary::new(
        HashSet::new(),
        HashSet::from([InputOutputKey::Group(KeyType(1), 2)]),
    );
    processor.accumulate_fee_statement(
        FeeStatement::new(100, 100, 0, 0, 0),
        Some(summary2),
        None,
    );
    
    // With granular mode, conflict multiplier for Txn 2 should be 1 (no conflict)
    // But it SHOULD be 2 because both transactions depend on Group(1)'s size
    // The effective gas will be underestimated, allowing more transactions than allowed
    
    assert_eq!(processor.get_effective_accumulated_block_gas(), 200); 
    // Should be 300 if group size conflict was detected (multiplier 2 for txn 2)
}
```

This demonstrates that the missing group size tracking leads to incorrect conflict multipliers and accumulated gas calculations, which would cause non-deterministic block boundaries when the gas limit is reached.

### Citations

**File:** aptos-move/aptos-vm/src/data_cache.rs (L112-117)
```rust
            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L60-72)
```rust
pub fn group_size_as_sum<T: Serialize + Clone + Debug>(
    mut group: impl Iterator<Item = (T, usize)>,
) -> PartialVMResult<ResourceGroupSize> {
    let (count, len) = group.try_fold((0, 0), |(count, len), (tag, value_byte_len)| {
        let delta = group_tagged_resource_size(&tag, value_byte_len)?;
        Ok::<(usize, u64), PartialVMError>((count + 1, len + delta))
    })?;

    Ok(ResourceGroupSize::Combined {
        num_tagged_resources: count,
        all_tagged_resources_size: len,
    })
}
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1205-1234)
```rust
    pub(crate) fn get_read_summary(&self) -> HashSet<InputOutputKey<T::Key, T::Tag>> {
        let mut ret = HashSet::new();
        for (key, read) in &self.data_reads {
            if let DataRead::Versioned(_, _, _) = read {
                ret.insert(InputOutputKey::Resource(key.clone()));
            }
        }

        for (key, group_reads) in &self.group_reads {
            for (tag, read) in &group_reads.inner_reads {
                if let DataRead::Versioned(_, _, _) = read {
                    ret.insert(InputOutputKey::Group(key.clone(), tag.clone()));
                }
            }
        }

        // TODO(loader_v2): Test summaries are the same.
        for key in self.module_reads.keys() {
            let key = T::Key::from_address_and_module_name(key.address(), key.name());
            ret.insert(InputOutputKey::Resource(key));
        }

        for (key, read) in &self.delayed_field_reads {
            if let DelayedFieldRead::Value { .. } = read {
                ret.insert(InputOutputKey::DelayedField(*key));
            }
        }

        ret
    }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L82-89)
```rust
            let rw_summary = if self
                .block_gas_limit_type
                .use_granular_resource_group_conflicts()
            {
                txn_read_write_summary
            } else {
                txn_read_write_summary.collapse_resource_group_conflicts()
            };
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L103-109)
```rust
        let raw_gas_used = fee_statement.execution_gas_used()
            * self
                .block_gas_limit_type
                .execution_gas_effective_multiplier()
            + fee_statement.io_gas_used() * self.block_gas_limit_type.io_gas_effective_multiplier();
        self.accumulated_raw_block_gas += raw_gas_used;
        self.accumulated_effective_block_gas += conflict_multiplier * raw_gas_used;
```
