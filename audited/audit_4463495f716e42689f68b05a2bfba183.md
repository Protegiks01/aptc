# Audit Report

## Title
Unauthenticated Validator Identity Exposure Enables Operator Privacy Violation and Targeted Network Attacks

## Summary
The Aptos inspection service exposes validator peer IDs (which are validator account addresses) through an unauthenticated HTTP endpoint that binds to `0.0.0.0:9101` by default. This endpoint is enabled by default (`expose_identity_information: true`) and lacks any configuration sanitizer to prevent mainnet validators from exposing this information. This allows attackers to directly correlate validator node IP addresses with their on-chain identities, enabling targeted network attacks and compromising operator privacy.

## Finding Description
The inspection service implements an `/identity_information` endpoint that exposes a validator's peer ID without authentication. [1](#0-0) 

The peer ID is directly derived from the validator's account address - they are equivalent identifiers. [2](#0-1) 

The inspection service configuration defaults to exposing this information with no authentication. [3](#0-2) 

Critically, while there is a configuration sanitizer that prevents mainnet validators from exposing node configuration, **it does not check whether identity information is exposed**: [4](#0-3) 

The server binds to all network interfaces by default and has no authentication mechanism. [5](#0-4) 

**Attack Flow:**
1. Attacker scans IP ranges on port 9101
2. Queries `http://<target-ip>:9101/identity_information` 
3. Receives peer_id (validator account address) in plaintext
4. Correlates the actual server IP with the validator's on-chain identity
5. Uses this to identify physical location, operator identity, and infrastructure details

While validator network addresses are published on-chain in the ValidatorSet, those addresses may be proxies, load balancers, or VPN endpoints. The inspection service runs on the **actual validator node**, enabling attackers to bypass these privacy protections and identify the real infrastructure.

## Impact Explanation
This constitutes a **High severity** operator privacy violation according to the security question classification. The impact includes:

1. **Physical Security Risk**: Attackers can geolocate actual validator node IPs to approximate physical datacenter locations, enabling physical security threats
2. **Targeted Network Attacks**: Enables precise DDoS targeting of specific validators' actual infrastructure, bypassing proxy protections
3. **Operational Security Compromise**: Exposes real validator infrastructure topology that operators intentionally obscure using network architecture
4. **Correlation with PII**: IP addresses can be reverse-resolved to ISPs, datacenters, and corporate networks, potentially identifying operator organizations

The Aptos bug bounty categories list this as a privacy violation with operational security implications. While not directly causing fund loss or consensus failure, it enables targeted attacks that could lead to such outcomes.

## Likelihood Explanation
**Likelihood: High**

1. The endpoint is **enabled by default** on all node types
2. No authentication is required - endpoint is publicly accessible
3. Default configuration templates do not disable this endpoint [6](#0-5) 
4. No configuration sanitizer prevents mainnet validators from exposure
5. Attack requires only basic HTTP requests and IP scanning
6. Most validator operators likely unaware of this exposure

This is not a theoretical issue - any validator operator who has not explicitly set `expose_identity_information: false` in their configuration is currently exposing this information.

## Recommendation
**Immediate Fix:**

1. Add a configuration sanitizer check for mainnet validators:

```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                // Verify that mainnet validators do not expose configuration
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                
                // ADD THIS CHECK: Verify that mainnet validators do not expose identity information
                if inspection_service_config.expose_identity_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose identity information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

2. Change the default for production environments:
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(),  // Bind to localhost only by default
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false,  // Disable by default
            expose_peer_information: false,
            expose_system_information: false,
        }
    }
}
```

3. Add authentication mechanism similar to the admin service
4. Document security implications clearly in operator guides

## Proof of Concept

**Step 1: Query an Aptos validator node's inspection service**
```bash
# Scan for exposed inspection service
curl http://<validator-ip>:9101/identity_information

# Expected output (if exposed):
# Identity Information:
#   - Validator network (Validator), peer ID: 0xabcd1234...
#   - Fullnode network (vfn), peer ID: 0xabcd1234...
```

**Step 2: Correlate with on-chain data**
```bash
# Query on-chain validator set
curl -X POST https://fullnode.mainnet.aptoslabs.com/v1 \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "aptos_getResource",
    "params": ["0x1", "ValidatorSet"],
    "id": 1
  }'

# Match the peer_id from Step 1 with the on-chain validator data
# Now attacker knows: This IP address = This specific validator account
```

**Step 3: Demonstrate privacy violation**
```bash
# Geolocate the actual validator infrastructure
whois <validator-ip>
# Perform reverse DNS lookup
dig -x <validator-ip>
# Identify datacenter, ISP, or corporate network
# This reveals operator identity and physical location
```

This PoC demonstrates that an unprivileged attacker can map validator account addresses to their actual server IP addresses, bypassing any proxy or privacy protections operators have implemented at the network level.

## Notes

The vulnerability exists due to three compounding factors:
1. Default configuration enables the endpoint
2. No authentication protects the endpoint  
3. No configuration sanitizer prevents mainnet validators from exposure

While validator network addresses are published on-chain for P2P connectivity, operators may use various privacy-preserving techniques (proxies, VPNs, load balancers, anycast addresses). The inspection service bypasses these protections by running on the actual validator node and revealing its identity directly.

### Citations

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L29-51)
```rust
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
```

**File:** network/discovery/src/validator_set.rs (L118-118)
```rust
            let peer_id = *info.account_address();
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L45-69)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L50-101)
```rust
pub fn start_inspection_service(
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) {
    // Fetch the service port and address
    let service_port = node_config.inspection_service.port;
    let service_address = node_config.inspection_service.address.clone();

    // Create the inspection service socket address
    let address: SocketAddr = (service_address.as_str(), service_port)
        .to_socket_addrs()
        .unwrap_or_else(|_| {
            panic!(
                "Failed to parse {}:{} as address",
                service_address, service_port
            )
        })
        .next()
        .unwrap();

    // Create a runtime for the inspection service
    let runtime = aptos_runtimes::spawn_named_runtime("inspection".into(), None);

    // Spawn the inspection service
    thread::spawn(move || {
        // Create the service function that handles the endpoint requests
        let make_service = make_service_fn(move |_conn| {
            let node_config = node_config.clone();
            let aptos_data_client = aptos_data_client.clone();
            let peers_and_metadata = peers_and_metadata.clone();
            async move {
                Ok::<_, Infallible>(service_fn(move |request| {
                    serve_requests(
                        request,
                        node_config.clone(),
                        aptos_data_client.clone(),
                        peers_and_metadata.clone(),
                    )
                }))
            }
        });

        // Start and block on the server
        runtime
            .block_on(async {
                let server = Server::bind(&address).serve(make_service);
                server.await
            })
            .unwrap();
    });
}
```

**File:** config/src/config/test_data/validator.yaml (L1-81)
```yaml
base:
    data_dir: "/opt/aptos/data"
    role: "validator"
    waypoint:
        from_storage:
            type: "vault"
            server: "https://127.0.0.1:8200"
            ca_certificate: "/full/path/to/certificate"
            token:
                from_disk: "/full/path/to/token"

consensus:
    safety_rules:
        service:
            type: process
            server_address: "/ip4/127.0.0.1/tcp/5555"

execution:
    genesis_file_location: "relative/path/to/genesis"

# For validator node we setup two networks, validator_network to allow validator connect to each other,
# and full_node_networks to allow fullnode connects to validator.

full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
      max_outbound_connections: 0
      identity:
          type: "from_storage"
          key_name: "fullnode_network"
          peer_id_name: "owner_account"
          backend:
              type: "vault"
              server: "https://127.0.0.1:8200"
              ca_certificate: "/full/path/to/certificate"
              token:
                  from_disk: "/full/path/to/token"
      network_id:
          private: "vfn"

validator_network:
    discovery_method: "onchain"
    listen_address: "/ip4/0.0.0.0/tcp/6180"
    identity:
        type: "from_storage"
        key_name: "validator_network"
        peer_id_name: "owner_account"
        backend:
            type: "vault"
            server: "https://127.0.0.1:8200"
            ca_certificate: "/full/path/to/certificate"
            token:
                from_disk: "/full/path/to/token"
    network_id: "validator"
    ### Load keys from file
    # identity:
    #     type: "from_file"
    #     path: /full/path/to/private-keys.yml
    #
    ### Load keys from secure storage service like vault:
    #
    # identity:
    #     type: "from_storage"
    #     key_name: "validator_network"
    #     peer_id_name: "owner_account"
    #     backend:
    #         type: "vault"
    #         server: "https://127.0.0.1:8200"
    #         ca_certificate: "/full/path/to/certificate"
    #         token:
    #             from_disk: "/full/path/to/token"
    #
    ### Load keys directly from config
    #
    # identity:
    #     type: "from_config"
    #     key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
    #     peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"
    mutual_authentication: true
    max_frame_size: 4194304 # 4 MiB
api:
    enabled: true
```
