# Audit Report

## Title
Path Traversal Vulnerability in Backup Restore Operations Allows Arbitrary File Read/Write on Validator Nodes

## Summary
The `LocalFs` backup storage implementation lacks path validation when handling `FileHandle` references from backup manifests. An attacker who can influence backup manifests can craft malicious `FileHandle` values containing path traversal sequences (e.g., `../../etc/passwd`) to read or write arbitrary files on the validator node during restore operations. [1](#0-0) 

## Finding Description
The vulnerability exists in the backup/restore system's file handling logic. When a validator operator performs a restore operation, backup manifests are loaded and deserialized without validating the `FileHandle` fields they contain. These handles are then used directly in file operations.

The attack flow is:

1. **Manifest Deserialization**: Transaction backup manifests contain `FileHandle` strings pointing to chunk data files: [2](#0-1) 

2. **No Validation**: The `FileHandle` type is just a string alias with no validation: [3](#0-2) 

3. **Vulnerable File Operations**: During restore, the `LocalFs::open_for_read()` method joins the base directory with the unvalidated file handle: [1](#0-0) 

When Rust's `PathBuf::join()` is used with a relative path containing `..` components, and then the resulting path is opened by the OS, the parent directory references are resolved. This allows escaping the intended backup directory.

4. **Restore Process**: The restore controller loads manifests and uses the FileHandles: [4](#0-3) 

An attacker who can control backup manifest content can inject malicious FileHandles like:
- `"../../etc/shadow"` - read system password hashes
- `"../../root/.ssh/id_rsa"` - steal SSH private keys  
- `"../../var/aptos/validator-keys/validator.key"` - steal validator signing keys
- `"../../aptos-data/secure-storage/keys"` - steal validator consensus keys

The write path through `create_for_write()` is partially protected by `ShellSafeName` validation for new backups, but the read path has no such protection: [5](#0-4) 

## Impact Explanation
**Severity: High** 

This vulnerability enables:

1. **Arbitrary File Read**: Read any file accessible to the validator process user, including:
   - Validator private keys and consensus keys
   - Node configuration files containing secrets
   - System files like `/etc/shadow`
   - Database files and state data

2. **Potential Arbitrary File Write**: While write operations have some protections, carefully crafted backup operations could potentially write to arbitrary locations

3. **Validator Compromise**: Stealing validator keys allows an attacker to:
   - Sign malicious blocks
   - Participate in consensus with the stolen identity
   - Potentially cause safety violations if combined with other attacks

This meets the **High Severity** criteria per the Aptos bug bounty:
- "Significant protocol violations" - compromised validator keys enable consensus attacks
- Potential "Validator node slowdowns" if critical files are corrupted
- Could escalate to Critical if it leads to consensus safety violations

## Likelihood Explanation
**Likelihood: Medium**

The attack requires:

1. **Attacker Prerequisites**:
   - Ability to write/modify backup manifests in the backup storage location
   - This could occur through:
     - Compromised backup storage credentials
     - Misconfigured cloud storage bucket permissions
     - Man-in-the-middle attacks on backup storage communication
     - Compromised backup infrastructure

2. **Operator Action Required**:
   - Validator operator must initiate a restore operation from the compromised backup
   - This is a routine operation during disaster recovery, node migration, or state sync

3. **Real-World Scenarios**:
   - Validators using shared backup infrastructure (e.g., common S3 bucket with weak IAM policies)
   - Backup-as-a-Service providers with security vulnerabilities
   - Supply chain attacks on backup tools/infrastructure
   - Insider threats with backup storage access

While backup storage is typically "trusted," defense-in-depth principles require validation even for trusted inputs. The lack of path validation violates secure coding best practices.

## Recommendation

Implement strict path validation for all `FileHandle` values before using them in file operations:

```rust
// In storage/backup/backup-cli/src/storage/local_fs/mod.rs

impl LocalFs {
    // Add validation method
    fn validate_file_handle(&self, file_handle: &FileHandleRef) -> Result<PathBuf> {
        let path = self.dir.join(file_handle);
        
        // Canonicalize to resolve any .. components and symlinks
        let canonical_path = path.canonicalize()
            .map_err(|e| anyhow!("Invalid file handle '{}': {}", file_handle, e))?;
        
        // Ensure the canonical path is still within self.dir
        let canonical_base = self.dir.canonicalize()
            .map_err(|e| anyhow!("Invalid base directory: {}", e))?;
        
        if !canonical_path.starts_with(&canonical_base) {
            bail!("Path traversal detected in file handle: {}", file_handle);
        }
        
        Ok(canonical_path)
    }
}

// Update open_for_read
async fn open_for_read(
    &self,
    file_handle: &FileHandleRef,
) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
    let path = self.validate_file_handle(file_handle)?;  // Validate first
    let file = OpenOptions::new()
        .read(true)
        .open(&path)
        .await
        .err_notes(&path)?;
    Ok(Box::new(file))
}

// Update create_for_write similarly
async fn create_for_write(
    &self,
    backup_handle: &BackupHandleRef,
    name: &ShellSafeName,
) -> Result<(FileHandle, Box<dyn AsyncWrite + Send + Unpin>)> {
    let file_handle = Path::new(backup_handle)
        .join(name.as_ref())
        .path_to_string()?;
    let abs_path = self.validate_file_handle(&file_handle)?;  // Validate
    // ... rest of implementation
}
```

Additionally, consider:
1. **Input Sanitization**: Reject FileHandles containing `..`, absolute paths, or suspicious patterns during manifest deserialization
2. **Chroot/Sandbox**: Run restore operations in a restricted environment
3. **Audit Logging**: Log all file operations during restore for security monitoring
4. **Manifest Signing**: Cryptographically sign manifests to detect tampering

## Proof of Concept

```rust
// Test demonstrating path traversal vulnerability
// Add to storage/backup/backup-cli/src/storage/local_fs/tests.rs

#[tokio::test]
async fn test_path_traversal_vulnerability() {
    use tempfile::TempDir;
    use std::fs;
    
    // Create temporary directories
    let backup_dir = TempDir::new().unwrap();
    let sensitive_dir = TempDir::new().unwrap();
    
    // Create a sensitive file outside backup directory
    let sensitive_file = sensitive_dir.path().join("secret.key");
    fs::write(&sensitive_file, b"VALIDATOR_PRIVATE_KEY").unwrap();
    
    // Create LocalFs storage pointing to backup directory
    let storage = LocalFs::new(backup_dir.path().to_path_buf());
    
    // Craft malicious file handle with path traversal
    // Calculate relative path from backup_dir to sensitive_file
    let relative_path = pathdiff::diff_paths(&sensitive_file, backup_dir.path())
        .unwrap();
    let malicious_handle = relative_path.to_str().unwrap();
    
    // Attempt to read sensitive file via path traversal
    let result = storage.open_for_read(malicious_handle).await;
    
    // VULNERABILITY: This succeeds and reads the sensitive file
    assert!(result.is_ok(), "Path traversal should be blocked but isn't");
    
    if let Ok(mut file) = result {
        let mut contents = Vec::new();
        use tokio::io::AsyncReadExt;
        file.read_to_end(&mut contents).await.unwrap();
        assert_eq!(contents, b"VALIDATOR_PRIVATE_KEY");
        println!("EXPLOIT SUCCESS: Read sensitive file via path traversal!");
    }
}

// Complete attack simulation
#[tokio::test]
async fn test_malicious_manifest_attack() {
    use serde_json;
    
    // Create malicious manifest with path traversal
    let malicious_manifest = r#"{
        "first_version": 0,
        "last_version": 100,
        "chunks": [{
            "first_version": 0,
            "last_version": 100,
            "transactions": "../../etc/passwd",
            "proof": "../../root/.ssh/id_rsa",
            "format": "V1"
        }]
    }"#;
    
    // Deserialize manifest (no validation occurs)
    let manifest: TransactionBackup = serde_json::from_str(malicious_manifest).unwrap();
    
    // The malicious paths are now in the manifest
    assert_eq!(manifest.chunks[0].transactions, "../../etc/passwd");
    
    println!("VULNERABILITY CONFIRMED: Malicious manifest accepted without validation");
}
```

**Notes:**
- The vulnerability exists because `FileHandle` is treated as a trusted value, but manifests can be influenced by attackers with backup storage access
- The `ShellSafeName` validation only applies to backup/file names during creation, not to FileHandles used during restore
- Path canonicalization must happen before opening files to prevent TOCTOU issues
- This affects all validator nodes that perform restore operations from potentially compromised backup sources

### Citations

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L80-96)
```rust
    async fn create_for_write(
        &self,
        backup_handle: &BackupHandleRef,
        name: &ShellSafeName,
    ) -> Result<(FileHandle, Box<dyn AsyncWrite + Send + Unpin>)> {
        let file_handle = Path::new(backup_handle)
            .join(name.as_ref())
            .path_to_string()?;
        let abs_path = self.dir.join(&file_handle).path_to_string()?;
        let file = OpenOptions::new()
            .write(true)
            .create_new(true)
            .open(&abs_path)
            .await
            .err_notes(&abs_path)?;
        Ok((file_handle, Box::new(file)))
    }
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L19-34)
```rust
#[derive(Clone, Deserialize, Serialize, Debug)]
pub struct TransactionChunk {
    pub first_version: Version,
    pub last_version: Version,
    /// Repeated `len(record) + record`, where `record` is BCS serialized tuple
    /// `(Transaction, TransactionInfo)`
    pub transactions: FileHandle,
    /// BCS serialized `(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)`.
    /// The `TransactionAccumulatorRangeProof` links the transactions to the
    /// `LedgerInfoWithSignatures`, and the `LedgerInfoWithSignatures` can be verified by the
    /// signatures it carries, against the validator set in the epoch. (Hence proper
    /// `EpochEndingBackup` is needed for verification.)
    pub proof: FileHandle,
    #[serde(default = "default_to_v0")]
    pub format: TransactionChunkFormat,
}
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L36-41)
```rust
/// URI pointing to a file in a backup storage, like "s3:///bucket/path/file".
/// These are created by the storage when `create_for_write()`, stored in manifests by the backup
/// controller, and passed back to the storage when `open_for_read()` by the restore controller
/// to retrieve a file referred to in the manifest.
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L100-109)
```rust
    async fn load(
        manifest: TransactionChunk,
        storage: &Arc<dyn BackupStorage>,
        epoch_history: Option<&Arc<EpochHistory>>,
    ) -> Result<Self> {
        let mut file = BufReader::new(storage.open_for_read(&manifest.transactions).await?);
        let mut txns = Vec::new();
        let mut persisted_aux_info = Vec::new();
        let mut txn_infos = Vec::new();
        let mut event_vecs = Vec::new();
```
