# Audit Report

## Title
Consensus Observer State Sync Deadlock on Permanent Failures

## Summary
The Consensus Observer's state sync manager does not properly handle permanent state sync failures, causing validators to enter an unrecoverable deadlock state where they indefinitely wait for sync operations that have already failed and will never complete.

## Finding Description

The vulnerability occurs in the interaction between `StateSyncManager` and `ConsensusObserver` when handling state sync failures.

The `StateSyncError` type is a transparent wrapper around `anyhow::Error` that does not distinguish between transient and permanent failures: [1](#0-0) 

When state sync operations fail in spawned tasks, the error is logged and the task exits without sending a notification:
- For fallback sync: [2](#0-1) 
- For commit sync: [3](#0-2) 

However, the sync handles (`fallback_sync_handle` or `sync_to_commit_handle`) remain set because they were initialized when the sync started: [4](#0-3) [5](#0-4) 

These handles are only cleared when success notifications are received: [6](#0-5) [7](#0-6) 

The consensus observer's progress check becomes permanently stuck because when handles remain set, the check methods return early without verifying actual progress: [8](#0-7) [9](#0-8) 

The handle check methods simply verify if handles exist: [10](#0-9) [11](#0-10) 

Permanent failures exist in the state sync driver, such as `OldSyncRequest`: [12](#0-11)  which is returned when the sync target is already committed: [13](#0-12) 

The progress check runs on a regular interval: [14](#0-13) [15](#0-14)  but cannot detect the stuck state due to the early returns.

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" under the Aptos bug bounty criteria:

- **Validator Liveness Failure**: Affected validators cannot participate in consensus, reducing network security margins
- **Requires Manual Intervention**: Only a node restart can recover from this state
- **Cascading Failures**: If multiple validators encounter the same missing blocks or permanent failures simultaneously, network liveness degrades
- **No Consensus Safety Impact**: Does not cause chain splits or double-spending
- **Resource Consumption**: Validator remains in stuck state consuming resources without contributing to consensus

## Likelihood Explanation

**High Likelihood**:

- **Natural Occurrence**: Can be triggered by legitimate network conditions (validators falling behind, blocks being pruned, network partitions)
- **No Malicious Intent Required**: Happens without attacker action when permanent sync failures occur
- **Common Scenarios**: 
  - Validator receives sync target for already-committed version (OldSyncRequest error)
  - Missing blocks that peers cannot provide
  - Database corruption or storage errors during sync
- **Detection Difficulty**: Validator operators may not immediately notice the stuck state as the node appears to be "syncing"

## Recommendation

Add error handling to detect sync task failures and clear handles appropriately:

1. Modify the spawned sync tasks to send failure notifications in addition to success notifications
2. Add a timeout mechanism to detect when sync tasks have been running too long without progress
3. Implement a watchdog that periodically checks if handles are set but no actual sync progress is occurring
4. On detecting a failed sync, clear the handle and optionally retry with exponential backoff

The fix should ensure that when a sync task fails, the `StateSyncManager` is notified and can clear the appropriate handle, allowing the consensus observer to resume normal progress checks.

## Proof of Concept

A PoC would involve:
1. Starting a consensus observer node
2. Causing it to receive a commit decision for a version it has already committed
3. Observing that the state sync task fails with `OldSyncRequest` error
4. Verifying that the handle remains set and progress checks return early indefinitely
5. Confirming that only a node restart recovers from this state

The vulnerability can be triggered by simulating network conditions where commit decisions arrive out of order or after the node has already advanced past the target version.

**Notes**

This vulnerability affects the consensus observer component specifically, which is enabled on validator fullnodes (VFNs) by default: [16](#0-15) 

The deadlock is permanent because there is no timeout or recovery mechanism in the event loop: [17](#0-16) 

The vulnerability does not affect consensus safety (no chain splits or double-spending) but does impact validator liveness, which is still a valid Medium severity issue under the Aptos bug bounty program.

### Citations

**File:** consensus/src/error.rs (L20-25)
```rust
#[derive(Debug, Error)]
#[error(transparent)]
pub struct StateSyncError {
    #[from]
    inner: anyhow::Error,
}
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L101-103)
```rust
    pub fn in_fallback_mode(&self) -> bool {
        self.fallback_sync_handle.is_some()
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L112-114)
```rust
    pub fn is_syncing_to_commit(&self) -> bool {
        self.sync_to_commit_handle.is_some()
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L156-160)
```rust
                    Err(error) => {
                        error!(LogSchema::new(LogEntry::ConsensusObserver)
                            .message(&format!("Failed to sync for fallback! Error: {:?}", error)));
                        return;
                    },
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L186-186)
```rust
        self.fallback_sync_handle = Some(DropGuard::new(abort_handle));
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L223-230)
```rust
                {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to sync to commit decision: {:?}! Error: {:?}",
                            commit_decision, error
                        ))
                    );
                    return;
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L257-257)
```rust
        self.sync_to_commit_handle = Some((DropGuard::new(abort_handle), epoch_changed));
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L172-177)
```rust
        // If we've fallen back to state sync, we should wait for it to complete
        if self.state_sync_manager.in_fallback_mode() {
            info!(LogSchema::new(LogEntry::ConsensusObserver)
                .message("Waiting for state sync to complete fallback syncing!",));
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L179-188)
```rust
        // If state sync is syncing to a commit decision, we should wait for it to complete
        if self.state_sync_manager.is_syncing_to_commit() {
            info!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Waiting for state sync to reach commit decision: {:?}!",
                    self.observer_block_data.lock().root().commit_info()
                ))
            );
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L964-964)
```rust
        self.state_sync_manager.clear_active_fallback_sync();
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1048-1048)
```rust
        self.state_sync_manager.clear_active_commit_sync();
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1127-1142)
```rust
        loop {
            tokio::select! {
                Some(network_message) = consensus_observer_message_receiver.next() => {
                    self.process_network_message(network_message).await;
                }
                Some(state_sync_notification) = state_sync_notification_listener.recv() => {
                    self.process_state_sync_notification(state_sync_notification).await;
                },
                _ = progress_check_interval.select_next_some() => {
                    self.check_progress().await;
                }
                else => {
                    break; // Exit the consensus observer loop
                }
            }
        }
```

**File:** state-sync/state-sync-driver/src/error.rs (L39-40)
```rust
    #[error("Received an old sync request for version {0}, but our pre-committed version is: {1} and committed version: {2}")]
    OldSyncRequest(Version, Version, Version),
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L276-283)
```rust
        if sync_target_version < latest_committed_version
            || sync_target_version < latest_pre_committed_version
        {
            let error = Err(Error::OldSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
                latest_committed_version,
            ));
```

**File:** config/src/config/consensus_observer_config.rs (L73-73)
```rust
            progress_check_interval_ms: 5_000, // 5 seconds
```

**File:** config/src/config/consensus_observer_config.rs (L119-128)
```rust
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```
