# Audit Report

## Title
Race Condition in JWK Consensus Allows Acceptance of Stale Quorum Certificates Leading to On-Chain State Inconsistency

## Summary
A race condition exists in `KeyLevelConsensusManager` between concurrent certifier task completion and sequential state updates, allowing stale quorum-certified updates to be accepted and committed on-chain when the consensus state has been superseded by a newer observation.

## Finding Description

The vulnerability occurs due to insufficient synchronization between the concurrent `UpdateCertifier` tasks and the `KeyLevelConsensusManager` event loop in the JWK consensus system.

**The Race Condition Flow:**

When `maybe_start_consensus()` is called with a new update, it uses `HashMap::insert()` to store the new `InProgress` state, which unconditionally overwrites any existing entry for the same (issuer, kid) key [1](#0-0) . When the previous `InProgress` state containing a `QuorumCertProcessGuard` is dropped, the guard's Drop implementation automatically calls `abort()` on the certifier task's handle [2](#0-1) .

However, the certifier task runs concurrently in a spawned async task that broadcasts the request, waits for quorum certification, and pushes the resulting `QuorumCertifiedUpdate` to a channel [3](#0-2) . If this task completes and pushes its result to the channel before the abort occurs, the quorum certificate remains in the channel queue.

**Critical Missing Validation:**

The `process_quorum_certified_update()` function only verifies that the consensus state is `InProgress`, but does NOT validate that the received quorum-certified update matches the `my_proposal.observed` value in the current state [4](#0-3) . This allows a quorum certificate for update_A to be accepted even when the current state contains an `InProgress` entry for update_B, creating an inconsistent state where `my_proposal` and `quorum_certified` contain different JWK values.

**Concrete Attack Scenario:**
1. JWKObserver detects JWK value A for (issuer, kid) → starts certifier_A → inserts InProgress_A
2. Certifier_A completes quickly and pushes QC_A to channel
3. Before event loop processes QC_A, JWKObserver detects JWK value B → starts certifier_B → overwrites InProgress_A with InProgress_B
4. Event loop receives QC_A from channel, finds InProgress_B in state map, accepts QC_A without validation
5. System creates `ValidatorTransaction::ObservedJWKUpdate` with stale QC_A and puts it in validator transaction pool
6. QC_A (stale value) gets committed on-chain despite current observed value being B
7. Certifier_B's QC_B is later rejected because state is already Finished

**Result:** The on-chain JWK state contains value A while the consensus state shows value B was proposed, creating a persistent state inconsistency between `my_proposal` and `quorum_certified`.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria:

- **State Inconsistencies Requiring Intervention**: The mismatch between `my_proposal` and `quorum_certified` creates an inconsistent internal state where the validator's current proposal doesn't match what was actually committed on-chain. This violates the state consistency invariant of the JWK consensus system.

- **Authentication/Authorization Impact**: JWKs are used to validate JWTs from OIDC providers for keyless accounts in the Aptos blockchain. A stale or incorrect JWK committed on-chain could cause legitimate authentication attempts to fail (if the stale key is older) or potentially allow invalid JWTs to be accepted (if validators have updated to newer keys but on-chain state is stale).

- **Consensus State Integrity**: The system accepts and commits a quorum certificate that doesn't match what the validator actually proposed in its current state, breaking the fundamental assumption that quorum-certified updates correspond to current validator proposals.

The KLAST channel configuration with capacity 1 per key [5](#0-4)  provides some protection by discarding older messages, but doesn't prevent the race if the event loop processes the stale QC before the newer one arrives in the channel.

## Likelihood Explanation

**Likelihood: Medium**

The race window is narrow (microseconds to milliseconds between certifier completion and state update), but can occur naturally without malicious action when:

1. OIDC providers rotate JWK keys in rapid succession (common during security incidents or planned rotations)
2. Provider endpoints return temporarily inconsistent values during propagation (common with geographically distributed systems)
3. Network conditions cause observation timing to align with certifier task completion
4. The certifier achieves quorum very quickly due to low network latency

The JWKObserver polls OIDC provider endpoints every 10 seconds [6](#0-5) , which provides regular opportunities for the race condition to occur during provider key rotations.

While an attacker cannot directly control OIDC provider responses (providers are trusted external services), the race can occur in production during legitimate key rotations, especially if providers have eventual consistency issues across their infrastructure.

## Recommendation

Add validation in `process_quorum_certified_update()` to verify that the received quorum-certified update matches the current `my_proposal` before accepting it:

```rust
match state {
    ConsensusState::InProgress { my_proposal, .. } => {
        // Extract the key-level update from the QC
        let qc_update = KeyLevelUpdate::try_from_issuer_level_repr(&issuer_level_repr.update)?;
        
        // Validate that the QC matches our current proposal
        if qc_update != my_proposal.observed {
            return Err(anyhow!(
                "Received QC for {:?} but current proposal is {:?}",
                qc_update,
                my_proposal.observed
            ));
        }
        
        // Proceed with accepting the QC
        let topic = Topic::JWK_CONSENSUS_PER_KEY_MODE {
            issuer: issuer.clone(),
            kid: kid.clone(),
        };
        let txn = ValidatorTransaction::ObservedJWKUpdate(issuer_level_repr.clone());
        let vtxn_guard = self.vtxn_pool.put(topic, Arc::new(txn), None);
        *state = ConsensusState::Finished {
            vtxn_guard,
            my_proposal: my_proposal.clone(),
            quorum_certified: issuer_level_repr,
        };
    },
    ...
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod race_condition_test {
    use super::*;
    use aptos_types::jwks::{JWK, KeyLevelUpdate};
    
    #[tokio::test]
    async fn test_stale_qc_acceptance() {
        // 1. Setup: Create KeyLevelConsensusManager with mocked components
        // 2. Observe JWK value A → triggers certifier_A
        // 3. Simulate certifier_A completing and pushing QC_A to channel
        // 4. Observe JWK value B → triggers certifier_B, overwrites state
        // 5. Process QC_A from channel
        // 6. Verify that QC_A is incorrectly accepted despite state now containing proposal B
        // 7. Verify final state has my_proposal=B but quorum_certified=A (inconsistent)
    }
}
```

## Notes

This vulnerability affects the per-key JWK consensus mode in Aptos, which is used when the `JWK_CONSENSUS_PER_KEY_MODE` feature flag is enabled. The issue stems from the event-driven architecture where concurrent certifier tasks can complete and enqueue results before state transitions occur, combined with the lack of validation that received quorum certificates match current proposals. The fix requires adding proper validation to ensure state consistency between proposed and certified updates.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L79-79)
```rust
        let (qc_update_tx, qc_update_rx) = aptos_channel::new(QueueStyle::KLAST, 1, None);
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L216-228)
```rust
        self.states_by_key.insert(
            (update.issuer.clone(), update.kid.clone()),
            ConsensusState::InProgress {
                my_proposal: ObservedKeyLevelUpdate {
                    author: self.my_addr,
                    observed: update,
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard {
                    handle: abort_handle,
                },
            },
        );
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L334-354)
```rust
        match state {
            ConsensusState::InProgress { my_proposal, .. } => {
                let topic = Topic::JWK_CONSENSUS_PER_KEY_MODE {
                    issuer: issuer.clone(),
                    kid: kid.clone(),
                };
                let txn = ValidatorTransaction::ObservedJWKUpdate(issuer_level_repr.clone());
                let vtxn_guard = self.vtxn_pool.put(topic, Arc::new(txn), None);
                *state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: issuer_level_repr,
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    issuer = issuer_str,
                    kid = kid_str,
                    base_version = key_level_update.base_version,
                    "certified key-level update accepted."
                );
                Ok(())
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L399-399)
```rust
                        Duration::from_secs(10),
```

**File:** crates/aptos-jwk-consensus/src/types.rs (L96-101)
```rust
impl Drop for QuorumCertProcessGuard {
    fn drop(&mut self) {
        let QuorumCertProcessGuard { handle } = self;
        handle.abort();
    }
}
```

**File:** crates/aptos-jwk-consensus/src/update_certifier.rs (L67-79)
```rust
        let task = async move {
            let qc_update = rb.broadcast(req, agg_state).await.expect("cannot fail");
            ConsensusMode::log_certify_done(epoch, &qc_update);
            let session_key = ConsensusMode::session_key_from_qc(&qc_update);
            match session_key {
                Ok(key) => {
                    let _ = qc_update_tx.push(key, qc_update);
                },
                Err(e) => {
                    error!("JWK update QCed but could not identify the session key: {e}");
                },
            }
        };
```
