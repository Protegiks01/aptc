# Audit Report

## Title
Optimistic Signature Verification Enables Performance-Based DoS Attack via Invalid Commit Vote Signatures

## Summary
The consensus pipeline's optimistic signature verification mechanism accepts unverified commit vote signatures that are only validated during aggregation. A malicious validator can inject invalid signatures, forcing all nodes to fall back to expensive individual signature verification of all collected signatures, causing significant performance degradation and potential consensus slowdowns.

## Finding Description

The vulnerability exists in how commit vote signatures are processed through the consensus pipeline when `optimistic_sig_verification` is enabled (which is the default configuration).

**Attack Flow:**

1. **Unverified Signature Acceptance**: When a commit vote arrives, `CommitMessage::verify()` calls `ValidatorVerifier::optimistic_verify()`. With optimistic verification enabled, signatures from validators not in the `pessimistic_verify_set` are accepted WITHOUT cryptographic verification. [1](#0-0) 

The critical check at line 278-279 shows that verification is SKIPPED if `optimistic_sig_verification` is true and the author is not in the pessimistic set, simply returning `Ok()` without verification.

2. **Unverified Storage**: These unverified signatures are stored in the `OrderedItem::unverified_votes` HashMap with the explicit assumption they will be verified later: [2](#0-1) 

3. **Aggregation Without Pre-Verification**: When advancing to the executed stage, all unverified votes (including potentially invalid ones) are added to the `SignatureAggregator` without any validation: [3](#0-2) [4](#0-3) 

4. **Expensive Fallback on Failure**: The `aggregate_and_verify()` method first attempts optimistic aggregation, but if verification fails (due to an invalid signature), it must verify EVERY signature individually: [5](#0-4) 

5. **Individual Verification Cost**: The `filter_invalid_signatures()` method performs parallel individual verification of ALL signatures: [6](#0-5) 

This operation verifies each signature individually (line 300), which is cryptographically expensive for BLS12-381 signatures.

**Configuration Vulnerability**: Optimistic signature verification is enabled by DEFAULT in production: [7](#0-6) 

**Mitigation Weakness**: The `pessimistic_verify_set` is marked as `#[serde(skip)]`, meaning it is NOT persisted and is reset on node restart: [8](#0-7) 

This breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits." A malicious actor can force nodes to perform O(n) expensive cryptographic operations instead of the intended O(1) aggregated verification.

## Impact Explanation

**Severity: Medium** - Validator node slowdown and performance-based denial of service

Per the Aptos bug bounty program, this qualifies as **Medium Severity** because it causes:
- **Validator Node Slowdowns**: Each invalid signature forces all nodes processing commit votes to perform O(n) individual BLS signature verifications instead of a single aggregated verification
- **Potential Liveness Issues**: During periods of high load or when multiple malicious validators coordinate, the cumulative verification cost can cause consensus timeouts
- **Resource Exhaustion**: BLS signature verification is computationally expensive, consuming significant CPU resources that should be used for block processing

The attack affects ALL nodes that receive the commit votes, not just a single node, amplifying the network-wide impact.

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely to occur because:

1. **Low Barrier to Entry**: Only requires a single malicious validator, not Byzantine threshold (f < n/3)
2. **Default Configuration**: Optimistic signature verification is enabled by default in production consensus config
3. **Ephemeral Mitigation**: The `pessimistic_verify_set` is not persisted across node restarts, allowing repeated attacks
4. **No Rate Limiting**: There are no mechanisms to rate-limit or penalize validators beyond the ephemeral blacklist
5. **Multiple Attack Vectors**: Malicious validators can:
   - Send one invalid signature per round before being detected
   - Use multiple validator identities if they control multiple stakes
   - Coordinate timing to maximize impact during critical consensus phases
   - Repeat attacks after node restarts when the pessimistic set is cleared

The attack complexity is minimal - a malicious validator simply needs to sign commit votes with an invalid BLS signature, which can be as simple as using a random signature or signing incorrect data.

## Recommendation

Implement one or more of the following mitigations:

**Option 1: Batch Pre-Verification (Recommended)**
Before adding signatures to the aggregator, perform batched verification of unverified signatures:

```rust
fn create_signature_aggregator(
    unverified_votes: HashMap<Author, CommitVote>,
    commit_ledger_info: &LedgerInfo,
    verifier: &ValidatorVerifier,
) -> SignatureAggregator<LedgerInfo> {
    let mut sig_aggregator = SignatureAggregator::new(commit_ledger_info.clone());
    
    // Pre-verify unverified signatures in parallel batches
    let verified_votes: HashMap<Author, CommitVote> = unverified_votes
        .into_par_iter()
        .filter(|(author, vote)| {
            if vote.signature_with_status().is_verified() {
                return true;
            }
            vote.ledger_info() == commit_ledger_info 
                && verifier.verify(*author, commit_ledger_info, vote.signature()).is_ok()
        })
        .collect();
    
    for (author, vote) in verified_votes {
        vote.signature_with_status().set_verified();
        sig_aggregator.add_signature(author, vote.signature_with_status());
    }
    sig_aggregator
}
```

**Option 2: Persistent Penalty Mechanism**
Make `pessimistic_verify_set` persistent across node restarts and implement staking penalties for validators who repeatedly submit invalid signatures.

**Option 3: Adaptive Verification**
Implement a hybrid approach that switches to pessimistic verification network-wide when the rate of verification failures exceeds a threshold.

**Option 4: Signature Pre-Validation**
Remove optimistic verification for commit votes entirely, as these are critical consensus messages that warrant immediate validation.

## Proof of Concept

```rust
// Reproduction steps for Rust test (add to consensus/src/pipeline/buffer_item.rs test module)

#[test]
fn test_performance_attack_via_invalid_signature() {
    use std::time::Instant;
    
    let (validator_signers, mut validator_verifier) = create_validators();
    validator_verifier.set_optimistic_sig_verification_flag(true);
    
    let pipelined_block = create_pipelined_block();
    let block_info = pipelined_block.block_info();
    let ledger_info = LedgerInfo::new(block_info.clone(), HashValue::zero());
    let ordered_proof = LedgerInfoWithSignatures::new(
        ledger_info.clone(), 
        AggregateSignature::empty()
    );
    
    // Create 6 valid signatures + 1 INVALID signature
    let mut cached_votes = HashMap::new();
    for i in 0..6 {
        let vote = CommitVote::new(
            validator_signers[i].author(), 
            ledger_info.clone(), 
            &validator_signers[i]
        ).unwrap();
        cached_votes.insert(vote.author(), vote);
    }
    
    // Inject INVALID signature from 7th validator
    let invalid_vote = CommitVote::new_with_signature(
        validator_signers[6].author(),
        ledger_info.clone(),
        bls12381::Signature::dummy_signature(), // INVALID
    );
    cached_votes.insert(invalid_vote.author(), invalid_vote);
    
    let ordered_item = BufferItem::new_ordered(
        vec![pipelined_block.clone()],
        ordered_proof.clone(),
        cached_votes,
    );
    
    // Measure time for aggregation with invalid signature
    let start = Instant::now();
    let executed_item = ordered_item.advance_to_executed_or_aggregated(
        vec![pipelined_block.clone()],
        &validator_verifier,
        None,
        true,
    );
    let elapsed = start.elapsed();
    
    println!("Time with invalid signature forcing individual verification: {:?}", elapsed);
    
    // This will take significantly longer than aggregated verification alone
    // because it must verify all 7 signatures individually after the 
    // aggregated verification fails
    
    assert!(validator_verifier.pessimistic_verify_set().len() == 1);
    assert!(validator_verifier.pessimistic_verify_set().contains(&validator_signers[6].author()));
}
```

**Expected Behavior**: The test demonstrates that a single invalid signature forces the system to fall back to individual verification of all signatures, significantly increasing processing time. In a production environment with 100+ validators, this amplification would cause severe performance degradation across the entire network.

## Notes

This vulnerability is particularly concerning because:
1. It affects the critical consensus path where performance is essential
2. The default configuration enables the vulnerable code path
3. The mitigation (pessimistic_verify_set) is ephemeral and doesn't persist
4. A single malicious validator can impact all nodes processing commit votes
5. The attack can be repeated across epochs as new validators join or existing ones restart

The issue should be addressed by either implementing robust pre-verification of signatures before aggregation or by making the penalty mechanism persistent and more severe.

### Citations

**File:** types/src/validator_verifier.rs (L154-156)
```rust
    #[serde(skip)]
    #[derivative(PartialEq = "ignore")]
    pessimistic_verify_set: DashSet<AccountAddress>,
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L40-52)
```rust
fn create_signature_aggregator(
    unverified_votes: HashMap<Author, CommitVote>,
    commit_ledger_info: &LedgerInfo,
) -> SignatureAggregator<LedgerInfo> {
    let mut sig_aggregator = SignatureAggregator::new(commit_ledger_info.clone());
    for vote in unverified_votes.values() {
        let sig = vote.signature_with_status();
        if vote.ledger_info() == commit_ledger_info {
            sig_aggregator.add_signature(vote.author(), sig);
        }
    }
    sig_aggregator
}
```

**File:** consensus/src/pipeline/buffer_item.rs (L165-171)
```rust
                    let mut partial_commit_proof =
                        create_signature_aggregator(unverified_votes, &commit_ledger_info);
                    if let Ok(commit_proof) = partial_commit_proof
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
```

**File:** consensus/src/pipeline/buffer_item.rs (L379-391)
```rust
            Self::Ordered(ordered) => {
                if ordered
                    .ordered_proof
                    .commit_info()
                    .match_ordered_only(target_commit_info)
                {
                    // we optimistically assume the vote will be valid in the future.
                    // when advancing to executed item, we will check if the sigs are valid.
                    // each author at most stores a single sig for each item,
                    // so an adversary will not be able to flood our memory.
                    ordered.unverified_votes.insert(author, vote);
                    return Ok(());
                }
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** config/src/config/consensus_config.rs (L382-382)
```rust
            optimistic_sig_verification: true,
```
