# Audit Report

## Title
Stateless Player Design Allows Cross-Config Usage Leading to Transcript Verification Mismatches and Consensus Failures

## Summary
The `Player` struct in the Aptos DKG implementation contains no reference to its originating `SecretSharingConfig`, allowing validators to inadvertently use Player instances across incompatible weighted configurations without compile-time or runtime detection. This can cause validators to access incorrect share indices in PVSS transcripts, leading to verification failures, incorrect secret reconstruction, and consensus divergence if validators use mismatched configs during the same DKG session.

## Finding Description

The vulnerability exists in the design of the cryptographic player identification system used for Distributed Key Generation (DKG) and secret sharing in Aptos randomness generation. [1](#0-0) 

The `Player` struct is intentionally stateless - containing only a numeric `id` field. While the comment states this provides "type-safety" to prevent out-of-range player IDs, it provides NO protection against using a Player from one `SecretSharingConfig` with a different, incompatible config.

The problem manifests when weighted configurations are involved. In weighted secret sharing, each player has a specific weight determining how many shares they own: [2](#0-1) 

These methods directly index into config-specific arrays using `player.id`, with no validation that the Player originated from the same config. The starting indices and weights are config-specific: [3](#0-2) 

When decrypting shares from a weighted transcript, the code uses these methods to compute which ciphertext array indices belong to a player: [4](#0-3) 

**Attack Scenario:**

Consider two weighted configs with the same total weight (W=60) but different distributions:
- **Config A**: weights=[30, 30], Player 1 owns shares at indices [30..60)
- **Config B**: weights=[40, 20], Player 1 owns shares at indices [40..60)

If a transcript is created with Config A but a validator attempts to decrypt it using Config B:
1. The transcript's `C` array has ciphertexts arranged per Config A's weight distribution
2. Config B computes `starting_index[1] = 40` and `weight[1] = 20`
3. The validator retrieves `C[40..60]` instead of `C[30..60]`
4. This yields wrong shares corresponding to incorrect polynomial evaluation points
5. Secret reconstruction fails or produces an incorrect secret
6. Consensus on randomness generation breaks

The transcript verification only checks total weight, not weight distribution: [5](#0-4) 

Two configs with identical total weight W but different per-player weight distributions will both pass `check_sizes()`, allowing the mismatch to go undetected.

## Impact Explanation

This qualifies as **High Severity** based on the Aptos bug bounty criteria for "Significant protocol violations" and potential consensus disruption.

**Impact on Consensus:**
- If validators use mismatched configs during DKG, they will decrypt different shares from the same transcript
- This breaks the deterministic execution invariant - validators produce different randomness outputs
- Randomness generation consensus fails, blocking epoch transitions
- Network may experience liveness failures requiring manual intervention

**Impact on Randomness Security:**
- Validators with wrong configs may reconstruct incorrect secrets
- This could compromise the security of on-chain randomness if partial shares are leaked
- VRF signatures and leader election could be affected

**Conditions for Exploitation:**
While the design flaw exists, exploitation requires validators to use incompatible configs, which could occur via:
1. Race conditions during epoch transitions where validators haven't synchronized on-chain state
2. Bugs in the deterministic config generation algorithm producing non-deterministic outputs
3. Node compromise or misconfiguration causing validators to use wrong epoch parameters
4. Software version mismatches if config derivation logic changes between versions

## Likelihood Explanation

**Likelihood: Medium-Low in normal operation, but High if triggering conditions exist**

The Aptos implementation has protective measures that reduce likelihood:
- All validators derive configs deterministically from the same on-chain validator stakes
- The `DKGRounding` algorithm appears deterministic given identical inputs
- Dealer index validation provides some bounds checking [6](#0-5) 

However, the lack of type-level or cryptographic binding between Player and Config means:
- ANY bug causing config divergence will silently trigger this vulnerability
- No defensive programming layer prevents misuse
- Testing may not catch cross-config usage since it requires specific conditions

The vulnerability is latent - waiting for triggering conditions like epoch synchronization bugs, non-determinism in config generation, or implementation changes that don't preserve config compatibility.

## Recommendation

**Solution 1: Type-level binding (Preferred)**
Add a phantom type parameter or unique identifier binding Player to its originating config:

```rust
pub struct Player<'cfg> {
    pub id: usize,
    _config_marker: PhantomData<&'cfg ()>,
}
```

Or add a config identifier:
```rust
pub struct Player {
    pub id: usize,
    config_hash: [u8; 32], // Hash of the config's weight distribution
}
```

**Solution 2: Runtime validation**
Add validation in methods that use Players to verify the Player is compatible with the config:

```rust
impl<TC: ThresholdConfig> WeightedConfig<TC> {
    pub fn validate_player(&self, player: &Player) -> anyhow::Result<()> {
        ensure!(
            player.id < self.num_players,
            "Player ID {} out of bounds for config with {} players",
            player.id,
            self.num_players
        );
        Ok(())
    }
    
    pub fn get_player_weight(&self, player: &Player) -> anyhow::Result<usize> {
        self.validate_player(player)?;
        Ok(self.weights[player.id])
    }
}
```

**Solution 3: Defensive checks in transcript operations**
Add weight distribution validation during transcript verification to detect config mismatches:

```rust
impl Transcript {
    fn verify_weight_distribution(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
        // Verify transcript structure matches config's expected weight distribution
        // This could check that ciphertext groupings align with weight boundaries
        Ok(())
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod config_mismatch_test {
    use aptos_crypto::weighted_config::WeightedConfigBlstrs;
    use aptos_crypto::traits::SecretSharingConfig;
    use aptos_dkg::pvss::{Player, das::WeightedTranscript, traits::Transcript};
    use aptos_crypto::Uniform;
    use rand::thread_rng;
    
    #[test]
    fn test_cross_config_player_usage_causes_mismatch() {
        let mut rng = thread_rng();
        
        // Create two configs with same total weight but different distributions
        let config_a = WeightedConfigBlstrs::new(40, vec![30, 30]).unwrap(); // W=60
        let config_b = WeightedConfigBlstrs::new(40, vec![40, 20]).unwrap(); // W=60
        
        // Setup dealing with config A
        let pp = <WeightedTranscript as Transcript>::PublicParameters::default_with_bls_base();
        let ssk = <WeightedTranscript as Transcript>::SigningSecretKey::generate(&mut rng);
        let spk = ssk.verifying_key();
        
        let eks: Vec<_> = (0..2)
            .map(|_| {
                let dk = <WeightedTranscript as Transcript>::DecryptPrivKey::generate(&mut rng);
                dk.to(&pp.get_encryption_public_params())
            })
            .collect();
        
        let secret = <WeightedTranscript as Transcript>::InputSecret::generate(&mut rng);
        
        // Deal transcript with Config A
        let player_a_0 = config_a.get_player(0);
        let trx = WeightedTranscript::deal(
            &config_a,
            &pp,
            &ssk,
            &spk,
            &eks,
            &secret,
            &0u64,
            &player_a_0,
            &mut rng,
        );
        
        // Verification with Config A succeeds
        assert!(trx.verify(&config_a, &pp, &[spk.clone()], &eks, &[0u64]).is_ok());
        
        // But check_sizes also passes with Config B (same total weight!)
        assert!(trx.check_sizes(&config_b).is_ok());
        
        // Attempt to decrypt with Config B using a Player from Config A
        let player_b_1 = config_b.get_player(1);
        let dk1 = <WeightedTranscript as Transcript>::DecryptPrivKey::generate(&mut rng);
        
        // This will access wrong indices: Config B thinks Player 1 starts at index 40,
        // but the transcript was built with Config A where Player 1 starts at index 30
        let (shares_b, _) = trx.decrypt_own_share(&config_b, &player_b_1, &dk1, &pp);
        
        // Now try with correct Config A
        let player_a_1 = config_a.get_player(1);
        let (shares_a, _) = trx.decrypt_own_share(&config_a, &player_a_1, &dk1, &pp);
        
        // The shares will be different due to accessing different array indices!
        // shares_b accesses C[40..60], shares_a accesses C[30..60]
        assert_ne!(shares_b.len(), shares_a.len()); // Different number of shares
        // This demonstrates the config mismatch causes incorrect share retrieval
    }
}
```

**Notes**

This vulnerability represents a critical defensive programming gap in the DKG implementation. While Aptos has mitigations that reduce the likelihood of config mismatches in practice (deterministic derivation, on-chain state synchronization), the stateless Player design provides no safety net if those mitigations fail. The lack of type-level or runtime binding between Player and SecretSharingConfig means any bug causing config divergence—whether from non-determinism, race conditions, or version incompatibilities—will silently propagate into consensus-breaking behavior. This violates the principle of defense in depth and could manifest as difficult-to-diagnose consensus failures during epoch transitions or DKG sessions.

### Citations

**File:** crates/aptos-crypto/src/player.rs (L21-24)
```rust
pub struct Player {
    /// A number from 0 to n-1.
    pub id: usize,
}
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L163-170)
```rust
    pub fn get_player_weight(&self, player: &Player) -> usize {
        self.weights[player.id]
    }

    /// Returns the starting index of a player's shares in the flattened vector of all weighted shares.
    pub fn get_player_starting_index(&self, player: &Player) -> usize {
        self.starting_index[player.id]
    }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L199-205)
```rust
    pub fn get_share_index(&self, i: usize, j: usize) -> Option<usize> {
        if j < self.weights[i] {
            Some(self.starting_index[i] + j)
        } else {
            None
        }
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L220-244)
```rust
    fn decrypt_own_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
        dk: &Self::DecryptPrivKey,
        _pp: &Self::PublicParameters,
    ) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
        let weight = sc.get_player_weight(player);
        let mut sk_shares = Vec::with_capacity(weight);
        let pk_shares = self.get_public_key_share(sc, player);

        for j in 0..weight {
            let k = sc.get_share_index(player.id, j).unwrap();

            let ctxt = self.C[k]; // h_1^{f(s_i + j - 1)} \ek_i^{r_{s_i + j}}
            let ephemeral_key = self.R[k].mul(dk.dk); // (g_1^{r_{s_i + j}})
            let dealt_secret_key_share = ctxt.sub(ephemeral_key);

            sk_shares.push(pvss::dealt_secret_key_share::g1::DealtSecretKeyShare::new(
                Self::DealtSecretKey::new(dealt_secret_key_share),
            ));
        }

        (sk_shares, pk_shares)
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L415-454)
```rust
    fn check_sizes(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
        let W = sc.get_total_weight();

        if self.V.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V.len()
            );
        }

        if self.V_hat.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V_hat.len()
            );
        }

        if self.R.len() != W {
            bail!(
                "Expected {} G_1 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R.len()
            );
        }

        if self.R_hat.len() != W {
            bail!(
                "Expected {} G_2 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R_hat.len()
            );
        }

        if self.C.len() != W {
            bail!("Expected C of length {}, but got {}", W, self.C.len());
        }

        Ok(())
```

**File:** types/src/dkg/real_dkg/mod.rs (L336-347)
```rust
        // Verify dealer indices are valid.
        let dealers = trx
            .main
            .get_dealers()
            .iter()
            .map(|player| player.id)
            .collect::<Vec<usize>>();
        let num_validators = params.session_metadata.dealer_validator_set.len();
        ensure!(
            dealers.iter().all(|id| *id < num_validators),
            "real_dkg::verify_transcript failed with invalid dealer index."
        );
```
