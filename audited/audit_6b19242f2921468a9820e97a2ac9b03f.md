# Audit Report

## Title
State Summary and Hot State Version Inconsistency Race Condition in PersistedState

## Summary
A race condition exists in `PersistedState` between `set()`, `get_state_summary()`, and `get_state()` that allows the state summary version to become inconsistent with the hot_state version. This occurs because the summary is updated synchronously while the hot_state commit is processed asynchronously, creating a time window where readers observe mismatched versions that violate state consistency invariants.

## Finding Description

The vulnerability stems from the asynchronous nature of hot state commits in `PersistedState::set()`: [1](#0-0) 

The function updates the summary **synchronously** (line 59) but enqueues the hot_state for **asynchronous** commit (line 61). The comment acknowledges ordering is important, but only addresses the order within `set()`, not the atomicity from a reader's perspective.

The hot state commit happens in a background Committer thread: [2](#0-1) 

The `enqueue_commit()` function merely sends the state to a channel and returns immediately. The actual commit happens later in the Committer thread: [3](#0-2) 

**The Race Scenario:**

1. Thread A (StateMerkleBatchCommitter) calls `set(snapshot_v2)`:
   - Summary immediately updated to V2 (locks mutex, updates, unlocks)
   - Hot state V2 queued for async commit
   - Function returns while hot_state is still at V1

2. Thread B (during initialization or execution) calls:
   - `get_state()` → Returns hot_state at V1 (Committer hasn't processed V2 yet)
   - `get_state_summary()` → Returns summary at V2

This occurs in critical code paths: [4](#0-3) 

The code retrieves persisted state (line 673) and persisted summary (line 677) separately, assuming they represent the same version. When they don't:
- State updates are calculated from base version V1
- Summary Merkle tree updates use base version V2
- This produces incorrect Merkle proofs and root hashes

The background committer thread that calls `set()` is spawned here: [5](#0-4) 

And the actual `set()` call occurs at: [6](#0-5) 

## Impact Explanation

**High Severity** - This vulnerability breaks critical Aptos invariants:

1. **Deterministic Execution Violation**: Different validators may read different state/summary version pairs during the race window, leading to different Merkle root hash calculations for the same block. This violates the requirement that "all validators must produce identical state roots for identical blocks."

2. **State Consistency Violation**: State transitions are no longer atomic from the reader's perspective. The summary reflects version N+1 while state remains at version N, violating the invariant that "state transitions must be atomic and verifiable via Merkle proofs."

3. **Consensus Safety Risk**: If validators compute different state root hashes due to reading inconsistent state/summary pairs, this could lead to consensus divergence, requiring manual intervention or a hard fork to resolve.

The Merkle tree update logic explicitly uses the persisted summary as a proof base: [7](#0-6) 

Using mismatched state (V1) and summary (V2) versions produces incorrect intermediate Merkle nodes and potentially wrong root hashes.

## Likelihood Explanation

**High Likelihood** during normal operation:

1. The race window exists whenever `set()` is called by the StateMerkleBatchCommitter thread, which happens regularly during block processing and state snapshots.

2. The window duration depends on the Committer thread's processing speed and system load. Under heavy load, the window widens, increasing race probability.

3. Critical code paths call both `get_state()` and `get_state_summary()` during:
   - Node initialization (`create_buffered_state_from_latest_snapshot`)
   - State checkpoint operations (`calculate_state_and_put_updates`)
   - Backup/restore operations

4. No synchronization mechanism prevents this race - the summary and hot_state are updated independently with different threading models.

## Recommendation

Implement atomic updates for state and summary by either:

**Option 1: Wait for commit completion in `set()`**
```rust
pub fn set(&self, persisted: StateWithSummary) {
    let (state, summary) = persisted.into_inner();
    
    *self.summary.lock() = summary;
    
    // Wait for async commit to complete
    self.hot_state.enqueue_commit(state);
    let version = persisted.version().expect("Version must exist");
    self.hot_state.wait_for_commit(version + 1);
}
```

**Option 2: Store state and summary together atomically**
```rust
pub struct PersistedState {
    hot_state: Arc<HotState>,
    // Combine summary with committed state version reference
    state_with_summary: Arc<Mutex<(StateSummary, Version)>>,
}

pub fn get_state_and_summary(&self) -> (Arc<dyn HotStateView>, State, StateSummary) {
    let (summary, expected_version) = self.state_with_summary.lock().clone();
    let (hot_state, state) = self.hot_state.get_committed();
    
    // Ensure versions match
    assert_eq!(state.version(), Some(expected_version));
    
    (hot_state, state, summary)
}
```

**Option 3: Add version tracking and validation**
```rust
pub fn get_state(&self) -> (Arc<dyn HotStateView>, State) {
    let summary_version = self.summary.lock().version();
    let (hot_state, state) = self.hot_state.get_committed();
    
    // Spin-wait if versions don't match (race in progress)
    while state.version() != summary_version {
        std::thread::sleep(Duration::from_micros(10));
        (hot_state, state) = self.hot_state.get_committed();
    }
    
    (hot_state, state)
}
```

## Proof of Concept

```rust
// Rust test demonstrating the race condition
#[test]
fn test_persisted_state_version_race() {
    use std::sync::{Arc, Barrier};
    use std::thread;
    
    let config = HotStateConfig::default();
    let persisted_state = Arc::new(PersistedState::new_empty(config));
    
    // Create initial state at V0
    let state_v0 = StateWithSummary::new_empty(config);
    persisted_state.set(state_v0);
    
    // Barrier to coordinate threads
    let barrier = Arc::new(Barrier::new(2));
    
    // Thread 1: Calls set() with V1
    let ps1 = Arc::clone(&persisted_state);
    let b1 = Arc::clone(&barrier);
    let t1 = thread::spawn(move || {
        let state_v1 = create_state_at_version(1, config);
        ps1.set(state_v1);
        b1.wait(); // Summary now at V1, but hot_state may still be V0
    });
    
    // Thread 2: Reads state and summary immediately after set()
    let ps2 = Arc::clone(&persisted_state);
    let b2 = Arc::clone(&barrier);
    let t2 = thread::spawn(move || {
        b2.wait(); // Wait for set() to complete
        
        // Race window: read both
        let summary = ps2.get_state_summary();
        let (_, state) = ps2.get_state();
        
        // ASSERTION FAILURE: versions should match but may not
        assert_eq!(
            summary.version(), 
            state.version(),
            "Race condition detected: summary at {:?}, state at {:?}",
            summary.version(),
            state.version()
        );
    });
    
    t1.join().unwrap();
    t2.join().unwrap();
}
```

## Notes

The code comment explicitly acknowledges version ordering is critical, but only addresses the order of operations within `set()`, not atomicity from readers' perspectives. The asynchronous commit model fundamentally breaks the consistency guarantee that state and summary represent the same version. This affects consensus safety when validators compute state roots during block processing.

### Citations

**File:** storage/aptosdb/src/state_store/persisted_state.rs (L50-62)
```rust
    pub fn set(&self, persisted: StateWithSummary) {
        let (state, summary) = persisted.into_inner();

        // n.b. Summary must be updated before committing the hot state, otherwise in the execution
        // pipeline we risk having a state generated based on a persisted version (v2) that's newer
        // than that of the summary (v1). That causes issue down the line where we commit the diffs
        // between a later snapshot (v3) and a persisted snapshot (v1) to the JMT, at which point
        // we will not be able to calculate the difference (v1 - v3) because the state links only
        // to as far as v2 (code will panic)
        *self.summary.lock() = summary;

        self.hot_state.enqueue_commit(state);
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L138-144)
```rust
    pub fn enqueue_commit(&self, to_commit: State) {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["hot_state_enqueue_commit"]);

        self.commit_tx
            .send(to_commit)
            .expect("Failed to queue for hot state commit.")
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L192-205)
```rust
    fn run(&mut self) {
        info!("HotState committer thread started.");

        while let Some(to_commit) = self.next_to_commit() {
            self.commit(&to_commit);
            *self.committed.lock() = to_commit;

            GAUGE.set_with(&["hot_state_items"], self.base.len() as i64);
            GAUGE.set_with(&["hot_state_key_bytes"], self.total_key_bytes as i64);
            GAUGE.set_with(&["hot_state_value_bytes"], self.total_value_bytes as i64);
        }

        info!("HotState committer quitting.");
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L673-682)
```rust
            let (hot_state, state) = out_persisted_state.get_state();
            let (new_state, _state_reads, hot_state_updates) = current_state
                .ledger_state()
                .update_with_db_reader(&state, hot_state, &state_update_refs, state_db.clone())?;
            let state_summary = out_persisted_state.get_state_summary();
            let new_state_summary = current_state.ledger_state_summary().update(
                &ProvableStateSummary::new(state_summary, state_db.as_ref()),
                &hot_state_updates,
                &state_update_refs,
            )?;
```

**File:** storage/aptosdb/src/state_store/state_snapshot_committer.rs (L67-77)
```rust
        let join_handle = std::thread::Builder::new()
            .name("state_batch_committer".to_string())
            .spawn(move || {
                let committer = StateMerkleBatchCommitter::new(
                    arc_state_db,
                    state_merkle_batch_commit_receiver,
                    persisted_state.clone(),
                );
                committer.run();
            })
            .expect("Failed to spawn state merkle batch committer thread.");
```

**File:** storage/aptosdb/src/state_store/state_merkle_batch_committer.rs (L106-106)
```rust
                    self.persisted_state.set(snapshot);
```

**File:** storage/storage-interface/src/state_store/state_summary.rs (L169-173)
```rust
        Ok(self
            .global_state_summary
            .freeze(&persisted.global_state_summary)
            .batch_update_sorted_uniq(&smt_updates, &ColdProvableStateSummary::new(persisted))?
            .unfreeze())
```
