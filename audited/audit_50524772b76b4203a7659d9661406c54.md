# Audit Report

## Title
Randomness Share Verification DoS via Repeated Invalid Proof Submission

## Summary
Byzantine validators can repeatedly send randomness shares with the same author/metadata but different invalid cryptographic proofs, forcing honest nodes to perform expensive BLS signature verification for each invalid share. The verification occurs before deduplication, allowing attackers to consume validator CPU resources and slow down consensus.

## Finding Description

The randomness generation protocol verifies shares before deduplication, creating a DoS attack vector. When a validator receives a `RandShare` message, the flow is:

1. **Network Reception**: Message arrives via `incoming_rpc_request` channel with per-sender queue limit of 10 (KLAST style) [1](#0-0) 

2. **Expensive Verification First**: Each message triggers `WVUF::verify_share()` - a costly BLS signature verification operation [2](#0-1) 

3. **Deduplication Only After Success**: Only successfully verified shares reach the `ShareAggregator`, which deduplicates by author [3](#0-2) 

**Attack Path:**
A Byzantine validator generates multiple `RandShare` messages with:
- Same `author` (their own address) 
- Same `metadata` (epoch, round)
- Different **invalid** `ProofShare` values (malformed BLS signatures)

Each share passes initial checks: [4](#0-3) 

But fails at expensive cryptographic verification. Since verification happens in `verification_task` before any deduplication, each invalid share consumes CPU resources despite being destined to fail: [5](#0-4) 

The bounded executor limits concurrent verifications but doesn't prevent the attack - as each verification completes (and fails), the next invalid share is processed: [6](#0-5) 

## Impact Explanation

This vulnerability meets **High Severity** criteria per Aptos bug bounty rules: "Validator node slowdowns."

**Quantified Impact:**
- Each invalid BLS signature verification consumes significant CPU time
- Attacker can send up to 10 concurrent invalid shares per victim (channel queue limit)
- As verifications complete, attacker sends more, maintaining sustained CPU load
- Multiple Byzantine validators can coordinate to amplify the attack
- Affects consensus liveness by slowing down randomness generation, which blocks block production

The attack breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." Honest nodes are forced to perform unbounded cryptographic operations on attacker-controlled invalid data.

## Likelihood Explanation

**High Likelihood:**
- **Low Attacker Requirements**: Any validator in the set can execute this attack (Byzantine fault model assumes up to 1/3 can be malicious)
- **Simple Execution**: Attacker only needs to generate random invalid BLS signatures - no sophisticated cryptographic attack required
- **No Rate Limiting**: No per-validator rate limiting on share verification attempts
- **No Caching**: No cache of previously rejected (author, metadata) tuples

**Attack Complexity**: Low - Byzantine validator can automate sending invalid shares at maximum rate the bounded executor can process.

## Recommendation

Implement early deduplication and verification result caching before expensive cryptographic operations:

```rust
// Add to RandManager struct:
struct RandManager<S: TShare, D: TAugmentedData> {
    // ... existing fields ...
    share_verification_cache: Arc<Mutex<HashMap<(Author, RandMetadata), VerificationResult>>>,
    share_rate_limiter: Arc<Mutex<HashMap<Author, TokenBucket>>>,
}

// In verification_task, add early checks:
async fn verification_task(...) {
    while let Some(rand_gen_msg) = incoming_rpc_request.next().await {
        match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
            Ok(msg) => {
                // For Share messages, check cache first
                if let RandMessage::Share(ref share) = msg {
                    let cache_key = (*share.author(), share.metadata().clone());
                    
                    // Check rate limit per author
                    if !rate_limiter.check_and_update(share.author()) {
                        continue; // Drop if rate limited
                    }
                    
                    // Check cache for recent verification
                    if let Some(cached_result) = cache.get(&cache_key) {
                        if cached_result.is_err() && cached_result.age() < Duration::from_secs(60) {
                            continue; // Skip re-verification of recently failed shares
                        }
                    }
                }
                
                // Proceed with verification...
                let result = msg.verify(...);
                
                // Cache verification result
                if let RandMessage::Share(ref share) = msg {
                    cache.insert(cache_key, result.clone());
                }
                
                if result.is_ok() {
                    // ... send to verified_msg_tx
                }
            },
            Err(e) => warn!("Invalid message: {}", e),
        }
    }
}
```

**Key Mitigations:**
1. **Verification Cache**: Cache (author, metadata) â†’ VerificationResult for 60 seconds to prevent re-verification of the same invalid share
2. **Per-Author Rate Limiting**: Limit share verification attempts per author (e.g., 10 per round using token bucket)
3. **Early Rejection**: Check cache before spawning expensive verification task

## Proof of Concept

```rust
#[cfg(test)]
mod dos_test {
    use super::*;
    use std::time::Instant;
    
    #[tokio::test]
    async fn test_share_verification_dos() {
        // Setup: Create RandManager with test configuration
        let (tx, mut rx) = unbounded();
        let bounded_executor = BoundedExecutor::new(10, tokio::runtime::Handle::current());
        
        // Create valid metadata
        let metadata = RandMetadata { epoch: 1, round: 1 };
        let byzantine_author = Author::random();
        
        // Attack: Send 100 invalid shares with same (author, metadata) but different invalid proofs
        let start = Instant::now();
        for i in 0..100 {
            let invalid_share = RandShare::new(
                byzantine_author,
                metadata.clone(),
                Share { share: ProofShare::random_invalid() }, // Invalid proof
            );
            
            let msg = RandMessage::Share(invalid_share);
            tx.unbounded_send(IncomingRandGenRequest {
                sender: byzantine_author,
                req: RpcRequest { data: bcs::to_bytes(&msg).unwrap(), ... },
                ...
            }).unwrap();
        }
        
        // Measure CPU time consumed verifying invalid shares
        // Expected: All 100 shares undergo expensive WVUF::verify_share()
        // Expected time: ~100 * VERIFICATION_TIME (no caching/deduplication)
        
        let elapsed = start.elapsed();
        println!("Time to process 100 invalid shares: {:?}", elapsed);
        
        // Assert: Processing time is proportional to number of shares (linear DoS)
        // With proper caching, should be constant after first verification failure
        assert!(elapsed.as_millis() > 100 * MIN_VERIFICATION_TIME_MS);
    }
}
```

**Notes:**
- The vulnerability exists in the proactive share broadcast flow (lines 414-424 in rand_manager.rs) where shares are verified in `verification_task` before reaching any deduplication logic
- The reactive share request flow using `ShareAggregateState::add()` has the same issue - verification at line 139 occurs before deduplication in `ShareAggregator`
- Per-key channel queuing (max 10 with KLAST) provides limited protection but doesn't prevent sustained CPU consumption
- The bounded executor's semaphore limits concurrent verifications but attackers can maintain a steady stream of invalid shares

### Citations

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L221-261)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingRandGenRequest>,
        verified_msg_tx: UnboundedSender<RpcRequest<S, D>>,
        rand_config: RandConfig,
        fast_rand_config: Option<RandConfig>,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(rand_gen_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = rand_config.clone();
            let fast_config_clone = fast_rand_config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
                        Ok(msg) => {
                            if msg
                                .verify(
                                    &epoch_state_clone,
                                    &config_clone,
                                    &fast_config_clone,
                                    rand_gen_msg.sender,
                                )
                                .is_ok()
                            {
                                let _ = tx.unbounded_send(RpcRequest {
                                    req: msg,
                                    protocol: rand_gen_msg.protocol,
                                    response_sender: rand_gen_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid rand gen message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L52-81)
```rust
    fn verify(
        &self,
        rand_config: &RandConfig,
        rand_metadata: &RandMetadata,
        author: &Author,
    ) -> anyhow::Result<()> {
        let index = *rand_config
            .validator
            .address_to_validator_index()
            .get(author)
            .ok_or_else(|| anyhow!("Share::verify failed with unknown author"))?;
        let maybe_apk = &rand_config.keys.certified_apks[index];
        if let Some(apk) = maybe_apk.get() {
            WVUF::verify_share(
                &rand_config.vuf_pp,
                apk,
                bcs::to_bytes(&rand_metadata)
                    .map_err(|e| anyhow!("Serialization failed: {}", e))?
                    .as_slice(),
                &self.share,
            )?;
        } else {
            bail!(
                "[RandShare] No augmented public key for validator id {}, {}",
                index,
                author
            );
        }
        Ok(())
    }
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L35-39)
```rust
    pub fn add_share(&mut self, weight: u64, share: RandShare<S>) {
        if self.shares.insert(*share.author(), share).is_none() {
            self.total_weight += weight;
        }
    }
```

**File:** consensus/src/rand/rand_gen/reliable_broadcast_state.rs (L131-139)
```rust
    fn add(&self, peer: Author, share: Self::Response) -> anyhow::Result<Option<()>> {
        ensure!(share.author() == &peer, "Author does not match");
        ensure!(
            share.metadata() == &self.rand_metadata,
            "Metadata does not match: local {:?}, received {:?}",
            self.rand_metadata,
            share.metadata()
        );
        share.verify(&self.rand_config)?;
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L36-60)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        sender: Author,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            RandMessage::RequestShare(_) => Ok(()),
            RandMessage::Share(share) => share.verify(rand_config),
            RandMessage::AugData(aug_data) => {
                aug_data.verify(rand_config, fast_rand_config, sender)
            },
            RandMessage::CertifiedAugData(certified_aug_data) => {
                certified_aug_data.verify(&epoch_state.verifier)
            },
            RandMessage::FastShare(share) => {
                share.share.verify(fast_rand_config.as_ref().ok_or_else(|| {
                    anyhow::anyhow!("[RandMessage] rand config for fast path not found")
                })?)
            },
            _ => bail!("[RandMessage] unexpected message type"),
        }
    }
```

**File:** crates/bounded-executor/src/executor.rs (L45-52)
```rust
    pub async fn spawn<F>(&self, future: F) -> JoinHandle<F::Output>
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
    {
        let permit = self.acquire_permit().await;
        self.executor.spawn(future_with_permit(future, permit))
    }
```
