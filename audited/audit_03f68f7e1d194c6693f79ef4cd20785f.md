# Audit Report

## Title
Genesis Coordination Lacks Cryptographic Verification of Shared Input Files

## Summary
The genesis generation process allows validators to independently fetch configuration files (`layout.yaml` and `employee_vesting_accounts.yaml`) from a Git repository without cryptographic verification. If different validators receive different versions of these files through Git manipulation, they will generate incompatible genesis states, preventing network startup.

## Finding Description

The Aptos genesis ceremony supports a distributed coordination model where validators fetch genesis configuration files from a shared Git repository. The implementation in `fetch_mainnet_genesis_info()` retrieves critical files without verifying their integrity: [1](#0-0) 

The Git client supports both local and GitHub repositories with branch specification: [2](#0-1) 

When fetching files, no hash verification or signature checking occurs: [3](#0-2) 

The genesis transaction is deterministically generated from these inputs: [4](#0-3) 

The waypoint is computed from the resulting state root after executing the genesis transaction: [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. Attacker gains control over the Git repository or performs branch manipulation
2. Validator A fetches `layout.yaml` with `min_stake: 1000000` 
3. Validator B fetches `layout.yaml` with `min_stake: 2000000`
4. Each validator generates a different genesis transaction
5. Different genesis → different state roots → different waypoints
6. Validators cannot agree on initial state → consensus fails at genesis

This breaks the **Deterministic Execution** invariant: all validators must produce identical state roots for the initial genesis state.

## Impact Explanation

**Severity Assessment: Medium**

While this could prevent network startup (which would typically be Critical), the actual impact is limited because:

1. **Operational Mitigation Exists**: The production deployment uses centralized genesis generation, not independent fetching: [7](#0-6) 

2. **Attacker Requirements**: The attacker needs either:
   - Control over the canonical Git repository (insider threat)
   - Man-in-the-middle capability on Git fetches (network-level attack, excluded per scope)
   - Ability to manipulate DNS/Git protocol (infrastructure compromise)

3. **Detection**: Validators would immediately detect mismatched waypoints before network start, allowing intervention.

However, this represents a **State Inconsistency** requiring manual intervention to resolve, which qualifies as Medium severity per the bug bounty criteria.

## Likelihood Explanation

**Likelihood: Low**

The attack requires significant capabilities beyond an unprivileged attacker:
- Repository control or sophisticated MITM attacks
- Coordination timing to affect multiple validators differently
- The genesis ceremony is typically a coordinated, one-time event with trusted participants

However, the lack of defense-in-depth means the code implicitly trusts Git as a secure channel, which violates security best practices.

## Recommendation

Implement cryptographic verification of genesis input files:

```rust
// In fetch_mainnet_genesis_info:
pub fn fetch_mainnet_genesis_info(
    git_options: GitOptions,
    expected_layout_hash: Option<HashValue>,
) -> CliTypedResult<MainnetGenesisInfo> {
    let client = git_options.get_client()?;
    let layout: Layout = client.get(Path::new(LAYOUT_FILE))?;
    
    // Verify layout file hash if provided
    if let Some(expected_hash) = expected_layout_hash {
        let layout_bytes = serde_yaml::to_vec(&layout)?;
        let actual_hash = HashValue::sha3_256_of(&layout_bytes);
        if actual_hash != expected_hash {
            return Err(CliError::UnexpectedError(format!(
                "Layout file hash mismatch: expected {}, got {}",
                expected_hash, actual_hash
            )));
        }
    }
    
    // Similar verification for employee_vesting_accounts
    // ... rest of function
}
```

Additionally, the genesis ceremony coordinator should:
1. Publish signed hashes of all genesis input files
2. Validators verify hashes before generation
3. Implement out-of-band waypoint verification before network start

## Proof of Concept

This is an operational vulnerability that cannot be easily demonstrated in a unit test, as it requires multiple validators and Git repository manipulation. However, the concept can be demonstrated:

```bash
# Terminal 1 - Validator A
mkdir -p validator-a/repo
cat > validator-a/repo/layout.yaml << EOF
chain_id: 1
min_stake: 1000000
max_stake: 100000000
# ... other fields
EOF

cd validator-a
aptos genesis generate-genesis \
  --local-repository-dir ./repo \
  --output-dir ./output \
  --mainnet

# Waypoint A: 0:abcd1234...

# Terminal 2 - Validator B  
mkdir -p validator-b/repo
cat > validator-b/repo/layout.yaml << EOF
chain_id: 1
min_stake: 2000000  # Different!
max_stake: 100000000
# ... other fields
EOF

cd validator-b
aptos genesis generate-genesis \
  --local-repository-dir ./repo \
  --output-dir ./output \
  --mainnet

# Waypoint B: 0:ef567890... (different!)

# Result: Validators cannot sync - waypoint mismatch
```

**Notes:**
- This vulnerability exploits the lack of cryptographic verification in the genesis input file fetching process
- In practice, Aptos deployments use centralized genesis generation which mitigates this risk
- However, the code itself does not enforce this operational model, creating a potential attack surface
- The fix should add hash verification as a defense-in-depth measure
- This is particularly important for permissionless networks where validators may not trust each other completely

### Citations

**File:** crates/aptos/src/genesis/mod.rs (L138-196)
```rust
pub fn fetch_mainnet_genesis_info(git_options: GitOptions) -> CliTypedResult<MainnetGenesisInfo> {
    let client = git_options.get_client()?;
    let layout: Layout = client.get(Path::new(LAYOUT_FILE))?;

    if layout.root_key.is_some() {
        return Err(CliError::UnexpectedError(
            "Root key must not be set for mainnet.".to_string(),
        ));
    }

    let total_supply = layout.total_supply.ok_or_else(|| {
        CliError::UnexpectedError("Layout file does not have `total_supply`".to_string())
    })?;

    let account_balance_map: AccountBalanceMap = client.get(Path::new(BALANCES_FILE))?;
    let accounts: Vec<AccountBalance> = account_balance_map.try_into()?;

    // Check that the supply matches the total
    let total_balance_supply: u64 = accounts.iter().map(|inner| inner.balance).sum();
    if total_supply != total_balance_supply {
        return Err(CliError::UnexpectedError(format!(
            "Total supply seen {} doesn't match expected total supply {}",
            total_balance_supply, total_supply
        )));
    }

    // Check that the user has a reasonable amount of APT, since below the minimum gas amount is
    // not useful 1 APT minimally
    const MIN_USEFUL_AMOUNT: u64 = 200000000;
    let ten_percent_of_total = total_supply / 10;
    for account in accounts.iter() {
        if account.balance != 0 && account.balance < MIN_USEFUL_AMOUNT {
            return Err(CliError::UnexpectedError(format!(
                "Account {} has an initial supply below expected amount {} < {}",
                account.account_address, account.balance, MIN_USEFUL_AMOUNT
            )));
        } else if account.balance > ten_percent_of_total {
            return Err(CliError::UnexpectedError(format!(
                "Account {} has an more than 10% of the total balance {} > {}",
                account.account_address, account.balance, ten_percent_of_total
            )));
        }
    }

    // Keep track of accounts for later lookup of balances
    let initialized_accounts: BTreeMap<AccountAddress, u64> = accounts
        .iter()
        .map(|inner| (inner.account_address, inner.balance))
        .collect();

    let employee_vesting_accounts: EmployeePoolMap =
        client.get(Path::new(EMPLOYEE_VESTING_ACCOUNTS_FILE))?;

    let employee_validators: Vec<_> = employee_vesting_accounts
        .inner
        .iter()
        .map(|inner| inner.validator.clone())
        .collect();
    let employee_vesting_accounts: Vec<EmployeePool> = employee_vesting_accounts.try_into()?;
```

**File:** crates/aptos/src/genesis/git.rs (L109-129)
```rust
impl GitOptions {
    pub fn get_client(self) -> CliTypedResult<Client> {
        if self.github_repository.is_none()
            && self.github_token_file.is_none()
            && self.local_repository_dir.is_some()
        {
            Ok(Client::local(self.local_repository_dir.unwrap()))
        } else if self.github_repository.is_some()
            && self.github_token_file.is_some()
            && self.local_repository_dir.is_none()
        {
            Client::github(
                self.github_repository.unwrap(),
                self.github_branch,
                self.github_token_file.unwrap(),
            )
        } else {
            Err(CliError::CommandArgumentError("Must provide either only --local-repository-dir or both --github-repository and --github-token-path".to_string()))
        }
    }
}
```

**File:** crates/aptos/src/genesis/git.rs (L159-184)
```rust
    pub fn get<T: DeserializeOwned + Debug>(&self, path: &Path) -> CliTypedResult<T> {
        match self {
            Client::Local(local_repository_path) => {
                let path = local_repository_path.join(path);

                if !path.exists() {
                    return Err(CliError::UnableToReadFile(
                        path.display().to_string(),
                        "File not found".to_string(),
                    ));
                }

                eprintln!("Reading {}", path.display());
                let mut file = std::fs::File::open(path.as_path())
                    .map_err(|e| CliError::IO(path.display().to_string(), e))?;

                let mut contents = String::new();
                file.read_to_string(&mut contents)
                    .map_err(|e| CliError::IO(path.display().to_string(), e))?;
                from_yaml(&contents)
            },
            Client::Github(client) => {
                from_base64_encoded_yaml(&client.get_file(&path.display().to_string())?)
            },
        }
    }
```

**File:** crates/aptos-genesis/src/mainnet.rs (L122-149)
```rust
    fn generate_genesis_txn(&self) -> Transaction {
        aptos_vm_genesis::encode_aptos_mainnet_genesis_transaction(
            &self.accounts,
            &self.employee_vesting_accounts,
            &self.validators,
            &self.framework,
            self.chain_id,
            &aptos_vm_genesis::GenesisConfiguration {
                allow_new_validators: true,
                is_test: false,
                epoch_duration_secs: self.epoch_duration_secs,
                min_stake: self.min_stake,
                min_voting_threshold: self.min_voting_threshold,
                max_stake: self.max_stake,
                recurring_lockup_duration_secs: self.recurring_lockup_duration_secs,
                required_proposer_stake: self.required_proposer_stake,
                rewards_apy_percentage: self.rewards_apy_percentage,
                voting_duration_secs: self.voting_duration_secs,
                voting_power_increase_limit: self.voting_power_increase_limit,
                employee_vesting_start: self.employee_vesting_start,
                employee_vesting_period_duration: self.employee_vesting_period_duration,
                initial_features_override: self.initial_features_override.clone(),
                randomness_config_override: self.randomness_config_override.clone(),
                jwk_consensus_config_override: self.jwk_consensus_config_override.clone(),
                initial_jwks: vec![],
                keyless_groth16_vk: None,
            },
        )
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L35-43)
```rust
pub fn generate_waypoint<V: VMBlockExecutor>(
    db: &DbReaderWriter,
    genesis_txn: &Transaction,
) -> Result<Waypoint> {
    let ledger_summary = db.reader.get_pre_committed_ledger_summary()?;

    let committer = calculate_genesis::<V>(db, ledger_summary, genesis_txn)?;
    Ok(committer.waypoint)
}
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L79-93)
```rust
impl GenesisCommitter {
    pub fn new(db: Arc<dyn DbWriter>, output: ExecutedChunk) -> Result<Self> {
        let ledger_info = output
            .ledger_info_opt
            .as_ref()
            .ok_or_else(|| anyhow!("LedgerInfo missing."))?
            .ledger_info();
        let waypoint = Waypoint::new_epoch_boundary(ledger_info)?;

        Ok(Self {
            db,
            output,
            waypoint,
        })
    }
```

**File:** terraform/helm/genesis/files/genesis.sh (L131-132)
```shellscript
# run genesis
aptos genesis generate-genesis --local-repository-dir ${WORKSPACE} --output-dir ${WORKSPACE}
```
