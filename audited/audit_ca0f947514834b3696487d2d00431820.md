# Audit Report

## Title
Telemetry Service Lacks HTTPS Enforcement Allowing Unencrypted Metrics Transmission

## Summary
The telemetry service's HTTP clients do not enforce HTTPS connections or validate URL schemes during configuration parsing, allowing telemetry data to be transmitted over unencrypted HTTP if misconfigured. This enables potential man-in-the-middle attacks to intercept and modify metrics data in transit.

## Finding Description
The `gather_and_send()` function in the telemetry service posts Prometheus metrics using `post_prometheus_metrics()`, which relies on HTTP clients (`VictoriaMetricsClient` and `PrometheusRemoteWriteClient`) that accept both HTTP and HTTPS URLs from configuration without validation. [1](#0-0) 

Both client implementations create a default `reqwest::Client` without TLS enforcement: [2](#0-1) [3](#0-2) 

Configuration parsing accepts any valid URL without scheme validation: [4](#0-3) 

The test configuration demonstrates HTTP usage without warnings: [5](#0-4) 

When HTTP URLs are configured, the reqwest client will transmit data unencrypted, allowing network attackers to:
1. Intercept sensitive node metrics (performance data, resource usage, peer information)
2. Modify metrics in transit to cause incorrect monitoring and alerting
3. Inject false telemetry data

## Impact Explanation
This is classified as **Medium severity** because:
- Telemetry data exposure could reveal sensitive operational information about validator nodes
- Modified metrics could mask performance issues or trigger false alarms
- However, this does not directly compromise consensus, transaction execution, or fund security
- Impact is limited to monitoring and observability infrastructure

## Likelihood Explanation
Likelihood is **Medium** because:
- Requires configuration file control or operator error (not directly exploitable)
- Development/testing environments commonly use HTTP for convenience
- Production deployments may inherit insecure test configurations
- No warnings or validation prevent HTTP usage in production
- Network position is required for MITM (moderate attacker capability)

## Recommendation
Implement URL scheme validation in configuration parsing to enforce HTTPS for production deployments:

```rust
// In lib.rs MetricsSinkConfig::make_clients()
fn make_clients(&self) -> HashMap<String, MetricsIngestClient> {
    self.endpoint_urls
        .iter()
        .map(|(name, url)| {
            let parsed_url = Url::parse(url).expect("valid URL in metrics sink config");
            
            // Enforce HTTPS in production
            if parsed_url.scheme() != "https" && !cfg!(test) {
                panic!(
                    "Metrics endpoint '{}' must use HTTPS scheme for security. URL: {}",
                    name, url
                );
            }
            
            // ... rest of client creation
        })
        .collect()
}
```

Additionally, configure reqwest with strict TLS settings:

```rust
// In victoria_metrics.rs and prometheus_remote_write.rs
let client = ReqwestClient::builder()
    .https_only(true)  // Reject HTTP URLs
    .min_tls_version(reqwest::tls::Version::TLS_1_2)
    .build()
    .expect("failed to build HTTP client");
```

## Proof of Concept

```rust
// Test demonstrating HTTP transmission without TLS
#[test]
fn test_http_url_accepted_without_validation() {
    use url::Url;
    use crate::clients::victoria_metrics::{VictoriaMetricsClient, AuthToken};
    
    // HTTP URL is accepted without error
    let http_url = Url::parse("http://insecure-metrics.example.com/api/v1/import/prometheus")
        .unwrap();
    let client = VictoriaMetricsClient::new(http_url.clone(), AuthToken::None);
    
    // Verify client accepts HTTP scheme
    assert_eq!(client.base_url().scheme(), "http");
    
    // In production, this would transmit metrics unencrypted
    // allowing MITM attacks on the network path between
    // telemetry service and metrics backend
}

// Integration test showing MITM scenario
#[tokio::test]
async fn test_mitm_interception_over_http() {
    use httpmock::MockServer;
    
    // Attacker's MITM proxy intercepts HTTP traffic
    let mitm_server = MockServer::start();
    let intercepted_data = Arc::new(Mutex::new(Vec::new()));
    let data_clone = intercepted_data.clone();
    
    let mock = mitm_server.mock(|when, then| {
        when.method("POST").path("/api/v1/import/prometheus");
        then.status(200)
            .body_fn(move |req| {
                // Attacker captures plaintext metrics
                data_clone.lock().unwrap().push(req.body.clone());
                "OK".to_string()
            });
    });
    
    // Telemetry service configured with HTTP URL (no TLS)
    let http_url = Url::parse(&format!("{}/api/v1/import/prometheus", mitm_server.base_url()))
        .unwrap();
    let client = VictoriaMetricsClient::new(http_url, AuthToken::Bearer("secret".into()));
    
    // Send sensitive metrics over HTTP
    let metrics = Bytes::from("validator_performance{peer_id=\"0xabc\"} 100");
    client.post_prometheus_metrics(metrics, vec![], "identity".into()).await.unwrap();
    
    // Attacker successfully intercepted data
    assert!(!intercepted_data.lock().unwrap().is_empty());
}
```

## Notes

**Important Context:**
- This vulnerability requires configuration-level access or operator misconfiguration, not direct network exploitation
- The telemetry service is auxiliary infrastructure, not a core consensus or execution component
- While reqwest validates certificates for HTTPS connections, it does not prevent HTTP usage when HTTP URLs are provided
- Production deployments should use HTTPS, but the code provides no enforcement or warnings
- This represents a defense-in-depth gap rather than a directly exploitable protocol vulnerability

### Citations

**File:** crates/aptos-telemetry-service/src/metrics.rs (L397-444)
```rust
    async fn gather_and_send(&self) -> Result<(), anyhow::Error> {
        let scraped_metrics = prometheus::TextEncoder::new()
            .encode_to_string(&prometheus::default_registry().gather())
            .map_err(|e| anyhow!("text encoding error {}", e))?;

        let mut gzip_encoder = GzEncoder::new(Vec::new(), Compression::default());
        gzip_encoder
            .write_all(scraped_metrics.as_bytes())
            .map_err(|e| anyhow!("gzip encoding error {}", e))?;
        let metrics_body = gzip_encoder.finish()?;

        let extra_labels = vec![
            "namespace=telemetry-web-service".into(),
            format!("cloud_run_revision={}", self.revision),
            format!("cloud_run_service={}", self.service),
            format!("cloud_run_container_id={}", self.instance_id),
            format!("gcp_project_id={}", self.project_id),
        ];

        let start_timer = Instant::now();

        let res = self
            .client
            .post_prometheus_metrics(Bytes::from(metrics_body), extra_labels, "gzip".into())
            .await;

        match res {
            Ok(res) => {
                METRICS_EXPORT_DURATION
                    .with_label_values(&[res.status().as_str()])
                    .observe(start_timer.elapsed().as_millis() as f64);
                if !res.status().is_success() {
                    return Err(anyhow!(
                        "remote write failed to victoria_metrics: {}",
                        res.error_for_status().err().unwrap()
                    ));
                }
            },
            Err(err) => {
                METRICS_EXPORT_DURATION
                    .with_label_values(&["Unknown"])
                    .observe(start_timer.elapsed().as_millis() as f64);
                return Err(anyhow!("error sending remote write request: {}", err));
            },
        }

        Ok(())
    }
```

**File:** crates/aptos-telemetry-service/src/clients/victoria_metrics.rs (L52-62)
```rust
    pub fn new(base_url: Url, auth_token: AuthToken) -> Self {
        let retry_policy = ExponentialBackoff::builder().build_with_max_retries(3);
        let inner = ClientBuilder::new(ReqwestClient::new())
            .with(RetryTransientMiddleware::new_with_policy(retry_policy))
            .build();
        Self {
            inner: DebugIgnore(inner),
            base_url,
            auth_token,
        }
    }
```

**File:** crates/aptos-telemetry-service/src/clients/prometheus_remote_write.rs (L119-130)
```rust
    /// Creates a new Remote Write client.
    pub fn new(base_url: Url, auth_token: AuthToken) -> Self {
        let retry_policy = ExponentialBackoff::builder().build_with_max_retries(3);
        let inner = ClientBuilder::new(ReqwestClient::new())
            .with(RetryTransientMiddleware::new_with_policy(retry_policy))
            .build();
        Self {
            inner: DebugIgnore(inner),
            base_url,
            auth_token,
        }
    }
```

**File:** crates/aptos-telemetry-service/src/lib.rs (L535-556)
```rust
    pub fn make_clients(&self) -> HashMap<String, MetricsIngestClient> {
        self.endpoint_urls
            .iter()
            .map(|(name, url)| {
                let auth_token = self.get_auth_token(name);
                let parsed_url = Url::parse(url).expect("valid URL in metrics sink config");
                let client = match self.backend_type {
                    MetricsBackendType::VictoriaMetrics => MetricsIngestClient::VictoriaMetrics(
                        victoria_metrics::VictoriaMetricsClient::new(parsed_url, auth_token),
                    ),
                    MetricsBackendType::PrometheusRemoteWrite => {
                        MetricsIngestClient::PrometheusRemoteWrite(
                            prometheus_remote_write::PrometheusRemoteWriteClient::new(
                                parsed_url, auth_token,
                            ),
                        )
                    },
                };
                (name.clone(), client)
            })
            .collect()
    }
```

**File:** crates/aptos-telemetry-service/e2e-test/telemetry-config.yaml (L70-83)
```yaml
    metrics_sinks:
      # VictoriaMetrics sink (Prometheus text format)
      - endpoint_urls:
          victoria_metrics: "http://127.0.0.1:8428/api/v1/import/prometheus"
        auth_type: none
        keys_env_var: "TEST_METRICS_KEYS"
        backend_type: victoria_metrics
      
      # Prometheus Remote Write sink (protobuf + snappy)
      - endpoint_urls:
          prometheus_remote_write: "http://127.0.0.1:9090/api/v1/write"
        auth_type: none
        keys_env_var: "TEST_METRICS_KEYS"
        backend_type: prometheus_remote_write
```
