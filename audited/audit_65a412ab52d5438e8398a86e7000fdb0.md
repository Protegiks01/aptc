# Audit Report

## Title
Missing Threshold Validation in Weighted Secret Sharing Configuration Could Break BFT Security Guarantees

## Summary
The pending weighted config implementation for secret sharing lacks validation to ensure that threshold values maintain BFT security properties (2/3 Byzantine fault tolerance) when transitioning from uniform weights to stake-weighted configurations. This could allow a minority coalition of validators with less than 2/3 total stake to successfully reconstruct secret shares, violating consensus safety assumptions.

## Finding Description
The codebase has two related configuration types for secret sharing that currently use hardcoded uniform weights (all validators have weight 1) with plans to implement weighted configurations based on validator stake: [1](#0-0) [2](#0-1) 

Both return hardcoded weight of 1, with comments indicating future weighted config implementation. The critical security issue arises because:

1. **Current state**: `SecretShareConfig` uses `WeightedConfigArkworks<Fr>` as its threshold config type, with threshold accessed via: [3](#0-2) 

2. **Missing validation**: The `WeightedConfig::new()` constructor accepts arbitrary threshold values without validating BFT security properties: [4](#0-3) 

The validation only checks that `threshold_weight > 0` and delegates to the underlying `ShamirThresholdConfig`, which only validates `t <= n` without checking if the threshold maintains the required 2/3 ratio for BFT: [5](#0-4) 

3. **Attack scenario**: During epoch transition or config migration, if a `WeightedConfigArkworks` is created with weighted validator shares (e.g., [2,2,1,1] for total weight 6) but retains an old threshold value designed for uniform weights (e.g., threshold=3):

   - Validators with combined weight â‰¥ 3 can reconstruct (e.g., validator with weight 2 + validator with weight 1)
   - This represents only 2 validators with 150/300 = 50% total stake
   - **Violates the 2/3 BFT requirement**: A minority coalition (< 67% stake) can control secret reconstruction

4. **Share aggregation check**: The vulnerability manifests when shares are aggregated: [6](#0-5) 

If `threshold()` returns an incorrect value (3 instead of 5 for total weight 6), aggregation succeeds prematurely with insufficient Byzantine fault tolerance.

5. **Correct threshold calculation**: The DKG rounding system properly calculates weighted thresholds: [7](#0-6) 

However, there's no enforcement that `SecretShareConfig` instances use properly calculated thresholds from DKG rounding.

## Impact Explanation
**Medium Severity** - State inconsistencies requiring intervention, potential consensus safety violation.

If misconfigured weighted configs are deployed, the system would allow validators controlling < 2/3 stake to reconstruct secret shares. This breaks the fundamental BFT assumption that requires > 2/3 honest stake for security. While this doesn't directly lead to fund theft, it could:

- Compromise randomness beacon integrity (if < 2/3 validators reconstruct beacon secrets)
- Enable premature secret reconstruction by minority coalitions
- Violate Invariant #2: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine"
- Require emergency intervention and config rollback

## Likelihood Explanation
**Low to Medium Likelihood** during implementation phase.

This vulnerability would manifest when:
1. The weighted config implementation is completed (currently TODO)
2. System operators migrate from uniform to weighted configurations during epoch transition
3. Threshold values are not recalculated using the DKG rounding algorithm
4. No validation prevents creating `WeightedConfig` with BFT-violating thresholds

The likelihood is reduced by the fact that the weighted implementation is incomplete, but increases if:
- Migration is rushed without proper validation
- Developers assume backward compatibility without threshold recalculation
- No integration tests verify BFT properties with weighted configs

## Recommendation

Add validation in `WeightedConfig::new()` to enforce BFT security properties:

```rust
pub fn new(threshold_weight: usize, weights: Vec<usize>) -> anyhow::Result<Self> {
    if threshold_weight == 0 {
        return Err(anyhow!("expected the minimum reconstruction weight to be > 0"));
    }

    if weights.is_empty() {
        return Err(anyhow!("expected a non-empty vector of player weights"));
    }
    
    let W: usize = weights.iter().sum();
    
    // NEW VALIDATION: Enforce BFT 2/3 threshold requirement
    let min_bft_threshold = (W * 2) / 3 + 1;
    if threshold_weight < min_bft_threshold {
        return Err(anyhow!(
            "threshold {} violates BFT security: must be >= {} (2/3 of total weight {})",
            threshold_weight, min_bft_threshold, W
        ));
    }
    
    // ... rest of implementation
}
```

Additionally:
- Document that `SecretShareConfig` creation must use DKG-calculated thresholds
- Add integration tests verifying BFT properties with various weight distributions
- Implement epoch transition validation to prevent deploying misconfigured weighted configs

## Proof of Concept

```rust
use aptos_crypto::weighted_config::WeightedConfigArkworks;

#[test]
fn test_bft_violation_with_incorrect_threshold() {
    // Scenario: 4 validators with stakes [100, 100, 50, 50]
    // After rounding: weights [2, 2, 1, 1], total weight = 6
    // Correct BFT threshold should be: ceil(6 * 2/3) + 1 = 5
    
    // VULNERABLE: Create config with old threshold designed for uniform weights
    let vulnerable_config = WeightedConfigArkworks::new(
        3,  // Old threshold (3 out of 4 validators)
        vec![2, 2, 1, 1]  // New weighted shares
    ).expect("Should create config");
    
    // This allows reconstruction with only 2 validators:
    // - Validator 0 (weight 2) + Validator 2 (weight 1) = 3 >= threshold
    // - But this is only 150/300 = 50% stake, violating 2/3 BFT requirement!
    
    assert_eq!(vulnerable_config.get_threshold_weight(), 3);
    assert_eq!(vulnerable_config.get_total_weight(), 6);
    
    // Correct config should use threshold = 5
    let correct_config = WeightedConfigArkworks::new(
        5,  // Correct BFT threshold
        vec![2, 2, 1, 1]
    ).expect("Should create config");
    
    assert_eq!(correct_config.get_threshold_weight(), 5);
    // Now requires validators with combined weight >= 5 (e.g., first 3 validators)
    // This represents >= 2/3 stake, maintaining BFT security
}
```

**Notes**

This vulnerability is currently latent as the weighted config implementation remains incomplete (indicated by TODO comments). However, it represents a critical design gap that must be addressed before deploying weighted configurations. The lack of BFT threshold validation in `WeightedConfig::new()` creates a dangerous API that could lead to consensus safety violations if misused during system upgrades. The proper solution requires both validation at config creation time and integration with the DKG rounding algorithm to ensure all deployed configurations maintain the 2/3 Byzantine fault tolerance requirement.

### Citations

**File:** types/src/secret_sharing.rs (L188-190)
```rust
    pub fn threshold(&self) -> u64 {
        self.config.get_threshold_config().t as u64
    }
```

**File:** types/src/secret_sharing.rs (L196-198)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }
```

**File:** consensus/src/rand/secret_sharing/types.rs (L99-102)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        // daniel todo: use weighted config
        1
    }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L67-105)
```rust
    pub fn new(threshold_weight: usize, weights: Vec<usize>) -> anyhow::Result<Self> {
        if threshold_weight == 0 {
            return Err(anyhow!(
                "expected the minimum reconstruction weight to be > 0"
            ));
        }

        if weights.is_empty() {
            return Err(anyhow!("expected a non-empty vector of player weights"));
        }
        let max_weight = *weights.iter().max().unwrap();
        let min_weight = *weights.iter().min().unwrap();

        let n = weights.len();
        let W = weights.iter().sum();

        // e.g., Suppose the weights for players 0, 1 and 2 are [2, 4, 3]
        // Then, our PVSS transcript implementation will store a vector of 2 + 4 + 3 = 9 shares,
        // such that:
        //  - Player 0 will own the shares at indices [0..2), i.e.,starting index 0
        //  - Player 1 will own the shares at indices [2..2 + 4) = [2..6), i.e.,starting index 2
        //  - Player 2 will own the shares at indices [6, 6 + 3) = [6..9), i.e., starting index 6
        let mut starting_index = Vec::with_capacity(weights.len());
        starting_index.push(0);

        for w in weights.iter().take(n - 1) {
            starting_index.push(starting_index.last().unwrap() + w);
        }

        let tc = TC::new(threshold_weight, W)?;
        Ok(WeightedConfig {
            tc,
            num_players: n,
            weights,
            starting_index,
            max_weight,
            min_weight,
        })
    }
```

**File:** crates/aptos-crypto/src/arkworks/shamir.rs (L88-92)
```rust
    fn new(t: usize, n: usize) -> Result<Self> {
        let domain = Radix2EvaluationDomain::new(n) // Note that `new(n)` internally does `n.next_power_of_two()`
            .expect("Invalid domain size: {}");
        Ok(Self { n, t, domain })
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L38-46)
```rust
    pub fn try_aggregate(
        self,
        secret_share_config: &SecretShareConfig,
        metadata: SecretShareMetadata,
        decision_tx: Sender<SecretSharedKey>,
    ) -> Either<Self, SecretShare> {
        if self.total_weight < secret_share_config.threshold() {
            return Either::Left(self);
        }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L98-106)
```rust
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();
```
