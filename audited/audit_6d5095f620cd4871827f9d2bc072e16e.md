# Audit Report

## Title
Governance Early Resolution Mechanism Breaks Due to Incorrect Total Supply Override in Sharded Execution

## Summary
The `total_supply_base_view_override()` function in sharded block execution returns a fixed base value (`u128::MAX >> 1 ≈ 1.7×10³⁸`) instead of the actual APT total supply (~10¹⁷). This causes governance proposals created during sharded execution to store an astronomically high early resolution threshold, making early resolution impossible even with >50% of voting power. [1](#0-0) 

## Finding Description

During sharded block execution, all transactions (both sharded and global) use `AggregatorOverriddenStateView` which intercepts reads of `TOTAL_SUPPLY_STATE_KEY`: [2](#0-1) 

When governance proposals are created via `aptos_governance::create_proposal_v2_impl()`, the code reads the total supply to calculate the early resolution threshold: [3](#0-2) 

The early resolution threshold is permanently stored in the `Proposal` struct: [4](#0-3) 

And checked during resolution without recalculation: [5](#0-4) 

**The Attack Flow:**
1. Sharded execution is used for a block containing governance proposal creation
2. `coin::supply<AptosCoin>()` reads from the aggregator stored at `TOTAL_SUPPLY_STATE_KEY`
3. The override returns `TOTAL_SUPPLY_AGGR_BASE_VAL` (~1.7×10³⁸) instead of actual supply (~10¹⁷)
4. Early resolution threshold = `1.7×10³⁸ / 2 + 1 ≈ 8.5×10³⁷`
5. This value is stored in the proposal permanently
6. Actual voting power cannot reach this threshold (21 orders of magnitude too high)
7. Early resolution becomes mathematically impossible

While `aggregate_and_update_total_supply()` corrects the total supply value in transaction outputs post-execution, it does NOT correct the already-stored early resolution threshold in the proposal: [6](#0-5) 

## Impact Explanation

**Severity: Medium** - This breaks the governance early resolution mechanism, violating the "Governance Integrity" invariant. Proposals created during sharded execution cannot resolve early even with overwhelming support (>50% of total supply voting). However:
- Proposals can still resolve after expiration time
- Governance continues to function, just slower
- No funds are at risk
- This constitutes "State inconsistencies requiring intervention" per Medium severity criteria

## Likelihood Explanation

**Likelihood: Low to Unknown** - This vulnerability's likelihood depends entirely on whether sharded execution is enabled in production and used for blocks containing governance transactions. The codebase shows:
- Sharded execution exists as a separate execution mode
- No clear feature flag or production configuration indicator was found
- A TODO comment suggests this is a temporary workaround [7](#0-6) 

However, an unprivileged attacker **cannot trigger** this condition - they cannot force sharded execution or control which execution path their transactions take.

## Recommendation

**Option 1: Skip supply-dependent calculations during sharded execution**
Detect when executing under `AggregatorOverriddenStateView` and skip setting early resolution thresholds, or read from an alternative source.

**Option 2: Pass actual total supply to sharded execution**
Instead of using a fixed override, pass the actual total supply value to the sharded executor and use it for the override base.

**Option 3: Recalculate thresholds post-aggregation**
After `aggregate_and_update_total_supply()` corrects values, scan for governance proposals created in the block and update their thresholds.

**Option 4: Disable governance proposal creation during sharded execution**
Mark governance proposal creation transactions as "global-only" that must bypass sharding.

## Proof of Concept

```rust
#[test]
fn test_governance_threshold_corruption_in_sharded_execution() {
    // Setup: Create a test environment with sharded execution
    let state_view = create_test_state_view();
    let aggr_overridden_view = AggregatorOverriddenStateView::new(
        &state_view,
        TOTAL_SUPPLY_AGGR_BASE_VAL
    );
    
    // 1. Read total supply through override
    let supply_key = TOTAL_SUPPLY_STATE_KEY.clone();
    let overridden_supply = aggr_overridden_view
        .get_state_value(&supply_key)
        .unwrap()
        .unwrap();
    let supply_value: u128 = bcs::from_bytes(overridden_supply.bytes()).unwrap();
    
    // 2. Verify it's the fixed base value, not actual supply
    assert_eq!(supply_value, TOTAL_SUPPLY_AGGR_BASE_VAL);
    
    // 3. Calculate early resolution threshold as governance would
    let early_resolution_threshold = supply_value / 2 + 1;
    
    // 4. Get actual total supply from real state
    let actual_supply: u128 = state_view
        .get_state_value(&supply_key)
        .unwrap()
        .map(|v| bcs::from_bytes(v.bytes()).unwrap())
        .unwrap();
    
    // 5. Demonstrate the threshold is impossibly high
    assert!(early_resolution_threshold > actual_supply * 1_000_000_000_000_000_000_000u128);
    println!("Threshold: {}, Actual Supply: {}", early_resolution_threshold, actual_supply);
    println!("Threshold is {} orders of magnitude higher than actual supply", 
             (early_resolution_threshold / actual_supply).ilog10());
}
```

---

**NOTE:** Upon strict validation, this vulnerability has a critical limitation: **it cannot be exploited by an unprivileged attacker**. The vulnerability requires sharded execution to be enabled and used for governance transactions, which is not under attacker control. While this is a real bug that breaks the early resolution mechanism, it does not meet the "exploitable by unprivileged attacker" criterion from the validation checklist.

The issue is better classified as a **latent implementation bug** rather than an exploitable vulnerability in the traditional security sense.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/aggr_overridden_state_view.rs (L29-35)
```rust
    fn total_supply_base_view_override(&self) -> Result<Option<StateValue>> {
        Ok(Some(StateValue::new_legacy(
            bcs::to_bytes(&self.total_supply_aggr_base_val)
                .unwrap()
                .into(),
        )))
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/aggr_overridden_state_view.rs (L41-48)
```rust
    fn get_state_value(&self, state_key: &StateKey) -> Result<Option<StateValue>> {
        if *state_key == *TOTAL_SUPPLY_STATE_KEY {
            // TODO: Remove this when we have aggregated total supply implementation for remote
            //       sharding. For now we need this because after all the txns are executed, the
            //       proof checker expects the total_supply to read/written to the tree.
            self.base_view.get_state_value(state_key)?;
            return self.total_supply_base_view_override();
        }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L439-449)
```text
        // We want to allow early resolution of proposals if more than 50% of the total supply of the network coins
        // has voted. This doesn't take into subsequent inflation/deflation (rewards are issued every epoch and gas fees
        // are burnt after every transaction), but inflation/delation is very unlikely to have a major impact on total
        // supply during the voting period.
        let total_voting_token_supply = coin::supply<AptosCoin>();
        let early_resolution_vote_threshold = option::none<u128>();
        if (option::is_some(&total_voting_token_supply)) {
            let total_supply = *option::borrow(&total_voting_token_supply);
            // 50% + 1 to avoid rounding errors.
            early_resolution_vote_threshold = option::some(total_supply / 2 + 1);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L84-116)
```text
    struct Proposal<ProposalType: store> has store {
        /// Required. The address of the proposer.
        proposer: address,

        /// Required. Should contain enough information to execute later, for example the required capability.
        /// This is stored as an option so we can return it to governance when the proposal is resolved.
        execution_content: Option<ProposalType>,

        /// Optional. Value is serialized value of an attribute.
        /// Currently, we have three attributes that are used by the voting flow.
        /// 1. RESOLVABLE_TIME_METADATA_KEY: this is uesed to record the resolvable time to ensure that resolution has to be done non-atomically.
        /// 2. IS_MULTI_STEP_PROPOSAL_KEY: this is used to track if a proposal is single-step or multi-step.
        /// 3. IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY: this attribute only applies to multi-step proposals. A single-step proposal will not have
        /// this field in its metadata map. The value is used to indicate if a multi-step proposal is in execution. If yes, we will disable further
        /// voting for this multi-step proposal.
        metadata: SimpleMap<String, vector<u8>>,

        /// Timestamp when the proposal was created.
        creation_time_secs: u64,

        /// Required. The hash for the execution script module. Only the same exact script module can resolve this
        /// proposal.
        execution_hash: vector<u8>,

        /// A proposal is only resolved if expiration has passed and the number of votes is above threshold.
        min_vote_threshold: u128,
        expiration_secs: u64,

        /// Optional. Early resolution threshold. If specified, the proposal can be resolved early if the total
        /// number of yes or no votes passes this threshold.
        /// For example, this can be set to 50% of the total supply of the voting token, so if > 50% vote yes or no,
        /// the proposal can be resolved before expiration.
        early_resolution_vote_threshold: Option<u128>,
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L620-628)
```text
    public fun can_be_resolved_early<ProposalType: store>(proposal: &Proposal<ProposalType>): bool {
        if (option::is_some(&proposal.early_resolution_vote_threshold)) {
            let early_resolution_threshold = *option::borrow(&proposal.early_resolution_vote_threshold);
            if (proposal.yes_votes >= early_resolution_threshold || proposal.no_votes >= early_resolution_threshold) {
                return true
            };
        };
        false
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L168-212)
```rust
pub fn aggregate_and_update_total_supply<S: StateView>(
    sharded_output: &mut Vec<Vec<Vec<TransactionOutput>>>,
    global_output: &mut [TransactionOutput],
    state_view: &S,
    executor_thread_pool: Arc<rayon::ThreadPool>,
) {
    let num_shards = sharded_output.len();
    let num_rounds = sharded_output[0].len();

    // The first element is 0, which is the delta for shard 0 in round 0. +1 element will contain
    // the delta for the global shard
    let mut aggr_total_supply_delta = vec![DeltaU128::default(); num_shards * num_rounds + 1];

    // No need to parallelize this as the runtime is O(num_shards * num_rounds)
    // TODO: Get this from the individual shards while getting 'sharded_output'
    let mut aggr_ts_idx = 1;
    for round in 0..num_rounds {
        sharded_output.iter().for_each(|shard_output| {
            let mut curr_delta = DeltaU128::default();
            // Though we expect all the txn_outputs to have total_supply, there can be
            // exceptions like 'block meta' (first txn in the block) and 'chkpt info' (last txn
            // in the block) which may not have total supply. Hence we iterate till we find the
            // last txn with total supply.
            for txn in shard_output[round].iter().rev() {
                if let Some(last_txn_total_supply) = txn.write_set().get_total_supply() {
                    curr_delta =
                        DeltaU128::get_delta(last_txn_total_supply, TOTAL_SUPPLY_AGGR_BASE_VAL);
                    break;
                }
            }
            aggr_total_supply_delta[aggr_ts_idx] =
                curr_delta + aggr_total_supply_delta[aggr_ts_idx - 1];
            aggr_ts_idx += 1;
        });
    }

    // The txn_outputs contain 'txn_total_supply' with
    // 'CrossShardStateViewAggrOverride::total_supply_aggr_base_val' as the base value.
    // The actual 'total_supply_base_val' is in the state_view.
    // The 'delta' for the shard/round is in aggr_total_supply_delta[round * num_shards + shard_id + 1]
    // For every txn_output, we have to compute
    //      txn_total_supply = txn_total_supply - CrossShardStateViewAggrOverride::total_supply_aggr_base_val + total_supply_base_val + delta
    // While 'txn_total_supply' is u128, the intermediate computation can be negative. So we use
    // DeltaU128 to handle any intermediate underflow of u128.
    let total_supply_base_val: u128 = get_state_value(&TOTAL_SUPPLY_STATE_KEY, state_view).unwrap();
```
