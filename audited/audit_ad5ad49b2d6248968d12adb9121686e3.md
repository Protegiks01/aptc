# Audit Report

## Title
Race Condition in Faucet Allows Multiple Funding of Same Account Leading to Faucet Drainage

## Summary
A Time-of-Check-Time-of-Use (TOCTOU) race condition in the Aptos Faucet's `TransferFunder` implementation allows an attacker to fund the same account multiple times by sending concurrent requests. This bypasses the intended "fund once per account" restriction, enabling complete drainage of the faucet's balance.

## Finding Description

The vulnerability exists in the gap between checking if an account exists and actually funding it. The attack flow is:

**Step 1: Concurrent Requests Pass Checker Phase**

The `fund_inner()` function calls `preprocess_request()` which runs all checkers: [1](#0-0) 

The checkers only validate by IP address or JWT (Firebase UID), NOT by receiver account address: [2](#0-1) 

This means multiple requests from different IPs/JWTs targeting the same receiver account will ALL pass the checker phase.

**Step 2: Race Window in TransferFunder**

After passing checkers, `funder.fund()` is called. In the `TransferFunder` implementation, account existence is checked: [3](#0-2) 

If the account doesn't exist (`receiver_seq_num.is_none()`), the request proceeds to fund it. However, **multiple concurrent requests can all see that the account doesn't exist yet** before any of them completes, allowing all to proceed.

**Step 3: Incorrect Assumption About aptos_account::transfer**

The code comment claims the Move function rejects existing accounts: [4](#0-3) 

However, the actual `aptos_account::transfer` implementation shows this is FALSE: [5](#0-4) 

The function **creates the account if it doesn't exist, but happily transfers to existing accounts**. This means the second (and subsequent) concurrent requests will successfully transfer funds to the already-created account.

**Step 4: Queue System Doesn't Prevent This**

The `update_sequence_numbers()` function has a queue, but it only prevents the funder from having too many outstanding transactions. Once a request gets its sequence numbers and exits the function, it's removed from the queue: [6](#0-5) 

This allows subsequent requests for the same receiver to proceed through the same checks.

**Attack Scenario:**
1. Attacker sends Request A from IP_1 to fund account X with amount Y
2. Simultaneously sends Request B from IP_2 to fund account X with amount Y
3. Both pass IP rate limits (different IPs)
4. Both call `update_sequence_numbers()` and see account X doesn't exist
5. Request A executes first: creates account X, transfers Y coins
6. Request B executes: transfers another Y coins to now-existing account X
7. Account X has 2Y coins - **DOUBLE FUNDED**

Repeat with N concurrent requests from N different IPs = N×Y coins stolen from faucet.

## Impact Explanation

**Critical Severity** - Loss of Funds (theft/minting)

This vulnerability allows complete drainage of the faucet's balance:
- Attacker can create unlimited accounts and fund each multiple times
- Each account can receive N× the intended amount (where N = concurrent requests)
- With 100 concurrent requests from different IPs/proxies, attacker receives 100× the per-request amount
- Faucet balance can be depleted to minimum_funds threshold
- On testnets with well-funded faucets, this represents significant token theft
- If faucet is misconfigured with mainnet funds, real economic loss occurs

## Likelihood Explanation

**Very High Likelihood:**
- Trivial to exploit - just send concurrent HTTP POST requests
- No special permissions needed
- Proxies/VPNs provide unlimited different IPs to bypass rate limiting
- JWT-based rate limiting can be bypassed with multiple Firebase accounts
- Race window is large (entire transaction submission duration)
- No transaction-level protection against multiple fundings of same account

## Recommendation

Implement per-receiver-account locking or atomic check-and-fund:

**Option 1: Receiver-based rate limiting in Checkers**
Add a checker that tracks funded receiver accounts in Redis/storage and rejects requests for already-funded accounts, similar to IP-based rate limiting but keyed by receiver address.

**Option 2: Atomic check in Move contract**
Modify the funding to use a custom Move function that aborts if the account already exists:
```move
public entry fun create_and_fund_once(source: &signer, to: address, amount: u64) {
    assert!(!account::exists_at(to), EACCOUNT_ALREADY_EXISTS);
    create_account(to);
    coin::transfer<AptosCoin>(source, to, amount);
}
```

**Option 3: Distributed lock on receiver address**
Before checking account existence, acquire a distributed lock (in Redis) on the receiver address. Hold the lock through the entire check-and-fund operation.

## Proof of Concept

```bash
#!/bin/bash
# Exploit script - sends 10 concurrent requests to fund same account

FAUCET_URL="http://faucet.testnet.aptoslabs.com/fund"
RECEIVER_ADDRESS="0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
AMOUNT="100000000"  # 1 APT in octas

# Send 10 concurrent requests from different source IPs (use proxies/VPNs)
for i in {1..10}; do
  curl -X POST "$FAUCET_URL" \
    -H "Content-Type: application/json" \
    -H "X-Forwarded-For: 1.2.3.$i" \
    -d "{\"address\":\"$RECEIVER_ADDRESS\",\"amount\":$AMOUNT}" &
done

wait

# Check balance - should be ~10 APT instead of 1 APT
aptos account list --account $RECEIVER_ADDRESS
```

**Expected Result:** Account receives ~10× the intended amount due to race condition.

**Rust Integration Test:**
```rust
#[tokio::test]
async fn test_concurrent_funding_race_condition() {
    let faucet = setup_test_faucet().await;
    let receiver = AccountAddress::random();
    
    // Spawn 10 concurrent funding requests for same account
    let mut handles = vec![];
    for i in 0..10 {
        let faucet_clone = faucet.clone();
        let handle = tokio::spawn(async move {
            faucet_clone.fund(
                Some(100_000_000),
                receiver,
                None,
                false,
                false
            ).await
        });
        handles.push(handle);
    }
    
    // Wait for all to complete
    let results: Vec<_> = futures::future::join_all(handles).await;
    let successful_fundings = results.iter().filter(|r| r.is_ok()).count();
    
    // Vulnerability: Multiple successful fundings instead of 1
    assert!(successful_fundings > 1, "Race condition allows multiple fundings");
    
    // Check actual balance
    let balance = check_account_balance(receiver).await;
    assert!(balance > 100_000_000, "Account received multiple fundings");
}
```

## Notes

This vulnerability affects the `TransferFunder` implementation specifically. The `MintFunder` may have different behavior but should also be audited for similar race conditions. The root cause is the lack of atomicity between the account existence check and the funding operation, combined with checkers that don't track by receiver account address.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L294-296)
```rust
        let (checker_data, bypass, _semaphore_permit) = self
            .preprocess_request(&fund_request, source_ip, header_map, dry_run)
            .await?;
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L236-243)
```rust
        // Generate a key corresponding to this identifier and the current day.
        let key_prefix = self.ratelimit_key_provider.ratelimit_key_prefix();
        let key_value = self
            .ratelimit_key_provider
            .ratelimit_key_value(&data)
            .await?;
        let (key, seconds_until_next_day) =
            self.get_key_and_secs_until_next_day(key_prefix, &key_value);
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L284-306)
```rust
        let (_funder_seq_num, receiver_seq_num) = update_sequence_numbers(
            &client,
            &self.faucet_account,
            &self.outstanding_requests,
            receiver_address,
            amount,
            self.wait_for_outstanding_txns_secs,
            DEFAULT_ASSET_NAME,
        )
        .await?;

        // When updating the sequence numbers, we expect that the receiver sequence
        // number should be None, because the account should not exist yet.
        if receiver_seq_num.is_some() {
            return Err(AptosTapError::new(
                "Account ineligible".to_string(),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(vec![RejectionReason::new(
                format!("Account {} already exists", receiver_address),
                RejectionReasonCode::AccountAlreadyExists,
            )]));
        }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L308-310)
```rust
        // This Move function checks if the account exists, and if it does,
        // returns an error. If not, it creates the account and transfers the
        // requested amount of coins to it.
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L82-97)
```text
    public entry fun transfer(source: &signer, to: address, amount: u64) {
        if (!account::exists_at(to)) {
            create_account(to)
        };

        if (features::operations_default_to_fa_apt_store_enabled()) {
            fungible_transfer_only(source, to, amount)
        } else {
            // Resource accounts can be created without registering them to receive APT.
            // This conveniently does the registration if necessary.
            if (!coin::is_account_registered<AptosCoin>(to)) {
                coin::register<AptosCoin>(&create_signer(to));
            };
            coin::transfer<AptosCoin>(source, to, amount)
        }
    }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L253-264)
```rust
            if is_at_front {
                // There might have been two requests with the same parameters, so we ensure that
                // we only pop off one of them. We do a read lock first since that is cheap,
                // followed by a write lock.
                drop(requests_map);
                let mut requests_map = outstanding_requests.write().await;
                if let Some(queue) = requests_map.get_mut(asset_name) {
                    if queue.first() == Some(&request_key) {
                        queue.remove(0);
                    }
                }
                break;
```
