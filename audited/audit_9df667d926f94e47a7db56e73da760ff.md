# Audit Report

## Title
Resource Exhaustion via Unchecked Frame Length in Handshake Protocol

## Summary
The `exchange_handshake()` function in the identity protocol allocates memory based on an attacker-controlled u16 length prefix before validating the actual data size. An attacker can claim a maximum frame size of 65,535 bytes while sending minimal data, causing wasteful memory allocation and enabling resource exhaustion attacks against nodes accepting untrusted connections.

## Finding Description

The vulnerability exists in the handshake exchange protocol used during peer connection establishment. The attack flow is:

1. **Connection Establishment**: In `MaybeMutual` authentication mode (used by public fullnodes and VFNs), any peer can establish a connection after completing the Noise cryptographic handshake. [1](#0-0) 

2. **Handshake Exchange**: After Noise handshake, peers exchange protocol information via `exchange_handshake()`: [2](#0-1) 

3. **Vulnerable Frame Reading**: The `read_u16frame()` function reads a 2-byte length prefix and **immediately allocates a buffer of that size** before reading actual data: [3](#0-2) 

4. **Resource Amplification**: A legitimate `HandshakeMsg` (containing chain_id, network_id, and supported protocols) serializes to approximately 100-500 bytes. However, an attacker can:
   - Send length prefix: `[0xFF, 0xFF]` (65,535 bytes in big-endian)
   - Trigger allocation of 64KB buffer via `buf.resize(65535, 0)`
   - Send only minimal actual data or delay sending
   - Force the node to waste ~64KB per connection for up to 30 seconds (transport timeout) [4](#0-3) 

5. **Attack Amplification**: With the default inbound connection limit: [5](#0-4) 

An attacker can open 100 concurrent connections, each wasting 65KB, for a total of ~6.5 MB per network. Multiple networks (validator, VFN, public) can be targeted simultaneously.

**Invariant Violated**: "Resource Limits: All operations must respect gas, storage, and computational limits" - the implementation allocates resources before validation, enabling amplification attacks.

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:

- **Limited Resource Exhaustion**: While the attack wastes memory (6.5 MB per network with default settings), it does not cause total node failure on modern servers with GB of RAM.

- **Sustained Attack Potential**: An attacker can repeatedly reconnect as connections timeout (30 seconds), maintaining continuous resource pressure.

- **No Authentication Required**: In `MaybeMutual` mode, the attack requires no trusted credentialsâ€”any peer with a generated keypair can exploit this.

- **Violates Defense-in-Depth**: The vulnerability breaks the principle of "validate before allocate," creating unnecessary attack surface before authentication completes.

This does not reach High severity because:
- Memory waste is bounded by connection limits
- Does not cause validator slowdowns or API crashes by itself
- Requires sustained effort to maintain pressure

However, it could **contribute to DoS** when combined with other resource exhaustion vectors.

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity: Low** - Attacker only needs to:
  1. Generate an x25519 keypair (trivial)
  2. Complete Noise handshake (standard protocol)
  3. Send 2 malformed bytes during handshake exchange

- **Attack Cost: Minimal** - No stake, registration, or economic cost required

- **Target Availability: High** - Public fullnodes and VFNs use `MaybeMutual` mode to accept connections from any peer

- **Detection Difficulty: Medium** - Attack appears as legitimate connection attempts until the malformed frame length is sent

## Recommendation

**Implement maximum frame size validation before allocation:**

Add a constant for maximum expected handshake size and validate before allocating:

```rust
// In network/netcore/src/framing.rs
const MAX_HANDSHAKE_FRAME_SIZE: u16 = 4096; // Conservative limit for HandshakeMsg

pub async fn read_u16frame<'stream, 'buf, 'c, TSocket>(
    mut stream: &'stream mut TSocket,
    buf: &'buf mut BytesMut,
) -> Result<()>
where
    'stream: 'c,
    'buf: 'c,
    TSocket: AsyncRead + Unpin,
{
    let len = read_u16frame_len(&mut stream).await?;
    
    // Validate frame size before allocation
    if len > MAX_HANDSHAKE_FRAME_SIZE {
        return Err(io::Error::new(
            io::ErrorKind::InvalidData,
            format!("Frame size {} exceeds maximum {}", len, MAX_HANDSHAKE_FRAME_SIZE),
        ));
    }
    
    buf.resize(len as usize, 0);
    stream.read_exact(buf.as_mut()).await?;
    Ok(())
}
```

Alternatively, create a separate `read_u16frame_with_limit()` function used specifically for handshake exchanges, while keeping the unlimited version for authenticated channels.

## Proof of Concept

```rust
// Rust PoC demonstrating the resource exhaustion attack
// Add to network/framework/src/protocols/identity.rs tests

#[cfg(test)]
mod exploit_tests {
    use super::*;
    use aptos_memsocket::MemorySocket;
    use bytes::BytesMut;
    use futures::{executor::block_on, io::AsyncWriteExt};
    use std::io;

    #[test]
    fn test_handshake_resource_exhaustion() {
        let (mut attacker, mut victim) = MemorySocket::new_pair();

        // Attacker sends malicious frame claiming 65535 bytes
        let attack = async move {
            // Send u16::MAX as frame length (big-endian)
            attacker.write_all(&[0xFF, 0xFF]).await.unwrap();
            attacker.flush().await.unwrap();
            
            // Send only minimal data (not the claimed 65535 bytes)
            attacker.write_all(b"small_data").await.unwrap();
            attacker.flush().await.unwrap();
            
            // Close connection, leaving victim with wasted allocation
            drop(attacker);
        };

        // Victim attempts to read handshake
        let victim_read = async move {
            let mut response = BytesMut::new();
            
            // This will allocate 65535 bytes based on attacker's claim
            let result = read_u16frame(&mut victim, &mut response).await;
            
            // Verify allocation happened
            assert_eq!(response.capacity(), 65535);
            
            // read_exact will fail due to insufficient data
            assert!(result.is_err());
            assert_eq!(result.unwrap_err().kind(), io::ErrorKind::UnexpectedEof);
            
            println!("Victim allocated {} bytes for actual data size: 10 bytes", 
                     response.capacity());
        };

        block_on(futures::future::join(attack, victim_read));
    }

    #[test]
    fn test_amplification_factor() {
        // Demonstrate amplification: attacker sends 2 bytes, victim allocates 65535
        let amplification_factor = 65535.0 / 2.0;
        assert_eq!(amplification_factor, 32767.5);
        
        // With 100 connections (default limit), attacker sends 200 bytes total
        // but causes victim to allocate 6.5 MB
        let connections = 100;
        let attacker_bytes = connections * 2;
        let victim_bytes = connections * 65535;
        
        println!("Amplification attack:");
        println!("  Attacker sends: {} bytes", attacker_bytes);
        println!("  Victim allocates: {} MB", victim_bytes / 1_048_576);
        println!("  Amplification: {}x", victim_bytes / attacker_bytes);
    }
}
```

**Notes:**

This vulnerability demonstrates a classic violation of the "validate-then-allocate" security principle. While the impact is limited by connection limits and modern hardware capabilities, it represents an unnecessary attack surface that should be eliminated. The fix is straightforward: validate the frame size against expected bounds before allocating memory.

The issue specifically affects the identity handshake protocol's use of u16-prefixed framing. The main network messaging layer uses a different framing mechanism with larger but validated limits (MAX_FRAME_SIZE = 4 MiB), showing that size validation is a recognized concern elsewhere in the codebase.

### Citations

**File:** network/framework/src/noise/handshake.rs (L95-98)
```rust
    /// In `MaybeMutual` mode, the dialer authenticates the server and the server will allow all
    /// inbound connections from any peer but will mark connections as `Trusted` if the incoming
    /// connection is apart of its trusted peers set.
    MaybeMutual(Arc<PeersAndMetadata>),
```

**File:** network/framework/src/protocols/identity.rs (L30-32)
```rust
    // Read handshake message from the Remote
    let mut response = BytesMut::new();
    read_u16frame(socket, &mut response).await?;
```

**File:** network/netcore/src/framing.rs (L18-20)
```rust
    let len = read_u16frame_len(&mut stream).await?;
    buf.resize(len as usize, 0);
    stream.read_exact(buf.as_mut()).await?;
```

**File:** network/framework/src/transport/mod.rs (L40-41)
```rust
/// A timeout for the connection to open and complete all of the upgrade steps.
pub const TRANSPORT_TIMEOUT: Duration = Duration::from_secs(30);
```

**File:** config/src/config/network_config.rs (L100-100)
```rust
    /// The initial peers to connect to prior to onchain discovery
```
