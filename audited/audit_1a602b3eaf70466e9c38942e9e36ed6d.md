# Audit Report

## Title
Integer Overflow in Indexer Backfiller Expected End Version Calculation

## Summary
The `Processor::new()` function in the indexer-grpc-file-store-backfiller performs unchecked addition when computing `expected_end_version`, which can cause integer overflow and lead to premature termination of the backfill process, resulting in incomplete indexer data.

## Finding Description
The vulnerability exists at two locations in `Processor::new()`: [1](#0-0) [2](#0-1) 

Both lines use unchecked addition (`starting_version + c`) to compute the ending version for backfill operations. In Rust, the `+` operator performs wrapping arithmetic in release builds, meaning overflow will silently wrap around to a small value rather than panicking or returning an error.

The Aptos codebase explicitly requires checked arithmetic for all integer operations per the coding guidelines: [3](#0-2) 

When overflow occurs, the computed `expected_end_version` wraps to a value much smaller than `starting_version`. This causes two critical checks to fail incorrectly: [4](#0-3) [5](#0-4) 

Both checks compare the current progress against the overflowed `ending_version`, causing the process to exit prematurely believing backfill is complete.

**Exploitation Scenario:**
An operator configures the backfiller with:
- `starting_version: 18446744073709550000` (near `u64::MAX`)
- `transactions_count: 2000`

The addition `18446744073709550000 + 2000` exceeds `u64::MAX` (18446744073709551615) and wraps to approximately 1384, causing immediate premature exit. [6](#0-5) 

The configuration values come from deserialized user input without validation.

## Impact Explanation
This vulnerability results in **state inconsistencies requiring intervention** (Medium Severity per Aptos Bug Bounty). 

The indexer provides critical data infrastructure for applications and users querying blockchain state. Incomplete backfill data causes:
- Applications to receive incorrect or missing transaction history
- Users to see incomplete balance/NFT information  
- Analytics platforms to have data gaps
- Potential financial losses for applications making decisions based on incomplete indexer data

While this doesn't directly affect consensus or on-chain execution, indexer infrastructure is essential for ecosystem functionality. Recovery requires manual intervention to detect the incomplete backfill, correct configuration, and restart the process.

## Likelihood Explanation
**Likelihood: Low to Medium**

This vulnerability can manifest in two scenarios:

1. **Accidental misconfiguration**: Operators providing extremely large version numbers or transaction counts could trigger this unintentionally, especially when backfilling from near the end of the version space or using overly large batch sizes.

2. **Malicious operator**: A compromised or malicious operator with configuration access could intentionally trigger this to cause indexer data inconsistencies.

While requiring operator-level access limits exploitability, configuration errors with large numbers are realistic, especially in automated deployment scenarios or when operators don't understand `u64` limits.

## Recommendation
Replace unchecked addition with `checked_add()` and handle overflow explicitly:

```rust
// Line 69 - validation mode
ending_version: transactions_count.and_then(|c| {
    starting_version.unwrap_or(0).checked_add(c)
        .context("Overflow computing ending_version")
        .ok()
}),

// Line 77 - backfill mode  
let expected_end_version = match transactions_count {
    Some(c) => Some(
        starting_version.checked_add(c)
            .context("Overflow: starting_version + transactions_count exceeds u64::MAX")?
    ),
    None => None,
};
```

Additionally, add validation at configuration parsing:

```rust
impl IndexerGrpcFileStoreBackfillerConfig {
    pub fn validate(&self) -> Result<()> {
        if let (Some(start), Some(count)) = (self.starting_version, self.transactions_count) {
            ensure!(
                start.checked_add(count).is_some(),
                "Configuration error: starting_version + transactions_count would overflow u64::MAX"
            );
        }
        Ok(())
    }
}
```

## Proof of Concept

```rust
// Add to ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/tests/overflow_test.rs

#[tokio::test]
async fn test_overflow_causes_premature_exit() {
    use std::u64;
    
    // Simulate configuration that causes overflow
    let starting_version = u64::MAX - 1000;
    let transactions_count = 2000_u64;
    
    // Demonstrate overflow behavior
    let overflowed_result = starting_version.wrapping_add(transactions_count);
    assert!(overflowed_result < starting_version, 
        "Overflow wraps to small value: {} < {}", 
        overflowed_result, starting_version);
    
    // This would cause the backfiller to immediately exit
    // thinking backfill is complete when it hasn't started
    let expected_starting_version = starting_version;
    let expected_end_version = overflowed_result;
    
    assert!(expected_starting_version >= expected_end_version,
        "Overflow causes incorrect 'backfill done' logic");
    
    // Corrected version with checked_add
    let safe_result = starting_version.checked_add(transactions_count);
    assert!(safe_result.is_none(), "checked_add properly detects overflow");
}
```

## Notes
This vulnerability affects both backfill mode and validation mode. The same overflow pattern exists in the v2 backfiller at similar locations, which should also be audited and fixed.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L69-69)
```rust
                ending_version: transactions_count.map(|c| starting_version.unwrap_or(0) + c),
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L77-77)
```rust
        let expected_end_version = transactions_count.map(|c| starting_version + c);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L97-102)
```rust
        if let Some(expected_end_version) = expected_end_version {
            if expected_starting_version >= expected_end_version {
                tracing::info!("Backfill is already done.");
                // Backfill is already done.
                exit(0);
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L251-255)
```rust
                    if let Some(ending_version) = ending_version {
                        if ending_version <= next_version_to_process {
                            // Backfill is done.
                            std::process::exit(0);
                        }
```

**File:** RUST_CODING_STYLE.md (L222-224)
```markdown
As every integer operation (`+`, `-`, `/`, `*`, etc.) implies edge-cases (e.g. overflow `u64::MAX + 1`, underflow `0u64 -1`, division by zero, etc.),
we use checked arithmetic instead of directly using math symbols.
It forces us to think of edge-cases, and handle them explicitly.
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/lib.rs (L23-24)
```rust
    pub starting_version: Option<u64>,
    pub transactions_count: Option<u64>,
```
