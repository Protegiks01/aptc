# Audit Report

## Title
Complete Bypass of Entry Function Filtering via Multisig Transactions with Empty Executables

## Summary
Transaction filters that deny specific entry functions can be completely bypassed by submitting multisig transactions with `TransactionExecutableRef::Empty`. The filter only examines the empty executable reference at submission time, while the actual blocked entry function is retrieved from on-chain storage during execution and executed without any filter validation.

## Finding Description

The Aptos transaction filtering system is designed to allow operators to block specific transactions based on various criteria, including entry function calls. However, there is a critical design flaw in how multisig transactions with empty executables are handled. [1](#0-0) 

When `matches_entry_function()` encounters a `TransactionExecutableRef::Empty`, it returns `false` (line 356 and 366), meaning the entry function matcher doesn't match. This causes DENY rules targeting specific entry functions to fail to match, allowing the transaction through the filter. [2](#0-1) 

The VM validation allows Empty executables specifically for multisig transactions, so these transactions pass validation.

During execution, the actual entry function is retrieved from on-chain storage: [3](#0-2) [4](#0-3) 

The `get_next_transaction_payload()` function retrieves the payload stored on-chain: [5](#0-4) 

Critically, when creating multisig transactions, there are NO restrictions on what entry functions can be stored: [6](#0-5) 

**Attack Path:**
1. Operator configures a DENY filter for a specific entry function (e.g., `TransactionMatcher::EntryFunction(0x1, "coin", "transfer")`)
2. Attacker creates a multisig account
3. Attacker calls `multisig_account::create_transaction()` with the blocked entry function as the payload - this is stored on-chain without any filter validation
4. Multisig owners approve the transaction
5. Attacker submits a multisig execution transaction with `TransactionExecutableRef::Empty` (via `TransactionPayload::Multisig` with `transaction_payload: None`)
6. The filter's `matches_entry_function()` sees Empty and returns false
7. The DENY rule doesn't match, transaction passes through mempool and consensus filters
8. During execution, the actual blocked entry function is retrieved from on-chain storage via `get_next_transaction_payload()`
9. The blocked entry function is executed without any filter checks [7](#0-6) 

## Impact Explanation

This vulnerability has **HIGH** severity impact according to Aptos bug bounty criteria as it represents a **significant protocol violation**. The transaction filtering system is a critical security mechanism that allows operators to:

- Block malicious or unwanted transaction types
- Implement compliance requirements
- Protect against specific attack vectors
- Control which smart contracts can be executed

The complete bypass of entry function filtering undermines these security guarantees. An attacker can execute any entry function, including those explicitly blocked by operators, by simply wrapping them in multisig transactions. This affects:

- **All validators and nodes** running transaction filters
- **Network operators** who cannot enforce their security policies
- **Compliance requirements** that may mandate blocking certain transaction types

The filters are applied at both mempool submission and consensus block preparation: [8](#0-7) 

But both only see the Empty executable, not the actual entry function that will be executed.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is straightforward to execute:
- No special privileges required beyond normal user access
- Multisig accounts are a standard feature available to all users
- Creating and executing multisig transactions is well-documented functionality
- No cryptographic or timing complexities involved
- Attack can be performed repeatedly

The only requirements are:
1. Ability to create a multisig account (any user can do this)
2. Ability to approve multisig transactions (attacker can control all owners of their own multisig account)
3. Knowledge that transaction filters are in use (observable from rejected transactions)

## Recommendation

The fundamental issue is that transaction filters only inspect the executable reference at submission time, but for multisig transactions, the actual executable is retrieved later from on-chain storage. There are several potential fixes:

**Option 1: Filter at Execution Time (Recommended)**
When `execute_multisig_transaction()` retrieves the payload from on-chain storage, apply transaction filters before executing it:

```rust
// In aptos_vm.rs, after line 1281
let payload = bcs::from_bytes::<MultisigTransactionPayload>(&payload_bytes)
    .map_err(|_| deserialization_error())?;

// NEW: Apply transaction filter to the retrieved payload
if let MultisigTransactionPayload::EntryFunction(ref entry_function) = payload {
    let temp_txn = create_temp_transaction_for_filtering(
        txn_data.sender,
        TransactionPayload::EntryFunction(entry_function.clone())
    );
    if !self.transaction_filter.allows_transaction(&temp_txn) {
        return Err(VMStatus::error(
            StatusCode::REJECTED_BY_FILTER,
            Some("Multisig payload rejected by transaction filter".to_string())
        ));
    }
}
```

**Option 2: Filter at Creation Time**
Modify `multisig_account::create_transaction()` to validate payloads against filters. However, this requires exposing filter configuration to Move code, which may not be desirable.

**Option 3: Expand Filter Logic**
Make `matches_entry_function()` aware of multisig transactions and inspect the on-chain stored payload:

```rust
// In transaction_filter.rs matches_entry_function
TransactionPayload::Multisig(multisig) => {
    // NEW: Fetch on-chain payload and validate it
    if let Some(on_chain_payload) = fetch_multisig_payload(multisig.multisig_address) {
        match on_chain_payload {
            MultisigTransactionPayload::EntryFunction(entry_function) => {
                compare_entry_function(entry_function, address, module_name, function)
            }
        }
    } else {
        false // No payload stored, cannot match
    }
}
```

**Recommended Fix:** Option 1 is cleanest as it applies filters at the point where the actual executable is known, maintaining the principle that filters should validate what actually executes.

## Proof of Concept

```move
// This Move test demonstrates the bypass
#[test(operator = @0x1, attacker = @0x2, victim = @0x3)]
public entry fun test_bypass_filter_with_multisig(
    operator: &signer,
    attacker: &signer,
    victim: &signer
) {
    // Setup: Operator has configured filters to DENY coin::transfer from 0x1
    // (This would be done via node configuration, simulated here)
    
    // Step 1: Attacker creates multisig account
    let multisig_addr = multisig_account::create_with_owners(
        attacker,
        vector[@0x2],  // Single owner for simplicity
        1,  // 1-of-1 signatures required
        vector::empty(),
        vector::empty()
    );
    
    // Step 2: Create multisig transaction with the BLOCKED entry function
    // This stores the blocked function on-chain without filter validation
    let payload = bcs::to_bytes(&MultisigTransactionPayload::EntryFunction(
        EntryFunction::new(
            ModuleId::new(@0x1, string::utf8(b"coin")),
            string::utf8(b"transfer"),
            vector[],
            vector[
                bcs::to_bytes(&@victim),
                bcs::to_bytes(&100u64)
            ]
        )
    ));
    
    multisig_account::create_transaction(attacker, multisig_addr, payload);
    
    // Step 3: Execute multisig transaction with EMPTY executable
    // The filter sees Empty, returns false, doesn't match DENY rule
    // Transaction is allowed through despite blocking coin::transfer
    let txn = create_multisig_transaction(
        attacker,
        multisig_addr,
        TransactionPayload::Multisig(Multisig {
            multisig_address: multisig_addr,
            transaction_payload: None  // Empty - bypasses filter!
        })
    );
    
    // Result: The blocked coin::transfer function executes
    // despite operator's DENY filter configuration
    assert!(/* attacker successfully transferred coins */, 1);
}
```

The Rust integration test would configure a `TransactionFilter` with a DENY rule, create a multisig account, store a blocked entry function on-chain via `create_transaction`, then submit execution with Empty executable. The test would verify that the transaction passes through the filter and executes the blocked function.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L333-375)
```rust
fn matches_entry_function(
    signed_transaction: &SignedTransaction,
    address: &AccountAddress,
    module_name: &String,
    function: &String,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.payload() {
        TransactionPayload::Script(_) | TransactionPayload::ModuleBundle(_) => false,
        TransactionPayload::Multisig(multisig) => multisig
            .transaction_payload
            .as_ref()
            .map(|payload| match payload {
                MultisigTransactionPayload::EntryFunction(entry_function) => {
                    compare_entry_function(entry_function, address, module_name, function)
                },
            })
            .unwrap_or(false),
        TransactionPayload::EntryFunction(entry_function) => {
            compare_entry_function(entry_function, address, module_name, function)
        },
        TransactionPayload::Payload(TransactionPayloadInner::V1 { executable, .. }) => {
            match executable.as_ref() {
                TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                TransactionExecutableRef::EntryFunction(entry_function) => {
                    compare_entry_function(entry_function, address, module_name, function)
                },
            }
        },
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function(entry_function, address, module_name, function)
                    },
                }
            } else {
                false
            }
        },
    }
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1221-1231)
```rust
            TransactionExecutableRef::Empty => {
                // Default to empty bytes if payload is not provided.
                if self
                    .features()
                    .is_abort_if_multisig_payload_mismatch_enabled()
                {
                    vec![]
                } else {
                    bcs::to_bytes::<Vec<u8>>(&vec![]).map_err(|_| invariant_violation_error())?
                }
            },
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1241-1280)
```rust
        let payload_bytes: Vec<Vec<u8>> = session
            .execute(|session| {
                session.execute_function_bypass_visibility(
                    &MULTISIG_ACCOUNT_MODULE,
                    GET_NEXT_TRANSACTION_PAYLOAD,
                    vec![],
                    serialize_values(&vec![
                        MoveValue::Address(multisig_address),
                        MoveValue::vector_u8(provided_payload),
                    ]),
                    gas_meter,
                    traversal_context,
                    module_storage,
                )
            })?
            .return_values
            .into_iter()
            .map(|(bytes, _ty)| bytes)
            .collect::<Vec<_>>();
        let payload_bytes = payload_bytes
            .first()
            // We expect the payload to either exists on chain or be passed along with the
            // transaction.
            .ok_or_else(|| {
                PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                    .with_message("Multisig payload bytes return error".to_string())
                    .finish(Location::Undefined)
            })?;
        // We have to deserialize twice as the first time returns the actual return type of the
        // function, which is vec<u8>. The second time deserializes it into the correct
        // EntryFunction payload type.
        // If either deserialization fails for some reason, that means the user provided incorrect
        // payload data either during transaction creation or execution.
        let deserialization_error = || {
            PartialVMError::new(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT)
                .finish(Location::Undefined)
        };
        let payload_bytes =
            bcs::from_bytes::<Vec<u8>>(payload_bytes).map_err(|_| deserialization_error())?;
        let payload = bcs::from_bytes::<MultisigTransactionPayload>(&payload_bytes)
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1287-1299)
```rust
        let execution_result = match payload {
            MultisigTransactionPayload::EntryFunction(entry_function) => self
                .execute_multisig_entry_function(
                    resolver,
                    module_storage,
                    session,
                    gas_meter,
                    traversal_context,
                    multisig_address,
                    &entry_function,
                    change_set_configs,
                    trace_recorder,
                ),
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2815-2820)
```rust
        if executable.is_empty() && !extra_config.is_multisig() {
            return Err(VMStatus::error(
                StatusCode::EMPTY_PAYLOAD_PROVIDED,
                Some("Empty provided for a non-multisig transaction".to_string()),
            ));
        }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L393-404)
```text
    public fun get_next_transaction_payload(
        multisig_account: address, provided_payload: vector<u8>): vector<u8> acquires MultisigAccount {
        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);
        let sequence_number = multisig_account_resource.last_executed_sequence_number + 1;
        let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);

        if (option::is_some(&transaction.payload)) {
            *option::borrow(&transaction.payload)
        } else {
            provided_payload
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L954-973)
```text
    public entry fun create_transaction(
        owner: &signer,
        multisig_account: address,
        payload: vector<u8>,
    ) acquires MultisigAccount {
        assert!(vector::length(&payload) > 0, error::invalid_argument(EPAYLOAD_CANNOT_BE_EMPTY));

        assert_multisig_account_exists(multisig_account);
        assert_is_owner(owner, multisig_account);

        let creator = address_of(owner);
        let transaction = MultisigTransaction {
            payload: option::some(payload),
            payload_hash: option::none<vector<u8>>(),
            votes: simple_map::create<address, bool>(),
            creator,
            creation_time_secs: now_seconds(),
        };
        add_transaction(creator, multisig_account, transaction);
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L408-466)
```rust
fn filter_transactions(
    transaction_filter_config: &TransactionFilterConfig,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(
    SignedTransaction,
    Option<u64>,
    Option<BroadcastPeerPriority>,
)> {
    // If the filter is not enabled, return early
    if !transaction_filter_config.is_enabled() {
        return transactions;
    }

    // Start the filter processing timer
    let transaction_filter_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FILTER_TRANSACTIONS_LABEL])
        .start_timer();

    // Filter the transactions and update the statuses accordingly
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
            } else {
                info!(LogSchema::event_log(
                    LogEntry::TransactionFilter,
                    LogEvent::TransactionRejected
                )
                .message(&format!(
                    "Transaction {} rejected by filter",
                    transaction.committed_hash()
                )));

                statuses.push((
                    transaction.clone(),
                    (
                        MempoolStatus::new(MempoolStatusCode::RejectedByFilter),
                        None,
                    ),
                ));
                None
            }
        })
        .collect();

    // Update the filter processing latency metrics
    transaction_filter_timer.stop_and_record();

    transactions
}
```
