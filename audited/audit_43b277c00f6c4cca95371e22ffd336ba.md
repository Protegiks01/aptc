# Audit Report

## Title
Consensus Config Changes Can Invalidate Ongoing Governance Votes Through Mid-Cycle Voting Power Manipulation

## Summary
Consensus configuration change proposals trigger blockchain reconfigurations that modify validator voting power mid-governance cycle, invalidating votes already cast on concurrent proposals. This violates the governance integrity invariant that voting power should remain stable throughout a proposal's voting period.

## Finding Description

The vulnerability exists in the interaction between consensus configuration changes and governance voting power calculations. When `generate_consensus_upgrade_proposal()` creates a governance proposal to update consensus configuration, the proposal execution calls: [1](#0-0) 

This triggers a blockchain reconfiguration via `aptos_governance::reconfigure()`: [2](#0-1) 

The reconfiguration process calls `stake::on_new_epoch()` which fundamentally changes the validator set composition: [3](#0-2) 

This epoch transition affects voting power calculations used by `get_voting_power()`: [4](#0-3) 

When `allow_validator_set_change` is false, the function calls `get_current_epoch_voting_power()` which returns 0 for validators that are no longer ACTIVE or PENDING_INACTIVE: [5](#0-4) 

**The Critical Flaw:** The governance system calculates remaining voting power as: [6](#0-5) 

This calculation assumes `get_voting_power()` returns consistent values throughout a proposal's lifecycle. However, when an epoch change occurs mid-voting period:
- Validators who were PENDING_INACTIVE lose all voting power (become INACTIVE)
- Validators who were PENDING_ACTIVE gain voting power (become ACTIVE)
- Votes already cast using old voting power remain counted, but the validators may no longer have that power
- The `used_voting_power` was recorded under old epoch rules, but `get_voting_power()` now returns new epoch values

**Attack Scenario:**
1. Governance Proposal A is created with a 7-day voting period
2. Validators vote on Proposal A, recording their `used_voting_power`
3. A consensus config change proposal (Proposal B) is executed during Proposal A's voting period
4. Proposal B triggers `reconfigure()`, causing an epoch transition via `stake::on_new_epoch()`
5. Validator states change: pending_inactive → inactive, pending_active → active
6. For Proposal A, votes cast by validators who became INACTIVE are now from validators with 0 voting power
7. Proposal outcomes become invalid as voting power distribution has fundamentally changed

## Impact Explanation

**Severity: HIGH** - This represents a significant protocol violation per Aptos bug bounty criteria.

The vulnerability breaks the **Governance Integrity** invariant by allowing voting power to change during active proposal voting periods. This can result in:

- **Vote Invalidation**: Validators who cast legitimate votes may lose their voting power mid-cycle, making their votes effectively invalid
- **Unpredictable Outcomes**: Proposal success/failure becomes dependent on timing of concurrent reconfigurations
- **Governance Manipulation**: Attackers can strategically time consensus config changes to affect concurrent proposal outcomes
- **Trust Erosion**: The governance system cannot guarantee vote stability, undermining its legitimacy

This affects all concurrent governance proposals whenever a consensus configuration change is executed, which could occur regularly in an active governance system.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The vulnerability is highly likely to occur because:

1. **Natural Occurrence**: Consensus config changes are legitimate governance operations that occur during normal network upgrades
2. **No Protections**: There are no mechanisms preventing reconfigurations during active proposal voting periods
3. **Common Pattern**: Multiple concurrent proposals are expected in active governance systems
4. **Easy Trigger**: Any governance participant can create and execute a consensus config change proposal
5. **Unintentional Impact**: Even non-malicious actors will trigger this issue during routine upgrades

The attack requires no special privileges beyond normal governance participation rights (sufficient stake to propose and vote). The timing overlap between proposals is likely to occur naturally as voting periods are typically 7 days and governance activity is continuous.

## Recommendation

**Fix 1: Snapshot Voting Power at Proposal Creation**

Store the voting power calculation method (epoch number, validator set snapshot, or stake amounts) at proposal creation time and use this snapshot for all voting power calculations throughout the proposal's lifecycle.

**Fix 2: Prevent Reconfigurations During Active Proposals**

Add a check in `aptos_governance::reconfigure()` to prevent epoch changes when there are active proposals:

```move
public entry fun reconfigure(aptos_framework: &signer) {
    system_addresses::assert_aptos_framework(aptos_framework);
    
    // Check for active proposals
    assert!(!has_active_proposals(), error::invalid_state(ERECONFIGURATION_BLOCKED_BY_ACTIVE_PROPOSALS));
    
    if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
        reconfiguration_with_dkg::try_start();
    } else {
        reconfiguration_with_dkg::finish(aptos_framework);
    }
}
```

**Fix 3: Track Epoch at Vote Time**

Record the epoch number when each vote is cast and validate that voting power calculations use the same epoch's validator set:

```move
struct VoteRecord has store {
    voting_power_used: u64,
    epoch_at_vote: u64,
}
```

**Recommended Solution**: Implement Fix 1 (snapshot voting power) as it provides the cleanest separation between governance and consensus operations while maintaining system flexibility.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, proposer = @0x123, voter = @0x234)]
public entry fun test_voting_power_changes_during_proposal(
    aptos_framework: signer,
    proposer: signer,
    voter: signer,
) acquires GovernanceConfig, GovernanceEvents, VotingRecords, VotingRecordsV2, ApprovedExecutionHashes, GovernanceResponsbility {
    // Setup
    setup_partial_voting(&aptos_framework, &proposer, &voter, &voter);
    
    // Create Proposal A
    create_proposal(&proposer, signer::address_of(&proposer), b"0", b"", b"");
    let proposal_a_id = 0;
    
    // Voter casts vote on Proposal A
    let voter_pool = signer::address_of(&voter);
    let initial_voting_power = get_voting_power(voter_pool);
    vote(&voter, voter_pool, proposal_a_id, true);
    
    let used_power = initial_voting_power;
    let remaining_power_before = get_remaining_voting_power(voter_pool, proposal_a_id);
    assert!(remaining_power_before == 0, 1); // All power used
    
    // Trigger reconfiguration via consensus config change
    // This simulates executing a consensus config change proposal
    let framework_signer = create_signer_with_capability(&get_signer_cap(@aptos_framework));
    reconfigure(&framework_signer);
    
    // After reconfiguration, voting power calculation changes
    let new_voting_power = get_voting_power(voter_pool);
    let remaining_power_after = get_remaining_voting_power(voter_pool, proposal_a_id);
    
    // VULNERABILITY: If voter's status changed (e.g., PENDING_INACTIVE -> INACTIVE),
    // new_voting_power may be 0, but used_power was recorded as > 0
    // This makes the vote invalid as it was cast with power the validator no longer has
    assert!(new_voting_power != initial_voting_power, 2); // Voting power changed
    // The calculation: remaining_power_after = new_voting_power - used_power
    // becomes incorrect because used_power was based on old epoch rules
}
```

## Notes

This vulnerability demonstrates a critical architectural flaw in the separation between governance and consensus layer state management. The dynamic calculation of voting power without epoch-aware snapshots creates a temporal inconsistency where votes can become retroactively invalid.

The issue is exacerbated by the dual-mode voting power calculation in `get_voting_power()` which behaves differently based on `allow_validator_set_change` configuration, creating additional complexity in predicting voting power changes across epochs.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/consensus_config.rs (L40-45)
```rust
            emitln!(
                writer,
                "consensus_config::set_for_next_epoch({}, consensus_blob);",
                signer_arg
            );
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L346-347)
```text
        let used_voting_power = *VotingRecordsV2[@aptos_framework].votes.borrow_with_default(record_key, &0);
        get_voting_power(stake_pool) - used_voting_power
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L731-742)
```text
    public fun get_voting_power(pool_address: address): u64 {
        let allow_validator_set_change = staking_config::get_allow_validator_set_change(&staking_config::get());
        if (allow_validator_set_change) {
            let (active, _, pending_active, pending_inactive) = stake::get_stake(pool_address);
            // We calculate the voting power as total non-inactive stakes of the pool. Even if the validator is not in the
            // active validator set, as long as they have a lockup (separately checked in create_proposal and voting), their
            // stake would still count in their voting power for governance proposals.
            active + pending_active + pending_inactive
        } else {
            stake::get_current_epoch_voting_power(pool_address)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L440-451)
```text
    public fun get_current_epoch_voting_power(pool_address: address): u64 acquires StakePool, ValidatorSet {
        assert_stake_pool_exists(pool_address);
        let validator_state = get_validator_state(pool_address);
        // Both active and pending inactive validators can still vote in the current epoch.
        if (validator_state == VALIDATOR_STATUS_ACTIVE || validator_state == VALIDATOR_STATUS_PENDING_INACTIVE) {
            let active_stake = coin::value(&borrow_global<StakePool>(pool_address).active);
            let pending_inactive_stake = coin::value(&borrow_global<StakePool>(pool_address).pending_inactive);
            active_stake + pending_inactive_stake
        } else {
            0
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1363-1367)
```text
        // Activate currently pending_active validators.
        append(&mut validator_set.active_validators, &mut validator_set.pending_active);

        // Officially deactivate all pending_inactive validators. They will now no longer receive rewards.
        validator_set.pending_inactive = vector::empty();
```
