# Audit Report

## Title
Indexer Database Failure Causes State Divergence and Inconsistent Error Reporting After Successful Main Database Commit

## Summary
The `AptosDB::commit_ledger` method commits transactions to the main ledger database before attempting to update the indexer database. If the indexer write fails, an error is returned to the caller suggesting the commit failed, when in reality the main database has already been successfully committed. This creates a state divergence between the main ledger and indexer databases, and leaves the node's in-memory state inconsistent with the persisted state.

## Finding Description
The vulnerability exists in the commit flow within the AptosDB storage layer. When transactions are committed: [1](#0-0) 

The main database commit occurs first and succeeds at line 107. Then `post_commit` is called at line 110 with the `?` operator, meaning any error will be propagated upward.

Inside `post_commit`, the indexer update occurs: [2](#0-1) 

The indexer writes to a separate database via `indexer.index()` calls at lines 648 and 656. These operations use the `?` operator, propagating any failures. [3](#0-2) 

The indexer's database write at line 144 can fail due to disk full, I/O errors, database corruption, or parsing errors (lines 127-138). When this occurs:

1. **Main database**: Successfully committed to version N (already persisted)
2. **Indexer database**: Remains at version N-k (write failed, still at old version)
3. **Error returned**: Caller receives error, incorrectly believing entire commit failed
4. **In-memory state**: NOT updated because the error causes early return from `post_commit` before reaching lines 662-669

This breaks the atomicity guarantee - the two databases should either both succeed or both fail, but instead we have a split outcome.

The startup recovery mechanism exists but only helps with transient failures: [4](#0-3) 

If the indexer failure is persistent (disk full, corruption), the node cannot recover and will fail to restart.

## Impact Explanation
This is a **Medium severity** vulnerability per Aptos bug bounty criteria:

- **"State inconsistencies requiring intervention"**: The indexer database diverges from the main ledger state, requiring operator intervention to repair or rebuild the indexer
- **Data availability issues**: Queries depending on the indexer (table info lookups, event indexing) will fail or return stale/incorrect data
- **Misleading error reporting**: The caller receives an error indicating commit failure when the main database successfully committed, potentially causing confusion in error handling logic
- **Cascading failures**: Subsequent commit attempts may fail version continuity checks since the in-memory state was not updated to match the persisted state

While this doesn't directly affect consensus (validators use the main database, not the indexer), it impacts data availability and requires manual intervention to resolve.

## Likelihood Explanation
This vulnerability has **moderate to high likelihood** in production environments:

- **Disk space exhaustion**: Common operational issue in blockchain nodes with growing databases
- **I/O errors**: Hardware failures or filesystem issues can cause write failures
- **Database corruption**: RocksDB corruption can occur due to crashes or hardware issues
- **No special privileges required**: This is a system-level bug that can be triggered by environmental conditions
- **Affects all nodes with indexer enabled**: Any node running with `enable_indexer=true` is vulnerable

The issue occurs automatically when the indexer database encounters any write failure, making it a realistic production scenario.

## Recommendation
The indexer update should be made non-fatal to the commit operation. Since the indexer is used for data availability and not consensus, its failure should not block successful main database commits. The fix should:

1. **Make indexer updates best-effort**: Log errors but don't propagate them
2. **Track indexer health separately**: Add monitoring for indexer lag
3. **Ensure in-memory state updates**: Always update in-memory state after successful main DB commit

**Recommended fix**:

```rust
fn post_commit(
    &self,
    old_committed_version: Option<Version>,
    version: Version,
    ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
    chunk_opt: Option<ChunkToCommit>,
) -> Result<()> {
    if old_committed_version.is_none() || version > old_committed_version.unwrap() {
        let first_version = old_committed_version.map_or(0, |v| v + 1);
        let num_txns = version + 1 - first_version;

        COMMITTED_TXNS.inc_by(num_txns);
        LATEST_TXN_VERSION.set(version as i64);
        // ... other updates ...

        // Make indexer update non-fatal
        if let Some(indexer) = &self.indexer {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["indexer_index"]);
            let indexer_result = if let Some(chunk) = chunk_opt
                && chunk.len() == num_txns as usize
            {
                let write_sets = chunk
                    .transaction_outputs
                    .iter()
                    .map(|t| t.write_set())
                    .collect_vec();
                indexer.index(self.state_store.clone(), first_version, &write_sets)
            } else {
                let write_sets: Vec<_> = self
                    .ledger_db
                    .write_set_db()
                    .get_write_set_iter(first_version, num_txns as usize)?
                    .try_collect()?;
                let write_set_refs = write_sets.iter().collect_vec();
                indexer.index(self.state_store.clone(), first_version, &write_set_refs)
            };
            
            // Log errors but don't propagate them
            if let Err(e) = indexer_result {
                error!(
                    error = ?e,
                    first_version = first_version,
                    num_txns = num_txns,
                    "Indexer update failed after successful commit. Indexer may be out of sync."
                );
                // Optionally: Set a metric to track indexer health
            }
        }
    }

    // Always update in-memory state after successful main DB commit
    if let Some(x) = ledger_info_with_sigs {
        self.ledger_db
            .metadata_db()
            .set_latest_ledger_info(x.clone());

        LEDGER_VERSION.set(x.ledger_info().version() as i64);
        NEXT_BLOCK_EPOCH.set(x.ledger_info().next_block_epoch() as i64);
    }

    Ok(())
}
```

Additionally, enhance the startup recovery to be more robust and add monitoring for indexer lag.

## Proof of Concept

```rust
#[cfg(test)]
mod test_indexer_failure {
    use super::*;
    use aptos_temppath::TempPath;
    use aptos_types::transaction::Transaction;
    
    #[test]
    fn test_indexer_divergence_on_write_failure() {
        // Setup: Create AptosDB with indexer enabled
        let tmpdir = TempPath::new();
        let mut db = AptosDB::new_for_test(tmpdir.path());
        
        // Simulate filling up the indexer disk partition
        // (In practice, this would be done by creating a filesystem with limited space)
        // For this test, we can mock the indexer to return write errors
        
        // Step 1: Commit some transactions successfully
        let genesis = test_helper::get_genesis_txn();
        db.save_transactions(&[genesis], 0, None, true, None).unwrap();
        
        // Step 2: Inject failure into indexer by filling disk or corrupting DB
        // (implementation detail - could mock the indexer's write_schemas call)
        
        // Step 3: Attempt to commit more transactions
        let txns = test_helper::get_test_signed_txns(5);
        let result = db.save_transactions(&txns, 1, None, true, None);
        
        // Expected behavior: Main DB commits, indexer fails, error is returned
        assert!(result.is_err(), "Expected error due to indexer failure");
        
        // Verify divergence:
        // Main DB has version 5
        let main_version = db.get_latest_version().unwrap();
        assert_eq!(main_version, 5, "Main DB should have committed to version 5");
        
        // Indexer still at version 0
        if let Some(indexer) = &db.indexer {
            assert_eq!(indexer.next_version(), 0, "Indexer should still be at version 0");
        }
        
        // In-memory state NOT updated (this is the additional bug)
        let ledger_info = db.ledger_db.metadata_db().get_latest_ledger_info_option();
        assert!(ledger_info.is_none() || ledger_info.unwrap().ledger_info().version() < 5,
            "In-memory ledger info should not reflect the committed version");
    }
}
```

**Notes:**
- The vulnerability affects the atomicity of the two-database system (main ledger + indexer)
- The indexer is meant to be an optimization for data availability, not a consensus-critical component
- The fix makes indexer failures non-fatal while maintaining proper error logging and monitoring
- Operators should monitor indexer health separately and rebuild if it falls behind

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L78-112)
```rust
    fn commit_ledger(
        &self,
        version: Version,
        ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
        chunk_opt: Option<ChunkToCommit>,
    ) -> Result<()> {
        gauged_api("commit_ledger", || {
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
            let _lock = self
                .commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["commit_ledger"]);

            let old_committed_ver = self.get_and_check_commit_range(version)?;

            let mut ledger_batch = SchemaBatch::new();
            // Write down LedgerInfo if provided.
            if let Some(li) = ledger_info_with_sigs {
                self.check_and_put_ledger_info(version, li, &mut ledger_batch)?;
            }
            // Write down commit progress
            ledger_batch.put::<DbMetadataSchema>(
                &DbMetadataKey::OverallCommitProgress,
                &DbMetadataValue::Version(version),
            )?;
            self.ledger_db.metadata_db().write_schemas(ledger_batch)?;

            // Notify the pruners, invoke the indexer, and update in-memory ledger info.
            self.post_commit(old_committed_ver, version, ledger_info_with_sigs, chunk_opt)
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L636-658)
```rust
            if let Some(indexer) = &self.indexer {
                let _timer = OTHER_TIMERS_SECONDS.timer_with(&["indexer_index"]);
                // n.b. txns_to_commit can be partial, when the control was handed over from consensus to state sync
                // where state sync won't send the pre-committed part to the DB again.
                if let Some(chunk) = chunk_opt
                    && chunk.len() == num_txns as usize
                {
                    let write_sets = chunk
                        .transaction_outputs
                        .iter()
                        .map(|t| t.write_set())
                        .collect_vec();
                    indexer.index(self.state_store.clone(), first_version, &write_sets)?;
                } else {
                    let write_sets: Vec<_> = self
                        .ledger_db
                        .write_set_db()
                        .get_write_set_iter(first_version, num_txns as usize)?
                        .try_collect()?;
                    let write_set_refs = write_sets.iter().collect_vec();
                    indexer.index(self.state_store.clone(), first_version, &write_set_refs)?;
                };
            }
```

**File:** storage/indexer/src/lib.rs (L83-148)
```rust
    pub fn index(
        &self,
        db_reader: Arc<dyn DbReader>,
        first_version: Version,
        write_sets: &[&WriteSet],
    ) -> Result<()> {
        let last_version = first_version + write_sets.len() as Version;
        let state_view = db_reader.state_view_at_version(Some(last_version))?;
        let annotator = AptosValueAnnotator::new(&state_view);
        self.index_with_annotator(&annotator, first_version, write_sets)
    }

    pub fn index_with_annotator<R: StateView>(
        &self,
        annotator: &AptosValueAnnotator<R>,
        first_version: Version,
        write_sets: &[&WriteSet],
    ) -> Result<()> {
        let next_version = self.next_version();
        db_ensure!(
            first_version <= next_version,
            "Indexer expects to see continuous transaction versions. Expecting: {}, got: {}",
            next_version,
            first_version,
        );
        let end_version = first_version + write_sets.len() as Version;
        if end_version <= next_version {
            warn!(
                "Seeing old transactions. Expecting version: {}, got {} transactions starting from version {}.",
                next_version,
                write_sets.len(),
                first_version,
            );
            return Ok(());
        }

        let mut table_info_parser = TableInfoParser::new(self, annotator);
        for write_set in write_sets {
            for (state_key, write_op) in write_set.write_op_iter() {
                table_info_parser.parse_write_op(state_key, write_op)?;
            }
        }

        let mut batch = SchemaBatch::new();
        match table_info_parser.finish(&mut batch) {
            Ok(_) => {},
            Err(err) => {
                aptos_logger::error!(first_version = first_version, end_version = end_version, error = ?&err);
                write_sets
                    .iter()
                    .enumerate()
                    .for_each(|(i, write_set)| {
                        aptos_logger::error!(version = first_version as usize + i, write_set = ?write_set);
                    });
                db_other_bail!("Failed to parse table info: {:?}", err);
            },
        };
        batch.put::<IndexerMetadataSchema>(
            &MetadataKey::LatestVersion,
            &MetadataValue::Version(end_version - 1),
        )?;
        self.db.write_schemas(batch)?;
        self.next_version.store(end_version, Ordering::Relaxed);

        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L207-228)
```rust
        if indexer.next_version() < ledger_next_version {
            use aptos_storage_interface::state_store::state_view::db_state_view::DbStateViewAtVersion;
            let db: Arc<dyn DbReader> = self.state_store.clone();

            let state_view = db.state_view_at_version(Some(ledger_next_version - 1))?;
            let annotator = AptosValueAnnotator::new(&state_view);

            const BATCH_SIZE: Version = 10000;
            let mut next_version = indexer.next_version();
            while next_version < ledger_next_version {
                info!(next_version = next_version, "AptosDB Indexer catching up. ",);
                let end_version = std::cmp::min(ledger_next_version, next_version + BATCH_SIZE);
                let write_sets = self
                    .ledger_db
                    .write_set_db()
                    .get_write_sets(next_version, end_version)?;
                let write_sets_ref: Vec<_> = write_sets.iter().collect();
                indexer.index_with_annotator(&annotator, next_version, &write_sets_ref)?;

                next_version = end_version;
            }
        }
```
