# Audit Report

## Title
EventStore Persists Unvalidated ContractEvent Data Leading to Node Crashes

## Summary
The EventStore does not validate that ContractEvent data is well-formed before persisting it to storage. Malformed events can be stored and later cause node panics when the `size()` method is called during backup operations or indexer processing.

## Finding Description

The EventStore's `put_events()` method directly serializes ContractEvent objects using BCS without performing any validation on the event structure. [1](#0-0) 

During normal VM execution, events are created through constructors that perform validation. [2](#0-1) 

However, when events are received during state synchronization or backup restoration, they are BCS-deserialized without validation since ContractEvent uses the default `derive(Deserialize)` implementation. [3](#0-2) 

The critical issue is that ContractEvent's `size()` method calls `.expect()` which panics if the size calculation fails. [4](#0-3) 

The underlying size calculation can fail if `bcs::serialized_size(&self.type_tag)?` returns an error. [5](#0-4) 

**Exploitation Path:**

1. A malformed ContractEvent with an invalid TypeTag structure enters the system (via Byzantine validator producing bad execution output, or corrupted state sync data)
2. During state sync verification, only the cryptographic hash is validated, not the internal structure. [6](#0-5) 
3. The malformed event is stored via `commit_events()` without validation. [7](#0-6) 
4. When the event is later retrieved and processed, code calls `event.size()` causing a panic:
   - During backup analysis [8](#0-7) 
   - During indexer processing [9](#0-8) 

## Impact Explanation

**HIGH Severity** - This vulnerability causes validator node crashes and API service disruption:

1. **Validator Node Slowdowns/Crashes**: Backup operations will panic when processing malformed events, disrupting node operations and potentially preventing proper backup procedures
2. **Indexer Service Outages**: The indexer-grpc service will crash when attempting to stream transactions containing malformed events, breaking API availability
3. **State Database Corruption**: Malformed data persists in the state database, creating a permanent source of crashes until manual intervention

This meets the **High Severity** criteria per Aptos Bug Bounty: "Validator node slowdowns" and "API crashes."

## Likelihood Explanation

**MEDIUM Likelihood** - While exploitation requires specific conditions, the missing validation creates a real attack surface:

1. **Byzantine Validator**: A malicious validator with >1/3 stake could produce TransactionOutputs with malformed events that pass hash verification
2. **VM Execution Bug**: Any bug in the Move VM execution path that creates malformed events would bypass the constructor validation
3. **Corrupted State Sync**: Compromised state sync sources could provide malformed events
4. **Backup Restoration**: Corrupted backup files could introduce malformed events during restoration

The vulnerability is systematic - any path that brings events into storage via BCS deserialization bypasses validation.

## Recommendation

Add validation in `EventDb::put_events()` before persisting events:

```rust
pub(crate) fn put_events(
    &self,
    version: u64,
    events: &[ContractEvent],
    skip_index: bool,
    batch: &mut impl WriteBatch,
) -> Result<()> {
    // Validate all events before persisting
    for event in events.iter() {
        // This validates that size() is computable and the event is well-formed
        event.size().map_err(|e| {
            AptosDbError::Other(format!(
                "Invalid event at version {}: {}",
                version, e
            ))
        })?;
    }
    
    // Event table and indices updates
    events
        .iter()
        .enumerate()
        .try_for_each::<_, Result<_>>(|(idx, event)| {
            // ... existing code ...
        })?;
    // ... rest of method ...
}
```

Additionally, make ContractEvent's `size()` method return Result instead of panicking:

```rust
pub fn size(&self) -> Result<usize, anyhow::Error> {
    match self {
        ContractEvent::V1(event) => event.size(),
        ContractEvent::V2(event) => event.size(),
    }
}
```

## Proof of Concept

```rust
use aptos_types::contract_event::{ContractEvent, ContractEventV1};
use aptos_types::event::EventKey;
use move_core_types::language_storage::TypeTag;
use move_core_types::account_address::AccountAddress;

#[test]
fn test_malformed_event_storage() {
    // Create a deeply nested TypeTag that exceeds safe limits
    let mut type_tag = TypeTag::U64;
    for _ in 0..200 {  // Nest beyond reasonable limits
        type_tag = TypeTag::Vector(Box::new(type_tag));
    }
    
    // Create ContractEventV1 by bypassing constructor validation
    // (simulating BCS deserialization)
    let malformed_event = ContractEventV1 {
        key: EventKey::new(0, AccountAddress::ZERO),
        sequence_number: 0,
        type_tag,
        event_data: vec![],
    };
    
    let event = ContractEvent::V1(malformed_event);
    
    // This would succeed in put_events (no validation)
    // But later calling size() would panic:
    let result = std::panic::catch_unwind(|| {
        event.size(); // PANIC!
    });
    
    assert!(result.is_err(), "Expected panic on malformed event size()");
}
```

## Notes

While the most direct exploitation path requires Byzantine validator control or corrupted state sync sources, this represents a critical missing validation layer. The defensive programming principle demands that all data entering persistent storage be validated, especially when that data can later cause crashes. The vulnerability breaks the **State Consistency** invariant by allowing malformed state to persist, and violates **Deterministic Execution** if different nodes handle malformed events differently during recovery operations.

### Citations

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L145-170)
```rust
    pub(crate) fn put_events(
        &self,
        version: u64,
        events: &[ContractEvent],
        skip_index: bool,
        batch: &mut impl WriteBatch,
    ) -> Result<()> {
        // Event table and indices updates
        events
            .iter()
            .enumerate()
            .try_for_each::<_, Result<_>>(|(idx, event)| {
                if let ContractEvent::V1(v1) = event {
                    if !skip_index {
                        batch.put::<EventByKeySchema>(
                            &(*v1.key(), v1.sequence_number()),
                            &(version, idx as u64),
                        )?;
                        batch.put::<EventByVersionSchema>(
                            &(*v1.key(), version, v1.sequence_number()),
                            &(idx as u64),
                        )?;
                    }
                }
                batch.put::<EventSchema>(&(version, idx as u64), event)
            })?;
```

**File:** aptos-move/framework/src/natives/event.rs (L141-144)
```rust
    let event =
        ContractEvent::new_v1(key, seq_num, ty_tag, blob).map_err(|_| SafeNativeError::Abort {
            abort_code: ECANNOT_CREATE_EVENT,
        })?;
```

**File:** types/src/contract_event.rs (L44-48)
```rust
#[derive(Hash, Clone, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub enum ContractEvent {
    V1(ContractEventV1),
    V2(ContractEventV2),
}
```

**File:** types/src/contract_event.rs (L108-114)
```rust
    pub fn size(&self) -> usize {
        let result = match self {
            ContractEvent::V1(event) => event.size(),
            ContractEvent::V2(event) => event.size(),
        };
        result.expect("Size of events is computable and is checked at construction time")
    }
```

**File:** types/src/contract_event.rs (L227-230)
```rust
    pub fn size(&self) -> anyhow::Result<usize> {
        let size = self.key.size() + 8 /* u64 */ + bcs::serialized_size(&self.type_tag)? + self.event_data.len();
        Ok(size)
    }
```

**File:** types/src/transaction/mod.rs (L2629-2643)
```rust
fn verify_events_against_root_hash(
    events: &[ContractEvent],
    transaction_info: &TransactionInfo,
) -> Result<()> {
    let event_hashes: Vec<_> = events.iter().map(CryptoHash::hash).collect();
    let event_root_hash = InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash();
    ensure!(
        event_root_hash == transaction_info.event_root_hash(),
        "The event root hash calculated doesn't match that carried on the \
                         transaction info! Calculated hash {:?}, transaction info hash {:?}",
        event_root_hash,
        transaction_info.event_root_hash()
    );
    Ok(())
}
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L401-408)
```rust
                chunk.iter().enumerate().try_for_each(|(i, txn_out)| {
                    self.ledger_db.event_db().put_events(
                        chunk_first_ver + i as Version,
                        txn_out.events(),
                        skip_index,
                        &mut batch,
                    )
                })?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/analysis.rs (L77-79)
```rust
        for (index, event) in events.iter().enumerate() {
            let event_size = event.size();
            events_size += event_size;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L499-502)
```rust
                .map(|event| EventSizeInfo {
                    type_tag_bytes: Self::ser_size_u32(event.type_tag()),
                    total_bytes: event.size() as u32,
                })
```
