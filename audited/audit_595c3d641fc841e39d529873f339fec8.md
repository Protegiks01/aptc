# Audit Report

## Title
Quadratic Algorithmic Complexity in Transaction Filter Enables Mempool and Consensus DoS

## Summary
The `allows_transaction()` function in the transaction filter performs inefficient O(R × A) operations when matching `AccountAddress` rules against Script transactions with many arguments, where R is the number of filter rules and A is the number of script arguments. An attacker can craft Script transactions with thousands of arguments to trigger worst-case performance, causing denial-of-service in mempool admission and consensus batch processing.

## Finding Description

The transaction filter is used in critical paths for mempool admission [1](#0-0)  and consensus batch coordination [2](#0-1) . 

The vulnerability stems from the `allows_transaction()` function [3](#0-2)  which iterates through all filter rules. For each rule with an `AccountAddress` matcher [4](#0-3) , it calls multiple matching functions including `matches_script_argument_address()`.

The `compare_script_argument_address()` function performs a linear search through all script arguments [5](#0-4) . This creates O(R × A) complexity where R is the number of rules and A is the number of script arguments.

Additionally, the `matches_transaction_authenticator_address()` function uses `Vec::contains()` for checking secondary signer addresses [6](#0-5)  and [7](#0-6) , which is O(K) where K is the number of secondary signers (up to 32).

**Attack Scenario:**
1. Attacker crafts Script transactions with ~20,000 U8 arguments (each 1-2 bytes, fitting within the 64KB transaction size limit [8](#0-7) )
2. The Script struct stores arguments as `Vec<TransactionArgument>` [9](#0-8) 
3. If mempool or consensus filter has 100 rules with `AccountAddress` matchers, each transaction triggers 100 × 20,000 = 2,000,000 iterations
4. Attacker floods mempool with thousands of such transactions
5. Mempool and consensus processing slows down significantly

The transaction filter configuration is loaded from YAML with no limit on the number of rules [10](#0-9) .

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program category "Validator node slowdowns." The attack can:

- **Degrade Mempool Performance**: Each transaction requires millions of operations before admission, blocking legitimate transaction processing
- **Impact Consensus**: Batch coordinator filtering slows block proposal processing
- **Amplifiable Attack**: Single attacker can submit many malicious transactions to compound the effect
- **No Gas Cost for Filter**: The filter check happens before gas metering, so attackers pay normal transaction fees but impose disproportionate CPU costs

The attack doesn't directly steal funds or violate consensus safety, but it breaks the **Resource Limits invariant** (Invariant #9) by allowing unbounded CPU consumption in non-gas-metered code paths.

## Likelihood Explanation

**Likelihood: High**

- **Low Attack Complexity**: Creating Script transactions with many U8 arguments is trivial
- **No Special Access Required**: Any user can submit transactions to mempool
- **Realistic Filter Configurations**: Production deployments may use dozens to hundreds of filtering rules for compliance or security purposes
- **Direct Impact**: No race conditions or special timing required
- **Cost-Effective**: Attacker pays normal transaction fees but causes disproportionate resource consumption

The attack is immediately exploitable if transaction filters are enabled with multiple `AccountAddress` rules.

## Recommendation

**Immediate Fixes:**

1. **Optimize `Vec::contains()` calls**: Convert `secondary_signer_addresses` to `HashSet` for O(1) lookups instead of O(n) linear search:

```rust
// In TransactionAuthenticator, store secondary_signer_addresses as HashSet
// Or convert to HashSet before the contains() check
let secondary_addresses_set: HashSet<_> = secondary_signer_addresses.iter().collect();
if secondary_addresses_set.contains(address) { ... }
```

2. **Add early termination for script argument matching**: Instead of checking ALL arguments, use a bloom filter or limit the search depth

3. **Impose filter complexity limits**: Add configuration limits on:
   - Maximum number of rules (e.g., 100)
   - Maximum matchers per rule (e.g., 10)
   - Total filter evaluation budget with timeout

4. **Cache filter results**: For identical transactions (by hash), cache the filter decision

**Long-term Solutions:**

- Implement O(1) address matching using HashSet-based matchers
- Add metrics and alerts for filter evaluation time
- Consider gas-metering the filter evaluation itself

## Proof of Concept

```rust
#[test]
fn test_quadratic_complexity_dos() {
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
    use aptos_types::{
        account_address::AccountAddress,
        chain_id::ChainId,
        transaction::{Script, RawTransaction, SignedTransaction, TransactionPayload},
    };
    use move_core_types::transaction_argument::TransactionArgument;
    use std::time::Instant;
    
    // Create filter with 100 rules, each with AccountAddress matcher
    let mut filter = TransactionFilter::empty();
    for _ in 0..100 {
        filter = filter.add_account_address_filter(true, AccountAddress::random());
    }
    
    // Create Script transaction with 20,000 U8 arguments
    let mut args = Vec::new();
    for i in 0..20_000 {
        args.push(TransactionArgument::U8((i % 256) as u8));
    }
    
    let script = Script::new(vec![0x4d, 0x56], vec![], args);
    let private_key = Ed25519PrivateKey::generate_for_testing();
    let raw_txn = RawTransaction::new(
        AccountAddress::random(),
        0,
        TransactionPayload::Script(script),
        1_000_000,
        1,
        u64::MAX,
        ChainId::new(1),
    );
    let signed_txn = SignedTransaction::new(
        raw_txn,
        private_key.public_key(),
        private_key.sign(&raw_txn).unwrap(),
    );
    
    // Measure filter evaluation time
    let start = Instant::now();
    let _ = filter.allows_transaction(&signed_txn);
    let duration = start.elapsed();
    
    // With 100 rules × 20,000 args = 2M iterations, expect >> 1ms
    println!("Filter evaluation took: {:?}", duration);
    assert!(duration.as_millis() > 10, "Expected significant processing time");
}
```

**Notes:**

The vulnerability is confirmed through code analysis showing the quadratic complexity in the matching logic. The `Vec::contains()` calls and `iter().any()` patterns create nested loops when combined with the rule iteration. While transaction size limits prevent unbounded growth, an attacker can still craft transactions that trigger millions of operations per filter check, sufficient to cause denial-of-service on mempool and consensus components.

### Citations

**File:** mempool/src/shared_mempool/tasks.rs (L437-437)
```rust
                .allows_transaction(&transaction)
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L195-195)
```rust
                    if !transaction_filter.allows_transaction(
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L30-47)
```rust
    pub fn allows_transaction(&self, signed_transaction: &SignedTransaction) -> bool {
        // If the filter is empty, allow the transaction by default
        if self.is_empty() {
            return true;
        }

        // Check if any rule matches the transaction
        for transaction_rule in &self.transaction_rules {
            if transaction_rule.matches(signed_transaction) {
                return match transaction_rule {
                    TransactionRule::Allow(_) => true,
                    TransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the transaction by default)
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L197-203)
```rust
            TransactionMatcher::AccountAddress(address) => {
                matches_sender_address(signed_transaction, address)
                    || matches_entry_function_module_address(signed_transaction, address)
                    || matches_multisig_address(signed_transaction, address)
                    || matches_script_argument_address(signed_transaction, address)
                    || matches_transaction_authenticator_address(signed_transaction, address)
            },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L248-256)
```rust
fn compare_script_argument_address(script: &Script, address: &AccountAddress) -> bool {
    script.args().iter().any(|transaction_argument| {
        if let TransactionArgument::Address(argument_address) = transaction_argument {
            argument_address == address
        } else {
            false
        }
    })
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L507-507)
```rust
                || secondary_signer_addresses.contains(address)
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L520-520)
```rust
                || secondary_signer_addresses.contains(address)
```

**File:** aptos-move/aptos-release-builder/data/example_output/4-gas-schedule.move (L108-108)
```text
//     txn.max_transaction_size_in_bytes                                   : 65536
```

**File:** types/src/transaction/script.rs (L64-69)
```rust
pub struct Script {
    #[serde(with = "serde_bytes")]
    code: Vec<u8>,
    ty_args: Vec<TypeTag>,
    args: Vec<TransactionArgument>,
}
```

**File:** config/src/config/transaction_filters_config.rs (L20-44)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct TransactionFilterConfig {
    filter_enabled: bool,                  // Whether the filter is enabled
    transaction_filter: TransactionFilter, // The transaction filter to apply
}

impl TransactionFilterConfig {
    pub fn new(filter_enabled: bool, transaction_filter: TransactionFilter) -> Self {
        Self {
            filter_enabled,
            transaction_filter,
        }
    }

    /// Returns true iff the filter is enabled and not empty
    pub fn is_enabled(&self) -> bool {
        self.filter_enabled && !self.transaction_filter.is_empty()
    }

    /// Returns a reference to the transaction filter
    pub fn transaction_filter(&self) -> &TransactionFilter {
        &self.transaction_filter
    }
}
```
