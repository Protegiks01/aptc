After thorough investigation of the Aptos Core codebase, I have validated this security claim. Here is my assessment:

# Audit Report

## Title
Unauthenticated Storage Server Summary Bypass Enables State Sync Denial of Service

## Summary
The Aptos state synchronization layer accepts `StorageServerSummary` messages from peers without cryptographically verifying the embedded `LedgerInfoWithSignatures`. This allows malicious peers to advertise fake data availability, manipulating peer selection algorithms and causing state synchronization delays.

## Finding Description

The state sync data client polls peers for storage summaries to determine which peers can service data requests. When a `StorageServerSummary` response is received, it contains a `DataSummary` with a `synced_ledger_info` field (type `LedgerInfoWithSignatures`) that should be signed by validators. However, **no signature verification occurs**.

**Attack Flow:**

1. **Unverified Summary Reception**: When the poller receives a storage summary, it directly updates the peer's state without verification. [1](#0-0) 

2. **Direct Storage Without Validation**: The summary is stored in peer state with no cryptographic checks. [2](#0-1) [3](#0-2) 

3. **Protocol Metadata Bypass**: The `ProtocolMetadata.can_service()` check always returns true with a TODO comment indicating this may need revision. [4](#0-3) 

4. **Timestamp-Based Selection**: The system uses the unverified `synced_ledger_info` timestamp to determine if peers can service optimistic fetches and subscriptions. [5](#0-4) [6](#0-5) 

**Exploitation Scenario:**

A malicious peer can forge a `StorageServerSummary` containing:
- Fabricated `LedgerInfoWithSignatures` with recent timestamps and high version numbers
- Empty or invalid BLS signatures (never checked)
- Fake data ranges claiming complete historical data

The victim node will:
- Accept the fake summary during polling
- Potentially select the malicious peer for data requests
- Waste resources when requests timeout or return invalid data
- Experience state sync delays while peer scoring gradually reduces the malicious peer's influence

**Evidence from Test Infrastructure**: The test suite creates fake ledger infos with empty signatures, confirming that signature verification is not performed on storage summaries. [7](#0-6) 

## Impact Explanation

This vulnerability enables **Denial of Service through state synchronization disruption**, qualifying as **High Severity** under the Aptos bug bounty category "Validator node slowdowns."

**Concrete Impacts:**

1. **State Sync Delays**: Validator and fullnode operators experience delayed synchronization as malicious peers are repeatedly selected based on fake advertisements
2. **Resource Exhaustion**: Network bandwidth and CPU cycles wasted on failed data requests and timeout handling
3. **Degraded Network Performance**: During periods with multiple malicious peers, honest nodes struggle to find reliable data sources

**Why Not Critical:**
- Actual transaction data IS verified when received (separate from summary advertisements)
- No consensus safety violations occur
- No fund theft or permanent network damage
- The peer scoring system provides eventual mitigation (though reactive, not preventive)

The default configuration enables peer score-based filtering, which excludes low-scoring peers' summaries from the global data summary calculation. [8](#0-7) [9](#0-8) 

However, this mitigation is reactive and does not prevent the initial exploitation or resource waste from continued polling of malicious peers.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack has low execution barriers:
- **Easy to execute**: Any connected peer can send arbitrary `StorageServerSummary` messages
- **No authentication required**: No cryptographic proof needed for summary advertisements  
- **Low cost**: No staking, validator status, or significant computational resources required

**Mitigating Factors:**
- Peer scoring system reduces malicious peer influence after multiple failures
- Default configuration excludes ignored peers from selection (score-based filtering)
- Multiple malicious peers needed for sustained impact

The peer scoring mechanism identifies and filters malicious peers, but this is a reactive defense that occurs after initial exploitation and resource waste. [10](#0-9) 

## Recommendation

Implement cryptographic verification of `LedgerInfoWithSignatures` in storage summaries:

1. **Immediate Fix**: Verify the BLS signature in `synced_ledger_info` against the validator set when processing storage summaries:
   - Extract the validator verifier for the appropriate epoch
   - Call `LedgerInfoWithSignatures::verify_signatures()` before accepting the summary
   - Reject summaries with invalid signatures

2. **Design Consideration**: If summary verification adds unacceptable overhead, consider:
   - Using a separate, lightweight authentication mechanism for peer advertisements
   - Implementing challenge-response protocols where peers must prove data availability
   - Restricting summary acceptance to authenticated/trusted peer sets

3. **Enhanced Mitigation**: Strengthen peer scoring to more aggressively penalize peers advertising inconsistent or unverifiabl data.

## Proof of Concept

While no executable PoC is provided, the vulnerability can be demonstrated by:

1. Running an Aptos node with modified storage service that sends fake summaries
2. Observing that fake summaries with arbitrary timestamps/versions are accepted
3. Monitoring peer selection logs showing the malicious peer being chosen for requests
4. Measuring state sync delays until peer scoring excludes the malicious peer

The test infrastructure already demonstrates that signatures are not verified, as tests routinely create `LedgerInfoWithSignatures` with empty signatures that are accepted by the system.

## Notes

**Important Context:**

1. **Design vs Implementation**: This appears to be a design limitation rather than an implementation bug. The storage summary mechanism treats peer advertisements as lightweight, unauthenticated hints rather than cryptographically proven claims.

2. **Mitigation Effectiveness**: The peer scoring system IS active and DOES reduce impact over time. Ignored peers' summaries are excluded from the global summary used for peer selection. However, malicious peers continue to be polled, wasting resources.

3. **Not a Network DoS**: This is an application-level protocol vulnerability exploiting missing authentication in peer advertisements, distinct from infrastructure-level network DoS attacks (which are out of scope).

4. **Actual Data Verification**: When transaction data, outputs, or states are actually received (not just advertised), they ARE cryptographically verified with proper ledger info signature checks in the state sync driver layer.

The vulnerability is valid because it enables measurable state sync disruption through a protocol-level design flaw, meeting the "Validator node slowdowns" impact category despite the presence of reactive mitigations.

### Citations

**File:** state-sync/aptos-data-client/src/poller.rs (L436-439)
```rust
        // Update the summary for the peer
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L152-160)
```rust
    fn is_ignored(&self) -> bool {
        // Only ignore peers if the config allows it
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }

        // Otherwise, ignore peers with a low score
        self.score <= IGNORE_PEER_THRESHOLD
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L177-179)
```rust
    fn update_storage_summary(&mut self, storage_summary: StorageServerSummary) {
        self.storage_summary = Some(storage_summary);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L325-329)
```rust
    pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
        self.peer_to_state
            .entry(peer)
            .or_insert(PeerState::new(self.data_client_config.clone()))
            .update_storage_summary(storage_summary);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L341-349)
```rust
        let storage_summaries: Vec<StorageServerSummary> = self
            .peer_to_state
            .iter()
            .filter_map(|peer_state| {
                peer_state
                    .value()
                    .get_storage_summary_if_not_ignored()
                    .cloned()
            })
```

**File:** state-sync/storage-service/types/src/responses.rs (L644-650)
```rust
impl ProtocolMetadata {
    /// We deem all requests serviceable, even if the requested chunk
    /// sizes are larger than the maximum sizes that can be served (the
    /// response will simply be truncated on the server side).
    pub fn can_service(&self, _request: &StorageServiceRequest) -> bool {
        true // TODO: figure out if should eventually remove this
    }
```

**File:** state-sync/storage-service/types/src/responses.rs (L708-721)
```rust
            GetNewTransactionOutputsWithProof(_) => can_service_optimistic_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
            GetNewTransactionsWithProof(_) => can_service_optimistic_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
            GetNewTransactionsOrOutputsWithProof(_) => can_service_optimistic_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
```

**File:** state-sync/storage-service/types/src/responses.rs (L914-933)
```rust
/// Returns true iff the synced ledger info timestamp
/// is within the given lag (in seconds).
fn check_synced_ledger_lag(
    synced_ledger_info: Option<&LedgerInfoWithSignatures>,
    time_service: TimeService,
    max_lag_secs: u64,
) -> bool {
    if let Some(synced_ledger_info) = synced_ledger_info {
        // Get the ledger info timestamp (in microseconds)
        let ledger_info_timestamp_usecs = synced_ledger_info.ledger_info().timestamp_usecs();

        // Get the current timestamp and max version lag (in microseconds)
        let current_timestamp_usecs = time_service.now_unix_time().as_micros() as u64;
        let max_version_lag_usecs = max_lag_secs * NUM_MICROSECONDS_IN_SECOND;

        // Return true iff the synced ledger info timestamp is within the max version lag
        ledger_info_timestamp_usecs + max_version_lag_usecs > current_timestamp_usecs
    } else {
        false // No synced ledger info was found!
    }
```

**File:** state-sync/aptos-data-client/src/tests/utils.rs (L114-150)
```rust
fn create_ledger_info(version: Version, timestamp_usecs: u64) -> LedgerInfoWithSignatures {
    LedgerInfoWithSignatures::new(
        LedgerInfo::new(
            BlockInfo::new(
                0,
                0,
                HashValue::zero(),
                HashValue::zero(),
                version,
                timestamp_usecs,
                None,
            ),
            HashValue::zero(),
        ),
        AggregateSignature::empty(),
    )
}

/// Creates a test storage server summary at the given version and timestamp
pub fn create_storage_summary(version: Version) -> StorageServerSummary {
    create_storage_summary_with_timestamp(version, 0)
}

/// Creates a test storage server summary at the given version and timestamp
pub fn create_storage_summary_with_timestamp(
    version: Version,
    timestamp_usecs: u64,
) -> StorageServerSummary {
    StorageServerSummary {
        protocol_metadata: ProtocolMetadata {
            max_epoch_chunk_size: 1000,
            max_state_chunk_size: 1000,
            max_transaction_chunk_size: 1000,
            max_transaction_output_chunk_size: 1000,
        },
        data_summary: DataSummary {
            synced_ledger_info: Some(create_ledger_info(version, timestamp_usecs)),
```

**File:** config/src/config/state_sync_config.rs (L466-466)
```rust
            ignore_low_score_peers: true,
```
