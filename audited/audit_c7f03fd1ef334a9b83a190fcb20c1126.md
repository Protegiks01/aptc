# Audit Report

## Title
Missing Proof Version Validation Enables Resource Exhaustion Attack on Storage Service

## Summary
The `get_transaction_data_with_proof()` constructor in the storage service request types does not validate that `proof_version >= end_version`, allowing malicious peers to craft requests that bypass invalid request tracking and cause unnecessary resource consumption on storage servers. This enables a resource exhaustion attack vector that is not properly rate-limited.

## Finding Description

The storage service request constructor at [1](#0-0)  creates a `GetTransactionDataWithProofRequest` without validating the relationship between `proof_version` and `end_version`. 

A transaction accumulator range proof can only be generated when the proof version is at or after all transactions being proven. This invariant is enforced deep in the accumulator layer at [2](#0-1) , which validates that `last_leaf_index < self.num_leaves`, effectively requiring `end_version <= proof_version`.

However, the request validation layer at [3](#0-2)  only checks that the `proof_version` is available in storage (synced_ledger_info >= proof_version), but does NOT validate the relationship between `proof_version` and `end_version` at [4](#0-3) .

**Attack Flow:**
1. Attacker creates request with `start_version=100, end_version=200, proof_version=150` (proof_version < end_version)
2. Request passes the `can_service()` validation at [5](#0-4)  because both the data range and proof version are individually available
3. Server processes request and fetches transaction data from storage at [6](#0-5) 
4. When generating the proof at [7](#0-6) , the accumulator validation fails
5. Error is converted to `StorageErrorEncountered` at [8](#0-7) , then to `InternalError` at [9](#0-8) 
6. Critically, the peer's invalid request count is NOT incremented because the error is not classified as `InvalidRequest`

## Impact Explanation

This is a **High Severity** issue per the Aptos bug bounty criteria for the following reasons:

1. **Validator Node Slowdowns**: Malicious peers can repeatedly send invalid requests that force storage servers to perform expensive I/O operations (fetching transaction data from disk, deserialization) before discovering the request is invalid. With max chunk sizes of thousands of transactions, each invalid request consumes significant resources.

2. **Bypasses Invalid Request Tracking**: The error is misclassified as an internal error rather than an invalid request, so the malicious peer is not penalized. The request moderator at [10](#0-9)  only increments invalid request counts and ignores peers when they send too many `InvalidRequest` errors, not internal errors.

3. **Resource Exhaustion Vector**: An attacker can amplify the attack by sending many such requests without being rate-limited, causing sustained resource consumption on storage service nodes critical for state synchronization.

## Likelihood Explanation

**Likelihood: High**

- **Trivial to Exploit**: Requires only setting `proof_version < end_version` in the request parameters
- **No Authentication Required**: Any network peer can send storage service requests
- **Not Rate-Limited**: Invalid requests bypass the invalid request counting mechanism
- **Amplifiable**: Can send multiple concurrent requests to multiple storage servers
- **Affects All Deployments**: This is a fundamental validation gap in the storage service protocol

## Recommendation

Add validation in the request constructor to ensure `proof_version >= end_version`:

```rust
pub fn get_transaction_data_with_proof(
    proof_version: u64,
    start_version: u64,
    end_version: u64,
    include_events: bool,
    max_response_bytes: u64,
) -> Result<Self, &'static str> {
    // Validate version ranges
    if start_version > end_version {
        return Err("start_version must be <= end_version");
    }
    if proof_version < end_version {
        return Err("proof_version must be >= end_version to generate valid proofs");
    }
    
    let transaction_data_request_type =
        TransactionDataRequestType::TransactionData(TransactionData { include_events });
    Ok(Self::GetTransactionDataWithProof(GetTransactionDataWithProofRequest {
        transaction_data_request_type,
        proof_version,
        start_version,
        end_version,
        max_response_bytes,
    }))
}
```

Additionally, add the same validation in the `can_service_transactions_with_proof` method at the server validation layer to provide defense-in-depth.

## Proof of Concept

```rust
#[tokio::test]
async fn test_invalid_proof_version_resource_exhaustion() {
    use aptos_storage_service_types::requests::DataRequest;
    
    // Create storage service with committed transactions up to version 1000
    let (mut mock_client, service, _, _, _) = MockClient::new(None, None);
    tokio::spawn(service.start());
    
    // Setup: Commit 1000 transactions to storage
    for version in 0..1000 {
        // ... commit transaction at version ...
    }
    
    // Attack: Request transactions with proof_version < end_version
    let start_version = 100;
    let end_version = 500;
    let proof_version = 300; // Invalid: proof_version < end_version
    
    let request = DataRequest::get_transaction_data_with_proof(
        proof_version,
        start_version,
        end_version,
        false,
        10_000_000,
    );
    
    // The request passes can_service validation
    let summary = mock_client.get_summary().await.unwrap();
    assert!(summary.can_service(&config, time_service, &request));
    
    // But causes resource waste when processed
    let response = mock_client.send_request(request).await;
    
    // Assert: Returns InternalError, not InvalidRequest
    // This means the peer is not penalized for the invalid request
    assert_matches!(response.unwrap_err(), StorageServiceError::InternalError(_));
    
    // The malicious peer can repeat this attack without being rate-limited
    // because the invalid request counter is not incremented
}
```

## Notes

The vulnerability affects all three transaction data request types (TransactionData, TransactionOutputData, and TransactionOrOutputData) that use the same validation logic. The similar helper functions `get_transaction_output_data_with_proof()` and `get_transaction_or_output_data_with_proof()` at [11](#0-10)  have the same vulnerability and should be fixed with the same validation.

### Citations

**File:** state-sync/storage-service/types/src/requests.rs (L158-174)
```rust
    pub fn get_transaction_data_with_proof(
        proof_version: u64,
        start_version: u64,
        end_version: u64,
        include_events: bool,
        max_response_bytes: u64,
    ) -> Self {
        let transaction_data_request_type =
            TransactionDataRequestType::TransactionData(TransactionData { include_events });
        Self::GetTransactionDataWithProof(GetTransactionDataWithProofRequest {
            transaction_data_request_type,
            proof_version,
            start_version,
            end_version,
            max_response_bytes,
        })
    }
```

**File:** state-sync/storage-service/types/src/requests.rs (L177-212)
```rust
    pub fn get_transaction_output_data_with_proof(
        proof_version: u64,
        start_version: u64,
        end_version: u64,
        max_response_bytes: u64,
    ) -> Self {
        let transaction_data_request_type = TransactionDataRequestType::TransactionOutputData;
        Self::GetTransactionDataWithProof(GetTransactionDataWithProofRequest {
            transaction_data_request_type,
            proof_version,
            start_version,
            end_version,
            max_response_bytes,
        })
    }

    /// Creates and returns a request to get new transaction or output data with a proof
    pub fn get_transaction_or_output_data_with_proof(
        proof_version: u64,
        start_version: u64,
        end_version: u64,
        include_events: bool,
        max_response_bytes: u64,
    ) -> Self {
        let transaction_data_request_type =
            TransactionDataRequestType::TransactionOrOutputData(TransactionOrOutputData {
                include_events,
            });
        Self::GetTransactionDataWithProof(GetTransactionDataWithProofRequest {
            transaction_data_request_type,
            proof_version,
            start_version,
            end_version,
            max_response_bytes,
        })
    }
```

**File:** storage/accumulator/src/lib.rs (L424-429)
```rust
        ensure!(
            last_leaf_index < self.num_leaves,
            "Invalid last_leaf_index: {}, num_leaves: {}",
            last_leaf_index,
            self.num_leaves,
        );
```

**File:** state-sync/storage-service/types/src/responses.rs (L810-816)
```rust
    /// Returns true iff the peer can create a proof for the given version
    fn can_create_proof(&self, proof_version: u64) -> bool {
        self.synced_ledger_info
            .as_ref()
            .map(|li| li.ledger_info().version() >= proof_version)
            .unwrap_or(false)
    }
```

**File:** state-sync/storage-service/types/src/responses.rs (L867-882)
```rust
    /// Returns true iff the peer can service the transactions and proof
    fn can_service_transactions_with_proof(
        &self,
        start_version: u64,
        end_version: u64,
        proof_version: u64,
    ) -> bool {
        let desired_range = match CompleteDataRange::new(start_version, end_version) {
            Ok(desired_range) => desired_range,
            Err(_) => return false,
        };

        let can_service_transactions = self.can_service_transactions(&desired_range);
        let can_create_proof = self.can_create_proof(proof_version);
        can_service_transactions && can_create_proof
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L50-69)
```rust
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L134-196)
```rust
    pub fn validate_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<(), Error> {
        // Validate the request and time the operation
        let validate_request = || {
            // If the peer is being ignored, return an error
            if let Some(peer_state) = self.unhealthy_peer_states.get(peer_network_id) {
                if peer_state.is_ignored() {
                    return Err(Error::TooManyInvalidRequests(format!(
                        "Peer is temporarily ignored. Unable to handle request: {:?}",
                        request
                    )));
                }
            }

            // Get the latest storage server summary
            let storage_server_summary = self.cached_storage_server_summary.load();

            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }

            Ok(()) // The request is valid
        };
        utils::execute_and_time_duration(
            &metrics::STORAGE_REQUEST_VALIDATION_LATENCY,
            Some((peer_network_id, request)),
            None,
            validate_request,
            None,
        )
    }
```

**File:** state-sync/storage-service/server/src/storage.rs (L1140-1192)
```rust
    fn get_transaction_data_with_proof(
        &self,
        transaction_data_with_proof_request: &GetTransactionDataWithProofRequest,
    ) -> aptos_storage_service_types::Result<TransactionDataWithProofResponse, Error> {
        // Extract the data versions from the request
        let proof_version = transaction_data_with_proof_request.proof_version;
        let start_version = transaction_data_with_proof_request.start_version;
        let end_version = transaction_data_with_proof_request.end_version;

        // Calculate the max response size to use
        let max_response_bytes = min(
            transaction_data_with_proof_request.max_response_bytes,
            self.config.max_network_chunk_bytes_v2,
        );

        // Fetch the transaction data based on the request type
        match transaction_data_with_proof_request.transaction_data_request_type {
            TransactionDataRequestType::TransactionData(request) => {
                // Get the transaction list with proof
                self.get_transactions_with_proof_by_size(
                    proof_version,
                    start_version,
                    end_version,
                    request.include_events,
                    max_response_bytes,
                    self.config.enable_size_and_time_aware_chunking,
                )
            },
            TransactionDataRequestType::TransactionOutputData => {
                // Get the transaction output list with proof
                self.get_transaction_outputs_with_proof_by_size(
                    proof_version,
                    start_version,
                    end_version,
                    max_response_bytes,
                    false,
                    self.config.enable_size_and_time_aware_chunking,
                )
            },
            TransactionDataRequestType::TransactionOrOutputData(request) => {
                // Get the transaction or output list with proof
                self.get_transactions_or_outputs_with_proof_by_size(
                    proof_version,
                    start_version,
                    end_version,
                    request.include_events,
                    0, // Fetch all outputs, or return transactions
                    max_response_bytes,
                    self.config.enable_size_and_time_aware_chunking,
                )
            },
        }
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_accumulator_db.rs (L77-90)
```rust
    pub fn get_transaction_range_proof(
        &self,
        start_version: Option<Version>,
        num_txns: u64,
        ledger_version: Version,
    ) -> Result<TransactionAccumulatorRangeProof> {
        Accumulator::get_range_proof(
            self,
            ledger_version + 1, /* num_leaves */
            start_version,
            num_txns,
        )
        .map_err(Into::into)
    }
```

**File:** state-sync/storage-service/server/src/error.rs (L43-46)
```rust
impl From<aptos_storage_interface::AptosDbError> for Error {
    fn from(error: aptos_storage_interface::AptosDbError) -> Self {
        Error::StorageErrorEncountered(error.to_string())
    }
```

**File:** state-sync/storage-service/server/src/handler.rs (L196-202)
```rust
        process_result.map_err(|error| match error {
            Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
            Error::TooManyInvalidRequests(error) => {
                StorageServiceError::TooManyInvalidRequests(error)
            },
            error => StorageServiceError::InternalError(error.to_string()),
        })
```
