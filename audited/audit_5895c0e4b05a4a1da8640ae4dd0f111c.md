# Audit Report

## Title
Unchecked State Key Access in Sharded Block Executor Causes Network-Wide Validator Crash

## Summary
The `aggregate_and_update_total_supply()` function in the sharded block executor performs an unsafe `.unwrap()` operation when reading `TOTAL_SUPPLY_STATE_KEY` from state. If this critical state key is missing, all validators running with sharded execution enabled would panic simultaneously, causing complete network liveness failure. [1](#0-0) 

## Finding Description

The vulnerability exists in the post-execution aggregation logic used by the sharded block executor. After sharded execution completes, the system aggregates total supply deltas across all shards. This aggregation requires reading the base value of `TOTAL_SUPPLY_STATE_KEY` from state: [2](#0-1) 

The `get_state_value` helper function returns `Option<T>`, where `None` indicates either:
1. The state key doesn't exist (returned `Ok(None)` from `get_state_value_bytes`)
2. An error occurred during state access (converted to `None` via `.ok()?`) [3](#0-2) 

The sharded executor is invoked when transactions are partitioned into `ExecutableTransactions::Sharded`: [4](#0-3) 

This aggregation occurs in `LocalExecutorClient::execute_block` after all shards complete: [5](#0-4) 

**Scenario for Exploitation:**

While `TOTAL_SUPPLY_STATE_KEY` is initialized during genesis via `aptos_coin::initialize`: [6](#0-5) 

The following scenarios could result in a missing state key:

1. **State Sync Edge Cases**: During state snapshot synchronization, if validators attempt block execution before the state sync completes, certain keys including `TOTAL_SUPPLY_STATE_KEY` might not yet be synced
2. **Database Corruption**: Storage layer corruption affecting specific state keys
3. **State Rollback Scenarios**: Rollback to a state version before genesis completion
4. **Race Conditions**: Concurrent state sync and execution operations where state view consistency is violated

## Impact Explanation

**Critical Severity** - Total Loss of Liveness/Network Availability

If this vulnerability is triggered when sharded execution is enabled across the validator set:

1. **Simultaneous Validator Crash**: All validators executing the same block would panic at the identical code location
2. **Network Halt**: With all validators crashed, the network cannot produce new blocks
3. **Consensus Breakdown**: AptosBFT cannot function without active validators
4. **Deterministic Failure**: Since all validators execute identical code with identical state inputs, the crash is deterministic and synchronized

This breaks the **Consensus Safety** and **Deterministic Execution** invariants. The network would require coordinated manual intervention (validator restarts with potential configuration changes or state repairs) to recover.

Per Aptos Bug Bounty criteria, this qualifies as **Critical Severity** under "Total loss of liveness/network availability."

## Likelihood Explanation

**Low to Medium Likelihood:**

**Reducing Factors:**
- Sharded execution is disabled by default (`num_executor_shards = 0`) [7](#0-6) 
- `TOTAL_SUPPLY_STATE_KEY` is initialized during genesis and should persist
- Production validators would need explicit configuration to enable sharding

**Increasing Factors:**
- No defensive checks against missing state keys in consensus-critical code
- State sync mechanisms could introduce race conditions
- If sharded execution is ever enabled for performance optimization, this becomes immediately exploitable
- Database corruption, though rare, is a realistic operational risk

The likelihood increases significantly if/when sharded execution becomes a production feature or if validators enable it for performance testing.

## Recommendation

**Immediate Fix:**

Replace the unsafe `.unwrap()` with defensive error handling:

```rust
let total_supply_base_val: u128 = get_state_value(&TOTAL_SUPPLY_STATE_KEY, state_view)
    .ok_or_else(|| {
        VMStatus::error(
            StatusCode::STORAGE_ERROR,
            Some("TOTAL_SUPPLY_STATE_KEY missing from state during aggregation".to_string())
        )
    })?;
```

**Alternative Approach:**

Provide a fallback mechanism:

```rust
let total_supply_base_val: u128 = get_state_value(&TOTAL_SUPPLY_STATE_KEY, state_view)
    .unwrap_or_else(|| {
        warn!("TOTAL_SUPPLY_STATE_KEY missing, using TOTAL_SUPPLY_AGGR_BASE_VAL as fallback");
        TOTAL_SUPPLY_AGGR_BASE_VAL
    });
```

**Additional Safeguards:**
1. Add state validation before enabling sharded execution
2. Include `TOTAL_SUPPLY_STATE_KEY` in critical state key verification during bootstrapping
3. Add monitoring/alerting for missing critical state keys

## Proof of Concept

**Rust-based Test Reproduction:**

```rust
#[cfg(test)]
mod test_missing_state_key {
    use super::*;
    use aptos_types::{
        state_store::{StateView, state_key::StateKey},
        write_set::TOTAL_SUPPLY_STATE_KEY,
    };
    
    // Mock StateView that returns None for TOTAL_SUPPLY_STATE_KEY
    struct CorruptedStateView;
    
    impl StateView for CorruptedStateView {
        fn get_state_value_bytes(&self, state_key: &StateKey) -> 
            Result<Option<Bytes>, StateViewError> {
            if *state_key == *TOTAL_SUPPLY_STATE_KEY {
                // Simulate missing state key
                Ok(None)
            } else {
                Ok(Some(Bytes::new()))
            }
        }
        
        fn get_usage(&self) -> Result<StateStorageUsage, StateViewError> {
            Ok(StateStorageUsage::zero())
        }
    }
    
    #[test]
    #[should_panic(expected = "called `Option::unwrap()` on a `None` value")]
    fn test_panic_on_missing_total_supply_key() {
        let state_view = CorruptedStateView;
        let mut sharded_output = vec![vec![vec![]]];
        let mut global_output = vec![];
        let thread_pool = Arc::new(rayon::ThreadPoolBuilder::new().build().unwrap());
        
        // This should panic when TOTAL_SUPPLY_STATE_KEY is missing
        aggregate_and_update_total_supply(
            &mut sharded_output,
            &mut global_output,
            &state_view,
            thread_pool,
        );
    }
}
```

**Verification Steps:**
1. Create a test environment with sharded execution enabled
2. Corrupt or remove `TOTAL_SUPPLY_STATE_KEY` from the state database
3. Attempt to execute a block through the sharded path
4. Observe validator panic at line 212 of `sharded_aggregator_service.rs`
5. Verify that all validators with identical configuration crash simultaneously

## Notes

- This vulnerability only affects deployments with sharded block execution enabled
- The `AggregatorOverriddenStateView` provides an override during execution but is not used during the aggregation phase [8](#0-7) 
- The lack of defensive programming in consensus-critical code violates best practices for distributed systems
- Even with low current likelihood, this represents a critical failure mode if sharded execution becomes production-ready

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L15-24)
```rust
pub fn get_state_value<S: StateView, T: DeserializeOwned>(
    state_key: &StateKey,
    state_view: &S,
) -> Option<T> {
    let value = state_view
        .get_state_value_bytes(state_key)
        .ok()?
        .map(move |value| bcs::from_bytes(&value));
    value.transpose().map_err(anyhow::Error::msg).unwrap()
}
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L212-213)
```rust
    let total_supply_base_val: u128 = get_state_value(&TOTAL_SUPPLY_STATE_KEY, state_view).unwrap();
    let base_val_delta = DeltaU128::get_delta(total_supply_base_val, TOTAL_SUPPLY_AGGR_BASE_VAL);
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L68-89)
```rust
        let out = match transactions {
            ExecutableTransactions::Unsharded(txns) => {
                Self::by_transaction_execution_unsharded::<V>(
                    executor,
                    txns,
                    auxiliary_infos,
                    parent_state,
                    state_view,
                    onchain_config,
                    transaction_slice_metadata,
                )?
            },
            // TODO: Execution with auxiliary info is yet to be supported properly here for sharded transactions
            ExecutableTransactions::Sharded(txns) => Self::by_transaction_execution_sharded::<V>(
                txns,
                auxiliary_infos,
                parent_state,
                state_view,
                onchain_config,
                transaction_slice_metadata.append_state_checkpoint_to_block(),
            )?,
        };
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L215-220)
```rust
        sharded_aggregator_service::aggregate_and_update_total_supply(
            &mut sharded_output,
            &mut global_output,
            state_view.as_ref(),
            self.global_executor.get_executor_thread_pool(),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L138-150)
```text
    fun initialize_aptos_coin(aptos_framework: &signer) {
        let (burn_cap, mint_cap) = aptos_coin::initialize(aptos_framework);

        coin::create_coin_conversion_map(aptos_framework);
        coin::create_pairing<AptosCoin>(aptos_framework);

        // Give stake module MintCapability<AptosCoin> so it can mint rewards.
        stake::store_aptos_coin_mint_cap(aptos_framework, mint_cap);
        // Give transaction_fee module BurnCapability<AptosCoin> so it can burn gas.
        transaction_fee::store_aptos_coin_burn_cap(aptos_framework, burn_cap);
        // Give transaction_fee module MintCapability<AptosCoin> so it can mint refunds.
        transaction_fee::store_aptos_coin_mint_cap(aptos_framework, mint_cap);
    }
```

**File:** execution/executor-benchmark/src/pipeline.rs (L49-49)
```rust
    pub num_executor_shards: usize,
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/aggr_overridden_state_view.rs (L41-50)
```rust
    fn get_state_value(&self, state_key: &StateKey) -> Result<Option<StateValue>> {
        if *state_key == *TOTAL_SUPPLY_STATE_KEY {
            // TODO: Remove this when we have aggregated total supply implementation for remote
            //       sharding. For now we need this because after all the txns are executed, the
            //       proof checker expects the total_supply to read/written to the tree.
            self.base_view.get_state_value(state_key)?;
            return self.total_supply_base_view_override();
        }
        self.base_view.get_state_value(state_key)
    }
```
