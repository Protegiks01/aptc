# Audit Report

## Title
Byzantine Validators Can Mask Equivocation Behind SubscriptionTimeout Errors in Consensus Observer

## Summary
The consensus observer lacks equivocation detection when receiving ordered blocks. A Byzantine validator can send two different valid blocks for the same (epoch, round), and the second block is silently dropped as a "duplicate" without triggering invalid message counters or security events. When combined with a subsequent SubscriptionTimeout, the equivocation is masked behind a legitimate-looking timeout error, preventing proper Byzantine behavior detection.

## Finding Description

The consensus observer validates ordered blocks but does not detect when a validator sends multiple different blocks for the same round (equivocation). The vulnerability exists in how the observer checks for duplicate blocks: [1](#0-0) 

The `existing_pending_block()` function only checks if a block with the same `(epoch, round)` key exists in the pending store. It does NOT compare block IDs/hashes to verify it's the same block.

When processing ordered block messages: [2](#0-1) 

If a block with the same (epoch, round) already exists, it's dropped and only a "dropped message" metric is incrementedâ€”not an "invalid message" metric.

**Attack Execution:**

1. **Equivocation Phase:** Byzantine validator sends Block A for (epoch=N, round=R) with valid signatures. The observer validates and inserts it into the pending block store.

2. **Second Block:** Validator sends Block B for (epoch=N, round=R) with different content but also valid signatures (valid proof from the same validator set).

3. **Silent Drop:** The observer calls `existing_pending_block()` which returns `true` (same epoch/round key). Block B is dropped via `update_metrics_for_dropped_ordered_block_message()`: [3](#0-2) 

This only increments `OBSERVER_DROPPED_MESSAGES`, not `OBSERVER_INVALID_MESSAGES`. No security event is logged.

4. **Timeout Masking:** The validator stops sending messages. After 15 seconds, the subscription times out: [4](#0-3) 

5. **Evidence Destruction:** The timeout triggers subscription termination and state clearing: [5](#0-4) 

The metrics show "subscription_timeout" and "dropped_ordered_block" but never "invalid_message" for the equivocation. The Byzantine behavior is masked behind a legitimate-looking timeout.

**Contrast with Core Consensus:** The main consensus implementation has explicit equivocation detection that the observer lacks. Core consensus uses `UnequivocalProposerElection` to detect and reject multiple proposals for the same round, but the observer only checks (epoch, round) keys without verifying block identity.

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention.

This vulnerability allows Byzantine validators to:
- Mask equivocation attempts behind timeout errors
- Avoid detection that would normally trigger invalid message counters
- Potentially serve different blocks to different observers without proper detection
- Undermine Byzantine fault detection mechanisms in the consensus observer architecture

While this doesn't directly cause fund loss or consensus safety violations (since observers don't vote), it undermines the security monitoring and Byzantine detection capabilities of the system. Different observers could receive conflicting blocks from the same validator without proper alerting, potentially causing state inconsistencies that require manual intervention to diagnose and resolve.

## Likelihood Explanation

**High Likelihood** - This vulnerability is easily exploitable by any validator publishing to consensus observers:

- No special privileges required beyond being a connected validator
- Both blocks can have valid signatures (validator signs both)
- The exploit is deterministic and reliable
- No complex timing or race conditions
- Only requires sending two messages and then stopping

The main constraint is that the validator must be able to produce valid signatures for both blocks, which any validator in the validator set can do.

## Recommendation

Add explicit equivocation detection to the consensus observer by comparing block IDs when the same (epoch, round) is encountered:

**In `consensus/src/consensus_observer/observer/pending_blocks.rs`:**

Modify `existing_pending_block()` to also return the existing block ID if found, then compare it with the new block ID. If they differ, this is equivocation and should:

1. Increment `OBSERVER_INVALID_MESSAGES` counter
2. Log a `SecurityEvent::ConsensusEquivocatingOrderVote`  
3. Terminate the subscription immediately as Byzantine

**Example fix:**

```rust
// In pending_blocks.rs
pub fn check_for_equivocation(&self, ordered_block: &OrderedBlock) -> Option<HashValue> {
    let first_block = ordered_block.first_block();
    let key = (first_block.epoch(), first_block.round());
    
    if let Some(existing) = self.blocks_without_payloads.get(&key) {
        let existing_id = existing.ordered_block().first_block().id();
        let new_id = first_block.id();
        if existing_id != new_id {
            return Some(existing_id); // Equivocation detected
        }
    }
    None
}
```

**In `consensus/src/consensus_observer/observer/consensus_observer.rs`:**

Before checking `existing_pending_block()`, check for equivocation:

```rust
// Check for equivocation
if let Some(existing_id) = self.observer_block_data.lock()
    .check_for_equivocation(&ordered_block) {
    error!(
        SecurityEvent::ConsensusEquivocatingOrderVote,
        "Detected equivocating block from peer: {:?}. Existing ID: {:?}, New ID: {:?}",
        peer_network_id, existing_id, ordered_block.first_block().id()
    );
    increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
    // Immediately terminate this subscription
    return;
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_equivocation_detection_in_observer() {
    // Setup consensus observer with a subscription to a validator
    let (observer, validator_peer_id) = setup_observer_with_subscription();
    
    // Create two different blocks for the same (epoch=1, round=10)
    let epoch = 1;
    let round = 10;
    
    // Block A - valid block with transaction set 1
    let block_a = create_ordered_block_with_proof(
        epoch,
        round, 
        vec![create_test_transaction("tx1")],
        HashValue::random(), // block_a_id
    );
    
    // Block B - different block, same epoch/round, with transaction set 2
    let block_b = create_ordered_block_with_proof(
        epoch,
        round,
        vec![create_test_transaction("tx2")],  
        HashValue::random(), // block_b_id (different from block_a)
    );
    
    // Both blocks have valid signatures from the same validator set
    assert_ne!(block_a.first_block().id(), block_b.first_block().id());
    assert!(block_a.verify_ordered_proof(&epoch_state).is_ok());
    assert!(block_b.verify_ordered_proof(&epoch_state).is_ok());
    
    // Send Block A - should be accepted
    observer.process_ordered_block_message(
        validator_peer_id,
        Instant::now(),
        block_a.clone()
    ).await;
    
    // Verify Block A was inserted
    let metrics_before = get_invalid_message_count(validator_peer_id);
    assert!(observer.observer_block_data.lock()
        .existing_pending_block(&block_a));
    
    // Send Block B (equivocation) - should trigger invalid message counter
    observer.process_ordered_block_message(
        validator_peer_id,
        Instant::now(),
        block_b.clone()
    ).await;
    
    // EXPECTED: Invalid message counter should increment (equivocation detected)
    // ACTUAL: Only dropped message counter increments
    let metrics_after = get_invalid_message_count(validator_peer_id);
    
    // This assertion FAILS with current code, demonstrating the vulnerability
    assert_eq!(metrics_after, metrics_before + 1, 
        "Equivocation should increment invalid message counter");
    
    // Verify security event was logged
    assert!(logs_contain_security_event(SecurityEvent::ConsensusEquivocatingOrderVote),
        "Equivocation should log security event");
}
```

The test demonstrates that when two different blocks for the same (epoch, round) are received, the current implementation only increments the dropped message counter, not the invalid message counter, and no security event is logged. This allows the equivocation to be masked by a subsequent SubscriptionTimeout error.

### Citations

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L90-99)
```rust
    /// Returns true iff the store contains an entry for the given ordered block
    pub fn existing_pending_block(&self, ordered_block: &OrderedBlock) -> bool {
        // Get the epoch and round of the first block
        let first_block = ordered_block.first_block();
        let first_block_epoch_round = (first_block.epoch(), first_block.round());

        // Check if the block is already in the store by epoch and round
        self.blocks_without_payloads
            .contains_key(&first_block_epoch_round)
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L208-234)
```rust
        {
            // Log the failure and clear the pending block state
            warn!(LogSchema::new(LogEntry::ConsensusObserver)
                .message(&format!("Subscription checks failed! Error: {:?}", error)));
            self.clear_pending_block_state().await;
        }
    }

    /// Clears the pending block state (this is useful for changing
    /// subscriptions, where we want to wipe all state and restart).
    async fn clear_pending_block_state(&self) {
        // Clear the observer block data
        let root = self.observer_block_data.lock().clear_block_data();

        // Reset the execution pipeline for the root
        if let Err(error) = self.execution_client.reset(&root).await {
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to reset the execution pipeline for the root! Error: {:?}",
                    error
                ))
            );
        }

        // Increment the cleared block state counter
        metrics::increment_counter_without_labels(&metrics::OBSERVER_CLEARED_BLOCK_STATE);
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L677-691)
```rust
        // Determine if the block is behind the last ordered block, or if it is already pending
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let block_out_of_date =
            first_block_epoch_round <= (last_ordered_block.epoch(), last_ordered_block.round());
        let block_pending = self
            .observer_block_data
            .lock()
            .existing_pending_block(&ordered_block);

        // If the block is out of date or already pending, ignore it
        if block_out_of_date || block_pending {
            // Update the metrics for the dropped ordered block
            update_metrics_for_dropped_ordered_block_message(peer_network_id, &ordered_block);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1267-1283)
```rust
fn update_metrics_for_dropped_ordered_block_message(
    peer_network_id: PeerNetworkId,
    ordered_block: &OrderedBlock,
) {
    // Update the dropped message counter
    increment_dropped_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);

    // Log the dropped ordered block message
    debug!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Ignoring ordered block message from peer: {:?}! Block epoch and round: ({}, {})",
            peer_network_id,
            ordered_block.proof_block_info().epoch(),
            ordered_block.proof_block_info().round()
        ))
    );
}
```

**File:** consensus/src/consensus_observer/observer/subscription.rs (L166-182)
```rust
    fn check_subscription_timeout(&self) -> Result<(), Error> {
        // Calculate the duration since the last message
        let time_now = self.time_service.now();
        let duration_since_last_message = time_now.duration_since(self.last_message_receive_time);

        // Check if the subscription has timed out
        if duration_since_last_message
            > Duration::from_millis(self.consensus_observer_config.max_subscription_timeout_ms)
        {
            return Err(Error::SubscriptionTimeout(format!(
                "Subscription to peer: {} has timed out! No message received for: {:?}",
                self.peer_network_id, duration_since_last_message
            )));
        }

        Ok(())
    }
```
