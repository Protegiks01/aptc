# Audit Report

## Title
Missing Chain ID Validation in Indexer gRPC Manager Configuration Allows Data Integrity Compromise

## Summary
The `IndexerGrpcManagerConfig` struct accepts arbitrary `chain_id` values (including zero or invalid IDs) without validation, and the `DataManager` does not verify that fullnode transaction responses match the configured chain ID. On fresh deployments, this can cause the indexer to process and serve transactions from one blockchain while labeling them with a different chain ID.

## Finding Description

The vulnerability exists in the indexer-grpc-manager configuration and data processing pipeline:

**1. Missing Type Safety and Validation in Configuration:** [1](#0-0) 

The configuration uses a raw `u64` for `chain_id` instead of the validated `ChainId` type. The Aptos codebase explicitly reserves chain ID 0 to catch accidental initialization: [2](#0-1) [3](#0-2) 

However, the indexer config bypasses this validation by using `u64` directly.

**2. Missing Fullnode Response Validation:**

When the `DataManager` fetches transactions from fullnodes, it receives `TransactionsFromNodeResponse` messages that include the fullnode's actual chain ID: [4](#0-3) [5](#0-4) 

But the DataManager processes these responses without validating the chain_id field: [6](#0-5) 

**3. Unchecked Metadata Initialization:**

On fresh deployments, the FileStoreUploader creates metadata with whatever chain_id is provided: [7](#0-6) 

**Attack Scenario:**
1. Operator deploys fresh indexer-grpc-manager with misconfigured `chain_id: 0` or wrong chain ID (e.g., testnet ID on mainnet)
2. FileStoreUploader initializes metadata with the invalid/wrong chain_id
3. DataManager connects to fullnode (which sends correct chain_id in responses)
4. DataManager accepts and caches transactions without validating response chain_id
5. GrpcManagerService serves these transactions with the wrong chain_id label: [8](#0-7) 

**Contrast with Cache Worker:**

The cache worker properly validates chain IDs at multiple points: [9](#0-8) [10](#0-9) 

But the indexer-grpc-manager lacks equivalent protections.

## Impact Explanation

This issue qualifies as **Medium Severity** under the Aptos bug bounty criteria ("State inconsistencies requiring intervention"):

1. **Data Integrity Compromise**: The indexer serves blockchain transactions with incorrect chain ID labels, violating data integrity guarantees
2. **Operational Impact**: Requires manual intervention to detect and remediate once deployed
3. **Downstream System Failures**: Applications consuming indexer data may:
   - Reject all data if they validate chain_id=0 as invalid
   - Process transactions from the wrong chain if they don't validate
   - Experience inconsistent behavior across indexer instances

While this is an off-chain indexing component (not consensus-critical), it provides critical infrastructure for the Aptos ecosystem.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability is exploitable through:
- **Accidental misconfiguration** during deployment (realistic scenario given complex configs)
- **Testing deployments** where operators use chain_id=0 or testnet IDs
- **Copy-paste errors** from example configs

While it requires operator involvement rather than pure external attack, the lack of validation makes operational errors likely, especially for new deployments.

## Recommendation

Implement defense-in-depth validation at multiple layers:

**1. Use type-safe chain_id in configuration:**
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcManagerConfig {
    #[serde(deserialize_with = "deserialize_config_chain_id")]
    pub(crate) chain_id: ChainId,  // Changed from u64
    // ... rest of fields
}
```

**2. Add validation in DataManager start method:**
```rust
// After line 232 in data_manager.rs
let mut response = response.unwrap().into_inner();
while let Some(response_item) = response.next().await {
    match response_item {
        Ok(r) => {
            // Validate chain_id from fullnode response
            if r.chain_id as u64 != chain_id {
                panic!(
                    "Chain ID mismatch: expected {}, got {} from fullnode",
                    chain_id, r.chain_id
                );
            }
            // ... rest of processing
        }
    }
}
```

**3. Add validation in RunnableConfig implementation:**
```rust
impl RunnableConfig for IndexerGrpcManagerConfig {
    fn validate(&self) -> Result<()> {
        ensure!(
            self.chain_id.id() > 0,
            "Chain ID cannot be 0 (reserved for accidental initialization)"
        );
        Ok(())
    }
    // ... rest of implementation
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[cfg(test)]
mod vulnerability_test {
    use super::*;
    
    #[test]
    #[should_panic(expected = "Chain ID mismatch")]
    fn test_chain_id_mismatch_detection() {
        // This test demonstrates that currently there's NO panic
        // when chain IDs mismatch, but there SHOULD be
        
        let config = IndexerGrpcManagerConfig {
            chain_id: 0,  // Invalid chain ID - should be rejected
            // ... other fields
        };
        
        // Currently this would succeed but shouldn't
        // After fix, this should panic during validation
        config.validate().expect("Should reject chain_id=0");
    }
    
    #[tokio::test]
    async fn test_fullnode_chain_id_validation() {
        // Simulate receiving transaction with chain_id=1
        // while configured with chain_id=0
        let response = TransactionsFromNodeResponse {
            chain_id: 1,  // Mainnet
            response: Some(Response::Data(data)),
        };
        
        let configured_chain_id = 0;  // Invalid
        
        // Currently NO validation happens
        // Should panic with "Chain ID mismatch"
        assert_ne!(response.chain_id as u64, configured_chain_id);
    }
}
```

## Notes

While this is an off-chain indexing component and not consensus-critical, it represents a violation of defense-in-depth principles. The Aptos codebase explicitly protects against chain_id=0 elsewhere [11](#0-10) , but the indexer-grpc-manager bypasses these protections. The cache worker demonstrates the correct pattern for validation [12](#0-11) , which should be applied consistently across all indexer components.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L29-32)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcManagerConfig {
    pub(crate) chain_id: u64,
```

**File:** types/src/chain_id.rs (L14-24)
```rust
    /// Users might accidentally initialize the ChainId field to 0, hence reserving ChainId 0 for accidental
    /// initialization.
    /// MAINNET is the Aptos mainnet production chain and is reserved for 1
    MAINNET = 1,
    // Even though these CHAIN IDs do not correspond to MAINNET, changing them should be avoided since they
    // can break test environments for various organisations.
    TESTNET = 2,
    DEVNET = 3,
    TESTING = 4,
    PREMAINNET = 5,
}
```

**File:** types/src/chain_id.rs (L176-176)
```rust
            ensure!(value > 0, "cannot have chain ID with 0");
```

**File:** types/src/chain_id.rs (L183-186)
```rust
    pub fn new(id: u8) -> Self {
        assert!(id > 0, "cannot have chain ID with 0");
        Self(id)
    }
```

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L47-54)
```text
message TransactionsFromNodeResponse {
  oneof response {
    StreamStatus status = 1;
    TransactionsOutput data = 2;
  }
  // Making sure that all the responses include a chain id
  uint32 chain_id = 3;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L245-260)
```rust
pub fn get_status(
    status_type: StatusType,
    start_version: u64,
    end_version: Option<u64>,
    ledger_chain_id: u8,
) -> TransactionsFromNodeResponse {
    TransactionsFromNodeResponse {
        response: Some(transactions_from_node_response::Response::Status(
            StreamStatus {
                r#type: status_type as i32,
                start_version,
                end_version,
            },
        )),
        chain_id: ledger_chain_id as u32,
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L257-280)
```rust
                match response_item {
                    Ok(r) => {
                        if let Some(response) = r.response {
                            match response {
                                Response::Data(data) => {
                                    trace!(
                                        "Putting data into cache, {} transaction(s).",
                                        data.transactions.len()
                                    );
                                    self.cache.write().await.put_transactions(data.transactions);
                                },
                                Response::Status(_) => continue,
                            }
                        } else {
                            warn!("Error when getting transactions from fullnode: no data.");
                            continue 'out;
                        }
                    },
                    Err(e) => {
                        warn!("Error when getting transactions from fullnode: {}", e);
                        continue 'out;
                    },
                }
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L47-63)
```rust
        if !file_store.is_initialized().await {
            info!(
                chain_id = chain_id,
                "FileStore is not initialized, initializing..."
            );
            info!("Transactions per folder: {NUM_TXNS_PER_FOLDER}.");
            let metadata = FileStoreMetadata {
                chain_id,
                num_transactions_per_folder: NUM_TXNS_PER_FOLDER,
                version: 0,
            };
            let raw_data = serde_json::to_vec(&metadata).unwrap();
            file_store
                .save_raw_file(PathBuf::from(METADATA_FILE_NAME), raw_data)
                .await
                .unwrap_or_else(|e| panic!("Failed to initialize FileStore: {e:?}."));
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L129-146)
```rust
    async fn get_transactions(
        &self,
        request: Request<GetTransactionsRequest>,
    ) -> Result<Response<TransactionsResponse>, Status> {
        let request = request.into_inner();
        let transactions = self
            .data_manager
            .get_transactions(request.starting_version(), MAX_SIZE_BYTES_FROM_CACHE)
            .await
            .map_err(|e| Status::internal(format!("{e}")))?;

        Ok(Response::new(TransactionsResponse {
            transactions,
            chain_id: Some(self.chain_id),
            // Not used.
            processed_range: None,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L310-324)
```rust
    // Guaranteed that chain id is here at this point because we already ensure that fileworker did the set up
    let chain_id = cache_operator.get_chain_id().await?.unwrap();
    if chain_id != fullnode_chain_id as u64 {
        bail!("[Indexer Cache] Chain ID mismatch between fullnode init signal and cache.");
    }

    // It's required to start the worker with the same version as file store.
    if file_store_metadata.version != starting_version {
        bail!("[Indexer Cache] Starting version mismatch between filestore metadata and fullnode init signal.");
    }
    if file_store_metadata.chain_id != fullnode_chain_id as u64 {
        bail!("[Indexer Cache] Chain id mismatch between filestore metadata and fullnode.");
    }

    Ok((fullnode_chain_id, starting_version))
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L382-384)
```rust
        if received.chain_id as u64 != fullnode_chain_id as u64 {
            panic!("[Indexer Cache] Chain id mismatch happens during data streaming.");
        }
```
