# Audit Report

## Title
Time-of-Check-Time-of-Use (TOCTOU) Race in Module Metadata Validation Allows Bypass of Randomness Annotation Security

## Summary
A TOCTOU vulnerability exists between module metadata validation during publishing and metadata usage during execution. For bytecode version 5 modules, the validation path clears struct and function attributes before validation, but the execution path does not apply the same clearing. This allows attackers to publish version 5 modules with invalid randomness annotations that bypass validation, enabling unauthorized access to randomness APIs and potential test-and-abort attacks.

## Finding Description

The vulnerability stems from inconsistent metadata processing between two code paths:

**Validation Path (Module Publishing):** [1](#0-0) 

The validation uses `get_metadata_from_compiled_code()` which includes special handling for version 5 modules: [2](#0-1) 

This function clears `struct_attributes` and `fun_attributes` for version 5 modules before returning the metadata for validation. The comment explicitly states this "should have been gated in the verify module metadata."

**Execution Path (Transaction Execution):** [3](#0-2) 

During execution, the randomness annotation is retrieved using a different code path: [4](#0-3) 

This calls `get_metadata()` which deserializes metadata directly without the version 5 clearing logic: [5](#0-4) 

**Attack Scenario:**
1. Attacker creates a bytecode version 5 module containing V1 metadata with a randomness annotation on a function
2. During publishing, `get_metadata_from_compiled_code()` clears the attributes, so validation sees an empty attribute list and passes
3. The module is stored with its original metadata intact
4. During execution, `get_metadata()` retrieves the uncleaned metadata with the randomness annotation present
5. The transaction is marked as "unbiasable," granting access to randomness APIs
6. The attacker can now call randomness functions without proper validation

The randomness annotation is a critical security mechanism: [6](#0-5) 

Bypassing this check enables test-and-abort attacks where users selectively abort transactions based on received random values.

Version 5 modules are still accepted by the system: [7](#0-6) 

## Impact Explanation

**High Severity** - This vulnerability enables:

1. **Randomness Security Bypass**: Attackers can access randomness APIs without proper annotation validation, violating the security model designed to prevent test-and-abort attacks
2. **Potential Consensus Issues**: If validators have different feature flags or process metadata differently, this could lead to non-deterministic execution where some nodes enforce the check and others don't
3. **Protocol Violation**: The randomness mechanism is a fundamental security primitive in Aptos for games, lotteries, and other applications requiring unpredictable values

While this doesn't directly cause fund loss, it undermines a core security mechanism and could enable economic attacks on applications using randomness (e.g., biasing lottery outcomes, manipulating NFT drops).

## Likelihood Explanation

**High Likelihood** - The attack is highly feasible:

1. Version 5 bytecode is still accepted by the network (VERSION_MIN = VERSION_5)
2. No special privileges required - any user with module publishing permissions can exploit this
3. The vulnerability is deterministic and not dependent on race conditions or timing
4. The code comment explicitly acknowledges this should have been fixed, indicating it's a known gap
5. Creating a version 5 module with V1 metadata is straightforward for an attacker

## Recommendation

**Immediate Fix**: Reject version 5 modules that contain V1 metadata during publishing rather than silently clearing the attributes. Version 5 modules should not have V1 metadata at all, as indicated by: [8](#0-7) 

**Recommended Code Fix** in `check_metadata_format()`:

```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            // SECURITY FIX: Reject V1 metadata in version 5 modules
            if data.key == *APTOS_METADATA_KEY_V1 && module.version < METADATA_V1_MIN_FILE_FORMAT_VERSION {
                return Err(MalformedError::InvalidMetadataVersion);
            }

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        }
        // ... rest of function
    }
    Ok(())
}
```

Add new error variant:
```rust
pub enum MalformedError {
    // ... existing variants
    #[error("Invalid metadata version for bytecode version")]
    InvalidMetadataVersion,
}
```

**Alternative Fix**: Remove the version 5 special case from `get_metadata_from_compiled_code()` and enforce validation consistently. However, this might break existing deployed modules.

## Proof of Concept

```move
// Create a version 5 Move module with randomness annotation
// (This would need to be compiled with custom tooling to produce version 5 bytecode with V1 metadata)

module 0xAttacker::MaliciousRandomness {
    use std::vector;
    use aptos_framework::randomness;
    
    // This function should require #[randomness] annotation
    // but will bypass validation in version 5 bytecode
    entry fun exploit_randomness() {
        // This should fail without proper annotation
        // but will succeed due to TOCTOU vulnerability
        let _ = randomness::fetch_and_increment_txn_counter();
    }
}
```

**Rust Test to Verify Vulnerability:**
```rust
#[test]
fn test_metadata_toctou_vulnerability() {
    // Create a version 5 module with V1 metadata containing randomness annotation
    let mut module = create_test_module_v5();
    
    // Add V1 metadata with randomness annotation
    module.metadata = vec![
        Metadata {
            key: APTOS_METADATA_KEY_V1.to_vec(),
            value: bcs::to_bytes(&create_metadata_with_randomness()).unwrap(),
        }
    ];
    
    // Validation should pass (attributes are cleared)
    let validation_metadata = get_metadata_from_compiled_code(&module);
    assert!(validation_metadata.as_ref().unwrap().fun_attributes.is_empty());
    
    // Execution should see the attributes (TOCTOU vulnerability)
    let execution_metadata = get_metadata(&module.metadata);
    assert!(!execution_metadata.as_ref().unwrap().fun_attributes.is_empty());
    
    // This demonstrates the inconsistency
    assert_ne!(validation_metadata, execution_metadata);
}
```

## Notes

This vulnerability exists because metadata handling evolved over time, and version 5 modules with V1 metadata were never properly rejected at the validation stage. The workaround of clearing attributes during validation creates the TOCTOU window. The proper fix is to reject such modules outright during publishing, as version 5 predates V1 metadata support.

### Citations

**File:** types/src/vm/module_metadata.rs (L40-40)
```rust
pub const METADATA_V1_MIN_FILE_FORMAT_VERSION: u32 = 6;
```

**File:** types/src/vm/module_metadata.rs (L199-230)
```rust
pub fn get_metadata(md: &[Metadata]) -> Option<Arc<RuntimeModuleMetadataV1>> {
    if let Some(data) = find_metadata(md, APTOS_METADATA_KEY_V1) {
        V1_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let meta = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .ok()
                    .map(Arc::new);
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else if let Some(data) = find_metadata(md, APTOS_METADATA_KEY) {
        V0_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let meta = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .ok()
                    .map(RuntimeModuleMetadata::upgrade)
                    .map(Arc::new);
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else {
        None
    }
}
```

**File:** types/src/vm/module_metadata.rs (L234-250)
```rust
pub fn get_randomness_annotation_for_entry_function(
    entry_func: &EntryFunction,
    metadata: &[Metadata],
) -> Option<RandomnessAnnotation> {
    get_metadata(metadata).and_then(|metadata| {
        metadata
            .fun_attributes
            .get(entry_func.function().as_str())
            .map(|attrs| {
                attrs
                    .iter()
                    .filter_map(KnownAttribute::try_as_randomness_annotation)
                    .next()
            })
            .unwrap_or(None)
    })
}
```

**File:** types/src/vm/module_metadata.rs (L288-300)
```rust
    code: &impl CompiledCodeMetadata,
) -> Option<RuntimeModuleMetadataV1> {
    if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY_V1) {
        let mut metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value).ok();
        // Clear out metadata for v5, since it shouldn't have existed in the first place and isn't
        // being used. Note, this should have been gated in the verify module metadata.
        if code.version() == 5 {
            if let Some(metadata) = metadata.as_mut() {
                metadata.struct_attributes.clear();
                metadata.fun_attributes.clear();
            }
        }
        metadata
```

**File:** types/src/vm/module_metadata.rs (L441-456)
```rust
pub fn verify_module_metadata_for_module_publishing(
    module: &CompiledModule,
    features: &Features,
) -> Result<(), MetaDataValidationError> {
    if features.is_enabled(FeatureFlag::SAFER_METADATA) {
        check_module_complexity(module)?;
    }

    if features.are_resource_groups_enabled() {
        check_metadata_format(module)?;
    }
    let metadata = if let Some(metadata) = get_metadata_from_compiled_code(module) {
        metadata
    } else {
        return Ok(());
    };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L983-990)
```rust
            if function.is_friend_or_private() {
                let maybe_randomness_annotation = get_randomness_annotation_for_entry_function(
                    entry_fn,
                    &function.owner_as_module()?.metadata,
                );
                if maybe_randomness_annotation.is_some() {
                    session.mark_unbiasable();
                }
```

**File:** aptos-move/framework/src/natives/randomness.rs (L79-97)
```rust
pub fn fetch_and_increment_txn_counter(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    if context.gas_feature_version() >= RELEASE_V1_23 {
        context.charge(RANDOMNESS_FETCH_AND_INC_COUNTER)?;
    }

    let ctx = context.extensions_mut().get_mut::<RandomnessContext>();
    if !ctx.is_unbiasable() {
        return Err(SafeNativeError::Abort {
            abort_code: E_API_USE_SUSCEPTIBLE_TO_TEST_AND_ABORT,
        });
    }

    let ret = ctx.txn_local_state.to_vec();
    ctx.increment();
    Ok(smallvec![Value::vector_u8(ret)])
```

**File:** types/src/on_chain_config/aptos_features.rs (L485-499)
```rust
    pub fn get_max_binary_format_version(&self) -> u32 {
        if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10) {
            file_format_common::VERSION_10
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V9) {
            file_format_common::VERSION_9
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V8) {
            file_format_common::VERSION_8
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V7) {
            file_format_common::VERSION_7
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V6) {
            file_format_common::VERSION_6
        } else {
            file_format_common::VERSION_5
        }
    }
```
