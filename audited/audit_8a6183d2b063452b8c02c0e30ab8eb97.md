# Audit Report

## Title
Consensus Failure Due to Inconsistent max_aa_gas Parameter During Rolling Validator Upgrades

## Summary
A version gating mismatch in the `max_aa_gas` parameter causes consensus divergence during rolling validator upgrades. Validators running updated node software with gas feature version < 30 initialize `max_aa_gas` to 0, causing all Account Abstraction transactions to fail, while validators on older software without this logic process the same transactions successfully, breaking consensus determinism.

## Finding Description

The vulnerability stems from a critical mismatch between parameter **definition** (which has version gating) and parameter **usage** (which does not).

The `max_aa_gas` parameter is defined with version gating tied to RELEASE_V1_26 (gas feature version 30): [1](#0-0) 

The version gating macro implementation skips loading parameters when `feature_version` doesn't match the specified range. If the key extraction returns `None`, the parameter is not loaded from the on-chain gas schedule and retains its zero-initialized value: [2](#0-1) 

However, the code that **uses** `max_aa_gas` performs NO version gating - it only checks if account abstraction feature flags are enabled: [3](#0-2) 

The same pattern appears in transaction validation: [4](#0-3) 

When `max_aa_gas = 0`, the expression `min(0, txn.max_gas_amount())` evaluates to 0, causing the gas meter to start with zero balance. Any gas consumption during prologue validation triggers an OUT_OF_GAS error, which the `unwrap_or_discard!` macro catches and converts to a discarded transaction: [5](#0-4) 

**Consensus Divergence Scenario:**

The Account Abstraction feature is enabled by default in the feature set: [6](#0-5) 

The `gas_feature_version` comes from the on-chain `GasScheduleV2` configuration, which is controlled by governance separately from node software upgrades: [7](#0-6) 

Rolling validator upgrades are explicitly supported and tested in the codebase, with validators upgraded in batches while maintaining network operation: [8](#0-7) 

During a rolling upgrade where:
1. On-chain `gas_feature_version` < 30 (governance hasn't upgraded yet)
2. Some validators run new software (with max_aa_gas logic)
3. Some validators run old software (without max_aa_gas logic)
4. A user submits an AA transaction

**Result:**
- **New validators**: Load `max_aa_gas = 0`, set `initial_balance = 0`, transaction fails with OUT_OF_GAS
- **Old validators**: No max_aa_gas logic, use full `txn.max_gas_amount()`, transaction executes successfully
- **Outcome**: Different execution results → consensus divergence → potential network partition

## Impact Explanation

This is a **Critical** severity vulnerability per Aptos bug bounty criteria because it directly causes **Consensus/Safety violations** (Category 2: "Different validators commit different blocks").

During rolling upgrades, the network will experience:
- **Consensus failures**: Validators produce different state roots for identical blocks containing AA transactions
- **Network partition risk**: Chain may fork as validators disagree on block validity
- **Transaction non-determinism**: Same transaction yields different results on different validators
- **Potential hardfork requirement**: Recovery may require coordinated manual intervention

The vulnerability affects all AA transactions during the upgrade window, which could represent significant network traffic depending on AA adoption rates.

## Likelihood Explanation

**High likelihood** of occurrence:

1. **Default enabled feature**: Account Abstraction is in the default feature set, making the vulnerable code path active without configuration
2. **Standard operational practice**: Rolling upgrades are the documented standard for validator updates to maintain availability
3. **Temporal coordination gap**: Node software releases and governance gas schedule updates occur at different times, creating a vulnerable window
4. **No runtime protection**: The code lacks version checks to prevent using uninitialized `max_aa_gas`
5. **Natural trigger**: Any user submitting an AA transaction during the window triggers the issue - no attacker needed

The vulnerability triggers automatically when:
- Validators run mixed software versions (standard during rolling upgrades)
- `gas_feature_version < 30` (before governance approval)
- AA feature flags enabled (default state)
- Any AA transaction submitted (normal user activity)

## Recommendation

Add version gating to the `max_aa_gas` usage to match the parameter definition:

```rust
let initial_balance = if (self.features().is_account_abstraction_enabled()
    || self.features().is_derivable_account_abstraction_enabled())
    && self.gas_feature_version() >= gas_feature_versions::RELEASE_V1_26
{
    vm_params.txn.max_aa_gas.min(txn.max_gas_amount().into())
} else {
    txn.max_gas_amount().into()
};
```

Apply the same fix to the validation path at lines 3263-3269.

Alternatively, ensure `max_aa_gas` has a non-zero default value in the `zeros()` implementation, or require on-chain gas schedule updates to complete before node software deployment.

## Proof of Concept

A complete PoC would require:
1. Set up a testnet with validators running mixed software versions
2. Ensure on-chain `gas_feature_version < 30`
3. Enable Account Abstraction features (default)
4. Submit an AA transaction with custom authentication
5. Observe different validators producing different execution results (some Discard, some Keep)
6. Verify different state roots produced for the same block

The test should extend the existing `SimpleValidatorUpgrade` compatibility test to include AA transaction submission during the upgrade window with gas feature version validation.

## Notes

This vulnerability represents a fundamental coordination issue between:
- Code-level feature gates (controlled by node software version)
- On-chain parameter availability (controlled by governance gas schedule updates)

The root cause is that newly introduced gas parameters can be referenced by code before they exist in the on-chain gas schedule, and the version gating mechanism at the macro level doesn't propagate to runtime usage checks. This pattern may affect other version-gated parameters introduced in future releases if similar mismatches exist between definition and usage.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L275-279)
```rust
        [
            max_aa_gas: Gas,
            { RELEASE_V1_26.. => "max_aa_gas" },
            60,
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L34-45)
```rust
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L176-189)
```rust
macro_rules! unwrap_or_discard {
    ($res:expr) => {
        match $res {
            Ok(s) => s,
            Err(e) => {
                // covers both VMStatus itself and VMError which can convert to VMStatus
                let s: VMStatus = e.into();

                let o = discarded_output(s.status_code());
                return (s, o);
            },
        }
    };
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2149-2155)
```rust
        let initial_balance = if self.features().is_account_abstraction_enabled()
            || self.features().is_derivable_account_abstraction_enabled()
        {
            vm_params.txn.max_aa_gas.min(txn.max_gas_amount().into())
        } else {
            txn.max_gas_amount().into()
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3263-3269)
```rust
        let initial_balance = if self.features().is_account_abstraction_enabled()
            || self.features().is_derivable_account_abstraction_enabled()
        {
            vm_params.txn.max_aa_gas.min(txn_data.max_gas_amount())
        } else {
            txn_data.max_gas_amount()
        };
```

**File:** types/src/on_chain_config/aptos_features.rs (L254-254)
```rust
            FeatureFlag::ACCOUNT_ABSTRACTION,
```

**File:** types/src/on_chain_config/gas_schedule.rs (L14-17)
```rust
pub struct GasScheduleV2 {
    pub feature_version: u64,
    pub entries: Vec<(String, u64)>,
}
```

**File:** testsuite/testcases/src/compatibility_test.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```
