# Audit Report

## Title
Panic-Induced Resource Exhaustion via RwLock Poisoning and Connection Counter Leaks in API Server

## Summary
The `panic_handler` in the Aptos API server does not properly clean up resources when panics occur. The use of `.unwrap()` on RwLock operations creates cascading failures when locks become poisoned, and atomic connection counters are permanently leaked when panics occur during request handling. This allows attackers to repeatedly trigger panics through public API endpoints, causing progressive performance degradation that affects validator API responsiveness.

## Finding Description
The vulnerability manifests through two interconnected resource leak mechanisms:

**1. RwLock Poisoning and Cascading Failures:**

The Context struct maintains three shared caches protected by RwLocks: [1](#0-0) 

These locks are accessed using `.unwrap()` throughout the codebase: [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) 

When a panic occurs while holding a write lock, the lock becomes poisoned. Subsequent calls to `.unwrap()` on these poisoned locks trigger new panics, creating a cascading failure where one initial panic causes all future API requests to panic.

**Initial Panic Trigger Point:** [8](#0-7) 

This code can panic when `prices_and_used` is empty but `is_full_block` is true (possible with blocks containing only system transactions but indicating limit_reached). This panic occurs during gas estimation while holding the write lock on `gas_estimation_cache`.

**2. Connection Counter Leak:**

The `/transactions/by_hash/wait` endpoint increments an atomic counter without proper cleanup on panic: [9](#0-8) 

The decrement occurs later: [10](#0-9) 

If a panic occurs between these two points, the counter is permanently incremented, eventually exhausting the connection limit and forcing the API into degraded short-poll-only mode.

**Panic Handler Does Not Clean Up:** [11](#0-10) 

The panic_handler only logs and returns an error responseâ€”it performs no resource cleanup. While Rust's panic unwinding does call Drop on stack values (releasing the lock guard), it cannot:
- Prevent lock poisoning
- Decrement atomic counters that should have been decremented in later code
- Prevent cascading panics from `.unwrap()` on poisoned locks

**Integration with CatchPanic Middleware:** [12](#0-11) 

The CatchPanic middleware catches panics and calls panic_handler, but does not perform any resource cleanup beyond standard Rust unwinding.

## Impact Explanation
This vulnerability achieves **HIGH severity** per Aptos bug bounty criteria due to:

1. **Validator Node Slowdowns**: Progressive API performance degradation affects validator operations that depend on API functionality
2. **API Crashes**: After lock poisoning, all endpoints using gas caches return errors continuously
3. **Resource Exhaustion**: Connection counter leaks permanently reduce API capacity

The impact is cumulative:
- First panic: Poisons one or more RwLocks
- Subsequent calls: Trigger cascading panics on any endpoint using poisoned caches
- Connection leaks: Progressively exhaust `wait_for_hash_active_connections` counter
- End state: API requires process restart to restore functionality

This affects core API endpoints including `/estimate_gas_price`, `/transactions`, and view function calls that all use the shared gas caches.

## Likelihood Explanation
**Likelihood: MEDIUM to HIGH**

The vulnerability is likely to occur because:

1. **Multiple Trigger Points**: Any panic in gas estimation code paths while holding locks
2. **Edge Cases Exist**: Blocks with only system transactions but `limit_reached()` true can trigger the `.min().unwrap()` panic
3. **No Authentication Required**: Public API endpoints accessible to any attacker
4. **Once Triggered, Self-Sustaining**: After initial lock poisoning, every subsequent call to affected endpoints panics
5. **Natural Occurrence Possible**: Edge case blocks can occur during normal operation, not requiring deliberate attack

An attacker can:
- Repeatedly call `/estimate_gas_price` to attempt triggering the edge case
- Once any panic occurs, spam any endpoint using gas caches to accelerate resource exhaustion
- Cause `/transactions/by_hash/wait` panics to leak connection counters
- Force API into degraded state requiring restart

## Recommendation
Implement proper error handling for RwLock operations and ensure atomic operations have cleanup guarantees:

**1. Replace `.unwrap()` with proper error handling:**

```rust
// In api/src/context.rs - Replace all lock acquisitions
let cache = self.gas_estimation_cache.read()
    .map_err(|_| E::internal_with_code(
        "Cache lock poisoned",
        AptosErrorCode::InternalError,
        ledger_info
    ))?;

let mut cache = self.gas_estimation_cache.write()
    .map_err(|_| E::internal_with_code(
        "Cache lock poisoned", 
        AptosErrorCode::InternalError,
        ledger_info
    ))?;
```

**2. Use RAII guards for atomic counters:**

```rust
// In api/src/transactions.rs - Create guard struct
struct ConnectionGuard<'a> {
    counter: &'a AtomicUsize,
}

impl<'a> ConnectionGuard<'a> {
    fn new(counter: &'a AtomicUsize) -> Option<Self> {
        if counter.fetch_add(1, Ordering::Relaxed) >= MAX_CONNECTIONS {
            counter.fetch_sub(1, Ordering::Relaxed);
            None
        } else {
            Some(ConnectionGuard { counter })
        }
    }
}

impl Drop for ConnectionGuard<'_> {
    fn drop(&mut self) {
        self.counter.fetch_sub(1, Ordering::Relaxed);
    }
}

// Then use it:
let _guard = ConnectionGuard::new(&self.context.wait_for_hash_active_connections)
    .ok_or_else(|| /* return short poll response */)?;
// Guard automatically decrements on panic or normal return
```

**3. Fix the `.min().unwrap()` panic:**

```rust
// In api/src/context.rs line 1270-1275
if is_full_block {
    Some(
        self.next_bucket(
            prices_and_used
                .iter()
                .map(|(price, _)| *price)
                .min()
                .unwrap_or(min_gas_unit_price), // Use unwrap_or instead of unwrap
        ),
    )
} else {
    None
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod panic_resource_leak_test {
    use super::*;
    use std::sync::{Arc, RwLock, atomic::{AtomicUsize, Ordering}};
    use std::panic;
    
    #[test]
    fn test_rwlock_poisoning_cascading_failure() {
        let cache = Arc::new(RwLock::new(0u64));
        let cache_clone = cache.clone();
        
        // Simulate first panic while holding write lock
        let result = panic::catch_unwind(|| {
            let mut guard = cache_clone.write().unwrap();
            *guard = 42;
            panic!("Simulated panic during cache update");
        });
        assert!(result.is_err());
        
        // Verify lock is poisoned
        assert!(cache.read().is_err());
        assert!(cache.write().is_err());
        
        // Demonstrate cascading failure - all subsequent .unwrap() calls panic
        let result = panic::catch_unwind(|| {
            let _guard = cache.read().unwrap(); // This will panic
        });
        assert!(result.is_err(), "Second read panics due to poisoned lock");
    }
    
    #[test]
    fn test_connection_counter_leak_on_panic() {
        let counter = Arc::new(AtomicUsize::new(0));
        let counter_clone = counter.clone();
        
        // Simulate panic after incrementing counter
        let result = panic::catch_unwind(|| {
            counter_clone.fetch_add(1, Ordering::Relaxed);
            panic!("Simulated panic during request");
            // fetch_sub never reached
        });
        assert!(result.is_err());
        
        // Counter is permanently incremented
        assert_eq!(counter.load(Ordering::Relaxed), 1);
        
        // After many panics, counter grows without bound
        for _ in 0..10 {
            let _ = panic::catch_unwind(|| {
                counter.fetch_add(1, Ordering::Relaxed);
                panic!("Another panic");
            });
        }
        assert_eq!(counter.load(Ordering::Relaxed), 11);
    }
}
```

To reproduce in production environment:
1. Deploy Aptos node with API server
2. Trigger edge case by calling `/estimate_gas_price` during blocks with only system transactions
3. Alternatively, inject panic via failpoint in gas estimation code path
4. Observe that subsequent calls to `/estimate_gas_price` and other endpoints fail
5. Monitor `wait_for_hash_active_connections` metric showing progressive leak
6. API becomes degraded and requires process restart

## Notes

This vulnerability specifically addresses the security question about panic_handler resource cleanup. The core issues are:

1. **RwLock `.unwrap()` usage creates cascading failures** - One panic poisons locks, causing all future operations to panic
2. **Atomic counters leak on panic** - RAII not used for cleanup guarantees
3. **panic_handler is passive** - Only logs and returns response, no active cleanup

The fixes require defensive programming: treating lock poisoning as a recoverable error and using RAII guards for all resources that need cleanup. This prevents a single panic from cascading into total API failure and ensures resources are properly released even during unwinding.

### Citations

**File:** api/src/context.rs (L78-80)
```rust
    gas_schedule_cache: Arc<RwLock<GasScheduleCache>>,
    gas_estimation_cache: Arc<RwLock<GasEstimationCache>>,
    gas_limit_cache: Arc<RwLock<GasLimitCache>>,
```

**File:** api/src/context.rs (L1270-1275)
```rust
                            prices_and_used
                                .iter()
                                .map(|(price, _)| *price)
                                .min()
                                .unwrap(),
                        ),
```

**File:** api/src/context.rs (L1306-1306)
```rust
        let cache = self.gas_estimation_cache.read().unwrap();
```

**File:** api/src/context.rs (L1313-1313)
```rust
        let mut cache = self.gas_estimation_cache.write().unwrap();
```

**File:** api/src/context.rs (L1468-1468)
```rust
            let cache = self.gas_schedule_cache.read().unwrap();
```

**File:** api/src/context.rs (L1483-1483)
```rust
            let mut cache = self.gas_schedule_cache.write().unwrap();
```

**File:** api/src/context.rs (L1548-1548)
```rust
            let cache = self.gas_limit_cache.read().unwrap();
```

**File:** api/src/context.rs (L1558-1558)
```rust
            let mut cache = self.gas_limit_cache.write().unwrap();
```

**File:** api/src/transactions.rs (L240-252)
```rust
        if self
            .context
            .wait_for_hash_active_connections
            .fetch_add(1, std::sync::atomic::Ordering::Relaxed)
            >= self
                .context
                .node_config
                .api
                .wait_by_hash_max_active_connections
        {
            self.context
                .wait_for_hash_active_connections
                .fetch_sub(1, std::sync::atomic::Ordering::Relaxed);
```

**File:** api/src/transactions.rs (L274-276)
```rust
        self.context
            .wait_for_hash_active_connections
            .fetch_sub(1, std::sync::atomic::Ordering::Relaxed);
```

**File:** api/src/error_converter.rs (L49-52)
```rust
pub fn panic_handler(err: Box<dyn Any + Send>) -> Response {
    error!("Panic captured: {:?}", err);
    build_panic_response("internal error".into())
}
```

**File:** api/src/runtime.rs (L256-256)
```rust
            .with(CatchPanic::new().with_handler(panic_handler))
```
