# Audit Report

## Title
Integer Truncation in Indexer GRPC Cache on 32-bit Systems Leading to Data Corruption

## Summary
The indexer GRPC data service implements a circular buffer cache that casts u64 version numbers to usize for array indexing. On 32-bit systems, when blockchain version numbers exceed u32::MAX (4,294,967,295), the cast truncates the value before the modulo operation, causing incorrect slot mapping and cache data corruption.

## Finding Description
The `DataManager` struct in the indexer GRPC service maintains a circular buffer cache of transactions indexed by version number. The implementation casts u64 version numbers directly to usize before performing modulo arithmetic to map versions to array slots: [1](#0-0) [2](#0-1) [3](#0-2) 

On 32-bit systems where `usize` is 32 bits:
- When `version` (u64) exceeds u32::MAX (4,294,967,295), the cast `version as usize` truncates the high 32 bits
- This truncation occurs **before** the modulo operation
- Different version numbers incorrectly map to the same slot
- Example: version 4,294,967,296 (u32::MAX + 1) becomes 0 after truncation

This breaks the **State Consistency** invariant for the indexer service, as the circular buffer will serve incorrect cached transaction data to clients once version numbers exceed the 32-bit threshold.

## Impact Explanation
This issue qualifies as **Medium Severity** under the "State inconsistencies requiring intervention" category, but with significant caveats:

**Actual Impact:**
- Cache data corruption in the indexer GRPC service
- Incorrect transaction data served to indexer clients
- Potential indexer state divergence from actual blockchain state

**Important Limitations:**
- Does NOT affect core consensus, validator operations, or blockchain state
- Does NOT cause loss of funds or consensus safety violations
- Only affects auxiliary indexer infrastructure, not the blockchain itself
- Requires manual intervention to fix corrupted indexer cache state

## Likelihood Explanation
**Likelihood: Very Low**

Required conditions (ALL must be met):
1. **32-bit system deployment**: Production Aptos nodes almost certainly run on 64-bit systems. 32-bit platforms are not standard for blockchain infrastructure.
2. **Version > 4.2 billion**: The Aptos mainnet would need to process over 4.2 billion transactions. Current networks are nowhere near this threshold.
3. **Running affected indexer service**: Only nodes running the specific indexer GRPC data service v2 are affected.

The vulnerability cannot be actively exploited by an attackerâ€”it would manifest automatically once both platform and version conditions are met. However, given modern deployment practices (64-bit systems) and current network state (low transaction counts), this scenario is highly unlikely in practice.

## Recommendation
Perform proper overflow checking and use u64 arithmetic throughout:

```rust
pub(super) fn get_data(&self, version: u64) -> &Option<Box<Transaction>> {
    let slot_index = (version % self.num_slots as u64) as usize;
    &self.data[slot_index]
}

pub(super) fn update_data(&mut self, start_version: u64, transactions: Vec<Transaction>) {
    // ... existing validation logic ...
    
    for (i, transaction) in transactions
        .into_iter()
        .enumerate()
        .skip(num_to_skip as usize)
    {
        let version = start_version + i as u64;
        let slot_index = (version % self.num_slots as u64) as usize;
        
        if let Some(transaction) = self.data[slot_index].take() {
            size_decreased += transaction.encoded_len();
        }
        size_increased += transaction.encoded_len();
        self.data[slot_index] = Some(Box::new(transaction));
    }
    // ... rest of function ...
}
```

The key fix is: perform modulo on u64 values BEFORE casting to usize, ensuring the result is always within bounds regardless of platform.

Additionally, add a compile-time assertion or runtime check if 32-bit support is intended:
```rust
#[cfg(target_pointer_width = "32")]
compile_error!("Aptos indexer requires 64-bit architecture");
```

## Proof of Concept
```rust
// Reproduction test demonstrating the truncation issue
#[cfg(test)]
mod tests {
    #[test]
    fn test_version_truncation_on_32bit() {
        // Simulate the bug: on 32-bit systems
        let version: u64 = 4_294_967_296; // u32::MAX + 1
        let num_slots: usize = 1000;
        
        // Buggy implementation (current code)
        let buggy_index = version as usize % num_slots;
        
        // Correct implementation (proposed fix)
        let correct_index = (version % num_slots as u64) as usize;
        
        #[cfg(target_pointer_width = "32")]
        {
            // On 32-bit: buggy_index would be 0 (incorrect)
            assert_eq!(buggy_index, 0); 
            // correct_index would be 296 (correct)
            assert_eq!(correct_index, 296);
            assert_ne!(buggy_index, correct_index);
        }
        
        #[cfg(target_pointer_width = "64")]
        {
            // On 64-bit: both produce same result
            assert_eq!(buggy_index, correct_index);
        }
    }
}
```

## Notes
While this represents a genuine correctness issue with u64 to usize casting on 32-bit systems, the practical security impact is minimal given:
1. Modern blockchain nodes use 64-bit architectures
2. Current transaction counts are well below the u32::MAX threshold
3. The issue affects indexer infrastructure, not core consensus or fund security

However, defensive programming suggests implementing the fix to ensure long-term correctness and prevent potential issues if 32-bit systems were ever deployed or if the codebase is reused in different contexts.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L40-42)
```rust
    pub(super) fn get_data(&self, version: u64) -> &Option<Box<Transaction>> {
        &self.data[version as usize % self.num_slots]
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L80-86)
```rust
            let version = start_version + i as u64;
            let slot_index = version as usize % self.num_slots;
            if let Some(transaction) = self.data[slot_index].take() {
                size_decreased += transaction.encoded_len();
            }
            size_increased += transaction.encoded_len();
            self.data[version as usize % self.num_slots] = Some(Box::new(transaction));
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L110-110)
```rust
                    self.data[self.start_version as usize % self.num_slots].take()
```
