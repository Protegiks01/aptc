# Audit Report

## Title
Time-of-Check to Time-of-Use Race Condition in Block Pruning Boundary Validation

## Summary
The `get_block_by_version()` function contains a TOCTOU race condition where the pruning boundary can advance between the API-level check and database-level access, causing requests for valid versions to receive incorrect "pruned" or "not found" errors.

## Finding Description

The vulnerability exists in the block retrieval flow where pruning boundaries are checked at two different points with different data sources:

1. **API-Level Check** [1](#0-0) 
   - Uses `latest_ledger_info.oldest_ledger_version` which is a snapshot from `get_first_viable_block()`
   - This snapshot uses `get_min_viable_version()` [2](#0-1) 

2. **Database-Level Check** [3](#0-2) 
   - Calls `error_if_ledger_pruned()` which reads the CURRENT `min_readable_version` [4](#0-3) 

The race occurs because `min_readable_version` is updated IMMEDIATELY when new blocks are committed, even before actual pruning happens: [5](#0-4) 

This happens during `post_commit()` after each block: [6](#0-5) 

**Attack Timeline:**
1. Time T1: API retrieves LedgerInfo with `oldest_ledger_version = 200` (when `latest_version = 1000`, `prune_window = 900`)
2. Time T2: User requests version 250, passes API check (250 >= 200)
3. Time T3: New blocks committed, `latest_version = 1200`, `min_readable_version` updated to 300
4. Time T4: Database check fails (250 < 300), returns error despite version being valid at request time

The error is then mapped to "block not found": [7](#0-6) 

## Impact Explanation

**Severity: Medium** (but below security vulnerability threshold)

This issue causes API reliability problems but does NOT meet the security vulnerability criteria because:

- **No Consensus Impact**: Does not affect blockchain consensus or state integrity
- **No Data Loss**: All data remains intact in the database  
- **No Authorization Bypass**: Does not enable unauthorized access
- **Transient Errors Only**: Clients receive errors but can retry successfully
- **No Financial Impact**: Does not affect funds, staking, or governance

The issue breaks the **State Consistency** invariant by creating inconsistency between the API's advertised pruning boundary and the actual database enforcement, but this is a quality/reliability issue rather than a security vulnerability.

## Likelihood Explanation

**High likelihood** in production environments:
- Occurs whenever API requests coincide with block commits
- Window of vulnerability exists during every new block (frequent)
- No attacker action required—happens during normal operation
- Multiple concurrent API clients increase probability

However, the impact is limited to transient API errors without security consequences.

## Recommendation

**Solution 1: Use Consistent Pruning Boundary**

Pass the snapshot `min_readable_version` from LedgerInfo through to the database layer instead of reading it again:

```rust
// In context.rs
pub fn get_block_by_version<E: StdApiError>(
    &self,
    version: u64,
    latest_ledger_info: &LedgerInfo,
    with_transactions: bool,
) -> Result<BcsBlock, E> {
    if version < latest_ledger_info.oldest_ledger_version.0 {
        return Err(version_pruned(version, latest_ledger_info));
    }
    
    let min_readable_at_snapshot = latest_ledger_info.oldest_ledger_version.0;
    let (first_version, last_version, new_block_event) = self
        .db
        .get_block_info_by_version_with_min_version(version, min_readable_at_snapshot)
        .map_err(|_| block_not_found_by_version(version, latest_ledger_info))?;
    // ...
}
```

**Solution 2: Only Update min_readable_version After Actual Pruning**

Modify pruner to update `min_readable_version` only after pruning completes, not when setting targets: [5](#0-4) 

Remove the `min_readable_version.store()` from `set_pruner_target_db_version()` and only update it after the pruner worker confirms completion.

## Proof of Concept

```rust
// Rust test demonstrating the race condition
#[tokio::test]
async fn test_pruning_race_condition() {
    let (mut swarm, mut cli, _faucet) = SwarmBuilder::new_local(1).build_with_cli(0).await;
    
    // Let chain advance
    swarm.wait_for_all_nodes_to_catchup(Duration::from_secs(10)).await.unwrap();
    
    // Get current ledger info
    let ledger_info = cli.get_ledger_info().await.unwrap();
    let oldest_version = ledger_info.oldest_ledger_version;
    
    // Calculate a version that should be valid based on current snapshot
    let test_version = oldest_version + 100;
    
    // Trigger rapid block commits to advance pruning boundary
    for _ in 0..50 {
        cli.create_account().await.unwrap();
    }
    
    // Request the previously-valid version
    // Expected: Success (version was valid when we checked)
    // Actual: May return "block not found" due to min_readable_version advancing
    let result = cli.get_block_by_version(test_version).await;
    
    // This assertion may fail intermittently due to the race condition
    assert!(result.is_ok(), "Version {test_version} should be accessible but got error: {:?}", result.err());
}
```

---

**Note:** While this is a legitimate race condition affecting API reliability, it does NOT constitute a security vulnerability per the bug bounty criteria as it causes no security harm—only transient errors that clients can handle through retries.

### Citations

**File:** api/src/context.rs (L660-661)
```rust
        if version < latest_ledger_info.oldest_ledger_version.0 {
            return Err(version_pruned(version, latest_ledger_info));
```

**File:** api/src/context.rs (L666-669)
```rust
        let (first_version, last_version, new_block_event) = self
            .db
            .get_block_info_by_version(version)
            .map_err(|_| block_not_found_by_version(version, latest_ledger_info))?;
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L52-63)
```rust
    fn get_min_viable_version(&self) -> Version {
        let min_version = self.get_min_readable_version();
        if self.is_pruner_enabled() {
            let adjusted_window = self
                .prune_window
                .saturating_sub(self.user_pruning_window_offset);
            let adjusted_cutoff = self.latest_version.lock().saturating_sub(adjusted_window);
            std::cmp::max(min_version, adjusted_cutoff)
        } else {
            min_version
        }
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L162-176)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L784-784)
```rust
            self.error_if_ledger_pruned("NewBlockEvent", version)?;
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L261-271)
```rust
    pub(super) fn error_if_ledger_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.ledger_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L628-629)
```rust
            self.ledger_pruner
                .maybe_set_pruner_target_db_version(version);
```
