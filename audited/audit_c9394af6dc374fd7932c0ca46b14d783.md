# Audit Report

## Title
ProofOfStore Author Field Manipulation Enabling Byzantine Proof Attribution Attacks

## Summary
Malicious validators can create `ProofOfStore` objects with falsified `author` fields in `BatchInfo`, causing these proofs to be incorrectly attributed to other validators. The `ProofOfStore::verify()` method validates multi-signatures but does not verify that the `BatchInfo.author` field matches any of the actual signers, enabling validators to hide their Byzantine proof creation activity and bypass author exclusion mechanisms.

## Finding Description

The vulnerability exists in the proof verification flow where `ProofOfStore` objects are validated and inserted into the batch proof queue.

**Critical Missing Validation:**

The `ProofOfStore::verify()` method only validates that the multi-signature is cryptographically correct over the `BatchInfo` structure, but does not verify that the `author` field within `BatchInfo` corresponds to any of the validators who actually signed the proof. [1](#0-0) 

The multi-signature verification extracts signers from the signature bitvec but never checks these against the `BatchInfo.author` field: [2](#0-1) 

**Exploitation Path:**

1. Malicious Validator M creates a `BatchInfo` with `author` field set to Victim Validator V (or any other validator)
2. M collects quorum signatures from validators (including M's own signature) - this is standard proof creation
3. M creates a `ProofOfStore` with the fake-author `BatchInfo` and valid multi-signature
4. M broadcasts `ProofOfStoreMsg` over the network

5. At receiving nodes, the proof passes verification because `ProofOfStore::verify()` only checks signature validity, not author authenticity

6. The proof is inserted into the batch proof queue where the fake author is used for attribution: [3](#0-2) 

7. The system incorrectly attributes the proof based on the fake author field, incrementing local counters if the fake author matches the node's peer ID: [4](#0-3) 

8. The `NUM_LOCAL_PROOFS_LEFT_ON_UPDATE` metric is updated with the misattributed proof count: [5](#0-4) 

**Security Guarantees Broken:**

1. **Proof Attribution Integrity**: The system assumes `BatchInfo.author` is trustworthy and reflects the actual proof creator
2. **Consensus Fairness**: The per-author queuing mechanism (`author_to_batches`) can be manipulated, violating fairness assumptions
3. **Exclusion Mechanism Bypass**: The `exclude_authors` filter can be circumvented by using fake author identities: [6](#0-5) 
4. **Byzantine Detection**: Monitoring systems relying on `NUM_LOCAL_PROOFS_LEFT_ON_UPDATE` and related metrics cannot accurately track validator behavior

## Impact Explanation

**HIGH SEVERITY** - This vulnerability constitutes a significant protocol violation per the Aptos bug bounty criteria:

1. **Exclusion Mechanism Bypass**: Validators marked for exclusion due to poor performance or Byzantine behavior can create proofs attributed to non-excluded validators, bypassing the `exclude_authors` filter that is designed to improve proposal success rates and maintain network health.

2. **Consensus Fairness Violation**: The system uses per-author queues with round-robin selection to ensure fairness between validators. By manipulating author attribution, malicious validators can gain unfair advantage in having their batches included in proposals.

3. **Byzantine Behavior Hiding**: The `NUM_LOCAL_PROOFS_LEFT_ON_UPDATE` and `NUM_LOCAL_TXNS_LEFT_ON_UPDATE` metrics are critical for monitoring validator behavior. Malicious validators can hide their proof creation activity by attributing proofs to other validators, preventing detection of Byzantine patterns.

4. **Operational Monitoring Corruption**: Node operators rely on local vs. remote proof metrics for capacity planning and anomaly detection. Falsified attribution renders these metrics unreliable, potentially masking attacks or operational issues.

While this does not directly cause loss of funds or consensus safety violations (the proofs themselves are still valid with quorum signatures), it enables significant protocol manipulation and defeats Byzantine detection mechanisms.

## Likelihood Explanation

**LIKELIHOOD: HIGH**

- **Attacker Requirements**: Only requires being a validator in the active set - no special privileges needed beyond normal validator operations
- **Technical Complexity**: LOW - Simply requires setting a different `author` field in `BatchInfo` during batch creation
- **Detection Difficulty**: HIGH - The attack is invisible at the cryptographic layer since multi-signatures remain valid; only statistical analysis of proof attribution patterns might detect anomalies
- **Execution Feasibility**: The attack can be executed during normal proof creation workflow with minimal code modifications

## Recommendation

Add author validation to ensure the `BatchInfo.author` field matches one of the actual proof signers. This can be implemented in multiple locations:

**Option 1 - Validation in ProofOfStore::verify():**

```rust
pub fn verify(&self, validator: &ValidatorVerifier, cache: &ProofCache) -> anyhow::Result<()> {
    let batch_info_ext: BatchInfoExt = self.info.clone().into();
    if let Some(signature) = cache.get(&batch_info_ext) {
        if signature == self.multi_signature {
            return Ok(());
        }
    }
    
    // Verify multi-signature
    validator
        .verify_multi_signatures(&self.info, &self.multi_signature)
        .context(format!(
            "Failed to verify ProofOfStore for batch: {:?}",
            self.info
        ))?;
    
    // NEW: Verify author is one of the signers
    let signers = self.multi_signature.get_signers_addresses(validator.get_ordered_account_addresses());
    ensure!(
        signers.contains(&self.info.author()),
        "BatchInfo author {} is not among the proof signers",
        self.info.author()
    );
    
    cache.insert(batch_info_ext, self.multi_signature.clone());
    Ok(())
}
```

**Option 2 - Validation in BatchProofQueue::insert_proof():**

```rust
pub(crate) fn insert_proof(&mut self, proof: ProofOfStore<BatchInfoExt>) {
    // ... existing expiration and duplicate checks ...
    
    let author = proof.author();
    
    // NEW: Verify author is one of the signers
    let signers = proof.multi_signature().get_signers_addresses(ordered_authors);
    if !signers.contains(&author) {
        counters::inc_rejected_pos_count("invalid_author");
        warn!(
            "Rejected proof with author {} not among signers",
            author
        );
        return;
    }
    
    // ... rest of insertion logic ...
}
```

**Recommended Approach**: Implement validation in `ProofOfStore::verify()` (Option 1) as this ensures the invariant is checked at the earliest point and prevents invalid proofs from propagating through the system.

## Proof of Concept

```rust
#[cfg(test)]
mod proof_author_validation_test {
    use super::*;
    use aptos_consensus_types::proof_of_store::{BatchInfo, BatchInfoExt, ProofOfStore};
    use aptos_crypto::HashValue;
    use aptos_types::{aggregate_signature::AggregateSignature, validator_signer::ValidatorSigner};
    
    #[test]
    fn test_proof_with_fake_author_accepted() {
        // Setup: Create validator signers
        let validator1 = ValidatorSigner::random([0u8; 32]);
        let validator2 = ValidatorSigner::random([1u8; 32]);
        let victim = ValidatorSigner::random([2u8; 32]);
        
        // Create BatchInfo with FAKE author (victim) but will be signed by validator1 & validator2
        let fake_author_batch_info = BatchInfoExt::new_v1(
            victim.author(), // FAKE AUTHOR
            BatchId::new(1),
            1, // epoch
            1000000, // expiration
            HashValue::random(),
            10, // num_txns
            1000, // num_bytes
            0, // gas_bucket_start
        );
        
        // Sign with validator1 and validator2 (NOT the victim)
        let sig1 = validator1.sign(&fake_author_batch_info).unwrap();
        let sig2 = validator2.sign(&fake_author_batch_info).unwrap();
        
        // Create aggregate signature
        let mut aggregator = AggregateSignature::empty();
        aggregator.add_signature(0, sig1); // validator1 index
        aggregator.add_signature(1, sig2); // validator2 index
        
        // Create ProofOfStore with fake author
        let proof = ProofOfStore::new(fake_author_batch_info.clone(), aggregator);
        
        // Setup validator verifier
        let validator_verifier = ValidatorVerifier::new(vec![
            (validator1.author(), validator1.public_key(), 1),
            (validator2.author(), validator2.public_key(), 1),
            (victim.author(), victim.public_key(), 1),
        ]);
        
        let proof_cache = ProofCache::new(100);
        
        // VULNERABILITY: This verification PASSES even though author != any signer
        assert!(proof.verify(&validator_verifier, &proof_cache).is_ok());
        
        // Demonstrate the fake author is used for attribution
        assert_eq!(proof.author(), victim.author()); // Returns FAKE author
        
        // When inserted into batch_proof_queue, this would be attributed to victim
        // instead of validator1/validator2 who actually created it
    }
}
```

**Expected Behavior**: The proof verification should fail because `victim.author()` is not among the actual signers (validator1 and validator2).

**Actual Behavior**: The proof verification passes, and the fake author is used for all subsequent attribution logic, enabling the attacks described above.

## Notes

This vulnerability affects the integrity of the quorum store's proof attribution system, which has cascading effects on fairness, monitoring, and Byzantine detection mechanisms. While the cryptographic validity of proofs is maintained (quorum signatures are still checked), the semantic meaning of the `author` field is not enforced, creating an exploitable trust assumption. The fix requires minimal code changes but is critical for maintaining protocol integrity and preventing validators from gaming the system.

### Citations

**File:** consensus/consensus-types/src/proof_of_store.rs (L635-652)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier, cache: &ProofCache) -> anyhow::Result<()> {
        let batch_info_ext: BatchInfoExt = self.info.clone().into();
        if let Some(signature) = cache.get(&batch_info_ext) {
            if signature == self.multi_signature {
                return Ok(());
            }
        }
        let result = validator
            .verify_multi_signatures(&self.info, &self.multi_signature)
            .context(format!(
                "Failed to verify ProofOfStore for batch: {:?}",
                self.info
            ));
        if result.is_ok() {
            cache.insert(batch_info_ext, self.multi_signature.clone());
        }
        result
    }
```

**File:** types/src/validator_verifier.rs (L346-386)
```rust
        &self,
        message: &T,
        multi_signature: &AggregateSignature,
    ) -> std::result::Result<(), VerifyError> {
        // Verify the number of signature is not greater than expected.
        Self::check_num_of_voters(self.len() as u16, multi_signature.get_signers_bitvec())?;
        let mut pub_keys = vec![];
        let mut authors = vec![];
        for index in multi_signature.get_signers_bitvec().iter_ones() {
            let validator = self
                .validator_infos
                .get(index)
                .ok_or(VerifyError::UnknownAuthor)?;
            authors.push(validator.address);
            pub_keys.push(validator.public_key());
        }
        // Verify the quorum voting power of the authors
        self.check_voting_power(authors.iter(), true)?;
        #[cfg(any(test, feature = "fuzzing"))]
        {
            if self.quorum_voting_power == 0 {
                // This should happen only in case of tests.
                // TODO(skedia): Clean up the test behaviors to not rely on empty signature
                // verification
                return Ok(());
            }
        }
        // Verify empty multi signature
        let multi_sig = multi_signature
            .sig()
            .as_ref()
            .ok_or(VerifyError::EmptySignature)?;
        // Verify the optimistically aggregated signature.
        let aggregated_key =
            PublicKey::aggregate(pub_keys).map_err(|_| VerifyError::FailedToAggregatePubKey)?;

        multi_sig
            .verify(message, &aggregated_key)
            .map_err(|_| VerifyError::InvalidMultiSignature)?;
        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L100-108)
```rust
    #[inline]
    fn inc_remaining_proofs(&mut self, author: &PeerId, num_txns: u64) {
        self.remaining_txns_with_duplicates += num_txns;
        self.remaining_proofs += 1;
        if *author == self.my_peer_id {
            self.remaining_local_txns += num_txns;
            self.remaining_local_proofs += 1;
        }
    }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L175-250)
```rust
    pub(crate) fn insert_proof(&mut self, proof: ProofOfStore<BatchInfoExt>) {
        if proof.expiration() <= self.latest_block_timestamp {
            counters::inc_rejected_pos_count(counters::POS_EXPIRED_LABEL);
            return;
        }
        let batch_key = BatchKey::from_info(proof.info());
        if self
            .items
            .get(&batch_key)
            .is_some_and(|item| item.proof.is_some() || item.is_committed())
        {
            counters::inc_rejected_pos_count(counters::POS_DUPLICATE_LABEL);
            return;
        }

        let author = proof.author();
        let bucket = proof.gas_bucket_start();
        let num_txns = proof.num_txns();
        let expiration = proof.expiration();

        let batch_sort_key = BatchSortKey::from_info(proof.info());
        let batches_for_author = self.author_to_batches.entry(author).or_default();
        batches_for_author.insert(batch_sort_key.clone(), proof.info().clone());

        // Check if a batch with a higher batch Id (reverse sorted) exists
        if let Some((prev_batch_key, _)) = batches_for_author
            .range((Bound::Unbounded, Bound::Excluded(batch_sort_key.clone())))
            .next_back()
        {
            if prev_batch_key.gas_bucket_start() == batch_sort_key.gas_bucket_start() {
                counters::PROOF_MANAGER_OUT_OF_ORDER_PROOF_INSERTION
                    .with_label_values(&[author.short_str().as_str()])
                    .inc();
            }
        }

        self.expirations.add_item(batch_sort_key, expiration);

        // If we are here, then proof is added for the first time. Otherwise, we will
        // return early. We only count when proof is added for the first time and txn
        // summary exists.
        if let Some(txn_summaries) = self
            .items
            .get(&batch_key)
            .and_then(|item| item.txn_summaries.as_ref())
        {
            for txn_summary in txn_summaries {
                *self
                    .txn_summary_num_occurrences
                    .entry(*txn_summary)
                    .or_insert(0) += 1;
            }
        }

        match self.items.entry(batch_key) {
            Entry::Occupied(mut entry) => {
                let item = entry.get_mut();
                item.proof = Some(proof);
                item.proof_insertion_time = Some(Instant::now());
            },
            Entry::Vacant(entry) => {
                entry.insert(QueueItem {
                    info: proof.info().clone(),
                    proof: Some(proof),
                    proof_insertion_time: Some(Instant::now()),
                    txn_summaries: None,
                });
            },
        }

        if author == self.my_peer_id {
            counters::inc_local_pos_count(bucket);
        } else {
            counters::inc_remote_pos_count(bucket);
        }
        self.inc_remaining_proofs(&author, num_txns);
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L596-600)
```rust
        for (_, batches) in self
            .author_to_batches
            .iter()
            .filter(|(author, _)| !exclude_authors.contains(author))
        {
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L805-814)
```rust
    pub(crate) fn remaining_txns_and_proofs(&self) -> (u64, u64) {
        let start = Instant::now();
        counters::NUM_TOTAL_TXNS_LEFT_ON_UPDATE.observe(self.remaining_txns_with_duplicates as f64);
        counters::NUM_TOTAL_PROOFS_LEFT_ON_UPDATE.observe(self.remaining_proofs as f64);
        counters::NUM_LOCAL_TXNS_LEFT_ON_UPDATE.observe(self.remaining_local_txns as f64);
        counters::NUM_LOCAL_PROOFS_LEFT_ON_UPDATE.observe(self.remaining_local_proofs as f64);

        let remaining_txns_without_duplicates = self.remaining_txns_without_duplicates();
        counters::NUM_UNIQUE_TOTAL_TXNS_LEFT_ON_UPDATE
            .observe(remaining_txns_without_duplicates as f64);
```
