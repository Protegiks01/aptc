# Audit Report

## Title
Hardcoded Event V2 Translation Config Causes Metadata Inconsistency During Database Restore

## Summary
The `get_indexer_db_for_restore()` function uses hardcoded configuration that enables event V2 translation indexing, but the restore process fails to write the corresponding `EventV2TranslationVersion` metadata. This creates an inconsistent database state that causes node startup failures with a panic, requiring manual intervention to recover.

## Finding Description

The vulnerability exists in the interaction between three components in the Aptos storage and indexer system:

**1. Hardcoded Configuration**

The `get_indexer_db_for_restore()` function creates an `InternalIndexerDBConfig` with all indexing features enabled, including `enable_event_v2_translation: true` and `event_v2_translation_ignores_below_version: 0`. [1](#0-0) 

The configuration parameters are hardcoded as: enable_transaction=true, enable_event=true, enable_event_v2_translation=true, event_v2_translation_ignores_below_version=0, enable_statekeys=true, batch_size=10_000. [2](#0-1) 

**2. Missing Metadata Write During Restore**

During state restoration, the `kv_finish()` method writes metadata for `LatestVersion`, `StateVersion`, `TransactionVersion`, and `EventVersion` based on which features are enabled. [3](#0-2) 

However, there is no conditional check for `event_v2_translation_enabled()` to write the `EventV2TranslationVersion` metadata, even though the hardcoded configuration during restore enables this feature.

**3. Version Consistency Check Fails at Startup**

When the node starts with the restored database, `get_start_version()` performs version consistency checks for all enabled indexer features. For event V2 translation, it retrieves `event_v2_translation_start_version` which defaults to 0 when the metadata doesn't exist via `map_or(0, |v| v + 1)`. [4](#0-3) 

With the hardcoded `event_v2_translation_ignores_below_version: 0` and a non-zero `start_version` from the restored data, the consistency check `event_v2_translation_ignores_below_version < start_version && start_version != event_v2_translation_start_version` evaluates to true, triggering a panic.

**Trigger Scenario:**
1. Node operator performs database restore using backup-cli with `--enable-state-indices` flag, which invokes `get_indexer_db_for_restore()` [5](#0-4) 
2. Restore completes at version N, creating metadata for LatestVersion, StateVersion, TransactionVersion, and EventVersion, but NOT EventV2TranslationVersion
3. Operator attempts to start node with configuration that has `enable_event_v2_translation: true`
4. During startup, `get_start_version()` calculates start_version=N and event_v2_translation_start_version=0 (default when metadata missing)
5. Consistency check triggers panic: "Cannot start event v2 translation indexer because the progress doesn't match"
6. Node fails to start, requiring manual metadata correction or configuration change

## Impact Explanation

This is a **Medium Severity** vulnerability according to Aptos bug bounty criteria:

- **State Inconsistency Requiring Intervention**: The restored database has incomplete metadata, violating database consistency invariants. Node operators cannot start their nodes without manual database manipulation or configuration changes.

- **Node Availability Loss**: Affected nodes cannot start until the issue is resolved, impacting network participation for validator nodes and API availability for fullnodes.

- **No Data Corruption**: The underlying state data remains intact; only indexer metadata is missing.

- **Limited Scope**: Only affects nodes performing restores with the `--enable-state-indices` flag and runtime configuration enabling event V2 translation.

This aligns with the Medium severity category of "State inconsistencies requiring manual intervention" worth up to $10,000 in the Aptos bug bounty program.

## Likelihood Explanation

**Likelihood: Medium**

- **Common Operation**: Database restore is a standard operational procedure for nodes recovering from failures or bootstrapping new infrastructure.

- **Feature Adoption**: The `--enable-state-indices` flag is commonly used by operators who want to support account-based API queries and indexing functionality.

- **Configuration Requirement**: The issue only manifests when the runtime configuration has `enable_event_v2_translation: true`, which is not the default setting [6](#0-5)  but may be enabled by operators wanting backward compatibility with V1 events.

- **Automatic Trigger**: Once the configuration conditions are met, the vulnerability triggers automatically during normal node startupâ€”no attacker action required.

- **Difficult to Diagnose**: Operators may not immediately understand the root cause of the panic, as the error message doesn't clearly indicate that the metadata is incomplete due to the restore process.

## Recommendation

**Fix 1: Write EventV2TranslationVersion Metadata During Restore**

Add a conditional check in the `kv_finish()` method to write the `EventV2TranslationVersion` metadata when the feature is enabled:

```rust
if internal_indexer_db.event_v2_translation_enabled() {
    batch.put::<InternalIndexerMetadataSchema>(
        &MetadataKey::EventV2TranslationVersion,
        &MetadataValue::Version(version - 1),
    )?;
}
```

This should be added in `storage/aptosdb/src/state_store/mod.rs` around line 1307, after the EventVersion write block.

**Fix 2: Match Restore Configuration to Runtime Configuration**

Instead of using hardcoded configuration in `get_indexer_db_for_restore()`, accept the intended runtime configuration as a parameter, ensuring consistency between restore and startup.

## Proof of Concept

**Reproduction Steps:**

1. Perform a database restore with state indices enabled:
```bash
aptos-db-tool restore bootstrap-db \
  --target-db-dir /path/to/db \
  --metadata-cache-dir /path/to/metadata \
  --command-adapter-config command_adapter.yaml \
  --enable-state-indices
```

2. Configure the node with event V2 translation enabled in `node.yaml`:
```yaml
indexer_db_config:
  enable_transaction: true
  enable_event: true
  enable_event_v2_translation: true
  enable_statekeys: true
```

3. Attempt to start the node:
```bash
aptos-node -f node.yaml
```

**Expected Result:**
Node fails to start with panic message:
```
Cannot start event v2 translation indexer because the progress doesn't match. 
start_version: <N>, event_v2_translation_start_version: 0
```

**Verification:**
Query the internal indexer DB metadata to confirm `EventV2TranslationVersion` key is missing while other version keys exist.

## Notes

This vulnerability demonstrates a design inconsistency where the restore process uses hardcoded configuration that doesn't align with the metadata it actually writes. The root cause is the mismatch between what features are enabled during restore configuration and what metadata is persisted. While the likelihood is reduced by the fact that event V2 translation is not enabled by default, it represents a real operational issue that can cause node startup failures requiring manual intervention.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L54-56)
```rust
        let internal_indexer_db_config =
            InternalIndexerDBConfig::new(true, true, true, 0, true, 10_000);
        Some(InternalIndexerDB::new(arc_db, internal_indexer_db_config))
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L141-158)
```rust
        if node_config.indexer_db_config.enable_event_v2_translation() {
            let event_v2_translation_start_version = self
                .db_indexer
                .indexer_db
                .get_event_v2_translation_version()?
                .map_or(0, |v| v + 1);
            if node_config
                .indexer_db_config
                .event_v2_translation_ignores_below_version()
                < start_version
                && start_version != event_v2_translation_start_version
            {
                panic!(
                    "Cannot start event v2 translation indexer because the progress doesn't match. \
                    start_version: {}, event_v2_translation_start_version: {}",
                    start_version, event_v2_translation_start_version
                );
            }
```

**File:** config/src/config/internal_indexer_db_config.rs (L22-38)
```rust
    pub fn new(
        enable_transaction: bool,
        enable_event: bool,
        enable_event_v2_translation: bool,
        event_v2_translation_ignores_below_version: u64,
        enable_statekeys: bool,
        batch_size: usize,
    ) -> Self {
        Self {
            enable_transaction,
            enable_event,
            enable_event_v2_translation,
            event_v2_translation_ignores_below_version,
            enable_statekeys,
            batch_size,
        }
    }
```

**File:** config/src/config/internal_indexer_db_config.rs (L69-79)
```rust
impl Default for InternalIndexerDBConfig {
    fn default() -> Self {
        Self {
            enable_transaction: false,
            enable_event: false,
            enable_event_v2_translation: false,
            event_v2_translation_ignores_below_version: 0,
            enable_statekeys: false,
            batch_size: 10_000,
        }
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1281-1315)
```rust
    fn kv_finish(&self, version: Version, usage: StateStorageUsage) -> Result<()> {
        self.ledger_db.metadata_db().put_usage(version, usage)?;
        if let Some(internal_indexer_db) = self.internal_indexer_db.as_ref() {
            if version > 0 {
                let mut batch = SchemaBatch::new();
                batch.put::<InternalIndexerMetadataSchema>(
                    &MetadataKey::LatestVersion,
                    &MetadataValue::Version(version - 1),
                )?;
                if internal_indexer_db.statekeys_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::StateVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                if internal_indexer_db.transaction_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::TransactionVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                if internal_indexer_db.event_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::EventVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                internal_indexer_db
                    .get_inner_db_ref()
                    .write_schemas(batch)?;
            }
        }

        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L300-304)
```rust
            let internal_indexer_db = if opt.enable_state_indices {
                InternalIndexerDBService::get_indexer_db_for_restore(db_dir.as_path())
            } else {
                None
            };
```
