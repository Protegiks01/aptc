# Audit Report

## Title
Storage Directory Traversal Vulnerability Allowing Arbitrary Filesystem Write Locations

## Summary
The `node_config.storage.dir()` method lacks path traversal validation, allowing directory traversal sequences (`..`) to write critical consensus and state sync databases to arbitrary filesystem locations outside the intended data directory. This affects multiple critical storage components including state sync metadata, consensus databases, and quorum store data.

## Finding Description

The vulnerability exists in the path resolution chain for storage directories used throughout the Aptos node. The attack surface spans multiple critical components:

**Vulnerable Code Path:**

1. The `StorageConfig::dir()` method resolves storage paths but performs no sanitization of directory traversal sequences: [1](#0-0) 

2. This unsanitized path is passed to create the `PersistentMetadataStorage` for state sync: [2](#0-1) 

3. The `PersistentMetadataStorage::new()` method directly joins the path with `STATE_SYNC_DB_NAME` without validation: [3](#0-2) 

4. The same vulnerable pattern affects multiple critical databases:
   - **ConsensusDB**: [4](#0-3) 
   - **QuorumStoreDB**: [5](#0-4) 
   - **RandDb**: [6](#0-5) 

**Missing Validation:**

The `ConfigSanitizer` implementation for `StorageConfig` validates paths in `db_path_overrides` but completely omits validation of the primary `storage.dir` field: [7](#0-6) 

**Exploitation Scenario:**

An attacker with config file modification access (e.g., compromised node operator, supply chain attack, or misconfigured deployment) can set:
```yaml
storage:
  dir: "../../../../../../tmp/attacker_controlled"
```

With default `data_dir` of `/opt/aptos/data`, this resolves to `/tmp/attacker_controlled/state_sync_db`, allowing:
- Writing databases to attacker-controlled locations
- Potential symlink attacks if attacker can place symlinks
- Disk space exhaustion on wrong partitions
- Data corruption by overwriting unrelated files
- Data exfiltration through predictable paths

## Impact Explanation

**Severity: High** per Aptos bug bounty criteria:
- **Validator node slowdowns**: Writing databases to incorrect partitions can cause I/O bottlenecks and performance degradation
- **Node crashes**: Attempting to write to protected locations causes database initialization failures and node startup failures  
- **Data integrity violations**: Critical consensus and state sync databases created in wrong locations can lead to state inconsistencies

This breaks the **State Consistency** invariant (#4): "State transitions must be atomic and verifiable via Merkle proofs" - if databases are written to arbitrary locations, the node cannot maintain consistent state.

The vulnerability affects critical consensus components (ConsensusDB, QuorumStoreDB, RandDb) which could lead to liveness failures if databases are corrupted or inaccessible.

## Likelihood Explanation

**Likelihood: Medium**

While the attack requires config file access, several realistic scenarios enable exploitation:
1. **Compromised node operator credentials** - common attack vector
2. **Supply chain attacks** - malicious config injection during deployment automation
3. **Misconfigured file permissions** - allowing unauthorized config modification
4. **Social engineering** - tricking operators into using malicious configs

The codebase already implements path validation for `db_path_overrides`, demonstrating awareness of path security issues, yet inconsistently omits validation for the primary `storage.dir` field. This inconsistency suggests the issue was overlooked rather than intentionally excluded.

Defense-in-depth principles dictate that even "trusted" inputs like config files should be validated to prevent accidents and limit damage from partial compromises.

## Recommendation

**Immediate Fix:** Add path traversal validation in the `ConfigSanitizer` implementation:

```rust
impl ConfigSanitizer for StorageConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = &node_config.storage;

        // ADD THIS: Validate storage.dir for path traversal
        let dir_path = config.dir();
        let canonicalized = dir_path.canonicalize().unwrap_or_else(|_| dir_path.clone());
        if canonicalized.components().any(|c| matches!(c, std::path::Component::ParentDir)) {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!("storage.dir contains invalid path traversal sequences: {:?}", config.dir),
            ));
        }

        // Ensure the resolved path stays within data_dir for relative paths
        if config.dir.is_relative() {
            let base_dir = config.data_dir.canonicalize().unwrap_or_else(|_| config.data_dir.clone());
            if !canonicalized.starts_with(&base_dir) {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("storage.dir resolves outside data_dir: {:?}", canonicalized),
                ));
            }
        }

        // ... rest of existing validation
    }
}
```

**Additional Recommendations:**
1. Apply same validation to `base.data_dir` field
2. Consider rejecting relative paths entirely for production environments
3. Add runtime checks before database creation
4. Document path security requirements in configuration guides

## Proof of Concept

```rust
// Create a test demonstrating the vulnerability
#[test]
fn test_directory_traversal_vulnerability() {
    use std::path::PathBuf;
    
    // Create malicious config with directory traversal
    let mut config = StorageConfig::default();
    config.dir = PathBuf::from("../../../../../../tmp/malicious");
    config.data_dir = PathBuf::from("/opt/aptos/data");
    
    // The dir() method does not sanitize path traversal
    let resolved_path = config.dir();
    println!("Resolved path: {:?}", resolved_path);
    // Output: /opt/aptos/data/../../../../../../tmp/malicious
    // Which normalizes to: /tmp/malicious
    
    // This would create state_sync_db at /tmp/malicious/state_sync_db
    // instead of the intended /opt/aptos/data/db/state_sync_db
    
    // Demonstrate the impact
    let metadata_storage = PersistentMetadataStorage::new(&resolved_path);
    // Database created at arbitrary location!
}
```

**Notes**

This vulnerability exemplifies inconsistent security practices - the codebase validates paths in `db_path_overrides` but omits validation for the primary `storage.dir` field. While config files are generally trusted inputs, defense-in-depth principles require validation to prevent accidental misconfigurations and limit damage from partial compromises. The impact is significant because it affects multiple critical consensus and storage components, potentially causing node failures or data corruption.

### Citations

**File:** config/src/config/storage_config.rs (L459-465)
```rust
    pub fn dir(&self) -> PathBuf {
        if self.dir.is_relative() {
            self.data_dir.join(&self.dir)
        } else {
            self.dir.clone()
        }
    }
```

**File:** config/src/config/storage_config.rs (L682-798)
```rust
impl ConfigSanitizer for StorageConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = &node_config.storage;

        let ledger_prune_window = config
            .storage_pruner_config
            .ledger_pruner_config
            .prune_window;
        let state_merkle_prune_window = config
            .storage_pruner_config
            .state_merkle_pruner_config
            .prune_window;
        let epoch_snapshot_prune_window = config
            .storage_pruner_config
            .epoch_snapshot_pruner_config
            .prune_window;
        let user_pruning_window_offset = config
            .storage_pruner_config
            .ledger_pruner_config
            .user_pruning_window_offset;

        if ledger_prune_window < 50_000_000 {
            warn!("Ledger prune_window is too small, harming network data availability.");
        }
        if state_merkle_prune_window < 100_000 {
            warn!("State Merkle prune_window is too small, node might stop functioning.");
        }
        if epoch_snapshot_prune_window < 50_000_000 {
            warn!("Epoch snapshot prune_window is too small, harming network data availability.");
        }
        if user_pruning_window_offset > 1_000_000 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "user_pruning_window_offset too large, so big a buffer is unlikely necessary. Set something < 1 million.".to_string(),
            ));
        }
        if user_pruning_window_offset > ledger_prune_window {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "user_pruning_window_offset is larger than the ledger prune window, the API will refuse to return any data.".to_string(),
            ));
        }

        if let Some(db_path_overrides) = config.db_path_overrides.as_ref() {
            if !config.rocksdb_configs.enable_storage_sharding {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "db_path_overrides is allowed only if sharding is enabled.".to_string(),
                ));
            }

            if let Some(ledger_db_path) = db_path_overrides.ledger_db_path.as_ref() {
                if !ledger_db_path.is_absolute() {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        format!(
                            "Path {ledger_db_path:?} in db_path_overrides is not an absolute path."
                        ),
                    ));
                }
            }

            if let Some(state_kv_db_path) = db_path_overrides.state_kv_db_path.as_ref() {
                if let Some(metadata_path) = state_kv_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_kv_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }

            if let Some(state_merkle_db_path) = db_path_overrides.state_merkle_db_path.as_ref() {
                if let Some(metadata_path) = state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }

            if let Some(hot_state_merkle_db_path) =
                db_path_overrides.hot_state_merkle_db_path.as_ref()
            {
                if let Some(metadata_path) = hot_state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = hot_state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }
        }

        Ok(())
    }
```

**File:** aptos-node/src/state_sync.rs (L156-156)
```rust
    let metadata_storage = PersistentMetadataStorage::new(&node_config.storage.dir());
```

**File:** state-sync/state-sync-driver/src/metadata_storage.rs (L66-86)
```rust
    pub fn new<P: AsRef<Path> + Clone>(db_root_path: P) -> Self {
        // Set the options to create the database if it's missing
        let mut options = Options::default();
        options.create_if_missing(true);
        options.create_missing_column_families(true);

        // Open the database
        let state_sync_db_path = db_root_path.as_ref().join(STATE_SYNC_DB_NAME);
        let instant = Instant::now();
        let database = DB::open(
            state_sync_db_path.clone(),
            "state_sync",
            vec![METADATA_CF_NAME],
            &options,
        )
        .unwrap_or_else(|error| {
            panic!(
                "Failed to open/create the state sync database at: {:?}. Error: {:?}",
                state_sync_db_path, error
            )
        });
```

**File:** consensus/src/persistent_liveness_storage.rs (L487-487)
```rust
        let db = Arc::new(ConsensusDB::new(config.storage.dir()));
```

**File:** consensus/src/consensus_provider.rs (L58-58)
```rust
    let quorum_store_db = Arc::new(QuorumStoreDB::new(node_config.storage.dir()));
```

**File:** consensus/src/consensus_provider.rs (L85-85)
```rust
    let rand_storage = Arc::new(RandDb::new(node_config.storage.dir()));
```
