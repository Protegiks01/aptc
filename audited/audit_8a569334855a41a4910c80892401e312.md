# Audit Report

## Title
Missing Cryptographic Delta Validation Before Persisting CertifiedAugData Enables Persistent Node Crash Loop

## Summary
CertifiedAugData Delta values are not cryptographically validated before storage, only after. While creating malformed CertifiedAugData requires Byzantine validator collusion, once persisted, the malformed data causes the node to panic during augmentation and enter an unrecoverable crash loop on restart.

## Finding Description
The consensus randomness generation system uses AugData structures containing Delta values that must be cryptographically valid for APK (Augmented Public Key) derivation. There are two types: uncertified AugData and CertifiedAugData.

**For regular AugData**, proper validation exists: [1](#0-0) 

This calls `aug_data.verify()` which validates Delta cryptographically: [2](#0-1) 

The `derive_apk()` call performs cryptographic validation via WVUF pairing checks: [3](#0-2) [4](#0-3) 

**However, for CertifiedAugData**, validation is incomplete: [5](#0-4) 

The `verify()` method only checks aggregate signatures, NOT Delta validity: [6](#0-5) 

When CertifiedAugData is received, it's saved to disk immediately: [7](#0-6) 

Delta validation only happens during `augment()` at line 127, which uses `.expect()` that panics on invalid Delta: [8](#0-7) 

On node restart, all persisted CertifiedAugData is loaded and augmented: [9](#0-8) 

**Attack Scenario:**
1. Byzantine validators (≥ threshold) collude to create CertifiedAugData with malformed Delta but valid aggregate signatures
2. They broadcast this to honest validators
3. Honest validator receives message, validates only signatures (not Delta), and saves to disk (line 124)
4. Node attempts `augment()` (line 127) which calls `derive_apk()` and panics on malformed Delta
5. Node crashes
6. On restart, node loads malformed data from disk and attempts `augment()` again (line 70 in `new()`)
7. Node panics again - enters permanent crash loop

## Impact Explanation
**Severity Assessment: Medium (not High)**

While this violates defense-in-depth principles, exploitation requires ≥ threshold (typically 2/3) Byzantine validators to create valid aggregate signatures on malformed data. This exceeds the < 1/3 Byzantine assumption in Aptos's trust model.

However, once exploited, the impact is severe:
- **Persistent DoS**: Affected validators cannot recover without manual database intervention
- **Consensus disruption**: If enough validators are affected, liveness degrades
- **Requires no additional attacks**: Once malformed data is persisted, crash loop is automatic

This qualifies as **Medium severity** under "State inconsistencies requiring intervention" rather than High severity because:
1. It requires Byzantine threshold (beyond normal trust assumptions)
2. It's a defense-in-depth failure rather than a primary security control failure
3. The bug bounty exclusions mention "51% attacks or stake majority attacks" - while this isn't exactly that, it requires supermajority (2/3) Byzantine validators

## Likelihood Explanation
**Likelihood: Low to Very Low**

Exploitation requires:
- ≥ 2/3 of validator stake to collude and sign malformed AugData
- This violates Aptos's < 1/3 Byzantine assumption
- Economic disincentives make such collusion extremely unlikely

However, the code should still validate Delta values as defense-in-depth against:
- Bugs in signature verification logic
- Edge cases during epoch transitions
- Database corruption scenarios
- Future protocol changes

## Recommendation
Add explicit Delta cryptographic validation before persisting CertifiedAugData:

```rust
pub fn add_certified_aug_data(
    &mut self,
    certified_data: CertifiedAugData<D>,
) -> anyhow::Result<CertifiedAugDataAck> {
    if self.certified_data.contains_key(certified_data.author()) {
        return Ok(CertifiedAugDataAck::new(self.epoch));
    }
    
    // ADD: Validate Delta values before storage
    certified_data
        .data()
        .verify(&self.config, &self.fast_config, certified_data.author())?;
    
    self.db.save_certified_aug_data(&certified_data)?;
    certified_data
        .data()
        .augment(&self.config, &self.fast_config, certified_data.author());
    self.certified_data
        .insert(*certified_data.author(), certified_data);
    Ok(CertifiedAugDataAck::new(self.epoch))
}
```

This ensures Delta validation happens before storage, preventing malformed data from being persisted even if signature validation has bugs or the trust model is temporarily violated.

## Proof of Concept

```rust
// This test demonstrates that CertifiedAugData with invalid Delta
// can pass signature verification but cause panic during augmentation

#[test]
#[should_panic(expected = "Add delta should succeed")]
fn test_malformed_certified_aug_data_panic() {
    use consensus::rand::rand_gen::{
        aug_data_store::AugDataStore,
        types::{AugData, AugmentedData, CertifiedAugData, RandConfig},
    };
    use aptos_types::aggregate_signature::AggregateSignature;
    
    // Setup: Create RandConfig and AugDataStore
    let (config, fast_config, db, signer, epoch) = setup_test_environment();
    
    // Create malformed AugmentedData with invalid Delta
    let malformed_delta = create_malformed_delta(); // Invalid cryptographic material
    let malformed_aug_data = AugmentedData {
        delta: malformed_delta,
        fast_delta: None,
    };
    
    let aug_data = AugData::new(epoch, author, malformed_aug_data);
    
    // Create valid aggregate signatures (simulating Byzantine threshold)
    let signatures = create_threshold_signatures(&aug_data);
    let certified_data = CertifiedAugData::new(aug_data, signatures);
    
    // Signature verification passes
    assert!(certified_data.verify(&verifier).is_ok());
    
    let mut store = AugDataStore::new(epoch, signer, config, fast_config, db);
    
    // This will save malformed data to disk, then panic during augment()
    // On restart, panic will occur again when loading from disk
    store.add_certified_aug_data(certified_data).unwrap(); // PANIC HERE
}
```

## Notes
The answer to the security question "Are the Delta values within AugData cryptographically validated before storage?" is:
- **For AugData**: YES, validation happens via `aug_data.verify()` → `derive_apk()` before `save_aug_data()`
- **For CertifiedAugData**: NO, only aggregate signatures are validated before `save_certified_aug_data()`, Delta validation happens after via `augment()`

This validation gap violates defense-in-depth principles even though exploitation requires Byzantine threshold validators.

### Citations

**File:** consensus/src/rand/rand_gen/network_messages.rs (L47-49)
```rust
            RandMessage::AugData(aug_data) => {
                aug_data.verify(rand_config, fast_rand_config, sender)
            },
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L50-52)
```rust
            RandMessage::CertifiedAugData(certified_aug_data) => {
                certified_aug_data.verify(&epoch_state.verifier)
            },
```

**File:** consensus/src/rand/rand_gen/types.rs (L185-187)
```rust
        rand_config
            .add_certified_delta(author, delta.clone())
            .expect("Add delta should succeed");
```

**File:** consensus/src/rand/rand_gen/types.rs (L196-204)
```rust
    fn verify(
        &self,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        author: &Author,
    ) -> anyhow::Result<()> {
        rand_config
            .derive_apk(author, self.delta.clone())
            .map(|_| ())?;
```

**File:** consensus/src/rand/rand_gen/types.rs (L555-558)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        verifier.verify_multi_signatures(&self.aug_data, &self.signatures)?;
        Ok(())
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L656-659)
```rust
    fn derive_apk(&self, peer: &Author, delta: Delta) -> anyhow::Result<APK> {
        let apk = WVUF::augment_pubkey(&self.vuf_pp, self.get_pk_share(peer).clone(), delta)?;
        Ok(apk)
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L134-140)
```rust
        if multi_pairing(
            [&delta.pi, &rks_combined].into_iter(),
            [&pks_combined, &pp.g_hat.neg()].into_iter(),
        ) != Gt::identity()
        {
            bail!("RPKs were not correctly randomized.");
        }
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L67-71)
```rust
        for (_, certified_data) in &certified_data {
            certified_data
                .data()
                .augment(&config, &fast_config, certified_data.author());
        }
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L117-127)
```rust
    pub fn add_certified_aug_data(
        &mut self,
        certified_data: CertifiedAugData<D>,
    ) -> anyhow::Result<CertifiedAugDataAck> {
        if self.certified_data.contains_key(certified_data.author()) {
            return Ok(CertifiedAugDataAck::new(self.epoch));
        }
        self.db.save_certified_aug_data(&certified_data)?;
        certified_data
            .data()
            .augment(&self.config, &self.fast_config, certified_data.author());
```
