# Audit Report

## Title
Testnet Gas Schedule Parameters Lack Network-Specific Validation Allowing Inadvertent Mainnet Deployment

## Summary
The Aptos gas schedule system lacks network-specific validation and sanity checks, allowing testnet-configured gas parameters (designed for testing with extreme values) to be deployed to mainnet through the governance process. Both testnet and mainnet use identical `InitialGasSchedule::initial()` implementations at genesis, and post-genesis updates have no safeguards preventing testnet values from being applied to mainnet.

## Finding Description

### No Separate Initial Implementations
The `InitialGasSchedule` trait defines a single `initial()` method without network differentiation: [1](#0-0) 

Both testnet and mainnet genesis use the same `default_gas_schedule()` function which calls `AptosGasParameters::initial()`: [2](#0-1) 

Both `generate_test_genesis()` and `generate_mainnet_genesis()` use identical gas schedules: [3](#0-2) [4](#0-3) 

### Testnet Uses Extreme Values for Testing
Operational tests demonstrate testnet using drastically relaxed gas parameters. For example, the transaction size limit is increased from the default 64 KB to 100 MB: [5](#0-4) [6](#0-5) 

This represents a **1,562x increase** (100 MB vs 64 KB) from the default value.

### Missing Validation in Gas Schedule Updates
The Move module responsible for gas schedule updates contains explicit TODO comments indicating missing validation: [7](#0-6) 

The validation only checks:
- Gas schedule blob is not empty
- Feature version is monotonically increasing

**Missing validations:**
- No network-specific checks (no chain_id validation)
- No sanity bounds on parameter values
- No detection of testnet-specific configurations [8](#0-7) [9](#0-8) 

### Same Deployment Mechanism
The gas upgrade proposal generation differs only in signer syntax between testnet and mainnet, not in parameter validation: [10](#0-9) 

## Impact Explanation

**Severity Assessment: Medium**

If testnet gas parameters (e.g., 100 MB transaction size) are inadvertently deployed to mainnet via governance:

1. **Network Degradation**: 100 MB transactions could cause:
   - Consensus delays from processing large transactions
   - Network bandwidth exhaustion
   - Memory pressure on validator nodes
   
2. **State Bloat**: Massive transactions enable storage DoS attacks

3. **Resource Exhaustion**: If other gas parameters are underpriced for testing, attackers could perform subsidized computation

This meets **Medium Severity** criteria: "State inconsistencies requiring intervention" and could escalate to **High Severity** ("Validator node slowdowns") depending on the specific parameters deployed.

## Likelihood Explanation

**Likelihood: Medium**

While this requires governance participation (limiting the attack surface), the likelihood is elevated by:

1. **No Technical Safeguards**: Zero validation prevents accidental deployment
2. **Operational Complexity**: Release processes involve multiple gas schedule variants
3. **Human Error Surface**: Developers managing both testnet and mainnet deployments could confuse configurations
4. **Historical Evidence**: The smoke test demonstrates testnet using 1,562x larger transaction limits for testing purposes

The lack of any sanity checking means a single mistake in the release process could deploy exploitable configurations to mainnet.

## Recommendation

Implement multi-layered validation:

**1. Add Network-Specific Validation in Move:**
```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // NEW: Validate gas schedule sanity bounds
    validate_gas_schedule_bounds(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

fun validate_gas_schedule_bounds(schedule: &GasScheduleV2) {
    // Enforce maximum bounds on critical parameters
    let entries_map = create_entries_map(&schedule.entries);
    
    // Example: max_transaction_size_in_bytes should not exceed 10 MB for mainnet
    let max_txn_size = get_entry(&entries_map, "txn.max_transaction_size_in_bytes");
    assert!(max_txn_size <= 10_485_760, error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    // Add more bounds checks for other critical parameters
}
```

**2. Add Rust-Side Validation:**

In `aptos-move/aptos-gas-schedule/src/lib.rs`, add a `validate()` method to `GasScheduleV2`:

```rust
impl GasScheduleV2 {
    pub fn validate(&self, is_mainnet: bool) -> Result<(), String> {
        // Parse entries into structured parameters
        let params = AptosGasParameters::from_on_chain_gas_schedule(
            &self.entries_as_map(),
            self.feature_version
        )?;
        
        // Enforce network-specific bounds
        if is_mainnet {
            if params.vm.txn.max_transaction_size_in_bytes.into(): u64 > 10_485_760 {
                return Err("max_transaction_size_in_bytes exceeds mainnet limit".into());
            }
            // Add more mainnet-specific checks
        }
        
        Ok(())
    }
}
```

**3. Process Improvements:**

- Separate configuration files for testnet and mainnet gas schedules
- Automated CI checks comparing proposed mainnet gas schedules against known safe bounds
- Require explicit `--network` flag when generating gas upgrade proposals

## Proof of Concept

**Attack Scenario:**

1. Developer generates testnet gas schedule with 100 MB transaction limit for stress testing
2. Developer accidentally uses testnet configuration when generating mainnet upgrade proposal
3. Governance proposal passes validation (no bounds checking exists)
4. Mainnet now accepts 100 MB transactions

**Reproduction Steps:**

```rust
// In testsuite/smoke-test/src/upgrade.rs
// This demonstrates the testnet configuration that could be accidentally deployed to mainnet

let mut gas_parameters = AptosGasParameters::initial();
gas_parameters.vm.txn.max_transaction_size_in_bytes = GasQuantity::new(100_000_000); // 100 MB

let gas_schedule = aptos_types::on_chain_config::GasScheduleV2 {
    feature_version: aptos_gas_schedule::LATEST_GAS_FEATURE_VERSION,
    entries: gas_parameters.to_on_chain_gas_schedule(aptos_gas_schedule::LATEST_GAS_FEATURE_VERSION),
};

// Generate proposal - note 'true' could be accidentally used even for mainnet
let (_, update_gas_script) = generate_gas_upgrade_proposal(
    None, 
    &gas_schedule,
    true,  // is_testnet - if accidentally set to true for mainnet, no validation prevents deployment
    None,
    false
).unwrap().pop().unwrap();

// This proposal would pass all current validations and could be executed on mainnet
```

**Impact Demonstration:**

After deployment, an attacker could submit 100 MB transactions to:
- Exhaust validator memory and network bandwidth
- Cause consensus delays
- Create state bloat requiring manual intervention

## Notes

The vulnerability stems from three compounding factors:

1. **Identical genesis initialization** for testnet and mainnet
2. **No network-aware validation** in gas schedule update paths
3. **Explicit TODO comments** acknowledging missing consistency checks

While this requires governance participation (limiting direct exploitation by unprivileged attackers), the complete absence of technical safeguards creates substantial operational risk. The Aptos team's own testing infrastructure demonstrates using extreme gas values on testnet (1,562x normal limits), making accidental crossover to mainnet a realistic concern.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/traits.rs (L25-29)
```rust
/// A trait for defining an initial value to be used in the genesis.
pub trait InitialGasSchedule: Sized {
    /// Returns the initial value of this type, which is used in the genesis.
    fn initial() -> Self;
}
```

**File:** aptos-move/vm-genesis/src/lib.rs (L128-133)
```rust
pub fn default_gas_schedule() -> GasScheduleV2 {
    GasScheduleV2 {
        feature_version: LATEST_GAS_FEATURE_VERSION,
        entries: AptosGasParameters::initial().to_on_chain_gas_schedule(LATEST_GAS_FEATURE_VERSION),
    }
}
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1447-1447)
```rust
        &default_gas_schedule(),
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1469-1469)
```rust
        &default_gas_schedule(),
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** testsuite/smoke-test/src/upgrade.rs (L51-60)
```rust
    // Bump the limit in gas schedule
    // TODO: Replace this logic with aptos-gas
    let mut gas_parameters = AptosGasParameters::initial();
    gas_parameters.vm.txn.max_transaction_size_in_bytes = GasQuantity::new(100_000_000);

    let gas_schedule = aptos_types::on_chain_config::GasScheduleV2 {
        feature_version: aptos_gas_schedule::LATEST_GAS_FEATURE_VERSION,
        entries: gas_parameters
            .to_on_chain_gas_schedule(aptos_gas_schedule::LATEST_GAS_FEATURE_VERSION),
    };
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-67)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-release-builder/src/components/gas.rs (L80-87)
```rust
pub fn generate_gas_upgrade_proposal(
    old_gas_schedule: Option<&GasScheduleV2>,
    new_gas_schedule: &GasScheduleV2,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> Result<Vec<(String, String)>> {
    let signer_arg = get_signer_arg(is_testnet, &next_execution_hash);
```
