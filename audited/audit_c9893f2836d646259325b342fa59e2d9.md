# Audit Report

## Title
Module-Level Metering Limit Silently Ignored Due to Wrong Configuration Variable

## Summary
The Move bytecode verifier's metering system contains a bug where the module-level complexity limit (`max_per_mod_meter_units`) is never enforced. Instead, the function-level limit (`max_per_fun_meter_units`) is incorrectly used for both module and function metering, allowing the configured module limit to fail silently.

## Finding Description
The bytecode verifier enforces complexity limits through the `BoundMeter` struct to prevent overly complex modules and functions from passing verification. The configuration specifies separate limits for function-level (`max_per_fun_meter_units`) and module-level (`max_per_mod_meter_units`) complexity. [1](#0-0) 

In the `BoundMeter::new()` constructor, line 115 incorrectly assigns `config.max_per_fun_meter_units` to the `mod_bounds.max` field instead of `config.max_per_mod_meter_units`. This means the module-level metering bounds use the function-level limit value.

The production configuration sets both limits to the same value: [2](#0-1) 

While this masks the bug in production, it represents a silent failure where a configured limit is not enforced as intended. If different values were configured (e.g., stricter module limits than function limits), modules exceeding the module limit would incorrectly pass verification without returning the expected `CONSTRAINT_NOT_SATISFIED` error. [3](#0-2) 

## Impact Explanation
**Severity: Low to None (in current production deployment)**

In the current production configuration, both `max_per_fun_meter_units` and `max_per_mod_meter_units` are set to `Some(1000 * 80000)`, so the bug has no immediate security impact on the Aptos mainnet. The incorrect limit value happens to match what should have been used.

However, this represents:
- A violation of design intent where separate limits should be independently enforced
- A maintenance hazard if future changes set different values for these limits
- A silent configuration failure that could affect testnets or private deployments

This does not meet the threshold for Critical, High, or Medium severity as defined by the Aptos bug bounty program, as it causes no funds loss, consensus violations, or state inconsistencies in production.

## Likelihood Explanation
The bug is present in all deployments but only manifests as a security issue if:
1. Someone configures `max_per_mod_meter_units` differently from `max_per_fun_meter_units`
2. A module is crafted with complexity between these two thresholds

In production, likelihood of exploitation is **zero** because both limits are identical.

## Recommendation
Fix the bug by using the correct configuration field:

```rust
pub fn new(config: &VerifierConfig) -> Self {
    Self {
        mod_bounds: Bounds {
            name: "<unknown>".to_string(),
            units: 0,
            max: config.max_per_mod_meter_units, // FIXED: use module limit
        },
        fun_bounds: Bounds {
            name: "<unknown>".to_string(),
            units: 0,
            max: config.max_per_fun_meter_units,
        },
    }
}
```

Additionally, add test coverage that validates both limits are enforced independently when configured with different values.

## Proof of Concept

```rust
#[test]
fn test_separate_module_and_function_limits() {
    use move_bytecode_verifier::{VerifierConfig, verify_module_with_config};
    
    // Configure different limits for module vs function
    let config = VerifierConfig {
        max_per_fun_meter_units: Some(1000),
        max_per_mod_meter_units: Some(500), // Stricter module limit
        ..Default::default()
    };
    
    // Create a module with multiple functions that individually pass
    // the function limit but together exceed the module limit
    let module = create_complex_module_within_function_limits();
    
    // This should fail with CONSTRAINT_NOT_SATISFIED due to module limit
    // but currently passes because module limit is ignored
    let result = verify_module_with_config(&config, &module);
    
    // BUG: result is Ok but should be Err(CONSTRAINT_NOT_SATISFIED)
    // because module complexity exceeds max_per_mod_meter_units
}
```

## Notes
While this is a genuine implementation bug where a limit fails silently, it does not constitute a security vulnerability in the production Aptos network due to the configuration values being identical. It represents a code quality issue and potential future risk rather than an active exploit vector.

**Given the extremely high bar for bug bounty validity and the lack of demonstrable security harm in production, this finding would likely be classified as out of scope or too low severity for the Aptos bug bounty program.**

### Citations

**File:** third_party/move/move-bytecode-verifier/src/meter.rs (L90-106)
```rust
impl Bounds {
    fn add(&mut self, units: u128) -> PartialVMResult<()> {
        if let Some(max) = self.max {
            let new_units = self.units.saturating_add(units);
            if new_units > max {
                // TODO: change to a new status PROGRAM_TOO_COMPLEX once this is rolled out. For
                // now we use an existing code to avoid breaking changes on potential rollback.
                return Err(PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                    .with_message(format!(
                        "program too complex (in `{}` with `{} current + {} new > {} max`)",
                        self.name, self.units, units, max
                    )));
            }
            self.units = new_units;
        }
        Ok(())
    }
```

**File:** third_party/move/move-bytecode-verifier/src/meter.rs (L109-123)
```rust
impl BoundMeter {
    pub fn new(config: &VerifierConfig) -> Self {
        Self {
            mod_bounds: Bounds {
                name: "<unknown>".to_string(),
                units: 0,
                max: config.max_per_fun_meter_units,
            },
            fun_bounds: Bounds {
                name: "<unknown>".to_string(),
                units: 0,
                max: config.max_per_fun_meter_units,
            },
        }
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L175-176)
```rust
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
```
