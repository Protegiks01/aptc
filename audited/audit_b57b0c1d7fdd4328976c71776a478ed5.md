# Audit Report

## Title
Node Health Checker TPS Validation Bypass via Single-Node Trust Boundary Violation

## Summary
The `TpsChecker` in the Aptos node health checker validates transaction throughput by submitting transactions to a target node and querying the same node to verify commitment. A malicious node operator can fake account sequence numbers to falsely pass TPS requirements without actually processing transactions on-chain.

## Finding Description
The TPS checker creates a trust boundary violation where the node being tested is solely responsible for reporting its own performance metrics without independent verification. [1](#0-0) 

The cluster is configured with only the target node's URL repeated, meaning all REST clients point to the node under test. When transactions are submitted and verified: [2](#0-1) 

The emitter creates job requests using these target-node-only clients. During verification: [3](#0-2) 

The verification queries account sequence numbers from `self.client()`, which is the target node itself: [4](#0-3) 

The actual verification makes REST API calls to the target node: [5](#0-4) 

A malicious node operator can modify their node's REST API to return fake incremented sequence numbers when queried, causing the checker to believe transactions were committed when they were not. The committed count is calculated based on these sequence numbers: [6](#0-5) 

And then used to pass/fail the TPS check: [7](#0-6) 

## Impact Explanation
This is **HIGH** severity under the Aptos bug bounty program as it constitutes a "Significant protocol violation" in the node validation infrastructure. While it doesn't directly compromise consensus or steal funds, it allows:

1. Unqualified nodes to bypass TPS validation requirements
2. Malicious operators to gain validator admission or maintain validator status despite poor performance
3. Degradation of network quality if slow nodes are admitted based on fake metrics
4. Erosion of trust in the node health checking system

The node-checker is likely used for automated validator admission, monitoring, and reputation scoring - all security-relevant decisions.

## Likelihood Explanation
**HIGH likelihood** - The attack is trivial to execute:
1. Requires only modifying REST API responses from the target node
2. No cryptographic bypasses or complex state manipulation needed
3. Node operators already control their node's behavior
4. The TpsChecker has no baseline cross-validation mechanism unlike `TransactionCorrectnessChecker`

Any node operator can exploit this to pass TPS checks without actually meeting performance requirements.

## Recommendation
The TPS checker should implement cross-validation against a trusted baseline node or multiple independent nodes. Modify the cluster configuration to include baseline nodes:

```rust
let cluster_config = ClusterArgs {
    targets: Some({
        let mut targets = vec![target_url; self.config.repeat_target_count];
        // Add baseline nodes for cross-validation
        if let Some(baseline_url) = providers.baseline_api_index_provider
            .as_ref()
            .map(|p| p.client.build_path("/").unwrap()) {
            targets.push(baseline_url);
        }
        targets
    }),
    // ... rest of config
};
```

Then verify transaction commitment by querying random accounts on both target and baseline nodes, comparing sequence numbers match. Alternatively, query transaction hashes from the baseline node to confirm transactions exist on-chain.

## Proof of Concept

```rust
// Mock malicious node REST API implementation
use axum::{Router, routing::get, Json};
use std::sync::atomic::{AtomicU64, Ordering};

static FAKE_SEQUENCE: AtomicU64 = AtomicU64::new(0);

async fn fake_account_handler() -> Json<AccountResponse> {
    // Return fake incremented sequence number
    let seq = FAKE_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    Json(AccountResponse {
        sequence_number: seq,
        authentication_key: "0x00".to_string(),
    })
}

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route("/v1/accounts/:address", get(fake_account_handler));
    
    // Malicious node accepts transactions but never commits them
    // When node-checker queries sequence numbers, returns fake increments
    // TPS checker calculates high "committed" TPS based on fake data
    // Node passes validation without processing transactions
    
    axum::Server::bind(&"0.0.0.0:8080".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}
```

**Notes:**

This vulnerability specifically affects the node health checker's TPS validation mechanism. The `TransactionCorrectnessChecker` implements proper baseline validation by comparing accumulator root hashes between nodes, but the `TpsChecker` does not employ similar cross-validation. This creates an asymmetry where correctness is validated but performance metrics can be faked.

### Citations

**File:** ecosystem/node-checker/src/checker/tps.rs (L130-139)
```rust
        let cluster_config = ClusterArgs {
            targets: Some(vec![target_url; self.config.repeat_target_count]),
            targets_file: None,
            coin_source_args: self.config.coin_source_args.clone(),
            chain_id: Some(chain_id),
            node_api_key: None,
        };
        let cluster = Cluster::try_from_cluster_args(&cluster_config)
            .await
            .map_err(TpsCheckerError::BuildClusterError)?;
```

**File:** ecosystem/node-checker/src/checker/tps.rs (L164-176)
```rust
        let evaluation_result = if rate.committed >= (self.config.minimum_tps as f64) {
            if stats.committed == stats.submitted {
                description.push_str(
                    " Your node could theoretically hit \
                even higher TPS, the evaluation suite only tests to check \
                your node meets the minimum requirements.",
                );
            }
            Self::build_result(
                "Transaction processing speed is sufficient".to_string(),
                100,
                description,
            )
```

**File:** crates/transaction-emitter-lib/src/wrappers.rs (L100-101)
```rust
    let mut emit_job_request =
        EmitJobRequest::new(cluster.all_instances().map(Instance::rest_client).collect())
```

**File:** crates/transaction-emitter-lib/src/emitter/submission_worker.rs (L82-84)
```rust
    fn client(&self) -> &RestClient {
        &self.clients[self.main_client_index]
    }
```

**File:** crates/transaction-emitter-lib/src/emitter/submission_worker.rs (L303-311)
```rust
        let (latest_fetched_counts, sum_of_completion_timestamps_millis) =
            wait_for_accounts_sequence(
                start_time,
                self.client(),
                &account_to_start_and_end_seq_num,
                txn_expiration_ts_secs,
                check_account_sleep_duration,
            )
            .await;
```

**File:** crates/transaction-emitter-lib/src/emitter/submission_worker.rs (L436-465)
```rust
fn count_committed_expired_stats(
    account_to_start_and_end_seq_num: HashMap<AccountAddress, (u64, u64)>,
    latest_fetched_counts: HashMap<AccountAddress, u64>,
    account_to_orderless_txns: HashMap<AccountAddress, HashSet<HashValue>>,
    failed_orderless_txns: HashMap<AccountAddress, HashSet<HashValue>>,
) -> (usize, usize) {
    let (seq_num_committed, seq_num_failed) = account_to_start_and_end_seq_num
        .iter()
        .map(
            |(address, (start_seq_num, end_seq_num))| match latest_fetched_counts.get(address) {
                Some(count) => {
                    assert!(
                        *count <= *end_seq_num,
                        "{address} :: {count} > {end_seq_num}"
                    );
                    if *count >= *start_seq_num {
                        (
                            (*count - *start_seq_num) as usize,
                            (*end_seq_num - *count) as usize,
                        )
                    } else {
                        debug!(
                            "Stale sequence_number fetched for {}, start_seq_num {}, fetched {}",
                            address, start_seq_num, *count
                        );
                        (0, (*end_seq_num - *start_seq_num) as usize)
                    }
                },
                None => (0, (end_seq_num - start_seq_num) as usize),
            },
```

**File:** crates/transaction-emitter-lib/src/emitter/mod.rs (L1227-1236)
```rust
pub async fn get_account_seq_num(
    client: &RestClient,
    address: AccountAddress,
) -> Result<(u64, u64)> {
    let result = client.get_account_bcs(address).await;
    match &result {
        Ok(resp) => Ok((
            resp.inner().sequence_number(),
            Duration::from_micros(resp.state().timestamp_usecs).as_secs(),
        )),
```
