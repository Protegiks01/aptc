# Audit Report

## Title
Lack of Input Validation in write_pruner_progress() Enables Pruner State Corruption During Fast Sync

## Summary
The `write_pruner_progress()` function in multiple ledger database components lacks validation of the version parameter, allowing incorrect pruner progress to be persisted if called with a version that doesn't match the actual pruning state. This creates a denial-of-service condition where valid data becomes inaccessible.

## Finding Description

The `write_pruner_progress()` function across multiple database components performs no validation on the version parameter before persisting it as pruner progress: [1](#0-0) [2](#0-1) 

This function is called during fast sync finalization: [3](#0-2) 

The version originates from the state sync process and is assumed to match the restored state snapshot, but no validation enforces this assumption: [4](#0-3) 

When `write_pruner_progress()` is called through the ledger database wrapper, it updates ALL sub-pruner progress markers atomically: [5](#0-4) 

The stored `min_readable_version` is then used to reject read requests for "pruned" data: [6](#0-5) 

**Vulnerability Scenario:**

If due to a bug in the state sync layer, the version parameter passed to `finalize_state_snapshot()` doesn't match the actual restored snapshot version:

1. State snapshot is restored at version X (e.g., 1,000,000)
2. Due to a bug, `finalize_state_snapshot()` is called with version Y (e.g., 2,000,000)
3. All pruner progress markers are set to 2,000,000
4. `min_readable_version` = 2,000,000
5. Node continues operating and commits transactions at versions 1,000,001+
6. Read requests for these valid versions are rejected with "data pruned" errors
7. The node becomes unable to serve historical queries despite having the data

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria for the following reasons:

1. **Validator Node Slowdowns**: A validator with corrupted pruner state will reject valid read requests, degrading its ability to serve queries and participate in state synchronization with peers.

2. **API Crashes**: APIs relying on reading historical data will fail when attempting to access versions incorrectly marked as pruned.

3. **State Consistency Violation**: The system's recorded pruning state diverges from the actual database contents, violating the invariant that metadata must accurately reflect storage state.

The impact is limited to nodes that experience the bug during fast sync, not network-wide, which keeps this at High rather than Critical severity.

## Likelihood Explanation

Likelihood is **Medium** because:

1. **Requires a pre-existing bug**: This vulnerability cannot be directly exploited by an external attacker. It requires another bug in the state sync layer that causes version mismatches.

2. **Fast sync is common**: Fast sync is used by new nodes joining the network and during disaster recovery, making the vulnerable code path frequently executed.

3. **No safety checks**: The complete absence of validation means any bug causing version mismatches will propagate to corrupted pruner state.

4. **Difficult to detect**: Corrupted pruner progress may not be immediately obvious, as the node continues operating normally for new data.

## Recommendation

Add validation in `write_pruner_progress()` and `finalize_state_snapshot()` to ensure the version parameter is reasonable:

**For immediate defense**, add validation in `write_pruner_progress()`:
```rust
pub(super) fn write_pruner_progress(&self, version: Version) -> Result<()> {
    // Validate version is not wildly ahead of current ledger state
    if let Ok(Some(synced_version)) = self.db.get::<DbMetadataSchema>(&DbMetadataKey::LedgerCommitProgress) {
        let synced = synced_version.expect_version();
        ensure!(
            version <= synced,
            "Pruner progress version {} exceeds synced version {}",
            version,
            synced
        );
    }
    
    self.db.put::<DbMetadataSchema>(
        &DbMetadataKey::TransactionPrunerProgress,
        &DbMetadataValue::Version(version),
    )
}
```

**For root cause fix**, validate in `finalize_state_snapshot()` that the version matches the output_with_proof:
```rust
// Extract and validate version from transaction info
let txn_info_version = output_with_proof.proof.transaction_infos
    .first()
    .ok_or_else(|| AptosDbError::Other("No transaction info in proof".to_string()))?
    .version();
ensure!(
    version == txn_info_version,
    "Version parameter {} doesn't match transaction info version {}",
    version,
    txn_info_version
);
```

## Proof of Concept

```rust
#[test]
fn test_pruner_progress_corruption() {
    use aptos_temppath::TempPath;
    use aptos_storage_interface::DbWriter;
    
    // Create test database
    let tmpdir = TempPath::new();
    let db = AptosDB::new_for_test(&tmpdir);
    
    // Commit some transactions (e.g., up to version 100)
    // ... commit logic ...
    
    // Simulate fast sync with INCORRECT version
    let actual_snapshot_version = 100;
    let incorrect_version = 500; // BUG: version mismatch
    
    // This call should fail but doesn't due to lack of validation
    db.ledger_db.transaction_db().write_pruner_progress(incorrect_version).unwrap();
    
    // Verify corruption: min_readable_version is now 500
    let min_readable = db.ledger_pruner.get_min_readable_version();
    assert_eq!(min_readable, 500);
    
    // Attempt to read version 200 (which doesn't exist)
    // This should fail with "not found" but instead fails with "pruned"
    let result = db.get_transaction(200);
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("pruned"));
    // Expected error message should be "not found" not "pruned"
}
```

## Notes

While this vulnerability cannot be directly exploited by an external attacker (as it requires triggering a bug in state sync logic), it represents a critical defensive programming gap. The lack of validation means any future bug in the state sync layer will propagate to persistent storage corruption. Given that fast sync is a critical recovery mechanism, the lack of validation creates unnecessary fragility in the system.

The vulnerability specifically breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs" - the pruner metadata becomes inconsistent with actual database state.

### Citations

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L40-45)
```rust
    pub(super) fn write_pruner_progress(&self, version: Version) -> Result<()> {
        self.db.put::<DbMetadataSchema>(
            &DbMetadataKey::TransactionPrunerProgress,
            &DbMetadataValue::Version(version),
        )
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L57-62)
```rust
    pub(super) fn write_pruner_progress(&self, version: Version) -> Result<()> {
        self.db.put::<DbMetadataSchema>(
            &DbMetadataKey::LedgerPrunerProgress,
            &DbMetadataValue::Version(version),
        )
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L225-234)
```rust
            self.ledger_pruner.save_min_readable_version(version)?;
            self.state_store
                .state_merkle_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .epoch_snapshot_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .state_kv_pruner
                .save_min_readable_version(version)?;
```

**File:** storage/storage-interface/src/lib.rs (L596-597)
```rust
    /// Note: this assumes that the output with proof has already been verified and that the
    /// state snapshot was restored at the same version.
```

**File:** storage/aptosdb/src/ledger_db/mod.rs (L372-388)
```rust
    // Only expect to be used by fast sync when it is finished.
    pub(crate) fn write_pruner_progress(&self, version: Version) -> Result<()> {
        info!("Fast sync is done, writing pruner progress {version} for all ledger sub pruners.");
        self.event_db.write_pruner_progress(version)?;
        self.persisted_auxiliary_info_db
            .write_pruner_progress(version)?;
        self.transaction_accumulator_db
            .write_pruner_progress(version)?;
        self.transaction_auxiliary_data_db
            .write_pruner_progress(version)?;
        self.transaction_db.write_pruner_progress(version)?;
        self.transaction_info_db.write_pruner_progress(version)?;
        self.write_set_db.write_pruner_progress(version)?;
        self.ledger_metadata_db.write_pruner_progress(version)?;

        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L261-271)
```rust
    pub(super) fn error_if_ledger_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.ledger_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```
