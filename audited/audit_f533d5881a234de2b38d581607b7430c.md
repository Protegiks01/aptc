# Audit Report

## Title
Critical Liveness Failure: Unhandled State Fetch Errors in Remote State View Service Cause Indefinite Deadlock

## Summary
The `handle_message()` function in `RemoteStateViewService` uses `.unwrap()` on `get_state_value()` calls, causing thread panics when any state key fetch fails. This results in no response being sent to requesting shards, which wait indefinitely without timeout, leading to complete blockchain liveness failure.

## Finding Description

The vulnerability exists in the remote state view service used for sharded block execution. When a remote shard requests state values, the service attempts to fetch all requested keys in a single batch operation. [1](#0-0) 

The critical flaw is that `get_state_value()` returns a `StateViewResult<Option<StateValue>>`, which is a `Result` type that can fail with `StateViewError`. [2](#0-1) 

When `.unwrap()` is called on a failed result, the thread panics. Since this occurs in a thread pool worker spawned from the service's main loop [3](#0-2) , the panic is isolated to that worker thread, and **no response is ever sent** to the requesting shard.

On the client side, the requesting shard has already inserted state keys with `RemoteStateValue::waiting()` status. [4](#0-3) 

When the shard attempts to access these values, it calls `get_value()`, which blocks on a condition variable waiting for the value to become ready. [5](#0-4) 

**There is no timeout mechanism** - the condition variable waits indefinitely using `cvar.wait()` in a loop. Since the server thread panicked and never sent a response, `set_value()` is never called, the condition variable is never notified, and the execution thread blocks forever.

This breaks the **liveness invariant** - the blockchain cannot make forward progress when sharded execution is enabled.

**When this occurs:**
- Database I/O errors during state reads
- State corruption causing deserialization failures
- Race conditions during `set_state_view()`/`drop_state_view()` lifecycle
- Any error from underlying `StateView` implementations (NotFound, BcsError, Other)

## Impact Explanation

This is **Critical Severity** per Aptos bug bounty criteria: **"Total loss of liveness/network availability"**.

When the vulnerability triggers:
1. The requesting shard's execution thread blocks indefinitely
2. Block execution never completes
3. The entire blockchain halts - no new blocks can be produced
4. All validators using sharded execution are affected simultaneously
5. Recovery requires manual intervention (node restart)
6. No automatic detection or recovery mechanism exists

The issue affects all nodes running with sharded block execution enabled [6](#0-5) , which includes both local and remote sharded execution modes.

## Likelihood Explanation

**Likelihood: Medium to High**

This can occur through multiple realistic scenarios:

1. **Database I/O Errors**: Disk failures, storage corruption, or I/O timeouts are common in production systems
2. **Race Conditions**: The state view lifecycle involves `set_state_view()` before execution and `drop_state_view()` after [7](#0-6) . If timing issues cause requests to arrive during transitions, errors can occur
3. **State Corruption**: Any database corruption affecting state values will trigger BCS deserialization errors
4. **Natural Failures**: Hardware issues, memory errors, or network-related state synchronization problems

The vulnerability requires no attacker action - it can happen organically during normal operations under stress or failure conditions.

## Recommendation

**Immediate Fix:** Replace `.unwrap()` with proper error handling and partial response capability.

```rust
fn handle_message(
    message: Message,
    state_view: Arc<RwLock<Option<Arc<S>>>>,
    kv_tx: Arc<Vec<Sender<Message>>>,
) {
    let _timer = REMOTE_EXECUTOR_TIMER
        .with_label_values(&["0", "kv_requests"])
        .start_timer();
    let req: RemoteKVRequest = bcs::from_bytes(&message.data).unwrap();
    let (shard_id, state_keys) = req.into();
    
    let resp = state_keys
        .into_iter()
        .filter_map(|state_key| {
            match state_view
                .read()
                .ok()
                .and_then(|guard| guard.as_ref().cloned())
            {
                Some(view) => match view.get_state_value(&state_key) {
                    Ok(state_value) => Some((state_key, state_value)),
                    Err(e) => {
                        error!("Failed to get state value for key {:?}: {}", state_key, e);
                        // Return None for this key to signal unavailability
                        Some((state_key, None))
                    }
                },
                None => {
                    error!("State view not available for shard {}", shard_id);
                    Some((state_key, None))
                }
            }
        })
        .collect_vec();
    
    let resp = RemoteKVResponse::new(resp);
    let resp = bcs::to_bytes(&resp).unwrap();
    let message = Message::new(resp);
    kv_tx[shard_id].send(message).unwrap();
}
```

**Additional Recommendations:**
1. Add timeout mechanism to `RemoteStateValue::get_value()` using `wait_timeout()`
2. Implement retry logic with exponential backoff
3. Add monitoring/alerting for state fetch failures
4. Consider adding a circuit breaker pattern to fail fast on persistent errors

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::{Arc, RwLock};
    use aptos_types::state_store::{StateView, StateViewResult, TStateView, StateViewError};
    use aptos_types::state_store::state_key::StateKey;
    use aptos_types::state_store::state_value::StateValue;
    
    // Mock StateView that returns errors for specific keys
    struct FailingStateView {
        fail_pattern: String,
    }
    
    impl TStateView for FailingStateView {
        type Key = StateKey;
        
        fn get_state_value(&self, state_key: &StateKey) -> StateViewResult<Option<StateValue>> {
            // Simulate database error for keys containing the fail pattern
            if format!("{:?}", state_key).contains(&self.fail_pattern) {
                Err(StateViewError::Other("Simulated database I/O error".to_string()))
            } else {
                Ok(None)
            }
        }
        
        fn get_usage(&self) -> StateViewResult<StateStorageUsage> {
            Ok(StateStorageUsage::new_untracked())
        }
    }
    
    impl StateView for FailingStateView {}
    
    #[test]
    #[should_panic(expected = "Simulated database I/O error")]
    fn test_partial_failure_causes_panic() {
        // Setup
        let failing_view = Arc::new(FailingStateView {
            fail_pattern: "key_2".to_string(),
        });
        let state_view = Arc::new(RwLock::new(Some(failing_view)));
        
        // Create request with multiple keys, where one will fail
        let keys = vec![
            StateKey::raw(b"key_1"),
            StateKey::raw(b"key_2"), // This will fail
            StateKey::raw(b"key_3"),
        ];
        let request = RemoteKVRequest::new(0, keys);
        let message = Message::new(bcs::to_bytes(&request).unwrap());
        
        // This will panic when it hits the failing key
        // In production, this panic happens in a thread pool worker,
        // so no response is sent and the client waits forever
        let (tx, _rx) = crossbeam_channel::unbounded();
        RemoteStateViewService::handle_message(
            message,
            state_view,
            Arc::new(vec![tx]),
        );
    }
}
```

**Notes**

This vulnerability demonstrates a critical failure in error handling for distributed state fetching. The all-or-nothing approach combined with lack of timeout mechanisms creates a severe availability risk. The fix requires both proper error propagation and defensive timeout strategies to ensure blockchain liveness even under partial failure conditions.

### Citations

**File:** execution/executor-service/src/remote_state_view_service.rs (L64-72)
```rust
    pub fn start(&self) {
        while let Ok(message) = self.kv_rx.recv() {
            let state_view = self.state_view.clone();
            let kv_txs = self.kv_tx.clone();
            self.thread_pool.spawn(move || {
                Self::handle_message(message, state_view, kv_txs);
            });
        }
    }
```

**File:** execution/executor-service/src/remote_state_view_service.rs (L95-107)
```rust
        let resp = state_keys
            .into_iter()
            .map(|state_key| {
                let state_value = state_view
                    .read()
                    .unwrap()
                    .as_ref()
                    .unwrap()
                    .get_state_value(&state_key)
                    .unwrap();
                (state_key, state_value)
            })
            .collect_vec();
```

**File:** types/src/state_store/errors.rs (L6-15)
```rust
#[derive(Debug, Error)]
pub enum StateViewError {
    #[error("{0} not found.")]
    NotFound(String),
    /// Other non-classified error.
    #[error("{0}")]
    Other(String),
    #[error(transparent)]
    BcsError(#[from] bcs::Error),
}
```

**File:** execution/executor-service/src/remote_state_view.rs (L126-135)
```rust
    fn insert_keys_and_fetch_values(
        state_view_clone: Arc<RwLock<RemoteStateView>>,
        thread_pool: Arc<ThreadPool>,
        kv_tx: Arc<Sender<Message>>,
        shard_id: ShardId,
        state_keys: Vec<StateKey>,
    ) {
        state_keys.clone().into_iter().for_each(|state_key| {
            state_view_clone.read().unwrap().insert_state_key(state_key);
        });
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L29-39)
```rust
    pub fn get_value(&self) -> Option<StateValue> {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        while let RemoteValueStatus::Waiting = *status {
            status = cvar.wait(status).unwrap();
        }
        match &*status {
            RemoteValueStatus::Ready(value) => value.clone(),
            RemoteValueStatus::Waiting => unreachable!(),
        }
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L180-212)
```rust
    fn execute_block(
        &self,
        state_view: Arc<S>,
        transactions: PartitionedTransactions,
        concurrency_level_per_shard: usize,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<ShardedExecutionOutput, VMStatus> {
        trace!("RemoteExecutorClient Sending block to shards");
        self.state_view_service.set_state_view(state_view);
        let (sub_blocks, global_txns) = transactions.into();
        if !global_txns.is_empty() {
            panic!("Global transactions are not supported yet");
        }
        for (shard_id, sub_blocks) in sub_blocks.into_iter().enumerate() {
            let senders = self.command_txs.clone();
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
        }

        let execution_results = self.get_output_from_shards()?;

        self.state_view_service.drop_state_view();
        Ok(ShardedExecutionOutput::new(execution_results, vec![]))
    }
```
