# Audit Report

## Title
Lock Poisoning in CommitSignerProvider Causes Permanent Validator Liveness Loss

## Summary
The `Mutex<MetricsSafetyRules>` implementation of `CommitSignerProvider` uses `aptos_infallible::Mutex`, which panics on poisoned locks. If any panic occurs during commit signature generation, the lock becomes permanently poisoned, preventing all future commit signatures and causing total loss of validator liveness until node restart. [1](#0-0) 

## Finding Description
The consensus pipeline uses a shared `Mutex<MetricsSafetyRules>` instance as the `CommitSignerProvider` for an entire epoch. This mutex is created during epoch initialization: [2](#0-1) [3](#0-2) [4](#0-3) 

The mutex uses `aptos_infallible::Mutex`, which has a critical design flaw - it panics when encountering a poisoned lock: [5](#0-4) 

**Attack Scenario:**

1. The `SigningPhase` runs continuously processing commit signature requests: [6](#0-5) 

2. During signature generation, the lock is acquired and `sign_commit_vote()` is called: [7](#0-6) 

3. If ANY panic occurs while holding the lock (during execution of the internal `sign_commit_vote()`, `perform_initialize()`, or safety rules operations), the lock guard is dropped and the mutex becomes poisoned.

4. The next attempt to acquire the lock calls `.expect()` on the poisoned lock, which **panics immediately**: [8](#0-7) 

5. The `SigningPhase` task terminates and cannot be restarted: [9](#0-8) 

6. All future commit signature attempts fail, causing **permanent validator liveness loss**.

**Potential Panic Triggers:**

While the code uses proper error handling with `?` operators, panics can still occur from:
- Arithmetic overflow in debug builds
- Index out of bounds in any data structure access
- Bugs in third-party dependencies (BLS signature libraries, serialization, etc.)
- Resource exhaustion (OOM, stack overflow) during complex operations
- Assertion failures in safety-critical code paths
- Undiscovered edge cases in validation logic

The signing path involves complex operations including epoch change proof retrieval, ledger info validation, signature verification, and cryptographic signing - each with multiple opportunities for unexpected panics. [10](#0-9) [11](#0-10) 

## Impact Explanation

This is a **Critical severity** vulnerability meeting the "Total loss of liveness/network availability" category from the Aptos bug bounty program.

**Impact:**
- **Validator incapacitation**: The affected validator cannot sign commit votes for the remainder of the epoch
- **Consensus participation loss**: The validator cannot contribute to consensus finalization
- **Network degradation**: If multiple validators are affected, consensus may slow or halt
- **No automatic recovery**: Requires manual node restart to restore functionality
- **Persistent until restart**: Unlike transient errors, lock poisoning is permanent

The vulnerability breaks the **liveness invariant** of consensus - validators must be able to continuously participate in block finalization. A single transient panic causes catastrophic and irreversible damage.

## Likelihood Explanation

**Likelihood: Medium to High**

While Rust's strong safety guarantees make panics relatively rare, the consequences are catastrophic:

1. **High complexity operations**: The signing path involves epoch initialization, storage access, signature verification, and cryptographic operations - all potential panic sources

2. **Resource exhaustion vulnerability**: Under heavy load or adversarial conditions, OOM or stack overflow panics become more likely

3. **Dependency risk**: Third-party cryptographic and serialization libraries may have undiscovered panic paths

4. **No fault tolerance**: Even a SINGLE transient panic during the entire epoch causes permanent damage

5. **Long-running exposure**: The same `Mutex` instance is used throughout an entire epoch, maximizing exposure time

The security model assumes validators should tolerate transient failures gracefully. This design violates that principle - any momentary panic (from bugs, resource exhaustion, or environmental conditions) causes permanent validator incapacitation.

## Recommendation

**Option 1: Handle Poison Errors Gracefully**

Replace `aptos_infallible::Mutex` with standard `std::sync::Mutex` and handle `PoisonError`:

```rust
impl CommitSignerProvider for Mutex<MetricsSafetyRules> {
    fn sign_commit_vote(
        &self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        let mut guard = self.lock().unwrap_or_else(|poisoned| {
            error!("SafetyRules mutex poisoned, recovering by taking ownership");
            poisoned.into_inner()
        });
        guard.sign_commit_vote(ledger_info, new_ledger_info)
    }
}
```

**Option 2: Recreate SafetyRules on Poisoning**

Maintain the ability to recreate `MetricsSafetyRules` and replace the poisoned instance:

```rust
pub struct RecoverableCommitSigner {
    safety_rules: Arc<Mutex<MetricsSafetyRules>>,
    safety_rules_factory: Box<dyn Fn() -> MetricsSafetyRules>,
}

impl CommitSignerProvider for RecoverableCommitSigner {
    fn sign_commit_vote(...) -> Result<...> {
        match self.safety_rules.lock() {
            Ok(mut guard) => guard.sign_commit_vote(...),
            Err(_) => {
                warn!("SafetyRules poisoned, recreating...");
                let new_rules = (self.safety_rules_factory)();
                *self.safety_rules = Arc::new(Mutex::new(new_rules));
                self.safety_rules.lock().unwrap().sign_commit_vote(...)
            }
        }
    }
}
```

**Option 3: Panic Catching Wrapper**

Wrap the signing operation in panic catching logic:

```rust
use std::panic::{catch_unwind, AssertUnwindSafe};

impl CommitSignerProvider for Mutex<MetricsSafetyRules> {
    fn sign_commit_vote(...) -> Result<...> {
        catch_unwind(AssertUnwindSafe(|| {
            self.lock().sign_commit_vote(ledger_info, new_ledger_info)
        }))
        .map_err(|_| Error::InternalError("Panic during signing".into()))?
    }
}
```

**Recommended Approach**: Option 1 is simplest and most robust - properly handling poison errors allows the system to continue operating even after transient panics.

## Proof of Concept

```rust
#[cfg(test)]
mod lock_poisoning_poc {
    use super::*;
    use std::sync::Arc;
    use std::thread;
    
    #[test]
    #[should_panic(expected = "Cannot currently handle a poisoned lock")]
    fn test_lock_poisoning_causes_permanent_failure() {
        use aptos_infallible::Mutex;
        
        // Simulate MetricsSafetyRules wrapped in Mutex
        let safety_rules = Arc::new(Mutex::new(MockSafetyRules::new()));
        
        let safety_rules_clone = safety_rules.clone();
        
        // Thread 1: Panic while holding the lock
        let handle = thread::spawn(move || {
            let _guard = safety_rules_clone.lock();
            // Simulate a panic during sign_commit_vote
            panic!("Simulated panic during signing operation");
        });
        
        // Wait for thread to panic and poison the lock
        let _ = handle.join();
        
        // Thread 2: Try to sign commit - this will panic due to poisoned lock
        // In production, this would be the SigningPhase task attempting to sign
        let _guard = safety_rules.lock(); // <- PANICS HERE with "Cannot currently handle a poisoned lock"
        
        // This line is never reached - validator is now permanently disabled
        // until node restart
    }
    
    struct MockSafetyRules;
    impl MockSafetyRules {
        fn new() -> Self { Self }
    }
}
```

**To demonstrate in the actual codebase**, inject a panic in the signing path:

```rust
// In consensus/src/metrics_safety_rules.rs, line 144
fn sign_commit_vote(
    &mut self,
    ledger_info: LedgerInfoWithSignatures,
    new_ledger_info: LedgerInfo,
) -> Result<bls12381::Signature, Error> {
    self.retry(|inner| {
        // Inject panic to simulate bug/resource exhaustion
        if rand::random::<f64>() < 0.01 { // 1% chance
            panic!("Simulated panic - could be OOM, assertion failure, etc.");
        }
        monitor!(
            "safety_rules",
            inner.sign_commit_vote(ledger_info.clone(), new_ledger_info.clone())
        )
    })
}
```

After the first panic, all subsequent signing attempts will fail permanently, proving total liveness loss.

## Notes

The explicit use of `aptos_infallible::Mutex` with the message "Cannot currently handle a poisoned lock" suggests developers are aware of this limitation but have not yet implemented proper recovery. This represents a critical gap in fault tolerance that violates the principle that validators should gracefully handle transient errors. The fix is straightforward and should be implemented before any panic-inducing bugs are discovered in production.

### Citations

**File:** consensus/src/metrics_safety_rules.rs (L40-69)
```rust
    pub fn perform_initialize(&mut self) -> Result<(), Error> {
        let consensus_state = self.consensus_state()?;
        let mut waypoint_version = consensus_state.waypoint().version();
        loop {
            let proofs = self
                .storage
                .retrieve_epoch_change_proof(waypoint_version)
                .map_err(|e| {
                    Error::InternalError(format!(
                        "Unable to retrieve Waypoint state from storage, encountered Error:{}",
                        e
                    ))
                })?;
            // We keep initializing safety rules as long as the waypoint continues to increase.
            // This is due to limits in the number of epoch change proofs that storage can provide.
            match self.initialize(&proofs) {
                Err(Error::WaypointOutOfDate(
                    prev_version,
                    curr_version,
                    current_epoch,
                    provided_epoch,
                )) if prev_version < curr_version => {
                    waypoint_version = curr_version;
                    info!("Previous waypoint version {}, updated version {}, current epoch {}, provided epoch {}", prev_version, curr_version, current_epoch, provided_epoch);
                    continue;
                },
                result => return result,
            }
        }
    }
```

**File:** consensus/src/metrics_safety_rules.rs (L153-161)
```rust
impl CommitSignerProvider for Mutex<MetricsSafetyRules> {
    fn sign_commit_vote(
        &self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.lock().sign_commit_vote(ledger_info, new_ledger_info)
    }
}
```

**File:** consensus/src/epoch_manager.rs (L828-829)
```rust
        let mut safety_rules =
            MetricsSafetyRules::new(self.safety_rules_manager.client(), self.storage.clone());
```

**File:** consensus/src/epoch_manager.rs (L862-862)
```rust
        let safety_rules_container = Arc::new(Mutex::new(safety_rules));
```

**File:** consensus/src/epoch_manager.rs (L868-868)
```rust
                safety_rules_container.clone(),
```

**File:** crates/aptos-infallible/src/mutex.rs (L19-23)
```rust
    pub fn lock(&self) -> MutexGuard<'_, T> {
        self.0
            .lock()
            .expect("Cannot currently handle a poisoned lock")
    }
```

**File:** consensus/src/pipeline/execution_client.rs (L514-514)
```rust
        tokio::spawn(signing_phase.start());
```

**File:** consensus/src/pipeline/pipeline_phase.rs (L88-108)
```rust
    pub async fn start(mut self) {
        // main loop
        while let Some(counted_req) = self.rx.next().await {
            let CountedRequest { req, guard: _guard } = counted_req;
            if self.reset_flag.load(Ordering::SeqCst) {
                continue;
            }
            let response = {
                let _timer = BUFFER_MANAGER_PHASE_PROCESS_SECONDS
                    .with_label_values(&[T::NAME])
                    .start_timer();
                self.processor.process(req).await
            };
            if let Some(tx) = &mut self.maybe_tx {
                if tx.send(response).await.is_err() {
                    debug!("Failed to send response, buffer manager probably dropped");
                    break;
                }
            }
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```
