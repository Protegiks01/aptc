# Audit Report

## Title
Version Spoofing in view_apt_account_balance_at_version() - Client Does Not Validate Returned Version Matches Request

## Summary
The `view_apt_account_balance_at_version()` function in the Aptos REST client does not validate that the balance returned by the server corresponds to the requested ledger version. This allows a malicious or compromised server to return balance data from any version while the client blindly accepts it.

## Finding Description

The `view_apt_account_balance_at_version()` function is designed to retrieve an account's APT balance at a specific historical ledger version. However, the client implementation lacks validation to ensure the server actually returned data from the requested version. [1](#0-0) 

The function calls `view_account_balance_bcs_impl()` which internally uses `view_bcs()`: [2](#0-1) 

The `view_bcs()` function constructs a URL with the requested version as a query parameter and sends the request to the server: [3](#0-2) 

After receiving the response, the client parses it through `check_and_parse_bcs_response()`: [4](#0-3) 

The response headers are parsed into a `State` object that includes the version: [5](#0-4) 

**Critical Issue**: The client never validates that `state.version` matches the `requested_version` parameter passed to `view_apt_account_balance_at_version()`.

Furthermore, examining the server-side implementation reveals a concerning pattern. The server's `get_latest_ledger_info_and_verify_lookup_version()` function returns the LATEST ledger info in response headers, not the requested version's info: [6](#0-5) 

This means the server correctly retrieves data at the requested version but sets the `X-Aptos-Ledger-Version` response header to the LATEST version, creating inherent version ambiguity.

## Impact Explanation

This vulnerability enables **version spoofing attacks** with the following impacts:

1. **Malicious Server Scenario**: A compromised or malicious REST API server can return balance data from any arbitrary version (e.g., an old version showing higher balance) while the client accepts it without validation. This could lead to:
   - Users making financial decisions based on incorrect balance information
   - Smart contracts or applications that rely on historical balance queries being manipulated
   - Potential for financial loss if downstream logic depends on accurate version-specific data

2. **Man-in-the-Middle (MITM) Scenario**: An attacker intercepting API traffic could:
   - Modify the response data to show balances from different versions
   - Alter version headers without client detection
   - Create inconsistencies between what the client requested and what it received

3. **Server Bug Amplification**: The current implementation where the server returns latest version in headers but data from requested version creates confusion that could be exploited if server bugs exist.

This qualifies as **High Severity** under the Aptos bug bounty program as it represents a significant protocol violation - the REST API client contract promises version-specific queries but cannot enforce this guarantee, potentially enabling API manipulation attacks.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability can be triggered in the following scenarios:

1. **Malicious Infrastructure**: If an attacker compromises or deploys a malicious Aptos REST API endpoint and convinces users/applications to connect to it
2. **Network-Level Attacks**: MITM attacks on unencrypted or improperly secured API connections
3. **Insider Threats**: Malicious node operators running modified server implementations
4. **Server Implementation Bugs**: Bugs in the official server implementation that cause it to return wrong version data

While the attack requires some infrastructure control, the impact is significant and the client-side validation gap makes exploitation straightforward once access is obtained.

## Recommendation

Add client-side validation to ensure the returned version matches the requested version:

```rust
pub async fn view_apt_account_balance_at_version(
    &self,
    address: AccountAddress,
    version: u64,
) -> AptosResult<Response<u64>> {
    let response = self
        .view_account_balance_bcs_impl(address, "0x1::aptos_coin::AptosCoin", Some(version))
        .await?;
    
    // VALIDATION: Ensure returned version matches requested version
    if response.state().version != version {
        return Err(RestError::Unknown(anyhow!(
            "Version mismatch: requested version {} but server returned data at version {}",
            version,
            response.state().version
        )));
    }
    
    Ok(response)
}
```

Additionally, the server should be fixed to return the requested version in the response headers instead of the latest version:

```rust
// In api/src/context.rs, create a new function:
pub fn get_ledger_info_at_version<E: StdApiError>(
    &self,
    requested_ledger_version: Version,
) -> Result<LedgerInfo, E> {
    // Create LedgerInfo for the specific requested version
    // instead of always returning latest
}
```

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_version_spoofing_vulnerability() {
    use aptos_rest_client::Client;
    use aptos_types::account_address::AccountAddress;
    
    // Connect to a test server
    let client = Client::new(test_server_url());
    
    let address = AccountAddress::from_hex_literal("0x1").unwrap();
    let requested_version = 1000u64;
    
    // Request balance at version 1000
    let response = client
        .view_apt_account_balance_at_version(address, requested_version)
        .await
        .unwrap();
    
    let returned_version = response.state().version;
    let balance = response.into_inner();
    
    // VULNERABILITY: Client does not validate version match
    // If server is malicious, returned_version != requested_version
    // but client still accepts the balance value
    
    println!("Requested version: {}", requested_version);
    println!("Returned version: {}", returned_version);
    println!("Balance: {}", balance);
    
    // This assertion would FAIL with current implementation
    // when server returns latest version in headers
    assert_eq!(returned_version, requested_version, 
        "Version mismatch detected - potential spoofing attack!");
}
```

## Notes

The vulnerability has two components:
1. **Client-side**: Missing validation (primary issue)
2. **Server-side**: Ambiguous version semantics in response headers (contributing factor)

Both should be addressed to fully secure version-specific queries. The client MUST validate returned versions match requests to maintain the security invariant that historical queries return data from the specified version.

### Citations

**File:** crates/aptos-rest-client/src/lib.rs (L340-367)
```rust
    pub async fn view_account_balance_bcs_impl(
        &self,
        address: AccountAddress,
        coin_type: &str,
        version: Option<u64>,
    ) -> AptosResult<Response<u64>> {
        let resp: Response<Vec<u64>> = self
            .view_bcs(
                &ViewFunction {
                    module: ModuleId::new(AccountAddress::ONE, ident_str!("coin").into()),
                    function: ident_str!("balance").into(),
                    ty_args: vec![TypeTag::Struct(Box::new(
                        StructTag::from_str(coin_type).unwrap(),
                    ))],
                    args: vec![bcs::to_bytes(&address).unwrap()],
                },
                version,
            )
            .await?;

        resp.and_then(|result| {
            if result.len() != 1 {
                Err(anyhow!("Wrong data size returned: {:?}", result).into())
            } else {
                Ok(result[0])
            }
        })
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L369-376)
```rust
    pub async fn view_apt_account_balance_at_version(
        &self,
        address: AccountAddress,
        version: u64,
    ) -> AptosResult<Response<u64>> {
        self.view_account_balance_bcs_impl(address, "0x1::aptos_coin::AptosCoin", Some(version))
            .await
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L438-460)
```rust
    pub async fn view_bcs<T: DeserializeOwned>(
        &self,
        request: &ViewFunction,
        version: Option<u64>,
    ) -> AptosResult<Response<T>> {
        let txn_payload = bcs::to_bytes(request)?;
        let mut url = self.build_path("view")?;
        if let Some(version) = version {
            url.set_query(Some(format!("ledger_version={}", version).as_str()));
        }

        let response = self
            .inner
            .post(url)
            .header(CONTENT_TYPE, BCS_VIEW_FUNCTION)
            .header(ACCEPT, BCS)
            .body(txn_payload)
            .send()
            .await?;

        let response = self.check_and_parse_bcs_response(response).await?;
        Ok(response.and_then(|bytes| bcs::from_bytes(&bytes))?)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1773-1779)
```rust
    async fn check_and_parse_bcs_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<Response<bytes::Bytes>> {
        let (response, state) = self.check_response(response).await?;
        Ok(Response::new(response.bytes().await?, state))
    }
```

**File:** crates/aptos-rest-client/src/state.rs (L22-102)
```rust
impl State {
    pub fn from_headers(headers: &reqwest::header::HeaderMap) -> anyhow::Result<Self> {
        let maybe_chain_id = headers
            .get(X_APTOS_CHAIN_ID)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_version = headers
            .get(X_APTOS_LEDGER_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_timestamp = headers
            .get(X_APTOS_LEDGER_TIMESTAMP)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_epoch = headers
            .get(X_APTOS_EPOCH)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_ledger_version = headers
            .get(X_APTOS_LEDGER_OLDEST_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_block_height = headers
            .get(X_APTOS_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_block_height = headers
            .get(X_APTOS_OLDEST_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let cursor = headers
            .get(X_APTOS_CURSOR)
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string());

        let state = if let (
            Some(chain_id),
            Some(version),
            Some(timestamp_usecs),
            Some(epoch),
            Some(oldest_ledger_version),
            Some(block_height),
            Some(oldest_block_height),
            cursor,
        ) = (
            maybe_chain_id,
            maybe_version,
            maybe_timestamp,
            maybe_epoch,
            maybe_oldest_ledger_version,
            maybe_block_height,
            maybe_oldest_block_height,
            cursor,
        ) {
            Self {
                chain_id,
                epoch,
                version,
                timestamp_usecs,
                oldest_ledger_version,
                block_height,
                oldest_block_height,
                cursor,
            }
        } else {
            anyhow::bail!(
                "Failed to build State from headers due to missing values in response. \
                Chain ID: {:?}, Version: {:?}, Timestamp: {:?}, Epoch: {:?}, \
                Oldest Ledger Version: {:?}, Block Height: {:?} Oldest Block Height: {:?}",
                maybe_chain_id,
                maybe_version,
                maybe_timestamp,
                maybe_epoch,
                maybe_oldest_ledger_version,
                maybe_block_height,
                maybe_oldest_block_height,
            )
        };

        Ok(state)
    }
```

**File:** api/src/context.rs (L294-317)
```rust
    pub fn get_latest_ledger_info_and_verify_lookup_version<E: StdApiError>(
        &self,
        requested_ledger_version: Option<Version>,
    ) -> Result<(LedgerInfo, Version), E> {
        let latest_ledger_info = self.get_latest_ledger_info()?;

        let requested_ledger_version =
            requested_ledger_version.unwrap_or_else(|| latest_ledger_info.version());

        // This is too far in the future, a retriable case
        if requested_ledger_version > latest_ledger_info.version() {
            return Err(version_not_found(
                requested_ledger_version,
                &latest_ledger_info,
            ));
        } else if requested_ledger_version < latest_ledger_info.oldest_ledger_version.0 {
            return Err(version_pruned(
                requested_ledger_version,
                &latest_ledger_info,
            ));
        }

        Ok((latest_ledger_info, requested_ledger_version))
    }
```
