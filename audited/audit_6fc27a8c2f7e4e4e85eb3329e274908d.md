# Audit Report

## Title
Validator Crash Due to Unhandled RocksDB IO Errors in BlockInfoSchema Write Path

## Summary
The AptosDB writer uses `.unwrap()` calls on RocksDB write operations in parallel threads, causing validator nodes to panic and crash instead of gracefully handling IO errors. When RocksDB returns IO errors during BlockInfoSchema writes (e.g., due to disk full, filesystem corruption, or hardware failures), the validator process terminates abruptly.

## Finding Description
The vulnerability exists in the storage commit path where block metadata is persisted to disk. During consensus block commitment, the system writes BlockInfoSchema data to RocksDB as part of the ledger metadata batch. [1](#0-0) 

The code spawns multiple parallel threads to commit different database components. Each spawn uses `.unwrap()` to handle the Result type: [2](#0-1) 

Inside `commit_state_kv_and_ledger_metadata`, another level of parallelization occurs with additional `.unwrap()` calls: [3](#0-2) 

The `write_schemas` method can fail with IO errors from RocksDB: [4](#0-3) 

RocksDB IO errors are explicitly mapped to AptosDbError: [5](#0-4) 

The developers have acknowledged this issue with a TODO comment: [6](#0-5) 

**Attack Path:**
1. Consensus reaches block commitment through `BlockExecutor::pre_commit_block()`
2. Calls `AptosDB::pre_commit_ledger()` 
3. Invokes `calculate_and_commit_ledger_and_state_kv()`
4. Spawns `commit_state_kv_and_ledger_metadata()` with `.unwrap()`
5. Inside that function, spawns `write_schemas()` with `.unwrap()`
6. If RocksDB encounters IO error (disk full, corruption, hardware failure), returns Err
7. The `.unwrap()` panics, crashing the validator thread and process

**Broken Invariants:**
- **Fault Tolerance**: Validators should degrade gracefully under operational failures
- **State Consistency**: Partial writes during panic can leave database in inconsistent state
- **Liveness**: Multiple validators experiencing disk issues can impact network liveness

## Impact Explanation
This issue falls under **Medium Severity** per the Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: A crash during commit can leave the database partially written, requiring manual recovery
- **Validator downtime**: Affected validators stop participating in consensus until restarted

While validator crashes are serious, this does not directly cause:
- Loss of funds (no theft or unauthorized minting)
- Consensus safety violations (no double-spending or chain splits)
- Network-wide partition (only affects validators with disk issues)

The impact is contained to operational reliability rather than protocol-level security.

## Likelihood Explanation
**Likelihood: Medium-Low**

Common triggering conditions:
- **Disk full**: High transaction volume or insufficient disk space provisioning
- **Hardware failures**: SSD failures, bad sectors, controller issues
- **Filesystem corruption**: Unexpected shutdowns, kernel bugs
- **I/O errors**: Storage device disconnection, NFS failures

These are operational issues that occur in production systems, but not exploitable by network attackers without system-level access. The issue is more about robustness and operational reliability than direct security exploitation.

## Recommendation
Replace all `.unwrap()` calls in the commit path with proper error propagation:

```rust
// In calculate_and_commit_ledger_and_state_kv()
THREAD_MANAGER.get_non_exe_cpu_pool().scope(|s| {
    let mut results = Vec::new();
    
    results.push(s.spawn(|_| {
        self.commit_events(chunk.first_version, chunk.transaction_outputs, skip_index_and_usage)
    }));
    
    results.push(s.spawn(|_| {
        self.commit_state_kv_and_ledger_metadata(chunk, skip_index_and_usage)
    }));
    
    // ... other spawns ...
});

// Collect results and propagate first error
for result in results {
    result.join().unwrap()?;  // Propagate error up the call chain
}
```

For the inner rayon scope:

```rust
// In commit_state_kv_and_ledger_metadata()
let mut ledger_result = Ok(());
let mut state_result = Ok(());

rayon::scope(|s| {
    s.spawn(|_| {
        ledger_result = self.ledger_db.metadata_db().write_schemas(ledger_metadata_batch);
    });
    s.spawn(|_| {
        state_result = self.state_kv_db.commit(chunk.expect_last_version(), None, sharded_state_kv_batches);
    });
});

ledger_result?;
state_result?;
```

This allows errors to propagate to `pre_commit_ledger()` which returns `Result<()>`, enabling the caller to handle the error gracefully (retry, log, alert) rather than crashing.

## Proof of Concept

```rust
// Rust test demonstrating the panic behavior
#[cfg(test)]
mod test {
    use super::*;
    use tempfile::TempDir;
    
    #[test]
    #[should_panic(expected = "IO error")]
    fn test_rocksdb_io_error_causes_panic() {
        let tmpdir = TempDir::new().unwrap();
        let db_path = tmpdir.path();
        
        // Create a DB
        let db = DB::open(db_path, "test_db", vec!["test_cf"], &Options::default()).unwrap();
        
        // Simulate disk full by making filesystem read-only
        // (In real scenario, this would be actual disk full)
        std::fs::set_permissions(db_path, std::fs::Permissions::from_mode(0o444)).unwrap();
        
        let mut batch = SchemaBatch::new();
        batch.put::<BlockInfoSchema>(&1u64, &test_block_info()).unwrap();
        
        // This will panic instead of returning Err
        db.write_schemas(batch).unwrap(); // PANICS HERE
    }
}
```

To reproduce in production environment:
1. Fill validator's disk to near capacity
2. Run high transaction throughput to trigger frequent commits
3. Observe validator crashes with panic messages related to RocksDB write failures
4. Check logs for "No space left on device" or similar IO errors before the crash

## Notes

**Read Path is Safe**: The read operations for BlockInfoSchema properly use `?` operator for error propagation: [7](#0-6) [8](#0-7) 

The issue is isolated to the write path in `aptosdb_writer.rs` where parallel commits use `.unwrap()` for performance optimization at the cost of robustness.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L271-319)
```rust
        THREAD_MANAGER.get_non_exe_cpu_pool().scope(|s| {
            // TODO(grao): Write progress for each of the following databases, and handle the
            // inconsistency at the startup time.
            //
            // TODO(grao): Consider propagating the error instead of panic, if necessary.
            s.spawn(|_| {
                self.commit_events(
                    chunk.first_version,
                    chunk.transaction_outputs,
                    skip_index_and_usage,
                )
                .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .write_set_db()
                    .commit_write_sets(chunk.first_version, chunk.transaction_outputs)
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .transaction_db()
                    .commit_transactions(
                        chunk.first_version,
                        chunk.transactions,
                        skip_index_and_usage,
                    )
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .persisted_auxiliary_info_db()
                    .commit_auxiliary_info(chunk.first_version, chunk.persisted_auxiliary_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_state_kv_and_ledger_metadata(chunk, skip_index_and_usage)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_transaction_infos(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                new_root_hash = self
                    .commit_transaction_accumulator(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
        });
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L369-381)
```rust
        rayon::scope(|s| {
            s.spawn(|_| {
                self.ledger_db
                    .metadata_db()
                    .write_schemas(ledger_metadata_batch)
                    .unwrap();
            });
            s.spawn(|_| {
                self.state_kv_db
                    .commit(chunk.expect_last_version(), None, sharded_state_kv_batches)
                    .unwrap();
            });
        });
```

**File:** storage/schemadb/src/lib.rs (L289-304)
```rust
    fn write_schemas_inner(&self, batch: impl IntoRawBatch, option: &WriteOptions) -> DbResult<()> {
        let labels = [self.name.as_str()];
        let _timer = APTOS_SCHEMADB_BATCH_COMMIT_LATENCY_SECONDS.timer_with(&labels);

        let raw_batch = batch.into_raw_batch(self)?;

        let serialized_size = raw_batch.inner.size_in_bytes();
        self.inner
            .write_opt(raw_batch.inner, option)
            .into_db_res()?;

        raw_batch.stats.commit();
        APTOS_SCHEMADB_BATCH_COMMIT_BYTES.observe_with(&[&self.name], serialized_size as f64);

        Ok(())
    }
```

**File:** storage/schemadb/src/lib.rs (L389-408)
```rust
fn to_db_err(rocksdb_err: rocksdb::Error) -> AptosDbError {
    match rocksdb_err.kind() {
        ErrorKind::Incomplete => AptosDbError::RocksDbIncompleteResult(rocksdb_err.to_string()),
        ErrorKind::NotFound
        | ErrorKind::Corruption
        | ErrorKind::NotSupported
        | ErrorKind::InvalidArgument
        | ErrorKind::IOError
        | ErrorKind::MergeInProgress
        | ErrorKind::ShutdownInProgress
        | ErrorKind::TimedOut
        | ErrorKind::Aborted
        | ErrorKind::Busy
        | ErrorKind::Expired
        | ErrorKind::TryAgain
        | ErrorKind::CompactionTooLarge
        | ErrorKind::ColumnFamilyDropped
        | ErrorKind::Unknown => AptosDbError::OtherRocksDbError(rocksdb_err.to_string()),
    }
}
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L265-267)
```rust
    pub(crate) fn get_block_info(&self, block_height: u64) -> Result<Option<BlockInfo>> {
        self.db.get::<BlockInfoSchema>(&block_height)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L330-337)
```rust
            Ok(self
                .ledger_db
                .metadata_db()
                .get_block_info(block_height)?
                .ok_or_else(|| {
                    AptosDbError::NotFound(format!("BlockInfo not found at height {block_height}"))
                })?)
        }
```
