# Audit Report

## Title
Type Confusion Vulnerability in Deserialized Closure Execution via Missing Layout Validation

## Summary
The Move VM runtime fails to validate that `captured_layouts` from deserialized closures match the actual function signature when resolving lazy-loaded functions. This allows type-confused values to be passed as function arguments during closure invocation, bypassing Move's type safety guarantees. The vulnerability creates a critical defense-in-depth failure that could enable type confusion attacks if combined with storage manipulation vectors.

## Finding Description

The vulnerability exists in the closure deserialization and resolution flow. When a closure is created via `PackClosure`, type checking ensures captured arguments match the function signature. However, when a closure is **deserialized from storage** and later called, the runtime trusts the `captured_layouts` field without validating it against the actual function signature.

**Vulnerable Flow:**

1. **Deserialization** - A closure is read from storage with `captured_layouts` field: [1](#0-0) 

2. **Lazy Resolution** - When the closure is called, `as_resolved()` loads the function but **does not validate** the stored `captured_layouts`: [2](#0-1) 

3. **Type Checking Bypass** - During `make_call_frame`, type checking is **explicitly skipped** for captured arguments based on the false assumption they were validated: [3](#0-2) 

The comment on line 966 states "Captured arguments are already verified against function signature" - this is true for freshly created closures but **false for deserialized closures** where layouts are never validated against the current function signature.

**Attack Vector:**

If an attacker can inject or manipulate closure data in storage (through storage layer vulnerabilities, serialization bugs, or module upgrade edge cases), they can craft a closure where `captured_layouts` doesn't match the function signature. When this malicious closure is invoked:

1. Values are deserialized according to the malicious `captured_layouts`
2. These type-confused values bypass all type checks
3. The function executes with arguments of incorrect types
4. Memory corruption or undefined behavior occurs

**Comparison with Normal Flow:**

When a closure is created via `PackClosure`, proper validation occurs: [4](#0-3) 

And at runtime (when enabled): [5](#0-4) 

But **no equivalent validation** exists for deserialized closures in `as_resolved()`.

## Impact Explanation

**Severity: Critical (pending concrete exploitation path)**

This vulnerability breaks the fundamental **Move VM Safety** invariant (#3) that bytecode execution must respect type constraints. Type confusion can lead to:

1. **Memory Corruption**: Passing values with incorrect type layouts to functions can cause out-of-bounds memory access
2. **Consensus Divergence**: Different nodes interpreting malformed closures differently could produce different state roots, violating **Deterministic Execution** invariant (#1)
3. **Value Manipulation**: Type confusion could allow treating a `u64` as an `address` or vice versa, enabling unauthorized access or fund theft
4. **VM Crashes**: Undefined behavior from type-confused values could crash validator nodes, affecting **liveness**

However, the practical exploitability depends on whether an unprivileged attacker can inject malformed closure data into storage. In the current Aptos design, this would require:
- Storage layer vulnerabilities allowing raw byte manipulation
- Serialization/deserialization bugs in BCS encoding
- Module upgrade compatibility check bypasses
- Native function vulnerabilities

Without identifying a concrete storage injection vector, this remains a **defense-in-depth failure** rather than a directly exploitable vulnerability.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability is **latent** - the code flaw exists, but exploitation requires additional conditions:

**Required for Exploitation:**
- Ability to write malformed closure bytes to storage (currently not possible through normal Move execution)
- OR a bug in module upgrade compatibility checks allowing signature changes
- OR undiscovered serialization/deserialization vulnerabilities

**Mitigating Factors:**
- Move's type-safe storage model prevents arbitrary byte writes
- Module upgrade compatibility checks should prevent signature changes
- Bytecode verification catches malformed closures at creation time

**Amplifying Factors:**
- Single point of failure - if ANY storage manipulation becomes possible, this vulnerability activates
- No defense-in-depth - missing validation is the last line of defense
- Silent failure - type confusion may not be immediately detected

## Recommendation

Add validation in `LazyLoadedFunction::as_resolved()` to verify that deserialized `captured_layouts` match the actual function signature:

```rust
pub(crate) fn as_resolved(
    &self,
    loader: &impl Loader,
    gas_meter: &mut impl DependencyGasMeter,
    traversal_context: &mut TraversalContext,
) -> PartialVMResult<Rc<LoadedFunction>> {
    let mut state = self.state.borrow_mut();
    Ok(match &mut *state {
        LazyLoadedFunctionState::Resolved { fun, .. } => fun.clone(),
        LazyLoadedFunctionState::Unresolved {
            data: SerializedFunctionData {
                module_id,
                fun_id,
                ty_args,
                mask,
                captured_layouts,
                ..
            },
        } => {
            let fun = loader.load_closure(
                gas_meter,
                traversal_context,
                module_id,
                fun_id,
                ty_args,
            )?;
            
            // ADDED: Validate captured_layouts match function signature
            let expected_layouts = Self::construct_captured_layouts(
                &loader.layout_converter(),
                gas_meter,
                traversal_context,
                &fun,
                *mask,
            )?;
            
            if let Some(expected) = expected_layouts {
                if captured_layouts != &expected {
                    return Err(PartialVMError::new(StatusCode::TYPE_MISMATCH)
                        .with_message(format!(
                            "Deserialized closure layouts don't match function signature for {}::{}",
                            module_id, fun_id
                        )));
                }
            }
            
            *state = LazyLoadedFunctionState::Resolved {
                fun: fun.clone(),
                ty_args: mem::take(ty_args),
                mask: *mask,
                captured_layouts: Some(mem::take(captured_layouts)),
            };
            fun
        },
    })
}
```

This ensures defense-in-depth by validating assumptions about stored data rather than blindly trusting it.

## Proof of Concept

Due to Move's type-safe storage model, a direct PoC cannot be constructed without additional vulnerabilities. However, the following illustrates the conceptual attack:

```
# Hypothetical scenario (requires storage manipulation capability):

1. Create legitimate closure: f(u64, u64) capturing first arg as u64
   - Normal captured_layouts = [MoveTypeLayout::U64]
   
2. [REQUIRES VULNERABILITY] Modify storage to corrupt captured_layouts:
   - Malicious captured_layouts = [MoveTypeLayout::Address]
   
3. Call the closure with u64 argument:
   - Runtime deserializes captured value as Address (32 bytes) instead of u64 (8 bytes)
   - Type checking is skipped (line 964: "if should_check && !is_captured")
   - Function f receives Address value in u64 parameter slot
   - Type confusion occurs, potentially accessing wrong memory locations

4. Result: Memory corruption, undefined behavior, potential consensus divergence
```

**Notes**

The vulnerability represents a **missing validation** rather than a directly exploitable attack path. While the code flaw is real and violates defensive programming principles, practical exploitation requires additional attack vectors (storage manipulation, serialization bugs, or upgrade check bypasses) that are not currently identified in the codebase.

This should be fixed as a **defense-in-depth** measure to ensure that even if future vulnerabilities allow storage manipulation, the Move VM maintains type safety guarantees. The fix is straightforward and adds minimal overhead while significantly strengthening security.

### Citations

**File:** third_party/move/move-vm/types/src/values/function_values_impl.rs (L178-208)
```rust
        let num_captured_values = mask.captured_count() as usize;
        let mut captured_layouts = Vec::with_capacity(num_captured_values);
        let mut captured = Vec::with_capacity(num_captured_values);
        for _ in 0..num_captured_values {
            let layout = read_required_value::<_, MoveTypeLayout>(&mut seq)?;
            match seq.next_element_seed(DeserializationSeed {
                ctx: self.0.ctx,
                layout: &layout,
            })? {
                Some(v) => {
                    captured_layouts.push(layout);
                    captured.push(v)
                },
                None => return Err(A::Error::invalid_length(captured.len(), &self)),
            }
        }
        // If the sequence length is known, check whether there are no extra values
        if matches!(seq.size_hint(), Some(remaining) if remaining != 0) {
            return Err(A::Error::invalid_length(captured.len(), &self));
        }
        let fun = fun_ext
            .create_from_serialization_data(SerializedFunctionData {
                format_version: FUNCTION_DATA_SERIALIZATION_FORMAT_V1,
                module_id,
                fun_id,
                ty_args,
                mask,
                captured_layouts,
            })
            .map_err(A::Error::custom)?;
        Ok(Closure(fun, Box::new(captured)))
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L429-443)
```rust
            } => {
                let fun = loader.load_closure(
                    gas_meter,
                    traversal_context,
                    module_id,
                    fun_id,
                    ty_args,
                )?;
                *state = LazyLoadedFunctionState::Resolved {
                    fun: fun.clone(),
                    ty_args: mem::take(ty_args),
                    mask: *mask,
                    captured_layouts: Some(mem::take(captured_layouts)),
                };
                fun
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L952-982)
```rust
        for i in (0..num_param_tys).rev() {
            let is_captured = mask.is_captured(i);
            let value = if is_captured {
                captured.pop().ok_or_else(|| {
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                        .with_message("inconsistent closure mask".to_string())
                })?
            } else {
                self.operand_stack.pop()?
            };
            locals.store_loc(i, value)?;

            if should_check && !is_captured {
                // Only perform paranoid type check for actual operands on the stack.
                // Captured arguments are already verified against function signature.
                let ty_args = function.ty_args();
                let ty = self.operand_stack.pop_ty()?;
                let expected_ty = &function.local_tys()[i];
                if !ty_args.is_empty() {
                    let expected_ty = self
                        .vm_config
                        .ty_builder
                        .create_ty_with_subst(expected_ty, ty_args)?;
                    // For parameter to argument, use assignability
                    ty.paranoid_check_assignable(&expected_ty)?;
                } else {
                    // Directly check against the expected type to save a clone here.
                    ty.paranoid_check_assignable(expected_ty)?;
                }
            }
        }
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L367-377)
```rust
    for ty in captured_param_tys.into_iter().rev() {
        let arg = safe_unwrap!(verifier.stack.pop());
        abilities = abilities.intersect(verifier.abilities(&arg)?);
        // For captured param type to argument, use assignability
        if (type_actuals.is_empty() && !ty.is_assignable_from(&arg))
            || (!type_actuals.is_empty() && !instantiate(ty, type_actuals).is_assignable_from(&arg))
        {
            return Err(verifier
                .error(StatusCode::PACK_TYPE_MISMATCH_ERROR, offset)
                .with_message("captured argument type mismatch".to_owned()));
        }
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L154-169)
```rust
    // Verify that captured arguments are assignable against types in the function
    // signature, and that they are no references.
    let expected_capture_tys = mask.extract(func.param_tys(), true);

    let given_capture_tys = operand_stack.popn_tys(expected_capture_tys.len() as u16)?;
    for (expected, given) in expected_capture_tys
        .into_iter()
        .zip(given_capture_tys.into_iter())
    {
        expected.paranoid_check_is_no_ref("Captured argument type")?;
        with_instantiation(ty_builder, func, expected, |expected| {
            // Intersect the captured type with the accumulated abilities
            abilities = abilities.intersect(given.abilities()?);
            given.paranoid_check_assignable(expected)
        })?
    }
```
