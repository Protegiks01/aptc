# Audit Report

## Title
Admin Service Exposes Sensitive Memory Information Without Authentication on Testnet/Devnet Deployments

## Summary
The Aptos admin service binds to all network interfaces (`0.0.0.0:9102`) by default and lacks authentication on testnet/devnet chains, allowing remote attackers who can reach the node's network to extract sensitive memory statistics and heap profiles through unauthenticated HTTP endpoints.

## Finding Description

The admin service has a critical security misconfiguration that exposes sensitive memory information to unauthenticated remote attackers on testnet and devnet deployments.

**Configuration Issues:**

The `AdminServiceConfig` defaults to binding on all network interfaces rather than localhost: [1](#0-0) 

**Authentication Bypass:**

The service automatically bypasses authentication when no authentication configs are provided, which is the default for non-mainnet chains: [2](#0-1) 

**Auto-Enabled on Testnet/Devnet:**

The `ConfigOptimizer` automatically enables the admin service on non-mainnet chains without requiring explicit operator consent: [3](#0-2) 

**Exposed Memory Information:**

The malloc handlers expose sensitive internal memory information without any access control: [4](#0-3) [5](#0-4) 

**Attack Path:**

1. Attacker identifies a testnet/devnet validator or fullnode IP address
2. Attacker sends HTTP GET request to `http://<NODE_IP>:9102/malloc/stats`
3. Server returns detailed jemalloc memory statistics without authentication check
4. Attacker can also call `/malloc/dump_profile` to dump heap profiles to disk
5. Memory information may reveal sensitive data, internal state, or help identify other vulnerabilities

**Network Exposure:**

The Kubernetes deployment configuration confirms the service is exposed on all pod interfaces: [6](#0-5) 

Furthermore, the default Kubernetes NetworkPolicy is disabled, providing no network-level protection: [7](#0-6) 

Even when NetworkPolicy is enabled, it doesn't include port 9102 in the ingress rules, but this only protects against HAProxy access, not direct pod IP connections from within the cluster: [8](#0-7) 

## Impact Explanation

This vulnerability qualifies as **High Severity** based on the Aptos bug bounty criteria for the following reasons:

1. **Information Disclosure**: Memory statistics and heap profiles can reveal:
   - Internal node state and operational details
   - Potentially sensitive transaction data in memory
   - Memory layout information useful for exploit development
   - Performance characteristics that could aid in resource exhaustion attacks

2. **Affects Production Networks**: While mainnet requires authentication, testnet and devnet are production networks used for:
   - Real value testing (testnet tokens, bridge testing)
   - Ecosystem development and integration testing
   - Security auditing and vulnerability research

3. **No Operator Awareness**: The service is auto-enabled on testnet/devnet without explicit configuration, meaning operators may not realize they're exposing this information.

4. **Wide Attack Surface**: Any attacker with network access to the node can exploit this, including:
   - Other validators in the network
   - Compromised nodes in the same data center/cloud
   - Attackers who gained partial network access

The vulnerability does not directly cause loss of funds or consensus violations, but the information disclosure could facilitate more severe attacks.

## Likelihood Explanation

**Likelihood: Medium to High**

The exploitability depends on network configuration:

1. **Kubernetes Deployments**: 
   - NetworkPolicy is disabled by default
   - Attackers within the same Kubernetes cluster can reach pod IPs directly
   - Cloud provider network policies may provide additional protection

2. **Non-Kubernetes Deployments**:
   - Depends on firewall configuration
   - If port 9102 is not explicitly blocked, the service is accessible

3. **Common Scenarios**:
   - Multi-tenant Kubernetes clusters (medium likelihood)
   - Compromised nodes in same network (high likelihood)
   - Cloud environments without security groups (medium likelihood)
   - Development/testing environments (high likelihood)

The vulnerability is automatically present on all testnet/devnet nodes unless operators explicitly:
- Set `admin_service.address = "127.0.0.1"` in config
- Configure authentication
- Disable the admin service
- Add firewall rules blocking port 9102

## Recommendation

**Immediate Fixes:**

1. **Change Default Bind Address to Localhost:**
```rust
// In config/src/config/admin_service_config.rs
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "127.0.0.1".to_string(),  // Changed from "0.0.0.0"
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
}
```

2. **Require Authentication on All Chains:**
```rust
// In config/src/config/admin_service_config.rs, update sanitizer:
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if node_config.admin_service.enabled == Some(true) {
            // Require authentication on ALL chains, not just mainnet
            if node_config.admin_service.authentication_configs.is_empty() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Must enable authentication for AdminService on all chains.".into(),
                ));
            }
        }

        Ok(())
    }
}
```

3. **Update Kubernetes NetworkPolicy:**
Add explicit ingress rules for port 9102 only from authorized sources, or ensure it's completely blocked.

4. **Disable by Default:**
Change the `ConfigOptimizer` to not auto-enable the service, requiring explicit operator action.

## Proof of Concept

**Step 1: Deploy a testnet node with default configuration**

```bash
# Using default helm values, the admin service will be enabled
# with no authentication and bound to 0.0.0.0:9102
helm install aptos-node terraform/helm/aptos-node \
  --set chain.chain_id=2
```

**Step 2: From within the cluster or network, access the endpoint**

```bash
# Get the pod IP
POD_IP=$(kubectl get pod -l app.kubernetes.io/name=validator -o jsonpath='{.items[0].status.podIP}')

# Extract memory statistics without authentication
curl http://${POD_IP}:9102/malloc/stats

# This returns detailed jemalloc statistics including:
# - Allocated memory, metadata, resident memory
# - Per-arena statistics
# - Bin-specific allocation counts
# - Internal fragmentation details

# Dump heap profile
curl http://${POD_IP}:9102/malloc/dump_profile
# Returns: "Successfully dumped heap profile to /tmp/heap-profile.{timestamp}"
```

**Step 3: Analyze the information**

The memory statistics reveal:
- Internal memory allocation patterns
- Heap fragmentation levels
- Active memory regions
- Potential indicators of cached transaction data
- Information useful for crafting memory exhaustion attacks

**Expected Output:**
```
Allocated: 2147483648, active: 1879048192, metadata: 268435456, resident: 2281701376, mapped: 4294967296
```

The vulnerability is confirmed if these commands succeed without authentication on a testnet/devnet node with default configuration.

---

## Notes

**Mainnet Protection:** Mainnet deployments are partially protected by the configuration sanitizer that requires authentication. However, this is a weak defense-in-depth as it only applies at configuration validation time.

**Deployment Variations:** The actual exploitability varies significantly based on:
- Cloud provider network security groups
- Kubernetes NetworkPolicy configuration
- Custom firewall rules
- Network segmentation practices

**Best Practice:** Production deployments should always bind administrative interfaces to localhost or implement strong authentication, regardless of chain type.

### Citations

**File:** config/src/config/admin_service_config.rs (L41-50)
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
```

**File:** config/src/config/admin_service_config.rs (L84-106)
```rust
impl ConfigOptimizer for AdminServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        _local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let mut modified_config = false;

        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

            modified_config = true; // The config was modified
        }

        Ok(modified_config)
    }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-174)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };
```

**File:** crates/aptos-admin-service/src/server/malloc.rs (L36-44)
```rust
pub fn handle_malloc_stats_request(max_len: usize) -> hyper::Result<Response<Body>> {
    match get_jemalloc_stats_string(max_len) {
        Ok(stats) => Ok(reply_with(Vec::new(), Body::from(stats))),
        Err(e) => Ok(reply_with_status(
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("Failed to get malloc stats: {e}"),
        )),
    }
}
```

**File:** crates/aptos-admin-service/src/server/malloc.rs (L65-76)
```rust
pub fn handle_dump_profile_request() -> hyper::Result<Response<Body>> {
    match dump_heap_profile() {
        Ok(path) => Ok(reply_with(
            Vec::new(),
            Body::from(format!("Successfully dumped heap profile to {path}")),
        )),
        Err(e) => Ok(reply_with_status(
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("Failed to dump heap profile: {e}"),
        )),
    }
}
```

**File:** terraform/helm/aptos-node/templates/validator.yaml (L183-192)
```yaml
        ports:
        - containerPort: 6180
        - containerPort: 6181  # VFN
        - containerPort: 6182  # Public
        - containerPort: 8080
          name: api
        - containerPort: 9101
          name: metrics
        - containerPort: 9102
          name: admin
```

**File:** terraform/helm/aptos-node/values.yaml (L90-93)
```yaml
  # -- DEPRECATED: it's broken with Cillium a.k.a. GKE DataplaneV2.
  # -- templates/networkpolicy.yaml kept around for reference in case we want to resurrect it.
  # -- Lock down network ingress and egress with Kubernetes NetworkPolicy
  enableNetworkPolicy: false
```

**File:** terraform/helm/aptos-node/templates/networkpolicy.yaml (L19-37)
```yaml
  ingress:
  # HAproxy
  - from:
    - podSelector:
        matchLabels:
          {{- include "aptos-validator.selectorLabels" $ | nindent 10 }}
          app.kubernetes.io/name: haproxy
          app.kubernetes.io/instance: haproxy-{{$i}}
    ports:
      # AptosNet from HAproxy
    - protocol: TCP
      port: 6180
    - protocol: TCP
      port: 9101
  {{- if $.Values.service.validator.enableRestApi }}
      # REST API from HAproxy
    - protocol: TCP
      port: 8080
  {{- end }}
```
