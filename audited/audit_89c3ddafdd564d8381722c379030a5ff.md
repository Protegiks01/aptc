# Audit Report

## Title
Protocol Mismatch and Silent Partial Failure in JWK Consensus Message Serialization

## Summary
The `to_bytes_by_protocol()` function in JWK consensus checks DIRECT_SEND protocol compatibility but JWK consensus exclusively uses RPC protocols. When peers lack DIRECT_SEND protocol support, they are silently excluded from pre-serialization results, causing inconsistent message delivery paths and potential performance degradation.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **JWKConsensusNetworkClient::to_bytes_by_protocol()** delegates to the underlying NetworkClient [1](#0-0) 

2. **NetworkClient::to_bytes_by_protocol()** uses `group_peers_by_protocol()` which checks against `direct_send_protocols_and_preferences` [2](#0-1) 

3. **group_peers_by_protocol()** silently excludes peers without compatible DIRECT_SEND protocols [3](#0-2) 

However, JWK consensus **only uses RPC protocols** for all message transmission: [4](#0-3) 

The protocol mismatch creates inconsistent behavior in ReliableBroadcast: [5](#0-4) 

**Attack Scenario:**
1. Validator A supports RPC protocols but not DIRECT_SEND protocols (or deliberately refuses them)
2. `to_bytes_by_protocol()` is called with peers [A, B, C]
3. Peer A is silently excluded from results (only {B: bytes, C: bytes} returned)
4. During broadcast, peers B and C receive pre-serialized bytes via `send_rb_rpc_raw`
5. Peer A falls back to `send_rb_rpc`, which re-serializes using RPC protocols
6. This creates performance inconsistency and defeats the optimization purpose
7. If A supports no common protocol, infinite retries occur with exponential backoff

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria - "State inconsistencies requiring intervention"

**Impacts:**
1. **Silent Partial Failure**: Function contract violated - returns partial results instead of complete failure
2. **Performance Degradation**: Affected validators experience re-serialization overhead on every message
3. **Potential DoS**: If validators lack common protocols, infinite retry loops consume resources
4. **Observability Issues**: Silent exclusions make network debugging difficult (only sampled logging)

This does NOT constitute Critical/High severity because:
- No consensus safety violation (messages deliver correctly)
- No fund loss or network partition
- No deterministic execution violation
- Serialization formats are compatible (both use CompressedBcs encoding)

## Likelihood Explanation

**Likelihood: Medium**

The issue manifests when:
- Validators have asymmetric protocol negotiation (support RPC but not DIRECT_SEND)
- Network configuration anomalies during validator onboarding
- Malicious validators deliberately refuse DIRECT_SEND protocol negotiation

While unusual, this is plausible in:
- Heterogeneous validator deployments
- Network upgrades with protocol version mismatches
- Targeted attacks by malicious validator operators

## Recommendation

**Fix 1: Use RPC protocols for to_bytes_by_protocol in JWK consensus**

Modify `group_peers_by_protocol` to accept a protocol preference parameter, or create a variant that uses RPC protocols:

```rust
// In network_interface.rs
fn to_bytes_by_protocol(
    &self,
    peers: Vec<PeerId>,
    message: JWKConsensusMsg,
) -> anyhow::Result<HashMap<PeerId, Bytes>> {
    let peer_network_ids: Vec<PeerNetworkId> = peers
        .into_iter()
        .map(|peer| self.get_peer_network_id_for_peer(peer))
        .collect();
    
    // Use RPC protocols instead of DIRECT_SEND since JWK consensus only uses RPC
    Ok(self
        .network_client
        .to_bytes_by_protocol_with_rpc(peer_network_ids, message)?
        .into_iter()
        .map(|(peer_network_id, bytes)| (peer_network_id.peer_id(), bytes))
        .collect())
}
```

**Fix 2: Return error on partial failure**

Modify `group_peers_by_protocol` to return an error when any peer lacks compatible protocols:

```rust
fn group_peers_by_protocol(
    &self,
    peers: Vec<PeerNetworkId>,
) -> Result<HashMap<ProtocolId, Vec<PeerNetworkId>>, Error> {
    let mut peers_per_protocol = HashMap::new();
    let mut peers_without_a_protocol = vec![];
    
    for peer in peers {
        match self.get_preferred_protocol_for_peer(&peer, &self.direct_send_protocols_and_preferences) {
            Ok(protocol) => peers_per_protocol.entry(protocol).or_insert_with(Vec::new).push(peer),
            Err(_) => peers_without_a_protocol.push(peer),
        }
    }
    
    if !peers_without_a_protocol.is_empty() {
        return Err(Error::NetworkError(format!(
            "Peers without compatible protocol: {:?}",
            peers_without_a_protocol
        )));
    }
    
    Ok(peers_per_protocol)
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_protocol_mismatch {
    use super::*;
    use aptos_types::PeerId;
    
    #[tokio::test]
    async fn test_partial_serialization_failure() {
        // Setup: Create peers with asymmetric protocol support
        // Peer A: only RPC protocols
        // Peer B: both DIRECT_SEND and RPC
        
        let peer_a = PeerId::random();
        let peer_b = PeerId::random();
        
        // Configure peer A to only support RPC protocols
        let peer_a_protocols = ProtocolIdSet::from([
            ProtocolId::JWKConsensusRpcCompressed,
        ]);
        
        // Configure peer B to support both
        let peer_b_protocols = ProtocolIdSet::from([
            ProtocolId::JWKConsensusDirectSendCompressed,
            ProtocolId::JWKConsensusRpcCompressed,
        ]);
        
        // Create network client with mocked peer metadata
        // ... setup code ...
        
        let message = JWKConsensusMsg::default();
        let peers = vec![peer_a, peer_b];
        
        // Call to_bytes_by_protocol
        let result = network_client.to_bytes_by_protocol(peers, message).unwrap();
        
        // Verify: peer_a is excluded from results (silent partial failure)
        assert!(!result.contains_key(&peer_a), "Peer A should be excluded");
        assert!(result.contains_key(&peer_b), "Peer B should be included");
        
        // This demonstrates the contract violation:
        // Function succeeds but returns partial results instead of error
        println!("Silent partial failure: {} peers requested, {} serialized", 
                 2, result.len());
    }
}
```

## Notes

While this issue represents a genuine correctness bug with operational impact, it does **not** violate critical consensus invariants. The DIRECT_SEND and RPC protocol variants use identical serialization formats (CompressedBcs encoding with JWKConsensus compression client), so message content remains consistent despite the different code paths. [6](#0-5) [7](#0-6) 

The sampled warning logging partially mitigates the observability issue but does not address the fundamental protocol mismatch or performance degradation for affected validators.

### Citations

**File:** crates/aptos-jwk-consensus/src/network_interface.rs (L64-79)
```rust
    pub fn to_bytes_by_protocol(
        &self,
        peers: Vec<PeerId>,
        message: JWKConsensusMsg,
    ) -> anyhow::Result<HashMap<PeerId, Bytes>> {
        let peer_network_ids: Vec<PeerNetworkId> = peers
            .into_iter()
            .map(|peer| self.get_peer_network_id_for_peer(peer))
            .collect();
        Ok(self
            .network_client
            .to_bytes_by_protocol(peer_network_ids, message)?
            .into_iter()
            .map(|(peer_network_id, bytes)| (peer_network_id.peer_id(), bytes))
            .collect())
    }
```

**File:** network/framework/src/application/interface.rs (L160-191)
```rust
    fn group_peers_by_protocol(
        &self,
        peers: Vec<PeerNetworkId>,
    ) -> HashMap<ProtocolId, Vec<PeerNetworkId>> {
        // Sort peers by protocol
        let mut peers_per_protocol = HashMap::new();
        let mut peers_without_a_protocol = vec![];
        for peer in peers {
            match self
                .get_preferred_protocol_for_peer(&peer, &self.direct_send_protocols_and_preferences)
            {
                Ok(protocol) => peers_per_protocol
                    .entry(protocol)
                    .or_insert_with(Vec::new)
                    .push(peer),
                Err(_) => peers_without_a_protocol.push(peer),
            }
        }

        // We only periodically log any unavailable peers (to prevent log spamming)
        if !peers_without_a_protocol.is_empty() {
            sample!(
                SampleRate::Duration(Duration::from_secs(10)),
                warn!(
                    "[sampled] Unavailable peers (without a common network protocol): {:?}",
                    peers_without_a_protocol
                )
            );
        }

        peers_per_protocol
    }
```

**File:** network/framework/src/application/interface.rs (L288-304)
```rust
    fn to_bytes_by_protocol(
        &self,
        peers: Vec<PeerNetworkId>,
        message: Message,
    ) -> anyhow::Result<HashMap<PeerNetworkId, Bytes>> {
        let peers_per_protocol = self.group_peers_by_protocol(peers);
        // Convert to bytes per protocol
        let mut bytes_per_peer = HashMap::new();
        for (protocol_id, peers) in peers_per_protocol {
            let bytes: Bytes = protocol_id.to_bytes(&message)?.into();
            for peer in peers {
                bytes_per_peer.insert(peer, bytes.clone());
            }
        }

        Ok(bytes_per_peer)
    }
```

**File:** crates/aptos-jwk-consensus/src/network.rs (L59-98)
```rust
#[async_trait::async_trait]
impl RBNetworkSender<JWKConsensusMsg> for NetworkSender {
    async fn send_rb_rpc_raw(
        &self,
        receiver: AccountAddress,
        raw_message: Bytes,
        timeout: Duration,
    ) -> anyhow::Result<JWKConsensusMsg> {
        Ok(self
            .jwk_network_client
            .send_rpc_raw(receiver, raw_message, timeout)
            .await?)
    }

    async fn send_rb_rpc(
        &self,
        receiver: AccountAddress,
        message: JWKConsensusMsg,
        timeout: Duration,
    ) -> anyhow::Result<JWKConsensusMsg> {
        if receiver == self.author {
            let (tx, rx) = oneshot::channel();
            let protocol = RPC[0];
            let self_msg = Event::RpcRequest(self.author, message, protocol, tx);
            self.self_sender.clone().send(self_msg).await?;
            if let Ok(Ok(Ok(bytes))) = tokio::time::timeout(timeout, rx).await {
                let response_msg =
                    tokio::task::spawn_blocking(move || protocol.from_bytes(&bytes)).await??;
                Ok(response_msg)
            } else {
                bail!("self rpc failed");
            }
        } else {
            let result = self
                .jwk_network_client
                .send_rpc(receiver, message, timeout)
                .await?;
            Ok(result)
        }
    }
```

**File:** crates/reliable-broadcast/src/lib.rs (L127-156)
```rust
            let peers = receivers.clone();
            let sender = network_sender.clone();
            let message_clone = message.clone();
            let protocols = Arc::new(
                tokio::task::spawn_blocking(move || {
                    sender.to_bytes_by_protocol(peers, message_clone)
                })
                .await??,
            );

            let send_message = |receiver, sleep_duration: Option<Duration>| {
                let network_sender = network_sender.clone();
                let time_service = time_service.clone();
                let message = message.clone();
                let protocols = protocols.clone();
                async move {
                    if let Some(duration) = sleep_duration {
                        time_service.sleep(duration).await;
                    }
                    let send_fut = if receiver == self_author {
                        network_sender.send_rb_rpc(receiver, message, rpc_timeout_duration)
                    } else if let Some(raw_message) = protocols.get(&receiver).cloned() {
                        network_sender.send_rb_rpc_raw(receiver, raw_message, rpc_timeout_duration)
                    } else {
                        network_sender.send_rb_rpc(receiver, message, rpc_timeout_duration)
                    };
                    (receiver, send_fut.await)
                }
                .boxed()
            };
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L166-167)
```rust
            ProtocolId::JWKConsensusDirectSendCompressed
            | ProtocolId::JWKConsensusRpcCompressed => Encoding::CompressedBcs(RECURSION_LIMIT),
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L185-186)
```rust
            ProtocolId::JWKConsensusDirectSendCompressed
            | ProtocolId::JWKConsensusRpcCompressed => CompressionClient::JWKConsensus,
```
