# Audit Report

## Title
Handshake Replay DoS Attack on Public and VFN Networks Due to Disabled Anti-Replay Protection

## Summary
The anti-replay timestamp protection is intentionally disabled for `MaybeMutual` authentication mode, which is used by Public and VFN networks. This allows attackers to replay captured handshake messages indefinitely, forcing nodes to perform expensive Diffie-Hellman cryptographic operations for each replay, creating a resource exhaustion DoS attack vector. [1](#0-0) 

## Finding Description

The vulnerability exists in the network handshake authentication logic. The `anti_replay_timestamps()` function returns `None` for `MaybeMutual` mode, completely disabling timestamp-based replay protection. [2](#0-1) 

The developers acknowledge this attack vector in comments, explaining that replay attacks force peers to perform expensive Diffie-Hellman operations. However, the protection is only enabled for `Mutual` mode due to implementation complexity concerns: [3](#0-2) 

**Which Networks Are Affected:**

The `MaybeMutual` mode is configured when `mutual_authentication` is set to `false`, which happens for all non-validator networks: [4](#0-3) [5](#0-4) 

Only `NetworkId::Validator` has `mutual_authentication = true`. Both `NetworkId::Vfn` (Validator Full Node network) and `NetworkId::Public` (public full node network) use `MaybeMutual` mode. [6](#0-5) 

**Attack Execution Flow:**

1. Attacker captures a legitimate handshake initiation message from any client connecting to a VFN or Public network node
2. Attacker replays this message repeatedly to the target server
3. Server processes each replay through the `upgrade_inbound` function, which:
   - Parses the Noise handshake message
   - Performs expensive Diffie-Hellman key exchanges
   - Builds response messages [7](#0-6) 

Since `anti_replay_timestamps()` returns `None` for `MaybeMutual` mode, the timestamp check is completely skipped, and all replays are processed.

**Why Connection Limits Don't Help:**

The `inbound_connection_limit` is only enforced AFTER the handshake completes successfully: [8](#0-7) 

This means an attacker can spam handshake replay messages and force the server to perform expensive cryptographic operations before any connection limit is even checked.

## Impact Explanation

**Severity: HIGH** per Aptos bug bounty criteria:
- "Validator node slowdowns" - This attack can slow down or crash VFN nodes
- Affects network availability for full nodes on the public network

**Scope:**
- All nodes operating on VFN networks (validators' associated full nodes)
- All nodes operating on Public networks (public full nodes)
- Critical infrastructure for blockchain operation

**Resource Exhaustion:**
Each handshake replay forces the server to:
- Parse cryptographic handshake messages
- Perform Diffie-Hellman key exchange (computationally expensive)
- Allocate memory for connection state
- Process and respond to the message

An attacker can send thousands of replays per second, overwhelming node resources.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Network access to capture handshake messages (messages are sent before encryption)
- Ability to send packets to target nodes
- No authentication or privileged access required

**Complexity:**
- Low - Handshake messages are captured in plaintext
- Simple replay attack with no cryptographic knowledge needed
- Can be automated with basic packet capture and replay tools

**Feasibility:**
- Public network nodes are openly accessible
- VFN nodes accept connections from their associated validators
- No rate limiting exists at the handshake level

## Recommendation

**Immediate Fix:**

Implement anti-replay protection for `MaybeMutual` mode with bounded memory usage. Options include:

1. **Time-window based approach**: Only store timestamps for the last N minutes, automatically expiring old entries
2. **LRU cache**: Limit timestamp storage to a fixed maximum size with least-recently-used eviction
3. **Per-IP rate limiting**: Track handshake attempts per source IP address

**Suggested Implementation:**

Add a bounded anti-replay structure for `MaybeMutual` mode:

```rust
// In HandshakeAuthMode::MaybeMutual
MaybeMutual {
    anti_replay_timestamps: RwLock<BoundedAntiReplayTimestamps>,
    peers_and_metadata: Arc<PeersAndMetadata>,
}

// BoundedAntiReplayTimestamps with LRU eviction
struct BoundedAntiReplayTimestamps {
    timestamps: LruCache<x25519::PublicKey, u64>,
    max_size: usize,
}
```

Then modify the `anti_replay_timestamps()` function to return the bounded structure for both modes.

**Alternative:** Implement rate limiting at the transport layer before handshake processing, limiting handshake attempts per source IP address.

## Proof of Concept

```rust
// PoC demonstrating handshake replay attack
use aptos_network::noise::HandshakeAuthMode;
use std::time::Duration;

#[tokio::test]
async fn test_handshake_replay_dos() {
    // Setup a node with MaybeMutual mode (e.g., Public network node)
    let (server_upgrader, server_public_key) = setup_public_network_node();
    
    // Legitimate client performs initial handshake
    let (client_socket, server_socket) = create_socket_pair();
    let handshake_message = capture_handshake_initiation(client_socket).await;
    
    // Attacker replays the captured handshake message multiple times
    let mut replay_tasks = vec![];
    for _ in 0..1000 {
        let msg_clone = handshake_message.clone();
        let server_clone = server_upgrader.clone();
        
        replay_tasks.push(tokio::spawn(async move {
            let (attack_socket, _) = create_socket_pair();
            // Send the same captured handshake message
            attack_socket.write_all(&msg_clone).await.unwrap();
            
            // Server will process this replay and perform expensive crypto operations
            // No anti-replay protection will reject this
            server_clone.upgrade_inbound(attack_socket).await
        }));
    }
    
    // All 1000 replays are processed, causing resource exhaustion
    // In MaybeMutual mode, no timestamps are checked
    for task in replay_tasks {
        let result = task.await;
        // Server performs full handshake processing for each replay
    }
    
    // Server resources are exhausted from processing 1000 identical replays
    assert!(server_is_overloaded());
}
```

**Notes**

This vulnerability represents a **known design tradeoff** by the Aptos development team. The comments explicitly acknowledge the attack vector but cite implementation complexity (unbounded memory growth) as the reason for not implementing protection in `MaybeMutual` mode.

However, the lack of any mitigation creates a practical DoS attack vector against critical network infrastructure. The attack is realistic, requires minimal sophistication, and can significantly impact node availability on VFN and Public networks.

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." Handshake processing should be rate-limited or protected against replay attacks to prevent resource exhaustion.

### Citations

**File:** network/framework/src/noise/handshake.rs (L30-39)
```rust
/// In a mutually authenticated network, a client message is accompanied with a timestamp.
/// This is in order to prevent replay attacks, where the attacker does not know the client's static key,
/// but can still replay a handshake message in order to force a peer into performing a few Diffie-Hellman key exchange operations.
///
/// Thus, to prevent replay attacks a responder will always check if the timestamp is strictly increasing,
/// effectively considering it as a stateful counter.
///
/// If the client timestamp has been seen before, or is not strictly increasing,
/// we can abort the handshake early and avoid heavy Diffie-Hellman computations.
/// If the client timestamp is valid, we store it.
```

**File:** network/framework/src/noise/handshake.rs (L86-92)
```rust
        // Only use anti replay protection in mutual-auth scenarios. In theory,
        // this is applicable everywhere; however, we would need to spend some
        // time making this more sophisticated so it garbage collects old
        // timestamps and doesn't use unbounded space. These are not problems in
        // mutual-auth scenarios because we have a bounded set of trusted peers
        // that rarely changes.
        anti_replay_timestamps: RwLock<AntiReplayTimestamps>,
```

**File:** network/framework/src/noise/handshake.rs (L123-131)
```rust
    fn anti_replay_timestamps(&self) -> Option<&RwLock<AntiReplayTimestamps>> {
        match &self {
            HandshakeAuthMode::Mutual {
                anti_replay_timestamps,
                ..
            } => Some(anti_replay_timestamps),
            HandshakeAuthMode::MaybeMutual(_) => None,
        }
    }
```

**File:** network/framework/src/noise/handshake.rs (L431-454)
```rust
        if let Some(anti_replay_timestamps) = self.auth_mode.anti_replay_timestamps() {
            // check that the payload received as the client timestamp (in seconds)
            if payload.len() != AntiReplayTimestamps::TIMESTAMP_SIZE {
                return Err(NoiseHandshakeError::MissingAntiReplayTimestamp(
                    remote_peer_short,
                ));
            }

            let mut client_timestamp = [0u8; AntiReplayTimestamps::TIMESTAMP_SIZE];
            client_timestamp.copy_from_slice(&payload);
            let client_timestamp = u64::from_le_bytes(client_timestamp);

            // check the timestamp is not a replay
            let mut anti_replay_timestamps = anti_replay_timestamps.write();
            if anti_replay_timestamps.is_replay(remote_public_key, client_timestamp) {
                return Err(NoiseHandshakeError::ServerReplayDetected(
                    remote_peer_short,
                    client_timestamp,
                ));
            }

            // store the timestamp
            anti_replay_timestamps.store_timestamp(remote_public_key, client_timestamp);
        }
```

**File:** config/src/config/network_config.rs (L135-142)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
```

**File:** config/src/network_id.rs (L168-170)
```rust
    pub fn is_validator_network(&self) -> bool {
        self == &NetworkId::Validator
    }
```

**File:** network/builder/src/builder.rs (L171-175)
```rust
        let authentication_mode = if config.mutual_authentication {
            AuthenticationMode::Mutual(identity_key)
        } else {
            AuthenticationMode::MaybeMutual(identity_key)
        };
```

**File:** network/framework/src/peer_manager/mod.rs (L372-388)
```rust
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
```
