# Audit Report

## Title
Race Condition in Indexer Object Query During Parallel Batch Processing Causes Historical Data Inconsistency

## Summary
The `CurrentObjectQuery::get_by_address()` method reads from the `current_objects` table without transaction isolation guarantees while multiple parallel processor tasks are concurrently writing to the same table. This creates a race condition where delete operations can query and record object state from future transaction versions, resulting in inconsistent historical data in the `objects` table.

## Finding Description

The Aptos indexer processes blockchain transactions in parallel batches to improve throughput. By default, 5 parallel processor tasks fetch and process different transaction version ranges concurrently [1](#0-0) .

The vulnerability occurs in the object deletion flow:

1. **Parallel Processing Setup**: Multiple tasks spawn to process sequential but non-overlapping version ranges [2](#0-1) 

2. **Delete Operation Query**: When processing a `DeleteResource` event, the code calls `get_object_owner()` to retrieve the object's previous state from the database [3](#0-2) 

3. **Unprotected Read**: The `CurrentObjectQuery::get_by_address()` method performs a plain SELECT query outside of any transaction isolation [4](#0-3) 

4. **Race Window**: Each batch commits in its own database transaction [5](#0-4) . PostgreSQL's default READ COMMITTED isolation level means Task A processing version 1100 can read data that Task B (processing version 1200) just committed, even though version 1200 is chronologically after version 1100.

5. **Inconsistent Historical Record**: The `objects` table receives a delete record at version 1100 with owner/state values from version 1200, violating temporal consistency.

The developer comment acknowledges this limitation [6](#0-5) .

## Impact Explanation

This qualifies as **Low to Medium Severity** under "State inconsistencies requiring intervention":

- **Data Integrity**: Historical records in the `objects` table become temporally inconsistent
- **API Reliability**: Applications querying historical object states receive incorrect owner information
- **No Blockchain Impact**: This affects only the off-chain indexer database, not consensus or blockchain state
- **Limited Exploitation**: An attacker cannot trigger this - it occurs naturally due to system design
- **Self-Correcting for Current State**: The `current_objects` table remains eventually consistent due to version-checking WHERE clauses [7](#0-6) 

## Likelihood Explanation

**High likelihood** of occurrence:
- Default configuration spawns 5 parallel tasks
- Race condition window exists for every delete operation processed while other batches are committing
- No synchronization prevents out-of-order commits
- Occurs naturally without attacker intervention

## Recommendation

**Option 1: Use Snapshot Isolation or Serializable Transactions**
```rust
// In get_object_owner, wrap the query in a transaction with appropriate isolation
pub fn get_object_owner(
    conn: &mut PgPoolConnection,
    object_address: &str,
) -> anyhow::Result<CurrentObject> {
    use diesel::connection::TransactionManager;
    
    conn.build_transaction()
        .repeatable_read()  // or .serializable()
        .run(|conn| {
            CurrentObjectQuery::get_by_address(object_address, conn)
                .map(|res| CurrentObject { /* ... */ })
        })
}
```

**Option 2: Sequential Processing with Version Ordering**
Modify the runtime to ensure batches commit in version order:
```rust
// Process batches but wait for previous batch to commit before starting next
for task in tasks {
    let result = task.await?;
    // Commit to database only after previous version commits
}
```

**Option 3: Snapshot-Based Queries**
Query from a specific version snapshot rather than current_objects:
```rust
// Query the objects historical table at max version < delete_version
// This ensures temporal consistency
```

## Proof of Concept

```rust
// Reproduction scenario:
// Terminal 1: Start indexer with processor_tasks=5
// Terminal 2: Monitor postgres logs for concurrent transactions
// Terminal 3: Query objects table after processing completes

// Expected: delete record at version 1100 with owner from version 1099
// Actual: delete record at version 1100 with owner from version 1200+

// SQL verification query:
// SELECT o1.transaction_version, o1.owner_address, o1.object_address
// FROM objects o1
// WHERE o1.is_deleted = true
//   AND EXISTS (
//     SELECT 1 FROM objects o2 
//     WHERE o2.object_address = o1.object_address
//       AND o2.transaction_version > o1.transaction_version
//       AND o2.owner_address != o1.owner_address
//   );
```

**Notes**

While this represents a genuine data consistency issue in the indexer implementation, it has several mitigating factors:

1. **Off-Chain Only**: The indexer is auxiliary infrastructure; blockchain consensus and state remain unaffected
2. **Non-Exploitable**: This is a design limitation, not an attack vector controllable by malicious actors
3. **Limited Scope**: Only historical `objects` records are affected; `current_objects` maintains eventual consistency
4. **Known Limitation**: Developer comments suggest awareness of temporal consistency challenges

The issue falls into a gray area where it represents poor engineering practice and could cause application-level bugs for consumers of the indexer API, but does not constitute a critical blockchain vulnerability. It would benefit from remediation but does not pose immediate security risk to funds, consensus, or network availability.

### Citations

**File:** config/src/config/indexer_config.rs (L22-22)
```rust
pub const DEFAULT_PROCESSOR_TASKS: u8 = 5;
```

**File:** crates/indexer/src/runtime.rs (L210-219)
```rust
        let mut tasks = vec![];
        for _ in 0..processor_tasks {
            let other_tailer = tailer.clone();
            let task = tokio::spawn(async move { other_tailer.process_next_batch().await });
            tasks.push(task);
        }
        let batches = match futures::future::try_join_all(tasks).await {
            Ok(res) => res,
            Err(err) => panic!("Error processing transaction batches: {:?}", err),
        };
```

**File:** crates/indexer/src/models/v2_objects.rs (L128-139)
```rust
                match Self::get_object_owner(conn, &resource.address) {
                    Ok(owner) => owner,
                    Err(_) => {
                        aptos_logger::error!(
                            transaction_version = txn_version,
                            lookup_key = &resource.address,
                            "Missing object owner for object. You probably should backfill db.",
                        );
                        return Ok(None);
                    },
                }
            };
```

**File:** crates/indexer/src/models/v2_objects.rs (L166-166)
```rust
    /// This is actually not great because object owner can change. The best we can do now though
```

**File:** crates/indexer/src/models/v2_objects.rs (L197-204)
```rust
    pub fn get_by_address(
        object_address: &str,
        conn: &mut PgPoolConnection,
    ) -> diesel::QueryResult<Self> {
        current_objects::table
            .filter(current_objects::object_address.eq(object_address))
            .first::<Self>(conn)
    }
```

**File:** crates/indexer/src/processors/default_processor.rs (L125-148)
```rust
    match conn
        .build_transaction()
        .read_write()
        .run::<_, Error, _>(|pg_conn| {
            insert_to_db_impl(
                pg_conn,
                &txns,
                (
                    &user_transactions,
                    &signatures,
                    &block_metadata_transactions,
                ),
                &events,
                &wscs,
                (
                    &move_modules,
                    &move_resources,
                    &table_items,
                    &current_table_items,
                    &table_metadata,
                ),
                (&objects, &current_objects),
            )
        }) {
```

**File:** crates/indexer/src/processors/default_processor.rs (L466-466)
```rust
                Some(" WHERE current_objects.last_transaction_version <= excluded.last_transaction_version "),
```
