# Audit Report

## Title
Privacy Violation in Telemetry Service: Default UUID Enables Cross-Node Telemetry Correlation

## Summary
The `default_uuid()` function in the telemetry authentication system returns `Uuid::default()` (all zeros), which allows attackers to omit the `run_uuid` field in authentication requests. This enables multiple nodes to receive JWT tokens with identical UUIDs, breaking the privacy guarantee that each node run should have a unique identifier and allowing correlation of telemetry data across different nodes. [1](#0-0) 

## Finding Description
The telemetry service uses `run_uuid` as a privacy-preserving identifier to track telemetry data from individual node runs without exposing persistent node identities. However, the `AuthRequest` struct uses a serde default that returns `Uuid::default()` when the field is omitted. [2](#0-1) 

When a node authenticates with the telemetry service, the `run_uuid` from the request is embedded directly into the JWT claims: [3](#0-2) [4](#0-3) 

This UUID is then attached as a label to all metrics submitted by the node: [5](#0-4) 

**Attack Path:**
1. Attacker modifies their telemetry client to omit the `run_uuid` field when sending `AuthRequest`
2. The serde deserializer applies the default value: `Uuid::default()` (00000000-0000-0000-0000-000000000000)
3. The authentication succeeds and returns a JWT with `run_uuid: 00000000-0000-0000-0000-000000000000`
4. All metrics from this node are labeled with `run_uuid=00000000-0000-0000-0000-000000000000`
5. Multiple attackers (or the same attacker with multiple nodes) can repeat this to correlate their telemetry
6. This allows tracking and correlation of metrics across different nodes, defeating the privacy protection

The test suite confirms this behavior is intentionally supported for backwards compatibility: [6](#0-5) 

## Impact Explanation
This vulnerability allows systematic privacy violations in the telemetry system. According to the Aptos bug bounty categories, this qualifies as **Medium Severity** because:

1. **Privacy Guarantee Violation**: The design intent is that each node run should have a unique UUID for privacy. By allowing identical UUIDs, this fundamental guarantee is broken.

2. **Cross-Node Correlation**: Attackers can correlate telemetry data from multiple nodes, potentially revealing:
   - Network topology and peer relationships
   - Geographic distribution (when location labels are enabled)
   - Performance characteristics and patterns
   - Node operator identities through behavioral fingerprinting
   - Coordinated attack patterns

3. **Scope**: While legitimate clients properly generate unique UUIDs, the backwards compatibility default creates an exploitable path that defeats the privacy mechanism for any node that chooses to use it (maliciously or otherwise).

The legitimate client implementation does generate proper UUIDs: [7](#0-6) [8](#0-7) 

However, the server accepts requests without this field, undermining the privacy protection.

## Likelihood Explanation
**Likelihood: Medium to High**

1. **Easy to Exploit**: An attacker only needs to omit a single JSON field in the authentication request
2. **No Special Permissions Required**: Any node operator can exploit this
3. **Backwards Compatibility Trade-off**: The feature exists intentionally to support older clients, but creates an exploitable gap
4. **Detection Difficulty**: Correlation attacks are subtle and may not be immediately detected

## Recommendation

**Option 1: Require run_uuid (Breaking Change)**
Remove the serde default and make `run_uuid` a required field:

```rust
#[derive(Serialize, Deserialize, Debug)]
pub struct AuthRequest {
    pub chain_id: ChainId,
    pub peer_id: PeerId,
    #[serde(default = "default_role_type")]
    pub role_type: RoleType,
    pub server_public_key: x25519::PublicKey,
    pub handshake_msg: Vec<u8>,
    // Remove the serde(default) attribute
    pub run_uuid: Uuid,
}
```

**Option 2: Generate Server-Side UUID (Backwards Compatible)**
When `run_uuid` is missing or equals `Uuid::default()`, generate a unique UUID server-side:

```rust
pub async fn handle_auth(context: Context, body: AuthRequest) -> Result<impl Reply, Rejection> {
    // ... existing validation code ...
    
    // Generate unique UUID if default/missing
    let run_uuid = if body.run_uuid == Uuid::default() {
        Uuid::new_v4()
    } else {
        body.run_uuid
    };
    
    let token = create_jwt_token(
        context.jwt_service(),
        body.chain_id,
        body.peer_id,
        node_type,
        epoch,
        run_uuid,  // Use the validated/generated UUID
    )
    // ... rest of function ...
}
```

**Option 3: Reject Default UUIDs**
Explicitly reject authentication requests with `Uuid::default()`:

```rust
pub async fn handle_auth(context: Context, body: AuthRequest) -> Result<impl Reply, Rejection> {
    // ... existing validation code ...
    
    if body.run_uuid == Uuid::default() {
        return Err(reject::custom(ServiceError::bad_request(
            ServiceErrorCode::AuthError(
                AuthError::InvalidRunUuid,
                body.chain_id,
            ),
        )));
    }
    
    // ... continue with authentication ...
}
```

**Recommended Solution**: Option 2 (server-side generation) provides the best balance of security and backwards compatibility, ensuring every authenticated session has a unique UUID without breaking older clients.

## Proof of Concept

The existing test demonstrates the vulnerability: [9](#0-8) 

This test shows that when `run_uuid` is omitted from the request (line 129-135), the authentication succeeds and the resulting JWT contains `run_uuid: Uuid::default()` (line 152).

To demonstrate the privacy violation, multiple nodes can authenticate without `run_uuid` and all receive tokens with identical UUIDs, enabling their telemetry to be correlated through the `run_uuid=00000000-0000-0000-0000-000000000000` label in metrics.

## Notes

While the backwards compatibility intent is understandable, the current implementation creates a privacy vulnerability. The telemetry system's design explicitly includes `run_uuid` for privacy protection, and allowing multiple nodes to share the same UUID (intentionally or not) defeats this protection. The server should enforce unique identifiers rather than relying solely on client-side generation.

### Citations

**File:** crates/aptos-telemetry-service/src/types/auth.rs (L11-21)
```rust
#[derive(Serialize, Deserialize, Debug)]
pub struct AuthRequest {
    pub chain_id: ChainId,
    pub peer_id: PeerId,
    #[serde(default = "default_role_type")]
    pub role_type: RoleType,
    pub server_public_key: x25519::PublicKey,
    pub handshake_msg: Vec<u8>,
    #[serde(default = "default_uuid")]
    pub run_uuid: Uuid,
}
```

**File:** crates/aptos-telemetry-service/src/types/auth.rs (L43-45)
```rust
fn default_uuid() -> Uuid {
    Uuid::default()
}
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L137-144)
```rust
    let token = create_jwt_token(
        context.jwt_service(),
        body.chain_id,
        body.peer_id,
        node_type,
        epoch,
        body.run_uuid,
    )
```

**File:** crates/aptos-telemetry-service/src/jwt_auth.rs (L32-40)
```rust
    let claims = Claims {
        chain_id,
        peer_id,
        node_type,
        epoch,
        exp: expiration as usize,
        iat: issued as usize,
        run_uuid: uuid,
    };
```

**File:** crates/aptos-telemetry-service/src/prometheus_push_metrics.rs (L158-187)
```rust
fn claims_to_extra_labels(claims: &Claims, common_name: Option<&String>) -> Vec<String> {
    let chain_name = if claims.chain_id.id() == 3 {
        format!("chain_name={}", claims.chain_id.id())
    } else {
        format!("chain_name={}", claims.chain_id)
    };
    let pod_name = if let Some(common_name) = common_name {
        format!(
            "kubernetes_pod_name=peer_id:{}//{}",
            common_name,
            claims.peer_id.to_hex_literal()
        )
    } else {
        // for community nodes we cannot determine which pod name they run in (or whether they run in k8s at all),
        // so we use the peer id as an approximation/replacement for pod_name
        // This works well with our existing grafana dashboards
        format!(
            "kubernetes_pod_name=peer_id:{}",
            claims.peer_id.to_hex_literal()
        )
    };
    vec![
        format!("role={}", claims.node_type),
        format!("metrics_source={}", "telemetry-service"),
        chain_name,
        format!("namespace={}", "telemetry-service"),
        pod_name,
        format!("run_uuid={}", claims.run_uuid),
    ]
}
```

**File:** crates/aptos-telemetry-service/src/tests/auth_test.rs (L113-154)
```rust
async fn test_auth_validator_backwards_compat_uuid() {
    let context = new_test_context().await;
    let server_public_key = context.inner.noise_config().public_key();

    let (mut rng, initiator, chain_id, peer_id, peer_set, _) = init(PeerRole::Validator);

    context
        .inner
        .peers()
        .validators()
        .write()
        .insert(chain_id, (1, peer_set));

    let (initiator_state, client_noise_msg) =
        init_handshake(&mut rng, chain_id, peer_id, server_public_key, &initiator);

    let req = json!({
        "chain_id": chain_id,
        "peer_id": peer_id,
        "role_type": RoleType::Validator,
        "server_public_key": server_public_key,
        "handshake_msg": &client_noise_msg,
    });
    let resp = context.post("/api/v1/auth", req).await;

    let decoded = finish_handshake(
        context.inner.jwt_service(),
        &initiator,
        initiator_state,
        resp,
    );

    assert_eq!(decoded.claims, Claims {
        chain_id,
        peer_id,
        node_type: NodeType::Validator,
        epoch: 1,
        exp: decoded.claims.exp,
        iat: decoded.claims.iat,
        run_uuid: Uuid::default(),
    },)
}
```

**File:** crates/aptos-telemetry/src/sender.rs (L82-91)
```rust
        Self {
            base_url,
            version_path_base,
            chain_id,
            peer_id: node_config.get_peer_id().unwrap_or(PeerId::ZERO),
            role_type: node_config.base.role,
            client,
            auth_context: Arc::new(AuthContext::new(node_config)),
            uuid: uuid::Uuid::new_v4(),
        }
```

**File:** crates/aptos-telemetry/src/sender.rs (L319-326)
```rust
        let auth_request = AuthRequest {
            chain_id: self.chain_id,
            peer_id: self.peer_id,
            role_type: self.role_type,
            server_public_key,
            handshake_msg: client_noise_msg,
            run_uuid: self.uuid,
        };
```
