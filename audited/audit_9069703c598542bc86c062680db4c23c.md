# Audit Report

## Title
Missing Low-Order Point Validation in x25519 Public Key Handling for Noise IK Protocol

## Summary
The x25519 public keys extracted from NetworkAddress for the Noise IK handshake lack validation to reject low-order (small subgroup) curve points. While invalid keys do not cause panics, they create a cryptographic weakness where malicious nodes can use low-order points to enable brute-force attacks on session keys.

## Finding Description

When parsing a NetworkAddress in `parse_dial_addr()`, the code extracts a raw x25519::PublicKey from the NoiseIK protocol without any validation. [1](#0-0) 

The x25519::PublicKey type accepts any 32-byte array without checking if it represents a valid curve point or validating against low-order points. [2](#0-1)  The TryFrom implementation only checks length. [3](#0-2) 

This unvalidated public key is then used directly in Diffie-Hellman operations during the Noise IK handshake. In the initiator's handshake, the remote static key is used in multiple DH operations: [4](#0-3)  and [5](#0-4) 

The responder side also performs DH with the initiator's static key without validation: [6](#0-5) 

**Attack Path:**
1. Attacker generates a low-order x25519 point (e.g., order-8 point) and uses it as their network static key
2. Attacker advertises this in their NetworkAddress via discovery
3. When honest nodes dial the attacker's address via `upgrade_outbound`, they extract the unvalidated key [7](#0-6) 
4. DH operations with the attacker's low-order static key produce outputs from a small set (â‰¤8 values)
5. Attacker brute-forces all possible session keys (at most 8 attempts)
6. Attacker decrypts and potentially forges messages in the session

**Why no panics occur:**
The x25519_dalek library performs scalar multiplication on any 32-byte input without validation [8](#0-7) , returning a result (possibly weak) rather than panicking.

## Impact Explanation

This constitutes a **Medium severity** cryptographic protocol violation per the bug bounty program's "Limited Protocol Violations" category. While it doesn't directly lead to funds loss or consensus breaks, it violates the Noise IK protocol's security guarantees:

- **Confidentiality compromise**: Attacker can decrypt handshake messages and session traffic directed to them
- **Limited scope**: Only affects sessions where honest nodes connect TO the malicious node  
- **Network layer weakness**: Could expose validator communication metadata or peer discovery information

The issue does not meet Critical/High severity because:
- No direct funds theft or consensus safety violation
- Attacker cannot forge messages without also controlling the peer
- Limited to specific attack scenarios (malicious node operator)
- No impact on validator performance or API availability

## Likelihood Explanation

**Moderate likelihood** of exploitation:
- Requires attacker to operate a network node and control its identity key
- Attacker must successfully advertise malicious public key via NetworkAddress discovery
- Other nodes must initiate connections to the attacker
- Detection is possible through monitoring for known low-order points

Importantly, Ed25519 implementations within the same codebase perform explicit small subgroup validation, demonstrating that this validation is considered necessary for elliptic curve keys. [9](#0-8)  The codebase also maintains test constants for the 8-torsion subgroup. [10](#0-9) 

This creates an inconsistency where Ed25519 keys are validated for low-order points but x25519 keys are not, despite both being used for cryptographic operations on the same elliptic curve.

## Recommendation

Implement low-order point validation for x25519 public keys before using them in cryptographic operations. This can be done by:

1. Adding a validation function in `x25519.rs` that checks if a point has low order
2. Calling this validation in `parse_dial_addr()` before accepting the public key
3. Alternatively, validating in `x25519::PublicKey::try_from()` to catch all conversions

The validation should reject the known low-order points on Curve25519, similar to the `is_small_order()` check used for Ed25519 keys.

## Proof of Concept

While a complete PoC would require setting up network nodes, the vulnerability can be demonstrated by:

1. Generating a low-order x25519 point (one of the 8-torsion subgroup points)
2. Creating a NetworkAddress with NoiseIK protocol containing this point
3. Observing that `parse_dial_addr()` accepts it without validation
4. Verifying that the Noise handshake proceeds with predictable DH outputs

The technical feasibility is confirmed by the code paths shown above, where no validation occurs between NetworkAddress extraction and cryptographic use.

## Notes

This vulnerability represents a real cryptographic protocol weakness in Aptos's network layer. While the practical impact is limited to network-level confidentiality and does not directly affect consensus or funds, it violates fundamental security assumptions of the Noise IK protocol and creates an exploitable weakness that a malicious network node operator could leverage. The inconsistency with Ed25519 validation practices further indicates this is an oversight rather than an intentional design decision.

### Citations

**File:** network/framework/src/transport/mod.rs (L498-503)
```rust
        match base_transport_suffix {
            [NoiseIK(pubkey), Handshake(version)] => {
                let base_addr = NetworkAddress::try_from(base_transport_protos.to_vec())
                    .expect("base_transport_protos is always non-empty");
                Ok((base_addr, *pubkey, *version))
            },
```

**File:** crates/aptos-crypto/src/x25519.rs (L90-94)
```rust
    pub fn diffie_hellman(&self, remote_public_key: &PublicKey) -> [u8; SHARED_SECRET_SIZE] {
        let remote_public_key = x25519_dalek::PublicKey::from(remote_public_key.0);
        let shared_secret = self.0.diffie_hellman(&remote_public_key);
        shared_secret.as_bytes().to_owned()
    }
```

**File:** crates/aptos-crypto/src/x25519.rs (L222-226)
```rust
impl std::convert::From<[u8; PUBLIC_KEY_SIZE]> for PublicKey {
    fn from(public_key_bytes: [u8; PUBLIC_KEY_SIZE]) -> Self {
        Self(public_key_bytes)
    }
}
```

**File:** crates/aptos-crypto/src/x25519.rs (L228-236)
```rust
impl std::convert::TryFrom<&[u8]> for PublicKey {
    type Error = traits::CryptoMaterialError;

    fn try_from(public_key_bytes: &[u8]) -> Result<Self, Self::Error> {
        let public_key_bytes: [u8; PUBLIC_KEY_SIZE] = public_key_bytes
            .try_into()
            .map_err(|_| traits::CryptoMaterialError::WrongLengthError)?;
        Ok(Self(public_key_bytes))
    }
```

**File:** crates/aptos-crypto/src/noise.rs (L309-311)
```rust
        // -> es
        let dh_output = e.diffie_hellman(&rs);
        let k = mix_key(&mut ck, &dh_output)?;
```

**File:** crates/aptos-crypto/src/noise.rs (L327-328)
```rust
        let dh_output = self.private_key.diffie_hellman(&rs);
        let k = mix_key(&mut ck, &dh_output)?;
```

**File:** crates/aptos-crypto/src/noise.rs (L468-470)
```rust
        // <- ss
        let dh_output = self.private_key.diffie_hellman(&rs);
        let k = mix_key(&mut ck, &dh_output)?;
```

**File:** network/framework/src/noise/handshake.rs (L207-218)
```rust
        // craft first handshake message  (-> e, es, s, ss)
        let mut rng = rand::rngs::OsRng;
        let initiator_state = self
            .noise_config
            .initiate_connection(
                &mut rng,
                prologue_msg,
                remote_public_key,
                Some(&payload),
                client_noise_msg,
            )
            .map_err(NoiseHandshakeError::BuildClientHandshakeMessageFailed)?;
```

**File:** aptos-move/framework/src/natives/cryptography/ed25519.rs (L76-80)
```rust
    // Check if the point lies on a small subgroup. This is required when using curves with a
    // small cofactor (e.g., in Ed25519, cofactor = 8).
    // NOTE(Gas): O(1) cost: multiplies the point by the cofactor
    context.charge(ED25519_PER_PUBKEY_SMALL_ORDER_CHECK * NumArgs::one())?;
    let valid = !point.is_small_order();
```

**File:** crates/aptos-crypto/src/unit_tests/ed25519_test.rs (L502-510)
```rust
// The 8-torsion subgroup E[8].
//
// In the case of Curve25519, it is cyclic; the i-th element of
// the array is [i]P, where P is a point of order 8
// generating E[8].
//
// Thus E[8] is the points indexed by `0,2,4,6`, and
// E[2] is the points indexed by `0,4`.
//
```
