# Audit Report

## Title
Race Condition in File Store Metadata Updates Allows Indexer State Divergence in Multi-Master Deployments

## Summary
The indexer-grpc file store system lacks atomic metadata update mechanisms and distributed coordination, allowing multiple indexer instances configured as "master" to concurrently update the shared `metadata.json` file without synchronization. This race condition can cause indexer state divergence, data corruption, and inconsistent views of the current processed version across instances.

## Finding Description

The indexer-grpc file store uses a master-replica architecture where the master instance processes transactions from cache and writes them to a shared file store (GCS or local filesystem). The system maintains a `metadata.json` file tracking the latest processed version. [1](#0-0) 

The `is_master` configuration flag is a simple boolean with no distributed coordination mechanism. [2](#0-1) 

When configured as master, instances run the `FileStoreUploader` which periodically updates metadata. [3](#0-2) 

The metadata update process reads the current metadata, processes transactions, then writes the updated metadata. [4](#0-3) 

For GCS deployments, metadata updates use `Object::create()` without any preconditions, generation matching, or atomic compare-and-swap operations. [5](#0-4) 

**Race Condition Scenario:**
1. Instance A (master) reads `metadata.version = 1000`
2. Instance B (master) reads `metadata.version = 1000`
3. Instance A processes transactions 1000-1999, writes `metadata.version = 2000`
4. Instance B processes transactions 1000-1999, overwrites `metadata.version = 2000`
5. Both instances uploaded duplicate transaction files for the same range
6. Or worse: Instance B processes 2000-2999 while A is at 1000-1999, causing version skips

The data manager relies on this metadata for cache garbage collection and version tracking. [6](#0-5) 

If metadata versions diverge or go backward, the system panics. [7](#0-6) 

## Impact Explanation

**Severity: Medium** (State inconsistencies requiring intervention)

This vulnerability causes:
1. **Data Corruption**: Duplicate or missing transaction files in the file store
2. **State Divergence**: Different indexer instances maintain inconsistent views of processed versions
3. **Service Disruption**: Panic conditions when metadata versions go backward
4. **Manual Intervention Required**: Operators must manually reconcile corrupted file store state

While this affects indexer availability and data integrity, it does **not** impact the blockchain consensus layer, validator operations, or on-chain state. The indexer is off-chain infrastructure for data queries. However, applications relying on the indexer would receive inconsistent or corrupted data, requiring manual recovery.

## Likelihood Explanation

**Likelihood: Medium-High**

This issue occurs when:
- Multiple instances are accidentally configured with `is_master: true` (operational error)
- Horizontal scaling is attempted without proper coordination
- Deployment automation incorrectly replicates master configuration

The likelihood increases with:
- Complex deployment environments (Kubernetes, multiple regions)
- Lack of deployment validation checks
- Operator unfamiliarity with the master-replica requirement

The lack of safeguards means a simple configuration error immediately triggers the race condition.

## Recommendation

Implement distributed coordination using one of these approaches:

**Option 1: Add GCS Conditional Writes**
Use GCS generation/metageneration matching for atomic metadata updates:
```rust
// In GcsFileStore::save_raw_file for metadata.json
Object::create_with_options(
    bucket_name,
    data,
    path,
    JSON_FILE_TYPE,
    CreateOptions {
        if_generation_match: Some(current_generation),
        ..Default::default()
    }
).await?;
```

**Option 2: Implement Distributed Locking**
Use Redis-based distributed locks before metadata updates:
```rust
// Acquire lock before metadata update
let lock = redis_lock.acquire("filestore_metadata_lock", Duration::from_secs(30)).await?;
// Update metadata
// Release lock
```

**Option 3: Add Runtime Master Election**
Implement automatic master election instead of static configuration using consensus protocols like Raft or leader election via Redis/etcd.

**Option 4: Add Deployment Validation**
Add startup checks to verify only one master exists:
```rust
// On startup, check if another master is active
// Register self in shared registry
// Fail fast if multiple masters detected
```

## Proof of Concept

```rust
// Reproduction Steps:
// 1. Deploy two indexer-grpc-manager instances with identical config
// 2. Set is_master: true in both configurations
// 3. Point both to the same GCS bucket
// 4. Start both instances simultaneously

// Expected Result:
// - Race condition on metadata.json updates
// - Duplicate transaction files uploaded
// - Metadata version inconsistencies
// - Potential panic when version goes backward

// Configuration for Instance A:
// is_master: true
// file_store_config: { bucket: "shared-bucket" }

// Configuration for Instance B:  
// is_master: true
// file_store_config: { bucket: "shared-bucket" }

// Observe:
// - Both instances call FileStoreUploader::update_file_store_metadata()
// - No synchronization between instances
// - GCS Object::create() allows last-write-wins
// - State divergence occurs
```

## Notes

This vulnerability is rooted in the assumption that operational discipline prevents multiple masters. The code implements the master-replica pattern correctly at the application level, but lacks defensive programming to prevent misconfiguration. Adding atomic operations or distributed locks would make the system resilient to deployment errors and safer for production use at scale.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/common.rs (L11-16)
```rust
#[derive(Serialize, Deserialize, Debug)]
pub struct FileStoreMetadata {
    pub chain_id: u64,
    pub num_transactions_per_folder: u64,
    pub version: u64,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L40-40)
```rust
    pub(crate) is_master: bool,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L112-120)
```rust
            if self.is_master {
                s.spawn(async move {
                    self.file_store_uploader
                        .lock()
                        .await
                        .start(self.data_manager.clone(), tx)
                        .await
                        .unwrap();
                });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L261-274)
```rust
    /// Updates the file store metadata.
    async fn update_file_store_metadata(&self, version: u64) -> Result<()> {
        FILE_STORE_VERSION.set(version as i64);
        let metadata = FileStoreMetadata {
            chain_id: self.chain_id,
            num_transactions_per_folder: NUM_TXNS_PER_FOLDER,
            version,
        };

        let raw_data = serde_json::to_vec(&metadata).map_err(anyhow::Error::msg)?;
        self.writer
            .save_raw_file(PathBuf::from(METADATA_FILE_NAME), raw_data)
            .await
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/gcs.rs (L120-137)
```rust
    async fn save_raw_file(&self, file_path: PathBuf, data: Vec<u8>) -> Result<()> {
        let path = self.get_path(file_path);
        trace!(
            "Uploading object to {}/{}.",
            self.bucket_name,
            path.as_str()
        );
        Object::create(
            self.bucket_name.as_str(),
            data,
            path.as_str(),
            JSON_FILE_TYPE,
        )
        .await
        .map_err(anyhow::Error::msg)?;

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L403-419)
```rust
    async fn update_file_store_version_in_cache(
        &self,
        cache: &RwLockReadGuard<'_, Cache>,
        version_can_go_backward: bool,
    ) {
        let file_store_version = self.file_store_reader.get_latest_version().await;
        if let Some(file_store_version) = file_store_version {
            let file_store_version_before_update = cache
                .file_store_version
                .fetch_max(file_store_version, Ordering::SeqCst);
            FILE_STORE_VERSION_IN_CACHE.set(file_store_version as i64);
            info!("Updated file_store_version in cache to {file_store_version}.");
            if !version_can_go_backward && file_store_version_before_update > file_store_version {
                panic!("File store version is going backward, data might be corrupted. {file_store_version_before_update} v.s. {file_store_version}");
            };
        }
    }
```
