# Audit Report

## Title
Silent Message Delivery Failures in NetworkMessageService Hide Execution Errors from Remote Executor Coordinators

## Summary
The `NetworkMessageService` trait implementation in `GRPCNetworkMessageServiceServerWrapper` always returns success (`Ok`) even when execution commands are not delivered to registered handlers, causing coordinators to indefinitely wait for results that will never arrive. This error suppression violates the contract between coordinators and executor shards, leading to liveness failures in sharded block execution.

## Finding Description

The `NetworkMessageService::simple_msg_exchange` implementation has critical error handling flaws that hide execution failures from coordinators. [1](#0-0) 

The server implementation suppresses errors in two ways:

**Issue 1: Silent Message Drops** [2](#0-1) 

When no handler is registered for a message type, the implementation logs an error but returns `Ok(Response::new(Empty {}))`. The coordinator receives a success response indicating the message was delivered, when in fact it was silently dropped.

**Issue 2: Panic on Channel Failures** [3](#0-2) 

The `.unwrap()` call will panic if the channel's receiver is disconnected or the channel is full, crashing the entire gRPC server.

**Exploitation Path:**

1. Coordinator sends `ExecuteBlockCommand` to executor shard via the remote executor client: [4](#0-3) 

2. The message is sent through the network controller's outbound handler: [5](#0-4) 

3. The gRPC client calls `simple_msg_exchange`: [6](#0-5) 

4. The server's `simple_msg_exchange` receives the message but:
   - If timing window during startup/shutdown: no handler registered â†’ returns success but message is lost
   - If handler channel is disconnected: panics and crashes server

5. Coordinator waits for results that never arrive: [7](#0-6) 

The coordinator blocks indefinitely on `rx.recv().unwrap()`, causing a complete liveness failure for that shard's block execution.

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program:

- **State inconsistencies requiring intervention**: The coordinator believes commands were delivered successfully while shards never received them, creating inconsistent execution states that require manual intervention to recover.

- **Liveness failures**: Block execution on affected shards hangs indefinitely when commands are silently dropped, requiring process restart.

While this primarily affects the remote executor feature (used for sharded execution), it violates the critical invariant that **execution commands must be reliably delivered between coordinators and executor shards**. Silent failures undermine the entire remote execution architecture.

The vulnerability can occur naturally during:
- Service startup race conditions (handlers not yet registered)
- Shutdown sequences (handlers already dropped)
- Malformed or unexpected message types

## Likelihood Explanation

**Moderate to High Likelihood** in production deployments using remote executor:

1. **Startup Race Conditions**: The network controller starts the gRPC server before the executor service registers all handlers: [8](#0-7) 

If messages arrive during this window, they are silently dropped.

2. **Shutdown Sequences**: When `ExecutorService::shutdown()` is called, handlers may be dropped before the network controller stops accepting messages.

3. **Message Type Mismatches**: Any mismatch in message type strings between sender and receiver causes silent drops.

While external exploitation requires network access to the gRPC endpoints (which may be internal-only in production), the vulnerability can trigger naturally during normal operations, making it a reliability issue even without malicious actors.

## Recommendation

**Fix 1: Return proper gRPC errors instead of success**

```rust
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    let _timer = NETWORK_HANDLER_TIMER
        .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
        .start_timer();
    let remote_addr = request.remote_addr();
    let network_message = request.into_inner();
    let msg = Message::new(network_message.message);
    let message_type = MessageType::new(network_message.message_type);

    if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
        // Return error instead of panic if send fails
        handler.send(msg).map_err(|e| {
            Status::internal(format!("Failed to deliver message to handler: {}", e))
        })?;
    } else {
        // Return error instead of logging and returning Ok
        return Err(Status::not_found(format!(
            "No handler registered for message type: {:?}",
            message_type
        )));
    }
    Ok(Response::new(Empty {}))
}
```

**Fix 2: Add retry logic on the client side** [9](#0-8) 

Replace the panic with exponential backoff retry as noted in the TODO comment.

**Fix 3: Ensure proper service startup ordering**

Delay network controller startup until all handlers are registered, or implement a readiness check.

## Proof of Concept

```rust
#[test]
fn test_unregistered_handler_returns_error() {
    use std::net::{IpAddr, Ipv4Addr, SocketAddr};
    use aptos_config::utils;
    use tokio::runtime::Runtime;

    let server_addr = SocketAddr::new(
        IpAddr::V4(Ipv4Addr::LOCALHOST), 
        utils::get_available_port()
    );
    
    // Create server with NO handlers registered
    let server_handlers = Arc::new(Mutex::new(HashMap::new()));
    let server = GRPCNetworkMessageServiceServerWrapper::new(
        server_handlers, 
        server_addr
    );

    let rt = Runtime::new().unwrap();
    let (shutdown_tx, shutdown_rx) = oneshot::channel();
    
    server.start(&rt, "test".to_string(), server_addr, 1000, shutdown_rx);
    
    // Wait for server to start
    std::thread::sleep(std::time::Duration::from_millis(100));

    // Create client and send message to unregistered handler
    let mut client = GRPCNetworkMessageServiceClientWrapper::new(&rt, server_addr);
    let client_addr = SocketAddr::new(
        IpAddr::V4(Ipv4Addr::LOCALHOST), 
        utils::get_available_port()
    );
    
    // This should FAIL but currently returns Ok
    let result = rt.block_on(async {
        client.send_message(
            client_addr,
            Message::new(b"test".to_vec()),
            &MessageType::new("unregistered_type".to_string()),
        ).await
    });
    
    // Currently this doesn't panic because server returns Ok
    // After fix, this should return an error
    
    shutdown_tx.send(()).unwrap();
}

#[test] 
fn test_coordinator_hangs_on_dropped_messages() {
    // Simulate coordinator sending ExecuteBlockCommand
    // Server drops message during startup race
    // Coordinator's get_output_from_shards() blocks forever
    // This demonstrates the liveness failure
}
```

## Notes

This vulnerability directly answers the security question: "Can implementations of the NetworkMessageService trait suppress or mishandle tonic::Status errors in ways that hide execution failures from coordinators?" 

The answer is **yes** - the implementation suppresses errors by:
1. Returning `Ok` when no handler exists (should return `Status::not_found`)
2. Panicking on channel errors (should return `Status::internal`)

Both patterns hide execution failures from coordinators, violating the error propagation contract required for reliable remote execution.

### Citations

**File:** protos/rust/src/pb/aptos.remote_executor.v1.tonic.rs (L127-133)
```rust
    pub trait NetworkMessageService: Send + Sync + 'static {
        ///
        async fn simple_msg_exchange(
            &self,
            request: tonic::Request<super::NetworkMessage>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L105-114)
```rust
        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
```

**File:** secure/net/src/grpc_network_service/mod.rs (L140-160)
```rust
    pub async fn send_message(
        &mut self,
        sender_addr: SocketAddr,
        message: Message,
        mt: &MessageType,
    ) {
        let request = tonic::Request::new(NetworkMessage {
            message: message.data,
            message_type: mt.get_type(),
        });
        // TODO: Retry with exponential backoff on failures
        match self.remote_channel.simple_msg_exchange(request).await {
            Ok(_) => {},
            Err(e) => {
                panic!(
                    "Error '{}' sending message to {} on node {:?}",
                    e, self.remote_addr, sender_addr
                );
            },
        }
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L166-169)
```rust
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
```

**File:** execution/executor-service/src/remote_executor_client.rs (L201-206)
```rust
            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
        }
```

**File:** secure/net/src/network_controller/outbound_handler.rs (L155-160)
```rust
                grpc_clients
                    .get_mut(remote_addr)
                    .unwrap()
                    .send_message(*socket_addr, msg, message_type)
                    .await;
            }
```

**File:** execution/executor-service/src/remote_executor_service.rs (L57-66)
```rust
    pub fn start(&mut self) {
        self.controller.start();
        let thread_name = format!("ExecutorService-{}", self.shard_id);
        let builder = thread::Builder::new().name(thread_name);
        let executor_service_clone = self.executor_service.clone();
        builder
            .spawn(move || {
                executor_service_clone.start();
            })
            .expect("Failed to spawn thread");
```
