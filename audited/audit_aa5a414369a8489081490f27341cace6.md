# Audit Report

## Title
Multisig Address Spoofing Allows Bypass of Transaction Filters in Mempool and Consensus

## Summary
The `matches_multisig_address()` function in the transaction filter module accepts the `multisig_address` field from transaction payloads without validation, allowing attackers to spoof multisig addresses to bypass filter rules before proper validation occurs during VM execution.

## Finding Description

The transaction filtering system in Aptos uses the `matches_multisig_address()` function to match transactions against configured filter rules based on multisig account addresses. However, this function directly extracts the `multisig_address` field from the transaction payload without any validation: [1](#0-0) 

The function simply reads `multisig.multisig_address` from the payload and compares it to the target address. An attacker can set this field to any arbitrary address when constructing their transaction.

This unvalidated field is then used by the `AccountAddress` matcher in the filtering logic: [2](#0-1) 

The filter is applied **before** VM validation in two critical locations:

1. **Mempool filtering** - transactions are filtered before entering the mempool: [3](#0-2) 

2. **Consensus block filtering** - through `BlockTransactionFilter` which reuses `TransactionMatcher`: [4](#0-3) 

The actual validation of the multisig address only occurs later during transaction execution in the VM prologue: [5](#0-4) 

This calls the Move validation function which properly checks ownership and approvals: [6](#0-5) 

**Attack Path:**
1. Attacker creates a multisig transaction with sender address A
2. Attacker sets `multisig_address` field to address B (a legitimate multisig account they don't own)
3. If filters are configured to block address A or allow only address B, the transaction passes the filter check
4. Transaction consumes mempool and validation resources
5. Transaction eventually fails in VM prologue validation (because sender A is not an owner of multisig B)
6. But the filter policy has already been bypassed

## Impact Explanation

This vulnerability qualifies as **High Severity** based on the following impacts:

1. **Access Control Bypass**: Filters are used to enforce operational policies such as allowing/denying specific multisig accounts. This bypass allows attackers to circumvent these policies, making transactions appear to originate from different multisig accounts.

2. **Resource Exhaustion**: Attackers can bypass filters designed to prevent resource exhaustion by making transactions appear to come from legitimate multisig accounts. While per-sender quotas still apply, the filter's purpose as an early rejection mechanism is defeated.

3. **Consensus Layer Impact**: The vulnerability extends to consensus-level filtering through `BlockTransactionFilter`, potentially allowing spoofed transactions into blocks before proper validation.

While this does not result in direct funds loss or consensus violations (as VM validation ultimately rejects invalid transactions), it represents a significant protocol violation where a security mechanism (transaction filtering) can be trivially bypassed.

## Likelihood Explanation

The likelihood of exploitation is **HIGH**:

1. **Trivial to Exploit**: An attacker simply needs to set the `multisig_address` field to any arbitrary address when creating a multisig transaction. No special privileges or complex techniques are required.

2. **Common Use Case**: Transaction filters are designed to be configurable for operational purposes, including multisig address-based filtering. Operators who configure such filters expect them to function correctly.

3. **No Detection Required**: The attack requires no reconnaissance or specific knowledge beyond understanding the transaction payload format.

4. **Realistic Scenarios**: 
   - Networks may whitelist specific multisig governance accounts
   - Filters may block problematic multisig accounts
   - Rate limiting may apply different rules to different multisig accounts

## Recommendation

The fix requires validating the `multisig_address` field before using it in filter decisions. However, this validation would require on-chain state access (to check if the multisig account exists and if the sender is an owner), which is expensive at the filter stage.

**Recommended Solution**: Remove multisig address matching from the filter logic entirely, as it cannot be validated without on-chain state access. Filters should only match on fields that can be validated from the transaction itself:

```rust
// In TransactionMatcher::AccountAddress, remove the multisig address check:
TransactionMatcher::AccountAddress(address) => {
    matches_sender_address(signed_transaction, address)
        || matches_entry_function_module_address(signed_transaction, address)
        // REMOVE: || matches_multisig_address(signed_transaction, address)
        || matches_script_argument_address(signed_transaction, address)
        || matches_transaction_authenticator_address(signed_transaction, address)
}
```

**Alternative Solution**: Add a separate, explicit `MultisigAddress` matcher that includes a clear warning in documentation that this field is unvalidated and should not be used for security-critical filtering.

**Long-term Solution**: If multisig address filtering is essential, implement a validation cache that tracks valid multisig accounts and their owners, updated from committed blocks. However, this adds significant complexity.

## Proof of Concept

```rust
// Proof of Concept demonstrating filter bypass

use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, SigningKey};
use aptos_transaction_filters::transaction_filter::TransactionFilter;
use aptos_types::{
    account_address::AccountAddress,
    chain_id::ChainId,
    transaction::{
        EntryFunction, MultisigTransactionPayload, RawTransaction, SignedTransaction,
        TransactionPayload,
    },
};
use move_core_types::{
    identifier::Identifier,
    language_storage::ModuleId,
};

fn main() {
    // Setup: Create a filter that DENIES transactions from attacker's multisig address
    let attacker_multisig_addr = AccountAddress::from_hex_literal("0xBAD").unwrap();
    let victim_multisig_addr = AccountAddress::from_hex_literal("0x123").unwrap();
    
    let filter = TransactionFilter::empty()
        .add_account_address_filter(false, attacker_multisig_addr); // DENY attacker's address
    
    // Create attacker's transaction with SPOOFED multisig_address pointing to victim
    let attacker_addr = AccountAddress::from_hex_literal("0xATTACKER").unwrap();
    let private_key = Ed25519PrivateKey::generate_for_testing();
    
    // Create a multisig transaction with SPOOFED multisig_address
    let entry_function = EntryFunction::new(
        ModuleId::new(AccountAddress::ONE, Identifier::new("test").unwrap()),
        Identifier::new("test_function").unwrap(),
        vec![],
        vec![],
    );
    
    let multisig_payload = aptos_types::transaction::Multisig {
        multisig_address: victim_multisig_addr, // SPOOFED - attacker sets this to victim's address
        transaction_payload: Some(MultisigTransactionPayload::EntryFunction(entry_function)),
    };
    
    let raw_txn = RawTransaction::new(
        attacker_addr, // Real sender is attacker
        0,
        TransactionPayload::Multisig(multisig_payload),
        1000000,
        1,
        1000000000,
        ChainId::test(),
    );
    
    let signature = private_key.sign(&raw_txn).unwrap();
    let signed_txn = SignedTransaction::new(raw_txn, private_key.public_key(), signature);
    
    // TEST: The filter should DENY this transaction (from attacker's multisig)
    // but it will ALLOW it because multisig_address is spoofed to victim's address
    let allowed = filter.allows_transaction(&signed_txn);
    
    println!("Transaction with spoofed multisig_address allowed: {}", allowed);
    println!("Expected: false (should be denied)");
    println!("Actual: true (filter bypassed!)");
    
    // This transaction would later fail in VM validation when it checks that
    // the attacker is not an owner of the victim's multisig account,
    // but it has already bypassed the mempool filter.
}
```

## Notes

The vulnerability demonstrates a time-of-check-time-of-use (TOCTOU) issue where the filter checks an unvalidated field that only gets properly validated later during VM execution. This is particularly concerning because:

1. Filters are explicitly designed as performance optimizations to reject bad transactions early
2. The `multisig_address` field appears trustworthy in the filter context but is actually attacker-controlled
3. No warning exists in the code or documentation about this validation gap

While the VM ultimately enforces correct multisig validation, the intermediate bypass allows resource exhaustion attacks and defeats the purpose of configurable transaction filtering policies.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L197-203)
```rust
            TransactionMatcher::AccountAddress(address) => {
                matches_sender_address(signed_transaction, address)
                    || matches_entry_function_module_address(signed_transaction, address)
                    || matches_multisig_address(signed_transaction, address)
                    || matches_script_argument_address(signed_transaction, address)
                    || matches_transaction_authenticator_address(signed_transaction, address)
            },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L421-447)
```rust
fn matches_multisig_address(
    signed_transaction: &SignedTransaction,
    address: &AccountAddress,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.payload() {
        TransactionPayload::EntryFunction(_)
        | TransactionPayload::Script(_)
        | TransactionPayload::ModuleBundle(_) => false,
        TransactionPayload::Multisig(multisig) => multisig.multisig_address == *address,
        TransactionPayload::Payload(TransactionPayloadInner::V1 { extra_config, .. }) => {
            match extra_config {
                TransactionExtraConfig::V1 {
                    multisig_address, ..
                } => multisig_address
                    .map(|multisig_address| multisig_address == *address)
                    .unwrap_or(false),
            }
        },
        TransactionPayload::EncryptedPayload(payload) => match payload.extra_config() {
            TransactionExtraConfig::V1 {
                multisig_address, ..
            } => multisig_address
                .map(|multisig_address| multisig_address == *address)
                .unwrap_or(false),
        },
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L408-466)
```rust
fn filter_transactions(
    transaction_filter_config: &TransactionFilterConfig,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(
    SignedTransaction,
    Option<u64>,
    Option<BroadcastPeerPriority>,
)> {
    // If the filter is not enabled, return early
    if !transaction_filter_config.is_enabled() {
        return transactions;
    }

    // Start the filter processing timer
    let transaction_filter_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FILTER_TRANSACTIONS_LABEL])
        .start_timer();

    // Filter the transactions and update the statuses accordingly
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
            } else {
                info!(LogSchema::event_log(
                    LogEntry::TransactionFilter,
                    LogEvent::TransactionRejected
                )
                .message(&format!(
                    "Transaction {} rejected by filter",
                    transaction.committed_hash()
                )));

                statuses.push((
                    transaction.clone(),
                    (
                        MempoolStatus::new(MempoolStatusCode::RejectedByFilter),
                        None,
                    ),
                ));
                None
            }
        })
        .collect();

    // Update the filter processing latency metrics
    transaction_filter_timer.stop_and_record();

    transactions
}
```

**File:** consensus/src/block_preparer.rs (L122-146)
```rust
/// Filters transactions in a block based on the filter configuration
fn filter_block_transactions(
    txn_filter_config: Arc<BlockTransactionFilterConfig>,
    block_id: HashValue,
    block_author: Option<AccountAddress>,
    block_epoch: u64,
    block_timestamp_usecs: u64,
    txns: Vec<SignedTransaction>,
) -> Vec<SignedTransaction> {
    // If the transaction filter is disabled, return early
    if !txn_filter_config.is_enabled() {
        return txns;
    }

    // Otherwise, filter the transactions
    txn_filter_config
        .block_transaction_filter()
        .filter_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp_usecs,
            txns,
        )
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2841-2860)
```rust
        if let Some(multisig_address) = extra_config.multisig_address() {
            // Once "simulation_enhancement" is enabled, the simulation path also validates the
            // multisig transaction by running the multisig prologue.
            if !self.is_simulation
                || self
                    .features()
                    .is_transaction_simulation_enhancement_enabled()
            {
                transaction_validation::run_multisig_prologue(
                    session,
                    module_storage,
                    txn_data,
                    executable,
                    multisig_address,
                    self.features(),
                    log_context,
                    traversal_context,
                )?
            }
        }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1139-1183)
```text
    fun validate_multisig_transaction(
        owner: &signer, multisig_account: address, payload: vector<u8>) acquires MultisigAccount {
        assert_multisig_account_exists(multisig_account);
        assert_is_owner(owner, multisig_account);
        let sequence_number = last_resolved_sequence_number(multisig_account) + 1;
        assert_transaction_exists(multisig_account, sequence_number);

        if (features::multisig_v2_enhancement_feature_enabled()) {
            assert!(
                can_execute(address_of(owner), multisig_account, sequence_number),
                error::invalid_argument(ENOT_ENOUGH_APPROVALS),
            );
        }
        else {
            assert!(
                can_be_executed(multisig_account, sequence_number),
                error::invalid_argument(ENOT_ENOUGH_APPROVALS),
            );
        };

        // If the transaction payload is not stored on chain, verify that the provided payload matches the hashes stored
        // on chain.
        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);
        let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);
        if (option::is_some(&transaction.payload_hash)) {
            let payload_hash = option::borrow(&transaction.payload_hash);
            assert!(
                sha3_256(payload) == *payload_hash,
                error::invalid_argument(EPAYLOAD_DOES_NOT_MATCH_HASH),
            );
        };

        // If the transaction payload is stored on chain and there is a provided payload,
        // verify that the provided payload matches the stored payload.
        if (features::abort_if_multisig_payload_mismatch_enabled()
            && option::is_some(&transaction.payload)
            && !vector::is_empty(&payload)
        ) {
            let stored_payload = option::borrow(&transaction.payload);
            assert!(
                payload == *stored_payload,
                error::invalid_argument(EPAYLOAD_DOES_NOT_MATCH),
            );
        }
    }
```
