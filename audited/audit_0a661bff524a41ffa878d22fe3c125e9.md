# Audit Report

## Title
Sensitive Vault Token Disclosure Through Node Configuration Logging and Remote Telemetry

## Summary
The Aptos node logs the complete `NodeConfig` structure during startup, which includes Vault authentication tokens when configured with `Token::FromConfig`. These logs can be transmitted to remote telemetry services, exposing sensitive credentials to unauthorized parties.

## Finding Description

The vulnerability exists in the node initialization flow where configuration data is logged without sanitization of sensitive fields:

**Primary Leak Path:**

1. At node startup, `log_all_configs()` is called [1](#0-0) 

2. This method serializes the entire `NodeConfig` to JSON and logs each section [2](#0-1) 

3. The `NodeConfig` contains `ConsensusConfig`, which includes `SafetyRulesConfig` with a `SecureBackend` field [3](#0-2) 

4. The `SecureBackend` can be a `VaultConfig` containing a `Token` enum [4](#0-3) 

5. The `Token` enum has `Debug` and `Serialize` derived, meaning `Token::FromConfig(String)` will expose the plaintext token [5](#0-4) 

**Secondary Leak Path:**

Additionally, the logger uses Debug formatting on the config [6](#0-5) , though postgres passwords receive some masking [7](#0-6) 

**Remote Exposure:**

When `enable_telemetry_remote_log` is enabled, logs are sent to remote telemetry endpoints [8](#0-7)  via HTTP POST to external services [9](#0-8) 

**Panic Handler Context:**

Regarding the original security question about panic safety: the crash handler logs panic information without sanitization [10](#0-9) , though the specific panic sites in `From<&SecureBackend> for Storage` don't currently leak tokens in their messages [11](#0-10) 

## Impact Explanation

This is classified as **Low Severity** (up to $1,000) per Aptos bug bounty criteria as a "Minor information leak." 

The exposed Vault tokens could allow unauthorized access to the validator's secure storage backend, potentially enabling:
- Reading of consensus keys and other secrets
- Modification of safety data
- Impersonation of the validator's identity

However, this requires:
1. Operator misconfiguration (using `Token::FromConfig` instead of `Token::FromDisk`)
2. Remote telemetry logging enabled
3. Attacker access to telemetry service or log aggregation systems

This does not directly lead to loss of funds, consensus violations, or network availability issues.

## Likelihood Explanation

**Moderate-to-Low likelihood:**
- Operators may use `Token::FromConfig` for convenience despite security implications
- Remote telemetry is an optional feature that may be enabled in production
- Telemetry services or log systems could be compromised or have inadequate access controls
- The vulnerability requires no special attacker privileges, only log access

However, security-conscious operators would use `Token::FromDisk` and restrict log access, reducing practical exploitation risk.

## Recommendation

Implement sanitization for sensitive configuration fields before logging:

1. Add a `sanitize()` method to `SecureBackend`, `VaultConfig`, and `Token` that redacts sensitive values
2. Apply sanitization in `log_all_configs()` and `log_config_and_build_information()`
3. Add sanitization to the crash handler for any configuration data in panic messages
4. Consider implementing a custom `Debug` trait for `Token` that redacts the token value
5. Add security warnings in documentation about `Token::FromConfig` risks

Example implementation:
```rust
impl Token {
    pub fn sanitized_debug(&self) -> String {
        match self {
            Token::FromConfig(_) => "FromConfig(**REDACTED**)".to_string(),
            Token::FromDisk(path) => format!("FromDisk({:?})", path),
        }
    }
}
```

## Proof of Concept

**Setup:**
1. Configure an Aptos validator node with Vault backend using `Token::FromConfig`:
```yaml
consensus:
  safety_rules:
    backend:
      type: vault
      server: "https://vault.example.com"
      token:
        from_config: "s.MySecretVaultToken123"
```

2. Enable remote telemetry logging in the node config:
```yaml
logger:
  enable_telemetry_remote_log: true
```

3. Start the node and observe startup logs

**Expected Result:**
The token "s.MySecretVaultToken123" appears in:
- Info logs: "Using consensus config: {...}"
- Remote telemetry POST requests to the telemetry service endpoint

**Verification:**
Check telemetry service logs or local log files for the plaintext token value in the serialized configuration JSON.

## Notes

While the original security question focused specifically on panic handler safety during `Storage` conversion, the investigation revealed that the more significant vulnerability is the routine logging of sensitive configuration during normal node startup, rather than panic scenarios. The panic handler does lack sanitization capabilities, but the current panic sites don't expose tokens in their messages. The broader issue is the absence of a defense-in-depth approach to protecting sensitive configuration data across all logging paths.

### Citations

**File:** aptos-node/src/lib.rs (L698-698)
```rust
    node_config.log_all_configs();
```

**File:** config/src/config/node_config.rs (L97-111)
```rust
    pub fn log_all_configs(&self) {
        // Parse the node config as serde JSON
        let config_value =
            serde_json::to_value(self).expect("Failed to serialize the node config!");
        let config_map = config_value
            .as_object()
            .expect("Failed to get the config map!");

        // Log each config entry
        for (config_name, config_value) in config_map {
            let config_string =
                serde_json::to_string(config_value).expect("Failed to parse the config value!");
            info!("Using {} config: {}", config_name, config_string);
        }
    }
```

**File:** config/src/config/safety_rules_config.rs (L23-34)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct SafetyRulesConfig {
    pub backend: SecureBackend,
    pub logger: LoggerConfig,
    pub service: SafetyRulesService,
    pub test: Option<SafetyRulesTestConfig>,
    // Read/Write/Connect networking operation timeout in milliseconds.
    pub network_timeout_ms: u64,
    pub enable_cached_safety_data: bool,
    pub initial_safety_rules_config: InitialSafetyRulesConfig,
}
```

**File:** config/src/config/secure_backend_config.rs (L51-74)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VaultConfig {
    /// Optional SSL Certificate for the vault host, this is expected to be a full path.
    pub ca_certificate: Option<PathBuf>,
    /// A namespace is an optional portion of the path to a key stored within Vault. For example,
    /// a secret, S, without a namespace would be available in secret/data/S, with a namespace, N, it
    /// would be in secret/data/N/S.
    pub namespace: Option<String>,
    /// Vault leverages leases on many tokens, specify this to automatically have your lease
    /// renewed up to that many seconds more. If this is not specified, the lease will not
    /// automatically be renewed.
    pub renew_ttl_secs: Option<u32>,
    /// Vault's URL, note: only HTTP is currently supported.
    pub server: String,
    /// The authorization token for accessing secrets
    pub token: Token,
    /// Disable check-and-set when writing secrets to Vault
    pub disable_cas: Option<bool>,
    /// Timeout for new vault socket connections, in milliseconds.
    pub connection_timeout_ms: Option<u64>,
    /// Timeout for generic vault operations (e.g., reads and writes), in milliseconds.
    pub response_timeout_ms: Option<u64>,
}
```

**File:** config/src/config/secure_backend_config.rs (L100-106)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum Token {
    FromConfig(String),
    /// This is an absolute path and not relative to data_dir
    FromDisk(PathBuf),
}
```

**File:** config/src/config/secure_backend_config.rs (L162-195)
```rust
impl From<&SecureBackend> for Storage {
    fn from(backend: &SecureBackend) -> Self {
        match backend {
            SecureBackend::InMemoryStorage => Storage::from(InMemoryStorage::new()),
            SecureBackend::OnDiskStorage(config) => {
                let storage = Storage::from(OnDiskStorage::new(config.path()));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
            SecureBackend::Vault(config) => {
                let storage = Storage::from(VaultStorage::new(
                    config.server.clone(),
                    config.token.read_token().expect("Unable to read token"),
                    config
                        .ca_certificate
                        .as_ref()
                        .map(|_| config.ca_certificate().unwrap()),
                    config.renew_ttl_secs,
                    config.disable_cas.map_or_else(|| true, |disable| !disable),
                    config.connection_timeout_ms,
                    config.response_timeout_ms,
                ));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
        }
    }
}
```

**File:** aptos-node/src/logger.rs (L50-54)
```rust
    if node_config.logger.enable_telemetry_remote_log {
        let (tx, rx) = mpsc::channel(TELEMETRY_LOG_INGEST_BUFFER_SIZE);
        logger_builder.remote_log_tx(tx);
        remote_log_receiver = Some(rx);
    }
```

**File:** aptos-node/src/logger.rs (L91-99)
```rust
    if let Some(u) = &node_config.indexer.postgres_uri {
        let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
        if parsed_url.password().is_some() {
            masked_config = node_config.clone();
            parsed_url.set_password(Some("*")).unwrap();
            masked_config.indexer.postgres_uri = Some(parsed_url.to_string());
            config = &masked_config;
        }
    }
```

**File:** aptos-node/src/logger.rs (L101-101)
```rust
    info!("Loaded node config: {:?}", config);
```

**File:** crates/aptos-telemetry/src/sender.rs (L195-214)
```rust
    async fn post_logs(&self, json: &[u8]) -> Result<Response, anyhow::Error> {
        debug!("Sending logs");

        let mut gzip_encoder = GzEncoder::new(Vec::new(), Compression::default());
        gzip_encoder.write_all(json)?;
        let compressed_bytes = gzip_encoder.finish()?;

        // Send the request and wait for a response
        let response = self
            .send_authenticated_request(
                self.client
                    .post(self.build_path("ingest/logs")?)
                    .header(CONTENT_ENCODING, "gzip")
                    .body(compressed_bytes),
            )
            .await?;

        // Process the result
        error_for_status_with_body(response).await
    }
```

**File:** crates/crash-handler/src/lib.rs (L33-43)
```rust
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);
```
