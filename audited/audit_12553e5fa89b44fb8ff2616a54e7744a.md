# Audit Report

## Title
Insecure Trusted Setup for Batch Encryption - Missing Multi-Party Computation Ceremony for tau_g2 Parameter

## Summary
The `DigestKey` cryptographic parameters, specifically `tau_g2`, are generated locally without a multi-party computation (MPC) trusted setup ceremony. An insider who generates or has access to the `DigestKey` setup process knows the secret trapdoor `tau`, enabling them to forge arbitrary KZG evaluation proofs and potentially break the confidentiality of encrypted transactions when this feature is enabled.

## Finding Description

The batch encryption scheme (FPTX/FPTXWeighted) uses a KZG-based polynomial commitment scheme that requires a trusted setup parameter `tau`. The security of this scheme critically depends on `tau` being generated through a multi-party computation ceremony where no single party knows the final value.

**Current Implementation:**

The `DigestKey::new()` function generates `tau` locally using a random number generator: [1](#0-0) 

**Attack Vector:**

An insider who executes `DigestKey::new()` or has access to the RNG state knows the secret `tau`. With knowledge of `tau`, they can:

1. **Forge Evaluation Proofs**: The eval proof verification equation is: [2](#0-1) 

This checks `e(proof, g2^(tau - id)) = e(digest, g2)`. An attacker who knows `tau` can compute valid proofs for arbitrary `(digest, id)` pairs.

2. **Break Encryption Confidentiality**: The encryption uses `tau_g2` directly in ciphertext computation: [3](#0-2) 

The ciphertext component `(g2^id - tau_g2) * r[0]` becomes vulnerable when `tau` is known.

**Acknowledgment of Issue:**

The codebase contains a TODO comment acknowledging this missing trusted setup: [4](#0-3) 

**Current Mitigation:**

Encrypted transactions are currently **disabled** in production through hardcoded validation rejection: [5](#0-4) 

However, this represents a critical vulnerability waiting to be exploited if encrypted transactions are enabled without implementing a proper trusted setup ceremony first.

## Impact Explanation

**Severity: Critical** (per Aptos Bug Bounty: up to $1,000,000)

If encrypted transactions are enabled without fixing the trusted setup issue:

1. **Total Loss of Confidentiality**: An insider who knows `tau` can decrypt all encrypted transactions or forge decryption proofs, bypassing the threshold decryption mechanism entirely.

2. **Insider Threat**: The entity responsible for generating `DigestKey` (likely during genesis or epoch transitions) would have permanent ability to:
   - Decrypt all past and future encrypted transactions
   - Forge evaluation proofs for arbitrary ciphertexts
   - Bypass validator threshold requirements

3. **Trust Violation**: The system violates the fundamental security assumption of KZG-based schemes that no single party knows the trapdoor.

4. **Consensus Integration Risk**: The encrypted transaction system is integrated into consensus: [6](#0-5) 

## Likelihood Explanation

**Current Likelihood: Low** (feature disabled in production)
**Future Likelihood: High** (if enabled without fix)

Currently, encrypted transactions are explicitly rejected during validation, preventing exploitation. However:

1. **Development Code Present**: The vulnerable code exists in production binaries, just gated by validation checks.

2. **Feature Activation Risk**: If encrypted transactions are enabled via feature flag or configuration change without implementing a proper trusted setup first, the vulnerability becomes immediately exploitable.

3. **Insider Access Required**: Exploitation requires insider access to the `DigestKey` generation process, but this is explicitly within the threat model per the security question.

## Recommendation

Implement a multi-party computation (MPC) trusted setup ceremony for `DigestKey` parameters:

**Option 1: MPC Ceremony Implementation**
- Design and implement a distributed powers-of-tau ceremony among validators
- Use existing MPC frameworks (e.g., similar to Zcash Sapling ceremony, Ethereum KZG ceremony)
- Ensure each participant contributes randomness and destroys their share
- Verify ceremony output using public verification procedures

**Option 2: Use Existing Ceremony Outputs**
- If curve parameters match existing ceremonies (BLS12-381), use pre-computed powers-of-tau from established ceremonies
- Verify ceremony transcripts before deployment
- Document ceremony provenance and security assumptions

**Code Changes Required:**
1. Remove local `tau` generation from `DigestKey::new()`
2. Modify `DigestKey` to accept pre-computed `tau_g2` and `tau_powers_g1` from ceremony outputs
3. Implement ceremony participation protocol for validators
4. Add verification logic to validate ceremony parameters before use
5. Store ceremony parameters in genesis or on-chain configuration

**Before Enabling Encrypted Transactions:**
- [ ] Complete trusted setup ceremony
- [ ] Verify ceremony outputs with independent auditors
- [ ] Update `DigestKey::new()` to use ceremony parameters
- [ ] Add ceremony parameter validation in genesis
- [ ] Remove hardcoded `FEATURE_UNDER_GATING` rejection only after trusted setup is complete

## Proof of Concept

```rust
// Demonstration: Forging evaluation proofs with knowledge of tau
use aptos_batch_encryption::{
    group::{Fr, G1Affine, G2Affine, PairingSetting},
    shared::{digest::DigestKey, ids::Id},
};
use ark_ec::AffineRepr;
use ark_std::rand::thread_rng;

#[test]
fn test_insider_knows_tau_can_forge_proofs() {
    let mut rng = thread_rng();
    
    // Insider generates DigestKey and knows tau
    let tau = Fr::rand(&mut rng);
    let digest_key = DigestKey::new(&mut rng, 8, 1).unwrap();
    
    // Create arbitrary digest (simulating encrypted transactions)
    let arbitrary_digest = G1Affine::generator();
    let arbitrary_id = Id::new(Fr::from(42u64));
    
    // ATTACK: Insider who knows tau can forge valid proof
    // Proof should satisfy: e(proof, g2^(tau - id)) = e(digest, g2)
    // Therefore: proof = digest * 1/(tau - id)
    
    let tau_minus_id = tau - arbitrary_id.x();
    let proof = (arbitrary_digest * tau_minus_id.inverse().unwrap()).into();
    
    // Verify the forged proof passes verification
    let verification = PairingSetting::pairing(
        proof,
        digest_key.tau_g2 - (G2Affine::generator() * arbitrary_id.x()).into(),
    ) == PairingSetting::pairing(arbitrary_digest, G2Affine::generator());
    
    assert!(verification, "Forged proof should verify correctly");
    
    // This demonstrates that knowledge of tau allows forging arbitrary
    // evaluation proofs, breaking the security of the encryption scheme
}
```

## Notes

- **Current Status**: Encrypted transactions are disabled in production, preventing immediate exploitation [5](#0-4) 

- **TODO Acknowledgment**: Developers are aware of the missing ceremony requirement [4](#0-3) 

- **Critical Before Production**: This issue MUST be resolved before encrypted transactions are enabled on mainnet

- **Scope Clarification**: While this requires insider access (whoever runs `DigestKey::new()`), the security question explicitly explores this threat model: "can a malicious party who knows tau break the encryption scheme"

### Citations

**File:** crates/aptos-batch-encryption/src/shared/digest.rs (L59-91)
```rust
    pub fn new(rng: &mut impl RngCore, batch_size: usize, num_rounds: usize) -> Option<Self> {
        let tau = Fr::rand(rng);

        let mut tau_powers_fr = vec![Fr::one()];
        let mut cur = tau;
        for _ in 0..batch_size {
            tau_powers_fr.push(cur);
            cur *= &tau;
        }

        let rs: Vec<Fr> = (0..num_rounds).map(|_| Fr::rand(rng)).collect();

        let tau_powers_randomized_fr = rs
            .into_iter()
            .map(|r| {
                tau_powers_fr
                    .iter()
                    .map(|tau_power| r * tau_power)
                    .collect::<Vec<Fr>>()
            })
            .collect::<Vec<Vec<Fr>>>();

        let tau_powers_g1: Vec<Vec<G1Affine>> = tau_powers_randomized_fr
            .into_iter()
            .map(|powers_for_r| G1Projective::from(G1Affine::generator()).batch_mul(&powers_for_r))
            .collect();

        let tau_powers_g1_projective: Vec<Vec<G1Projective>> = tau_powers_g1
            .iter()
            .map(|gs| gs.iter().map(|g| G1Projective::from(*g)).collect())
            .collect();

        let tau_g2: G2Affine = (G2Affine::generator() * tau).into();
```

**File:** crates/aptos-batch-encryption/src/shared/digest.rs (L138-146)
```rust
    fn verify_pf(&self, digest: &Digest, id: Id, pf: G1Affine) -> Result<()> {
        // TODO use multipairing here?
        Ok((PairingSetting::pairing(
            pf,
            self.tau_g2 - G2Projective::from(G2Affine::generator() * id.x()),
        ) == PairingSetting::pairing(digest.as_g1(), G2Affine::generator()))
        .then_some(())
        .ok_or(BatchEncryptionError::EvalProofVerifyError)?)
    }
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L119-132)
```rust
    fn bibe_encrypt<R: RngCore + CryptoRng>(
        &self,
        rng: &mut R,
        plaintext: &impl Plaintext,
        id: Id,
    ) -> Result<BIBECiphertext> {
        let r = [Fr::rand(rng), Fr::rand(rng)];
        let hashed_encryption_key: G1Affine = symmetric::hash_g2_element(self.sig_mpk_g2)?;

        let ct_g2 = [
            (G2Affine::generator() * r[0] + self.sig_mpk_g2 * r[1]).into(),
            ((G2Affine::generator() * id.x() - self.tau_g2) * r[0]).into(),
            (-(G2Affine::generator() * r[1])).into(),
        ];
```

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L172-172)
```rust
        let group_generators = GroupGenerators::default(); // TODO: At least one of these should come from a powers of tau ceremony?
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3229-3231)
```rust
        if transaction.payload().is_encrypted_variant() {
            return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
        }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L57-93)
```rust
        let digest_key: DigestKey = secret_share_config
            .as_ref()
            .expect("must exist")
            .digest_key()
            .clone();
        let msk_share: MasterSecretKeyShare = secret_share_config
            .as_ref()
            .expect("must exist")
            .msk_share()
            .clone();

        // TODO(ibalajiarun): FIXME
        let len = 10;
        let encrypted_txns = if encrypted_txns.len() > len {
            let mut to_truncate = encrypted_txns;
            to_truncate.truncate(len);
            to_truncate
        } else {
            encrypted_txns
        };

        let txn_ciphertexts: Vec<Ciphertext> = encrypted_txns
            .iter()
            .map(|txn| {
                // TODO(ibalajiarun): Avoid clone and use reference instead
                txn.payload()
                    .as_encrypted_payload()
                    .expect("must be a encrypted txn")
                    .ciphertext()
                    .clone()
            })
            .collect();

        // TODO(ibalajiarun): Consider using commit block height to reduce trusted setup size
        let encryption_round = block.round();
        let (digest, proofs_promise) =
            FPTXWeighted::digest(&digest_key, &txn_ciphertexts, encryption_round)?;
```
