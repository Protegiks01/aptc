# Audit Report

## Title
Panic on Empty Transaction Array in Table Info Service Causes Indexer Service Crash

## Summary
The `process_transactions()` function in the table info indexer service unconditionally accesses array elements without checking if the array is empty, leading to a panic that crashes the indexer service during normal operation.

## Finding Description

The vulnerability exists in the `process_transactions()` function which accesses array bounds without validation: [1](#0-0) 

These lines directly access `raw_txns[0]` and `raw_txns.last().unwrap()` without checking if the array is empty. While the called function `parse_table_info()` has an empty check, the panic occurs before reaching it: [2](#0-1) 

The vulnerability is triggered through the following execution path:

1. The main processing loop fetches transactions which can be empty when catching up or between blocks: [3](#0-2) 

2. When `transactions_in_current_epoch` is empty, it's passed to `process_transactions_in_parallel()` WITHOUT an empty check (unlike `transactions_in_previous_epoch` which is checked at line 124): [4](#0-3) 

3. In `process_transactions_in_parallel()`, when the transactions array is empty, no parallel tasks are spawned (empty chunks iterator), but if there are pending items from previous processing, the retry logic triggers: [5](#0-4) 

4. This calls `process_transactions()` with an empty array, causing an index-out-of-bounds panic at line 325 and an unwrap-on-None panic at line 326.

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria for the following reasons:

1. **Service Availability Impact**: The panic crashes the table info indexer service, disrupting table info parsing and indexing functionality.

2. **State Inconsistency**: The crash can leave the indexer in an inconsistent state with unprocessed transactions and pending items, requiring manual intervention to restart and recover.

3. **Not Consensus-Critical**: While this affects service availability, it does not impact consensus, transaction execution, validator operations, or fund security. The indexer-grpc services are auxiliary components for data access and querying.

This meets the Medium severity category of "State inconsistencies requiring intervention" as the service crash interrupts indexing operations and may require operator intervention to restart.

## Likelihood Explanation

**High Likelihood** - This can occur during normal operation:

1. **Common Scenario**: When the indexer catches up to the latest ledger version and there are no new transactions to process, `fetch_batches()` returns an empty array.

2. **Pending State Condition**: If there are leftover pending items in `indexer_async_v2` from previous multi-threaded processing (which is normal due to the async nature of table info parsing with nested references).

3. **No External Trigger Required**: This happens automatically during normal operation without any malicious input or attacker action.

4. **Reproducible**: The condition can be consistently reproduced by running the indexer service during low transaction periods with pending state.

## Recommendation

Add an early return check for empty arrays in `process_transactions()`:

```rust
async fn process_transactions(
    context: Arc<ApiContext>,
    indexer_async_v2: Arc<IndexerAsyncV2>,
    raw_txns: &[TransactionOnChainData],
) -> EndVersion {
    // Add empty check at the beginning
    if raw_txns.is_empty() {
        return 0; // or return last processed version from context
    }
    
    let start_time = std::time::Instant::now();
    let start_version = raw_txns[0].version;
    let end_version = raw_txns.last().unwrap().version;
    // ... rest of function
}
```

Additionally, add defensive check before calling `process_transactions_in_parallel()`:

```rust
// Line 168 - add check like line 124
if !transactions_in_current_epoch.is_empty() {
    self.process_transactions_in_parallel(
        self.indexer_async_v2.clone(),
        transactions_in_current_epoch,
    )
    .await;
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    #[should_panic(expected = "index out of bounds")]
    async fn test_process_transactions_empty_array_panic() {
        // Setup mock context and indexer_async_v2
        let context = Arc::new(create_mock_api_context());
        let indexer_async_v2 = Arc::new(create_mock_indexer_async_v2());
        
        // Call with empty array - this will panic
        let empty_txns: Vec<TransactionOnChainData> = vec![];
        
        // This should panic at line 325 when accessing raw_txns[0]
        TableInfoService::process_transactions(
            context,
            indexer_async_v2,
            &empty_txns,
        ).await;
    }
    
    #[tokio::test]
    async fn test_process_transactions_in_parallel_with_empty_and_pending() {
        let context = Arc::new(create_mock_api_context());
        let indexer_async_v2 = Arc::new(create_mock_indexer_async_v2());
        
        // Setup indexer_async_v2 to have pending items
        indexer_async_v2.add_mock_pending_item();
        
        let service = TableInfoService::new(
            context,
            0,
            10,
            100,
            None,
            indexer_async_v2,
        );
        
        // Pass empty transactions - should trigger retry with empty array
        let empty_txns = vec![];
        
        // This will panic in the retry logic at line 288
        service.process_transactions_in_parallel(
            service.indexer_async_v2.clone(),
            empty_txns,
        ).await;
    }
}
```

## Notes

The vulnerability exists due to inconsistent empty-checking patterns in the codebase. While `transactions_in_previous_epoch` is checked for emptiness before processing (line 124), `transactions_in_current_epoch` is not (line 168), creating an asymmetric protection that allows empty arrays to reach the vulnerable code path.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L113-121)
```rust
            let batches = self.get_batches(ledger_version).await;
            let transactions = self.fetch_batches(batches, ledger_version).await.unwrap();
            let num_transactions = transactions.len();
            let last_version = transactions
                .last()
                .map(|txn| txn.version)
                .unwrap_or_default();
            let (transactions_in_previous_epoch, transactions_in_current_epoch, epoch) =
                transactions_in_epochs(&self.context, current_epoch, transactions);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L168-172)
```rust
            self.process_transactions_in_parallel(
                self.indexer_async_v2.clone(),
                transactions_in_current_epoch,
            )
            .await;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L286-294)
```rust
                if !self.indexer_async_v2.is_indexer_async_v2_pending_on_empty() {
                    self.indexer_async_v2.clear_pending_on();
                    Self::process_transactions(
                        context.clone(),
                        indexer_async_v2.clone(),
                        &transactions,
                    )
                    .await;
                }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L325-326)
```rust
        let start_version = raw_txns[0].version;
        let end_version = raw_txns.last().unwrap().version;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L398-400)
```rust
        if raw_txns.is_empty() {
            return Ok(());
        }
```
