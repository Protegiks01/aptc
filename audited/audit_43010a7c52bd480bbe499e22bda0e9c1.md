# Audit Report

## Title
IPv4-Mapped IPv6 Address Bypass in Aptos Faucet IP Filtering

## Summary
The `IpRangeManager` in the Aptos faucet service fails to normalize IPv4-mapped IPv6 addresses (e.g., `::ffff:192.168.1.1`) before performing IP range checks. This allows attackers to bypass both IP blocklists and IP allowlists by connecting with IPv4-mapped IPv6 representations of IPv4 addresses, circumventing intended access controls.

## Finding Description
The vulnerability exists in how the faucet's IP filtering logic handles IPv4-mapped IPv6 addresses. [1](#0-0) 

The `contains_ip()` function performs type-based routing: IPv4 addresses are checked against `ipv4_list`, and IPv6 addresses are checked against `ipv6_list`. IPv4-mapped IPv6 addresses (which are valid IPv6 addresses like `::ffff:192.168.1.1`) are treated as `IpAddr::V6` and checked only against the `ipv6_list`.

The IP blocklist checker similarly separates checks by IP type: [2](#0-1) 

**Attack Scenario:**

1. Administrator configures the faucet with an IPv4 blocklist containing `192.168.1.0/24` to block a malicious actor
2. This range is parsed and stored in `ipv4_list` [3](#0-2) 
3. Attacker from `192.168.1.1` connects to the faucet using the IPv4-mapped IPv6 address `::ffff:192.168.1.1`
4. The source IP is extracted and stored as `IpAddr::V6` in `CheckerData` [4](#0-3) 
5. The blocklist checker matches on `IpAddr::V6` variant and checks only `ipv6_list`, which doesn't contain the blocked range
6. The attacker successfully bypasses the IP blocklist

This vulnerability is exploitable when the faucet is configured to listen on IPv6 or dual-stack mode (e.g., binding to `::`), which is common in production deployments.

## Impact Explanation
This vulnerability allows attackers to bypass IP-based access controls in the Aptos faucet service, which could lead to:

1. **Rate Limit Bypass**: Attackers can circumvent IP-based rate limiting by repeatedly switching between IPv4 and IPv4-mapped IPv6 representations, potentially draining the faucet
2. **Blocklist Bypass**: Malicious actors who have been explicitly blocked can regain access
3. **Allowlist Circumvention**: The inverse problem exists for IP allowlistsâ€”legitimate IPv4 addresses in the allowlist won't match when accessed via IPv4-mapped IPv6, causing service disruption

While the faucet is not a core consensus component, this represents a **Medium Severity** issue under the Aptos bug bounty program as it enables "Limited funds loss or manipulation" through unauthorized faucet drainage and service disruption.

## Likelihood Explanation
The likelihood is **High** if the faucet is deployed with:
- IPv6 or dual-stack networking enabled (common in modern cloud deployments)
- IP-based rate limiting or blocklisting configured with IPv4 ranges (typical configuration)
- Direct exposure or proxies that preserve IPv4-mapped IPv6 addresses

The attack requires no special privileges and can be executed by any attacker with basic networking knowledge. The attacker only needs to configure their HTTP client to connect via IPv6 with IPv4-mapped addresses, which is supported by standard tools like curl: `curl -6 http://[::ffff:FAUCET_IP]:8081/...`

## Recommendation
Normalize IPv4-mapped IPv6 addresses to their IPv4 equivalents before performing IP range checks. The Rust standard library provides the `Ipv6Addr::to_ipv4_mapped()` method for this purpose.

**Recommended Fix** in `ip_range_manager.rs`:

```rust
pub fn contains_ip(&self, ip: &IpAddr) -> bool {
    match ip {
        IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
        IpAddr::V6(ipv6) => {
            // Check if this is an IPv4-mapped IPv6 address
            if let Some(ipv4) = ipv6.to_ipv4_mapped() {
                // Check against IPv4 list for mapped addresses
                self.ipv4_list.contains(&ipv4)
            } else {
                // Regular IPv6 address
                self.ipv6_list.contains(ipv6)
            }
        }
    }
}
```

Apply the same normalization in `ip_blocklist.rs` at lines 41-48 to ensure consistency across both implementations.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
    use std::fs::write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_ipv4_mapped_ipv6_bypass() {
        // Create a temporary blocklist file with IPv4 range
        let mut file = NamedTempFile::new().unwrap();
        write(file.path(), "192.168.1.0/24").unwrap();
        
        // Create IpRangeManager with IPv4 blocklist
        let config = IpRangeManagerConfig {
            file: file.path().to_path_buf(),
        };
        let manager = IpRangeManager::new(config).unwrap();
        
        // Test that regular IPv4 is blocked
        let ipv4_addr = IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1));
        assert!(manager.contains_ip(&ipv4_addr), "IPv4 address should be in blocklist");
        
        // Test that IPv4-mapped IPv6 bypasses the blocklist (VULNERABILITY)
        let ipv4_mapped = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc0a8, 0x0101));
        assert!(!manager.contains_ip(&ipv4_mapped), 
                "IPv4-mapped IPv6 bypasses blocklist - VULNERABILITY CONFIRMED");
        
        // Both addresses represent the same underlying IP (192.168.1.1)
        // but only the IPv4 variant is blocked
    }
}
```

## Notes
This vulnerability affects the faucet service's IP-based access control mechanisms. While the faucet is an auxiliary service and not a core blockchain component, the bypass of security controls represents a legitimate security issue that should be addressed. The fix is straightforward and adds minimal performance overhead while ensuring that IPv4-mapped IPv6 addresses are properly handled according to their semantic meaning.

### Citations

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L28-48)
```rust
        let mut ipv4_list = IpRange::<Ipv4Net>::new();
        let mut ipv6_list = IpRange::<Ipv6Net>::new();
        for line in std::io::BufReader::new(file).lines() {
            let line = line?;
            if line.starts_with('#') || line.starts_with("//") || line.is_empty() {
                continue;
            }
            match line.parse::<Ipv4Net>() {
                Ok(ipv4_net) => {
                    ipv4_list.add(ipv4_net);
                },
                Err(_) => match line.parse::<Ipv6Net>() {
                    Ok(ipv6_net) => {
                        ipv6_list.add(ipv6_net);
                    },
                    Err(_) => {
                        bail!("Failed to parse line as IPv4 or IPv6 range: {}", line);
                    },
                },
            }
        }
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L55-60)
```rust
    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(ipv6),
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L33-48)
```rust
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L147-153)
```rust
#[derive(Clone, Debug)]
pub struct CheckerData {
    pub time_request_received_secs: u64,
    pub receiver: AccountAddress,
    pub source_ip: IpAddr,
    pub headers: Arc<HeaderMap>,
}
```
