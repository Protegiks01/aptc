# Audit Report

## Title
Feature Flag Race Condition Causes Mempool Divergence During Epoch Transitions

## Summary
A race condition between commit notifications and reconfiguration notifications in the mempool validator allows transactions to be validated with stale feature flags. During epoch transitions, when feature flags are changed, validators can temporarily disagree on transaction validity, causing mempool divergence and inconsistent transaction acceptance across the network.

## Finding Description

The vulnerability stems from how the VMValidator caches the execution environment and updates it through two separate, asynchronous notification channels.

**Environment Caching Architecture:**

The `CachedModuleView` stores an `AptosEnvironment` that includes the `Features` configuration fetched from on-chain state. [1](#0-0) 

This environment is created once and cached: [2](#0-1) 

**The Critical Race Condition:**

When transactions are committed, the mempool receives notifications through a **dedicated spawned task**: [3](#0-2) 

This task calls `notify_commit()` which only updates the state view, **NOT** the cached environment: [4](#0-3) 

The `notify_commit()` implementation calls `reset_state_view()` which explicitly does NOT update the environment: [5](#0-4) 

Meanwhile, reconfiguration notifications are processed on a **separate channel in the main coordinator loop**: [6](#0-5) 

Only when `restart()` is called does the environment get updated: [7](#0-6) 

**The Attack Sequence:**

1. **Epoch Change Block Executed**: A governance proposal changes a feature flag (e.g., disables `KEYLESS_ACCOUNTS`) via `features::on_new_epoch()`: [8](#0-7) 

2. **State Sync Processes Block**: The notification handler sends notifications in this order: [9](#0-8) 

3. **Commit Notification Processed First**: The dedicated mempool task receives the commit notification and calls `notify_commit()`, updating only the state view.

4. **Race Window Opens**: The cached environment still contains old Features. When a transaction is submitted during this window, validation creates an AptosVM from the stale environment: [10](#0-9) 

5. **Validation Uses Stale Features**: The keyless validation checks feature flags from the cached environment: [11](#0-10) 

6. **Transaction Accepted with Wrong Feature State**: A keyless transaction passes validation even though the feature is now disabled, because the cached environment still shows it as enabled.

7. **Reconfiguration Eventually Processed**: Later, the main loop processes the reconfiguration notification and calls `restart()`, finally updating the environment.

**Impact on Different Validators:**

- Validators that process reconfiguration quickly will reject the transaction
- Validators with delayed reconfiguration processing will accept the transaction
- This creates **mempool divergence** where different validators have different views of transaction validity

## Impact Explanation

This vulnerability constitutes a **High Severity** issue as a "Significant protocol violation" per the Aptos bug bounty criteria.

**Specific Impacts:**

1. **Mempool Divergence**: Different validators maintain different transaction pools based on when they processed the reconfiguration notification. This breaks the assumption that validators have consistent views of pending transactions.

2. **Transaction Inconsistency**: Users can have transactions accepted by some validators but rejected by others, creating confusion and unreliable transaction submission.

3. **Proposal Strategy Differences**: Validators may propose blocks with different transaction sets, reducing consensus efficiency.

4. **Applies to All Feature Flags**: This affects not just keyless transactions, but ANY feature flag that gates transaction validation, including:
   - `WEBAUTHN_SIGNATURE` 
   - `SLH_DSA_SHA2_128S_SIGNATURE`
   - `ORDERLESS_TRANSACTIONS`
   - `ALLOW_SERIALIZED_SCRIPT_ARGS`

While this does not cause consensus safety violations (all validators execute blocks deterministically with fresh environments), it creates operational inconsistencies that violate protocol assumptions about validator behavior.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to occur because:

1. **Deterministic Trigger**: Epoch changes happen regularly and predictably in Aptos
2. **Natural Race Window**: The asynchronous notification processing creates a non-trivial time window between commit and reconfiguration processing
3. **No Synchronization**: There is no mechanism to ensure the environment is refreshed when on-chain configs change
4. **Multiple Feature Flags**: Many feature flags can trigger this behavior, increasing the attack surface

The race window exists whenever:
- A feature flag is changed via governance
- Mempool receives commit notification before processing reconfiguration notification
- Users submit transactions during this window

## Recommendation

**Fix 1: Synchronize Environment Updates with On-Chain Config Changes**

Modify `notify_commit()` to detect when on-chain configs have changed and force an environment refresh:

```rust
// In vm_validator.rs
fn notify_commit(&mut self) {
    let db_state_view = self.db_state_view();
    let base_view_id = self.state.state_view_id();
    let new_view_id = db_state_view.id();
    
    // Check if this commit includes a reconfiguration
    let base_epoch = self.get_epoch_from_state(&self.state.state_view);
    let new_epoch = self.get_epoch_from_state(&db_state_view);
    
    if base_epoch != new_epoch {
        // Reconfiguration occurred, do full reset
        self.state.reset_all(db_state_view.into());
    } else {
        // Normal commit, just update state view
        match (base_view_id, new_view_id) {
            (
                StateViewId::TransactionValidation { base_version: old_version },
                StateViewId::TransactionValidation { base_version: new_version },
            ) => {
                if old_version <= new_version {
                    self.state.reset_state_view(db_state_view.into());
                }
            },
            _ => self.state.reset_all(db_state_view.into()),
        }
    }
}
```

**Fix 2: Always Refresh Environment on Commit**

A simpler but potentially more expensive fix is to always call `reset_all()` instead of `reset_state_view()`: [12](#0-11) 

Change line 93 from `self.state.reset_state_view(db_state_view.into())` to `self.state.reset_all(db_state_view.into())`.

This ensures the environment is always fresh but may impact performance due to more frequent environment reconstruction.

## Proof of Concept

**Reproduction Steps:**

1. **Setup**: Deploy a test network with multiple validators

2. **Submit Governance Proposal**:
```move
script {
    use std::features;
    fun disable_keyless(governance: &signer) {
        features::change_feature_flags_for_next_epoch(
            governance,
            vector[],
            vector[features::get_keyless_accounts_feature()]
        );
    }
}
```

3. **Monitor for Epoch Change**: Wait for the epoch transition block to be committed

4. **Exploit Race Window**: Immediately after the epoch change block is committed (observable via API), submit a keyless transaction to multiple validators:
```rust
// Pseudo-code for attack
let keyless_txn = create_keyless_transaction();
let epoch_change_detected = monitor_for_epoch_change();

if epoch_change_detected {
    // Submit within microseconds of epoch change
    for validator in validators {
        submit_transaction(validator, keyless_txn);
    }
}
```

5. **Observe Divergence**: Query each validator's mempool:
   - Some validators will have accepted the transaction (those that haven't processed reconfiguration yet)
   - Other validators will have rejected it (those that processed reconfiguration first)

6. **Verify**: Check validator logs for `FEATURE_UNDER_GATING` errors occurring at different times across validators

**Expected Result**: Mempool divergence observable through different validators accepting/rejecting the same transaction based on notification processing timing.

## Notes

This vulnerability demonstrates a subtle but important invariant violation: validators should have consistent views of transaction validity at any given state. The asynchronous nature of notification processing combined with environment caching breaks this invariant during configuration changes. While block execution remains deterministic (all validators execute with fresh environments), the mempool layer experiences temporary inconsistency that can be exploited during every epoch transition.

### Citations

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L93-103)
```rust
pub struct CachedModuleView<S> {
    /// The raw snapshot of the state used for validation.
    pub state_view: S,
    /// Stores configs needed for execution.
    pub environment: AptosEnvironment,
    /// Versioned cache for deserialized and verified Move modules. The versioning allows to detect
    /// when the version of the code is no longer up-to-date (a newer version has been committed to
    /// the state view) and update the cache accordingly.
    pub module_cache:
        UnsyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, usize>,
}
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L108-119)
```rust
    pub fn new(state_view: S) -> Self {
        info!(
            AdapterLogSchema::new(state_view.id(), 0),
            "Validation environment and module cache created"
        );
        let environment = AptosEnvironment::new(&state_view);
        Self {
            state_view,
            environment,
            module_cache: UnsyncModuleCache::empty(),
        }
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L121-125)
```rust
    /// Resets the state view snapshot to the new one. Does not invalidate the module cache, nor
    /// the VM.
    pub fn reset_state_view(&mut self, state_view: S) {
        self.state_view = state_view;
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L132-138)
```rust
    /// Resets the state to the new one, empties module cache, and resets the VM based on the new
    /// state view snapshot.
    pub fn reset_all(&mut self, state_view: S) {
        self.state_view = state_view;
        self.environment = AptosEnvironment::new(&self.state_view);
        self.module_cache = UnsyncModuleCache::empty();
    }
```

**File:** mempool/src/shared_mempool/coordinator.rs (L115-117)
```rust
            reconfig_notification = mempool_reconfig_events.select_next_some() => {
                handle_mempool_reconfig_event(&mut smp, &bounded_executor, reconfig_notification.on_chain_configs).await;
            },
```

**File:** mempool/src/shared_mempool/coordinator.rs (L136-163)
```rust
/// Spawn a task to handle commit notifications from state sync
fn spawn_commit_notification_handler<NetworkClient, TransactionValidator>(
    smp: &SharedMempool<NetworkClient, TransactionValidator>,
    mut mempool_listener: MempoolNotificationListener,
) where
    NetworkClient: NetworkClientInterface<MempoolSyncMsg> + 'static,
    TransactionValidator: TransactionValidation + 'static,
{
    let mempool = smp.mempool.clone();
    let mempool_validator = smp.validator.clone();
    let use_case_history = smp.use_case_history.clone();
    let num_committed_txns_received_since_peers_updated = smp
        .network_interface
        .num_committed_txns_received_since_peers_updated
        .clone();

    tokio::spawn(async move {
        while let Some(commit_notification) = mempool_listener.next().await {
            handle_commit_notification(
                &mempool,
                &mempool_validator,
                &use_case_history,
                commit_notification,
                &num_committed_txns_received_since_peers_updated,
            );
        }
    });
}
```

**File:** mempool/src/shared_mempool/coordinator.rs (L234-265)
```rust
    num_committed_txns_received_since_peers_updated: &Arc<AtomicU64>,
) where
    TransactionValidator: TransactionValidation,
{
    debug!(
        block_timestamp_usecs = msg.block_timestamp_usecs,
        num_committed_txns = msg.transactions.len(),
        LogSchema::event_log(LogEntry::StateSyncCommit, LogEvent::Received),
    );

    // Process and time committed user transactions.
    let start_time = Instant::now();
    counters::mempool_service_transactions(
        counters::COMMIT_STATE_SYNC_LABEL,
        msg.transactions.len(),
    );
    num_committed_txns_received_since_peers_updated
        .fetch_add(msg.transactions.len() as u64, Ordering::Relaxed);
    process_committed_transactions(
        mempool,
        use_case_history,
        msg.transactions,
        msg.block_timestamp_usecs,
    );
    mempool_validator.write().notify_commit();
    let latency = start_time.elapsed();
    counters::mempool_service_latency(
        counters::COMMIT_STATE_SYNC_LABEL,
        counters::REQUEST_SUCCESS_LABEL,
        latency,
    );
}
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L834-844)
```text
    public fun on_new_epoch(framework: &signer) acquires Features, PendingFeatures {
        ensure_framework_signer(framework);
        if (exists<PendingFeatures>(@std)) {
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            if (exists<Features>(@std)) {
                Features[@std].features = features;
            } else {
                move_to(framework, Features { features })
            }
        }
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L96-111)
```rust
        // Notify the storage service of the committed transactions
        storage_service_notification_handler
            .notify_storage_service_of_committed_transactions(latest_synced_version)
            .await?;

        // Notify mempool of the committed transactions
        mempool_notification_handler
            .notify_mempool_of_committed_transactions(transactions, blockchain_timestamp_usecs)
            .await?;

        // Notify the event subscription service of the events
        event_subscription_service
            .lock()
            .notify_events(latest_synced_version, events)?;

        Ok(())
```

**File:** vm-validator/src/vm_validator.rs (L76-99)
```rust
    fn notify_commit(&mut self) {
        let db_state_view = self.db_state_view();

        // On commit, we need to update the state view so that we can see the latest resources.
        let base_view_id = self.state.state_view_id();
        let new_view_id = db_state_view.id();
        match (base_view_id, new_view_id) {
            (
                StateViewId::TransactionValidation {
                    base_version: old_version,
                },
                StateViewId::TransactionValidation {
                    base_version: new_version,
                },
            ) => {
                // if the state view forms a linear history, just update the state view
                if old_version <= new_version {
                    self.state.reset_state_view(db_state_view.into());
                }
            },
            // if the version is incompatible, we flush the cache
            _ => self.state.reset_all(db_state_view.into()),
        }
    }
```

**File:** vm-validator/src/vm_validator.rs (L155-165)
```rust
        let result = std::panic::catch_unwind(move || {
            let vm_validator_locked = vm_validator.lock().unwrap();

            use aptos_vm::VMValidator;
            let vm = AptosVM::new(&vm_validator_locked.state.environment);
            vm.validate_transaction(
                txn,
                &vm_validator_locked.state.state_view,
                &vm_validator_locked.state,
            )
        });
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L163-186)
```rust
        // Feature-gating for keyless TXNs (whether ZK or ZKless, whether passkey-based or not)
        if matches!(sig.cert, EphemeralCertificate::ZeroKnowledgeSig { .. }) {
            if !features.is_zk_keyless_enabled() {
                return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
            }

            with_zk = true;
        }
        if matches!(sig.cert, EphemeralCertificate::OpenIdSig { .. })
            && !features.is_zkless_keyless_enabled()
        {
            return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
        }
        if matches!(sig.ephemeral_signature, EphemeralSignature::WebAuthn { .. })
            && !features.is_keyless_with_passkeys_enabled()
        {
            return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
        }
        if matches!(pk, AnyKeylessPublicKey::Federated { .. })
            && !features.is_federated_keyless_enabled()
        {
            return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
        }
    }
```
