# Audit Report

## Title
Indexer Denial of Service via UTF-8 Truncation Panic in Coin Symbol Processing

## Summary
The `truncate_str()` utility function uses Rust's `String::truncate()` which operates on byte positions rather than character boundaries. When processing coin symbols containing multi-byte UTF-8 characters, the indexer can panic and crash, causing a denial of service on critical API infrastructure.

## Finding Description

The `truncate_str()` function is implemented incorrectly for UTF-8 strings: [1](#0-0) 

This function calls Rust's `String::truncate()` which operates on **bytes**, not Unicode characters. According to Rust's safety guarantees, `String::truncate()` will **panic** if the truncation point is not on a UTF-8 character boundary.

While line 57 in `v2_token_metadata.rs` is safe because it processes Move type strings (which are ASCII-only per Move's identifier restrictions), the same `truncate_str()` function is used throughout the codebase on user-controlled Unicode data. [2](#0-1) 

The critical vulnerability occurs in coin symbol processing: [3](#0-2) 

The attack vector:
1. Move framework allows coin symbols up to 32 **bytes**: [4](#0-3) 

2. Database schema limits symbols to 10 **characters**: [5](#0-4) 

3. When a coin with a 32-byte symbol containing multi-byte UTF-8 characters is created, the indexer attempts to truncate to 10 bytes: [6](#0-5) 

4. If byte position 10 falls in the middle of a multi-byte character, `String::truncate(10)` **panics**, crashing the indexer.

**Example Attack**: Create a coin with symbol "ðŸ’°ðŸ’°ðŸ’°ðŸ’°ðŸ’°ðŸ’°ðŸ’°ðŸ’°" (8 money bag emoji Ã— 4 bytes each = 32 bytes, valid per Move). When the indexer tries to truncate to byte 10, it falls in the middle of the 3rd emoji (bytes 8-11), causing a panic.

## Impact Explanation

**Severity: High** - This qualifies as an "API crash" per the Aptos bug bounty severity categories.

The indexer is critical infrastructure that powers:
- Block explorers (viewing transactions, accounts, balances)
- Wallet applications (balance queries, transaction history)
- DApp frontends (token metadata, on-chain state)
- Analytics platforms (chain metrics, activity tracking)

When the indexer crashes:
- All API services become unavailable
- No new transaction data is indexed
- User-facing applications cannot query blockchain state
- Service requires manual restart and investigation

**Important note**: This does NOT affect consensus or validator operations. Validators continue processing blocks normally. However, it represents a significant service disruption affecting all API-dependent applications.

## Likelihood Explanation

**Likelihood: High**

- **Attacker requirements**: Any user can create a coin with arbitrary name/symbol
- **Complexity**: Trivial - just create a coin with multi-byte UTF-8 characters in the symbol
- **Detection difficulty**: Easy to discover through code review or testing with Unicode
- **Cost**: Standard gas fees for coin creation (~0.01 APT)

The attack is completely deterministic and reproducible. Any coin created with:
- Symbol length between 11-32 bytes
- Containing multi-byte UTF-8 characters positioned such that byte 10 falls mid-character

will trigger the panic.

## Recommendation

Replace `truncate_str()` with a UTF-8-aware character truncation function:

```rust
pub fn truncate_str(val: &str, max_chars: usize) -> String {
    val.chars().take(max_chars).collect()
}
```

This truncates by character count rather than byte count, preventing mid-character splits.

Alternatively, if byte-based truncation is required, use a safe variant:

```rust
pub fn truncate_str(val: &str, max_bytes: usize) -> String {
    if val.len() <= max_bytes {
        return val.to_string();
    }
    
    // Find the last valid UTF-8 boundary at or before max_bytes
    let mut idx = max_bytes;
    while idx > 0 && !val.is_char_boundary(idx) {
        idx -= 1;
    }
    val[..idx].to_string()
}
```

Additionally, align database schema limits with Move framework limits to avoid unnecessary truncation.

## Proof of Concept

```rust
#[test]
fn test_truncate_str_panic() {
    use crate::util::truncate_str;
    
    // Create a string with 8 emoji (32 bytes total)
    let symbol = "ðŸ’°ðŸ’°ðŸ’°ðŸ’°ðŸ’°ðŸ’°ðŸ’°ðŸ’°";
    assert_eq!(symbol.len(), 32); // 32 bytes
    assert_eq!(symbol.chars().count(), 8); // 8 characters
    
    // This will panic because byte 10 is not on a character boundary
    // Each emoji is 4 bytes: [0-3][4-7][8-11][12-15]...
    // Byte 10 is in the middle of the 3rd emoji
    let result = std::panic::catch_unwind(|| {
        truncate_str(symbol, 10)
    });
    
    assert!(result.is_err(), "Expected panic but function succeeded");
}
```

To reproduce the full attack:
1. Deploy a Move module that creates a coin with symbol "ðŸ’°ðŸ’°ðŸ’°ðŸ’°ðŸ’°ðŸ’°ðŸ’°ðŸ’°"
2. Submit the transaction to create this coin
3. Observe the indexer crash when processing the `CoinInfo` resource
4. Check indexer logs for panic: "byte index 10 is not a char boundary"

## Notes

The specific line 57 in `v2_token_metadata.rs` is actually **safe** because it processes Move type strings (e.g., `0x1::module::Resource`) which are restricted to ASCII characters by Move's identifier validation rules. However, the underlying `truncate_str()` function has a fundamental design flaw that causes crashes when used on Unicode data elsewhere in the codebase, particularly in coin symbol processing.

The vulnerability demonstrates the importance of UTF-8 awareness when implementing string manipulation utilities in systems that process international text.

### Citations

**File:** crates/indexer/src/util.rs (L23-27)
```rust
pub fn truncate_str(val: &str, max_chars: usize) -> String {
    let mut trunc = val.to_string();
    trunc.truncate(max_chars);
    trunc
}
```

**File:** third_party/move/move-core/types/src/identifier.rs (L5-23)
```rust
//! An identifier is the name of an entity (module, resource, function, etc) in Move.
//!
//! A valid identifier consists of an ASCII string which satisfies any of the conditions:
//!
//! * The first character is a letter and the remaining characters are letters, digits,
//!   underscores, or dollar.
//! * The first character is an underscore or dollar, and there is at least one further letter,
//!   digit, underscore, or dollar.
//!
//! Notice that dollar (`$`) is reserved for compiler or runtime intrinsic identifiers
//! and cannot be reached from the Move language.
//!
//! The spec for allowed identifiers is similar to Rust's spec
//! ([as of version 1.38](https://doc.rust-lang.org/1.38.0/reference/identifiers.html)).
//!
//! Allowed identifiers are currently restricted to ASCII due to unresolved issues with Unicode
//! normalization. See [Rust issue #55467](https://github.com/rust-lang/rust/issues/55467) and the
//! associated RFC for some discussion. Unicode identifiers may eventually be supported once these
//! issues are worked out.
```

**File:** crates/indexer/src/models/coin_models/coin_utils.rs (L34-36)
```rust
    pub fn get_symbol_trunc(&self) -> String {
        truncate_str(&self.symbol, 10)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L125-126)
```text
    const MAX_COIN_NAME_LENGTH: u64 = 32;
    const MAX_COIN_SYMBOL_LENGTH: u64 = 32;
```

**File:** crates/indexer/src/schema.rs (L83-84)
```rust
        #[max_length = 10]
        symbol -> Varchar,
```

**File:** crates/indexer/src/models/coin_models/coin_infos.rs (L72-72)
```rust
                    symbol: inner.get_symbol_trunc(),
```
