# Audit Report

## Title
Monitoring Blindness and Rate Limiting Bypass via Uncounted V2 Request Drops in Storage Service

## Summary
The storage service server drops transaction data v2 requests when `enable_transaction_data_v2` is disabled, but does so before request validation, rate limiting, and error metric collection. This creates a monitoring blind spot where `STORAGE_REQUESTS_RECEIVED` metrics increase without corresponding error or response metrics, allowing attackers to bypass rate limiting and operate undetected.

## Finding Description

The storage service implements a request moderator that tracks invalid requests per peer and rate-limits peers that exceed `max_invalid_requests_per_peer`. However, when a v2 transaction data request arrives at a server with `enable_transaction_data_v2 = false`, the request is dropped prematurely in the request handling flow. [1](#0-0) 

The request flow shows that:
1. `STORAGE_REQUESTS_RECEIVED` metric is incremented for all incoming requests
2. V2 requests are checked and dropped with only a warning log
3. The early return bypasses all subsequent validation and metrics

The normal flow processes requests through `validate_and_handle_request()`, which calls the moderator's validation: [2](#0-1) 

The moderator validation increments invalid request counters and enforces rate limiting: [3](#0-2) 

When invalid request count exceeds the threshold, the moderator marks peers as ignored: [4](#0-3) 

However, v2 requests dropped at line 116 of handler.rs never reach this validation logic, creating a bypass where:
- Requests are counted in `STORAGE_REQUESTS_RECEIVED`
- No corresponding `STORAGE_ERRORS_ENCOUNTERED` or `STORAGE_RESPONSES_SENT` metric is incremented
- Invalid request counters are not incremented
- Rate limiting is not applied

The v2 request types that trigger this bypass are: [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Validator Node Slowdowns**: Attackers can send unlimited v2 requests that consume server resources (network bandwidth, deserialization, logging) without being rate-limited, potentially degrading node performance.

2. **Monitoring Blindness**: Operators monitoring the storage service see `STORAGE_REQUESTS_RECEIVED` increasing without corresponding error or response metrics, creating an impossible state in dashboards. This metric discrepancy can:
   - Hide legitimate attacks occurring simultaneously
   - Prevent accurate capacity planning
   - Mask service degradation

3. **Resource Exhaustion**: Each dropped request still:
   - Consumes network bandwidth
   - Gets deserialized
   - Generates a log entry (log spam attack)
   - Increments metrics

4. **Security Monitoring Bypass**: The attack operates entirely below the detection threshold of standard monitoring, as error metrics and rate limiting do not capture these requests.

## Likelihood Explanation

This vulnerability is **highly likely** to be exploitable:

1. **No Special Requirements**: Any network peer can send storage service requests; no privileged access is required.

2. **Configuration-Dependent**: While `enable_transaction_data_v2` defaults to `true` in current code, operators may disable it for compatibility or testing, making those nodes vulnerable.

3. **Easy Discovery**: Attackers can probe whether v2 is disabled by sending v2 requests and observing that no error response is returned (the connection is silently dropped).

4. **Low Attack Complexity**: The attack requires only crafting valid v2 request messages, which is straightforward given the public request types.

## Recommendation

Move the v2 request validation check to occur **after** the request moderator validation, or ensure that dropped v2 requests are properly counted as errors and subject to rate limiting.

**Recommended Fix:**

```rust
pub fn process_request_and_respond(
    &self,
    storage_service_config: StorageServiceConfig,
    peer_network_id: PeerNetworkId,
    protocol_id: ProtocolId,
    request: StorageServiceRequest,
    response_sender: ResponseSender,
) {
    // Update the request count
    increment_counter(
        &metrics::STORAGE_REQUESTS_RECEIVED,
        peer_network_id.network_id(),
        request.get_label(),
    );

    // Handle any optimistic fetch requests
    if request.data_request.is_optimistic_fetch() {
        self.handle_optimistic_fetch_request(peer_network_id, request, response_sender);
        return;
    }

    // Handle any subscription requests
    if request.data_request.is_subscription_request() {
        self.handle_subscription_request(
            storage_service_config,
            peer_network_id,
            request,
            response_sender,
        );
        return;
    }

    // If the request is for transaction v2 data and server doesn't support it,
    // treat it as an invalid request (with proper error metrics)
    if request.data_request.is_transaction_data_v2_request()
        && !storage_service_config.enable_transaction_data_v2
    {
        let error = Error::InvalidRequest(format!(
            "Received a v2 data request ({}), which is not supported!",
            request.get_label()
        ));
        
        // Increment error counter
        increment_counter(
            &metrics::STORAGE_ERRORS_ENCOUNTERED,
            peer_network_id.network_id(),
            error.get_label().into(),
        );
        
        // Send error response (this will allow moderator to track invalid requests)
        let storage_error = StorageServiceError::InvalidRequest(error.to_string());
        response_sender.send(Err(storage_error));
        return;
    }

    // Process the request and return the response to the client
    let response = self.process_request(&peer_network_id, request.clone(), false);
    self.send_response(request, response, response_sender);
}
```

This ensures that:
1. Error metrics are properly incremented
2. An error response is sent to the client
3. Future requests from the same peer can be tracked by the moderator
4. Monitoring dashboards show accurate request/response/error counts

## Proof of Concept

```rust
#[tokio::test]
async fn test_v2_request_monitoring_blindness() {
    use aptos_config::config::StorageServiceConfig;
    use aptos_storage_service_types::requests::{
        DataRequest, GetTransactionDataWithProofRequest, StorageServiceRequest,
        TransactionDataRequestType,
    };
    use aptos_config::network_id::{NetworkId, PeerNetworkId};
    use aptos_types::PeerId;
    
    // Create a storage service with v2 disabled
    let mut config = StorageServiceConfig::default();
    config.enable_transaction_data_v2 = false;
    
    // Create a v2 request
    let v2_request = StorageServiceRequest::new(
        DataRequest::GetTransactionDataWithProof(GetTransactionDataWithProofRequest {
            proof_version: 100,
            start_version: 0,
            end_version: 10,
            include_events: false,
            transaction_data_request_type: TransactionDataRequestType::TransactionOutputData,
        }),
        false,
    );
    
    let peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    
    // Get initial metrics
    let initial_requests = STORAGE_REQUESTS_RECEIVED
        .with_label_values(&[peer_network_id.network_id().as_str(), v2_request.get_label().as_str()])
        .get();
    let initial_errors = STORAGE_ERRORS_ENCOUNTERED
        .with_label_values(&[peer_network_id.network_id().as_str(), "invalid_request"])
        .get();
    
    // Send the v2 request
    // handler.process_request_and_respond(config, peer_network_id, protocol_id, v2_request, response_sender);
    
    // Verify metrics show the blindness:
    // - STORAGE_REQUESTS_RECEIVED should be incremented
    // - STORAGE_ERRORS_ENCOUNTERED should NOT be incremented (BUG!)
    // - This creates a metric gap that allows undetected attacks
    
    let final_requests = STORAGE_REQUESTS_RECEIVED
        .with_label_values(&[peer_network_id.network_id().as_str(), v2_request.get_label().as_str()])
        .get();
    let final_errors = STORAGE_ERRORS_ENCOUNTERED
        .with_label_values(&[peer_network_id.network_id().as_str(), "invalid_request"])
        .get();
    
    assert_eq!(final_requests, initial_requests + 1, "Request metric should be incremented");
    assert_eq!(final_errors, initial_errors, "ERROR: Error metric is not incremented - monitoring blindness!");
    // The second assertion demonstrates the vulnerability
}
```

## Notes

This vulnerability demonstrates a classic monitoring blindness issue where security-critical events (invalid requests) are not properly tracked in metrics, allowing attackers to operate below the detection threshold of standard operational monitoring. The fix requires ensuring that all request outcomes (success, error, or drop) are properly accounted for in metrics and subject to rate limiting controls.

### Citations

**File:** state-sync/storage-service/server/src/handler.rs (L98-117)
```rust
        // Update the request count
        increment_counter(
            &metrics::STORAGE_REQUESTS_RECEIVED,
            peer_network_id.network_id(),
            request.get_label(),
        );

        // If the request is for transaction v2 data, only process it
        // if the server supports it. Otherwise, drop the request.
        if request.data_request.is_transaction_data_v2_request()
            && !storage_service_config.enable_transaction_data_v2
        {
            warn!(LogSchema::new(LogEntry::StorageServiceError)
                .error(&Error::InvalidRequest(format!(
                    "Received a v2 data request ({}), which is not supported!",
                    request.get_label()
                )))
                .peer_network_id(&peer_network_id));
            return;
        }
```

**File:** state-sync/storage-service/server/src/handler.rs (L205-213)
```rust
    /// Validate the request and only handle it if the moderator allows
    fn validate_and_handle_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<StorageServiceResponse, Error> {
        // Validate the request with the moderator
        self.request_moderator
            .validate_request(peer_network_id, request)?;
```

**File:** state-sync/storage-service/server/src/moderator.rs (L47-69)
```rust
    /// Increments the invalid request count for the peer and marks
    /// the peer to be ignored if it has sent too many invalid requests.
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L134-186)
```rust
    pub fn validate_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<(), Error> {
        // Validate the request and time the operation
        let validate_request = || {
            // If the peer is being ignored, return an error
            if let Some(peer_state) = self.unhealthy_peer_states.get(peer_network_id) {
                if peer_state.is_ignored() {
                    return Err(Error::TooManyInvalidRequests(format!(
                        "Peer is temporarily ignored. Unable to handle request: {:?}",
                        request
                    )));
                }
            }

            // Get the latest storage server summary
            let storage_server_summary = self.cached_storage_server_summary.load();

            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }

```

**File:** state-sync/storage-service/types/src/requests.rs (L150-155)
```rust
    /// Returns true iff the request is a transaction data v2 request
    pub fn is_transaction_data_v2_request(&self) -> bool {
        matches!(self, &Self::GetTransactionDataWithProof(_))
            || matches!(self, &Self::GetNewTransactionDataWithProof(_))
            || matches!(self, &Self::SubscribeTransactionDataWithProof(_))
    }
```
