# Audit Report

## Title
Missing Groth16 Verification Key Validation Allows Governance to Set Malicious VK from Compromised Trusted Setup

## Summary
The `set_groth16_verification_key_for_next_epoch` function allows governance to set an arbitrary Groth16 verification key without any cryptographic validation. While a `validate_groth16_vk` function exists to verify BN254 curve point validity, it is never called. This enables governance to set a malicious VK from a compromised trusted setup ceremony, allowing attackers who know the toxic waste to forge zero-knowledge proofs and steal all keyless accounts.

## Finding Description

The keyless account system relies on Groth16 zero-knowledge proofs for authentication. The security of this system fundamentally depends on the verification key (VK) coming from a proper trusted setup ceremony where the toxic waste was destroyed.

**The Vulnerability:** [1](#0-0) 

The governance function to update the VK performs NO validation whatsoever. It only checks that the caller is `@aptos_framework` and then directly buffers the VK for the next epoch.

**Unused Validation Function:** [2](#0-1) 

A `validate_groth16_vk` function exists that validates BN254 curve points, but it is **never called anywhere in the codebase**. This validation would at minimum ensure the curve points are valid, but even this basic check is missing.

**Contrast with Proper Validation Pattern:** [3](#0-2) 

Other on-chain configs like `gas_schedule` properly validate inputs before calling `config_buffer::upsert`, including checking feature versions and other constraints.

**False Security Claim:** [4](#0-3) 

The comment claims "we do check for that in `keyless_account.move`" but this is **demonstrably false**. The VK is loaded with only deserialization checks, no validation.

**Delayed Deserialization Check:** [5](#0-4) 

The only validation that occurs is basic BN254 point deserialization when the VK is loaded into `PreparedVerifyingKey`. This merely checks if bytes can be deserialized into valid curve points. It does **NOT** verify:
- The VK matches expected circuit parameters
- The VK comes from a proper trusted setup
- The VK matches any known-good hash or commitment
- The VK parameters are consistent with the circuit design

**Security Warning Already Present:** [6](#0-5) 

The code already acknowledges this risk with a WARNING that "If a malicious key is set, this would lead to stolen funds."

**Attack Path:**

1. Attacker compromises a trusted setup ceremony (or conducts their own) and keeps the toxic waste (secret randomness used to generate the VK)
2. Attacker submits governance proposal with malicious VK from their compromised setup
3. Governance votes pass the proposal (could happen through social engineering, compromised governance, or if the VK appears valid)
4. VK is set on-chain via `on_new_epoch` without any validation: [7](#0-6) 
5. With knowledge of the toxic waste, attacker can forge ZKPs for any keyless public key
6. Attacker generates fraudulent ZKPs authenticating as any keyless account holder
7. Verification succeeds because the malicious VK validates the forged proofs: [8](#0-7) 
8. Attacker drains all keyless accounts on the network

## Impact Explanation

**Severity: CRITICAL** - This meets the highest severity criteria per Aptos bug bounty:

1. **Loss of Funds (theft)**: Complete compromise of ALL keyless accounts. Attacker can authenticate as any keyless user and transfer their funds.

2. **Cryptographic Correctness Invariant Violation**: Breaks the fundamental cryptographic assumption that zero-knowledge proofs cannot be forged without the witness. A malicious VK from a compromised setup undermines the entire security model.

3. **Scope**: Affects every single keyless account on the Aptos blockchain. With keyless accounts being a major feature for user onboarding, this could result in catastrophic losses.

4. **No Recovery Path**: Once a malicious VK is set and funds are stolen, there is no way to recover them without a hard fork. The theft would appear cryptographically valid.

This vulnerability directly enables theft of funds at network scale, qualifying for the maximum Critical severity rating ($1,000,000 bounty range).

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

While this requires governance action, the likelihood is concerning because:

1. **No Technical Barrier**: There is zero on-chain validation. Any VK that deserializes will be accepted.

2. **Social Engineering Vector**: A malicious VK could be disguised as a legitimate upgrade (e.g., "updating to a more efficient circuit"). Without on-chain verification against expected parameters or hash commitments, governance participants cannot verify the VK's authenticity.

3. **Complexity Barrier is Low**: VKs are opaque byte arrays. Even technically sophisticated governance participants cannot manually verify a VK came from a proper trusted setup just by inspecting the proposal.

4. **Trust in Proposers**: Governance often trusts proposals from core developers or reputable community members. If such an entity is compromised or malicious, the proposal could pass.

5. **No Defense in Depth**: The comment suggests validation was intended but never implemented. This indicates a known gap that has persisted.

The main protection is governance vigilance, but technical verification is impossible without additional on-chain checks.

## Recommendation

Implement multiple layers of defense:

**1. Call the Existing Validation Function:**

Modify `set_groth16_verification_key_for_next_epoch`:

```move
public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk);  // ADD THIS LINE
    config_buffer::upsert<Groth16VerificationKey>(vk);
}
```

**2. Add VK Hash Verification:**

Store a cryptographic commitment to the expected VK (computed from the trusted setup ceremony output):

```move
struct ExpectedVKHash has key {
    hash: vector<u8>,
}

public fun set_groth16_verification_key_for_next_epoch(
    fx: &signer, 
    vk: Groth16VerificationKey,
    expected_hash: vector<u8>
) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk);
    
    // Verify VK matches expected hash from trusted setup
    let vk_bytes = bcs::to_bytes(&vk);
    let vk_hash = aptos_hash::sha3_512(vk_bytes);
    assert!(vk_hash == expected_hash, E_VK_HASH_MISMATCH);
    
    config_buffer::upsert<Groth16VerificationKey>(vk);
}
```

**3. Require Multi-Signature from Circuit Authors:**

Include a signature from the trusted setup ceremony participants proving the VK is authentic.

**4. Time-Lock VK Changes:**

Add a mandatory waiting period after VK proposal before activation to allow community review.

**5. Circuit Parameter Verification:**

Add on-chain verification that the VK's structure matches expected circuit parameters (e.g., number of public inputs, constraint count).

## Proof of Concept

```move
#[test(fx = @aptos_framework)]
fun test_malicious_vk_accepted_without_validation(fx: signer) {
    use aptos_framework::keyless_account;
    use aptos_framework::config_buffer;
    
    // Initialize config buffer
    config_buffer::initialize(&fx);
    
    // Create a malicious VK with arbitrary curve points
    // In reality, these would come from a compromised trusted setup
    let malicious_vk = keyless_account::new_groth16_verification_key(
        x"DEADBEEF...", // malicious alpha_g1
        x"BAADF00D...", // malicious beta_g2  
        x"CAFEBABE...", // malicious gamma_g2
        x"FACADE00...", // malicious delta_g2
        vector[x"...", x"..."] // malicious gamma_abc_g1
    );
    
    // This should fail validation but currently succeeds!
    keyless_account::set_groth16_verification_key_for_next_epoch(
        &fx, 
        malicious_vk
    );
    
    // The malicious VK is now queued for the next epoch
    assert!(config_buffer::does_exist<Groth16VerificationKey>(), 1);
    
    // After epoch change, the malicious VK becomes active
    // Attacker can now forge ZKPs using toxic waste from their setup
}
```

**Exploitation Steps in Rust:**

1. Conduct compromised trusted setup, save toxic waste `τ`
2. Generate malicious VK from compromised setup
3. Submit governance proposal with malicious VK
4. After epoch change, for any target keyless account with public key `pk`:
   - Compute arbitrary public inputs hash `h` for target `pk`
   - Use `τ` to forge proof `π` such that `Verify(VK_malicious, h, π) = true`
   - Submit transaction with forged `π` authenticating as target account
   - Transaction validates successfully, attacker drains account

## Notes

This vulnerability exists because:

1. The `validate_groth16_vk` function was implemented but never integrated into the governance update flow
2. No cryptographic binding exists between the on-chain VK and the trusted setup ceremony outputs  
3. The only check is deserialization, which any well-formed malicious VK will pass
4. The code comment falsely suggests validation happens, indicating incomplete implementation

The impact is maximized because keyless accounts are designed for mass user adoption. A single malicious VK update compromises the entire keyless account ecosystem simultaneously.

**Critical Finding**: This represents a fundamental gap in the security architecture of keyless accounts. The trusted setup ceremony is the root of trust, and there must be cryptographic verification that the on-chain VK matches the ceremony output.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L182-192)
```text
    /// Pre-validate the VK to actively-prevent incorrect VKs from being set on-chain.
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L259-262)
```text
    /// WARNING: To mitigate against DoS attacks, a VK change should be done together with a training wheels PK change,
    /// so that old ZKPs for the old VK cannot be replayed as potentially-valid ZKPs.
    ///
    /// WARNING: If a malicious key is set, this would lead to stolen funds.
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L358-378)
```text
    public(friend) fun on_new_epoch(fx: &signer) acquires Groth16VerificationKey, Configuration {
        system_addresses::assert_aptos_framework(fx);

        if (config_buffer::does_exist<Groth16VerificationKey>()) {
            let vk = config_buffer::extract_v2();
            if (exists<Groth16VerificationKey>(@aptos_framework)) {
                *borrow_global_mut<Groth16VerificationKey>(@aptos_framework) = vk;
            } else {
                move_to(fx, vk);
            }
        };

        if (config_buffer::does_exist<Configuration>()) {
            let config = config_buffer::extract_v2();
            if (exists<Configuration>(@aptos_framework)) {
                *borrow_global_mut<Configuration>(@aptos_framework) = config;
            } else {
                move_to(fx, config);
            }
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L287-293)
```rust
        // We use an `Option` to handle the VK not being set on-chain, or an incorrect VK being set
        // via governance (although, currently, we do check for that in `keyless_account.move`).
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```

**File:** types/src/keyless/groth16_vk.rs (L62-91)
```rust
impl TryFrom<&Groth16VerificationKey> for PreparedVerifyingKey<Bn254> {
    type Error = CryptoMaterialError;

    fn try_from(vk: &Groth16VerificationKey) -> Result<Self, Self::Error> {
        if vk.gamma_abc_g1.len() != 2 {
            return Err(CryptoMaterialError::DeserializationError);
        }

        // NOTE: Technically, we already validate the points when we set the VK in Move, so we could
        // make this 2x faster by avoiding the point validation checks  via
        // `deserialize_with_mode(..., Compress::Yes, Validate::No)`. Due to paranoia, will not
        // optimize this for now.
        Ok(Self::from(VerifyingKey {
            alpha_g1: G1Affine::deserialize_compressed(vk.alpha_g1.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            beta_g2: G2Affine::deserialize_compressed(vk.beta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_g2: G2Affine::deserialize_compressed(vk.gamma_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            delta_g2: G2Affine::deserialize_compressed(vk.delta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_abc_g1: vec![
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[0].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[1].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
            ],
        }))
    }
}
```

**File:** types/src/keyless/groth16_sig.rs (L215-235)
```rust
    pub fn verify_proof(
        &self,
        public_inputs_hash: Fr,
        pvk: &PreparedVerifyingKey<Bn254>,
    ) -> anyhow::Result<()> {
        // let start = std::time::Instant::now();
        let proof: Proof<Bn254> = Proof {
            a: self.a.deserialize_into_affine()?,
            b: self.b.deserialize_into_affine()?,
            c: self.c.deserialize_into_affine()?,
        };
        // println!("Deserialization time: {:?}", start.elapsed());

        // let start = std::time::Instant::now();
        let verified = Groth16::<Bn254>::verify_proof(pvk, &proof, &[public_inputs_hash])?;
        // println!("Proof verification time: {:?}", start.elapsed());
        if !verified {
            bail!("groth16 proof verification failed")
        }
        Ok(())
    }
```
