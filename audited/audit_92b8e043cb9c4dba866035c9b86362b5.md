# Audit Report

## Title
2-Chain Consensus Safety Violation: Timeout Certificate Allows Round Regression Below one_chain_round

## Summary
The `safe_to_timeout()` function in the 2-chain consensus safety rules contains a critical logic error that allows validators to sign timeouts for rounds significantly lower than their observed `one_chain_round`, enabling potential consensus safety violations through chain equivocation.

## Finding Description

The vulnerability exists in the timeout safety check logic. [1](#0-0) 

The function uses OR logic to evaluate two separate timeout paths:
1. Timeout based on QC: `round == next_round(qc_round)`
2. Timeout based on TC: `round == next_round(tc_round)`

The safety check `qc_round >= safety_data.one_chain_round` is applied uniformly to BOTH paths via the AND operator, but this creates a critical gap.

**The `one_chain_round` field** represents the highest certified block round the validator has observed. [2](#0-1) 

When the TC-based timeout path is taken (`round == next_round(tc_round)` evaluates to TRUE), the current logic only validates that `qc_round >= one_chain_round`, but does NOT validate that `tc_round >= one_chain_round`. This allows the following attack:

**Attack Scenario:**
1. Validator has `one_chain_round = 100` (observed certified block at round 100)
2. Attacker presents a valid but old `TwoChainTimeoutCertificate` with `tc_round = 50`
3. Attacker constructs a `TwoChainTimeout` message with:
   - `round = 51` (timeout round)
   - `qc_round = 100` (satisfies the one_chain_round check)
   - Includes the TC from step 2

4. The safety check evaluates:
   - `round == next_round(qc_round)` → `51 == 101` → FALSE
   - `round == next_round(tc_round)` → `51 == 51` → TRUE
   - `qc_round >= one_chain_round` → `100 >= 100` → TRUE
   - Result: `(FALSE || TRUE) && TRUE = TRUE` → **PASSES**

5. Validator signs timeout for round 51, updating `last_voted_round = 51` [3](#0-2) 

6. Validator can now vote on blocks at round 52+ that may conflict with the chain containing the certified block at round 100

**Safety Invariant Violation:**

In 2-chain consensus, a block B0 commits when there exists a certified block B1 at `round(B0) + 1`. [4](#0-3) 

If the validator has `one_chain_round = 100`, there may already be committed blocks at rounds 99-100. By allowing the validator to timeout and subsequently vote at round 51-52, this creates the potential for:
- **Equivocation**: Voting on two conflicting chains (one at round 100+, one at round 51+)
- **Double commit**: Different validators committing different blocks at the same logical position
- **Chain fork**: Network split with different honest validators on incompatible chains

The voting safety check also does not validate against `one_chain_round`. [5](#0-4) 

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This vulnerability qualifies as **Critical** under the Aptos Bug Bounty program because it enables:

1. **Consensus/Safety violations**: Validators can participate in conflicting chains, violating the fundamental safety guarantee that no two conflicting blocks can both commit under < 1/3 Byzantine validators

2. **Potential chain split**: If exploited systematically, this could cause different honest validators to commit different blocks, requiring manual intervention or a hard fork to resolve

3. **Breaking the 2-chain safety invariant**: The attack allows validators to regress below their observed certified blocks, undermining the monotonic progress assumption critical to 2-chain consensus correctness

The vulnerability is exploitable with:
- Valid (but old) timeout certificates that can be collected from network history
- No need for validator collusion or Byzantine behavior beyond presenting stale but valid messages
- Affects all validators that process the malicious timeout message

## Likelihood Explanation

**High Likelihood**

1. **Attack feasibility**: Old TCs are naturally produced during normal consensus operation and can be collected and replayed. No cryptographic forgery required.

2. **Detection difficulty**: The attack uses valid cryptographic signatures and passes all existing safety checks, making it difficult to detect without specific monitoring for round regression.

3. **Network conditions**: The vulnerability is more likely to manifest during network partitions or high latency scenarios where validators may receive messages out of order, making old TCs appear alongside current state.

4. **No collusion required**: A single malicious actor can trigger this by presenting valid-but-stale TCs to honest validators.

5. **Persistent impact**: Once a validator signs a regressed timeout, the damage persists in their `last_voted_round` state, affecting all subsequent voting decisions.

## Recommendation

The timeout safety check should validate that whichever path is taken (QC-based or TC-based), the round being used as justification is not below `one_chain_round`.

**Recommended fix:**

```rust
fn safe_to_timeout(
    &self,
    timeout: &TwoChainTimeout,
    maybe_tc: Option<&TwoChainTimeoutCertificate>,
    safety_data: &SafetyData,
) -> Result<(), Error> {
    let round = timeout.round();
    let qc_round = timeout.hqc_round();
    let tc_round = maybe_tc.map_or(0, |tc| tc.round());
    
    // Check both paths separately with appropriate one_chain_round validation
    let qc_path_safe = round == next_round(qc_round)? 
        && qc_round >= safety_data.one_chain_round;
    
    let tc_path_safe = round == next_round(tc_round)? 
        && tc_round >= safety_data.one_chain_round;
    
    if qc_path_safe || tc_path_safe {
        Ok(())
    } else {
        Err(Error::NotSafeToTimeout(
            round,
            qc_round,
            tc_round,
            safety_data.one_chain_round,
        ))
    }
}
```

Alternatively, use the TC's highest QC round when validating the TC path:

```rust
let tc_hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
let tc_path_safe = round == next_round(tc_round)? 
    && tc_hqc_round >= safety_data.one_chain_round;
```

## Proof of Concept

Add the following test to `consensus/safety-rules/src/tests/suite.rs`:

```rust
#[test]
fn test_timeout_regression_vulnerability() {
    let (mut safety_rules, signer) = test_utils::make_safety_rules();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();
    
    // Build chain: genesis -> a1 (round 1) -> ... -> a100 (round 100)
    let mut prev_block = test_utils::make_proposal_with_qc(1, genesis_qc.clone(), &signer);
    
    for round in 2..=100 {
        prev_block = make_proposal_with_parent(round, &prev_block, None, &signer);
    }
    
    // Vote on round 100 block, setting one_chain_round = 99 (from a100's QC)
    safety_rules.construct_and_sign_vote_two_chain(&prev_block, None).unwrap();
    
    // Create a valid TC from old round 50
    let old_tc = make_timeout_cert(50, &genesis_qc, &signer);
    
    // Create timeout for round 51 with high QC (round 99)
    let malicious_timeout = TwoChainTimeout::new(
        1,  // epoch
        51, // round (based on TC at round 50)
        prev_block.block().quorum_cert().clone() // QC at round 99
    );
    
    // This SHOULD fail because tc_round (50) < one_chain_round (99)
    // But currently PASSES due to the vulnerability
    let result = safety_rules.sign_timeout_with_qc(
        &malicious_timeout,
        Some(&old_tc)
    );
    
    // Vulnerability: This succeeds when it should fail
    assert!(result.is_err(), "Timeout should be rejected for round regression");
    
    // Verify error is NotSafeToTimeout
    match result.unwrap_err() {
        Error::NotSafeToTimeout(round, qc_round, tc_round, one_chain_round) => {
            assert_eq!(round, 51);
            assert_eq!(tc_round, 50);
            assert_eq!(one_chain_round, 99);
            assert!(tc_round < one_chain_round, "TC round regresses below one_chain_round");
        }
        _ => panic!("Expected NotSafeToTimeout error"),
    }
}
```

**Notes**

The vulnerability stems from the logical operator precedence in the boolean condition. The current implementation `(A || B) && C` applies constraint C uniformly to both paths A and B, when it should be `(A && C) || (B && C')` where C' is a TC-specific constraint checking `tc_round >= one_chain_round`.

This is a subtle but critical logic error that violates the fundamental monotonicity assumption of the 2-chain consensus protocol: validators should never regress to processing rounds lower than the highest certified blocks they have observed.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L43-44)
```rust
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L133-136)
```rust
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L147-166)
```rust
    /// Core safety voting rule for 2-chain protocol. Return success if 1 or 2 is true
    /// 1. block.round == block.qc.round + 1
    /// 2. block.round == tc.round + 1 && block.qc.round >= tc.highest_hqc.round
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L190-194)
```rust
    /// Produces a LedgerInfo that either commits a block based upon the 2-chain
    /// commit rule or an empty LedgerInfo for no commit. The 2-chain commit rule is: B0 and its
    /// prefixes can be committed if there exist certified block B1 that satisfy:
    /// 1) B0 <- B1 <--
    /// 2) round(B0) + 1 = round(B1)
```

**File:** consensus/consensus-types/src/safety_data.rs (L15-17)
```rust
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
```
