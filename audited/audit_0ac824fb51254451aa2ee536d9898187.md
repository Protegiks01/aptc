# Audit Report

## Title
Path Traversal Vulnerability in Backup System Metadata Processing Leading to Arbitrary File Read

## Summary
A path traversal vulnerability exists in the Aptos backup system where malicious metadata can cause arbitrary file reads on validator/fullnode filesystems during automatic restore operations. The vulnerability stems from inadequate validation of `FileHandle` strings embedded in backup metadata, which are used directly in file path operations without sanitization.

## Finding Description

The vulnerability exists in the interaction between metadata storage and file access operations in the backup system. While `save_metadata_lines()` validates its direct inputs (`ShellSafeName` and `TextLine`), it does not validate the content within those inputs—specifically the `FileHandle` strings embedded in metadata structures. [1](#0-0) 

The attack chain works as follows:

1. **Metadata Creation**: Backup metadata structures (`EpochEndingBackupMeta`, `StateSnapshotBackupMeta`, `TransactionBackupMeta`) contain a `manifest` field of type `FileHandle` (which is just a `String`). This field is never validated when metadata is created: [2](#0-1) 

2. **Metadata Serialization**: When metadata is converted to `TextLine` via `to_text_line()`, it's serialized to JSON. Path traversal sequences like `../../../../../../etc/passwd` are preserved as strings in the JSON: [3](#0-2) 

3. **TextLine Validation**: The `TextLine::new()` function only checks for literal newline characters, not path traversal: [4](#0-3) 

4. **Metadata Parsing**: During restore, metadata files are parsed back from JSON without validation: [5](#0-4) 

5. **Automatic Restore**: The restore coordinator automatically loads metadata and uses the manifest FileHandles: [6](#0-5) 

6. **Path Traversal Exploitation**: When `StateSnapshotRestoreController` attempts to load the manifest, it calls `load_json_file()`: [7](#0-6) 

7. **Vulnerable File Access**: The `load_json_file()` eventually calls `open_for_read()` which in LocalFs directly joins the untrusted FileHandle with the base directory: [8](#0-7) 

The critical vulnerability is at line 102: `let path = self.dir.join(file_handle);`. In Rust, `Path::join()` with a relative path containing `..` allows directory traversal. If `file_handle` is `"../../../../../../../etc/passwd"`, this resolves to `/etc/passwd` regardless of `self.dir`. [9](#0-8) 

## Impact Explanation

This vulnerability qualifies as **High Severity** according to Aptos bug bounty criteria:

**Information Disclosure → Key Theft → Loss of Funds**: An attacker who gains write access to backup storage (compromised S3 bucket, shared NFS, etc.) can inject malicious metadata. When a validator or fullnode performs automatic restore during bootstrapping, the malicious FileHandle causes arbitrary file reads. This enables:

- Reading validator consensus keys (`/opt/aptos/data/secure-data.json` or similar)
- Reading network keys and configuration files
- Reading state database files
- Reading `/etc/passwd`, environment variables, or other system files

Once consensus keys are obtained, the attacker can impersonate the validator, potentially leading to:
- Double-signing attacks
- Equivocation
- Theft of staked funds through validator key compromise

This represents a significant protocol violation and meets the High severity threshold of "Significant protocol violations" with potential escalation to Critical if keys lead to direct fund theft.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires:
1. **Write access to backup storage**: While this requires some level of access, shared backup infrastructure (S3 buckets, cloud storage) can be misconfigured or compromised. Organizations often share backup storage across environments or have overly permissive IAM policies.

2. **Node performing restore operation**: This happens automatically during:
   - New node bootstrapping (common for validators joining the network)
   - State sync recovery after crashes
   - Disaster recovery scenarios

No validator insider access or protocol-level privileges are required. The attack exploits the trust placed in backup storage, which may be considered "trusted" infrastructure but is actually part of the attack surface.

The likelihood increases because:
- Backup storage is often shared/external infrastructure
- Node bootstrap is automatic (no operator intervention needed)
- The vulnerability is in the default LocalFs implementation used for testing and potentially production
- No existing path validation or sanitization is present in the codebase

## Recommendation

Implement strict validation of FileHandle strings before use in file operations:

1. **Validate on Creation**: Add validation when FileHandles are created in `create_for_write()` to ensure they don't contain path traversal sequences.

2. **Validate on Use**: Most critically, add path validation in `open_for_read()` before joining paths:

```rust
async fn open_for_read(
    &self,
    file_handle: &FileHandleRef,
) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
    // Validate file_handle doesn't contain path traversal
    ensure!(
        !file_handle.contains("..") && !file_handle.starts_with('/'),
        "Invalid file handle: path traversal not allowed"
    );
    
    let path = self.dir.join(file_handle);
    
    // Canonicalize and ensure the resolved path is still within self.dir
    let canonical_path = path.canonicalize().err_notes(&path)?;
    let canonical_dir = self.dir.canonicalize().err_notes(&self.dir)?;
    ensure!(
        canonical_path.starts_with(&canonical_dir),
        "Path traversal detected: resolved path outside backup directory"
    );
    
    let file = OpenOptions::new()
        .read(true)
        .open(&canonical_path)
        .await
        .err_notes(&canonical_path)?;
    Ok(Box::new(file))
}
```

3. **Consider Using Typed Paths**: Leverage the path normalization utilities already present in the codebase for Move packages: [10](#0-9) 

4. **Add Metadata Validation**: Implement validation when deserializing metadata to reject FileHandles containing suspicious patterns.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_path_traversal_in_metadata() {
    use std::path::PathBuf;
    use tempfile::TempDir;
    use crate::storage::{BackupStorage, local_fs::LocalFs};
    use crate::metadata::{Metadata, StateSnapshotBackupMeta};
    
    // Setup: Create temporary backup directory
    let temp_dir = TempDir::new().unwrap();
    let storage = LocalFs::new(temp_dir.path().to_path_buf());
    
    // Create /tmp/sensitive_file to simulate a sensitive file
    let sensitive_content = "SENSITIVE_VALIDATOR_KEY";
    std::fs::write("/tmp/sensitive_file", sensitive_content).unwrap();
    
    // Attack: Create malicious metadata with path traversal in manifest field
    let malicious_metadata = Metadata::StateSnapshotBackup(StateSnapshotBackupMeta {
        epoch: 1,
        version: 100,
        manifest: "../../../../../../../tmp/sensitive_file".to_string(), // Path traversal!
    });
    
    // Save malicious metadata (simulating attacker writing to backup storage)
    let text_line = malicious_metadata.to_text_line().unwrap();
    storage.save_metadata_line(&malicious_metadata.name(), &text_line)
        .await
        .unwrap();
    
    // Exploit: During restore, the manifest FileHandle is used in open_for_read
    let file_handle = "../../../../../../../tmp/sensitive_file";
    let mut reader = storage.open_for_read(file_handle).await.unwrap();
    
    let mut content = String::new();
    reader.read_to_string(&mut content).await.unwrap();
    
    // Verify: The sensitive file was read via path traversal
    assert_eq!(content, sensitive_content);
    println!("VULNERABILITY CONFIRMED: Read sensitive file outside backup directory!");
}
```

## Notes

- The vulnerability affects the LocalFs backend directly. The CommandAdapter backend is also potentially vulnerable to command injection depending on how the FileHandle is used in shell commands.
- This represents a defense-in-depth failure: untrusted data (backup storage) is trusted implicitly without validation.
- The attack surface exists because backup storage is often considered "trusted infrastructure" but may be shared, misconfigured, or compromised.
- The automatic nature of restore operations during node bootstrap makes this vulnerability particularly concerning as it requires no operator interaction to exploit.

### Citations

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L149-181)
```rust
    async fn save_metadata_lines(
        &self,
        name: &ShellSafeName,
        lines: &[TextLine],
    ) -> Result<FileHandle> {
        let dir = self.metadata_dir();
        create_dir_all(&dir).await.err_notes(name)?; // in case not yet created
        let content = lines
            .iter()
            .map(|e| e.as_ref())
            .collect::<Vec<&str>>()
            .join("");
        let path = dir.join(name.as_ref());
        let file = OpenOptions::new()
            .write(true)
            .create_new(true)
            .open(&path)
            .await;
        match file {
            Ok(mut f) => {
                f.write_all(content.as_bytes()).await.err_notes(&path)?;
                f.shutdown().await.err_notes(&path)?;
            },
            Err(e) if e.kind() == io::ErrorKind::AlreadyExists => {
                info!("File {} already exists, Skip", name.as_ref());
            },
            _ => bail!("Unexpected Error in saving metadata file {}", name.as_ref()),
        }
        let fh = PathBuf::from(Self::METADATA_DIR)
            .join(name.as_ref())
            .path_to_string()?;
        Ok(fh)
    }
```

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L170-172)
```rust
    pub fn to_text_line(&self) -> Result<TextLine> {
        TextLine::new(&serde_json::to_string(self)?)
    }
```

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L175-196)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd)]
pub struct EpochEndingBackupMeta {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub first_version: Version,
    pub last_version: Version,
    pub manifest: FileHandle,
}

#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd)]
pub struct StateSnapshotBackupMeta {
    pub epoch: u64,
    pub version: Version,
    pub manifest: FileHandle,
}

#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd)]
pub struct TransactionBackupMeta {
    pub first_version: Version,
    pub last_version: Version,
    pub manifest: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L107-114)
```rust
impl TextLine {
    pub fn new(value: &str) -> Result<Self> {
        let newlines: &[_] = &['\n', '\r'];
        ensure!(value.find(newlines).is_none(), "Newline not allowed.");
        let mut ret = value.to_string();
        ret.push('\n');
        Ok(Self(ret))
    }
```

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L237-246)
```rust
    async fn load_metadata_lines(&mut self) -> Result<Vec<Metadata>> {
        let mut buf = String::new();
        self.read_to_string(&mut buf)
            .await
            .err_notes((file!(), line!(), &buf))?;
        Ok(buf
            .lines()
            .map(serde_json::from_str::<Metadata>)
            .collect::<Result<_, serde_json::error::Error>>()?)
    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L117-122)
```rust
        let metadata_view = metadata::cache::sync_and_load(
            &self.metadata_cache_opt,
            Arc::clone(&self.storage),
            self.global_opt.concurrent_downloads,
        )
        .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-124)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
```

**File:** storage/backup/backup-cli/src/utils/storage_ext.rs (L24-29)
```rust
    async fn read_all(&self, file_handle: &FileHandleRef) -> Result<Vec<u8>> {
        let mut file = self.open_for_read(file_handle).await?;
        let mut bytes = Vec::new();
        file.read_to_end(&mut bytes).await?;
        Ok(bytes)
    }
```

**File:** third_party/move/tools/move-package-resolver/src/path.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

use anyhow::Result;
use std::{
    ops::Deref,
    path::{Component, Path, PathBuf},
};

/// Wrapper around [`PathBuf`] that represents a canonical path, which is not only normalized,
/// but also absolute and have all symbolic links resolved.
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct CanonicalPath(PathBuf);

impl Deref for CanonicalPath {
    type Target = PathBuf;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl AsRef<Path> for CanonicalPath {
    fn as_ref(&self) -> &Path {
        &self.0
    }
}

impl CanonicalPath {
    pub fn new(path: impl AsRef<Path>) -> Result<Self> {
        let path = path.as_ref().canonicalize()?;
        Ok(Self(path))
    }
}

/// Normalizes a path by removing all redundant `..` and `.` components.
/// Accepts both relative and absolute paths as input.
///
/// Examples:
/// - `./foo` -> `foo`
/// - `a/b/../c` -> `a/c`
/// - `/foo/../..` -> `/`
/// - `a/../../b` -> `../b`
fn normalize_path(path: impl AsRef<Path>) -> PathBuf {
    let path = path.as_ref();
    let mut stack = vec![];

    for component in path.components() {
        match &component {
            Component::CurDir => (),
```
