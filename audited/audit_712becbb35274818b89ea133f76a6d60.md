# Audit Report

## Title
Event V2 Translation Failure Masking Causes Silent Data Loss in Indexer

## Summary
The `translate_event_v2_to_v1()` function in `db_indexer.rs` catches all translation errors and converts them to `Ok(None)` instead of propagating them, causing Event V2 events to silently disappear from the indexer when translation fails. The `map_err()` and `?` operator at lines 451-457 are dead code that never execute, resulting in data loss without error propagation. [1](#0-0) 

## Finding Description

The vulnerability exists in the event indexing logic within `DBIndexer::process_a_batch()`. When processing Event V2 events, the code attempts to translate them to V1 format for backward compatibility. However, the error handling is fundamentally broken:

**The Core Issue:**

The `translate_event_v2_to_v1()` function implementation **never returns an `Err(...)`**. Instead, it catches all translation errors internally and returns `Ok(None)`: [2](#0-1) 

At line 565, when any translation error occurs (BCS deserialization failures, state lookup errors, resource not found, etc.), the function enters the `Err(e)` branch. While it distinguishes between "ignored" errors (mint/burn with ConcurrentSupply) and other errors at lines 568-577, **all errors ultimately return `Ok(None)` at line 578**.

**The Dead Code:**

Back in `process_a_batch()`, lines 451-457 contain a `map_err()` call followed by a `?` operator that is **completely unreachable**: [3](#0-2) 

Since `translate_event_v2_to_v1()` always returns `Ok(...)`, the `map_err()` closure never executes, and the `?` operator simply unwraps the `Ok` value. When translation fails, the function returns `Ok(None)`, which causes the `if let Some(translated_v1_event)` pattern at line 450 to not match, silently skipping the event.

**Types of Failures That Are Masked:**

1. **BCS Deserialization Errors**: When `try_from_bytes()` fails due to malformed event data [4](#0-3) 

2. **State Lookup Errors**: When resources cannot be found (for events other than mint/burn) [5](#0-4) 

3. **Resource Deserialization Errors**: When `bcs::from_bytes()` fails on state values

4. **Sequence Number Calculation Errors**: Any errors from `get_next_sequence_number()`

**Attack Vectors:**

1. **Malicious Move Contracts**: An attacker can deploy a Move contract that emits Event V2 events with intentionally malformed data structures. When the indexer attempts to deserialize these via `try_from_bytes()`, the BCS deserialization will fail, the error will be caught and converted to `Ok(None)`, and the events will disappear from the index.

2. **State Corruption/Race Conditions**: If there's a timing issue where a resource is deleted between transaction execution and indexing, the translator won't find the required resource (e.g., `TokenStore`, `CoinStore`), causing the event to be dropped.

3. **Schema Evolution Issues**: During framework upgrades, if event schemas change, BCS deserialization might fail for events created with old schemas, causing them to silently disappear.

## Impact Explanation

This vulnerability represents **HIGH severity** under the Aptos bug bounty program criteria:

**Data Integrity Violation**: The indexer is a critical component that provides historical event data to dApps, wallets, explorers, and other ecosystem tools. Silent data loss violates the fundamental guarantee that all blockchain events are queryable.

**Specific Impacts:**

1. **dApp Breakage**: Applications relying on event queries will receive incomplete data, leading to:
   - Missing transaction history in wallets
   - Incomplete token transfer records
   - Failed balance reconciliation
   - Broken NFT metadata tracking

2. **Security Implications**: Some dApps use events for security-critical operations:
   - Monitoring suspicious activities
   - Tracking governance votes
   - Auditing fund movements
   - The silent loss of these events could mask malicious activities

3. **Debugging Impossibility**: When events disappear, developers cannot:
   - Debug their contracts effectively
   - Trace transaction execution
   - Audit system behavior

4. **No Error Visibility**: Events disappear with only a warning log (line 572-576), which can be easily missed in production systems. There's no metric, alert, or hard failure to indicate data loss. [6](#0-5) 

While this doesn't directly affect consensus (the blockchain state itself remains correct), it represents a **significant protocol violation** that undermines the reliability of the indexing infrastructure, qualifying as HIGH severity.

## Likelihood Explanation

**High Likelihood** - This vulnerability can occur through multiple realistic scenarios:

1. **Frequent Occurrence**: Any Move contract that emits Event V2 events can trigger this if:
   - The event data is malformed
   - The required resources are missing
   - There are BCS deserialization issues

2. **Low Attacker Requirements**: An attacker only needs to:
   - Deploy a Move contract (permissionless)
   - Emit malformed Event V2 events
   - No special privileges required

3. **Production Reality**: The code already has special handling for expected failures (mint/burn with ConcurrentSupply at lines 568-570), indicating that translation failures DO occur in practice. The fact that the code tries to handle these cases shows this is not theoretical. [7](#0-6) 

4. **Gradual Accumulation**: Even if individual failures are rare, they accumulate over time, progressively degrading the indexer's data quality without any visible indication until users report missing data.

## Recommendation

**Fix the error handling to properly propagate unexpected errors:**

```rust
pub fn translate_event_v2_to_v1(
    &self,
    v2: &ContractEventV2,
) -> Result<Option<ContractEventV1>> {
    let _timer = TIMER.timer_with(&["translate_event_v2_to_v1"]);
    if let Some(translator) = self
        .event_v2_translation_engine
        .translators
        .get(v2.type_tag())
    {
        let result = translator.translate_event_v2_to_v1(v2, &self.event_v2_translation_engine);
        match result {
            Ok(v1) => Ok(Some(v1)),
            Err(e) => {
                // Only ignore expected errors for ConcurrentSupply collections
                let is_ignored_error = (v2.type_tag() == &*MINT_TYPE
                    || v2.type_tag() == &*BURN_TYPE)
                    && e.to_string().contains("resource not found");
                
                if is_ignored_error {
                    // Expected failure for ConcurrentSupply - return Ok(None)
                    Ok(None)
                } else {
                    // Unexpected error - propagate it
                    warn!(
                        "Failed to translate event: {:?}. Error: {}",
                        v2,
                        e.to_string()
                    );
                    Err(e)  // Changed from Ok(None) to Err(e)
                }
            },
        }
    } else {
        Ok(None)
    }
}
```

**Key Changes:**
1. Return `Err(e)` for unexpected translation failures instead of `Ok(None)`
2. Only return `Ok(None)` for genuinely expected failures (ConcurrentSupply case)
3. This makes the `map_err()` and `?` operator at lines 451-457 functional
4. Batch processing will fail fast on unexpected errors, preventing silent data loss

**Additional Recommendations:**
1. Add metrics to track translation failures
2. Add alerting when translation error rates exceed thresholds
3. Consider adding a configuration flag to control error handling behavior (strict vs. lenient mode)
4. Review all other event translators to ensure they return appropriate errors

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::contract_event::ContractEventV2;
    use move_core_types::language_storage::TypeTag;
    
    #[test]
    fn test_malformed_event_data_causes_silent_loss() {
        // Setup: Create an indexer instance
        let indexer = /* setup DBIndexer */;
        
        // Create a malformed CoinDeposit event with invalid BCS data
        let malformed_data = vec![0xFF, 0xFF, 0xFF]; // Invalid BCS encoding
        let event_v2 = ContractEventV2::new(
            COIN_DEPOSIT_TYPE.clone(),
            malformed_data,
        );
        
        // Attempt translation
        let result = indexer.translate_event_v2_to_v1(&event_v2);
        
        // BUG: This returns Ok(None) instead of Err(...)
        assert!(result.is_ok());
        assert!(result.unwrap().is_none());
        
        // The event has silently disappeared!
        // Expected: result.is_err() should be true
        // Actual: result is Ok(None), event is dropped without error propagation
    }
    
    #[test]
    fn test_missing_resource_causes_silent_loss() {
        // Setup: Create an indexer with empty state
        let indexer = /* setup DBIndexer with no resources */;
        
        // Create a valid TokenDeposit event, but TokenStore resource doesn't exist
        let token_deposit = TokenDeposit::new(/* valid data */);
        let event_v2 = ContractEventV2::new(
            TOKEN_DEPOSIT_TYPE.clone(),
            bcs::to_bytes(&token_deposit).unwrap(),
        );
        
        // Attempt translation - TokenDepositTranslator will fail to find TokenStore
        let result = indexer.translate_event_v2_to_v1(&event_v2);
        
        // BUG: This returns Ok(None) instead of propagating the error
        assert!(result.is_ok());
        assert!(result.unwrap().is_none());
        
        // The event has silently disappeared without proper error handling!
    }
}
```

**Move PoC:**

```move
module attacker::event_disruptor {
    use std::signer;
    use aptos_framework::event;
    
    // Create an event type that will cause translation issues
    struct MaliciousEvent has drop, store {
        // Intentionally incompatible with expected schema
        corrupted_data: vector<u8>,
    }
    
    public entry fun emit_broken_events(account: &signer) {
        // Emit events that will fail during translation
        event::emit(MaliciousEvent {
            corrupted_data: vector[0xFF, 0xFF, 0xFF],
        });
        
        // These events will be silently dropped from the indexer
        // without any error propagation or hard failure
    }
}
```

## Notes

The vulnerability is confirmed through code analysis showing that `translate_event_v2_to_v1()` returns `Ok(None)` for ALL errors (line 578), making the error handling at lines 451-457 ineffective. This breaks the data integrity invariant for the indexer, causing events to silently disappear when translation fails for any reason beyond the explicitly handled ConcurrentSupply case.

### Citations

**File:** storage/indexer/src/db_indexer.rs (L448-487)
```rust
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
                    }
                    Ok::<(), AptosDbError>(())
                })?;
            }
```

**File:** storage/indexer/src/db_indexer.rs (L552-584)
```rust
    pub fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
    ) -> Result<Option<ContractEventV1>> {
        let _timer = TIMER.timer_with(&["translate_event_v2_to_v1"]);
        if let Some(translator) = self
            .event_v2_translation_engine
            .translators
            .get(v2.type_tag())
        {
            let result = translator.translate_event_v2_to_v1(v2, &self.event_v2_translation_engine);
            match result {
                Ok(v1) => Ok(Some(v1)),
                Err(e) => {
                    // If the token object collection uses ConcurrentSupply, skip the translation and ignore the error.
                    // This is expected, as the event handle won't be found in either FixedSupply or UnlimitedSupply.
                    let is_ignored_error = (v2.type_tag() == &*MINT_TYPE
                        || v2.type_tag() == &*BURN_TYPE)
                        && e.to_string().contains("resource not found");
                    if !is_ignored_error {
                        warn!(
                            "Failed to translate event: {:?}. Error: {}",
                            v2,
                            e.to_string()
                        );
                    }
                    Ok(None)
                },
            }
        } else {
            Ok(None)
        }
    }
```

**File:** types/src/account_config/events/coin_deposit.rs (L31-33)
```rust
    pub fn try_from_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
        bcs::from_bytes(bytes).map_err(Into::into)
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L627-629)
```rust
            return Err(AptosDbError::from(anyhow::format_err!(
                "Token store resource not found"
            )));
```
