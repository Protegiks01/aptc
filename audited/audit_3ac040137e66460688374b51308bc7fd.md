# Audit Report

## Title
Genesis Denial of Service via Unvalidated Proof-of-Possession in ValidatorConfiguration

## Summary
The genesis configuration validation in the Rust codebase fails to verify BLS12-381 Proof-of-Possession (PoP) cryptographic validity, only checking for field presence and uniqueness. This allows an attacker to submit a ValidatorConfiguration with an invalid or mismatched PoP that passes Rust validation but causes the genesis transaction to abort during Move execution, resulting in complete network unavailability at launch.

## Finding Description

The `validate_validators` function in the genesis validation code checks that cryptographic keys are present and unique across validators, but does NOT verify their cryptographic validity or that the Proof-of-Possession correctly validates against the consensus public key. [1](#0-0) 

The validation only ensures that `consensus_public_key` and `proof_of_possession` fields are `Some` and unique, without calling any cryptographic verification functions. There is no invocation of `ProofOfPossession::verify()` or similar validation in the Rust codebase's genesis validation path.

However, the actual PoP verification occurs much later during genesis transaction execution in the Move code: [2](#0-1) 

This function calls the native BLS12-381 verification: [3](#0-2) 

This creates a Time-of-Check-Time-of-Use (TOCTOU) vulnerability where:
1. **Time of Check**: Rust validation passes with only presence/uniqueness checks
2. **Time of Use**: Move execution validates PoP and aborts if invalid

The Ed25519 public keys are also not validated for weak keys (all zeros, all ones, small-order points) during deserialization: [4](#0-3) 

**Attack Scenario:**
1. Attacker submits a `ValidatorConfiguration` to the genesis Git repository with:
   - A weak or invalid BLS12-381 consensus public key (e.g., identity point, all zeros)
   - A mismatched or invalid Proof of Possession
   - Weak Ed25519 keys (e.g., all zeros) for owner/operator/voter accounts

2. Genesis coordinator runs validation via `validate_validators` which only checks:
   - Fields are present (not `None`) ✓
   - Keys are unique across validators ✓
   - **Does NOT verify PoP cryptographic validity** ❌

3. Genesis blob is generated using the invalid configuration and distributed to all validators

4. When validators attempt to start the network, genesis transaction execution reaches `stake::rotate_consensus_key`

5. The Move code verifies the PoP and **aborts** with `EINVALID_PUBLIC_KEY`

6. Genesis transaction fails → **Network cannot start** → Complete Denial of Service

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program:

- **"Significant protocol violations"**: Prevents the network from launching at all
- Borders on **Critical** severity due to "Total loss of liveness/network availability" at genesis time
- **Impact**: Complete network unavailability requiring genesis regeneration and redistribution
- **Blast radius**: Affects all validators and prevents any blockchain operations
- **Recovery cost**: Requires manual intervention, genesis recreation, and recoordination with all validators
- **Reputation damage**: Failed launch or delayed mainnet deployment

While not permanent (genesis can be regenerated), the operational impact is severe and could be exploited to delay or disrupt critical network launches.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is likely to succeed if:

1. **Genesis process accepts community validator submissions**: The codebase shows Git-based genesis coordination where validators submit their configurations via pull requests [5](#0-4) 

2. **No manual cryptographic verification**: If genesis coordinators rely solely on the automated `validate_validators` function without manually verifying each PoP

3. **Attack complexity**: LOW - Attacker only needs to:
   - Generate an invalid PoP (or use all zeros)
   - Submit a ValidatorConfiguration YAML file
   - No special privileges required

4. **Detection difficulty**: The invalid configuration passes all Rust checks, making it hard to detect before distribution

**Mitigation factors:**
- Mainnet genesis is typically highly controlled
- Multiple review stages may catch obvious invalid keys
- However, subtle cryptographic invalidity could slip through

## Recommendation

Add cryptographic validation to the Rust genesis validation code to verify PoP before genesis creation:

```rust
// In crates/aptos/src/genesis/mod.rs, in validate_validators function
// After line 774, add:

// Validate Proof of Possession for consensus key
if validator.join_during_genesis {
    if let (Some(consensus_pk), Some(pop)) = (
        &validator.consensus_public_key,
        &validator.proof_of_possession,
    ) {
        // Verify the PoP cryptographically validates against the public key
        if !pop.verify(consensus_pk).is_ok() {
            errors.push(CliError::UnexpectedError(format!(
                "Validator {} has an invalid proof of possession that does not verify against its consensus public key",
                name
            )));
        }
        
        // Additionally check the public key is not weak (identity point)
        if consensus_pk.subgroup_check().is_err() {
            errors.push(CliError::UnexpectedError(format!(
                "Validator {} has a weak consensus public key (identity or invalid subgroup)",
                name
            )));
        }
    }
}
```

Additionally, add validation for Ed25519 keys to detect weak/predictable keys:

```rust
// Check Ed25519 keys are not all zeros or other weak patterns
fn is_weak_ed25519_key(key: &Ed25519PublicKey) -> bool {
    let bytes = key.to_bytes();
    bytes.iter().all(|&b| b == 0) || // all zeros
    bytes.iter().all(|&b| b == 0xff) || // all ones
    bytes == [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] // identity point
}

// Apply to owner, operator, and voter keys
if is_weak_ed25519_key(&validator.owner_account_public_key) {
    errors.push(CliError::UnexpectedError(format!(
        "Validator {} has a weak owner account public key",
        name
    )));
}
```

## Proof of Concept

**Step 1**: Create an invalid ValidatorConfiguration YAML:

```yaml
# validator-config.yaml
owner_account_address: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
owner_account_public_key: "0xc0ffee..." # Valid Ed25519 key
operator_account_address: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
operator_account_public_key: "0xc0ffee..." # Valid Ed25519 key
voter_account_address: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
voter_account_public_key: "0xc0ffee..." # Valid Ed25519 key
consensus_public_key: "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" # All zeros - weak key
proof_of_possession: "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" # Invalid/mismatched PoP
validator_network_public_key: "0xabcd..." # Valid x25519 key
validator_host: "127.0.0.1:6180"
stake_amount: 100000000000000
commission_percentage: 10
join_during_genesis: true
```

**Step 2**: Submit to genesis repository and run validation:

```bash
# This will PASS validation
aptos genesis validate-genesis --genesis-repo-dir ./genesis-repo
```

**Step 3**: Generate genesis:

```bash
# This will succeed and create genesis.blob
aptos genesis generate-genesis --genesis-repo-dir ./genesis-repo --output-dir ./output
```

**Step 4**: Attempt to start a validator with this genesis:

```bash
# This will FAIL with EINVALID_PUBLIC_KEY error
aptos-node -f validator-config.yaml
```

**Expected Result**: The node fails to start because the Move code validates the PoP during `stake::rotate_consensus_key` execution in the genesis transaction, discovers the invalid PoP, and aborts with error code `EINVALID_PUBLIC_KEY`.

**Notes**

This vulnerability demonstrates a critical gap between Rust-side validation (presence/uniqueness only) and Move-side validation (full cryptographic verification). The issue is particularly severe for genesis scenarios where recovery requires complete re-coordination among all network participants. The fix should enforce cryptographic validation at the earliest possible point (Rust validation) to fail fast and provide clear error messages before genesis blob distribution.

### Citations

**File:** crates/aptos/src/genesis/mod.rs (L744-774)
```rust
            if validator.consensus_public_key.is_none() {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} does not have a consensus public key, though it's joining during genesis",
                    name
                )));
            }
            if !unique_consensus_keys
                .insert(validator.consensus_public_key.as_ref().unwrap().clone())
            {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a repeated a consensus public key {}",
                    name,
                    validator.consensus_public_key.as_ref().unwrap()
                )));
            }

            if validator.proof_of_possession.is_none() {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} does not have a consensus proof of possession, though it's joining during genesis",
                    name
                )));
            }
            if !unique_consensus_pops
                .insert(validator.proof_of_possession.as_ref().unwrap().clone())
            {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a repeated a consensus proof of possessions {}",
                    name,
                    validator.proof_of_possession.as_ref().unwrap()
                )));
            }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L927-931)
```text
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            new_consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L558-586)
```rust
fn native_bls12381_verify_proof_of_possession(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.is_empty());
    debug_assert!(arguments.len() == 2);

    context.charge(BLS12381_BASE)?;

    let pop_bytes = safely_pop_arg!(arguments, Vec<u8>);
    let key_bytes = safely_pop_arg!(arguments, Vec<u8>);

    let pk = match bls12381_deserialize_pk(key_bytes, context)? {
        Some(pk) => pk,
        None => return Ok(smallvec![Value::bool(false)]),
    };

    let pop = match bls12381_deserialize_pop(pop_bytes, context)? {
        Some(pop) => pop,
        None => return Ok(smallvec![Value::bool(false)]),
    };

    // NOTE(Gas): 2 bilinear pairings and a hash-to-curve
    context.charge(BLS12381_PER_POP_VERIFY * NumArgs::one())?;
    let valid = pop.verify(&pk).is_ok();

    Ok(smallvec![Value::bool(valid)])
}
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L295-304)
```rust
impl TryFrom<&[u8]> for Ed25519PublicKey {
    type Error = CryptoMaterialError;

    /// Deserialize an Ed25519PublicKey. This method will NOT check for key validity, which means
    /// the returned public key could be in a small subgroup. Nonetheless, our signature
    /// verification implicitly checks if the public key lies in a small subgroup, so canonical
    /// uses of this library will not be susceptible to small subgroup attacks.
    fn try_from(bytes: &[u8]) -> std::result::Result<Ed25519PublicKey, CryptoMaterialError> {
        Ed25519PublicKey::from_bytes_unchecked(bytes)
    }
```

**File:** crates/aptos/src/genesis/git.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{
    common::{
        types::{CliError, CliTypedResult},
        utils::{create_dir_if_not_exist, write_to_file},
    },
    CliCommand,
};
use aptos_config::config::Token;
use aptos_framework::ReleaseBundle;
use aptos_genesis::config::Layout;
use aptos_github_client::Client as GithubClient;
use async_trait::async_trait;
use clap::Parser;
use serde::{de::DeserializeOwned, Serialize};
use std::{
    fmt::Debug,
    io::Read,
    path::{Path, PathBuf},
    str::FromStr,
};

pub const LAYOUT_FILE: &str = "layout.yaml";
pub const OPERATOR_FILE: &str = "operator.yaml";
pub const OWNER_FILE: &str = "owner.yaml";
pub const FRAMEWORK_NAME: &str = "framework.mrb";
pub const BALANCES_FILE: &str = "balances.yaml";
pub const EMPLOYEE_VESTING_ACCOUNTS_FILE: &str = "employee_vesting_accounts.yaml";

/// Setup a shared Git repository for Genesis
///
/// This will setup a folder or an online Github repository to be used
/// for Genesis.  If it's the local, it will create the folders but not
/// set up a Git repository.
#[derive(Parser)]
pub struct SetupGit {
    #[clap(flatten)]
    pub(crate) git_options: GitOptions,

    /// Path to the `Layout` file which defines where all the files are
    #[clap(long, value_parser)]
    pub(crate) layout_file: PathBuf,
}

#[async_trait]
impl CliCommand<()> for SetupGit {
    fn command_name(&self) -> &'static str {
        "SetupGit"
```
