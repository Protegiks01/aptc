# Audit Report

## Title
Memory Exhaustion via Malicious Gzip-Compressed Source Maps in PackageMetadata

## Summary
Attackers can publish Move modules with maliciously crafted gzip-compressed source maps that expand from ~1MB compressed size to gigabytes of uncompressed data. When node operators or developers use CLI tools to inspect or display package metadata, the unbounded decompression triggers memory exhaustion, causing denial of service.

## Finding Description

The `SourceMap` data structure contains unbounded collections (BTreeMaps and Vecs) that can grow arbitrarily large: [1](#0-0) 

When publishing a package, the source map is serialized with BCS and compressed with gzip before being stored in `ModuleMetadata.source_map`: [2](#0-1) 

The critical vulnerability occurs in the `Display` implementation for `ModuleMetadata`, which unconditionally decompresses the entire source map without any size validation: [3](#0-2) 

**Attack Path:**

1. Attacker creates a `SourceMap` with millions of entries in `code_map`, `nops`, `locals`, `parameters`, and `type_parameters` fields using highly repetitive data
2. Attacker serializes this with BCS (~10-100 MB uncompressed) and compresses with gzip (~500KB-1MB compressed)
3. Attacker publishes a module with this malicious source map via `publish_package_txn`: [4](#0-3) 

4. The publishing passes validation because:
   - No validation of source_map contents occurs during publishing
   - Compressed size stays under the 1 MB per write operation limit: [5](#0-4) 

5. When node operators or developers use CLI tools (e.g., `aptos move upgrade`, `PrintPackageMetadata` command), the Display trait is invoked: [6](#0-5) 

6. The `unzip_metadata_str` function attempts to decompress gigabytes of data into memory, causing OOM and crashing the tool

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: When validator operators inspect on-chain packages using CLI tools, their systems experience memory exhaustion
- **API crashes**: If REST API nodes implement display functionality for `PackageMetadata`, malicious source maps can crash API services
- **Operational DoS**: Essential developer and operator tooling becomes unusable when encountering malicious packages

The impact is limited to operational tooling because validators do not deserialize source maps during transaction execution or consensus. However, the ability to deny service to critical node operator tooling represents significant operational risk.

## Likelihood Explanation

**Likelihood: High**

- **Trivial to execute**: Any user can publish a package with malicious metadata by paying transaction gas (~$0.01-$1)
- **No special permissions required**: Standard account can publish modules
- **Difficult to detect**: Compressed payload appears innocuous (< 1 MB)
- **Wide attack surface**: Affects all CLI tools, release-builder, and potentially REST APIs that display package metadata
- **Persistent threat**: Once published on-chain, the malicious package remains accessible indefinitely

The only constraint is the 1 MB storage write limit, but gzip compression ratios of 100:1 or higher are achievable with repetitive data, allowing effective "zip bomb" attacks.

## Recommendation

Implement size validation for decompressed source maps at two points:

**1. During Publishing (Preventive)**
Add validation in `publish_package` to check decompressed size:

```rust
// In aptos-move/framework/src/natives/code.rs or validation logic
const MAX_DECOMPRESSED_SOURCE_MAP_SIZE: usize = 10_000_000; // 10 MB

fn validate_module_metadata(metadata: &ModuleMetadata) -> Result<(), Error> {
    if !metadata.source_map.is_empty() {
        let decompressed = unzip_metadata(&metadata.source_map)
            .map_err(|_| Error::InvalidSourceMap)?;
        if decompressed.len() > MAX_DECOMPRESSED_SOURCE_MAP_SIZE {
            return Err(Error::SourceMapTooLarge);
        }
        // Optionally: validate BCS deserialization succeeds and check field counts
        bcs::from_bytes::<SourceMap>(&decompressed)
            .map_err(|_| Error::MalformedSourceMap)?;
    }
    Ok(())
}
```

**2. During Display (Defensive)**
Add size limits to the Display implementation:

```rust
// In aptos-move/framework/src/natives/code.rs
impl fmt::Display for ModuleMetadata {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Module name:{}", self.name)?;
        if !self.source_map.is_empty() {
            writeln!(f, "Source map:")?;
            match unzip_metadata(&self.source_map) {
                Ok(data) if data.len() <= MAX_DECOMPRESSED_SOURCE_MAP_SIZE => {
                    match String::from_utf8(data) {
                        Ok(source_map) => writeln!(f, "{}", source_map)?,
                        Err(_) => writeln!(f, "<binary data>")?,
                    }
                }
                Ok(_) => writeln!(f, "<source map too large: {} bytes>", self.source_map.len())?,
                Err(_) => writeln!(f, "<invalid source map>")?,
            }
        }
        Ok(())
    }
}
```

## Proof of Concept

```rust
// Rust PoC demonstrating the vulnerability
use aptos_framework::natives::code::ModuleMetadata;
use move_bytecode_source_map::source_map::{SourceMap, FunctionSourceMap};
use move_ir_types::location::Loc;
use std::collections::BTreeMap;

#[test]
fn test_malicious_source_map_memory_exhaustion() {
    // Create a malicious source map with millions of entries
    let mut source_map = SourceMap::new(
        Loc::new(FileHash::empty(), 0, 0),
        None
    );
    
    let mut func_map = FunctionSourceMap::new(Loc::new(FileHash::empty(), 0, 0), false);
    
    // Add millions of code mappings (highly compressible with gzip)
    for i in 0..10_000_000 {
        func_map.add_code_mapping(i, Loc::new(FileHash::empty(), 0, 0));
        
        // Add repetitive locals (gzip compresses well)
        if i < 1_000_000 {
            func_map.add_local_mapping((format!("local_{}", i % 100), Loc::new(FileHash::empty(), 0, 0)));
        }
    }
    
    source_map.add_top_level_function_mapping(FunctionDefinitionIndex(0), Loc::new(FileHash::empty(), 0, 0), false).unwrap();
    
    // Serialize and compress (BCS + gzip)
    let serialized = bcs::to_bytes(&source_map).unwrap();
    let compressed = aptos_framework::zip_metadata(&serialized).unwrap();
    
    println!("Uncompressed size: {} MB", serialized.len() / 1_000_000);
    println!("Compressed size: {} KB", compressed.len() / 1_000);
    
    // Create ModuleMetadata with malicious source map
    let metadata = ModuleMetadata {
        name: "MaliciousModule".to_string(),
        source: vec![],
        source_map: compressed,
        extension: None,
    };
    
    // Trigger the vulnerability by displaying the metadata
    // This will attempt to decompress gigabytes and exhaust memory
    println!("{}", metadata); // <-- Memory exhaustion occurs here
}
```

**Notes**

The vulnerability is constrained by storage limits (1 MB per write, 10 MB per transaction), but gzip compression enables effective "zip bomb" style attacks. A 1 MB compressed payload can realistically expand to 10-100 MB or more with repetitive data. While this doesn't reach "gigabytes" as stated in the security question, it still represents a significant DoS vector affecting operational tooling. The core issue is the lack of decompression size validation in both publishing and display paths.

### Citations

**File:** third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs (L47-74)
```rust
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct FunctionSourceMap {
    /// The source location for the definition of this entire function. Note that in certain
    /// instances this will have no valid source location e.g. the "main" function for modules that
    /// are treated as programs are synthesized and therefore have no valid source location.
    pub definition_location: Loc,

    /// The names of the type parameters to the function.
    /// Note that type parameters need to be added in the order of their declaration.
    pub type_parameters: Vec<SourceName>,

    /// The names of the parameters to the function.
    pub parameters: Vec<SourceName>,

    /// The index into the vector is the local's index. The corresponding `(Identifier, Location)` tuple
    /// is the name and location of the local.
    pub locals: Vec<SourceName>,

    /// A map to the code offset for a corresponding nop. Nop's are used as markers for some
    /// high level language information
    pub nops: BTreeMap<NopLabel, CodeOffset>,

    /// The source location map for the function body.
    pub code_map: BTreeMap<CodeOffset, Loc>,

    /// Whether this function is a native function or not.
    pub is_native: bool,
}
```

**File:** aptos-move/framework/src/built_package.rs (L540-544)
```rust
            let source_map = if self.options.with_source_maps {
                zip_metadata(&u.unit.serialize_source_map())?
            } else {
                vec![]
            };
```

**File:** aptos-move/framework/src/natives/code.rs (L111-127)
```rust
impl fmt::Display for ModuleMetadata {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Module name:{}", self.name)?;
        if !self.source.is_empty() {
            writeln!(f, "Source code:")?;
            let source = unzip_metadata_str(&self.source).unwrap();
            writeln!(f, "{}", source)?;
        }
        if !self.source_map.is_empty() {
            writeln!(f, "Source map:")?;
            let source_map = unzip_metadata_str(&self.source_map).unwrap();
            writeln!(f, "{}", source_map)?;
        }
        writeln!(f, "Module extension:{:?}", self.extension)?;
        Ok(())
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L256-259)
```text
    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)
    acquires PackageRegistry {
        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-157)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
        ],
```

**File:** aptos-move/aptos-release-builder/src/main.rs (L450-462)
```rust
            let packages = client
                .get_account_resource_bcs::<PackageRegistry>(address, "0x1::code::PackageRegistry")
                .await?;
            for package in packages.into_inner().packages {
                if package.name == package_name {
                    if print_json {
                        println!("{}", serde_json::to_string(&package).unwrap());
                    } else {
                        println!("{}", package);
                    }
                    break;
                }
            }
```
