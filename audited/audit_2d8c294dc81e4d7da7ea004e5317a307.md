# Audit Report

## Title
Missing Associated Data Validation in Encrypted Transaction Flow Enables Cross-Sender Ciphertext Reuse Attack

## Summary
The encrypted transaction implementation lacks cryptographic validation of `associated_data` binding in the VM validation and decryption pipeline. While encrypted transactions are currently feature-gated, when enabled, attackers can clone ciphertexts from one sender's transaction and reuse them in transactions from different senders by injecting via P2P, completely bypassing the intended sender-to-ciphertext binding.

## Finding Description

The `Ciphertext` struct implements `Clone` and contains `associated_data_bytes` that cryptographically binds the ciphertext to a specific sender address. [1](#0-0) 

When an encrypted transaction is created, the `associated_data` (containing the sender address) is embedded and signed within the ciphertext. [2](#0-1) 

The `verify` method correctly checks that the provided `associated_data` matches what was signed in the ciphertext. [3](#0-2) 

**Critical Gap #1 - API Validation Only:**
The API layer validates encrypted payloads by calling `payload.verify(sender)`. [4](#0-3) 

However, the `EncryptedPayload::verify` method implementation only validates against the transaction sender. [5](#0-4) 

**Critical Gap #2 - VM Validation Bypass:**
The VM validator currently gates all encrypted transactions with `FEATURE_UNDER_GATING`. [6](#0-5) 

When this feature gate is removed, the `validate_signed_transaction` method does NOT call `payload.verify()` to validate the associated_data binding. [7](#0-6) 

**Critical Gap #3 - P2P Transaction Injection:**
Transactions broadcast via P2P bypass API validation and go directly through VM validation. [8](#0-7) 

The validation flow calls the VM validator which would miss the associated_data check. [9](#0-8) 

**Critical Gap #4 - Decryption Without Validation:**
The consensus decryption pipeline decrypts ciphertexts without any associated_data verification. [10](#0-9) 

The decryption extracts executables from the `Decrypted` state without validation. [11](#0-10) 

**Attack Scenario (when feature enabled):**
1. Alice creates encrypted transaction T1 with sender=Alice, containing ciphertext C1 with associated_data={sender: Alice}
2. Malicious validator Bob clones C1 and creates transaction T2 with sender=Bob containing the same C1
3. Bob broadcasts T2 via P2P network to other validators
4. T2 passes VM validation (only checks signature of T2, not the ciphertext's associated_data)
5. T2 enters consensus and decryption pipeline
6. C1 is decrypted without checking that its associated_data matches Bob's address
7. Alice's encrypted payload executes in Bob's transaction context

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos Bug Bounty)

This constitutes a **Significant Protocol Violation** as defined in the High Severity category. The vulnerability completely breaks the cryptographic binding between ciphertexts and sender contexts, which is a fundamental security property of authenticated encryption with associated data (AEAD).

**Current State:** The vulnerability is **latently present** but not currently exploitable because encrypted transactions are feature-gated at multiple levels (VM validation and quorum store). [12](#0-11) 

**When Feature Enabled:** Would allow:
- Cross-sender transaction replay/reuse attacks
- Execution of encrypted transactions in unintended sender contexts
- Potential for unauthorized operations depending on encrypted payload contents
- Violation of **Cryptographic Correctness** and **Transaction Validation** invariants

## Likelihood Explanation

**Current Likelihood: NONE** (feature gated)

**Future Likelihood (when feature enabled): HIGH**

Attack requirements when feature is enabled:
- **LOW barrier:** Attacker observes ciphertexts from blockchain (public)
- **MEDIUM barrier:** Attacker must inject transactions via P2P network
- **HIGH probability:** Any validator or network peer with mempool access can exploit

The missing validation is a systematic gap across three critical code paths (API, VM validation, decryption), making exploitation highly likely if not addressed before feature activation.

## Recommendation

Add `associated_data` validation in the VM validation layer to ensure all transaction submission paths verify the cryptographic binding:

**In `aptos-move/aptos-vm/src/aptos_vm.rs`, within `validate_transaction` method:**

```rust
// After removing the FEATURE_UNDER_GATING check for encrypted payloads
if let Some(encrypted_payload) = transaction.payload().as_encrypted_payload() {
    encrypted_payload.verify(transaction.sender())
        .map_err(|_| VMStatus::error(
            StatusCode::INVALID_SIGNATURE,
            Some("Encrypted payload associated_data verification failed".to_string())
        ))?;
}
```

**Additionally, add defensive validation in the decryption pipeline:**

In `consensus/src/pipeline/decryption_pipeline_builder.rs`, before decryption at line 126, add:

```rust
// Verify associated_data matches sender before decryption
if let Err(e) = txn.payload()
    .as_encrypted_payload()
    .expect("must be encrypted")
    .verify(txn.sender()) 
{
    // Mark as failed decryption instead of panicking
    txn.payload_mut()
        .as_encrypted_payload_mut()
        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
        .expect("must exist");
    continue;
}
```

This defense-in-depth approach ensures validation at both submission time (VM validation) and execution time (decryption pipeline).

## Proof of Concept

**Theoretical PoC** (would require feature enablement to execute):

```rust
// Scenario demonstrating the vulnerability

// Step 1: Alice creates legitimate encrypted transaction
let alice_address = AccountAddress::from_hex_literal("0xa11ce").unwrap();
let alice_txn = create_encrypted_transaction(
    alice_address,
    encrypted_payload_with_ciphertext_C1, // Contains associated_data={sender: alice}
);

// Step 2: Malicious validator Bob intercepts and clones the ciphertext
let bob_address = AccountAddress::from_hex_literal("0xb0b").unwrap();
let cloned_ciphertext = alice_txn.payload()
    .as_encrypted_payload()
    .unwrap()
    .ciphertext()
    .clone(); // Ciphertext is Clone-able

// Step 3: Bob creates new transaction with his address but Alice's ciphertext
let bob_txn = SignedTransaction::new(
    RawTransaction::new(
        bob_address, // Different sender!
        sequence_number,
        TransactionPayload::EncryptedPayload(EncryptedPayload::Encrypted {
            ciphertext: cloned_ciphertext, // Same ciphertext with associated_data={sender: alice}
            extra_config,
            payload_hash,
        }),
        max_gas,
        gas_price,
        expiration,
        chain_id,
    ),
    bob_private_key, // Bob signs the transaction
);

// Step 4: Bob broadcasts via P2P (bypasses API validation)
// VM validation would check:
// - bob_txn signature: VALID (signed by Bob) ✓
// - Sequence number: VALID ✓
// - BUT MISSING: ciphertext.verify(bob_address) would FAIL ✗

// Step 5: If VM validation doesn't check associated_data:
// - Transaction enters consensus
// - Decryption pipeline decrypts Alice's ciphertext
// - Alice's encrypted payload executes in Bob's context
// - VULNERABILITY: Associated_data binding bypassed!
```

**Notes:**
- This PoC cannot currently execute due to feature gating
- Demonstrates the logical flow of the attack when feature is enabled
- Shows that validation must be added before feature activation

---

**Critical Action Required:** This vulnerability MUST be addressed before enabling the encrypted transaction feature. The missing validation represents a fundamental security flaw in the current implementation that would be immediately exploitable upon feature activation.

### Citations

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L23-31)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, Eq, PartialEq)]
#[serde(bound(deserialize = "PCT: DeserializeOwned"))]
pub struct Ciphertext<PCT: InnerCiphertext> {
    vk: VerifyingKey,
    bibe_ct: PCT,
    #[serde(with = "serde_bytes")]
    associated_data_bytes: Vec<u8>,
    signature: Signature,
}
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L84-95)
```rust
        // So that Ciphertext doesn't have to be generic over some AD: AssociatedData
        let associated_data_bytes = bcs::to_bytes(&associated_data)?;

        let to_sign = (&bibe_ct, &associated_data_bytes);
        let signature = signing_key.sign(&bcs::to_bytes(&to_sign)?);

        Ok(Ciphertext {
            vk,
            bibe_ct,
            associated_data_bytes,
            signature,
        })
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L111-132)
```rust
    pub fn verify(&self, associated_data: &impl AssociatedData) -> Result<()> {
        let hashed_id = Id::from_verifying_key(&self.vk);

        (self.bibe_ct.id() == hashed_id).then_some(()).ok_or(
            BatchEncryptionError::CTVerifyError(CTVerifyError::IdDoesNotMatchHashedVK),
        )?;
        (self.associated_data_bytes == bcs::to_bytes(associated_data)?)
            .then_some(())
            .ok_or(BatchEncryptionError::CTVerifyError(
                CTVerifyError::AssociatedDataDoesNotMatch,
            ))?;

        let to_verify = (&self.bibe_ct, &self.associated_data_bytes);

        self.vk
            .verify(&bcs::to_bytes(&to_verify)?, &self.signature)
            .map_err(|e| {
                BatchEncryptionError::CTVerifyError(CTVerifyError::SigVerificationFailed(e))
            })?;

        Ok(())
    }
```

**File:** api/src/transactions.rs (L1340-1346)
```rust
                if let Err(e) = payload.verify(signed_transaction.sender()) {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        e.context("Encrypted transaction payload could not be verified"),
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }
```

**File:** types/src/transaction/encrypted_payload.rs (L82-87)
```rust
    pub fn executable_ref(&self) -> Result<TransactionExecutableRef<'_>> {
        let Self::Decrypted { executable, .. } = self else {
            bail!("Transaction is encrypted");
        };
        Ok(executable.as_ref())
    }
```

**File:** types/src/transaction/encrypted_payload.rs (L147-150)
```rust
    pub fn verify(&self, sender: AccountAddress) -> anyhow::Result<()> {
        let associated_data = PayloadAssociatedData::new(sender);
        self.ciphertext().verify(&associated_data)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1779-1951)
```rust
    fn validate_signed_transaction(
        &self,
        session: &mut SessionExt<impl AptosMoveResolver>,
        module_storage: &impl ModuleStorage,
        transaction: &SignedTransaction,
        transaction_data: &TransactionMetadata,
        log_context: &AdapterLogSchema,
        is_approved_gov_script: bool,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl AptosGasMeter,
    ) -> Result<SerializedSigners, VMStatus> {
        // Check transaction format.
        if transaction.contains_duplicate_signers() {
            return Err(VMStatus::error(
                StatusCode::SIGNERS_CONTAIN_DUPLICATES,
                None,
            ));
        }

        let keyless_authenticators = aptos_types::keyless::get_authenticators(transaction)
            .map_err(|_| VMStatus::error(StatusCode::INVALID_SIGNATURE, None))?;

        // If there are keyless TXN authenticators, validate them all.
        if !keyless_authenticators.is_empty() && !self.is_simulation {
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
        }

        // Account Abstraction dispatchable authentication.
        let senders = transaction_data.senders();
        let proofs = transaction_data.authentication_proofs();

        // Validate that the number of senders matches the number of authentication proofs
        if senders.len() != proofs.len() {
            return Err(VMStatus::error(
                StatusCode::INVALID_NUMBER_OF_AUTHENTICATION_PROOFS,
                Some(format!(
                    "Mismatch between senders count ({}) and authentication proofs count ({})",
                    senders.len(),
                    proofs.len()
                )),
            ));
        }

        // Add fee payer.
        let fee_payer_signer = if let Some(fee_payer) = transaction_data.fee_payer {
            Some(match &transaction_data.fee_payer_authentication_proof {
                Some(AuthenticationProof::Abstract {
                    function_info,
                    auth_data,
                }) => {
                    let enabled = match auth_data {
                        AbstractAuthenticationData::V1 { .. } => {
                            self.features().is_account_abstraction_enabled()
                        },
                        AbstractAuthenticationData::DerivableV1 { .. } => {
                            self.features().is_derivable_account_abstraction_enabled()
                        },
                    };
                    if enabled {
                        dispatchable_authenticate(
                            session,
                            gas_meter,
                            fee_payer,
                            function_info.clone(),
                            auth_data,
                            traversal_context,
                            module_storage,
                        )
                        .map_err(|mut vm_error| {
                            if vm_error.major_status() == OUT_OF_GAS {
                                vm_error
                                    .set_major_status(ACCOUNT_AUTHENTICATION_GAS_LIMIT_EXCEEDED);
                            }
                            vm_error.into_vm_status()
                        })
                    } else {
                        return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
                    }
                },
                _ => Ok(serialized_signer(&fee_payer)),
            }?)
        } else {
            None
        };
        let sender_signers = itertools::zip_eq(senders, proofs)
            .map(|(sender, proof)| match proof {
                AuthenticationProof::Abstract {
                    function_info,
                    auth_data,
                } => {
                    let enabled = match auth_data {
                        AbstractAuthenticationData::V1 { .. } => {
                            self.features().is_account_abstraction_enabled()
                        },
                        AbstractAuthenticationData::DerivableV1 { .. } => {
                            self.features().is_derivable_account_abstraction_enabled()
                        },
                    };
                    if enabled {
                        dispatchable_authenticate(
                            session,
                            gas_meter,
                            sender,
                            function_info.clone(),
                            auth_data,
                            traversal_context,
                            module_storage,
                        )
                        .map_err(|mut vm_error| {
                            if vm_error.major_status() == OUT_OF_GAS {
                                vm_error
                                    .set_major_status(ACCOUNT_AUTHENTICATION_GAS_LIMIT_EXCEEDED);
                            }
                            vm_error.into_vm_status()
                        })
                    } else {
                        Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None))
                    }
                },
                _ => Ok(serialized_signer(&sender)),
            })
            .collect::<Result<_, _>>()?;

        let serialized_signers = SerializedSigners::new(sender_signers, fee_payer_signer);

        if matches!(transaction.payload(), TransactionPayload::Payload(_))
            && !self.features().is_transaction_payload_v2_enabled()
        {
            return Err(VMStatus::error(
                StatusCode::FEATURE_UNDER_GATING,
                Some(
                    "User transactions with TransactionPayloadInner variant are not yet supported"
                        .to_string(),
                ),
            ));
        }

        if !self.features().is_orderless_txns_enabled() {
            if let ReplayProtector::Nonce(_) = transaction.replay_protector() {
                return Err(VMStatus::error(
                    StatusCode::FEATURE_UNDER_GATING,
                    Some("Orderless transactions are not yet supported".to_string()),
                ));
            }
        }

        // The prologue MUST be run AFTER any validation. Otherwise you may run prologue and hit
        // SEQUENCE_NUMBER_TOO_NEW if there is more than one transaction from the same sender and
        // end up skipping validation.
        let executable = transaction
            .executable_ref()
            .map_err(|_| deprecated_module_bundle!())?;
        let extra_config = transaction.extra_config();
        self.run_prologue_with_payload(
            session,
            module_storage,
            &serialized_signers,
            executable,
            extra_config,
            transaction_data,
            log_context,
            is_approved_gov_script,
            traversal_context,
        )?;
        Ok(serialized_signers)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3229-3230)
```rust
        if transaction.payload().is_encrypted_variant() {
            return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
```

**File:** mempool/src/shared_mempool/tasks.rs (L210-230)
```rust
pub(crate) async fn process_transaction_broadcast<NetworkClient, TransactionValidator>(
    smp: SharedMempool<NetworkClient, TransactionValidator>,
    // The sender of the transactions can send the time at which the transactions were inserted
    // in the sender's mempool. The sender can also send the priority of this node for the sender
    // of the transactions.
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    message_id: MempoolMessageId,
    timeline_state: TimelineState,
    peer: PeerNetworkId,
    timer: HistogramTimer,
) where
    NetworkClient: NetworkClientInterface<MempoolSyncMsg>,
    TransactionValidator: TransactionValidation,
{
    timer.stop_and_record();
    let _timer = counters::process_txn_submit_latency_timer(peer.network_id());
    let results = process_incoming_transactions(&smp, transactions, timeline_state, false);
```

**File:** mempool/src/shared_mempool/tasks.rs (L490-500)
```rust
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L121-148)
```rust
        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```

**File:** consensus/src/quorum_store/types.rs (L285-287)
```rust
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
```
