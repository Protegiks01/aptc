# Audit Report

## Title
DKG Chunky PVSS: Panic on Transcript Generation with Zero-Capacity Range Proof Parameters

## Summary
The `PublicParameters::new()` function in the chunky PVSS implementation accepts `max_num_shares=0` without validation, creating range proof parameters with insufficient capacity (`max_n=1`). When attempting to generate a transcript with any non-zero number of shares, the range proof's `prove()` function panics due to an assertion failure, causing an unrecoverable node crash. [1](#0-0) 

## Finding Description

The vulnerability manifests in three stages:

**Stage 1: Invalid Parameter Creation**
When `PublicParameters::new(max_num_shares=0, ell=16, ...)` is called, it calculates `max_num_chunks_padded = 1` and creates a range proof `ProverKey` with `max_n=1`. [2](#0-1) 

**Stage 2: Range Proof Setup Accepts Invalid Capacity**
The `dekart_univariate_v2::Proof::setup()` function accepts `max_n=1` and creates a `ProverKey` that only supports proving 1 value, despite the assertion at line 262 passing because `num_omegas=2` is a power of two. [3](#0-2) 

**Stage 3: Panic During Transcript Generation**
When `Transcript::deal()` attempts to create a transcript with even 1 share, it needs to prove `n = get_total_weight() * num_chunks_per_scalar(ell)` values. For 1 share with `ell=16` on BLS12-381, this requires `n = 1 * 16 = 16` chunks. The range proof's `prove()` function asserts `n <= max_n`, which fails (`16 <= 1`), causing a panic. [4](#0-3) [5](#0-4) 

The calculation shows that `num_chunks_per_scalar` for BLS12-381 scalar field (255 bits) with `ell=16` yields 16 chunks per share: [6](#0-5) 

## Impact Explanation

**Severity Assessment: No Exploitable Impact**

While this constitutes a robustness bug, it does **NOT** meet High severity criteria because:

1. **No Production Usage**: The chunky PVSS scheme is not used in Aptos production DKG. The live system uses the DAS scheme instead: [7](#0-6) 

2. **No Attacker-Controlled Path**: There is no code path where an external attacker can force the system to use chunky PVSS with `max_num_shares=0`. Public parameters are generated through trusted setup procedures, not attacker-controlled inputs.

3. **Test-Only Code Path**: Grep analysis shows chunky PVSS is only referenced in test files, not production validators or DKG managers.

The bug would only manifest if:
- Future code adopts chunky PVSS without proper parameter validation
- A developer accidentally passes `max_num_shares=0` during setup
- The code is modified to expose this functionality to untrusted inputs

None of these scenarios represent an active, exploitable vulnerability.

## Likelihood Explanation

**Likelihood: Negligible**

This cannot occur in production because:
1. Chunky PVSS is not enabled in the DKG manager or validator nodes
2. No configuration mechanism allows selecting chunky PVSS over DAS
3. Public parameters are generated once during trusted setup, not dynamically from user input

The only scenario where this triggers is during development/testing if a developer explicitly calls `PublicParameters::new(0, ...)`, which would immediately reveal itself as a bug during testing.

## Recommendation

Despite not being exploitable, this should be fixed for defensive programming and future-proofing:

```rust
pub fn new<R: RngCore + CryptoRng>(
    max_num_shares: usize,
    ell: u8,
    max_aggregation: usize,
    rng: &mut R,
) -> Result<Self, anyhow::Error> {
    anyhow::ensure!(
        max_num_shares > 0,
        "max_num_shares must be greater than 0, got {}",
        max_num_shares
    );
    
    let max_num_chunks_padded =
        ((max_num_shares * num_chunks_per_scalar::<E::ScalarField>(ell) as usize) + 1)
            .next_power_of_two()
            - 1;
    
    // ... rest of implementation
}
```

Alternatively, add validation in the range proof setup to ensure `max_n` is sufficient for realistic use cases.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "must be ≤ max_n")]
fn test_zero_max_num_shares_causes_panic() {
    use aptos_dkg::pvss::chunky::weighted_transcriptv2::Transcript;
    use aptos_dkg::pvss::chunky::public_parameters::PublicParameters;
    use aptos_dkg::pvss::traits::Transcript as _;
    use ark_bls12_381::Bls12_381;
    use rand::thread_rng;
    
    let mut rng = thread_rng();
    
    // Create public parameters with zero capacity
    let pp = PublicParameters::<Bls12_381>::new(0, 16, 1, &mut rng);
    
    // Create a minimal secret sharing config with 1 share
    let sc = /* minimal WeightedConfig with total_weight=1 */;
    
    // Attempt to deal a transcript - this will PANIC
    let _transcript = Transcript::deal(&sc, &pp, /* ... */);
}
```

## Notes

**Validation Checklist Assessment:**
- ❌ Exploitable by unprivileged attacker: No attacker-controlled path exists
- ❌ Attack path is realistic: Chunky PVSS not used in production
- ❌ Clear security harm demonstrated: No impact on live validators

**Conclusion:** While the bug exists and should be fixed for code quality, it does NOT constitute an exploitable High severity vulnerability per the strict validation criteria. The issue would only become exploitable if future code changes enable chunky PVSS in production without adding proper validation.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L161-183)
```rust
    pub fn new<R: RngCore + CryptoRng>(
        max_num_shares: usize,
        ell: u8,
        max_aggregation: usize,
        rng: &mut R,
    ) -> Self {
        let max_num_chunks_padded =
            ((max_num_shares * num_chunks_per_scalar::<E::ScalarField>(ell) as usize) + 1)
                .next_power_of_two()
                - 1;

        let group_generators = GroupGenerators::default(); // TODO: At least one of these should come from a powers of tau ceremony?
        let pp_elgamal = chunked_elgamal::PublicParameters::default();
        let G = *pp_elgamal.message_base();
        let pp = Self {
            pp_elgamal,
            pk_range_proof: dekart_univariate_v2::Proof::setup(
                max_num_chunks_padded,
                ell as usize,
                group_generators,
                rng,
            )
            .0,
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate_v2.rs (L255-262)
```rust
    fn setup<R: RngCore + CryptoRng>(
        max_n: usize,
        max_ell: usize,
        group_generators: GroupGenerators<E>,
        rng: &mut R,
    ) -> (ProverKey<E>, VerificationKey<E>) {
        let num_omegas = max_n + 1;
        assert!(num_omegas.is_power_of_two());
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate_v2.rs (L344-352)
```rust
        let n = values.len();
        let max_ell = prover_precomputed.powers_of_two.len();

        assert!(
            n <= *max_n,
            "n (got {}) must be ≤ max_n (which is {})",
            n,
            max_n
        );
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L1030-1037)
```rust
        let range_proof = dekart_univariate_v2::Proof::prove(
            &pp.pk_range_proof,
            &f_evals_chunked_flat,
            pp.ell as usize,
            &range_proof_commitment,
            &hkzg_randomness,
            rng,
        );
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L308-310)
```rust
/// - `Rs_rows`: slice of vectors, same shape as `Cs_rows`, contains corresponding committed randomness/keys.
/// - `dk`: decryption key for the player.
/// - `pp`: public parameters (provides group generator).
```

**File:** types/src/dkg/real_dkg/mod.rs (L38-40)
```rust
pub type WTrx = pvss::das::WeightedTranscript;
pub type DkgPP = <WTrx as Transcript>::PublicParameters;
pub type SSConfig = <WTrx as Transcript>::SecretSharingConfig;
```
