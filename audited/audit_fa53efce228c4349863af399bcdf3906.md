# Audit Report

## Title
Module Address Inconsistency in Definition Processing Causes Member Lookup Failures and Deprecation Check Bypass

## Summary
A critical inconsistency exists in how the Move compiler processes modules within `address` blocks when those modules also specify their own address. The `all_module_members()` function records module members using the address block's address, while the `definition()` function uses the module's self-specified address, creating a mismatch that causes member lookups to fail and deprecation checks to be bypassed.

## Finding Description

The vulnerability stems from inconsistent address handling between two phases of the compilation process: [1](#0-0) 

In `all_module_members()`, when processing a `Definition::Address`, the function uses the address block's address for ALL modules within it, creating module identifiers with that address. [2](#0-1) 

However, in `definition()`, the `check_module_address()` function is called which allows a module's self-specified address to override the address block's address: [3](#0-2) 

When a module within an address block specifies a different address, `check_module_address()` returns the module's address (line 395), not the block's address. This creates a critical mismatch:

**Example scenario:**
```move
address 0x1 {
    module 0x42::Exploit { 
        #[deprecated]
        public fun sensitive() { }
    }
}
```

**Phase 1 (all_module_members):** Module members recorded under `0x1::Exploit`

**Phase 2 (definition):** Module definition stored under `0x42::Exploit`

When code later references `0x42::Exploit::sensitive()`, the member lookup fails: [4](#0-3) 

The lookup at line 1202 `module_members.get(mident)` uses `0x42::Exploit`, but the members are stored under `0x1::Exploit`, causing the lookup to return `None` and bypassing the deprecation check.

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria (state inconsistencies requiring intervention):

1. **Deprecation Check Bypass**: Deprecated functions, structs, and constants can be used without warnings when accessed via the module's self-specified address, undermining the deprecation system's security guarantees.

2. **Compiler State Inconsistency**: Creates orphaned module member records and phantom module entries, violating the compiler's internal invariants.

3. **Name Resolution Failures**: Module member lookups may fail unexpectedly when using the actual module address, potentially causing incorrect error messages or allowing invalid code patterns.

4. **Developer Confusion**: Misleads developers about module addresses, potentially causing deployment to wrong addresses on-chain.

While this is a compile-time issue (not affecting runtime VM execution or consensus directly), it compromises the security of the compilation process and can lead to incorrect module deployments.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires:
- Writing a module inside an `address` block with a different self-specified address
- This pattern triggers a compiler warning but continues compilation
- Developers might accidentally create this pattern, or malicious actors could intentionally exploit it

The attack is straightforward to execute and requires no special privileges. Any Move developer can create this pattern in their code.

## Recommendation

Fix the inconsistency by making `all_module_members()` respect module self-specified addresses the same way `definition()` does. Modify the Address variant handling to check each module's address:

```rust
P::Definition::Address(addr_def) => {
    let block_addr = address_(
        compilation_env,
        named_addr_map,
        /* suggest_declaration */ false,
        addr_def.addr,
    );
    for m in &addr_def.modules {
        // Check if module has its own address specification
        let module_addr = match &m.address {
            Some(a) => address_(
                compilation_env,
                named_addr_map,
                /* suggest_declaration */ true,
                *a,
            ),
            None => block_addr,
        };
        let mident = sp(m.name.loc(), ModuleIdent_::new(module_addr, m.name));
        module_members(members, always_add, m, &mident);
        // Handle deprecation attributes...
    }
}
```

Alternatively, make this an error instead of a warning to prevent the inconsistent state entirely.

## Proof of Concept

Create a Move file `exploit.move`:

```move
address 0x1 {
    module 0x42::DeprecatedModule {
        #[deprecated]
        public fun dangerous_function() { }
    }
}

module 0x2::Attacker {
    use 0x42::DeprecatedModule;
    
    public fun exploit() {
        // This should warn about deprecated function
        // but won't because member lookup fails
        DeprecatedModule::dangerous_function();
    }
}
```

Compile with: `move compile --path exploit.move`

**Expected**: Deprecation warning for `dangerous_function` usage

**Actual**: No deprecation warning (lookup fails silently), compilation succeeds with inconsistent module addressing

**Notes**

This vulnerability represents a subtle inconsistency in Definition variant processing where the Address variant's module handling differs between the member recording phase and the definition processing phase. While the enum variants themselves (Module/Address/Script) are properly distinguished via pattern matching, the Address variant's internal logic creates a "type confusion" at the address level - confusing which address should identify the module. This breaks the compiler's internal invariants and bypasses security checks that rely on consistent module identification.

### Citations

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs (L288-313)
```rust
fn definition(
    context: &mut Context,
    module_map: &mut UniqueMap<ModuleIdent, E::ModuleDefinition>,
    scripts: &mut Vec<E::Script>,
    package_name: Option<Symbol>,
    def: P::Definition,
) {
    match def {
        P::Definition::Module(mut m) => {
            let module_paddr = std::mem::take(&mut m.address);
            let module_addr = module_paddr
                .map(|a| sp(a.loc, address(context, /* suggest_declaration */ true, a)));
            module(context, module_map, package_name, module_addr, m)
        },
        P::Definition::Address(a) => {
            let addr = address(context, /* suggest_declaration */ false, a.addr);
            for mut m in a.modules {
                let module_addr = check_module_address(context, a.loc, addr, &mut m);
                module(context, module_map, package_name, Some(module_addr), m)
            }
        },

        P::Definition::Script(_) if !context.is_source_definition => (),
        P::Definition::Script(s) => script(context, scripts, package_name, s),
    }
}
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs (L374-399)
```rust
fn check_module_address(
    context: &mut Context,
    loc: Loc,
    addr: Address,
    m: &mut P::ModuleDefinition,
) -> Spanned<Address> {
    let module_address = std::mem::take(&mut m.address);
    match module_address {
        Some(other_paddr) => {
            let other_loc = other_paddr.loc;
            let other_addr = address(context, /* suggest_declaration */ true, other_paddr);
            let msg = if addr == other_addr {
                "Redundant address specification"
            } else {
                "Multiple addresses specified for module"
            };
            context.env.add_diag(diag!(
                Declarations::DuplicateItem,
                (other_loc, msg),
                (loc, "Address previously specified here")
            ));
            sp(other_loc, other_addr)
        },
        None => sp(loc, addr),
    }
}
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs (L935-992)
```rust
fn all_module_members<'a>(
    compilation_env: &mut CompilationEnv,
    named_addr_maps: &NamedAddressMaps,
    members: &mut UniqueMap<ModuleIdent, ModuleMembers>,
    module_deprecation_attribute_locs: &mut BTreeMap<ModuleIdent, Loc>,
    always_add: bool,
    defs: impl IntoIterator<Item = &'a P::PackageDefinition>,
) {
    for P::PackageDefinition {
        named_address_map,
        def,
        ..
    } in defs
    {
        let named_addr_map = named_addr_maps.get(*named_address_map);
        match def {
            P::Definition::Module(m) => {
                let addr = match &m.address {
                    Some(a) => {
                        address_(
                            compilation_env,
                            named_addr_map,
                            /* suggest_declaration */ true,
                            *a,
                        )
                    },
                    // Error will be handled when the module is compiled
                    None => {
                        Address::Numerical(None, sp(m.loc, NumericalAddress::DEFAULT_ERROR_ADDRESS))
                    },
                };
                let mident = sp(m.name.loc(), ModuleIdent_::new(addr, m.name));
                module_members(members, always_add, m, &mident);
                if let Some(loc) = deprecated_attribute_location(&m.attributes) {
                    module_deprecation_attribute_locs.insert(mident, loc);
                }
            },
            P::Definition::Address(addr_def) => {
                let addr = address_(
                    compilation_env,
                    named_addr_map,
                    /* suggest_declaration */ false,
                    addr_def.addr,
                );
                for m in &addr_def.modules {
                    let mident = sp(m.name.loc(), ModuleIdent_::new(addr, m.name));
                    module_members(members, always_add, m, &mident);
                    if let Some(loc) = deprecated_attribute_location(&addr_def.attributes) {
                        module_deprecation_attribute_locs.insert(mident, loc);
                    } else if let Some(loc) = deprecated_attribute_location(&m.attributes) {
                        module_deprecation_attribute_locs.insert(mident, loc);
                    }
                }
            },
            P::Definition::Script(_) => (),
        }
    }
}
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs (L1195-1205)
```rust
fn member_has_deprecated_annotation(
    context: &mut Context,
    mident: &ModuleIdent,
    member: &Spanned<Symbol>,
) -> Option<Loc> {
    context
        .module_members
        .get(mident)
        .and_then(|members| members.get(member))
        .and_then(|member_info| member_info.deprecation)
}
```
