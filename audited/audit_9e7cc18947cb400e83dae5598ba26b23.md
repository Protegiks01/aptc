# Audit Report

## Title
Race Condition Between Cache Garbage Collection and File Store Metadata Updates Causes Temporary Transaction Unavailability

## Summary
The indexer-grpc data manager has a race condition where `file_store_version` in cache is optimistically incremented before transactions are fully committed to file store metadata. This allows `maybe_gc()` to prematurely evict transactions from cache while file store metadata updates are throttled (up to 10 seconds delay), creating a window where transactions are neither in cache nor reflected in file store metadata, forcing clients to repeatedly fail and retry requests.

## Finding Description
The vulnerability stems from a timing mismatch between three operations:

1. **Optimistic Version Update**: When `FileStoreUploader` fetches transactions from cache, it immediately increments `cache.file_store_version` via atomic `fetch_add` [1](#0-0) 

2. **Aggressive Cache Eviction**: The `maybe_gc()` function uses this optimistically-updated `file_store_version` to determine which transactions are safe to evict from cache [2](#0-1) 

3. **Delayed Metadata Updates**: File store metadata updates are throttled with `MIN_UPDATE_FREQUENCY = 10 seconds` and `max_update_frequency = 1.5 seconds` (for GCS) [3](#0-2) [4](#0-3) 

**Exploitation Path**:
- FileStoreUploader reads transactions [V1, V2) from cache with `update_file_store_version=true` [5](#0-4) 
- Cache's `file_store_version` immediately increments to V2
- `maybe_gc()` runs and evicts [V1, V2) because `start_version < file_store_version` [6](#0-5) 
- File upload completes, but metadata update is delayed by throttling [7](#0-6) 
- Client requests version in [V1, V2) range
- Cache lookup fails (already GC'd) [8](#0-7) 
- File store lookup fails because `get_latest_version()` returns stale metadata [9](#0-8) 
- Client receives error and must retry [10](#0-9) 

## Impact Explanation
This qualifies as **Medium severity** under Aptos bug bounty criteria because it causes "State inconsistencies requiring intervention" in the indexer service. While it doesn't affect core blockchain consensus or execution, it:

- Forces clients to implement aggressive retry logic or experience failures
- Creates unpredictable service availability windows (up to 10 seconds of unavailability)
- Can be triggered repeatedly during periods of high transaction volume causing cache pressure
- Degrades the reliability of the indexer-grpc service which is critical infrastructure for applications and block explorers
- Could be weaponized by flooding transactions to maintain constant cache pressure, creating a persistent DoS condition on the indexer service

## Likelihood Explanation
**High likelihood** - This occurs naturally during normal operation when:
- Transaction throughput is high enough to fill the cache
- Cache size exceeds `target_cache_size`, triggering GC
- The time delta between version increment and metadata update creates the race window

The condition is deterministic given sufficient cache pressure and happens without requiring attacker intervention. In production environments with sustained transaction loads, this race condition will occur regularly.

## Recommendation
Implement synchronous metadata commitment before incrementing `file_store_version`:

1. **Option 1 (Safest)**: Only increment `cache.file_store_version` AFTER file store metadata is successfully updated:
   - Remove the optimistic increment in `get_transactions` 
   - Update `file_store_version` in the upload completion callback
   - Use fetch_max when reading actual file store version to handle race with multiple uploaders

2. **Option 2 (Performance)**: Add a separate tracking mechanism:
   - Maintain `file_store_version_committed` (actual metadata version) separate from `file_store_version_pending` (optimistic version)
   - Use `file_store_version_committed` in `maybe_gc()` to ensure only truly-committed data is evicted
   - Update `file_store_version_committed` after successful metadata write

3. **Option 3 (Hybrid)**: Introduce a safety buffer:
   - Make `maybe_gc()` only evict versions below `file_store_version - SAFETY_BUFFER` where SAFETY_BUFFER = 20000 transactions (~10-15 seconds of buffer)
   - This provides time for metadata updates to complete before eviction

The safest approach is Option 1 to eliminate the race entirely, though it requires refactoring the uploader's callback mechanism.

## Proof of Concept

```rust
// Integration test demonstrating the race condition
// File: ecosystem/indexer-grpc/indexer-grpc-manager/tests/race_condition_test.rs

#[tokio::test]
async fn test_cache_gc_race_with_file_store_metadata() {
    // Setup: Create DataManager with small cache
    let cache_config = CacheConfig {
        max_cache_size: 1_000_000,    // 1MB - small to trigger GC
        target_cache_size: 500_000,    // 500KB
    };
    
    // 1. Fill cache with transactions [0, 1000)
    for i in 0..1000 {
        cache.put_transactions(vec![create_transaction(i)]);
    }
    
    // 2. Simulate FileStoreUploader fetching with update_file_store_version=true
    // This increments cache.file_store_version to 1000
    let txns = cache.get_transactions(0, MAX_SIZE, /*update_file_store_version=*/ true);
    
    // 3. Before metadata update completes, trigger GC by adding more data
    for i in 1000..2000 {
        cache.put_transactions(vec![create_transaction(i)]);
    }
    
    // maybe_gc() runs and removes [0, 1000) from cache
    
    // 4. Client tries to fetch version 500 (now evicted from cache)
    let client_request_result = data_manager.get_transactions(500, 1000).await;
    
    // Expected: Client gets error because:
    // - Not in cache (GC'd)
    // - File store metadata not yet updated (still shows version 0)
    assert!(client_request_result.is_err() || client_request_result.unwrap().is_empty());
    
    // 5. Wait for metadata update (10 seconds)
    tokio::time::sleep(Duration::from_secs(11)).await;
    
    // Now the request succeeds because metadata caught up
    let result = data_manager.get_transactions(500, 1000).await;
    assert!(result.is_ok() && !result.unwrap().is_empty());
}
```

**Notes**

This vulnerability is specific to the indexer-grpc auxiliary service and does not affect core blockchain consensus, execution, or state integrity. However, it represents a significant availability issue for applications depending on reliable transaction indexing. The race condition is inherent to the current architecture's optimistic version tracking combined with throttled metadata updates, and requires architectural changes to fully resolve.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L68-74)
```rust
        while self.start_version < self.file_store_version.load(Ordering::SeqCst)
            && self.cache_size > self.target_cache_size
        {
            let transaction = self.transactions.pop_front().unwrap();
            self.cache_size -= transaction.encoded_len();
            self.start_version += 1;
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L129-134)
```rust
                let old_version = self
                    .file_store_version
                    .fetch_add(transactions.len() as u64, Ordering::SeqCst);
                let new_version = old_version + transactions.len() as u64;
                FILE_STORE_VERSION_IN_CACHE.set(new_version as i64);
                info!("Updated file_store_version in cache to {new_version}.");
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L299-329)
```rust
        if start_version >= cache_start_version {
            if start_version >= cache_next_version {
                // If lagging, try to fetch the data from FN.
                if self.lagging(cache_next_version) && self.allow_fn_fallback {
                    debug!("GrpcManager is lagging, getting data from FN, requested_version: {start_version}, cache_next_version: {cache_next_version}.");
                    let request = GetTransactionsFromNodeRequest {
                        starting_version: Some(start_version),
                        transactions_count: Some(5000),
                    };

                    let (_, mut fullnode_client) =
                        self.metadata_manager.get_fullnode_for_request(&request);
                    let response = fullnode_client.get_transactions_from_node(request).await?;
                    let mut response = response.into_inner();
                    while let Some(Ok(response_item)) = response.next().await {
                        if let Some(response) = response_item.response {
                            match response {
                                Response::Data(data) => {
                                    return Ok(data.transactions);
                                },
                                Response::Status(_) => continue,
                            }
                        }
                    }
                }

                tokio::time::sleep(Duration::from_millis(200)).await;

                // Let client side to retry.
                return Ok(vec![]);
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L366-370)
```rust
            let error_msg = "Failed to fetch transactions from filestore, either filestore is not available, or data is corrupted.";
            // TODO(grao): Consider downgrade this to warn! if this happens too frequently when
            // filestore is unavailable.
            error!(error_msg);
            bail!(error_msg);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L29-29)
```rust
const MIN_UPDATE_FREQUENCY: Duration = Duration::from_secs(10);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L157-163)
```rust
                        data_manager
                            .get_transactions_from_cache(
                                next_version,
                                MAX_SIZE_PER_FILE,
                                /*update_file_store_version=*/ true,
                            )
                            .await
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L250-256)
```rust
        if Instant::now() - self.last_metadata_update_time >= max_update_frequency {
            let _timer = TIMER
                .with_label_values(&["do_upload__update_metadata"])
                .start_timer();
            self.update_file_store_metadata(last_version + 1).await?;
            self.last_metadata_update_time = Instant::now();
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/gcs.rs (L139-142)
```rust
    fn max_update_frequency(&self) -> Duration {
        // NOTE: GCS has rate limiting on per object update rate at once per second.
        Duration::from_secs_f32(1.5)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/file_store_reader.rs (L180-194)
```rust
    pub async fn get_latest_version(&self) -> Option<u64> {
        let metadata = self.get_file_store_metadata().await;
        let latest_version = metadata.map(|metadata| {
            if metadata.chain_id != self.chain_id {
                panic!("Wrong chain_id.");
            }
            metadata.version
        });

        if let Some(version) = latest_version {
            self.cached_file_store_version
                .fetch_max(version, Ordering::SeqCst);
        }

        latest_version
```
