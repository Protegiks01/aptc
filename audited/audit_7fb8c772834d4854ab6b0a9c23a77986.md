# Audit Report

## Title
Insecure Directory Permissions in Binary Installation Path Allow Local Privilege Escalation

## Summary
The `build_updater()` function in `update_helper.rs` creates the installation directory for binaries (movefmt, prover dependencies, and other CLI tools) without explicitly setting restrictive permissions. This relies on the system's umask for security, which if misconfigured, allows an attacker with local access to replace installed binaries with malicious code, leading to code execution with the victim's privileges.

## Finding Description

The vulnerability exists in the directory creation logic used by multiple binary updaters in the Aptos CLI tool. [1](#0-0) 

When `install_dir` is not provided, the code calls `get_additional_binaries_dir()` to get the default installation path (`~/.local/bin` on Unix systems), then creates it using `std::fs::create_dir_all(&dir)` without explicitly setting permissions. [2](#0-1) 

The `std::fs::create_dir_all()` function on Unix systems creates directories with permissions determined by the default umask. With a standard umask of `0o022`, directories are created with `0o755` permissions (owner can write, others can read/execute). However, if a user has a misconfigured umask such as `0o000` or `0o002`, the directory could be created with world-writable or group-writable permissions.

**Attack Scenario:**
1. Developer/validator operator has misconfigured umask (e.g., `umask 000`)
2. User runs `aptos update movefmt` or any other binary updater
3. Installation directory `~/.local/bin` (or `~/.aptoscli/bin` on Windows) is created with overly permissive permissions (e.g., `0o777` - world-writable)
4. Local attacker with access to the system replaces the legitimate binary with malicious code
5. When the victim runs the tool, they execute the attacker's code with their own privileges
6. Attacker gains access to victim's private keys, credentials, or can manipulate blockchain operations

This vulnerability affects multiple binary updaters that use the same `build_updater()` helper function: [3](#0-2) [4](#0-3) 

The codebase demonstrates awareness of permission security in other contexts, explicitly setting restrictive permissions for sensitive files: [5](#0-4) [6](#0-5) 

However, this secure pattern is not applied to directory creation in the binary updater.

## Impact Explanation

This qualifies as **High severity** based on the following:

1. **Code Execution**: Successful exploitation leads to arbitrary code execution with the victim's privileges
2. **Privileged Users at Risk**: If validator operators or core developers are affected, attackers could:
   - Steal validator private keys
   - Manipulate blockchain operations
   - Compromise validator infrastructure
   - Inject backdoors into Move smart contracts being developed
3. **Supply Chain Attack Vector**: Compromised developer tools can lead to broader supply chain attacks
4. **Wide Attack Surface**: Multiple binary updaters (movefmt, prover dependencies, mutation test tools) are affected

While this requires local access and a misconfigured umask, the impact on blockchain security through compromised validators or developers is severe enough to warrant High severity classification.

## Likelihood Explanation

**Moderate Likelihood:**

**Factors Increasing Likelihood:**
- Multi-user development/testing systems are common in organizations
- Some Linux distributions or container configurations may have non-standard umask settings
- Developers may inadvertently set permissive umasks for various reasons
- The vulnerability affects multiple binary updaters, increasing the attack surface

**Factors Decreasing Likelihood:**
- Most modern Linux systems have secure default umask (`0o022`)
- Validators typically run on dedicated, single-user systems
- Professional operators follow security best practices
- Requires local system access (attacker must already have some level of system access)

## Recommendation

Apply explicit restrictive permissions when creating installation directories on Unix systems using `DirBuilder` with the `mode()` method from `std::os::unix::fs::DirBuilderExt`:

```rust
pub fn build_updater(
    info: &UpdateRequiredInfo,
    install_dir: Option<PathBuf>,
    repo_owner: String,
    repo_name: String,
    binary_name: &str,
    linux_name: &str,
    mac_os_name: &str,
    windows_name: &str,
    assume_yes: bool,
) -> Result<Box<dyn ReleaseUpdate>> {
    // ... existing code ...

    let install_dir = match install_dir.clone() {
        Some(dir) => dir,
        None => {
            let dir = get_additional_binaries_dir();
            // Create the directory with restrictive permissions (owner-only)
            #[cfg(unix)]
            {
                use std::fs::DirBuilder;
                use std::os::unix::fs::DirBuilderExt;
                
                let mut builder = DirBuilder::new();
                builder.recursive(true);
                builder.mode(0o700); // rwx------ (owner only)
                builder.create(&dir)
                    .with_context(|| format!("Failed to create directory: {:?}", dir))?;
            }
            
            #[cfg(not(unix))]
            {
                std::fs::create_dir_all(&dir)
                    .with_context(|| format!("Failed to create directory: {:?}", dir))?;
            }
            
            dir
        },
    };

    // ... rest of function ...
}
```

Apply the same fix to `prover_dependencies.rs` at the directory creation site.

Alternatively, set permissions to `0o755` if the binaries need to be accessible by other users, but ensure the parent directory structure has appropriate permissions.

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// File: poc_insecure_directory_permissions.rs

use std::fs;
use std::os::unix::fs::PermissionsExt;
use std::path::PathBuf;
use tempfile::TempDir;

#[test]
fn test_insecure_directory_permissions() {
    // Save current umask
    let original_umask = unsafe { libc::umask(0o000) }; // Set permissive umask
    
    // Simulate the vulnerable code path
    let temp = TempDir::new().unwrap();
    let install_dir = temp.path().join(".local/bin");
    
    // This is what the vulnerable code does
    std::fs::create_dir_all(&install_dir).unwrap();
    
    // Check the permissions
    let metadata = fs::metadata(&install_dir).unwrap();
    let permissions = metadata.permissions();
    let mode = permissions.mode() & 0o777;
    
    println!("Directory created with permissions: {:o}", mode);
    
    // With umask 000, directory will have 0o777 (world-writable)
    assert_eq!(mode, 0o777, "Directory is world-writable!");
    
    // An attacker could now place a malicious binary here
    let malicious_binary = install_dir.join("movefmt");
    fs::write(&malicious_binary, b"#!/bin/sh\necho 'Malicious code executed'\n").unwrap();
    
    // Make it executable
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&malicious_binary).unwrap().permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&malicious_binary, perms).unwrap();
    }
    
    // Restore original umask
    unsafe { libc::umask(original_umask) };
    
    println!("PoC: Successfully demonstrated that with misconfigured umask,");
    println!("     installation directory is created with insecure permissions");
    println!("     allowing attackers to replace binaries.");
}
```

## Notes

This vulnerability affects the Aptos CLI tool's binary update mechanism, not the blockchain protocol itself. However, compromised CLI tools used by validators or developers could lead to broader security incidents including validator key theft or malicious smart contract deployment. The fix should be applied consistently across all binary updaters in the codebase to ensure defense-in-depth security.

### Citations

**File:** crates/aptos/src/update/update_helper.rs (L51-59)
```rust
    let install_dir = match install_dir.clone() {
        Some(dir) => dir,
        None => {
            let dir = get_additional_binaries_dir();
            // Make the directory if it doesn't already exist.
            std::fs::create_dir_all(&dir)
                .with_context(|| format!("Failed to create directory: {:?}", dir))?;
            dir
        },
```

**File:** crates/aptos/src/update/helpers.rs (L16-20)
```rust
    #[cfg(not(windows))]
    {
        let home_dir = std::env::var("HOME").unwrap_or_else(|_| "".into());
        PathBuf::from(home_dir).join(".local/bin")
    }
```

**File:** crates/aptos/src/update/movefmt.rs (L102-114)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        build_updater(
            info,
            self.install_dir.clone(),
            self.repo_owner.clone(),
            self.repo_name.clone(),
            FORMATTER_BINARY_NAME,
            "unknown-linux-gnu",
            "apple-darwin",
            "windows",
            self.prompt_options.assume_yes,
        )
    }
```

**File:** crates/aptos/src/update/prover_dependencies.rs (L105-114)
```rust
        let install_dir = match self.install_dir.clone() {
            Some(dir) => dir,
            None => {
                let dir = get_additional_binaries_dir();
                // Make the directory if it doesn't already exist.
                std::fs::create_dir_all(&dir)
                    .with_context(|| format!("Failed to create directory: {:?}", dir))?;
                dir
            },
        };
```

**File:** crates/aptos/src/common/utils.rs (L223-228)
```rust
/// Write a User only read / write file
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
```

**File:** crates/aptos/src/common/types.rs (L1083-1089)
```rust
    /// Save to the `output_file` with restricted permissions (mode 0600)
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```
