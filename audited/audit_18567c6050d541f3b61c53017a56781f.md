# Audit Report

## Title
Event Gas Model Missing Per-Item Charges Enables Resource Exhaustion at Undercharged Cost

## Summary
The `io_gas_per_event()` function charges only per-byte costs for events without any per-item overhead charge, unlike state writes which charge both per-slot and per-byte fees. This allows attackers to emit millions of small events at ~1000x lower cost than equivalent state operations, causing disproportionate storage and indexing overhead.

## Finding Description

The event gas charging model in `io_gas_per_event()` only applies per-byte charges without per-item overhead: [1](#0-0) 

The gas parameter `storage_io_per_event_byte_write` is defined as 89 internal gas units per byte: [2](#0-1) 

In contrast, state write operations charge both per-slot overhead (89,568 gas units) AND per-byte costs (89 gas units): [3](#0-2) 

During transaction execution, each event is charged individually but only by size: [4](#0-3) 

However, each event incurs significant per-item costs in the storage layer. For V1 events, the system writes to three separate database schemas: [5](#0-4) 

Additionally, all events contribute to Merkle accumulator updates: [6](#0-5) 

The current limits allow up to 10MB total event size per transaction with no limit on event count: [7](#0-6) 

**Attack Scenario:**
1. Attacker submits transaction emitting 10,000,000 events of 1 byte each (10MB total, at limit)
2. Gas charged: 10,000,000 × 89 = 890,000,000 internal gas units
3. Actual cost to system: 30-40 million database writes (3-4 per event), millions of hash computations, extensive indexing overhead
4. Proper cost if charged like state writes: 10,000,000 × 89,568 + 890,000,000 ≈ 896,570,000,000 internal gas units (1000× higher)

This breaks **Invariant #9: Resource Limits** - operations do not properly respect their actual storage and computational costs through adequate gas charging.

## Impact Explanation

This qualifies as **Low Severity** per the Aptos bug bounty criteria as a non-critical implementation bug. While it enables resource exhaustion attacks:

- Does NOT cause consensus issues (deterministic across all nodes)
- Does NOT enable loss or theft of funds
- Does NOT create non-recoverable network failures
- DOES allow disproportionate resource consumption at undercharged cost
- DOES impact storage layer and indexer performance
- The max_io_gas limit (1B units) caps per-transaction damage
- The 10MB total event size limit prevents unbounded abuse

The impact is primarily economic inefficiency and potential degradation of indexer/storage performance if exploited at scale, not critical system compromise.

## Likelihood Explanation

**HIGH likelihood** of occurrence:
- No special privileges required - any transaction sender can exploit
- Simple to execute - emit many small events from Move code
- Economically rational if gas costs matter to attacker
- No complex timing or race conditions needed
- Can be repeated across multiple transactions

The only barrier is that each transaction pays maximum IO gas even while undercharged relative to true cost, limiting per-transaction damage but not preventing sustained attacks.

## Recommendation

Add a per-event overhead charge similar to per-slot charges for state operations:

1. Define new gas parameter `storage_io_per_event` (suggested: ~10,000-50,000 internal gas units to reflect per-item overhead)

2. Update `io_gas_per_event()` to charge both per-item and per-byte:
```rust
pub fn io_gas_per_event(
    &self,
    event: &ContractEvent,
) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
    STORAGE_IO_PER_EVENT + STORAGE_IO_PER_EVENT_BYTE_WRITE * NumBytes::new(event.size() as u64)
}
```

3. Consider adding `max_events_per_transaction` limit to complement byte limits

4. Calibrate the per-event cost based on actual profiling of storage write, indexing, and Merkle accumulator overhead

## Proof of Concept

```move
module attacker::event_spam {
    use std::signer;
    use aptos_framework::event;
    
    struct TinyEvent has drop, store {
        value: u8,
    }
    
    public entry fun spam_events(account: &signer) {
        let i = 0;
        // Emit 1 million events of minimal size
        while (i < 1000000) {
            event::emit(TinyEvent { value: 1 });
            i = i + 1;
        };
    }
}
```

**Test Steps:**
1. Deploy above module to testnet/devnet
2. Execute `spam_events()` with gas profiling enabled
3. Observe gas charged is purely proportional to byte size (1M × event_size × 89)
4. Monitor storage layer showing 3-4M database writes
5. Compare to equivalent state write operation showing ~1000× higher gas charge

The discrepancy confirms events are undercharged relative to their actual per-item storage and indexing costs.

## Notes

This issue represents a fundamental design gap in the gas model rather than a coding error. The lack of per-event overhead charging creates economic misalignment between gas costs and actual resource consumption. While the per-transaction limits prevent catastrophic abuse, sustained exploitation across many transactions could degrade storage and indexer performance over time.

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L296-301)
```rust
    pub fn io_gas_per_event(
        &self,
        event: &ContractEvent,
    ) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
        STORAGE_IO_PER_EVENT_BYTE_WRITE * NumBytes::new(event.size() as u64)
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L108-126)
```rust
            storage_io_per_state_slot_write: InternalGasPerArg,
            { 0..=9 => "write_data.per_op", 10.. => "storage_io_per_state_slot_write"},
            // The cost of writing down the upper level new JMT nodes are shared between transactions
            // because we write down the JMT in batches, however the bottom levels will be specific
            // to each transactions assuming they don't touch exactly the same leaves. It's fair to
            // target roughly 1-2 full internal JMT nodes (about 0.5-1KB in total) worth of writes
            // for each write op.
            89_568,
        ],
        [
            legacy_write_data_per_new_item: InternalGasPerArg,
            {0..=9 => "write_data.new_item"},
            1_280_000,
        ],
        [
            storage_io_per_state_byte_write: InternalGasPerByte,
            { 0..=9 => "write_data.per_byte_in_key", 10.. => "storage_io_per_state_byte_write"},
            89,
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L133-136)
```rust
            storage_io_per_event_byte_write: InternalGasPerByte,
            { RELEASE_V1_11.. => "storage_io_per_event_byte_write" },
            89,
        ],
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1121-1123)
```rust
        for event in change_set.events_iter() {
            gas_meter.charge_io_gas_for_event(event)?;
        }
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L153-170)
```rust
        events
            .iter()
            .enumerate()
            .try_for_each::<_, Result<_>>(|(idx, event)| {
                if let ContractEvent::V1(v1) = event {
                    if !skip_index {
                        batch.put::<EventByKeySchema>(
                            &(*v1.key(), v1.sequence_number()),
                            &(version, idx as u64),
                        )?;
                        batch.put::<EventByVersionSchema>(
                            &(*v1.key(), version, v1.sequence_number()),
                            &(idx as u64),
                        )?;
                    }
                }
                batch.put::<EventSchema>(&(version, idx as u64), event)
            })?;
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L172-185)
```rust
        if !skip_index {
            // EventAccumulatorSchema updates
            let event_hashes: Vec<HashValue> = events.iter().map(ContractEvent::hash).collect();
            let (_root_hash, writes) =
                MerkleAccumulator::<EmptyReader, EventAccumulatorHasher>::append(
                    &EmptyReader,
                    0,
                    &event_hashes,
                )?;

            writes.into_iter().try_for_each(|(pos, hash)| {
                batch.put::<EventAccumulatorSchema>(&(version, pos), &hash)
            })?;
        }
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L115-125)
```rust
        let mut total_event_size = 0;
        for event in change_set.events_iter() {
            let size = event.event_data().len() as u64;
            if size > self.max_bytes_per_event {
                return storage_write_limit_reached(None);
            }
            total_event_size += size;
            if total_event_size > self.max_bytes_all_events_per_transaction {
                return storage_write_limit_reached(None);
            }
        }
```
