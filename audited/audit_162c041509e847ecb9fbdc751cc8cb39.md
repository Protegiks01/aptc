# Audit Report

## Title
Silent Loss of Critical Security Forensics During Serialization Failures

## Summary
The Aptos logger silently drops security event data fields when serde serialization fails, emitting incomplete security logs with only a stderr message that may go unnoticed during active attacks. This allows attackers to evade forensic analysis by crafting consensus/network messages that trigger serialization failures in attached data fields.

## Finding Description
The security logging infrastructure contains a critical flaw in how it handles serialization failures for structured log data. When logging security events (e.g., `SecurityEvent::ConsensusEquivocatingVote`, `SecurityEvent::InvalidSyncInfoMsg`), validators attach critical forensic data such as vote details, sync information, peer identifiers, and error contexts. [1](#0-0) 

When `serde_json::to_value()` fails for any attached data field, the `JsonVisitor::visit_pair` method prints an error to stderr and returns early without inserting the key-value pair into the log entry's data map. The log entry is still created and sent to log outputs, but critical forensic fields are missing.

Example attack scenario:
1. Attacker sends a malformed consensus vote or sync message to a validator
2. Validator detects the malicious behavior and attempts to log it: [2](#0-1) 

3. The `SecurityEvent::ConsensusEquivocatingVote` marker serializes successfully (simple enum)
4. However, the attached `vote` or `previous_vote` data structures fail to serialize due to:
   - Deeply nested structures hitting serde recursion limits
   - Custom types with incomplete Serialize implementations
   - Binary data that wasn't properly hex-encoded
   - Circular references or other edge cases

5. The logger silently drops the `vote` and `previous_vote` fields with only an eprintln
6. The emitted log contains only:
   ```json
   {
     "level": "ERROR",
     "data": {
       "security-event": "consensus_equivocating_vote",
       "remote_peer": "..."  // If this also fails to serialize, it's also dropped
     }
   }
   ```
7. Operators cannot identify which vote was equivocal or investigate the attack
8. Attacker's malicious behavior is documented but not forensically useful

The same vulnerability affects all security event types across the codebase: [3](#0-2) [4](#0-3) 

## Impact Explanation
This qualifies as **High Severity** under the Aptos bug bounty category of "Significant protocol violations" because:

1. **Byzantine Fault Tolerance Dependency**: AptosBFT relies on detecting and responding to malicious validator behavior. Loss of forensic data during attacks fundamentally undermines the protocol's security monitoring capabilities.

2. **Attack Amplification**: Attackers can intentionally craft payloads to trigger serialization failures, effectively evading security logging while probing consensus vulnerabilities or conducting reconnaissance.

3. **Incident Response Blindness**: During active attacks, operators lose the ability to:
   - Identify which validators are Byzantine (peer identifiers may be dropped)
   - Understand attack methodology (vote/block/sync data dropped)
   - Implement targeted mitigations (firewall rules, validator set exclusions)
   - Provide evidence for governance proposals to slash malicious validators

4. **Silent Failure**: While errors are printed to stderr, this is inadequate for production monitoring:
   - stderr may not be centrally logged or monitored
   - During attack floods, stderr messages are easily missed
   - No metrics/alerts are triggered for dropped security data
   - The structured log appears valid but is incomplete

5. **Cascading Security Impact**: Inability to investigate security events could enable attackers to:
   - Test various attack vectors without leaving forensic trails
   - Escalate from reconnaissance to exploitation undetected
   - Coordinate multi-validator attacks without identification

## Likelihood Explanation
**Moderate to High Likelihood**:

1. **Attacker Control**: Malicious actors can craft network messages, consensus votes, and blocks with structures specifically designed to trigger serialization edge cases.

2. **Complex Data Structures**: Aptos consensus messages involve deeply nested structures (blocks, votes, quorum certificates, sync info) that are serialization-intensive. Edge cases include:
   - Vote data with unusual validator signatures
   - Sync info with complex nested quorum certificates  
   - Block payloads with malformed transaction data
   - Error types with non-serializable internal state

3. **Production Occurrence**: Even without malicious intent, legitimate bugs or edge cases in consensus implementation could produce data that fails to serialize, leading to silent forensic data loss during critical security events.

4. **No Circuit Breaker**: There's no fallback mechanism - if serialization fails, the data is simply lost. There's no retry with simplified serialization, no fallback to Debug formatting, and no critical alert.

## Recommendation

Implement robust error handling for security event serialization with multiple defensive layers:

```rust
impl Visitor for JsonVisitor<'_> {
    fn visit_pair(&mut self, key: Key, value: Value<'_>) {
        let v = match value {
            Value::Debug(d) => serde_json::Value::String(
                TruncatedLogString::from(format!("{:?}", d)).into(),
            ),
            Value::Display(d) => {
                serde_json::Value::String(TruncatedLogString::from(d.to_string()).into())
            },
            Value::Serde(s) => match serde_json::to_value(s) {
                Ok(value) => value,
                Err(e) => {
                    // CRITICAL: For security events, don't silently drop data
                    // Attempt fallback serialization strategies
                    let fallback_msg = format!("SERIALIZATION_FAILED: {} - attempted Debug fallback", e);
                    
                    // Increment critical metric
                    STRUCT_LOG_PARSE_ERROR_COUNT.inc();
                    
                    // Try to preserve some information via Debug formatting
                    let debug_repr = format!("{:?}", s);
                    serde_json::Value::String(
                        TruncatedLogString::from(format!("{} | Debug: {}", fallback_msg, debug_repr)).into()
                    )
                },
            },
        };

        self.0.insert(key, v);
    }
}
```

Additional recommendations:
1. **Never skip field insertion** - always insert a value, even if it's an error message
2. **Add metrics** - `STRUCT_LOG_PARSE_ERROR_COUNT` should trigger alerts for security events
3. **Structured error values** - Use JSON objects like `{"error": "serialization_failed", "reason": "...", "debug": "..."}` instead of silently dropping
4. **Security event validation** - Add CI tests that verify all SecurityEvent usages in the codebase include only types that are guaranteed to serialize
5. **Runtime monitoring** - Alert on any serialization failures for logs containing security-event keys

## Proof of Concept

```rust
// Add to crates/aptos-logger/tests/security_event_serialization.rs
#[cfg(test)]
mod security_event_serialization_tests {
    use aptos_logger::{error, SecurityEvent, AptosData};
    use serde::Serialize;
    use std::sync::{Arc, Mutex};
    
    // Type that deliberately fails to serialize
    struct FailingSerialize;
    
    impl Serialize for FailingSerialize {
        fn serialize<S>(&self, _serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            Err(serde::ser::Error::custom("Deliberate serialization failure"))
        }
    }
    
    #[test]
    fn test_security_event_with_failing_serialization() {
        // Setup logger with custom writer to capture output
        let logs = Arc::new(Mutex::new(Vec::new()));
        let logs_clone = logs.clone();
        
        struct TestWriter(Arc<Mutex<Vec<String>>>);
        impl aptos_logger::Writer for TestWriter {
            fn write(&self, log: String) {
                self.0.lock().unwrap().push(log);
            }
            fn write_buferred(&mut self, log: String) {
                self.write(log);
            }
        }
        
        AptosData::builder()
            .is_async(false)
            .printer(Box::new(TestWriter(logs_clone)))
            .build();
        
        // Log a security event with data that will fail to serialize
        let failing_data = FailingSerialize;
        error!(
            SecurityEvent::ConsensusEquivocatingVote,
            remote_peer = "attacker_validator",
            vote = failing_data,  // This will fail to serialize
            "Detected equivocating vote"
        );
        
        // Verify the log was emitted
        let captured_logs = logs.lock().unwrap();
        assert_eq!(captured_logs.len(), 1);
        let log_entry = &captured_logs[0];
        
        // Parse the JSON log
        let parsed: serde_json::Value = serde_json::from_str(log_entry).unwrap();
        
        // VULNERABILITY: The security-event is present but critical 'vote' data is missing
        assert!(parsed["data"]["security-event"].as_str().is_some());
        assert_eq!(
            parsed["data"]["security-event"],
            "consensus_equivocating_vote"
        );
        
        // CRITICAL ISSUE: The 'vote' key is completely missing from the log
        // Operators cannot investigate the attack without the vote data
        assert!(parsed["data"]["vote"].is_null());
        
        // Only remote_peer was preserved (if it serialized successfully)
        assert_eq!(parsed["data"]["remote_peer"], "attacker_validator");
        
        println!("VULNERABILITY CONFIRMED: Security event logged but critical forensic data silently dropped");
        println!("Log entry: {}", log_entry);
    }
}
```

## Notes

While the `SecurityEvent` enum itself (being a simple string-serializing enum) will almost always serialize successfully, the **critical attached forensic data** is vulnerable to silent loss. This is especially concerning for:

- Complex consensus data structures (votes, blocks, sync info)
- Network messages with binary payloads
- Error types with non-serializable internal state
- Custom types with incomplete `Serialize` implementations

The current implementation provides a false sense of security - operators see security event logs and believe they have complete forensic data, when in reality critical investigation fields may have been silently dropped with only an easily-missed stderr message.

### Citations

**File:** crates/aptos-logger/src/aptos_logger.rs (L167-188)
```rust
        impl Visitor for JsonVisitor<'_> {
            fn visit_pair(&mut self, key: Key, value: Value<'_>) {
                let v = match value {
                    Value::Debug(d) => serde_json::Value::String(
                        TruncatedLogString::from(format!("{:?}", d)).into(),
                    ),
                    Value::Display(d) => {
                        serde_json::Value::String(TruncatedLogString::from(d.to_string()).into())
                    },
                    Value::Serde(s) => match serde_json::to_value(s) {
                        Ok(value) => value,
                        Err(e) => {
                            // Log and skip the value that can't be serialized
                            eprintln!("error serializing structured log: {} for key {:?}", e, key);
                            return;
                        },
                    },
                };

                self.0.insert(key, v);
            }
        }
```

**File:** consensus/src/pending_votes.rs (L300-305)
```rust
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );
```

**File:** consensus/src/round_manager.rs (L889-894)
```rust
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
```

**File:** mempool/src/shared_mempool/tasks.rs (L599-604)
```rust
            trace!(
                SecurityEvent::InvalidTransactionMempool,
                failed_transaction = txn,
                vm_status = vm_status,
                sender = sender,
            );
```
