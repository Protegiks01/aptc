# Audit Report

## Title
Missing Gas Parameter Value Validation Allows Malicious Validators to Set Exploitable Gas Schedules

## Summary
The gas schedule update mechanism in `gas_schedule.move` lacks validation of gas parameter values, allowing malicious validators to propose and execute governance changes that set exploitable gas parameters (zero costs, u64::MAX limits). The system explicitly has TODO comments acknowledging this missing validation, and the code is designed to accept zero-valued gas parameters intended only for testing environments.

## Finding Description

The Aptos governance system allows validators with sufficient stake to propose changes to the on-chain gas schedule through the `gas_schedule::set_for_next_epoch()` function. However, this function and related validation logic contain critical security gaps:

**Missing Validation in gas_schedule.move:** [1](#0-0) [2](#0-1) [3](#0-2) 

The only validations performed are:
1. Empty blob check
2. Feature version monotonicity check  
3. System address authorization [4](#0-3) 

**No Value Validation in Rust Gas Parameter Loading:** [5](#0-4) 

The macro only checks parameter existence, not value validity. It directly converts any u64 value without bounds checking.

**System Designed to Accept Zero Gas Parameters:** [6](#0-5) [7](#0-6) 

The `zeros()` and `unlimited()` functions show the system accepts zero-valued gas parameters, though intended for testing.

**Division-by-Zero Protection Confirms Zero Acceptance:** [8](#0-7) 

This code explicitly handles zero gas parameters to prevent crashes, confirming they're accepted by the system.

**Attack Path:**

1. Malicious validator with `required_proposer_stake` creates governance proposal
2. Proposal execution script contains malicious gas schedule with:
   - Zero instruction costs (free computation)
   - Zero storage costs (free state writes)
   - u64::MAX for `maximum_number_of_gas_units` (unlimited gas)
   - Zero for `min_price_per_gas_unit` (free transactions) [9](#0-8) 

3. Proposal passes through voting (>50% or after `voting_duration_secs`) [10](#0-9) 

4. Resolution transaction executes, calling `set_for_next_epoch()` then `reconfigure()` [11](#0-10) 

5. If DKG disabled, `finish()` immediately applies gas changes in same transaction: [12](#0-11) 

6. New epoch begins with malicious gas parameters active
7. Attacker exploits in subsequent blocks/transactions

**Broken Invariants:**
- **Move VM Safety**: Gas limits no longer enforced with zero costs
- **Resource Limits**: Unlimited operations with u64::MAX limits
- **Deterministic Execution**: Different gas schedules could cause consensus splits if not synchronized

## Impact Explanation

**Critical Severity** - This vulnerability enables multiple critical attack vectors:

1. **Resource Exhaustion**: Zero gas costs allow unlimited computation and storage writes, enabling network DoS through resource exhaustion

2. **Economic Attack**: Zero `min_price_per_gas_unit` allows spam transactions with no economic cost, breaking the fee market

3. **Consensus Safety Risk**: If validators load different gas schedules (timing issues, DKG delays), they may disagree on transaction execution results, violating deterministic execution

4. **Gas Metering Bypass**: Core security invariant requiring gas limits is completely bypassed with zero costs

5. **Storage Bombing**: With zero storage costs, attackers can fill state storage at no cost, requiring expensive state pruning or hardfork

The validation at transaction submission time becomes meaningless when the bounds themselves can be set to exploitable values: [13](#0-12) 

If `maximum_number_of_gas_units` is set to u64::MAX via governance, this check becomes useless.

## Likelihood Explanation

**Likelihood: Medium-High**

**Requirements:**
- Validator with `required_proposer_stake` (significant but achievable)
- >50% voting power OR waiting for `voting_duration_secs` (typically days)
- Validator access to propose blocks for exploitation

**Mitigating Factors:**
- Requires governance proposal visibility (on-chain, observable)
- Time window between proposal and execution allows detection
- If DKG enabled, longer delay before application
- Honest validators can counter-propose or emergency response

**Aggravating Factors:**
- TODO comments indicate known missing validation
- System explicitly designed to accept zero values (testing mode)
- No emergency stop mechanism for malicious gas schedules
- Once applied, immediate exploitation possible in next block

## Recommendation

Implement comprehensive gas parameter validation in `gas_schedule.move`:

```move
// In gas_schedule.move, add validation function:
fun validate_gas_schedule_params(gas_schedule: &GasScheduleV2): bool {
    // Validate against reasonable bounds
    let entries = &gas_schedule.entries;
    let i = 0;
    while (i < vector::length(entries)) {
        let entry = vector::borrow(entries, i);
        
        // Reject zero values for critical parameters
        if (contains_substring(&entry.key, b"gas_unit") || 
            contains_substring(&entry.key, b"min_transaction") ||
            contains_substring(&entry.key, b"price_per_gas")) {
            assert!(entry.val > 0, error::invalid_argument(EINVALID_GAS_VALUE));
        };
        
        // Reject suspiciously high values (>10^15 as reasonable bound)
        assert!(entry.val < 1000000000000000, error::invalid_argument(EINVALID_GAS_VALUE));
        
        // Specific parameter bounds
        if (entry.key == b"txn.maximum_number_of_gas_units") {
            assert!(entry.val <= 20000000, error::invalid_argument(EINVALID_GAS_VALUE));
        };
        
        if (entry.key == b"txn.min_price_per_gas_unit") {
            assert!(entry.val >= 1, error::invalid_argument(EINVALID_GAS_VALUE));
        };
        
        i = i + 1;
    };
    true
}

// Add validation call in set_for_next_epoch (line 94):
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD THIS LINE:
    assert!(validate_gas_schedule_params(&new_gas_schedule), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

Additionally:
1. Implement rate limiting on gas schedule changes (max 1 per epoch)
2. Add governance proposal type tagging for critical parameter changes
3. Require super-majority (>66%) for gas parameter changes
4. Implement emergency governance override mechanism

## Proof of Concept

```move
#[test_only]
module aptos_framework::test_malicious_gas_schedule {
    use aptos_framework::aptos_governance;
    use aptos_framework::gas_schedule;
    use std::vector;
    use aptos_framework::account;
    
    #[test(aptos_framework = @aptos_framework, validator = @0x123)]
    fun test_zero_gas_schedule_attack(aptos_framework: signer, validator: signer) {
        // Setup: Initialize governance and stake
        // (assume setup functions exist for test environment)
        
        // Create malicious gas schedule with zero costs
        let malicious_entries = vector::empty();
        
        // Zero instruction costs - free computation
        vector::push_back(&mut malicious_entries, create_gas_entry(b"instr.nop", 0));
        vector::push_back(&mut malicious_entries, create_gas_entry(b"instr.ld_u64", 0));
        
        // Zero transaction costs - free transactions  
        vector::push_back(&mut malicious_entries, create_gas_entry(b"txn.min_transaction_gas_units", 0));
        vector::push_back(&mut malicious_entries, create_gas_entry(b"txn.min_price_per_gas_unit", 0));
        
        // Unlimited gas - no limits
        vector::push_back(&mut malicious_entries, create_gas_entry(b"txn.maximum_number_of_gas_units", 18446744073709551615)); // u64::MAX
        
        let malicious_schedule = GasScheduleV2 {
            feature_version: 1,
            entries: malicious_entries
        };
        
        let schedule_bytes = bcs::to_bytes(&malicious_schedule);
        
        // Malicious validator creates proposal
        let execution_hash = hash_script(b"set_malicious_gas_schedule");
        aptos_governance::create_proposal(
            &validator,
            signer::address_of(&validator),
            execution_hash,
            b"",
            b""
        );
        
        // Votes pass (assume sufficient voting power)
        aptos_governance::vote(&validator, signer::address_of(&validator), 0, true);
        
        // Fast forward time
        timestamp::update_global_time_for_test(timestamp::now_seconds() + 100000);
        
        // Resolve and execute - THIS SHOULD FAIL but currently succeeds!
        let framework_signer = aptos_governance::resolve(0, @aptos_framework);
        
        // This call has NO validation on parameter values!
        gas_schedule::set_for_next_epoch(&framework_signer, schedule_bytes);
        aptos_governance::reconfigure(&framework_signer);
        
        // At this point, zero gas costs are now active
        // Attacker can now submit unlimited transactions for free
    }
}
```

The PoC demonstrates that malicious gas schedules can be set through governance without any value validation, violating critical resource limit invariants.

## Notes

This vulnerability exists because the system was designed with `zeros()` and `unlimited()` modes for testing/development, but lacks production safeguards preventing their activation through governance. The explicit TODO comments in the codebase acknowledge this missing validation, making this a known design gap rather than an oversight. However, the security implications make this a critical vulnerability requiring immediate remediation.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-67)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L75-75)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L38-42)
```rust
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*
```

**File:** aptos-move/aptos-vm-types/src/storage/mod.rs (L42-50)
```rust
    pub fn unlimited() -> Self {
        Self::new_impl(
            LATEST_GAS_FEATURE_VERSION,
            &Features::default(),
            &AptosGasParameters::zeros(), // free of charge
            &DummyConfigStorage,
            ChangeSetConfigs::unlimited_at_gas_feature_version(LATEST_GAS_FEATURE_VERSION), // no limits
        )
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/mod.rs (L68-74)
```rust
    pub fn zeros() -> Self {
        Self {
            vm: VMGasParameters::zeros(),
            natives: NativeGasParameters::zeros(),
        }
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L53-71)
```rust
        // MAXIMUM_NUMBER_OF_GAS_UNITS * MAX_PRICE_PER_GAS_UNIT < min(u64::MAX, GasUnits<GasCarrier>::MAX)
        [
            maximum_number_of_gas_units: Gas,
            "maximum_number_of_gas_units",
            aptos_global_constants::MAX_GAS_AMOUNT
        ],
        // The minimum gas price that a transaction can be submitted with.
        // TODO(Gas): should probably change this to something > 0
        [
            min_price_per_gas_unit: FeePerGasUnit,
            "min_price_per_gas_unit",
            aptos_global_constants::GAS_UNIT_PRICE
        ],
        // The maximum gas unit price that a transaction can be submitted with.
        [
            max_price_per_gas_unit: FeePerGasUnit,
            "max_price_per_gas_unit",
            10_000_000_000
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L291-298)
```rust
    // TODO(Gas): Right now we are relying on this to avoid div by zero errors when using the all-zero
    //            gas parameters. See if there's a better way we can handle this.
    pub fn scaling_factor(&self) -> GasScalingFactor {
        match u64::from(self.gas_unit_scaling_factor) {
            0 => 1.into(),
            x => x.into(),
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L439-449)
```text
        // We want to allow early resolution of proposals if more than 50% of the total supply of the network coins
        // has voted. This doesn't take into subsequent inflation/deflation (rewards are issued every epoch and gas fees
        // are burnt after every transaction), but inflation/delation is very unlikely to have a major impact on total
        // supply during the voting period.
        let total_voting_token_supply = coin::supply<AptosCoin>();
        let early_resolution_vote_threshold = option::none<u128>();
        if (option::is_some(&total_voting_token_supply)) {
            let total_supply = *option::borrow(&total_voting_token_supply);
            // 50% + 1 to avoid rounding errors.
            early_resolution_vote_threshold = option::some(total_supply / 2 + 1);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L126-138)
```rust
    if txn_metadata.max_gas_amount() > txn_gas_params.maximum_number_of_gas_units {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.maximum_number_of_gas_units,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND,
            None,
        ));
```
