# Audit Report

## Title
Message Amplification DoS via Misdirected SignedBatchInfo in Quorum Store

## Summary
Byzantine validators can send `SignedBatchInfo` messages for their own batches to all validators (instead of just themselves as batch authors), causing every receiving validator to perform expensive BLS signature verification before detecting the message is misdirected. This creates an O(N) amplification attack where a single small message triggers disproportionate cryptographic work across the network.

## Finding Description

The Aptos consensus quorum store uses `SignedBatchInfo` messages to collect validator signatures on batches for proof aggregation. The intended flow is:

1. Validator A creates and broadcasts batch B
2. Other validators (B, C, D) receive B, persist it, and sign it
3. Each validator sends their `SignedBatchInfo` **only to Validator A** (the batch author)
4. Validator A aggregates signatures into a `ProofOfStore`

However, the signature verification occurs **before** checking if the receiving validator is the batch author: [1](#0-0) 

The expensive cryptographic signature verification happens in `SignedBatchInfo::verify()`: [2](#0-1) 

Only **after** this expensive verification does the `ProofCoordinator` check if the batch belongs to this validator: [3](#0-2) 

**Attack Path:**

1. Byzantine validator V_byz creates batch B (author = V_byz)
2. V_byz signs the batch creating `SignedBatchInfo(B, sig_V_byz)`
3. **V_byz maliciously sends `SignedBatchInfo` to ALL N validators** (not just to itself)
4. Each honest validator V_honest receives the message and:
   - Performs expensive BLS signature verification via `validator.optimistic_verify()` 
   - Forwards to `ProofCoordinator`
   - `ProofCoordinator.init_proof()` checks: `B.author == V_honest.peer_id`
   - Since `V_byz != V_honest`, rejects with `WrongAuthor`
5. The expensive cryptographic work is wasted

**Amplification:**
- Cost to attacker: Create batch + 1 signature + N network messages (~200 bytes each)
- Cost to network: N validators × expensive BLS verification (milliseconds of CPU each)
- With `max_num_batches = 20`, a single message triggers 20 verifications per validator
- Total amplification: ~20N expensive operations for one small message

The legitimate sending behavior shows `SignedBatchInfo` should only go to the batch author: [4](#0-3) 

But there's no enforcement preventing Byzantine validators from misdirecting these messages.

## Impact Explanation

This is a **Medium Severity** DoS vulnerability per the Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: Byzantine validators can continuously send misdirected `SignedBatchInfo` messages to saturate honest validators' CPU with signature verification tasks, slowing down consensus participation.

2. **Consensus Liveness Impact**: The bounded executor limits concurrent verifications to 16 tasks: [5](#0-4) 

An attacker sending messages at a steady rate can keep all verification slots occupied with useless work, delaying legitimate message processing and proof aggregation.

3. **Resource Exhaustion**: While the quorum store channel has per-sender limits of 50 messages: [6](#0-5) 

These limits apply **after** verification, providing no protection against the expensive pre-verification work.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Easy to Execute**: Any Byzantine validator can send network messages to any peer. No special privileges or coordination required.

2. **Low Attack Cost**: Creating batches and broadcasting signatures requires minimal resources compared to the verification cost imposed on victims.

3. **Scalable**: Attacker can create multiple batches per second, each triggering N×20 expensive verifications across the network.

4. **No Rate Limiting**: There's no per-sender rate limiting on `SignedBatchInfo` messages before verification, and the existing `max_num_batches` check only limits batches per message, not message frequency.

## Recommendation

**Add early filtering before signature verification to reject misdirected `SignedBatchInfo` messages:**

In `UnverifiedEvent::verify()`, before calling `sd.verify()`, check if the batch author matches the local peer ID by examining the `SignedBatchInfo` metadata (which is not cryptographically protected but can be validated early). Alternatively, modify the message structure to include intended recipient information.

**Recommended fix in `consensus/src/round_manager.rs`:**

```rust
UnverifiedEvent::SignedBatchInfoMsgV2(sd) => {
    if !self_message {
        // Early rejection: check if any batch in the message is authored by us
        // before expensive signature verification
        let should_process = sd.signed_infos.iter().any(|info| {
            info.batch_info().author() == my_peer_id
        });
        
        if !should_process {
            // Reject early without signature verification
            return Err(VerifyError::InvalidRequest(
                "SignedBatchInfo for batch not authored by this validator"
            ));
        }
        
        sd.verify(
            peer_id,
            max_num_batches,
            max_batch_expiry_gap_usecs,
            validator,
        )?;
        counters::VERIFY_MSG
            .with_label_values(&["signed_batch_v2"])
            .observe(start_time.elapsed().as_secs_f64());
    }
    VerifiedEvent::SignedBatchInfo(sd)
},
```

This ensures expensive BLS signature verification only occurs for batches that could legitimately be aggregated by this validator.

## Proof of Concept

```rust
// Rust integration test demonstrating the vulnerability
#[tokio::test]
async fn test_signed_batch_info_amplification_dos() {
    // Setup: Create network with 10 validators
    let num_validators = 10;
    let (validators, mut network) = create_test_network(num_validators).await;
    
    // Byzantine validator (index 0) creates a batch
    let byzantine_validator = &validators[0];
    let batch = byzantine_validator.create_batch(vec![/* transactions */]).await;
    
    // Byzantine validator signs the batch
    let signed_batch_info = byzantine_validator.sign_batch(&batch);
    
    // Normal flow: should only send to self
    // Byzantine flow: send to ALL validators
    let mut verification_count = Arc::new(AtomicUsize::new(0));
    
    for i in 1..num_validators {
        let honest_validator = &validators[i];
        let count = verification_count.clone();
        
        // Simulate receiving SignedBatchInfo from Byzantine validator
        tokio::spawn(async move {
            // This will trigger signature verification
            let result = honest_validator
                .process_signed_batch_info(signed_batch_info.clone())
                .await;
            
            count.fetch_add(1, Ordering::SeqCst);
            
            // Should fail with WrongAuthor, but only after expensive verification
            assert!(matches!(result, Err(SignedBatchInfoError::WrongAuthor)));
        });
    }
    
    // Wait for all verifications to complete
    tokio::time::sleep(Duration::from_secs(5)).await;
    
    // Verify that (N-1) validators performed expensive verification
    // even though all would eventually reject the message
    assert_eq!(verification_count.load(Ordering::SeqCst), num_validators - 1);
    
    // Demonstrate amplification: single message caused 9 expensive operations
    println!("Amplification factor: {}", num_validators - 1);
}
```

**Notes:**

- This vulnerability breaks the **Resource Limits** invariant: operations should respect computational limits, but Byzantine validators can force disproportionate work on honest validators.
- The attack is particularly effective because BLS signature verification is cryptographically expensive (O(milliseconds) per signature).
- Byzantine validators can automate this attack to continuously flood the network with misdirected messages, degrading consensus performance network-wide.

### Citations

**File:** consensus/src/round_manager.rs (L184-196)
```rust
            UnverifiedEvent::SignedBatchInfo(sd) => {
                if !self_message {
                    sd.verify(
                        peer_id,
                        max_num_batches,
                        max_batch_expiry_gap_usecs,
                        validator,
                    )?;
                    counters::VERIFY_MSG
                        .with_label_values(&["signed_batch"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::SignedBatchInfo(Box::new((*sd).into()))
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L459-482)
```rust
    pub fn verify(
        &self,
        sender: PeerId,
        max_batch_expiry_gap_usecs: u64,
        validator: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        if sender != self.signer {
            bail!("Sender {} mismatch signer {}", sender, self.signer);
        }

        if self.expiration()
            > aptos_infallible::duration_since_epoch().as_micros() as u64
                + max_batch_expiry_gap_usecs
        {
            bail!(
                "Batch expiration too far in future: {} > {}",
                self.expiration(),
                aptos_infallible::duration_since_epoch().as_micros() as u64
                    + max_batch_expiry_gap_usecs
            );
        }

        Ok(validator.optimistic_verify(self.signer, &self.info, &self.signature)?)
    }
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L269-283)
```rust
    fn init_proof(
        &mut self,
        signed_batch_info: &SignedBatchInfo<BatchInfoExt>,
    ) -> Result<(), SignedBatchInfoError> {
        // Check if the signed digest corresponding to our batch
        if signed_batch_info.author() != self.peer_id {
            return Err(SignedBatchInfoError::WrongAuthor);
        }
        let batch_author = self
            .batch_reader
            .exists(signed_batch_info.digest())
            .ok_or(SignedBatchInfoError::NotFound)?;
        if batch_author != signed_batch_info.author() {
            return Err(SignedBatchInfoError::WrongAuthor);
        }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L108-110)
```rust
                    network_sender
                        .send_signed_batch_info_msg_v2(signed_batch_infos, vec![peer_id])
                        .await;
```

**File:** config/src/config/consensus_config.rs (L379-379)
```rust
            num_bounded_executor_tasks: 16,
```

**File:** consensus/src/network.rs (L762-767)
```rust
        let (quorum_store_messages_tx, quorum_store_messages) = aptos_channel::new(
            QueueStyle::FIFO,
            // TODO: tune this value based on quorum store messages with backpressure
            50,
            Some(&counters::QUORUM_STORE_CHANNEL_MSGS),
        );
```
