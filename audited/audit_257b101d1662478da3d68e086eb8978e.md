# Audit Report

## Title
Consensus Observer Fails to Distinguish Byzantine Faults from Benign Faults, Allowing Malicious Peers to Operate Without Consequences

## Summary
The consensus observer's error handling system does not distinguish between Byzantine faults (malicious behavior such as forged signatures or invalid proofs) and benign faults (network issues, bugs). All invalid messages are treated identically—logged and counted—but no security actions are taken against Byzantine peers. This allows malicious peers to repeatedly send invalid consensus messages without facing subscription termination, banning, or any other consequences, violating fundamental BFT security assumptions.

## Finding Description

The error type system in the consensus observer lacks explicit Byzantine fault classification. [1](#0-0) 

When invalid messages are detected (failed signature verification, incorrect proofs, manipulated data), the system only increments a metric counter and drops the message, without taking any security action against the misbehaving peer: [2](#0-1) 

Multiple critical verification failures are handled this way throughout the codebase:

- Block payload digest verification failures: [3](#0-2) 

- Block payload signature verification failures: [4](#0-3) 

- Commit decision verification failures: [5](#0-4) 

- Ordered block verification failures: [6](#0-5) 

- Ordered proof verification failures: [7](#0-6) 

The subscription health check system only monitors peer connectivity, message timeouts, DB sync progress, and peer optimality—but completely ignores Byzantine behavior or invalid message counts: [8](#0-7) 

There is no configuration parameter for invalid message thresholds or Byzantine peer banning: [9](#0-8) 

**Attack Scenario:**

1. Attacker establishes a connection as a peer to a consensus observer node (VFN or validator)
2. Attacker successfully subscribes to consensus updates
3. Attacker sends invalid consensus messages with:
   - Forged BLS signatures on block payloads
   - Incorrect commitment proofs
   - Manipulated block data that fails digest verification
   - Invalid ordered block proofs
4. Each invalid message is validated by the victim node (consuming CPU/resources), logged, and dropped
5. The metric counter `OBSERVER_INVALID_MESSAGES` is incremented, but **no action is taken**
6. The subscription remains active as long as:
   - The attacker stays connected
   - Messages arrive within `max_subscription_timeout_ms` (15 seconds by default)
   - No better peer appears for optimality checks
7. Attacker can repeat step 3 indefinitely, wasting victim resources

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program because it constitutes a "Significant protocol violation" that can cause "Validator node slowdowns."

**Specific Impacts:**

1. **BFT Security Assumption Violation**: BFT protocols assume Byzantine behavior is detected and appropriately handled. This implementation fails to handle Byzantine faults, allowing malicious peers to operate freely.

2. **Resource Exhaustion**: Malicious peers can force victim nodes to repeatedly validate cryptographically invalid messages (signature verification, proof checking), wasting CPU cycles and memory.

3. **Network Degradation**: Multiple Byzantine peers could collectively slow down consensus observer nodes across the network, affecting consensus participation for VFNs and validators.

4. **No Deterrent Mechanism**: Without consequences for Byzantine behavior, there is no deterrent preventing attacks, and the network cannot maintain Byzantine fault tolerance guarantees.

5. **Validator Impact**: Validators running consensus observer publishers could experience performance degradation, potentially affecting their ability to participate in consensus rounds.

This does not reach **Critical** severity because:
- It does not directly cause consensus safety violations or fund loss
- It does not create a non-recoverable network partition
- The attack requires sustained peer connections and doesn't cause permanent damage

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploitable because:

1. **Low Barrier to Entry**: Any peer that can establish network connectivity to a consensus observer node can attempt this attack. No special privileges, stake, or validator status required.

2. **No Technical Complexity**: The attack simply involves sending well-formed but cryptographically invalid messages. No sophisticated exploit techniques needed.

3. **No Detection or Punishment**: The system provides no feedback mechanism that would allow operators to detect ongoing attacks or automatically defend against them.

4. **Wide Attack Surface**: All nodes running consensus observer (validators and VFNs on mainnet, as configured) are vulnerable.

5. **Asymmetric Cost**: The attacker's cost (network bandwidth to send invalid messages) is much lower than the victim's cost (cryptographic verification operations).

6. **Persistent Subscriptions**: Once a subscription is established, it persists through repeated Byzantine behavior as long as basic liveness conditions are met.

## Recommendation

Implement a comprehensive Byzantine fault detection and response system for the consensus observer:

**1. Extend the Error enum to classify Byzantine faults:**

```rust
// In consensus/src/consensus_observer/common/error.rs
#[derive(Debug, Error)]
pub enum Error {
    #[error("Byzantine message error: {0}")]
    ByzantineMessageError(String),  // NEW: Explicitly Byzantine behavior
    
    #[error("Invalid message error: {0}")]
    InvalidMessageError(String),     // Keep for ambiguous cases
    
    // ... rest of errors
}

impl Error {
    /// Returns true if this error indicates Byzantine behavior
    pub fn is_byzantine(&self) -> bool {
        matches!(self, Self::ByzantineMessageError(_))
    }
}
```

**2. Add Byzantine peer tracking to ConsensusObserverSubscription:**

```rust
// In consensus/src/consensus_observer/observer/subscription.rs
pub struct ConsensusObserverSubscription {
    // ... existing fields ...
    
    // NEW: Track Byzantine behavior
    byzantine_message_count: u64,
    last_byzantine_message_time: Option<Instant>,
}

// Add to check_subscription_health():
fn check_subscription_health(&mut self, ...) -> Result<(), Error> {
    // ... existing checks ...
    
    // NEW: Check for excessive Byzantine behavior
    self.check_byzantine_behavior()?;
    
    Ok(())
}

fn check_byzantine_behavior(&self) -> Result<(), Error> {
    let threshold = self.consensus_observer_config.max_byzantine_messages_per_subscription;
    if self.byzantine_message_count >= threshold {
        return Err(Error::SubscriptionTerminated(format!(
            "Peer {} exceeded Byzantine message threshold: {} >= {}",
            self.peer_network_id, self.byzantine_message_count, threshold
        )));
    }
    Ok(())
}
```

**3. Add configuration parameters:**

```rust
// In config/src/config/consensus_observer_config.rs
pub struct ConsensusObserverConfig {
    // ... existing fields ...
    
    /// Maximum number of Byzantine messages tolerated per subscription
    pub max_byzantine_messages_per_subscription: u64,
    /// Time window (in milliseconds) to reset Byzantine message counter
    pub byzantine_message_reset_interval_ms: u64,
}

impl Default for ConsensusObserverConfig {
    fn default() -> Self {
        Self {
            // ... existing defaults ...
            max_byzantine_messages_per_subscription: 10,  // Allow 10 Byzantine messages
            byzantine_message_reset_interval_ms: 300_000, // 5 minute reset window
        }
    }
}
```

**4. Update message verification to use ByzantineMessageError:**

When signature verification, proof verification, or digest verification fails, return `Error::ByzantineMessageError` instead of `Error::InvalidMessageError`. Track Byzantine message counts in the subscription and terminate subscriptions that exceed the threshold.

## Proof of Concept

```rust
// Proof of Concept: Malicious Consensus Observer Peer
// This demonstrates a peer that repeatedly sends invalid messages without consequences

use aptos_config::network_id::{NetworkId, PeerNetworkId};
use aptos_consensus_types::common::Author;
use aptos_crypto::{HashValue, bls12381};
use aptos_types::block_info::BlockInfo;

// Malicious peer simulation
async fn byzantine_peer_attack() {
    // Step 1: Connect to consensus observer node
    let victim_peer = PeerNetworkId::new(NetworkId::Validator, /* victim peer ID */);
    let observer_client = /* get consensus observer client */;
    
    // Step 2: Subscribe to consensus updates
    let subscription_request = ConsensusObserverRequest::Subscribe;
    observer_client.send_rpc_request_to_peer(&victim_peer, subscription_request, 5000).await.unwrap();
    
    // Step 3: Repeatedly send invalid messages
    for round in 0..1000 {
        // Create a block with forged signature
        let fake_block = create_block_with_forged_signature(round);
        let invalid_payload = BlockPayload::new(
            fake_block,
            vec![], // Empty batches
        );
        
        // Send to victim - will be validated (wasting CPU) then dropped
        let message = ConsensusObserverDirectSend::BlockPayload(invalid_payload);
        observer_client.send_direct_send(victim_peer, message).await;
        
        // Send invalid commit decision with wrong proof
        let fake_commit = create_commit_with_invalid_proof(round);
        let message = ConsensusObserverDirectSend::CommitDecision(fake_commit);
        observer_client.send_direct_send(victim_peer, message).await;
        
        tokio::time::sleep(Duration::from_millis(100)).await;
    }
    
    // Result: Subscription remains active, attacker sent 2000 invalid messages
    // Victim wasted significant resources on verification
    // No consequences for attacker
}

fn create_block_with_forged_signature(round: u64) -> Block {
    // Create block with invalid/forged BLS signature
    let fake_sig = bls12381::Signature::dummy_signature();
    // ... construct invalid block
}

fn create_commit_with_invalid_proof(round: u64) -> CommitDecision {
    // Create commit decision with incorrect proof
    // ... construct invalid commit
}
```

**Notes**

The vulnerability exists because the consensus observer treats all error types uniformly without considering the security implications of Byzantine behavior versus benign faults. While the system correctly validates messages and rejects invalid ones, it fails to implement the critical BFT security mechanism of detecting and penalizing Byzantine actors. This creates an exploitable gap where malicious peers can waste network resources and violate BFT assumptions without facing any consequences, undermining the security guarantees of the consensus observer system.

### Citations

**File:** consensus/src/consensus_observer/common/error.rs (L7-41)
```rust
#[derive(Debug, Error)]
pub enum Error {
    #[error("Invalid message error: {0}")]
    InvalidMessageError(String),

    #[error("Network error: {0}")]
    NetworkError(String),

    #[error("Consensus observer falling behind: {0}")]
    ObserverFallingBehind(String),

    #[error("Consensus observer progress stopped: {0}")]
    ObserverProgressStopped(String),

    #[error("Aptos network rpc error: {0}")]
    RpcError(#[from] RpcError),

    #[error("Subscription disconnected: {0}")]
    SubscriptionDisconnected(String),

    #[error("Subscription progress stopped: {0}")]
    SubscriptionProgressStopped(String),

    #[error("Subscriptions reset: {0}")]
    SubscriptionsReset(String),

    #[error("Subscription suboptimal: {0}")]
    SubscriptionSuboptimal(String),

    #[error("Subscription timeout: {0}")]
    SubscriptionTimeout(String),

    #[error("Unexpected error encountered: {0}")]
    UnexpectedError(String),
}
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L386-397)
```rust
        if let Err(error) = block_payload.verify_payload_digests() {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payload digests! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                    block_payload.block(), peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L403-413)
```rust
            if let Err(error) = block_payload.verify_payload_signatures(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify block payload signatures! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                        block_payload.block(), peer_network_id, error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L470-482)
```rust
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L659-671)
```rust
        if let Err(error) = ordered_block.verify_ordered_blocks() {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify ordered blocks! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L730-742)
```rust
            if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify ordered proof! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        ordered_block.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1355-1362)
```rust
/// Increments the invalid message counter for the given peer and message
fn increment_invalid_message_counter(peer_network_id: &PeerNetworkId, message_label: &str) {
    metrics::increment_counter(
        &metrics::OBSERVER_INVALID_MESSAGES,
        message_label,
        peer_network_id,
    );
}
```

**File:** consensus/src/consensus_observer/observer/subscription.rs (L63-91)
```rust
    pub fn check_subscription_health(
        &mut self,
        connected_peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
        skip_peer_optimality_check: bool,
    ) -> Result<(), Error> {
        // Verify the subscription peer is still connected
        let peer_network_id = self.get_peer_network_id();
        if !connected_peers_and_metadata.contains_key(&peer_network_id) {
            return Err(Error::SubscriptionDisconnected(format!(
                "The peer: {:?} is no longer connected!",
                peer_network_id
            )));
        }

        // Verify the subscription has not timed out
        self.check_subscription_timeout()?;

        // Verify that the DB is continuing to sync and commit new data
        self.check_syncing_progress()?;

        // Verify that the subscription peer is still optimal
        self.check_subscription_peer_optimality(
            connected_peers_and_metadata,
            skip_peer_optimality_check,
        )?;

        // The subscription seems healthy
        Ok(())
    }
```

**File:** config/src/config/consensus_observer_config.rs (L19-61)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct ConsensusObserverConfig {
    /// Whether the consensus observer is enabled
    pub observer_enabled: bool,
    /// Whether the consensus publisher is enabled
    pub publisher_enabled: bool,

    /// Maximum number of pending network messages
    pub max_network_channel_size: u64,
    /// Maximum number of parallel serialization tasks for message sends
    pub max_parallel_serialization_tasks: usize,
    /// Timeout (in milliseconds) for network RPC requests
    pub network_request_timeout_ms: u64,

    /// Interval (in milliseconds) to garbage collect peer state
    pub garbage_collection_interval_ms: u64,
    /// Maximum number of blocks to keep in memory (e.g., pending blocks, ordered blocks, etc.)
    pub max_num_pending_blocks: u64,
    /// Interval (in milliseconds) to check progress of the consensus observer
    pub progress_check_interval_ms: u64,

    /// The maximum number of concurrent subscriptions
    pub max_concurrent_subscriptions: u64,
    /// Maximum timeout (in milliseconds) we'll wait for the synced version to
    /// increase before terminating the active subscription.
    pub max_subscription_sync_timeout_ms: u64,
    /// Maximum message timeout (in milliseconds) for active subscriptions
    pub max_subscription_timeout_ms: u64,
    /// Interval (in milliseconds) to check for subscription related peer changes
    pub subscription_peer_change_interval_ms: u64,
    /// Interval (in milliseconds) to refresh the subscription
    pub subscription_refresh_interval_ms: u64,

    /// Duration (in milliseconds) to require state sync to synchronize when in fallback mode
    pub observer_fallback_duration_ms: u64,
    /// Duration (in milliseconds) we'll wait on startup before considering fallback mode
    pub observer_fallback_startup_period_ms: u64,
    /// Duration (in milliseconds) we'll wait for syncing progress before entering fallback mode
    pub observer_fallback_progress_threshold_ms: u64,
    /// Duration (in milliseconds) of acceptable sync lag before entering fallback mode
    pub observer_fallback_sync_lag_threshold_ms: u64,
}
```
