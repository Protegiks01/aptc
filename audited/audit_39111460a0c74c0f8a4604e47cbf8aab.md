# Audit Report

## Title
Integer Overflow in DAG Memory Pruning Causes Unbounded Memory Growth and Network-Wide OOM

## Summary
Setting `dag_ordering_causal_history_window` to `usize::MAX` via on-chain governance causes integer overflow in the DAG store's pruning calculation, preventing garbage collection and leading to unbounded memory growth. This results in all validators running out of memory and complete network liveness loss.

## Finding Description

The `dag_ordering_causal_history_window` configuration parameter controls the memory window size for DAG consensus history. This parameter can be set via on-chain governance with no validation beyond checking that the config bytes are non-empty. [1](#0-0) 

When this value is set to `usize::MAX`, it causes a critical integer overflow in the memory pruning logic. The `InMemDag::commit_callback` function calculates the start round for pruning using: [2](#0-1) 

With `window_size = u64::MAX`, the multiplication `3 * self.window_size` uses default Rust wrapping arithmetic. The calculation `3 * u64::MAX` wraps around to `u64::MAX - 2` (18,446,744,073,709,551,613). 

For any realistic commit round (less than 10^19), `commit_round.saturating_sub(u64::MAX - 2)` saturates to 0, making `new_start_round = 0`. After the initial rounds when `start_round` advances beyond 0, the pruning condition `new_start_round > self.start_round` becomes permanently false, disabling all future pruning.

The DAG store maintains nodes in memory indexed by round in a `BTreeMap<Round, Vec<Option<NodeStatus>>>`. [3](#0-2) 

Without pruning, every new round adds N nodes (where N = number of validators) to the map permanently. With typical consensus progressing at ~1 round/second and 100 validators, memory grows at ~100 nodes/second indefinitely until the process crashes from out-of-memory (OOM).

The configuration is passed through the bootstrap process without validation: [4](#0-3) 

## Impact Explanation

This vulnerability meets **Critical Severity** criteria:

**Total loss of liveness/network availability**: All validators running DAG consensus will experience unbounded memory growth. Within hours to days (depending on available memory), validators will exhaust system memory and crash due to OOM errors. As validators crash, the network loses quorum and consensus halts completely. This requires emergency intervention and potentially a hard fork to recover.

**Non-recoverable without intervention**: The malicious configuration persists in on-chain state across restarts. Validators cannot recover by simply restartingâ€”they will immediately begin accumulating memory again. Only a coordinated governance action to reset the configuration or a hard fork can restore the network.

**Affects entire validator set**: Unlike attacks targeting individual nodes, this affects all validators uniformly, making the network-wide impact deterministic and catastrophic.

## Likelihood Explanation

**Likelihood: Medium to High**

**Attack Requirements:**
- Governance control to pass a consensus config update proposal
- Knowledge to craft a malicious `DagConsensusConfigV1` with `dag_ordering_causal_history_window = usize::MAX`

**Feasibility:**
- While governance is generally trusted, configuration errors are possible
- No validation exists to prevent extreme values
- The value `usize::MAX` could be accidentally set during testing or misconfiguration
- A malicious actor with sufficient governance voting power could deliberately exploit this

**Historical Context:**
- Configuration-based vulnerabilities have occurred in blockchain systems when validation is insufficient
- The lack of bounds checking on a critical memory management parameter is a significant oversight

## Recommendation

Implement strict validation for `dag_ordering_causal_history_window` at multiple layers:

**1. Add bounds checking in DagConsensusConfigV1 deserialization:**

```rust
impl DagConsensusConfigV1 {
    const MAX_DAG_WINDOW_SIZE: usize = 1000; // Reasonable upper bound
    const MIN_DAG_WINDOW_SIZE: usize = 1;
    
    pub fn validate(&self) -> Result<(), anyhow::Error> {
        ensure!(
            self.dag_ordering_causal_history_window >= Self::MIN_DAG_WINDOW_SIZE,
            "dag_ordering_causal_history_window must be at least {}",
            Self::MIN_DAG_WINDOW_SIZE
        );
        ensure!(
            self.dag_ordering_causal_history_window <= Self::MAX_DAG_WINDOW_SIZE,
            "dag_ordering_causal_history_window must not exceed {}",
            Self::MAX_DAG_WINDOW_SIZE
        );
        Ok(())
    }
}
```

**2. Fix the overflow-prone multiplication using saturating or checked arithmetic:**

```rust
fn commit_callback(
    &mut self,
    commit_round: Round,
) -> Option<BTreeMap<u64, Vec<Option<NodeStatus>>>> {
    let new_start_round = commit_round.saturating_sub(
        self.window_size.saturating_mul(3)
    );
    if new_start_round > self.start_round {
        self.start_round = new_start_round;
        return Some(self.prune());
    }
    None
}
```

**3. Add validation in the Move module:**

Add a native function to validate consensus config structure before accepting it via governance.

## Proof of Concept

**Rust Test Demonstrating the Vulnerability:**

```rust
#[test]
fn test_unbounded_memory_with_max_window_size() {
    use crate::dag::dag_store::InMemDag;
    use aptos_types::epoch_state::EpochState;
    use std::sync::Arc;
    
    // Setup test environment
    let epoch_state = Arc::new(create_test_epoch_state(4));
    
    // Create DAG with window_size = u64::MAX (simulating usize::MAX on 64-bit)
    let mut dag = InMemDag::new_empty(
        epoch_state.clone(),
        1, // start_round
        u64::MAX, // window_size set to maximum value
    );
    
    // Simulate adding nodes for multiple rounds
    for round in 1..=100 {
        for validator in epoch_state.verifier.get_ordered_account_addresses() {
            let node = create_test_certified_node(round, &validator);
            dag.add_node_for_test(node).unwrap();
        }
    }
    
    // Simulate commit at round 100
    let pruned = dag.commit_callback(100);
    
    // VULNERABILITY: No nodes were pruned because of integer overflow
    assert!(pruned.is_none(), "Expected no pruning due to overflow");
    
    // Verify all nodes from round 1 are still in memory
    assert_eq!(dag.lowest_round(), 1, "Start round should still be 1");
    assert_eq!(dag.highest_round(), 100, "Should have all rounds up to 100");
    
    // With window_size=10 (normal), nodes before round 70 should be pruned
    // But with window_size=u64::MAX, ALL nodes remain in memory
    
    // This demonstrates unbounded growth - in production, this continues
    // until OOM crash occurs
}
```

**Exploitation Steps:**

1. Attacker gains governance voting power through legitimate stake
2. Creates governance proposal with malicious consensus config:
```rust
let malicious_config = DagConsensusConfigV1 {
    dag_ordering_causal_history_window: usize::MAX,
    anchor_election_mode: AnchorElectionMode::RoundRobin,
};
let config_bytes = bcs::to_bytes(&OnChainConsensusConfig::V5 {
    alg: ConsensusAlgorithmConfig::DAG(malicious_config),
    vtxn: ValidatorTxnConfig::default_for_genesis(),
    window_size: None,
    rand_check_enabled: true,
}).unwrap();
```
3. Submits proposal via `consensus_config::set_for_next_epoch()`
4. Proposal passes governance vote
5. Config applied at next epoch via reconfiguration
6. All validators begin accumulating unbounded DAG history
7. Within hours/days, validators exhaust memory and crash
8. Network loses quorum and consensus halts

## Notes

- This vulnerability affects only DAG consensus mode, not Jolteon/JolteonV2
- The multiplication overflow occurs silently in release builds with default Rust arithmetic
- The default value of 10 is safe, but the lack of validation creates a critical attack surface
- Similar issues may exist in other on-chain config parameters lacking validation

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** consensus/src/dag/dag_store.rs (L49-59)
```rust
/// Data structure that stores the in-memory DAG representation, it maintains round based index.
#[derive(Clone)]
pub struct InMemDag {
    nodes_by_round: BTreeMap<Round, Vec<Option<NodeStatus>>>,
    /// Map between peer id to vector index
    author_to_index: HashMap<Author, usize>,
    start_round: Round,
    epoch_state: Arc<EpochState>,
    /// The window we maintain between highest committed round and initial round
    window_size: u64,
}
```

**File:** consensus/src/dag/dag_store.rs (L419-429)
```rust
    fn commit_callback(
        &mut self,
        commit_round: Round,
    ) -> Option<BTreeMap<u64, Vec<Option<NodeStatus>>>> {
        let new_start_round = commit_round.saturating_sub(3 * self.window_size);
        if new_start_round > self.start_round {
            self.start_round = new_start_round;
            return Some(self.prune());
        }
        None
    }
```

**File:** consensus/src/dag/bootstrap.rs (L683-691)
```rust
    fn full_bootstrap(&self) -> (BootstrapBaseState, NetworkHandler, DagFetcherService) {
        let (anchor_election, commit_history, commit_events) = self.build_anchor_election();

        let base_state = self.bootstrap_dag_store(
            anchor_election.clone(),
            commit_history,
            commit_events,
            self.onchain_config.dag_ordering_causal_history_window as u64,
        );
```
