# Audit Report

## Title
Validators Can Bypass Time-Based Transaction Filters via Block Timestamp Manipulation

## Summary
Validators can manipulate block timestamps to bypass `BlockTimeStampGreaterThan` transaction filtering rules by setting timestamps older than the current time while still satisfying block validation constraints. This allows transactions that should be filtered based on time-based policies to be included in blocks and executed.

## Finding Description

The transaction filtering system in Aptos allows operators to configure time-based policies using `BlockTimeStampGreaterThan` matchers. [1](#0-0) 

When a validator creates a block, the timestamp is obtained from their local time service. [2](#0-1) 

Block validation only enforces three timestamp constraints:
1. Must be strictly greater than parent timestamp (for non-nil blocks)
2. Must not be more than 5 minutes in the future
3. Must not exceed round deadline [3](#0-2) 

**Critically, there is no validation that the timestamp is close to the current time.** A validator can set a timestamp significantly older than current time as long as it satisfies `parent_timestamp < new_timestamp < current_time + 5min`.

Transaction filters are applied during block execution by all validators: [4](#0-3) 

The filter evaluation at [5](#0-4)  uses the block's timestamp directly without verifying its recency.

**Attack Scenario:**
1. A `Deny` rule is configured: `BlockTimeStampGreaterThan(T)` to block transactions when `block_timestamp > T`
2. Current time is `T + 1000 seconds`
3. Parent block has timestamp `T - 100 seconds`
4. Malicious proposer wants to include transactions that should be denied
5. Proposer sets `block_timestamp = T - 1 second`
6. Filter evaluates: `(T - 1) > T` = `false` → rule doesn't match → transactions **allowed**
7. All validators execute with this manipulated timestamp and include the filtered transactions

The timestamp guarantees documented at [6](#0-5)  only ensure monotonicity and that timestamps are not too far in the future—not that they are recent.

## Impact Explanation

This vulnerability allows validators to bypass security policies implemented through time-based transaction filters. The impact severity is **High** because:

1. **Significant Protocol Violation**: Time-based filtering is a security mechanism intended to enforce temporal access control policies
2. **Policy Bypass**: Operators cannot rely on timestamp-based filters to enforce time-windowed restrictions
3. **Deterministic Exploit**: The attack is deterministic and works whenever a validator is selected as proposer
4. **All Validators Affected**: Because filters are applied during execution, all validators will accept the manipulated timestamp

The actual damage depends on how transaction filters are used:
- If used for emergency shutdown mechanisms → High impact
- If used for phased rollouts or staged migrations → High impact  
- If used for governance time-locks → High impact
- If used only for testing/debugging → Lower impact

Under the Aptos bug bounty criteria, this qualifies as **High Severity** ("Significant protocol violations").

## Likelihood Explanation

**Likelihood: High** when the following conditions are met:

1. **Proposer Selection**: Attacker must be a validator selected as proposer for a round (depends on stake and proposer election)
2. **Filter Configuration**: Time-based transaction filters must be actively configured
3. **Parent Timestamp Age**: Parent block timestamp must be old enough to allow manipulation
4. **No Additional Verification**: No out-of-band timestamp verification is performed

The attack requires validator privileges, making this an **insider threat**. However, given that:
- Validators regularly rotate as proposers
- Parent timestamps naturally age over time
- No additional timestamp validation exists

An adversarial validator can execute this attack reliably when selected as proposer.

## Recommendation

Add validation to ensure block timestamps cannot be significantly older than the receiving validator's current time. Modify the `verify_well_formed` function: [7](#0-6) 

**Recommended Fix:**
```rust
} else {
    ensure!(
        self.timestamp_usecs() > parent.timestamp_usecs(),
        "Blocks must have strictly increasing timestamps"
    );

    let current_ts = duration_since_epoch();
    
    // NEW: Ensure timestamp is not too old (e.g., max 1 minute in the past)
    const MAX_TIMESTAMP_DRIFT_PAST: u64 = 60_000_000; // 60 seconds in microseconds
    ensure!(
        self.timestamp_usecs() >= current_ts.as_micros().saturating_sub(MAX_TIMESTAMP_DRIFT_PAST) as u64,
        "Blocks must not have timestamps too far in the past"
    );

    // Existing check: not too far in future
    const TIMEBOUND: u64 = 300_000_000;
    ensure!(
        self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
        "Blocks must not be too far in the future"
    );
}
```

This enforces a bounded timestamp window (e.g., current_time ± allowed_drift) while preserving monotonicity guarantees.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_timestamp_manipulation_bypasses_filter() {
    use aptos_crypto::HashValue;
    use aptos_transaction_filters::block_transaction_filter::{
        BlockTransactionFilter, BlockMatcher, BlockTransactionMatcher, BlockTransactionRule,
    };
    use aptos_types::transaction::SignedTransaction;
    
    // Configure filter: Deny transactions when block_timestamp > 1000
    let filter = BlockTransactionFilter::new(vec![
        BlockTransactionRule::Deny(vec![
            BlockTransactionMatcher::Block(BlockMatcher::BlockTimeStampGreaterThan(1000)),
        ]),
    ]);
    
    let block_id = HashValue::random();
    let block_author = None;
    let block_epoch = 1;
    let txn = SignedTransaction::dummy();
    
    // Normal case: current timestamp > 1000, transaction should be DENIED
    let current_timestamp = 2000;
    assert!(!filter.allows_transaction(
        block_id,
        block_author,
        block_epoch,
        current_timestamp,
        &txn
    ), "Transaction should be denied when timestamp > 1000");
    
    // Attack: Proposer sets old timestamp < 1000, transaction is ALLOWED
    let manipulated_timestamp = 999;
    assert!(filter.allows_transaction(
        block_id,
        block_author,
        block_epoch,
        manipulated_timestamp,
        &txn
    ), "VULNERABILITY: Transaction is allowed with manipulated old timestamp");
}
```

This test demonstrates that a validator can bypass time-based filters by setting an older timestamp that still passes block validation but circumvents filtering rules.

## Notes

This vulnerability represents a trust boundary violation where validators, who are partially trusted actors, can manipulate timestamps within validation constraints to bypass security policies. While the timestamp manipulation itself doesn't directly break consensus safety or cause fund loss, it undermines the security guarantees of time-based transaction filtering—a feature integrated into the production consensus pipeline.

### Citations

**File:** crates/aptos-transaction-filters/src/block_transaction_filter.rs (L283-285)
```rust
            BlockMatcher::BlockTimeStampGreaterThan(target_timestamp) => {
                matches_timestamp_greater_than(block_timestamp, target_timestamp)
            },
```

**File:** crates/aptos-transaction-filters/src/block_transaction_filter.rs (L320-323)
```rust
/// Returns true iff the block timestamp is greater than the target timestamp
fn matches_timestamp_greater_than(block_timestamp: u64, target_timestamp: &u64) -> bool {
    block_timestamp > *target_timestamp
}
```

**File:** consensus/src/liveness/proposal_generator.rs (L598-601)
```rust
        // All proposed blocks in a branch are guaranteed to have increasing timestamps
        // since their predecessor block will not be added to the BlockStore until
        // the local time exceeds it.
        let timestamp = self.time_service.get_current_timestamp();
```

**File:** consensus/consensus-types/src/block.rs (L521-540)
```rust
        if self.is_nil_block() || parent.has_reconfiguration() {
            ensure!(
                self.timestamp_usecs() == parent.timestamp_usecs(),
                "Nil/reconfig suffix block must have same timestamp as parent"
            );
        } else {
            ensure!(
                self.timestamp_usecs() > parent.timestamp_usecs(),
                "Blocks must have strictly increasing timestamps"
            );

            let current_ts = duration_since_epoch();

            // we can say that too far is 5 minutes in the future
            const TIMEBOUND: u64 = 300_000_000;
            ensure!(
                self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
                "Blocks must not be too far in the future"
            );
        }
```

**File:** consensus/src/block_preparer.rs (L87-96)
```rust
        let block_timestamp_usecs = block.timestamp_usecs();

        // Transaction filtering, deduplication and shuffling are CPU intensive tasks, so we run them in a blocking task.
        let result = tokio::task::spawn_blocking(move || {
            let filtered_txns = filter_block_transactions(
                txn_filter_config,
                block_id,
                block_author,
                block_epoch,
                block_timestamp_usecs,
```

**File:** consensus/consensus-types/src/block_data.rs (L86-96)
```rust
    /// It makes the following guarantees:
    ///   1. Time Monotonicity: Time is monotonically increasing in the block chain.
    ///      (i.e. If H1 < H2, H1.Time < H2.Time).
    ///   2. If a block of transactions B is agreed on with timestamp T, then at least
    ///      f+1 honest validators think that T is in the past. An honest validator will
    ///      only vote on a block when its own clock >= timestamp T.
    ///   3. If a block of transactions B has a QC with timestamp T, an honest validator
    ///      will not serve such a block to other validators until its own clock >= timestamp T.
    ///   4. Current: an honest validator is not issuing blocks with a timestamp in the
    ///       future. Currently we consider a block is malicious if it was issued more
    ///       that 5 minutes in the future.
```
