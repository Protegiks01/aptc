# Audit Report

## Title
Distance Spoofing Attack: Malicious Peers Can Manipulate Network Topology to Influence Consensus, State Sync, and Mempool Peer Selection

## Summary
Malicious peers can report false `distance_from_validators` values with insufficient validation, allowing them to appear more trustworthy and gain priority in critical peer selection algorithms for consensus observer subscriptions, state sync data requests, and mempool transaction propagation. This vulnerability breaks the network's trust model by allowing attackers to position themselves as preferred data sources without actual proximity to validators.

## Finding Description

The peer monitoring service implements a validation mechanism for `distance_from_validators` values reported by peers, but contains a critical gap that allows distance spoofing for any peer reporting distance ≥ 2.

**Validation Gap:**

The validation logic only enforces role-based checks for distance values 0 and 1, but accepts any distance ≥ 2 that is within the maximum bound: [1](#0-0) 

For distance values ≥ 2, the only check is that the value does not exceed `MAX_DISTANCE_FROM_VALIDATORS` (100). There is **no verification** that the peer is actually at that distance from validators. [2](#0-1) 

**Trust Propagation:**

Nodes calculate their own distance by trusting peer-reported values and adding 1: [3](#0-2) 

This creates a cascading trust issue where false distance values propagate through the network topology.

**Critical Usage in Consensus Observer:**

The consensus observer prioritizes peers with lower distances when selecting subscription targets: [4](#0-3) 

Peers are grouped by distance in ascending order (BTreeMap), meaning lower distance values are selected first for consensus subscriptions.

**Critical Usage in State Sync:**

State sync uses distance as the primary factor for peer selection: [5](#0-4) 

**Critical Usage in Mempool:**

Mempool prioritizes transaction forwarding to peers with lower validator distances: [6](#0-5) 

**Attack Scenario:**

1. Malicious Public Fullnode (PFN) at true distance 5 reports `distance_from_validators = 2`
2. Validation passes because 2 ≤ 100 and role checks don't apply to distance ≥ 2
3. Other nodes query this peer's network information and receive the false distance value
4. Those nodes calculate their own distance as 2 + 1 = 3 (instead of true value 5 + 1 = 6)
5. The malicious peer gets prioritized for:
   - Consensus observer subscriptions (receives consensus updates first)
   - State sync data requests (becomes preferred data source)
   - Mempool transaction propagation (receives transactions first)
6. Malicious peer can deliver stale, delayed, or manipulated data affecting consensus liveness and network data freshness

## Impact Explanation

**Critical/High Severity** - This vulnerability impacts multiple critical systems:

1. **Consensus Liveness**: Nodes may subscribe to malicious peers for consensus updates, potentially receiving delayed or stale consensus information. While this doesn't directly break consensus safety (BFT tolerates < 1/3 Byzantine), it can degrade liveness by increasing block confirmation latency.

2. **State Sync Integrity**: Nodes preferentially request state sync data from peers with lower distances. Malicious peers can position themselves as primary data sources and deliver stale state, forcing honest nodes to repeatedly retry or timeout.

3. **Mempool Efficiency**: Transaction propagation prioritizes lower-distance peers. Malicious peers can create bottlenecks in transaction dissemination, affecting network throughput.

4. **Network Topology Corruption**: False distance values propagate through the network as nodes trust peer-reported values to calculate their own distances. This corrupts the entire network's routing decisions over time.

This qualifies as **High Severity** ($50,000 range) due to potential validator node performance degradation and protocol violations. It may approach **Critical Severity** if it can be demonstrated to cause measurable consensus delays or enable more sophisticated attacks in combination with other vectors.

## Likelihood Explanation

**Likelihood: High**

This attack is highly likely because:

1. **Low Barrier to Entry**: Any Public Fullnode can execute this attack without requiring validator access or special privileges
2. **Simple Exploitation**: The attacker only needs to respond to `GetNetworkInformation` requests with a false distance value
3. **No Detection Mechanism**: There is no mechanism to verify or audit the accuracy of reported distances
4. **Cascading Effect**: Once false values are accepted, they propagate to other nodes automatically
5. **Immediate Impact**: Malicious peers are immediately prioritized for consensus, state sync, and mempool operations

The attack requires minimal resources and can be performed continuously. Multiple colluding malicious nodes could amplify the impact by reporting coordinated false distances.

## Recommendation

Implement independent distance verification rather than trusting self-reported values. Several approaches:

**Approach 1: Bidirectional Distance Calculation**
Instead of trusting peer-reported distances, nodes should independently calculate peer distances based on the distances those peers report for THEIR connected peers. If peer A reports distance X, verify it's consistent with peer A's reported connections to validators/VFNs.

**Approach 2: Enhanced Validation for Distance ≥ 2**
For Public Fullnodes (distance ≥ 2), require additional proof:
- Verify the peer is connected to peers with distance-1 
- Cross-reference reported distance with distances from other peers
- Implement distance consensus: accept distance only if multiple independent peers report similar values

**Approach 3: Signed Distance Attestations**
Require validators/VFNs to sign distance attestations for their immediate downstream peers. Peers at distance ≥ 2 must present a chain of signed attestations proving their path to validators.

**Example Fix (Approach 2):**

```rust
// In network_info.rs, enhance validation for distance >= 2
distance_from_validators => {
    // The distance must be less than or equal to the max
    if distance_from_validators > MAX_DISTANCE_FROM_VALIDATORS {
        return false;
    }
    
    // For distance >= 2, perform additional validation
    // Verify the peer's connected peers support this distance claim
    if let Some(connected_peers) = &network_info_response.connected_peers {
        let has_lower_distance_peer = connected_peers.iter().any(|(_, conn_metadata)| {
            // Check if peer is connected to someone with distance-1
            // This would require extending ConnectionMetadata to include distance
            peer_has_distance_minus_one(conn_metadata, distance_from_validators)
        });
        
        if !has_lower_distance_peer && distance_from_validators >= 2 {
            // Peer claims distance N but isn't connected to anyone with distance N-1
            return false;
        }
    }
    
    true
}
```

Additionally, implement distance auditing:
- Log distance claims from all peers
- Monitor for suspicious distance changes or inconsistencies
- Implement reputation scoring that penalizes peers with inconsistent distance reports

## Proof of Concept

```rust
// PoC: Demonstrate that a malicious peer can report false distance and pass validation

#[test]
fn test_distance_spoofing_vulnerability() {
    use aptos_config::{
        config::{BaseConfig, NodeConfig, PeerRole, RoleType},
        network_id::{NetworkId, PeerNetworkId},
    };
    use aptos_peer_monitoring_service_types::{
        response::{NetworkInformationResponse, PeerMonitoringServiceResponse},
    };
    use aptos_network::{
        application::metadata::PeerMetadata,
        protocols::wire::handshake::v1::{MessagingProtocolVersion, ProtocolIdSet},
        transport::{ConnectionId, ConnectionMetadata},
    };
    use aptos_types::PeerId;
    use std::collections::HashMap;
    
    // Create a network info state for a Public Fullnode (PFN)
    let node_config = NodeConfig {
        base: BaseConfig {
            role: RoleType::FullNode,
            ..Default::default()
        },
        ..Default::default()
    };
    let mut network_info_state = NetworkInfoState::new(
        node_config,
        TimeService::mock()
    );
    
    // Create a malicious peer claiming to be a PFN at distance 2
    // (when it's actually at distance 5 or more)
    let malicious_peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    let connection_metadata = ConnectionMetadata::new(
        malicious_peer.peer_id(),
        ConnectionId::default(),
        NetworkAddress::from_str("/ip4/127.0.0.1/tcp/8081").unwrap(),
        ConnectionOrigin::Outbound,
        MessagingProtocolVersion::V1,
        ProtocolIdSet::empty(),
        PeerRole::Unknown, // Unknown role = regular PFN
    );
    let peer_metadata = PeerMetadata::new(connection_metadata);
    
    // Malicious peer reports FALSE distance of 2
    // (actual distance might be 5, but validation can't verify this)
    let malicious_distance = 2;
    let network_info_response = NetworkInformationResponse {
        connected_peers: HashMap::new(),
        distance_from_validators: malicious_distance,
    };
    
    // Handle the response - this should PASS validation (demonstrating the vulnerability)
    network_info_state.handle_monitoring_service_response(
        &malicious_peer,
        peer_metadata,
        PeerMonitoringServiceRequest::GetNetworkInformation,
        PeerMonitoringServiceResponse::NetworkInformation(network_info_response),
        0.0,
    );
    
    // VULNERABILITY: The false distance is accepted and stored
    let stored_response = network_info_state.get_latest_network_info_response();
    assert!(stored_response.is_some());
    assert_eq!(
        stored_response.unwrap().distance_from_validators,
        malicious_distance
    );
    
    // This malicious peer will now be PRIORITIZED in:
    // 1. Consensus observer subscriptions
    // 2. State sync peer selection  
    // 3. Mempool transaction forwarding
    // All because it claimed a false distance that passed validation
    
    println!("VULNERABILITY CONFIRMED: Malicious peer successfully reported false distance");
    println!("False distance: {}, Stored distance: {}", 
             malicious_distance, 
             stored_response.unwrap().distance_from_validators);
}

// Additional PoC: Show that this peer gets prioritized in consensus observer selection
#[test]
fn test_malicious_peer_prioritization() {
    // Create honest peer at distance 4 and malicious peer falsely claiming distance 2
    let mut peers_and_metadata = HashMap::new();
    
    // Honest peer at true distance 4
    let honest_peer = create_peer_with_distance(NetworkId::Public, 4, true);
    peers_and_metadata.insert(honest_peer.0, honest_peer.1);
    
    // Malicious peer falsely claiming distance 2 (true distance unknown, maybe 5+)
    let malicious_peer = create_peer_with_distance(NetworkId::Public, 2, true);
    peers_and_metadata.insert(malicious_peer.0, malicious_peer.1);
    
    // Sort peers by subscription optimality (used by consensus observer)
    let sorted_peers = sort_peers_by_subscription_optimality(&peers_and_metadata);
    
    // VULNERABILITY: Malicious peer with false distance is selected FIRST
    assert_eq!(sorted_peers[0], malicious_peer.0);
    assert_eq!(sorted_peers[1], honest_peer.0);
    
    println!("VULNERABILITY CONFIRMED: Malicious peer prioritized over honest peer");
    println!("Consensus observer would subscribe to malicious peer first!");
}
```

**Notes:**
- The validation logic specifically fails to verify distance accuracy for any peer reporting distance ≥ 2, creating a wide attack surface
- The vulnerability is compounded by the trust propagation mechanism where nodes calculate their own distance based on peer-reported values
- This affects three critical systems (consensus, state sync, mempool), making it a high-impact vulnerability
- The fix requires implementing independent distance verification or cryptographic distance attestations rather than trusting self-reported values

### Citations

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L118-141)
```rust
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };
```

**File:** peer-monitoring-service/types/src/lib.rs (L22-22)
```rust
pub const MAX_DISTANCE_FROM_VALIDATORS: u64 = 100; // Nodes that aren't connected to the network
```

**File:** peer-monitoring-service/server/src/lib.rs (L298-340)
```rust
fn get_distance_from_validators(
    base_config: &BaseConfig,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> u64 {
    // Get the connected peers and metadata
    let connected_peers_and_metadata = match peers_and_metadata.get_connected_peers_and_metadata() {
        Ok(connected_peers_and_metadata) => connected_peers_and_metadata,
        Err(error) => {
            warn!(LogSchema::new(LogEntry::PeerMonitoringServiceError).error(&error.into()));
            return MAX_DISTANCE_FROM_VALIDATORS;
        },
    };

    // If we're a validator and we have active validator peers, we're in the validator set.
    // TODO: figure out if we need to deal with validator set forks here.
    if base_config.role.is_validator() {
        for peer_metadata in connected_peers_and_metadata.values() {
            if peer_metadata.get_connection_metadata().role.is_validator() {
                return 0;
            }
        }
    }

    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
}
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L283-312)
```rust
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```

**File:** state-sync/aptos-data-client/src/utils.rs (L23-64)
```rust
/// Chooses peers weighted by distance from the validator set
/// and latency. We prioritize distance over latency as we want
/// to avoid close but not up-to-date peers.
pub fn choose_random_peers_by_distance_and_latency(
    peers: HashSet<PeerNetworkId>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    num_peers_to_choose: usize,
) -> HashSet<PeerNetworkId> {
    // Group peers and latency weights by validator distance, i.e., distance -> [(peer, latency weight)]
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for peer in peers {
        if let Some((distance, latency)) =
            get_distance_and_latency_for_peer(&peers_and_metadata, peer)
        {
            let latency_weight = convert_latency_to_weight(latency);
            peers_and_latencies_by_distance
                .entry(distance)
                .or_insert_with(Vec::new)
                .push((peer, latency_weight));
        }
    }

    // Select the peers by distance and latency weights. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut selected_peers = HashSet::new();
    for (_, peers_and_latencies) in peers_and_latencies_by_distance {
        // Select the peers by latency weights
        let num_peers_remaining = num_peers_to_choose.saturating_sub(selected_peers.len()) as u64;
        let peers = choose_random_peers_by_weight(num_peers_remaining, peers_and_latencies);

        // Add the peers to the entire set
        selected_peers.extend(peers);

        // If we have selected enough peers, return early
        if selected_peers.len() >= num_peers_to_choose {
            return selected_peers;
        }
    }

    // Return the selected peers
    selected_peers
}
```

**File:** mempool/src/shared_mempool/priority.rs (L613-639)
```rust
/// Compares the validator distance for the given pair of monitoring metadata.
/// The peer with the lowest validator distance is prioritized.
fn compare_validator_distance(
    monitoring_metadata_a: &Option<&PeerMonitoringMetadata>,
    monitoring_metadata_b: &Option<&PeerMonitoringMetadata>,
) -> Ordering {
    // Get the validator distance from the monitoring metadata
    let validator_distance_a = get_distance_from_validators(monitoring_metadata_a);
    let validator_distance_b = get_distance_from_validators(monitoring_metadata_b);

    // Compare the distances
    match (validator_distance_a, validator_distance_b) {
        (Some(validator_distance_a), Some(validator_distance_b)) => {
            // Prioritize the peer with the lowest validator distance
            validator_distance_a.cmp(&validator_distance_b).reverse()
        },
        (Some(_), None) => {
            Ordering::Greater // Prioritize the peer with a validator distance
        },
        (None, Some(_)) => {
            Ordering::Less // Prioritize the peer with a validator distance
        },
        (None, None) => {
            Ordering::Equal // Neither peer has a validator distance
        },
    }
}
```
