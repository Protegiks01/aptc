# Audit Report

## Title
Byzantine Validators Can Cause Unbounded Memory Growth in JWK Consensus via Malicious RPC Requests

## Summary
Byzantine validators can send arbitrary `KeyLevelObservationRequest` RPC messages with fake (issuer, kid) pairs to force victim validators to create unbounded `ConsensusState::NotStarted` entries in the `states_by_key` HashMap, leading to memory exhaustion within an epoch.

## Finding Description

The `KeyLevelConsensusManager` in the JWK consensus subsystem maintains a HashMap that maps `(Issuer, KID)` tuples to `ConsensusState` instances. [1](#0-0) 

When processing incoming RPC requests of type `KeyLevelObservationRequest`, the code unconditionally creates new HashMap entries using `.entry().or_default()` for any requested (issuer, kid) pair, regardless of whether that pair is legitimate: [2](#0-1) 

A Byzantine validator can exploit this by sending RPC messages with arbitrary (issuer, kid) pairs. Each unique pair creates a new `ConsensusState::NotStarted` entry that persists in memory.

The cleanup mechanism in `reset_with_on_chain_state()` has a critical flaw. It retains entries where the on-chain version hasn't changed: [3](#0-2) 

For malicious entries with arbitrary issuers not present in the on-chain state, both `new_onchain_jwks.get(issuer)` and `self.onchain_jwks.get(issuer)` return `None`, which default to version 0. Since 0 == 0, these malicious entries are incorrectly retained forever within the epoch.

**Attack Flow:**
1. Byzantine validator crafts `JWKConsensusMsg::KeyLevelObservationRequest` messages with arbitrary (issuer, kid) pairs
2. Messages pass through the network layer and epoch manager without validation [4](#0-3) 
3. `process_peer_request()` creates `NotStarted` entries for each unique pair
4. Malicious entries persist until epoch boundary (hours to days in production)
5. Repeated attacks cause unbounded HashMap growth and memory exhaustion

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **Resource Exhaustion**: Unbounded memory growth can degrade validator performance or cause node crashes
- **State Inconsistencies**: Memory pressure may affect consensus participation and state processing
- **Limited Scope**: Requires Byzantine validator capability, not executable by arbitrary network peers
- **Temporal Bound**: Entries are cleared at epoch boundaries (though epochs can last hours/days)

The impact is not Critical because:
- Does not directly cause consensus safety violations or fund loss
- Does not permanently damage the network (recovers at next epoch)
- Requires adversarial validator access

However, sustained attacks across multiple epochs could significantly degrade network performance and availability, affecting validator uptime and consensus efficiency.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is straightforward to execute:
- Byzantine validators have native RPC capabilities
- No authentication or authorization checks on RPC request contents
- No rate limiting on RPC requests [5](#0-4) 
- Automatic entry creation on any incoming request

Aptos's security model assumes < 1/3 Byzantine validators, making this a realistic threat model. A single compromised validator can execute this attack repeatedly with minimal effort and no on-chain costs.

## Recommendation

Implement multiple defensive layers:

**1. Validate RPC Requests:**
Before creating HashMap entries, verify that the (issuer, kid) pair exists in legitimate on-chain JWK state or current observations:

```rust
pub fn process_peer_request(&mut self, rpc_req: IncomingRpcRequest) -> Result<()> {
    let IncomingRpcRequest { msg, mut response_sender, .. } = rpc_req;
    match msg {
        JWKConsensusMsg::KeyLevelObservationRequest(request) => {
            let ObservedKeyLevelUpdateRequest { issuer, kid, .. } = request;
            
            // ADDED: Validate the request against known state
            let is_valid = self.onchain_jwks
                .get(&issuer)
                .map(|jwks| jwks.jwks.contains_key(&kid))
                .unwrap_or(false);
            
            if !is_valid {
                debug!("Rejecting RPC for unknown (issuer, kid) pair");
                return Ok(());
            }
            
            let consensus_state = self.states_by_key
                .entry((issuer.clone(), kid.clone()))
                .or_default();
            // ... rest of function
        },
        _ => bail!("unexpected rpc: {}", msg.name()),
    }
}
```

**2. Fix Cleanup Logic:**
Correct the `reset_with_on_chain_state()` retention predicate to remove entries for unknown issuers:

```rust
self.states_by_key.retain(|(issuer, kid), _| {
    // Only retain if issuer exists in new on-chain state AND version unchanged
    new_onchain_jwks.get(issuer)
        .map(|new_jwks| {
            self.onchain_jwks.get(issuer)
                .map(|old_jwks| {
                    new_jwks.version == old_jwks.version 
                        && new_jwks.jwks.contains_key(kid)
                })
                .unwrap_or(false)
        })
        .unwrap_or(false)
});
```

**3. Add Size Limits:**
Implement a maximum size for `states_by_key` with LRU eviction or reject new entries when limit is reached.

**4. Add Rate Limiting:**
Implement per-peer RPC rate limiting in the network layer to prevent flood attacks.

## Proof of Concept

```rust
#[cfg(test)]
mod test_unbounded_growth {
    use super::*;
    use aptos_types::jwks::{Issuer, KID};
    
    #[test]
    fn test_malicious_rpc_causes_unbounded_growth() {
        // Setup: Create KeyLevelConsensusManager with empty on-chain state
        let mut manager = setup_test_manager_with_empty_state();
        
        // Attack: Send 10,000 RPC requests with unique fake (issuer, kid) pairs
        for i in 0..10000 {
            let fake_issuer: Issuer = format!("fake_issuer_{}", i).into_bytes();
            let fake_kid: KID = format!("fake_kid_{}", i).into_bytes();
            
            let rpc_request = create_observation_request(fake_issuer.clone(), fake_kid.clone());
            
            // Process the malicious RPC - creates NotStarted entry
            manager.process_peer_request(rpc_request).unwrap();
        }
        
        // Verify: 10,000 entries created in states_by_key
        assert_eq!(manager.states_by_key.len(), 10000);
        
        // Verify: Entries persist after reset_with_on_chain_state (cleanup fails)
        manager.reset_with_on_chain_state(AllProvidersJWKs::default()).unwrap();
        
        // BUG: Malicious entries are NOT cleaned up due to version comparison bug
        assert_eq!(manager.states_by_key.len(), 10000, 
            "Malicious entries should be removed but persist due to vulnerability");
    }
}
```

## Notes

This vulnerability is specific to the `KeyLevelConsensusManager` (per-key mode). The `IssuerLevelConsensusManager` is not affected because it uses a different HashMap key structure with one entry per issuer, and issuers are bounded by on-chain configuration. [6](#0-5) 

The vulnerability requires the `JWK_CONSENSUS_PER_KEY_MODE` feature flag to be enabled. [7](#0-6)

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L59-59)
```rust
    states_by_key: HashMap<(Issuer, KID), ConsensusState<ObservedKeyLevelUpdate>>,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L244-254)
```rust
        self.states_by_key.retain(|(issuer, _), _| {
            new_onchain_jwks
                .get(issuer)
                .map(|jwks| jwks.version)
                .unwrap_or_default()
                == self
                    .onchain_jwks
                    .get(issuer)
                    .map(|jwks| jwks.version)
                    .unwrap_or_default()
        });
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L274-277)
```rust
                let consensus_state = self
                    .states_by_key
                    .entry((issuer.clone(), kid.clone()))
                    .or_default();
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L94-105)
```rust
    fn process_rpc_request(
        &mut self,
        peer_id: Author,
        rpc_request: IncomingRpcRequest,
    ) -> Result<()> {
        if Some(rpc_request.msg.epoch()) == self.epoch_state.as_ref().map(|s| s.epoch) {
            if let Some(tx) = &self.jwk_rpc_msg_tx {
                let _ = tx.push(peer_id, (peer_id, rpc_request));
            }
        }
        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L222-222)
```rust
            let (jwk_rpc_msg_tx, jwk_rpc_msg_rx) = aptos_channel::new(QueueStyle::FIFO, 100, None);
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L228-236)
```rust
                if features.is_enabled(FeatureFlag::JWK_CONSENSUS_PER_KEY_MODE) {
                    Box::new(KeyLevelConsensusManager::new(
                        Arc::new(my_sk),
                        self.my_addr,
                        epoch_state.clone(),
                        rb,
                        self.vtxn_pool.clone(),
                    ))
                } else {
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L54-54)
```rust
    states_by_issuer: HashMap<Issuer, PerProviderState>,
```
