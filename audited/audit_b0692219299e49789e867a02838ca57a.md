# Audit Report

## Title
Type Confusion Through Incomplete Ability Validation in Cross-Module Function Signature Comparison

## Summary
The `compare_structs()` function in the Move bytecode verifier only validates module ID and struct name when comparing struct types across modules, but fails to validate that struct abilities match. This allows a malicious module to use struct handles with restricted abilities in function signatures, creating type confusion where the VM treats the same struct as having different abilities in different execution contexts, potentially leading to consensus violations and security bypasses.

## Finding Description

The vulnerability exists in the cross-module dependency verification system. When a module imports a function from another module, the bytecode verifier compares the function signatures to ensure type safety. However, the comparison is incomplete. [1](#0-0) 

The `compare_structs()` function only compares `module_id` and `struct_name`, but **does not compare abilities or type parameters**. This is problematic because:

1. The `verify_imported_structs()` function allows local struct handles to have a **subset** of the actual struct's abilities: [2](#0-1) 

2. At runtime, when converting signature tokens to types, the VM uses the **local module's struct handle abilities**, not the actual definition: [3](#0-2) 

3. When ability checks occur at runtime, they query these cached abilities: [4](#0-3) 

**Attack Scenario:**
1. Module B defines: `public struct X has copy, drop, store, key { value: u64 }`
2. Module B defines: `public fun store_x(x: X)` which stores X in global storage
3. Attacker's Module A imports `store_x` but creates a struct handle for `X` with only `{copy, drop}` abilities (omitting `store` and `key`)
4. This passes `verify_imported_structs()` because subset abilities are allowed
5. This passes `compare_structs()` because it only checks module ID and name
6. At runtime, Module A's view of type `X` has abilities `{copy, drop}`, while Module B's view has `{copy, drop, store, key}`
7. Different nodes may execute with different cached ability information, causing **non-deterministic execution** and **consensus violations**

The core security guarantee broken is: **All modules must have a consistent view of a struct's abilities.** The Move type system requires that abilities are intrinsic properties of types, not context-dependent.

## Impact Explanation

**Severity: HIGH to CRITICAL**

This vulnerability breaks the fundamental **Deterministic Execution** invariant:

1. **Consensus Violation Risk**: Different validators may have different cached ability views for the same struct depending on which modules they've loaded and in what order. This can cause different execution outcomes for the same transaction, leading to state divergence.

2. **Security Bypass**: The `key` and `store` abilities gate access to global storage operations. If a module can present a type as lacking these abilities while another module treats it as having them, it could bypass storage access controls.

3. **Type System Violation**: The Move language specification states that abilities are properties of the type itself, not the context. This vulnerability allows the same type to have different properties in different contexts, fundamentally breaking type safety.

4. **Runtime Check Bypass**: Functions like `paranoid_check_has_ability()` will use the incorrect cached abilities: [5](#0-4) 

This meets **High Severity** criteria: "Significant protocol violations" and potentially **Critical Severity** if it can be weaponized to cause consensus splits.

## Likelihood Explanation

**Likelihood: MEDIUM**

The attack is feasible because:
- Any module publisher can craft bytecode with restricted struct handle abilities
- The verification bypass is in production code
- No special privileges are required
- The attack is reproducible and deterministic

However, exploitation requires:
- Publishing a malicious module on-chain
- Understanding the internal VM type loading mechanism
- Crafting specific bytecode patterns

The impact depends on whether different nodes cache different ability views during execution, which requires analysis of the module loader's caching behavior.

## Recommendation

**Fix: Validate ability consistency in `compare_structs()`**

The function should be enhanced to validate that the abilities in both struct handles are compatible:

```rust
fn compare_structs(
    context: &Context,
    idx1: StructHandleIndex,
    idx2: StructHandleIndex,
    def_module: &CompiledModule,
) -> PartialVMResult<()> {
    // grab ModuleId and struct name for the module being verified
    let struct_handle = context.resolver.struct_handle_at(idx1);
    let module_handle = context.resolver.module_handle_at(struct_handle.module);
    let module_id = context.resolver.module_id_for_handle(module_handle);
    let struct_name = context.resolver.identifier_at(struct_handle.name);

    // grab ModuleId and struct name for the definition
    let def_struct_handle = def_module.struct_handle_at(idx2);
    let def_module_handle = def_module.module_handle_at(def_struct_handle.module);
    let def_module_id = def_module.module_id_for_handle(def_module_handle);
    let def_struct_name = def_module.identifier_at(def_struct_handle.name);

    if module_id != def_module_id || struct_name != def_struct_name {
        return Err(PartialVMError::new(StatusCode::TYPE_MISMATCH));
    }
    
    // ADD: Validate abilities match exactly for cross-module function signatures
    if struct_handle.abilities != def_struct_handle.abilities {
        return Err(PartialVMError::new(StatusCode::TYPE_MISMATCH)
            .with_message("struct abilities mismatch in cross-module function signature"));
    }
    
    // ADD: Validate type parameters match
    if !compatible_struct_type_parameters(
        &struct_handle.type_parameters,
        &def_struct_handle.type_parameters,
    ) {
        return Err(PartialVMError::new(StatusCode::TYPE_MISMATCH)
            .with_message("struct type parameters mismatch in cross-module function signature"));
    }

    Ok(())
}
```

## Proof of Concept

```rust
// Create two modules demonstrating the vulnerability

module 0x1::DefiningModule {
    // Struct with all abilities
    struct Resource has copy, drop, store, key {
        value: u64
    }
    
    public fun process(r: Resource): u64 {
        r.value
    }
}

module 0x2::AttackModule {
    use 0x1::DefiningModule;
    
    // In bytecode, craft a struct handle for DefiningModule::Resource
    // with only {copy, drop} abilities (omitting store, key)
    // This requires direct bytecode manipulation
    
    public fun exploit() {
        // Call DefiningModule::process with the restricted handle
        // The verifier will accept this because compare_structs()
        // only checks module ID and name
        // But at runtime, this module's view of Resource lacks
        // store and key abilities
    }
}
```

To properly demonstrate this, one would need to:
1. Manually craft Move bytecode with manipulated struct handle abilities
2. Use the Move bytecode assembler to create the malicious module
3. Attempt to publish and execute, observing the type confusion

**Notes**

The unused `check_compatibility()` function in runtime_types.rs was likely intended to catch this issue but is never invoked: [6](#0-5) 

This suggests the vulnerability may be a known concern that was incompletely addressed. The verification should occur at bytecode verification time (in `compare_structs()`), not at runtime.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/dependencies.rs (L395-400)
```rust
fn compatible_struct_abilities(
    local_struct_abilities_declaration: AbilitySet,
    defined_struct_abilities: AbilitySet,
) -> bool {
    local_struct_abilities_declaration.is_subset(defined_struct_abilities)
}
```

**File:** third_party/move/move-bytecode-verifier/src/dependencies.rs (L573-596)
```rust
fn compare_structs(
    context: &Context,
    idx1: StructHandleIndex,
    idx2: StructHandleIndex,
    def_module: &CompiledModule,
) -> PartialVMResult<()> {
    // grab ModuleId and struct name for the module being verified
    let struct_handle = context.resolver.struct_handle_at(idx1);
    let module_handle = context.resolver.module_handle_at(struct_handle.module);
    let module_id = context.resolver.module_id_for_handle(module_handle);
    let struct_name = context.resolver.identifier_at(struct_handle.name);

    // grab ModuleId and struct name for the definition
    let def_struct_handle = def_module.struct_handle_at(idx2);
    let def_module_handle = def_module.module_handle_at(def_struct_handle.module);
    let def_module_id = def_module.module_id_for_handle(def_module_handle);
    let def_struct_name = def_module.identifier_at(def_struct_handle.name);

    if module_id != def_module_id || struct_name != def_struct_name {
        Err(PartialVMError::new(StatusCode::TYPE_MISMATCH))
    } else {
        Ok(())
    }
}
```

**File:** third_party/move/move-vm/runtime/src/loader/type_loader.rs (L103-109)
```rust
        SignatureToken::Struct(sh_idx) => {
            let struct_handle = module.struct_handle_at(*sh_idx);
            let ty = Type::Struct {
                idx: struct_name_table[sh_idx.0 as usize],
                ability: AbilityInfo::struct_(struct_handle.abilities),
            };
            (ty, true)
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L223-248)
```rust
    pub fn check_compatibility(&self, struct_handle: &StructHandle) -> PartialVMResult<()> {
        if !struct_handle.abilities.is_subset(self.abilities) {
            return Err(
                PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                    .with_message("Ability definition of module mismatch".to_string()),
            );
        }

        if self.phantom_ty_params_mask.len() != struct_handle.type_parameters.len()
            || !self
                .phantom_ty_params_mask
                .iter()
                .zip(struct_handle.type_parameters.iter())
                .all(|(defined_is_phantom, local_type_parameter)| {
                    !local_type_parameter.is_phantom || defined_is_phantom
                })
        {
            return Err(
                PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(
                    "Phantom type parameter definition of module mismatch".to_string(),
                ),
            );
        }

        Ok(())
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L543-549)
```rust
    pub fn paranoid_check_has_ability(&self, ability: Ability) -> PartialVMResult<()> {
        if !self.abilities()?.has_ability(ability) {
            let msg = format!("Type {} does not have expected ability {}", self, ability);
            return paranoid_failure!(msg);
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L808-808)
```rust
            Type::Struct { ability, .. } => Ok(ability.base_ability_set),
```
