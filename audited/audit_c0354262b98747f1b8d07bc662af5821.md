# Audit Report

## Title
State Database Desynchronization Through Differential Pruning Windows Causes Scanner Crash

## Summary
The `state_kv_db` and `state_merkle_db` can become desynchronized when configured with different pruning windows, causing the snapshot scanner to panic when attempting to read values referenced by Merkle tree leaves that have been prematurely pruned from the key-value database.

## Finding Description

The Aptos storage system maintains two separate databases with independent pruning mechanisms:
- `state_merkle_db`: Stores Jellyfish Merkle tree nodes (leaves and internal nodes)
- `state_kv_db`: Stores the actual state key-value pairs

Each database has its own pruner with independently configurable `prune_window` settings: [1](#0-0) [2](#0-1) 

The pruning logic calculates `min_readable_version` as: [3](#0-2) [4](#0-3) 

The vulnerability occurs when `LedgerPrunerConfig.prune_window` (for state_kv) is smaller than `StateMerklePrunerConfig.prune_window` (for state_merkle). The state KV pruner deletes values based on their `stale_since_version`: [5](#0-4) 

The scanner iterates through Merkle tree leaves and expects all referenced values to exist: [6](#0-5) 

**Exploitation Scenario:**
1. Configure `state_kv_pruner.prune_window = 1000` and `state_merkle_pruner.prune_window = 2000`
2. Current version reaches 10,000
3. A Merkle snapshot exists at version 8,500 (within state_merkle's retention window)
4. A leaf at version 8,500 points to `(StateKey K, version 8,400)`
5. Value at version 8,400 was superseded at version 8,600 (creating stale index)
6. State KV pruner's `min_readable_version = 9,000`, so it prunes values with `stale_since_version <= 9,000`
7. The value at version 8,400 is deleted (since 8,600 <= 9,000)
8. Scanner attempts to read snapshot at version 8,500
9. Scanner panics with "Value must exist." when the missing value is encountered

## Impact Explanation

This is a **High Severity** issue meeting the criteria "API crashes" and "Significant protocol violations":

1. **Tool Failure**: The snapshot scanner crashes, preventing database integrity verification and auditing
2. **State Inconsistency**: Violates the fundamental invariant that Merkle tree snapshots must be fully reconstructible from the key-value store
3. **Operational Impact**: Prevents operators from examining historical state, debugging issues, or verifying state synchronization
4. **Silent Data Loss**: The inconsistency can exist without detection until the scanner is used

While not directly affecting consensus or transaction processing, this breaks critical state verification capabilities and represents a significant protocol violation of database consistency guarantees.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is likely to occur in production because:
1. Different pruning windows are a valid configuration choice (by design)
2. Operators may intentionally configure smaller state_kv windows to save disk space
3. No validation prevents mismatched pruning configurations
4. The inconsistency accumulates silently over time
5. Only detected when scanning old snapshots (infrequent operation)

The scanner accepts any version as input without validation: [7](#0-6) 

## Recommendation

**Fix 1: Enforce Consistent Pruning Windows**
Add validation to ensure `state_kv_pruner.prune_window >= state_merkle_pruner.prune_window`. The state KV database must retain values at least as long as the Merkle snapshots that reference them.

**Fix 2: Add Scanner Validation**
Before scanning, verify that the requested version is within the `state_kv_pruner.min_readable_version`:
```rust
pub fn run(self) -> Result<()> {
    // Validate version is readable
    let min_readable = self.db_dir.open_ledger_db()?
        .metadata_db()
        .get_state_kv_min_readable_version()?;
    ensure!(
        self.version >= min_readable,
        "Version {} is below min_readable_version {}. Values may have been pruned.",
        self.version,
        min_readable
    );
    // ... rest of function
}
```

**Fix 3: Coordinate Pruner Progress**
Modify the state KV pruner to check the oldest existing Merkle snapshot before pruning values, ensuring no referenced values are deleted.

## Proof of Concept

**Setup:**
1. Configure node with:
   - `state_kv_pruner.prune_window = 100`
   - `state_merkle_pruner.prune_window = 200`
   - `state_kv_pruner.enable = true`
   - `state_merkle_pruner.enable = true`

2. Run blockchain to version 500+
3. Wait for pruning to complete
4. Attempt to scan snapshot at version 250:
   ```bash
   aptos-debugger scan-snapshot --version 250 --db-dir /path/to/db
   ```

**Expected Result:** Scanner panics with "Value must exist." when encountering a leaf whose value was pruned.

**Verification:**
Check pruner progress metrics:
- `state_kv_pruner.min_readable` ≈ 400 (500 - 100)
- `state_merkle_pruner.min_readable` ≈ 300 (500 - 200)

Snapshot at version 250 exists in state_merkle_db but referenced values at versions < 300 may be missing from state_kv_db if they were superseded before version 400.

### Citations

**File:** config/src/config/storage_config.rs (L327-341)
```rust
pub struct LedgerPrunerConfig {
    /// Boolean to enable/disable the ledger pruner. The ledger pruner is responsible for pruning
    /// everything else except for states (e.g. transactions, events etc.)
    pub enable: bool,
    /// This is the default pruning window for any other store except for state store. State store
    /// being big in size, we might want to configure a smaller window for state store vs other
    /// store.
    pub prune_window: u64,
    /// Batch size of the versions to be sent to the ledger pruner - this is to avoid slowdown due to
    /// issuing too many DB calls and batch prune instead. For ledger pruner, this means the number
    /// of versions to prune a time.
    pub batch_size: usize,
    /// The offset for user pruning window to adjust
    pub user_pruning_window_offset: u64,
}
```

**File:** config/src/config/storage_config.rs (L345-353)
```rust
pub struct StateMerklePrunerConfig {
    /// Boolean to enable/disable the state merkle pruner. The state merkle pruner is responsible
    /// for pruning state tree nodes.
    pub enable: bool,
    /// Window size in versions.
    pub prune_window: u64,
    /// Number of stale nodes to prune a time.
    pub batch_size: usize,
}
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L128-142)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["state_kv_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
    }
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs (L159-174)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());

        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&[S::name(), "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
    }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs (L54-65)
```rust
        let mut iter = self
            .db_shard
            .iter::<StaleStateValueIndexByKeyHashSchema>()?;
        iter.seek(&current_progress)?;
        for item in iter {
            let (index, _) = item?;
            if index.stale_since_version > target_version {
                break;
            }
            batch.delete::<StaleStateValueIndexByKeyHashSchema>(&index)?;
            batch.delete::<StateValueByKeyHashSchema>(&(index.state_key_hash, index.version))?;
        }
```

**File:** storage/aptosdb/src/db_debugger/state_kv/scan_snapshot.rs (L28-29)
```rust
    #[clap(long)]
    version: Version,
```

**File:** storage/aptosdb/src/db_debugger/state_kv/scan_snapshot.rs (L85-111)
```rust
                            let (value_version, value) = if enable_sharding {
                                let mut iter = state_kv_db
                                    .db_shard(key.get_shard_id())
                                    .iter::<StateValueByKeyHashSchema>()
                                    .unwrap();
                                iter.seek(&(key.hash(), key_version)).unwrap();
                                iter.next()
                                    .transpose()
                                    .unwrap()
                                    .and_then(|((_, version), value_opt)| {
                                        value_opt.map(|value| (version, value))
                                    })
                                    .expect("Value must exist.")
                            } else {
                                let mut iter = state_kv_db
                                    .db_shard(key.get_shard_id())
                                    .iter::<StateValueSchema>()
                                    .unwrap();
                                iter.seek(&(key.clone(), key_version)).unwrap();
                                iter.next()
                                    .transpose()
                                    .unwrap()
                                    .and_then(|((_, version), value_opt)| {
                                        value_opt.map(|value| (version, value))
                                    })
                                    .expect("Value must exist.")
                            };
```
