# Audit Report

## Title
Undocumented Dependency on libsecp256k1 Signature Normalization Behavior Breaks Transaction Validation Under Library Updates

## Summary
The secp256k1_ecdsa wrapper module makes a critical undocumented assumption about libsecp256k1's signature normalization behavior without defensive validation. If the library is updated to produce high-s signatures (non-normalized), all newly signed transactions would fail verification, causing network-wide transaction validation failures and potential consensus disruption.

## Finding Description

The wrapper module at `crates/aptos-crypto/src/secp256k1_ecdsa.rs` creates a brittle dependency on libsecp256k1's internal behavior through three critical code points:

**1. Assumed Signature Normalization During Signing:** [1](#0-0) 

The signing function directly wraps the library's output without any normalization, relying on an undocumented assumption stated in the comment: "libsecp256k1 ensures that the s in signature is normalized".

**2. Explicit High-S Rejection During Verification:** [2](#0-1) 

The verification function explicitly checks and rejects high-s signatures to prevent malleability attacks.

**3. Consensus-Critical Transaction Validation Path:** [3](#0-2) 

This signature verification is called during transaction validation in the VM, making it consensus-critical. [4](#0-3) [5](#0-4) 

**The Vulnerability:**

If libsecp256k1 (currently version 0.7.0) is updated to a version that changes its signing behavior to produce high-s signatures: [6](#0-5) 

1. The signing function would produce high-s signatures
2. The verification function would reject them as invalid
3. All transactions signed with the updated library would fail validation
4. Transaction validation breaks, causing consensus disruption

The malleability test confirms this behavior: [7](#0-6) 

## Impact Explanation

**Severity: High**

While this vulnerability cannot be exploited by an external attacker directly, it creates a **critical protocol safety risk** during routine maintenance:

1. **Transaction Validation Failure**: All newly signed transactions would fail the consensus-critical validation path, breaking the Transaction Validation invariant
2. **Network Disruption**: If validators update and restart during a rolling deployment with an incompatible library version, transaction processing halts
3. **Consensus Risk**: Mixed library versions during deployment could cause validators to disagree on transaction validity, violating Deterministic Execution
4. **Hidden Dependency**: The assumption is only documented in a code comment, not validated or tested against library changes

This qualifies as **High Severity** under the bug bounty program criteria: "Significant protocol violations" that could cause "Validator node slowdowns" or transaction processing failures.

## Likelihood Explanation

**Likelihood: Medium**

While this requires a library update to trigger:

1. **Security Updates Are Common**: libsecp256k1 may receive security patches requiring urgent updates
2. **Untested Assumption**: No defensive validation exists to catch this during testing
3. **Cross-Platform Risk**: Different platforms or compilation flags might produce different signature types
4. **SDK Update Risk**: If client SDKs update independently, user transactions could fail unexpectedly

The risk is real because cryptographic libraries DO evolve their APIs and behavior for security reasons, and this dependency is neither documented in the library's public API contract nor defensively validated in the wrapper.

## Recommendation

Add explicit signature normalization after signing to eliminate the dependency on library behavior:

```rust
fn sign(&self, message: &libsecp256k1::Message) -> Signature {
    let (mut signature, _recovery_id) = libsecp256k1::sign(message, &self.0);
    
    // Defensive normalization: ensure low-s regardless of library behavior
    if signature.s.is_high() {
        signature.s = -signature.s;
    }
    
    Signature(signature)
}
```

Additionally:
1. Document the normalization requirement in the module documentation
2. Add integration tests that verify signature normalization across library updates
3. Pin the exact libsecp256k1 version with a comment explaining the behavioral dependency
4. Add CI checks that verify library behavior before accepting version updates

## Proof of Concept

The following test demonstrates the vulnerability would manifest if the library behavior changes:

```rust
#[test]
fn test_library_behavior_assumption() {
    use crate::secp256k1_ecdsa::{PrivateKey, PublicKey};
    use crate::{SigningKey, Uniform};
    use rand_core::OsRng;
    
    let mut rng = OsRng;
    let message = b"Test transaction";
    let key_pair = KeyPair::<PrivateKey, PublicKey>::generate(&mut rng);
    
    // Current behavior: library produces low-s signatures
    let signature = key_pair.private_key.sign_arbitrary_message(message);
    assert!(!signature.0.s.is_high(), "Library should produce low-s signatures");
    assert!(signature.verify_arbitrary_msg(message, &key_pair.public_key).is_ok());
    
    // Simulated future behavior: if library produces high-s
    let mut high_sig = signature.clone();
    high_sig.0.s = -high_sig.0.s;
    assert!(high_sig.0.s.is_high(), "Simulated high-s signature");
    
    // This would fail verification, breaking transaction validation
    assert!(high_sig.verify_arbitrary_msg(message, &key_pair.public_key).is_err(),
        "High-s signatures are rejected, but library might produce them in future versions");
}
```

## Notes

This vulnerability represents a **defensive coding gap** rather than an immediately exploitable attack vector. The security assumption on external library behavior is implicit rather than enforced, creating maintainability and safety risks that could manifest during routine updates. The fix is straightforward and should be implemented before any libsecp256k1 version updates are considered.

### Citations

**File:** crates/aptos-crypto/src/secp256k1_ecdsa.rs (L47-60)
```rust
    fn sign(&self, message: &libsecp256k1::Message) -> Signature {
        let (signature, _recovery_id) = libsecp256k1::sign(message, &self.0);
        Signature(signature)
    }

    /// Private function aimed at minimizing code duplication between sign
    /// methods of the SigningKey implementation. This should remain private.
    #[cfg(any(test, feature = "fuzzing"))]
    fn sign_arbitrary_message(&self, message: &[u8]) -> Signature {
        let message =
            bytes_to_message(message).expect("Consistently hashed to 32-bytes, should never fail.");
        // libsecp256k1 ensures that the s in signature is normalized
        self.sign(&message)
    }
```

**File:** crates/aptos-crypto/src/secp256k1_ecdsa.rs (L209-223)
```rust
    fn verify(
        &self,
        message: &libsecp256k1::Message,
        public_key: &libsecp256k1::PublicKey,
    ) -> Result<()> {
        // Prevent malleability attacks, low order only. The library only signs in low
        // order, so this was done intentionally.
        if self.0.s.is_high() {
            Err(anyhow!(CryptoMaterialError::CanonicalRepresentationError))
        } else if libsecp256k1::verify(message, &self.0, public_key) {
            Ok(())
        } else {
            Err(anyhow!("Unable to verify signature."))
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3232-3237)
```rust
        let txn = match transaction.check_signature() {
            Ok(t) => t,
            _ => {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            },
        };
```

**File:** types/src/transaction/mod.rs (L1310-1313)
```rust
    pub fn check_signature(self) -> Result<SignatureCheckedTransaction> {
        self.authenticator.verify(&self.raw_txn)?;
        Ok(SignatureCheckedTransaction(self))
    }
```

**File:** types/src/transaction/authenticator.rs (L1297-1299)
```rust
            (Self::Secp256k1Ecdsa { signature }, AnyPublicKey::Secp256k1Ecdsa { public_key }) => {
                signature.verify(message, public_key)
            },
```

**File:** Cargo.toml (L678-678)
```text
libsecp256k1 = "0.7.0"
```

**File:** crates/aptos-crypto/src/unit_tests/secp256k1_ecdsa_test.rs (L98-112)
```rust
    let mut high_signature = signature.clone();
    high_signature.0.s = -high_signature.0.s;
    let high_signature_bytes = high_signature.to_bytes();

    // We can load
    secp256k1_ecdsa::Signature::try_from(&high_signature_bytes[..]).unwrap();

    // Ensure this is now high.
    assert!(!signature.0.s.is_high());
    assert!(high_signature.0.s.is_high());
    assert!(high_signature.0.s != signature.0.s);
    high_signature
        .verify_arbitrary_msg(message, &key_pair.public_key)
        .unwrap_err();
}
```
