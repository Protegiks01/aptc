# Audit Report

## Title
Race Condition in Faucet Rate Limiter Due to Relaxed Memory Ordering Allows Rate Limit Bypass

## Summary
The `clear_if_new_day()` function in the faucet's memory-based rate limiter uses `Relaxed` atomic memory ordering when updating the `current_day` field. This creates a race condition where the new day value can become visible to other threads before the request cache is cleared, allowing concurrent threads to observe inconsistent state and bypass daily rate limits. [1](#0-0) 

## Finding Description

The vulnerability stems from a Time-of-Check to Time-of-Use (TOCTOU) race condition in the daily rate limit reset logic. The function performs three operations:

1. Check if a new day has started (line 54-55)
2. Update `current_day` atomically with `Relaxed` ordering (line 57-60)
3. Clear the IP address request cache (line 61) [2](#0-1) 

**The Problem**: `Relaxed` memory ordering provides no synchronization guarantees between threads. While it ensures sequential consistency for operations on the same atomic variable within a single thread, it does NOT establish a happens-before relationship between the atomic store at line 59 and the cache clear at line 61. This means:

- Thread A can store the new day value (line 59)
- Thread B can observe this new value (line 55)  
- But the cache may not yet be cleared by Thread A

**Exploitation Scenario**:

At midnight (day boundary), when the day changes from N to N+1:

1. **Thread A** (first request after midnight):
   - Checks condition: day N+1 > day N → TRUE
   - Stores N+1 to `current_day` with Relaxed ordering
   - **[PREEMPTED before line 61]**

2. **Thread B** (concurrent request from same IP):
   - Checks condition: Loads `current_day` → sees N+1 (from Thread A)
   - Evaluates: day N+1 > day N+1 → FALSE
   - Skips the cache clear
   - Acquires lock and accesses cache
   - Sees OLD request count from day N
   - Either incorrectly rejects (if quota exhausted) or allows and increments stale counter

3. **Thread A** (resumes):
   - Acquires lock and clears cache (too late)

This breaks the fundamental invariant that **rate limits reset daily**. An IP address that exhausted its quota on day N can be incorrectly denied on day N+1, or conversely, can make extra requests beyond the daily limit by racing with the cache clear. [3](#0-2) 

The faucet processes concurrent requests through the `preprocess_request` function which iterates through checkers: [4](#0-3) 

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria for the following reasons:

**Limited Funds Manipulation**: While this affects the Aptos faucet's testnet token distribution, the impact is limited to:
- Allowing certain IPs to exceed daily rate limits during the race window at day boundaries
- Incorrectly denying service to legitimate users at day boundaries
- Potential faster draining of faucet testnet resources

**State Inconsistency**: The rate limiter maintains state (request counts per IP) that becomes inconsistent with the day counter, violating the service's operational invariants.

**Scope Limitation**: This vulnerability affects only the faucet service (a testnet utility), not the core blockchain consensus, state management, or validator operations. It does not compromise:
- Mainnet funds or assets
- Consensus safety or liveness
- Blockchain state integrity
- Validator node security

The faucet's configuration shows it's designed to prevent abuse: [5](#0-4) 

## Likelihood Explanation

**High Likelihood**: This race condition will occur regularly because:

1. **Natural Trigger**: The condition triggers automatically every 24 hours at the day boundary (midnight in the TAP epoch timezone)
2. **Concurrent Access**: The faucet is a web service designed to handle concurrent requests from multiple users
3. **No Special Requirements**: Any user can trigger this by making legitimate requests near the daily limit around midnight
4. **Wide Race Window**: The window includes any concurrent requests during cache clear operations

The timing functions are deterministic: [6](#0-5) 

## Recommendation

Use proper memory ordering or restructure the code to hold the lock before updating `current_day`. The recommended fix is the double-checked locking pattern:

```rust
async fn clear_if_new_day(&self) {
    let current_day_value = days_since_tap_epoch(get_current_time_secs());
    
    // Fast path: check without lock
    if current_day_value > self.current_day.load(std::sync::atomic::Ordering::Acquire) {
        // Acquire lock before any updates
        let mut cache = self.ip_to_requests_today.lock().await;
        
        // Double-check pattern: verify condition still holds under lock
        if current_day_value > self.current_day.load(std::sync::atomic::Ordering::Relaxed) {
            cache.clear();
            // Update current_day AFTER cache is cleared, with Release ordering
            self.current_day.store(current_day_value, std::sync::atomic::Ordering::Release);
        }
    }
}
```

This ensures:
1. The cache clear happens atomically with the `current_day` update
2. `Release` ordering on store ensures the cache clear is visible before the new day value
3. `Acquire` ordering on load ensures proper synchronization
4. Double-check pattern prevents multiple threads from clearing unnecessarily

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    use std::net::IpAddr;
    use tokio::task::JoinSet;
    
    #[tokio::test]
    async fn test_race_condition_at_day_boundary() {
        // Setup: Create rate limiter with 100 requests/day limit
        let config = MemoryRatelimitCheckerConfig {
            max_requests_per_day: 100,
            max_entries_in_map: NonZeroUsize::new(1000).unwrap(),
        };
        let checker = Arc::new(MemoryRatelimitChecker::new(config));
        let test_ip: IpAddr = "1.2.3.4".parse().unwrap();
        
        // Phase 1: Exhaust quota on "day N"
        for i in 0..100 {
            let mut cache = checker.ip_to_requests_today.lock().await;
            cache.put(test_ip, i + 1);
        }
        
        // Simulate day boundary: manually advance current_day
        // (In real scenario, this happens via clear_if_new_day at midnight)
        let old_day = checker.current_day.load(std::sync::atomic::Ordering::Relaxed);
        let new_day = old_day + 1;
        
        // Phase 2: Race condition - update current_day but don't clear cache yet
        checker.current_day.store(new_day, std::sync::atomic::Ordering::Relaxed);
        // Simulate timing window where cache not yet cleared
        
        // Phase 3: Concurrent request during race window
        let checker_clone = checker.clone();
        let race_task = tokio::spawn(async move {
            checker_clone.clear_if_new_day().await;
            let cache = checker_clone.ip_to_requests_today.lock().await;
            cache.get(&test_ip).copied()
        });
        
        let result = race_task.await.unwrap();
        
        // Expected: cache should be cleared (None or reset to low count)
        // Actual with bug: May see old count of 100 even though it's a new day
        println!("Request count after race: {:?}", result);
        
        // Demonstrate the invariant violation:
        // If result is Some(100), rate limiter incorrectly denies requests on new day
    }
}
```

## Notes

**Important Context**:
- This vulnerability is limited to the **faucet service**, which distributes testnet tokens only
- It does NOT affect consensus, blockchain state, validator operations, or mainnet funds
- The faucet is a utility service for development and testing, not a core blockchain component
- Impact is restricted to potential abuse of testnet token distribution and denial of service to legitimate testnet users during daily reset windows
- While technically valid as a race condition bug, the real-world security impact is low since it only affects a testnet utility service

The vulnerability is valid and exploitable, but its scope is limited to rate limiting enforcement in a non-critical service component.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L15-21)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MemoryRatelimitCheckerConfig {
    pub max_requests_per_day: u32,

    #[serde(default = "MemoryRatelimitCheckerConfig::default_max_entries_in_map")]
    pub max_entries_in_map: NonZeroUsize,
}
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L53-63)
```rust
    async fn clear_if_new_day(&self) {
        if days_since_tap_epoch(get_current_time_secs())
            > self.current_day.load(std::sync::atomic::Ordering::Relaxed)
        {
            self.current_day.store(
                days_since_tap_epoch(get_current_time_secs()),
                std::sync::atomic::Ordering::Relaxed,
            );
            self.ip_to_requests_today.lock().await.clear();
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L75-88)
```rust
        let mut ip_to_requests_today = self.ip_to_requests_today.lock().await;

        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-270)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }
```

**File:** crates/aptos-faucet/core/src/helpers.rs (L19-35)
```rust
pub fn get_current_time_secs() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time has gone backwards???")
        .as_secs()
}

/// This unixtime is 12:01am PDT on 2021-09-25. See the docstring for
/// RedisRatelimitChecker for more information on how we use this value.
/// We also use this in MemoryRatelimitChecker in a similar way.
pub const TAP_EPOCH_SECS: u64 = 1664089260;

/// Get the number of days since the tap epoch. See the docstring for
/// RedisRatelimitChecker.
pub fn days_since_tap_epoch(current_time_secs: u64) -> u64 {
    (current_time_secs - TAP_EPOCH_SECS) / 86400
}
```
