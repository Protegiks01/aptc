# Audit Report

## Title
Encrypted Transaction Confidentiality Breach via Payload Hash Enumeration Attack

## Summary
The `EncryptedPayload::Encrypted` structure exposes a `payload_hash` field that contains the SHA3-256 hash of the plaintext transaction payload. For transactions with limited entropy (e.g., governance votes, standard token transfers with predictable parameters), an attacker can enumerate possible transactions, compute their hashes, and match against the exposed `payload_hash` to determine the transaction content before decryption, breaking confidentiality guarantees.

## Finding Description

The `EncryptedPayload` enum defines three variants, with the `Encrypted` variant containing a publicly visible `payload_hash` field: [1](#0-0) 

This `payload_hash` is intended to represent the SHA3-256 hash of the `DecryptedPayload` structure (containing the `TransactionExecutable` and `decryption_nonce`). The hash is transmitted in plaintext as part of the serialized transaction and is visible to all network participants before decryption. [2](#0-1) 

During transaction submission via the API, the only validation performed is verification that the ciphertext is properly signed and associated with the correct sender: [3](#0-2) [4](#0-3) 

The ciphertext verification only checks the signature and associated data binding, not the payload_hash: [5](#0-4) 

During consensus decryption, the encrypted payload is decrypted but there is **no validation** that the decrypted payload matches the stored `payload_hash`: [6](#0-5) 

The `into_decrypted()` method simply accepts the decrypted executable and nonce without verifying they hash to the stored `payload_hash`: [7](#0-6) 

**Attack Scenario:**

1. **Transaction Space with Limited Entropy**: Consider a governance vote transaction where users vote on proposal #42 (yes/no). The `TransactionExecutable` would be `EntryFunction(vote, [42, true])` or `EntryFunction(vote, [42, false])`.

2. **Hash Enumeration**: An attacker observing an encrypted transaction with `payload_hash = H` can:
   - Enumerate: `DecryptedPayload{executable: vote(42, true), nonce: n}` for various nonce values
   - Enumerate: `DecryptedPayload{executable: vote(42, false), nonce: n}` for various nonce values
   - Compute SHA3-256 hashes of BCS-serialized payloads
   - Match against observed `payload_hash = H`

3. **Confidentiality Breach**: When a match is found, the attacker knows the vote content **before decryption**, breaking the confidentiality guarantee of encrypted transactions.

This is particularly severe for:
- **Governance votes**: Limited options (approve/reject)
- **Token transfers**: Predictable recipients and amounts
- **Validator operations**: Limited set of actions
- **DeFi operations**: Common operations with known parameters

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos Bug Bounty)

This vulnerability breaks the **confidentiality guarantee** of encrypted transactions, which is a fundamental security property. While it doesn't directly cause loss of funds, it enables:

1. **Privacy Violations**: User transaction content is revealed before execution
2. **Front-Running**: Attackers can front-run transactions after determining their content
3. **MEV Extraction**: Miners/validators can extract value by knowing transaction content early
4. **Governance Manipulation**: Voting strategies can be revealed before proposal execution
5. **Competitive Disadvantage**: Trading strategies and DeFi operations become transparent

The impact is classified as Medium because:
- It requires low-entropy transaction space to be exploitable
- It doesn't directly steal funds but breaks privacy guarantees
- It affects state consistency by violating confidentiality invariants
- It may require intervention to fix affected transactions

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Always Exposed**: The `payload_hash` is part of the public transaction structure and is always visible to observers, mempool operators, and validators.

2. **Common Transaction Patterns**: Many blockchain transactions have inherently low entropy:
   - Governance votes (2 choices per proposal)
   - Standard transfers (limited recipient set, common amounts like 100, 1000, etc.)
   - Staking operations (stake/unstake to known validators)
   - DeFi operations (swap on known DEXes, predictable amounts)

3. **Predictable Nonces**: If `decryption_nonce` values are sequential or predictable, the attack space becomes even smaller.

4. **No Special Access Required**: Any network participant can observe transactions and perform this attack. No validator collusion or special privileges needed.

5. **Low Computational Cost**: Enumerating small message spaces and computing SHA3-256 hashes is trivial on modern hardware.

## Recommendation

**Solution 1: Remove payload_hash from EncryptedPayload**

The `payload_hash` field should be removed entirely from the `EncryptedPayload::Encrypted` variant. If hash verification is needed, it should only be computed and validated internally after decryption, never exposed publicly.

**Solution 2: Replace with Commitment Scheme**

If a hash must be included for integrity purposes, use a commitment scheme that includes a random salt:
- `commitment = SHA3-256(payload || random_salt)`
- Store both `commitment` and `random_salt` (encrypted with the payload)
- After decryption, verify: `SHA3-256(decrypted_payload || decrypted_salt) == commitment`

**Solution 3: Add Post-Decryption Validation**

At minimum, add validation that the decrypted payload matches the stored hash to prevent malicious decryption, though this doesn't solve the confidentiality breach.

**Recommended Fix:**

Modify `encrypted_payload.rs`:
- Remove `payload_hash` from public `Encrypted` variant
- Add internal validation after decryption using ciphertext authentication
- Rely on the existing `Ciphertext` signature mechanism for integrity

## Proof of Concept

```rust
#[cfg(test)]
mod payload_hash_attack_test {
    use super::*;
    use aptos_crypto::HashValue;
    use move_core_types::{account_address::AccountAddress, identifier::Identifier};
    
    #[test]
    fn test_governance_vote_enumeration_attack() {
        // Simulate a governance vote transaction
        let proposal_id = 42u64;
        let decryption_nonce = 12345u64;
        
        // Two possible votes
        let vote_yes = TransactionExecutable::EntryFunction(
            EntryFunction::new(
                ModuleId::new(AccountAddress::ONE, Identifier::new("governance").unwrap()),
                Identifier::new("vote").unwrap(),
                vec![],
                vec![
                    bcs::to_bytes(&proposal_id).unwrap(),
                    bcs::to_bytes(&true).unwrap(),
                ],
            )
        );
        
        let vote_no = TransactionExecutable::EntryFunction(
            EntryFunction::new(
                ModuleId::new(AccountAddress::ONE, Identifier::new("governance").unwrap()),
                Identifier::new("vote").unwrap(),
                vec![],
                vec![
                    bcs::to_bytes(&proposal_id).unwrap(),
                    bcs::to_bytes(&false).unwrap(),
                ],
            )
        );
        
        // Create DecryptedPayloads
        let payload_yes = DecryptedPayload {
            executable: vote_yes.clone(),
            decryption_nonce,
        };
        
        let payload_no = DecryptedPayload {
            executable: vote_no.clone(),
            decryption_nonce,
        };
        
        // Compute hashes (what would be stored in payload_hash)
        let hash_yes = HashValue::sha3_256_of(&bcs::to_bytes(&payload_yes).unwrap());
        let hash_no = HashValue::sha3_256_of(&bcs::to_bytes(&payload_no).unwrap());
        
        // Simulate attacker observing an encrypted transaction with payload_hash = hash_yes
        let observed_hash = hash_yes;
        
        // Attacker enumerates possible votes
        println!("Attacker observes payload_hash: {:?}", observed_hash);
        
        if hash_yes == observed_hash {
            println!("ATTACK SUCCESS: Vote is YES");
            println!("Transaction content revealed before decryption!");
            assert_eq!(hash_yes, observed_hash);
        } else if hash_no == observed_hash {
            println!("ATTACK SUCCESS: Vote is NO");
            println!("Transaction content revealed before decryption!");
        }
        
        // This demonstrates that with only 2 possibilities, an attacker can
        // determine the vote content by simply computing and comparing hashes
    }
}
```

## Notes

1. **This is not a cryptographic weakness in SHA3-256** - the hash function is secure. The vulnerability lies in the **system design** that exposes a hash of potentially low-entropy data alongside the ciphertext.

2. **Related Issue**: There is also no validation that the decrypted payload matches the stored `payload_hash` during the decryption process, which could allow malicious validators to provide incorrect decryptions. However, this is a separate concern from the confidentiality breach.

3. **Affected Transactions**: The vulnerability is most severe for transactions with inherently limited message spaces, including governance votes, standard token transfers with predictable parameters, and common DeFi operations.

4. **Defense Difficulty**: Since `EncryptedPayload` implements `Serialize`/`Deserialize` and is part of the public API, the `payload_hash` field is always transmitted and visible to network observers, making this vulnerability difficult to mitigate without a protocol change.

### Citations

**File:** types/src/transaction/encrypted_payload.rs (L14-24)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct DecryptedPayload {
    executable: TransactionExecutable,
    decryption_nonce: u64,
}

impl DecryptedPayload {
    pub fn unwrap(self) -> (TransactionExecutable, u64) {
        (self.executable, self.decryption_nonce)
    }
}
```

**File:** types/src/transaction/encrypted_payload.rs (L42-64)
```rust
pub enum EncryptedPayload {
    Encrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
    },
    FailedDecryption {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,
    },
    Decrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,

        // decrypted things
        executable: TransactionExecutable,
        decryption_nonce: u64,
    },
}
```

**File:** types/src/transaction/encrypted_payload.rs (L101-125)
```rust
    pub fn into_decrypted(
        &mut self,
        eval_proof: EvalProof,
        executable: TransactionExecutable,
        nonce: u64,
    ) -> anyhow::Result<()> {
        let Self::Encrypted {
            ciphertext,
            extra_config,
            payload_hash,
        } = self
        else {
            bail!("Payload is not in Encrypted state");
        };

        *self = Self::Decrypted {
            ciphertext: ciphertext.clone(),
            extra_config: extra_config.clone(),
            payload_hash: *payload_hash,
            eval_proof,
            executable,
            decryption_nonce: nonce,
        };
        Ok(())
    }
```

**File:** types/src/transaction/encrypted_payload.rs (L147-151)
```rust
    pub fn verify(&self, sender: AccountAddress) -> anyhow::Result<()> {
        let associated_data = PayloadAssociatedData::new(sender);
        self.ciphertext().verify(&associated_data)
    }
}
```

**File:** api/src/transactions.rs (L1323-1347)
```rust
            TransactionPayload::EncryptedPayload(payload) => {
                if !self.context.node_config.api.allow_encrypted_txns_submission {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        "Encrypted Transaction submission is not allowed yet",
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }

                if !payload.is_encrypted() {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        "Encrypted transaction must be in encrypted state",
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }

                if let Err(e) = payload.verify(signed_transaction.sender()) {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        e.context("Encrypted transaction payload could not be verified"),
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }
            },
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L111-132)
```rust
    pub fn verify(&self, associated_data: &impl AssociatedData) -> Result<()> {
        let hashed_id = Id::from_verifying_key(&self.vk);

        (self.bibe_ct.id() == hashed_id).then_some(()).ok_or(
            BatchEncryptionError::CTVerifyError(CTVerifyError::IdDoesNotMatchHashedVK),
        )?;
        (self.associated_data_bytes == bcs::to_bytes(associated_data)?)
            .then_some(())
            .ok_or(BatchEncryptionError::CTVerifyError(
                CTVerifyError::AssociatedDataDoesNotMatch,
            ))?;

        let to_verify = (&self.bibe_ct, &self.associated_data_bytes);

        self.vk
            .verify(&bcs::to_bytes(&to_verify)?, &self.signature)
            .map_err(|e| {
                BatchEncryptionError::CTVerifyError(CTVerifyError::SigVerificationFailed(e))
            })?;

        Ok(())
    }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L121-148)
```rust
        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```
