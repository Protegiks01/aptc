# Audit Report

## Title
Stale NFT Ownership Data in Burn Attribution Due to Incomplete `prior_nft_ownership` Tracking

## Summary
The `parse_v2_token()` function fails to update `prior_nft_ownership` when NFT transfers occur via ObjectCore-only WriteResource changes. When a subsequent burn happens in the same batch, the fallback database query returns stale ownership data from the previous batch, causing incorrect burn attribution.

## Finding Description

The vulnerability exists in the indexer's token processing logic. The `prior_nft_ownership` HashMap is designed to track NFT ownership changes within a transaction batch to correctly attribute burns. [1](#0-0) 

This map is only updated when specific resource types are encountered during processing. For V2 NFTs, updates occur when a `0x4::token::Token` resource is written: [2](#0-1) 

However, in the Aptos Object model, NFT transfers only update the `owner` field in the `ObjectCore` resource, not the `Token` resource: [3](#0-2) 

The `Token` resource contains metadata (name, description, URI) that doesn't change during transfers. Therefore, when processing a transfer WriteResource:

1. The ObjectCore WriteResource is encountered
2. `TokenDataV2::get_v2_from_write_resource()` is called but returns `None` because the resource type is `0x1::object::ObjectCore`, not `0x4::token::Token`: [4](#0-3) [5](#0-4) 

3. The code block that updates `prior_nft_ownership` is skipped
4. Later, when a burn occurs via DeleteResource, `get_burned_nft_v2_from_delete_resource()` checks `prior_nft_ownership` first: [6](#0-5) 

5. When not found in `prior_nft_ownership`, it falls back to querying the database
6. The database query returns ownership from the PREVIOUS batch (before the transfer), not the current ownership
7. The burn is attributed to the wrong owner

**Attack Scenario:**
- Batch N contains:
  - Transaction 100: Alice transfers NFT to Bob (only ObjectCore.owner updated)
  - Transaction 101: Bob burns the NFT
- When processing:
  - Transaction 100: `prior_nft_ownership` NOT updated (ObjectCore is not Token resource)
  - Transaction 101: Burn processing queries database, finds Alice as owner
  - **Burn incorrectly attributed to Alice instead of Bob**

## Impact Explanation

This vulnerability causes data integrity issues in the Aptos indexer, which is critical infrastructure that many applications depend on:

- **NFT Marketplaces**: Display incorrect ownership history and burn events
- **Analytics Platforms**: Report incorrect burn statistics and owner attribution
- **Wallet Applications**: Show wrong ownership transitions
- **Legal/Compliance**: Incorrect audit trails for NFT ownership

While this doesn't directly affect on-chain consensus or cause loss of funds, it corrupts off-chain data that applications use for critical business logic. Per the Aptos bug bounty criteria, this could qualify as **Medium Severity** under "State inconsistencies requiring intervention" or potentially **High Severity** given the criticality of indexer data for the ecosystem.

## Likelihood Explanation

This vulnerability is **highly likely** to occur in production because:

1. **Normal Usage Pattern**: NFT transfers followed by burns in the same block/batch are common (e.g., burn-to-upgrade mechanisms, immediate disposal after purchase)
2. **Design Flaw**: The code incorrectly assumes that all ownership changes will be accompanied by Token resource updates
3. **No Mitigation**: There are no checks or fallbacks to detect this mismatch
4. **Batch Processing**: The indexer processes transactions in batches, creating multiple opportunities for this race condition within each batch

## Recommendation

**Fix 1: Track ObjectCore ownership changes**

Modify `parse_v2_token()` to detect ObjectCore updates for known NFT objects and update `prior_nft_ownership` accordingly. When processing WriteResource changes, check if ObjectCore.owner changed and the address corresponds to a known token:

```rust
// After line 1114 in token_processor.rs, add:
if let Some(object_core) = ObjectCore::from_write_resource(wr, txn_version).unwrap() {
    let address = standardize_address(&wr.address.to_string());
    // Check if this is a known token by looking it up in token_v2_metadata_helper
    if let Some(metadata) = token_v2_metadata_helper.get(&address) {
        if let Some(token) = &metadata.token {
            // This is a token object - track the ownership change
            prior_nft_ownership.insert(
                address.clone(),
                NFTOwnershipV2 {
                    token_data_id: address,
                    owner_address: object_core.get_owner_address(),
                    is_soulbound: Some(!object_core.allow_ungated_transfer),
                },
            );
        }
    }
}
```

**Fix 2: Improve fallback query logic**

When falling back to the database query, check if the token exists in `current_token_ownerships_v2` (which would be updated in the current batch's pending inserts) or add a warning log when database ownership doesn't match recent events.

## Proof of Concept

**Scenario Setup:**
1. Create an NFT and mint to Alice at transaction version 1000
2. In a new batch starting at version 2000:
   - Transaction 2000: Alice transfers NFT to Bob (only ObjectCore updated)
   - Transaction 2001: Bob burns NFT
3. Process the batch through the indexer

**Expected Behavior:**
- Burn should be attributed to Bob (current owner)

**Actual Behavior:**
- `prior_nft_ownership` is not updated during transaction 2000 processing
- When processing burn at transaction 2001, fallback database query returns Alice
- Burn incorrectly attributed to Alice

**Reproduction Steps:**
```rust
// In a Move test module:
#[test(creator = @0xcafe, alice = @0xa11ce, bob = @0xb0b)]
public fun test_burn_attribution(creator: &signer, alice: &signer, bob: &signer) {
    // Setup: Create and mint NFT to Alice
    let token_addr = create_nft(creator, alice); // version 1000
    
    // Transaction 2000: Transfer from Alice to Bob (only ObjectCore changes)
    object::transfer(alice, token_addr, @0xb0b); 
    
    // Transaction 2001: Bob burns the NFT
    burn_token(bob, token_addr);
    
    // Query indexer database - will show Alice as burn owner (incorrect)
    // Should show Bob as burn owner (correct)
}
```

The indexer's `current_token_ownerships_v2` table will show:
- `owner_address`: Alice (incorrect)
- `amount`: 0 (correct - burned)

Instead of:
- `owner_address`: Bob (correct)
- `amount`: 0 (correct - burned)

## Notes

This vulnerability is specific to the **indexer component** of Aptos Core, which processes blockchain data for off-chain querying. While it doesn't affect on-chain consensus or state (which remains correct), it corrupts the indexer database that applications depend on for accurate NFT ownership history and burn attribution.

The root cause is an architectural mismatch: the Aptos Object model stores ownership in `ObjectCore` and metadata in `Token`, but the indexer assumes ownership changes always involve `Token` resource updates.

### Citations

**File:** crates/indexer/src/processors/token_processor.rs (L1068-1068)
```rust
    let mut prior_nft_ownership: HashMap<String, NFTOwnershipV2> = HashMap::new();
```

**File:** crates/indexer/src/processors/token_processor.rs (L1345-1377)
```rust
                        if let Some((token_data, current_token_data)) =
                            TokenDataV2::get_v2_from_write_resource(
                                resource,
                                txn_version,
                                wsc_index,
                                txn_timestamp,
                                &token_v2_metadata_helper,
                            )
                            .unwrap()
                        {
                            // Add NFT ownership
                            if let Some(inner) = TokenOwnershipV2::get_nft_v2_from_token_data(
                                &token_data,
                                &token_v2_metadata_helper,
                            )
                            .unwrap()
                            {
                                let (
                                    nft_ownership,
                                    current_nft_ownership,
                                    from_nft_ownership,
                                    from_current_nft_ownership,
                                ) = inner;
                                token_ownerships_v2.push(nft_ownership);
                                // this is used to persist latest owner for burn event handling
                                prior_nft_ownership.insert(
                                    current_nft_ownership.token_data_id.clone(),
                                    NFTOwnershipV2 {
                                        token_data_id: current_nft_ownership.token_data_id.clone(),
                                        owner_address: current_nft_ownership.owner_address.clone(),
                                        is_soulbound: current_nft_ownership.is_soulbound_v2,
                                    },
                                );
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L548-571)
```text
    inline fun transfer_raw_inner(object: address, to: address) {
        let object_core = borrow_global_mut<ObjectCore>(object);
        if (object_core.owner != to) {
            if (std::features::module_event_migration_enabled()) {
                event::emit(
                    Transfer {
                        object,
                        from: object_core.owner,
                        to,
                    },
                );
            } else {
                event::emit_event(
                    &mut object_core.transfer_events,
                    TransferEvent {
                        object,
                        from: object_core.owner,
                        to,
                    },
                );
            };
            object_core.owner = to;
        };
    }
```

**File:** crates/indexer/src/models/token_models/v2_token_datas.rs (L83-109)
```rust
        if let Some(inner) = &TokenV2::from_write_resource(write_resource, txn_version)? {
            let token_data_id = standardize_address(&write_resource.address.to_string());
            // Get maximum, supply, and is fungible from fungible asset if this is a fungible token
            let (mut maximum, mut supply, mut decimals, mut is_fungible_v2) =
                (None, BigDecimal::zero(), 0, Some(false));
            // Get token properties from 0x4::property_map::PropertyMap
            let mut token_properties = serde_json::Value::Null;
            if let Some(metadata) = token_v2_metadata.get(&token_data_id) {
                let fungible_asset_metadata = metadata.fungible_asset_metadata.as_ref();
                let fungible_asset_supply = metadata.fungible_asset_supply.as_ref();
                if let Some(metadata) = fungible_asset_metadata {
                    if let Some(fa_supply) = fungible_asset_supply {
                        maximum = fa_supply.get_maximum();
                        supply = fa_supply.current.clone();
                        decimals = metadata.decimals as i64;
                        is_fungible_v2 = Some(true);
                    }
                }
                token_properties = metadata
                    .property_map
                    .as_ref()
                    .map(|m| m.inner.clone())
                    .unwrap_or(token_properties);
            } else {
                // ObjectCore should not be missing, returning from entire function early
                return Ok(None);
            }
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L204-231)
```rust
    pub fn from_write_resource(
        write_resource: &WriteResource,
        txn_version: i64,
    ) -> anyhow::Result<Option<Self>> {
        let type_str = format!(
            "{}::{}::{}",
            write_resource.data.typ.address,
            write_resource.data.typ.module,
            write_resource.data.typ.name
        );
        if !V2TokenResource::is_resource_supported(type_str.as_str()) {
            return Ok(None);
        }
        let resource = MoveResource::from_write_resource(
            write_resource,
            0, // Placeholder, this isn't used anyway
            txn_version,
            0, // Placeholder, this isn't used anyway
        );

        if let V2TokenResource::TokenV2(inner) =
            V2TokenResource::from_resource(&type_str, resource.data.as_ref().unwrap(), txn_version)?
        {
            Ok(Some(inner))
        } else {
            Ok(None)
        }
    }
```

**File:** crates/indexer/src/models/token_models/v2_token_ownerships.rs (L287-306)
```rust
            let latest_nft_ownership: NFTOwnershipV2 = match prior_nft_ownership.get(token_address)
            {
                Some(inner) => inner.clone(),
                None => {
                    match CurrentTokenOwnershipV2Query::get_nft_by_token_data_id(
                        conn,
                        token_address,
                    ) {
                        Ok(nft) => nft,
                        Err(_) => {
                            aptos_logger::error!(
                                transaction_version = txn_version,
                                lookup_key = &token_address,
                                "Failed to find NFT for burned token. You probably should backfill db."
                            );
                            return Ok(None);
                        },
                    }
                },
            };
```
