# Audit Report

## Title
Trapdoor Memory Exposure: Cryptographic Secrets Not Zeroized After KZG Setup

## Summary
The trapdoor values (`xi` and `tau`) generated during the range proof setup are not zeroized from memory after use, allowing an attacker with memory read access to extract these secrets and compromise the entire DKG protocol security.

## Finding Description

The DKG range proof system uses a Hiding KZG commitment scheme that relies on a cryptographic trapdoor for setup. This trapdoor must be securely destroyed after generating the commitment and verification keys.

**Vulnerability Flow:**

1. During DKG initialization, `PublicParameters::new()` calls the range proof setup function: [1](#0-0) 

2. The setup function generates a trapdoor containing secret values: [2](#0-1) 

3. The `Trapdoor` struct contains two secret scalar field elements but has **no memory protection**: [3](#0-2) 

4. After the trapdoor is used to generate keys, it goes out of scope when setup returns, but Rust's default behavior does **not** zero the memory: [4](#0-3) 

**Critical Security Gap:**
- No `Drop` implementation for `Trapdoor` struct
- No use of `zeroize` crate in the entire aptos-dkg module
- Secret values persist in deallocated memory

**Attack Exploitation:**
An attacker who gains memory read access through:
- Memory dump (crash dump, core dump)
- Cold boot attack on validator hardware
- Malware with memory inspection capabilities
- Debugging/inspection tools on compromised nodes

Can extract the trapdoor values and use them to:
1. **Break hiding property**: Extract committed values from commitments
2. **Forge range proofs**: Create valid proofs for arbitrary values without knowing the actual values
3. **Compromise DKG security**: Undermine the entire distributed key generation protocol

Similar to how trapdoors enable proof simulation in Groth16: [5](#0-4) 

## Impact Explanation

This meets **Critical Severity** criteria because:

1. **Cryptographic Correctness Violation**: Breaks the fundamental security assumption that trapdoors are destroyed after setup, violating Invariant #10: "Cryptographic Correctness: BLS signatures, VRF, and hash operations must be secure"

2. **DKG Protocol Compromise**: The range proofs are used in the PVSS (Publicly Verifiable Secret Sharing) scheme for distributed key generation. Compromising them undermines validator security.

3. **Potential Consensus Impact**: If the DKG protocol is compromised, malicious actors could potentially manipulate validator operations, leading to consensus violations.

4. **Defense-in-Depth Failure**: Even if memory access requires prior compromise, cryptographic secrets should always be zeroized as a security best practice (CWE-316).

## Likelihood Explanation

**Likelihood Assessment: Medium-Low (but High Impact)**

**Prerequisites for exploitation:**
- Attacker must gain memory read access to a validator node
- Timing window exists while trapdoor is in memory (during and shortly after setup)

**Realistic attack scenarios:**
1. **Compromised validator node**: If a validator node is compromised by malware, the attacker gains memory access
2. **Crash dumps**: Automatic crash dumps or core dumps may contain trapdoor values
3. **Cold boot attacks**: Physical access to validator hardware enables memory extraction
4. **Container/VM escape**: In cloud deployments, container escape could provide memory access

**Note**: While this requires initial access, the lack of memory zeroization violates security best practices and significantly increases the impact of any node compromise.

## Recommendation

Implement proper memory zeroization using the `zeroize` crate:

```rust
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(CanonicalSerialize, Debug, Clone, Zeroize, ZeroizeOnDrop)]
pub struct Trapdoor<E: Pairing> {
    pub xi: E::ScalarField,
    pub tau: E::ScalarField,
}
```

Alternatively, implement a manual `Drop` trait:

```rust
impl<E: Pairing> Drop for Trapdoor<E> {
    fn drop(&mut self) {
        // Zero out the secret values
        // Note: E::ScalarField may need custom zeroization
        // depending on the underlying implementation
    }
}
```

**Additional recommendations:**
1. Add `#[must_use]` annotation to setup functions to ensure keys are not accidentally discarded
2. Document the security-critical nature of trapdoor handling
3. Consider using secure memory allocation for cryptographic secrets
4. Audit all other cryptographic secret handling in the codebase

## Proof of Concept

```rust
#[cfg(test)]
mod memory_leak_poc {
    use super::*;
    use std::ptr;
    
    #[test]
    fn test_trapdoor_memory_not_zeroed() {
        let mut rng = rand::thread_rng();
        
        // Allocate trapdoor
        let trapdoor = Box::new(Trapdoor::<ark_bn254::Bn254>::rand(&mut rng));
        let trapdoor_ptr = &*trapdoor as *const _ as *const u8;
        
        // Store original values for comparison
        let original_xi = trapdoor.xi;
        let original_tau = trapdoor.tau;
        
        // Drop the trapdoor
        drop(trapdoor);
        
        // Memory inspection: In a real attack, the attacker would scan
        // all accessible memory. This simplified POC shows the memory
        // is not zeroed after drop.
        
        // WARNING: This is undefined behavior and for demonstration only
        // In production, an attacker would use proper memory inspection tools
        unsafe {
            let leaked_data = std::slice::from_raw_parts(
                trapdoor_ptr,
                std::mem::size_of::<Trapdoor<ark_bn254::Bn254>>()
            );
            
            // Check if memory still contains the secret values
            // In a proper implementation with zeroization, this would be all zeros
            let is_zeroed = leaked_data.iter().all(|&b| b == 0);
            
            assert!(
                !is_zeroed,
                "Trapdoor memory was NOT zeroed after drop - vulnerability confirmed"
            );
        }
    }
}
```

**Note**: The PoC demonstrates the issue using unsafe memory inspection. In a real attack, an attacker with memory dump access would scan for the trapdoor pattern in memory dumps, crash dumps, or via debugging interfaces.

---

**Notes**

This vulnerability represents a critical security best practice violation. While exploitation requires memory read access (a prerequisite compromise), the failure to zeroize cryptographic secrets significantly amplifies the impact of any validator node compromise. The lack of memory protection for trapdoors is a clear violation of defense-in-depth principles and standard cryptographic hygiene. All cryptographic implementations handling secret material should use the `zeroize` crate or equivalent memory sanitization techniques.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L177-183)
```rust
            pk_range_proof: dekart_univariate_v2::Proof::setup(
                max_num_chunks_padded,
                ell as usize,
                group_generators,
                rng,
            )
            .0,
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate_v2.rs (L265-266)
```rust
        let trapdoor = univariate_hiding_kzg::Trapdoor::<E>::rand(rng);
        let xi_1_proj: E::G1 = group_generators.g1 * trapdoor.xi;
```

**File:** crates/aptos-dkg/src/pcs/univariate_hiding_kzg.rs (L87-91)
```rust
#[derive(CanonicalSerialize, Debug, Clone)]
pub struct Trapdoor<E: Pairing> {
    pub xi: E::ScalarField,
    pub tau: E::ScalarField,
}
```

**File:** crates/aptos-dkg/src/pcs/univariate_hiding_kzg.rs (L102-147)
```rust
pub fn setup<E: Pairing>(
    m: usize,
    basis_type: SrsType,
    group_generators: GroupGenerators<E>,
    trapdoor: Trapdoor<E>,
) -> (VerificationKey<E>, CommitmentKey<E>) {
    utils::assert_power_of_two(m);

    let GroupGenerators { g1, g2 } = group_generators;
    let Trapdoor { xi, tau } = trapdoor;

    let (xi_1, tau_1) = ((g1 * xi).into_affine(), (g1 * tau).into_affine());
    let (xi_2, tau_2) = ((g2 * xi).into_affine(), (g2 * tau).into_affine());

    let eval_dom = ark_poly::Radix2EvaluationDomain::<E::ScalarField>::new(m)
        .expect("Could not construct evaluation domain");

    let msm_basis = match basis_type {
        SrsType::Lagrange => SrsBasis::Lagrange {
            lagr: lagrange_basis::<E::G1>(g1.into(), tau, m, eval_dom),
        },
        SrsType::PowersOfTau => SrsBasis::PowersOfTau {
            tau_powers: powers_of_tau::<E::G1>(g1.into(), tau, m),
        },
    };

    let roots_of_unity_in_eval_dom = eval_dom.elements().collect();
    let m_inv = E::ScalarField::from(m as u64).inverse().unwrap();

    (
        VerificationKey {
            xi_2,
            tau_2,
            group_generators,
        },
        CommitmentKey {
            xi_1,
            tau_1,
            msm_basis,
            eval_dom,
            roots_of_unity_in_eval_dom,
            g1,
            m_inv,
        },
    )
}
```

**File:** types/src/keyless/proof_simulation.rs (L152-181)
```rust
    pub fn create_proof_with_trapdoor(
        pk: &Trapdoor<E>,
        a: E::ScalarField,
        b: E::ScalarField,
        public_inputs: &[E::ScalarField],
    ) -> Result<Proof<E>, SynthesisError> {
        let mut g_ic = pk.gamma_abc_g1[0].into_group();
        for (i, b) in public_inputs.iter().zip(pk.gamma_abc_g1.iter().skip(1)) {
            g_ic.add_assign(&b.mul_bigint(i.into_bigint()));
        }
        g_ic *= pk.gamma;

        let delta_inverse = pk.delta.inverse().unwrap();
        let ab = a * b;
        let alpha_beta = pk.alpha * pk.beta;

        let g1_ab = pk.g1 * ab;
        let g1_alpha_beta = pk.g1 * alpha_beta;

        let g1_a = pk.g1 * a;
        let g2_b = pk.g2 * b;

        let g1_c = (g1_ab - g1_alpha_beta - g_ic) * delta_inverse;

        Ok(Proof {
            a: g1_a.into_affine(),
            b: g2_b.into_affine(),
            c: g1_c.into_affine(),
        })
    }
```
