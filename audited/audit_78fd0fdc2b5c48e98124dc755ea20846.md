# Audit Report

## Title
gRPC Reflection Metadata Mismatch in Default Indexer Configuration Causing Service Discovery Failures

## Summary
The default indexer gRPC configuration (`use_data_service_interface=false`) exposes the `FullnodeData` service but registers gRPC reflection metadata for the `RawData` service instead. This causes clients using gRPC reflection for service discovery to see incorrect method signatures, leading to API call failures and service availability issues.

## Finding Description

The indexer gRPC service supports two different interfaces controlled by the `use_data_service_interface` configuration parameter [1](#0-0) :

1. **FullnodeData service** (when `use_data_service_interface = false`, the default [2](#0-1) )
2. **RawData service** (when `use_data_service_interface = true`)

These are two completely different gRPC services defined in separate proto files:
- `FullnodeData` with methods `Ping` and `GetTransactionsFromNode` [3](#0-2) 
- `RawData` with method `GetTransactions` [4](#0-3) 

The vulnerability occurs in the reflection service registration. The runtime registers file descriptor sets for reflection [5](#0-4) , but critically, it only registers `INDEXER_V1_FILE_DESCRIPTOR_SET` (containing the `RawData` service definition) and not the `FILE_DESCRIPTOR_SET` from `aptos.internal.fullnode.v1` (containing the `FullnodeData` service definition [6](#0-5) ).

The service selection logic then conditionally exposes only one service based on the configuration [7](#0-6) . With the default configuration (`use_data_service_interface = false`), the `FullnodeDataServer` is exposed, but the reflection metadata only advertises the `RawData` service.

This creates a service discovery mismatch where:
1. Clients query gRPC reflection and discover `RawData.GetTransactions` method
2. Clients attempt to call `GetTransactions` which doesn't exist on the running service
3. The actual methods `GetTransactionsFromNode` and `Ping` are not discoverable via reflection
4. Clients receive "method not found" errors and fail to connect

There is even a TODO comment acknowledging this is a known footgun [8](#0-7) .

## Impact Explanation

This issue qualifies as **Low Severity** per the Aptos bug bounty criteria as a "non-critical implementation bug." While it causes API incompatibility and service discovery failures, it does not result in:
- Loss or theft of funds
- Consensus safety violations
- State corruption or manipulation
- Access control bypasses
- Validator node crashes

The impact is limited to operational/compatibility issues for clients using gRPC reflection for service discovery, which is a standard practice in gRPC ecosystems.

## Likelihood Explanation

**Likelihood: High** - This affects the default configuration, meaning all indexer fullnodes running with default settings expose this mismatch. Any client using gRPC reflection (common tools include `grpcurl`, `grpcui`, and many gRPC client libraries) will encounter this issue immediately upon attempting service discovery and method invocation.

## Recommendation

Add the missing file descriptor set to the reflection service registration:

```rust
use aptos_protos::{
    indexer::v1::{
        raw_data_server::RawDataServer, 
        FILE_DESCRIPTOR_SET as INDEXER_V1_FILE_DESCRIPTOR_SET,
    },
    internal::fullnode::v1::{
        fullnode_data_server::FullnodeDataServer,
        FILE_DESCRIPTOR_SET as INTERNAL_FULLNODE_V1_FILE_DESCRIPTOR_SET,
    },
    transaction::v1::FILE_DESCRIPTOR_SET as TRANSACTION_V1_TESTING_FILE_DESCRIPTOR_SET,
    util::timestamp::FILE_DESCRIPTOR_SET as UTIL_TIMESTAMP_FILE_DESCRIPTOR_SET,
};

// In the bootstrap function:
let reflection_service = tonic_reflection::server::Builder::configure()
    .register_encoded_file_descriptor_set(INDEXER_V1_FILE_DESCRIPTOR_SET)
    .register_encoded_file_descriptor_set(INTERNAL_FULLNODE_V1_FILE_DESCRIPTOR_SET)
    .register_encoded_file_descriptor_set(TRANSACTION_V1_TESTING_FILE_DESCRIPTOR_SET)
    .register_encoded_file_descriptor_set(UTIL_TIMESTAMP_FILE_DESCRIPTOR_SET)
    .build_v1()
    .expect("Failed to build reflection service");
```

This ensures both service definitions are available in reflection metadata regardless of which one is actually instantiated.

## Proof of Concept

**Prerequisites:**
- Running Aptos indexer fullnode with default configuration (`use_data_service_interface = false`)
- `grpcurl` tool installed

**Steps to reproduce:**

1. Start indexer fullnode with default config:
```bash
# use_data_service_interface defaults to false
cargo run -p aptos-node -- -f <config_file>
```

2. List services using reflection:
```bash
grpcurl -plaintext localhost:50051 list
# Output shows: aptos.indexer.v1.RawData
# Missing: aptos.internal.fullnode.v1.FullnodeData
```

3. Attempt to call the advertised method:
```bash
grpcurl -plaintext -d '{"starting_version": "0"}' \
  localhost:50051 aptos.indexer.v1.RawData/GetTransactions
# Error: method not found
```

4. The actual working method is not discoverable:
```bash
grpcurl -plaintext localhost:50051 list aptos.internal.fullnode.v1.FullnodeData
# Error: service not found in reflection metadata
```

This demonstrates the API incompatibility where clients expect one interface (RawData from reflection) but receive another (FullnodeData in reality).

## Notes

While this is a genuine API incompatibility issue as described in the security question, it does not meet the **Critical, High, or Medium severity** thresholds required by the validation checklist. It represents a Low severity configuration bug that affects service discoverability but does not compromise blockchain security, consensus safety, or result in loss of funds.

### Citations

**File:** config/src/config/indexer_grpc_config.rs (L36-40)
```rust
    /// If true, the GRPC stream interface exposed by the data service will be used
    /// instead of the standard fullnode GRPC stream interface. In other words, with
    /// this enabled, you can use an indexer fullnode like it is an instance of the
    /// indexer-grpc data service (aka the Transaction Stream Service API).
    pub use_data_service_interface: bool,
```

**File:** config/src/config/indexer_grpc_config.rs (L89-89)
```rust
            use_data_service_interface: false,
```

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L63-66)
```text
service FullnodeData {
  rpc Ping(PingFullnodeRequest) returns (PingFullnodeResponse);
  rpc GetTransactionsFromNode(GetTransactionsFromNodeRequest) returns (stream TransactionsFromNodeResponse);
}
```

**File:** protos/proto/aptos/indexer/v1/raw_data.proto (L51-54)
```text
service RawData {
  // Get transactions batch without any filtering from starting version and end if transaction count is present.
  rpc GetTransactions(GetTransactionsRequest) returns (stream TransactionsResponse);
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L87-97)
```rust
        let reflection_service = tonic_reflection::server::Builder::configure()
            // Note: It is critical that the file descriptor set is registered for every
            // file that the top level API proto depends on recursively. If you don't,
            // compilation will still succeed but reflection will fail at runtime.
            //
            // TODO: Add a test for this / something in build.rs, this is a big footgun.
            .register_encoded_file_descriptor_set(INDEXER_V1_FILE_DESCRIPTOR_SET)
            .register_encoded_file_descriptor_set(TRANSACTION_V1_TESTING_FILE_DESCRIPTOR_SET)
            .register_encoded_file_descriptor_set(UTIL_TIMESTAMP_FILE_DESCRIPTOR_SET)
            .build_v1()
            .expect("Failed to build reflection service");
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L106-121)
```rust
        let router = match use_data_service_interface {
            false => {
                let svc = FullnodeDataServer::new(server)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip);
                tonic_server.add_service(svc)
            },
            true => {
                let svc = RawDataServer::new(localnet_data_server)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip);
                tonic_server.add_service(svc)
            },
        };
```

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.rs (L107-108)
```rust
/// Encoded file descriptor set for the `aptos.internal.fullnode.v1` package
pub const FILE_DESCRIPTOR_SET: &[u8] = &[
```
