# Audit Report

## Title
Consensus Safety Violation: `match_ordered_only()` Fails to Validate Execution Results in Commit Vote Signing

## Summary
The `guarded_sign_commit_vote()` function in SafetyRules uses `match_ordered_only()` to validate consistency between ordered and commit certificates, but this validation only checks ordering fields (epoch, round, id, timestamp) and completely ignores execution result fields (executed_state_id, version, next_epoch_state). This allows validators to sign commit votes with divergent execution results for the same block, breaking consensus safety and enabling permanent chain forks if execution non-determinism occurs.

## Finding Description

The SafetyRules component serves as the last line of defense in Aptos consensus, designed to prevent validators from signing inconsistent or conflicting states even when other components fail. However, the current implementation contains a critical gap in its validation logic. [1](#0-0) 

The `guarded_sign_commit_vote()` function validates that the ordered ledger info (with placeholder execution state) matches the commit ledger info (with actual execution results) by calling: [2](#0-1) 

However, the `match_ordered_only()` implementation only validates ordering-related fields: [3](#0-2) 

The BlockInfo structure contains critical execution result fields that are NOT validated: [4](#0-3) 

This means two BlockInfo objects can pass `match_ordered_only()` while having:
- Different `executed_state_id` (state root hash after execution) 
- Different `version` (ledger version)
- Different `next_epoch_state` (epoch change information)

**Attack Scenario - Consensus Fork via Execution Non-Determinism:**

If any bug in the Move VM, execution layer, or hardware fault causes non-deterministic execution:

1. Validator V1 executes block B → produces (state_root_A, version_100)
2. Validator V2 executes block B → produces (state_root_B, version_100) due to non-determinism
3. Both validators call `sign_commit_vote()` with their respective execution results
4. Safety rules on both nodes validate using `match_ordered_only()` → both PASS (only epoch/round/id/timestamp checked)
5. Both validators broadcast commit votes with conflicting execution states
6. When receiving votes, validators in Ordered state accept both via `match_ordered_only()`: [5](#0-4) 

7. Upon local execution, each validator only aggregates votes matching their own execution result: [6](#0-5) 

8. If validators split into two groups (both achieving 2f+1 signatures), both groups form valid quorum certificates with DIFFERENT execution states for the same block
9. **Result: Permanent consensus fork** - validators commit different states, blockchain splits into multiple incompatible chains

This breaks the fundamental invariant:
> **Deterministic Execution**: All validators must produce identical state roots for identical blocks

The safety rules SHOULD prevent this by refusing to sign any execution result that could lead to state divergence, but `match_ordered_only()` provides insufficient validation.

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This vulnerability qualifies for Critical severity under the Aptos Bug Bounty program because it enables:

1. **Consensus Safety Violation**: Breaks the fundamental guarantee that all honest validators commit the same state for the same block, violating BFT safety under < 1/3 Byzantine assumption

2. **Non-recoverable Network Partition**: If triggered, creates permanent chain fork requiring hard fork to resolve - different validator subsets maintain incompatible chain histories

3. **Total Loss of Liveness**: Once fork occurs, consensus cannot progress without manual intervention and chain rollback

The vulnerability doesn't require any Byzantine actors - it's a defense-in-depth failure that allows execution bugs, hardware faults, or race conditions to cause catastrophic consensus failures that safety rules should prevent.

## Likelihood Explanation

**High Likelihood** of manifestation because:

1. **No Attacker Required**: Any non-determinism bug in the execution layer (Move VM, native functions, state access) would trigger this. Historical precedent shows execution bugs are common in blockchain systems.

2. **Hardware Faults**: Bit flips, memory corruption, or CPU inconsistencies during execution could produce different state roots that would pass safety rules validation.

3. **Complexity of Move VM**: The Move VM executes arbitrary smart contracts with complex state interactions, making deterministic execution difficult to guarantee across all edge cases.

4. **Already Relied Upon**: The codebase shows that `match_ordered_only()` is used in multiple critical paths for vote validation, indicating reliance on this insufficient check.

The barrier to exploitation is simply the presence of ANY execution non-determinism bug, which is a realistic scenario given the complexity of blockchain execution engines.

## Recommendation

**Fix: Strengthen `match_ordered_only()` to validate execution results OR remove its use in safety-critical paths**

Option 1 - Add execution result validation (when appropriate):
```rust
pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
    // Original ordering checks
    let ordering_matches = self.epoch == executed_block_info.epoch
        && self.round == executed_block_info.round
        && self.id == executed_block_info.id
        && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                && executed_block_info.has_reconfiguration()));
    
    if !ordering_matches {
        return false;
    }
    
    // For ordered-only blocks (dummy execution), we can't validate execution results
    // For executed blocks, we should validate they don't conflict
    if self.is_ordered_only() {
        // Original behavior for ordered-only comparisons
        return true;
    }
    
    // If both have real execution results, they must match exactly
    self.executed_state_id == executed_block_info.executed_state_id
        && self.version == executed_block_info.version
        && self.next_epoch_state == executed_block_info.next_epoch_state
}
```

Option 2 - More explicit validation in `guarded_sign_commit_vote()`:
```rust
fn guarded_sign_commit_vote(
    &mut self,
    ledger_info: LedgerInfoWithSignatures,
    new_ledger_info: LedgerInfo,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;
    
    let old_ledger_info = ledger_info.ledger_info();
    
    // Verify old is ordered-only
    if !old_ledger_info.commit_info().is_ordered_only()
        && old_ledger_info.commit_info() != new_ledger_info.commit_info()
    {
        return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
    }
    
    // Verify new has real execution results (not placeholder)
    if new_ledger_info.commit_info().is_ordered_only() {
        return Err(Error::InvalidCommitLedgerInfo(
            "Commit ledger info must have real execution results".into()
        ));
    }
    
    // Verify ordering fields match
    if !old_ledger_info
        .commit_info()
        .match_ordered_only(new_ledger_info.commit_info())
    {
        return Err(Error::InconsistentExecutionResult(
            old_ledger_info.commit_info().to_string(),
            new_ledger_info.commit_info().to_string(),
        ));
    }
    
    // NEW: Additional validation that execution results are present
    if new_ledger_info.commit_info().executed_state_id() == *ACCUMULATOR_PLACEHOLDER_HASH {
        return Err(Error::InvalidCommitLedgerInfo(
            "Commit vote must contain real executed_state_id".into()
        ));
    }
    
    // Continue with signature verification...
}
```

## Proof of Concept

```rust
#[test]
fn test_match_ordered_only_insufficient_validation() {
    use aptos_crypto::hash::{HashValue, ACCUMULATOR_PLACEHOLDER_HASH};
    use aptos_types::block_info::BlockInfo;
    
    // Create ordered-only block info (placeholder execution state)
    let ordered_info = BlockInfo::new(
        1,                              // epoch
        10,                             // round
        HashValue::random(),            // id
        *ACCUMULATOR_PLACEHOLDER_HASH,  // executed_state_id (dummy)
        0,                              // version (dummy)
        12345,                          // timestamp
        None,                           // next_epoch_state
    );
    
    let block_id = ordered_info.id();
    
    // Two different execution results for the SAME block
    let execution_result_a = BlockInfo::new(
        1,                              // epoch (same)
        10,                             // round (same)
        block_id,                       // id (same)
        HashValue::sha3_256_of(b"state_A"),  // DIFFERENT state root
        100,                            // DIFFERENT version
        12345,                          // timestamp (same)
        None,
    );
    
    let execution_result_b = BlockInfo::new(
        1,                              // epoch (same)
        10,                             // round (same)
        block_id,                       // id (same)
        HashValue::sha3_256_of(b"state_B"),  // DIFFERENT state root  
        99,                             // DIFFERENT version
        12345,                          // timestamp (same)
        None,
    );
    
    // VULNERABILITY: Both different execution results pass match_ordered_only()
    assert!(ordered_info.match_ordered_only(&execution_result_a));
    assert!(ordered_info.match_ordered_only(&execution_result_b));
    
    // But they represent DIFFERENT execution states!
    assert_ne!(
        execution_result_a.executed_state_id(),
        execution_result_b.executed_state_id()
    );
    assert_ne!(execution_result_a.version(), execution_result_b.version());
    
    // This means safety rules would sign BOTH conflicting execution results,
    // enabling consensus fork if validators split into groups with different
    // execution results due to non-determinism bugs.
}
```

## Notes

This vulnerability represents a fundamental defense-in-depth failure. The SafetyRules component exists specifically to prevent validators from signing inconsistent data even when other components have bugs. By not validating execution results, it defeats its own purpose and creates a single point of failure where any execution non-determinism bug (in Move VM, native functions, state access, or hardware) can cause catastrophic consensus failures.

The issue is particularly concerning because:
1. It's used in multiple critical consensus paths
2. The function name `match_ordered_only()` suggests it's checking consistency, but it's not checking execution consistency
3. Test coverage doesn't validate the scenario where execution results differ while ordering fields match
4. The impact is network-wide and requires hard fork to recover

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```

**File:** types/src/block_info.rs (L27-44)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L40-52)
```rust
fn create_signature_aggregator(
    unverified_votes: HashMap<Author, CommitVote>,
    commit_ledger_info: &LedgerInfo,
) -> SignatureAggregator<LedgerInfo> {
    let mut sig_aggregator = SignatureAggregator::new(commit_ledger_info.clone());
    for vote in unverified_votes.values() {
        let sig = vote.signature_with_status();
        if vote.ledger_info() == commit_ledger_info {
            sig_aggregator.add_signature(vote.author(), sig);
        }
    }
    sig_aggregator
}
```

**File:** consensus/src/pipeline/buffer_item.rs (L379-391)
```rust
            Self::Ordered(ordered) => {
                if ordered
                    .ordered_proof
                    .commit_info()
                    .match_ordered_only(target_commit_info)
                {
                    // we optimistically assume the vote will be valid in the future.
                    // when advancing to executed item, we will check if the sigs are valid.
                    // each author at most stores a single sig for each item,
                    // so an adversary will not be able to flood our memory.
                    ordered.unverified_votes.insert(author, vote);
                    return Ok(());
                }
```
