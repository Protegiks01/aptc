# Audit Report

## Title
Missing Signature Validation in Peer Storage Summary Allows Network State Manipulation

## Summary
The `update_peer_storage_summary` function in the data client poller does not validate the cryptographic signatures of `LedgerInfoWithSignatures` contained in peer-advertised `StorageServerSummary` responses before storing them in internal state. This allows malicious peers to inject fake ledger information with arbitrary version numbers, disrupting state synchronization decisions and causing denial-of-service conditions.

## Finding Description

When the data client poller receives a `StorageServerSummary` from a peer, it immediately stores the summary without validating the contained `synced_ledger_info` field, which is a `LedgerInfoWithSignatures` that should contain valid BLS aggregate signatures from 2f+1 validators. [1](#0-0) 

This delegates to the peer states module: [2](#0-1) 

Which directly stores the summary without any validation: [3](#0-2) 

The unvalidated summaries are then aggregated to compute a global view of network state: [4](#0-3) 

The `highest_synced_ledger_info()` method selects the ledger info with the highest version number based solely on version comparison, without signature verification: [5](#0-4) 

This manipulated global summary is then used for critical synchronization decisions, including waypoint satisfiability checks: [6](#0-5) 

**Attack Path:**
1. Malicious peer crafts a `StorageServerSummary` with a fake `synced_ledger_info` containing an extremely high version number (e.g., `u64::MAX`) but invalid/missing signatures
2. Target node polls this peer and receives the malicious summary
3. Summary is stored without validating the BLS signatures in `LedgerInfoWithSignatures`
4. When calculating global data summary, this fake ledger info becomes the "highest synced"
5. Bootstrapper and other components use this fake version for synchronization decisions
6. Node believes the network is far ahead and makes incorrect sync decisions

While `LedgerInfoWithSignatures` has a `verify_signatures` method available: [7](#0-6) 

This method is never called when storing peer-advertised summaries.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:

1. **Validator node slowdowns**: Nodes waste resources repeatedly querying malicious peers that advertise fake data, causing synchronization delays and resource exhaustion

2. **Significant protocol violations**: The state synchronization protocol's integrity is violated by allowing unverified cryptographic claims to influence critical decisions

3. **Network disruption**: Multiple malicious peers can cause network-wide confusion by advertising inconsistent or impossible state information, degrading overall network health

The vulnerability breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure" - signatures are completely bypassed in this code path.

## Likelihood Explanation

**Likelihood: High**

- **Attacker requirements**: Only needs to run a malicious peer node and connect to target nodes - no special privileges or validator access required
- **Complexity**: Low - simply requires sending a malformed `StorageServerSummary` with fake version numbers
- **Detection difficulty**: Hard to detect as the fake data blends with legitimate peer advertisements until actual sync attempts fail
- **Impact scope**: Affects all nodes that connect to the malicious peer

## Recommendation

Add signature validation before storing peer-advertised `StorageServerSummary` data. The validation should:

1. Verify BLS signatures in `synced_ledger_info` against known validator sets
2. Check that advertised data ranges are reasonable and consistent
3. Implement rate limiting and reputation scoring for peers advertising suspicious data

**Suggested fix** in `peer_states.rs`:

```rust
/// Updates the storage summary for the given peer
pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
    // Validate synced_ledger_info if present
    if let Some(synced_ledger_info) = &storage_summary.data_summary.synced_ledger_info {
        // Verify signatures against validator verifier
        // (requires access to epoch state and validator verifier)
        if let Err(error) = validate_ledger_info_signatures(synced_ledger_info) {
            warn!("Rejecting storage summary from peer {:?}: invalid signatures: {:?}", 
                  peer, error);
            return; // Reject invalid summary
        }
    }
    
    // Store only if validation passed
    self.peer_to_state
        .entry(peer)
        .or_insert(PeerState::new(self.data_client_config.clone()))
        .update_storage_summary(storage_summary);
}
```

## Proof of Concept

```rust
// Malicious peer sends fake StorageServerSummary
use aptos_storage_service_types::responses::{StorageServerSummary, DataSummary, ProtocolMetadata};
use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
use aptos_crypto::bls12381::Signature as AggregateSignature;

// Create fake ledger info with invalid signatures but very high version
let fake_ledger_info = LedgerInfo::new(
    BlockInfo::new(
        999999999, // Fake epoch
        0,
        HashValue::zero(),
        HashValue::zero(),
        u64::MAX, // Extremely high version
        0,
        None,
    ),
    HashValue::zero(),
);

// Empty/invalid signature
let fake_signatures = AggregateSignature::empty();

let fake_ledger_info_with_sigs = LedgerInfoWithSignatures::new(
    fake_ledger_info,
    fake_signatures,
);

let malicious_summary = StorageServerSummary {
    protocol_metadata: ProtocolMetadata::default(),
    data_summary: DataSummary {
        synced_ledger_info: Some(fake_ledger_info_with_sigs),
        epoch_ending_ledger_infos: None,
        states: None,
        transactions: None,
        transaction_outputs: None,
    },
};

// When this is sent to update_peer_storage_summary, it will be stored
// without validation, and the fake version u64::MAX will influence
// global summary calculations
```

**Notes**

The vulnerability is confirmed through code analysis. The missing validation allows malicious peers to manipulate the node's perception of network state, causing synchronization disruptions and resource exhaustion. While actual data fetched later undergoes cryptographic verification, the decision-making process is corrupted by unvalidated advertisements, leading to High severity impact on node performance and protocol correctness.

### Citations

**File:** state-sync/aptos-data-client/src/poller.rs (L437-439)
```rust
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```

**File:** state-sync/aptos-data-client/src/client.rs (L213-215)
```rust
    pub fn update_peer_storage_summary(&self, peer: PeerNetworkId, summary: StorageServerSummary) {
        self.peer_states.update_summary(peer, summary)
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L325-330)
```rust
    pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
        self.peer_to_state
            .entry(peer)
            .or_insert(PeerState::new(self.data_client_config.clone()))
            .update_storage_summary(storage_summary);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L338-408)
```rust
    /// Calculates a global data summary using all known storage summaries
    pub fn calculate_global_data_summary(&self) -> GlobalDataSummary {
        // Gather all storage summaries, but exclude peers that are ignored
        let storage_summaries: Vec<StorageServerSummary> = self
            .peer_to_state
            .iter()
            .filter_map(|peer_state| {
                peer_state
                    .value()
                    .get_storage_summary_if_not_ignored()
                    .cloned()
            })
            .collect();

        // If we have no peers, return an empty global summary
        if storage_summaries.is_empty() {
            return GlobalDataSummary::empty();
        }

        // Calculate the global data summary using the advertised peer data
        let mut advertised_data = AdvertisedData::empty();
        let mut max_epoch_chunk_sizes = vec![];
        let mut max_state_chunk_sizes = vec![];
        let mut max_transaction_chunk_sizes = vec![];
        let mut max_transaction_output_chunk_sizes = vec![];
        for summary in storage_summaries {
            // Collect aggregate data advertisements
            if let Some(epoch_ending_ledger_infos) = summary.data_summary.epoch_ending_ledger_infos
            {
                advertised_data
                    .epoch_ending_ledger_infos
                    .push(epoch_ending_ledger_infos);
            }
            if let Some(states) = summary.data_summary.states {
                advertised_data.states.push(states);
            }
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
            if let Some(transactions) = summary.data_summary.transactions {
                advertised_data.transactions.push(transactions);
            }
            if let Some(transaction_outputs) = summary.data_summary.transaction_outputs {
                advertised_data
                    .transaction_outputs
                    .push(transaction_outputs);
            }

            // Collect preferred max chunk sizes
            max_epoch_chunk_sizes.push(summary.protocol_metadata.max_epoch_chunk_size);
            max_state_chunk_sizes.push(summary.protocol_metadata.max_state_chunk_size);
            max_transaction_chunk_sizes.push(summary.protocol_metadata.max_transaction_chunk_size);
            max_transaction_output_chunk_sizes
                .push(summary.protocol_metadata.max_transaction_output_chunk_size);
        }

        // Calculate optimal chunk sizes based on the advertised data
        let optimal_chunk_sizes = calculate_optimal_chunk_sizes(
            &self.data_client_config,
            max_epoch_chunk_sizes,
            max_state_chunk_sizes,
            max_transaction_chunk_sizes,
            max_transaction_output_chunk_sizes,
        );
        GlobalDataSummary {
            advertised_data,
            optimal_chunk_sizes,
        }
    }
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L184-198)
```rust
    pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
        let highest_synced_position = self
            .synced_ledger_infos
            .iter()
            .map(|ledger_info_with_sigs| ledger_info_with_sigs.ledger_info().version())
            .position_max();

        if let Some(highest_synced_position) = highest_synced_position {
            self.synced_ledger_infos
                .get(highest_synced_position)
                .cloned()
        } else {
            None
        }
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L880-915)
```rust
    fn verify_waypoint_is_satisfiable(
        &mut self,
        global_data_summary: &GlobalDataSummary,
    ) -> Result<(), Error> {
        // If our storage has already synced beyond our waypoint, nothing needs to be checked
        let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        let waypoint_version = self.driver_configuration.waypoint.version();
        if latest_ledger_info.ledger_info().version() >= waypoint_version {
            self.verified_epoch_states
                .set_verified_waypoint(waypoint_version);
            return Ok(());
        }

        // Get the highest advertised synced ledger info version
        let highest_advertised_ledger_info = global_data_summary
            .advertised_data
            .highest_synced_ledger_info()
            .ok_or_else(|| {
                Error::UnsatisfiableWaypoint(
                    "Unable to check waypoint satisfiability! No highest advertised ledger info found in the network!".into(),
                )
            })?;
        let highest_advertised_version = highest_advertised_ledger_info.ledger_info().version();

        // Compare the highest advertised version with our waypoint
        if highest_advertised_version < waypoint_version {
            Err(Error::UnsatisfiableWaypoint(
                format!(
                    "The waypoint is not satisfiable! No advertised version higher than our waypoint! Highest version: {:?}, waypoint version: {:?}.",
                    highest_advertised_version, waypoint_version
                )
            ))
        } else {
            Ok(())
        }
    }
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```
