# Audit Report

## Title
Off-By-One Error in Type Size Validation Causes Verification-Runtime Mismatch

## Summary
The bytecode verifier and runtime type builder use inconsistent comparison operators when checking type size limits. The verifier allows types with size exactly equal to `max_type_nodes` (using `>`), while the TypeBuilder rejects types with count exactly equal to `max_ty_size` (using `>=`). When both limits are set to 128, a type with exactly 128 nodes passes verification but fails at runtime, breaking deterministic execution guarantees.

## Finding Description

The vulnerability exists in two comparison operations:

**Bytecode Verifier** (`limits.rs`): [1](#0-0) 

The verifier uses `type_size > limit`, which **allows** types where `type_size == limit`.

**Runtime TypeBuilder** (`runtime_types.rs`): [2](#0-1) 

The TypeBuilder uses `*count >= max_ty_size`, which **rejects** types where `count == max_ty_size`.

In production, both limits are configured to the same value (128 when function values are enabled): [3](#0-2) [4](#0-3) 

For non-struct, non-type-parameter nodes, both systems count identically (each node = 1). A Move function type with 127 parameters creates exactly 128 nodes:
- 1 Function token  
- 127 parameter tokens
- Total: 128 nodes

Such a type will:
1. **Pass bytecode verification**: `128 > 128` evaluates to false
2. **Fail at runtime**: `128 >= 128` evaluates to true, triggering `TOO_MANY_TYPE_NODES` error

This breaks **Invariant #1: Deterministic Execution** - validators cannot produce identical results when verified bytecode fails during execution. It also violates **Invariant #3: Move VM Safety** by allowing verified modules that cannot execute.

## Impact Explanation

**Severity: Medium** 

This qualifies as Medium severity under "State inconsistencies requiring intervention" because:

1. **Consensus Impact**: Different validators may handle module publishing differently depending on when type instantiation occurs, potentially causing state divergence
2. **Module Publishing Failure**: Modules passing verification but failing at execution create undefined behavior in the blockchain state
3. **Transaction Execution Failure**: Any transaction attempting to use such types will fail deterministically, but only after verification

The impact is limited because:
- No direct fund loss or theft
- No consensus safety violation (all nodes fail consistently once runtime is reached)  
- Requires feature flag `enable_function_values` to be active
- Only affects types with exactly 128 nodes, a specific edge case

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability will trigger when:
1. Function values feature is enabled (already active in production per gas feature version checks)
2. A module contains a type with exactly 128 nodes (requires intentional construction)
3. The type is used in contexts requiring runtime instantiation (struct fields, constants, signatures)

While not trivial to trigger accidentally, an attacker aware of this boundary condition could deliberately craft malicious modules. The specific node count (128) is discoverable by examining public configuration.

## Recommendation

Change the bytecode verifier comparison to match the TypeBuilder's stricter check:

```rust
// In third_party/move/move-bytecode-verifier/src/limits.rs, line 190
if let Some(limit) = config.max_type_nodes {
    if type_size >= limit {  // Changed from > to >=
        return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES));
    }
}
```

This ensures types with size exactly equal to the limit are rejected consistently at both verification and runtime. Alternatively, change TypeBuilder to use `>` for consistency, but the stricter check is safer.

Also document the semantic difference between "maximum" (inclusive) vs "limit" (exclusive) in configuration naming and documentation.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_type_size_boundary_mismatch() {
    use move_binary_format::file_format::{SignatureToken, Ability};
    use move_bytecode_verifier::{VerifierConfig, verifier::VerificationScope};
    use move_vm_types::loaded_data::runtime_types::TypeBuilder;
    
    // Create a Function type with 127 U64 parameters (128 total nodes)
    let mut params = vec![];
    for _ in 0..127 {
        params.push(SignatureToken::U64);
    }
    let function_type = SignatureToken::Function(
        params,
        vec![], // no return values
        Ability::empty()
    );
    
    // Configure with max_type_nodes = 128
    let verifier_config = VerifierConfig {
        scope: VerificationScope::Everything,
        max_type_nodes: Some(128),
        max_type_depth: Some(20),
        max_function_parameters: Some(128),
        max_function_return_values: Some(128),
        // ... other config fields with defaults
    };
    
    // Test bytecode verification - should PASS
    let verify_result = verify_type_node(&verifier_config, &function_type);
    assert!(verify_result.is_ok(), "Verification should pass for 128 nodes");
    
    // Test runtime TypeBuilder - should FAIL
    let ty_builder = TypeBuilder::with_limits(128, 20);
    let runtime_result = ty_builder.create_constant_ty(&function_type);
    assert!(runtime_result.is_err(), "Runtime should reject 128 nodes");
    assert_eq!(
        runtime_result.unwrap_err().major_status(),
        StatusCode::TOO_MANY_TYPE_NODES
    );
}
```

The test demonstrates that a type with exactly 128 nodes passes verification but fails at runtime, confirming the off-by-one inconsistency.

## Notes

The vulnerability stems from semantic ambiguity around "maximum" limits. The verifier interprets `max_type_nodes` as "at most N nodes" (inclusive), while TypeBuilder interprets `max_ty_size` as "fewer than N nodes" (exclusive). This inconsistency is further obscured because:

1. Both systems use different variable names (`max_type_nodes` vs `max_ty_size`)
2. The verifier applies weighted counting for structs/type-parameters (Ã—4), though this doesn't affect the specific exploit case
3. The depth check uses `>` in both places, creating inconsistent patterns within the same codebase

The fix should standardize on one semantic (recommend stricter `>=` check) and document the intended behavior clearly.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L189-193)
```rust
        if let Some(limit) = config.max_type_nodes {
            if type_size > limit {
                return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES));
            }
        }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L1195-1203)
```rust
    fn check(&self, count: &mut u64, depth: u64) -> PartialVMResult<()> {
        if *count >= self.max_ty_size {
            return self.too_many_nodes_error();
        }
        if depth > self.max_ty_depth {
            return self.too_large_depth_error();
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L162-166)
```rust
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L266-268)
```rust
            max_ty_size: NumTypeNodes,
            { RELEASE_V1_15.. => "max_ty_size" },
            128,
```
