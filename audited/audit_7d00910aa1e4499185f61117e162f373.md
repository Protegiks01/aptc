# Audit Report

## Title
Unzeroed Private Key Copies in Memory via ConfigKey::private_key() Method

## Summary
The `ConfigKey::private_key()` method in `config/src/keys.rs` creates additional unzeroed copies of sensitive cryptographic key material in memory through its BCS serialization-based clone implementation. This violates Aptos's documented secure coding guidelines and increases the attack surface for memory extraction attacks, including cold boot attacks, process memory scanning, and core dump analysis.

## Finding Description

The `ConfigKey<T>` wrapper provides a `private_key()` method that returns the wrapped private key by value: [1](#0-0) 

This method calls `self.clone()` which uses a custom clone implementation based on BCS serialization: [2](#0-1) 

When `private_key()` is invoked, the following memory operations occur:
1. `bcs::to_bytes(self)` serializes the entire `ConfigKey<T>` (including the private key) into a temporary `Vec<u8>` buffer
2. `bcs::from_bytes(...)` deserializes those bytes back into a new `ConfigKey<T>` instance
3. The `.key` field is extracted and returned
4. The temporary `Vec<u8>` buffer and cloned `ConfigKey` are dropped

**Critical Issue:** When these temporary structures are dropped, Rust's standard allocator simply marks the memory as freeâ€”it does NOT zero the memory. The private key bytes remain in the heap until that memory region is reallocated and overwritten by other data.

This directly violates the Aptos Secure Coding Guidelines: [3](#0-2) [4](#0-3) 

**Production Usage:** This function is actively used in production code paths, not just tests: [5](#0-4) [6](#0-5) 

The `ConfigKey` wrapper is explicitly designed to make private keys clonable for configuration purposes, as documented in the code comments: [7](#0-6) 

While the intent is to support testing and low-security environments, validators can still configure network identity keys using `from_config` in their configuration files: [8](#0-7) 

## Impact Explanation

This issue qualifies as **Medium Severity** under the Aptos Bug Bounty program criteria for the following reasons:

1. **Attack Vector:** An attacker who gains memory access to a validator process (via malware, RCE exploit, physical access to the server, or access to crash dumps/swap files) can scan the heap for unzeroed x25519 private key material

2. **Impact Scope:** Compromise of network identity keys allows:
   - Network-level impersonation of the validator
   - Man-in-the-middle attacks on P2P validator communication
   - Potential disruption of consensus message delivery
   
3. **Limitations:** This does NOT compromise:
   - Consensus signing keys (stored separately in secure storage for production validators)
   - Funds or account keys
   - The ability to sign blocks or votes

The impact aligns with Medium severity: "State inconsistencies requiring intervention" and increased attack surface for network-level security, without direct consensus or fund compromise.

## Likelihood Explanation

**Likelihood: Medium**

The exploit requires:
1. **Attacker Capability:** Memory access to the validator process through:
   - Malware/rootkit on the validator machine
   - Exploitation of another vulnerability (RCE)
   - Physical access to the server (cold boot attack)
   - Access to crash dumps or swap files

2. **Target Value:** Validators are high-value targets in the Aptos ecosystem, making them attractive to sophisticated attackers

3. **Detection Difficulty:** Memory scanning attacks are difficult to detect and the unzeroed key material persists for an unpredictable duration

4. **Mitigating Factors:**
   - Production validators are encouraged to use secure storage backends (Vault) rather than `from_config`
   - The vulnerability requires pre-existing memory access capability
   - Modern operating systems may have some memory protection mechanisms

However, the code explicitly violates documented security policy, and the vulnerability is present in production code paths that are actively used during node initialization and key management operations.

## Recommendation

Implement proper zeroization of sensitive key material using the `zeroize` crate as required by the security guidelines. The fix should:

1. **Add the `zeroize` dependency** to `config/Cargo.toml`

2. **Replace the BCS-based clone** with a zero-copy approach or implement explicit zeroization:

```rust
use zeroize::Zeroize;

impl<T: DeserializeOwned + PrivateKey + Serialize> Clone for ConfigKey<T> {
    fn clone(&self) -> Self {
        let mut bytes = bcs::to_bytes(self).unwrap();
        let result = bcs::from_bytes(&bytes).unwrap();
        bytes.zeroize(); // Explicitly zero the temporary serialized bytes
        result
    }
}
```

3. **Consider redesigning the API** to avoid cloning private keys entirely:

```rust
pub fn private_key(&self) -> T {
    // Instead of cloning, deserialize once and move ownership
    let mut bytes = bcs::to_bytes(self).unwrap();
    let result = bcs::from_bytes::<Self>(&bytes).unwrap().key;
    bytes.zeroize();
    result
}
```

4. **Implement Drop for ConfigKey** with zeroization:

```rust
impl<T: PrivateKey + Serialize> Drop for ConfigKey<T> {
    fn drop(&mut self) {
        // Zero the key field if T supports zeroization
        // This requires T to implement Zeroize
    }
}
```

5. **Long-term solution:** Consider removing the `from_config` option entirely for production validators and mandate secure storage backends only, enforcing this through runtime validation.

## Proof of Concept

The following Rust test demonstrates the vulnerability by showing that private key material persists in memory after the function returns:

```rust
#[cfg(test)]
mod memory_leak_poc {
    use super::*;
    use aptos_crypto::x25519;
    use aptos_crypto::Uniform;
    
    #[test]
    fn test_private_key_memory_leak() {
        // Generate a test private key with known pattern
        let test_key = x25519::PrivateKey::generate_for_testing();
        let key_bytes = test_key.to_bytes();
        
        // Wrap in ConfigKey
        let config_key = ConfigKey::new(test_key);
        
        // Track heap allocations before calling private_key()
        let heap_before = get_heap_snapshot(); // Hypothetical function
        
        // Call the vulnerable function
        let extracted_key = config_key.private_key();
        
        // The extracted key should match
        assert_eq!(extracted_key.to_bytes(), key_bytes);
        
        // Take a heap snapshot after the call
        let heap_after = get_heap_snapshot();
        
        // Search for the key pattern in unallocated heap memory
        // This would find the unzeroed copies from BCS serialization
        let found_copies = scan_heap_for_pattern(&heap_after, &key_bytes);
        
        // Vulnerability: Multiple copies of the key exist in memory
        assert!(found_copies.len() > 1, 
            "Expected to find unzeroed copies of the private key in heap memory");
    }
    
    #[test]
    fn test_bcs_serialization_creates_copies() {
        let test_key = x25519::PrivateKey::generate_for_testing();
        let config_key = ConfigKey::new(test_key);
        
        // The clone operation creates a serialized copy
        let cloned = config_key.clone();
        
        // Both ConfigKey instances contain the same key material
        assert_eq!(
            config_key.private_key().to_bytes(),
            cloned.private_key().to_bytes()
        );
        
        // After dropping cloned, its memory is not zeroed
        drop(cloned);
        // Key material remains in heap until memory is reused
    }
}
```

To demonstrate this vulnerability in practice, an attacker with memory access would:

1. Monitor the validator process memory space
2. Scan for x25519 private key patterns (32-byte values with specific mathematical properties)
3. Extract unzeroed copies created during `private_key()` invocations
4. Use the compromised network identity key to impersonate the validator on the P2P network

## Notes

- The vulnerability affects network identity keys (x25519::PrivateKey) used for P2P communication encryption and peer authentication
- Consensus signing keys stored in secure storage (Vault) are not directly affected by this specific vulnerability, though similar patterns may exist in the secure storage export functions
- The `cloneable-private-keys` feature flag exists but doesn't address the zeroization issue
- Even if `from_config` is discouraged for production, it remains a supported and documented configuration option that validators may use

### Citations

**File:** config/src/keys.rs (L20-24)
```rust
/// ConfigKey places a clonable wrapper around PrivateKeys for config purposes only. The only time
/// configs have keys is either for testing or for low security requirements. We recommend that
/// keys be stored in key managers. If we make keys unclonable, then the configs must be mutable
/// and that becomes a requirement strictly as a result of supporting test environments, which is
/// undesirable. Hence this internal wrapper allows for keys to be clonable but only from configs.
```

**File:** config/src/keys.rs (L36-38)
```rust
    pub fn private_key(&self) -> T {
        self.clone().key
    }
```

**File:** config/src/keys.rs (L49-53)
```rust
impl<T: DeserializeOwned + PrivateKey + Serialize> Clone for ConfigKey<T> {
    fn clone(&self) -> Self {
        bcs::from_bytes(&bcs::to_bytes(self).unwrap()).unwrap()
    }
}
```

**File:** RUST_SECURE_CODING.md (L96-96)
```markdown
Do not rely on `Drop` trait in security material treatment after the use, use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) to explicit destroy security material, e.g. private keys.
```

**File:** RUST_SECURE_CODING.md (L145-145)
```markdown
Use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) for zeroing memory containing sensitive data.
```

**File:** config/src/config/network_config.rs (L187-189)
```rust
    pub fn identity_key(&self) -> x25519::PrivateKey {
        let key = match &self.identity {
            Identity::FromConfig(config) => Some(config.key.private_key()),
```

**File:** config/src/config/config_optimizer.rs (L220-230)
```rust
            if let Identity::FromConfig(IdentityFromConfig {
                source: IdentitySource::AutoGenerated,
                key: config_key,
                ..
            }) = &fullnode_network_config.identity
            {
                let path = node_config.storage.dir().join(IDENTITY_KEY_FILE);
                if let Some(loaded_identity) = Identity::load_identity(&path)? {
                    fullnode_network_config.identity = loaded_identity;
                } else {
                    Identity::save_private_key(&path, &config_key.private_key())?;
```

**File:** config/src/config/test_data/validator.yaml (L72-77)
```yaml
    ### Load keys directly from config
    #
    # identity:
    #     type: "from_config"
    #     key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
    #     peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"
```
