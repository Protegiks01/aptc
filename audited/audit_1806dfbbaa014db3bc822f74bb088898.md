# Audit Report

## Title
API State Queries Lack Cryptographic Authentication Against State Root

## Summary
The Aptos REST API's `table_item()` function retrieves state data without cryptographic verification against the blockchain's state root. This allows API node operators to serve forged table items, resources, and modules to clients without detection, breaking the trustless security model expected of blockchain systems.

## Finding Description

The `table_item()` function in `api/src/state.rs` retrieves table data using an unverified state view. [1](#0-0) 

The state view is created via `Context::state_view()`, which calls `state_view_at_version()`: [2](#0-1) 

This creates a `DbStateView` with `maybe_verify_against_state_root_hash: None`: [3](#0-2) 

When `get_state_value_bytes()` is called at line 432, it ultimately invokes `DbStateView::get()`, which only performs proof verification when `maybe_verify_against_state_root_hash` is Some: [4](#0-3) 

Since the API uses the unverified path, no cryptographic authentication occurs. The database layer has `get_state_value_with_proof_by_version()` available but it's not utilized by the API layer.

A secure alternative exists - `verified_state_view_at_version()` - which properly sets the state root hash for verification: [5](#0-4) 

This method is used in test scenarios but not in production API code.

**Attack Scenario:**
1. Attacker operates a malicious Aptos API node with modified database
2. User queries for table item (e.g., token balance, NFT ownership)
3. Malicious node returns forged data showing incorrect balance/ownership
4. User makes financial decisions based on false information
5. No cryptographic verification exists to detect the forgery

This affects all state query endpoints: `get_account_resource()`, `get_account_module()`, `get_table_item()`, `get_raw_table_item()`, and view functions. [6](#0-5) 

## Impact Explanation

While this doesn't meet the traditional "Critical" bug bounty categories (no on-chain fund theft, no consensus violation), it represents a **High Severity** issue under "Significant protocol violations" because:

1. **Ecosystem-wide Trust Breach**: All API clients (wallets, dApps, block explorers) rely on API data authenticity
2. **No Alternative**: Aptos doesn't expose proof-based APIs, forcing clients to trust unverified data
3. **Financial Loss Vector**: Users could lose funds through decisions based on forged balances, ownership data, or governance state
4. **Violates Blockchain Security Model**: Blockchains promise cryptographic verifiability; this API provides none

The severity is elevated because this is the **official Aptos API implementation**, not a third-party service. Users reasonably expect data served by core infrastructure to be verifiable.

## Likelihood Explanation

**Likelihood: High**

1. **Low Barrier**: Anyone can run an Aptos API node without privileges
2. **User Dependency**: Many users query API nodes rather than running full nodes
3. **No Detection**: Without proof verification, forgeries are undetectable
4. **High Value Targets**: Token balances, NFT ownership, and governance votes are high-value targets for manipulation

The attack requires no validator access, no consensus exploit, and minimal technical sophistication - just a modified database on a publicly accessible API node.

## Recommendation

**Immediate Fix**: Replace `state_view_at_version()` with `verified_state_view_at_version()` in all API endpoints:

```rust
// In api/src/context.rs, modify state_view() method:
pub fn state_view<E: StdApiError>(
    &self,
    requested_ledger_version: Option<u64>,
) -> Result<(LedgerInfo, u64, DbStateView), E> {
    let (latest_ledger_info, requested_ledger_version) =
        self.get_latest_ledger_info_and_verify_lookup_version(requested_ledger_version)?;

    let state_view = self
        .db
        .verified_state_view_at_version(  // Changed from state_view_at_version
            Some(requested_ledger_version),
            &latest_ledger_info.ledger_info_with_sigs().ledger_info()  // Pass ledger_info for verification
        )
        .map_err(|err| {
            E::internal_with_code(err, AptosErrorCode::InternalError, &latest_ledger_info)
        })?;

    Ok((latest_ledger_info, requested_ledger_version, state_view))
}
```

**Long-term Solution**: Implement a proof-based API that returns both data and Sparse Merkle Proofs, allowing clients to perform trustless verification against the state root in the signed ledger info.

## Proof of Concept

```rust
// Demonstration showing unverified vs verified state views
use aptos_storage_interface::DbReader;
use aptos_storage_interface::state_store::state_view::db_state_view::{
    DbStateViewAtVersion, VerifiedStateViewAtVersion
};
use aptos_types::state_store::state_key::StateKey;

fn demonstrate_vulnerability(db: Arc<dyn DbReader>) {
    let version = 1000;
    
    // Current API behavior - NO VERIFICATION
    let unverified_view = db.state_view_at_version(Some(version)).unwrap();
    let unverified_data = unverified_view.get_state_value_bytes(&state_key).unwrap();
    // ^ This data could be forged if database is modified
    
    // Secure behavior - WITH VERIFICATION  
    let ledger_info = db.get_latest_ledger_info().unwrap();
    let verified_view = db.verified_state_view_at_version(
        Some(version), 
        ledger_info.ledger_info()
    ).unwrap();
    let verified_data = verified_view.get_state_value_bytes(&state_key).unwrap();
    // ^ This data is cryptographically verified against state root
    
    // In the current implementation, only verified_view performs proof checks
    // The API uses unverified_view, allowing forged data to pass through
}
```

## Notes

This vulnerability stems from an architectural decision to use `state_view_at_version()` (unverified) rather than `verified_state_view_at_version()` (verified with proof checking). The infrastructure for proof verification exists and is used in test scenarios [7](#0-6) , but was not integrated into the production API endpoints.

The `TStateView` trait's `get_state_value_bytes()` default implementation delegates to `get_state_value()`, which relies on the underlying view's verification settings: [8](#0-7) 

Comments in the code indicate this is a known limitation for "buffered state", but the issue affects all API state queries, not just buffered transactions: [9](#0-8)

### Citations

**File:** api/src/state.rs (L404-406)
```rust
        let (ledger_info, ledger_version, state_view) = self
            .context
            .state_view(ledger_version.map(|inner| inner.0))?;
```

**File:** api/src/context.rs (L193-195)
```rust
    pub fn state_view_at_version(&self, version: Version) -> Result<DbStateView> {
        Ok(self.db.state_view_at_version(Some(version))?)
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L21-23)
```rust
    /// DB doesn't support returning proofs for buffered state, so only optionally verify proof.
    /// TODO: support returning state proof for buffered state.
    maybe_verify_against_state_root_hash: Option<HashValue>,
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L27-46)
```rust
    fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
        if let Some(version) = self.version {
            if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
                // TODO(aldenhu): sample-verify proof inside DB
                // DB doesn't support returning proofs for buffered state, so only optionally
                // verify proof.
                // TODO: support returning state proof for buffered state.
                if let Ok((value, proof)) =
                    self.db.get_state_value_with_proof_by_version(key, version)
                {
                    proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
                }
            }
            Ok(self
                .db
                .get_state_value_with_version_by_version(key, version)?)
        } else {
            Ok(None)
        }
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L98-105)
```rust
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version,
            maybe_verify_against_state_root_hash: None,
        })
    }
}
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L107-138)
```rust
pub trait VerifiedStateViewAtVersion {
    fn verified_state_view_at_version(
        &self,
        version: Option<Version>,
        ledger_info: &LedgerInfo,
    ) -> StateViewResult<DbStateView>;
}

impl VerifiedStateViewAtVersion for Arc<dyn DbReader> {
    fn verified_state_view_at_version(
        &self,
        version: Option<Version>,
        ledger_info: &LedgerInfo,
    ) -> StateViewResult<DbStateView> {
        let db = self.clone();

        if let Some(version) = version {
            let txn_with_proof =
                db.get_transaction_by_version(version, ledger_info.version(), false)?;
            txn_with_proof.verify(ledger_info)?;

            let state_root_hash = txn_with_proof
                .proof
                .transaction_info
                .state_checkpoint_hash()
                .ok_or_else(|| StateViewError::NotFound("state_checkpoint_hash".to_string()))?;

            Ok(DbStateView {
                db,
                version: Some(version),
                maybe_verify_against_state_root_hash: Some(state_root_hash),
            })
```

**File:** api/src/view_function.rs (L105-113)
```rust
    let state_view = context
        .state_view_at_version(requested_version)
        .map_err(|err| {
            BasicErrorWith404::bad_request_with_code(
                err,
                AptosErrorCode::InternalError,
                &ledger_info,
            )
        })?;
```

**File:** execution/executor-test-helpers/src/integration_test_impl.rs (L266-269)
```rust
    let view = db
        .reader
        .verified_state_view_at_version(Some(current_version), latest_li)
        .unwrap();
```

**File:** types/src/state_store/mod.rs (L72-75)
```rust
    fn get_state_value_bytes(&self, state_key: &Self::Key) -> StateViewResult<Option<Bytes>> {
        let val_opt = self.get_state_value(state_key)?;
        Ok(val_opt.map(|val| val.bytes().clone()))
    }
```
