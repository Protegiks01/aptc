# Audit Report

## Title
Order Vote Validation Uses Incorrect BlockInfo Comparison in Decoupled Execution Mode

## Summary
The safety rules for order vote validation use direct BlockInfo comparison (`!=`) instead of `match_ordered_only()`, causing order votes to be rejected when execution completes before order vote creation. This logic bug prevents validators from creating valid order votes in decoupled execution mode, potentially causing consensus liveness issues.

## Finding Description

Aptos consensus operates in decoupled execution mode where block ordering occurs before execution completes. The critical flaw is in the safety rules validation logic:

**1. Regular Voting Phase**: Validators create votes using placeholder execution state. The `gen_vote_data()` method with `decoupled_execution=true` creates `BlockInfo` with `ACCUMULATOR_PLACEHOLDER_HASH`: [1](#0-0) [2](#0-1) 

**2. Decoupled Execution Always Active**: This mode is hardcoded and cannot be disabled: [3](#0-2) 

**3. Order Vote Creation Flow**: After QC formation, `broadcast_order_vote()` creates an order vote proposal: [4](#0-3) [5](#0-4) 

**4. Race Condition in block_info()**: The `order_vote_proposal()` method calls `block_info()` which retrieves the current execution state: [6](#0-5) [7](#0-6) [8](#0-7) 

If execution has completed, `compute_result()` returns the real hash instead of placeholder.

**5. The Core Bug - Incorrect Comparison**: Safety rules validate order votes using direct BlockInfo comparison: [9](#0-8) 

BlockInfo includes `executed_state_id` and derives `PartialEq`: [10](#0-9) 

The `!=` operator compares ALL fields including `executed_state_id`. When the QC's `certified_block` has placeholder hash but `order_vote_proposal.block_info()` has the real hash (because execution completed), they don't match, causing rejection.

**6. Correct Pattern Exists**: Other parts of the codebase use `match_ordered_only()` for decoupled execution: [11](#0-10) [12](#0-11) 

The `match_ordered_only()` method only compares fields that don't change during execution (epoch, round, id, timestamp), explicitly designed for decoupled execution compatibility.

## Impact Explanation

**HIGH Severity** - This qualifies as "Validator Node Slowdowns (High)" or "Limited Protocol Violations (Medium)" depending on manifestation frequency:

1. **Order Vote Rejection**: Validators whose execution completes before order vote creation cannot create valid order votes due to hash mismatches
2. **Potential Quorum Failure**: If sufficient validators (> 1/3) complete execution quickly, order certificate formation may fail
3. **Consensus Pipeline Impact**: While regular QCs form successfully, the ordering phase could stall
4. **Logic Bug**: Even if timing usually prevents manifestation, the incorrect comparison logic violates the decoupled execution design pattern used elsewhere in the codebase

## Likelihood Explanation

**MEDIUM to HIGH Likelihood**:

1. **Always Active**: Decoupled execution is hardcoded to `true`, so the vulnerable code path is always executed
2. **Natural Timing Variance**: Validators have different execution speeds due to hardware, network conditions, and load variations
3. **No Synchronization**: The code path from QC formation to order vote creation contains no `await` on execution futures
4. **Inconsistent Pattern**: The codebase uses `match_ordered_only()` elsewhere for this exact scenario, indicating awareness of the need for special handling in decoupled execution

## Recommendation

Replace the direct comparison in `verify_order_vote_proposal()` with `match_ordered_only()`:

```rust
pub(crate) fn verify_order_vote_proposal(
    &mut self,
    order_vote_proposal: &OrderVoteProposal,
) -> Result<(), Error> {
    let proposed_block = order_vote_proposal.block();
    let safety_data = self.persistent_storage.safety_data()?;

    self.verify_epoch(proposed_block.epoch(), &safety_data)?;

    let qc = order_vote_proposal.quorum_cert();
    // Use match_ordered_only for decoupled execution compatibility
    if !qc.certified_block().match_ordered_only(order_vote_proposal.block_info()) {
        return Err(Error::InvalidOneChainQuorumCertificate(
            qc.certified_block().id(),
            order_vote_proposal.block_info().id(),
        ));
    }
    if qc.certified_block().id() != proposed_block.id() {
        return Err(Error::InvalidOneChainQuorumCertificate(
            qc.certified_block().id(),
            proposed_block.id(),
        ));
    }
    self.verify_qc(qc)?;
    Ok(())
}
```

This aligns the order vote validation with the pattern used in `block_store.rs` and properly handles decoupled execution mode.

## Proof of Concept

The bug manifests when:
1. Block is proposed and receives votes with placeholder hash
2. QC is formed with `certified_block` containing `ACCUMULATOR_PLACEHOLDER_HASH`
3. Execution completes and `set_compute_result()` updates the block's state to real hash
4. `broadcast_order_vote()` is called, invoking `block.order_vote_proposal(qc)`
5. `order_vote_proposal()` calls `block_info()` which now returns the real hash
6. Safety rules comparison fails: `qc.certified_block() != order_vote_proposal.block_info()`

While a full reproduction would require setting up a validator network with controlled execution timing, the logic bug is evident from code inspection and violates the decoupled execution design pattern documented elsewhere in the codebase.

### Citations

**File:** consensus/consensus-types/src/vote_proposal.rs (L59-69)
```rust
    /// This function returns the vote data with a dummy executed_state_id and version
    fn vote_data_ordering_only(&self) -> VoteData {
        VoteData::new(
            self.block().gen_block_info(
                *ACCUMULATOR_PLACEHOLDER_HASH,
                0,
                self.next_epoch_state().cloned(),
            ),
            self.block().quorum_cert().certified_block().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L88-90)
```rust
    pub fn gen_vote_data(&self) -> anyhow::Result<VoteData> {
        if self.decoupled_execution {
            Ok(self.vote_data_ordering_only())
```

**File:** types/src/on_chain_config/consensus_config.rs (L238-241)
```rust
    /// Decouple execution from consensus or not.
    pub fn decoupled_execution(&self) -> bool {
        true
    }
```

**File:** consensus/src/round_manager.rs (L1626-1631)
```rust
    async fn create_order_vote(
        &mut self,
        block: Arc<PipelinedBlock>,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<OrderVote> {
        let order_vote_proposal = block.order_vote_proposal(qc);
```

**File:** consensus/src/round_manager.rs (L1653-1662)
```rust
    async fn broadcast_order_vote(
        &mut self,
        vote: &Vote,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<()> {
        if let Some(proposed_block) = self.block_store.get_block(vote.vote_data().proposed().id()) {
            // Generate an order vote with ledger_info = proposed_block
            let order_vote = self
                .create_order_vote(proposed_block.clone(), qc.clone())
                .await?;
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L440-442)
```rust
    pub fn compute_result(&self) -> StateComputeResult {
        self.state_compute_result.lock().clone()
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-459)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L471-473)
```rust
    pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
        OrderVoteProposal::new(self.block.clone(), self.block_info(), quorum_cert)
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L87-102)
```rust
    pub(crate) fn verify_order_vote_proposal(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<(), Error> {
        let proposed_block = order_vote_proposal.block();
        let safety_data = self.persistent_storage.safety_data()?;

        self.verify_epoch(proposed_block.epoch(), &safety_data)?;

        let qc = order_vote_proposal.quorum_cert();
        if qc.certified_block() != order_vote_proposal.block_info() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                order_vote_proposal.block_info().id(),
            ));
        }
```

**File:** types/src/block_info.rs (L27-44)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/src/block_storage/block_store.rs (L525-536)
```rust
        match self.get_block(qc.certified_block().id()) {
            Some(pipelined_block) => {
                ensure!(
                    // decoupled execution allows dummy block infos
                    pipelined_block
                        .block_info()
                        .match_ordered_only(qc.certified_block()),
                    "QC for block {} has different {:?} than local {:?}",
                    qc.certified_block().id(),
                    qc.certified_block(),
                    pipelined_block.block_info()
                );
```
