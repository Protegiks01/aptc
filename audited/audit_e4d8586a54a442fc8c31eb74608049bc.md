# Audit Report

## Title
Event Sequence Number Collision During Module Event Migration Causing Indexer Data Corruption

## Summary
During the module event migration period, a sequence number collision vulnerability exists in the event translation system. When the `MODULE_EVENT_MIGRATION` feature flag toggles between transactions, the EventHandle counter becomes desynchronized from translated V2 event sequence numbers, causing both native V1 events and translated V2 events to receive identical sequence numbers. This results in database overwrites in the indexer, leading to data loss and inconsistent event histories.

## Finding Description

The vulnerability stems from a fundamental mismatch in how V1 and V2 events handle sequence numbering during the migration period.

**V1 Event Emission Path:**
When `emit_token_royalty_mutate_event` is called with the feature flag disabled, it emits a V1 event through the EventHandle mechanism [1](#0-0) . The `emit_event` function increments the EventHandle counter after emission [2](#0-1) .

**V2 Event Emission Path:**
When the same function is called with the feature flag enabled, it emits a V2 module event [3](#0-2) . This calls `event::emit()` which invokes the native function [4](#0-3)  and does NOT increment the EventHandle counter.

**Translation Layer:**
The `RoyaltyMutateTranslator` translates V2 events to V1 format for backward compatibility [5](#0-4) . It reads the `TokenEventStoreV1` resource to obtain the EventHandle counter [6](#0-5) .

**Sequence Number Assignment:**
The `get_next_sequence_number` function uses a cache-database-fallback pattern, returning the EventHandle counter as the default when no cached or database entry exists [7](#0-6) .

**Collision Mechanism:**
Consider this scenario:
1. Transaction N (flag OFF): V1 event with seq=K emitted, counter becomes K+1
2. Transaction N+1 (flag ON): V2 event emitted, counter remains K+1 (not incremented)
3. Translator assigns seq=K+1 to translated V2 event (using counter as default)
4. Transaction N+2 (flag OFF): V1 event with seq=K+1 emitted (counter was K+1)

Both transactions N+1 and N+2 produce events with sequence number K+1.

**Database Overwrite:**
Both events are written to `EventByKeySchema` with the composite key `(event_key, sequence_number)` [8](#0-7)  and [9](#0-8) . The database schema uses this as a unique key [10](#0-9) , causing the second write to overwrite the first.

This breaks the fundamental invariant that event sequence numbers must be unique and monotonically increasing for each event key.

## Impact Explanation

This vulnerability qualifies as **MEDIUM severity** under the Aptos bug bounty program, meeting the criteria for "Limited Protocol Violations":

1. **State Inconsistencies Requiring Manual Intervention**: The indexer database becomes corrupted with missing events, requiring manual database repair or re-indexing from genesis to restore consistency.

2. **Protocol Invariant Violation**: Violates the event system's core invariant that sequence numbers must be unique per event key, as verified by the continuity check in `lookup_events_by_key` [11](#0-10) .

3. **Indexer Divergence**: Different indexers processing the same blockchain data may have different events stored for the same sequence number, depending on processing timing and cache state, leading to non-deterministic query results.

4. **Limited Scope**: While this affects critical infrastructure (the indexer), it does NOT:
   - Impact consensus or validator operations
   - Corrupt on-chain blockchain state
   - Enable direct fund theft or unauthorized transfers
   - Cause validator node slowdowns or API crashes

The on-chain state remains correct and consistent. The vulnerability only affects the auxiliary indexer infrastructure used for historical queries.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurrence:

1. **Natural Trigger**: The bug activates automatically during the module event migration period when governance toggles the `MODULE_EVENT_MIGRATION` feature flag. No malicious action is required.

2. **Common Operations**: Any user calling `mutate_tokendata_royalty` [12](#0-11)  during the migration period triggers the vulnerability. Token royalty mutations are standard NFT operations.

3. **No Special Permissions**: Any token creator with mutable royalty configuration can trigger the event emission—this is a normal user operation, not a privileged function.

4. **Extended Window**: The migration period could span weeks or months, providing sustained exposure time.

5. **Mathematical Certainty**: If N V1 events are emitted (counter reaches N), then M V2 events are emitted (counter stays at N), subsequent V1 events will reuse sequence numbers N through N+M-1, guaranteeing collisions.

## Recommendation

**Solution: Increment EventHandle Counter for V2 Events**

Modify the V2 emission path to maintain EventHandle counter consistency:

```move
// In emit_token_royalty_mutate_event
initialize_token_event_store(creator);
let token_event_store = &mut TokenEventStoreV1[creator_addr];
if (std::features::module_event_migration_enabled()) {
    event::emit(RoyaltyMutate { ... });
    // ADD THIS: Increment counter to maintain synchronization
    token_event_store.royalty_mutate_events.counter += 1;
} else {
    event::emit_event<RoyaltyMutateEvent>(
        &mut token_event_store.royalty_mutate_events,
        event,
    );
}
```

Alternatively, enhance the translator to track the highest assigned sequence number independently of the EventHandle counter, storing it persistently in `EventSequenceNumberSchema` immediately after each translation.

## Proof of Concept

The following Move test demonstrates the vulnerability:

```move
#[test(creator = @0x123)]
fun test_sequence_collision(creator: &signer) {
    // Setup token with mutable royalty
    token::create_collection(creator, ...);
    let token_data_id = token::create_tokendata(creator, ...);
    
    // Scenario: Feature flag OFF → ON → OFF
    // Version 1: Flag OFF - emits V1 event seq=0
    token::mutate_tokendata_royalty(creator, token_data_id, royalty_a);
    
    // Version 2: Flag ON - emits V2 event (counter stays at 1)
    features::enable_module_event_migration();
    token::mutate_tokendata_royalty(creator, token_data_id, royalty_b);
    
    // Version 3: Flag OFF - emits V1 event seq=1 (collision!)
    features::disable_module_event_migration();
    token::mutate_tokendata_royalty(creator, token_data_id, royalty_c);
    
    // Indexer processes these events:
    // - V2 event translated to seq=1 (using counter=1 as default)
    // - V3 native V1 event has seq=1
    // Result: Database overwrite, one event lost
}
```

The indexer would exhibit the collision when processing these transactions sequentially, with the final event overwriting the translated V2 event in `EventByKeySchema`.

## Notes

- The vulnerability affects all event types during module event migration, not just royalty events
- The collision does not affect on-chain state or smart contract execution—only indexer data integrity
- NFT marketplaces should query current on-chain royalty data from resources rather than relying solely on historical event data
- A proper fix requires coordination between the Move framework team and storage/indexer team to maintain sequence number consistency across the migration period

### Citations

**File:** aptos-move/framework/aptos-token/sources/token_event_store.move (L476-487)
```text
            event::emit(
                RoyaltyMutate {
                    creator: creator_addr,
                    collection,
                    token,
                    old_royalty_numerator,
                    old_royalty_denominator,
                    old_royalty_payee_addr,
                    new_royalty_numerator,
                    new_royalty_denominator,
                    new_royalty_payee_addr,
                });
```

**File:** aptos-move/framework/aptos-token/sources/token_event_store.move (L488-492)
```text
        } else {
            event::emit_event<RoyaltyMutateEvent>(
                &mut token_event_store.royalty_mutate_events,
                event,
            );
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L17-19)
```text
    public fun emit<T: store + drop>(msg: T) {
        write_module_event_to_store<T>(msg);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L54-60)
```text
    public fun emit_event<T: drop + store>(handle_ref: &mut EventHandle<T>, msg: T) {
        write_to_event_store<T>(bcs::to_bytes(&handle_ref.guid), handle_ref.counter, msg);
        spec {
            assume handle_ref.counter + 1 <= MAX_U64;
        };
        handle_ref.counter += 1;
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L190-200)
```rust
    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
        if let Some(seq) = self.get_cached_sequence_number(event_key) {
            Ok(seq + 1)
        } else {
            let seq = self
                .internal_indexer_db
                .get::<EventSequenceNumberSchema>(event_key)?
                .map_or(default, |seq| seq + 1);
            Ok(seq)
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L1245-1287)
```rust
struct RoyaltyMutateTranslator;
impl EventV2Translator for RoyaltyMutateTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let royalty_mutation = RoyaltyMutate::try_from_bytes(v2.event_data())?;
        let struct_tag = StructTag::from_str("0x3::token_event_store::TokenEventStoreV1")?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(royalty_mutation.creator(), &struct_tag)?
        {
            let object_resource: TokenEventStoreV1Resource = bcs::from_bytes(&state_value_bytes)?;
            let key = *object_resource.royalty_mutate_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, object_resource.royalty_mutate_events().count())?;
            (key, sequence_number)
        } else {
            // If the TokenEventStoreV1 resource is not found, we skip the event translation to
            // avoid panic because the creation number cannot be decided.
            return Err(AptosDbError::from(anyhow::format_err!(
                "TokenEventStoreV1 resource not found"
            )));
        };
        let royalty_mutation_event = RoyaltyMutateEvent::new(
            *royalty_mutation.creator(),
            royalty_mutation.collection().clone(),
            royalty_mutation.token().clone(),
            *royalty_mutation.old_royalty_numerator(),
            *royalty_mutation.old_royalty_denominator(),
            *royalty_mutation.old_royalty_payee_addr(),
            *royalty_mutation.new_royalty_numerator(),
            *royalty_mutation.new_royalty_denominator(),
            *royalty_mutation.new_royalty_payee_addr(),
        );
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            ROYALTY_MUTATE_EVENT_TYPE.clone(),
            bcs::to_bytes(&royalty_mutation_event)?,
        )?)
    }
}
```

**File:** storage/indexer/src/db_indexer.rs (L434-446)
```rust
                    if let ContractEvent::V1(v1) = event {
                        batch
                            .put::<EventByKeySchema>(
                                &(*v1.key(), v1.sequence_number()),
                                &(version, idx as u64),
                            )
                            .expect("Failed to put events by key to a batch");
                        batch
                            .put::<EventByVersionSchema>(
                                &(*v1.key(), version, v1.sequence_number()),
                                &(idx as u64),
                            )
                            .expect("Failed to put events by version to a batch");
```

**File:** storage/indexer/src/db_indexer.rs (L464-469)
```rust
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
```

**File:** storage/indexer_schemas/src/schema/event_by_key/mod.rs (L23-29)
```rust
define_pub_schema!(EventByKeySchema, Key, Value, EVENT_BY_KEY_CF_NAME);

type SeqNum = u64;
type Key = (EventKey, SeqNum);

type Index = u64;
type Value = (Version, Index);
```

**File:** storage/aptosdb/src/event_store/mod.rs (L130-137)
```rust
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                db_other_bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
            }
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L831-850)
```text
    public fun mutate_tokendata_royalty(creator: &signer, token_data_id: TokenDataId, royalty: Royalty) acquires Collections {
        assert_tokendata_exists(creator, token_data_id);

        let all_token_data = &mut Collections[token_data_id.creator].token_data;
        let token_data = all_token_data.borrow_mut(token_data_id);
        assert!(token_data.mutability_config.royalty, error::permission_denied(EFIELD_NOT_MUTABLE));

        token_event_store::emit_token_royalty_mutate_event(
            creator,
            token_data_id.collection,
            token_data_id.name,
            token_data.royalty.royalty_points_numerator,
            token_data.royalty.royalty_points_denominator,
            token_data.royalty.payee_address,
            royalty.royalty_points_numerator,
            royalty.royalty_points_denominator,
            royalty.payee_address
        );
        token_data.royalty = royalty;
    }
```
