# Audit Report

## Title
Unauthorized ConsensusObserver Subscription Enables Pre-Commitment Consensus Information Leakage

## Summary
Malicious nodes can claim `ConsensusObserver` protocol support during network handshake and successfully subscribe to consensus updates from validators without any authorization checks, enabling them to receive pre-commit consensus messages including ordered blocks and transaction payloads.

## Finding Description

The ConsensusObserver protocol is designed to allow fullnodes to follow consensus updates. However, the subscription mechanism lacks authorization controls, allowing any node to claim protocol support and receive sensitive consensus information.

**Attack Flow:**

1. **Protocol Declaration**: During network handshake, a malicious node declares support for `ProtocolId::ConsensusObserver` and `ProtocolId::ConsensusObserverRpc` in its `ProtocolIdSet`. [1](#0-0) 

2. **Network Registration**: The ConsensusObserver protocols are registered on all network types (Validator, VFN, Public) when consensus observer is enabled, making the protocol accessible across all networks. [2](#0-1) 

3. **Protocol Configuration**: The network configuration specifies both direct-send and RPC protocols for consensus observer without restricting which peers can claim support. [3](#0-2) 

4. **Subscription Without Authorization**: When the malicious node sends a `Subscribe` RPC request, the `ConsensusPublisher` processes it without any verification of whether the peer should be authorized to receive consensus messages. It simply adds the peer to `active_subscribers` and sends a `SubscribeAck` response. [4](#0-3) 

5. **Message Broadcasting**: Once subscribed, the publisher broadcasts all consensus messages to active subscribers, including `OrderedBlock`, `CommitDecision`, and `BlockPayload` messages containing pre-commit consensus data. [5](#0-4) 

**Sensitive Information Exposed:**

The leaked consensus messages contain:
- **OrderedBlock**: Blocks with ordering proofs before commitment [6](#0-5) 
- **CommitDecision**: Commit proofs indicating finalization
- **BlockPayload**: Transaction payloads including user transactions [7](#0-6) 

**Missing Security Controls:**

The only "authorization" is protocol support verification during peer sorting for subscription optimality, which merely checks if the peer's metadata indicates protocol supportâ€”information the peer itself declares. [8](#0-7) 

There is no verification that:
- The subscribing peer is a validator
- The peer has any legitimate need for consensus messages  
- The peer's identity or role authorizes access to pre-commit data

## Impact Explanation

This vulnerability enables **consensus information leakage**, which falls under **Medium severity** per the Aptos bug bounty criteria for the following reasons:

1. **Front-Running Capability**: Attackers gain early visibility into transaction ordering before blocks are committed, enabling them to:
   - Front-run user transactions by submitting competing transactions with higher gas
   - Extract MEV (Maximal Extractable Value) opportunities
   - Manipulate markets based on advance knowledge of pending transactions

2. **Limited but Real Financial Impact**: While this doesn't directly steal funds or break consensus safety, it enables "limited funds loss or manipulation" (Medium severity criteria) by allowing attackers to profit at the expense of regular users through front-running attacks.

3. **Information Asymmetry**: The attacker obtains consensus information seconds before it becomes publicly committed, creating unfair advantages in time-sensitive DeFi operations.

This does not qualify as Critical severity because:
- It doesn't violate consensus safety (no double-spending or chain splits)
- It doesn't enable direct fund theft from the protocol
- It doesn't cause network availability issues

However, it exceeds Low severity ("minor information leaks") because the leaked information has direct financial exploitation potential.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploited because:

1. **Low Barrier to Entry**: Any actor can run a node and connect to the Aptos network without special permissions or credentials.

2. **Simple Exploitation**: The attack requires only:
   - Implementing network handshake with ConsensusObserver protocol support
   - Establishing connection to a validator/VFN with publisher enabled
   - Sending a single Subscribe RPC request

3. **No Detection Mechanism**: The publisher has no way to distinguish between legitimate fullnode observers and malicious subscribers, as both present identical protocol support claims.

4. **High Value Target**: Pre-commit consensus information is valuable for MEV extraction and front-running, providing strong financial incentives for exploitation.

5. **Network Design**: The ConsensusObserver protocols are intentionally registered on all networks to enable fullnode observation, making the attack surface broadly accessible.

## Recommendation

Implement authorization controls for ConsensusObserver subscriptions:

**Option 1: Network-Based Access Control**
Restrict ConsensusObserver publisher functionality to trusted networks only. Publishers should only accept subscriptions from peers on validator or VFN networks, not public networks.

```rust
fn process_network_message(&self, network_message: ConsensusPublisherNetworkMessage) {
    let (peer_network_id, message, response_sender) = network_message.into_parts();
    
    // Verify the subscription request is from an authorized network
    match message {
        ConsensusObserverRequest::Subscribe => {
            // Only allow subscriptions from validator or VFN networks
            if !peer_network_id.network_id().is_validator_network() 
                && !peer_network_id.network_id().is_vfn_network() {
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "Rejected subscription from unauthorized network! Peer: {:?}",
                        peer_network_id
                    )));
                return; // Reject the subscription
            }
            
            // Existing subscription logic...
            self.add_active_subscriber(peer_network_id);
            // ...
        },
        // ... other cases
    }
}
```

**Option 2: Peer Role Verification**
Check the peer's role from connection metadata before accepting subscriptions:

```rust
// In ConsensusPublisher, add method to verify peer authorization
fn is_peer_authorized(&self, peer_network_id: &PeerNetworkId) -> bool {
    let peers_and_metadata = self.consensus_observer_client.get_peers_and_metadata();
    match peers_and_metadata.get_metadata_for_peer(peer_network_id) {
        Some(metadata) => {
            let connection = metadata.get_connection_metadata();
            // Only allow validators or preferred upstreams
            matches!(
                connection.role,
                PeerRole::Validator | PeerRole::PreferredUpstream
            )
        },
        None => false,
    }
}
```

**Option 3: Explicit Allowlist**
Maintain a configuration-based allowlist of authorized subscribers based on peer identity or public keys.

## Proof of Concept

```rust
// Test demonstrating unauthorized subscription
#[tokio::test]
async fn test_unauthorized_consensus_observer_subscription() {
    use aptos_config::network_id::{NetworkId, PeerNetworkId};
    use aptos_types::PeerId;
    use aptos_network::protocols::wire::handshake::v1::{ProtocolId, ProtocolIdSet};
    
    // Setup: Create a consensus publisher (validator side)
    let consensus_observer_config = ConsensusObserverConfig::default();
    let network_id = NetworkId::Public; // Attacker on public network
    let peers_and_metadata = PeersAndMetadata::new(&[network_id]);
    let network_client = NetworkClient::new(vec![], vec![], hashmap![], peers_and_metadata.clone());
    let consensus_observer_client = Arc::new(ConsensusObserverClient::new(network_client));
    let (consensus_publisher, _) = ConsensusPublisher::new(
        consensus_observer_config,
        consensus_observer_client,
    );
    
    // Attack Step 1: Malicious node claims ConsensusObserver protocol support
    let malicious_peer_id = PeerId::random();
    let malicious_peer_network_id = PeerNetworkId::new(network_id, malicious_peer_id);
    let mut connection_metadata = ConnectionMetadata::mock(malicious_peer_id);
    
    // Attacker declares protocol support in handshake
    connection_metadata.application_protocols = ProtocolIdSet::from_iter(vec![
        ProtocolId::ConsensusObserver,
        ProtocolId::ConsensusObserverRpc,
    ]);
    
    peers_and_metadata
        .insert_connection_metadata(malicious_peer_network_id, connection_metadata)
        .unwrap();
    
    // Attack Step 2: Send Subscribe request (no authorization check)
    let subscribe_request = ConsensusObserverRequest::Subscribe;
    let network_message = ConsensusPublisherNetworkMessage::new(
        malicious_peer_network_id,
        subscribe_request,
        ResponseSender::new_for_test(),
    );
    
    consensus_publisher.process_network_message(network_message);
    
    // Verify: Malicious peer is now an active subscriber
    let active_subscribers = consensus_publisher.get_active_subscribers();
    assert!(active_subscribers.contains(&malicious_peer_network_id));
    
    // Attack Step 3: Malicious peer now receives all consensus messages
    // (demonstrated by successful subscription - actual message reception 
    // would require full network stack setup)
    println!("Attack successful: Unauthorized peer subscribed to consensus updates");
}
```

**Notes:**
- The PoC demonstrates that any peer claiming protocol support can subscribe without authorization
- In a real attack, the malicious node would receive `OrderedBlock`, `CommitDecision`, and `BlockPayload` messages
- The attacker could use this information for front-running or MEV extraction before blocks are publicly committed

### Citations

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L73-74)
```rust
    ConsensusObserver = 27,
    ConsensusObserverRpc = 28,
```

**File:** aptos-node/src/network.rs (L170-189)
```rust
pub fn consensus_observer_network_configuration(
    node_config: &NodeConfig,
) -> NetworkApplicationConfig {
    let direct_send_protocols = vec![ProtocolId::ConsensusObserver];
    let rpc_protocols = vec![ProtocolId::ConsensusObserverRpc];
    let max_network_channel_size = node_config.consensus_observer.max_network_channel_size as usize;

    let network_client_config =
        NetworkClientConfig::new(direct_send_protocols.clone(), rpc_protocols.clone());
    let network_service_config = NetworkServiceConfig::new(
        direct_send_protocols,
        rpc_protocols,
        aptos_channel::Config::new(max_network_channel_size)
            .queue_style(QueueStyle::FIFO)
            .counters(
                &consensus_observer::common::metrics::PENDING_CONSENSUS_OBSERVER_NETWORK_EVENTS,
            ),
    );
    NetworkApplicationConfig::new(network_client_config, network_service_config)
}
```

**File:** aptos-node/src/network.rs (L336-358)
```rust
        // Register consensus observer (both client and server) with the network
        if node_config
            .consensus_observer
            .is_observer_or_publisher_enabled()
        {
            // Create the network handle for this network type
            let network_handle = register_client_and_service_with_network(
                &mut network_builder,
                network_id,
                &network_config,
                consensus_observer_network_configuration(node_config),
                false,
            );

            // Add the network handle to the set of handles
            if let Some(consensus_observer_network_handles) =
                &mut consensus_observer_network_handles
            {
                consensus_observer_network_handles.push(network_handle);
            } else {
                consensus_observer_network_handles = Some(vec![network_handle]);
            }
        }
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L181-192)
```rust
            ConsensusObserverRequest::Subscribe => {
                // Add the peer to the set of active subscribers
                self.add_active_subscriber(peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "New peer subscribed to consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple subscription ACK
                response_sender.send(ConsensusObserverResponse::SubscribeAck);
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L212-232)
```rust
    pub fn publish_message(&self, message: ConsensusObserverDirectSend) {
        // Get the active subscribers
        let active_subscribers = self.get_active_subscribers();

        // Send the message to all active subscribers
        for peer_network_id in &active_subscribers {
            // Send the message to the outbound receiver for publishing
            let mut outbound_message_sender = self.outbound_message_sender.clone();
            if let Err(error) =
                outbound_message_sender.try_send((*peer_network_id, message.clone()))
            {
                // The message send failed
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                        .event(LogEvent::SendDirectSendMessage)
                        .message(&format!(
                            "Failed to send outbound message to the receiver for peer {:?}! Error: {:?}",
                            peer_network_id, error
                    )));
            }
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L158-166)
```rust
            ConsensusObserverDirectSend::BlockPayload(block_payload) => {
                write!(
                    f,
                    "BlockPayload: {}. Number of transactions: {}, limit: {:?}, proofs: {:?}",
                    block_payload.block,
                    block_payload.transaction_payload.transactions().len(),
                    block_payload.transaction_payload.transaction_limit(),
                    block_payload.transaction_payload.payload_proofs(),
                )
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L179-184)
```rust
/// OrderedBlock message contains the ordered blocks and the proof of the ordering
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct OrderedBlock {
    blocks: Vec<Arc<PipelinedBlock>>,
    ordered_proof: LedgerInfoWithSignatures,
}
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L352-356)
```rust
/// Returns true iff the peer metadata indicates support for consensus observer
fn supports_consensus_observer(peer_metadata: &PeerMetadata) -> bool {
    peer_metadata.supports_protocol(ProtocolId::ConsensusObserver)
        && peer_metadata.supports_protocol(ProtocolId::ConsensusObserverRpc)
}
```
