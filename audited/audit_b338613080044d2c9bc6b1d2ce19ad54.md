# Audit Report

## Title
Unbounded Memory Consumption in JWK Observer Through Large OpenID Configuration Responses

## Summary
The `fetch_jwks_uri_from_openid_config()` and `fetch_jwks_from_jwks_uri()` functions in the JWK utilities crate lack response size limits when deserializing JSON payloads from external OIDC provider endpoints. An attacker who compromises a governance-approved OIDC provider endpoint can send multi-gigabyte JSON responses, causing memory exhaustion in all validator nodes simultaneously and degrading consensus liveness.

## Finding Description

The JWK consensus system enables keyless account authentication by periodically fetching JSON Web Keys from OIDC providers (Google, Facebook, etc.). Validators run `JWKObserver` threads that fetch OpenID configurations and JWK sets every 10 seconds from URLs stored in the on-chain `SupportedOIDCProviders` resource. [1](#0-0) [2](#0-1) 

Both functions use `reqwest::Response::json().await?` which deserializes the entire HTTP response body into memory without size limits. The deserialization targets are: [3](#0-2) 

The `JWKsResponse` struct contains `Vec<serde_json::Value>`, allowing arbitrarily large JSON arrays. Neither `reqwest` nor `serde_json` impose default size limits.

**Attack Flow:**

1. An OIDC provider (e.g., `https://accounts.google.com/.well-known/openid-configuration`) is added to `SupportedOIDCProviders` through on-chain governance: [4](#0-3) 

2. Validators spawn `JWKObserver` threads for each provider, fetching every 10 seconds: [5](#0-4) 

3. If the OIDC provider endpoint is compromised or has a bug, it can return a response like:
```json
{
  "issuer": "https://malicious.com",
  "jwks_uri": "...",
  "padding": "A" * 10_000_000_000  // 10GB string
}
```

4. Each validator attempts to deserialize this into memory simultaneously, causing:
   - Memory exhaustion (OOM kills or severe paging)
   - Node slowdowns or crashes
   - Consensus liveness degradation

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Severity: HIGH** per Aptos bug bounty criteria:

- **Validator node slowdowns**: Memory exhaustion causes severe performance degradation across all validators
- **API crashes**: Validators may crash due to OOM conditions
- **Significant protocol violations**: Consensus liveness is impacted when validators are simultaneously affected

This is a Denial of Service (DoS) attack vector that targets critical validator infrastructure. While it requires compromise of an external OIDC provider, such providers are:
- Outside Aptos' security perimeter
- Can have bugs or misconfigurations
- Are attractive targets (Google, Facebook infrastructure)

The attack affects **all validators simultaneously** since they all fetch from the same URLs, making this a network-wide availability issue rather than isolated node failures.

## Likelihood Explanation

**Likelihood: MEDIUM-LOW**

**Requirements:**
- Attacker must compromise or exploit a governance-approved OIDC provider endpoint
- OR trigger a bug in the provider's infrastructure
- The provider must be in the active `SupportedOIDCProviders` list

**Mitigating factors:**
- Major OIDC providers (Google, Facebook) have robust security
- Governance vets providers before adding them
- Not directly exploitable by arbitrary attackers

**Amplifying factors:**
- Once triggered, affects ALL validators (100% impact)
- Repeats every 10 seconds until the provider is removed
- No rate limiting or circuit breaker mechanisms
- Validators have no protection against malicious responses from trusted URLs

Real-world scenarios where this could occur:
1. Provider infrastructure compromise (supply chain attack)
2. Misconfiguration in provider's CDN or load balancer
3. Bug in provider's OpenID configuration endpoint
4. DNS hijacking/BGP hijacking targeting the provider

## Recommendation

Implement strict response size limits in the JWK fetching functions:

```rust
use reqwest::ClientBuilder;
use std::time::Duration;

// Configuration constants
const MAX_OPENID_CONFIG_SIZE: usize = 1024 * 10; // 10 KB
const MAX_JWKS_RESPONSE_SIZE: usize = 1024 * 100; // 100 KB
const REQUEST_TIMEOUT: Duration = Duration::from_secs(30);

pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = ClientBuilder::new()
        .timeout(REQUEST_TIMEOUT)
        .build()?;
    
    let response = client.get(config_url).send().await?;
    let content_length = response.content_length().unwrap_or(0);
    
    if content_length > MAX_OPENID_CONFIG_SIZE as u64 {
        return Err(anyhow::anyhow!(
            "OpenID config response too large: {} bytes", 
            content_length
        ));
    }
    
    let bytes = response.bytes().await?;
    if bytes.len() > MAX_OPENID_CONFIG_SIZE {
        return Err(anyhow::anyhow!(
            "OpenID config response too large: {} bytes", 
            bytes.len()
        ));
    }
    
    let OpenIDConfiguration { jwks_uri, .. } = serde_json::from_slice(&bytes)?;
    Ok(jwks_uri)
}

pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = ClientBuilder::new()
        .timeout(REQUEST_TIMEOUT)
        .build()?;
        
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    
    let response = request_builder.send().await?;
    let content_length = response.content_length().unwrap_or(0);
    
    if content_length > MAX_JWKS_RESPONSE_SIZE as u64 {
        return Err(anyhow::anyhow!(
            "JWKs response too large: {} bytes", 
            content_length
        ));
    }
    
    let bytes = response.bytes().await?;
    if bytes.len() > MAX_JWKS_RESPONSE_SIZE {
        return Err(anyhow::anyhow!(
            "JWKs response too large: {} bytes", 
            bytes.len()
        ));
    }
    
    let JWKsResponse { keys } = serde_json::from_slice(&bytes)?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**Additional mitigations:**
1. Add circuit breaker logic in `JWKObserver` to stop retrying after consecutive failures
2. Implement monitoring/alerting for abnormal response sizes
3. Add rate limiting to prevent rapid retry loops
4. Consider using streaming JSON parsers for large responses

## Proof of Concept

```rust
// Test demonstrating memory exhaustion vulnerability
// Place in crates/jwk-utils/src/lib.rs

#[cfg(test)]
mod vulnerability_tests {
    use super::*;
    use tokio::net::TcpListener;
    use tokio::io::AsyncWriteExt;
    
    #[tokio::test]
    async fn test_large_openid_config_dos() {
        // Spawn malicious HTTP server
        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let addr = listener.local_addr().unwrap();
        
        tokio::spawn(async move {
            let (mut socket, _) = listener.accept().await.unwrap();
            
            // Send HTTP headers
            socket.write_all(b"HTTP/1.1 200 OK\r\n").await.unwrap();
            socket.write_all(b"Content-Type: application/json\r\n").await.unwrap();
            socket.write_all(b"Content-Length: 100000000\r\n\r\n").await.unwrap();
            
            // Send large JSON payload
            socket.write_all(b"{\"issuer\":\"test\",\"jwks_uri\":\"test\",\"padding\":\"").await.unwrap();
            
            // Stream 100MB of data
            let chunk = vec![b'A'; 1024 * 1024]; // 1MB chunks
            for _ in 0..100 {
                socket.write_all(&chunk).await.unwrap();
            }
            
            socket.write_all(b"\"}").await.unwrap();
        });
        
        let url = format!("http://{}", addr);
        
        // This should cause memory exhaustion
        // In a real validator, this would repeat every 10 seconds
        let result = fetch_jwks_uri_from_openid_config(&url).await;
        
        // Without size limits, this will consume 100MB+ RAM
        // With proper limits, this should fail gracefully
        assert!(result.is_err(), "Should reject oversized responses");
    }
    
    #[tokio::test]
    async fn test_large_jwks_response_dos() {
        // Similar test for fetch_jwks_from_jwks_uri
        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let addr = listener.local_addr().unwrap();
        
        tokio::spawn(async move {
            let (mut socket, _) = listener.accept().await.unwrap();
            socket.write_all(b"HTTP/1.1 200 OK\r\n").await.unwrap();
            socket.write_all(b"Content-Type: application/json\r\n").await.unwrap();
            socket.write_all(b"Content-Length: 100000000\r\n\r\n").await.unwrap();
            socket.write_all(b"{\"keys\":[").await.unwrap();
            
            let chunk = vec![b'A'; 1024 * 1024];
            for _ in 0..100 {
                socket.write_all(&chunk).await.unwrap();
            }
            
            socket.write_all(b"]}").await.unwrap();
        });
        
        let url = format!("http://{}", addr);
        let result = fetch_jwks_from_jwks_uri(None, &url).await;
        
        assert!(result.is_err(), "Should reject oversized responses");
    }
}
```

**Notes**

The vulnerability exists because validators trust external OIDC provider endpoints without validating response sizes. While these URLs are governance-controlled, the actual HTTP endpoints are external infrastructure outside Aptos' security perimeter. The lack of basic HTTP hygiene (timeouts, size limits) creates a critical DoS vector that could impact network liveness. The fix is straightforward: implement standard HTTP client protections including response size limits, timeouts, and proper error handling.

### Citations

**File:** crates/jwk-utils/src/lib.rs (L10-19)
```rust
#[derive(Serialize, Deserialize)]
struct OpenIDConfiguration {
    issuer: String,
    jwks_uri: String,
}

#[derive(Serialize, Deserialize)]
struct JWKsResponse {
    keys: Vec<serde_json::Value>,
}
```

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** crates/jwk-utils/src/lib.rs (L40-44)
```rust
pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L317-330)
```text
    public fun upsert_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>, config_url: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };

        let old_config_url = remove_oidc_provider_internal(&mut provider_set, name);
        vector::push_back(&mut provider_set.providers, OIDCProvider { name, config_url });
        config_buffer::upsert(provider_set);
        old_config_url
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L51-89)
```rust
    async fn start(
        fetch_interval: Duration,
        my_addr: AccountAddress,
        issuer: String,
        open_id_config_url: String,
        observation_tx: aptos_channel::Sender<(), (Issuer, Vec<JWK>)>,
        close_rx: oneshot::Receiver<()>,
    ) {
        let mut interval = tokio::time::interval(fetch_interval);
        interval.set_missed_tick_behavior(MissedTickBehavior::Delay);
        let mut close_rx = close_rx.into_stream();
        let my_addr = if cfg!(feature = "smoke-test") {
            // Include self validator address in JWK request,
            // so dummy OIDC providers in smoke tests can do things like "key A for validator 1, key B for validator 2".
            Some(my_addr)
        } else {
            None
        };

        loop {
            tokio::select! {
                _ = interval.tick().fuse() => {
                    let timer = Instant::now();
                    let result = fetch_jwks(open_id_config_url.as_str(), my_addr).await;
                    debug!(issuer = issuer, "observe_result={:?}", result);
                    let secs = timer.elapsed().as_secs_f64();
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
                    } else {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "err"]).observe(secs);
                    }
                },
                _ = close_rx.select_next_some() => {
                    break;
                }
            }
        }
```
