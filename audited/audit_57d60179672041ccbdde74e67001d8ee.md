# Audit Report

## Title
Non-Deterministic HashMap Serialization in OnChainConsensusConfig Violates Consensus Determinism Invariant

## Summary
The fuzzing infrastructure does not validate that schema decoding is deterministic across multiple runs and platforms. The `OnChainConsensusConfig` type contains a `ProposerElectionType::RoundProposer` variant with a `HashMap<Round, AccountAddress>` that is BCS-serialized for governance proposals, violating the codebase's documented requirement for deterministic data structures in consensus-critical code. This creates a potential consensus failure vector if validators independently serialize configuration data.

## Finding Description

The schema fuzzing tests use `assert_encode_decode` which only validates round-trip correctness but does not verify deterministic encoding: [1](#0-0) 

This function tests that `encode(x) → decode → y` where `x == y`, but never validates that multiple invocations of `encode(x)` produce identical byte sequences, which is critical for consensus determinism.

The codebase explicitly documents that HashMap lacks deterministic iteration order and should not be used for serialization: [2](#0-1) 

Despite this guidance, `ProposerElectionType::RoundProposer` contains a HashMap that is part of the consensus configuration: [3](#0-2) 

This configuration is serialized with BCS for governance proposals: [4](#0-3) 

The codebase demonstrates awareness of this issue by explicitly converting HashMap to BTreeMap when deterministic serialization is required: [5](#0-4) 

**Attack Vector:**
1. Governance participant creates a proposal to update consensus config using RoundProposer variant
2. The HashMap iteration order is implementation-defined and may vary between platforms/runs
3. Multiple serializations of the logically identical config produce different byte sequences
4. If validators independently serialize configs for verification or caching, they may compute different hashes
5. This breaks the "Deterministic Execution" invariant where all validators must produce identical state

## Impact Explanation

**Severity: Medium to High**

This violates the first critical invariant: "All validators must produce identical state roots for identical blocks." While the issue is currently mitigated by RoundProposer not being used in default configurations, it represents a **design vulnerability** in the validation infrastructure:

1. **Fuzzing Gap**: The lack of determinism validation means any future schema changes introducing non-deterministic types would pass all tests
2. **Consensus Risk**: If RoundProposer is enabled via governance, different nodes could produce different serializations during config updates or verification
3. **Transaction Determinism**: Governance proposals with identical logical content could have different transaction hashes depending on serialization order

This qualifies as **Medium Severity** per the bug bounty criteria ("State inconsistencies requiring intervention") with potential escalation to **High Severity** if RoundProposer is actively used in production.

## Likelihood Explanation

**Current Likelihood: LOW to MEDIUM**

The issue is currently low likelihood because:
- RoundProposer is not used in default genesis configuration (uses LeaderReputation instead): [6](#0-5) 

- Primary usage is in test code
- Config is typically deserialized once per epoch and used in memory

However, likelihood increases to MEDIUM if:
- Governance activates RoundProposer for specific network scenarios
- Future config types introduce HashMap without validation
- Config verification or caching logic performs re-serialization

## Recommendation

**Immediate Fix:**
1. Replace HashMap with BTreeMap in ProposerElectionType::RoundProposer:
```rust
pub enum ProposerElectionType {
    RoundProposer(BTreeMap<Round, AccountAddress>), // Changed from HashMap
}
```

2. Enhance schema fuzzing to validate deterministic encoding:
```rust
pub fn assert_deterministic_encode<S: Schema>(value: &S::Value) {
    let bytes1 = value.encode_value().expect("First encoding should work");
    let bytes2 = value.encode_value().expect("Second encoding should work");
    assert_eq!(bytes1, bytes2, "Encoding must be deterministic");
    
    let decoded = S::Value::decode_value(&bytes1).expect("Decoding should work");
    let bytes3 = decoded.encode_value().expect("Re-encoding should work");
    assert_eq!(bytes1, bytes3, "Re-encoding must produce identical bytes");
}
```

3. Add this validation to the test_no_panic_decoding macro

**Long-term:**
- Audit all on-chain config types for HashMap usage
- Add clippy lint to prevent HashMap in types implementing OnChainConfig
- Document determinism requirements in schema trait documentation

## Proof of Concept

```rust
use aptos_types::on_chain_config::{OnChainConsensusConfig, ConsensusConfigV1, ProposerElectionType};
use std::collections::HashMap;
use move_core_types::account_address::AccountAddress;

#[test]
fn test_non_deterministic_serialization() {
    // Create two identical HashMaps with different insertion orders
    let mut map1 = HashMap::new();
    map1.insert(1u64, AccountAddress::random());
    map1.insert(2u64, AccountAddress::random());
    
    let mut map2 = HashMap::new();
    // Insert in reverse order
    map2.insert(2u64, map1[&2u64]);
    map2.insert(1u64, map1[&1u64]);
    
    let config1 = OnChainConsensusConfig::V1(ConsensusConfigV1 {
        proposer_election_type: ProposerElectionType::RoundProposer(map1),
        ..ConsensusConfigV1::default()
    });
    
    let config2 = OnChainConsensusConfig::V1(ConsensusConfigV1 {
        proposer_election_type: ProposerElectionType::RoundProposer(map2),
        ..ConsensusConfigV1::default()
    });
    
    // Serialize both
    let bytes1 = bcs::to_bytes(&config1).unwrap();
    let bytes2 = bcs::to_bytes(&config2).unwrap();
    
    // These MAY be different due to HashMap iteration order
    // This demonstrates the non-determinism risk
    if bytes1 != bytes2 {
        println!("Non-deterministic serialization detected!");
        println!("Same logical config, different bytes");
    }
}
```

**Notes:**
- This issue exists at the intersection of fuzzing validation and type design
- The schema fuzzing framework passes types with HashMap because it only validates round-trip correctness
- The codebase's own security guidelines prohibit HashMap for this exact reason, but enforcement is manual
- RoundProposer usage in tests shows the type is functional but potentially unsafe for production consensus

### Citations

**File:** storage/schemadb/src/schema.rs (L152-163)
```rust
    pub fn assert_encode_decode<S: Schema>(key: &S::Key, value: &S::Value) {
        {
            let encoded = key.encode_key().expect("Encoding key should work.");
            let decoded = S::Key::decode_key(&encoded).expect("Decoding key should work.");
            assert_eq!(*key, decoded);
        }
        {
            let encoded = value.encode_value().expect("Encoding value should work.");
            let decoded = S::Value::decode_value(&encoded).expect("Decoding value should work.");
            assert_eq!(*value, decoded);
        }
    }
```

**File:** RUST_SECURE_CODING.md (L121-131)
```markdown
### Data Structures with Deterministic Internal Order

Certain data structures, like HashMap and HashSet, do not guarantee a deterministic order for the elements stored within them. This lack of order can lead to problems in operations that require processing elements in a consistent sequence across multiple executions. In the Aptos blockchain, deterministic data structures help in achieving consensus, maintaining the integrity of the ledger, and ensuring that computations can be reliably reproduced across different nodes.

Below is a list of deterministic data structures available in Rust. Please note, this list may not be exhaustive:

- **BTreeMap:** maintains its elements in sorted order by their keys.
- **BinaryHeap:** It maintains its elements in a heap order, which is a complete binary tree where each parent node is less than or equal to its child nodes.
- **Vec**: It maintains its elements in the order in which they were inserted. ⚠️
- **LinkedList:** It maintains its elements in the order in which they were inserted. ⚠️
- **VecDeque:** It maintains its elements in the order in which they were inserted. ⚠️
```

**File:** types/src/on_chain_config/consensus_config.rs (L481-505)
```rust
impl Default for ConsensusConfigV1 {
    fn default() -> Self {
        Self {
            decoupled_execution: true,
            back_pressure_limit: 10,
            exclude_round: 40,
            max_failed_authors_to_store: 10,
            proposer_election_type: ProposerElectionType::LeaderReputation(
                LeaderReputationType::ProposerAndVoterV2(ProposerAndVoterConfig {
                    active_weight: 1000,
                    inactive_weight: 10,
                    failed_weight: 1,
                    failure_threshold_percent: 10, // = 10%
                    // In each round we get stastics for the single proposer
                    // and large number of validators. So the window for
                    // the proposers needs to be significantly larger
                    // to have enough useful statistics.
                    proposer_window_num_validators_multiplier: 10,
                    voter_window_num_validators_multiplier: 1,
                    weight_by_voting_power: true,
                    use_history_from_previous_epoch_max_count: 5,
                }),
            ),
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L508-523)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "snake_case")] // cannot use tag = "type" as nested enums cannot work, and bcs doesn't support it
pub enum ProposerElectionType {
    // Choose the smallest PeerId as the proposer
    // with specified param contiguous_rounds
    FixedProposer(u32),
    // Round robin rotation of proposers
    // with specified param contiguous_rounds
    RotatingProposer(u32),
    // Committed history based proposer election
    LeaderReputation(LeaderReputationType),
    // Pre-specified proposers for each round,
    // or default proposer if round proposer not
    // specified
    RoundProposer(HashMap<Round, AccountAddress>),
}
```

**File:** aptos-move/aptos-release-builder/src/components/consensus_config.rs (L33-34)
```rust
            let consensus_config_blob = bcs::to_bytes(consensus_config).unwrap();
            assert!(consensus_config_blob.len() < 65536);
```

**File:** aptos-move/aptos-transaction-simulation-session/src/delta.rs (L15-17)
```rust
pub fn save_delta(delta_path: &Path, delta: &HashMap<StateKey, Option<StateValue>>) -> Result<()> {
    // Use BTreeMap to ensure deterministic ordering
    let mut delta_str = BTreeMap::new();
```
