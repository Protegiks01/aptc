# Audit Report

## Title
HTTP Method String Injection Causes Prometheus Metrics Cardinality Explosion in API Logging Middleware

## Summary
The API logging middleware in `api/src/log.rs` uses arbitrary HTTP method strings directly as Prometheus metric labels without validation or sanitization. This allows attackers to inject unlimited unique method strings (e.g., CONNECT, FOOBAR, METHOD1, METHOD2, etc.), causing unbounded metric cardinality growth that can exhaust memory in the metrics collection system and degrade observability infrastructure.

## Finding Description

The vulnerability exists in the request logging flow where HTTP methods are captured and used as metric labels: [1](#0-0) 

The HTTP method is cloned from the incoming request without any validation. The `Method` type from the `poem` framework (which re-exports from the Rust `http` crate) supports not only standard HTTP methods but also arbitrary extension methods per RFC 7231. [2](#0-1) 

The method string is then used directly as a label in the `HISTOGRAM` metric. The Prometheus metric is defined with "method" as one of its label dimensions: [3](#0-2) 

The logging middleware is attached using `.around()` which wraps the entire route handler: [4](#0-3) 

Critically, the middleware executes **before** any route matching or method validation by the OpenAPI framework. While CORS is configured to allow only GET and POST: [5](#0-4) 

CORS validation only occurs for browser-initiated cross-origin requests. Non-browser clients and same-origin requests can send arbitrary HTTP methods that bypass CORS checks but still get logged with metrics recorded.

**Attack Flow:**
1. Attacker sends HTTP requests with arbitrary method strings (CONNECT, PATCH, DELETE, FOOBAR, METHOD_1, METHOD_2, ...)
2. Each request reaches `middleware_log()` before route/method validation
3. Method string is cloned and later converted via `.as_str()` to create a unique Prometheus metric series
4. Each unique method creates a new time series: `aptos_api_requests{method="FOOBAR", operation_id="...", status="..."}`
5. Prometheus stores all unique time series in memory
6. Sustained attack with many unique methods causes memory exhaustion and metrics system degradation

## Impact Explanation

This issue is classified as **Low Severity** according to the Aptos bug bounty program criteria. It affects observability infrastructure rather than core blockchain functionality:

- **No funds at risk**: Cannot steal, mint, or freeze tokens
- **No consensus impact**: Does not affect AptosBFT safety or liveness
- **No blockchain state impact**: Cannot corrupt state, manipulate governance, or affect validators
- **Limited to monitoring**: Only impacts the Prometheus metrics collection and scraping

The impact is constrained to:
- Increased memory consumption in metrics exporters and Prometheus servers
- Slower metrics queries and scraping
- Potential degradation or failure of monitoring dashboards
- Does not affect the API's core transaction processing functionality

While this could theoretically be leveraged as part of a broader attack to blind operators to other issues, it does not directly compromise any blockchain security guarantees.

## Likelihood Explanation

**Likelihood: Medium**

The attack is straightforward to execute:
- Requires no authentication or special privileges
- Public API endpoints are accessible to any network client
- Simple to script arbitrary HTTP method requests
- No rate limiting specifically on method diversity

However:
- Requires knowledge of the specific vulnerability
- Needs sustained attack to have significant impact
- Monitoring systems typically have their own resource limits
- Operators would likely notice and mitigate anomalous traffic patterns

## Recommendation

Implement method validation and normalization in the logging middleware to limit metric label cardinality:

```rust
// In api/src/log.rs, around line 61
fn normalize_method(method: &Method) -> &'static str {
    match method {
        &Method::GET => "GET",
        &Method::POST => "POST",
        &Method::PUT => "PUT",
        &Method::DELETE => "DELETE",
        &Method::PATCH => "PATCH",
        &Method::HEAD => "HEAD",
        &Method::OPTIONS => "OPTIONS",
        _ => "OTHER", // Group all non-standard methods
    }
}

// Then in the HttpRequestLog struct initialization:
let mut log = HttpRequestLog {
    remote_addr: request.remote_addr().as_socket_addr().cloned(),
    method: request.method().clone(), // Keep original for logging
    // ...
};

// And when recording metrics, use the normalized version:
HISTOGRAM
    .with_label_values(&[
        normalize_method(&log.method), // Use normalized method
        operation_id,
        log.status.to_string().as_str(),
    ])
    .observe(elapsed.as_secs_f64());
```

Alternatively, add method validation at the routing layer to reject unsupported methods earlier, though this alone won't prevent the metrics issue if logging occurs first.

## Proof of Concept

```rust
// Save as: api/tests/method_cardinality_test.rs
#[cfg(test)]
mod method_cardinality_tests {
    use reqwest;
    use std::time::Duration;

    #[tokio::test]
    async fn test_arbitrary_method_creates_metrics() {
        // Start test API server (assumes test context available)
        let api_url = "http://localhost:8080/v1/";
        
        let client = reqwest::Client::new();
        
        // Send requests with various arbitrary methods
        let arbitrary_methods = vec![
            "CONNECT", "TRACE", "FOOBAR", "CUSTOM1", 
            "CUSTOM2", "CUSTOM3", "ARBITRARY_METHOD_123"
        ];
        
        for method in arbitrary_methods {
            let request = client
                .request(reqwest::Method::from_bytes(method.as_bytes()).unwrap(), api_url)
                .timeout(Duration::from_secs(5))
                .send()
                .await;
                
            // Request may fail with 404/405, but metrics are still recorded
            println!("Sent request with method: {}, response: {:?}", 
                     method, request.map(|r| r.status()));
        }
        
        // Check metrics endpoint to verify unique time series created
        let metrics_response = client
            .get("http://localhost:9101/metrics")
            .send()
            .await
            .unwrap()
            .text()
            .await
            .unwrap();
            
        // Verify that arbitrary methods appear in metrics
        for method in ["FOOBAR", "CUSTOM1", "ARBITRARY_METHOD_123"] {
            assert!(
                metrics_response.contains(&format!("method=\"{}\"", method)),
                "Method {} should appear in metrics", method
            );
        }
    }
}
```

**Notes:**
- This vulnerability is classified as **Low Severity** per Aptos bug bounty criteria
- It does not affect any of the 10 critical blockchain invariants (deterministic execution, consensus safety, Move VM safety, state consistency, governance integrity, staking security, transaction validation, access control, resource limits for blockchain operations, or cryptographic correctness)
- The issue affects operational monitoring infrastructure, not core blockchain security
- While exploitable and concrete, the impact is limited to observability degradation rather than blockchain compromise

### Citations

**File:** api/src/log.rs (L54-62)
```rust
pub async fn middleware_log<E: Endpoint>(next: E, request: Request) -> Result<Response> {
    let start = std::time::Instant::now();

    let (trace_id, span_id) = extract_trace_context(&request);

    let mut log = HttpRequestLog {
        remote_addr: request.remote_addr().as_socket_addr().cloned(),
        method: request.method().clone(),
        path: request.uri().path().to_string(),
```

**File:** api/src/log.rs (L115-121)
```rust
    HISTOGRAM
        .with_label_values(&[
            log.method.as_str(),
            operation_id,
            log.status.to_string().as_str(),
        ])
        .observe(elapsed.as_secs_f64());
```

**File:** api/src/metrics.rs (L31-39)
```rust
pub static HISTOGRAM: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "aptos_api_requests",
        "API requests latency grouped by method, operation_id and status",
        &["method", "operation_id", "status"],
        SUB_MS_BUCKETS.to_vec()
    )
    .unwrap()
});
```

**File:** api/src/runtime.rs (L229-259)
```rust
    runtime_handle.spawn(async move {
        let cors = Cors::new()
            // To allow browsers to use cookies (for cookie-based sticky
            // routing in the LB) we must enable this:
            // https://stackoverflow.com/a/24689738/3846032
            .allow_credentials(true)
            .allow_methods(vec![Method::GET, Method::POST]);

        // Build routes for the API
        let route = Route::new()
            .at("/", poem::get(root_handler))
            .nest(
                "/v1",
                Route::new()
                    .nest("/", api_service)
                    .at("/spec.json", poem::get(spec_json))
                    .at("/spec.yaml", poem::get(spec_yaml))
                    // TODO: We add this manually outside of the OpenAPI spec for now.
                    // https://github.com/poem-web/poem/issues/364
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
            )
            .with(cors)
            .with_if(config.api.compression_enabled, Compression::new())
            .with(PostSizeLimit::new(size_limit))
            .with(CatchPanic::new().with_handler(panic_handler))
            // NOTE: Make sure to keep this after all the `with` middleware.
            .catch_all_error(convert_error)
            .around(middleware_log);
```
