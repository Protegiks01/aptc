# Audit Report

## Title
Pending Active Validators Can Bypass Stake Lockup Period Through Early Exit

## Summary
Validators who join the validator set but call `leave_validator_set()` before the first epoch transition can immediately withdraw their stake without waiting for the lockup period, completely bypassing the stake lockup mechanism designed to prevent immediate unstaking attacks.

## Finding Description

The Aptos staking system enforces a lockup period (defined by `recurring_lockup_duration_secs`) to prevent validators from immediately unstaking after joining the validator set. This lockup mechanism is critical for network security, as it ensures validators have "skin in the game" and cannot rapidly enter/exit to manipulate voting power or avoid penalties.

However, a critical vulnerability exists in the validator lifecycle:

When a stake pool is initialized, the `locked_until_secs` field is set to 0. [1](#0-0) 

The lockup is only set when a validator becomes active during the `on_new_epoch()` epoch transition, which automatically renews lockup for active validators. [2](#0-1) 

The `leave_validator_set()` function has special handling for validators still in PENDING_ACTIVE status - it directly removes them from the pending_active list without moving them to pending_inactive. [3](#0-2) 

This means if a validator leaves before their first epoch as an active validator, their `locked_until_secs` remains 0. The `withdraw_with_cap()` function has an edge case handler that allows immediate withdrawal when a validator is INACTIVE and the lockup has expired. [4](#0-3) 

Since `timestamp::now_seconds() >= 0` is always true, this condition is satisfied immediately.

**Attack Path:**
1. Attacker initializes a validator stake pool (lockup = 0)
2. Attacker calls `join_validator_set()` → status becomes PENDING_ACTIVE
3. Attacker calls `add_stake(X)` → X coins added to active pool (for PENDING_ACTIVE validators, stake goes to `active` not `pending_active`) [5](#0-4) 
4. Before the next epoch, attacker calls `leave_validator_set()` → removed from pending_active, status becomes INACTIVE, lockup still 0
5. Attacker calls `unlock(X)` → moves stake from active to pending_inactive [6](#0-5) 
6. Attacker calls `withdraw(X)` → edge case handler moves pending_inactive to inactive (because validator is INACTIVE AND timestamp >= 0), withdrawal succeeds immediately

## Impact Explanation

**Severity: HIGH (up to $50,000)**

This vulnerability breaks the fundamental staking security invariant that validator stake must remain locked for a minimum duration. The lockup mechanism serves several critical purposes:

1. **Prevent rapid validator churn** - Attackers could join/leave repeatedly to manipulate the validator set
2. **Ensure accountability** - Validators should have locked stake during their tenure to be penalized for misbehavior
3. **Voting power stability** - Prevents manipulation of governance voting power through rapid stake movements
4. **Economic security** - Creates a commitment period that aligns validator incentives with network health

This qualifies as a "Significant protocol violation" under the High Severity category, as it completely bypasses a core security mechanism of the staking system.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is:
- **Easy to discover**: The attack path is straightforward and requires no special knowledge
- **Simple to execute**: Only requires calling standard staking functions in sequence
- **No special conditions**: Works for any validator at any time
- **Deterministic**: Always succeeds when executed correctly
- **Undetectable**: Appears as normal validator operations

The only requirement is having enough stake to meet the minimum validator requirements, which is publicly known and easily achievable.

## Recommendation

**Fix Option 1: Set initial lockup when joining validator set**

Modify `join_validator_set_internal()` to set an initial lockup period:

```move
public(friend) fun join_validator_set_internal(
    operator: &signer,
    pool_address: address
) acquires StakePool, ValidatorConfig, ValidatorSet {
    // ... existing validation ...
    
    let stake_pool = borrow_global_mut<StakePool>(pool_address);
    
    // Set initial lockup if not already set
    if (stake_pool.locked_until_secs == 0) {
        let config = staking_config::get();
        let recurring_lockup = staking_config::get_recurring_lockup_duration(&config);
        stake_pool.locked_until_secs = timestamp::now_seconds() + recurring_lockup;
    };
    
    // ... rest of function ...
}
```

**Fix Option 2: Enforce lockup in withdraw regardless of validator status**

Modify `withdraw_with_cap()` to always enforce lockup:

```move
public fun withdraw_with_cap(
    owner_cap: &OwnerCapability,
    withdraw_amount: u64
): Coin<AptosCoin> acquires StakePool, ValidatorSet {
    assert_reconfig_not_in_progress();
    let pool_address = owner_cap.pool_address;
    assert_stake_pool_exists(pool_address);
    let stake_pool = borrow_global_mut<StakePool>(pool_address);
    
    // Always enforce lockup expiration before allowing withdrawal
    assert!(
        timestamp::now_seconds() >= stake_pool.locked_until_secs,
        error::invalid_state(EINVALID_LOCKUP)
    );
    
    // Edge case handler only for moving pending_inactive to inactive
    if (get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE) {
        let pending_inactive_stake = coin::extract_all(&mut stake_pool.pending_inactive);
        coin::merge(&mut stake_pool.inactive, pending_inactive_stake);
    };
    
    // ... rest of function ...
}
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, validator = @0x123)]
public entry fun test_pending_active_validator_immediate_withdraw_exploit(
    aptos_framework: &signer,
    validator: &signer,
) acquires AllowedValidators, OwnerCapability, StakePool, ValidatorConfig, ValidatorSet {
    initialize_for_test(aptos_framework);
    
    // Step 1: Validator initializes with stake (lockup = 0 by default)
    let validator_address = signer::address_of(validator);
    let (_sk, pk, pop) = generate_identity();
    initialize_test_validator(&pk, &pop, validator, 100, true, false);
    
    // Verify validator is pending_active
    assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_PENDING_ACTIVE, 0);
    
    // Verify lockup is 0
    assert!(get_lockup_secs(validator_address) == 0, 1);
    
    // Step 2: Leave before epoch transition
    leave_validator_set(validator, validator_address);
    
    // Verify validator is now inactive
    assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_INACTIVE, 2);
    
    // Verify lockup is still 0 (never got set!)
    assert!(get_lockup_secs(validator_address) == 0, 3);
    
    // Step 3: Unlock stake
    unlock(validator, 100);
    
    // Step 4: Withdraw immediately (should fail but succeeds due to bug!)
    let (_, _, _, pending_inactive) = get_stake(validator_address);
    assert!(pending_inactive == 100, 4);
    
    // This withdrawal succeeds immediately without waiting for lockup!
    withdraw(validator, 100);
    
    // Verify stake was withdrawn successfully
    let (_, inactive, _, _) = get_stake(validator_address);
    assert!(inactive == 0, 5); // All stake withdrawn
}
```

## Notes

The existing test `test_pending_active_validator_leaves_validator_set` validates that the validator status transitions correctly but does not test whether the lockup is enforced during withdrawal. [7](#0-6) 

This vulnerability affects the core staking invariant and should be patched immediately to prevent exploitation on mainnet.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L700-705)
```text
        move_to(owner, StakePool {
            active: coin::zero<AptosCoin>(),
            pending_active: coin::zero<AptosCoin>(),
            pending_inactive: coin::zero<AptosCoin>(),
            inactive: coin::zero<AptosCoin>(),
            locked_until_secs: 0,
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L837-841)
```text
        if (is_current_epoch_validator(pool_address)) {
            coin::merge<AptosCoin>(&mut stake_pool.pending_active, coins);
        } else {
            coin::merge<AptosCoin>(&mut stake_pool.active, coins);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1117-1132)
```text
    public fun unlock_with_cap(amount: u64, owner_cap: &OwnerCapability) acquires StakePool {
        assert_reconfig_not_in_progress();
        // Short-circuit if amount to unlock is 0 so we don't emit events.
        if (amount == 0) {
            return
        };

        // Unlocked coins are moved to pending_inactive. When the current lockup cycle expires, they will be moved into
        // inactive in the earliest possible epoch transition.
        let pool_address = owner_cap.pool_address;
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        // Cap amount to unlock by maximum active stake.
        let amount = min(amount, coin::value(&stake_pool.active));
        let unlocked_stake = coin::extract(&mut stake_pool.active, amount);
        coin::merge<AptosCoin>(&mut stake_pool.pending_inactive, unlocked_stake);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1174-1181)
```text
        // There's an edge case where a validator unlocks their stake and leaves the validator set before
        // the stake is fully unlocked (the current lockup cycle has not expired yet).
        // This can leave their stake stuck in pending_inactive even after the current lockup cycle expires.
        if (get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE &&
            timestamp::now_seconds() >= stake_pool.locked_until_secs) {
            let pending_inactive_stake = coin::extract_all(&mut stake_pool.pending_inactive);
            coin::merge(&mut stake_pool.inactive, pending_inactive_stake);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1231-1248)
```text
        // If the validator is still pending_active, directly kick the validator out.
        let maybe_pending_active_index = find_validator(&validator_set.pending_active, pool_address);
        if (option::is_some(&maybe_pending_active_index)) {
            vector::swap_remove(
                &mut validator_set.pending_active, option::extract(&mut maybe_pending_active_index));

            // Decrease the voting power increase as the pending validator's voting power was added when they requested
            // to join. Now that they changed their mind, their voting power should not affect the joining limit of this
            // epoch.
            let validator_stake = (get_next_epoch_voting_power(stake_pool) as u128);
            // total_joining_power should be larger than validator_stake but just in case there has been a small
            // rounding error somewhere that can lead to an underflow, we still want to allow this transaction to
            // succeed.
            if (validator_set.total_joining_power > validator_stake) {
                validator_set.total_joining_power = validator_set.total_joining_power - validator_stake;
            } else {
                validator_set.total_joining_power = 0;
            };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1435-1449)
```text
            // Automatically renew a validator's lockup for validators that will still be in the validator set in the
            // next epoch.
            let stake_pool = borrow_global_mut<StakePool>(validator_info.addr);
            let now_secs = timestamp::now_seconds();
            let reconfig_start_secs = if (chain_status::is_operating()) {
                get_reconfig_start_time_secs()
            } else {
                now_secs
            };
            if (stake_pool.locked_until_secs <= reconfig_start_secs) {
                spec {
                    assume now_secs + recurring_lockup_duration_secs <= MAX_U64;
                };
                stake_pool.locked_until_secs = now_secs + recurring_lockup_duration_secs;
            };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L2372-2392)
```text
    public entry fun test_pending_active_validator_leaves_validator_set(
        aptos_framework: &signer,
        validator: &signer,
    ) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, PendingTransactionFee, StakePool, TransactionFeeConfig, ValidatorConfig, ValidatorPerformance, ValidatorSet {
        initialize_for_test(aptos_framework);
        // Validator joins but epoch hasn't ended, so the validator is still pending_active.
        let (_sk, pk, pop) = generate_identity();
        initialize_test_validator(&pk, &pop, validator, 100, true, false);
        let validator_address = signer::address_of(validator);
        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_PENDING_ACTIVE, 0);

        // Check that voting power increase is tracked.
        assert!(borrow_global<ValidatorSet>(@aptos_framework).total_joining_power == 100, 0);

        // Leave the validator set immediately.
        leave_validator_set(validator, validator_address);
        assert!(get_validator_state(validator_address) == VALIDATOR_STATUS_INACTIVE, 1);

        // Check that voting power increase has been decreased when the pending active validator leaves.
        assert!(borrow_global<ValidatorSet>(@aptos_framework).total_joining_power == 0, 1);
    }
```
