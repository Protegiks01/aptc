# Audit Report

## Title
Lack of Parameter Validation in StateComputer::new_epoch() Allows Invalid Epoch State Acceptance Leading to Validator Node Crashes

## Summary
The `new_epoch()` function in `ExecutionProxy` (implementing `StateComputer` trait) accepts an `EpochState` parameter without validating that it contains a non-empty validator set, non-zero total voting power, or valid cryptographic parameters. This lack of defensive validation creates a critical failure point where downstream code panics when processing an invalid epoch state.

## Finding Description

The `StateComputer::new_epoch()` function is responsible for configuring consensus execution for a new epoch. The implementation in `ExecutionProxy` directly accepts and stores the provided `EpochState` without any validation: [1](#0-0) 

The function extracts validators from `epoch_state.verifier.get_ordered_account_addresses_iter()` and stores them without checking if the validator set is empty or if the total voting power is zero.

The `ValidatorVerifier` type explicitly supports empty validator sets, setting both `quorum_voting_power` and `total_voting_power` to zero: [2](#0-1) 

Furthermore, `EpochState` provides an `empty()` constructor that creates an instance with no validators: [3](#0-2) 

When this invalid `EpochState` propagates through the consensus initialization in `start_new_epoch()`: [4](#0-3) 

The code proceeds to call `create_proposer_election()` which expects at least one proposer and panics if the list is empty: [5](#0-4) 

This panic with "INVARIANT VIOLATION: proposers is empty" immediately crashes the validator node, causing total loss of consensus participation.

## Impact Explanation

**Critical Severity** - This vulnerability constitutes a **Total loss of liveness/network availability** attack vector:

1. **Validator Node Crash**: If an invalid `EpochState` with empty validators reaches `new_epoch()`, the node will panic and crash when `create_proposer_election()` is called, terminating the consensus process.

2. **Network-Wide Impact**: If multiple validators process the same invalid epoch state (e.g., from a maliciously crafted or buggy on-chain configuration), the entire network could halt simultaneously.

3. **Non-Recoverable Without Intervention**: The panic occurs during epoch initialization, making automatic recovery impossible. Validators would need manual intervention or code patches to restart.

4. **Bypasses Safety Mechanisms**: With `quorum_voting_power = 0` and `total_voting_power = 0`, signature verification checks would accept trivial voting power thresholds, potentially allowing consensus bypass if the crash could be avoided: [6](#0-5) 

The lack of defensive validation violates **Critical Invariant #2 (Consensus Safety)** and **Critical Invariant #10 (Cryptographic Correctness)** by allowing mathematically invalid consensus configurations.

## Likelihood Explanation

**Likelihood: Low to Medium** (with conditions)

**Exploitation Requirements:**
1. An attacker would need to cause an invalid `ValidatorSet` to be committed to blockchain state, which requires either:
   - Finding a separate vulnerability in the Move staking framework that bypasses minimum stake validation
   - Gaining control of on-chain governance to push malicious configuration changes
   - Exploiting a deserialization bug that produces invalid `EpochState` from corrupted data

**Mitigating Factors:**
- The Move staking framework has validation that requires minimum stake thresholds
- Normal epoch transitions derive `EpochState` from on-chain validator sets that should be properly validated
- Multiple layers of the system expect valid epoch states

**Aggravating Factors:**
- The code explicitly supports empty validator sets (see `EpochState::empty()` and `ValidatorVerifier::new()` empty case handling)
- No defensive checks exist at the critical `new_epoch()` entry point
- The panic is unrecoverable and affects all validators processing the same invalid state

While direct exploitation requires breaching upstream validation, this represents a **defense-in-depth failure** where a single bug in any upstream component could trigger catastrophic node crashes.

## Recommendation

Add comprehensive parameter validation to `StateComputer::new_epoch()` to reject invalid epoch states:

```rust
fn new_epoch(
    &self,
    epoch_state: &EpochState,
    payload_manager: Arc<dyn TPayloadManager>,
    transaction_shuffler: Arc<dyn TransactionShuffler>,
    block_executor_onchain_config: BlockExecutorConfigFromOnchain,
    transaction_deduper: Arc<dyn TransactionDeduper>,
    randomness_enabled: bool,
    consensus_onchain_config: OnChainConsensusConfig,
    persisted_auxiliary_info_version: u8,
    network_sender: Arc<NetworkSender>,
) {
    // Validate epoch state parameters
    if epoch_state.verifier.is_empty() {
        panic!("FATAL: Cannot start epoch {} with empty validator set", epoch_state.epoch);
    }
    
    if epoch_state.verifier.total_voting_power() == 0 {
        panic!("FATAL: Cannot start epoch {} with zero total voting power", epoch_state.epoch);
    }
    
    if epoch_state.verifier.quorum_voting_power() == 0 {
        panic!("FATAL: Cannot start epoch {} with zero quorum voting power", epoch_state.epoch);
    }

    // Validate that we can extract validators
    let validators: Arc<[AccountAddress]> = epoch_state
        .verifier
        .get_ordered_account_addresses_iter()
        .collect::<Vec<_>>()
        .into();
    
    if validators.is_empty() {
        panic!("FATAL: Extracted empty validator list for epoch {}", epoch_state.epoch);
    }

    *self.state.write() = Some(MutableState {
        validators,
        payload_manager,
        transaction_shuffler,
        block_executor_onchain_config,
        transaction_deduper,
        is_randomness_enabled: randomness_enabled,
        consensus_onchain_config,
        persisted_auxiliary_info_version,
        network_sender,
    });
}
```

Additionally, add validation in `start_new_epoch()` before the `EpochState` is distributed to components:

```rust
// After creating epoch_state (line 1171-1174)
if epoch_state.verifier.is_empty() {
    panic!("FATAL: Received empty validator set for epoch {}", epoch_state.epoch);
}

if epoch_state.verifier.total_voting_power() == 0 {
    panic!("FATAL: Received zero total voting power for epoch {}", epoch_state.epoch);
}
```

These panics are appropriate because an invalid epoch state represents an unrecoverable system state that should halt the node immediately rather than allowing corrupted consensus to proceed.

## Proof of Concept

```rust
#[cfg(test)]
mod test_invalid_epoch_state {
    use super::*;
    use crate::test_utils::mock_execution_client::MockExecutionClient;
    use aptos_types::{
        epoch_state::EpochState,
        validator_verifier::ValidatorVerifier,
    };
    use std::sync::Arc;

    #[test]
    #[should_panic(expected = "INVARIANT VIOLATION: proposers is empty")]
    fn test_new_epoch_with_empty_validator_set() {
        // Create an ExecutionProxy with mock dependencies
        let execution_proxy = Arc::new(ExecutionProxy::new(
            Arc::new(MockExecutionClient::new()),
            Arc::new(MockTxnNotifier::new()),
            Arc::new(MockConsensusNotificationSender::new()),
            BlockTransactionFilterConfig::default(),
            false,
            None,
        ));

        // Create an invalid EpochState with empty validator set
        let empty_epoch_state = EpochState::new(
            1,
            ValidatorVerifier::new(vec![]) // Empty validator list
        );

        // Call new_epoch with the invalid state - this should be rejected but isn't
        execution_proxy.new_epoch(
            &empty_epoch_state,
            Arc::new(DirectMempoolPayloadManager::new()),
            Arc::new(NoOpTransactionShuffler::new()),
            BlockExecutorConfigFromOnchain::default(),
            Arc::new(NoOpTransactionDeduper::new()),
            false,
            OnChainConsensusConfig::default(),
            0,
            Arc::new(NetworkSender::new(/* ... */)),
        );

        // Now attempt to create proposer election - this will panic
        let epoch_manager = EpochManager::new(/* ... */);
        let proposer_election = epoch_manager.create_proposer_election(
            &empty_epoch_state,
            &OnChainConsensusConfig::default()
        );
        // Panic occurs at line 400: proposers.first().expect("INVARIANT VIOLATION: proposers is empty")
    }

    #[test]
    fn test_signature_verification_with_zero_quorum() {
        // Create a ValidatorVerifier with empty validator set
        let verifier = ValidatorVerifier::new(vec![]);
        
        assert_eq!(verifier.len(), 0);
        assert_eq!(verifier.total_voting_power(), 0);
        assert_eq!(verifier.quorum_voting_power(), 0);
        
        // With quorum = 0, check_voting_power would accept 0 voting power
        let result = verifier.check_aggregated_voting_power(0, true);
        // This passes: 0 >= 0
        assert!(result.is_ok());
        
        // This demonstrates that signature verification logic degenerates
        // when validator set is empty, allowing trivial quorum formation
    }
}
```

**Notes**

This vulnerability represents a **defense-in-depth failure** rather than a directly exploitable attack in normal operation. The Move staking framework includes validation to prevent empty validator sets from being committed to blockchain state. However, the lack of parameter validation in the critical `new_epoch()` function creates several risks:

1. **Single Point of Failure**: Any bug in upstream validation (Move framework, governance, deserialization) could trigger immediate validator crashes.

2. **Maintenance Risk**: Future code changes to the staking framework or epoch transition logic could inadvertently allow invalid states to reach this function.

3. **Attack Surface Expansion**: If other vulnerabilities are discovered that allow on-chain state manipulation, this missing validation becomes a force multiplier.

The presence of `EpochState::empty()` and special handling for empty validator sets in `ValidatorVerifier::new()` suggests the system was designed to support edge cases, yet critical consensus code assumes these edge cases cannot occur (as evidenced by the "INVARIANT VIOLATION" panic).

**Severity Assessment**: While the lack of parameter validation is a genuine issue, classifying this as a Critical severity bounty-worthy vulnerability requires demonstrating a concrete attack path. Without evidence that an unprivileged attacker can actually create an invalid `ValidatorSet` on-chain (bypassing Move framework validation), this remains a **code quality and defensive programming issue** rather than an immediately exploitable vulnerability.

The recommended fix should still be implemented as a critical security hardening measure to prevent future exploitation if upstream validation is ever bypassed.

### Citations

**File:** consensus/src/state_computer.rs (L235-262)
```rust
    fn new_epoch(
        &self,
        epoch_state: &EpochState,
        payload_manager: Arc<dyn TPayloadManager>,
        transaction_shuffler: Arc<dyn TransactionShuffler>,
        block_executor_onchain_config: BlockExecutorConfigFromOnchain,
        transaction_deduper: Arc<dyn TransactionDeduper>,
        randomness_enabled: bool,
        consensus_onchain_config: OnChainConsensusConfig,
        persisted_auxiliary_info_version: u8,
        network_sender: Arc<NetworkSender>,
    ) {
        *self.state.write() = Some(MutableState {
            validators: epoch_state
                .verifier
                .get_ordered_account_addresses_iter()
                .collect::<Vec<_>>()
                .into(),
            payload_manager,
            transaction_shuffler,
            block_executor_onchain_config,
            transaction_deduper,
            is_randomness_enabled: randomness_enabled,
            consensus_onchain_config,
            persisted_auxiliary_info_version,
            network_sender,
        });
    }
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** types/src/validator_verifier.rs (L462-480)
```rust
    pub fn check_aggregated_voting_power(
        &self,
        aggregated_voting_power: u128,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let target = if check_super_majority {
            self.quorum_voting_power
        } else {
            self.total_voting_power - self.quorum_voting_power + 1
        };

        if aggregated_voting_power < target {
            return Err(VerifyError::TooLittleVotingPower {
                voting_power: aggregated_voting_power,
                expected_voting_power: target,
            });
        }
        Ok(aggregated_voting_power)
    }
```

**File:** types/src/epoch_state.rs (L32-37)
```rust
    pub fn empty() -> Self {
        Self {
            epoch: 0,
            verifier: Arc::new(ValidatorVerifier::new(vec![])),
        }
    }
```

**File:** consensus/src/epoch_manager.rs (L396-405)
```rust
            ProposerElectionType::RoundProposer(round_proposers) => {
                // Hardcoded to the first proposer
                let default_proposer = proposers
                    .first()
                    .expect("INVARIANT VIOLATION: proposers is empty");
                Arc::new(RoundProposer::new(
                    round_proposers.clone(),
                    *default_proposer,
                ))
            },
```

**File:** consensus/src/epoch_manager.rs (L1164-1176)
```rust
    async fn start_new_epoch(&mut self, payload: OnChainConfigPayload<P>) {
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
        let mut verifier: ValidatorVerifier = (&validator_set).into();
        verifier.set_optimistic_sig_verification_flag(self.config.optimistic_sig_verification);

        let epoch_state = Arc::new(EpochState {
            epoch: payload.epoch(),
            verifier: verifier.into(),
        });

        self.epoch_state = Some(epoch_state.clone());
```
