# Audit Report

## Title
Validators Accept Incomplete Epoch Change Proofs Due to Unchecked `more` Flag

## Summary
The `more` flag in `EpochChangeProof` indicates whether additional epochs exist beyond the proof's coverage. However, consensus validators in `SafetyRules` and `EpochManager` never validate this flag when accepting epoch change proofs. An attacker providing a malicious state sync response can set `more=false` on an incomplete proof, causing validators to believe they've reached the current epoch when they're actually behind, resulting in validator unavailability and potential network liveness degradation.

## Finding Description

The `EpochChangeProof` struct contains a `more` boolean field intended to indicate pagination state when epoch changes exceed the maximum limit (`MAX_NUM_EPOCH_ENDING_LEDGER_INFO = 100`). [1](#0-0) 

When storage constructs these proofs, the `more` flag is correctly set based on whether the requested range exceeds the limit: [2](#0-1) [3](#0-2) 

However, the core verification function `EpochChangeProof::verify()` **never checks the `more` flag**: [4](#0-3) 

While `TrustedState::verify_and_ratchet_inner()` does check the `more` flag when comparing against a `latest_li`, this protection is only available in the light client sync path: [5](#0-4) 

**Critical vulnerability**: Consensus validators use different code paths that bypass this check:

**1. SafetyRules initialization:** [6](#0-5) 

The `guarded_initialize()` function calls `proof.verify(&waypoint)` which returns the last ledger info in the proof without checking if `more=false` correctly indicates completeness.

**2. EpochManager epoch transitions:** [7](#0-6) 

**3. SafetyRules pagination loop:** [8](#0-7) 

This loop retrieves proofs from storage and continues only on `WaypointOutOfDate` errors. If an incomplete proof has `more=false`, the validator believes initialization is complete and exits the loop.

**Attack Scenario:**

1. Validator restarts with waypoint at epoch 1, actual network at epoch 200
2. Attacker intercepts state sync response (malicious full node or MITM)
3. Attacker provides:
   - `EpochChangeProof` covering epochs 1→100 (valid but incomplete)
   - `more = false` (falsely claiming completeness)
4. Validator's `perform_initialize()` retrieves this proof
5. `guarded_initialize()` calls `proof.verify()` → succeeds (signatures valid)
6. Validator updates to epoch 100
7. Loop exits (no error, `more=false` suggests completion)
8. **Validator operates at epoch 100 while network is at epoch 200**
9. Validator's consensus messages rejected (wrong epoch)
10. Validator offline, potential slashing for inactivity

## Impact Explanation

**Severity: HIGH**

This vulnerability enables validator unavailability attacks and violates the protocol's epoch synchronization guarantees:

1. **Single Validator Impact**: 
   - Validator stuck at outdated epoch
   - Cannot participate in consensus
   - Potential slashing for missed proposals/votes
   - Qualifies as "Validator node slowdowns" (High severity)

2. **Multi-Validator Impact**:
   - If attacker targets multiple validators simultaneously
   - Network may lose >1/3 validators
   - **Liveness failure** - consensus stalls
   - Qualifies as "Significant protocol violations" (High severity)

3. **Broken Invariant**:
   - Violates **Consensus Safety** invariant: validators must maintain consistent epoch state
   - Violates **State Consistency**: validators accept incomplete state as complete
   - Although not a safety violation (no chain splits), this is a critical liveness and availability issue

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Attack Requirements:**
- Attacker must control state sync responses (malicious full node or network MITM)
- Validator must be syncing from scratch or recovering from crash
- No validator collusion required (unprivileged attack)

**Realistic Scenarios:**
1. Validators configured to sync from public full nodes (common for new validators)
2. Network MITM during validator bootstrap
3. Compromised state sync infrastructure
4. Malicious full node operators

**Ease of Exploitation:**
- The `more` flag is not cryptographically protected (not covered by ledger info signatures)
- Attacker can modify it without invalidating proof signatures
- No additional cryptographic attacks needed
- Single-request attack (doesn't require sustained control)

## Recommendation

**Solution 1: Validate `more` flag in consensus verification paths**

Add validation in `SafetyRules::guarded_initialize()`:

```rust
fn guarded_initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error> {
    let waypoint = self.persistent_storage.waypoint()?;
    let last_li = proof
        .verify(&waypoint)
        .map_err(|e| Error::InvalidEpochChangeProof(format!("{}", e)))?;
    
    // NEW: Verify more flag consistency
    let ledger_info = last_li.ledger_info();
    let current_epoch = self.persistent_storage.safety_data()?.epoch;
    
    // If proof claims completeness (more=false), verify we're not in a future epoch
    if !proof.more {
        let proof_final_epoch = ledger_info.next_block_epoch();
        ensure!(
            proof_final_epoch >= current_epoch,
            Error::InvalidEpochChangeProof(format!(
                "Proof claims completeness (more=false) but ends at epoch {} while current epoch is {}",
                proof_final_epoch, current_epoch
            ))
        );
    }
    
    // ... rest of function
}
```

**Solution 2: Include `more` flag in cryptographic verification**

Modify `EpochChangeProof` to include the `more` flag in a signed commitment, or require a separate attestation that the proof is complete.

**Solution 3: Always require latest ledger info for validation**

Modify consensus verification to always compare against a known-good latest ledger info (similar to TrustedState path) rather than accepting proofs in isolation.

## Proof of Concept

```rust
#[test]
fn test_incomplete_proof_with_false_more_flag() {
    use aptos_types::{
        epoch_change::EpochChangeProof,
        ledger_info::LedgerInfoWithSignatures,
        waypoint::Waypoint,
    };
    use consensus_safety_rules::SafetyRules;
    
    // Setup: Create valid epoch change chain from epoch 1 to 100
    let mut ledger_infos = vec![];
    let (signers, verifier) = random_validator_verifier(1, None, true);
    
    for epoch in 1..=100 {
        let (next_signers, next_verifier) = random_validator_verifier(epoch as usize + 1, None, true);
        let epoch_state = EpochState {
            epoch: epoch + 1,
            verifier: Arc::new(next_verifier),
        };
        let ledger_info = create_epoch_ending_ledger_info(epoch, epoch_state);
        let signed_li = sign_ledger_info(&ledger_info, &signers);
        ledger_infos.push(signed_li);
    }
    
    // ATTACK: Create proof with more=false, claiming this is complete
    // when actually the network is at epoch 200
    let malicious_proof = EpochChangeProof::new(
        ledger_infos,
        false  // <-- INCORRECTLY SET: should be true since epochs 101-200 are missing
    );
    
    // Validator at epoch 1 receives this proof
    let waypoint = Waypoint::new_epoch_boundary(&ledger_infos[0].ledger_info()).unwrap();
    let mut safety_rules = create_safety_rules(waypoint);
    
    // VULNERABILITY: guarded_initialize accepts the incomplete proof
    // because it never checks the 'more' flag
    let result = safety_rules.guarded_initialize(&malicious_proof);
    
    assert!(result.is_ok()); // Proof accepted!
    
    // Validator now believes it's at epoch 100
    let consensus_state = safety_rules.consensus_state().unwrap();
    assert_eq!(consensus_state.epoch(), 100);
    
    // But the actual network is at epoch 200!
    // This validator will be offline and unable to participate in consensus
    // IMPACT: Validator DoS, potential network liveness failure if multiple validators affected
}
```

## Notes

This vulnerability specifically affects **consensus validators** during initialization and epoch transitions. Light clients using `TrustedState::verify_and_ratchet()` are protected because that code path checks the `more` flag against `latest_li`. The root cause is the architectural decision to have separate verification paths for validators vs. light clients, where validators use `EpochChangeProof::verify()` directly without the additional `more` flag validation that light clients have.

The fix should be implemented in all consensus code paths that accept `EpochChangeProof`, particularly `SafetyRules::guarded_initialize()` and any direct calls to `proof.verify()` that don't subsequently validate completeness.

### Citations

**File:** types/src/epoch_change.rs (L35-48)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
/// A vector of LedgerInfo with contiguous increasing epoch numbers to prove a sequence of
/// epoch changes from the first LedgerInfo's epoch.
pub struct EpochChangeProof {
    pub ledger_info_with_sigs: Vec<LedgerInfoWithSignatures>,
    pub more: bool,
}
impl EpochChangeProof {
    pub fn new(ledger_info_with_sigs: Vec<LedgerInfoWithSignatures>, more: bool) -> Self {
        Self {
            ledger_info_with_sigs,
            more,
        }
    }
```

**File:** types/src/epoch_change.rs (L66-118)
```rust
    pub fn verify(&self, verifier: &dyn Verifier) -> Result<&LedgerInfoWithSignatures> {
        ensure!(
            !self.ledger_info_with_sigs.is_empty(),
            "The EpochChangeProof is empty"
        );
        ensure!(
            !verifier
                .is_ledger_info_stale(self.ledger_info_with_sigs.last().unwrap().ledger_info()),
            "The EpochChangeProof is stale as our verifier is already ahead \
             of the entire EpochChangeProof"
        );
        let mut verifier_ref = verifier;

        for ledger_info_with_sigs in self
            .ledger_info_with_sigs
            .iter()
            // Skip any stale ledger infos in the proof prefix. Note that with
            // the assertion above, we are guaranteed there is at least one
            // non-stale ledger info in the proof.
            //
            // It's useful to skip these stale ledger infos to better allow for
            // concurrent client requests.
            //
            // For example, suppose the following:
            //
            // 1. My current trusted state is at epoch 5.
            // 2. I make two concurrent requests to two validators A and B, who
            //    live at epochs 9 and 11 respectively.
            //
            // If A's response returns first, I will ratchet my trusted state
            // to epoch 9. When B's response returns, I will still be able to
            // ratchet forward to 11 even though B's EpochChangeProof
            // includes a bunch of stale ledger infos (for epochs 5, 6, 7, 8).
            //
            // Of course, if B's response returns first, we will reject A's
            // response as it's completely stale.
            .skip_while(|&ledger_info_with_sigs| {
                verifier.is_ledger_info_stale(ledger_info_with_sigs.ledger_info())
            })
        {
            // Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof.
            verifier_ref.verify(ledger_info_with_sigs)?;
            // While the original verification could've been via waypoints,
            // all the next epoch changes are verified using the (already
            // trusted) validator sets.
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
        }

        Ok(self.ledger_info_with_sigs.last().unwrap())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L1044-1048)
```rust
        let (paging_epoch, more) = if end_epoch - start_epoch > limit as u64 {
            (start_epoch + limit as u64, true)
        } else {
            (end_epoch, false)
        };
```

**File:** storage/aptosdb/src/common.rs (L9-9)
```rust
pub(crate) const MAX_NUM_EPOCH_ENDING_LEDGER_INFO: usize = 100;
```

**File:** types/src/trusted_state.rs (L183-186)
```rust
            } else if latest_li.ledger_info().epoch() > new_epoch && epoch_change_proof.more {
                epoch_change_li
            } else {
                bail!("Inconsistent epoch change proof and latest ledger info");
```

**File:** consensus/safety-rules/src/safety_rules.rs (L265-274)
```rust
    fn guarded_initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error> {
        let waypoint = self.persistent_storage.waypoint()?;
        let last_li = proof
            .verify(&waypoint)
            .map_err(|e| Error::InvalidEpochChangeProof(format!("{}", e)))?;
        let ledger_info = last_li.ledger_info();
        let epoch_state = ledger_info
            .next_epoch_state()
            .cloned()
            .ok_or(Error::InvalidLedgerInfo)?;
```

**File:** consensus/src/epoch_manager.rs (L544-551)
```rust
    async fn initiate_new_epoch(&mut self, proof: EpochChangeProof) -> anyhow::Result<()> {
        let ledger_info = proof
            .verify(self.epoch_state())
            .context("[EpochManager] Invalid EpochChangeProof")?;
        info!(
            LogSchema::new(LogEvent::NewEpoch).epoch(ledger_info.ledger_info().next_block_epoch()),
            "Received verified epoch change",
        );
```

**File:** consensus/src/metrics_safety_rules.rs (L40-68)
```rust
    pub fn perform_initialize(&mut self) -> Result<(), Error> {
        let consensus_state = self.consensus_state()?;
        let mut waypoint_version = consensus_state.waypoint().version();
        loop {
            let proofs = self
                .storage
                .retrieve_epoch_change_proof(waypoint_version)
                .map_err(|e| {
                    Error::InternalError(format!(
                        "Unable to retrieve Waypoint state from storage, encountered Error:{}",
                        e
                    ))
                })?;
            // We keep initializing safety rules as long as the waypoint continues to increase.
            // This is due to limits in the number of epoch change proofs that storage can provide.
            match self.initialize(&proofs) {
                Err(Error::WaypointOutOfDate(
                    prev_version,
                    curr_version,
                    current_epoch,
                    provided_epoch,
                )) if prev_version < curr_version => {
                    waypoint_version = curr_version;
                    info!("Previous waypoint version {}, updated version {}, current epoch {}, provided epoch {}", prev_version, curr_version, current_epoch, provided_epoch);
                    continue;
                },
                result => return result,
            }
        }
```
