# Audit Report

## Title
State Inconsistency from Incorrect Async Cancellation Error Handling in Consensus Pipeline

## Summary
The consensus pipeline's `notify_state_sync` function has flawed error handling that ignores task cancellation errors (`JoinError`) from the `commit_ledger` phase. When blocks are aborted during state sync or fork resolution, state sync gets notified about transactions that were pre-committed but never committed to the ledger, creating a critical state inconsistency between consensus components.

## Finding Description

The vulnerability exists in the consensus pipeline's error propagation logic when async tasks are cancelled. [1](#0-0) 

The `notify_state_sync` function only checks for `TaskError::InternalError` when awaiting `commit_ledger_fut`, but silently ignores `TaskError::JoinError` (task cancellation) and `TaskError::PropagatedError`. [2](#0-1) 

**Attack Path:**

1. A block enters the consensus pipeline and successfully completes pre-commit (writes to storage but not finalized)
2. The pipeline gets aborted via `abort_pipeline()` - this happens automatically during state sync, fork resolution, or block pruning [3](#0-2) 
3. The abort cancels `commit_proof_fut` which has an abort handle [4](#0-3) 
4. `commit_ledger` fails early with `JoinError` before actually committing the ledger [5](#0-4) 
5. In `notify_state_sync`, the error check doesn't match `JoinError`, so execution continues
6. State sync receives `notify_new_commit()` with transactions that were never committed to ledger
7. Mempool removes these transactions, event subscribers receive notifications, but the ledger doesn't contain them

**Invariant Broken:** State Consistency - different components (consensus, state sync, mempool) have divergent views of what transactions are committed.

## Impact Explanation

**Severity: Medium to High**

This vulnerability causes state inconsistencies requiring manual intervention:

- **State Divergence**: State sync believes transactions are committed when they're only pre-committed, creating inconsistency with the actual ledger state
- **Transaction Loss**: Mempool incorrectly removes transactions thinking they're committed, causing them to be lost from the system
- **Event Corruption**: Event subscribers receive events for transactions not in the ledger, breaking application logic assumptions
- **Consensus Risk**: If different validators experience this at different times, it could lead to consensus divergence or safety violations

This meets **Medium Severity** ("State inconsistencies requiring intervention") and potentially **High Severity** ("Significant protocol violations") per the bug bounty criteria.

## Likelihood Explanation

**Likelihood: High**

This vulnerability triggers automatically during normal network operations without any attacker action:

- **State Sync**: Happens regularly when nodes catch up or fall behind
- **Fork Resolution**: Occurs naturally when competing blocks exist and one branch is pruned
- **Epoch Transitions**: Blocks may be aborted during epoch boundary handling
- **Block Pruning**: Old blocks are regularly cleaned up from the block tree

The comment in the code acknowledges this scenario but implements the logic incorrectly: [6](#0-5) 

The intent was to notify state sync about pre-committed transactions before entering state sync, but the implementation fails to distinguish between "never committed" (cancellation) versus "already committed" (success).

## Recommendation

Fix the error handling in `notify_state_sync` to properly handle all error types from `commit_ledger_fut`:

```rust
async fn notify_state_sync(
    pre_commit_fut: TaskFuture<PreCommitResult>,
    commit_ledger_fut: TaskFuture<CommitLedgerResult>,
    parent_notify_state_sync_fut: TaskFuture<PostCommitResult>,
    state_sync_notifier: Arc<dyn ConsensusNotificationSender>,
    block: Arc<Block>,
) -> TaskResult<NotifyStateSyncResult> {
    let mut tracker = Tracker::start_waiting("notify_state_sync", &block);
    let compute_result = pre_commit_fut.await?;
    parent_notify_state_sync_fut.await?;
    
    // Wait for commit_ledger to complete - propagate ALL errors
    match commit_ledger_fut.await {
        Ok(None) => {
            // Block was committed as prefix, no notification needed
            return Ok(());
        },
        Ok(Some(_)) => {
            // Ledger was successfully committed, proceed with notification
        },
        Err(e) => {
            // Any error (Internal, Join, or Propagated) means ledger wasn't committed
            // Do NOT notify state sync about uncommitted transactions
            return Err(TaskError::PropagatedError(Box::new(e)));
        }
    }

    tracker.start_working();
    let txns = compute_result.transactions_to_commit().to_vec();
    let subscribable_events = compute_result.subscribable_events().to_vec();
    if let Err(e) = monitor!(
        "notify_state_sync",
        state_sync_notifier
            .notify_new_commit(txns, subscribable_events)
            .await
    ) {
        error!(error = ?e, "Failed to notify state synchronizer");
    }

    Ok(())
}
```

The key changes:
1. Match on the full `Result` from `commit_ledger_fut.await`
2. Only proceed with notification if `Ok(Some(_))` is returned
3. Propagate ALL error types, not just `InternalError`
4. Handle `Ok(None)` case where block was committed as prefix

## Proof of Concept

**Rust Reproduction Steps:**

1. Set up a consensus node with a block in the pipeline
2. Ensure the block reaches the pre-commit stage (successfully pre-committed)
3. Trigger `abort_pipeline_for_state_sync()` before commit_ledger completes
4. Observe that state sync receives commit notification despite ledger not being committed
5. Check that mempool removes the transactions incorrectly

**Test Case Outline:**

```rust
#[tokio::test]
async fn test_notify_state_sync_cancellation_bug() {
    // 1. Create a block and start pipeline processing
    let block = create_test_block();
    let pipeline_builder = setup_pipeline_builder();
    
    // 2. Process block through pre-commit stage
    // Monitor commit_proof_fut to not be sent yet
    
    // 3. Trigger abort_pipeline() before commit_proof arrives
    block.abort_pipeline();
    
    // 4. Verify state sync received notification
    assert!(state_sync_received_commit_notification());
    
    // 5. Verify ledger does NOT contain the transactions
    assert!(!ledger_contains_transactions());
    
    // This demonstrates the state inconsistency
}
```

## Notes

This vulnerability is particularly insidious because:

1. **Timing-Dependent**: Only triggers when cancellation happens between pre-commit and commit-ledger phases
2. **Silent Failure**: No error is logged when the incorrect notification occurs
3. **Distributed Impact**: Different nodes may experience this at different times, causing network-wide inconsistency
4. **Normal Operations**: Requires no attack - happens during routine state sync and fork resolution

The error type system in [7](#0-6)  distinguishes between `JoinError` (cancellation), `InternalError` (application errors), and `PropagatedError`, but this distinction is not properly utilized in the error handling logic.

### Citations

**File:** consensus/src/pipeline/pipeline_builder.rs (L306-313)
```rust
        let commit_proof_fut = spawn_shared_fut(
            async move {
                commit_proof_fut
                    .await
                    .map_err(|_| TaskError::from(anyhow!("commit proof tx cancelled")))
            },
            Some(abort_handles),
        );
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1079-1106)
```rust
    async fn commit_ledger(
        pre_commit_fut: TaskFuture<PreCommitResult>,
        commit_proof_fut: TaskFuture<LedgerInfoWithSignatures>,
        parent_block_commit_fut: TaskFuture<CommitLedgerResult>,
        executor: Arc<dyn BlockExecutorTrait>,
        block: Arc<Block>,
    ) -> TaskResult<CommitLedgerResult> {
        let mut tracker = Tracker::start_waiting("commit_ledger", &block);
        parent_block_commit_fut.await?;
        pre_commit_fut.await?;
        let ledger_info_with_sigs = commit_proof_fut.await?;

        // it's committed as prefix
        if ledger_info_with_sigs.commit_info().id() != block.id() {
            return Ok(None);
        }

        tracker.start_working();
        let ledger_info_with_sigs_clone = ledger_info_with_sigs.clone();
        tokio::task::spawn_blocking(move || {
            executor
                .commit_ledger(ledger_info_with_sigs_clone)
                .map_err(anyhow::Error::from)
        })
        .await
        .expect("spawn blocking failed")?;
        Ok(Some(ledger_info_with_sigs))
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1147-1177)
```rust
    async fn notify_state_sync(
        pre_commit_fut: TaskFuture<PreCommitResult>,
        commit_ledger_fut: TaskFuture<CommitLedgerResult>,
        parent_notify_state_sync_fut: TaskFuture<PostCommitResult>,
        state_sync_notifier: Arc<dyn ConsensusNotificationSender>,
        block: Arc<Block>,
    ) -> TaskResult<NotifyStateSyncResult> {
        let mut tracker = Tracker::start_waiting("notify_state_sync", &block);
        let compute_result = pre_commit_fut.await?;
        parent_notify_state_sync_fut.await?;
        // if commit ledger is aborted, it's typically an abort caused by reset to fall back to state sync
        // we want to finish notifying already pre-committed txns before go into state sync
        // so only return if there's internal error from commit ledger
        if let Err(e @ TaskError::InternalError(_)) = commit_ledger_fut.await {
            return Err(TaskError::PropagatedError(Box::new(e)));
        }

        tracker.start_working();
        let txns = compute_result.transactions_to_commit().to_vec();
        let subscribable_events = compute_result.subscribable_events().to_vec();
        if let Err(e) = monitor!(
            "notify_state_sync",
            state_sync_notifier
                .notify_new_commit(txns, subscribable_events)
                .await
        ) {
            error!(error = ?e, "Failed to notify state synchronizer");
        }

        Ok(())
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L46-68)
```rust
#[derive(Clone, Debug)]
pub enum TaskError {
    JoinError(Arc<JoinError>),
    InternalError(Arc<Error>),
    PropagatedError(Box<TaskError>),
}

impl Display for TaskError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            TaskError::JoinError(e) => write!(f, "JoinError: {}", e),
            TaskError::InternalError(e) => write!(f, "InternalError: {}", e),
            TaskError::PropagatedError(e) => write!(f, "PropagatedError: {}", e),
        }
    }
}

impl From<Error> for TaskError {
    fn from(value: Error) -> Self {
        Self::InternalError(Arc::new(value))
    }
}
pub type TaskResult<T> = Result<T, TaskError>;
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L361-365)
```rust
impl Drop for PipelinedBlock {
    fn drop(&mut self) {
        let _ = self.abort_pipeline();
    }
}
```
