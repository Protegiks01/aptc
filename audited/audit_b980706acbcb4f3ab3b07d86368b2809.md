# Audit Report

## Title
Governance Proposal Ordering Vulnerability Allows Version-Epoch Desynchronization

## Summary
The `generate_version_upgrade_proposal()` function generates governance proposals with the correct ordering of `version::set_for_next_epoch()` followed by `aptos_governance::reconfigure()`, but there is no on-chain enforcement preventing malicious proposals from reversing this order or omitting calls entirely. This allows attackers with sufficient governance power to create proposals that desynchronize version updates from epoch transitions. [1](#0-0) 

## Finding Description

The vulnerability exists in the interaction between the off-chain proposal generation tool and the on-chain governance execution system.

**Code Generation (Off-Chain):**
The Rust function `generate_version_upgrade_proposal()` generates Move script text with hardcoded correct ordering: [2](#0-1) 

**Governance Proposal System (On-Chain):**
The governance system only validates that the executed script's hash matches the hash stored during proposal creation. There is NO validation of the script's content or ordering: [3](#0-2) 

**Version Update Mechanism:**
The `set_for_next_epoch()` function stages the version in a config buffer: [4](#0-3) 

The `on_new_epoch()` function applies the buffered version during reconfiguration: [5](#0-4) 

**Reconfiguration Flow:**
During `aptos_governance::reconfigure()`, the system calls `reconfiguration_with_dkg::finish()` which applies buffered configs BEFORE incrementing the epoch: [6](#0-5) 

**Attack Scenario:**
An attacker creates a malicious governance proposal with reversed ordering:

```move
script {
    use aptos_framework::aptos_governance;
    use aptos_framework::version;
    
    fun main(proposal_id: u64) {
        let framework_signer = aptos_governance::resolve(proposal_id, @0x1);
        // REVERSED ORDER
        aptos_governance::reconfigure(&framework_signer);  // Called FIRST
        version::set_for_next_epoch(&framework_signer, 42); // Called SECOND
    }
}
```

**Execution Flow:**
1. `reconfigure()` is called first
2. `finish()` â†’ `version::on_new_epoch()` checks buffer (empty, no update)
3. `reconfiguration::reconfigure()` increments epoch to N+1
4. `set_for_next_epoch()` is called, staging version 42 in buffer
5. **Result**: Epoch N+1 has old version; version 42 waits until epoch N+2

This breaks the documented usage pattern: [7](#0-6) 

## Impact Explanation

This vulnerability causes **state inconsistency** between the expected and actual protocol version at specific epochs. According to Aptos bug bounty severity categories, this qualifies as **Medium Severity** - "State inconsistencies requiring intervention."

The version number gates critical protocol features (EntryFunction payloads, Multi-agent transactions, Conflict-Resistant Sequence Numbers): [8](#0-7) 

**Consequences:**
1. **Protocol Version Mismatch**: Network operators expect version N at epoch M, but it's delayed to epoch M+1
2. **Feature Availability Confusion**: Features gated by the version number become available one epoch late
3. **Validator Coordination Issues**: Validators who upgraded their software expecting features at a specific epoch will face unexpected behavior
4. **Infrastructure Disruption**: Monitoring systems, APIs, and clients expecting version synchronization with epochs may malfunction

This does NOT meet Critical severity because:
- No direct fund theft or minting
- No guaranteed consensus safety violation
- No permanent network partition
- Can be corrected in subsequent epochs

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

**Requirements for exploitation:**
1. Attacker must have sufficient stake to meet `required_proposer_stake` threshold
2. Proposal must receive enough votes to pass (significant governance participation)
3. Proposal must survive community review period (typically several days) [9](#0-8) 

**Factors reducing likelihood:**
- High barrier to entry (governance stake requirement)
- Transparent on-chain proposal review process
- Community can vote against suspicious proposals

**Factors increasing likelihood:**
- No technical validation prevents this attack
- Attacker with 51% voting power could execute this
- Could be disguised in complex multi-step proposals

## Recommendation

Implement on-chain validation to enforce the correct ordering pattern. Add a dedicated governance function that atomically performs both operations:

```move
/// Safely update version and trigger reconfiguration in the correct order.
/// This function ensures version updates always synchronize with epoch changes.
public entry fun update_version_and_reconfigure(
    aptos_framework: &signer,
    new_major_version: u64
) acquires Version {
    // Ensure only framework can call
    system_addresses::assert_aptos_framework(aptos_framework);
    
    // Stage the version update
    set_for_next_epoch(aptos_framework, new_major_version);
    
    // Trigger reconfiguration (applies the staged version)
    aptos_governance::reconfigure(aptos_framework);
}
```

Update `generate_version_upgrade_proposal()` to use this atomic function:

```rust
emitln!(
    writer,
    "version::update_version_and_reconfigure({}, {});",
    signer_arg,
    version.major,
);
```

Alternatively, add runtime validation in `reconfiguration_with_dkg::finish()` to verify that if a version is buffered, it must be applied in the same transaction that triggered reconfiguration.

## Proof of Concept

```move
#[test_only]
module aptos_framework::version_ordering_attack_test {
    use aptos_framework::version;
    use aptos_framework::reconfiguration;
    use aptos_framework::aptos_governance;
    use std::signer;

    #[test(aptos_framework = @aptos_framework)]
    fun test_reversed_order_causes_delay(aptos_framework: signer) {
        // Initialize version at 1
        version::initialize(&aptos_framework, 1);
        
        let initial_version = version::get();
        assert!(initial_version.major == 1, 0);
        
        let initial_epoch = reconfiguration::current_epoch();
        
        // ATTACK: Call reconfigure BEFORE set_for_next_epoch
        aptos_governance::reconfigure(&aptos_framework);
        
        let after_reconfig_epoch = reconfiguration::current_epoch();
        let after_reconfig_version = version::get();
        
        // Epoch advanced
        assert!(after_reconfig_epoch == initial_epoch + 1, 1);
        
        // But version is STILL old!
        assert!(after_reconfig_version.major == 1, 2);
        
        // Now set version for "next" epoch
        version::set_for_next_epoch(&aptos_framework, 2);
        
        // Version is buffered but not applied yet
        let still_old_version = version::get();
        assert!(still_old_version.major == 1, 3);
        
        // Need ANOTHER reconfiguration to apply the version
        aptos_governance::reconfigure(&aptos_framework);
        
        // NOW version is updated (one epoch late)
        let final_version = version::get();
        assert!(final_version.major == 2, 4);
        
        // This demonstrates the version update was delayed by one epoch
    }
}
```

## Notes

This vulnerability exists because the `generate_version_upgrade_proposal()` function is a code generation utility that produces correctly-ordered scripts, but the on-chain governance system has no mechanism to enforce this ordering. The documented usage pattern in the version module clearly shows the intended order, but this is not enforced at the protocol level.

While the vulnerability requires significant governance participation to exploit, it represents a genuine protocol invariant violation where version updates can become desynchronized from epoch boundaries, potentially causing operational issues across the validator network and dependent infrastructure.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/version.rs (L10-40)
```rust
pub fn generate_version_upgrade_proposal(
    version: &AptosVersion,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> Result<Vec<(String, String)>> {
    let signer_arg = get_signer_arg(is_testnet, &next_execution_hash);
    let mut result = vec![];

    let writer = CodeWriter::new(Loc::default());

    let proposal = generate_governance_proposal(
        &writer,
        is_testnet,
        next_execution_hash,
        is_multi_step,
        &["aptos_framework::version"],
        |writer| {
            emitln!(
                writer,
                "version::set_for_next_epoch({}, {});",
                signer_arg,
                version.major,
            );
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
        },
    );

    result.push(("version".to_string(), proposal));
    Ok(result)
}
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L447-450)
```text
        assert!(
            transaction_context::get_script_hash() == proposal.execution_hash,
            error::invalid_argument(EPROPOSAL_EXECUTION_HASH_NOT_MATCHING),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L55-58)
```text
    /// Used in on-chain governances to update the major version for the next epoch.
    /// Example usage:
    /// - `aptos_framework::version::set_for_next_epoch(&framework_signer, new_version);`
    /// - `aptos_framework::aptos_governance::reconfigure(&framework_signer);`
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L59-64)
```text
    public entry fun set_for_next_epoch(account: &signer, major: u64) acquires Version {
        assert!(exists<SetVersionCapability>(signer::address_of(account)), error::permission_denied(ENOT_AUTHORIZED));
        let old_major = borrow_global<Version>(@aptos_framework).major;
        assert!(old_major < major, error::invalid_argument(EINVALID_MAJOR_VERSION_NUMBER));
        config_buffer::upsert(Version {major});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L67-77)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires Version {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<Version>()) {
            let new_value = config_buffer::extract_v2<Version>();
            if (exists<Version>(@aptos_framework)) {
                *borrow_global_mut<Version>(@aptos_framework) = new_value;
            } else {
                move_to(framework, new_value);
            }
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** types/src/on_chain_config/aptos_version.rs (L18-31)
```rust
// NOTE: version number for release 1.2 Aptos
// Items gated by this version number include:
//  - the EntryFunction payload type
pub const APTOS_VERSION_2: AptosVersion = AptosVersion { major: 2 };

// NOTE: version number for release 1.3 of Aptos
// Items gated by this version number include:
//  - Multi-agent transactions
pub const APTOS_VERSION_3: AptosVersion = AptosVersion { major: 3 };

// NOTE: version number for release 1.4 of Aptos
// Items gated by this version number include:
//  - Conflict-Resistant Sequence Numbers
pub const APTOS_VERSION_4: AptosVersion = AptosVersion { major: 4 };
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L420-434)
```text
        // The proposer's stake needs to be at least the required bond amount.
        let governance_config = borrow_global<GovernanceConfig>(@aptos_framework);
        let stake_balance = get_voting_power(stake_pool);
        assert!(
            stake_balance >= governance_config.required_proposer_stake,
            error::invalid_argument(EINSUFFICIENT_PROPOSER_STAKE),
        );

        // The proposer's stake needs to be locked up at least as long as the proposal's voting period.
        let current_time = timestamp::now_seconds();
        let proposal_expiration = current_time + governance_config.voting_duration_secs;
        assert!(
            stake::get_lockup_secs(stake_pool) >= proposal_expiration,
            error::invalid_argument(EINSUFFICIENT_STAKE_LOCKUP),
        );
```
