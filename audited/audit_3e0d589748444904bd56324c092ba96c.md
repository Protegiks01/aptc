# Audit Report

## Title
Inspection Service Exposes Validator Identity Without Sanitization on Mainnet

## Summary
The `/identity_information` endpoint in the inspection service reveals whether a queried node is a validator through the presence of `validator_network` configuration. Unlike the `/configuration` endpoint which has explicit sanitization preventing exposure on mainnet validators, the identity information endpoint lacks equivalent protection, enabling attackers to enumerate and target validators despite the default `expose_identity_information: true` configuration. [1](#0-0) 

## Finding Description
The `get_identity_information()` function explicitly checks for the presence of `validator_network` configuration and exposes this information when the inspection service endpoint is enabled. This breaks the defense-in-depth security model by providing attackers with a real-time oracle to definitively identify which nodes are validators.

**Vulnerability Flow:**

1. **Default Configuration is Insecure**: The `expose_identity_information` flag defaults to `true` [2](#0-1) 

2. **No Mainnet Validator Sanitization**: The `ConfigSanitizer` implementation prevents mainnet validators from exposing configuration, but **does not** include equivalent checks for identity information [3](#0-2) 

3. **Definitive Validator Identification**: The presence check at line 34 creates a binary oracle - if `validator_network` exists in the response, the node is definitively a validator [4](#0-3) 

4. **Publicly Accessible Without Authentication**: The service binds to `0.0.0.0` by default and has no authentication mechanism [5](#0-4) 

**Attack Scenario:**
```
1. Attacker identifies potential validator IPs (from network scanning or infrastructure analysis)
2. For each IP, sends: GET http://<IP>:9101/identity_information
3. If response contains "Validator network", the node is confirmed as a validator
4. Attacker builds database of validator nodes for targeted infrastructure attacks
```

## Impact Explanation
This qualifies as **Medium severity** per the Aptos bug bounty criteria as it enables targeted attacks against critical consensus infrastructure:

- **Validator Enumeration**: Attackers can definitively distinguish validators from fullnodes on shared infrastructure
- **Real-time Reconnaissance**: Provides current validator status even when on-chain data is outdated
- **Targeted Attack Enablement**: Facilitates DDoS, network isolation, or social engineering attacks against specific validators
- **Defense-in-Depth Violation**: Contradicts the security model evidenced by the `expose_configuration` sanitizer

While validator addresses are available on-chain through `ValidatorSet`, the inspection service provides the critical missing link: mapping IP addresses to validator status in real-time. This is particularly dangerous when validators use proxies, load balancers, or share infrastructure with fullnodes. [6](#0-5) 

## Likelihood Explanation
**High Likelihood:**
- Default configuration enables the endpoint (`expose_identity_information: true`)
- No authentication or rate limiting protects the endpoint
- No sanitizer prevents mainnet validators from exposing identity information
- Standard HTTP GET request is trivial to execute
- Port 9101 is commonly accessible if firewall rules are misconfigured

The inconsistency between sanitizing `expose_configuration` but not `expose_identity_information` suggests this is an oversight rather than an intentional design decision.

## Recommendation
Add sanitization for `expose_identity_information` on mainnet validators, matching the existing pattern for `expose_configuration`:

```rust
fn sanitize(
    node_config: &NodeConfig,
    node_type: NodeType,
    chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = Self::get_sanitizer_name();
    let inspection_service_config = &node_config.inspection_service;

    // Verify that mainnet validators do not expose the configuration
    if let Some(chain_id) = chain_id {
        if node_type.is_validator() && chain_id.is_mainnet() {
            if inspection_service_config.expose_configuration {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
            // ADD THIS CHECK:
            if inspection_service_config.expose_identity_information {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose identity information!".to_string(),
                ));
            }
        }
    }
    Ok(())
}
```

Additionally, change the default to `expose_identity_information: false` for production deployments. [7](#0-6) 

## Proof of Concept

```rust
#[tokio::test]
async fn test_validator_enumeration_attack() {
    use crate::server::{serve_requests, IDENTITY_INFORMATION_PATH};
    use aptos_config::config::NodeConfig;
    use hyper::{Body, Method, Request};
    
    // Create validator and fullnode configs
    let mut validator_config = NodeConfig::get_default_validator_config();
    let mut fullnode_config = NodeConfig::get_default_pfn_config();
    
    // Both have inspection service enabled (default)
    validator_config.inspection_service.expose_identity_information = true;
    fullnode_config.inspection_service.expose_identity_information = true;
    
    // Query validator node
    let request = Request::builder()
        .method(Method::GET)
        .uri(IDENTITY_INFORMATION_PATH)
        .body(Body::empty())
        .unwrap();
    let response = serve_requests(request, validator_config.clone(), 
        create_mock_data_client(), create_mock_peers()).await.unwrap();
    let body_bytes = hyper::body::to_bytes(response.into_body()).await.unwrap();
    let validator_response = String::from_utf8(body_bytes.to_vec()).unwrap();
    
    // Query fullnode
    let request = Request::builder()
        .method(Method::GET)
        .uri(IDENTITY_INFORMATION_PATH)
        .body(Body::empty())
        .unwrap();
    let response = serve_requests(request, fullnode_config.clone(),
        create_mock_data_client(), create_mock_peers()).await.unwrap();
    let body_bytes = hyper::body::to_bytes(response.into_body()).await.unwrap();
    let fullnode_response = String::from_utf8(body_bytes.to_vec()).unwrap();
    
    // VULNERABILITY: Can definitively distinguish validators from fullnodes
    assert!(validator_response.contains("Validator network"));
    assert!(!fullnode_response.contains("Validator network"));
    
    println!("ATTACK SUCCESS: Validator identified via inspection service");
}
``` [8](#0-7) 

## Notes

The vulnerability is confirmed through code analysis showing:
1. Explicit validator network presence check enabling binary identification
2. Missing sanitizer for mainnet validators (unlike `expose_configuration`)  
3. Default-enabled configuration creating insecure-by-default deployment
4. No authentication protecting the inspection endpoint

While validator information exists on-chain, the inspection service provides attackers with a critical real-time mapping tool from IP addresses to validator status, enabling targeted infrastructure attacks.

### Citations

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L29-51)
```rust
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L45-69)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L171-193)
```text
    struct ValidatorInfo has copy, store, drop {
        addr: address,
        voting_power: u64,
        config: ValidatorConfig,
    }

    /// Full ValidatorSet, stored in @aptos_framework.
    /// 1. join_validator_set adds to pending_active queue.
    /// 2. leave_valdiator_set moves from active to pending_inactive queue.
    /// 3. on_new_epoch processes two pending queues and refresh ValidatorInfo from the owner's address.
    struct ValidatorSet has copy, key, drop, store {
        consensus_scheme: u8,
        // Active validators for the current epoch.
        active_validators: vector<ValidatorInfo>,
        // Pending validators to leave in next epoch (still active).
        pending_inactive: vector<ValidatorInfo>,
        // Pending validators to join in next epoch.
        pending_active: vector<ValidatorInfo>,
        // Current total voting power.
        total_voting_power: u128,
        // Total voting power waiting to join in the next epoch.
        total_joining_power: u128,
    }
```

**File:** crates/aptos-inspection-service/src/server/tests.rs (L114-144)
```rust
#[tokio::test]
async fn test_inspect_identity_information() {
    // Create a validator config (with a single validator identity)
    let mut config = NodeConfig::get_default_validator_config();
    if let Some(network_config) = config.validator_network.as_mut() {
        network_config.identity = Identity::None; // Reset the identity
        network_config
            .set_listen_address_and_prepare_identity()
            .unwrap(); // Generates a random identity
    }
    config.full_node_networks = vec![];

    // Disable the identity information endpoint and ping it
    config.inspection_service.expose_identity_information = false;
    let mut response = send_get_request_to_path(&config, IDENTITY_INFORMATION_PATH).await;
    let response_body = body::to_bytes(response.body_mut()).await.unwrap();

    // Verify that the response contains an error
    assert_eq!(response.status(), StatusCode::FORBIDDEN);
    assert_eq!(response_body, IDENTITY_INFO_DISABLED_MESSAGE);

    // Enable the identity information endpoint and ping it
    config.inspection_service.expose_identity_information = true;
    let mut response = send_get_request_to_path(&config, IDENTITY_INFORMATION_PATH).await;
    let response_body = body::to_bytes(response.body_mut()).await.unwrap();
    let response_body_string = read_to_string(response_body.as_ref()).unwrap();

    // Verify that the response contains the expected information
    assert_eq!(response.status(), StatusCode::OK);
    assert!(response_body_string.contains("Identity Information:"));
}
```
