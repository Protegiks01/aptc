# Audit Report

## Title
Server-Side Request Forgery (SSRF) via Malicious JWK Consensus Configuration URLs Enabling Validator Infrastructure Compromise

## Summary
The JWK consensus configuration system allows governance proposals to set arbitrary URLs without validation. When validators fetch JWK configurations, they make unvalidated HTTP requests to these URLs, enabling SSRF attacks against cloud metadata services, internal networks, and validator infrastructure.

## Finding Description

The vulnerability exists across multiple layers of the JWK consensus configuration system:

**1. Move Layer - No URL Validation**

The `new_oidc_provider` function accepts arbitrary strings for `config_url` without any validation: [1](#0-0) 

The only validation performed in `new_v1` is checking for duplicate provider names: [2](#0-1) 

**2. Governance Propagation Path**

Governance proposals can update the JWK consensus config using the governance script generation in the release builder: [3](#0-2) 

The malicious `config_url` is embedded directly into the governance proposal script without validation and applied at the next epoch boundary.

**3. Validator Execution - Automatic SSRF**

When the new epoch begins, validators spawn JWKObserver instances for each OIDC provider: [4](#0-3) 

The JWKObserver periodically fetches from the configured URL every 10 seconds: [5](#0-4) 

**4. Unvalidated HTTP Requests**

The actual HTTP request is made without any URL validation or network restrictions: [6](#0-5) 

The reqwest client is created with default settings (no timeout, no URL filtering, follows redirects): [7](#0-6) 

**Attack Scenario:**

1. Attacker creates governance proposal to update JWK consensus config with malicious URLs such as:
   - `http://169.254.169.254/latest/meta-data/iam/security-credentials/` (AWS metadata)
   - `http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token` (GCP metadata)
   - `http://localhost:8080/admin/` (internal admin panels)
   - `http://10.0.0.5/internal-api/` (internal network services)

2. Proposal passes through normal governance voting process

3. At next epoch boundary, configuration is applied across all validators

4. Every validator spawns JWKObserver threads that make HTTP requests to the malicious URL every 10 seconds

5. Attackers gain:
   - Cloud provider credentials from metadata services
   - Internal network topology information
   - Access to internal services
   - Potential RCE if internal services are vulnerable

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos Bug Bounty program:

- **Validator Infrastructure Compromise**: SSRF can leak cloud provider credentials (AWS/GCP/Azure IAM roles, API keys) from metadata endpoints, allowing attackers to compromise validator cloud infrastructure
  
- **Validator Node Impact**: All validators simultaneously make requests to attacker-controlled endpoints, enabling mass reconnaissance and potential coordinated attacks

- **Significant Protocol Violation**: Validators should not make arbitrary HTTP requests to external systems. This breaks the security boundary between consensus operations and external network access

- **Persistent Exploitation**: Once the malicious config is applied, it persists until another governance proposal changes it, providing extended access

- **Network-Wide Impact**: Unlike single-validator attacks, this affects the entire validator set simultaneously

This does not reach Critical severity because it requires governance approval (not a direct consensus safety violation) and doesn't directly cause fund loss or network partition, but the infrastructure compromise potential is severe.

## Likelihood Explanation

**Moderate Likelihood:**

**Barriers:**
- Requires governance proposal to pass (needs sufficient stake and voting support)
- Governance participants may review proposals before voting

**Enablers:**
- Governance proposals may not receive thorough security review, especially for "configuration updates"
- The malicious nature of URLs may not be obvious (e.g., seemingly legitimate domain names that redirect)
- Social engineering could convince stakeholders that the URLs are legitimate OIDC providers
- Once approved, exploitation is automatic and guaranteed
- No alert mechanism exists to detect suspicious outbound requests from validators

**Exploitation Complexity:**
- Low - Attack requires only crafting a governance proposal with malicious URLs
- Fully automated once proposal passes
- No need for validator operator access or code changes

## Recommendation

Implement multi-layer URL validation:

**1. Move Layer Validation** - Add URL scheme and format validation:

```move
public fun new_oidc_provider(name: String, config_url: String): OIDCProvider {
    // Validate URL scheme is https only
    let url_bytes = string::bytes(&config_url);
    assert!(
        vector::length(url_bytes) >= 8 && 
        *vector::borrow(url_bytes, 0) == 104 && // 'h'
        *vector::borrow(url_bytes, 1) == 116 && // 't'
        *vector::borrow(url_bytes, 2) == 116 && // 't'
        *vector::borrow(url_bytes, 3) == 112 && // 'p'
        *vector::borrow(url_bytes, 4) == 115 && // 's'
        *vector::borrow(url_bytes, 5) == 58,    // ':'
        error::invalid_argument(EINVALID_URL_SCHEME)
    );
    OIDCProvider { name, config_url }
}
```

**2. Rust Layer Validation** - Add URL allowlist and security checks:

```rust
use url::Url;

pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    // Parse and validate URL
    let url = Url::parse(config_url)
        .context("Invalid URL format")?;
    
    // Enforce HTTPS only
    if url.scheme() != "https" {
        bail!("Only HTTPS URLs are allowed");
    }
    
    // Block private IP ranges and localhost
    if let Some(host) = url.host_str() {
        if host == "localhost" || host.starts_with("127.") || 
           host.starts_with("10.") || host.starts_with("192.168.") ||
           host.starts_with("169.254.") || host.starts_with("172.") {
            bail!("Private network addresses are not allowed");
        }
    }
    
    // Create client with security settings
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(10))
        .redirect(reqwest::redirect::Policy::limited(3))
        .build()?;
        
    let OpenIDConfiguration { jwks_uri, .. } = client
        .get(config_url)
        .send()
        .await?
        .json()
        .await?;
        
    Ok(jwks_uri)
}
```

**3. Operational Controls:**
- Maintain an allowlist of approved OIDC provider domains in chain configuration
- Implement monitoring for unusual outbound HTTP requests from validators
- Add governance proposal review requirements for JWK config changes

## Proof of Concept

**Move Test - Demonstrating Malicious URL Acceptance:**

```move
#[test]
fun test_malicious_url_accepted() {
    use std::string::utf8;
    
    // These malicious URLs are currently accepted without validation
    let aws_metadata = new_oidc_provider(
        utf8(b"malicious-aws"),
        utf8(b"http://169.254.169.254/latest/meta-data/")
    );
    
    let localhost_admin = new_oidc_provider(
        utf8(b"malicious-localhost"),
        utf8(b"http://localhost:8080/admin")
    );
    
    let internal_network = new_oidc_provider(
        utf8(b"malicious-internal"),
        utf8(b"http://10.0.0.5/internal-api")
    );
    
    // All malicious URLs are accepted
    let config = new_v1(vector[aws_metadata, localhost_admin, internal_network]);
    
    // This config would be applied to all validators, causing SSRF
}
```

**Rust Test - Demonstrating Unvalidated HTTP Request:**

```rust
#[tokio::test]
async fn test_ssrf_via_jwk_fetch() {
    use aptos_jwk_utils::fetch_jwks_uri_from_openid_config;
    
    // This should fail but currently succeeds (or attempts the request)
    let malicious_urls = vec![
        "http://169.254.169.254/latest/meta-data/",  // AWS metadata
        "http://localhost:8080/admin",                // Localhost
        "http://10.0.0.1/internal",                   // Private network
    ];
    
    for url in malicious_urls {
        // Currently no validation - request is attempted
        let result = fetch_jwks_uri_from_openid_config(url).await;
        // In production, this would expose validator infrastructure
        println!("Attempted fetch from: {} - Result: {:?}", url, result);
    }
}
```

## Notes

This vulnerability demonstrates a critical security principle violation: **external input validation**. The system trusts governance-provided URLs without validation, assuming governance participants will only provide safe values. However, governance can be compromised through social engineering, vote manipulation, or simple oversight. Defense-in-depth requires validation at multiple layers, especially for operations that cross security boundaries like making HTTP requests to arbitrary URLs.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L90-98)
```text
    public fun new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {
        let name_set = simple_map::new<String, u64>();
        vector::for_each_ref(&oidc_providers, |provider| {
            let provider: &OIDCProvider = provider;
            let (_, old_value) = simple_map::upsert(&mut name_set, provider.name, 0);
            if (option::is_some(&old_value)) {
                abort(error::invalid_argument(EDUPLICATE_PROVIDERS))
            }
        });
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L105-107)
```text
    public fun new_oidc_provider(name: String, config_url: String): OIDCProvider {
        OIDCProvider { name, config_url }
    }
```

**File:** aptos-move/aptos-release-builder/src/components/jwk_consensus_config.rs (L32-36)
```rust
                    emitln!(writer, "let config = jwk_consensus_config::new_v1(vector[");
                    for p in v1.oidc_providers.iter() {
                        emitln!(writer, "jwk_consensus_config::new_oidc_provider(utf8(b\"{}\"), utf8(b\"{}\")),", p.name, p.config_url);
                    }
                    emitln!(writer, "]);");
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-124)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L70-84)
```rust
        loop {
            tokio::select! {
                _ = interval.tick().fuse() => {
                    let timer = Instant::now();
                    let result = fetch_jwks(open_id_config_url.as_str(), my_addr).await;
                    debug!(issuer = issuer, "observe_result={:?}", result);
                    let secs = timer.elapsed().as_secs_f64();
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
                    } else {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "err"]).observe(secs);
                    }
                },
```

**File:** crates/jwk-utils/src/lib.rs (L29-36)
```rust
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
```

**File:** crates/jwk-utils/src/lib.rs (L40-44)
```rust
pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```
