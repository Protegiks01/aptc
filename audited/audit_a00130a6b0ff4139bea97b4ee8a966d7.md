# Audit Report

## Title
Genesis Framework Injection via Unverified Release Bundle Loading

## Summary
The `ReleaseBundle::read()` function lacks cryptographic integrity verification, allowing attackers with filesystem access to inject malicious Move bytecode into genesis transactions, compromising the entire blockchain from initialization. [1](#0-0) 

## Finding Description

**Note on Scope**: The security question claims this vulnerability affects governance proposals. However, my investigation reveals that governance proposal generation builds packages fresh from source code and does NOT use `ReleaseBundle::read()`. [2](#0-1) 

The actual vulnerability lies in **genesis generation**, which is equally critical as it compromises the network from inception.

**Attack Path**:

1. When genesis is generated using a local repository, the framework is loaded from `framework.mrb` without cryptographic verification: [3](#0-2) 

2. The unverified `ReleaseBundle` is passed directly to genesis transaction generation: [4](#0-3) 

3. The tampered framework modules are published to genesis state without verification: [5](#0-4) 

4. The waypoint mechanism only verifies that nodes agree on the SAME genesis, not that genesis is UNTAMPERED. If genesis is generated with a malicious framework, the waypoint is calculated from that compromised state.

**Broken Invariants**:
- **Deterministic Execution**: Different operators may unknowingly use different tampered frameworks
- **Access Control**: Malicious framework bypasses system address protections
- **Move VM Safety**: Arbitrary bytecode executes with framework privileges

## Impact Explanation

**Severity: Critical** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability enables complete blockchain compromise:

1. **Loss of Funds**: Malicious framework can steal all tokens, mint unlimited APT, or freeze accounts
2. **Consensus/Safety Violations**: Can manipulate validator set, break BFT properties, or create irrecoverable forks
3. **Permanent Network Damage**: Requires hard fork to remediate if malicious genesis is deployed

The impact extends to ALL nodes bootstrapping from the compromised genesis, affecting validators, full nodes, and the entire ecosystem.

## Likelihood Explanation

**Likelihood: Medium**

**Required Attacker Capabilities**:
- Filesystem access to the genesis generation environment
- Timing: Access during genesis setup phase
- Knowledge: Understanding of Move bytecode and framework structure

**Realistic Attack Scenarios**:
1. **Compromised Development Environment**: Genesis often generated on developer workstations
2. **Supply Chain Attack**: Tampered framework in git repository or network share
3. **Insider Threat**: Malicious genesis operator
4. **CI/CD Pipeline Compromise**: Automated genesis generation systems

While not trivially exploitable, these scenarios are realistic for high-value blockchain deployments.

## Recommendation

Add cryptographic signature verification to `ReleaseBundle::read()`:

```rust
pub fn read(file: PathBuf) -> anyhow::Result<ReleaseBundle> {
    let content = std::fs::read(&file)
        .with_context(|| format!("while reading `{}`", file.display()))?;
    let bundle: ReleaseBundle = bcs::from_bytes(&content)?;
    
    // Verify cryptographic signature from trusted authority
    verify_bundle_signature(&bundle, &content)?;
    
    Ok(bundle)
}

fn verify_bundle_signature(bundle: &ReleaseBundle, content: &[u8]) -> anyhow::Result<()> {
    // Implement signature verification using Ed25519 or similar
    // Signature should be over the BCS-serialized content
    // Public key should be hardcoded or from secure configuration
    unimplemented!("Add signature verification")
}
```

**Additional Mitigations**:
1. Generate reproducible builds with published source hashes
2. Require multi-party verification for genesis frameworks
3. Add integrity checks comparing framework hash to known-good values
4. Log framework source_digest and require manual verification [6](#0-5) 

## Proof of Concept

```rust
// Reproduction steps:
// 1. Generate legitimate framework bundle
// 2. Deserialize and modify bytecode
// 3. Serialize back to disk
// 4. Run genesis generation with tampered bundle

use aptos_framework::ReleaseBundle;
use std::path::PathBuf;

fn tamper_framework(bundle_path: &str) {
    // Read legitimate bundle
    let mut bundle = ReleaseBundle::read(PathBuf::from(bundle_path)).unwrap();
    
    // Inject malicious module (simplified - actual attack would modify existing modules)
    // In practice, attacker would:
    // 1. Modify move_stdlib or aptos_framework modules
    // 2. Add backdoor functions for fund theft
    // 3. Manipulate governance voting logic
    // 4. Bypass access controls
    
    // Write tampered bundle back
    bundle.write(PathBuf::from(bundle_path)).unwrap();
    
    // Genesis generation will now use this tampered bundle
    // All nodes bootstrapping from this genesis will execute malicious code
}
```

**Notes**

While the security question specifically mentioned governance proposals, the actual vulnerability exists in genesis generation. Governance proposal generation builds packages from source and does not use the vulnerable `read()` function. However, the genesis attack vector is arguably more severe, as it compromises the network from inception rather than requiring approval through governance voting. The lack of cryptographic integrity validation in `ReleaseBundle::read()` creates a critical supply chain vulnerability during network bootstrapping.

### Citations

**File:** aptos-move/framework/src/release_bundle.rs (L45-49)
```rust
    pub fn read(file: PathBuf) -> anyhow::Result<ReleaseBundle> {
        let content =
            std::fs::read(&file).with_context(|| format!("while reading `{}`", file.display()))?;
        Ok(bcs::from_bytes::<ReleaseBundle>(&content)?)
    }
```

**File:** crates/aptos/src/governance/mod.rs (L1029-1032)
```rust
        let package_path = move_options.get_package_path()?;
        let options = included_artifacts.build_options(&move_options)?;
        let package = BuiltPackage::build(package_path, options)?;
        let release = ReleasePackage::new(package)?;
```

**File:** crates/aptos/src/genesis/git.rs (L230-241)
```rust
    pub fn get_framework(&self) -> CliTypedResult<ReleaseBundle> {
        match self {
            Client::Local(local_repository_path) => {
                let path = local_repository_path.join(FRAMEWORK_NAME);
                if !path.exists() {
                    return Err(CliError::UnableToReadFile(
                        path.display().to_string(),
                        "File not found".to_string(),
                    ));
                }
                Ok(ReleaseBundle::read(path)?)
            },
```

**File:** crates/aptos/src/genesis/mod.rs (L236-242)
```rust
    let framework = client.get_framework()?;
    Ok(MainnetGenesisInfo::new(
        layout.chain_id,
        accounts,
        employee_vesting_accounts,
        validators,
        framework,
```

**File:** aptos-move/vm-genesis/src/lib.rs (L262-276)
```rust
pub fn encode_genesis_change_set(
    core_resources_key: &Ed25519PublicKey,
    validators: &[Validator],
    framework: &ReleaseBundle,
    chain_id: ChainId,
    genesis_config: &GenesisConfiguration,
    consensus_config: &OnChainConsensusConfig,
    execution_config: &OnChainExecutionConfig,
    gas_schedule: &GasScheduleV2,
) -> ChangeSet {
    validate_genesis_config(genesis_config);

    let mut state_view = GenesisStateView::new();
    for (module_bytes, module) in framework.code_and_compiled_modules() {
        state_view.add_module(&module.self_id(), module_bytes);
```

**File:** aptos-move/framework/src/natives/code.rs (L61-71)
```rust
pub struct PackageMetadata {
    pub name: String,
    pub upgrade_policy: UpgradePolicy,
    pub upgrade_number: u64,
    pub source_digest: String,
    #[serde(with = "serde_bytes")]
    pub manifest: Vec<u8>,
    pub modules: Vec<ModuleMetadata>,
    pub deps: Vec<PackageDep>,
    pub extension: Option<Any>,
}
```
