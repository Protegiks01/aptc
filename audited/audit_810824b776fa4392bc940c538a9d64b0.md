# Audit Report

## Title
Panic-Induced Denial of Service in Transaction Generator via Invalid Package Name

## Summary
The `package_metadata()`, `package_modules()`, and `package_script()` functions in the `PreBuiltPackages` trait do not handle non-existent package names gracefully, leading to a panic that crashes the transaction generation infrastructure when an invalid package name is provided.

## Finding Description

The vulnerability exists in the package retrieval mechanism used by the transaction generator library. When any of the `PreBuiltPackages` trait methods are called with a non-existent package name, the following panic chain occurs:

1. **Entry Point**: Methods `package_metadata()`, `package_modules()`, or `package_script()` are called with an invalid package name [1](#0-0) 

2. **Panic Source**: The `get_package()` method unconditionally panics when the package doesn't exist [2](#0-1) 

3. **Propagation Path**: This panic propagates through `Package::by_name()` [3](#0-2) 

4. **Critical Usage**: The panic reaches `PackageHandler::new()`, which is used throughout the transaction generation infrastructure [4](#0-3) 

5. **Infrastructure Impact**: This is instantiated in core transaction generation workflows [5](#0-4) 

The same vulnerability affects `package_modules()` and `package_script()`: [6](#0-5) 

## Impact Explanation

This vulnerability falls under **Medium Severity** per Aptos bug bounty criteria, specifically as "State inconsistencies requiring intervention" in the transaction generation infrastructure. While it does not directly affect blockchain consensus or state integrity, it causes:

- **Infrastructure Denial of Service**: Transaction generation processes crash completely when encountering invalid package names
- **Testing/Benchmarking Disruption**: Load testing and performance benchmarking tools become unavailable
- **Operational Impact**: Requires manual intervention and process restart to recover

However, it's important to note that this affects **auxiliary infrastructure** (transaction generators, benchmarking tools, testing frameworks) rather than core blockchain protocol components (validators, consensus, execution engine).

## Likelihood Explanation

The likelihood depends on the deployment context:

- **High** if transaction generator configuration is exposed through APIs or user-facing tools where malformed input could be provided
- **Medium** if package names are only specified through internal configuration files or CLI arguments
- **Low** in production validator environments where this library is typically not used

The vulnerability is easily triggered - any misspelled or non-existent package name will cause an immediate panic.

## Recommendation

Replace the panic with proper error handling that returns a `Result` type:

```rust
// In PrebuiltPackagesBundle
pub fn get_package(&self, package_name: &str) -> Result<&PrebuiltPackage, String> {
    self.packages
        .get(package_name)
        .ok_or_else(|| format!("Package {} does not exist", package_name))
}

// Update trait methods to propagate errors
fn package_metadata(&self, package_name: &str) -> Result<PackageMetadata, String> {
    Ok(self.package_bundle()
        .get_package(package_name)?
        .metadata
        .clone())
}
```

Alternatively, for backward compatibility with panic behavior, add validation methods:

```rust
pub fn package_exists(&self, package_name: &str) -> bool {
    self.packages.contains_key(package_name)
}

pub fn get_package_or_default(&self, package_name: &str, default: &str) -> &PrebuiltPackage {
    self.packages.get(package_name)
        .unwrap_or_else(|| {
            eprintln!("Warning: Package {} not found, using {}", package_name, default);
            self.packages.get(default).expect("Default package must exist")
        })
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    #[should_panic(expected = "Package nonexistent_package does not exist")]
    fn test_invalid_package_name_panic() {
        // Create a minimal PrebuiltPackagesBundle
        let bundle = PrebuiltPackagesBundle {
            packages: BTreeMap::new(),
        };
        
        // This will panic with the message:
        // "Package nonexistent_package does not exist"
        bundle.get_package("nonexistent_package");
    }
    
    #[test]
    #[should_panic]
    fn test_package_metadata_panic_on_invalid_name() {
        struct TestPackages;
        impl PreBuiltPackages for TestPackages {
            fn package_bundle(&self) -> &PrebuiltPackagesBundle {
                static BUNDLE: PrebuiltPackagesBundle = PrebuiltPackagesBundle {
                    packages: BTreeMap::new(),
                };
                &BUNDLE
            }
        }
        
        let packages = TestPackages;
        // This triggers the panic through package_metadata -> get_package
        packages.package_metadata("invalid_package");
    }
}
```

**Notes:**
This vulnerability is confirmed to exist in the transaction-generator-lib auxiliary infrastructure. However, it should be noted that this library is primarily used for testing, benchmarking, and load generation purposes, not in core validator consensus or execution paths. The impact is limited to operational tooling rather than blockchain protocol security.

### Citations

**File:** crates/transaction-generator-lib/src/publishing/entry_point_trait.rs (L24-29)
```rust
    fn package_metadata(&self, package_name: &str) -> PackageMetadata {
        self.package_bundle()
            .get_package(package_name)
            .metadata
            .clone()
    }
```

**File:** crates/transaction-generator-lib/src/publishing/entry_point_trait.rs (L31-62)
```rust
    fn package_modules(&self, package_name: &str) -> Vec<(String, CompiledModule, u32)> {
        let mut results = vec![];
        let default_config = DeserializerConfig::new(VERSION_DEFAULT, IDENTIFIER_SIZE_MAX);

        let modules = &self.package_bundle().get_package(package_name).modules;
        for (module_name, bytes) in modules {
            let (module, binary_format_version) = if let Ok(module) =
                CompiledModule::deserialize_with_config(bytes, &default_config)
            {
                (module, VERSION_DEFAULT)
            } else {
                let module =
                    CompiledModule::deserialize(bytes).expect("Module must always deserialize");
                (module, VERSION_MAX)
            };
            results.push((module_name.to_owned(), module, binary_format_version));
        }

        results
    }

    fn package_script(&self, package_name: &str) -> Option<CompiledScript> {
        let scripts = &self.package_bundle().get_package(package_name).scripts;
        assert!(
            scripts.len() <= 1,
            "Only single script per package is supported"
        );

        scripts
            .last()
            .map(|bytes| CompiledScript::deserialize(bytes).expect("Script must deserialize"))
    }
```

**File:** crates/transaction-generator-lib/src/publishing/prebuild_packages.rs (L46-50)
```rust
    pub fn get_package(&self, package_name: &str) -> &PrebuiltPackage {
        self.packages
            .get(package_name)
            .unwrap_or_else(|| panic!("Package {package_name} does not exist"))
    }
```

**File:** crates/transaction-generator-lib/src/publishing/publish_util.rs (L68-78)
```rust
    pub fn new(pre_built: &'static dyn PreBuiltPackages, name: &str) -> Self {
        let packages = vec![PackageTracker {
            publishers: vec![],
            suffix: 0,
            package: Package::by_name(pre_built, name),
        }];
        PackageHandler {
            packages,
            is_simple: name == "simple",
        }
    }
```

**File:** crates/transaction-generator-lib/src/publishing/publish_util.rs (L129-138)
```rust
    pub fn by_name(pre_built: &'static dyn PreBuiltPackages, name: &str) -> Self {
        let modules = pre_built.package_modules(name);
        let metadata = pre_built.package_metadata(name);
        let script = pre_built.package_script(name);
        Self::Simple {
            modules,
            metadata,
            script,
        }
    }
```

**File:** crates/transaction-generator-lib/src/lib.rs (L343-354)
```rust
                TransactionType::PublishPackage {
                    use_account_pool,
                    pre_built,
                    package_name,
                } => wrap_accounts_pool(
                    Box::new(PublishPackageCreator::new(
                        txn_factory.clone(),
                        PackageHandler::new(pre_built, &package_name),
                    )),
                    use_account_pool,
                    &accounts_pool,
                ),
```
