# Audit Report

## Title
Missing Final State Root Verification Allows Incomplete State Restoration via Partial Range Proofs

## Summary
The `get_range_proof()` function does not verify that `rightmost_key` is actually the rightmost key in the queried range, and the production restore code lacks final root hash verification. This allows a malicious backup operator to create incomplete backups with valid range proofs that pass all incremental verifications during restore, resulting in an incomplete state tree without detection.

## Finding Description

The vulnerability exists in the backup/restore flow for state snapshots:

**Backup Flow Issue:**

The `get_range_proof()` function in `JellyfishMerkleTree` only verifies that the provided `rightmost_key` exists, but does NOT verify it's the actual rightmost key in any range: [1](#0-0) 

The function merely checks `account.is_some()` at line 807, confirming the key exists, but never validates whether this key is truly the rightmost in the queried range. This allows an attacker to request a proof for a key in the middle of a range.

During backup, chunks are created and proofs are requested for each chunk's `last_key`: [2](#0-1) 

If a malicious backup service returns incomplete chunks (missing keys), the `last_key` will be in the middle of the actual range, but a valid proof will still be generated.

**Restore Flow Issue:**

During restore, each chunk is verified using `SparseMerkleRangeProof::verify()`: [3](#0-2) 

This verification only confirms that the proof is valid for keys up to `rightmost_known_leaf`. The `right_siblings` in the proof represent subtrees containing keys beyond the rightmost known leaf, but these siblings are used only for hash computation—they are NOT added to the restored tree structure. [4](#0-3) 

The critical flaw is that after all chunks are restored, the production code does NOT verify the final root hash: [5](#0-4) 

The `finish_impl()` method only freezes remaining nodes and writes them to storage, with no final root hash verification. While test code verifies this: [6](#0-5) 

The production restore controller in backup-cli does not perform this check: [7](#0-6) 

**Attack Scenario:**

1. Malicious backup operator controls backup service responses
2. Returns incomplete state chunks (e.g., keys A,B,C when full state has A,B,C,D,E)
3. Generates valid range proof for key C (proof includes hashes for subtrees containing D,E)
4. During restore, incremental verification passes (proof is valid)
5. Final tree contains only A,B,C; keys D,E are missing
6. No error raised—restore appears successful
7. Node operates with incomplete state, causing failures or inconsistencies later

This breaks the **State Consistency** invariant that "State transitions must be atomic and verifiable via Merkle proofs."

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria because:

1. **Significant Protocol Violation**: Allows restoration of incomplete state that appears valid
2. **State Inconsistencies Requiring Intervention**: The incomplete state will cause:
   - Transaction execution failures when accessing missing state
   - Consensus disagreements when computing state roots
   - Potential node crashes or undefined behavior
   - Requires manual intervention to detect and fix

3. **Validator Node Impact**: Nodes restored from malicious backups would:
   - Compute incorrect state roots
   - Fail to validate blocks correctly  
   - Potentially cause consensus issues if multiple validators affected

While this doesn't directly cause fund loss or consensus safety violations (since other validators would reject incorrect state roots), it represents a significant state management vulnerability that could lead to network operational issues and requires intervention to resolve.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Attacker Requirements:**
- Control over backup service responses, OR
- Ability to provide malicious backup data to operators

**Realistic Scenarios:**
1. Compromised backup infrastructure
2. Malicious backup service operator
3. Man-in-the-middle attack on backup data transfer
4. Social engineering of node operators to use malicious backups

**Detection Difficulty:**
- Restore process appears successful (no errors)
- Issue only discovered when:
  - Node attempts state sync and root hash mismatches
  - Transactions fail due to missing state
  - Manual state verification performed

**Mitigation Factors:**
- Operators typically use trusted backup sources
- Other validators would reject incorrect state roots
- Issue likely detected during normal operation

However, the lack of explicit validation makes this a real threat, especially for new nodes joining the network or disaster recovery scenarios.

## Recommendation

Add explicit final root hash verification in the production restore flow:

**Fix 1: Add final verification in StateSnapshotRestoreController**

In `storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs`, after line 228:

```rust
tokio::task::spawn_blocking(move || {
    let restore = receiver.lock().take().unwrap();
    restore.finish()?;
    
    // CRITICAL FIX: Verify final root hash
    let state_merkle_db = ...; // Get access to state merkle DB
    let actual_root_hash = JellyfishMerkleTree::new(&state_merkle_db)
        .get_root_hash(self.version)?;
    
    ensure!(
        actual_root_hash == manifest.root_hash,
        "Final state root hash mismatch! Expected: {:x}, Got: {:x}. \
         State restoration incomplete or corrupted.",
        manifest.root_hash,
        actual_root_hash
    );
    
    Ok(())
}).await??;
```

**Fix 2: Add validation in JellyfishMerkleRestore::finish_impl**

Alternatively, add verification directly in the restore implementation:

```rust
pub fn finish_impl(mut self) -> Result<()> {
    self.wait_for_async_commit()?;
    
    // ... existing freeze logic ...
    
    self.freeze(0);
    self.store.write_node_batch(&self.frozen_nodes)?;
    
    // CRITICAL FIX: Verify final root hash matches expected
    let tree = JellyfishMerkleTree::new(self.store.as_ref());
    let actual_root_hash = tree.get_root_hash(self.version)?;
    
    ensure!(
        actual_root_hash == self.expected_root_hash,
        "State restoration root hash mismatch! Expected: {:x}, Got: {:x}. \
         This indicates incomplete or corrupted state data.",
        self.expected_root_hash,
        actual_root_hash
    );
    
    Ok(())
}
```

**Fix 3: Add range boundary validation in get_range_proof**

For defense-in-depth, add documentation and optional validation:

```rust
/// Gets the proof that shows a list of keys up to `rightmost_key_to_prove` exist at `version`.
/// 
/// # Security Note
/// This function does NOT verify that `rightmost_key_to_prove` is the actual rightmost
/// key in the tree. Callers must ensure they request proofs for the correct rightmost key
/// in their intended range. The restored state MUST be validated against expected root hash.
pub fn get_range_proof(
    &self,
    rightmost_key_to_prove: HashValue,
    version: Version,
) -> Result<SparseMerkleRangeProof> {
    // existing implementation
}
```

## Proof of Concept

```rust
// Proof of Concept demonstrating incomplete state restoration
// This test would fail with current code but should fail with proper validation

#[test]
fn test_incomplete_state_restoration_vulnerability() {
    use aptos_jellyfish_merkle::{JellyfishMerkleTree, mock_tree_store::MockTreeStore};
    use aptos_crypto::{hash::CryptoHash, HashValue};
    use std::collections::BTreeMap;
    
    // Setup: Create a complete state tree with keys A, B, C, D, E
    let complete_kvs: BTreeMap<HashValue, (Vec<u8>, Vec<u8>)> = [
        (b"A", b"value_a"),
        (b"B", b"value_b"),
        (b"C", b"value_c"),
        (b"D", b"value_d"),
        (b"E", b"value_e"),
    ]
    .iter()
    .map(|(k, v)| {
        let key = CryptoHash::hash(&k.to_vec());
        (key, (k.to_vec(), v.to_vec()))
    })
    .collect();
    
    let (complete_db, version) = init_mock_db(&complete_kvs);
    let complete_tree = JellyfishMerkleTree::new(&complete_db);
    let expected_root_hash = complete_tree.get_root_hash(version).unwrap();
    
    // Attack: Create incomplete backup with only A, B, C
    let incomplete_kvs: Vec<_> = complete_kvs.iter().take(3).collect();
    let rightmost_incomplete = incomplete_kvs.last().unwrap().0;
    
    // Generate proof for incomplete range (key C, not E)
    let proof = complete_tree.get_range_proof(*rightmost_incomplete, version).unwrap();
    
    // Restore: Create new DB and restore incomplete data
    let restore_db = Arc::new(MockTreeStore::default());
    let mut restore = StateSnapshotRestore::new(
        &restore_db,
        &restore_db,
        version,
        expected_root_hash,
        false,
        StateSnapshotRestoreMode::Default,
    ).unwrap();
    
    // Add incomplete chunk - this SHOULD fail but currently succeeds
    restore.add_chunk(
        incomplete_kvs.iter().map(|(_, (k, v))| (k.clone(), v.clone())).collect(),
        proof
    ).unwrap(); // ← Incremental verification passes!
    
    restore.finish().unwrap(); // ← No error raised!
    
    // Vulnerability: Restored tree has different root hash but no error was raised
    let restored_tree = JellyfishMerkleTree::new(&restore_db);
    let actual_root_hash = restored_tree.get_root_hash(version).unwrap();
    
    // This assertion demonstrates the vulnerability:
    // The restored root hash differs from expected, but restore succeeded
    assert_ne!(
        actual_root_hash, 
        expected_root_hash,
        "VULNERABILITY: Incomplete state restoration succeeded without detection!"
    );
    
    // Keys D and E are missing from restored state
    assert!(restored_tree.get(CryptoHash::hash(b"D"), version).unwrap().is_none());
    assert!(restored_tree.get(CryptoHash::hash(b"E"), version).unwrap().is_none());
}
```

## Notes

This vulnerability is particularly concerning because:

1. **Silent Failure**: The restore process completes without errors, giving operators false confidence in data integrity

2. **Test Coverage Gap**: While tests verify final root hash, production code does not, creating a dangerous discrepancy between test and production behavior

3. **Attack Surface**: Any compromise of backup infrastructure or malicious backup operators can exploit this to create invalid node states

4. **Operational Impact**: Detected only during normal operation when state inconsistencies cause failures, potentially requiring node rebuild or manual intervention

The fix is straightforward and should be implemented in both the restore controller and the JellyfishMerkleRestore implementation for defense-in-depth.

### Citations

**File:** storage/jellyfish-merkle/src/lib.rs (L801-824)
```rust
    pub fn get_range_proof(
        &self,
        rightmost_key_to_prove: HashValue,
        version: Version,
    ) -> Result<SparseMerkleRangeProof> {
        let (account, proof) = self.get_with_proof(rightmost_key_to_prove, version)?;
        ensure!(account.is_some(), "rightmost_key_to_prove must exist.");

        let siblings = proof
            .siblings()
            .iter()
            .zip(rightmost_key_to_prove.iter_bits())
            .filter_map(|(sibling, bit)| {
                // We only need to keep the siblings on the right.
                if !bit {
                    Some(*sibling)
                } else {
                    None
                }
            })
            .rev()
            .collect();
        Ok(SparseMerkleRangeProof::new(siblings))
    }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L429-437)
```rust
        tokio::io::copy(
            &mut self
                .client
                .get_account_range_proof(last_key, self.version())
                .await?,
            &mut proof_file,
        )
        .await?;
        proof_file.shutdown().await?;
```

**File:** types/src/proof/definition.rs (L782-826)
```rust
    pub fn verify(
        &self,
        expected_root_hash: HashValue,
        rightmost_known_leaf: SparseMerkleLeafNode,
        left_siblings: Vec<HashValue>,
    ) -> Result<()> {
        let num_siblings = left_siblings.len() + self.right_siblings.len();
        let mut left_sibling_iter = left_siblings.iter();
        let mut right_sibling_iter = self.right_siblings().iter();

        let mut current_hash = rightmost_known_leaf.hash();
        for bit in rightmost_known_leaf
            .key()
            .iter_bits()
            .rev()
            .skip(HashValue::LENGTH_IN_BITS - num_siblings)
        {
            let (left_hash, right_hash) = if bit {
                (
                    *left_sibling_iter
                        .next()
                        .ok_or_else(|| format_err!("Missing left sibling."))?,
                    current_hash,
                )
            } else {
                (
                    current_hash,
                    *right_sibling_iter
                        .next()
                        .ok_or_else(|| format_err!("Missing right sibling."))?,
                )
            };
            current_hash = SparseMerkleInternalNode::new(left_hash, right_hash).hash();
        }

        ensure!(
            current_hash == expected_root_hash,
            "{}: Root hashes do not match. Actual root hash: {:x}. Expected root hash: {:x}.",
            type_name::<Self>(),
            current_hash,
            expected_root_hash,
        );

        Ok(())
    }
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L628-697)
```rust
    fn verify(&self, proof: SparseMerkleRangeProof) -> Result<()> {
        let previous_leaf = self
            .previous_leaf
            .as_ref()
            .expect("The previous leaf must exist.");

        let previous_key = previous_leaf.account_key();
        // If we have all siblings on the path from root to `previous_key`, we should be able to
        // compute the root hash. The siblings on the right are already in the proof. Now we
        // compute the siblings on the left side, which represent all the states that have ever
        // been added.
        let mut left_siblings = vec![];

        // The following process might add some extra placeholder siblings on the left, but it is
        // nontrivial to determine when the loop should stop. So instead we just add these
        // siblings for now and get rid of them in the next step.
        let mut num_visited_right_siblings = 0;
        for (i, bit) in previous_key.iter_bits().enumerate() {
            if bit {
                // This node is a right child and there should be a sibling on the left.
                let sibling = if i >= self.partial_nodes.len() * 4 {
                    *SPARSE_MERKLE_PLACEHOLDER_HASH
                } else {
                    Self::compute_left_sibling(
                        &self.partial_nodes[i / 4],
                        previous_key.get_nibble(i / 4),
                        (3 - i % 4) as u8,
                    )
                };
                left_siblings.push(sibling);
            } else {
                // This node is a left child and there should be a sibling on the right.
                num_visited_right_siblings += 1;
            }
        }
        ensure!(
            num_visited_right_siblings >= proof.right_siblings().len(),
            "Too many right siblings in the proof.",
        );

        // Now we remove any extra placeholder siblings at the bottom. We keep removing the last
        // sibling if 1) it's a placeholder 2) it's a sibling on the left.
        for bit in previous_key.iter_bits().rev() {
            if bit {
                if *left_siblings.last().expect("This sibling must exist.")
                    == *SPARSE_MERKLE_PLACEHOLDER_HASH
                {
                    left_siblings.pop();
                } else {
                    break;
                }
            } else if num_visited_right_siblings > proof.right_siblings().len() {
                num_visited_right_siblings -= 1;
            } else {
                break;
            }
        }

        // Left siblings must use the same ordering as the right siblings in the proof
        left_siblings.reverse();

        // Verify the proof now that we have all the siblings
        proof
            .verify(
                self.expected_root_hash,
                SparseMerkleLeafNode::new(*previous_key, previous_leaf.value_hash()),
                left_siblings,
            )
            .map_err(Into::into)
    }
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L750-789)
```rust
    pub fn finish_impl(mut self) -> Result<()> {
        self.wait_for_async_commit()?;
        // Deal with the special case when the entire tree has a single leaf or null node.
        if self.partial_nodes.len() == 1 {
            let mut num_children = 0;
            let mut leaf = None;
            for i in 0..16 {
                if let Some(ref child_info) = self.partial_nodes[0].children[i] {
                    num_children += 1;
                    if let ChildInfo::Leaf(node) = child_info {
                        leaf = Some(node.clone());
                    }
                }
            }

            match num_children {
                0 => {
                    let node_key = NodeKey::new_empty_path(self.version);
                    assert!(self.frozen_nodes.is_empty());
                    self.frozen_nodes.insert(node_key, Node::Null);
                    self.store.write_node_batch(&self.frozen_nodes)?;
                    return Ok(());
                },
                1 => {
                    if let Some(node) = leaf {
                        let node_key = NodeKey::new_empty_path(self.version);
                        assert!(self.frozen_nodes.is_empty());
                        self.frozen_nodes.insert(node_key, node.into());
                        self.store.write_node_batch(&self.frozen_nodes)?;
                        return Ok(());
                    }
                },
                _ => (),
            }
        }

        self.freeze(0);
        self.store.write_node_batch(&self.frozen_nodes)?;
        Ok(())
    }
```

**File:** storage/aptosdb/src/state_restore/restore_test.rs (L251-252)
```rust
    let actual_root_hash = tree.get_root_hash(version).unwrap();
    assert_eq!(actual_root_hash, expected_root_hash);
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L228-230)
```rust
        tokio::task::spawn_blocking(move || receiver.lock().take().unwrap().finish()).await??;
        self.run_mode.finish();
        Ok(())
```
