# Audit Report

## Title
Stall Counter Inconsistency in Block Executor Leads to Execution Failure

## Summary
The `add_stall()` function in `scheduler_status.rs` performs an atomic increment of `num_stalls` before acquiring a lock and validating invariants. If the invariant check fails (specifically for incarnation 0 at line 377), the function returns an error but leaves `num_stalls` in an inconsistent state. This can cause subsequent legitimate `remove_stall()` operations to fail with a panic error, halting block execution. [1](#0-0) 

## Finding Description
The vulnerability stems from a Time-of-Check-Time-of-Use (TOCTOU) race condition in the stall mechanism of the BlockSTM v2 parallel execution scheduler. The `add_stall()` function has the following problematic sequence:

1. **Atomic increment happens first** (line 365): `num_stalls.fetch_add(1, Ordering::SeqCst)` executes outside any lock protection
2. **Lock acquisition** (line 367): Only after incrementing does it acquire the status lock
3. **Invariant validation** (line 373-377): Checks if the transaction is at incarnation 0 in PendingScheduling state
4. **Error return without rollback**: If validation fails, returns error but `num_stalls` remains incremented [2](#0-1) 

This violates the documented contract that "each successful add_stall call requires a guarantee that the corresponding remove_stall will eventually be performed." When `add_stall` returns an error, the caller treats it as a failed operation and does not call `remove_stall`, yet `num_stalls` has been incremented. [3](#0-2) 

Subsequently, when `remove_stall()` is called (potentially from a different code path or due to other stalls being removed), it encounters this inconsistent state. At line 437-441, if the transaction is at incarnation 0 in PendingScheduling state with `num_stalls = 1`, the function detects the violation and panics: [4](#0-3) 

## Impact Explanation
**Medium Severity** - State inconsistencies requiring intervention.

When this panic occurs, the error propagates through the execution stack:
- `remove_stall()` error → `AbortedDependencies::remove_stall()` error
- → `propagate()` error → `finish_execution()` error → Block execution failure [5](#0-4) [6](#0-5) [7](#0-6) 

This causes validators to fail block execution, requiring manual intervention to recover. While the design intends to prevent `add_stall` from being called on incarnation 0 (by only recording dependencies after aborts), the defensive invariant check itself creates a vulnerability through improper state management.

## Likelihood Explanation
**Medium Likelihood** - Requires specific conditions but possible through bugs or race conditions.

While the normal code flow prevents this (dependencies are only recorded for incarnation > 0), the scenario can occur if:

1. Any future code changes introduce a bug that calls `add_stall` on incarnation 0
2. Race conditions in the concurrent execution environment cause unexpected state transitions
3. Error recovery paths inadvertently trigger stall operations on incarnation 0

The very existence of the invariant check at line 377 indicates the developers anticipated this scenario could occur, making it a realistic defensive concern. [8](#0-7) 

## Recommendation
Fix the ordering by either:

**Option 1: Perform validation before atomic increment**
```rust
pub(crate) fn add_stall(&self, txn_idx: TxnIndex) -> Result<bool, PanicError> {
    let status = &self.statuses[txn_idx as usize];
    
    // Acquire lock first for validation
    let status_guard = status.status_with_incarnation.lock();
    let dependency_status =
        DependencyStatus::from_u8(status.dependency_shortcut.load(Ordering::Relaxed))?;
    
    // Validate invariants before modifying state
    match (status_guard.pending_scheduling(), dependency_status) {
        (Some(0), DependencyStatus::ShouldDefer) => {
            return Err(code_invariant_error("0-th incarnation in add_stall"));
        },
        (Some(_), DependencyStatus::IsSafe | DependencyStatus::WaitForExecution) => {
            return Err(code_invariant_error(
                "Inconsistent status and dependency shortcut in add_stall",
            ));
        },
        _ => {}
    }
    
    // Only increment after validation passes
    if status.num_stalls.fetch_add(1, Ordering::SeqCst) == 0 {
        // Handle 0→1 transition...
    }
    Ok(false)
}
```

**Option 2: Rollback on error**
```rust
if status.num_stalls.fetch_add(1, Ordering::SeqCst) == 0 {
    let status_guard = status.status_with_incarnation.lock();
    
    // ... validation checks ...
    
    match (status_guard.pending_scheduling(), dependency_status) {
        (Some(0), DependencyStatus::ShouldDefer) => {
            // Rollback the increment before returning error
            status.num_stalls.fetch_sub(1, Ordering::SeqCst);
            return Err(code_invariant_error("0-th incarnation in add_stall"));
        },
        // ... other error cases also need rollback ...
    }
}
```

Option 1 is cleaner as it validates before modifying state, preventing inconsistencies entirely.

## Proof of Concept
```rust
#[test]
fn test_stall_counter_inconsistency() {
    use crate::scheduler_status::{ExecutionStatus, ExecutionStatuses, StatusWithIncarnation, SchedulingStatus};
    use crate::scheduler_v2::ExecutionQueueManager;
    
    // Create a transaction at incarnation 0, PendingScheduling
    let execution_queue_manager = ExecutionQueueManager::new(1);
    let status = ExecutionStatus::new_for_test(
        StatusWithIncarnation::new_for_test(SchedulingStatus::PendingScheduling, 0),
        0, // num_stalls = 0
    );
    
    let statuses = ExecutionStatuses::new_for_test(
        execution_queue_manager,
        vec![status],
    );
    
    // Attempt to add_stall on incarnation 0 - this should fail
    let add_result = statuses.add_stall(0);
    assert!(add_result.is_err(), "add_stall should fail for incarnation 0");
    
    // BUG: num_stalls is now 1, but add_stall returned error!
    assert_eq!(statuses.get_status(0).num_stalls.load(Ordering::Relaxed), 1);
    
    // Now if remove_stall is called, it will also fail with panic
    let remove_result = statuses.remove_stall(0);
    assert!(remove_result.is_err(), "remove_stall fails due to inconsistent state");
    
    // This demonstrates the vulnerability: num_stalls is inconsistent
    // and legitimate remove operations fail
}
```

## Notes
This issue represents a defensive programming anti-pattern where state-modifying operations (atomic increment) occur before validation checks (invariant verification under lock). While the current design attempts to prevent this scenario through careful dependency tracking, the implementation itself is fragile and could cause execution failures if any code path violates the assumptions. The invariant check serves as a safety net but paradoxically creates a vulnerability through improper state management.

### Citations

**File:** aptos-move/block-executor/src/scheduler_status.rs (L88-93)
```rust
============================== Transaction Stall Mechanism ==============================

In the BlockSTMv2 scheduler, a transaction status can be "stalled," meaning there have been
more [ExecutionStatuses::add_stall] than [ExecutionStatuses::remove_stall] calls on its status.
Each successful [ExecutionStatuses::add_stall] call requires a guarantee that the
corresponding [ExecutionStatuses::remove_stall] will eventually be performed.
```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L363-377)
```rust
    pub(crate) fn add_stall(&self, txn_idx: TxnIndex) -> Result<bool, PanicError> {
        let status = &self.statuses[txn_idx as usize];
        if status.num_stalls.fetch_add(1, Ordering::SeqCst) == 0 {
            // Acquire write lock for (non-monitor) shortcut modifications.
            let status_guard = status.status_with_incarnation.lock();

            let dependency_status =
                DependencyStatus::from_u8(status.dependency_shortcut.load(Ordering::Relaxed))?;

            match (status_guard.pending_scheduling(), dependency_status) {
                (Some(0), DependencyStatus::ShouldDefer) => {
                    // Adding a stall requires being recorded in aborted dependencies in scheduler_v2,
                    // which in turn only happens in the scheduler after a successful abort (that must
                    // increment the incarnation of the status).
                    return Err(code_invariant_error("0-th incarnation in add_stall"));
```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L437-441)
```rust
            if let Some(incarnation) = status_guard.pending_scheduling() {
                if incarnation == 0 {
                    // Invariant due to scheduler logic: for a successful remove_stall there
                    // must have been an add_stall for incarnation 0, which is impossible.
                    return Err(code_invariant_error("0-th incarnation in remove_stall"));
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L343-346)
```rust
            if statuses.remove_stall(*idx)? {
                // May require recursive remove_stalls.
                stall_propagation_queue.insert(*idx as usize);
            }
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L931-932)
```rust
        // Handle recursive propagation of add / remove stall.
        self.propagate(stall_propagation_queue)?;
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L1229-1230)
```rust
                aborted_deps_guard
                    .remove_stall(&self.txn_statuses, &mut stall_propagation_queue)?;
```
