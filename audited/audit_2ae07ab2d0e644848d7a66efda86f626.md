# Audit Report

## Title
DKGTranscript Author Field Spoofing in ValidatorTransaction Processing

## Summary
The `DKGTranscript.metadata.author` field is not validated against the validator set when processing `ValidatorTransaction::DKGResult` in consensus or execution, allowing a malicious validator to submit DKG results with arbitrary author attribution, including non-existent addresses or other validators' addresses.

## Finding Description

The vulnerability exists in the validation flow for `ValidatorTransaction::DKGResult`. During peer-to-peer DKG transcript exchange, the system correctly validates that `metadata.author` matches the sender: [1](#0-0) 

However, when the final aggregated DKG result is submitted as a `ValidatorTransaction`, no such validation occurs. The consensus layer calls: [2](#0-1) 

Which delegates to: [3](#0-2) 

The `DKGTranscript::verify()` method only validates the cryptographic transcript content, not the metadata author: [4](#0-3) 

The `verify_transcript_extra` call uses `ensures_single_dealer=None`, meaning it validates dealer indices within the transcript but never checks if `metadata.author` corresponds to any actual validator: [5](#0-4) 

During execution, only the `transcript_bytes` are passed to Move, completely ignoring the author field: [6](#0-5) 

However, the `metadata.author` field is exported through the public API and indexer: [7](#0-6) 

**Attack Path:**
1. Malicious validator aggregates valid DKG transcripts
2. Creates `ValidatorTransaction::DKGResult` with `metadata.author` set to arbitrary address (e.g., another validator's address or `0x0`)
3. When selected as block proposer, includes this transaction in their proposal
4. Other validators accept the proposal because validation only checks cryptographic transcript validity
5. Spoofed author is committed to blockchain and exported through API/indexer

## Impact Explanation

This vulnerability breaks the **Transaction Validation** and **Access Control** invariants by allowing attribution manipulation in historical records. While it does not directly cause fund loss or consensus safety violations, it undermines protocol integrity by:

1. **Historical Record Corruption**: Blockchain explorers and indexers show incorrect authorship
2. **Off-chain System Manipulation**: Analytics, monitoring, or reputation systems relying on DKG authorship data receive false information
3. **Attribution Fraud**: Malicious validators can frame innocent validators or hide their own participation
4. **Protocol Violation**: The implicit expectation that author fields represent actual participants is violated

This qualifies as **Medium Severity** under "State inconsistencies requiring intervention" - the on-chain historical state contains incorrect attribution metadata that cannot be corrected without off-chain annotation systems.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is easily exploitable:
- **Low Technical Barrier**: Simply set `metadata.author` to any value when creating the transaction
- **No Cryptographic Requirements**: No signature forgery or complex cryptographic attack needed
- **Regular Opportunity**: Every time a validator becomes block proposer during DKG
- **No Detection**: Current validation logic has no checks to detect this attack

The only requirement is being a validator selected as block proposer, which occurs regularly in normal network operation.

## Recommendation

Add validation in the consensus layer to ensure `metadata.author` matches the block proposer or is at least a valid validator in the current epoch:

```rust
// In consensus/src/round_manager.rs, process_proposal method
if let Some(vtxns) = proposal.validator_txns() {
    for vtxn in vtxns {
        let vtxn_type_name = vtxn.type_name();
        ensure!(
            is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
            "unexpected validator txn: {:?}",
            vtxn_type_name
        );
        
        // Add author validation for DKGResult
        if let ValidatorTransaction::DKGResult(dkg_transcript) = vtxn {
            let author = dkg_transcript.metadata.author;
            ensure!(
                self.epoch_state.verifier.get_voting_power(&author).is_some(),
                "DKGResult author {} is not a valid validator",
                author
            );
        }
        
        vtxn.verify(self.epoch_state.verifier.as_ref())
            .context(format!("{} verify failed", vtxn_type_name))?;
    }
}
```

Alternatively, validate that the author matches the block proposer if the intention is that only the proposer should be attributed.

## Proof of Concept

```rust
#[test]
fn test_dkg_author_spoofing() {
    // Setup: Create a validator who will propose a block
    let mut round_manager = create_round_manager();
    let malicious_validator = round_manager.author();
    let victim_validator = AccountAddress::from_hex_literal("0xBEEF").unwrap();
    
    // Create valid DKG transcript with spoofed author
    let valid_transcript_bytes = create_valid_dkg_transcript(&round_manager);
    let spoofed_dkg_result = ValidatorTransaction::DKGResult(DKGTranscript {
        metadata: DKGTranscriptMetadata {
            epoch: round_manager.epoch(),
            author: victim_validator, // Spoofed to victim!
        },
        transcript_bytes: valid_transcript_bytes,
    });
    
    // Create proposal with spoofed transaction
    let proposal = create_proposal_with_vtxn(
        &round_manager,
        malicious_validator,
        vec![spoofed_dkg_result.clone()]
    );
    
    // Validate - should accept despite spoofed author
    let result = round_manager.process_proposal(proposal).await;
    assert!(result.is_ok(), "Proposal with spoofed author was rejected");
    
    // Verify the spoofed author is exported in API
    let exported = ExportedDKGTranscript::from(spoofed_dkg_result.unwrap_dkg());
    assert_eq!(exported.author, victim_validator);
    // Historical records now incorrectly show victim_validator submitted this DKG result
}
```

## Notes

The vulnerability specifically affects the final `ValidatorTransaction::DKGResult` submission, not the peer-to-peer transcript exchange phase where validation is correctly implemented. The fix should add validation at consensus proposal processing time to ensure metadata integrity before the transaction is committed to the blockchain and exported through public APIs.

### Citations

**File:** dkg/src/transcript_aggregation/mod.rs (L84-86)
```rust
        ensure!(
            metadata.author == sender,
            "[DKG] adding peer transcript failed with node author mismatch"
```

**File:** consensus/src/round_manager.rs (L1126-1136)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
```

**File:** types/src/validator_txn.rs (L45-52)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        match self {
            ValidatorTransaction::DKGResult(dkg_result) => dkg_result
                .verify(verifier)
                .context("DKGResult verification failed"),
            ValidatorTransaction::ObservedJWKUpdate(_) => Ok(()),
        }
    }
```

**File:** types/src/dkg/mod.rs (L83-87)
```rust
    pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
        let transcripts: Transcripts = bcs::from_bytes(&self.transcript_bytes)
            .context("Transcripts deserialization failed")?;
        RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L295-329)
```rust
    fn verify_transcript_extra(
        trx: &Self::Transcript,
        verifier: &ValidatorVerifier,
        checks_voting_power: bool,
        ensures_single_dealer: Option<AccountAddress>,
    ) -> anyhow::Result<()> {
        let all_validator_addrs = verifier.get_ordered_account_addresses();
        let main_trx_dealers = trx.main.get_dealers();
        let mut dealer_set = HashSet::with_capacity(main_trx_dealers.len());
        for dealer in main_trx_dealers.iter() {
            if let Some(dealer_addr) = all_validator_addrs.get(dealer.id) {
                dealer_set.insert(*dealer_addr);
            } else {
                bail!("invalid dealer idx");
            }
        }
        ensure!(main_trx_dealers.len() == dealer_set.len());
        if ensures_single_dealer.is_some() {
            let expected_dealer_set: HashSet<AccountAddress> =
                ensures_single_dealer.into_iter().collect();
            ensure!(expected_dealer_set == dealer_set);
        }

        if checks_voting_power {
            verifier
                .check_voting_power(dealer_set.iter(), true)
                .context("not enough power")?;
        }

        if let Some(fast_trx) = &trx.fast {
            ensure!(fast_trx.get_dealers() == main_trx_dealers);
            ensure!(trx.main.get_dealt_public_key() == fast_trx.get_dealt_public_key());
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L99-112)
```rust
        // Check epoch number.
        if dkg_node.metadata.epoch != config_resource.epoch() {
            return Err(Expected(EpochNotCurrent));
        }

        // Deserialize transcript and verify it.
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** api/types/src/transaction.rs (L848-860)
```rust
impl From<DKGTranscript> for ExportedDKGTranscript {
    fn from(value: DKGTranscript) -> Self {
        let DKGTranscript {
            metadata,
            transcript_bytes,
        } = value;
        let DKGTranscriptMetadata { epoch, author } = metadata;
        Self {
            epoch: epoch.into(),
            author: author.into(),
            payload: HexEncodedBytes::from(transcript_bytes),
        }
    }
```
