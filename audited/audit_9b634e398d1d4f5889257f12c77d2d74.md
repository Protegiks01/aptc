# Audit Report

## Title
Table Detection Bypass via Function Type Captured Values in Move Resource Viewer

## Summary
The `contains_tables()` method incorrectly returns `false` for all function types, regardless of whether closures capture table values. This causes the storage indexer to miss table references hidden inside closure captured values, leading to incomplete table tracking and potential state query inconsistencies.

## Finding Description

The Move resource viewer implements table detection to track all `Table<K,V>` instances across blockchain state. However, there is a critical flaw in how function types are analyzed for table content.

**The Root Cause:** [1](#0-0) 

The `contains_tables()` method returns `false` unconditionally for `FatType::Function(_)` types (line 548), even though function types can contain tables in two ways:
1. In their type signatures (argument or return types)
2. In their captured values at runtime (closures)

**The Vulnerability Chain:**

When `FatStructType::subst()` computes whether a substituted type contains tables: [2](#0-1) 

It relies on the `contains_tables()` check (line 190) which incorrectly returns `false` for function types.

The indexer uses this detection to identify tables in resources: [3](#0-2) 

When `contains_tables()` returns `false`, the early return at line 700 prevents table discovery.

Even if the check passes, function values are skipped entirely during recursive table collection: [4](#0-3) 

At line 1043, function values return immediately without examining captured values for tables.

**Attack Scenario:**

A user can create a Move module with a struct containing a closure that captures a table:

```move
struct Wrapper has key {
    f: |u64| u64 has store
}

public entry fun store_closure(account: &signer) {
    let table = table::new<u64, u64>();
    table::add(&mut table, 1, 100);
    
    // Closure captures the table
    let f = |x| *table::borrow(&table, x);
    move_to(account, Wrapper { f });
}
```

The closure's captured values contain the table instance (stored in `MoveClosure.captured` field): [5](#0-4) 

When the indexer processes this resource: [6](#0-5) 

The table hidden in the closure's captured values is never discovered and tracked, causing indexer state to be incomplete.

## Impact Explanation

This qualifies as **Medium Severity** under Aptos bug bounty criteria ("State inconsistencies requiring intervention").

**Concrete Impacts:**
1. **Incomplete Indexer State**: The storage indexer maintains a mapping of all table handles to their key/value types. Tables captured in closures are missing from this mapping.

2. **Query Inconsistencies**: API queries relying on table metadata will return incomplete results, potentially affecting:
   - Table enumeration endpoints
   - State synchronization operations  
   - Analytics and monitoring tools

3. **State Sync Issues**: If nodes rely on the indexer for table discovery during state synchronization, they may miss table data hidden in closures.

4. **Chain Integrity Risk**: While not directly causing consensus splits, the inconsistency between actual chain state and indexed state violates the State Consistency invariant that "state transitions must be verifiable."

This does not reach Critical severity because:
- No direct fund loss or theft
- Consensus remains functional
- Tables can still be accessed if handles are known through other means
- Issue is limited to indexer subsystem

## Likelihood Explanation

**Likelihood: Medium-High**

Move recently added first-class function support with closures that can have `store` ability. Tables also have `store` ability: [7](#0-6) 

The runtime allows closures to capture any value with `store` ability: [8](#0-7) 

At line 166, captured values' abilities are intersected with the closure's abilities, allowing tables (which have `store`) to be captured if the function is public or persistent.

The attack requires:
- Deploying a module with closures (standard Move feature)
- No special privileges needed
- Works on any Aptos network

The likelihood is high because:
- The feature is newly available and developers may naturally use it
- No warnings prevent this pattern
- The bug affects any closure capturing tables, intentionally or accidentally

## Recommendation

Fix the `contains_tables()` method to recursively check function type signatures and update `collect_table_info_from_value()` to examine closure captured values:

**Fix 1**: Update `contains_tables()` in `fat_type.rs`:

```rust
pub(crate) fn contains_tables(&self) -> bool {
    match self {
        FatType::Struct(st) => st.contains_tables,
        FatType::MutableReference(ty) | FatType::Reference(ty) | FatType::Vector(ty) => {
            ty.contains_tables()
        },
        FatType::Runtime(tys) => tys.iter().any(|ty| ty.contains_tables()),
        FatType::RuntimeVariants(vars) => vars.iter().flatten().any(|ty| ty.contains_tables()),
        // FIX: Check function argument and return types for tables
        FatType::Function(fun_ty) => {
            fun_ty.args.iter().any(|ty| ty.contains_tables()) ||
            fun_ty.results.iter().any(|ty| ty.contains_tables())
        },
        // ... primitives return false
        _ => false,
    }
}
```

**Fix 2**: Update `collect_table_info_from_value()` in `lib.rs` to process function values:

```rust
(FatType::Function(_fun_ty), MoveValue::Closure(closure)) => {
    // Process captured values for tables
    for (layout, value) in &closure.captured {
        let fat_type = FatType::from_runtime_layout(layout, limit)
            .map_err(|e| anyhow!("failed to process captured value: {}", e))?;
        self.collect_table_info_from_value(&fat_type, value.clone(), limit, infos)?;
    }
    Ok(())
},
```

## Proof of Concept

**Move Module** (`sources/closure_table_bypass.move`):

```move
module 0x1::closure_table_bypass {
    use aptos_std::table::{Self, Table};
    use std::signer;

    struct ClosureWrapper has key {
        compute: |u64| u64 has store,
    }

    public entry fun exploit(account: &signer) {
        // Create a table
        let table = table::new<u64, u64>();
        table::add(&mut table, 1, 100);
        table::add(&mut table, 2, 200);
        
        // Create closure that captures the table
        // This table will NOT be tracked by the indexer
        let compute = |key: u64| -> u64 {
            *table::borrow(&table, key)
        };
        
        // Store the closure (and its captured table)
        move_to(account, ClosureWrapper { compute });
    }

    #[view]
    public fun verify_exists(addr: address): bool {
        exists<ClosureWrapper>(addr)
    }
}
```

**Test Steps:**
1. Deploy the module above
2. Call `exploit()` to store a closure capturing a table
3. Query the indexer for all tables at that address
4. **Expected**: The table should be listed in indexer state
5. **Actual**: The table is missing - indexer returns incomplete data
6. The table exists in the resource but is invisible to table enumeration APIs

**Rust Test** (add to `third_party/move/tools/move-resource-viewer/src/lib.rs`):

```rust
#[test]
fn test_closure_table_detection() {
    use move_core_types::value::{MoveValue, MoveStruct};
    use move_core_types::function::MoveClosure;
    
    // Create a closure that captures a table
    let table = /* construct table value */;
    let closure = MoveClosure {
        captured: vec![(/* table layout */, table)],
        // ... other fields
    };
    
    let function_type = FatType::Function(/* ... */);
    
    // BUG: This returns false even though closure captures a table
    assert!(!function_type.contains_tables());
    
    let mut infos = vec![];
    // BUG: collect_table_info_from_value skips the closure
    // The captured table is never added to infos
    annotator.collect_table_info_from_value(
        &function_type,
        MoveValue::Closure(closure),
        &mut Limiter::default(),
        &mut infos
    ).unwrap();
    
    assert_eq!(infos.len(), 0); // BUG: Should be 1
}
```

## Notes

This vulnerability affects the storage indexer subsystem specifically. While the Move VM and consensus layers remain secure, the indexer's incomplete view of chain state can impact:
- REST API table query endpoints
- Block explorers and analytics platforms  
- Any service relying on complete table enumeration

The issue becomes more severe as Move's closure feature gains adoption. Since closures with `store` ability are a legitimate programming pattern, developers may inadvertently trigger this bug without realizing tables are being hidden from indexer tracking.

### Citations

**File:** third_party/move/tools/move-resource-viewer/src/fat_type.rs (L175-222)
```rust
    pub fn subst(
        &self,
        ty_args: &[FatType],
        subst_struct: &impl Fn(
            &FatStructType,
            &[FatType],
            &mut Limiter,
        ) -> PartialVMResult<FatStructRef>,
        limiter: &mut Limiter,
    ) -> PartialVMResult<FatStructType> {
        limiter.charge(std::mem::size_of::<AccountAddress>())?;
        limiter.charge(self.module.as_bytes().len())?;
        limiter.charge(self.name.as_bytes().len())?;
        // self.contains_tables already reflects tables directly used in field types, we
        // only need to combine it here with tables used in type arguments.
        let contains_tables = self.contains_tables || ty_args.iter().any(|t| t.contains_tables());
        Ok(Self {
            address: self.address,
            module: self.module.clone(),
            name: self.name.clone(),
            abilities: self.abilities,
            ty_args: self
                .ty_args
                .iter()
                .map(|ty| ty.subst(ty_args, subst_struct, limiter))
                .collect::<PartialVMResult<_>>()?,
            layout: match &self.layout {
                FatStructLayout::Singleton(fields) => FatStructLayout::Singleton(
                    fields
                        .iter()
                        .map(|ty| ty.subst(ty_args, subst_struct, limiter))
                        .collect::<PartialVMResult<_>>()?,
                ),
                FatStructLayout::Variants(variants) => FatStructLayout::Variants(
                    variants
                        .iter()
                        .map(|fields| {
                            fields
                                .iter()
                                .map(|ty| ty.subst(ty_args, subst_struct, limiter))
                                .collect::<PartialVMResult<_>>()
                        })
                        .collect::<PartialVMResult<_>>()?,
                ),
            },
            contains_tables,
        })
    }
```

**File:** third_party/move/tools/move-resource-viewer/src/fat_type.rs (L530-556)
```rust
    pub(crate) fn contains_tables(&self) -> bool {
        match self {
            FatType::Struct(st) => st.contains_tables,
            FatType::MutableReference(ty) | FatType::Reference(ty) | FatType::Vector(ty) => {
                ty.contains_tables()
            },
            FatType::Runtime(tys) => tys.iter().any(|ty| ty.contains_tables()),
            FatType::RuntimeVariants(vars) => vars.iter().flatten().any(|ty| ty.contains_tables()),
            FatType::Bool
            | FatType::U8
            | FatType::U64
            | FatType::U128
            | FatType::Address
            | FatType::Signer
            | FatType::TyParam(_)
            | FatType::U16
            | FatType::U32
            | FatType::U256
            | FatType::Function(_)
            | FatType::I8
            | FatType::I16
            | FatType::I32
            | FatType::I64
            | FatType::I128
            | FatType::I256 => false,
        }
    }
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L692-718)
```rust
    pub fn collect_table_info(
        &self,
        ty_tag: &TypeTag,
        blob: &[u8],
        infos: &mut Vec<MoveTableInfo>,
    ) -> anyhow::Result<()> {
        let mut limit = Limiter::default();
        if !self.contains_tables(ty_tag, &mut limit)? {
            return Ok(());
        }
        let fat_ty = self.resolve_type_impl(ty_tag, &mut limit)?;
        let layout = (&fat_ty).try_into().map_err(into_vm_status)?;
        let move_value = MoveValue::simple_deserialize(blob, &layout)?;
        self.collect_table_info_from_value(&fat_ty, move_value, &mut limit, infos)
    }

    fn contains_tables(&self, ty_tag: &TypeTag, limit: &mut Limiter) -> anyhow::Result<bool> {
        if let Some(contains) = self.contains_tables_cache.borrow().get(ty_tag) {
            return Ok(*contains);
        }
        let ty = self.resolve_type_impl(ty_tag, limit)?;
        let contains = ty.contains_tables();
        self.contains_tables_cache
            .borrow_mut()
            .insert(ty_tag.clone(), contains);
        Ok(contains)
    }
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L954-1051)
```rust
    fn collect_table_info_from_value(
        &self,
        ty: &FatType,
        val: MoveValue,
        limit: &mut Limiter,
        infos: &mut Vec<MoveTableInfo>,
    ) -> anyhow::Result<()> {
        match (ty, val) {
            (FatType::Vector(elem_ty), MoveValue::Vector(elem_vals)) => {
                if elem_ty.contains_tables() {
                    for val in elem_vals {
                        self.collect_table_info_from_value(elem_ty, val, limit, infos)?
                    }
                }
                Ok(())
            },
            (FatType::Struct(sty), MoveValue::Struct(sval)) => {
                if sty.is_table()
                    && let [key_type, value_type] = sty.ty_args.as_slice()
                    && let MoveStruct::Runtime(vals) = &sval
                    && let Some(MoveValue::Address(handle)) = vals.first()
                {
                    infos.push(MoveTableInfo {
                        key_type: key_type.type_tag(limit)?,
                        value_type: value_type.type_tag(limit)?,
                        handle: *handle,
                    });
                    Ok(())
                } else if sty.contains_tables {
                    match (&sty.layout, sval) {
                        (
                            FatStructLayout::Singleton(field_tys),
                            MoveStruct::Runtime(field_vals),
                        ) => {
                            for (ty, val) in field_tys.iter().zip(field_vals) {
                                self.collect_table_info_from_value(ty, val, limit, infos)?
                            }
                            Ok(())
                        },
                        (
                            FatStructLayout::Variants(variants),
                            MoveStruct::RuntimeVariant(tag, field_vals),
                        ) if (tag as usize) < variants.len() => {
                            for (ty, val) in variants[tag as usize].iter().zip(field_vals) {
                                self.collect_table_info_from_value(ty, val, limit, infos)?
                            }
                            Ok(())
                        },
                        (_, sval) => {
                            bail!("invalid type/value while extracting table info: type={:?}, value={:?}", sty, sval)
                        },
                    }
                } else {
                    Ok(())
                }
            },
            (FatType::Runtime(tys), MoveValue::Struct(MoveStruct::Runtime(vals))) => {
                for (ty, val) in tys.iter().zip(vals) {
                    self.collect_table_info_from_value(ty, val, limit, infos)?
                }
                Ok(())
            },
            (
                FatType::RuntimeVariants(vars),
                MoveValue::Struct(MoveStruct::RuntimeVariant(tag, vals)),
            ) if (tag as usize) < vars.len() => {
                for (ty, val) in vars[tag as usize].iter().zip(vals) {
                    self.collect_table_info_from_value(ty, val, limit, infos)?
                }
                Ok(())
            },

            // Every other combo cannot harbor tables.
            (FatType::Bool, _)
            | (FatType::U8, _)
            | (FatType::U16, _)
            | (FatType::U32, _)
            | (FatType::U64, _)
            | (FatType::U128, _)
            | (FatType::U256, _)
            | (FatType::Address, _)
            | (FatType::Signer, _)
            | (FatType::Vector(_), _)
            | (FatType::Struct(_), _)
            | (FatType::Reference(_), _)
            | (FatType::MutableReference(_), _)
            | (FatType::TyParam(_), _)
            | (FatType::Runtime(_), _)
            | (FatType::RuntimeVariants(_), _)
            | (FatType::Function(_), _)
            | (FatType::I8, _)
            | (FatType::I16, _)
            | (FatType::I32, _)
            | (FatType::I64, _)
            | (FatType::I128, _)
            | (FatType::I256, _) => Ok(()),
        }
    }
```

**File:** third_party/move/move-core/types/src/function.rs (L256-262)
```rust
pub struct MoveClosure {
    pub module_id: ModuleId,
    pub fun_id: Identifier,
    pub ty_args: Vec<TypeTag>,
    pub mask: ClosureMask,
    pub captured: Vec<(MoveTypeLayout, MoveValue)>,
}
```

**File:** storage/indexer/src/db_v2.rs (L260-268)
```rust
        struct_tag: StructTag,
        bytes: &Bytes,
    ) -> Result<()> {
        let ty_tag = TypeTag::Struct(Box::new(struct_tag));
        let mut infos = vec![];
        self.annotator
            .collect_table_info(&ty_tag, bytes, &mut infos)?;
        self.process_table_infos(infos)
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/table.move (L12-15)
```text
    /// Type of tables
    struct Table<phantom K: copy + drop, phantom V> has store {
        handle: address,
    }
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L142-188)
```rust
pub fn verify_pack_closure(
    ty_builder: &TypeBuilder,
    operand_stack: &mut Stack,
    func: &LoadedFunction,
    mask: ClosureMask,
) -> PartialVMResult<()> {
    // Accumulated abilities
    let mut abilities = if func.function.is_persistent() {
        AbilitySet::PUBLIC_FUNCTIONS
    } else {
        AbilitySet::PRIVATE_FUNCTIONS
    };
    // Verify that captured arguments are assignable against types in the function
    // signature, and that they are no references.
    let expected_capture_tys = mask.extract(func.param_tys(), true);

    let given_capture_tys = operand_stack.popn_tys(expected_capture_tys.len() as u16)?;
    for (expected, given) in expected_capture_tys
        .into_iter()
        .zip(given_capture_tys.into_iter())
    {
        expected.paranoid_check_is_no_ref("Captured argument type")?;
        with_instantiation(ty_builder, func, expected, |expected| {
            // Intersect the captured type with the accumulated abilities
            abilities = abilities.intersect(given.abilities()?);
            given.paranoid_check_assignable(expected)
        })?
    }
    // Push result type onto stack
    let args = mask
        .extract(func.param_tys(), false)
        .into_iter()
        .map(|curried| with_owned_instantiation(ty_builder, func, curried, Ok))
        .collect::<PartialVMResult<Vec<_>>>()?;
    let results = func
        .return_tys()
        .iter()
        .map(|ret| with_owned_instantiation(ty_builder, func, ret, Ok))
        .collect::<PartialVMResult<Vec<_>>>()?;
    operand_stack.push_ty(Type::Function {
        args,
        results,
        abilities,
    })?;

    Ok(())
}
```
