# Audit Report

## Title
Peer Role Spoofing via Unsafe VFN Role Assignment in Validator Network Handshake

## Summary
Malicious full nodes can exploit an unsafe assumption in the Noise handshake authentication logic to masquerade as Validator Full Nodes (VFNs), gaining elevated trust and priority in peer selection algorithms. The vulnerability exists in the inbound connection handling for validators on the VFN network, where any non-authenticated peer is automatically assigned the `PeerRole::ValidatorFullNode` role without cryptographic proof.

## Finding Description

The vulnerability exists in the `upgrade_inbound` function of the Noise handshake protocol. When a validator receives an inbound connection on the VFN network from a peer that is NOT in the trusted peers set, the code makes an unsafe assumption: [1](#0-0) 

This code assumes that any inbound connection to a validator on the VFN network MUST be from a ValidatorFullNode. However, this assumption is made in the `MaybeMutual` authentication mode for peers not in the trusted set, meaning:

1. The peer's identity is verified (peer_id matches public key)
2. But there is NO cryptographic proof that the peer is actually a VFN

The role assignment occurs here: [2](#0-1) 

Once assigned `PeerRole::ValidatorFullNode`, this role is stored in `ConnectionMetadata`: [3](#0-2) 

This spoofed role then affects multiple critical subsystems:

**1. Peer Monitoring Service Validation:**
The peer can claim `distance_from_validators = 1` and pass validation because the system checks if the peer has the VFN role: [4](#0-3) 

**2. State-Sync Peer Priority:**
The spoofed VFN receives `MediumPriority` instead of `LowPriority`: [5](#0-4) 

**3. Upstream/Downstream Peer Selection:**
VFNs are included in upstream roles for public networks and downstream roles for VFN networks: [6](#0-5) [7](#0-6) 

**Attack Steps:**
1. Attacker creates a full node with a valid x25519 keypair
2. Connects to a validator on the VFN network (inbound connection)
3. Completes Noise handshake with correctly derived peer_id
4. Gets automatically assigned `PeerRole::ValidatorFullNode`
5. Sends `NetworkInformationResponse` claiming `distance_from_validators = 1`
6. Passes all validation checks due to spoofed VFN role
7. Gains elevated priority in peer selection across multiple subsystems

## Impact Explanation

This is a **HIGH severity** vulnerability according to Aptos bug bounty criteria because it enables:

1. **Significant Protocol Violations**: Breaks the trust model assumption that VFN roles are authenticated
2. **Validator Node Manipulation**: Affects peer selection algorithms used by validators for state-sync and mempool operations
3. **Trust Escalation Attack**: Allows unauthorized peers to gain elevated privileges in the network hierarchy
4. **Network Integrity Impact**: Multiple malicious nodes could coordinate to manipulate peer selection, potentially isolating validators or disrupting data propagation

The impact is amplified because:
- State-sync prioritizes VFN peers for data transfer
- Peer monitoring service trusts distance metrics from VFN peers
- Connectivity manager uses peer roles for upstream/downstream decisions
- Mempool may prioritize transaction forwarding based on peer roles

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely because:

1. **Low Barrier to Entry**: Any actor can create a full node and connect to validators
2. **No Special Privileges Required**: Does not require validator access, stake, or insider knowledge
3. **Simple Exploitation**: Attack requires only standard network connection capabilities
4. **No Detection Mechanisms**: Current implementation has no way to detect this role spoofing
5. **Scalable**: Attacker can deploy multiple malicious nodes to amplify impact

The vulnerability is exploitable on any validator running in the default configuration with the VFN network enabled.

## Recommendation

**Immediate Fix**: Do not automatically assign `PeerRole::ValidatorFullNode` to non-authenticated peers. Instead, assign `PeerRole::Unknown` and require explicit authentication.

**Code Fix:**
```rust
// In network/framework/src/noise/handshake.rs, lines 406-423
// Replace the unsafe role inference with:

if self.network_context.role().is_validator() {
    if network_id.is_vfn_network() {
        // Do NOT assume inbound connections are VFNs
        // Only authenticated peers in trusted set can have VFN role
        Ok(PeerRole::Unknown)
    } else {
        // Otherwise, they're unknown
        Ok(PeerRole::Unknown)
    }
} else {
    // We're a VFN or PFN
    Ok(PeerRole::Unknown)
}
```

**Long-term Solution:**
1. Require VFNs to be in the trusted peers set for validators
2. Implement cryptographic attestation of node roles
3. Add runtime verification that VFN peers actually connect to their assigned validators
4. Enhance peer monitoring to detect inconsistent role claims

## Proof of Concept

```rust
#[test]
fn test_vfn_role_spoofing_attack() {
    use aptos_config::config::{PeerRole, RoleType};
    use aptos_config::network_id::{NetworkContext, NetworkId};
    use aptos_crypto::x25519;
    use aptos_memsocket::MemorySocket;
    use aptos_network::application::storage::PeersAndMetadata;
    use aptos_types::PeerId;
    use futures::executor::block_on;
    
    // Create a validator node (victim)
    let validator_peer_id = PeerId::random();
    let validator_key = x25519::PrivateKey::generate(&mut rand::rngs::OsRng);
    let validator_context = NetworkContext::new(
        RoleType::Validator,
        NetworkId::Vfn,
        validator_peer_id,
    );
    
    // Create peers_and_metadata with empty trusted peers
    let peers_and_metadata = PeersAndMetadata::new(&[NetworkId::Vfn]);
    
    // Create validator's handshake handler
    let validator_handshake = NoiseUpgrader::new(
        validator_context,
        validator_key,
        HandshakeAuthMode::maybe_mutual(peers_and_metadata),
    );
    
    // Create a malicious node (attacker)
    let attacker_peer_id = PeerId::random();
    let attacker_key = x25519::PrivateKey::generate(&mut rand::rngs::OsRng);
    let attacker_pubkey = attacker_key.public_key();
    let attacker_context = NetworkContext::new(
        RoleType::FullNode, // Regular full node
        NetworkId::Vfn,
        attacker_peer_id,
    );
    
    // Attacker creates handshake as a regular full node
    let attacker_handshake = NoiseUpgrader::new(
        attacker_context,
        attacker_key,
        HandshakeAuthMode::server_only(&[NetworkId::Vfn]),
    );
    
    // Simulate inbound connection from attacker to validator
    let (validator_socket, attacker_socket) = MemorySocket::new_pair();
    
    // Attacker initiates connection
    let attacker_task = async move {
        attacker_handshake
            .upgrade_outbound(
                attacker_socket,
                validator_peer_id,
                validator_key.public_key(),
                AntiReplayTimestamps::now,
            )
            .await
    };
    
    // Validator accepts connection
    let validator_task = async move {
        validator_handshake.upgrade_inbound(validator_socket).await
    };
    
    let (attacker_result, validator_result) = block_on(futures::future::join(
        attacker_task,
        validator_task,
    ));
    
    // Verify the attack succeeded
    let (_, _, peer_role) = validator_result.unwrap();
    
    // BUG: Attacker is assigned ValidatorFullNode role without authentication!
    assert_eq!(peer_role, PeerRole::ValidatorFullNode);
    
    // The attacker now has elevated privileges:
    // - Can claim distance_from_validators = 1
    // - Gets MediumPriority in state-sync
    // - Selected as upstream peer
    // - Trusted for network information
}
```

**Notes:**
- The actual handshake authentication code confirms the peer_id is derived from the public key, preventing complete identity spoofing
- However, it does NOT authenticate that the peer is actually a VFN with validator connections
- Any full node can exploit this to gain VFN privileges on validator nodes
- This breaks the trust assumptions of the peer role hierarchy used throughout the Aptos networking stack

### Citations

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** network/framework/src/transport/mod.rs (L320-331)
```rust
    Ok(Connection {
        socket,
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
    })
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L128-135)
```rust
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
```

**File:** state-sync/aptos-data-client/src/priority.rs (L67-72)
```rust
        // connected to a validator is a rare (but possible) scenario.
        return if peer_network_id.is_vfn_network() {
            PeerPriority::MediumPriority
        } else {
            PeerPriority::LowPriority
        };
```

**File:** config/src/network_id.rs (L176-180)
```rust
            NetworkId::Public => &[
                PeerRole::PreferredUpstream,
                PeerRole::Upstream,
                PeerRole::ValidatorFullNode,
            ],
```

**File:** config/src/network_id.rs (L199-201)
```rust
            NetworkId::Vfn => match role {
                RoleType::Validator => &[PeerRole::ValidatorFullNode],
                RoleType::FullNode => &[],
```
