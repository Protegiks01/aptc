# Audit Report

## Title
Consensus Configuration Inconsistency Due to Missing Version Compatibility Enforcement in OnChain Config Deserialization

## Summary
During rolling upgrades, validators running different software versions can operate with inconsistent consensus configurations when a governance proposal updates `OnChainConsensusConfig` to a newer variant (e.g., V5) that older validators cannot deserialize. This creates a critical liveness failure where validators sign different `LedgerInfo` hashes, preventing quorum formation and halting the network.

## Finding Description

The vulnerability stems from the interaction between BCS enum deserialization, fallback behavior, and the `order_vote_enabled` flag's impact on commit ledger info generation.

**Execution Flow:**

1. **Config Deserialization Phase**: At epoch transition, validators fetch `OnChainConsensusConfig` from on-chain state. [1](#0-0) 

2. **Deserialization Failure**: Validators running older software (knowing only V1-V4) fail to deserialize V5 configs via BCS, as BCS cannot handle unknown enum variants. The code logs a warning but continues. [2](#0-1) 

3. **Fallback to Default**: Failed deserialization triggers `unwrap_or_default()`, returning `OnChainConsensusConfig::V4` with `order_vote_enabled: false`. [3](#0-2) 

4. **Config Divergence**: Newer validators use V5 (potentially with `order_vote_enabled: true`), while older validators use V4 default (with `order_vote_enabled: false`). [4](#0-3) 

5. **Critical Impact - Different LedgerInfo Construction**: The `generate_commit_ledger_info` function creates fundamentally different `LedgerInfo` objects based on `order_vote_enabled`:
   - When `true`: uses `HashValue::zero()` as `consensus_data_hash`
   - When `false`: uses `ordered_proof.ledger_info().consensus_data_hash()` [5](#0-4) 

6. **Quorum Formation Failure**: Validators sign different `LedgerInfo` hashes, making signature aggregation impossible. The network cannot form a commit quorum. [6](#0-5) 

**No Version Enforcement**: The Move framework's `set_for_next_epoch` only validates that config bytes are non-empty, with no check that all validators can deserialize the new variant. [7](#0-6) 

## Impact Explanation

**Critical Severity - Total Loss of Liveness/Network Availability**

This vulnerability meets the Aptos bug bounty's **Critical** criteria for "Total Loss of Liveness/Network Availability: Network halts due to protocol bug, all validators unable to progress."

The impact is severe because:

1. **Complete Network Halt**: Validators cannot aggregate signatures on commit decisions, preventing any blocks from being committed
2. **Silent Failure**: Validators continue operating but cannot reach consensus, making the issue difficult to diagnose
3. **Requires Manual Intervention**: Recovery requires coordinated validator upgrades or governance action to roll back the config
4. **Breaks Consensus Invariant**: Violates the requirement that all honest validators produce identical behavior for identical inputs

The vulnerability specifically causes different `consensus_data_hash` values in `LedgerInfo` objects that validators must sign, fundamentally breaking the ability to form a quorum certificate.

## Likelihood Explanation

**Medium Likelihood** during operational windows:

**Triggering Conditions:**
- Rolling upgrade in progress with mixed validator versions (standard practice)
- Governance proposal updates `OnChainConsensusConfig` to newer variant (V5)
- No coordination between upgrade completion and config update timing

**Realistic Scenario:**
1. Validators begin rolling upgrade from version supporting V1-V4 to version supporting V1-V5
2. During upgrade window (50% upgraded, 50% not), governance proposal passes updating config to V5
3. At next epoch boundary, divergence occurs silently

**No Code-Level Protection:**
- Framework validation only checks non-empty bytes
- No minimum version requirements enforced
- No validator capability checks before applying configs
- Relies entirely on operational coordination (not enforced in code)

**Mitigating Factors:**
- Requires operational timing error (config update during incomplete upgrade)
- Aptos governance reviews proposals, but no technical enforcement
- Compatibility tests exist but don't validate config version mismatches during rolling upgrades

## Recommendation

**Implement Version Compatibility Validation:**

1. **Add Config Version Metadata**: Extend `OnChainConsensusConfig` variants to include a `min_validator_version` field that specifies the minimum software version required to deserialize the config.

2. **Validator Version Tracking**: Maintain on-chain registry of active validator software versions, updated during epoch transitions.

3. **Pre-Application Validation**: In `consensus_config::set_for_next_epoch()`, validate that all active validators report versions >= the config's `min_validator_version` before accepting the proposal.

4. **Fail-Safe Rejection**: If deserialization fails, validators should halt with clear error rather than silently falling back to defaults.

5. **Migration Path**: For V5 configs, add a two-phase deployment:
   - Phase 1: All validators upgrade software to support V5 deserialization
   - Phase 2: Governance proposal updates on-chain config to V5

**Alternative Short-Term Fix:**
Add explicit version compatibility checks in `EpochManager::start_new_epoch()` that compare the deserialized config variant against known supported variants, halting with a clear error if unsupported.

## Proof of Concept

The vulnerability can be demonstrated through the following test scenario:

```rust
// Simulated test showing divergence
#[test]
fn test_config_version_divergence() {
    // Validator A: Supports V1-V5
    let config_v5 = OnChainConsensusConfig::V5 {
        alg: ConsensusAlgorithmConfig::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: true,  // Key difference
        },
        vtxn: ValidatorTxnConfig::default_for_genesis(),
        window_size: DEFAULT_WINDOW_SIZE,
        rand_check_enabled: true,
    };
    
    // Validator B: Only supports V1-V4, deserialization fails
    // Falls back to Default which returns V4 with order_vote_enabled: false
    let config_v4_default = OnChainConsensusConfig::default();
    
    // Both validators attempt to create commit ledger info
    let ordered_proof = /* ... */;
    let commit_info = /* ... */;
    
    let ledger_info_a = generate_commit_ledger_info(
        &commit_info, 
        &ordered_proof, 
        true  // order_vote_enabled from V5
    );
    
    let ledger_info_b = generate_commit_ledger_info(
        &commit_info, 
        &ordered_proof, 
        false  // order_vote_enabled from V4 default
    );
    
    // Critical: Different hashes prevent signature aggregation
    assert_ne!(ledger_info_a.hash(), ledger_info_b.hash());
    // Network cannot form quorum - liveness failure
}
```

The key validation points are in the cited code sections showing how `order_vote_enabled` directly affects the `consensus_data_hash` field in `LedgerInfo` construction, making it impossible for validators with different configs to aggregate signatures.

## Notes

**Operational vs. Technical Safeguards**: While Aptos likely has operational procedures to coordinate upgrades with config updates, the vulnerability exists at the code level. The threat model considers scenarios where operational coordination fails (human error, timing issues, emergency upgrades).

**Distinction from Network DoS**: This is not a network DoS attack but a protocol-level liveness failure caused by legitimate governance actions during incomplete upgrades. The vulnerability is in the lack of version enforcement, not in the networking layer.

**Recovery Path**: Recovery would require either: (1) rolling back the on-chain config via emergency governance proposal, or (2) fast-tracking validator upgrades to achieve consistency. Both require manual coordination and network downtime.

### Citations

**File:** consensus/src/epoch_manager.rs (L1178-1201)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L46-52)
```rust
    pub fn default_if_missing() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: false,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L25-38)
```rust
fn generate_commit_ledger_info(
    commit_info: &BlockInfo,
    ordered_proof: &LedgerInfoWithSignatures,
    order_vote_enabled: bool,
) -> LedgerInfo {
    LedgerInfo::new(
        commit_info.clone(),
        if order_vote_enabled {
            HashValue::zero()
        } else {
            ordered_proof.ledger_info().consensus_data_hash()
        },
    )
}
```

**File:** consensus/src/pipeline/buffer_item.rs (L159-171)
```rust
                    let commit_ledger_info = generate_commit_ledger_info(
                        &commit_info,
                        &ordered_proof,
                        order_vote_enabled,
                    );

                    let mut partial_commit_proof =
                        create_signature_aggregator(unverified_votes, &commit_ledger_info);
                    if let Ok(commit_proof) = partial_commit_proof
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```
