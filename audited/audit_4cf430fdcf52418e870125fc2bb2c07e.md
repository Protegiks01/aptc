# Audit Report

## Title
Division by Zero in Proposer Election Causes Network-Wide Consensus Halt via Empty Validator Set

## Summary
A governance proposal can increase the minimum stake requirement to a value higher than all current validators' stakes, causing all validators to be removed during the next epoch transition. This results in an empty validator set that triggers a division-by-zero panic in `RotatingProposer::get_valid_proposer()`, completely halting the network with no recovery path except a hard fork.

## Finding Description

The vulnerability exists across multiple layers of the Aptos codebase with no validation to prevent an empty validator set:

**1. Division by Zero in Proposer Election:**
The `get_valid_proposer()` function performs modulo division without checking if the proposers list is empty. [1](#0-0) 

**2. No Validation in Constructor:**
`RotatingProposer::new()` accepts an empty proposers vector without validation. [2](#0-1) 

**3. Epoch Transition Vulnerability:**
The `on_new_epoch()` function in `stake.move` can produce an empty validator set when all validators fall below the minimum stake requirement. The critical loop filters out validators with insufficient stake but has NO assertion to ensure at least one validator remains. [3](#0-2) 

**4. Insufficient Stake Validation:**
The `update_required_stake()` function only validates that `minimum_stake <= maximum_stake` and `maximum_stake > 0`. There is NO check ensuring the new minimum stake doesn't exceed all current validators' stakes. [4](#0-3) 

**5. ValidatorVerifier Accepts Empty Sets:**
`ValidatorVerifier::new()` explicitly handles empty validator lists by setting quorum to 0, rather than rejecting them. [5](#0-4) 

**6. EpochManager Creates Proposer Without Validation:**
The `create_proposer_election()` function collects proposers from the verifier and passes them to `RotatingProposer::new()` without checking for emptiness. [6](#0-5) 

**Attack Path:**

1. Initial state: Network operates with N validators (e.g., 100 validators with 1M APT each)
2. Governance passes a proposal calling `staking_config::update_required_stake(aptos_framework, 100_000_000, 200_000_000)` - setting minimum stake to 100M APT
3. During next epoch transition, `stake::on_new_epoch()` executes:
   - Iterates through all validators
   - Each validator's `voting_power >= minimum_stake` check fails (1M < 100M)
   - `next_epoch_validators` remains empty
   - Sets `validator_set.active_validators = next_epoch_validators` (empty vector)
4. Empty `ValidatorSet` converts to empty `ValidatorVerifier`
5. `EpochManager::start_new_epoch()` creates `EpochState` with empty verifier
6. `create_proposer_election()` creates `RotatingProposer` with empty proposers list
7. When consensus calls `get_valid_proposer(round)`:
   - Executes `% self.proposers.len()` where `proposers.len() == 0`
   - **PANIC: division by zero**
   - All validator nodes crash
   - Network cannot produce blocks
   - No recovery without hard fork

This breaks the **Consensus Safety** invariant (network must maintain liveness) and the implicit invariant that at least one validator must always exist.

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple critical impact categories from the Aptos bug bounty:

1. **Non-recoverable network partition (requires hardfork)**: Once triggered, the network cannot recover through normal consensus mechanisms. Every validator node will panic when attempting to select a proposer, making block production impossible.

2. **Total loss of liveness/network availability**: The entire Aptos blockchain halts completely. No transactions can be processed, no blocks can be produced, and the network is effectively dead until a hard fork is deployed.

3. **Consensus violation**: Breaks the fundamental liveness guarantee that the network can always make progress.

The impact is catastrophic because:
- Affects 100% of validator nodes simultaneously
- No automatic recovery mechanism exists
- Requires coordinated hard fork to restore network
- All economic activity on the chain stops
- Users cannot access their funds until recovery

## Likelihood Explanation

**Medium-High Likelihood:**

**Factors increasing likelihood:**
1. **Democratic governance**: Any governance proposal can be submitted and voted on. A misconfigured or malicious proposal could be passed through legitimate channels.
2. **Human error**: Governance participants might not realize the consequences of setting minimum stake too high.
3. **Economic attacks**: An attacker could manipulate governance votes or exploit economic incentives to pass such a proposal.
4. **No warnings**: The system provides no warnings when setting stake requirements that exceed current validators' stakes.
5. **Only one check**: The `ELAST_VALIDATOR` check only protects against voluntary leaving via `leave_validator_set()`, not automatic removal via `on_new_epoch()`.

**Factors decreasing likelihood:**
1. Requires governance approval (though this is achievable)
2. Validators would likely notice and vote against obvious attacks
3. The effect is obvious and catastrophic (not a subtle exploit)

However, the severity is so extreme that even a moderate likelihood warrants immediate mitigation.

## Recommendation

Add validation at multiple layers to prevent empty validator sets:

**1. In stake.move `on_new_epoch()`:**
```move
// After line 1401
validator_set.active_validators = next_epoch_validators;
assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
validator_set.total_voting_power = total_voting_power;
```

**2. In staking_config.move `update_required_stake()`:**
```move
public fun update_required_stake(
    aptos_framework: &signer,
    minimum_stake: u64,
    maximum_stake: u64,
) acquires StakingConfig {
    system_addresses::assert_aptos_framework(aptos_framework);
    validate_required_stake(minimum_stake, maximum_stake);
    
    // NEW: Verify at least one active validator can meet new minimum
    let validator_set = borrow_global<ValidatorSet>(@aptos_framework);
    let can_meet_requirement = false;
    vector::for_each_ref(&validator_set.active_validators, |validator_info| {
        let stake_pool = borrow_global<StakePool>(validator_info.addr);
        if (stake_pool.active >= minimum_stake) {
            can_meet_requirement = true;
        }
    });
    assert!(can_meet_requirement, error::invalid_argument(EINVALID_STAKE_RANGE));
    
    let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
    staking_config.minimum_stake = minimum_stake;
    staking_config.maximum_stake = maximum_stake;
}
```

**3. In ValidatorVerifier::new() (defense in depth):**
```rust
pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
    assert!(!validator_infos.is_empty(), "ValidatorVerifier cannot be empty");
    let total_voting_power = sum_voting_power(&validator_infos);
    let quorum_voting_power = total_voting_power * 2 / 3 + 1;
    Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
}
```

**4. In RotatingProposer::new() (defense in depth):**
```rust
pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
    assert!(!proposers.is_empty(), "RotatingProposer requires at least one proposer");
    Self {
        proposers,
        contiguous_rounds,
    }
}
```

## Proof of Concept

```move
#[test_only]
module aptos_framework::stake_empty_validator_set_test {
    use aptos_framework::stake;
    use aptos_framework::staking_config;
    use std::vector;
    
    #[test(aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = 0x20006)] // ELAST_VALIDATOR if fix applied
    public fun test_empty_validator_set_via_high_minimum_stake(
        aptos_framework: &signer
    ) {
        // Setup: Create a validator set with validators having 1M APT each
        // (initialization code omitted for brevity)
        
        // Attack: Increase minimum stake to 100M APT (higher than all validators)
        staking_config::update_required_stake(aptos_framework, 100_000_000, 200_000_000);
        
        // Trigger epoch transition
        stake::on_new_epoch();
        
        // Verify: All validators were removed (validator set is empty)
        let validator_set = stake::get_validator_set();
        assert!(vector::length(&validator_set.active_validators) == 0, 1);
        
        // This would cause panic in RotatingProposer::get_valid_proposer()
        // when consensus attempts to select next proposer
    }
}
```

**Notes:**
- This vulnerability demonstrates a critical gap in epoch transition validation
- The `ELAST_VALIDATOR` error code exists but only protects voluntary exits, not automatic removals
- The system explicitly supports empty validator sets at multiple layers (ValidatorVerifier::new, EpochState::empty), suggesting this scenario was considered but not properly guarded against in the critical `on_new_epoch()` path

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L27-32)
```rust
    pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
        Self {
            proposers,
            contiguous_rounds,
        }
    }
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1402)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
        validator_set.total_voting_power = total_voting_power;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** consensus/src/epoch_manager.rs (L292-299)
```rust
        let proposers = epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .collect::<Vec<_>>();
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
            },
```
