# Audit Report

## Title
Peer Monitoring Service Exposes Internal Error Details to Untrusted Peers

## Summary
The peer-monitoring-service server's error handling converts internal errors to strings using `.to_string()` and sends them to untrusted network peers, potentially leaking sensitive information including file system paths, internal network addresses, validator identities, and implementation details.

## Finding Description

The peer-monitoring-service error handling chain uses an unsafe pattern that preserves and transmits all internal error details to untrusted peers: [1](#0-0) 

Network errors are converted to strings, preserving all internal details. These errors can originate from `PeerManagerError` which contains sensitive data: [2](#0-1) 

The `PeerManagerError::AlreadyConnected` variant includes a `NetworkAddress` that contains internal IP addresses, ports, DNS names, and cryptographic public keys: [3](#0-2) [4](#0-3) 

Similarly, `PeerManagerError::NotConnected` exposes validator identities via `PeerId` (which is a type alias for `AccountAddress`).

Storage errors also leak internal details: [5](#0-4) [6](#0-5) 

Database IO errors can include file system paths: [7](#0-6) [8](#0-7) 

All internal errors are wrapped and sent to untrusted peers: [9](#0-8) 

These error responses are serialized and transmitted over the network: [10](#0-9) 

The `PeerMonitoringServiceError` type is serializable and contains the full error string: [11](#0-10) 

## Impact Explanation

This is a **Medium severity** information disclosure vulnerability per the Aptos bug bounty criteria. It leaks:

1. **Internal IP addresses and ports** - NetworkAddress formatting includes `/ip4/10.0.0.16/tcp/6180` style addresses
2. **Validator identities** - PeerId exposes which validators a node is connected to
3. **Cryptographic public keys** - NetworkAddress includes `/noise-ik/<pubkey>` information
4. **File system paths** - Storage IO errors may expose internal directory structures
5. **Network topology** - Connection errors reveal internal network architecture

This information aids attacker reconnaissance for more sophisticated attacks, including:
- Mapping the validator network topology
- Identifying specific validator nodes for targeted attacks
- Understanding internal infrastructure for social engineering
- Discovering software versions and configurations from error messages

While not directly causing fund loss or consensus violations, this violates defense-in-depth principles and the principle of least privilege for information disclosure.

## Likelihood Explanation

**High likelihood** - This vulnerability can be triggered through normal operations:

1. Storage errors occur during node startup, database corruption, or disk failures
2. Network errors occur during connection establishment or peer disconnections  
3. Any peer can send requests to the peer-monitoring-service and receive error responses
4. No special privileges or attack sophistication required

The `get_node_information()` handler actively queries storage, making storage errors a realistic trigger path for information leakage.

## Recommendation

Implement sanitized error messages for external responses while preserving detailed errors for internal logging:

```rust
// In peer-monitoring-service/server/src/lib.rs
match error {
    Error::InvalidRequest(error) => {
        Err(PeerMonitoringServiceError::InvalidRequest(error))
    },
    Error::StorageErrorEncountered(_) => {
        // Log detailed error internally
        error!(LogSchema::new(LogEntry::PeerMonitoringServiceError)
            .error(&error)
            .request(&request));
        // Return sanitized error to peer
        Err(PeerMonitoringServiceError::InternalError(
            "Storage error encountered".to_string()
        ))
    },
    Error::UnexpectedErrorEncountered(_) => {
        // Log detailed error internally  
        error!(LogSchema::new(LogEntry::PeerMonitoringServiceError)
            .error(&error)
            .request(&request));
        // Return sanitized error to peer
        Err(PeerMonitoringServiceError::InternalError(
            "Internal error encountered".to_string()
        ))
    },
}
```

Additionally, review all error conversion implementations to ensure sensitive data is not included in Display/Debug formatting for types that may be sent over the network.

## Proof of Concept

```rust
// Demonstration of information leakage via error messages
// This would be added as a test in peer-monitoring-service/server/src/tests.rs

#[tokio::test]
async fn test_error_message_information_disclosure() {
    // Setup: Create a peer monitoring server with a failing storage backend
    let mut mock_storage = MockStorageReader::new();
    
    // Configure storage to return an error with internal file path
    mock_storage
        .expect_get_highest_synced_epoch_and_version()
        .returning(|| {
            Err(Error::StorageErrorEncountered(
                "RocksDB IO Error: No such file or directory: /var/aptos/db/ledger.db".to_string()
            ))
        });
    
    // Create request handler
    let handler = Handler::new(
        BaseConfig::default(),
        Arc::new(mock_peers_and_metadata()),
        Instant::now(),
        mock_storage,
        TimeService::mock(),
    );
    
    // Send GetNodeInformation request
    let request = PeerMonitoringServiceRequest::GetNodeInformation;
    let response = handler.call(NetworkId::Validator, request);
    
    // Verify that error message contains internal file path
    match response {
        Err(PeerMonitoringServiceError::InternalError(msg)) => {
            // VULNERABILITY: Internal file path is exposed to untrusted peer
            assert!(msg.contains("/var/aptos/db/ledger.db"));
            println!("LEAKED: {}", msg);
        },
        _ => panic!("Expected InternalError"),
    }
}
```

## Notes

This vulnerability represents a pattern issue where internal implementation details are unnecessarily exposed to untrusted network peers. While the current code may not always trigger the most severe cases (NetworkAddress leakage), the unsafe error handling pattern means any future code changes that introduce network operations or different error paths could inadvertently leak highly sensitive information. The vulnerability violates information security principles and should be remediated by implementing proper error sanitization for all external-facing error responses.

### Citations

**File:** peer-monitoring-service/server/src/error.rs (L28-32)
```rust
impl From<aptos_network::application::error::Error> for Error {
    fn from(error: aptos_network::application::error::Error) -> Self {
        Error::UnexpectedErrorEncountered(error.to_string())
    }
}
```

**File:** network/framework/src/peer_manager/error.rs (L25-29)
```rust
    #[error("Not connected with Peer {0}")]
    NotConnected(PeerId),

    #[error("Already connected at {0}")]
    AlreadyConnected(NetworkAddress),
```

**File:** types/src/network_address/mod.rs (L111-127)
```rust
#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub enum Protocol {
    Ip4(Ipv4Addr),
    Ip6(Ipv6Addr),
    Dns(DnsName),
    Dns4(DnsName),
    Dns6(DnsName),
    Tcp(u16),
    Memory(u16),
    // human-readable x25519::PublicKey is lower-case hex encoded
    NoiseIK(x25519::PublicKey),
    // TODO(philiphayes): use actual handshake::MessagingProtocolVersion. we
    // probably need to move network wire into its own crate to avoid circular
    // dependency b/w network and types.
    Handshake(u8),
}
```

**File:** types/src/network_address/mod.rs (L598-618)
```rust
impl fmt::Display for Protocol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use self::Protocol::*;
        match self {
            Ip4(addr) => write!(f, "/ip4/{}", addr),
            Ip6(addr) => write!(f, "/ip6/{}", addr),
            Dns(domain) => write!(f, "/dns/{}", domain),
            Dns4(domain) => write!(f, "/dns4/{}", domain),
            Dns6(domain) => write!(f, "/dns6/{}", domain),
            Tcp(port) => write!(f, "/tcp/{}", port),
            Memory(port) => write!(f, "/memory/{}", port),
            NoiseIK(pubkey) => write!(
                f,
                "/noise-ik/{}",
                pubkey
                    .to_encoded_string()
                    .expect("ValidCryptoMaterialStringExt::to_encoded_string is infallible")
            ),
            Handshake(version) => write!(f, "/handshake/{}", version),
        }
    }
```

**File:** peer-monitoring-service/server/src/storage.rs (L36-41)
```rust
        let latest_ledger_info_with_sigs = self
            .storage
            .get_latest_ledger_info()
            .map_err(|err| Error::StorageErrorEncountered(err.to_string()))?;
        Ok(latest_ledger_info_with_sigs.ledger_info().clone())
    }
```

**File:** peer-monitoring-service/server/src/storage.rs (L56-63)
```rust
        let maybe_lowest_available_version = self
            .storage
            .get_first_txn_version()
            .map_err(|error| Error::StorageErrorEncountered(error.to_string()))?;
        maybe_lowest_available_version.ok_or_else(|| {
            Error::StorageErrorEncountered("get_first_txn_version() returned None!".into())
        })
    }
```

**File:** storage/storage-interface/src/errors.rs (L29-30)
```rust
    #[error("AptosDB IO Error: {0}")]
    IoError(String),
```

**File:** storage/storage-interface/src/errors.rs (L57-60)
```rust
impl From<std::io::Error> for AptosDbError {
    fn from(error: std::io::Error) -> Self {
        Self::IoError(format!("{}", error))
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L198-203)
```rust
                match error {
                    Error::InvalidRequest(error) => {
                        Err(PeerMonitoringServiceError::InvalidRequest(error))
                    },
                    error => Err(PeerMonitoringServiceError::InternalError(error.to_string())),
                }
```

**File:** peer-monitoring-service/server/src/network.rs (L106-112)
```rust
    pub fn send(self, response: Result<PeerMonitoringServiceResponse>) {
        let msg = PeerMonitoringServiceMessage::Response(response);
        let result = bcs::to_bytes(&msg)
            .map(Bytes::from)
            .map_err(RpcError::BcsError);
        let _ = self.response_tx.send(result);
    }
```

**File:** peer-monitoring-service/types/src/lib.rs (L26-32)
```rust
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
pub enum PeerMonitoringServiceError {
    #[error("Internal service error: {0}")]
    InternalError(String),
    #[error("Invalid service request: {0}")]
    InvalidRequest(String),
}
```
