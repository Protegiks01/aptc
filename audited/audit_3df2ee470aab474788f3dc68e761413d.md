# Audit Report

## Title
Missing Signature Validation in State Snapshot Backup Manifest Creation Allows Acceptance of Forged State Roots

## Summary
The `write_manifest()` function in the state snapshot backup process deserializes `LedgerInfoWithSignatures` but discards it without validating the cryptographic signatures. This allows a compromised backup service or MITM attacker to inject forged state roots into backup manifests, which can lead to state corruption when restored in certain modes. [1](#0-0) 

## Finding Description
During state snapshot backup creation, the backup CLI retrieves proof data from the backup service containing both `TransactionInfoWithProof` and `LedgerInfoWithSignatures`. The critical security flaw occurs when this data is deserialized: [2](#0-1) 

The `LedgerInfoWithSignatures` contains validator signatures that cryptographically attest to the validity of the ledger state. However, the code immediately discards this object (using `_`) without:
1. Validating the BLS aggregated signatures using `verify_signatures()`
2. Verifying the `TransactionInfoWithProof` against the `LedgerInfo` using `verify()`
3. Confirming the ledger info represents a state committed by a quorum of validators

The state root hash is extracted from the unverified `TransactionInfo` and written directly to the manifest. The unvalidated proof bytes are also persisted to storage.

**Attack Vector:**
A malicious backup service operator or MITM attacker on the backup service connection could:
1. Forge a `LedgerInfoWithSignatures` with invalid/missing signatures
2. Create a matching `TransactionInfoWithProof` with a manipulated state root
3. Serve this data to the backup CLI during backup creation
4. The backup CLI accepts it without validation and creates a manifest with the forged state root

During restore, the validation depends on the presence of epoch history:
- **With epoch history** (normal mode): Signatures ARE validated via `EpochHistory::verify_ledger_info()` [3](#0-2) 

- **Without epoch history** (debug mode with `skip_epoch_endings`): Signatures are NOT validated [4](#0-3) 

The signature validation is implemented and available: [5](#0-4) 

And epoch verification confirms signatures through the validator verifier: [6](#0-5) 

However, these validations are bypassed during backup creation, violating the defense-in-depth principle.

## Impact Explanation
**Severity: Medium to High**

This vulnerability breaks the **State Consistency** and **Cryptographic Correctness** invariants by allowing unverified state roots into the backup system.

**Critical Impact Scenarios:**
1. **State Corruption**: Nodes restored from malicious backups using `skip_epoch_endings` mode would have incorrect state (balances, validator sets, governance state)
2. **Consensus Divergence**: If validator nodes restore with different state roots, they will produce different state transitions, violating deterministic execution
3. **Network Partition**: Multiple validators restoring from different forged backups could create irreconcilable chain forks requiring manual intervention

**Medium Impact Scenarios:**
1. **Operational Risk**: Backup integrity cannot be cryptographically verified at creation time, requiring trust in the backup service
2. **Supply Chain Attack**: Compromised backup infrastructure could inject malicious state that remains undetected until restore time

While the `skip_epoch_endings` flag is marked for debugging, its existence creates a viable attack path. The Aptos bug bounty program explicitly lists "State inconsistencies requiring intervention" as Medium severity and "Consensus/Safety violations" as Critical severity.

## Likelihood Explanation
**Likelihood: Medium**

**Attack Prerequisites:**
1. Compromised backup service OR successful MITM on backup service HTTP connection
2. Backup creation using the vulnerable code path (all state snapshot backups)
3. Restore operation with `skip_epoch_endings` flag (debug/testing scenarios)

**Mitigating Factors:**
- Normal production restores with epoch history validation would catch forged signatures
- Backup service typically runs on trusted infrastructure (localhost or internal network)
- The attack requires compromise of operator-controlled infrastructure

**Aggravating Factors:**
- No cryptographic validation at backup creation time means corrupted/forged data can persist undetected
- Backups may be transferred between systems, extending the attack surface
- Debug flags in production code create exploitable paths
- The HTTP connection to backup service may not be authenticated/encrypted

The vulnerability represents a fundamental security architecture flaw: cryptographic signatures are available but not validated at a critical trust boundary.

## Recommendation

**Immediate Fix:** Add signature validation during backup manifest creation.

The `write_manifest()` function must:
1. Obtain or construct a `ValidatorVerifier` for the epoch
2. Call `verify_signatures()` on the `LedgerInfoWithSignatures`
3. Call `verify()` on the `TransactionInfoWithProof` against the `LedgerInfo`
4. Only proceed with manifest creation if validation succeeds

**Implementation approach:**
- Extend `StateSnapshotBackupController` to maintain epoch history or validator verifier
- Before using the state root hash, validate both the proof and signatures
- Return an error if validation fails, preventing creation of invalid backups

**Defense-in-depth improvements:**
- Use authenticated/encrypted connections between backup CLI and backup service
- Add checksum validation for backup artifacts
- Implement backup integrity verification as a separate audit step
- Remove or restrict the `skip_epoch_endings` flag in production deployments

## Proof of Concept

```rust
// Reproduction steps demonstrating the vulnerability:

// 1. Setup: Create a forged LedgerInfoWithSignatures with invalid signatures
use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
use aptos_types::aggregate_signature::AggregateSignature;
use aptos_types::block_info::BlockInfo;

let forged_ledger_info = LedgerInfo::new(
    BlockInfo::empty(),
    HashValue::zero(),
);

// Create LedgerInfoWithSignatures with EMPTY (invalid) signature
let forged_li_with_sigs = LedgerInfoWithSignatures::new(
    forged_ledger_info,
    AggregateSignature::empty(), // No valid signatures!
);

// 2. Create a matching TransactionInfoWithProof with fake state root
let fake_state_root = HashValue::random();
let fake_txn_info = TransactionInfo::new(
    HashValue::zero(),
    HashValue::zero(),
    HashValue::zero(),
    Some(fake_state_root), // Fake state root
    0,
    ExecutionStatus::Success,
);

let fake_proof = TransactionAccumulatorProof::new(vec![]);
let fake_txn_info_with_proof = TransactionInfoWithProof::new(
    fake_proof,
    fake_txn_info,
);

// 3. Serialize as the backup service would
let forged_proof_bytes = bcs::to_bytes(&(
    fake_txn_info_with_proof,
    forged_li_with_sigs,
)).unwrap();

// 4. The backup CLI's write_manifest() deserializes this:
let (txn_info, _): (TransactionInfoWithProof, LedgerInfoWithSignatures) = 
    bcs::from_bytes(&forged_proof_bytes).unwrap();

// 5. VULNERABILITY: It uses the fake state root without validation!
let manifest_root_hash = txn_info.transaction_info()
    .ensure_state_checkpoint_hash()
    .unwrap();

// Result: manifest_root_hash contains the forged fake_state_root
// The invalid LedgerInfoWithSignatures was never validated
assert_eq!(manifest_root_hash, fake_state_root);

// 6. During restore with skip_epoch_endings (no epoch_history),
// this forged state root would be accepted without signature validation
```

**Validation Test:**
To verify the fix works, add a test that:
1. Creates a backup service mock serving invalid signatures
2. Runs `StateSnapshotBackupController::write_manifest()`
3. Expects the function to return an error due to signature validation failure
4. Confirms no manifest is created with the forged data

## Notes

The vulnerability stems from a fundamental architectural flaw: treating the backup service as a trusted source without cryptographic validation. While the backup service typically runs on operator-controlled infrastructure, defense-in-depth principles require validation of cryptographic signatures at trust boundaries. The availability of validator signatures in `LedgerInfoWithSignatures` provides the necessary cryptographic proofâ€”it must be verified before accepting state roots into the backup system.

The restore-time validation (when epoch history is available) provides partial mitigation but does not eliminate the vulnerability, as the `skip_epoch_endings` code path exists and the lack of backup-time validation violates security best practices.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L454-468)
```rust
        let proof_bytes = self.client.get_state_root_proof(self.version()).await?;
        let (txn_info, _): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            bcs::from_bytes(&proof_bytes)?;

        let (proof_handle, mut proof_file) = self
            .storage
            .create_for_write(backup_handle, Self::proof_name())
            .await?;
        proof_file.write_all(&proof_bytes).await?;
        proof_file.shutdown().await?;

        let manifest = StateSnapshotBackup {
            epoch: self.epoch,
            version: self.version(),
            root_hash: txn_info.transaction_info().ensure_state_checkpoint_hash()?,
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```

**File:** types/src/epoch_state.rs (L41-50)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```
