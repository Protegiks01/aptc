# Audit Report

## Title
Information Disclosure: Internal Storage Structure Leaked Through Event API Error Messages

## Summary
The Event API's error handling at lines 173-179 in `api/src/events.rs` fails to sanitize error messages from the storage layer, exposing internal database structure details including transaction version numbers, event indices, sequence numbers, and database corruption detection logic to unauthenticated API users.

## Finding Description

The vulnerability exists in the error propagation chain from the storage layer to the API response: [1](#0-0) 

The error mapping uses `BasicErrorWith404::internal_with_code(err, ...)` which ultimately calls `AptosError::new_with_error_code`: [2](#0-1) 

The critical issue is at line 34 where `format!("{:#}", error)` is used. The `{:#}` format specifier for `anyhow::Error` prints the **entire error chain** including all context messages. This means storage layer errors with internal details are propagated unchanged to API users.

The storage layer generates errors containing sensitive internal information: [3](#0-2) 

This error message reveals:
- Internal sequence number validation logic
- Expected vs actual sequence numbers
- Database corruption detection mechanisms
- Whether events are pruned

Additional storage errors that leak internal details: [4](#0-3) [5](#0-4) 

The indexer implementation has similar issues: [6](#0-5) 

An attacker querying the events API with non-existent or invalid event keys will receive detailed error messages such as:
```
"Failed to find events by key 0x... 

Caused by:
    DB corruption: Sequence number not continuous. expected: 5, actual: 7"
```

or

```
"Failed to find events by key 0x...

Caused by:
    Event 3 of Txn 12345"
```

## Impact Explanation

This is a **Medium severity** information disclosure vulnerability per the Aptos bug bounty program. While it doesn't directly cause fund loss or consensus violations, it leaks significant internal implementation details:

1. **Transaction version numbers** - Reveals internal ledger versioning that could aid timing attacks
2. **Event indices within transactions** - Exposes database schema and indexing structure
3. **Sequence number validation logic** - Reveals database invariants and consistency checks
4. **Database corruption detection mechanisms** - Exposes internal health monitoring logic
5. **Pruning behavior** - Reveals storage management strategy

This information could assist attackers in:
- Crafting more sophisticated attacks against the storage layer
- Understanding database invariants to identify potential exploitation vectors
- Timing attacks based on transaction version information
- Reconnaissance for identifying database state and configuration

The severity is elevated to Medium because the leaked details expose core database implementation and could facilitate higher-severity attacks on the storage subsystem.

## Likelihood Explanation

**High likelihood** - This vulnerability is trivially exploitable by any API user:
1. No authentication required
2. Simple API calls trigger the issue
3. Errors occur naturally when querying non-existent events or invalid parameters
4. The vulnerability affects all Event API endpoints
5. Both main database and indexer code paths are affected

Any user can trigger this by simply querying events that don't exist or have been pruned, making this a persistent information leak affecting all deployments.

## Recommendation

Sanitize storage error messages before exposing them to API users. Replace detailed internal errors with generic user-facing messages:

```rust
fn list(
    &self,
    latest_ledger_info: LedgerInfo,
    accept_type: AcceptType,
    page: Page,
    event_key: EventKey,
) -> BasicResultWith404<Vec<VersionedEvent>> {
    let ledger_version = latest_ledger_info.version();
    let events = self
        .context
        .get_events(
            &event_key,
            page.start_option(),
            page.limit(&latest_ledger_info)?,
            ledger_version,
        )
        .map_err(|err| {
            // Log internal error details for debugging
            aptos_logger::error!("Failed to retrieve events: {:?}", err);
            
            // Return sanitized error to user
            BasicErrorWith404::internal_with_code(
                "Failed to retrieve events", // Generic message
                AptosErrorCode::InternalError,
                &latest_ledger_info,
            )
        })?;
    // ... rest of function
}
```

Alternatively, implement error sanitization in `AptosError::new_with_error_code` to strip internal context:

```rust
pub fn new_with_error_code<ErrorType: std::fmt::Display>(
    error: ErrorType,
    error_code: AptosErrorCode,
) -> AptosError {
    // Use {:#} for internal logging but sanitize for API response
    let internal_message = format!("{:#}", error);
    aptos_logger::debug!("Internal error: {}", internal_message);
    
    // Extract only the root cause without internal context
    let sanitized_message = format!("{}", error);
    
    Self {
        message: sanitized_message,
        error_code,
        vm_error_code: None,
    }
}
```

## Proof of Concept

To demonstrate this vulnerability:

1. Set up an Aptos node with the REST API enabled
2. Query a non-existent event by calling:
   ```
   GET /v1/accounts/0x1/events/999999
   ```
3. Observe the error response contains internal details like:
   - Transaction version numbers
   - Event indices
   - Sequence number mismatches
   - Database corruption detection messages

Example expected response revealing internal details:
```json
{
  "message": "Failed to find events by key 0x010000000000000000f423f\n\nCaused by:\n    Event 0 of Txn 54321",
  "error_code": "internal_error",
  "vm_error_code": null
}
```

The error message exposes that the storage attempted to retrieve event at index 0 from transaction version 54321, revealing internal transaction versioning and event indexing structure.

### Citations

**File:** api/src/events.rs (L171-178)
```rust
            .context(format!("Failed to find events by key {}", event_key))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &latest_ledger_info,
                )
            })?;
```

**File:** api/types/src/error.rs (L29-38)
```rust
    pub fn new_with_error_code<ErrorType: std::fmt::Display>(
        error: ErrorType,
        error_code: AptosErrorCode,
    ) -> AptosError {
        Self {
            message: format!("{:#}", error),
            error_code,
            vm_error_code: None,
        }
    }
```

**File:** storage/aptosdb/src/event_store/mod.rs (L47-50)
```rust
        self.event_db
            .get::<EventSchema>(&(version, index))?
            .ok_or_else(|| AptosDbError::NotFound(format!("Event {} of Txn {}", index, version)))
    }
```

**File:** storage/aptosdb/src/event_store/mod.rs (L130-137)
```rust
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                db_other_bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
            }
```

**File:** storage/aptosdb/src/event_store/mod.rs (L153-156)
```rust
            return Err(AptosDbError::NotFound(format!(
                "Event {} of seq num {}.",
                event_key, seq_num
            )));
```

**File:** storage/indexer/src/db_indexer.rs (L709-714)
```rust
                ensure!(
                    seq == v0.sequence_number(),
                    "Index broken, expected seq:{}, actual:{}",
                    seq,
                    v0.sequence_number()
                );
```
