# Audit Report

## Title
TOCTOU Race Condition in Fast Sync Pruner Progress Updates

## Summary
A Time-Of-Check-Time-Of-Use (TOCTOU) race condition exists in `FastSyncStorageWrapper.finalize_state_snapshot()` that could allow concurrent fast sync operations to write conflicting pruner progress metadata, potentially causing incorrect event pruning behavior.

## Finding Description

The vulnerability exists in the interaction between fast sync status checking and pruner progress updates: [1](#0-0) 

The function reads `fast_sync_status` without holding a lock, asserts it equals `STARTED`, then proceeds with the finalization. The write lock is only acquired AFTER the underlying `finalize_state_snapshot()` completes. This creates a race window where:

1. Thread A reads status (STARTED) and passes assertion
2. Thread B reads status (STARTED) and passes assertion  
3. Both threads proceed to call the underlying finalization
4. Both call `save_min_readable_version()` which eventually invokes `EventDb.write_pruner_progress()` [2](#0-1) 

This method directly calls `self.db.put()` without any synchronization. While each individual `put()` operation is atomic (RocksDB WriteBatch), there's no ordering guarantee across concurrent calls from different threads. [3](#0-2) 

Multiple pruner managers have their progress updated sequentially within each finalization, but if two finalization operations run concurrently with different versions (e.g., version 100 and version 99), the final `EventPrunerProgress` value depends on which write completes last, potentially resulting in version 99 overwriting version 100.

## Impact Explanation

This qualifies as **Medium severity** per the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

If the race condition manifests with an older version overwriting a newer version in pruner progress metadata, the consequences include:
- Events that should be considered already-pruned may be re-pruned or skipped
- The pruner may retain more data than necessary or prune data it shouldn't
- State inconsistency between what the pruner believes is pruned and actual database state
- Potential need for manual intervention to correct pruner metadata

## Likelihood Explanation

**Likelihood: Low to Very Low**

While the race condition is real, triggering it requires:
1. Multiple concurrent calls to `initialize_state_synchronizer()` creating separate state sync operations
2. Both operations progressing to `finalize_state_snapshot()` simultaneously
3. The race window being hit during the TOCTOU gap

The state sync driver design appears to handle one sync operation at a time, and `StorageSynchronizer` methods take `&mut self`, suggesting exclusive access. However, the lack of enforcement at the storage layer means this is a defensive programming issue - the code should be more robust even if current usage patterns don't trigger the race.

## Recommendation

Hold the write lock for the entire duration of the finalization operation:

```rust
fn finalize_state_snapshot(
    &self,
    version: Version,
    output_with_proof: TransactionOutputListWithProofV2,
    ledger_infos: &[LedgerInfoWithSignatures],
) -> Result<()> {
    // Acquire write lock at the start and hold it throughout
    let mut status_guard = self.fast_sync_status.write();
    
    // Check status while holding lock
    if *status_guard != FastSyncStatus::STARTED {
        return Err(AptosDbError::Other(
            "Fast sync not in STARTED state".to_string()
        ).into());
    }
    
    // Perform finalization while holding lock
    self.get_aptos_db_write_ref().finalize_state_snapshot(
        version,
        output_with_proof,
        ledger_infos,
    )?;
    
    // Update status before releasing lock
    *status_guard = FastSyncStatus::FINISHED;
    Ok(())
}
```

Additionally, consider adding a mutex around `write_pruner_progress()` calls or using a compare-and-swap operation to ensure progress only moves forward.

## Proof of Concept

```rust
// Conceptual PoC - requires test framework modifications
#[tokio::test]
async fn test_concurrent_finalize_state_snapshot_race() {
    let wrapper = FastSyncStorageWrapper::new(...);
    
    // Initialize two state snapshot receivers
    let receiver1 = wrapper.get_state_snapshot_receiver(100, hash1).unwrap();
    let receiver2 = wrapper.get_state_snapshot_receiver(99, hash2).unwrap();
    
    // Simulate concurrent finalization
    let handle1 = tokio::spawn(async move {
        wrapper.finalize_state_snapshot(100, output1, ledger_infos1)
    });
    
    let handle2 = tokio::spawn(async move {
        wrapper.finalize_state_snapshot(99, output2, ledger_infos2)
    });
    
    // Both should complete, but pruner progress may be incorrect
    handle1.await.unwrap();
    handle2.await.unwrap();
    
    // Check if EventPrunerProgress reflects version 99 instead of 100
    let progress = get_event_pruner_progress();
    assert_eq!(progress, 100); // May fail if race occurred
}
```

**Notes**

This vulnerability requires concurrent fast sync operations to manifest. While the current state sync driver design suggests single-threaded operation, the lack of explicit synchronization at the storage layer represents a defensive programming gap. The TOCTOU bug in `FastSyncStorageWrapper` combined with unsynchronized writes in `EventDb.write_pruner_progress()` creates a potential race condition that, while unlikely to occur in normal operation, violates the state consistency invariant and could cause pruning inconsistencies if triggered.

### Citations

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L154-170)
```rust
    fn finalize_state_snapshot(
        &self,
        version: Version,
        output_with_proof: TransactionOutputListWithProofV2,
        ledger_infos: &[LedgerInfoWithSignatures],
    ) -> Result<()> {
        let status = self.get_fast_sync_status();
        assert_eq!(status, FastSyncStatus::STARTED);
        self.get_aptos_db_write_ref().finalize_state_snapshot(
            version,
            output_with_proof,
            ledger_infos,
        )?;
        let mut status = self.fast_sync_status.write();
        *status = FastSyncStatus::FINISHED;
        Ok(())
    }
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L47-52)
```rust
    pub(super) fn write_pruner_progress(&self, version: Version) -> Result<()> {
        self.db.put::<DbMetadataSchema>(
            &DbMetadataKey::EventPrunerProgress,
            &DbMetadataValue::Version(version),
        )
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L225-234)
```rust
            self.ledger_pruner.save_min_readable_version(version)?;
            self.state_store
                .state_merkle_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .epoch_snapshot_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .state_kv_pruner
                .save_min_readable_version(version)?;
```
