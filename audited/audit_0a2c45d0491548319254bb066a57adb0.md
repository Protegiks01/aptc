# Audit Report

## Title
Dangerous Default Auth Key Inheritance in Resource Account Creation Enables Unauthorized Access via Compromised Origin Keys

## Summary
The `create_resource_account` function contains a critical design flaw in its authentication key selection logic. When `optional_auth_key` is empty, the resource account inherits the origin account's current authentication key instead of using `ZERO_AUTH_KEY`. This violates the resource account security model and enables attackers who have compromised the origin's authentication key to gain unauthorized control over resource accounts, potentially leading to fund theft and smart contract manipulation. [1](#0-0) 

## Finding Description

The authentication key selection logic in `rotate_account_authentication_key_and_store_capability` creates a dangerous default behavior that compromises resource account security. [2](#0-1) 

**The Vulnerability:**

When developers create a resource account using the CLI or programmatically without explicitly providing an authentication key, the Rust implementation passes an empty vector: [3](#0-2) 

The Move code then checks if this vector is empty and, if so, fetches the origin account's **current** authentication key and assigns it to the resource account. This directly violates the security principle established in the account module that resource accounts should only be controlled via `SignerCapability`: [4](#0-3) 

**Attack Scenario:**

1. Attacker compromises the origin account's authentication key through phishing, malware, or leaked credentials
2. Victim creates a resource account for a DeFi protocol, liquidity pool, or NFT project using the default CLI command: `aptos account create-resource-account --seed "my-protocol"`
3. Since no `--authentication-key` parameter is provided, the resource account inherits the compromised origin auth key
4. The attacker can now sign transactions directly as the resource account, bypassing the intended `SignerCapability`-based access control
5. Even though the `SignerCapability` is securely stored in the origin's `Container`, the attacker has direct authentication key access
6. The attack persists until `retrieve_resource_account_cap` is called (which rotates to `ZERO_AUTH_KEY`), creating a vulnerability window [5](#0-4) 

**Invariant Violation:**

This breaks the **Access Control invariant** (#8) that resource accounts should be isolated from direct key-based control. The `account::create_resource_account` function explicitly sets `ZERO_AUTH_KEY` for this reason, but the higher-level wrapper immediately overrides this security measure.

**Inconsistency with Safer Alternative:**

The `create_resource_account_and_publish_package` function correctly uses `ZERO_AUTH_KEY`, demonstrating awareness of the secure pattern: [6](#0-5) 

## Impact Explanation

**Severity: HIGH** (meets criteria for $50,000 bounty category)

This vulnerability enables:

1. **Unauthorized Access**: Attackers with compromised origin keys gain full control over resource accounts
2. **Fund Theft**: Resource accounts holding APT, tokens, or NFTs can be drained
3. **Smart Contract Manipulation**: Attackers can manipulate DeFi protocols, liquidity pools, and other smart contracts
4. **Protocol Violations**: Breaks the fundamental resource account security model
5. **Widespread Impact**: Affects any developer using the default CLI behavior or following the documented pattern with empty auth keys

The issue qualifies as **"Significant protocol violations"** under the High Severity category because it systematically undermines the resource account access control model across the entire framework.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability has a high probability of exploitation due to:

1. **Common Attack Vector**: Authentication key compromise via phishing, malware, and leaked credentials is a frequent real-world threat
2. **Default Behavior**: The CLI defaults to empty auth key when no parameter is provided, making this the common usage pattern
3. **Developer Confusion**: Many developers will not understand the nuanced difference between empty auth key (inherits origin's key) vs. providing `ZERO_AUTH_KEY` explicitly
4. **Documentation Ambiguity**: The documentation explains the behavior but doesn't emphasize the security implications of using empty auth keys
5. **Delayed Protection**: The vulnerability window exists from resource account creation until `retrieve_resource_account_cap` is called, which may be minutes, hours, or never [7](#0-6) 

## Recommendation

**Immediate Fix**: Change the default behavior to use `ZERO_AUTH_KEY` when `optional_auth_key` is empty, making it consistent with `create_resource_account_and_publish_package`:

```move
fun rotate_account_authentication_key_and_store_capability(
    origin: &signer,
    resource: signer,
    resource_signer_cap: account::SignerCapability,
    optional_auth_key: vector<u8>
) acquires Container {
    let origin_addr = signer::address_of(origin);
    if (!exists<Container>(origin_addr)) {
        move_to(origin, Container { store: simple_map::create() })
    };

    let container = borrow_global_mut<Container>(origin_addr);
    let resource_addr = signer::address_of(&resource);
    simple_map::add(&mut container.store, resource_addr, resource_signer_cap);

    // FIXED: Default to ZERO_AUTH_KEY for security instead of origin's auth key
    let auth_key =
        if (vector::is_empty(&optional_auth_key)) {
            ZERO_AUTH_KEY  // Changed from: account::get_authentication_key(origin_addr)
        } else {
            optional_auth_key
        };
    account::rotate_authentication_key_internal(&resource, auth_key);
}
```

**Alternative**: If the current behavior is intentional for the documented workflow, add explicit validation requiring developers to opt-in to using origin's auth key:

```move
// Require explicit non-empty auth key to inherit origin's key
assert!(
    !vector::is_empty(&optional_auth_key),
    error::invalid_argument(EMUST_PROVIDE_AUTH_KEY)
);
```

**Documentation Update**: Clearly warn developers about the security implications in both code comments and external documentation.

## Proof of Concept

```move
#[test_only]
module test_addr::resource_account_auth_key_exploit {
    use std::signer;
    use std::vector;
    use aptos_framework::account;
    use aptos_framework::resource_account;

    #[test(attacker = @0x1234, victim = @0x5678)]
    fun test_compromised_origin_key_exploits_resource_account(
        attacker: signer,
        victim: signer
    ) {
        // Setup: Create victim's account
        let victim_addr = signer::address_of(&victim);
        account::create_account(victim_addr);
        
        // Attacker compromises victim's auth key (simulated by knowing it)
        let victim_auth_key = account::get_authentication_key(victim_addr);
        
        // Victim creates resource account with empty auth key (common mistake)
        let seed = b"my-defi-protocol";
        resource_account::create_resource_account(
            &victim,
            seed,
            vector::empty<u8>()  // Empty - will inherit victim's auth key!
        );
        
        // Calculate resource account address
        let resource_addr = account::create_resource_address(&victim_addr, seed);
        
        // VULNERABILITY: Resource account now has victim's auth key
        let resource_auth_key = account::get_authentication_key(resource_addr);
        assert!(resource_auth_key == victim_auth_key, 1);
        
        // Attacker can now sign transactions as the resource account
        // using the compromised victim auth key, bypassing SignerCapability
        // (In real attack: attacker would use this to drain funds, manipulate state, etc.)
    }
}
```

## Notes

The vulnerability is particularly dangerous because:

1. **Hidden Dependency**: Developers may not realize their resource account security is tied to their origin account's authentication key security
2. **Long Vulnerability Window**: The issue persists until `retrieve_resource_account_cap` is explicitly called, which may be delayed or forgotten
3. **Inconsistent API**: The safer `create_resource_account_and_publish_package` uses `ZERO_AUTH_KEY`, but `create_resource_account` does not, creating API inconsistency
4. **Violates Principle of Least Privilege**: Resource accounts should have minimal authentication surface by default, not inherit additional authentication methods

This represents a systemic design flaw affecting the entire resource account security model in the Aptos Framework.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/resource_account.move (L8-16)
```text
///  1. Create a new account using `resource_account::create_resource_account`. This creates the
///     account, stores the `signer_cap` within a `resource_account::Container`, and rotates the key to
///     the current account's authentication key or a provided authentication key.
///  2. Define the liquidity pool module's address to be the same as the resource account.
///  3. Construct a package-publishing transaction for the resource account using the
///     authentication key used in step 1.
///  4. In the liquidity pool module's `init_module` function, call `retrieve_resource_account_cap`
///     which will retrieve the `signer_cap` and rotate the resource account's authentication key to
///     `0x0`, effectively locking it off.
```

**File:** aptos-move/framework/aptos-framework/sources/resource_account.move (L122-139)
```text
    /// Creates a new resource account, publishes the package under this account transaction under
    /// this account and leaves the signer cap readily available for pickup.
    public entry fun create_resource_account_and_publish_package(
        origin: &signer,
        seed: vector<u8>,
        metadata_serialized: vector<u8>,
        code: vector<vector<u8>>
    ) acquires Container {
        let (resource, resource_signer_cap) =
            account::create_resource_account(origin, seed);
        aptos_framework::code::publish_package_txn(&resource, metadata_serialized, code);
        rotate_account_authentication_key_and_store_capability(
            origin,
            resource,
            resource_signer_cap,
            ZERO_AUTH_KEY
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/resource_account.move (L141-163)
```text
    fun rotate_account_authentication_key_and_store_capability(
        origin: &signer,
        resource: signer,
        resource_signer_cap: account::SignerCapability,
        optional_auth_key: vector<u8>
    ) acquires Container {
        let origin_addr = signer::address_of(origin);
        if (!exists<Container>(origin_addr)) {
            move_to(origin, Container { store: simple_map::create() })
        };

        let container = borrow_global_mut<Container>(origin_addr);
        let resource_addr = signer::address_of(&resource);
        simple_map::add(&mut container.store, resource_addr, resource_signer_cap);

        let auth_key =
            if (vector::is_empty(&optional_auth_key)) {
                account::get_authentication_key(origin_addr)
            } else {
                optional_auth_key
            };
        account::rotate_authentication_key_internal(&resource, auth_key);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/resource_account.move (L168-196)
```text
    public fun retrieve_resource_account_cap(
        resource: &signer, source_addr: address
    ): account::SignerCapability acquires Container {
        assert!(
            exists<Container>(source_addr),
            error::not_found(ECONTAINER_NOT_PUBLISHED)
        );

        let resource_addr = signer::address_of(resource);
        let (resource_signer_cap, empty_container) = {
            let container = borrow_global_mut<Container>(source_addr);
            assert!(
                simple_map::contains_key(&container.store, &resource_addr),
                error::invalid_argument(EUNAUTHORIZED_NOT_OWNER)
            );
            let (_resource_addr, signer_cap) =
                simple_map::remove(&mut container.store, &resource_addr);
            (signer_cap, simple_map::length(&container.store) == 0)
        };

        if (empty_container) {
            let container = move_from<Container>(source_addr);
            let Container { store } = container;
            simple_map::destroy_empty(store);
        };

        account::rotate_authentication_key_internal(resource, ZERO_AUTH_KEY);
        resource_signer_cap
    }
```

**File:** crates/aptos/src/account/create_resource_account.rs (L77-90)
```rust
    async fn execute(self) -> CliTypedResult<CreateResourceAccountSummary> {
        let authentication_key: Vec<u8> = if let Some(key) = self.authentication_key {
            bcs::to_bytes(&key)?
        } else {
            vec![]
        };
        self.txn_options
            .submit_transaction(resource_account_create_resource_account(
                self.seed_args.seed()?,
                authentication_key,
            ))
            .await
            .map(CreateResourceAccountSummary::from)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1144-1147)
```text
        // By default, only the SignerCapability should have control over the resource account and not the auth key.
        // If the source account wants direct control via auth key, they would need to explicitly rotate the auth key
        // of the resource account using the SignerCapability.
        rotate_authentication_key_internal(&resource, ZERO_AUTH_KEY);
```
