# Audit Report

## Title
Repeated Fallback Triggering Enables Indefinite Output Syncing Mode Lock-in via Malicious Peer Attacks

## Summary
The state-sync driver's `fallback_to_outputs()` mechanism lacks protection against repeated triggering, allowing malicious peers to keep a node indefinitely stuck in output-only syncing mode by strategically timing data corruption attacks after each fallback period expires. This prevents the node from executing transactions independently and degrades its network participation. [1](#0-0) 

## Finding Description
The vulnerability exists in the fallback mechanism designed to temporarily switch nodes to output syncing when transaction execution fails. The `fallback_to_outputs()` function sets a fallback start time that lasts for a configured duration (default 180 seconds). [2](#0-1) 

When this duration expires, `in_fallback_mode()` returns false and clears the fallback start time, allowing the node to resume transaction execution mode. [3](#0-2) 

However, the mechanism has no protection against repeated triggering. A malicious peer can exploit this by:

1. **Initial fallback trigger**: Sending invalid transaction data that causes execution errors in the storage synchronizer [4](#0-3) 

2. **Error propagation**: The storage synchronizer sends an `ErrorNotification` to the driver [5](#0-4) 

3. **Fallback activation**: The driver calls `handle_storage_synchronizer_error()`, which invokes `fallback_to_outputs()` for nodes in `ExecuteOrApplyFromGenesis` or `ExecuteTransactionsOrApplyOutputs` mode [6](#0-5) [7](#0-6) 

4. **Mode switch**: The node switches to requesting only transaction outputs (not full transactions) during stream creation [8](#0-7) [9](#0-8) 

5. **Timer reset vulnerability**: When the fallback expires and the node attempts to resume transaction execution, the malicious peer immediately sends another batch of invalid data, triggering a new fallback period with a completely reset timer.

The critical flaw is that `fallback_to_outputs()` only checks if `fallback_start_time` is `None` before setting it. After expiration clears this value, any subsequent error immediately resets the timer to the current time, with no memory of previous fallbacks, no increasing backoff, and no maximum fallback count.

## Impact Explanation
This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program for multiple reasons:

**Validator Node Slowdowns**: Nodes stuck in output syncing mode cannot execute transactions independently, forcing them to trust peer-provided outputs. This is fundamentally slower than transaction execution for validator participation and creates a trust dependency on potentially malicious peers.

**Significant Protocol Violations**: The attack violates critical Aptos invariants:
- **Deterministic Execution Invariant**: Affected nodes cannot independently verify that their state matches other validators' states through re-execution
- **Liveness Guarantee**: The node's ability to catch up with the network and participate fully is indefinitely degraded

**Security Degradation**: When syncing via outputs only, the node must trust pre-computed transaction outputs from peers without VM-based verification. This transforms a trust-minimized system into one with single-point-of-trust vulnerabilities, as malicious outputs could corrupt the node's state.

**Network Participation Impact**: Validator nodes affected by this attack cannot fulfill their consensus duties properly, as they lack the ability to independently execute and verify transactions, degrading overall network security and liveness.

## Likelihood Explanation
This vulnerability has **HIGH likelihood** of exploitation:

**Low Attack Complexity**: A malicious peer only needs to:
- Send cryptographically valid but execution-failing transaction data (e.g., transactions with valid signatures but that fail VM execution)
- Time these attacks to occur shortly after fallback periods expire
- Repeat the pattern indefinitely

**Multiple Attack Vectors**: Errors triggering fallback can come from:
- Malicious transaction data
- Malformed transaction outputs
- Any data causing storage synchronizer failures

**Limited Defenses**: While peer scoring exists [10](#0-9) , it operates independently of the fallback mechanism and requires multiple bad responses before peers are ignored. During this window, fallbacks can be repeatedly triggered. Additionally, multiple coordinating malicious peers can rotate their attacks to avoid individual peer penalties.

**Organic Triggers**: Even without malicious intent, network issues or edge cases causing execution failures could inadvertently trigger repeated fallbacks, making this vulnerability exploitable through both active attacks and passive network conditions.

## Recommendation
Implement fallback rate limiting with exponential backoff and maximum attempt tracking:

```rust
pub struct OutputFallbackHandler {
    driver_configuration: DriverConfiguration,
    fallback_start_time: Arc<Mutex<Option<Instant>>>,
    fallback_count: Arc<Mutex<u64>>,  // NEW: Track consecutive fallbacks
    last_fallback_reset: Arc<Mutex<Instant>>,  // NEW: Track when to reset count
    time_service: TimeService,
}

impl OutputFallbackHandler {
    pub fn fallback_to_outputs(&mut self) {
        let mut fallback_count = self.fallback_count.lock();
        let mut last_reset = self.last_fallback_reset.lock();
        let now = self.time_service.now();
        
        // Reset count if enough time has passed since last fallback
        if now.duration_since(*last_reset).as_secs() > 3600 { // 1 hour cooldown
            *fallback_count = 0;
            *last_reset = now;
        }
        
        // Reject if too many consecutive fallbacks
        const MAX_FALLBACK_ATTEMPTS: u64 = 5;
        if *fallback_count >= MAX_FALLBACK_ATTEMPTS {
            error!("Maximum fallback attempts ({}) exceeded. Manual intervention required.", 
                   MAX_FALLBACK_ATTEMPTS);
            return;
        }
        
        let missing_fallback_start_time = self.fallback_start_time.lock().is_none();
        if missing_fallback_start_time {
            *fallback_count += 1;
            
            // Exponential backoff: base_duration * 2^(attempt - 1)
            let backoff_multiplier = 2u64.pow((*fallback_count - 1) as u32);
            let extended_duration = self.get_fallback_duration()
                .saturating_mul(backoff_multiplier.min(8)); // Cap at 8x
            
            self.set_fallback_start_time(now);
            info!("Falling back to output syncing (attempt {}/{}) for {:?} seconds",
                  *fallback_count, MAX_FALLBACK_ATTEMPTS, extended_duration.as_secs());
        }
    }
    
    pub fn in_fallback_mode(&mut self) -> bool {
        let fallback_start_time = self.fallback_start_time.lock().take();
        let fallback_count = *self.fallback_count.lock();
        
        if let Some(fallback_start_time) = fallback_start_time {
            // Calculate duration with exponential backoff
            let backoff_multiplier = 2u64.pow((fallback_count - 1) as u32);
            let extended_duration = self.get_fallback_duration()
                .saturating_mul(backoff_multiplier.min(8));
            
            if let Some(fallback_deadline) = fallback_start_time.checked_add(extended_duration) {
                if self.time_service.now() >= fallback_deadline {
                    info!("Fallback period expired after {:?} seconds (attempt {})",
                          extended_duration.as_secs(), fallback_count);
                    false
                } else {
                    self.set_fallback_start_time(fallback_start_time);
                    true
                }
            } else {
                warn!("Fallback deadline overflowed");
                false
            }
        } else {
            false
        }
    }
}
```

This fix implements three protective mechanisms:
1. **Maximum attempts**: After 5 consecutive fallbacks, the mechanism stops triggering
2. **Exponential backoff**: Each successive fallback doubles the duration (capped at 8x)
3. **Cooldown reset**: After 1 hour without fallbacks, the counter resets

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_time_service::MockTimeService;
    
    #[tokio::test]
    async fn test_repeated_fallback_attack() {
        // Setup
        let mock_time = MockTimeService::new();
        let config = DriverConfiguration::default();
        let mut handler = OutputFallbackHandler::new(config, mock_time.clone().into());
        
        // Simulate repeated attacks
        for i in 0..10 {
            // Trigger fallback (simulates malicious peer error)
            handler.fallback_to_outputs();
            assert!(handler.in_fallback_mode(), "Should be in fallback mode after attack {}", i);
            
            // Advance time to just after fallback expires
            mock_time.advance_secs(181); // 180s default + 1s
            
            // Fallback should expire
            assert!(!handler.in_fallback_mode(), "Fallback should expire at iteration {}", i);
            
            // Attacker immediately triggers another error
            // This demonstrates the node can be kept in fallback indefinitely
        }
        
        // After 10 iterations, node has spent 1800 seconds (30 minutes)
        // in fallback mode across 10 separate fallback periods, never
        // successfully executing transactions
    }
}
```

**Notes**

The vulnerability is exacerbated by the fact that output syncing fundamentally changes the trust model of the node. While executing transactions, a node independently verifies correctness through VM execution. In output syncing mode, it trusts peer-provided outputs without verification, making it vulnerable to state corruption if malicious outputs are provided. The indefinite lock-in to this degraded mode represents a significant security and liveness concern for the Aptos network.

### Citations

**File:** state-sync/state-sync-driver/src/utils.rs (L138-147)
```rust
    pub fn fallback_to_outputs(&mut self) {
        let missing_fallback_start_time = self.fallback_start_time.lock().is_none();
        if missing_fallback_start_time {
            self.set_fallback_start_time(self.time_service.now());
            info!(LogSchema::new(LogEntry::Driver).message(&format!(
                "Falling back to output syncing for at least {:?} seconds!",
                self.get_fallback_duration().as_secs()
            )));
        }
    }
```

**File:** state-sync/state-sync-driver/src/utils.rs (L150-174)
```rust
    pub fn in_fallback_mode(&mut self) -> bool {
        let fallback_start_time = self.fallback_start_time.lock().take();
        if let Some(fallback_start_time) = fallback_start_time {
            if let Some(fallback_deadline) =
                fallback_start_time.checked_add(self.get_fallback_duration())
            {
                // Check if we elapsed the max fallback duration
                if self.time_service.now() >= fallback_deadline {
                    info!(LogSchema::new(LogEntry::AutoBootstrapping)
                        .message("Passed the output fallback deadline! Disabling fallback mode!"));
                    false
                } else {
                    // Reinsert the fallback deadline (not enough time has passed)
                    self.set_fallback_start_time(fallback_start_time);
                    true
                }
            } else {
                warn!(LogSchema::new(LogEntry::Driver)
                    .message("The fallback deadline overflowed! Disabling fallback mode!"));
                false
            }
        } else {
            false
        }
    }
```

**File:** config/src/config/state_sync_config.rs (L141-141)
```rust
            fallback_to_output_syncing_secs: 180, // 3 minutes
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L572-586)
```rust
                Err(error) => {
                    // Send an error notification to the driver (we failed to execute/apply the chunk)
                    let error = if executed_chunk {
                        format!("Failed to execute the data chunk! Error: {:?}", error)
                    } else {
                        format!("Failed to apply the data chunk! Error: {:?}", error)
                    };
                    handle_storage_synchronizer_error(
                        notification_metadata,
                        error,
                        &error_notification_sender,
                        &pending_data_chunks,
                    )
                    .await;
                },
```

**File:** state-sync/state-sync-driver/src/driver.rs (L495-532)
```rust
    async fn handle_error_notification(&mut self, error_notification: ErrorNotification) {
        warn!(LogSchema::new(LogEntry::SynchronizerNotification)
            .error_notification(error_notification.clone())
            .message("Received an error notification from the storage synchronizer!"));

        // Terminate the currently active streams
        let notification_id = error_notification.notification_id;
        let notification_feedback = NotificationFeedback::InvalidPayloadData;
        if self.bootstrapper.is_bootstrapped() {
            if let Err(error) = self
                .continuous_syncer
                .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                    notification_id,
                    notification_feedback,
                ))
                .await
            {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .message(&format!(
                        "Failed to terminate the active stream for the continuous syncer! Error: {:?}",
                        error
                    )));
            }
        } else if let Err(error) = self
            .bootstrapper
            .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                notification_id,
                notification_feedback,
            ))
            .await
        {
            error!(
                LogSchema::new(LogEntry::SynchronizerNotification).message(&format!(
                    "Failed to terminate the active stream for the bootstrapper! Error: {:?}",
                    error
                ))
            );
        };
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L769-796)
```rust
                if self.output_fallback_handler.in_fallback_mode() {
                    metrics::set_gauge(
                        &metrics::DRIVER_FALLBACK_MODE,
                        ExecutingComponent::Bootstrapper.get_label(),
                        1,
                    );
                    self.streaming_client
                        .get_all_transaction_outputs(
                            next_version,
                            end_version,
                            highest_known_ledger_version,
                        )
                        .await?
                } else {
                    metrics::set_gauge(
                        &metrics::DRIVER_FALLBACK_MODE,
                        ExecutingComponent::Bootstrapper.get_label(),
                        0,
                    );
                    self.streaming_client
                        .get_all_transactions_or_outputs(
                            next_version,
                            end_version,
                            highest_known_ledger_version,
                            false,
                        )
                        .await?
                }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1517-1536)
```rust
    pub async fn handle_storage_synchronizer_error(
        &mut self,
        notification_and_feedback: NotificationAndFeedback,
    ) -> Result<(), Error> {
        // Reset the active stream
        self.reset_active_stream(Some(notification_and_feedback))
            .await?;

        // Fallback to output syncing if we need to
        if let BootstrappingMode::ExecuteOrApplyFromGenesis = self.get_bootstrapping_mode() {
            self.output_fallback_handler.fallback_to_outputs();
            metrics::set_gauge(
                &metrics::DRIVER_FALLBACK_MODE,
                ExecutingComponent::Bootstrapper.get_label(),
                1,
            );
        }

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L142-169)
```rust
                if self.output_fallback_handler.in_fallback_mode() {
                    metrics::set_gauge(
                        &metrics::DRIVER_FALLBACK_MODE,
                        ExecutingComponent::ContinuousSyncer.get_label(),
                        1,
                    );
                    self.streaming_client
                        .continuously_stream_transaction_outputs(
                            highest_synced_version,
                            highest_synced_epoch,
                            sync_request_target,
                        )
                        .await?
                } else {
                    metrics::set_gauge(
                        &metrics::DRIVER_FALLBACK_MODE,
                        ExecutingComponent::ContinuousSyncer.get_label(),
                        0,
                    );
                    self.streaming_client
                        .continuously_stream_transactions_or_outputs(
                            highest_synced_version,
                            highest_synced_epoch,
                            false,
                            sync_request_target,
                        )
                        .await?
                }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L501-522)
```rust
    pub async fn handle_storage_synchronizer_error(
        &mut self,
        notification_and_feedback: NotificationAndFeedback,
    ) -> Result<(), Error> {
        // Reset the active stream
        self.reset_active_stream(Some(notification_and_feedback))
            .await?;

        // Fallback to output syncing if we need to
        if let ContinuousSyncingMode::ExecuteTransactionsOrApplyOutputs =
            self.get_continuous_syncing_mode()
        {
            self.output_fallback_handler.fallback_to_outputs();
            metrics::set_gauge(
                &metrics::DRIVER_FALLBACK_MODE,
                ExecutingComponent::ContinuousSyncer.get_label(),
                1,
            );
        }

        Ok(())
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{
    global_summary::{AdvertisedData, GlobalDataSummary, OptimalChunkSizes},
    interface::ResponseError,
    logging::{LogEntry, LogEvent, LogSchema},
    metrics,
};
use aptos_config::{
    config::AptosDataClientConfig,
    network_id::{NetworkId, PeerNetworkId},
};
use aptos_logger::prelude::*;
use aptos_storage_service_types::{
    requests::StorageServiceRequest, responses::StorageServerSummary,
};
use aptos_time_service::TimeService;
use dashmap::DashMap;
use std::{
    cmp::min,
    collections::{BTreeMap, HashSet},
    sync::Arc,
    time::Duration,
};

// Useful constants
const LOGS_FREQUENCY_SECS: u64 = 120; // 2 minutes
const METRICS_FREQUENCY_SECS: u64 = 15; // 15 seconds
const NUM_PEER_BUCKETS_FOR_METRICS: u8 = 4; // To avoid metric explosion, we bucket peers into groups

/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;

pub enum ErrorType {
    /// A response or error that's not actively malicious but also doesn't help
    /// us make progress, e.g., timeouts, remote errors, invalid data, etc...
    NotUseful,
    /// A response or error that appears to be actively hindering progress or
    /// attempting to deceive us, e.g., invalid proof.
```
