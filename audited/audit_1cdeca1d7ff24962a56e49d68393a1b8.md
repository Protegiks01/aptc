# Audit Report

## Title
Git Dependency Cache Collision Vulnerability Enables Dependency Confusion Attacks

## Summary
The Move package manager's git dependency caching mechanism uses an overly aggressive URL sanitization function that can cause different git URLs to hash to the same cache directory path. This enables dependency confusion attacks where a malicious package from one URL can be substituted for a legitimate package from a different URL, potentially leading to supply chain compromise or denial of service.

## Finding Description

The vulnerability exists in the git dependency resolution and caching logic. When Move packages declare git dependencies, the system caches downloaded repositories in `~/.move/` with paths computed by sanitizing the git URL and revision. [1](#0-0) 

This `url_to_file_name` function replaces all occurrences of `/`, `:`, `.`, and `@` with underscores. This creates cache path collisions between distinct URLs:

**Collision Examples:**
- `https://github.com/company/internal.repo` → `https___github_com_company_internal_repo`
- `https://github.com/company.internal/repo` → `https___github_com_company_internal_repo` ⚠️ **SAME PATH**

When resolving dependencies, the system checks if the cache directory exists: [2](#0-1) 

**Critical Issue:** When the cache directory exists (line 563), there is **no validation** that the cached repository's git remote URL matches the expected dependency URL. The system either:
1. Uses the cached repository as-is (if `skip_fetch_latest_git_deps` is true)
2. Executes `git fetch origin` and `git reset --hard origin/{rev}` (lines 608-609)

In scenario 2, the `origin` remote still points to whichever URL was cloned first. If Package B's URL collides with Package A's cache path, and A was downloaded first:
- B's download is skipped because the directory exists
- B's update fetches from A's `origin` URL (wrong repository!)
- B uses A's repository contents

**Attack Scenario:**

1. Legitimate project depends on: `{ git = "https://github.com/trusted/security.lib", rev = "v1.0" }`
2. Attacker publishes malicious package: `{ git = "https://github.com/trusted.security/lib", rev = "v1.0" }`
3. Both URLs sanitize to: `https___github_com_trusted_security_lib_v1_0`
4. Attacker's package is in the dependency tree and gets downloaded first (via transitive dependencies)
5. When the legitimate package is resolved, the cached directory exists
6. The system uses the attacker's repository instead of the legitimate one
7. If both packages have the same name in `Move.toml`, the manifest validation passes
8. Malicious code from attacker's package is compiled into the project

The package name check at: [3](#0-2) 

Only validates **after** the wrong repository has been downloaded and its manifest parsed. If the attacker uses the same package name, this check passes, enabling silent substitution.

## Impact Explanation

**High Severity** per Aptos Bug Bounty criteria:

1. **Supply Chain Attack Vector**: Malicious code can be injected into Move packages during the build process, potentially compromising validator nodes, user wallets, or deployed smart contracts.

2. **Deterministic Execution Violation**: Different developers building the same project may receive different packages depending on the order dependencies are resolved, violating the invariant that all validators must produce identical builds from identical source.

3. **Denial of Service**: Even when package name validation catches the attack, it causes confusing build failures without explaining the root cause (cache collision), making debugging difficult.

4. **Wide Attack Surface**: Any public git hosting service (GitHub, GitLab, etc.) can be exploited since the attacker only needs to create a repository with a colliding URL.

While this doesn't directly compromise consensus at runtime, it compromises the build-time security of the Move development toolchain, which is critical infrastructure for the Aptos ecosystem.

## Likelihood Explanation

**Medium to High Likelihood:**

1. **Low Attacker Complexity**: Creating a git repository with a colliding URL requires minimal effort and no special privileges.

2. **Realistic Collision Scenarios**: The regex pattern `/|:|\.|@` creates many collision opportunities:
   - Domain/path separators can be substituted with dots
   - Protocol separators are removed
   - Common naming patterns create natural collisions

3. **Transitive Dependency Risk**: Attackers can inject malicious dependencies deep in the dependency tree, making them harder to detect.

4. **Caching Persistence**: Once a malicious package is cached, it persists across builds until manually cleared.

5. **No Validation**: The system performs no cryptographic verification (e.g., git commit signatures) or URL validation of cached repositories.

## Recommendation

**Immediate Fix:**

1. **Use cryptographic hashing for cache paths** instead of simple character replacement:

```rust
fn url_to_file_name(url: &str) -> String {
    use sha2::{Sha256, Digest};
    let mut hasher = Sha256::new();
    hasher.update(url.as_bytes());
    format!("{:x}", hasher.finalize())
}
```

2. **Validate cached repository URL** before using it:

```rust
fn verify_cached_repo_url(repo_path: &str, expected_url: &str) -> Result<()> {
    let output = Command::new("git")
        .args(["-C", repo_path, "remote", "get-url", "origin"])
        .output()?;
    let actual_url = String::from_utf8(output.stdout)?.trim().to_string();
    
    if actual_url != expected_url {
        bail!(
            "Cached repository URL mismatch. Expected '{}' but found '{}'. \
             Clearing cache and re-downloading.",
            expected_url, actual_url
        );
    }
    Ok(())
}
```

3. **Store metadata** alongside cached repositories indicating the source URL and verify it matches.

**Long-term Security Improvements:**

1. Implement git commit signature verification
2. Add dependency lock files with content hashes
3. Support private package registries with authentication
4. Add warnings when URL collisions are detected

## Proof of Concept

**Step 1: Create two repositories with colliding URLs**

```bash
# Legitimate repository
mkdir -p /tmp/legitimate/secure.package
cd /tmp/legitimate/secure.package
git init
cat > Move.toml << 'EOF'
[package]
name = "SecurePackage"
version = "1.0.0"

[addresses]
SecureAddr = "0x1"
EOF

mkdir sources
cat > sources/lib.move << 'EOF'
module SecureAddr::Lib {
    public fun is_legitimate(): bool { true }
}
EOF

git add .
git commit -m "Legitimate package"

# Malicious repository (note: secure/package instead of secure.package)
mkdir -p /tmp/malicious/secure/package
cd /tmp/malicious/secure/package
git init
cat > Move.toml << 'EOF'
[package]
name = "SecurePackage"
version = "1.0.0"

[addresses]
SecureAddr = "0x1"
EOF

mkdir sources
cat > sources/lib.move << 'EOF'
module SecureAddr::Lib {
    public fun is_legitimate(): bool { false }  // Malicious code!
}
EOF

git add .
git commit -m "Malicious package"
```

**Step 2: Demonstrate cache collision**

```bash
# URLs that collide:
# file:///tmp/legitimate/secure.package
# file:///tmp/malicious/secure/package
# Both sanitize to: file____tmp_legitimate_secure_package (for first)
#                   file____tmp_malicious_secure_package (for second - different!)

# Actually, let me fix this example - the URLs need to collide:
# file:///tmp/repo/secure.package
# file:///tmp/repo.secure/package
# Both sanitize to: file____tmp_repo_secure_package
```

**Step 3: Create test project**

```rust
// Test in Rust to demonstrate the vulnerability
#[test]
fn test_dependency_cache_collision() {
    let url1 = "https://github.com/company/internal.repo";
    let url2 = "https://github.com/company.internal/repo";
    
    let cache_path_1 = url_to_file_name(url1);
    let cache_path_2 = url_to_file_name(url2);
    
    // This assertion will pass, demonstrating the collision
    assert_eq!(cache_path_1, cache_path_2);
    assert_eq!(cache_path_1, "https___github_com_company_internal_repo");
}
```

**Exploitation:** If an attacker can get their malicious dependency downloaded first (through transitive dependencies or alphabetical ordering), subsequent attempts to download the legitimate package will use the cached malicious version.

### Citations

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L446-451)
```rust
fn url_to_file_name(url: &str) -> String {
    regex::Regex::new(r"/|:|\.|@")
        .unwrap()
        .replace_all(url, "_")
        .to_string()
}
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L449-454)
```rust
        if dep_name_in_pkg != dep_package.package.name {
            bail!("Name of dependency declared in package '{}' does not match dependency's package name '{}'",
                dep_name_in_pkg,
                dep_package.package.name
            );
        }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L551-616)
```rust
    fn download_and_update_if_remote<W: Write>(
        dep_name: PackageName,
        dep: &Dependency,
        skip_fetch_latest_git_deps: bool,
        writer: &mut W,
    ) -> Result<()> {
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();

            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
            } else if !skip_fetch_latest_git_deps {
                // Confirm git is available.
                git::confirm_git_available()?;

                // Update the git dependency
                // Check first that it isn't a git rev (if it doesn't work, just continue with the fetch)
                if let Ok(parsed_rev) = git::find_rev(git_path, git_rev) {
                    // If it's exactly the same, then it's a git rev
                    if parsed_rev.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                if let Ok(tag) = git::find_tag(git_path, git_rev) {
                    // If it's exactly the same, then it's a git tag, for now tags won't be updated
                    // Tags don't easily update locally and you can't use reset --hard to cleanup
                    // any extra files
                    if tag.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                writeln!(
                    writer,
                    "{} {}",
                    "UPDATING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;
                // If the current folder exists, do a fetch and reset to ensure that the branch
                // is up to date
                // NOTE: this means that you must run the package system with a working network connection
                git::fetch_origin(git_path, dep_name)?;
                git::reset_hard(git_path, git_rev, dep_name)?;
            }
        }
        if let Some(node_info) = &dep.node_info {
            package_hooks::resolve_custom_dependency(dep_name, node_info)?
        }
        Ok(())
    }
```
