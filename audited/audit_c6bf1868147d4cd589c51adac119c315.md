# Audit Report

## Title
Replay Verification Tool Silently Accepts Corrupted Transaction Metadata, Masking Critical Database Integrity Issues

## Summary
The replay verification tool in `replay_on_archive.rs` fails to detect missing or corrupted `PersistedAuxiliaryInfo` metadata because the database iterator returns default `None` values instead of errors, and the verification logic does not validate the `auxiliary_info_hash` field in `TransactionInfo`. This allows database corruption to go undetected, potentially leading to state inconsistencies across validator nodes.

## Finding Description

The vulnerability exists in a chain of permissive error handling across three components:

**1. Database Iterator Silently Returns Default Values**

When `get_persisted_auxiliary_info_iter` is called and auxiliary info entries are missing from the database, it returns `PersistedAuxiliaryInfo::None` instead of failing: [1](#0-0) 

The TODO comment explicitly acknowledges this is problematic. For versions before the first persisted entry, the iterator fabricates `None` values rather than reporting the data gap.

**2. Replay Verification Accepts Fabricated Values**

The verification tool extracts this potentially fabricated metadata without validation: [2](#0-1) 

The `persisted_aux_info` is then used to create `AuxiliaryInfo` objects for re-execution: [3](#0-2) 

**3. Verification Skips Auxiliary Info Hash Check**

During verification, the `ensure_match_transaction_info` method only validates status, gas usage, write set hash, and event root hash - but **does not check** the `auxiliary_info_hash` field: [4](#0-3) 

This breaks the critical invariant that `TransactionInfo` must be fully verified. The `auxiliary_info_hash` field was computed during original execution: [5](#0-4) 

**Impact Chain:**

1. Original execution commits transaction with `PersistedAuxiliaryInfo::V1 { transaction_index: X }` and stores `auxiliary_info_hash = Some(hash(V1{X}))` in `TransactionInfo`

2. Database corruption or incomplete backup loses the auxiliary info entry

3. Replay verification retrieves `PersistedAuxiliaryInfo::None` from the permissive iterator

4. Transaction re-executes with `transaction_index = NotAvailable` instead of the original value

5. For transactions that don't call `monotonically_increasing_counter_internal`, execution produces identical outputs despite wrong metadata

6. Verification passes because `auxiliary_info_hash` is not checked, even though it should mismatch (`Some(hash)` vs what would be computed from `None`)

7. **Database corruption remains undetected**

The `transaction_index` is critical for Move contracts that rely on ordering guarantees: [6](#0-5) 

When `TransactionIndexKind::NotAvailable`, the native function aborts. However, many transactions don't use this feature, allowing replay to succeed with corrupted metadata.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria ("Significant protocol violations"):

1. **State Consistency Violation**: The replay verification tool is a critical component for maintaining database integrity across validator nodes. Its failure to detect corruption violates the "State Consistency" invariant that "state transitions must be atomic and verifiable."

2. **Potential Consensus Divergence**: If different validator nodes restore from backups with different auxiliary info states, they could have inconsistent databases. During disaster recovery scenarios, this could lead to nodes producing different execution results for the same block.

3. **Undetected Data Corruption**: The tool's primary purpose - verifying database integrity - is compromised. Operators relying on it for backup validation or corruption detection receive false confidence.

4. **Transaction Ordering Violations**: For Move contracts using `monotonically_increasing_counter_internal`, the transaction index directly affects execution results. Silent corruption of this metadata could lead to non-deterministic execution across nodes.

## Likelihood Explanation

**HIGH likelihood** in production environments:

- Database corruption from disk failures is common in distributed systems
- Backup/restore operations frequently result in incomplete data
- The TODO comment indicates developers are aware of the issue but haven't fixed it
- No existing safeguards prevent the vulnerability from manifesting
- The verification tool is specifically used in scenarios where corruption is suspected, making this a critical failure

## Recommendation

Implement strict validation at multiple layers:

**Fix 1: Make Iterator Fail on Missing Data**

In `persisted_auxiliary_info_db.rs`, change the iterator to return an error instead of fabricating `None` values when data is missing:

```rust
// Remove the permissive "return all Nones" logic at lines 75-78
// Instead, ensure continuous versions and fail if gaps exist
```

**Fix 2: Add Auxiliary Info Hash Validation**

In `TransactionOutput::ensure_match_transaction_info`, add validation:

```rust
// After line 1925, add:
let output_aux_hash = /* compute from persisted_aux_info used during execution */;
ensure!(
    output_aux_hash == txn_info.auxiliary_info_hash(),
    "{}: version:{}, auxiliary_info_hash mismatch, computed:{:?}, expected:{:?}",
    ERR_MSG,
    version,
    output_aux_hash,
    txn_info.auxiliary_info_hash()
);
```

**Fix 3: Explicit Corruption Detection**

Add a dedicated validation function that compares retrieved `PersistedAuxiliaryInfo` against `TransactionInfo.auxiliary_info_hash`: [7](#0-6) 

Call this function in the replay verification flow before re-execution.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_replay_verification_accepts_corrupted_auxiliary_info() {
    // Setup: Initialize database and commit transactions with V1 auxiliary info
    let db = create_test_db();
    let txn = create_test_transaction();
    let aux_info = PersistedAuxiliaryInfo::V1 { transaction_index: 5 };
    
    // Commit transaction with auxiliary info
    commit_transaction(&db, txn.clone(), aux_info);
    
    // Simulate corruption: delete auxiliary info entry
    delete_auxiliary_info(&db, version);
    
    // Run replay verification
    let verifier = Verifier::new(&config)?;
    let errors = verifier.verify(version, 1)?;
    
    // BUG: Verification passes even though auxiliary info is corrupted
    assert!(errors.is_empty()); // This should fail but doesn't!
    
    // Expected: Should detect that auxiliary_info_hash in TransactionInfo
    // doesn't match the PersistedAuxiliaryInfo::None returned by iterator
}
```

**Notes**

The vulnerability specifically affects the replay verification tool (`db-tool`), which is critical infrastructure for database integrity validation, backup verification, and disaster recovery. While not directly exploitable by external attackers, this represents a significant protocol violation where a critical verification mechanism fails its core purpose. The issue is compounded by the fact that the `auxiliary_info_hash` field was specifically added to `TransactionInfo` for integrity verification, yet the verification tool doesn't check it.

### Citations

**File:** storage/aptosdb/src/ledger_db/persisted_auxiliary_info_db.rs (L75-84)
```rust
            // Note in this case we return all Nones. We rely on the caller to not query future
            // data when the DB is empty.
            // TODO(grao): This will be unreachable in the future, consider make it an error later.
            start_version + num_persisted_auxiliary_info as u64
        };
        let num_none = std::cmp::min(
            num_persisted_auxiliary_info,
            version.saturating_sub(start_version) as usize,
        );
        let none_iter = itertools::repeat_n(Ok(PersistedAuxiliaryInfo::None), num_none);
```

**File:** storage/db-tool/src/replay_on_archive.rs (L270-279)
```rust
            let (
                input_txn,
                persisted_aux_info,
                expected_txn_info,
                expected_event,
                expected_writeset,
            ) = item?;
            let is_epoch_ending = expected_event.iter().any(ContractEvent::is_new_epoch_event);
            cur_txns.push(input_txn);
            cur_persisted_aux_info.push(persisted_aux_info);
```

**File:** storage/db-tool/src/replay_on_archive.rs (L370-374)
```rust
            cur_persisted_aux_info
                .iter()
                .map(|info| AuxiliaryInfo::new(*info, None))
                .collect(),
        );
```

**File:** types/src/transaction/mod.rs (L1869-1927)
```rust
    pub fn ensure_match_transaction_info(
        &self,
        version: Version,
        txn_info: &TransactionInfo,
        expected_write_set: Option<&WriteSet>,
        expected_events: Option<&[ContractEvent]>,
    ) -> Result<()> {
        const ERR_MSG: &str = "TransactionOutput does not match TransactionInfo";

        let expected_txn_status: TransactionStatus = txn_info.status().clone().into();
        ensure!(
            self.status() == &expected_txn_status,
            "{}: version:{}, status:{:?}, auxiliary data:{:?}, expected:{:?}",
            ERR_MSG,
            version,
            self.status(),
            self.auxiliary_data(),
            expected_txn_status,
        );

        ensure!(
            self.gas_used() == txn_info.gas_used(),
            "{}: version:{}, gas_used:{:?}, expected:{:?}",
            ERR_MSG,
            version,
            self.gas_used(),
            txn_info.gas_used(),
        );

        let write_set_hash = CryptoHash::hash(self.write_set());
        ensure!(
            write_set_hash == txn_info.state_change_hash(),
            "{}: version:{}, write_set_hash:{:?}, expected:{:?}, write_set: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            write_set_hash,
            txn_info.state_change_hash(),
            self.write_set,
            expected_write_set,
        );

        let event_hashes = self
            .events()
            .iter()
            .map(CryptoHash::hash)
            .collect::<Vec<_>>();
        let event_root_hash = InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash;
        ensure!(
            event_root_hash == txn_info.event_root_hash(),
            "{}: version:{}, event_root_hash:{:?}, expected:{:?}, events: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            event_root_hash,
            txn_info.event_root_hash(),
            self.events(),
            expected_events,
        );

        Ok(())
```

**File:** types/src/transaction/mod.rs (L2812-2855)
```rust
fn verify_auxiliary_infos_against_transaction_infos(
    auxiliary_infos: &[PersistedAuxiliaryInfo],
    transaction_infos: &[TransactionInfo],
) -> Result<()> {
    // Verify the lengths of the auxiliary infos and transaction infos match
    ensure!(
        auxiliary_infos.len() == transaction_infos.len(),
        "The number of auxiliary infos ({}) does not match the number of transaction infos ({})",
        auxiliary_infos.len(),
        transaction_infos.len(),
    );

    // Verify the auxiliary info hashes match those of the transaction infos
    auxiliary_infos
        .par_iter()
        .zip_eq(transaction_infos.par_iter())
        .map(|(aux_info, txn_info)| {
            match aux_info {
                PersistedAuxiliaryInfo::None
                | PersistedAuxiliaryInfo::TimestampNotYetAssignedV1 { .. } => {
                    ensure!(
                        txn_info.auxiliary_info_hash().is_none(),
                        "The transaction info has an auxiliary info hash: {:?}, \
                             but the persisted auxiliary info is None!",
                        txn_info.auxiliary_info_hash()
                    );
                },
                PersistedAuxiliaryInfo::V1 { .. } => {
                    let aux_info_hash = CryptoHash::hash(aux_info);
                    ensure!(
                        txn_info.auxiliary_info_hash() == Some(aux_info_hash),
                        "The auxiliary info hash does not match the transaction info! \
                             Auxiliary info hash: {:?}. Auxiliary info hash in txn_info: {:?}.",
                        aux_info_hash,
                        txn_info.auxiliary_info_hash()
                    );
                },
            }
            Ok(())
        })
        .collect::<Result<Vec<_>>>()?;

    Ok(())
}
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L61-67)
```rust
                let auxiliary_info_hash = match persisted_auxiliary_info {
                    PersistedAuxiliaryInfo::None => None,
                    PersistedAuxiliaryInfo::V1 { .. } => {
                        Some(CryptoHash::hash(persisted_auxiliary_info))
                    },
                    PersistedAuxiliaryInfo::TimestampNotYetAssignedV1 { .. } => None,
                };
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L187-211)
```rust
        // monotonically_increasing_counter (128 bits) = `<reserved_byte (8 bits)> || timestamp_us (64 bits) || transaction_index (32 bits) || session counter (8 bits) || local_counter (16 bits)`
        // reserved_byte: 0 for block/chunk execution (V1), 1 for validation/simulation (TimestampNotYetAssignedV1)
        let timestamp_us = safely_pop_arg!(args, u64);
        let transaction_index_kind = user_transaction_context.transaction_index_kind();

        let (reserved_byte, transaction_index) = match transaction_index_kind {
            TransactionIndexKind::BlockExecution { transaction_index } => {
                (0u128, transaction_index)
            },
            TransactionIndexKind::ValidationOrSimulation { transaction_index } => {
                (1u128, transaction_index)
            },
            TransactionIndexKind::NotAvailable => {
                return Err(SafeNativeError::Abort {
                    abort_code: error::invalid_state(abort_codes::ETRANSACTION_INDEX_NOT_AVAILABLE),
                });
            },
        };

        let mut monotonically_increasing_counter: u128 = reserved_byte << 120;
        monotonically_increasing_counter |= (timestamp_us as u128) << 56;
        monotonically_increasing_counter |= (transaction_index as u128) << 24;
        monotonically_increasing_counter |= session_counter << 16;
        monotonically_increasing_counter |= local_counter;
        Ok(smallvec![Value::u128(monotonically_increasing_counter)])
```
