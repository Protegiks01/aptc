# Audit Report

## Title
Aptos Faucet Auth Token File Lacks Permission Validation Allowing Unauthorized Modification

## Summary
The `ListManager::new()` function in the Aptos faucet service reads authorization token files without verifying file permissions, allowing unauthorized local users with write access to modify the token list and bypass authentication controls.

## Finding Description
The Aptos faucet service uses `ListManager` to manage authorization tokens for both the `AuthTokenChecker` (which validates tokens) and `AuthTokenBypasser` (which allows tokens to skip all checks). The `ListManager::new()` function reads token files but performs no permission validation. [1](#0-0) 

The function simply opens the file and reads its contents without checking whether the file has appropriate permissions (e.g., not world-writable or group-writable). This creates a security vulnerability where:

1. An attacker with local system access could modify a world-writable token file
2. The attacker could add their own tokens to the `AuthTokenChecker` allowlist to gain access
3. The attacker could add tokens to the `AuthTokenBypasser` list to bypass all rate limiting and security checks

Both the checker and bypasser use this same vulnerable `ListManager`: [2](#0-1) [3](#0-2) 

The faucet service distributes test tokens on devnet/testnet networks. While these are not mainnet funds, the service is critical infrastructure for the Aptos developer ecosystem.

## Impact Explanation
This vulnerability falls under **Medium Severity** according to the Aptos bug bounty criteria. While the faucet distributes test tokens rather than mainnet funds, unauthorized access could:

- Allow attackers to drain testnet/devnet faucet funds by bypassing rate limits
- Disrupt the developer experience for legitimate users
- Enable denial-of-service attacks on the faucet service
- Compromise the integrity of testnet/devnet operations

The impact is limited because:
- Only affects test networks, not mainnet production funds
- Requires local system access (not a remote exploit)
- Does not affect consensus, validators, or blockchain state

However, defensive permission checking is a security best practice that the Aptos codebase already follows in other sensitive contexts. The CLI includes `save_to_file_confidential()` for sensitive files: [4](#0-3) 

## Likelihood Explanation
Likelihood is **Medium**. This requires:
- An operator to misconfigure file permissions (world-writable or group-writable)
- An attacker to have a local user account on the faucet server
- The faucet to be deployed in a multi-user environment

While this requires local access, such scenarios are realistic in:
- Shared hosting environments
- Containerized deployments with volume mounts
- Development/staging servers with multiple developers
- Compromised accounts through other vulnerabilities

## Recommendation
Add file permission validation to `ListManager::new()` to ensure the token file is not world-writable or group-writable:

```rust
use std::fs::File;
#[cfg(unix)]
use std::os::unix::fs::PermissionsExt;

pub fn new(config: ListManagerConfig) -> Result<Self> {
    let file = File::open(&config.file)
        .with_context(|| format!("Failed to open {}", config.file.to_string_lossy()))?;
    
    // Validate file permissions on Unix systems
    #[cfg(unix)]
    {
        let metadata = file.metadata()?;
        let permissions = metadata.permissions();
        let mode = permissions.mode();
        
        // Check if file is world-writable (other write bit set)
        if mode & 0o002 != 0 {
            anyhow::bail!(
                "Security: token file {} is world-writable (mode: {:o}). File must not be writable by others.",
                config.file.to_string_lossy(),
                mode & 0o777
            );
        }
        
        // Check if file is group-writable (group write bit set)
        if mode & 0o020 != 0 {
            anyhow::bail!(
                "Security: token file {} is group-writable (mode: {:o}). File should only be writable by owner.",
                config.file.to_string_lossy(),
                mode & 0o777
            );
        }
    }
    
    let mut items = HashSet::new();
    for line in std::io::BufReader::new(file).lines() {
        let line = line?;
        if line.starts_with('#') || line.starts_with("//") || line.is_empty() {
            continue;
        }
        items.insert(line);
    }
    Ok(Self { items })
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::fs::{File, OpenOptions};
    use std::io::Write;
    #[cfg(unix)]
    use std::os::unix::fs::PermissionsExt;
    
    #[test]
    #[cfg(unix)]
    fn test_rejects_world_writable_file() {
        let temp_file = std::env::temp_dir().join("test_world_writable_tokens.txt");
        
        // Create a world-writable file
        let mut file = File::create(&temp_file).unwrap();
        writeln!(file, "test_token_123").unwrap();
        
        // Set world-writable permissions (0o666)
        let mut perms = std::fs::metadata(&temp_file).unwrap().permissions();
        perms.set_mode(0o666);
        std::fs::set_permissions(&temp_file, perms).unwrap();
        
        // Attempt to load - should fail with our fix
        let config = ListManagerConfig {
            file: temp_file.clone(),
        };
        
        let result = ListManager::new(config);
        
        // Clean up
        std::fs::remove_file(temp_file).ok();
        
        // Should fail with our security check
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("world-writable"));
    }
    
    #[test]
    #[cfg(unix)]
    fn test_accepts_owner_only_file() {
        let temp_file = std::env::temp_dir().join("test_secure_tokens.txt");
        
        // Create a file with proper permissions
        let mut file = File::create(&temp_file).unwrap();
        writeln!(file, "test_token_123").unwrap();
        
        // Set owner-only permissions (0o600)
        let mut perms = std::fs::metadata(&temp_file).unwrap().permissions();
        perms.set_mode(0o600);
        std::fs::set_permissions(&temp_file, perms).unwrap();
        
        let config = ListManagerConfig {
            file: temp_file.clone(),
        };
        
        let result = ListManager::new(config);
        
        // Clean up
        std::fs::remove_file(temp_file).ok();
        
        // Should succeed
        assert!(result.is_ok());
        assert_eq!(result.unwrap().num_items(), 1);
    }
}
```

## Notes

While this is a valid security concern regarding defensive coding practices, it's important to note:

1. **Deployment Context**: The faucet is auxiliary infrastructure for test networks, not a consensus-critical component
2. **Access Requirements**: Exploitation requires local system access and misconfigured file permissions
3. **Impact Scope**: Affects testnet/devnet operations, not mainnet funds or blockchain consensus
4. **Best Practice**: The fix aligns with security practices already used elsewhere in the Aptos codebase for sensitive files

The vulnerability demonstrates the importance of defensive permission checking even for non-consensus components, as compromised auxiliary services can disrupt developer experience and testnet operations.

### Citations

**File:** crates/aptos-faucet/core/src/common/list_manager.rs (L21-32)
```rust
    pub fn new(config: ListManagerConfig) -> Result<Self> {
        let file = File::open(&config.file)
            .with_context(|| format!("Failed to open {}", config.file.to_string_lossy()))?;
        let mut items = HashSet::new();
        for line in std::io::BufReader::new(file).lines() {
            let line = line?;
            if line.starts_with('#') || line.starts_with("//") || line.is_empty() {
                continue;
            }
            items.insert(line);
        }
        Ok(Self { items })
```

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L20-27)
```rust
    pub fn new(config: ListManagerConfig) -> Result<Self> {
        let manager = ListManager::new(config)?;
        info!(
            "Loaded {} auth tokens into AuthTokenBypasser",
            manager.num_items()
        );
        Ok(Self { manager })
    }
```

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L20-27)
```rust
    pub fn new(config: ListManagerConfig) -> Result<Self> {
        let manager = ListManager::new(config)?;
        info!(
            "Loaded {} auth tokens into AuthTokenChecker",
            manager.num_items()
        );
        Ok(Self { manager })
    }
```

**File:** crates/aptos/src/common/types.rs (L1083-1089)
```rust
    /// Save to the `output_file` with restricted permissions (mode 0600)
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```
