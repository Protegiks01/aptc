# Audit Report

## Title
Resource Group V0 Format Incompatibility in ExecutorViewWithChangeSet Causes Invariant Violation and Potential Validator Divergence

## Summary
The `try_get_group_write_from_change_set()` function in `ExecutorViewWithChangeSet` unconditionally treats non-`WriteResourceGroup` operations at resource group keys as invariant violations, without accounting for V0 resource group format where groups are stored as regular `Write` operations. This causes `code_invariant_error` when epilogue or respawned session code accesses resource groups in V0 format, potentially leading to validator divergence if error handling differs across nodes.

## Finding Description
The Aptos VM supports two resource group formats in `VMChangeSet`:
- **V1 format**: Resource groups stored as `WriteResourceGroup` in `resource_group_write_set` (used when `RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET` feature is enabled and resolver is capable)
- **V0 format**: Resource groups stored as regular `Write` operations in `resource_write_set` (backwards compatibility mode) [1](#0-0) 

The vulnerable function `try_get_group_write_from_change_set()` pattern matches on `AbstractResourceWriteOp` but treats V0 entries as errors: [2](#0-1) 

**Attack Path:**

1. V0 format is active (feature disabled, non-capable resolver, or `WriteSetPayload::Direct` transaction)
2. User transaction modifies a resource group member (e.g., `FungibleStore` which is a resource group member): [3](#0-2) 

3. Change set contains V0 entries (Write operations at group keys): [4](#0-3) 

4. `RespawnedSession` is created with this V0 change set: [5](#0-4) 

5. Epilogue code accesses the modified resource group (e.g., `burn_fee` accessing `FungibleStore`): [6](#0-5) 

6. `ExecutorViewWithChangeSet.get_resource_from_group()` calls `try_get_group_write_from_change_set()`: [7](#0-6) 

7. Function finds `Write` operation at group_key and returns `code_invariant_error` (lines 100-105)
8. Transaction fails with invariant violation instead of executing correctly

**V0 Format Activation Conditions:** [8](#0-7) 

V0 is used when `is_resource_groups_split_in_change_set_capable()` returns false, which occurs with non-capable resolvers or default trait implementations: [9](#0-8) 

## Impact Explanation
**High Severity** - This vulnerability violates the **Deterministic Execution** invariant, as different validators may handle the `code_invariant_error` differently:

- Some nodes may panic and crash
- Others may return the error and continue
- This leads to non-deterministic transaction outcomes across validators
- Causes consensus divergence and potential chain splits

The impact qualifies as **High Severity** per Aptos bug bounty criteria:
- **Significant protocol violations**: Non-deterministic execution breaks consensus
- **Validator node issues**: Nodes may diverge on transaction execution results
- **State inconsistencies**: Different nodes compute different state roots

While the feature is enabled by default, the vulnerability remains exploitable in:
- Feature flag transition periods (governance changes)
- Non-capable resolver contexts
- `WriteSetPayload::Direct` transactions
- Test environments with feature disabled

## Likelihood Explanation
**Medium-High Likelihood:**

The vulnerability is **likely** to occur because:

1. **Multiple trigger paths exist**: V0 format activates in non-capable resolvers, `WriteSetPayload::Direct` transactions, and when feature is disabled
2. **Common code path**: Epilogue execution with resource group access is standard (fee burning uses `FungibleStore`)
3. **No explicit guards**: No capability check in `try_get_group_write_from_change_set()` to handle V0 gracefully
4. **Feature flag transitions**: Governance can disable/enable flags, creating temporary V0 states

The attack requires:
- V0 format to be active (feature disabled OR non-capable resolver)
- Transaction that modifies resource group members
- Epilogue or respawned session accessing those members

These conditions are realistic in production edge cases and guaranteed in test environments.

## Recommendation
Add capability-aware handling in `try_get_group_write_from_change_set()` to support both V0 and V1 formats:

```rust
fn try_get_group_write_from_change_set<'s>(
    &'s self,
    group_key: &StateKey,
    calling_fn_name: &'static str,
) -> Result<Option<&'s GroupWrite>, PanicError> {
    use AbstractResourceWriteOp::*;

    self.change_set
        .resource_write_set()
        .get(group_key)
        .and_then(|abstract_write_op| match abstract_write_op {
            WriteResourceGroup(group_write) => Some(Ok(group_write)),
            ResourceGroupInPlaceDelayedFieldChange(_) => None,
            Write(_) | WriteWithDelayedFields(_) | InPlaceDelayedFieldChange(_) => {
                // Check if we're in V0 mode where resource groups are stored as Write ops
                if !self.base_resource_group_view.is_resource_groups_split_in_change_set_capable() {
                    // V0 format: forward to base view to handle the blob
                    None
                } else {
                    // V1 format with invalid entry: this is an actual invariant violation
                    Some(Err(code_invariant_error(format!(
                        "Non-ResourceGroup write found in {} call for key {:?}",
                        calling_fn_name, group_key
                    ))))
                }
            },
        })
        .transpose()
}
```

Additionally, implement proper V0 blob handling in the base view forwarding path similar to `ResourceGroupAdapter::get_resource_from_group_impl()`.

## Proof of Concept

```rust
#[cfg(test)]
mod test_v0_resource_group_divergence {
    use super::*;
    use aptos_types::transaction::TransactionStatus;
    use aptos_vm::AptosVM;
    use move_core_types::account_address::AccountAddress;
    
    #[test]
    fn test_v0_resource_group_in_respawned_session() {
        // Setup: Disable RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET feature
        let mut harness = MoveHarness::new();
        harness.enable_features(
            vec![],
            vec![FeatureFlag::RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET]
        );
        
        // Create account with FungibleStore (resource group member)
        let account = harness.new_account_at(AccountAddress::random());
        
        // Execute transaction that modifies FungibleStore
        let txn = harness.create_transaction_with_fungible_store_modification(&account);
        let output = harness.run_transaction(txn);
        
        // This should succeed but will trigger code_invariant_error
        // when epilogue tries to access FungibleStore through
        // ExecutorViewWithChangeSet during respawned session
        match output.status() {
            TransactionStatus::Keep(_) => {
                // Expected to fail with invariant error in V0 mode
                panic!("Transaction should fail with code_invariant_error in V0 mode");
            },
            TransactionStatus::Discard(status) => {
                // Verify it's the specific invariant error from try_get_group_write_from_change_set
                assert!(status.message().unwrap().contains("Non-ResourceGroup write found"));
            },
            _ => panic!("Unexpected transaction status"),
        }
    }
}
```

## Notes
This vulnerability demonstrates a format version incompatibility where `ExecutorViewWithChangeSet` assumes V1 format universally without checking resolver capabilities. The fix must ensure both V0 and V1 formats are handled correctly in all execution contexts, particularly in respawned sessions where epilogue code accesses resource groups modified in user transactions.

### Citations

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L464-477)
```rust
        match resource_group_change_set {
            ResourceGroupChangeSet::V0(v0_changes) => {
                for (state_key, blob_op) in v0_changes {
                    let op = woc.convert_resource(&state_key, blob_op, false)?;
                    resource_write_set.insert(state_key, op);
                }
            },
            ResourceGroupChangeSet::V1(v1_changes) => {
                for (state_key, resources) in v1_changes {
                    let group_write = woc.convert_resource_group_v1(&state_key, resources)?;
                    resource_group_write_set.insert(state_key, group_write);
                }
            },
        }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/view_with_change_set.rs (L87-108)
```rust
    fn try_get_group_write_from_change_set<'s>(
        &'s self,
        group_key: &StateKey,
        calling_fn_name: &'static str,
    ) -> Result<Option<&'s GroupWrite>, PanicError> {
        use AbstractResourceWriteOp::*;

        self.change_set
            .resource_write_set()
            .get(group_key)
            .and_then(|abstract_write_op| match abstract_write_op {
                WriteResourceGroup(group_write) => Some(Ok(group_write)),
                ResourceGroupInPlaceDelayedFieldChange(_) => None, // Will become Ok(None) after transpose
                Write(_) | WriteWithDelayedFields(_) | InPlaceDelayedFieldChange(_) => {
                    Some(Err(code_invariant_error(format!(
                        "Non-ResourceGroup write found in {} call for key {:?}",
                        calling_fn_name, group_key
                    ))))
                },
            })
            .transpose()
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/view_with_change_set.rs (L313-334)
```rust
    fn get_resource_from_group(
        &self,
        group_key: &Self::GroupKey,
        resource_tag: &Self::ResourceTag,
        maybe_layout: Option<&Self::Layout>,
    ) -> PartialVMResult<Option<Bytes>> {
        self.try_get_group_write_from_change_set(group_key, "get_resource_from_group")?
            .and_then(|group_write| group_write.inner_ops().get(resource_tag))
            .map_or_else(
                || {
                    self.base_resource_group_view.get_resource_from_group(
                        group_key,
                        resource_tag,
                        maybe_layout,
                    )
                },
                |(write_op, layout)| {
                    randomly_check_layout_matches(maybe_layout, layout.as_deref())?;
                    Ok(write_op.extract_raw_bytes())
                },
            )
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L146-155)
```text
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    /// The store object that holds fungible assets of a specific type associated with an account.
    struct FungibleStore has key {
        /// The address of the base metadata object.
        metadata: Object<Metadata>,
        /// The balance of the fungible metadata.
        balance: u64,
        /// If true, owner transfer is disabled that only `TransferRef` can move in/out from this store.
        frozen: bool
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L1096-1101)
```text
    public(friend) fun address_burn_from_for_gas(
        self: &BurnRef, store_addr: address, amount: u64
    ) acquires FungibleStore, Supply, ConcurrentSupply, ConcurrentFungibleBalance {
        // ref metadata match is checked in burn() call
        self.burn(unchecked_withdraw_with_no_events(store_addr, amount));
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/respawned_session.rs (L44-49)
```rust
    ) -> RespawnedSession<'r> {
        let executor_view = ExecutorViewWithChangeSet::new(
            base.as_executor_view(),
            base.as_resource_group_view(),
            previous_session_change_set,
        );
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L134-147)
```rust
        let group_size_kind = GroupSizeKind::from_gas_feature_version(
            gas_feature_version,
            // Even if flag is enabled, if we are in non-capable context, we cannot use AsSum,
            // and split resource groups in the VMChangeSet.
            // We are not capable if:
            // - Block contains single PayloadWriteSet::Direct transaction
            // - we are not executing blocks for a live network in a gas charging context
            //     (outside of BlockExecutor) i.e. unit tests, view functions, etc.
            //     In this case, disabled will lead to a different gas behavior,
            //     but gas is not relevant for those contexts.
            resource_groups_split_in_vm_change_set_enabled
                && maybe_resource_group_view
                    .is_some_and(|v| v.is_resource_groups_split_in_change_set_capable()),
        );
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L228-230)
```rust
    fn is_resource_groups_split_in_change_set_capable(&self) -> bool {
        self.group_size_kind == GroupSizeKind::AsSum
    }
```
