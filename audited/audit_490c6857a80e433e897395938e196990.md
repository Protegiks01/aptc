# Audit Report

## Title
Server-Side Request Forgery (SSRF) in Move Package Dependency Resolution via Unvalidated node_url

## Summary
The Move package manifest system stores Aptos node URLs as unvalidated strings, allowing attackers to craft malicious `Move.toml` files with dependencies pointing to internal services (localhost, cloud metadata endpoints, internal networks). When developers or CI/CD systems build these packages, HTTP requests are made to attacker-controlled URLs, enabling SSRF attacks that can leak credentials, scan internal networks, and access protected services.

## Finding Description
The vulnerability exists in the Move package dependency resolution system. When a Move package declares a dependency with `PackageLocation::Aptos`, the `node_url` field is deserialized from the manifest as a raw `String` without validation. [1](#0-0) 

During package compilation, the resolver converts this string directly to a URL and passes it to the HTTP client: [2](#0-1) 

The URL is then used to fetch the package from the "node": [3](#0-2) 

The actual HTTP request is made in the package cache without any URL validation: [4](#0-3) 

The REST client directly passes the URL to reqwest, making the actual HTTP request: [5](#0-4) [6](#0-5) 

**Attack Path:**
1. Attacker creates a malicious `Move.toml` with: `MyPackage = { aptos = "http://169.254.169.254/latest/meta-data", address = "0x1" }`
2. Victim (developer, CI system, or build infrastructure) attempts to compile the package using `aptos move compile`
3. The build process resolves dependencies and calls the resolver
4. HTTP GET request is made to `http://169.254.169.254/latest/meta-data/v1/accounts/{address}/resource/0x1::code::PackageRegistry?ledger_version={version}`
5. In AWS environments, this leaks IAM credentials; in other environments, it can access internal services

## Impact Explanation
This is **High Severity** based on Aptos bug bounty criteria. While it doesn't directly affect consensus or on-chain state, it represents a significant security vulnerability in the Aptos build infrastructure:

1. **Credential Theft**: In cloud environments (AWS, GCP, Azure), metadata services expose sensitive credentials:
   - AWS: `http://169.254.169.254/latest/meta-data/iam/security-credentials/`
   - GCP: `http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token`
   - Azure: `http://169.254.169.254/metadata/identity/oauth2/token`

2. **Internal Network Reconnaissance**: Attackers can scan internal networks accessible to build systems, potentially discovering validator node management interfaces, internal APIs, or other sensitive services.

3. **Build System Compromise**: CI/CD systems often have elevated privileges. Compromising their credentials can lead to supply chain attacks affecting the entire Aptos ecosystem.

4. **Validator Infrastructure Risk**: If validator operators build or verify packages using compromised manifests, their internal infrastructure could be exposed.

## Likelihood Explanation
**High Likelihood** - The attack is trivial to execute:

1. **Low Complexity**: Attacker only needs to create a malicious `Move.toml` file
2. **Common Scenarios**: Package builds occur in:
   - Developer workstations
   - CI/CD pipelines (GitHub Actions, GitLab CI, Jenkins)
   - Package verification systems
   - Automated testing infrastructure
3. **No Authentication Required**: The attack doesn't require any special privileges
4. **Wide Attack Surface**: Any system that builds Move packages from untrusted sources is vulnerable

## Recommendation
Implement strict URL validation before making HTTP requests in the package resolution system:

```rust
// In third_party/move/tools/move-package-resolver/src/resolver.rs
use std::net::IpAddr;

fn validate_node_url(url: &Url) -> Result<()> {
    // Only allow https scheme (or http for localhost in dev mode)
    match url.scheme() {
        "https" => {},
        "http" if cfg!(debug_assertions) => {},
        _ => bail!("Only HTTPS URLs are allowed for Aptos dependencies"),
    }
    
    // Block private/internal IP ranges
    if let Some(host) = url.host() {
        match host {
            url::Host::Ipv4(ip) => {
                if ip.is_private() || ip.is_loopback() || ip.is_link_local() {
                    bail!("Private/internal IP addresses are not allowed");
                }
            },
            url::Host::Ipv6(ip) => {
                if ip.is_loopback() || ip.is_unspecified() {
                    bail!("Private/internal IP addresses are not allowed");
                }
            },
            url::Host::Domain(domain) => {
                // Block metadata service domains
                let blocked_domains = ["169.254.169.254", "metadata.google.internal", 
                                       "localhost", "127.0.0.1"];
                if blocked_domains.iter().any(|&d| domain.contains(d)) {
                    bail!("Blocked domain");
                }
            }
        }
    }
    
    Ok(())
}

// Apply in resolve_dependency:
PackageLocation::Aptos { node_url, package_addr } => {
    remote_url = Url::from_str(&node_url)?;
    validate_node_url(&remote_url)?; // Add validation
    // ... rest of code
}
```

Alternatively, implement an allowlist of trusted Aptos node URLs (mainnet, testnet, devnet) and reject all others by default.

## Proof of Concept

Create a malicious Move package:

```toml
# Move.toml
[package]
name = "MaliciousPackage"
version = "1.0.0"

[dependencies]
# Attempt to access AWS metadata service
AWSMetadata = { aptos = "http://169.254.169.254/latest/meta-data", address = "0x1" }

# Attempt to access internal network
InternalService = { aptos = "http://192.168.1.1/admin", address = "0x1" }

# Attempt to access localhost
LocalAdmin = { aptos = "http://localhost:8080/admin", address = "0x1" }
```

Execute:
```bash
aptos move compile --package-dir ./malicious_package
```

Observe in network logs or using a local proxy that HTTP requests are made to:
- `http://169.254.169.254/latest/meta-data/v1/accounts/0x1/resource/...`
- `http://192.168.1.1/admin/v1/accounts/0x1/resource/...`
- `http://localhost:8080/admin/v1/accounts/0x1/resource/...`

In AWS environments with IMDSv1 enabled, the metadata service will respond with credentials.

## Notes
This vulnerability affects the build tooling rather than runtime blockchain operations. However, it poses significant risk to the Aptos ecosystem's supply chain security, particularly affecting:
- CI/CD infrastructure building Aptos packages
- Developer workstations compiling untrusted packages
- Automated package verification systems
- Any build environment with access to sensitive internal networks or cloud metadata services

The issue stems from the documented "tentative design" with "leaky abstraction" noted in the code comments, where the `node_url` was kept as a raw `String` rather than implementing proper validation as a `Url` type with security constraints.

### Citations

**File:** third_party/move/tools/move-package-manifest/src/manifest.rs (L149-156)
```rust
    Aptos {
        /// URL to the Aptos full-node connected to the network where the package is published.
        node_url: String,

        /// Address of the published package.
        package_addr: AccountAddress,
    },
}
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L186-203)
```rust
    Ok(match &identity.location {
        SourceLocation::OnChain {
            node: _,
            package_addr,
        } => {
            let fullnode_url = user_provided_url.expect("must be specified for on-chain dep");

            let network_version = package_lock.resolve_network_version(fullnode_url).await?;

            package_cache
                .fetch_on_chain_package(
                    fullnode_url,
                    network_version,
                    *package_addr,
                    &identity.name,
                )
                .await?
        },
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L413-428)
```rust
        PackageLocation::Aptos {
            node_url,
            package_addr,
        } => {
            remote_url = Url::from_str(&node_url)?;

            let identity = PackageIdentity {
                name: dep_name.to_string(),
                location: SourceLocation::OnChain {
                    node: CanonicalNodeIdentity::new(&remote_url)?,
                    package_addr,
                },
            };

            (identity, Some(&remote_url))
        },
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L280-340)
```rust
    pub async fn fetch_on_chain_package(
        &self,
        fullnode_url: &Url,
        network_version: u64,
        address: AccountAddress,
        package_name: &str,
    ) -> Result<PathBuf>
    where
        L: PackageCacheListener,
    {
        let on_chain_packages_path = self.root.join("on-chain");

        let canonical_node_identity = CanonicalNodeIdentity::new(fullnode_url)?;
        let canonical_name = format!(
            "{}+{}+{}+{}",
            &*canonical_node_identity, network_version, address, package_name
        );

        let cached_package_path = on_chain_packages_path.join(&canonical_name);

        // If the package directory already exists, assume it has been cached.
        if cached_package_path.exists() {
            // TODO: In the future, consider verifying data integrity,
            //       e.g. hash of metadata or full contents.
            return Ok(cached_package_path);
        }

        // Package directory does not exist -- need to download the package and cache it.
        //
        // First, acquire a lock to ensure exclusive write access to this package.
        let lock_path = cached_package_path.with_extension("lock");

        fs::create_dir_all(&on_chain_packages_path)?;
        let _file_lock =
            FileLock::lock_with_alert_on_wait(&lock_path, Duration::from_millis(1000), || {
                self.listener.on_file_lock_wait(&lock_path);
            })
            .await?;

        self.listener.on_file_lock_acquired(&lock_path);

        // After acquiring the lock, re-check if the package was already cached by another process.
        if cached_package_path.exists() {
            return Ok(cached_package_path);
        }

        // Fetch the on-chain package registry at the specified ledger version and look-up the
        // package by name.
        self.listener
            .on_bytecode_package_download_start(address, package_name);

        let client = aptos_rest_client::Client::new(fullnode_url.clone());

        let package_registry = client
            .get_account_resource_at_version_bcs::<PackageRegistry>(
                address,
                "0x1::code::PackageRegistry",
                network_version,
            )
            .await?
            .into_inner();
```

**File:** crates/aptos-rest-client/src/lib.rs (L134-136)
```rust
    pub fn new(base_url: Url) -> Self {
        Self::builder(AptosBaseUrl::Custom(base_url)).build()
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1687-1690)
```rust
    async fn get_bcs(&self, url: Url) -> AptosResult<Response<bytes::Bytes>> {
        let response = self.inner.get(url).header(ACCEPT, BCS).send().await?;
        self.check_and_parse_bcs_response(response).await
    }
```
