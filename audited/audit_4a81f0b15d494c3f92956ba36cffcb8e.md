# Audit Report

## Title
Missing Gas Parameter Validation Enables Economic Disruption Through Governance

## Summary
The gas parameter initialization system lacks validation checks, allowing governance proposals to set arbitrary values (including zero or extremely high values) for hash operation gas costs. This breaks the "Resource Limits" invariant and can systematically disrupt gas economics network-wide.

## Finding Description

The `GasParameters` struct in `hash.rs` defines gas costs for SHA2-256 and SHA3-256 operations: [1](#0-0) 

These parameters are loaded from on-chain storage via the gas schedule system. The critical vulnerability lies in the `from_on_chain_gas_schedule` implementation generated by the `define_gas_parameters!` macro: [2](#0-1) 

This implementation performs **zero validation** - it directly converts u64 values from the on-chain BTreeMap using `.into()` without checking for:
- Zero values (making operations free)
- Unreasonably high values (making operations prohibitively expensive)  
- Reasonable ranges or consistency with computational cost

The on-chain gas schedule is updated through governance proposals that call `set_for_next_epoch()`: [3](#0-2) 

Critically, the Move code contains explicit TODO comments acknowledging missing validation: [4](#0-3) 

**Attack Path:**
1. A governance proposal is created to update the gas schedule
2. The proposal includes malicious gas parameter values (e.g., all zeros for free hashing, or u64::MAX for impossibly expensive operations)
3. If the proposal passes governance voting, it's applied at the next epoch
4. All validators reload gas parameters from on-chain storage
5. Hash operations now charge incorrect amounts deterministically across all nodes

**Broken Invariants:**
- **Resource Limits** (Invariant #9): Operations no longer respect computational limits when gas is zero
- **Move VM Safety** (Invariant #3): Bytecode execution doesn't properly respect gas constraints

## Impact Explanation

**Severity: High** (per bug bounty criteria: "Significant protocol violations")

With zero gas costs:
- Attackers spam hash-heavy transactions at minimal cost
- Validators process expensive cryptographic operations for near-zero fees
- Network experiences resource exhaustion without economic protection
- Gas economics model fundamentally broken

With extremely high gas costs:
- Legitimate operations using hashing become impossible
- Critical system functions that rely on hashing fail
- Potential network liveness issues

**Critical consideration:** While deterministic (all validators use the same malicious values), this breaks the economic security model that protects against resource exhaustion attacks.

## Likelihood Explanation

**Likelihood: Low to Medium**

**Requirements:**
- Must pass governance proposal (requires significant stake-weighted voting power)
- Either malicious governance majority OR compromised governance process OR buggy proposal

**Mitigating factors:**
- Governance participants are typically reputable validators
- Proposals are publicly visible before execution
- Community can review gas schedule changes

**Exacerbating factors:**
- No validation exists as defense-in-depth
- TODO comments show this was intended but never implemented
- A single malicious/buggy proposal affects entire network

## Recommendation

Implement comprehensive validation in both Move and Rust layers:

**Move Layer** (defense at source):
```move
// In gas_schedule.move, replace TODO with actual validation
fun validate_gas_schedule(schedule: &GasScheduleV2) {
    // Validate hash parameters are within acceptable ranges
    let entries = &schedule.entries;
    // Check each critical parameter exists and has reasonable value
    // Example: hash costs should be between MIN_HASH_GAS and MAX_HASH_GAS
    assert!(validate_parameter_range(entries, "move_stdlib.hash.sha2_256.base", 1000, 1000000), 
        error::invalid_argument(EINVALID_GAS_SCHEDULE));
    // ... validate other parameters
}
```

**Rust Layer** (defense in depth):
```rust
// In macros.rs, add validation after loading parameters
fn from_on_chain_gas_schedule(...) -> Result<Self, String> {
    let mut params = $params_name::zeros();
    
    // Load parameters
    $(
        if let Some(key) = ... {
            let value = gas_schedule.get(&name).cloned()
                .ok_or_else(|| format!("Gas parameter {} does not exist", name))?;
            params.$name = value.into();
        }
    )*
    
    // VALIDATE LOADED PARAMETERS
    params.validate()?;
    
    Ok(params)
}

// Add validation method to each GasParameters struct
impl MoveStdlibGasParameters {
    fn validate(&self) -> Result<(), String> {
        if self.hash_sha2_256_base == 0.into() {
            return Err("hash_sha2_256_base cannot be zero".to_string());
        }
        // ... validate other parameters
        Ok(())
    }
}
```

## Proof of Concept

**Move Test demonstrating vulnerability:**

```move
#[test(aptos_framework = @0x1)]
fun test_malicious_gas_schedule(aptos_framework: signer) {
    use aptos_framework::gas_schedule;
    use std::vector;
    
    // Create malicious gas schedule with zero hash costs
    let malicious_schedule = vector[
        1, 0, 0, 0, 0, 0, 0, 0,  // feature_version: 1
        2, 0, 0, 0, 0, 0, 0, 0,  // entry count: 2
        // Entry 1: move_stdlib.hash.sha2_256.base = 0
        30, // key length
        109, 111, 118, 101, 95, 115, 116, 100, 108, 105, 98, 46, 104, 97, 115, 104, 46, 
        115, 104, 97, 50, 95, 50, 53, 54, 46, 98, 97, 115, 101,
        0, 0, 0, 0, 0, 0, 0, 0,  // value: 0 (FREE!)
        // Entry 2: move_stdlib.hash.sha2_256.per_byte = 0  
        34, // key length
        109, 111, 118, 101, 95, 115, 116, 100, 108, 105, 98, 46, 104, 97, 115, 104, 46,
        115, 104, 97, 50, 95, 50, 53, 54, 46, 112, 101, 114, 95, 98, 121, 116, 101,
        0, 0, 0, 0, 0, 0, 0, 0,  // value: 0 (FREE!)
    ];
    
    // This should fail with validation error, but currently succeeds
    gas_schedule::set_for_next_epoch(&aptos_framework, malicious_schedule);
    
    // After next epoch, SHA2-256 hashing costs ZERO gas
    // Attackers can spam unlimited hash operations
}
```

**Rust reproduction:**

The vulnerability can be verified by checking that `from_on_chain_gas_schedule` accepts a BTreeMap with zero values without returning an error:

```rust
use std::collections::BTreeMap;

let mut malicious_schedule = BTreeMap::new();
malicious_schedule.insert("move_stdlib.hash.sha2_256.base".to_string(), 0u64);
malicious_schedule.insert("move_stdlib.hash.sha2_256.per_byte".to_string(), 0u64);

// This succeeds despite zero values being economically invalid
let params = MoveStdlibGasParameters::from_on_chain_gas_schedule(
    &malicious_schedule, 
    1
).unwrap();

assert_eq!(params.hash_sha2_256_base, 0.into()); // Passes - should fail!
```

## Notes

This vulnerability requires governance compromise to exploit, placing it at the boundary of the trust model. However, it represents a critical gap in defense-in-depth: even trusted inputs should be validated to prevent accidental or malicious misconfiguration. The explicit TODO comments indicate this validation was intended but never implemented, making it a legitimate security concern warranting remediation.

### Citations

**File:** third_party/move/move-stdlib/src/natives/hash.rs (L113-116)
```rust
pub struct GasParameters {
    pub sha2_256: Sha2_256GasParameters,
    pub sha3_256: Sha3_256GasParameters,
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L32-46)
```rust
        impl $crate::traits::FromOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```
