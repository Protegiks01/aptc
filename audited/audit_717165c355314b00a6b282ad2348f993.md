# Audit Report

## Title
Mainnet Validators Can Bypass Paranoid Type Verification Enforcement via Configuration Sanitizer Bypass

## Summary
Mainnet validators can bypass the `sanitize()` function's enforcement of `paranoid_type_verification` by setting `skip_config_sanitizer: true` in their node configuration, allowing them to disable critical Move VM type safety checks. This creates a consensus split risk where validators with different settings may execute transactions differently, violating the deterministic execution invariant.

## Finding Description

The `ExecutionConfig::sanitize()` function enforces that mainnet validators must enable `paranoid_type_verification`: [1](#0-0) 

However, this entire sanitization process can be bypassed by setting `skip_config_sanitizer: true` in the node startup configuration: [2](#0-1) 

The `skip_config_sanitizer` field is a publicly configurable option that defaults to `false`: [3](#0-2) 

An explicit test demonstrates this bypass works as designed, allowing invalid mainnet configurations to pass validation: [4](#0-3) 

**Attack Path:**
1. Validator operator modifies their node's YAML configuration file to set:
   ```yaml
   node_startup:
     skip_config_sanitizer: true
   execution:
     paranoid_type_verification: false
   ```
2. Node starts successfully with sanitizer bypassed
3. The VM configuration is set via `set_aptos_vm_configurations()`: [5](#0-4) 

4. The global `PARANOID_TYPE_CHECKS` OnceCell is set to `false`: [6](#0-5) 

5. During transaction execution, the interpreter selects `NoRuntimeTypeCheck` instead of `FullRuntimeTypeCheck`: [7](#0-6) 

6. The `NoRuntimeTypeCheck` implementation performs no type safety checks: [8](#0-7) 

**Invariant Violated:**
This breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks." If validators have different `paranoid_type_verification` settings and a Move VM bug exists that the paranoid checks would catch, validators will execute transactions differently, producing different state roots and causing a consensus split.

## Impact Explanation

**Critical Severity** - Consensus/Safety Violation

This vulnerability enables a potential consensus split scenario. The paranoid type checks are defense-in-depth mechanisms that verify type safety invariants during Move bytecode execution. These checks complement the bytecode verifier and catch potential VM bugs or edge cases.

If validators run with different settings:
- A validator with checks disabled may accept and execute a transaction that validators with checks enabled would reject
- This leads to different state roots for the same block
- Consensus breaks as validators cannot agree on the canonical chain state
- Recovery requires identifying the misconfigured validators and coordinating a network-wide restart

The fact that Aptos explicitly enforces this setting on mainnet via sanitization indicates it's considered a critical safety requirement. The existence of the bypass mechanism undermines this enforcement entirely.

## Likelihood Explanation

**Likelihood: Low to Medium**

While the default configuration is secure (`skip_config_sanitizer: false`, `paranoid_type_verification: true`), the vulnerability can manifest through:

1. **Accidental Misconfiguration**: Validator operators copying test configurations to production, or using outdated configuration templates that include the bypass flag
2. **Intentional Misconfiguration**: Validator operators seeking performance optimizations may disable checks without understanding the consensus implications
3. **No Detection Mechanism**: There is no logging, warning, or monitoring when `skip_config_sanitizer` is enabled on mainnet

The OnceCell mechanism prevents runtime modification after startup, providing some protection: [9](#0-8) 

However, this doesn't prevent the initial misconfiguration from taking effect.

## Recommendation

**Primary Fix:** Remove the ability to bypass config sanitization on mainnet networks. Add a chain-ID-aware check that prevents `skip_config_sanitizer` from being effective on mainnet:

```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // Prevent sanitizer bypass on mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && node_config.node_startup.skip_config_sanitizer {
                return Err(Error::ConfigSanitizerFailed(
                    "NodeConfig".to_string(),
                    "skip_config_sanitizer cannot be enabled on mainnet!".into(),
                ));
            }
        }
        
        // If config sanitization is disabled, don't do anything (only for non-mainnet)
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
        
        // ... rest of sanitization
    }
}
```

**Additional Mitigations:**
1. Add critical warning logs when `skip_config_sanitizer` is true
2. Add telemetry/metrics to detect validators running with this setting
3. Consider removing `skip_config_sanitizer` entirely from production builds (compile-time feature flag)
4. Document that this flag is for testing only

## Proof of Concept

**Step 1:** Create a mainnet validator config file (`validator_config.yaml`):
```yaml
base:
  role: "validator"
  
node_startup:
  skip_config_sanitizer: true  # Bypass sanitizer
  
execution:
  paranoid_type_verification: false  # Disable safety checks
  genesis_file_location: "genesis.blob"
```

**Step 2:** Rust code demonstrating the bypass:
```rust
use aptos_config::config::{NodeConfig, NodeType, ExecutionConfig, NodeStartupConfig};
use aptos_types::chain_id::ChainId;
use aptos_config::config::config_sanitizer::ConfigSanitizer;

fn main() {
    // Create a mainnet validator config with checks disabled
    let mut node_config = NodeConfig {
        node_startup: NodeStartupConfig {
            skip_config_sanitizer: true,  // Enable bypass
            ..Default::default()
        },
        execution: ExecutionConfig {
            paranoid_type_verification: false,  // Disable checks
            ..Default::default()
        },
        ..Default::default()
    };
    
    // Attempt to sanitize for mainnet validator
    let result = NodeConfig::sanitize(
        &node_config, 
        NodeType::Validator, 
        Some(ChainId::mainnet())
    );
    
    // This should fail but succeeds due to the bypass
    assert!(result.is_ok(), "Sanitizer was bypassed!");
    
    println!("SUCCESS: Mainnet validator config with disabled type checks passed validation!");
    println!("This validator will execute transactions without paranoid type safety checks.");
}
```

**Expected Behavior:** The sanitizer should reject this configuration on mainnet.
**Actual Behavior:** The configuration passes validation, and the validator runs with type checks disabled.

**Consensus Split Scenario:**
1. Deploy the misconfigured validator to mainnet
2. Wait for a transaction that triggers a VM bug caught by paranoid checks
3. Validator with checks disabled: Executes transaction, produces state root A
4. Validators with checks enabled: Reject transaction due to type check failure, produce state root B
5. Network splits as validators cannot agree on the canonical state

---

**Notes:**
- The vulnerability requires validator operator access to modify configuration files, but this is standard operational access and not considered "privileged" in the attack model for configuration security
- The OnceCell protection prevents runtime modification but does not address the initial bypass
- No on-chain governance or consensus-level enforcement validates this setting across validators

### Citations

**File:** config/src/config/execution_config.rs (L166-183)
```rust
        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L212-239)
```rust
    fn test_disable_config_sanitizer() {
        // Create a default node config (with sanitization enabled)
        let mut node_config = NodeConfig::default();

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer fails
        let error =
            NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
                .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
    }
```

**File:** config/src/config/node_startup_config.rs (L8-11)
```rust
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** aptos-node/src/utils.rs (L53-56)
```rust
pub fn set_aptos_vm_configurations(node_config: &NodeConfig) {
    set_layout_caches(node_config.execution.layout_caches_enabled);
    set_paranoid_type_checks(node_config.execution.paranoid_type_verification);
    set_async_runtime_checks(node_config.execution.async_runtime_checks);
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L27-28)
```rust
static PARANOID_TYPE_CHECKS: OnceCell<bool> = OnceCell::new();
static PARANOID_REF_CHECKS: OnceCell<bool> = OnceCell::new();
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L45-53)
```rust
/// Set the paranoid type check flag.
pub fn set_paranoid_type_checks(enable: bool) {
    PARANOID_TYPE_CHECKS.set(enable).ok();
}

/// Returns the paranoid type check flag if already set, and true otherwise.
pub fn get_paranoid_type_checks() -> bool {
    PARANOID_TYPE_CHECKS.get().cloned().unwrap_or(true)
}
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L244-278)
```rust
        let paranoid_type_checks =
            !trace_recorder.is_enabled() && interpreter.vm_config.paranoid_type_checks;
        let optimize_trusted_code =
            !trace_recorder.is_enabled() && interpreter.vm_config.optimize_trusted_code;
        let paranoid_ref_checks = interpreter.vm_config.paranoid_ref_checks;

        let function = Rc::new(function);
        macro_rules! execute_main {
            ($type_check:ty, $ref_check:ty) => {
                interpreter.execute_main::<$type_check, $ref_check>(
                    data_cache,
                    function_caches,
                    gas_meter,
                    traversal_context,
                    extensions,
                    trace_recorder,
                    function,
                    args,
                )
            };
        }

        // Note: we have organized the code below from most-likely config to least-likely config.
        match (
            paranoid_type_checks,
            optimize_trusted_code,
            paranoid_ref_checks,
        ) {
            (true, true, false) => execute_main!(UntrustedOnlyRuntimeTypeCheck, NoRuntimeRefCheck),
            (true, false, false) => execute_main!(FullRuntimeTypeCheck, NoRuntimeRefCheck),
            (true, true, true) => execute_main!(UntrustedOnlyRuntimeTypeCheck, FullRuntimeRefCheck),
            (true, false, true) => execute_main!(FullRuntimeTypeCheck, FullRuntimeRefCheck),
            (false, _, false) => execute_main!(NoRuntimeTypeCheck, NoRuntimeRefCheck),
            (false, _, true) => execute_main!(NoRuntimeTypeCheck, FullRuntimeRefCheck),
        }
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L220-244)
```rust
impl RuntimeTypeCheck for NoRuntimeTypeCheck {
    #[cfg_attr(feature = "force-inline", inline(always))]
    fn pre_execution_type_stack_transition(
        _frame: &Frame,
        _operand_stack: &mut Stack,
        _instruction: &Instruction,
        _ty_cache: &mut FrameTypeCache,
    ) -> PartialVMResult<()> {
        Ok(())
    }

    #[cfg_attr(feature = "force-inline", inline(always))]
    fn post_execution_type_stack_transition(
        _frame: &Frame,
        _operand_stack: &mut Stack,
        _instruction: &Instruction,
        _ty_cache: &mut FrameTypeCache,
    ) -> PartialVMResult<()> {
        Ok(())
    }

    #[cfg_attr(feature = "force-inline", inline(always))]
    fn should_perform_checks(_for_fun: &Function) -> bool {
        false
    }
```
