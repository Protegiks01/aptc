# Audit Report

## Title
Database Corruption Masking: Critical Security Events Classified as Generic Storage Errors

## Summary
The storage service error handling uniformly classifies all `AptosDbError` types—including database corruption, deserialization failures, and I/O errors—as generic `StorageErrorEncountered` errors. This prevents operators from distinguishing between benign operational errors (e.g., data not found) and critical security incidents (e.g., database corruption, active attacks), enabling attacks to proceed undetected.

## Finding Description

The `From<AptosDbError>` implementation converts all database error types into a single error variant without preserving the underlying error classification: [1](#0-0) 

This uniform conversion masks critical distinctions between error types. At the RocksDB layer, corruption errors are mapped alongside benign errors: [2](#0-1) 

Specifically, `ErrorKind::Corruption` is converted to `AptosDbError::OtherRocksDbError`, which then becomes `StorageErrorEncountered`. Similarly, BCS deserialization errors (indicating data integrity violations) and I/O errors (indicating potential disk corruption) are all treated identically.

The metrics system uses a single label for all storage errors: [3](#0-2) [4](#0-3) 

Throughout the storage service, all database errors are uniformly converted: [5](#0-4) [6](#0-5) [7](#0-6) 

The error handler converts all non-invalid-request errors to generic internal errors: [8](#0-7) 

The executor layer also treats all `AptosDbError` types uniformly: [9](#0-8) 

**Attack Scenario:**

1. Database corruption occurs (via disk failure, bit flips, filesystem attack, or targeted corruption by an attacker with node access)
2. RocksDB detects corruption and returns `ErrorKind::Corruption`
3. Converted to `AptosDbError::OtherRocksDbError`
4. Further converted to `StorageErrorEncountered` with label "storage_error"
5. Metrics show generic storage errors; operators cannot identify corruption
6. No alerts triggered for database integrity violation
7. Corrupted data may be served to peers during state sync
8. If selective corruption targets consensus-critical data, different validators may produce different results
9. Corruption spreads undetected; no restoration from backups initiated

This breaks the **State Consistency** invariant—operators cannot detect when database state is compromised, preventing timely remediation.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria: This constitutes a "significant protocol violation" because:

1. **Detection Failure**: Operators cannot distinguish database corruption from normal operational errors, preventing incident response
2. **Attack Masking**: Active attacks on database integrity appear as benign storage issues
3. **Consensus Risk**: Selective corruption of state data could cause validator divergence without triggering alerts
4. **State Poisoning**: Corrupted state values served during state sync appear as normal errors, allowing poison to spread
5. **Silent Data Loss**: Historical data corruption goes undetected until restoration attempts fail

While not directly exploitable by unprivileged external attackers, this vulnerability masks attacks already in progress and prevents detection of hardware failures or insider attacks that corrupt the database. It represents a critical gap in security monitoring and defense-in-depth.

## Likelihood Explanation

**Moderate to High Likelihood:**

- **Hardware failures** causing disk corruption occur regularly in production systems
- **Bit flips** from cosmic rays or memory errors can corrupt database files
- **Filesystem bugs** or crashes can leave databases in inconsistent states
- **Insider threats** with node access can deliberately corrupt specific data
- **Supply chain attacks** on storage hardware could introduce targeted corruption

Once corruption exists (regardless of cause), the masking occurs automatically and consistently. The likelihood of **not detecting** corruption is 100% given the current implementation.

## Recommendation

Implement error type differentiation to preserve critical error classifications:

```rust
// In state-sync/storage-service/server/src/error.rs
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
pub enum Error {
    #[error("Invalid request received: {0}")]
    InvalidRequest(String),
    #[error("Storage error encountered: {0}")]
    StorageErrorEncountered(String),
    #[error("Database corruption detected: {0}")]
    DatabaseCorruptionDetected(String),  // NEW: Critical security event
    #[error("Data integrity violation: {0}")]
    DataIntegrityViolation(String),  // NEW: Deserialization/consistency errors
    #[error("Too many invalid requests: {0}")]
    TooManyInvalidRequests(String),
    #[error("Unexpected error encountered: {0}")]
    UnexpectedErrorEncountered(String),
}

impl Error {
    pub fn get_label(&self) -> &'static str {
        match self {
            Error::InvalidRequest(_) => "invalid_request",
            Error::StorageErrorEncountered(_) => "storage_error",
            Error::DatabaseCorruptionDetected(_) => "database_corruption",  // Separate metric
            Error::DataIntegrityViolation(_) => "data_integrity_violation",
            Error::TooManyInvalidRequests(_) => "too_many_invalid_requests",
            Error::UnexpectedErrorEncountered(_) => "unexpected_error",
        }
    }
}

impl From<aptos_storage_interface::AptosDbError> for Error {
    fn from(error: aptos_storage_interface::AptosDbError) -> Self {
        // Preserve critical error classifications
        match &error {
            AptosDbError::RocksDbIncompleteResult(_) 
            | AptosDbError::OtherRocksDbError(msg) if msg.contains("Corruption") => {
                Error::DatabaseCorruptionDetected(error.to_string())
            },
            AptosDbError::BcsError(_) | AptosDbError::IoError(_) => {
                Error::DataIntegrityViolation(error.to_string())
            },
            _ => Error::StorageErrorEncountered(error.to_string()),
        }
    }
}
```

Additionally:
1. Configure alerting rules to trigger on `database_corruption` and `data_integrity_violation` metrics
2. Implement automatic node isolation when corruption is detected
3. Add structured logging with error type classification
4. Consider adding periodic database integrity checks

## Proof of Concept

```rust
// Test demonstrating corruption masking
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_storage_interface::AptosDbError;

    #[test]
    fn test_corruption_error_masking() {
        // Simulate RocksDB corruption error
        let corruption_error = AptosDbError::OtherRocksDbError(
            "Corruption: block checksum mismatch".to_string()
        );
        
        // Convert to storage service error
        let service_error: Error = corruption_error.into();
        
        // Verify it's classified as generic storage error
        assert_eq!(service_error.get_label(), "storage_error");
        
        // Demonstrate that operators cannot distinguish corruption from NotFound
        let not_found_error = AptosDbError::NotFound("state_value".to_string());
        let not_found_service_error: Error = not_found_error.into();
        
        // Both produce the same metric label
        assert_eq!(service_error.get_label(), not_found_service_error.get_label());
        
        // This proves critical database corruption cannot be monitored separately
        println!("VULNERABILITY: Database corruption masked as generic storage error");
        println!("Corruption error: {:?}", service_error);
        println!("Normal error: {:?}", not_found_service_error);
        println!("Both have label: {}", service_error.get_label());
    }
}
```

Run with: `cargo test --package aptos-storage-service-server test_corruption_error_masking`

**Notes:**

This vulnerability represents a critical gap in security observability. While it doesn't enable direct exploitation by external attackers, it masks active attacks and prevents detection of database integrity violations. The inability to distinguish corruption from normal errors means operators cannot take appropriate action (isolate nodes, restore from backups, investigate attacks) when database integrity is compromised. This could allow consensus safety violations, state poisoning, or data loss to proceed undetected.

### Citations

**File:** state-sync/storage-service/server/src/error.rs (L19-29)
```rust
impl Error {
    /// Returns a summary label for the error type
    pub fn get_label(&self) -> &'static str {
        match self {
            Error::InvalidRequest(_) => "invalid_request",
            Error::StorageErrorEncountered(_) => "storage_error",
            Error::TooManyInvalidRequests(_) => "too_many_invalid_requests",
            Error::UnexpectedErrorEncountered(_) => "unexpected_error",
        }
    }
}
```

**File:** state-sync/storage-service/server/src/error.rs (L43-47)
```rust
impl From<aptos_storage_interface::AptosDbError> for Error {
    fn from(error: aptos_storage_interface::AptosDbError) -> Self {
        Error::StorageErrorEncountered(error.to_string())
    }
}
```

**File:** storage/schemadb/src/lib.rs (L389-408)
```rust
fn to_db_err(rocksdb_err: rocksdb::Error) -> AptosDbError {
    match rocksdb_err.kind() {
        ErrorKind::Incomplete => AptosDbError::RocksDbIncompleteResult(rocksdb_err.to_string()),
        ErrorKind::NotFound
        | ErrorKind::Corruption
        | ErrorKind::NotSupported
        | ErrorKind::InvalidArgument
        | ErrorKind::IOError
        | ErrorKind::MergeInProgress
        | ErrorKind::ShutdownInProgress
        | ErrorKind::TimedOut
        | ErrorKind::Aborted
        | ErrorKind::Busy
        | ErrorKind::Expired
        | ErrorKind::TryAgain
        | ErrorKind::CompactionTooLarge
        | ErrorKind::ColumnFamilyDropped
        | ErrorKind::Unknown => AptosDbError::OtherRocksDbError(rocksdb_err.to_string()),
    }
}
```

**File:** state-sync/storage-service/server/src/metrics.rs (L104-112)
```rust
/// Counter for storage service errors encountered
pub static STORAGE_ERRORS_ENCOUNTERED: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_storage_service_server_errors",
        "Counters related to the storage server errors encountered",
        &["network_id", "error_type"]
    )
    .unwrap()
});
```

**File:** state-sync/storage-service/server/src/storage.rs (L273-275)
```rust
                Some(Err(error)) => {
                    return Err(Error::StorageErrorEncountered(error.to_string()));
                },
```

**File:** state-sync/storage-service/server/src/storage.rs (L451-456)
```rust
                Some((Err(error), _, _, _))
                | Some((_, Err(error), _, _))
                | Some((_, _, Err(error), _))
                | Some((_, _, _, Err(error))) => {
                    return Err(Error::StorageErrorEncountered(error.to_string()));
                },
```

**File:** state-sync/storage-service/server/src/storage.rs (L960-962)
```rust
                Some(Err(error)) => {
                    return Err(Error::StorageErrorEncountered(error.to_string()));
                },
```

**File:** state-sync/storage-service/server/src/handler.rs (L195-203)
```rust
        // Transform the request error into a storage service error (for the client)
        process_result.map_err(|error| match error {
            Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
            Error::TooManyInvalidRequests(error) => {
                StorageServiceError::TooManyInvalidRequests(error)
            },
            error => StorageServiceError::InternalError(error.to_string()),
        })
    }
```

**File:** execution/executor-types/src/error.rs (L53-59)
```rust
impl From<AptosDbError> for ExecutorError {
    fn from(error: AptosDbError) -> Self {
        Self::InternalError {
            error: format!("{}", error),
        }
    }
}
```
