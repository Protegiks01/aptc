# Audit Report

## Title
Private Key File Path Disclosure via Debug Logging in Node-Checker Configuration Validation

## Summary
The node-checker's configuration validation logs the complete `BaselineConfiguration` at debug level, which can expose file paths to private key files stored in the `TpsCheckerConfig`. While the actual private key values are protected by `SilentDebug`, the file system paths (`mint_file` and `coin_source_file`) are logged as plain strings, disclosing sensitive filesystem information.

## Finding Description
The node-checker component includes a validation command that logs configuration data at debug level. [1](#0-0) 

The `BaselineConfiguration` contains a `checkers` field that can include `TpsCheckerConfig`. [2](#0-1) 

The `TpsCheckerConfig` includes `CoinSourceArgs` which contains file path fields for private keys. [3](#0-2) 

These file path fields in `CoinSourceArgs` are plain `String` types that lack any Debug redaction. [4](#0-3) 

While `ConfigKey<Ed25519PrivateKey>` is protected by `SilentDebug` [5](#0-4)  which elides the actual key material [6](#0-5) , the `mint_file` and `coin_source_file` String fields are logged verbatim, exposing filesystem paths.

## Impact Explanation
This is classified as **Low severity** per Aptos bug bounty criteria (minor information leak). The disclosure is limited to:
- File paths to key material (not the keys themselves)
- Only occurs when debug logging is enabled
- Requires operator to run validation command with their own configuration
- No direct impact on consensus, funds, or network availability
- The node-checker is an ecosystem monitoring tool, not part of core blockchain execution

## Likelihood Explanation
**Low likelihood** - requires specific operator actions:
1. Operator must enable debug-level logging
2. Operator must run the validation command with a TPS checker configuration
3. Operator must use file-based key sources rather than direct key parameters
4. The leaked information is the operator's own filesystem paths on their own system

There is no remote attack vector, and the tool is designed for operator use.

## Recommendation
Implement a custom Debug trait for `CoinSourceArgs` that redacts file paths containing sensitive key material:

```rust
impl std::fmt::Debug for CoinSourceArgs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CoinSourceArgs")
            .field("mint_key", &self.mint_key.as_ref().map(|_| "<redacted>"))
            .field("mint_file", &self.mint_file.as_ref().map(|_| "<redacted path>"))
            .field("coin_source_key", &self.coin_source_key.as_ref().map(|_| "<redacted>"))
            .field("coin_source_file", &self.coin_source_file.as_ref().map(|_| "<redacted path>"))
            .finish()
    }
}
```

Alternatively, reconsider the necessity of logging complete configurations at debug level, or reduce the logging to only essential validation results.

## Proof of Concept
Create a configuration file with TPS checker:
```yaml
configuration_id: "test"
configuration_name: "Test Config"
checkers:
  - type: Tps
    common:
      required: true
    coin_source_args:
      mint_file: "/path/to/sensitive/mint_key.key"
    minimum_tps: 100
```

Run validation with debug logging:
```bash
RUST_LOG=debug cargo run --bin aptos-node-checker validate --path config.yaml
```

The debug output will display the file path `/path/to/sensitive/mint_key.key` in logs, which could be captured in log aggregation systems or exposed through operational monitoring.

## Notes
While this is a valid information disclosure issue, it has **limited security impact** because:
- It's in the ecosystem tooling, not core blockchain consensus/execution
- The operator controls both the configuration and the logging
- There's no remote exploitation vector
- The actual key material remains protected

This represents good security hygiene to implement, but does not constitute a critical vulnerability to the Aptos blockchain protocol itself.

### Citations

**File:** ecosystem/node-checker/src/configuration/validate.rs (L20-20)
```rust
    debug!("Validated configuration: {:#?}", configuration);
```

**File:** ecosystem/node-checker/src/configuration/types.rs (L36-36)
```rust
    pub checkers: Vec<CheckerConfig>,
```

**File:** ecosystem/node-checker/src/checker/tps.rs (L62-66)
```rust
    // Ed25519PrivateKey, either on the CLI or from a file, for minting coins.
    // We choose to take this in in the baseline config because we can't
    // securely transmit this at request time over the wire.
    #[serde(flatten)]
    pub coin_source_args: CoinSourceArgs,
```

**File:** crates/transaction-emitter-lib/src/args.rs (L21-36)
```rust
#[derive(Clone, Debug, Default, Deserialize, Parser, Serialize)]
pub struct CoinSourceArgs {
    /// Ed25519PrivateKey for minting coins
    #[clap(long, value_parser = ConfigKey::<Ed25519PrivateKey>::from_encoded_string)]
    pub mint_key: Option<ConfigKey<Ed25519PrivateKey>>,

    #[clap(long, conflicts_with = "mint_key")]
    pub mint_file: Option<String>,

    /// Ed25519PrivateKey for minting coins
    #[clap(long, value_parser = ConfigKey::<Ed25519PrivateKey>::from_encoded_string, conflicts_with_all = &["mint_key", "mint_file"])]
    pub coin_source_key: Option<ConfigKey<Ed25519PrivateKey>>,

    #[clap(long, conflicts_with_all = &["mint_key", "mint_file", "coin_source_key"])]
    pub coin_source_file: Option<String>,
}
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L23-23)
```rust
#[derive(DeserializeKey, SerializeKey, SilentDebug, SilentDisplay)]
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L128-143)
```rust
#[proc_macro_derive(SilentDebug)]
pub fn silent_debug(source: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(source).expect("Incorrect macro input");
    let name = &ast.ident;
    let (impl_generics, ty_generics, where_clause) = ast.generics.split_for_impl();

    quote! {
        // In order to ensure that secrets are never leaked, Debug is elided
        impl #impl_generics ::std::fmt::Debug for #name #ty_generics #where_clause {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "<elided secret for {}>", stringify!(#name))
            }
        }
    }
    .into()
}
```
