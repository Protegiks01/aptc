# Audit Report

## Title
Missing Gas Parameter Validation Enables Complete Network Halt via Malicious Gas Schedule

## Summary
Gas parameters loaded from on-chain storage lack any validation of their values. An attacker with governance control can set gas parameters to extreme values (e.g., u64::MAX or zero), causing immediate and total network halt requiring a hard fork to recover.

## Finding Description

The Aptos blockchain loads gas parameters from on-chain storage through the `GasScheduleV2` resource without validating that parameter values are within reasonable bounds. This breaks the **Resource Limits** invariant (#9) which requires "all operations must respect gas, storage, and computational limits."

### Vulnerability Location

The vulnerability exists in the gas schedule update mechanism: [1](#0-0) [2](#0-1) [3](#0-2) 

### Attack Mechanism

The deserialization macro directly converts u64 values without validation: [4](#0-3) 

Gas calculations use saturating arithmetic, so extreme values propagate: [5](#0-4) 

When a malicious gas schedule sets parameters like `min_transaction_gas_units` or `intrinsic_gas_per_byte` to u64::MAX (18,446,744,073,709,551,615), the intrinsic gas check fails for ALL transactions: [6](#0-5) 

Since the maximum allowable gas is only 2,000,000: [7](#0-6) 

Every transaction's intrinsic gas (approaching u64::MAX) vastly exceeds the user's `max_gas_amount`, causing all transactions to fail with `MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS`.

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Total loss of liveness/network availability**: Once activated, ALL transactions (including governance transactions) fail the intrinsic gas validation, completely halting the network.

2. **Non-recoverable network partition (requires hardfork)**: Normal governance cannot fix this because governance transactions also fail. Only a coordinated hard fork can restore the chain.

3. **Deterministic Execution violation**: While validators would deterministically agree that all transactions fail, the network becomes unusable.

The impact satisfies the Critical Severity criteria per the Aptos Bug Bounty program: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)."

## Likelihood Explanation

**Medium-Low Likelihood** with potentially **catastrophic impact**:

**Attack Requirements:**
- Governance access to propose and pass a malicious gas schedule update
- This typically requires either:
  - Governance compromise through stake manipulation or voting exploits
  - Malicious insider with governance privileges
  - Critical bug in governance proposal tooling generating invalid schedules

**Mitigating Factors:**
- Governance proposals undergo community review
- Multiple stakeholders must approve changes
- The trust model assumes governance participants act honestly

**Aggravating Factors:**
- TODO comments explicitly acknowledge missing validation
- No runtime checks prevent extreme values
- Accidental misconfiguration could trigger this (not just malicious intent)
- During network upgrades, human error in gas schedule generation is possible

## Recommendation

Implement comprehensive validation in the `set_for_next_epoch` and related functions:

```move
// In gas_schedule.move, replace TODO comments with actual validation:

public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD VALIDATION HERE:
    validate_gas_schedule_bounds(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

// Add new validation function:
fun validate_gas_schedule_bounds(schedule: &GasScheduleV2) {
    let i = 0;
    let len = vector::length(&schedule.entries);
    
    while (i < len) {
        let entry = vector::borrow(&schedule.entries, i);
        
        // Prevent zero values for critical parameters
        if (is_critical_nonzero_param(&entry.key)) {
            assert!(entry.val > 0, error::invalid_argument(EINVALID_GAS_SCHEDULE));
        };
        
        // Prevent extreme values (e.g., > u64::MAX / 1000)
        assert!(entry.val < 18446744073709551, error::invalid_argument(EINVALID_GAS_SCHEDULE));
        
        i = i + 1;
    };
}
```

Additionally, implement Rust-side validation in the deserialization macro: [8](#0-7) 

Add bounds checking after line 40.

## Proof of Concept

```move
#[test(framework = @aptos_framework)]
#[expected_failure(abort_code = 0x10009, location = aptos_framework::transaction_validation)]
fun test_extreme_gas_parameters_halt_network(framework: signer) {
    use std::bcs;
    use aptos_framework::gas_schedule;
    
    // Create a malicious gas schedule with extreme values
    let malicious_schedule = gas_schedule::GasScheduleV2 {
        feature_version: 100,
        entries: vector[
            gas_schedule::GasEntry {
                key: string::utf8(b"txn.min_transaction_gas_units"),
                val: 18446744073709551615, // u64::MAX
            },
            // Other required parameters with normal values...
        ],
    };
    
    // Set the malicious gas schedule
    let blob = bcs::to_bytes(&malicious_schedule);
    gas_schedule::set_for_next_epoch(&framework, blob);
    gas_schedule::on_new_epoch(&framework);
    
    // Now try to submit ANY transaction
    // It will fail because intrinsic gas (u64::MAX) > max_gas_amount (2,000,000)
    // This demonstrates complete network halt
}
```

**Rust Test Reproduction:**

```rust
#[test]
fn test_extreme_gas_causes_transaction_failure() {
    use aptos_gas_schedule::TransactionGasParameters;
    use move_core_types::gas_algebra::{InternalGas, NumBytes};
    
    // Create gas params with extreme min_transaction_gas_units
    let mut params = TransactionGasParameters::zeros();
    params.min_transaction_gas_units = InternalGas::new(u64::MAX);
    
    // Calculate intrinsic gas for a small transaction
    let txn_size = NumBytes::new(100);
    let intrinsic = params.calculate_intrinsic_gas(txn_size);
    
    // The intrinsic gas will be u64::MAX (saturated)
    // This exceeds any reasonable max_gas_amount
    assert!(u64::from(intrinsic.evaluate(0, &vm_params)) > 2_000_000);
    // Transaction would be rejected, proving network halt
}
```

## Notes

While this vulnerability requires governance access (violating the "unprivileged attacker" criterion), it represents a **critical missing validation** that could cause catastrophic failure through:

1. **Governance compromise** scenarios not covered by the trust model
2. **Accidental misconfiguration** during legitimate gas schedule updates
3. **Software bugs** in governance tooling that generate invalid schedules

The explicit TODO comments indicate the developers recognized this validation gap but never implemented it. This is a clear violation of defense-in-depth principles for a critical blockchain infrastructure component.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-48)
```text
        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-68)
```text
            // TODO(Gas): check if gas schedule is consistent
            *gas_schedule = new_gas_schedule;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L75-76)
```text
            // TODO(Gas): check if gas schedule is consistent
            move_to<GasScheduleV2>(aptos_framework, new_gas_schedule);
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L32-46)
```rust
        impl $crate::traits::FromOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
        }
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L229-231)
```rust
fn mul_impl<U1, U2>(x: GasQuantity<U2>, y: GasQuantity<UnitDiv<U1, U2>>) -> GasQuantity<U1> {
    GasQuantity::new(x.val.saturating_mul(y.val))
}
```

**File:** aptos-move/aptos-vm/src/gas.rs (L154-172)
```rust
    let intrinsic_gas = txn_gas_params
        .calculate_intrinsic_gas(raw_bytes_len)
        .evaluate(gas_feature_version, &gas_params.vm);
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
    if txn_metadata.max_gas_amount() < total_rounded {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                total_rounded,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
            None,
        ));
    }
```

**File:** config/global-constants/src/lib.rs (L30-31)
```rust
#[cfg(not(any(test, feature = "testing")))]
pub const MAX_GAS_AMOUNT: u64 = 2_000_000;
```
