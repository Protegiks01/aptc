# Audit Report

## Title
Personally Identifiable Information (IP Addresses) Collected and Stored in BigQuery Without Anonymization

## Summary
The Aptos telemetry service collects client IP addresses from HTTP headers and stores them in BigQuery without anonymization, pseudonymization, or privacy controls, potentially violating data protection regulations such as GDPR and CCPA.

## Finding Description
The telemetry service's custom event ingestion endpoint extracts client IP addresses from the `X-Forwarded-For` HTTP header and inserts them directly into telemetry event parameters before persisting the data to BigQuery. [1](#0-0) [2](#0-1) 

The IP address is stored under the key defined in constants: [3](#0-2) 

The event parameters, including the IP address, are then serialized and inserted into BigQuery: [4](#0-3) [5](#0-4) 

The telemetry data structures confirm that params is an unrestricted BTreeMap that can contain arbitrary key-value pairs: [6](#0-5) [7](#0-6) 

**What Makes This a Privacy Violation:**

1. **IP Addresses as PII**: Under GDPR Article 4(1), IP addresses are considered personal data because they can identify or help identify natural persons
2. **No Anonymization**: The full IP address is stored without truncation, hashing, or masking
3. **No Privacy Controls**: No evidence of data retention limits, deletion mechanisms, or access controls specific to PII
4. **No Consent Mechanism**: Node operators are not asked for explicit consent to collect location-identifying information
5. **Cross-Reference Risk**: Combined with other telemetry data (peer_id, chain_id, timestamps, event patterns), IP addresses enable de-anonymization and behavioral profiling

## Impact Explanation
While this issue does not directly compromise blockchain consensus, funds security, or network availability, it represents a **compliance and reputational risk**:

- **Regulatory Risk**: Potential GDPR fines up to â‚¬20 million or 4% of annual global turnover under Article 83(5)
- **Legal Liability**: CCPA violations can result in statutory damages of $100-$750 per consumer per incident
- **Reputational Damage**: Privacy violations can undermine trust in the Aptos ecosystem
- **Operational Impact**: Regulatory investigations can disrupt operations and require costly remediation

However, this does **not** meet the Aptos Bug Bounty Program's defined impact categories (Critical/High/Medium/Low), which focus specifically on blockchain security rather than privacy compliance.

## Likelihood Explanation
This issue occurs **automatically** for every custom event sent to the telemetry service. The likelihood is **100%** for all nodes using the telemetry service, as IP address collection is not optional or configurable.

## Recommendation
Implement privacy-preserving telemetry collection:

1. **IP Anonymization**: Truncate the last octet of IPv4 addresses (e.g., 192.168.1.XXX) or the last 80 bits of IPv6 addresses
2. **Privacy Policy**: Document what data is collected, why, and how long it's retained
3. **Data Retention**: Implement automated deletion of telemetry data after a defined period (e.g., 90 days)
4. **Configuration Option**: Allow node operators to opt out of IP address collection
5. **Legal Review**: Ensure compliance with GDPR, CCPA, and other applicable privacy regulations

Example anonymization implementation:
```rust
// Anonymize IPv4 by zeroing last octet, IPv6 by zeroing last 80 bits
let client_ip = forwarded_for
    .as_ref()
    .and_then(|xff| xff.split(',').next())
    .map(|ip| anonymize_ip(ip))
    .unwrap_or("UNKNOWN".to_string());

fn anonymize_ip(ip: &str) -> String {
    if let Ok(addr) = ip.parse::<std::net::IpAddr>() {
        match addr {
            std::net::IpAddr::V4(v4) => {
                let octets = v4.octets();
                format!("{}.{}.{}.0", octets[0], octets[1], octets[2])
            }
            std::net::IpAddr::V6(v6) => {
                let segments = v6.segments();
                format!("{:x}:{:x}:{:x}::", segments[0], segments[1], segments[2])
            }
        }
    } else {
        "INVALID".to_string()
    }
}
```

## Proof of Concept
This is not an exploitable vulnerability requiring a PoC, but rather a systemic privacy issue. The IP address collection can be verified by:

1. Running a telemetry service instance
2. Sending a custom event from a node with a known IP
3. Querying BigQuery to verify the IP address is stored in event_params

**Note**: This finding represents a **privacy compliance concern** rather than a traditional blockchain security vulnerability. While the PII collection is confirmed and real, it does not meet the Aptos Bug Bounty Program's defined impact categories, which focus on consensus safety, funds security, and network availability rather than data privacy regulations.

### Citations

**File:** crates/aptos-telemetry-service/src/custom_event.rs (L38-39)
```rust
        .and(warp::header::optional("X-Forwarded-For"))
        .and_then(handle_custom_event)
```

**File:** crates/aptos-telemetry-service/src/custom_event.rs (L77-85)
```rust
    let client_ip = forwarded_for
        .as_ref()
        .and_then(|xff| xff.split(',').next())
        .unwrap_or("UNKNOWN");

    let telemetry_event = &mut body.events[0];
    telemetry_event
        .params
        .insert(IP_ADDRESS_KEY.into(), client_ip.into());
```

**File:** crates/aptos-telemetry-service/src/custom_event.rs (L87-96)
```rust
    let event_params: Vec<serde_json::Value> = telemetry_event
        .params
        .iter()
        .map(|(k, v)| {
            json!({
                "key": k,
                "value": v
            })
        })
        .collect();
```

**File:** crates/aptos-telemetry-service/src/custom_event.rs (L105-150)
```rust
    let row = BigQueryRow {
        event_identity: EventIdentity::from(claims),
        event_name: telemetry_event.name.clone(),
        event_timestamp: duration.as_secs(),
        event_params,
    };

    insert_request.add_row(None, &row).map_err(|e| {
        error!("unable to create row: {}", e);
        ServiceError::internal(CustomEventIngestError::from(e).into())
    })?;

    let start_timer = Instant::now();

    context
        .bigquery_client()
        .ok_or_else(|| {
            error!("big query client is not configured");
            ServiceError::internal(
                CustomEventIngestError::from(anyhow!("BQ client is not configured")).into(),
            )
        })?
        .insert_all(insert_request)
        .await
        .map_err(|e| {
            BIG_QUERY_BACKEND_REQUEST_DURATION
                .with_label_values(&["request_error"])
                .observe(start_timer.elapsed().as_millis() as f64);
            error!("unable to insert row into bigquery: {}", e);
            ServiceError::internal(CustomEventIngestError::from(e).into())
        })
        .and_then(|result| {
            if let Some(err) = result.insert_errors {
                BIG_QUERY_BACKEND_REQUEST_DURATION
                    .with_label_values(&["insert_error"])
                    .observe(start_timer.elapsed().as_secs_f64());
                Err(ServiceError::bad_request(
                    CustomEventIngestError::from(err[0].clone()).into(),
                ))
            } else {
                BIG_QUERY_BACKEND_REQUEST_DURATION
                    .with_label_values(&["success"])
                    .observe(start_timer.elapsed().as_secs_f64());
                Ok(result)
            }
        })?;
```

**File:** crates/aptos-telemetry-service/src/constants.rs (L20-21)
```rust
/// The IP address key
pub const IP_ADDRESS_KEY: &str = "IP_ADDRESS";
```

**File:** crates/aptos-telemetry-service/src/types/telemetry.rs (L8-13)
```rust
/// A useful struct for serialization a telemetry event
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TelemetryEvent {
    pub name: String,
    pub params: BTreeMap<String, String>,
}
```

**File:** crates/aptos-telemetry-service/src/types/telemetry.rs (L24-31)
```rust
#[derive(Debug, Serialize, Clone)]
pub(crate) struct BigQueryRow {
    #[serde(flatten)]
    pub event_identity: EventIdentity,
    pub event_name: String,
    pub event_timestamp: u64,
    pub event_params: Vec<serde_json::Value>,
}
```
