# Audit Report

## Title
Missing Cryptographic Verification of Eval Proofs Breaks Decryption Accountability

## Summary
The `eval_proof` field in `EncryptedPayload` is never cryptographically verified against the digest commitment. While verification methods exist (`DigestKey::verify()`, `verify_pf()`, `verify_all()`), they are never called in the production consensus or execution pipeline. This allows validators to provide arbitrary eval_proof bytes without cryptographic validation, breaking the accountability guarantee for encrypted transaction decryption.

## Finding Description
The `EncryptedPayload` enum stores `eval_proof` in both `Decrypted` and `FailedDecryption` variants to provide cryptographic accountability for decryption results. The `eval_proof` is a KZG opening proof that should prove the ciphertext was correctly evaluated at a specific point. [1](#0-0) 

The batch encryption library provides verification methods for eval proofs: [2](#0-1) 

However, these verification methods are **never called in production code**. In the decryption pipeline, eval_proofs are computed and used, but never verified: [3](#0-2) 

The `prepare_individual()` method uses the eval_proof in a pairing computation without verifying it: [4](#0-3) 

The `EncryptedPayload::verify()` method only verifies the ciphertext, not the eval_proof: [5](#0-4) 

**Attack Scenario:**
While validators compute their own eval_proofs during consensus (making live attacks impractical), the lack of verification breaks post-hoc accountability. A compromised validator could:
1. Store incorrect eval_proofs in transaction state
2. Provide false evidence about decryption failures
3. Hide evidence of malicious decryption attempts

Since eval_proofs are stored on-chain but never verified, they cannot serve their intended accountability purpose.

## Impact Explanation
This is a **Medium severity** issue rather than Critical because:
- It does NOT break consensus safety (all validators compute independent eval_proofs)
- It does NOT enable fund theft or unauthorized access
- It DOES break accountability and auditability guarantees
- It prevents forensic analysis of decryption failures

The issue violates the **Cryptographic Correctness** invariant: "hash operations must be secure" and the accountability guarantee implied by storing eval_proofs.

## Likelihood Explanation
**High likelihood** for accountability failures. Every encrypted transaction includes an eval_proof that is never verified, meaning the accountability mechanism is completely non-functional. While this doesn't enable direct attacks during consensus (due to independent computation), it means:
- Auditors cannot verify historical decryption claims
- Compromised validators can falsify evidence
- Dispute resolution around decryption failures is impossible

## Recommendation
Add explicit eval_proof verification in the consensus pipeline and when validating blocks:

```rust
// In decryption_pipeline_builder.rs, after computing proofs:
let proofs = FPTXWeighted::eval_proofs_compute_all(&proofs_promise, &digest_key);

// ADD: Verify all eval proofs
digest_key.verify_all(&digest, &proofs)
    .context("Eval proof verification failed")?;

// In encrypted_payload.rs, enhance verify() method:
pub fn verify(&self, sender: AccountAddress, digest_key: &DigestKey) -> anyhow::Result<()> {
    let associated_data = PayloadAssociatedData::new(sender);
    self.ciphertext().verify(&associated_data)?;
    
    // Verify eval_proof if in Decrypted or FailedDecryption state
    match self {
        Self::Decrypted { eval_proof, ciphertext, .. } |
        Self::FailedDecryption { eval_proof, ciphertext, .. } => {
            // Need digest from metadata to verify
            // digest_key.verify(&digest, eval_proof, ciphertext.id())?;
        },
        _ => {},
    }
    Ok(())
}
```

Note: Full implementation requires passing digest metadata through the verification chain.

## Proof of Concept
Test demonstrating that verification methods exist but are never used:

```rust
// This test would pass, showing the vulnerability exists
#[test]
fn test_eval_proof_never_verified() {
    // Create a fake eval_proof
    let fake_proof = EvalProof::random(); // Random G1 point
    
    // Create EncryptedPayload with fake proof
    let payload = EncryptedPayload::Decrypted {
        ciphertext: Ciphertext::random(),
        extra_config: TransactionExtraConfig::V1 {
            multisig_address: None,
            replay_protection_nonce: None,
        },
        payload_hash: HashValue::random(),
        eval_proof: fake_proof, // FAKE proof
        executable: TransactionExecutable::Empty,
        decryption_nonce: 0,
    };
    
    // Verify passes - it doesn't check eval_proof!
    assert!(payload.verify(AccountAddress::random()).is_ok());
    
    // Proof: search entire codebase shows DigestKey::verify() 
    // is never called on eval_proofs in production code
}
``` [6](#0-5) 

**Notes:**
- The test utility creates transactions with random eval_proofs, showing they're not validated
- Grep search confirms `verify_pf()` and `verify_all()` only appear in test files
- Production code path through `prepare_individual()` uses but never verifies eval_proofs

### Citations

**File:** types/src/transaction/encrypted_payload.rs (L48-63)
```rust
    FailedDecryption {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,
    },
    Decrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,

        // decrypted things
        executable: TransactionExecutable,
        decryption_nonce: u64,
    },
```

**File:** types/src/transaction/encrypted_payload.rs (L147-150)
```rust
    pub fn verify(&self, sender: AccountAddress) -> anyhow::Result<()> {
        let associated_data = PayloadAssociatedData::new(sender);
        self.ciphertext().verify(&associated_data)
    }
```

**File:** crates/aptos-batch-encryption/src/shared/digest.rs (L138-157)
```rust
    fn verify_pf(&self, digest: &Digest, id: Id, pf: G1Affine) -> Result<()> {
        // TODO use multipairing here?
        Ok((PairingSetting::pairing(
            pf,
            self.tau_g2 - G2Projective::from(G2Affine::generator() * id.x()),
        ) == PairingSetting::pairing(digest.as_g1(), G2Affine::generator()))
        .then_some(())
        .ok_or(BatchEncryptionError::EvalProofVerifyError)?)
    }

    pub fn verify(&self, digest: &Digest, pfs: &EvalProofs, id: Id) -> Result<()> {
        let pf = pfs.computed_proofs[&id];
        self.verify_pf(digest, id, pf)
    }

    pub fn verify_all(&self, digest: &Digest, pfs: &EvalProofs) -> Result<()> {
        pfs.computed_proofs
            .iter()
            .try_for_each(|(id, pf)| self.verify_pf(digest, *id, *pf))
    }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L113-148)
```rust
        let proofs = FPTXWeighted::eval_proofs_compute_all(&proofs_promise, &digest_key);

        let maybe_decryption_key = secret_shared_key_rx
            .await
            .expect("decryption key should be available");
        // TODO(ibalajiarun): account for the case where decryption key is not available
        let decryption_key = maybe_decryption_key.expect("decryption key should be available");

        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L92-106)
```rust
    fn prepare_individual(
        &self,
        digest: &Digest,
        eval_proof: &EvalProof,
    ) -> Result<PreparedBIBECiphertext> {
        let pairing_output = PairingSetting::pairing(digest.as_g1(), self.ct_g2[0])
            + PairingSetting::pairing(**eval_proof, self.ct_g2[1]);

        Ok(PreparedBIBECiphertext {
            pairing_output,
            ct_g2: self.ct_g2[2].into(),
            padded_key: self.padded_key.clone(),
            symmetric_ciphertext: self.symmetric_ciphertext.clone(),
        })
    }
```

**File:** crates/aptos-transaction-filters/src/tests/utils.rs (L68-99)
```rust
pub fn create_encrypted_transaction_failed_state() -> SignedTransaction {
    let encrypted_payload = EncryptedPayload::FailedDecryption {
        ciphertext: Ciphertext::random(),
        extra_config: TransactionExtraConfig::V1 {
            multisig_address: None,
            replay_protection_nonce: None,
        },
        payload_hash: HashValue::random(),
        eval_proof: EvalProof::random(),
    };

    let transaction_payload = TransactionPayload::EncryptedPayload(encrypted_payload);
    create_signed_transaction(transaction_payload, false)
}

/// Creates and returns an encrypted transaction in a plaintext state
pub fn create_encrypted_transaction_plaintext_state() -> SignedTransaction {
    let encrypted_payload = EncryptedPayload::Decrypted {
        ciphertext: Ciphertext::random(),
        extra_config: TransactionExtraConfig::V1 {
            multisig_address: None,
            replay_protection_nonce: None,
        },
        payload_hash: HashValue::random(),
        eval_proof: EvalProof::random(),
        executable: TransactionExecutable::Empty,
        decryption_nonce: 0,
    };

    let transaction_payload = TransactionPayload::EncryptedPayload(encrypted_payload);
    create_signed_transaction(transaction_payload, false)
}
```
