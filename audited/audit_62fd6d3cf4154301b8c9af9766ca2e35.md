# Audit Report

## Title
Banned Peer Ban Bypass Through Connection Cycling in Storage Service Request Moderator

## Summary
The storage service request moderator's garbage collection mechanism removes disconnected peers from the unhealthy peer tracking map, allowing banned peers to bypass exponential backoff restrictions by disconnecting and reconnecting. This affects all handler instances sharing the same `Arc<RequestModerator>` and enables persistent DoS attacks.

## Finding Description

The storage service implements a request moderator to prevent misbehaving peers from overwhelming the system with invalid requests. When a peer sends too many invalid requests, they are "ignored" for an exponentially increasing duration. However, the garbage collection logic in `refresh_unhealthy_peer_states` completely removes disconnected peers from the tracking map, resetting their ban state.

**Architecture Overview:**

All handler instances share the same `Arc<RequestModerator>` instance [1](#0-0) , which contains an `Arc<DashMap<PeerNetworkId, UnhealthyPeerState>>` [2](#0-1) . This means any corruption or manipulation of the moderator's internal state affects every handler processing requests.

**The Vulnerability:**

The `refresh_unhealthy_peer_states` method runs periodically (every 1 second by default [3](#0-2) ) and uses a `retain` operation to garbage collect disconnected peers [4](#0-3) . When a peer is not in the connected peers list, their entry is completely removed, including their ban status and exponential backoff timer.

**Attack Scenario:**

1. Malicious peer sends 500 invalid requests (default `max_invalid_requests_per_peer` [5](#0-4) )
2. Peer gets banned with `ignore_start_time` set, should wait 5 minutes [6](#0-5) 
3. Attacker disconnects their connection
4. Within 1 second, the refresh task removes them from `unhealthy_peer_states` because they're no longer in `connected_peers_and_metadata`
5. Attacker reconnects with a clean slate
6. Validation check at request time finds no entry in the map [7](#0-6) , so requests proceed normally
7. Repeat: send another 500 invalid requests before being banned again

This completely bypasses the exponential backoff mechanism [8](#0-7)  that doubles the ignore duration with each violation.

## Impact Explanation

**Severity: HIGH** (Validator node slowdowns / DoS)

This vulnerability enables a persistent Denial-of-Service attack against storage service validators:

- **Resource Exhaustion**: An attacker can send 500 invalid requests per second by cycling connections, forcing validators to repeatedly validate unsatisfiable requests
- **CPU/Storage DoS**: Each invalid request requires database queries and validation logic, consuming CPU and I/O resources
- **Network-Wide Impact**: Multiple coordinated attackers could severely degrade network performance
- **Affects All Handlers**: Because all handlers share the same `Arc<RequestModerator>` [9](#0-8) , the reset state affects every request processing thread

While this doesn't directly cause consensus violations or fund loss, it qualifies as **High Severity** under the "Validator node slowdowns" category, as it can significantly impair validator performance and state synchronization capabilities.

## Likelihood Explanation

**Likelihood: HIGH**

- **Ease of Exploitation**: Attacker only needs to disconnect/reconnect their network connection, which is trivial to automate
- **No Special Privileges**: Any public fullnode (PFN) peer can execute this attack
- **Low Detection**: The behavior appears as normal peer churn to the network
- **Confirmed by Tests**: The test suite explicitly demonstrates this behavior [10](#0-9) , showing that disconnected banned peers are garbage collected

The attack is practically guaranteed to work because:
1. The refresh interval is only 1 second
2. No persistent ban tracking exists across connections
3. Only public network peers are ignored [11](#0-10) , but this makes them the primary attack vector

## Recommendation

**Solution 1: Persistent Ban Tracking (Recommended)**

Modify the garbage collection logic to preserve ban state for recently disconnected peers:

```rust
// In moderator.rs refresh_unhealthy_peer_states method
self.unhealthy_peer_states.retain(|peer_network_id, unhealthy_peer_state| {
    if connected_peers_and_metadata.contains_key(peer_network_id) {
        // Peer is still connected - refresh and keep
        unhealthy_peer_state.refresh_peer_state(peer_network_id);
        true
    } else {
        // Peer disconnected - only remove if not currently ignored OR
        // enough time has passed since they should have been unblocked
        if unhealthy_peer_state.is_ignored() {
            // Keep banned peers for the full ban duration even if disconnected
            unhealthy_peer_state.refresh_peer_state(peer_network_id);
            unhealthy_peer_state.is_ignored() // Keep if still ignored after refresh
        } else {
            false // Not ignored, safe to remove
        }
    }
});
```

**Solution 2: Connection-ID Based Tracking**

Track bans by `(PeerNetworkId, ConnectionId)` tuple instead of just `PeerNetworkId`, so reconnections don't share the same entry. However, this is more complex to implement correctly.

**Solution 3: Rate Limiting by Peer Identity**

Implement additional rate limiting at the peer identity level (using cryptographic peer ID) that persists across connections.

## Proof of Concept

```rust
// Test demonstrating the ban bypass vulnerability
#[tokio::test]
async fn test_banned_peer_bypass_via_reconnection() {
    // Setup storage service with default config
    let (mut mock_client, mut service, _) = MockClient::new(None, None).await;
    let request_moderator = service.get_request_moderator();
    let unhealthy_peer_states = request_moderator.get_unhealthy_peer_states();
    
    // Create malicious peer
    let attacker_peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    let highest_synced_version = 1000;
    
    // Attack iteration 1: Send invalid requests until banned
    for i in 0..500 {
        send_invalid_transaction_request(
            highest_synced_version,
            &mut mock_client,
            attacker_peer,
        ).await.unwrap_err();
    }
    
    // Verify peer is banned
    assert!(unhealthy_peer_states.get(&attacker_peer).unwrap().is_ignored());
    
    // Attacker disconnects
    peers_and_metadata.remove_peer_metadata(attacker_peer, ConnectionId::from(1)).unwrap();
    
    // Wait for garbage collection (1 second refresh interval)
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    // Verify ban was cleared (VULNERABILITY!)
    assert!(!unhealthy_peer_states.contains_key(&attacker_peer));
    
    // Attacker reconnects with new connection
    peers_and_metadata.insert_connection_metadata(
        attacker_peer,
        create_connection_metadata(attacker_peer.peer_id(), 2)
    ).unwrap();
    
    // Attack iteration 2: Can send another 500 invalid requests immediately
    // without waiting for the 5 minute ban period
    for i in 0..500 {
        send_invalid_transaction_request(
            highest_synced_version,
            &mut mock_client,
            attacker_peer,
        ).await.unwrap_err();
    }
    
    // Attacker was able to send 1000 invalid requests in ~2 seconds
    // instead of being banned for 5 minutes after the first 500
    println!("Ban bypass successful - exponential backoff completely circumvented");
}
```

## Notes

This vulnerability is particularly concerning because:

1. **Shared State Corruption**: The question asks if moderator state corruption affects all handler instances - YES, because all handlers share the same `Arc<RequestModerator>`, any manipulation of the underlying `unhealthy_peer_states` DashMap affects every request handler thread simultaneously.

2. **Intentional Design Flaw**: The garbage collection behavior appears intentional (as evidenced by test coverage) but fails to consider the security implications of allowing banned peers to reset their state through disconnection.

3. **Public Network Only**: While the ban mechanism only applies to public network peers [11](#0-10) , this actually makes the attack more accessible since anyone can connect as a public fullnode.

4. **No Integer Overflow**: While investigating, I also checked for integer overflow in the exponential backoff mechanism [12](#0-11) , but this would take decades to trigger and is impractical compared to the connection cycling attack.

### Citations

**File:** state-sync/storage-service/server/src/handler.rs (L53-53)
```rust
    request_moderator: Arc<RequestModerator>,
```

**File:** state-sync/storage-service/server/src/moderator.rs (L55-62)
```rust
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());
```

**File:** state-sync/storage-service/server/src/moderator.rs (L89-90)
```rust
                // Double the min time to ignore the peer
                self.min_time_to_ignore_secs *= 2;
```

**File:** state-sync/storage-service/server/src/moderator.rs (L111-111)
```rust
    unhealthy_peer_states: Arc<DashMap<PeerNetworkId, UnhealthyPeerState>>,
```

**File:** state-sync/storage-service/server/src/moderator.rs (L142-149)
```rust
            if let Some(peer_state) = self.unhealthy_peer_states.get(peer_network_id) {
                if peer_state.is_ignored() {
                    return Err(Error::TooManyInvalidRequests(format!(
                        "Peer is temporarily ignored. Unable to handle request: {:?}",
                        request
                    )));
                }
            }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L213-228)
```rust
        self.unhealthy_peer_states
            .retain(|peer_network_id, unhealthy_peer_state| {
                if connected_peers_and_metadata.contains_key(peer_network_id) {
                    // Refresh the ignored peer state
                    unhealthy_peer_state.refresh_peer_state(peer_network_id);

                    // If the peer is ignored, increment the ignored peer count
                    if unhealthy_peer_state.is_ignored() {
                        num_ignored_peers += 1;
                    }

                    true // The peer is still connected, so we should keep it
                } else {
                    false // The peer is no longer connected, so we should remove it
                }
            });
```

**File:** config/src/config/state_sync_config.rs (L201-201)
```rust
            max_invalid_requests_per_peer: 500,
```

**File:** config/src/config/state_sync_config.rs (L214-214)
```rust
            request_moderator_refresh_interval_ms: 1000, // 1 second
```

**File:** state-sync/storage-service/server/src/lib.rs (L399-409)
```rust
            let request_moderator = self.request_moderator.clone();
            let time_service = self.time_service.clone();
            self.runtime.spawn_blocking(move || {
                Handler::new(
                    cached_storage_server_summary,
                    optimistic_fetches,
                    lru_response_cache,
                    request_moderator,
                    storage,
                    subscriptions,
                    time_service,
```

**File:** state-sync/storage-service/server/src/tests/request_moderator.rs (L338-352)
```rust
    // Disconnect the third peer
    peers_and_metadata
        .remove_peer_metadata(peer_network_ids[2], ConnectionId::from(2))
        .unwrap();

    // Elapse enough time for the peer monitor loop to garbage collect the peer
    wait_for_request_moderator_to_garbage_collect(
        unhealthy_peer_states.clone(),
        &time_service,
        &peer_network_ids[2],
    )
    .await;

    // Verify that the peer is no longer being tracked
    assert!(!unhealthy_peer_states.contains_key(&peer_network_ids[2]));
```
