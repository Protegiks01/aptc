# Audit Report

## Title
Gas Metering Bypass via Module Bundle Deserialization - Under-Priced Per-Module Computation

## Summary
The Aptos VM performs expensive per-module deserialization work **before** charging gas for the per-module overhead, allowing attackers to submit module bundles with thousands of small modules to execute under-priced computation and cause validator node slowdowns.

## Finding Description

The vulnerability exists in the module publishing flow where gas charging occurs **after** expensive deserialization operations, breaking the invariant that "all operations must respect gas, storage, and computational limits."

**Attack Flow:**

1. `ModuleBundle::new()` creates a bundle structure without any validation or gas checks [1](#0-0) 

2. The native function `native_request_publish` charges gas based only on a base fee plus per-byte charges, with **no per-module overhead**: [2](#0-1) 

   The gas parameters are:
   - `CODE_REQUEST_PUBLISH_BASE`: 1,838 internal gas units (once per request)
   - `CODE_REQUEST_PUBLISH_PER_BYTE`: 7 internal gas units per byte [3](#0-2) 

3. Later, in `resolve_pending_code_publish_and_finish_user_session`, the VM deserializes **all modules in the bundle** via `deserialize_module_bundle()` **before** any per-module gas charging occurs: [4](#0-3) 

4. The deserialization function loops through each module, calling `CompiledModule::deserialize_with_config()` - an expensive operation involving binary format parsing, table reading, and bounds checking: [5](#0-4) 

5. **Only after** deserialization completes, the VM attempts to charge per-module dependency gas: [6](#0-5) 

   This charges `DEPENDENCY_PER_MODULE` (74,460 units) + `DEPENDENCY_PER_BYTE` (42 units per byte) for each module: [7](#0-6) 

   With values: [8](#0-7) 

**The Vulnerability:** An attacker can submit a bundle with N small modules (e.g., 5,000 modules of 50 bytes each):
- Gas charged in native function: 1,838 + (5,000 × 50 × 7) = **1,751,838 units**
- Deserialization work performed: **5,000 × deserialization_cost_per_module** (expensive CPU work!)
- Gas that **should** be charged after: 5,000 × 74,460 + (250,000 × 42) = **382,800,000 units**

If the transaction has insufficient gas for the dependency charging phase, it aborts - but the CPU-intensive deserialization work at line 1491 was **already executed** before the gas check.

## Impact Explanation

**Severity: High** - Validator node slowdowns due to under-priced computation.

This vulnerability allows attackers to:
1. Submit transactions that consume significant validator CPU resources during module deserialization
2. Pay minimal gas (only per-byte charges without per-module overhead)
3. Force all validators to perform expensive deserialization work before realizing insufficient gas was paid
4. Repeat attacks cheaply to sustain validator resource exhaustion

Each malicious transaction can deserialize thousands of modules (limited only by transaction size limits), each requiring binary format parsing, structure validation, and bounds checking - all happening **before** proper gas metering occurs.

According to the Aptos bug bounty criteria, this qualifies as **High Severity** because it enables "validator node slowdowns" through systematically under-priced computation.

## Likelihood Explanation

**Likelihood: High**

The attack is:
- **Trivial to execute**: Any user can submit a transaction with a module bundle
- **Low cost**: Attacker only pays for bytes (~7 gas units per byte) instead of per-module overhead (~74,460 gas units per module)
- **High amplification**: A 250KB transaction (5,000 modules × 50 bytes) pays ~1.75M gas but causes work worth ~382M gas
- **No special privileges required**: Standard transaction submission
- **Repeatable**: Attacker can submit multiple transactions to sustain the attack

The minimum viable module can be constructed using the `empty_module()` pattern: [9](#0-8) 

## Recommendation

**Solution: Charge per-module overhead BEFORE deserialization, not after.**

1. **Immediate fix**: Add a per-module gas charge in `native_request_publish` before creating the ModuleBundle:

```rust
fn native_request_publish(
    context: &mut SafeNativeContext,
    ...
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    context.charge(CODE_REQUEST_PUBLISH_BASE)?;
    
    let policy = safely_pop_arg!(args, u8);
    let mut code = vec![];
    for module in safely_pop_arg!(args, Vec<Value>) {
        let module_code = module.value_as::<Vec<u8>>()?;
        
        // NEW: Charge per-module overhead upfront
        context.charge(CODE_REQUEST_PUBLISH_PER_MODULE)?;
        
        // Existing: per-byte charge
        context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(module_code.len() as u64))?;
        code.push(module_code);
    }
    // ... rest of function
}
```

Add a new gas parameter `CODE_REQUEST_PUBLISH_PER_MODULE` with a value that covers the deserialization cost (suggested: ~74,460 to match `DEPENDENCY_PER_MODULE`).

2. **Defense in depth**: Add an explicit limit on the number of modules per bundle (suggested: 256 modules maximum) in the native function validation.

3. **Alternative approach**: Move deserialization inside a try-charge pattern where gas is pre-charged based on bundle size, then refunded if actual work is less.

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the attack pattern

use aptos_types::transaction::ModuleBundle;
use move_binary_format::file_format::empty_module;

fn exploit_gas_metering_bypass() {
    // Step 1: Create many small modules
    let num_modules = 5000;
    let mut module_bytecodes = vec![];
    
    for i in 0..num_modules {
        let mut module = empty_module();
        // Modify module name to make it unique
        module.identifiers[0] = format!("Module{}", i).parse().unwrap();
        
        let mut bytecode = vec![];
        module.serialize(&mut bytecode).unwrap();
        module_bytecodes.push(bytecode);
    }
    
    // Step 2: Create ModuleBundle
    let bundle = ModuleBundle::new(module_bytecodes);
    
    // Step 3: Submit transaction with minimal gas
    // Gas paid in native function: ~1,838 + (5000 * 50 * 7) = ~1.75M units
    // Actual work performed: 5000 * deserialization_overhead = very expensive!
    // Gas that should be charged: 5000 * 74,460 = ~372M units
    
    // Result: Transaction fails during dependency gas charging phase,
    // but validator has already performed all deserialization work!
    
    // Step 4: Repeat to sustain validator resource exhaustion
}
```

**Reproduction steps:**
1. Create a transaction payload with `code::request_publish` containing 5,000 minimal modules
2. Set transaction gas limit to ~2M units (enough for native function, insufficient for dependencies)
3. Submit transaction
4. Observe: Transaction fails with OUT_OF_GAS during dependency charging
5. Measure: Validator CPU time spent on deserialization before gas check
6. Repeat: Submit multiple such transactions to sustain resource exhaustion

**Notes**

The vulnerability is gated by gas feature version >= 15 (RELEASE_V1_10) for the per-module dependency charging to even be attempted. Prior to version 15, there was **no** per-module charge at all, making the undercharging even worse. Current mainnet runs version 45, so the dependency charging exists but occurs too late (after deserialization).

The core issue is a time-of-check-time-of-use (TOCTOU) pattern where expensive work (deserialization) happens before the resource check (gas charging). This violates the gas metering invariant that computation should be charged **before** or **during** execution, not after.

### Citations

**File:** types/src/transaction/module.rs (L42-46)
```rust
    pub fn new(codes: Vec<Vec<u8>>) -> ModuleBundle {
        ModuleBundle {
            codes: codes.into_iter().map(Module::new).collect(),
        }
    }
```

**File:** aptos-move/framework/src/natives/code.rs (L292-301)
```rust
    context.charge(CODE_REQUEST_PUBLISH_BASE)?;

    let policy = safely_pop_arg!(args, u8);
    let mut code = vec![];
    for module in safely_pop_arg!(args, Vec<Value>) {
        let module_code = module.value_as::<Vec<u8>>()?;

        context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(module_code.len() as u64))?;
        code.push(module_code);
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L320-321)
```rust
        [code_request_publish_base: InternalGas, "code.request_publish.base", 1838],
        [code_request_publish_per_byte: InternalGasPerByte, "code.request_publish.per_byte", 7],
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1444-1461)
```rust
    fn deserialize_module_bundle(&self, modules: &ModuleBundle) -> VMResult<Vec<CompiledModule>> {
        let mut result = vec![];
        for module_blob in modules.iter() {
            match CompiledModule::deserialize_with_config(
                module_blob.code(),
                self.deserializer_config(),
            ) {
                Ok(module) => {
                    result.push(module);
                },
                Err(_err) => {
                    return Err(PartialVMError::new(StatusCode::CODE_DESERIALIZATION_ERROR)
                        .finish(Location::Undefined))
                },
            }
        }
        Ok(result)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1491-1493)
```rust
        let modules = self.deserialize_module_bundle(&bundle)?;
        let modules: &Vec<CompiledModule> =
            traversal_context.referenced_module_bundles.alloc(modules);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1498-1543)
```rust
        if self.gas_feature_version() >= RELEASE_V1_10 {
            // Charge old versions of existing modules, in case of upgrades.
            for module in modules.iter() {
                let addr = module.self_addr();
                let name = module.self_name();

                if !traversal_context.visit_if_not_special_address(addr, name) {
                    continue;
                }

                let size_if_old_module_exists = module_storage
                    .unmetered_get_module_size(addr, name)?
                    .map(|v| v as u64);
                if let Some(old_size) = size_if_old_module_exists {
                    gas_meter
                        .charge_dependency(
                            DependencyKind::Existing,
                            addr,
                            name,
                            NumBytes::new(old_size),
                        )
                        .map_err(|err| {
                            err.finish(Location::Module(ModuleId::new(*addr, name.to_owned())))
                        })?;
                }
            }

            // Charge all modules in the bundle that is about to be published.
            for (module, blob) in modules.iter().zip(bundle.iter()) {
                let addr = module.self_addr();
                let name = module.self_name();
                gas_meter
                    .charge_dependency(
                        DependencyKind::New,
                        addr,
                        name,
                        NumBytes::new(blob.code().len() as u64),
                    )
                    .map_err(|err| err.finish(Location::Undefined))?;

                // In case of lazy loading: add all modules in a bundle as visited to avoid double
                // charging during module initialization.
                if self.features().is_lazy_loading_enabled() {
                    traversal_context.visit_if_not_special_address(addr, name);
                }
            }
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L70-73)
```rust
        if self.feature_version() >= 15 && !addr.is_special() {
            self.algebra
                .charge_execution(DEPENDENCY_PER_MODULE + DEPENDENCY_PER_BYTE * size)?;
            self.algebra.count_dependency(size)?;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L241-249)
```rust
            dependency_per_module: InternalGas,
            { RELEASE_V1_10.. => "dependency_per_module" },
            74460,
        ],
        [
            dependency_per_byte: InternalGasPerByte,
            { RELEASE_V1_10.. => "dependency_per_byte" },
            42,
        ],
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L3677-3704)
```rust
pub fn empty_module() -> CompiledModule {
    CompiledModule {
        version: file_format_common::VERSION_MAX,
        module_handles: vec![ModuleHandle {
            address: AddressIdentifierIndex(0),
            name: IdentifierIndex(0),
        }],
        self_module_handle_idx: ModuleHandleIndex(0),
        identifiers: vec![self_module_name().to_owned()],
        address_identifiers: vec![AccountAddress::ZERO],
        constant_pool: vec![],
        metadata: vec![],
        function_defs: vec![],
        struct_defs: vec![],
        struct_handles: vec![],
        function_handles: vec![],
        field_handles: vec![],
        friend_decls: vec![],
        struct_def_instantiations: vec![],
        function_instantiations: vec![],
        field_instantiations: vec![],
        signatures: vec![Signature(vec![])],
        struct_variant_handles: vec![],
        struct_variant_instantiations: vec![],
        variant_field_handles: vec![],
        variant_field_instantiations: vec![],
    }
}
```
