# Audit Report

## Title
Memory Tracking Bypass Exploitation Window in Table Natives Before FixMemoryUsageTracking Activation

## Summary
The `FixMemoryUsageTracking` timed feature flag addresses a critical memory tracking vulnerability in table native functions. However, this appears to be a **known issue** with a scheduled fix rather than a new vulnerability discovery. The exploitation window between code deployment and feature activation (March 7-11, 2025) is real but intentionally managed through Aptos's timed feature system.

## Finding Description

The vulnerability exists in the memory tracking mechanism for table native operations. When `FixMemoryUsageTracking` is disabled, the `use_heap_memory` function performs no actual memory tracking: [1](#0-0) [2](#0-1) 

The feature activation is scheduled for: [3](#0-2) 

During the window before activation, attackers can:

1. **Create deeply nested structures** in tables that would normally exceed the 10MB memory quota [4](#0-3) 

2. **Bypass memory limits** because `use_heap_memory` returns immediately without tracking when the feature is disabled

3. **Persist malicious state** - these entries remain in storage even after feature activation

4. **Cause post-activation DoS** - accessing these entries after activation triggers MEMORY_LIMIT_EXCEEDED errors

The test suite explicitly validates this behavior: [5](#0-4) 

## Impact Explanation

**This issue fails the validation criterion: "Not a known issue from previous security audits"**

The existence of:
- A specifically named feature flag (`FixMemoryUsageTracking`)
- Explicit comments documenting the bug being fixed
- Scheduled activation dates
- Test coverage validating the fix

All indicate this is a **known and managed vulnerability** rather than a new discovery. The Aptos team has intentionally chosen to deploy the fix with a delayed activation, likely to allow coordinated network upgrade and testing.

While the technical vulnerability is real and exploitable during the window, reporting this as a "new finding" would be misleading since the team is clearly aware and has a mitigation timeline.

## Likelihood Explanation

The exploitation is straightforward - any user can deploy contracts that create deeply nested table entries during the vulnerable window. However, the managed rollout suggests this risk has been accepted by the Aptos team as part of their feature deployment strategy.

## Recommendation

This is not a new vulnerability requiring a fix - it's a known issue with a scheduled resolution. The concern about the exploitation window is valid, but this is an operational/deployment strategy question rather than a code vulnerability discovery.

If there are concerns about the activation delay, the recommendation would be to:
1. Accelerate the feature activation timeline if possible
2. Implement monitoring for suspicious table operations creating deeply nested structures
3. Consider emergency activation procedures if exploitation is detected

## Proof of Concept

The proof of concept already exists in the test suite and demonstrates the issue comprehensively. [6](#0-5) 

---

## Notes

While the vulnerability is technically exploitable during the window before activation, this fails the validation criterion requiring findings to be "not a known issue." The timed feature flag system is Aptos's chosen mechanism for managing this type of security fix deployment, and the team has clearly identified and scheduled the fix. This represents a deployment strategy decision rather than an undiscovered vulnerability.

**Answer to the security question**: YES, attackers CAN exploit the window before activation, but this is a known and managed risk rather than a new vulnerability discovery.

### Citations

**File:** types/src/on_chain_config/timed_features.rs (L20-21)
```rust
    // Fixes the bug of table natives not tracking the memory usage of the global values they create.
    FixMemoryUsageTracking,
```

**File:** types/src/on_chain_config/timed_features.rs (L102-109)
```rust
            (FixMemoryUsageTracking, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 7, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (FixMemoryUsageTracking, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 11, 17, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L205-217)
```rust
    pub fn use_heap_memory(&mut self, amount: u64) -> SafeNativeResult<()> {
        if self.timed_feature_enabled(TimedFeatureFlag::FixMemoryUsageTracking) {
            if self.has_direct_gas_meter_access_in_native_context() {
                self.gas_meter()
                    .use_heap_memory_in_native_context(amount)
                    .map_err(LimitExceededError::from_err)?;
            } else {
                self.legacy_heap_memory_usage =
                    self.legacy_heap_memory_usage.saturating_add(amount);
            }
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L142-142)
```rust
        [memory_quota: AbstractValueSize, { 1.. => "memory_quota" }, 10_000_000],
```

**File:** aptos-move/e2e-move-tests/src/tests/memory_quota.rs (L47-107)
```rust
#[test]
fn deeply_nested_structs() {
    let mut h = MoveHarness::new();

    h.modify_gas_schedule(|gas_params| {
        gas_params.vm.txn.memory_quota = 10_000_000.into();
        gas_params.vm.txn.max_execution_gas = 100_000_000_000.into();
    });

    // Publish the code
    let acc = h.new_account_at(AccountAddress::from_hex_literal("0xbeef").unwrap());
    assert_success!(h.publish_package(
        &acc,
        &common::test_dir_path("memory_quota.data/nested_struct"),
    ));

    // Initialize
    let result = h.run_entry_function(
        &acc,
        str::parse("0xbeef::very_nested_structure::init").unwrap(),
        vec![],
        vec![],
    );
    assert_success!(result);

    // Create nested structs as table entries
    for _i in 0..5 {
        let result = h.run_entry_function(
            &acc,
            str::parse("0xbeef::very_nested_structure::add").unwrap(),
            vec![],
            vec![MoveValue::U64(2000).simple_serialize().unwrap()],
        );
        assert_success!(result);
    }

    // Try to load the whole table -- this should succeed
    let result = h.run_entry_function(
        &acc,
        str::parse("0xbeef::very_nested_structure::read_all").unwrap(),
        vec![],
        vec![],
    );
    assert_success!(result);

    // Forward 2 hours to activate TimedFeatureFlag::FixMemoryUsageTracking
    // Now attempting to load the whole table shall result in an execution failure (memory limit hit)
    h.new_epoch();
    let result = h.run_entry_function(
        &acc,
        str::parse("0xbeef::very_nested_structure::read_all").unwrap(),
        vec![],
        vec![],
    );
    assert!(matches!(
        result,
        TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(Some(
            StatusCode::MEMORY_LIMIT_EXCEEDED
        )))
    ));
}
```
