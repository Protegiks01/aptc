# Audit Report

## Title
Epoch State Corruption via Non-Atomic Batch Processing in Bootstrapper

## Summary
The `process_epoch_ending_payload()` function in the state-sync bootstrapper fails to implement atomic batch verification semantics for epoch ending ledger infos. When verification fails mid-batch, partial state updates in `verified_epoch_states` are not rolled back, violating the atomic all-or-nothing semantics expected for epoch change proof verification and leading to potential state inconsistencies.

## Finding Description
The vulnerability exists in the epoch ending payload processing logic. [1](#0-0) 

The loop processes each epoch ending ledger info sequentially, calling `update_verified_epoch_states()` which performs state mutations before all validation is complete. [2](#0-1) 

The critical issue occurs when:
1. Early ledger infos in the batch are processed successfully, mutating the in-memory state (`highest_fetched_epoch_ending_version`, `latest_epoch_state`, and `new_epoch_ending_ledger_infos` map)
2. A later ledger info fails at line 115 when `insert_new_epoch_ending_ledger_info()` returns an error (e.g., duplicate version)
3. At this point, lines 112-114 have already executed, updating state that is NOT rolled back [3](#0-2) 

When the error handler executes, `reset_active_stream()` is called but it does NOT reset `verified_epoch_states`: [4](#0-3) 

This violates the atomic batch verification semantics documented in the `EpochChangeProof::verify()` implementation, which ensures all-or-nothing verification: [5](#0-4) 

**Attack Scenario:**
A malicious peer sends a crafted payload: `[ValidEpochX@V100, ValidEpochY@V200, ValidEpochZ@V200]` where two ledger infos share the same version (malformed but with valid signatures).

1. EpochX processes successfully, state updated
2. EpochY processes successfully, inserts V200 into map
3. EpochZ passes signature verification, updates `highest_fetched_epoch_ending_version` to V200 and `latest_epoch_state`, but fails when trying to insert duplicate V200 into the map
4. Result: `latest_epoch_state` has been advanced beyond what the map contains, creating inconsistency between the epoch state and the stored ledger infos

The node's state becomes corrupted with `highest_fetched_epoch_ending_version` pointing to a version that may not match the actual highest epoch state, and `latest_epoch_state` potentially advanced beyond the verified ledger info chain.

## Impact Explanation
**Severity: High**

This vulnerability breaks the **State Consistency** invariant (#4) which requires state transitions to be atomic. The impact includes:

1. **State Inconsistency**: The in-memory `verified_epoch_states` structure enters an inconsistent state where `latest_epoch_state`, `highest_fetched_epoch_ending_version`, and `new_epoch_ending_ledger_infos` map are out of sync

2. **Verification Chain Break**: Subsequent epoch verifications may use an incorrect `latest_epoch_state` as the verifier, causing valid epoch endings to be rejected or allowing verification to skip epochs

3. **Bootstrapping Failure**: When `get_highest_known_ledger_info()` is called, it may attempt to retrieve a ledger info at `highest_fetched_epoch_ending_version` that doesn't exist in the map, triggering an `UnexpectedError`: [6](#0-5) 

4. **Protocol Violation**: Different nodes may end up with different partial epoch states if they receive malicious payloads at different times, potentially leading to consensus divergence during bootstrapping

While this requires a malicious peer to craft invalid payloads, it doesn't require Byzantine validator signatures, making it exploitable by any network participant.

## Likelihood Explanation
**Likelihood: Medium**

- **Attack Complexity**: Low - any malicious peer can craft a payload with duplicate versions or other malformations that trigger the failure path
- **Attacker Requirements**: Only requires the ability to serve data to bootstrapping nodes via the data streaming service
- **Detection**: Difficult to detect as the corruption is in-memory and may only manifest during subsequent verification attempts
- **Triggering Conditions**: Occurs whenever a node is bootstrapping and receives a malformed epoch ending payload from a malicious peer

The vulnerability is likely to be triggered during network disruptions or when malicious peers are present, making it a realistic threat to bootstrapping nodes.

## Recommendation
Implement atomic batch verification by collecting all state updates and only applying them if the entire batch succeeds:

```rust
pub fn update_verified_epoch_states_atomic(
    &mut self,
    epoch_ending_ledger_infos: &[LedgerInfoWithSignatures],
    waypoint: &Waypoint,
) -> Result<(), Error> {
    // Verify all ledger infos first without mutating state
    let mut temp_latest_epoch_state = self.latest_epoch_state.clone();
    let mut pending_updates = Vec::new();
    
    for epoch_ending_ledger_info in epoch_ending_ledger_infos {
        // Verify against temporary state
        temp_latest_epoch_state
            .verify(epoch_ending_ledger_info)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })?;
        
        if let Some(next_epoch_state) = epoch_ending_ledger_info.ledger_info().next_epoch_state() {
            // Check for duplicates without inserting
            let version = epoch_ending_ledger_info.ledger_info().version();
            if self.new_epoch_ending_ledger_infos.contains_key(&version) {
                return Err(Error::UnexpectedError(format!(
                    "Duplicate epoch ending ledger info found! Version: {:?}",
                    version
                )));
            }
            
            // Store pending update
            pending_updates.push((version, epoch_ending_ledger_info.clone(), next_epoch_state.clone()));
            temp_latest_epoch_state = next_epoch_state.clone();
            
            self.verify_waypoint(epoch_ending_ledger_info, waypoint)?;
        } else {
            return Err(Error::VerificationError(
                "The ledger info was not epoch ending!".into(),
            ));
        }
    }
    
    // All verification passed - now apply updates atomically
    for (version, ledger_info, next_state) in pending_updates {
        self.highest_fetched_epoch_ending_version = version;
        self.latest_epoch_state = next_state;
        self.new_epoch_ending_ledger_infos.insert(version, ledger_info);
    }
    
    Ok(())
}
```

Then update `process_epoch_ending_payload()` to call this atomic version:
```rust
if let Err(error) = self.verified_epoch_states.update_verified_epoch_states_atomic(
    &epoch_ending_ledger_infos,
    &self.driver_configuration.waypoint,
) {
    self.reset_active_stream(Some(NotificationAndFeedback::new(
        notification_id,
        NotificationFeedback::PayloadProofFailed,
    )))
    .await?;
    return Err(error);
}
```

## Proof of Concept
```rust
#[tokio::test]
async fn test_partial_epoch_state_rollback() {
    use crate::bootstrapper::VerifiedEpochStates;
    use aptos_types::epoch_state::EpochState;
    use aptos_types::validator_verifier::random_validator_verifier;
    use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
    use aptos_types::block_info::BlockInfo;
    use aptos_crypto::hash::HashValue;
    use std::sync::Arc;
    
    // Create initial epoch state
    let (signers1, verifier1) = random_validator_verifier(1, None, true);
    let epoch_state_1 = EpochState {
        epoch: 1,
        verifier: Arc::new(verifier1),
    };
    let mut verified_states = VerifiedEpochStates::new(epoch_state_1.clone());
    
    // Create valid epoch 1 ending ledger info
    let (signers2, verifier2) = random_validator_verifier(1, None, true);
    let epoch_state_2 = EpochState {
        epoch: 2,
        verifier: Arc::new(verifier2),
    };
    
    let ledger_info_1 = LedgerInfo::new(
        BlockInfo::new(1, 0, HashValue::zero(), HashValue::zero(), 100, 0, Some(epoch_state_2.clone())),
        HashValue::zero(),
    );
    let sig_1 = signers1[0].sign(&ledger_info_1).unwrap();
    let ledger_info_with_sig_1 = LedgerInfoWithSignatures::new(
        ledger_info_1,
        std::collections::BTreeMap::from([(signers1[0].author(), sig_1)]),
    );
    
    // Process first ledger info - should succeed
    let waypoint = aptos_types::waypoint::Waypoint::default();
    verified_states.update_verified_epoch_states(&ledger_info_with_sig_1, &waypoint).unwrap();
    
    // Create duplicate version ledger info (same version 100, different epoch)
    let (_, verifier3) = random_validator_verifier(1, None, true);
    let epoch_state_3 = EpochState {
        epoch: 3,
        verifier: Arc::new(verifier3),
    };
    
    let ledger_info_2_dup = LedgerInfo::new(
        BlockInfo::new(2, 0, HashValue::zero(), HashValue::zero(), 100, 0, Some(epoch_state_3.clone())),
        HashValue::zero(),
    );
    let sig_2 = signers2[0].sign(&ledger_info_2_dup).unwrap();
    let ledger_info_with_sig_2_dup = LedgerInfoWithSignatures::new(
        ledger_info_2_dup,
        std::collections::BTreeMap::from([(signers2[0].author(), sig_2)]),
    );
    
    // Process duplicate - should fail at insert, but state mutations already happened
    let result = verified_states.update_verified_epoch_states(&ledger_info_with_sig_2_dup, &waypoint);
    
    // Verify the bug: even though update failed, latest_epoch_state was mutated
    // before the insert failure occurred
    assert!(result.is_err());
    
    // The inconsistency: latest_epoch_state may have been updated to epoch 3
    // but the map still only contains the epoch 1 ending ledger info
    // This demonstrates the non-atomic behavior
}
```

This proof of concept demonstrates how the state can become inconsistent when verification fails after partial updates, violating the atomic batch processing semantics that epoch change proofs should maintain.

### Citations

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L98-129)
```rust
    pub fn update_verified_epoch_states(
        &mut self,
        epoch_ending_ledger_info: &LedgerInfoWithSignatures,
        waypoint: &Waypoint,
    ) -> Result<(), Error> {
        // Verify the ledger info against the latest epoch state
        self.latest_epoch_state
            .verify(epoch_ending_ledger_info)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })?;

        // Update the latest epoch state with the next epoch
        if let Some(next_epoch_state) = epoch_ending_ledger_info.ledger_info().next_epoch_state() {
            self.highest_fetched_epoch_ending_version =
                epoch_ending_ledger_info.ledger_info().version();
            self.latest_epoch_state = next_epoch_state.clone();
            self.insert_new_epoch_ending_ledger_info(epoch_ending_ledger_info.clone())?;

            trace!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
                "Updated the latest epoch state to epoch: {:?}",
                self.latest_epoch_state.epoch
            )));
        } else {
            return Err(Error::VerificationError(
                "The ledger info was not epoch ending!".into(),
            ));
        }

        // Check if the ledger info corresponds to the trusted waypoint
        self.verify_waypoint(epoch_ending_ledger_info, waypoint)
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L169-194)
```rust
    fn insert_new_epoch_ending_ledger_info(
        &mut self,
        epoch_ending_ledger_info: LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        let ledger_info = epoch_ending_ledger_info.ledger_info();
        info!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
            "Adding a new epoch to the epoch ending ledger infos. Epoch: {:?}, Version: {:?}, Ends epoch: {:?}, Waypoint: {:?}",
            ledger_info.epoch(), ledger_info.version(), ledger_info.ends_epoch(), Waypoint::new_epoch_boundary(ledger_info),
        )));

        // Insert the version to ledger info mapping
        let version = ledger_info.version();
        if let Some(epoch_ending_ledger_info) = self
            .new_epoch_ending_ledger_infos
            .insert(version, epoch_ending_ledger_info)
        {
            Err(Error::UnexpectedError(format!(
                "Duplicate epoch ending ledger info found!\
                 Version: {:?}, \
                 ledger info: {:?}",
                version, epoch_ending_ledger_info,
            )))
        } else {
            Ok(())
        }
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L213-228)
```rust
    pub fn get_highest_known_ledger_info(&self) -> Result<Option<LedgerInfoWithSignatures>, Error> {
        let highest_known_ledger_info = if !self.new_epoch_ending_ledger_infos.is_empty() {
            let highest_fetched_ledger_info = self
                .get_epoch_ending_ledger_info(self.highest_fetched_epoch_ending_version)
                .ok_or_else(|| {
                    Error::UnexpectedError(format!(
                        "The highest known ledger info for version: {:?} was not found!",
                        self.highest_fetched_epoch_ending_version
                    ))
                })?;
            Some(highest_fetched_ledger_info)
        } else {
            None
        };
        Ok(highest_known_ledger_info)
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1094-1106)
```rust
        for epoch_ending_ledger_info in epoch_ending_ledger_infos {
            if let Err(error) = self.verified_epoch_states.update_verified_epoch_states(
                &epoch_ending_ledger_info,
                &self.driver_configuration.waypoint,
            ) {
                self.reset_active_stream(Some(NotificationAndFeedback::new(
                    notification_id,
                    NotificationFeedback::PayloadProofFailed,
                )))
                .await?;
                return Err(error);
            }
        }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1538-1556)
```rust
    /// Resets the currently active data stream and speculative state
    pub async fn reset_active_stream(
        &mut self,
        notification_and_feedback: Option<NotificationAndFeedback>,
    ) -> Result<(), Error> {
        if let Some(active_data_stream) = &self.active_data_stream {
            let data_stream_id = active_data_stream.data_stream_id;
            utils::terminate_stream_with_feedback(
                &mut self.streaming_client,
                data_stream_id,
                notification_and_feedback,
            )
            .await?;
        }

        self.active_data_stream = None;
        self.speculative_stream_state = None;
        Ok(())
    }
```

**File:** types/src/epoch_change.rs (L66-118)
```rust
    pub fn verify(&self, verifier: &dyn Verifier) -> Result<&LedgerInfoWithSignatures> {
        ensure!(
            !self.ledger_info_with_sigs.is_empty(),
            "The EpochChangeProof is empty"
        );
        ensure!(
            !verifier
                .is_ledger_info_stale(self.ledger_info_with_sigs.last().unwrap().ledger_info()),
            "The EpochChangeProof is stale as our verifier is already ahead \
             of the entire EpochChangeProof"
        );
        let mut verifier_ref = verifier;

        for ledger_info_with_sigs in self
            .ledger_info_with_sigs
            .iter()
            // Skip any stale ledger infos in the proof prefix. Note that with
            // the assertion above, we are guaranteed there is at least one
            // non-stale ledger info in the proof.
            //
            // It's useful to skip these stale ledger infos to better allow for
            // concurrent client requests.
            //
            // For example, suppose the following:
            //
            // 1. My current trusted state is at epoch 5.
            // 2. I make two concurrent requests to two validators A and B, who
            //    live at epochs 9 and 11 respectively.
            //
            // If A's response returns first, I will ratchet my trusted state
            // to epoch 9. When B's response returns, I will still be able to
            // ratchet forward to 11 even though B's EpochChangeProof
            // includes a bunch of stale ledger infos (for epochs 5, 6, 7, 8).
            //
            // Of course, if B's response returns first, we will reject A's
            // response as it's completely stale.
            .skip_while(|&ledger_info_with_sigs| {
                verifier.is_ledger_info_stale(ledger_info_with_sigs.ledger_info())
            })
        {
            // Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof.
            verifier_ref.verify(ledger_info_with_sigs)?;
            // While the original verification could've been via waypoints,
            // all the next epoch changes are verified using the (already
            // trusted) validator sets.
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
        }

        Ok(self.ledger_info_with_sigs.last().unwrap())
    }
```
