# Audit Report

## Title
Race Condition in save_ledger_infos() Leading to Ledger Info Ordering Violations and Cache Inconsistency

## Summary
A race condition exists in the `save_ledger_infos()` function that can cause ledger info ordering violations when concurrent calls use different execution paths (with and without `existing_batch`). This creates a window where the database and in-memory cache can become inconsistent, potentially allowing lower-version ledger infos to overwrite higher-version ones for the same epoch.

## Finding Description

The `save_ledger_infos()` function has asymmetric behavior based on the `existing_batch` parameter: [1](#0-0) 

When `existing_batch` is provided, the function only adds ledger infos to the batch without writing to the database or updating the in-memory cache. When `existing_batch` is None, it writes to the database and immediately calls `update_latest_ledger_info()`.

The critical vulnerability occurs in `finalize_state_snapshot()` which uses the batched path: [2](#0-1) 

There's a race window between line 223 (database write) and line 236 (cache update). During this window, the database contains the new ledger info but the in-memory cache still reflects the old state.

The `update_latest_ledger_info()` function has a check-then-act race condition: [3](#0-2) 

This function only compares epochs (not versions within epochs), and the three-step operation (read-check-write) is not atomic.

Furthermore, `LedgerInfoSchema` stores ledger infos keyed by epoch number: [4](#0-3) 

This means multiple ledger infos for the same epoch will overwrite each other, with the last write winning regardless of version ordering.

Critically, `finalize_state_snapshot()` has no locking mechanism, unlike other commit operations: [5](#0-4) 

The `pre_commit_lock` and `commit_lock` exist for their respective operations, but no such protection exists for `finalize_state_snapshot()`.

The in-memory cache uses `ArcSwap` which provides atomic pointer updates but doesn't make the entire check-compare-update sequence atomic: [6](#0-5) [7](#0-6) 

**Exploitation Scenario:**
1. Thread A calls `finalize_state_snapshot()` with LedgerInfo for epoch 5, version 200 (correct epoch-ending LI)
2. Thread A adds LI_v200 to batch and commits to DB (line 223)
3. Thread B concurrently calls `save_ledger_infos([LI_epoch5_v150], None)` with stale data
4. Thread B writes LI_v150 to DB, overwriting LI_v200 for epoch 5 (last write wins)
5. Thread B updates cache to v150
6. Thread A later calls `update_latest_ledger_info([LI_v200])` at line 236
7. Thread A reads cache (v150), compares epochs (5 vs 5), and updates cache to v200

**Result:** Database contains v150 (lower version) but cache points to v200 (higher version) - permanent inconsistency violating state consistency invariant.

## Impact Explanation

This vulnerability breaks **Critical Invariant #4: State Consistency** - state transitions must be atomic and verifiable. The inconsistency between database and cache can cause:

1. **Consensus Safety Violations**: Different nodes may have different views of the latest ledger info, potentially causing consensus disagreements
2. **State Sync Failures**: New nodes syncing state may receive inconsistent ledger info, leading to failed synchronization
3. **Epoch Transition Issues**: Incorrect epoch-ending ledger info can corrupt validator set transitions

This qualifies as **High Severity** per the bug bounty criteria due to "Significant protocol violations" and potential for state inconsistencies requiring manual intervention.

## Likelihood Explanation

The likelihood depends on whether concurrent calls to `finalize_state_snapshot()` or mixed concurrent calls to storage operations can occur. During fast sync or state restore operations, if multiple threads or async tasks process state data concurrently without proper coordination at the application layer, this race condition can manifest.

The fact that `pre_commit_ledger()` and `commit_ledger()` have explicit locking with panic messages ("Concurrent committing detected") suggests the developers anticipated concurrency issues. The absence of similar protection for `finalize_state_snapshot()` is concerning.

## Recommendation

**Solution 1: Add explicit locking to `finalize_state_snapshot()`**

Add a dedicated lock similar to `pre_commit_lock` and `commit_lock` in the `AptosDB` struct and acquire it in `finalize_state_snapshot()` to prevent concurrent execution.

**Solution 2: Make cache update atomic with DB write**

Modify `save_ledger_infos()` to always update the cache immediately after writing to DB when using batched writes, or pass a flag to indicate whether cache update is needed.

**Solution 3: Version-aware cache updates**

Modify `update_latest_ledger_info()` to compare both epoch AND version:

```rust
pub(crate) fn update_latest_ledger_info(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
) -> Result<()> {
    let new_li = ledger_infos.last().unwrap();
    if let Some(current_li) = ledger_metadata_db.get_latest_ledger_info_option() {
        // Compare epoch first, then version within same epoch
        if current_li.ledger_info().epoch() > new_li.ledger_info().epoch() 
            || (current_li.ledger_info().epoch() == new_li.ledger_info().epoch() 
                && current_li.ledger_info().version() >= new_li.ledger_info().version()) {
            return Ok(());
        }
    }
    ledger_metadata_db.set_latest_ledger_info(new_li.clone());
    Ok(())
}
```

## Proof of Concept

Due to the complexity of setting up concurrent state sync operations in a test environment and the lack of direct external triggering mechanisms, a traditional PoC is challenging. However, the race can be demonstrated with a Rust unit test:

```rust
#[test]
fn test_concurrent_save_ledger_infos_race() {
    use std::sync::Arc;
    use std::thread;
    
    // Setup: Create AptosDB instance and ledger infos for same epoch
    let db = Arc::new(setup_test_db());
    let li_v200 = create_test_ledger_info(5, 200); // epoch 5, version 200
    let li_v150 = create_test_ledger_info(5, 150); // epoch 5, version 150
    
    // Thread 1: Batched write with higher version
    let db1 = Arc::clone(&db);
    let handle1 = thread::spawn(move || {
        let mut batch = SchemaBatch::new();
        save_ledger_infos_impl(db1.ledger_db.metadata_db(), &[li_v200], &mut batch).unwrap();
        db1.ledger_db.metadata_db().write_schemas(batch).unwrap();
        thread::sleep(Duration::from_millis(10)); // Simulate race window
        update_latest_ledger_info(db1.ledger_db.metadata_db(), &[li_v200]).unwrap();
    });
    
    // Thread 2: Direct write with lower version (interleaves during race window)
    let db2 = Arc::clone(&db);
    let handle2 = thread::spawn(move || {
        thread::sleep(Duration::from_millis(5));
        save_ledger_infos(db2.ledger_db.metadata_db(), &[li_v150], None).unwrap();
    });
    
    handle1.join().unwrap();
    handle2.join().unwrap();
    
    // Verify: Check for inconsistency
    let cached = db.ledger_db.metadata_db().get_latest_ledger_info_option().unwrap();
    let from_db = db.ledger_db.metadata_db().get_latest_ledger_info_in_epoch(5).unwrap();
    
    // Race condition manifests as version mismatch
    assert_ne!(cached.ledger_info().version(), from_db.ledger_info().version());
}
```

## Notes

This vulnerability demonstrates a classic TOCTOU (Time-Of-Check-Time-Of-Use) race condition combined with inconsistent handling of database writes versus cache updates. The fix should ensure atomicity between database persistence and cache updates, or add explicit concurrency control to prevent concurrent modifications of the same epoch's ledger info.

### Citations

**File:** storage/aptosdb/src/backup/restore_utils.rs (L41-58)
```rust
pub(crate) fn save_ledger_infos(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    existing_batch: Option<&mut SchemaBatch>,
) -> Result<()> {
    ensure!(!ledger_infos.is_empty(), "No LedgerInfos to save.");

    if let Some(existing_batch) = existing_batch {
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, existing_batch)?;
    } else {
        let mut batch = SchemaBatch::new();
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, &mut batch)?;
        ledger_metadata_db.write_schemas(batch)?;
        update_latest_ledger_info(ledger_metadata_db, ledger_infos)?;
    }

    Ok(())
}
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L60-74)
```rust
/// Updates the latest ledger info iff a ledger info with a higher epoch is found
pub(crate) fn update_latest_ledger_info(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
) -> Result<()> {
    if let Some(li) = ledger_metadata_db.get_latest_ledger_info_option() {
        if li.ledger_info().epoch() > ledger_infos.last().unwrap().ledger_info().epoch() {
            // No need to update latest ledger info.
            return Ok(());
        }
    }
    ledger_metadata_db.set_latest_ledger_info(ledger_infos.last().unwrap().clone());

    Ok(())
}
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L201-236)
```rust
            restore_utils::save_ledger_infos(
                self.ledger_db.metadata_db(),
                ledger_infos,
                Some(&mut ledger_db_batch.ledger_metadata_db_batches),
            )?;

            ledger_db_batch
                .ledger_metadata_db_batches
                .put::<DbMetadataSchema>(
                    &DbMetadataKey::LedgerCommitProgress,
                    &DbMetadataValue::Version(version),
                )?;
            ledger_db_batch
                .ledger_metadata_db_batches
                .put::<DbMetadataSchema>(
                    &DbMetadataKey::OverallCommitProgress,
                    &DbMetadataValue::Version(version),
                )?;

            // Apply the change set writes to the database (atomically) and update in-memory state
            //
            // state kv and SMT should use shared way of committing.
            self.ledger_db.write_schemas(ledger_db_batch)?;

            self.ledger_pruner.save_min_readable_version(version)?;
            self.state_store
                .state_merkle_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .epoch_snapshot_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .state_kv_pruner
                .save_min_readable_version(version)?;

            restore_utils::update_latest_ledger_info(self.ledger_db.metadata_db(), ledger_infos)?;
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L94-98)
```rust
    pub(crate) fn get_latest_ledger_info_option(&self) -> Option<LedgerInfoWithSignatures> {
        let ledger_info_ptr = self.latest_ledger_info.load();
        let ledger_info: &Option<_> = ledger_info_ptr.deref();
        ledger_info.clone()
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L180-183)
```rust
    pub(crate) fn set_latest_ledger_info(&self, ledger_info_with_sigs: LedgerInfoWithSignatures) {
        self.latest_ledger_info
            .store(Arc::new(Some(ledger_info_with_sigs)));
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L186-198)
```rust
    pub(crate) fn put_ledger_info(
        &self,
        ledger_info_with_sigs: &LedgerInfoWithSignatures,
        batch: &mut SchemaBatch,
    ) -> Result<()> {
        let ledger_info = ledger_info_with_sigs.ledger_info();

        if ledger_info.ends_epoch() {
            // This is the last version of the current epoch, update the epoch by version index.
            batch.put::<EpochByVersionSchema>(&ledger_info.version(), &ledger_info.epoch())?;
        }
        batch.put::<LedgerInfoSchema>(&ledger_info.epoch(), ledger_info_with_sigs)
    }
```

**File:** storage/aptosdb/src/db/mod.rs (L34-37)
```rust
    /// This is just to detect concurrent calls to `pre_commit_ledger()`
    pre_commit_lock: std::sync::Mutex<()>,
    /// This is just to detect concurrent calls to `commit_ledger()`
    commit_lock: std::sync::Mutex<()>,
```
