# Audit Report

## Title
Multi-Step Governance Proposals Can Fail Partially, Leaving Blockchain State Inconsistent

## Summary
Multi-step governance proposals in Aptos can execute partially when the `next_execution_hash` embedded in an earlier step does not match the actual hash of a subsequent step. This causes the earlier steps to commit state changes while later steps abort, violating atomicity guarantees and leaving the blockchain in an inconsistent state.

## Finding Description

The Aptos governance system supports multi-step proposals where each step must specify the hash of the next step via the `next_execution_hash` parameter. The critical vulnerability lies in the lack of **on-chain pre-validation** of the hash chain before proposal execution begins. [1](#0-0) 

When generating multi-step proposals, the `generate_gas_upgrade_proposal()` function accepts a `next_execution_hash` parameter that is embedded directly into the Move script without validation against the actual next script. [2](#0-1) 

During execution, `resolve_proposal_v2()` updates the on-chain `proposal.execution_hash` to whatever `next_execution_hash` value was provided in the script, **without verifying** that this hash corresponds to any real script. [3](#0-2) 

The hash validation only occurs when the NEXT step attempts to execute via `is_proposal_resolvable()`, which checks if the current script's hash matches the stored `proposal.execution_hash`. If there's a mismatch (due to an incorrect `next_execution_hash` in the previous step), the transaction aborts with `EPROPOSAL_EXECUTION_HASH_NOT_MATCHING`.

**Attack Scenario:**
1. A multi-step gas schedule proposal is created where Step 1 contains an incorrect `next_execution_hash` for Step 2 (due to generation bug, manual error, or malicious intent)
2. Governance participants vote to approve the proposal based on Step 1's visible changes
3. Step 1 executes successfully, calling `gas_schedule::set_for_next_epoch()` and `aptos_governance::reconfigure()`, committing state changes to the blockchain
4. Step 2 is submitted for execution but fails immediately in `is_proposal_resolvable()` because its actual script hash doesn't match the incorrect hash stored by Step 1
5. The gas schedule update from Step 1 is now permanently committed, but Step 2's intended changes (potentially critical configuration updates) can never execute
6. The blockchain is left in an inconsistent state with partial proposal execution [4](#0-3) 

The `resolve_multi_step_proposal()` function blindly trusts the `next_execution_hash` parameter and updates the approved hashes accordingly, enabling this partial execution scenario.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria:

- **State Inconsistencies Requiring Intervention**: Multi-step proposals can leave the blockchain in partially executed states that require manual intervention or governance action to resolve. For gas schedule updates, this could mean validators operate with mismatched gas configurations, potentially causing consensus disagreements or transaction execution failures.

- **Violation of State Consistency Invariant**: The system guarantees that "state transitions must be atomic and verifiable." Multi-step proposals violate this by allowing non-atomic execution where earlier steps commit but later steps fail irreversibly.

- **Governance Integrity Breach**: Approved proposals should execute in their entirety. Partial execution undermines governance integrity as voters approve complete proposal packages, not partial implementations.

For gas schedule proposals specifically, partial execution could cause:
- Validators using inconsistent gas parameters leading to different transaction execution costs
- Potential consensus splits if gas-related epoch changes are incomplete
- Inability to properly roll out coordinated framework + gas schedule updates

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can occur through multiple realistic scenarios:

1. **Script Generation Bugs**: The release builder generates scripts in reverse order and computes hashes. Any bug in `get_execution_hash()` or non-deterministic script generation could produce incorrect hashes. [5](#0-4) 

2. **Manual Modification**: Developers might manually edit generated scripts after hash computation, invalidating the embedded hashes.

3. **Timing Issues**: If scripts are regenerated or modified between proposal creation and execution, hash mismatches can occur.

4. **No Pre-Execution Validation**: The voting system accepts proposals with any `next_execution_hash` value. There is no on-chain mechanism to verify the hash chain is valid before execution begins. [6](#0-5) 

The CLI tool `VerifyProposal` can detect hash mismatches, but it's **optional** and not enforced on-chain. [7](#0-6) 

## Recommendation

Implement **on-chain hash chain validation** before multi-step proposal execution:

1. **Proposal Metadata Extension**: When creating multi-step proposals, store the complete hash chain (hashes of all steps) in proposal metadata.

2. **Pre-Execution Validation**: Add a new function `validate_multi_step_proposal_chain()` that verifies all steps' hashes match the stored chain before allowing Step 1 to execute.

3. **Atomic Execution Option**: Consider implementing a batched execution mode where all multi-step proposal steps execute in a single transaction (if technically feasible), ensuring true atomicity.

4. **Mandatory Verification**: Make the `VerifyProposal` check mandatory through on-chain enforcement or governance process requirements.

**Proposed code fix for `voting.move`:**

```move
// Add to proposal metadata during creation
const MULTI_STEP_HASH_CHAIN_KEY: vector<u8> = b"multi_step_hash_chain";

// New validation function
public fun validate_multi_step_hash_chain<ProposalType: store>(
    voting_forum_address: address,
    proposal_id: u64,
    all_step_hashes: vector<vector<u8>>
): bool acquires VotingForum {
    let proposal = get_proposal<ProposalType>(voting_forum_address, proposal_id);
    let chain_key = utf8(MULTI_STEP_HASH_CHAIN_KEY);
    
    if (!simple_map::contains_key(&proposal.metadata, &chain_key)) {
        return false
    };
    
    let stored_chain = simple_map::borrow(&proposal.metadata, &chain_key);
    bcs::to_bytes(&all_step_hashes) == *stored_chain
}

// Modify resolve_proposal_v2 to enforce validation for first step
public fun resolve_proposal_v2<ProposalType: store>(
    voting_forum_address: address,
    proposal_id: u64,
    next_execution_hash: vector<u8>,
) acquires VotingForum {
    is_proposal_resolvable<ProposalType>(voting_forum_address, proposal_id);
    
    let voting_forum = borrow_global_mut<VotingForum<ProposalType>>(voting_forum_address);
    let proposal = table::borrow_mut(&mut voting_forum.proposals, proposal_id);
    
    // NEW: For multi-step proposals on first execution, verify hash chain
    let multi_step_in_exec_key = utf8(IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY);
    let is_first_step = !simple_map::contains_key(&proposal.metadata, &multi_step_in_exec_key);
    
    if (is_first_step && vector::length(&next_execution_hash) > 0) {
        // Verify that next_execution_hash exists in the validated chain
        assert!(
            validate_hash_in_chain(proposal, next_execution_hash),
            error::invalid_argument(EINVALID_HASH_CHAIN)
        );
    };
    
    // ... rest of existing logic
}
```

## Proof of Concept

**Test Scenario** (Move pseudo-code):

```move
#[test]
fun test_multi_step_proposal_partial_failure() {
    // 1. Create multi-step proposal with 2 steps
    let proposal_id = create_multi_step_proposal_for_gas_update();
    
    // 2. Vote and approve the proposal
    vote_and_approve(proposal_id);
    
    // 3. Generate Step 1 script with INCORRECT hash for Step 2
    let step1_script = generate_step1_with_wrong_hash(proposal_id);
    let step2_script = generate_step2();
    
    // 4. Execute Step 1 - should succeed
    execute_script(step1_script);
    
    // Verify: gas schedule was updated by Step 1
    let gas_schedule = get_current_gas_schedule();
    assert!(gas_schedule.feature_version == NEW_VERSION, 0);
    
    // 5. Attempt to execute Step 2 - should ABORT
    let result = try_execute_script(step2_script);
    assert!(result.is_error(), 1);
    assert!(result.error_code() == EPROPOSAL_EXECUTION_HASH_NOT_MATCHING, 2);
    
    // 6. Verify inconsistent state:
    // - Step 1's gas schedule change is committed
    // - Step 2 cannot execute (hash mismatch)
    // - Proposal is stuck in partial execution
    assert!(proposal_is_partially_executed(proposal_id), 3);
}
```

**Rust reproduction steps:**

1. Use `aptos-release-builder` to generate a multi-step gas schedule proposal
2. Manually modify the generated Step 2 script (changing a comment or parameter)
3. Submit Step 1 for execution via governance
4. After Step 1 commits, attempt to execute the modified Step 2
5. Observe: Step 2 fails with hash mismatch, Step 1's changes are permanent

## Notes

This vulnerability demonstrates a fundamental **atomicity violation** in Aptos multi-step governance. While the hash verification mechanism works correctly for preventing unauthorized script substitution, it inadvertently enables partial execution scenarios when hashes are incorrect from the start.

The issue is exacerbated by:
- No on-chain validation of hash chains before execution
- Optional off-chain verification tools
- Trust-based assumption that proposal creators generate correct hashes
- No rollback mechanism for failed multi-step proposals

The severity is medium because exploitation requires either governance process failures or tooling bugs rather than direct attacker control, but the impact on state consistency is significant.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/gas.rs (L80-86)
```rust
pub fn generate_gas_upgrade_proposal(
    old_gas_schedule: Option<&GasScheduleV2>,
    new_gas_schedule: &GasScheduleV2,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> Result<Vec<(String, String)>> {
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L447-450)
```text
        assert!(
            transaction_context::get_script_hash() == proposal.execution_hash,
            error::invalid_argument(EPROPOSAL_EXECUTION_HASH_NOT_MATCHING),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L514-566)
```text
    public fun resolve_proposal_v2<ProposalType: store>(
        voting_forum_address: address,
        proposal_id: u64,
        next_execution_hash: vector<u8>,
    ) acquires VotingForum {
        is_proposal_resolvable<ProposalType>(voting_forum_address, proposal_id);

        let voting_forum = borrow_global_mut<VotingForum<ProposalType>>(voting_forum_address);
        let proposal = table::borrow_mut(&mut voting_forum.proposals, proposal_id);

        // Update the IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY key to indicate that the multi-step proposal is in execution.
        let multi_step_in_execution_key = utf8(IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY);
        if (simple_map::contains_key(&proposal.metadata, &multi_step_in_execution_key)) {
            let is_multi_step_proposal_in_execution_value = simple_map::borrow_mut(
                &mut proposal.metadata,
                &multi_step_in_execution_key
            );
            *is_multi_step_proposal_in_execution_value = to_bytes(&true);
        };

        let multi_step_key = utf8(IS_MULTI_STEP_PROPOSAL_KEY);
        let is_multi_step = simple_map::contains_key(&proposal.metadata, &multi_step_key) && from_bcs::to_bool(
            *simple_map::borrow(&proposal.metadata, &multi_step_key)
        );
        let next_execution_hash_is_empty = vector::length(&next_execution_hash) == 0;

        // Assert that if this proposal is single-step, the `next_execution_hash` parameter is empty.
        assert!(
            is_multi_step || next_execution_hash_is_empty,
            error::invalid_argument(ESINGLE_STEP_PROPOSAL_CANNOT_HAVE_NEXT_EXECUTION_HASH)
        );

        // If the `next_execution_hash` parameter is empty, it means that either
        // - this proposal is a single-step proposal, or
        // - this proposal is multi-step and we're currently resolving the last step in the multi-step proposal.
        // We can mark that this proposal is resolved.
        if (next_execution_hash_is_empty) {
            proposal.is_resolved = true;
            proposal.resolution_time_secs = timestamp::now_seconds();

            // Set the `IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY` value to false upon successful resolution of the last step of a multi-step proposal.
            if (is_multi_step) {
                let is_multi_step_proposal_in_execution_value = simple_map::borrow_mut(
                    &mut proposal.metadata,
                    &multi_step_in_execution_key
                );
                *is_multi_step_proposal_in_execution_value = to_bytes(&false);
            };
        } else {
            // If the current step is not the last step,
            // update the proposal's execution hash on-chain to the execution hash of the next step.
            proposal.execution_hash = next_execution_hash;
        };
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L644-661)
```text
    public fun resolve_multi_step_proposal(
        proposal_id: u64,
        signer_address: address,
        next_execution_hash: vector<u8>
    ): signer acquires GovernanceResponsbility, ApprovedExecutionHashes {
        voting::resolve_proposal_v2<GovernanceProposal>(@aptos_framework, proposal_id, next_execution_hash);
        // If the current step is the last step of this multi-step proposal,
        // we will remove the execution hash from the ApprovedExecutionHashes map.
        if (vector::length(&next_execution_hash) == 0) {
            remove_approved_hash(proposal_id);
        } else {
            // If the current step is not the last step of this proposal,
            // we replace the current execution hash with the next execution hash
            // in the ApprovedExecutionHashes map.
            add_approved_script_hash(proposal_id)
        };
        get_signer(signer_address)
    }
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L816-841)
```rust
pub fn get_execution_hash(result: &[(String, String)]) -> Option<HashValue> {
    if result.is_empty() {
        None
    } else {
        let temp_script_path = TempPath::new();
        temp_script_path.create_as_file().unwrap();
        let mut move_script_path = temp_script_path.path().to_path_buf();
        move_script_path.set_extension("move");
        std::fs::write(move_script_path.as_path(), result.last().unwrap().1.clone())
            .map_err(|err| {
                anyhow!(
                    "Failed to get execution hash: failed to write to file: {:?}",
                    err
                )
            })
            .unwrap();

        let (_, hash) = GenerateExecutionHash {
            script_path: Option::from(move_script_path),
            framework_local_dir: Some(aptos_framework_path()),
        }
        .generate_hash()
        .unwrap();
        Some(hash)
    }
}
```

**File:** crates/aptos/src/governance/mod.rs (L238-268)
```rust
    async fn execute(mut self) -> CliTypedResult<VerifyProposalResponse> {
        // Compile local first to get the hash
        let (_, hash) = self
            .compile_proposal_args
            .compile("SubmitProposal", self.prompt_options)?;

        // Retrieve the onchain proposal
        let client = self.rest_options.client(&self.profile)?;
        let forum = client
            .get_account_resource_bcs::<VotingForum>(
                AccountAddress::ONE,
                "0x1::voting::VotingForum<0x1::governance_proposal::GovernanceProposal>",
            )
            .await?
            .into_inner();
        let voting_table = forum.table_handle.0;

        let proposal: Proposal = get_proposal(&client, voting_table, self.proposal_id)
            .await?
            .into();

        // Compare the hashes
        let computed_hash = hash.to_hex();
        let onchain_hash = proposal.execution_hash;

        Ok(VerifyProposalResponse {
            verified: computed_hash == onchain_hash,
            computed_hash,
            onchain_hash,
        })
    }
```
