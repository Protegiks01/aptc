# Audit Report

## Title
Seed Peer Validation Bypass Enables Eclipse Attacks on Public Fullnodes

## Summary
The `optimize_public_network_config()` function skips adding default trusted seed peers when user-provided seeds exist in the local configuration, without validating the authenticity of those user-provided seeds. This allows an attacker who can influence a user's configuration file to completely isolate a fullnode to malicious peers, enabling eclipse attacks that can result in denial of service, transaction censorship, and network partition.

## Finding Description

The vulnerability exists in the config optimization logic for public fullnode networks. When a node starts, the config optimizer checks whether seeds are provided in the local configuration. [1](#0-0) 

The critical flaw is in the conditional logic: if `local_network_config_yaml["seeds"].is_null()` returns false (meaning user provided seeds), the optimizer skips adding the hardcoded trusted MAINNET_SEED_PEERS or TESTNET_SEED_PEERS entirely. The node is then left with ONLY the user-provided seeds for initial peer discovery.

The only validation performed on user-provided seeds is format checking, not authenticity verification: [2](#0-1) 

This validation only ensures addresses are in aptosnet format and that public keys exist - it does NOT verify these are legitimate Aptos network nodes.

**Attack Flow:**

1. **Attacker distributes malicious configuration**: Through supply chain attacks, compromised download sources, or social engineering, an attacker tricks a victim into using a configuration file with malicious seed peers.

2. **Config optimizer respects malicious seeds**: When the node starts, the optimizer detects non-null seeds in the config and skips adding default trusted seeds entirely.

3. **Node isolation**: The victim node initializes ConnectivityManager with ONLY the malicious seeds as its initial peer set. [3](#0-2) 

4. **Eclipse attack execution**: The malicious seed peers have complete control over the node's initial network view. They can:
   - Refuse all connection attempts (complete DoS)
   - Refuse to serve blockchain state data (preventing sync)
   - Selectively censor transactions or blocks
   - Monitor all transaction submissions (privacy breach)

5. **Onchain discovery chicken-egg problem**: For onchain discovery to function, the node must first sync blockchain state to read the validator set. [4](#0-3)  But to sync state, it needs to connect to legitimate peers. If only malicious seeds are available and they refuse to serve data, the node cannot bootstrap.

**Why Mitigations Are Insufficient:**

- **Waypoint verification**: Only prevents accepting fabricated state, not starvation attacks where no data is served
- **Cryptographic verification**: Requires receiving blocks to verify; useless if malicious seeds serve nothing  
- **Inbound connections**: Public networks use `MaybeMutual` authentication allowing unknown peers, but a node behind NAT/firewall may not receive inbound connections
- **Connection limits**: With only 6 default outbound connections [5](#0-4) , malicious seeds can easily dominate the connection pool

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria:

**Primary Impact - Validator Node Slowdowns / API Crashes**: A public fullnode that becomes eclipsed cannot sync blockchain state, leading to service unavailability. For organizations running public fullnode infrastructure (exchanges, wallets, dApps), this results in:
- Complete service outage for new nodes attempting to join the network
- Inability to serve blockchain data to users
- Failed transaction submission and query APIs

**Secondary Impacts**:
- **Transaction Censorship**: Eclipsed nodes see a filtered view of the blockchain, potentially missing critical transactions
- **Privacy Breach**: All transaction submissions and queries are visible to the malicious seed operators
- **Network Partition**: If multiple nodes use the same malicious seed configuration, it creates isolated network segments

While this doesn't directly cause consensus safety violations or fund loss (validators use separate validator networks with different security), it severely impacts the public fullnode network's availability and trustworthiness, which is critical for ecosystem health.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is realistic because:

1. **Accessible attack vector**: Attackers can distribute malicious configs through:
   - Compromised documentation/tutorials showing "example configs"
   - Malicious Docker images or deployment scripts
   - Supply chain attacks on config management tools
   - Typosquatting package repositories

2. **Low technical barrier**: The attacker only needs to:
   - Run malicious seed nodes (trivial infrastructure cost)
   - Distribute a YAML config file (social engineering)
   - No need for validator keys, stake, or protocol-level exploits

3. **Wide impact surface**: Affects all new public fullnodes on mainnet/testnet that use the malicious config

4. **No runtime detection**: The victim node has no way to detect it's been eclipsed until significant time passes without sync progress

The primary constraint is social engineering effectiveness - the attacker must convince users to adopt the malicious configuration. However, this is feasible through legitimate-looking tutorials, automated deployment tools, or compromised infrastructure-as-code repositories.

## Recommendation

Implement defense-in-depth protections in the config optimizer:

**1. Always preserve default seeds (primary fix):**
```rust
// In optimize_public_network_config(), around line 203:
if fullnode_network_config.network_id == NetworkId::Public {
    if let Some(chain_id) = chain_id {
        let default_seeds = if chain_id.is_testnet() {
            create_seed_peers(TESTNET_SEED_PEERS.into())?
        } else if chain_id.is_mainnet() {
            create_seed_peers(MAINNET_SEED_PEERS.into())?
        } else {
            HashMap::new()
        };
        
        // ALWAYS merge default seeds with user-provided seeds
        // Never allow user config to completely replace trusted seeds
        for (peer_id, peer) in default_seeds {
            fullnode_network_config.seeds.entry(peer_id)
                .or_insert(peer);
        }
        
        if !default_seeds.is_empty() {
            modified_config = true;
        }
    }
}
```

**2. Validate seed authenticity (secondary defense):**
Extend `verify_seeds()` to check if at least some seeds match the hardcoded trusted set:
```rust
pub fn verify_seeds(&self, chain_id: Option<ChainId>) -> Result<(), Error> {
    // ... existing format validation ...
    
    // Verify at least one seed matches trusted set
    if let Some(chain_id) = chain_id {
        let trusted_seeds = if chain_id.is_testnet() {
            // Extract peer IDs from TESTNET_SEED_PEERS
        } else if chain_id.is_mainnet() {
            // Extract peer IDs from MAINNET_SEED_PEERS  
        } else {
            return Ok(()); // No validation for non-public networks
        };
        
        let has_trusted = self.seeds.keys()
            .any(|peer_id| trusted_seeds.contains(peer_id));
        
        if !has_trusted {
            return Err(Error::InvariantViolation(
                "Configuration contains no trusted seed peers. \
                 Rejecting to prevent eclipse attacks.".to_string()
            ));
        }
    }
    Ok(())
}
```

**3. Emit security warnings:**
Log prominent warnings when user-provided seeds are detected, alerting operators to potential configuration tampering.

## Proof of Concept

**Setup:** Create a malicious config that triggers the vulnerability:

```yaml
# malicious_fullnode.yaml
base:
  role: "full_node"
  waypoint:
    from_config: "0:0000000000000000000000000000000000000000000000000000000000000000"

full_node_networks:
  - network_id: "Public"
    discovery_method: "onchain"
    seeds:
      # Malicious seed controlled by attacker
      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:
        addresses:
          - "/ip4/192.0.2.1/tcp/6182/noise-ik/0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/handshake/0"
        role: "Upstream"
```

**Verification Steps:**

1. Start Aptos node with malicious config on testnet
2. Observe that no default TESTNET_SEED_PEERS are added to discovered peers
3. Node attempts to connect only to `192.0.2.1` (attacker-controlled)
4. Attacker's seed refuses connections or serves no data
5. Node remains stuck at genesis, unable to sync state
6. Onchain discovery cannot function without synced state
7. Node is completely eclipsed, confirming the vulnerability

**Expected vs Actual Behavior:**
- **Expected**: Node should ALWAYS have default trusted seeds, with user seeds as additions
- **Actual**: Node has ONLY malicious seeds, creating single point of failure

This demonstrates that the lack of seed validation combined with default seed removal creates a critical eclipse attack vector against public fullnode infrastructure.

---

**Notes:**

The vulnerability is exacerbated by the fact that public fullnodes are essential infrastructure for the Aptos ecosystem (exchanges, wallets, block explorers). While validators use separate, secured networks, public fullnodes rely on the seed peer mechanism for bootstrapping. The current implementation violates the principle of "secure by default" by allowing untrusted configuration to completely override security-critical default peers without validation.

### Citations

**File:** config/src/config/config_optimizer.rs (L203-215)
```rust
            if local_network_config_yaml["seeds"].is_null() {
                if let Some(chain_id) = chain_id {
                    if chain_id.is_testnet() {
                        fullnode_network_config.seeds =
                            create_seed_peers(TESTNET_SEED_PEERS.into())?;
                        modified_config = true;
                    } else if chain_id.is_mainnet() {
                        fullnode_network_config.seeds =
                            create_seed_peers(MAINNET_SEED_PEERS.into())?;
                        modified_config = true;
                    }
                }
            }
```

**File:** config/src/config/network_config.rs (L43-43)
```rust
pub const MAX_FULLNODE_OUTBOUND_CONNECTIONS: usize = 6;
```

**File:** config/src/config/network_config.rs (L319-340)
```rust
    pub fn verify_seeds(&self) -> Result<(), Error> {
        for (peer_id, addrs) in self.seed_addrs.iter() {
            for addr in addrs {
                Self::verify_address(peer_id, addr)?;
            }
        }

        for (peer_id, seed) in self.seeds.iter() {
            for addr in seed.addresses.iter() {
                Self::verify_address(peer_id, addr)?;
            }

            // Require there to be a pubkey somewhere, either in the address (assumed by `is_aptosnet_addr`)
            if seed.keys.is_empty() && seed.addresses.is_empty() {
                return Err(Error::InvariantViolation(format!(
                    "Seed peer {} has no pubkeys",
                    peer_id.short_str(),
                )));
            }
        }
        Ok(())
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L400-402)
```rust
        // Set the initial seed config addresses and public keys
        connmgr.handle_update_discovered_peers(DiscoverySource::Config, seeds);
        connmgr
```

**File:** network/discovery/src/validator_set.rs (L68-91)
```rust
    fn extract_updates(&mut self, payload: OnChainConfigPayload<P>) -> PeerSet {
        let _process_timer = EVENT_PROCESSING_LOOP_BUSY_DURATION_S.start_timer();

        let node_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");

        let peer_set = extract_validator_set_updates(self.network_context, node_set);
        // Ensure that the public key matches what's onchain for this peer
        self.find_key_mismatches(
            peer_set
                .get(&self.network_context.peer_id())
                .map(|peer| &peer.keys),
        );

        inc_by_with_context(
            &DISCOVERY_COUNTS,
            &self.network_context,
            "new_nodes",
            peer_set.len() as u64,
        );

        peer_set
    }
```
