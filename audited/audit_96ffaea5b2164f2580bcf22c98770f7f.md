# Audit Report

## Title
Memory Expansion During Resource Deserialization Without Proportional Gas Metering

## Summary

Resource deserialization in `create_data_cache_entry()` charges gas based on storage bytes loaded but allocates memory proportional to the number of elements in vectors. This creates a gas metering bypass where an attacker can craft resources with many small-sized elements that expand significantly from their BCS-serialized size to their in-memory representation, potentially causing validator node memory pressure and slowdowns.

## Finding Description

The vulnerability exists in the resource loading path where: [1](#0-0) 

The `create_data_cache_entry()` function loads resource bytes from storage and deserializes them. Gas is charged based on `bytes_loaded` (the BCS-serialized size), but memory allocation during deserialization is proportional to the number of elements and their in-memory representation: [2](#0-1) 

The deserialization uses `ValueSerDeContext::deserialize()` which does not enforce size limits: [3](#0-2) 

The deserialization implementation lacks depth checking that exists in serialization: [4](#0-3) 

While serialization enforces depth limits: [5](#0-4) 

**Attack Scenario:**

1. Attacker creates a Move module with a resource containing vectors of small structures (e.g., structs with 1-2 small fields)
2. Populates the vector with hundreds of thousands of elements (e.g., 100,000 elements)
3. Due to BCS's compact encoding, this serializes to ~100-800KB (within the 1MB storage limit)
4. When validators or users load this resource, gas is charged for ~100-800KB of bytes loaded
5. However, deserialization allocates memory for 100,000+ `Value` enum objects, each with significant overhead (enum tags, `Rc`, `RefCell`, alignment), expanding to 5-50MB
6. This memory allocation happens without additional gas charges

The memory expansion ratio depends on element size in BCS vs in-memory representation:
- Small structs in BCS: 1-10 bytes per element
- In memory as `Value`: 48+ bytes per element (enum overhead, `Rc<RefCell<>>` containers)
- Expansion factor: 5-50x [6](#0-5) 

Vector deserialization allocates incrementally but totals to the full element count: [7](#0-6) 

## Impact Explanation

**Severity: HIGH** - Validator node slowdowns and memory exhaustion

This vulnerability enables resource exhaustion attacks that violate **Invariant #9: "Resource Limits: All operations must respect gas, storage, and computational limits"**:

1. **Memory Pressure**: An attacker can create resources that consume 5-50x more memory than their storage footprint suggests
2. **Gas Metering Bypass**: Memory allocation costs during deserialization are not reflected in gas charges
3. **Validator Impact**: When validators process blocks containing transactions that load such resources, they experience memory pressure disproportionate to gas charged
4. **Amplification**: Multiple such resources across different accounts amplify the effect
5. **Consensus Risk**: Memory exhaustion could cause validator nodes to slow down or crash, affecting block processing

Per Aptos Bug Bounty criteria, this falls under **HIGH Severity ($50,000)**:
- "Validator node slowdowns" - directly caused by disproportionate memory allocation
- "Significant protocol violations" - gas metering guarantee is violated

The 1MB per-resource storage limit caps individual resource expansion to ~50MB, but attackers can create multiple resources to amplify impact.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack is feasible because:

1. **Low Technical Barrier**: Any user can deploy Move modules and create resources with vectors
2. **Economic Cost**: Attacker must pay gas to create the large vectors initially (vector push_back operations cost gas): [8](#0-7) 

3. **Asymmetric Cost**: Attacker pays once during creation; every subsequent read causes disproportionate memory allocation without gas charge
4. **Practical Limits**: The 1MB storage limit per resource caps maximum expansion, requiring multiple resources for significant impact [9](#0-8) 

5. **Detection**: Such resources would appear "normal" in storage but cause unexpected memory usage during deserialization

The attack is realistic but requires upfront gas investment, making it economically constrained.

## Recommendation

Implement size and depth validation during deserialization to match serialization guarantees:

1. **Add depth checking during deserialization**: Track depth in `DeserializationSeed` and enforce `max_value_nest_depth` limit
2. **Enforce BCS size limits**: Use `bcs::from_bytes_with_limit()` instead of `bcs::from_bytes_seed()` with a limit based on the storage bytes
3. **Charge gas for deserialization work**: Add gas charges proportional to the number of elements deserialized, not just bytes loaded
4. **Add element count limits**: Set maximum vector lengths for resource deserialization based on gas available

Example fix for adding size limit:

```rust
// In value_serde.rs
pub fn deserialize_with_limit(
    self,
    bytes: &[u8],
    layout: &MoveTypeLayout,
    max_bytes: usize,
) -> PartialVMResult<Value> {
    let seed = DeserializationSeed { ctx: &self, layout };
    bcs::from_bytes_seed_with_limit(seed, bytes, max_bytes)
        .map_err(|e| {
            PartialVMError::new(StatusCode::FAILED_TO_DESERIALIZE_RESOURCE)
                .with_message(format!("deserializer error: {}", e))
        })
}
```

## Proof of Concept

```move
module attacker::memory_bomb {
    use std::vector;

    // Small struct with minimal fields
    struct TinyStruct has store, drop {
        value: u8,
    }

    // Resource containing large vector of tiny structs
    struct MemoryBomb has key {
        data: vector<TinyStruct>,
    }

    // Create a resource with 100,000 tiny elements
    // - BCS size: ~100-200KB (compact encoding)
    // - Memory size after deserialize: ~5-10MB (Value enum overhead)
    public fun create_bomb(account: &signer) {
        let v = vector::empty<TinyStruct>();
        let i = 0;
        while (i < 100000) {
            vector::push_back(&mut v, TinyStruct { value: (i % 256) as u8 });
            i = i + 1;
        };
        
        move_to(account, MemoryBomb { data: v });
    }

    // Anyone reading this resource will allocate 5-10MB
    // but only be charged gas for ~100-200KB
    public fun read_bomb(addr: address): u64 acquires MemoryBomb {
        let bomb = borrow_global<MemoryBomb>(addr);
        vector::length(&bomb.data)
    }
}
```

**Expected Behavior:**
1. Attacker calls `create_bomb()` - pays gas for 100K vector operations + storage
2. Victim calls `read_bomb()` - pays gas for ~100-200KB bytes loaded
3. Validator deserializes resource - allocates ~5-10MB memory without proportional gas charge
4. Multiple such resources amplify memory pressure on validators

## Notes

The vulnerability is mitigated by:
- The 1MB per-resource storage limit caps individual expansion
- Attacker must pay significant upfront gas cost during resource creation
- Expansion is multiplicative (5-50x), not exponential as originally questioned

However, the gas metering asymmetry remains a valid security concern enabling resource exhaustion attacks against validator nodes.

### Citations

**File:** third_party/move/move-vm/runtime/src/data_cache.rs (L255-327)
```rust
    fn create_data_cache_entry(
        metadata_loader: &impl ModuleMetadataLoader,
        layout_converter: &LayoutConverter<impl StructDefinitionLoader>,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        module_storage: &dyn ModuleStorage,
        resource_resolver: &dyn ResourceResolver,
        addr: &AccountAddress,
        ty: &Type,
    ) -> PartialVMResult<(DataCacheEntry, NumBytes)> {
        let struct_tag = match module_storage.runtime_environment().ty_to_ty_tag(ty)? {
            TypeTag::Struct(struct_tag) => *struct_tag,
            _ => {
                // Since every resource is a struct, the tag must be also a struct tag.
                return Err(PartialVMError::new(StatusCode::INTERNAL_TYPE_ERROR));
            },
        };

        let layout_with_delayed_fields = layout_converter.type_to_type_layout_with_delayed_fields(
            gas_meter,
            traversal_context,
            ty,
            false,
        )?;

        let (data, bytes_loaded) = {
            let module = metadata_loader.load_module_for_metadata(
                gas_meter,
                traversal_context,
                &struct_tag.module_id(),
            )?;

            // If we need to process delayed fields, we pass type layout to remote storage. Remote
            // storage, in turn ensures that all delayed field values are pre-processed.
            resource_resolver.get_resource_bytes_with_metadata_and_layout(
                addr,
                &struct_tag,
                &module.metadata,
                layout_with_delayed_fields.layout_when_contains_delayed_fields(),
            )?
        };

        let function_value_extension = FunctionValueExtensionAdapter { module_storage };
        let (layout, contains_delayed_fields) = layout_with_delayed_fields.unpack();
        let value = match data {
            Some(blob) => {
                let max_value_nest_depth = function_value_extension.max_value_nest_depth();
                let val = ValueSerDeContext::new(max_value_nest_depth)
                    .with_func_args_deserialization(&function_value_extension)
                    .with_delayed_fields_serde()
                    .deserialize(&blob, &layout)
                    .ok_or_else(|| {
                        let msg = format!(
                            "Failed to deserialize resource {} at {}!",
                            struct_tag.to_canonical_string(),
                            addr
                        );
                        PartialVMError::new(StatusCode::FAILED_TO_DESERIALIZE_RESOURCE)
                            .with_message(msg)
                    })?;
                GlobalValue::cached(val)?
            },
            None => GlobalValue::none(),
        };

        let entry = DataCacheEntry {
            struct_tag,
            layout,
            contains_delayed_fields,
            value,
        };
        Ok((entry, NumBytes::new(bytes_loaded as u64)))
    }
```

**File:** third_party/move/move-vm/types/src/value_serde.rs (L237-241)
```rust
    /// Deserializes the bytes using the provided layout into a Move [Value].
    pub fn deserialize(self, bytes: &[u8], layout: &MoveTypeLayout) -> Option<Value> {
        let seed = DeserializationSeed { ctx: &self, layout };
        bcs::from_bytes_seed(seed, bytes).ok()
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L137-155)
```rust
pub(crate) enum Container {
    Locals(Rc<RefCell<Vec<Value>>>),
    Vec(Rc<RefCell<Vec<Value>>>),
    Struct(Rc<RefCell<Vec<Value>>>),
    VecU8(Rc<RefCell<Vec<u8>>>),
    VecU64(Rc<RefCell<Vec<u64>>>),
    VecU128(Rc<RefCell<Vec<u128>>>),
    VecBool(Rc<RefCell<Vec<bool>>>),
    VecAddress(Rc<RefCell<Vec<AccountAddress>>>),
    VecU16(Rc<RefCell<Vec<u16>>>),
    VecU32(Rc<RefCell<Vec<u32>>>),
    VecU256(Rc<RefCell<Vec<int256::U256>>>),
    VecI8(Rc<RefCell<Vec<i8>>>),
    VecI16(Rc<RefCell<Vec<i16>>>),
    VecI32(Rc<RefCell<Vec<i32>>>),
    VecI64(Rc<RefCell<Vec<i64>>>),
    VecI128(Rc<RefCell<Vec<i128>>>),
    VecI256(Rc<RefCell<Vec<int256::I256>>>),
}
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4834-4838)
```rust
impl serde::Serialize for SerializationReadyValue<'_, '_, '_, MoveTypeLayout, Value> {
    fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        use MoveTypeLayout as L;

        self.ctx.check_depth(self.depth).map_err(S::Error::custom)?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5092-5164)
```rust
impl<'d> serde::de::DeserializeSeed<'d> for DeserializationSeed<'_, &MoveTypeLayout> {
    type Value = Value;

    fn deserialize<D: serde::de::Deserializer<'d>>(
        self,
        deserializer: D,
    ) -> Result<Self::Value, D::Error> {
        use MoveTypeLayout as L;

        match self.layout {
            // Primitive types.
            L::Bool => bool::deserialize(deserializer).map(Value::bool),
            L::U8 => u8::deserialize(deserializer).map(Value::u8),
            L::U16 => u16::deserialize(deserializer).map(Value::u16),
            L::U32 => u32::deserialize(deserializer).map(Value::u32),
            L::U64 => u64::deserialize(deserializer).map(Value::u64),
            L::U128 => u128::deserialize(deserializer).map(Value::u128),
            L::U256 => int256::U256::deserialize(deserializer).map(Value::u256),
            L::I8 => i8::deserialize(deserializer).map(Value::i8),
            L::I16 => i16::deserialize(deserializer).map(Value::i16),
            L::I32 => i32::deserialize(deserializer).map(Value::i32),
            L::I64 => i64::deserialize(deserializer).map(Value::i64),
            L::I128 => i128::deserialize(deserializer).map(Value::i128),
            L::I256 => int256::I256::deserialize(deserializer).map(Value::i256),
            L::Address => AccountAddress::deserialize(deserializer).map(Value::address),
            L::Signer => {
                if self.ctx.legacy_signer {
                    Err(D::Error::custom(
                        "Cannot deserialize signer into value".to_string(),
                    ))
                } else {
                    let seed = DeserializationSeed {
                        ctx: self.ctx,
                        layout: &MoveStructLayout::signer_serialization_layout(),
                    };
                    Ok(Value::struct_(seed.deserialize(deserializer)?))
                }
            },

            // Structs.
            L::Struct(struct_layout) => {
                let seed = DeserializationSeed {
                    ctx: self.ctx,
                    layout: struct_layout,
                };
                Ok(Value::struct_(seed.deserialize(deserializer)?))
            },

            // Vectors.
            L::Vector(layout) => Ok(match layout.as_ref() {
                L::U8 => Value::vector_u8(Vec::deserialize(deserializer)?),
                L::U16 => Value::vector_u16(Vec::deserialize(deserializer)?),
                L::U32 => Value::vector_u32(Vec::deserialize(deserializer)?),
                L::U64 => Value::vector_u64(Vec::deserialize(deserializer)?),
                L::U128 => Value::vector_u128(Vec::deserialize(deserializer)?),
                L::U256 => Value::vector_u256(Vec::deserialize(deserializer)?),
                L::I8 => Value::vector_i8(Vec::deserialize(deserializer)?),
                L::I16 => Value::vector_i16(Vec::deserialize(deserializer)?),
                L::I32 => Value::vector_i32(Vec::deserialize(deserializer)?),
                L::I64 => Value::vector_i64(Vec::deserialize(deserializer)?),
                L::I128 => Value::vector_i128(Vec::deserialize(deserializer)?),
                L::I256 => Value::vector_i256(Vec::deserialize(deserializer)?),
                L::Bool => Value::vector_bool(Vec::deserialize(deserializer)?),
                L::Address => Value::vector_address(Vec::deserialize(deserializer)?),
                layout => {
                    let seed = DeserializationSeed {
                        ctx: self.ctx,
                        layout,
                    };
                    let vector = deserializer.deserialize_seq(VectorElementVisitor(seed))?;
                    Value::Container(Container::Vec(Rc::new(RefCell::new(vector))))
                },
            }),
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5271-5283)
```rust
    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
    where
        A: serde::de::SeqAccess<'d>,
    {
        let mut vals = Vec::new();
        while let Some(elem) = seq.next_element_seed(DeserializationSeed {
            ctx: self.0.ctx,
            layout: self.0.layout,
        })? {
            vals.push(elem)
        }
        Ok(vals)
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/instr.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! This module defines the gas parameters for all Move instructions.

use crate::{
    gas_feature_versions::{RELEASE_V1_18, RELEASE_V1_33, RELEASE_V1_38, RELEASE_V1_40},
    gas_schedule::VMGasParameters,
};
use aptos_gas_algebra::{
    InternalGas, InternalGasPerAbstractValueUnit, InternalGasPerArg, InternalGasPerByte,
    InternalGasPerTypeNode,
};

crate::gas_schedule::macros::define_gas_parameters!(
    InstructionGasParameters,
    "instr",
    VMGasParameters => .instr,
    [
        // nop
        [nop: InternalGas, "nop", 36],
        // control flow
        [ret: InternalGas, "ret", 220],
        [abort: InternalGas, "abort", 220],
        [abort_msg_base: InternalGas, { RELEASE_V1_40.. => "abort_msg.base" }, 440],
        [abort_msg_per_byte: InternalGasPerByte, { RELEASE_V1_40.. => "abort_msg.per_byte" }, 45],

        // Note(Gas): The costs of the branch instructions have been jacked up a bit intentionally
        //            to prevent any single transaction from running for too long.
        [br_true: InternalGas, "br_true", 441],
        [br_false: InternalGas, "br_false", 441],
        [branch: InternalGas, "branch", 294],

        // stack
        [pop: InternalGas, "pop", 147],
        [ld_u8: InternalGas, "ld_u8", 220],
        [ld_u16: InternalGas, { 5.. => "ld_u16" }, 220],
        [ld_u32: InternalGas, { 5.. => "ld_u32" }, 220],
        [ld_u64: InternalGas, "ld_u64", 220],
        [ld_u128: InternalGas, "ld_u128", 294],
        [ld_u256: InternalGas, { 5.. => "ld_u256" }, 294],
        [ld_i8: InternalGas, { RELEASE_V1_38.. => "ld_i8" }, 220],
        [ld_i16: InternalGas, { RELEASE_V1_38.. => "ld_i16" }, 220],
        [ld_i32: InternalGas, { RELEASE_V1_38.. => "ld_i32" }, 220],
        [ld_i64: InternalGas, { RELEASE_V1_38.. => "ld_i64" }, 220],
        [ld_i128: InternalGas, { RELEASE_V1_38.. => "ld_i128" }, 294],
        [ld_i256: InternalGas, { RELEASE_V1_38.. => "ld_i256" }, 294],
        [ld_true: InternalGas, "ld_true", 220],
        [ld_false: InternalGas, "ld_false", 220],
        [ld_const_base: InternalGas, "ld_const.base", 2389],
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::change_set::ChangeSetInterface;
use aptos_gas_schedule::AptosGasParameters;
use move_binary_format::errors::{Location, PartialVMError};
use move_core_types::vm_status::{StatusCode, VMStatus};

#[derive(Clone, Debug)]
pub struct ChangeSetConfigs {
    gas_feature_version: u64,
    max_bytes_per_write_op: u64,
    max_bytes_all_write_ops_per_transaction: u64,
    max_bytes_per_event: u64,
    max_bytes_all_events_per_transaction: u64,
    max_write_ops_per_transaction: u64,
}

impl ChangeSetConfigs {
    pub fn unlimited_at_gas_feature_version(gas_feature_version: u64) -> Self {
        Self::new_impl(
            gas_feature_version,
            u64::MAX,
            u64::MAX,
            u64::MAX,
            u64::MAX,
            u64::MAX,
        )
    }

    pub fn new(feature_version: u64, gas_params: &AptosGasParameters) -> Self {
        if feature_version >= 5 {
            Self::from_gas_params(feature_version, gas_params)
        } else if feature_version >= 3 {
            Self::for_feature_version_3()
        } else {
            Self::unlimited_at_gas_feature_version(feature_version)
        }
    }

    fn new_impl(
        gas_feature_version: u64,
        max_bytes_per_write_op: u64,
        max_bytes_all_write_ops_per_transaction: u64,
        max_bytes_per_event: u64,
        max_bytes_all_events_per_transaction: u64,
        max_write_ops_per_transaction: u64,
    ) -> Self {
        Self {
            gas_feature_version,
```
