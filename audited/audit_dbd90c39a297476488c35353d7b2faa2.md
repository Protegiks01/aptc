# Audit Report

## Title
Missing JWT Issued-At Time (iat) Validation Allows Extended Ephemeral Key Validity Period

## Summary
The `verify_jwt_claims()` function does not validate that the JWT's `iat` (issued-at time) claim is not set to a future timestamp. This allows ephemeral public keys to remain valid for significantly longer than the intended security boundaries defined by `max_exp_horizon_secs`.

## Finding Description

The keyless authentication system validates JWT claims to ensure ephemeral public keys have limited validity periods. The validation logic calculates the maximum allowed expiration as `max_expiration_date = iat + max_exp_horizon_secs` and checks that the ephemeral key's expiration falls within this window. [1](#0-0) 

However, the code never validates that `iat` itself represents a past or present timestamp. If an OIDC provider (whether legitimate with clock skew issues, compromised, or a malicious federated provider) issues a JWT with `iat` set to a future timestamp, the validation passes and the ephemeral key's effective validity period extends beyond the intended security boundaries.

The same issue exists in the pepper service validation: [2](#0-1) 

The on-chain validation in the VM also inherits this issue: [3](#0-2) 

**Attack Scenario:**

1. A malicious federated JWK provider (or compromised/misconfigured OIDC provider) issues a JWT with:
   - `iat = current_time + 365 days` (future timestamp)
   - Other valid claims
   
2. User creates keyless transaction with:
   - `exp_date_secs = iat + 100 days = current_time + 465 days`
   
3. Validation passes because:
   - `exp_date_secs < (iat + max_exp_horizon_secs)` ✓
   - No check that `iat <= current_time` ✗

4. Result: The ephemeral key is valid for 465 days instead of the intended ~115 days (devnet configuration) [4](#0-3) 

This breaks the security invariant that ephemeral keys should be short-lived, as evidenced by the configuration enforcing a maximum horizon of ~115 days from issuance.

## Impact Explanation

**Severity: Medium**

This vulnerability allows ephemeral keys to remain valid for extended periods beyond the intended security boundaries:

- **Extended Attack Window**: If an ephemeral private key is compromised at any point during the inflated validity period, attackers gain prolonged unauthorized access to the keyless account
- **Security Principle Violation**: Breaks the defense-in-depth principle of short-lived credentials, which limits the damage from key compromise
- **Not Direct Funds Loss**: Does not directly cause theft or minting of funds, but increases the risk window for such attacks

The impact aligns with **Medium Severity** per Aptos bug bounty criteria as it creates "state inconsistencies requiring intervention" (extended key validity states) and increases risk of "limited funds loss" through extended compromise windows.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability can be exploited in several realistic scenarios:

1. **Clock Skew**: OIDC providers with misconfigured system clocks could unintentionally issue JWTs with future `iat` values (lower impact, seconds to minutes)

2. **Federated JWK Providers**: In federated keyless setups, malicious actors registering as JWK providers could deliberately issue JWTs with future `iat` timestamps (higher impact, days to months)

3. **Compromised OIDC Providers**: While less likely, a compromised provider could issue such tokens

The likelihood is elevated by the fact that JWT best practices (RFC 7519) recommend validating `iat` claims, and many JWT libraries support `iat` validation, but this implementation explicitly skips it. [5](#0-4) 

## Recommendation

Add validation to ensure `iat` is not set to a future timestamp, with appropriate leeway for clock skew. Implement this in all validation paths:

**1. In `verify_jwt_claims()` function:**

```rust
pub fn verify_jwt_claims(
    &self,
    exp_timestamp_secs: u64,
    epk: &EphemeralPublicKey,
    pk: &KeylessPublicKey,
    config: &Configuration,
) -> anyhow::Result<()> {
    let claims: Claims = serde_json::from_str(&self.jwt_payload_json)?;

    // NEW: Validate iat is not too far in the future
    let current_time_secs = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();
    
    const MAX_IAT_SKEW_SECS: u64 = 300; // 5 minutes clock skew allowance
    
    if claims.oidc_claims.iat > current_time_secs + MAX_IAT_SKEW_SECS {
        return Err(anyhow::anyhow!(
            "JWT 'iat' claim is too far in the future: iat = {}, current_time = {}", 
            claims.oidc_claims.iat, 
            current_time_secs
        ));
    }

    // Rest of existing validation...
    let max_expiration_date = seconds_from_epoch(
        claims
            .oidc_claims
            .iat
            .checked_add(config.max_exp_horizon_secs)
            .ok_or_else(|| {
                anyhow::anyhow!("Overflow when adding iat and max_exp_horizon_secs")
            })?,
    )?;
    // ... continue with existing checks
}
```

**2. In `verify_public_key_expiry_date_secs()` function:**

Add similar validation before line 450 to check that `claims.claims.iat <= time_now_secs + MAX_IAT_SKEW_SECS`.

## Proof of Concept

```rust
#[test]
fn test_jwt_with_future_iat_should_fail() {
    use std::time::{SystemTime, UNIX_EPOCH};
    
    let config = Configuration::new_for_devnet();
    let (mut sig, pk) = get_sample_openid_sig_and_pk();
    
    let oidc_sig = match &mut sig.cert {
        EphemeralCertificate::OpenIdSig(oidc_sig) => oidc_sig,
        _ => panic!("Expected OpenIdSig"),
    };
    
    // Get current time
    let current_time_secs = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();
    
    // Create JWT with future iat (1 year in the future)
    let future_iat = current_time_secs + (365 * 24 * 60 * 60);
    let mut jwt = SAMPLE_JWT_PARSED.clone();
    jwt.oidc_claims.iat = future_iat;
    oidc_sig.jwt_payload_json = serde_json::to_string(&jwt).unwrap();
    
    // Set exp_date_secs to be within max_exp_horizon_secs from future iat
    let exp_date_secs = future_iat + (100 * 24 * 60 * 60); // 100 days from future iat
    
    // This should fail but currently passes (demonstrates vulnerability)
    let result = oidc_sig.verify_jwt_claims(
        exp_date_secs,
        &sig.ephemeral_pubkey,
        &pk,
        &config,
    );
    
    // CURRENT BEHAVIOR: result.is_ok() == true (vulnerability)
    // EXPECTED BEHAVIOR: result.is_err() == true (should reject future iat)
    assert!(result.is_ok(), "Vulnerability: Future iat is accepted when it should be rejected");
}
```

## Notes

While the exploitation requires cooperation from an OIDC provider (either through compromise, misconfiguration, or malicious federated provider registration), the lack of `iat` validation violates JWT security best practices. The defense-in-depth principle suggests that even if OIDC providers are generally trusted, the system should validate all claims to prevent extended attack windows from provider-side issues.

The configuration clearly intends ephemeral keys to be short-lived with a maximum horizon of ~115 days from issuance, but the missing `iat` validation undermines this security boundary.

### Citations

**File:** types/src/keyless/openid_sig.rs (L64-78)
```rust
        let max_expiration_date = seconds_from_epoch(
            claims
                .oidc_claims
                .iat
                .checked_add(config.max_exp_horizon_secs)
                .ok_or_else(|| {
                    anyhow::anyhow!("Overflow when adding iat and max_exp_horizon_secs")
                })?,
        )?;
        let expiration_date = seconds_from_epoch(exp_timestamp_secs)?;

        ensure!(
            expiration_date < max_expiration_date,
            "The ephemeral public key's expiration date is too far into the future"
        );
```

**File:** keyless/pepper/service/src/dedicated_handlers/pepper_request.rs (L387-395)
```rust
    // Validate the JWT signature.
    // TODO: can we avoid decoding the JWT twice?
    let mut validation_with_sig_verification = Validation::new(RS256);
    validation_with_sig_verification.validate_exp = false; // Don't validate the exp time
    jsonwebtoken::decode::<Claims>(jwt, &jwk_decoding_key, &validation_with_sig_verification) // Signature verification happens here
        .map_err(|e| {
            PepperServiceError::BadRequest(format!("JWT signature verification failed: {e}"))
        })?;

```

**File:** keyless/pepper/service/src/dedicated_handlers/pepper_request.rs (L430-468)
```rust
fn verify_public_key_expiry_date_secs(
    exp_date_secs: u64,
    claims: &TokenData<Claims>,
    keyless_configuration: &Configuration,
) -> Result<(), PepperServiceError> {
    // Get the current time
    let time_now_secs = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();

    // Verify that the expiry date is in the future
    if exp_date_secs <= time_now_secs {
        return Err(PepperServiceError::BadRequest(format!(
            "The ephemeral public key expiry date has passed: exp_date_secs = {}, time_now_secs = {}",
            exp_date_secs, time_now_secs
        )));
    }

    // Get the maximum allowed expiry date
    let (max_exp_date_secs, overflowed) = claims
        .claims
        .iat
        .overflowing_add(keyless_configuration.max_exp_horizon_secs);
    if overflowed {
        return Err(PepperServiceError::BadRequest(
            "The maximum allowed expiry date overflowed".to_string(),
        ));
    }

    // Verify that the expiry date is within the allowed horizon
    if exp_date_secs >= max_exp_date_secs {
        Err(PepperServiceError::BadRequest(
            "The ephemeral public key expiry date is too far in the future (and beyond the max allowed horizon)".into()
        ))
    } else {
        Ok(())
    }
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L371-378)
```rust
                    openid_sig
                        .verify_jwt_claims(
                            signature.exp_date_secs,
                            &signature.ephemeral_pubkey,
                            public_key.inner_keyless_pk(),
                            config,
                        )
                        .map_err(|_| invalid_signature!("OpenID claim verification failed"))?;
```

**File:** types/src/keyless/configuration.rs (L62-73)
```rust
    pub fn new_for_devnet() -> Configuration {
        Configuration {
            override_aud_vals: vec![Self::OVERRIDE_AUD_FOR_TESTING.to_owned()],
            max_signatures_per_txn: 3,
            max_exp_horizon_secs: 10_000_000, // ~115.74 days
            training_wheels_pubkey: None,
            max_commited_epk_bytes: circuit_constants::MAX_COMMITED_EPK_BYTES,
            max_iss_val_bytes: circuit_constants::MAX_ISS_VAL_BYTES,
            max_extra_field_bytes: circuit_constants::MAX_EXTRA_FIELD_BYTES,
            max_jwt_header_b64_bytes: circuit_constants::MAX_JWT_HEADER_B64_BYTES,
        }
    }
```
