# Audit Report

## Title
Insufficient Validation of distance_from_validators Enables Peer Selection Manipulation in Consensus Observer

## Summary
Malicious untrusted peers can falsely claim low `distance_from_validators` values (2-100) in their `NetworkInformationResponse` without adequate validation, allowing them to manipulate consensus observer peer selection and cause denial of service by being preferentially selected for subscriptions despite being unable to provide valid consensus data.

## Finding Description

The peer monitoring service validates peer-reported `distance_from_validators` values based on peer roles for distances 0 and 1, but applies insufficient validation for distances ≥ 2. This breaks the peer selection security invariant that peers should be selected based on their actual proximity to validators. [1](#0-0) 

The validation logic correctly prevents validator impersonation (distance=0) and VFN impersonation (distance=1) by checking peer roles:

- **Distance 0**: Requires `peer_role.is_validator()` AND correct network context
- **Distance 1**: Requires `peer_role.is_vfn()` AND correct network context  
- **Distance ≥ 2**: Only checks `distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS` (100)

For untrusted peers with `PeerRole::Unknown` (not in trusted peers set), they can claim any distance from 2-100 and pass validation. These false distances are stored in the node's `PeersAndMetadata`: [2](#0-1) 

The consensus observer's peer selection algorithm prioritizes peers by distance (lower is better), making falsely-reporting peers preferentially selected: [3](#0-2) 

**Attack Path:**
1. Malicious peer M connects to consensus observer node O on public network
2. During Noise handshake, M is not in O's trusted peers set → assigned `PeerRole::Unknown`
3. O's peer monitoring client sends `GetNetworkInformation` request to M
4. M responds with `NetworkInformationResponse { distance_from_validators: 2, ... }` (false claim)
5. Validation passes (2 ≤ 100), false distance stored in O's metadata
6. When O selects peers for subscriptions, M ranks higher than honest peers at distance 10, 20, etc.
7. O subscribes to M expecting timely consensus data
8. M provides no data, stale data, or intentionally delays → subscription timeout/failure
9. In coordinated attack with multiple malicious peers, all subscriptions point to unhelpful peers

## Impact Explanation

This vulnerability enables **High Severity** impact under "Significant protocol violations" category:

- **Consensus Observer Denial of Service**: Malicious peers claiming false low distances monopolize subscription slots, preventing observers from receiving valid consensus data
- **Network Observability Degradation**: In coordinated attacks, all consensus observers in a region could be rendered ineffective
- **Service Disruption**: Exchanges, wallets, and infrastructure relying on consensus observers for real-time blockchain data would experience degraded service
- **Resource Exhaustion**: Network bandwidth and connection resources wasted on unhelpful peers

While the attack doesn't break consensus safety (validator signatures still validated), it significantly degrades protocol functionality by manipulating the peer selection mechanism that consensus observers depend on for reliable operation.

## Likelihood Explanation

**HIGH LIKELIHOOD:**

- **Low Attack Complexity**: Any peer can connect to public network and respond to monitoring requests with false data
- **No Special Access Required**: Attacker needs no validator keys, trusted peer status, or insider access
- **Scalable Attack**: Attacker can run multiple malicious peers claiming false distances
- **Persistent Effect**: False distances remain cached until peer connection ends or request retry
- **Weak Detection**: No mechanism to verify claimed distance against actual network topology

The attack is trivially executable and can be deployed at scale with commodity infrastructure.

## Recommendation

Implement stricter validation for `distance_from_validators` for untrusted peers:

**Option 1: Role-Based Distance Bounds**
```rust
distance_from_validators => {
    // Additional validation based on peer role
    let max_allowed_distance = match peer_metadata.get_connection_metadata().role {
        PeerRole::Unknown => {
            // Unknown peers on public network should have distance >= some minimum
            // to prevent false claims of proximity to validators
            if distance_from_validators < MIN_DISTANCE_FOR_UNKNOWN_PEERS {
                return false;
            }
        },
        _ => {},
    };
    distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
}
```

**Option 2: Cross-Peer Verification**
Before accepting a peer's distance claim, verify it's consistent with distances reported by other connected peers. A peer claiming distance=2 should have neighbors at distance=1 or 0.

**Option 3: Trust Decay for Untrusted Peers**
Introduce a "trust score" that increases when peers provide valid, timely data. For peer selection, weight both distance AND trust score, preventing new untrusted peers from immediately dominating selection.

**Recommended Implementation:**
Apply Option 1 with `MIN_DISTANCE_FOR_UNKNOWN_PEERS = 3`, preventing unknown peers from claiming they're within 2 hops of validators, combined with Option 3 for long-term robustness.

## Proof of Concept

```rust
// Mock malicious peer server responding to NetworkInformation requests
use aptos_peer_monitoring_service_types::response::{NetworkInformationResponse, ConnectionMetadata};
use std::collections::BTreeMap;

fn create_malicious_network_info_response() -> NetworkInformationResponse {
    NetworkInformationResponse {
        connected_peers: BTreeMap::new(),
        distance_from_validators: 2, // FALSE CLAIM - actually 50+ hops away
    }
}

// Test demonstrating the vulnerability
#[test]
fn test_untrusted_peer_false_distance_accepted() {
    // 1. Create a NetworkInfoState for a fullnode
    let node_config = create_test_node_config(RoleType::FullNode);
    let mut network_info_state = NetworkInfoState::new(node_config, TimeService::mock());
    
    // 2. Create peer metadata for an untrusted peer with PeerRole::Unknown
    let peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    let peer_metadata = create_peer_metadata_with_role(PeerRole::Unknown);
    
    // 3. Malicious peer responds with false distance = 2
    let malicious_response = create_malicious_network_info_response();
    
    // 4. Process the response - it should be accepted despite being false
    network_info_state.handle_monitoring_service_response(
        &peer_network_id,
        peer_metadata,
        PeerMonitoringServiceRequest::GetNetworkInformation,
        PeerMonitoringServiceResponse::NetworkInformation(malicious_response.clone()),
        0.1,
    );
    
    // 5. Verify the false distance was stored
    let stored_response = network_info_state.get_latest_network_info_response();
    assert!(stored_response.is_some());
    assert_eq!(stored_response.unwrap().distance_from_validators, 2);
    
    // 6. This peer would now be preferentially selected over honest peers
    // with correctly-reported distances of 5, 10, etc.
}
```

## Notes

The vulnerability specifically affects untrusted peers (not in trusted peers set) that get assigned `PeerRole::Unknown`. Trusted peers and peers with validated roles (Validator, ValidatorFullNode) have their distances properly validated. The issue is that the validation assumes distance ≥ 2 is safe for any peer role, when in reality untrusted peers should face stricter scrutiny on their distance claims to prevent peer selection manipulation attacks.

### Citations

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L116-154)
```rust
        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```

**File:** peer-monitoring-service/client/src/lib.rs (L232-260)
```rust
            // Update the latest peer monitoring metadata
            for peer_network_id in all_peers {
                let peer_monitoring_metadata =
                    match peer_monitor_state.peer_states.read().get(&peer_network_id) {
                        Some(peer_state) => {
                            peer_state
                                .extract_peer_monitoring_metadata()
                                .unwrap_or_else(|error| {
                                    // Log the error and return the default
                                    warn!(LogSchema::new(LogEntry::MetadataUpdateLoop)
                                        .event(LogEvent::UnexpectedErrorEncountered)
                                        .peer(&peer_network_id)
                                        .error(&error));
                                    PeerMonitoringMetadata::default()
                                })
                        },
                        None => PeerMonitoringMetadata::default(), // Use the default
                    };

                // Insert the latest peer monitoring metadata into peers and metadata
                if let Err(error) = peers_and_metadata
                    .update_peer_monitoring_metadata(peer_network_id, peer_monitoring_metadata)
                {
                    warn!(LogSchema::new(LogEntry::MetadataUpdateLoop)
                        .event(LogEvent::UnexpectedErrorEncountered)
                        .peer(&peer_network_id)
                        .error(&error.into()));
                }
            }
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L275-312)
```rust
/// Sorts the peers by subscription optimality (in descending order of
/// optimality). This requires: (i) sorting the peers by distance from the
/// validator set and ping latency (lower values are more optimal); and (ii)
/// filtering out peers that don't support consensus observer.
///
/// Note: we prioritize distance over latency as we want to avoid close
/// but not up-to-date peers. If peers don't have sufficient metadata
/// for sorting, they are given a lower priority.
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```
