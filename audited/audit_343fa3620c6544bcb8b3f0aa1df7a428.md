# Audit Report

## Title
Unencrypted Validator Private Key Storage Enables Complete Key Compromise Through Backup Theft

## Summary
Aptos validator private keys (account, consensus, and network keys) are stored in plaintext YAML files without encryption. Official documentation instructs operators to back up these files for disaster recovery, but provides no encryption guidance. If backup storage is compromised through cloud misconfiguration, supply chain attacks, or infrastructure breaches, attackers gain complete access to all validator cryptographic material, enabling consensus manipulation, reward theft, and validator impersonation.

## Finding Description

The Aptos codebase implements deterministic key generation from seeds using `KeyGen::from_seed()` [1](#0-0) , which generates all validator keys from a single 32-byte seed. These keys are then serialized to YAML files in plaintext format.

The vulnerability manifests in multiple components:

**1. Genesis Key Generation**

The genesis builder generates validator keys and writes them to plaintext YAML files [2](#0-1) . The `PrivateIdentity` structure contains all critical private keys: account private key (Ed25519), consensus private key (BLS12381), validator network private key (x25519), and full node network private key (x25519) [3](#0-2) .

**2. CLI Key Generation**

The `aptos genesis generate-keys` command writes private keys to `private-keys.yaml` using plaintext YAML serialization [4](#0-3) . The only security measure is Unix file permissions (0600) [5](#0-4) , which provides no protection once files are backed up.

**3. IdentityBlob Storage**

Validator identity is persisted using `IdentityBlob`, which contains private keys serialized directly to YAML without encryption [6](#0-5) . The private keys are serialized as hex-encoded strings using `serde_yaml::to_string()`.

**4. OnDisk Storage Backend**

The consensus safety rules use `OnDiskStorage` by default [7](#0-6) . This storage backend explicitly states it "should not be used in production" and "provides no security guarantees (e.g., encryption before writing to disk)" [8](#0-7) . Yet it writes all data in plaintext JSON [9](#0-8) .

**5. Official Backup Recommendations**

The deployment documentation explicitly instructs validators to back up their key files: "Backup your key files somewhere safe, this is important for you to establish ownership of your node, and it will be used to claim your rewards later if eligible. Very important!!" [10](#0-9) . The files listed include `private-keys.yaml`, `validator-identity.yaml`, and `validator-full-node-identity.yaml` [11](#0-10) , all containing plaintext private keys.

**Attack Path:**

1. Validator operator follows official documentation to generate keys using `aptos genesis generate-keys`
2. Keys are stored in plaintext YAML files with only filesystem permissions (0600) as protection
3. Operator backs up these files to disaster recovery storage (as officially recommended)
4. Backup storage is compromised through:
   - Cloud storage misconfiguration (public S3 bucket)
   - Compromised backup service provider or CI/CD system
   - Ransomware attack with data exfiltration
   - Supply chain attack on backup infrastructure
   - Insider threat at backup facility
5. Attacker extracts plaintext private keys from backup files
6. Attacker can now:
   - Sign consensus messages and blocks (using consensus private key)
   - Impersonate the validator on the network (using network private keys)
   - Steal validator rewards (using account private key)
   - Perform double-signing attacks leading to slashing

This breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure" - which includes secure key storage as a prerequisite.

## Impact Explanation

**Severity: Critical**

This vulnerability meets multiple Critical severity criteria per Aptos bug bounty:

1. **Loss of Funds**: Stolen account private keys enable theft of validator rewards and staked funds
2. **Consensus/Safety Violations**: Stolen consensus private keys enable signing malicious blocks, double-signing attacks, and consensus manipulation
3. **Validator Impersonation**: Stolen network keys enable complete validator impersonation

A single backup compromise exposes ALL validator keys, enabling:
- Participation in consensus as the compromised validator
- Creation of equivocation proofs leading to slashing
- Theft of all validator rewards and potentially staked assets
- Long-term persistent access (keys remain valid until rotated)

The impact is amplified because:
- Many validators may use similar backup strategies (cloud storage)
- A single cloud provider breach could expose multiple validators
- Keys stored in backups may not be rotated for extended periods

## Likelihood Explanation

**Likelihood: High**

Backup compromise is a well-documented attack vector in production systems:

1. **Cloud Storage Misconfiguration**: Frequent occurrences of publicly exposed S3 buckets and Azure containers containing sensitive data
2. **Supply Chain Attacks**: Backup service providers are attractive targets (e.g., SolarWinds, Kaseya incidents)
3. **Ransomware with Exfiltration**: Modern ransomware exfiltrates data before encryption, specifically targeting backups
4. **CI/CD Compromise**: Automated deployment systems often have access to validator keys and are frequently targeted

The likelihood is increased by:
- Official documentation recommends backups without encryption guidance
- No warning about OnDisk storage being used in production genesis builder
- Operators may not realize the files contain plaintext keys (YAML appears innocuous)
- Many operators use cloud services for backup, increasing attack surface

## Recommendation

Implement encryption at rest for all validator private key storage:

**1. Introduce Encrypted Storage Backend**
- Implement encryption layer in `OnDiskStorage` using authenticated encryption (AES-256-GCM)
- Derive encryption keys from hardware security modules (HSM) or system keyring
- Require explicit encryption passphrase for key file operations

**2. Update Genesis Builder**
- Switch default from `OnDiskStorage` to `Vault` backend for production
- Add explicit warning when OnDisk storage is used
- Require `--insecure-plaintext-keys` flag for unencrypted storage

**3. Encrypt Backup Files**
- Add `--encrypt` flag to `aptos genesis generate-keys` command
- Generate encrypted backup files using GPG or age encryption
- Update documentation to require backup encryption

**4. Key Derivation Alternative**
- Store only encrypted seed (32 bytes) instead of all derived keys
- Derive keys on-demand from encrypted seed
- Reduces backup attack surface to single encrypted value

**Example Fix for write_to_user_only_file:**

```rust
pub fn write_to_user_only_file_encrypted(
    path: &Path, 
    name: &str, 
    bytes: &[u8],
    encryption_key: &[u8; 32]
) -> CliTypedResult<()> {
    let nonce = generate_random_nonce();
    let cipher = Aes256Gcm::new(encryption_key.into());
    let encrypted_bytes = cipher.encrypt(&nonce, bytes)
        .map_err(|e| CliError::EncryptionError(e))?;
    
    // Write nonce + encrypted data
    let mut output = Vec::new();
    output.extend_from_slice(&nonce);
    output.extend_from_slice(&encrypted_bytes);
    
    write_to_user_only_file(path, name, &output)
}
```

**5. Update Documentation**
- Add prominent warning about backup encryption in all deployment READMEs
- Provide example commands for encrypted backups
- Document key rotation procedures for compromised keys

## Proof of Concept

```rust
// Demonstrates plaintext key storage vulnerability
use aptos_keygen::KeyGen;
use aptos_genesis::keys::generate_key_objects;
use std::fs;

fn main() {
    // Step 1: Generate validator keys from seed (as operators do)
    let seed: [u8; 32] = [0x42; 32]; // Deterministic seed
    let mut keygen = KeyGen::from_seed(seed);
    
    // Step 2: Generate all validator keys
    let (validator_blob, vfn_blob, private_identity, public_identity) = 
        generate_key_objects(&mut keygen).unwrap();
    
    // Step 3: Serialize to YAML (as done by genesis builder)
    let private_yaml = serde_yaml::to_string(&private_identity).unwrap();
    fs::write("private-keys.yaml", &private_yaml).unwrap();
    
    // Step 4: Demonstrate keys are plaintext
    let file_contents = fs::read_to_string("private-keys.yaml").unwrap();
    println!("=== PLAINTEXT PRIVATE KEYS IN BACKUP ===");
    println!("{}", file_contents);
    
    // Step 5: Show attacker can extract keys
    let stolen_identity: aptos_genesis::keys::PrivateIdentity = 
        serde_yaml::from_str(&file_contents).unwrap();
    
    println!("\n=== ATTACKER EXTRACTS KEYS ===");
    println!("Account key extracted: {}", 
        hex::encode(stolen_identity.account_private_key.to_bytes()));
    println!("Consensus key extracted: {}", 
        hex::encode(&stolen_identity.consensus_private_key.to_bytes()[0..32]));
    println!("Validator network key extracted: {}", 
        hex::encode(stolen_identity.validator_network_private_key.to_bytes()));
    
    println!("\n=== ATTACKER CAN NOW ===");
    println!("1. Sign consensus messages with consensus key");
    println!("2. Impersonate validator on network");
    println!("3. Steal validator rewards with account key");
    println!("4. Perform double-signing attacks");
}
```

**Execution:**
```bash
# Generate keys as operator
$ aptos genesis generate-keys --output-dir ~/validator-keys

# Back up files (as documentation recommends)  
$ cp ~/validator-keys/*.yaml ~/backups/

# Simulate backup compromise
$ cat ~/backups/private-keys.yaml
# Output shows plaintext private keys in hex format

# Attacker extracts and uses keys
# All validator cryptographic operations now compromised
```

## Notes

This vulnerability represents a systemic weakness in the validator key management architecture. While filesystem permissions (0600) provide basic protection on the live system, they offer no protection for backup copies stored in cloud services, backup tapes, or replicated storage systems. The widespread practice of backing up configuration and key files for disaster recovery transforms this plaintext storage into a critical security vulnerability.

The issue is exacerbated by the official documentation explicitly instructing operators to back up these files without mentioning encryption, and by the genesis builder using the insecure `OnDiskStorage` backend by default despite its own documentation warning against production use.

### Citations

**File:** crates/aptos-keygen/src/lib.rs (L21-23)
```rust
    pub fn from_seed(seed: [u8; 32]) -> Self {
        Self(StdRng::from_seed(seed))
    }
```

**File:** crates/aptos-genesis/src/builder.rs (L145-148)
```rust
            write_yaml(val_identity_file.as_path(), &validator_identity)?;
            write_yaml(vfn_identity_file.as_path(), &vfn_identity)?;
            write_yaml(private_identity_file.as_path(), &private_identity)?;
            write_yaml(public_identity_file.as_path(), &public_identity)?;
```

**File:** crates/aptos-genesis/src/builder.rs (L620-623)
```rust
        // Use a file based storage backend for safety rules
        let mut storage = OnDiskStorageConfig::default();
        storage.set_data_dir(validator.dir.clone());
        config.consensus.safety_rules.backend = SecureBackend::OnDiskStorage(storage);
```

**File:** crates/aptos-genesis/src/keys.rs (L15-22)
```rust
#[derive(Deserialize, Serialize)]
pub struct PrivateIdentity {
    pub account_address: AccountAddress,
    pub account_private_key: Ed25519PrivateKey,
    pub consensus_private_key: bls12381::PrivateKey,
    pub full_node_network_private_key: x25519::PrivateKey,
    pub validator_network_private_key: x25519::PrivateKey,
}
```

**File:** crates/aptos/src/genesis/keys.rs (L82-86)
```rust
        write_to_user_only_file(
            private_keys_file.as_path(),
            PRIVATE_KEYS_FILE,
            to_yaml(&private_identity)?.as_bytes(),
        )?;
```

**File:** crates/aptos/src/common/utils.rs (L223-228)
```rust
/// Write a User only read / write file
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
```

**File:** config/src/config/identity_config.rs (L24-46)
```rust
#[derive(Deserialize, Serialize)]
pub struct IdentityBlob {
    /// Optional account address. Used for validators and validator full nodes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_address: Option<AccountAddress>,
    /// Optional account key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_private_key: Option<Ed25519PrivateKey>,
    /// Optional consensus key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consensus_private_key: Option<bls12381::PrivateKey>,
    /// Network private key. Peer id is derived from this if account address is not present
    pub network_private_key: x25519::PrivateKey,
}

impl IdentityBlob {
    pub fn from_file(path: &Path) -> anyhow::Result<IdentityBlob> {
        Ok(serde_yaml::from_str(&fs::read_to_string(path)?)?)
    }

    pub fn to_file(&self, path: &Path) -> anyhow::Result<()> {
        let mut file = File::open(path)?;
        Ok(file.write_all(serde_yaml::to_string(self)?.as_bytes())?)
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```

**File:** secure/storage/src/on_disk.rs (L64-69)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
```

**File:** terraform/aptos-node/aws/README.md (L108-108)
```markdown
    This will create three files: `private-keys.yaml`, `validator-identity.yaml`, `validator-full-node-identity.yaml` for you. Backup your key files somewhere safe, this is important for you to establish ownership of your node, and it will be used to claim your rewards later if eligible. Very important!!
```

**File:** terraform/aptos-node/aws/README.md (L169-171)
```markdown
    - `private-keys.yaml` Private keys for owner account, consensus, networking
    - `validator-identity.yaml` Private keys for setting validator identity
    - `validator-full-node-identity.yaml` Private keys for setting validator full node identity
```
