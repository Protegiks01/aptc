# Audit Report

## Title
Off-by-One Error in Internal Indexer Causes Indexing Gaps When No New Transactions Occur

## Summary
The `InternalIndexerDBService::run()` method contains an off-by-one error that causes it to skip indexing the last committed transaction when `start_version == target_version`. The service waits indefinitely for new commits instead of processing the current version, creating indexing gaps when the node is idle.

## Finding Description

The vulnerability exists in the main processing loop of the internal indexer service. The issue stems from a mismatch between the semantics of the `DBIndexer::process()` method and how it's called in the service's run loop. [1](#0-0) 

The `process()` method is documented as "left inclusive, right exclusive" but internally adds 1 to include the end version: [2](#0-1) [3](#0-2) 

**The Attack Path:**

1. During node initialization, genesis transaction (version 0) is committed to AptosDB
2. The watch channel sender sends an update `(Instant, 0)` through the channel [4](#0-3) 

3. Later, `InternalIndexerDBService::run()` starts and reads:
   - `start_version = 0` (indexer DB is empty, nothing persisted yet)
   - `target_version = 0` (main DB has genesis at version 0)

4. The condition `target_version <= start_version` (i.e., `0 <= 0`) evaluates to TRUE
5. The service calls `update_receiver.changed().await` to wait for a NEW update
6. If the node remains idle with no new transactions, `changed()` blocks forever
7. Genesis transaction is never indexed

**Root Cause:** To process version N, `process(N, N+1)` must be called (due to the `while version < end_version` loop), but the code calls `process(start_version, target_version)` which equals `process(0, 0)` when both are 0. This processes nothing and waits indefinitely. [3](#0-2) 

## Impact Explanation

**Severity: Medium** - State inconsistencies requiring intervention

This vulnerability breaks the **State Consistency** invariant by creating indexing gaps. Specifically:

- **Indexing Gaps**: Transactions committed before or during service startup are not indexed until new transactions arrive
- **Query Inconsistencies**: API queries relying on the internal indexer will return incomplete data
- **Service Degradation**: The indexer appears healthy but silently fails to process recent transactions
- **Manual Intervention Required**: Operators must detect the gap and restart the service or wait for new transactions

This matches the Aptos bug bounty **Medium Severity** category: "State inconsistencies requiring intervention" (up to $10,000).

While this doesn't cause consensus violations or fund loss, it breaks data availability guarantees critical for dApps and users querying the blockchain state.

## Likelihood Explanation

**Likelihood: Medium to High**

This bug occurs reliably in specific scenarios:

1. **Fresh Node Deployment**: Any new validator or fullnode starting from genesis will hit this bug if no transactions occur immediately after startup
2. **Low-Activity Periods**: Testnets or private networks with infrequent transactions will experience prolonged indexing delays
3. **Service Restarts**: Restarting the internal indexer service during idle periods triggers the bug

**Attacker Requirements**: None - this is an inherent logic bug requiring no malicious input

**Frequency**: Occurs automatically whenever:
- `start_version == target_version` (equal versions)
- No new transactions are committed after service startup
- Common during initialization, testing, or low-activity periods

## Recommendation

Change the `process()` call to use `target_version + 1` to match the expected semantics: [5](#0-4) 

**Fix:**
```rust
pub async fn run(&mut self, node_config: &NodeConfig) -> Result<()> {
    let mut start_version = self.get_start_version(node_config).await?;
    let mut target_version = self.db_indexer.main_db_reader.ensure_synced_version()?;
    let mut step_timer = std::time::Instant::now();

    loop {
        if target_version < start_version {  // Changed: strict inequality
            match self.update_receiver.changed().await {
                Ok(_) => {
                    (step_timer, target_version) = *self.update_receiver.borrow();
                },
                Err(e) => {
                    panic!("Failed to get update from update_receiver: {}", e);
                },
            }
        }
        // FIX: Add 1 to target_version to process inclusively
        let next_version = self.db_indexer.process(start_version, target_version + 1)?;
        INDEXER_DB_LATENCY.set(step_timer.elapsed().as_millis() as i64);
        log_grpc_step(
            SERVICE_TYPE,
            IndexerGrpcStep::InternalIndexerDBProcessed,
            Some(start_version as i64),
            Some(next_version as i64),
            None,
            None,
            Some(step_timer.elapsed().as_secs_f64()),
            None,
            Some((next_version - start_version) as i64),
            None,
        );
        start_version = next_version;
    }
}
```

The `get_num_of_transactions()` method already safely caps at the actual synced version, so calling with `target_version + 1` is safe: [2](#0-1) 

## Proof of Concept

```rust
#[tokio::test]
async fn test_indexer_gap_on_equal_versions() {
    use aptos_config::config::NodeConfig;
    use aptos_db::AptosDB;
    use aptos_db_indexer::db_indexer::InternalIndexerDB;
    use aptos_indexer_grpc_table_info::internal_indexer_db_service::InternalIndexerDBService;
    use aptos_temppath::TempPath;
    use std::sync::Arc;
    use tokio::sync::watch;
    use std::time::{Duration, Instant};

    // Setup: Create test DB with genesis only
    let temp_path = TempPath::new();
    let mut node_config = NodeConfig::default();
    node_config.storage.dir = temp_path.path().to_path_buf();
    node_config.indexer_db_config.enable_event = true;
    node_config.indexer_db_config.enable_transaction = true;
    
    // Create internal indexer DB
    let internal_indexer_db = InternalIndexerDBService::get_indexer_db(&node_config).unwrap();
    
    // Create watch channel with initial value (Instant::now(), 0) - simulating genesis
    let (sender, receiver) = watch::channel::<(Instant, u64)>((Instant::now(), 0));
    
    // Create mock DB reader that returns synced_version = 0 (genesis committed)
    // ... (mock setup code)
    
    // Create the service
    let mut service = InternalIndexerDBService::new(
        db_reader,
        internal_indexer_db.clone(),
        receiver
    );
    
    // Attempt to run the service
    let handle = tokio::spawn(async move {
        service.run(&node_config).await
    });
    
    // Wait a reasonable time
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    // BUG: The service should have indexed version 0, but it's still waiting
    // Verify that indexer DB has NOT processed version 0
    let persisted_version = internal_indexer_db.get_persisted_version().unwrap();
    assert_eq!(persisted_version, None); // BUG: Should be Some(0)!
    
    // The service is blocked in changed().await waiting for a new commit
    // Even though version 0 exists and should be processed
}
```

**Expected Behavior:** After service starts with genesis at version 0, it should immediately index version 0.

**Actual Behavior:** Service blocks waiting for version 1 to be committed, leaving version 0 unindexed.

---

**Notes:**

While the security question asked specifically about the `update_receiver` being "consumed or closed," the actual vulnerability is more subtle. The receiver cannot be "consumed" in the traditional Rust sense (watch receivers are Clone). However, the bug manifests when:

1. The receiver was created and updates were sent during initialization
2. The service starts with `start_version == target_version` 
3. The `changed()` wait condition requires a NEW change after the current check
4. This creates a race where the last committed version isn't indexed until a future commit

The fix addresses the root cause: the off-by-one error in how `process()` is invoked, ensuring all committed transactions are indexed regardless of the watch channel state.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L167-199)
```rust
    pub async fn run(&mut self, node_config: &NodeConfig) -> Result<()> {
        let mut start_version = self.get_start_version(node_config).await?;
        let mut target_version = self.db_indexer.main_db_reader.ensure_synced_version()?;
        let mut step_timer = std::time::Instant::now();

        loop {
            if target_version <= start_version {
                match self.update_receiver.changed().await {
                    Ok(_) => {
                        (step_timer, target_version) = *self.update_receiver.borrow();
                    },
                    Err(e) => {
                        panic!("Failed to get update from update_receiver: {}", e);
                    },
                }
            }
            let next_version = self.db_indexer.process(start_version, target_version)?;
            INDEXER_DB_LATENCY.set(step_timer.elapsed().as_millis() as i64);
            log_grpc_step(
                SERVICE_TYPE,
                IndexerGrpcStep::InternalIndexerDBProcessed,
                Some(start_version as i64),
                Some(next_version as i64),
                None,
                None,
                Some(step_timer.elapsed().as_secs_f64()),
                None,
                Some((next_version - start_version) as i64),
                None,
            );
            start_version = next_version;
        }
    }
```

**File:** storage/indexer/src/db_indexer.rs (L382-394)
```rust
    fn get_num_of_transactions(&self, version: Version, end_version: Version) -> Result<u64> {
        let highest_version = min(self.main_db_reader.ensure_synced_version()?, end_version);
        if version > highest_version {
            // In case main db is not synced yet or recreated
            return Ok(0);
        }
        // we want to include the last transaction since the iterator interface will is right exclusive.
        let num_of_transaction = min(
            self.indexer_db.config.batch_size as u64,
            highest_version + 1 - version,
        );
        Ok(num_of_transaction)
    }
```

**File:** storage/indexer/src/db_indexer.rs (L396-407)
```rust
    /// Process all transactions from `start_version` to `end_version`. Left inclusive, right exclusive.
    pub fn process(&self, start_version: Version, end_version: Version) -> Result<Version> {
        let mut version = start_version;
        while version < end_version {
            let next_version = self.process_a_batch(version, end_version)?;
            if next_version == version {
                break;
            }
            version = next_version;
        }
        Ok(version)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L603-624)
```rust
    fn post_commit(
        &self,
        old_committed_version: Option<Version>,
        version: Version,
        ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
        chunk_opt: Option<ChunkToCommit>,
    ) -> Result<()> {
        // If commit succeeds and there are at least one transaction written to the storage, we
        // will inform the pruner thread to work.
        if old_committed_version.is_none() || version > old_committed_version.unwrap() {
            let first_version = old_committed_version.map_or(0, |v| v + 1);
            let num_txns = version + 1 - first_version;

            COMMITTED_TXNS.inc_by(num_txns);
            LATEST_TXN_VERSION.set(version as i64);
            if let Some(update_sender) = &self.update_subscriber {
                update_sender
                    .send((Instant::now(), version))
                    .map_err(|err| {
                        AptosDbError::Other(format!("Failed to send update to subscriber: {}", err))
                    })?;
            }
```
