# Audit Report

## Title
Aggregator V1 Creation Storage Fee Bypass via Legacy Modification Conversion

## Summary
When the `STORAGE_SLOT_METADATA` feature flag is disabled, Aggregator V1 creation operations are incorrectly converted to `WriteOp::legacy_modification` instead of `WriteOp::legacy_creation`, bypassing slot creation fees and causing metadata inconsistencies.

## Finding Description

The `convert_aggregator_modification` function handles both creation and modification of Aggregator V1 values. When processing an aggregator write operation for a non-existent aggregator (creation scenario), the function checks whether storage slot metadata is enabled: [1](#0-0) 

When `new_slot_metadata` is `None` (indicating `STORAGE_SLOT_METADATA` feature is disabled), the code uses `WriteOp::legacy_modification(data)` even for new aggregator creation. This bypasses the proper operation type distinction that exists in the base `convert` function: [2](#0-1) 

The storage fee calculation system treats Creation and Modification operations differently: [3](#0-2) 

Creation operations charge `legacy_storage_fee_per_state_slot_create` plus bytes fees, while Modification operations only charge bytes fees. By marking aggregator creations as modifications, the slot creation fee is bypassed.

**Attack Path:**
1. Attacker waits for or triggers `STORAGE_SLOT_METADATA` feature flag to be disabled
2. Attacker sends transactions creating multiple Aggregator V1 instances
3. Each creation is processed through `convert_aggregator_modification`
4. WriteOps are created as Modifications instead of Creations
5. Storage fee system only charges bytes fees, skipping slot creation fees
6. Attacker creates state slots at significantly reduced cost

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per Aptos bug bounty program:
- **Limited funds loss**: Storage fees are undercharged for aggregator creations, resulting in economic loss to the protocol
- **State inconsistencies**: Write operations are semantically incorrect (Modification vs Creation), creating metadata tracking issues that may require intervention

The issue violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" - storage fees are not correctly assessed for aggregator creations.

## Likelihood Explanation

**Likelihood: Low to Medium**

The exploitability depends on the `STORAGE_SLOT_METADATA` feature flag state:
- If currently enabled on mainnet: Not immediately exploitable
- If disabled or can be disabled through governance: Directly exploitable
- Historical deployments or testnets with disabled metadata: Already affected

The comment at line 281 indicates this is intentional "legacy" behavior, suggesting it was the original design before metadata support was added. However, the storage fee system was not updated to account for this legacy path, creating the vulnerability.

## Recommendation

Fix the inconsistency by properly distinguishing Creation from Modification for aggregator operations:

```rust
pub(crate) fn convert_aggregator_modification(
    &self,
    state_key: &StateKey,
    value: u128,
) -> PartialVMResult<WriteOp> {
    let maybe_existing_metadata = self
        .remote
        .get_aggregator_v1_state_value_metadata(state_key)?;
    let data = serialize(&value).into();

    let op = match maybe_existing_metadata {
        None => {
            match &self.new_slot_metadata {
                // FIX: Use legacy_creation instead of legacy_modification for new aggregators
                None => WriteOp::legacy_creation(data),
                Some(metadata) => WriteOp::creation(data, metadata.clone()),
            }
        },
        Some(metadata) => WriteOp::modification(data, metadata),
    };

    Ok(op)
}
```

Alternatively, use the proper `convert` function with explicit `MoveStorageOp::New` or `MoveStorageOp::Modify` based on metadata existence, similar to how resources and tables are handled.

## Proof of Concept

```rust
#[test]
fn test_aggregator_creation_fee_bypass() {
    use aptos_types::on_chain_config::FeatureFlag;
    
    // Create test harness with STORAGE_SLOT_METADATA disabled
    let mut harness = MoveHarness::new_with_features(
        vec![],  // Empty features - metadata disabled
        vec![FeatureFlag::STORAGE_SLOT_METADATA],  // Explicitly disable
    );
    
    let account = harness.new_account_at(AccountAddress::random());
    
    // Create an aggregator V1 through native functions
    let result = harness.run_transaction_payload(
        &account,
        aptos_stdlib::aggregator_v1_create_aggregator(1000),
    );
    
    // Extract the write set
    let write_set = result.write_set();
    
    // Find the aggregator state key write op
    for (key, write_op) in write_set {
        if key.is_aggregator() {
            // VULNERABILITY: Should be Creation, but is Modification
            assert!(matches!(
                write_op.as_base_op(),
                BaseStateOp::Modification(_)
            ), "Aggregator creation incorrectly marked as Modification");
            
            // Calculate fees - will show missing slot creation fee
            let fee_params = harness.get_gas_params();
            let charge_refund = DiskSpacePricing::V1.charge_refund_write_op(
                &fee_params,
                WriteOpInfo { key, op_size: write_op.project_write_op_size(|| Some(100)), metadata_mut: write_op.metadata() }
            );
            
            // VERIFY: Slot creation fee is NOT charged
            assert_eq!(charge_refund.charge, /* only bytes fee, no slot fee */);
        }
    }
}
```

**Notes:**
- This vulnerability is explicitly acknowledged in the code comment as "legacy" behavior for backward compatibility
- The issue only manifests when `STORAGE_SLOT_METADATA` feature flag is disabled
- While the behavior appears intentional, it creates an economic inconsistency where aggregators are undercharged compared to other state items
- The storage fee bypass is deterministic and affects all validators equally, so it doesn't cause consensus divergence
- The primary impact is economic (undercharged fees) rather than state corruption or consensus violation

### Citations

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L230-258)
```rust
        let write_op = match (state_value_metadata, move_storage_op) {
            (None, Modify(_) | Delete) => {
                // Possible under speculative execution, returning speculative error waiting for re-execution.
                return Err(
                    PartialVMError::new(StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR)
                        .with_message(
                            "When converting write op: updating non-existent value.".to_string(),
                        ),
                );
            },
            (Some(_), New(_)) => {
                // Possible under speculative execution, returning speculative error waiting for re-execution.
                return Err(
                    PartialVMError::new(StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR)
                        .with_message(
                            "When converting write op: Recreating existing value.".to_string(),
                        ),
                );
            },
            (None, New(data)) => match &self.new_slot_metadata {
                None => {
                    if legacy_creation_as_modification {
                        WriteOp::legacy_modification(data)
                    } else {
                        WriteOp::legacy_creation(data)
                    }
                },
                Some(metadata) => WriteOp::creation(data, metadata.clone()),
            },
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L278-284)
```rust
        let op = match maybe_existing_metadata {
            None => {
                match &self.new_slot_metadata {
                    // n.b. Aggregator writes historically did not distinguish Create vs Modify.
                    None => WriteOp::legacy_modification(data),
                    Some(metadata) => WriteOp::creation(data, metadata.clone()),
                }
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L124-145)
```rust
            Creation { write_len } => {
                let slot_fee = params.legacy_storage_fee_per_state_slot_create * NumSlots::new(1);
                let bytes_fee = Self::discounted_write_op_size_for_v1(params, op.key, write_len)
                    * params.legacy_storage_fee_per_excess_state_byte;

                if !op.metadata_mut.is_none() {
                    op.metadata_mut.set_slot_deposit(slot_fee.into())
                }

                ChargeAndRefund {
                    charge: slot_fee + bytes_fee,
                    refund: 0.into(),
                }
            },
            Modification { write_len } => {
                let bytes_fee = Self::discounted_write_op_size_for_v1(params, op.key, write_len)
                    * params.legacy_storage_fee_per_excess_state_byte;

                ChargeAndRefund {
                    charge: bytes_fee,
                    refund: 0.into(),
                }
```
