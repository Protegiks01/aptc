# Audit Report

## Title
API Handlers Fail to Check Granular Internal Indexer Feature Flags, Causing Endpoint Failures

## Summary
API handlers in `api/src/context.rs` check whether the internal indexer is enabled but fail to verify if specific indexer features (events, transactions, state keys) are enabled before invoking corresponding indexer methods. This causes API endpoints to crash with internal server errors when node operators configure storage sharding with partial indexer features enabled.

## Finding Description

The internal indexer DB configuration supports granular feature flags:
- `enable_event`: enables event indexing
- `enable_transaction`: enables transaction-by-account indexing  
- `enable_statekeys`: enables state key indexing [1](#0-0) 

The `is_internal_indexer_db_enabled()` function returns `true` if **any** of these features is enabled, not all. [1](#0-0) 

API handlers use a two-level check:
1. Is DB sharding enabled? (`db_sharding_enabled()`)
2. Does `indexer_reader` exist? [2](#0-1) 

However, they **do not** check if the specific feature is enabled. For example, `get_events()`: [3](#0-2) 

The `IndexerReaders::get_events()` implementation performs a feature-specific check: [4](#0-3) 

**Attack Scenario:**
1. Node operator configures: `enable_storage_sharding: true`, `enable_event: false`, `enable_transaction: true`, `enable_statekeys: false`
2. This configuration passes validation [5](#0-4) 
3. User calls `/accounts/{address}/events/{creation_number}`
4. API handler checks sharding enabled ✓ and `indexer_reader` exists ✓
5. Calls `indexer_reader.get_events()`
6. Returns error: "Internal event index is not enabled"
7. API returns 500 Internal Server Error

**Affected Methods:**
- `get_events()` - doesn't verify `enable_event` [6](#0-5) 

- `get_state_values()` - doesn't verify `enable_statekeys` [7](#0-6) 

- `get_resources_by_pagination()` - doesn't verify `enable_statekeys` [8](#0-7) 

- `get_modules_by_pagination()` - doesn't verify `enable_statekeys` [9](#0-8) 

- `get_account_ordered_transactions()` - doesn't verify `enable_transaction` [10](#0-9) 

## Impact Explanation

**High Severity** per Aptos bug bounty criteria - "API crashes"

This bug causes multiple API endpoints to fail with 500 Internal Server Error responses when:
- Storage sharding is enabled (common in production)
- Not all internal indexer features are enabled (legitimate configuration)
- Users attempt to query data requiring disabled features

Affected endpoints include:
- `GET /accounts/{address}/events/{creation_number}` 
- `GET /accounts/{address}/events/{event_handle}/{field_name}`
- `GET /accounts/{address}/resources` (with pagination)
- `GET /accounts/{address}/modules` (with pagination)
- `GET /accounts/{address}/transactions`

The failures manifest as internal server errors rather than graceful "feature not enabled" responses, degrading API availability and reliability.

## Likelihood Explanation

**Likelihood: High**

Storage sharding is the default configuration (`enable_storage_sharding: true` by default). Node operators may legitimately disable specific indexer features they don't need to reduce resource consumption. For example:
- A validator node might only enable `enable_transaction` but not events or state keys
- An archive node might selectively enable features based on use case

The config sanitizer only enforces that internal indexer requires sharding, not that all features must be enabled together. [5](#0-4) 

Any user making standard API calls will trigger the bug when attempting operations that require disabled features.

## Recommendation

API handlers should check feature-specific flags before invoking indexer methods. Two approaches:

**Approach 1: Check in Context methods**
```rust
pub fn get_events(...) -> Result<Vec<EventWithVersion>> {
    let mut res = if !db_sharding_enabled(&self.node_config) {
        self.db.get_events(event_key, start, order, limit as u64, ledger_version)?
    } else {
        let reader = self.indexer_reader
            .as_ref()
            .ok_or_else(|| anyhow!("Internal indexer reader doesn't exist"))?;
        
        // NEW: Check feature-specific flag
        if !self.node_config.indexer_db_config.enable_event() {
            bail!("Event indexing is not enabled on this node");
        }
        
        reader.get_events(event_key, start, order, limit as u64, ledger_version)?
    };
    // ... rest of method
}
```

Apply similar checks in:
- `get_state_values()` - check `enable_statekeys()`
- `get_resources_by_pagination()` - check `enable_statekeys()`
- `get_modules_by_pagination()` - check `enable_statekeys()`
- `get_account_ordered_transactions()` - check `enable_transaction()`

**Approach 2: Fallback to main DB**
When feature is disabled but sharding is enabled, fallback to querying the main DB directly (if supported), or return a clear error indicating the feature is disabled.

## Proof of Concept

**Configuration File** (`node_config.yaml`):
```yaml
storage:
  rocksdb_configs:
    enable_storage_sharding: true

indexer_db_config:
  enable_transaction: true
  enable_event: false  # Event indexing DISABLED
  enable_statekeys: false
```

**Reproduction Steps:**
1. Start Aptos node with above configuration
2. Wait for node to sync
3. Query events endpoint:
```bash
curl http://localhost:8080/v1/accounts/0x1/events/0
```

**Expected Result:** 500 Internal Server Error with message "Internal event index is not enabled"

**Rust Test Reproduction:**
```rust
#[test]
fn test_api_event_query_with_disabled_indexer_feature() {
    let mut config = NodeConfig::default();
    config.storage.rocksdb_configs.enable_storage_sharding = true;
    config.indexer_db_config.enable_event = false;
    config.indexer_db_config.enable_transaction = true;
    
    // Initialize context with this config
    // Attempt to call get_events()
    // Assert: Returns error "Internal event index is not enabled"
}
```

## Notes

This vulnerability affects API availability but not consensus or fund security. The issue stems from incomplete validation at the API handler layer - handlers check for indexer existence but not feature-specific enablement. The bug is exacerbated by the valid use case of selective feature enablement for resource optimization.

### Citations

**File:** config/src/config/internal_indexer_db_config.rs (L60-62)
```rust
    pub fn is_internal_indexer_db_enabled(&self) -> bool {
        self.enable_transaction || self.enable_event || self.enable_statekeys
    }
```

**File:** config/src/config/internal_indexer_db_config.rs (L91-99)
```rust
        // Shouldn't turn on internal indexer for db without sharding
        if !node_config.storage.rocksdb_configs.enable_storage_sharding
            && config.is_internal_indexer_db_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Don't turn on internal indexer db if DB sharding is off".into(),
            ));
        }
```

**File:** api/src/context.rs (L443-458)
```rust
        let mut iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        None,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(&StateKeyPrefix::from(address), None, version)?
        };
```

**File:** api/src/context.rs (L477-496)
```rust
        let account_iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        prev_state_key,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(
                    &StateKeyPrefix::from(address),
                    prev_state_key,
                    version,
                )?
        };
```

**File:** api/src/context.rs (L568-587)
```rust
        let account_iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        prev_state_key,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(
                    &StateKeyPrefix::from(address),
                    prev_state_key,
                    version,
                )?
        };
```

**File:** api/src/context.rs (L900-923)
```rust
        let txns_res = if !db_sharding_enabled(&self.node_config) {
            self.db.get_account_ordered_transactions(
                address,
                start_seq_number,
                limit as u64,
                true,
                ledger_version,
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| anyhow!("Indexer reader is None"))
                .map_err(|err| {
                    E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
                })?
                .get_account_ordered_transactions(
                    address,
                    start_seq_number,
                    limit as u64,
                    true,
                    ledger_version,
                )
                .map_err(|e| AptosDbError::Other(e.to_string()))
        };
```

**File:** api/src/context.rs (L1084-1111)
```rust
    pub fn get_events(
        &self,
        event_key: &EventKey,
        start: Option<u64>,
        limit: u16,
        ledger_version: u64,
    ) -> Result<Vec<EventWithVersion>> {
        let (start, order) = if let Some(start) = start {
            (start, Order::Ascending)
        } else {
            (u64::MAX, Order::Descending)
        };
        let mut res = if !db_sharding_enabled(&self.node_config) {
            self.db
                .get_events(event_key, start, order, limit as u64, ledger_version)?
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| anyhow!("Internal indexer reader doesn't exist"))?
                .get_events(event_key, start, order, limit as u64, ledger_version)?
        };
        if order == Order::Descending {
            res.reverse();
            Ok(res)
        } else {
            Ok(res)
        }
    }
```

**File:** api/src/context.rs (L1771-1773)
```rust
fn db_sharding_enabled(node_config: &NodeConfig) -> bool {
    node_config.storage.rocksdb_configs.enable_storage_sharding
}
```

**File:** storage/indexer/src/indexer_reader.rs (L76-87)
```rust
        if let Some(db_indexer_reader) = &self.db_indexer_reader {
            if db_indexer_reader.indexer_db.event_enabled() {
                return Ok(db_indexer_reader.get_events(
                    event_key,
                    start,
                    order,
                    limit,
                    ledger_version,
                )?);
            } else {
                anyhow::bail!("Internal event index is not enabled")
            }
```
