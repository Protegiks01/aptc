# Audit Report

## Title
Guard Type Lacks !Send Marker Allowing Cross-Thread Migration in Async Contexts Breaking Memory Fence Synchronization

## Summary
The `Guard<'a, T>` type in `ExplicitSyncWrapper` is implicitly `Send` due to containing only a reference to a `Sync` type. This allows the Guard to be held across `.await` points in async contexts, enabling task migration between threads. Since memory fences only establish ordering guarantees within a single thread, having the `acquire()` fence execute on one thread and the `unlock()` release fence execute on another thread breaks the intended synchronization guarantees, potentially causing data races on the underlying `UnsafeCell`. [1](#0-0) 

## Finding Description
The `Guard` type is designed to provide RAII-style access to `ExplicitSyncWrapper`, issuing an Acquire fence on creation and a Release fence on drop: [2](#0-1) [3](#0-2) 

The critical issue is that `Guard` is implicitly `Send` because:
1. It contains only `&'a ExplicitSyncWrapper<T>`
2. `ExplicitSyncWrapper<T>` implements `Sync` [4](#0-3) 
3. In Rust, `&T` is `Send` when `T: Sync`
4. There is no explicit `impl !Send for Guard<'_, T>` marker

When `Guard` is `Send`, it can be moved across threads, including in async contexts where tasks holding the Guard across `.await` points can be migrated by the runtime. The synchronization protocol relies on acquire/release fence semantics, but **memory fences only establish happens-before relationships within a single thread**. If the acquire fence executes on Thread A and the release fence executes on Thread B (after task migration), no cross-thread synchronization occurs.

The block executor uses `ExplicitSyncWrapper` to protect critical shared state: [5](#0-4) 

While the current codebase uses Rayon thread pools (synchronous) and calls the block executor via `spawn_blocking` from async contexts: [6](#0-5) 

The public API allows future misuse if Guards were held across `.await` points in refactored or external code using these primitives.

## Impact Explanation
This vulnerability is classified as **Medium Severity** per Aptos bug bounty criteria for the following reasons:

1. **Not Currently Exploited**: No existing code in the repository holds Guards across `.await` points. The block executor is properly isolated via `spawn_blocking`.

2. **Latent API Vulnerability**: The type system permits incorrect usage that would cause undefined behavior (data races on `UnsafeCell`). This could lead to:
   - Corruption of `block_limit_processor` (gas limit tracking)
   - Corruption of `final_results` (transaction outputs)
   - Corruption of `maybe_block_epilogue_txn_idx`

3. **Potential Critical Impact**: If exploited through future refactoring or external usage, data races on these structures would violate the **Deterministic Execution** invariant (all validators must produce identical state roots) and **State Consistency** invariant, potentially causing consensus violations.

4. **Requires Code Changes**: Exploitation requires either internal refactoring that introduces the bug or external code using the public API incorrectly. This is not directly exploitable by an external attacker submitting transactions.

## Likelihood Explanation
**Low to Medium Likelihood:**

- **Current Risk**: Low - the existing codebase doesn't misuse the API
- **Future Risk**: Medium - potential for introduction during:
  - Refactoring to native async/await for performance
  - External libraries using `ExplicitSyncWrapper` as a public primitive
  - Maintenance by developers unfamiliar with the fence semantics

The risk increases if the block executor is ever refactored to use async/await patterns directly instead of `spawn_blocking`, or if `ExplicitSyncWrapper` is exposed as a general-purpose synchronization primitive.

## Recommendation
Add an explicit `!Send` marker to prevent `Guard` from being moved across threads:

```rust
impl<T> !Send for Guard<'_, T> {}
```

This makes it a compile-time error to hold `Guard` across `.await` points or move it between threads, preventing the synchronization violation. This is the standard pattern for RAII guards that rely on thread-local guarantees (e.g., `std::sync::MutexGuard` is also `!Send`).

Add the marker after line 26 in the file: [1](#0-0) 

## Proof of Concept

```rust
// This PoC demonstrates that Guard is currently Send and can be held across .await
// In a real async runtime, this would allow task migration breaking synchronization

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;

    #[tokio::test]
    async fn test_guard_is_send_vulnerability() {
        // Create a wrapper protecting some shared state
        let wrapper = Arc::new(ExplicitSyncWrapper::new(vec![1, 2, 3]));
        let wrapper_clone = wrapper.clone();
        
        // Spawn an async task that holds Guard across await
        let handle = tokio::spawn(async move {
            // Acquire the guard on one thread
            let mut guard = wrapper_clone.acquire();
            println!("Guard acquired on thread: {:?}", std::thread::current().id());
            
            // Hold guard across await - task may migrate to different thread
            tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
            
            // Guard drops here - potentially on a different thread
            // This breaks the acquire/release fence synchronization
            guard.push(4);
            println!("Guard dropped on thread: {:?}", std::thread::current().id());
        });
        
        handle.await.unwrap();
        
        // This compiles successfully because Guard is Send
        // With the fix (impl !Send for Guard), this would be a compile error:
        // "future cannot be sent between threads safely"
    }
    
    // This test verifies that Guard is currently Send (it should fail to compile after fix)
    fn _assert_guard_is_send<T: Send>() {}
    fn _verify_guard_send_property() {
        _assert_guard_is_send::<Guard<'_, i32>>();  // Currently compiles, should fail after fix
    }
}
```

**Expected behavior after fix**: The test should fail to compile with error message indicating that `Guard` cannot be sent between threads, preventing the vulnerability at compile time.

## Notes

This is a **latent API design vulnerability** rather than an actively exploited bug. While no current code paths in the Aptos codebase misuse the API, the type system allows incorrect usage that would cause undefined behavior. The fix is straightforward (adding `!Send`) and aligns with Rust best practices for RAII guards that rely on thread-local semantics. This prevents both accidental misuse during refactoring and intentional misuse by external code.

### Citations

**File:** aptos-move/block-executor/src/explicit_sync_wrapper.rs (L24-26)
```rust
pub struct Guard<'a, T> {
    lock: &'a ExplicitSyncWrapper<T>,
}
```

**File:** aptos-move/block-executor/src/explicit_sync_wrapper.rs (L35-42)
```rust
    pub fn acquire(&self) -> Guard<'_, T> {
        atomic::fence(atomic::Ordering::Acquire);
        Guard { lock: self }
    }

    pub(crate) fn unlock(&self) {
        atomic::fence(atomic::Ordering::Release);
    }
```

**File:** aptos-move/block-executor/src/explicit_sync_wrapper.rs (L89-93)
```rust
impl<T> Drop for Guard<'_, T> {
    fn drop(&mut self) {
        self.lock.unlock();
    }
}
```

**File:** aptos-move/block-executor/src/explicit_sync_wrapper.rs (L95-95)
```rust
unsafe impl<T> Sync for ExplicitSyncWrapper<T> {}
```

**File:** aptos-move/block-executor/src/executor.rs (L96-98)
```rust
    block_limit_processor: &'a ExplicitSyncWrapper<BlockGasLimitProcessor<T>>,
    final_results: &'a ExplicitSyncWrapper<Vec<E::Output>>,
    maybe_block_epilogue_txn_idx: &'a ExplicitSyncWrapper<Option<TxnIndex>>,
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L857-867)
```rust
        tokio::task::spawn_blocking(move || {
            executor
                .execute_and_update_state(
                    (block.id(), txns, auxiliary_info).into(),
                    block.parent_id(),
                    onchain_execution_config,
                )
                .map_err(anyhow::Error::from)
        })
        .await
        .expect("spawn blocking failed")?;
```
