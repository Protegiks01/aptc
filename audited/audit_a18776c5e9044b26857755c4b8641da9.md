# Audit Report

## Title
Missing Epoch Consistency Validation in SafetyRules.sign_proposal() Allows Cross-Epoch Block Signing

## Summary
The `SafetyRules::guarded_sign_proposal()` function fails to validate that the `BlockData.epoch` field matches the epoch of the block certified by the embedded `QuorumCert`. This allows signing of malformed proposals that mix epochs, violating a fundamental consensus safety invariant.

## Finding Description

The `SafetyRules::guarded_sign_proposal()` function in [1](#0-0)  performs several critical safety checks before signing a proposal, but **omits validation that the BlockData's epoch matches its QuorumCert's certified block epoch**.

The function validates:
1. The epoch matches the stored safety_data.epoch [2](#0-1) 
2. The QuorumCert has valid signatures [3](#0-2) 
3. Round progression rules [4](#0-3) 

However, it **never checks** that `block_data.epoch() == block_data.quorum_cert().certified_block().epoch()`.

In contrast, `Block::verify_well_formed()` explicitly enforces this invariant [5](#0-4) , and `SafetyRules::verify_proposal()` (used for voting) calls `verify_well_formed()` [6](#0-5) .

**Attack Scenario:**

A compromised validator node or buggy code could construct malicious `BlockData` using [7](#0-6) :

```
BlockData::new_for_testing(
    epoch: 10,           // Current epoch
    round: valid_round,
    timestamp_usecs: valid_timestamp,
    quorum_cert: qc_from_epoch_9,  // QC from previous epoch!
    block_type: BlockType::Proposal { ... }
)
```

When passed to `sign_proposal()`:
- ✓ `verify_epoch(10, safety_data{epoch:10})` passes
- ✓ `verify_qc(qc_from_epoch_9)` passes (valid signatures)
- ✗ No check that epoch(10) != qc.certified_block().epoch(9)
- Result: **Signature is generated and returned**

This violates the invariant that blocks must extend QCs from the same epoch, breaking the chain of custody across epoch boundaries.

## Impact Explanation

**Severity: High** (Not Critical because exploitation requires node compromise)

This vulnerability breaks **Consensus Safety** - specifically the invariant that validator set transitions must be atomic and properly chained. While other validators would reject such proposals via `verify_well_formed()`, the fact that SafetyRules signs invalid data represents a critical failure of the safety layer.

**Potential consequences:**
1. **Safety layer bypass**: SafetyRules is supposed to be the authoritative safety enforcer but can be tricked
2. **Chain of custody violation**: Signatures span epochs incorrectly  
3. **Defense-in-depth failure**: Missing validation creates single point of failure
4. **Future exploit potential**: Could be chained with other vulnerabilities to cause actual safety violations

This does not qualify as Critical because:
- Requires node compromise to construct malicious `BlockData`
- Network would reject the proposal (defense in depth still works at voting stage)
- No immediate consensus split or fund loss

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability exists in production code and is exploitable, but requires:

1. **Prerequisite conditions**:
   - Compromised validator node OR buggy proposal generator code
   - Ability to construct arbitrary `BlockData` structures
   - Access to sign_proposal() call path

2. **Mitigating factors**:
   - Normal `ProposalGenerator` constructs BlockData correctly [8](#0-7) 
   - Other validators reject malformed proposals [5](#0-4) 
   - No direct network path to inject malicious BlockData

3. **Risk factors**:
   - Violates defense-in-depth principles
   - Future code changes could introduce bugs that construct invalid BlockData
   - Could be combined with other vulnerabilities

## Recommendation

Add epoch consistency validation in `SafetyRules::guarded_sign_proposal()`:

```rust
fn guarded_sign_proposal(
    &mut self,
    block_data: &BlockData,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;
    self.verify_author(block_data.author())?;

    let mut safety_data = self.persistent_storage.safety_data()?;
    self.verify_epoch(block_data.epoch(), &safety_data)?;

    // ADD THIS VALIDATION:
    if block_data.epoch() != block_data.quorum_cert().certified_block().epoch() {
        return Err(Error::IncorrectEpoch(
            block_data.epoch(),
            block_data.quorum_cert().certified_block().epoch(),
        ));
    }

    if block_data.round() <= safety_data.last_voted_round {
        return Err(Error::InvalidProposal(format!(
            "Proposed round {} is not higher than last voted round {}",
            block_data.round(),
            safety_data.last_voted_round
        )));
    }

    self.verify_qc(block_data.quorum_cert())?;
    self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;

    let signature = self.sign(block_data)?;
    Ok(signature)
}
```

Alternatively, call `Block::verify_well_formed()` on the constructed Block before signing, similar to how `verify_proposal()` does it.

## Proof of Concept

```rust
#[test]
fn test_sign_proposal_cross_epoch_attack() {
    use aptos_consensus_types::{
        block_data::{BlockData, BlockType},
        quorum_cert::QuorumCert,
    };
    
    // Setup: Initialize SafetyRules for epoch 10
    let (mut safety_rules, signer) = setup_safety_rules_for_epoch(10);
    
    // Create a valid QC from epoch 9 (previous epoch)
    let qc_epoch_9 = create_valid_qc_for_epoch(9, &signer);
    
    // Attack: Construct malicious BlockData with mismatched epochs
    let malicious_block_data = BlockData::new_for_testing(
        10,  // Current epoch
        qc_epoch_9.certified_block().round() + 1,
        current_timestamp(),
        qc_epoch_9,  // QC from epoch 9!
        BlockType::Proposal {
            payload: Payload::empty(false, true),
            author: signer.author(),
            failed_authors: vec![],
        },
    );
    
    // Attempt to sign - THIS SHOULD FAIL BUT CURRENTLY SUCCEEDS
    let result = safety_rules.sign_proposal(&malicious_block_data);
    
    // BUG: The signature is created despite epoch mismatch
    assert!(result.is_ok(), "SafetyRules signed cross-epoch proposal!");
    
    // Verify that this violates the invariant
    let block = Block::new_proposal_from_block_data_and_signature(
        malicious_block_data,
        result.unwrap(),
    );
    
    // Other validators would reject this
    assert!(block.verify_well_formed().is_err());
}
```

## Notes

- This is a **defense-in-depth violation** rather than a directly exploitable vulnerability
- The validation exists in `verify_well_formed()` but not in `sign_proposal()`
- SafetyRules should independently validate all safety-critical invariants
- The asymmetry between `sign_proposal()` and `verify_proposal()` (which DOES call `verify_well_formed()`) is concerning

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L78-80)
```rust
        proposed_block
            .verify_well_formed()
            .map_err(|error| Error::InvalidProposal(error.to_string()))?;
```

**File:** consensus/safety-rules/src/safety_rules.rs (L346-370)
```rust
    fn guarded_sign_proposal(
        &mut self,
        block_data: &BlockData,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        self.verify_author(block_data.author())?;

        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(block_data.epoch(), &safety_data)?;

        if block_data.round() <= safety_data.last_voted_round {
            return Err(Error::InvalidProposal(format!(
                "Proposed round {} is not higher than last voted round {}",
                block_data.round(),
                safety_data.last_voted_round
            )));
        }

        self.verify_qc(block_data.quorum_cert())?;
        self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;
        // we don't persist the updated preferred round to save latency (it'd be updated upon voting)

        let signature = self.sign(block_data)?;
        Ok(signature)
    }
```

**File:** consensus/consensus-types/src/block.rs (L479-482)
```rust
        ensure!(
            parent.epoch() == self.epoch(),
            "block's parent should be in the same epoch"
        );
```

**File:** consensus/consensus-types/src/block_data.rs (L262-276)
```rust
    pub fn new_for_testing(
        epoch: u64,
        round: Round,
        timestamp_usecs: u64,
        quorum_cert: QuorumCert,
        block_type: BlockType,
    ) -> Self {
        Self {
            epoch,
            round,
            timestamp_usecs,
            quorum_cert,
            block_type,
        }
    }
```

**File:** consensus/src/liveness/proposal_generator.rs (L534-553)
```rust
        let block = if self.vtxn_config.enabled() {
            BlockData::new_proposal_ext(
                validator_txns,
                payload,
                self.author,
                failed_authors,
                round,
                timestamp,
                quorum_cert,
            )
        } else {
            BlockData::new_proposal(
                payload,
                self.author,
                failed_authors,
                round,
                timestamp,
                quorum_cert,
            )
        };
```
