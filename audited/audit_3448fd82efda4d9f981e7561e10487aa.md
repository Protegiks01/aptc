# Audit Report

## Title
Unmetered Gas Execution in Genesis Transaction Replay Allows Indefinite Verification Hang

## Summary
The `replay_on_archive` tool in `storage/db-tool/src/replay_on_archive.rs` can hang indefinitely when replaying a malicious database containing `GenesisTransaction` with `WriteSetPayload::Script` that contains infinite loops. These transactions execute with `UnmeteredGasMeter`, bypassing all gas limits and execution time bounds, even when `timeout_secs` is configured.

## Finding Description

The vulnerability exists in the interaction between database replay and VM execution modes:

1. **Database Trust Model**: The replay tool reads transactions directly from the database via `BackupHandler::get_transaction_iter` without validation: [1](#0-0) 

2. **Unmetered Genesis Execution**: When the VM executes a `GenesisTransaction` with `WriteSetPayload::Script`, it uses `UnmeteredGasMeter` with no gas limits: [2](#0-1) 

3. **Infinite Gas Budget**: `UnmeteredGasMeter` provides unlimited gas and no-op charge methods: [3](#0-2) 

4. **Ineffective Timeout**: The `timeout_secs` parameter only checks elapsed time between transaction batches, not during execution: [4](#0-3) 

5. **Blocking Execution**: Transaction execution in `execute_and_verify` is synchronous and blocking: [5](#0-4) 

**Attack Path:**
1. Attacker gains control of a database (backup corruption, insider threat, or creates malicious test database)
2. Injects `GenesisTransaction` entries with `WriteSetPayload::Script` containing Move bytecode with infinite loops (e.g., `while (true) {}`)
3. Operator runs `replay_on_archive` tool to verify/replay the database
4. Tool executes malicious transaction with `UnmeteredGasMeter`
5. Infinite loop executes without gas limits
6. Tool hangs indefinitely, timeout check never reached (execution is blocking)

**Normal Transactions Protected**: Regular `UserTransaction` types are protected by gas limits: [6](#0-5) [7](#0-6) 

However, these protections don't apply to `GenesisTransaction` with `WriteSetPayload::Script`.

## Impact Explanation

**Severity: Low (does not meet High/Medium criteria)**

While this is a genuine code vulnerability, its impact is limited to offline database verification tools:

- **No Consensus Impact**: Does not affect live validators or blockchain consensus
- **No Network Impact**: Does not cause network partitions or validator unavailability  
- **No Funds Impact**: Cannot steal, freeze, or mint funds
- **Tool-Level DoS Only**: Only affects the `db-tool` replay utility, not core blockchain operations

This is an operational inconvenience rather than a blockchain security vulnerability. The Aptos bug bounty High severity criteria require "Validator node slowdowns, API crashes, Significant protocol violations" - none of which apply to an offline verification tool hanging.

## Likelihood Explanation

**Likelihood: Low**

Prerequisites for exploitation:
1. Attacker must gain control of database (high bar):
   - Compromise backup storage
   - Insider threat with database access
   - Create malicious test database for operator to use
2. Operator must run replay tool on untrusted/malicious database
3. Database must contain properly formatted `GenesisTransaction` with malicious script

This is not exploitable through normal blockchain operations or network interactions. It requires database-level access or social engineering to trick operators into using a malicious database.

## Recommendation

**Option 1: Apply Execution Timeout During Transaction Execution**

Implement per-transaction execution timeout using thread-based interruption or signal-based termination. This would require significant refactoring to make VM execution interruptible.

**Option 2: Use Metered Gas for All Transactions During Replay**

Modify replay execution to always use production gas meters with limits, even for `GenesisTransaction`:

```rust
// In execute_single_transaction or similar
// For replay mode, force metered execution even for genesis transactions
let use_metered_gas_in_replay = true;
if use_metered_gas_in_replay {
    // Use standard gas meter with max limits
    let gas_meter = make_prod_gas_meter(...);
    // Execute with metered gas
} else {
    // Current unmetered path
}
```

**Option 3: Validate Transaction Types from Database**

Add validation when reading from database to reject `GenesisTransaction` entries beyond genesis (version 0):

```rust
// In replay_on_archive.rs verify loop
if current_version > 0 {
    match &input_txn {
        Transaction::GenesisTransaction(_) => {
            bail!("GenesisTransaction found at non-genesis version {}", current_version);
        }
        _ => {}
    }
}
```

## Proof of Concept

**Step 1: Create malicious Move script (infinite_loop.move)**
```move
script {
    fun main() {
        loop {} // Infinite loop
    }
}
```

**Step 2: Compile and inject into test database**
```rust
// Pseudo-code for PoC
use aptos_types::transaction::{Transaction, WriteSetPayload};

// Compile infinite loop script
let compiled_script = compile_script("infinite_loop.move");

// Create malicious GenesisTransaction
let malicious_txn = Transaction::GenesisTransaction(
    WriteSetPayload::Script {
        script: compiled_script,
        execute_as: genesis_address,
    }
);

// Inject into database at arbitrary version
db.save_transaction(version, malicious_txn);
```

**Step 3: Run replay and observe hang**
```bash
cargo run --bin db-tool -- replay-on-archive \
    --start-version 0 \
    --end-version 100 \
    --target-db-dir /path/to/malicious/db \
    # Note: Even with --timeout-secs, execution will hang
```

The tool will hang indefinitely during `execute_block` when processing the malicious transaction, never reaching the timeout check in the main loop.

---

**Notes:**
- This vulnerability is specific to the offline `db-tool` replay functionality
- It does NOT affect live consensus, validators, or blockchain security  
- Impact is limited to operational tooling, not core protocol
- The severity does not meet the High/Medium criteria of the Aptos bug bounty program
- While technically exploitable, practical exploitation requires database-level access
- Similar issues may exist in other tools that replay transactions with unmetered execution

### Citations

**File:** storage/db-tool/src/replay_on_archive.rs (L247-249)
```rust
        let txn_iter = self
            .backup_handler
            .get_transaction_iter(start, limit as usize)?;
```

**File:** storage/db-tool/src/replay_on_archive.rs (L258-268)
```rust
            // timeout check
            if let Some(duration) = self.timeout_secs {
                if self.replay_stat.get_elapsed_secs() >= duration {
                    bail!(
                        "Verify timeout: {}s elapsed. Deadline: {}s. Failed txns count: {}",
                        self.replay_stat.get_elapsed_secs(),
                        duration,
                        total_failed_txns.len(),
                    );
                }
            }
```

**File:** storage/db-tool/src/replay_on_archive.rs (L375-387)
```rust
        let executed_outputs = executor
            .execute_block(
                &txns_provider,
                &self
                    .arc_db
                    .state_view_at_version(current_version.checked_sub(1))?,
                BlockExecutorConfigFromOnchain::new_no_block_limit(),
                TransactionSliceMetadata::Chunk {
                    begin: *current_version,
                    end: *current_version + cur_txns.len() as u64,
                },
            )
            .map(BlockOutput::into_transaction_outputs_forced)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2307-2315)
```rust
                self.validate_and_execute_script(
                    &mut tmp_session,
                    &SerializedSigners::new(senders, None),
                    code_storage,
                    &mut UnmeteredGasMeter,
                    &mut traversal_context,
                    script,
                    &mut NoOpTraceRecorder,
                )?;
```

**File:** third_party/move/move-vm/types/src/gas.rs (L424-431)
```rust
impl GasMeter for UnmeteredGasMeter {
    fn balance_internal(&self) -> InternalGas {
        u64::MAX.into()
    }

    fn charge_simple_instr(&mut self, _instr: SimpleInstruction) -> PartialVMResult<()> {
        Ok(())
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L210-214)
```rust
        [
            max_execution_gas: InternalGas,
            { 7.. => "max_execution_gas" },
            920_000_000, // 92ms of execution at 10k gas per ms
        ],
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L204-208)
```rust
        if self.feature_version >= 7 && self.execution_gas_used > self.max_execution_gas {
            Err(PartialVMError::new(StatusCode::EXECUTION_LIMIT_REACHED))
        } else {
            Ok(())
        }
```
