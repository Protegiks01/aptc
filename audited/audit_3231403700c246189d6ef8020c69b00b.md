# Audit Report

## Title
Genesis Configuration Corruption via Unvalidated Consensus Parameters Causing Network-Wide Consensus Failure

## Summary
The `aptos_genesis::config::Layout` structure deserializes on-chain consensus configuration from YAML without validating critical nested parameters. An attacker can inject malicious consensus configuration values (e.g., setting reputation window multipliers to 0 or failure thresholds to invalid values) during genesis setup, which will cause all validators to experience consensus failures, leader election divergence, or complete network paralysis from genesis.

## Finding Description
The vulnerability exists in the genesis configuration loading and validation flow: [1](#0-0) 

The `Layout::from_disk()` method deserializes the entire configuration structure using `serde_yaml::from_str()` without any semantic validation: [2](#0-1) 

The Layout contains complex nested consensus configuration that gets directly deserialized: [3](#0-2) 

During genesis generation, these configurations are passed through without validation beyond basic checks: [4](#0-3) 

The `validate_genesis_config()` function only validates basic numeric parameters (min_stake, epoch_duration, etc.) but completely ignores the nested consensus configuration structure.

**The Attack Path:**

1. An attacker participating in genesis ceremony provides a malicious `layout.yaml` with:
   - `proposer_window_num_validators_multiplier: 0` 
   - `voter_window_num_validators_multiplier: 0`
   - OR `failure_threshold_percent: 0` or `> 100`

2. This configuration gets deserialized and written to genesis state without validation.

3. When validators initialize the epoch manager, they calculate window sizes: [5](#0-4) 

With multiplier = 0, `window_size = num_validators * 0 = 0`, causing the reputation backend to return empty history.

4. This breaks leader election determinism - validators may elect different leaders or fail to elect any leader, causing consensus to halt or fork from genesis.

**Alternative Attack Vector with failure_threshold_percent:**

Setting `failure_threshold_percent` to 0 means any validator with even one failed proposal gets marked as failed, unfairly penalizing all validators: [6](#0-5) 

Setting it to > 100 means validators never get penalized even with 100% failure rate, breaking the reputation system entirely.

## Impact Explanation
This is a **Critical Severity** vulnerability (up to $1,000,000) as it meets multiple critical impact criteria:

1. **Consensus/Safety Violations**: With window_size = 0, the reputation system returns empty historical data, causing non-deterministic leader election. Different validators may elect different leaders for the same round, violating consensus safety and causing chain forks.

2. **Non-recoverable Network Partition**: If the network launches with corrupted genesis configuration, all validators start with the broken consensus parameters. This requires a hard fork to fix, as the invalid configuration is baked into genesis state.

3. **Total Loss of Liveness**: If failure_threshold_percent is set to 0, all validators immediately get marked as failed after any proposal failure, potentially deadlocking the network with no valid leaders.

The vulnerability breaks the **Deterministic Execution** invariant (all validators must produce identical state) and the **Consensus Safety** invariant (AptosBFT must prevent chain splits).

## Likelihood Explanation
**Likelihood: High**

The attack is highly likely to occur because:

1. **Accessible Attack Surface**: Genesis configuration files are often prepared by multiple parties in a decentralized genesis ceremony. Any participant with write access to `layout.yaml` can inject malicious values.

2. **No Validation**: The code path from YAML deserialization to genesis state creation has zero semantic validation of consensus parameters. serde only validates types, not logical constraints.

3. **Non-Obvious**: The parameters appear technical and innocent (e.g., "multiplier: 0" could seem like "disabled" rather than "broken").

4. **Testnet Vulnerability**: Even for testnets, this allows anyone proposing genesis configs to DoS the network from launch.

5. **No Runtime Detection**: Once genesis is committed, there's no mechanism to detect or reject the invalid configuration until consensus actually fails.

## Recommendation

Add comprehensive validation for all consensus configuration parameters in the genesis validation flow:

```rust
// In aptos-move/vm-genesis/src/lib.rs, expand validate_genesis_config():

fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    // ... existing validations ...
    
    // Add validation for consensus config
    validate_consensus_config(consensus_config);
}

fn validate_consensus_config(consensus_config: &OnChainConsensusConfig) {
    match consensus_config {
        OnChainConsensusConfig::V3 { alg, vtxn, .. }
        | OnChainConsensusConfig::V4 { alg, vtxn, .. }
        | OnChainConsensusConfig::V5 { alg, vtxn, .. } => {
            match alg {
                ConsensusAlgorithmConfig::Jolteon { main, .. }
                | ConsensusAlgorithmConfig::JolteonV2 { main, .. } => {
                    validate_consensus_config_v1(main);
                }
                ConsensusAlgorithmConfig::DAG(dag_config) => {
                    assert!(
                        dag_config.dag_ordering_causal_history_window > 0,
                        "DAG ordering causal history window must be > 0"
                    );
                }
            }
        }
        _ => {}
    }
}

fn validate_consensus_config_v1(config: &ConsensusConfigV1) {
    if let ProposerElectionType::LeaderReputation(rep_type) = &config.proposer_election_type {
        match rep_type {
            LeaderReputationType::ProposerAndVoter(pv_config)
            | LeaderReputationType::ProposerAndVoterV2(pv_config) => {
                assert!(
                    pv_config.proposer_window_num_validators_multiplier > 0,
                    "Proposer window multiplier must be > 0"
                );
                assert!(
                    pv_config.voter_window_num_validators_multiplier > 0,
                    "Voter window multiplier must be > 0"
                );
                assert!(
                    pv_config.failure_threshold_percent > 0 
                        && pv_config.failure_threshold_percent <= 100,
                    "Failure threshold percent must be in range (0, 100]"
                );
                assert!(
                    pv_config.active_weight > 0,
                    "Active weight must be > 0"
                );
            }
        }
    }
}
```

Additionally, add validation in `Layout::from_disk()` to catch issues earlier:

```rust
// In crates/aptos-genesis/src/config.rs
impl Layout {
    pub fn from_disk(path: &Path) -> anyhow::Result<Self> {
        let mut file = File::open(path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        
        let layout: Self = serde_yaml::from_str(&contents)?;
        layout.validate()?;  // Add validation step
        Ok(layout)
    }
    
    fn validate(&self) -> anyhow::Result<()> {
        // Validate consensus config parameters
        self.validate_consensus_config()?;
        Ok(())
    }
}
```

## Proof of Concept

Create a malicious `layout.yaml`:

```yaml
chain_id: 4
users: ["alice"]
min_stake: 100000000000000
max_stake: 100000000000000000
min_voting_threshold: 100000000000000
epoch_duration_secs: 7200
recurring_lockup_duration_secs: 86400
required_proposer_stake: 100000000000000
rewards_apy_percentage: 10
voting_duration_secs: 43200
voting_power_increase_limit: 20

on_chain_consensus_config:
  V5:
    alg:
      JolteonV2:
        main:
          decoupled_execution: true
          back_pressure_limit: 10
          exclude_round: 40
          max_failed_authors_to_store: 10
          proposer_election_type:
            leader_reputation:
              ProposerAndVoterV2:
                active_weight: 1000
                inactive_weight: 10
                failed_weight: 1
                failure_threshold_percent: 0  # MALICIOUS: Marks everyone as failed
                proposer_window_num_validators_multiplier: 0  # MALICIOUS: Breaks reputation
                voter_window_num_validators_multiplier: 0     # MALICIOUS: Breaks reputation
                weight_by_voting_power: true
                use_history_from_previous_epoch_max_count: 5
        quorum_store_enabled: true
        order_vote_enabled: true
    vtxn:
      V1:
        per_block_limit_txn_count: 2
        per_block_limit_total_bytes: 2097152
    window_size: null
    rand_check_enabled: true

on_chain_execution_config:
  V7:
    transaction_shuffler_type: "NoShuffling"
    block_gas_limit_type: "NoLimit" 
    transaction_deduper_type: "TxnHashAndAuthenticatorV1"
```

Run genesis generation:
```bash
aptos genesis generate-genesis --layout-file malicious_layout.yaml --output-dir genesis_output
```

When validators start with this genesis blob, consensus will immediately fail due to:
1. Window size = 0 causing empty reputation history
2. failure_threshold_percent = 0 marking all validators as failed
3. Non-deterministic leader election causing consensus divergence

The network will be completely non-functional from genesis, requiring a hard fork to recover.

### Citations

**File:** crates/aptos-genesis/src/config.rs (L29-90)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct Layout {
    /// Root key for the blockchain only for test chains
    #[serde(default)]
    pub root_key: Option<Ed25519PublicKey>,
    /// List of usernames or identifiers
    pub users: Vec<String>,
    /// ChainId for the target network
    pub chain_id: ChainId,
    /// Whether to allow new validators to join the set after genesis
    ///
    /// Ignored for mainnet
    #[serde(default)]
    pub allow_new_validators: bool,
    /// Duration of an epoch
    pub epoch_duration_secs: u64,
    /// Whether this is a test network or not
    ///
    /// Ignored for mainnet
    #[serde(default)]
    pub is_test: bool,
    /// Minimum stake to be in the validator set
    pub min_stake: u64,
    /// Minimum number of votes to consider a proposal valid.
    pub min_voting_threshold: u128,
    /// Maximum stake to be in the validator set
    pub max_stake: u64,
    /// Minimum number of seconds to lockup staked coins
    pub recurring_lockup_duration_secs: u64,
    /// Required amount of stake to create proposals.
    pub required_proposer_stake: u64,
    /// Percentage of stake given out as rewards a year (0-100%).
    pub rewards_apy_percentage: u64,
    /// Voting duration for a proposal in seconds.
    pub voting_duration_secs: u64,
    /// % of current epoch's total voting power that can be added in this epoch.
    pub voting_power_increase_limit: u64,
    /// Total supply of coins
    pub total_supply: Option<u64>,
    /// Timestamp (in seconds) when employee vesting starts.
    pub employee_vesting_start: Option<u64>,
    /// Duration of each vesting period (in seconds).
    pub employee_vesting_period_duration: Option<u64>,
    /// Onchain Consensus Config
    #[serde(default = "OnChainConsensusConfig::default_for_genesis")]
    pub on_chain_consensus_config: OnChainConsensusConfig,
    /// Onchain Execution Config
    #[serde(default = "OnChainExecutionConfig::default_for_genesis")]
    pub on_chain_execution_config: OnChainExecutionConfig,

    /// An optional JWK consensus config to use, instead of `default_for_genesis()`.
    #[serde(default)]
    pub jwk_consensus_config_override: Option<OnChainJWKConsensusConfig>,

    /// JWKs to patch in genesis.
    #[serde(default)]
    pub initial_jwks: Vec<IssuerJWK>,

    /// Keyless Groth16 verification key to install in genesis.
    #[serde(default)]
    pub keyless_groth16_vk_override: Option<Groth16VerificationKey>,
}
```

**File:** crates/aptos-genesis/src/config.rs (L92-104)
```rust
impl Layout {
    /// Read the layout from a YAML file on disk
    pub fn from_disk(path: &Path) -> anyhow::Result<Self> {
        let mut file = File::open(path).map_err(|e| {
            anyhow::Error::msg(format!("Failed to open file {}, {}", path.display(), e))
        })?;
        let mut contents = String::new();
        file.read_to_string(&mut contents).map_err(|e| {
            anyhow::Error::msg(format!("Failed to read file {}, {}", path.display(), e))
        })?;

        Ok(serde_yaml::from_str(&contents)?)
    }
```

**File:** crates/aptos/src/genesis/mod.rs (L270-312)
```rust
pub fn fetch_genesis_info(git_options: GitOptions) -> CliTypedResult<GenesisInfo> {
    let client = git_options.get_client()?;
    let layout: Layout = client.get(Path::new(LAYOUT_FILE))?;

    if layout.root_key.is_none() {
        return Err(CliError::UnexpectedError(
            "Layout field root_key was not set.  Please provide a hex encoded Ed25519PublicKey."
                .to_string(),
        ));
    }

    let validators = get_validator_configs(&client, &layout, false).map_err(parse_error)?;
    let framework = client.get_framework()?;
    Ok(GenesisInfo::new(
        layout.chain_id,
        layout.root_key.unwrap(),
        validators,
        framework,
        &GenesisConfiguration {
            allow_new_validators: layout.allow_new_validators,
            epoch_duration_secs: layout.epoch_duration_secs,
            is_test: layout.is_test,
            min_stake: layout.min_stake,
            min_voting_threshold: layout.min_voting_threshold,
            max_stake: layout.max_stake,
            recurring_lockup_duration_secs: layout.recurring_lockup_duration_secs,
            required_proposer_stake: layout.required_proposer_stake,
            rewards_apy_percentage: layout.rewards_apy_percentage,
            voting_duration_secs: layout.voting_duration_secs,
            voting_power_increase_limit: layout.voting_power_increase_limit,
            employee_vesting_start: layout.employee_vesting_start,
            employee_vesting_period_duration: layout.employee_vesting_period_duration,
            consensus_config: layout.on_chain_consensus_config,
            execution_config: layout.on_chain_execution_config,
            gas_schedule: default_gas_schedule(),
            initial_features_override: None,
            randomness_config_override: None,
            jwk_consensus_config_override: layout.jwk_consensus_config_override.clone(),
            initial_jwks: layout.initial_jwks.clone(),
            keyless_groth16_vk: layout.keyless_groth16_vk_override.clone(),
        },
    )?)
}
```

**File:** aptos-move/vm-genesis/src/lib.rs (L405-439)
```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    assert!(
        genesis_config.min_stake <= genesis_config.max_stake,
        "Min stake must be smaller than or equal to max stake"
    );
    assert!(
        genesis_config.epoch_duration_secs > 0,
        "Epoch duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs > 0,
        "Recurring lockup duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs >= genesis_config.epoch_duration_secs,
        "Recurring lockup duration must be at least as long as epoch duration"
    );
    assert!(
        genesis_config.rewards_apy_percentage > 0 && genesis_config.rewards_apy_percentage < 100,
        "Rewards APY must be > 0% and < 100%"
    );
    assert!(
        genesis_config.voting_duration_secs > 0,
        "On-chain voting duration must be > 0"
    );
    assert!(
        genesis_config.voting_duration_secs < genesis_config.recurring_lockup_duration_secs,
        "Voting duration must be strictly smaller than recurring lockup"
    );
    assert!(
        genesis_config.voting_power_increase_limit > 0
            && genesis_config.voting_power_increase_limit <= 50,
        "voting_power_increase_limit must be > 0 and <= 50"
    );
}
```

**File:** consensus/src/epoch_manager.rs (L314-335)
```rust
                        let proposer_window_size = proposers.len()
                            * proposer_and_voter_config.proposer_window_num_validators_multiplier;
                        let voter_window_size = proposers.len()
                            * proposer_and_voter_config.voter_window_num_validators_multiplier;
                        let heuristic: Box<dyn ReputationHeuristic> =
                            Box::new(ProposerAndVoterHeuristic::new(
                                self.author,
                                proposer_and_voter_config.active_weight,
                                proposer_and_voter_config.inactive_weight,
                                proposer_and_voter_config.failed_weight,
                                proposer_and_voter_config.failure_threshold_percent,
                                voter_window_size,
                                proposer_window_size,
                                leader_reputation_type.use_reputation_window_from_stale_end(),
                            ));
                        (
                            heuristic,
                            std::cmp::max(proposer_window_size, voter_window_size),
                            proposer_and_voter_config.weight_by_voting_power,
                            proposer_and_voter_config.use_history_from_previous_epoch_max_count,
                        )
                    },
```

**File:** consensus/src/liveness/leader_reputation.rs (L541-552)
```rust
                if cur_failed_proposals * 100
                    > (cur_proposals + cur_failed_proposals) * self.failure_threshold_percent
                {
                    self.failed_weight
                } else if cur_proposals > 0 || cur_votes > 0 {
                    self.active_weight
                } else {
                    self.inactive_weight
                }
            })
            .collect()
    }
```
