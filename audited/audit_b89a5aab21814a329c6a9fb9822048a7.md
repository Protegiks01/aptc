# Audit Report

## Title
Missing Consensus Safety Check in SyncInfo Verification Allows Same-Round Different-Block Certificates

## Summary
The `verify()` function in `SyncInfo` fails to validate that when `highest_quorum_cert` and `highest_ordered_cert` have the same round number, they must certify the same block. This missing validation violates a critical consensus safety invariant and represents a defense-in-depth failure.

## Finding Description

The `SyncInfo` structure carries synchronization metadata including `highest_quorum_cert` (HQC) and `highest_ordered_cert` (HOC) that nodes use to synchronize their consensus state. [1](#0-0) 

The `verify()` function performs several checks but **critically omits** verification that HQC and HOC certify the same block when they have the same round number. [2](#0-1) 

The existing check only verifies that HQC round >= HOC round, but does NOT check block identity when rounds are equal. [3](#0-2) 

In AptosBFT consensus, having two different blocks certified/ordered for the same round within the same epoch is a fundamental safety violation. The `BlockTree` enforces this invariant with a precondition check, but only during insertion and only in debug/analysis builds. [4](#0-3) 

When such a malformed `SyncInfo` is processed via `add_certs()`, the system attempts to insert certificates for different blocks at the same round. With order votes disabled, this could lead to multiple `insert_quorum_cert()` calls for different blocks at the same round. [5](#0-4) 

## Impact Explanation

**Severity: High**

This issue constitutes a significant protocol violation because:

1. **Consensus Safety Invariant Violation**: The fundamental invariant that "only one block can be certified per round per epoch" could be violated if such certificates exist
2. **Defense-in-Depth Failure**: The verification layer fails to catch malformed consensus data before it propagates through the system
3. **Potential State Inconsistency**: Different nodes processing such `SyncInfo` could end up with inconsistent views of which block is correct for a given round

While categorized as High rather than Critical because exploitation requires obtaining two valid certificates for different blocks at the same round (which should be impossible with < 1/3 Byzantine validators under normal operation), the missing check represents a serious protocol vulnerability. If certificates with this property were ever created through any means (fork scenarios, validator equivocation, or future vulnerabilities), they would pass verification and could cause consensus issues.

## Likelihood Explanation

**Likelihood: Low to Medium**

Under normal operation with < 1/3 Byzantine validators, creating two valid quorum certificates for different blocks at the same round should be theoretically impossible. However, this could occur in several scenarios:

1. **Fork/Network Partition Scenarios**: During epoch transitions or network partitions, competing forks might temporarily produce such certificates
2. **Validator Equivocation**: Byzantine validators with sufficient stake (â‰¥ 1/3) could deliberately create such certificates
3. **Cascading Vulnerabilities**: Other vulnerabilities in certificate creation or validation could lead to such states

The impact is amplified because once created, such malformed `SyncInfo` messages would propagate through the network unchecked, potentially affecting multiple nodes.

## Recommendation

Add explicit validation in the `verify()` function to check that when HQC and HOC have the same round, they must reference the same block:

```rust
// After line 156 in sync_info.rs, add:
if self.highest_quorum_cert.certified_block().round()
    == self.highest_ordered_cert().commit_info().round()
{
    ensure!(
        self.highest_quorum_cert.certified_block().id()
            == self.highest_ordered_cert().commit_info().id(),
        "HQC and HOC have same round {} but certify different blocks: HQC block {} vs HOC block {}",
        self.highest_quorum_cert.certified_block().round(),
        self.highest_quorum_cert.certified_block().id(),
        self.highest_ordered_cert().commit_info().id()
    );
}
```

This check ensures that the critical consensus safety invariant is enforced at the verification layer, providing defense-in-depth against malformed consensus messages.

## Proof of Concept

```rust
#[test]
fn test_sync_info_same_round_different_blocks() {
    use aptos_consensus_types::{
        block::Block,
        quorum_cert::QuorumCert,
        sync_info::SyncInfo,
        vote_data::VoteData,
    };
    use aptos_types::block_info::BlockInfo;
    
    // Create two different blocks at round 10
    let block_a = BlockInfo::new(1, 10, HashValue::random(), 
                                   HashValue::zero(), 0, 0, None);
    let block_b = BlockInfo::new(1, 10, HashValue::random(), 
                                   HashValue::zero(), 0, 0, None);
    
    // Simulate creating QCs for both blocks (in reality this requires 2f+1 signatures)
    let vote_data_a = VoteData::new(block_a.clone(), block_a.clone());
    let qc_a = QuorumCert::new(vote_data_a, create_test_ledger_info());
    
    let vote_data_b = VoteData::new(block_b.clone(), block_b.clone());
    let wrapped_b = WrappedLedgerInfo::new(vote_data_b, create_test_ledger_info());
    
    // Create SyncInfo with same round but different blocks
    let sync_info = SyncInfo::new(qc_a, wrapped_b, None);
    
    // This should FAIL but currently PASSES verification
    let result = sync_info.verify(&validator_verifier);
    
    // Expected: Err("HQC and HOC have same round but certify different blocks")
    // Actual: Ok(()) - verification passes incorrectly
    assert!(result.is_err(), "Should reject same-round different-block certificates");
}
```

## Notes

This vulnerability specifically addresses the missing validation logic in `SyncInfo::verify()`. While the `BlockTree` does have a safety invariant check via MIRAI preconditions, these are not enforced in production builds and occur after state modifications have begun. The verification layer should catch this issue before any processing occurs, implementing proper defense-in-depth for consensus safety.

### Citations

**File:** consensus/consensus-types/src/sync_info.rs (L14-25)
```rust
#[derive(Deserialize, Serialize, Clone, Eq, PartialEq)]
/// This struct describes basic synchronization metadata.
pub struct SyncInfo {
    /// Highest quorum certificate known to the peer.
    highest_quorum_cert: QuorumCert,
    /// Highest ordered cert known to the peer.
    highest_ordered_cert: Option<WrappedLedgerInfo>,
    /// Highest commit cert (ordered cert with execution result) known to the peer.
    highest_commit_cert: WrappedLedgerInfo,
    /// Optional highest timeout certificate if available.
    highest_2chain_timeout_cert: Option<TwoChainTimeoutCertificate>,
}
```

**File:** consensus/consensus-types/src/sync_info.rs (L138-212)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let epoch = self.highest_quorum_cert.certified_block().epoch();
        ensure!(
            epoch == self.highest_ordered_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HQC"
        );
        ensure!(
            epoch == self.highest_commit_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HCC"
        );
        if let Some(tc) = &self.highest_2chain_timeout_cert {
            ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
        }

        ensure!(
            self.highest_quorum_cert.certified_block().round()
                >= self.highest_ordered_cert().commit_info().round(),
            "HQC has lower round than HOC"
        );

        ensure!(
            self.highest_ordered_round() >= self.highest_commit_round(),
            format!(
                "HOC {} has lower round than HLI {}",
                self.highest_ordered_cert(),
                self.highest_commit_cert()
            )
        );

        ensure!(
            *self.highest_ordered_cert().commit_info() != BlockInfo::empty(),
            "HOC has no committed block"
        );

        ensure!(
            *self.highest_commit_cert().commit_info() != BlockInfo::empty(),
            "HLI has empty commit info"
        );

        // we don't have execution in unit tests, so this check would fail
        #[cfg(not(any(test, feature = "fuzzing")))]
        {
            ensure!(
                !self.highest_commit_cert().commit_info().is_ordered_only(),
                "HLI {} has ordered only commit info",
                self.highest_commit_cert().commit_info()
            );
        }

        self.highest_quorum_cert
            .verify(validator)
            .and_then(|_| {
                self.highest_ordered_cert
                    .as_ref()
                    .map_or(Ok(()), |cert| cert.verify(validator))
                    .context("Fail to verify ordered certificate")
            })
            .and_then(|_| {
                // we do not verify genesis ledger info
                if self.highest_commit_cert.commit_info().round() > 0 {
                    self.highest_commit_cert
                        .verify(validator)
                        .context("Fail to verify commit certificate")?
                }
                Ok(())
            })
            .and_then(|_| {
                if let Some(tc) = &self.highest_2chain_timeout_cert {
                    tc.verify(validator)?;
                }
                Ok(())
            })
            .context("Fail to verify SyncInfo")?;
        Ok(())
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L349-364)
```rust
    pub(super) fn insert_quorum_cert(&mut self, qc: QuorumCert) -> anyhow::Result<()> {
        let block_id = qc.certified_block().id();
        let qc = Arc::new(qc);

        // Safety invariant: For any two quorum certificates qc1, qc2 in the block store,
        // qc1 == qc2 || qc1.round != qc2.round
        // The invariant is quadratic but can be maintained in linear time by the check
        // below.
        precondition!({
            let qc_round = qc.certified_block().round();
            self.id_to_quorum_cert.values().all(|x| {
                (*(*x).ledger_info()).ledger_info().consensus_data_hash()
                    == (*(*qc).ledger_info()).ledger_info().consensus_data_hash()
                    || x.certified_block().round() != qc_round
            })
        });
```

**File:** consensus/src/block_storage/sync_manager.rs (L116-173)
```rust
    pub async fn add_certs(
        &self,
        sync_info: &SyncInfo,
        mut retriever: BlockRetriever,
    ) -> anyhow::Result<()> {
        // When the local ordered round is very old than the received sync_info, this function will
        // (1) resets the block store with highest commit cert = sync_info.highest_quorum_cert()
        // (2) insert all the blocks between (inclusive) highest_commit_cert.commit_info().id() to
        // highest_quorum_cert.certified_block().id() into the block store and storage
        // (3) insert the quorum cert for all the above blocks into the block store and storage
        // (4) executes all the blocks that are ordered while inserting the above quorum certs
        self.sync_to_highest_quorum_cert(
            sync_info.highest_quorum_cert().clone(),
            sync_info.highest_commit_cert().clone(),
            &mut retriever,
        )
        .await?;

        self.sync_to_highest_commit_cert(
            sync_info.highest_commit_cert().ledger_info(),
            retriever.network.clone(),
        )
        .await;

        // The insert_ordered_cert(order_cert) function call expects that order_cert.commit_info().id() block
        // is already stored in block_store. So, we first call insert_quorum_cert(highest_quorum_cert).
        // This call will ensure that the highest ceritified block along with all its ancestors are inserted
        // into the block store.
        self.insert_quorum_cert(sync_info.highest_quorum_cert(), &mut retriever)
            .await?;

        // Even though we inserted the highest_quorum_cert (and its ancestors) in the above step,
        // we still need to insert ordered cert explicitly. This will send the highest ordered block
        // to execution.
        if self.order_vote_enabled {
            self.insert_ordered_cert(&sync_info.highest_ordered_cert())
                .await?;
        } else {
            // When order votes are disabled, the highest_ordered_cert().certified_block().id() need not be
            // one of the ancestors of highest_quorum_cert.certified_block().id() due to forks. So, we call
            // insert_quorum_cert instead of insert_ordered_cert as in the above case. This will ensure that
            // highest_ordered_cert().certified_block().id() is inserted the block store.
            self.insert_quorum_cert(
                &self
                    .highest_ordered_cert()
                    .as_ref()
                    .clone()
                    .into_quorum_cert(self.order_vote_enabled)?,
                &mut retriever,
            )
            .await?;
        }

        if let Some(tc) = sync_info.highest_2chain_timeout_cert() {
            self.insert_2chain_timeout_certificate(Arc::new(tc.clone()))?;
        }
        Ok(())
    }
```
