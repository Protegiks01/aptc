# Audit Report

## Title
Consensus Liveness Failure During order_vote Transition Due to NIL Block Confusion in certified_block()

## Summary
The `certified_block()` method in `WrappedLedgerInfo` fails when transitioning from `order_vote_enabled=true` to `order_vote_enabled=false`, causing nodes to be unable to sync and resulting in consensus liveness failure. The issue stems from a hash mismatch between dummy `VoteData` (which resembles NIL blocks with timestamp=0) and the `consensus_data_hash` stored in recovered ledger info.

## Finding Description

**Core Issue:**

When `order_vote_enabled=true`, the system creates `WrappedLedgerInfo` objects with:
- `VoteData::dummy()` (which has `proposed.timestamp_usecs = parent.timestamp_usecs = 0`, making `is_for_nil()` return true)
- `LedgerInfo` with `consensus_data_hash = HashValue::zero()` [1](#0-0) [2](#0-1) 

However, `VoteData::dummy().hash()` ≠ `HashValue::zero()` (it produces a real hash of the serialized dummy BlockInfo structures).

**Attack Path:**

1. Network operates with `order_vote_enabled=true`
2. Node restarts and recovers from storage using `persistent_liveness_storage.rs`
3. Recovery code creates root certificates with dummy VoteData when `order_vote_enabled=true`: [3](#0-2) 

4. These become the node's `highest_commit_cert` and `highest_ordered_cert`
5. On-chain governance changes configuration to `order_vote_enabled=false`
6. Node's config updates to `order_vote_enabled=false`
7. Node attempts to sync via `sync_manager.rs`, which calls: [4](#0-3) 

8. The `certified_block(false)` method checks that `order_vote_enabled` is false, then calls `verify_consensus_data_hash()`: [5](#0-4) [6](#0-5) 

9. The verification computes `VoteData::dummy().hash()` and compares it to `HashValue::zero()` from the ledger info
10. **Hash mismatch causes error:** "WrappedLedgerInfo's vote data hash mismatch LedgerInfo"
11. Sync operation fails, node cannot progress

**Additional Failure Points:**

The same issue occurs at two other locations: [7](#0-6) [8](#0-7) 

Both call `into_quorum_cert(order_vote_enabled)` which internally calls `verify_consensus_data_hash()`: [9](#0-8) 

## Impact Explanation

**Severity: High (up to $50,000)**

This vulnerability causes:
- **Validator node slowdowns**: Affected nodes cannot sync and fall behind
- **Significant protocol violations**: Breaks consensus liveness during legitimate configuration transitions
- **Potential network-wide impact**: If multiple validators restart during the transition period, they all become stuck

The issue qualifies as High severity because:
1. It causes consensus liveness degradation
2. It affects core consensus synchronization mechanisms
3. It can impact multiple validators simultaneously
4. Recovery requires manual intervention or rollback of the governance configuration change

While not Critical severity (doesn't cause permanent network partition or fund loss), it significantly disrupts consensus operations during a legitimate governance-driven feature flag transition.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability will trigger whenever:
1. On-chain governance changes `order_vote_enabled` from `true` to `false` (or vice versa)
2. Any validator node restarts/recovers while the flag is in one state
3. The node then operates under the opposite flag state

Given that:
- Feature flag transitions are expected during protocol upgrades
- Node restarts are common (maintenance, crashes, upgrades)
- The order_vote feature is actively used for performance optimization

The likelihood is medium-high. The issue is deterministic once the conditions are met, and doesn't require any attacker action—it's triggered by legitimate network operations.

## Recommendation

**Fix Option 1: Skip hash verification when transitioning**

Modify `certified_block()` and `into_quorum_cert()` to detect when the `WrappedLedgerInfo` was created with dummy data and skip `verify_consensus_data_hash()` in such cases:

```rust
fn verify_consensus_data_hash(&self) -> anyhow::Result<()> {
    let vote_hash = self.vote_data.hash();
    let consensus_hash = self.ledger_info().ledger_info().consensus_data_hash();
    
    // Skip verification if both are dummy/zero values (order_vote transition case)
    if consensus_hash == HashValue::zero() && self.vote_data == VoteData::dummy() {
        return Ok(());
    }
    
    ensure!(
        consensus_hash == vote_hash,
        "WrappedLedgerInfo's vote data hash mismatch LedgerInfo, {} {}",
        self.ledger_info(),
        self.vote_data
    );
    Ok(())
}
```

**Fix Option 2: Ensure dummy VoteData hash equals HashValue::zero()**

Create a special dummy VoteData that explicitly hashes to `HashValue::zero()` to match the `consensus_data_hash` used when `order_vote_enabled=true`.

**Fix Option 3: Track order_vote_enabled state in WrappedLedgerInfo**

Add a boolean field to `WrappedLedgerInfo` indicating whether it was created with `order_vote_enabled=true`, and use this to conditionally skip verification.

**Recommended: Fix Option 1** is the safest and most backward-compatible approach.

## Proof of Concept

```rust
#[test]
fn test_order_vote_transition_sync_failure() {
    // Setup: Node recovers with order_vote_enabled=true
    let dummy_vote_data = VoteData::dummy();
    let ledger_info = LedgerInfo::new(
        BlockInfo::empty(),
        HashValue::zero(), // consensus_data_hash when order_vote_enabled=true
    );
    let ledger_info_sig = LedgerInfoWithSignatures::new(
        ledger_info,
        AggregateSignature::empty(),
    );
    
    let wrapped_li = WrappedLedgerInfo::new(dummy_vote_data.clone(), ledger_info_sig);
    
    // Verify the hash mismatch
    let vote_hash = dummy_vote_data.hash();
    assert_ne!(vote_hash, HashValue::zero(), 
        "VoteData::dummy() hash should not equal HashValue::zero()");
    
    // Simulate transition: order_vote_enabled changes to false
    let order_vote_enabled = false;
    
    // This will fail with hash mismatch error
    let result = wrapped_li.certified_block(order_vote_enabled);
    assert!(result.is_err(), "Should fail due to hash mismatch");
    assert!(result.unwrap_err().to_string().contains("vote data hash mismatch"),
        "Error should mention hash mismatch");
    
    // Same failure for into_quorum_cert
    let result2 = wrapped_li.into_quorum_cert(order_vote_enabled);
    assert!(result2.is_err(), "Should fail due to hash mismatch");
}
```

This PoC demonstrates that calling `certified_block(false)` on a `WrappedLedgerInfo` created with dummy VoteData (as done during recovery with `order_vote_enabled=true`) will fail due to the hash mismatch between `VoteData::dummy().hash()` and `HashValue::zero()`.

## Notes

The NIL block confusion mentioned in the security question is accurate—`VoteData::dummy()` creates blocks with `timestamp_usecs=0` for both proposed and parent, which makes `is_for_nil()` return true. While this specific characteristic doesn't directly cause the vulnerability, it highlights the confusion between dummy data and actual NIL blocks during the order_vote transition, making the issue harder to debug and potentially masking the root cause in logs.

### Citations

**File:** consensus/consensus-types/src/vote_data.rs (L82-85)
```rust
    /// Is the vote for a NIL block.
    pub fn is_for_nil(&self) -> bool {
        self.proposed().timestamp_usecs() == self.parent().timestamp_usecs()
    }
```

**File:** types/src/block_info.rs (L67-77)
```rust
    pub fn empty() -> Self {
        Self {
            epoch: 0,
            round: 0,
            id: HashValue::zero(),
            executed_state_id: HashValue::zero(),
            version: 0,
            timestamp_usecs: 0,
            next_epoch_state: None,
        }
    }
```

**File:** consensus/src/persistent_liveness_storage.rs (L145-163)
```rust
        let (root_ordered_cert, root_commit_cert) = if order_vote_enabled {
            // We are setting ordered_root same as commit_root. As every committed block is also ordered, this is fine.
            // As the block store inserts all the fetched blocks and quorum certs and execute the blocks, the block store
            // updates highest_ordered_cert accordingly.
            let root_ordered_cert =
                WrappedLedgerInfo::new(VoteData::dummy(), latest_ledger_info_sig.clone());
            (root_ordered_cert.clone(), root_ordered_cert)
        } else {
            let root_ordered_cert = quorum_certs
                .iter()
                .find(|qc| qc.commit_info().id() == commit_block.id())
                .ok_or_else(|| format_err!("No LI found for root: {}", latest_commit_id))?
                .clone()
                .into_wrapped_ledger_info();
            let root_commit_cert = root_ordered_cert
                .create_merged_with_executed_state(latest_ledger_info_sig)
                .expect("Inconsistent commit proof and evaluation decision, cannot commit block");
            (root_ordered_cert, root_commit_cert)
        };
```

**File:** consensus/src/block_storage/sync_manager.rs (L158-166)
```rust
            self.insert_quorum_cert(
                &self
                    .highest_ordered_cert()
                    .as_ref()
                    .clone()
                    .into_quorum_cert(self.order_vote_enabled)?,
                &mut retriever,
            )
            .await?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L413-418)
```rust
        if !order_vote_enabled {
            // TODO: this is probably still necessary, but need to think harder, it's pretty subtle
            // check if highest_commit_cert comes from a fork
            // if so, we need to fetch it's block as well, to have a proof of commit.
            let highest_commit_certified_block =
                highest_commit_cert.certified_block(order_vote_enabled)?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L453-457)
```rust
                quorum_certs.push(
                    highest_commit_cert
                        .clone()
                        .into_quorum_cert(order_vote_enabled)?,
                );
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L53-62)
```rust
    fn verify_consensus_data_hash(&self) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "WrappedLedgerInfo's vote data hash mismatch LedgerInfo, {} {}",
            self.ledger_info(),
            self.vote_data
        );
        Ok(())
    }
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L64-71)
```rust
    pub fn certified_block(&self, order_vote_enabled: bool) -> anyhow::Result<&BlockInfo> {
        ensure!(
            !order_vote_enabled,
            "wrapped_ledger_info.certified_block should not be called when order votes are enabled"
        );
        self.verify_consensus_data_hash()?;
        Ok(self.vote_data.proposed())
    }
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L125-135)
```rust
    pub fn into_quorum_cert(self, order_vote_enabled: bool) -> anyhow::Result<QuorumCert> {
        ensure!(
            !order_vote_enabled,
            "wrapped_ledger_info.into_quorum_cert should not be called when order votes are enabled"
        );
        self.verify_consensus_data_hash()?;
        Ok(QuorumCert::new(
            self.vote_data.clone(),
            self.signed_ledger_info.clone(),
        ))
    }
```
