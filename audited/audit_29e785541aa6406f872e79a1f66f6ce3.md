# Audit Report

## Title
Unverified Target Ledger Info Selection Enables State Sync Denial of Service

## Summary
The state synchronization system selects a target ledger info from peer advertisements without cryptographic verification, allowing malicious peers to advertise arbitrarily high versions that stall synchronization until retry limits are exhausted.

## Finding Description

The vulnerability exists in how continuous transaction streams select their synchronization target. The system aggregates peer advertisements without verification and selects the ledger info with the highest version number, allowing malicious peers to disrupt synchronization.

**Attack Flow:**

1. **Unverified Aggregation**: When peers advertise their `StorageServerSummary`, the data client collects all `synced_ledger_info` values directly without any signature verification: [1](#0-0) 

The polling mechanism accepts peer advertisements without validation: [2](#0-1) 

2. **Highest Version Selection Without Verification**: The `highest_synced_ledger_info()` method selects the ledger info purely based on version number without verifying signatures: [3](#0-2) 

3. **Target Set Without Verification**: The continuous transaction stream engine uses this unverified ledger info to select the sync target: [4](#0-3) 

And sets it as the current target: [5](#0-4) 

4. **Verification Only on Response**: Signature verification only occurs when data is received, not when selecting the target: [6](#0-5) [7](#0-6) 

By this point, the stream has already committed to requesting data at an unreachable version.

5. **Retry Exhaustion**: The system retries up to `max_request_retry` times (default: 5) with exponential backoff before terminating: [8](#0-7) [9](#0-8) 

**The Critical Gap**: A malicious peer can advertise a `StorageServerSummary` with an arbitrarily high `synced_ledger_info` version. While honest peers generate their summaries from actual storage: [10](#0-9) 

Nothing prevents a malicious peer from sending fabricated values. The system selects this malicious target without verification, creates requests for unreachable versions, and enters a retry loop until exhaustion.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria for "Validator node slowdowns."

**Demonstrated Impact:**
- Syncing nodes (including validators) experience repeated synchronization failures
- Each failed attempt incurs exponentially increasing timeout delays
- Multiple retry cycles delay synchronization significantly
- Validators are slowed in their ability to sync and participate in consensus
- The attack can be repeated if the attacker operates multiple peers

The attack does NOT cause permanent liveness loss because:
- Streams terminate after retry exhaustion
- Peer scoring eventually ignores malicious peers: [11](#0-10) 

- New streams can be created after termination

However, the disruption window is significant and degrades validator performance during the attack period.

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Ability to run a network peer (no validator credentials needed)
- Ability to respond to `GetStorageServerSummary` requests with fabricated data
- No stake or governance participation required

**Attack Complexity: Low**
- Simply advertise a `StorageServerSummary` with an inflated version number
- The system automatically selects it due to "highest version" logic
- No sophisticated timing or coordination needed

**Detection Difficulty: Medium**
- Attacks initially appear as legitimate synchronization failures
- Peer scoring eventually identifies and ignores the malicious peer
- However, disruption occurs before mitigation takes effect

## Recommendation

Implement signature verification when selecting target ledger info, not just when processing responses. Add verification in the target selection path:

1. Verify `synced_ledger_info` signatures in `highest_synced_ledger_info()` before selecting
2. Validate against the current epoch state before accepting peer advertisements
3. Add early rejection of advertisements with implausibly high versions compared to honest peers
4. Consider requiring quorum agreement on ledger info versions before accepting as target

## Proof of Concept

A malicious peer can implement a custom storage service that responds to `GetStorageServerSummary` with:

```rust
StorageServerSummary {
    protocol_metadata: /* normal metadata */,
    data_summary: DataSummary {
        synced_ledger_info: Some(fabricated_ledger_info_with_version_10000000),
        /* other fields */
    }
}
```

When an honest validator queries this peer, it will:
1. Accept the advertisement without verification
2. Include it in the global data summary
3. Select it as the highest synced ledger info
4. Set it as the sync target
5. Create requests for version 10,000,000
6. Fail repeatedly as no peer can service the request
7. Retry 5 times with exponential backoff
8. Terminate the stream

This delays the validator's synchronization by multiple minutes before peer scoring takes effect.

---

**Notes:**
This is a protocol-level logic vulnerability, not a network DoS attack. It exploits missing verification in the target selection mechanism and qualifies as "Validator node slowdowns" (High severity) rather than being out of scope as a network DoS.

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L152-174)
```rust
    fn is_ignored(&self) -> bool {
        // Only ignore peers if the config allows it
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }

        // Otherwise, ignore peers with a low score
        self.score <= IGNORE_PEER_THRESHOLD
    }

    /// Updates the score of the peer according to a successful operation
    fn update_score_success(&mut self) {
        self.score = f64::min(self.score + SUCCESSFUL_RESPONSE_DELTA, MAX_SCORE);
    }

    /// Updates the score of the peer according to an error
    fn update_score_error(&mut self, error: ErrorType) {
        let multiplier = match error {
            ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
            ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        };
        self.score = f64::max(self.score * multiplier, MIN_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L374-378)
```rust
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
```

**File:** state-sync/aptos-data-client/src/poller.rs (L436-439)
```rust
        // Update the summary for the peer
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L184-198)
```rust
    pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
        let highest_synced_position = self
            .synced_ledger_infos
            .iter()
            .map(|ledger_info_with_sigs| ledger_info_with_sigs.ledger_info().version())
            .position_max();

        if let Some(highest_synced_position) = highest_synced_position {
            self.synced_ledger_infos
                .get(highest_synced_position)
                .cloned()
        } else {
            None
        }
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L498-535)
```rust
    fn select_target_ledger_info(
        &self,
        advertised_data: &AdvertisedData,
    ) -> Result<Option<LedgerInfoWithSignatures>, Error> {
        // Check if the stream has a final target ledger info
        match &self.request {
            StreamRequest::ContinuouslyStreamTransactions(request) => {
                if let Some(target) = &request.target {
                    return Ok(Some(target.clone()));
                }
            },
            StreamRequest::ContinuouslyStreamTransactionOutputs(request) => {
                if let Some(target) = &request.target {
                    return Ok(Some(target.clone()));
                }
            },
            StreamRequest::ContinuouslyStreamTransactionsOrOutputs(request) => {
                if let Some(target) = &request.target {
                    return Ok(Some(target.clone()));
                }
            },
            request => invalid_stream_request!(request),
        };

        // We don't have a final target, select the highest to make progress
        if let Some(highest_synced_ledger_info) = advertised_data.highest_synced_ledger_info() {
            let (next_request_version, _) = self.next_request_version_and_epoch;
            if next_request_version > highest_synced_ledger_info.ledger_info().version() {
                Ok(None) // We're already at the highest synced ledger info. There's no known target.
            } else {
                Ok(Some(highest_synced_ledger_info))
            }
        } else {
            Err(Error::DataIsUnavailable(
                "Unable to find the highest synced ledger info!".into(),
            ))
        }
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1186-1192)
```rust
        // If we don't have a syncing target, try to select one
        let (next_request_version, next_request_epoch) = self.next_request_version_and_epoch;
        if self.current_target_ledger_info.is_none() {
            // Try to select a new ledger info from the advertised data
            if let Some(target_ledger_info) =
                self.select_target_ledger_info(&global_data_summary.advertised_data)?
            {
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L452-465)
```rust
        // Verify the ledger info state and signatures
        if let Err(error) = self
            .get_speculative_stream_state()?
            .verify_ledger_info_with_signatures(ledger_info_with_signatures)
        {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::PayloadProofFailed,
            )))
            .await?;
            Err(error)
        } else {
            Ok(())
        }
```

**File:** state-sync/state-sync-driver/src/utils.rs (L100-110)
```rust
    /// Verifies the given ledger info with signatures against the current epoch state
    pub fn verify_ledger_info_with_signatures(
        &mut self,
        ledger_info_with_signatures: &LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        self.epoch_state
            .verify(ledger_info_with_signatures)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })
    }
```

**File:** config/src/config/state_sync_config.rs (L256-277)
```rust
    pub max_request_retry: u64,

    /// Maximum lag (in seconds) we'll tolerate when sending subscription requests
    pub max_subscription_stream_lag_secs: u64,

    /// The interval (milliseconds) at which to check the progress of each stream.
    pub progress_check_interval_ms: u64,
}

impl Default for DataStreamingServiceConfig {
    fn default() -> Self {
        Self {
            dynamic_prefetching: DynamicPrefetchingConfig::default(),
            enable_subscription_streaming: false,
            global_summary_refresh_interval_ms: 50,
            max_concurrent_requests: MAX_CONCURRENT_REQUESTS,
            max_concurrent_state_requests: MAX_CONCURRENT_STATE_REQUESTS,
            max_data_stream_channel_sizes: 50,
            max_notification_id_mappings: 300,
            max_num_consecutive_subscriptions: 45, // At ~3 blocks per second, this should last ~15 seconds
            max_pending_requests: 50,
            max_request_retry: 5,
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L446-453)
```rust
        if self.stream_engine.is_stream_complete()
            || self.request_failure_count >= self.streaming_service_config.max_request_retry
            || self.send_failure
        {
            if !self.send_failure && self.stream_end_notification_id.is_none() {
                self.send_end_of_stream_notification().await?;
            }
            return Ok(()); // There's nothing left to do
```

**File:** state-sync/storage-service/server/src/storage.rs (L1036-1073)
```rust
    fn get_data_summary(&self) -> aptos_storage_service_types::Result<DataSummary, Error> {
        // Fetch the latest ledger info
        let latest_ledger_info_with_sigs = self.storage.get_latest_ledger_info()?;

        // Fetch the epoch ending ledger info range
        let latest_ledger_info = latest_ledger_info_with_sigs.ledger_info();
        let epoch_ending_ledger_infos = if latest_ledger_info.ends_epoch() {
            let highest_ending_epoch = latest_ledger_info.epoch();
            Some(CompleteDataRange::from_genesis(highest_ending_epoch))
        } else if latest_ledger_info.epoch() > 0 {
            let highest_ending_epoch =
                latest_ledger_info.epoch().checked_sub(1).ok_or_else(|| {
                    Error::UnexpectedErrorEncountered("Highest ending epoch overflowed!".into())
                })?;
            Some(CompleteDataRange::from_genesis(highest_ending_epoch))
        } else {
            None // We haven't seen an epoch change yet
        };

        // Fetch the transaction and transaction output ranges
        let latest_version = latest_ledger_info.version();
        let transactions = self.fetch_transaction_range(latest_version)?;
        let transaction_outputs = self.fetch_transaction_output_range(latest_version)?;

        // Fetch the state values range
        let states = self.fetch_state_values_range(latest_version, &transactions)?;

        // Return the relevant data summary
        let data_summary = DataSummary {
            synced_ledger_info: Some(latest_ledger_info_with_sigs),
            epoch_ending_ledger_infos,
            transactions,
            transaction_outputs,
            states,
        };

        Ok(data_summary)
    }
```
