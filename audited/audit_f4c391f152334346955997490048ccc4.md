# Audit Report

## Title
Consensus Observer Block Suppression via Race Condition in Pending Block Storage

## Summary
The consensus observer's pending block store allows attackers to suppress legitimate blocks by exploiting a race condition where duplicate detection occurs before cryptographic proof verification. An attacker can insert invalid blocks that pass structural validation but have forged proofs, causing legitimate blocks with the same epoch/round to be silently dropped.

## Finding Description

The vulnerability exists in the block processing pipeline where blocks without payloads bypass cryptographic verification before being stored in the pending block store.

**Attack Flow:**

1. **Attacker sends malicious block** (epoch=E, round=R, hash=A, invalid proof):
   - Passes `verify_ordered_blocks()` which only validates internal structure [1](#0-0) 
   - Since no payloads are included, inserted into pending store without proof verification [2](#0-1) 
   - Stored using (epoch, round) as key [3](#0-2) 

2. **Legitimate block arrives** (epoch=E, round=R, hash=B, valid proof):
   - Check `existing_pending_block()` returns true (attacker's block exists) [4](#0-3) 
   - Block is immediately dropped before reaching insertion logic [5](#0-4) 

3. **Payloads arrive for epoch=E, round=R**:
   - Attacker's block retrieved and processed [6](#0-5) 
   - Cryptographic verification `verify_ordered_proof()` finally executes and fails [7](#0-6) 
   - Invalid block rejected, but legitimate block was already suppressed

The root cause is the warning-only behavior when duplicates are detected by (epoch, round) without hash validation [8](#0-7) 

## Impact Explanation

**High Severity** - This vulnerability enables systematic Denial of Service attacks on consensus observers:

- **Consensus Observer Disruption**: Attackers can prevent observers from receiving any valid blocks by continuously sending invalid blocks for all upcoming rounds
- **Network Reliability**: Compromises the observer network's ability to track consensus state accurately
- **Cascading Failures**: Observers relying on suppressed blocks cannot sync or provide accurate data to downstream services

This qualifies as **High Severity** per Aptos bug bounty criteria: "Validator node slowdowns" and "Significant protocol violations" - the observer node becomes unable to fulfill its role in the network.

## Likelihood Explanation

**High Likelihood**:

- **Low Barrier**: Attacker only needs to be a subscribed peer (verified only for subscription status, not validator authority) [9](#0-8) 
- **Repeatable**: Attack can be executed for every block/round indefinitely
- **No Detection**: Only warnings are logged; no automatic peer banning or rate limiting visible in code
- **Low Cost**: Sending malformed blocks requires minimal resources

## Recommendation

**Immediate Fix**: Verify cryptographic proofs BEFORE checking for duplicates and storing blocks.

```rust
// In process_ordered_block_message(), verify proof early:
async fn process_ordered_block_message(
    &mut self,
    peer_network_id: PeerNetworkId,
    message_received_time: Instant,
    ordered_block: OrderedBlock,
) {
    // ... existing execution pool check ...
    
    // Verify the ordered blocks before processing
    if let Err(error) = ordered_block.verify_ordered_blocks() {
        // ... existing error handling ...
    }
    
    // NEW: Verify cryptographic proof BEFORE duplicate check
    let epoch_state = self.get_epoch_state();
    if ordered_block.proof_block_info().epoch() == epoch_state.epoch {
        if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
            error!("Failed to verify ordered proof early: {:?}", error);
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
    }
    
    // ... rest of existing logic ...
}
```

**Additional Hardening**:
1. Use block hash in duplicate detection instead of (epoch, round) alone
2. Implement peer reputation system to ban peers sending invalid blocks
3. Add metrics for dropped blocks due to duplicate detection

## Proof of Concept

```rust
#[tokio::test]
async fn test_block_suppression_attack() {
    // Setup consensus observer and subscription
    let mut observer = create_test_observer();
    let attacker_peer = PeerNetworkId::random();
    observer.subscription_manager.add_subscription(attacker_peer);
    
    // Step 1: Attacker sends block without payloads (invalid proof)
    let epoch = 10;
    let round = 100;
    let malicious_block = create_ordered_block_with_invalid_proof(epoch, round);
    // Remove payloads to trigger pending store path
    let malicious_msg = ConsensusObserverDirectSend::OrderedBlock(malicious_block.clone());
    observer.process_network_message(NetworkMessage::new(attacker_peer, malicious_msg)).await;
    
    // Verify malicious block is in pending store
    assert!(observer.observer_block_data.lock()
        .existing_pending_block(&malicious_block));
    
    // Step 2: Legitimate block with same epoch/round arrives
    let legitimate_peer = PeerNetworkId::random();
    observer.subscription_manager.add_subscription(legitimate_peer);
    let legitimate_block = create_ordered_block_with_valid_proof(epoch, round);
    let legit_msg = ConsensusObserverDirectSend::OrderedBlock(legitimate_block.clone());
    observer.process_network_message(NetworkMessage::new(legitimate_peer, legit_msg)).await;
    
    // BUG: Legitimate block should be stored but is dropped due to duplicate (epoch, round)
    // Only malicious block remains in pending store
    let pending = observer.observer_block_data.lock()
        .get_pending_block_by_hash(malicious_block.first_block().id());
    assert!(pending.is_some()); // Malicious block still present
    
    // Step 3: Payloads arrive
    let payload = create_block_payload(epoch, round);
    observer.process_block_payload_message(
        legitimate_peer, 
        Instant::now(), 
        payload
    ).await;
    
    // Malicious block fails verification, but legitimate block was suppressed
    // Observer received no valid block for this round - ATTACK SUCCESSFUL
}
```

**Notes:**
- The vulnerability requires the attacker to be a subscribed peer, but subscription validation only checks peer presence, not validator authority
- Attack is persistent and can suppress all blocks systematically
- No automatic mitigation exists; only warning logs are generated
- The issue fundamentally violates the consensus observer's safety guarantee: observers should receive valid blocks despite malicious peers

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L225-227)
```rust
    /// Verifies the ordered blocks and returns an error if the data is invalid.
    /// Note: this does not check the ordered proof.
    pub fn verify_ordered_blocks(&self) -> Result<(), Error> {
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L341-352)
```rust
    async fn order_ready_pending_block(&mut self, block_epoch: u64, block_round: Round) {
        // Remove any ready pending block
        let pending_block_with_metadata = self
            .observer_block_data
            .lock()
            .remove_ready_pending_block(block_epoch, block_round);

        // Process the ready ordered block (if it exists)
        if let Some(pending_block_with_metadata) = pending_block_with_metadata {
            self.process_ordered_block(pending_block_with_metadata)
                .await;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L578-594)
```rust
        // Verify the message is from the peers we've subscribed to
        if let Err(error) = self
            .subscription_manager
            .verify_message_for_subscription(peer_network_id)
        {
            // Update the rejected message counter
            increment_rejected_message_counter(&peer_network_id, &message);

            // Log the error and return
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received message that was not from an active subscription! Error: {:?}",
                    error,
                ))
            );
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L681-691)
```rust
        let block_pending = self
            .observer_block_data
            .lock()
            .existing_pending_block(&ordered_block);

        // If the block is out of date or already pending, ignore it
        if block_out_of_date || block_pending {
            // Update the metrics for the dropped ordered block
            update_metrics_for_dropped_ordered_block_message(peer_network_id, &ordered_block);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L706-713)
```rust
        if self.all_payloads_exist(pending_block_with_metadata.ordered_block().blocks()) {
            self.process_ordered_block(pending_block_with_metadata)
                .await;
        } else {
            self.observer_block_data
                .lock()
                .insert_pending_block(pending_block_with_metadata);
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L727-742)
```rust
        // Verify the ordered block proof
        let epoch_state = self.get_epoch_state();
        if ordered_block.proof_block_info().epoch() == epoch_state.epoch {
            if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify ordered proof! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        ordered_block.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L91-99)
```rust
    pub fn existing_pending_block(&self, ordered_block: &OrderedBlock) -> bool {
        // Get the epoch and round of the first block
        let first_block = ordered_block.first_block();
        let first_block_epoch_round = (first_block.epoch(), first_block.round());

        // Check if the block is already in the store by epoch and round
        self.blocks_without_payloads
            .contains_key(&first_block_epoch_round)
    }
```

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L116-132)
```rust
        // Insert the block into the store using the epoch round of the first block
        let first_block_epoch_round = (first_block.epoch(), first_block.round());
        match self.blocks_without_payloads.entry(first_block_epoch_round) {
            Entry::Occupied(_) => {
                // The block is already in the store
                warn!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "A pending block was already found for the given epoch and round: {:?}",
                        first_block_epoch_round
                    ))
                );
            },
            Entry::Vacant(entry) => {
                // Insert the block into the store
                entry.insert(pending_block.clone());
            },
        }
```
