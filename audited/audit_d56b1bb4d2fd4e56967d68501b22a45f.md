Audit Report

## Title
Bypass of Mainnet Anti-Unstable Bytecode Checks via Missing or Default CompilationMetadata

## Summary
Aptos Core’s mainnet bytecode validation can be bypassed by either omitting or defaulting `CompilationMetadata` in Move bytecode, permitting deployment of modules compiled with unstable (unapproved) compiler and language versions. This fundamentally breaks consensus safety barriers meant to prevent unstable/experimental features on production networks.

## Finding Description
The publish flow on mainnet uses `reject_unstable_bytecode()` to iterate over each module and reject those with `CompilationMetadata.unstable == true`. However, this check only occurs if compilation metadata is present—which is not required or enforced at the VM level. If the metadata is missing, the mainnet deployment check is silently bypassed. Furthermore, the `Default` implementation of `CompilationMetadata` sets `unstable: false` and provides empty/invalid version strings, allowing attackers to insert default metadata and thus falsely claim module stability. There is no validation of version fields themselves, only the boolean flag.

A determined attacker can compile modules with an unstable compiler, strip or spoof metadata (`unstable: false; compiler_version: ""; language_version: ""`), and deploy them on mainnet. As a concrete path:
1. Compile code using an unstable compiler version
2. Manually remove or craft the `CompilationMetadata` during serialization
3. Submit a publish transaction to mainnet
4. Mainnet validation passes because either:
   - There is no metadata (`None` case, check skipped)
   - Metadata claims `unstable: false`, and version strings aren't validated or parsed

## Impact Explanation
**Critical Severity**: Any unprivileged party can deploy code to mainnet compiled using unapproved/unstable features. This breaks the invariant that all mainnet bytecode must be compiled with an approved, safe toolchain, potentially causing:
- Consensus splits via non-deterministic or experimental code execution
- Irrecoverable state, freezing, or safety violations
- Exploit chaining with experimental features not reviewed for production

**All mainnet validators and application state are affected.**

## Likelihood Explanation
The attack does not require validator collusion nor privileged access. All tools required to serialize, modify, and strip Move bytecode metadata are public. The Aptos publish APIs do not enforce the presence or correctness of compilation metadata, thus making exploitation trivial.

## Recommendation
1. **Enforce Required Metadata**: Reject any publish attempts on mainnet unless valid, _parseable_ `CompilationMetadata` is present for all modules.
2. **Strict Version Validation**: Reject metadata with empty or unparseable compiler/language version strings.
3. **Safe Default**: Change the `Default` implementation of `CompilationMetadata` to set `unstable: true`, or (better) never accept default-constructed metadata in production flows.
4. **Mitigation**: Backfill all existing deployed modules with proper, auditable metadata, or restrict module loading to known-good hashes.

## Proof of Concept

1. Compile any Move module (with `move-compiler` unstable version, e.g., `V2_1`)
2. Manually edit serialized bytecode to remove (or set default) `CompilationMetadata` entry
3. Use API to publish to mainnet
4. Observe: No `StatusCode::UNSTABLE_BYTECODE_REJECTED` error occurs, module is accepted

---

**Relevant code citations:** [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

---

**Notes:**  
The exploit does not depend on test harnesses, is present in main production execution flow, and does not require insider access. It directly breaks consensus-related invariants and must be addressed prior to further mainnet releases.

### Citations

**File:** third_party/move/move-model/src/metadata.rs (L49-62)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CompilationMetadata {
    /// A flag indicating whether, at time of creation, the compilation
    /// result was considered as unstable. Unstable code may have restrictions
    /// for deployment on production networks. This flag is true if either the
    /// compiler or language versions are unstable.
    pub unstable: bool,
    /// The version of the compiler, as a string. See
    /// `CompilationVersion::from_str` for supported version strings.
    pub compiler_version: String,
    /// The version of the language, as a string. See
    /// `LanguageVersion::from_str` for supported version strings.
    pub language_version: String,
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** types/src/vm/module_metadata.rs (L311-317)
```rust
pub fn get_compilation_metadata(code: &impl CompiledCodeMetadata) -> Option<CompilationMetadata> {
    if let Some(data) = find_metadata(code.metadata(), COMPILATION_METADATA_KEY) {
        bcs::from_bytes::<CompilationMetadata>(&data.value).ok()
    } else {
        None
    }
}
```

**File:** aptos-move/e2e-move-tests/src/tests/metadata.rs (L123-127)
```rust
    let mut compiled_module = CompiledModule::deserialize(&origin_code[0]).unwrap();
    let metadata = f();
    let mut invalid_code = vec![];
    compiled_module.metadata = metadata;
    compiled_module.serialize(&mut invalid_code).unwrap();
```

**File:** third_party/move/move-compiler-v2/src/file_format_generator/module_generator.rs (L165-170)
```rust
        let compilation_metadata = CompilationMetadata::new(compiler_version, language_version);
        let metadata = Metadata {
            key: COMPILATION_METADATA_KEY.to_vec(),
            value: bcs::to_bytes(&compilation_metadata)
                .expect("Serialization of CompilationMetadata should succeed"),
        };
```
