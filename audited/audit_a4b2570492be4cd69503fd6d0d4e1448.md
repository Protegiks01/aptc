# Audit Report

## Title
Consensus Split Risk from Uncoordinated BlockEndInfo Version Upgrades

## Summary
If `BlockEndInfo` were to add a V1 variant with different fields or structure, validators running different software versions would generate block epilogue transactions with different BCS serializations, leading to divergent transaction hashes, different state roots, and a consensus split requiring a hard fork to resolve.

## Finding Description

The `get_block_end_info()` function in `limit_processor.rs` creates a `BlockEndInfo::V0` structure containing block gas and output limit metrics. [1](#0-0) 

This `BlockEndInfo` is embedded within a `Transaction::BlockEpilogue` that gets BCS-serialized and committed to the ledger. [2](#0-1) 

The `BlockEndInfo` enum currently has only a V0 variant. [3](#0-2) 

**Critical Flaw:** There is no feature flag or on-chain coordination mechanism for `BlockEndInfo` versioning itself. While `BlockEpiloguePayload` V0/V1 selection is coordinated via the `CALCULATE_TRANSACTION_FEE_FOR_DISTRIBUTION` feature flag, [4](#0-3)  no such mechanism exists for the internal `BlockEndInfo` structure.

**Consensus Violation Path:**
1. Network plans to add `BlockEndInfo::V1` with new fields
2. During rolling upgrade, some validators run software creating V1, others create V0
3. Both validator sets execute identical user transactions
4. When generating block epilogue, they create different `BlockEndInfo` variants
5. Different variants → different BCS serialization → different transaction hashes
6. Block epilogue transaction becomes part of committed state
7. Different transaction hashes → different state modifications → different Merkle tree roots
8. Validators cannot agree on block commitment → **consensus split**

The block epilogue transaction is extracted and its `BlockEndInfo` is parsed during execution output processing. [5](#0-4) 

## Impact Explanation

**Severity: Critical** - Non-recoverable network partition (up to $1,000,000 per bug bounty)

This breaks the fundamental invariant: "**Deterministic Execution**: All validators must produce identical state roots for identical blocks."

Impact consequences:
- Network splits into two incompatible chains (V0 validators vs V1 validators)
- Neither chain can achieve consensus quorum if split crosses 2/3 threshold
- Complete loss of liveness until hard fork coordination
- All transactions after the split point exist on divergent chains
- Requires emergency hard fork and manual chain selection to resolve
- Potential loss of user funds on the abandoned chain

## Likelihood Explanation

**Current Likelihood: N/A** - `BlockEndInfo` currently has only V0 variant

**Future Likelihood (if V1 added without proper coordination): High**

This would occur automatically during any rolling upgrade where:
1. Core developers add `BlockEndInfo::V1` with new fields
2. Validators upgrade their nodes incrementally (standard practice)
3. No feature flag gates the version selection

The issue requires no attacker and no malicious behavior - it would manifest during legitimate operational procedures (software upgrades), making it inevitable unless proper version coordination is implemented.

## Recommendation

**Add feature flag for BlockEndInfo version coordination:**

1. Add new feature flag in `types/src/on_chain_config/aptos_features.rs`:
```rust
BLOCK_END_INFO_V1 = 98,
```

2. Modify `get_block_end_info()` to check feature flag:
```rust
pub(crate) fn get_block_end_info(&self, features: &Features) -> TBlockEndInfoExt<T::Key> {
    let inner = if features.is_block_end_info_v1_enabled() {
        // Future: Create BlockEndInfo::V1 when feature is enabled
        BlockEndInfo::V0 { /* ... */ }
    } else {
        BlockEndInfo::V0 { /* ... */ }
    };
    // ...
}
```

3. Coordinate feature flag activation through on-chain governance before releasing software with V1 support
4. Ensure all validators upgrade to V1-compatible software before enabling flag
5. Activate flag via governance proposal to atomically switch all validators simultaneously

## Proof of Concept

```rust
#[cfg(test)]
mod consensus_split_test {
    use super::*;
    use aptos_types::transaction::{BlockEndInfo, Transaction};
    use bcs;
    
    #[test]
    fn test_different_block_end_info_versions_produce_different_hashes() {
        // Simulate V0 validator creating block epilogue
        let block_id = HashValue::zero();
        let v0_info = BlockEndInfo::V0 {
            block_gas_limit_reached: true,
            block_output_limit_reached: false,
            block_effective_block_gas_units: 1000,
            block_approx_output_size: 5000,
        };
        let txn_v0 = Transaction::block_epilogue_v0(block_id, v0_info);
        let bytes_v0 = bcs::to_bytes(&txn_v0).unwrap();
        
        // Simulate V1 validator creating block epilogue (hypothetical V1 with extra field)
        // If BlockEndInfo::V1 existed with different structure:
        // let v1_info = BlockEndInfo::V1 { 
        //     block_gas_limit_reached: true,
        //     block_output_limit_reached: false,
        //     block_effective_block_gas_units: 1000,
        //     block_approx_output_size: 5000,
        //     new_field: 123, // <- Causes different serialization
        // };
        // let txn_v1 = Transaction::block_epilogue_v0(block_id, v1_info);
        // let bytes_v1 = bcs::to_bytes(&txn_v1).unwrap();
        
        // assert_ne!(bytes_v0, bytes_v1); // Different bytes → consensus split
        
        // Current test shows V0 serialization is deterministic:
        let bytes_v0_copy = bcs::to_bytes(&Transaction::block_epilogue_v0(
            block_id,
            BlockEndInfo::V0 {
                block_gas_limit_reached: true,
                block_output_limit_reached: false,
                block_effective_block_gas_units: 1000,
                block_approx_output_size: 5000,
            }
        )).unwrap();
        
        assert_eq!(bytes_v0, bytes_v0_copy); // Same version → deterministic
    }
}
```

## Notes

This vulnerability is **hypothetical** - it describes what would happen IF `BlockEndInfo::V1` were added without proper version coordination. The current codebase only has V0, so there is no exploitable vulnerability today. However, the lack of a coordination mechanism represents a **critical protocol design gap** that must be addressed before any future BlockEndInfo version upgrades.

The issue cannot be exploited by an unprivileged attacker as it requires validators to run different software versions, which occurs during legitimate upgrade procedures, not through external attack vectors.

### Citations

**File:** aptos-move/block-executor/src/limit_processor.rs (L271-292)
```rust
    pub(crate) fn get_block_end_info(&self) -> TBlockEndInfoExt<T::Key> {
        let inner = BlockEndInfo::V0 {
            block_gas_limit_reached: self
                .block_gas_limit()
                .map(|per_block_gas_limit| {
                    self.get_effective_accumulated_block_gas() >= per_block_gas_limit
                })
                .unwrap_or(false),
            block_output_limit_reached: self
                .block_gas_limit_type
                .block_output_limit()
                .map(|per_block_output_limit| {
                    self.get_accumulated_approx_output_size() >= per_block_output_limit
                })
                .unwrap_or(false),
            block_effective_block_gas_units: self.get_effective_accumulated_block_gas(),
            block_approx_output_size: self.get_accumulated_approx_output_size(),
        };

        let to_make_hot = self.get_keys_to_make_hot();
        TBlockEndInfoExt::new(inner, to_make_hot)
    }
```

**File:** types/src/transaction/mod.rs (L2945-2977)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub enum Transaction {
    /// Transaction submitted by the user. e.g: P2P payment transaction, publishing module
    /// transaction, etc.
    /// TODO: We need to rename SignedTransaction to SignedUserTransaction, as well as all the other
    ///       transaction types we had in our codebase.
    UserTransaction(SignedTransaction),

    /// Transaction that applies a WriteSet to the current storage, it's applied manually via aptos-db-bootstrapper.
    GenesisTransaction(WriteSetPayload),

    /// Transaction to update the block metadata resource at the beginning of a block,
    /// when on-chain randomness is disabled.
    BlockMetadata(BlockMetadata),

    /// Transaction to let the executor update the global state tree and record the root hash
    /// in the TransactionInfo
    /// The hash value inside is unique block id which can generate unique hash of state checkpoint transaction
    StateCheckpoint(HashValue),

    /// Transaction that only proposed by a validator mainly to update on-chain configs.
    ValidatorTransaction(ValidatorTransaction),

    /// Transaction to update the block metadata resource at the beginning of a block,
    /// when on-chain randomness is enabled.
    BlockMetadataExt(BlockMetadataExt),

    /// Transaction to let the executor update the global state tree and record the root hash
    /// in the TransactionInfo
    /// The hash value inside is unique block id which can generate unique hash of state checkpoint transaction
    /// Replaces StateCheckpoint, with optionally having more data.
    BlockEpilogue(BlockEpiloguePayload),
}
```

**File:** types/src/transaction/block_epilogue.rs (L63-74)
```rust
pub enum BlockEndInfo {
    V0 {
        /// Whether block gas limit was reached
        block_gas_limit_reached: bool,
        /// Whether block output limit was reached
        block_output_limit_reached: bool,
        /// Total gas_units block consumed
        block_effective_block_gas_units: u64,
        /// Total output size block produced
        block_approx_output_size: u64,
    },
}
```

**File:** aptos-move/block-executor/src/executor.rs (L2023-2028)
```rust
        if !features.is_calculate_transaction_fee_for_distribution_enabled() {
            return Ok(T::block_epilogue_v0(
                block_id,
                block_end_info.to_persistent(),
            ));
        }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L379-385)
```rust
        let mut block_end_info = None;
        if is_block {
            if let Some(Transaction::BlockEpilogue(payload)) = transactions.last() {
                block_end_info = payload.try_as_block_end_info().cloned();
                ensure!(statuses_for_input_txns.pop().is_some());
            }
        }
```
