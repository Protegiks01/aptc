# Audit Report

## Title
Parking Lot Eviction Bypass Enables Denial-of-Service via Unnecessary Broadcast Backoff

## Summary
An attacker can fill a node's mempool parking lot with future-sequence transactions, causing legitimate broadcast messages containing non-ready transactions to trigger unnecessary 30-second backoff delays without attempting parking lot eviction. This exploits a flaw in the eviction logic that only evicts when incoming transactions are ready for broadcast.

## Finding Description

The `gen_ack_response()` function triggers backoff when any transaction receives `MempoolStatusCode::MempoolIsFull`. [1](#0-0) 

The root cause lies in `TransactionStore::check_is_full_after_eviction()`, which only attempts to evict parking lot transactions when **both** conditions are met:
1. Mempool is full
2. The incoming transaction is ready for broadcast [2](#0-1) 

A transaction is "ready" only if its sequence number matches the receiver's view of the account's current sequence number. [3](#0-2) 

**Attack Scenario:**

1. **Parking Lot Saturation**: Attacker creates ~313-20,000 accounts (depending on transaction sizes) and sends up to 100 future-sequence transactions per account to the victim node. These transactions are valid (pass VM validation) but have sequence numbers ahead of the on-chain state, placing them in the parking lot. With default config values, this fills mempool capacity. [4](#0-3) 

2. **State Divergence Exploitation**: Due to natural state synchronization delays, honest Node A (at block height N+10) broadcasts transactions that are ready on its state view but NOT ready on the victim's state view (at block height N). When the victim receives these broadcasts, `check_txn_ready()` returns false.

3. **Eviction Bypass**: Since the incoming transactions are not ready, the eviction loop never executes, even though the parking lot is full of attacker-controlled transactions that could be evicted. `MempoolIsFull` is returned. [5](#0-4) 

4. **Backoff Trigger**: The `MempoolIsFull` status causes `gen_ack_response()` to set `backoff_and_retry = true`, which puts the honest broadcaster into backoff mode. [6](#0-5) 

5. **Broadcast Delay**: The broadcaster now waits 30 seconds (default `shared_mempool_backoff_interval_ms`) instead of 10 milliseconds between broadcasts to the victim. [7](#0-6) 

The mempool is "full" in absolute terms, but conceptually not full of useful transactions—the parking lot contains evictable attacker-controlled junk that will never become ready.

## Impact Explanation

**Severity: High** - This qualifies as "Validator node slowdowns" per the Aptos bug bounty program.

**Network-Wide Impact:**
- Transaction propagation delays of 30 seconds across affected peer connections
- Reduced mempool synchronization efficiency network-wide
- Potential for consensus liveness degradation if enough nodes are targeted simultaneously
- User-facing delays in transaction confirmation times

**Resource Requirements:**
- With default capacity of 2GB bytes and 2M transactions, attacker needs ~313 accounts (at max transaction size ~64KB) or up to 20,000 accounts (for minimal transactions)
- Per-account limit of 100 transactions enforced. [8](#0-7) 
- Continuous cost to maintain attack as transactions expire after 600 seconds. [9](#0-8) 

## Likelihood Explanation

**Likelihood: Medium-High**

**Favorable Factors for Attacker:**
- State divergence between nodes is common in distributed systems (nodes at different block heights)
- Nodes continuously broadcast from their timeline, creating regular opportunities to trigger the vulnerability
- Attack can target specific high-value nodes (VFNs, major RPC providers)
- Per-account limits can be circumvented by creating multiple accounts

**Mitigating Factors:**
- Requires significant upfront cost (account creation + gas for parking lot transactions)
- Requires continuous maintenance (transactions expire after 10 minutes)
- Randomized eviction from parking lot means some legitimate transactions might still evict attacker's transactions [10](#0-9) 

## Recommendation

**Solution: Implement opportunistic eviction for non-ready incoming transactions**

Modify `check_is_full_after_eviction()` to attempt parking lot eviction even when the incoming transaction is not ready, if the parking lot has sufficient size:

```rust
fn check_is_full_after_eviction(
    &mut self,
    txn: &MempoolTransaction,
    account_sequence_number: Option<u64>,
) -> bool {
    // Evict if mempool is full and EITHER:
    // 1. The incoming transaction is ready (original logic), OR
    // 2. The parking lot is above a threshold (e.g., 10% of capacity)
    let should_evict = self.is_full() && 
        (self.check_txn_ready(txn, account_sequence_number) || 
         self.parking_lot_index.size() > self.capacity / 10);
    
    if should_evict {
        let now = Instant::now();
        let mut evicted_txns = 0;
        let mut evicted_bytes = 0;
        while let Some(txn_pointer) = self.parking_lot_index.get_poppable() {
            if let Some(txn) = self.transactions.get_mut(&txn_pointer.sender)
                .and_then(|txns| txns.remove(&txn_pointer.replay_protector)) 
            {
                evicted_bytes += txn.get_estimated_bytes() as u64;
                evicted_txns += 1;
                self.index_remove(&txn);
                if !self.is_full() {
                    break;
                }
            } else {
                break;
            }
        }
        if evicted_txns > 0 {
            counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_COUNT.observe(evicted_txns as f64);
            counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_BYTES.observe(evicted_bytes as f64);
            counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_LATENCY
                .observe(now.elapsed().as_secs_f64());
        }
    }
    self.is_full()
}
```

**Alternative: Implement per-broadcast-source backoff tracking**

Instead of blanket backoff for all broadcasts, track backoff per peer and only apply backoff if the same peer repeatedly triggers `MempoolIsFull`.

## Proof of Concept

```rust
#[cfg(test)]
mod parking_lot_dos_test {
    use super::*;
    
    #[test]
    fn test_parking_lot_eviction_bypass() {
        // Setup: Create mempool with small capacity for testing
        let mut config = NodeConfig::default();
        config.mempool.capacity = 1000;
        config.mempool.capacity_per_user = 10;
        let mut mempool = Mempool::new(&config);
        
        // Step 1: Attacker fills parking lot with future transactions
        // Create 100 attacker accounts
        for account_idx in 0..100 {
            let attacker_account = AccountAddress::random();
            // Send 10 transactions with future sequence numbers (5-14)
            // while on-chain sequence is 0
            for seq in 5..15 {
                let txn = create_transaction(attacker_account, seq);
                let status = mempool.add_txn(
                    txn,
                    0, // ranking_score
                    Some(0), // account_sequence_number = 0 (on-chain)
                    TimelineState::NotReady,
                    false,
                    None,
                    None,
                );
                // Should be accepted but go to parking lot
                assert_eq!(status.code, MempoolStatusCode::Accepted);
            }
        }
        
        // Verify mempool is full (1000 transactions in parking lot)
        assert!(mempool.transactions.is_full());
        
        // Step 2: Honest node broadcasts transaction that is NOT ready on victim
        let honest_account = AccountAddress::random();
        let broadcast_txn = create_transaction(honest_account, 5);
        
        // On victim's state view, account sequence is 0
        // So transaction with seq 5 is NOT ready
        let status = mempool.add_txn(
            broadcast_txn,
            100, // high ranking_score
            Some(0), // account_sequence_number = 0
            TimelineState::NotReady,
            false,
            None,
            None,
        );
        
        // BUG: Returns MempoolIsFull instead of evicting parking lot
        assert_eq!(status.code, MempoolStatusCode::MempoolIsFull);
        
        // Expected: Should evict from parking lot and accept transaction
        // or at least not return MempoolIsFull if parking lot is evictable
    }
}
```

**Notes**

The vulnerability is subtle because it conflates two distinct concepts:
1. **Absolute capacity** (mempool size limits)
2. **Effective capacity** (capacity for useful, ready-to-broadcast transactions)

The parking lot can be filled with attacker-controlled transactions that will never become ready, creating a denial-of-service condition where the mempool appears full but contains primarily junk. The eviction policy fails to account for this scenario when legitimate broadcasts contain non-ready transactions due to natural state divergence.

The 3000x slowdown (10ms → 30s) in broadcast intervals represents a significant degradation in transaction propagation efficiency, potentially affecting network liveness if deployed against multiple high-connectivity nodes simultaneously.

### Citations

**File:** mempool/src/shared_mempool/tasks.rs (L108-114)
```rust
    let schedule_backoff = network_interface.is_backoff_mode(&peer);

    let interval_ms = if schedule_backoff {
        smp.config.shared_mempool_backoff_interval_ms
    } else {
        smp.config.shared_mempool_tick_interval_ms
    };
```

**File:** mempool/src/shared_mempool/tasks.rs (L254-278)
```rust
fn gen_ack_response(
    message_id: MempoolMessageId,
    results: Vec<SubmissionStatusBundle>,
    peer: &PeerNetworkId,
) -> MempoolSyncMsg {
    let mut backoff_and_retry = false;
    for (_, (mempool_status, _)) in results.into_iter() {
        if mempool_status.code == MempoolStatusCode::MempoolIsFull {
            backoff_and_retry = true;
            break;
        }
    }

    update_ack_counter(
        peer,
        counters::SENT_LABEL,
        backoff_and_retry,
        backoff_and_retry,
    );
    MempoolSyncMsg::BroadcastTransactionsResponse {
        message_id,
        retry: backoff_and_retry,
        backoff: backoff_and_retry,
    }
}
```

**File:** mempool/src/core_mempool/transaction_store.rs (L311-317)
```rust
        if self.check_is_full_after_eviction(&txn, account_sequence_number) {
            return MempoolStatus::new(MempoolStatusCode::MempoolIsFull).with_message(format!(
                "Mempool is full. Mempool size: {}, Capacity: {}",
                self.system_ttl_index.size(),
                self.capacity,
            ));
        }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L322-332)
```rust
            match txn_replay_protector {
                ReplayProtector::SequenceNumber(_) => {
                    if txns.seq_num_txns_len() >= self.capacity_per_user {
                        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
                            format!(
                                "Mempool over capacity for account. Number of seq number transactions from account: {} Capacity per account: {}",
                                txns.seq_num_txns_len() ,
                                self.capacity_per_user,
                            ),
                        );
                    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L415-456)
```rust
    fn check_is_full_after_eviction(
        &mut self,
        txn: &MempoolTransaction,
        account_sequence_number: Option<u64>,
    ) -> bool {
        if self.is_full() && self.check_txn_ready(txn, account_sequence_number) {
            let now = Instant::now();
            // try to free some space in Mempool from ParkingLot by evicting non-ready txns
            let mut evicted_txns = 0;
            let mut evicted_bytes = 0;
            while let Some(txn_pointer) = self.parking_lot_index.get_poppable() {
                if let Some(txn) = self
                    .transactions
                    .get_mut(&txn_pointer.sender)
                    .and_then(|txns| txns.remove(&txn_pointer.replay_protector))
                {
                    debug!(
                        LogSchema::new(LogEntry::MempoolFullEvictedTxn).txns(TxnsLog::new_txn(
                            txn.get_sender(),
                            txn.get_replay_protector()
                        ))
                    );
                    evicted_bytes += txn.get_estimated_bytes() as u64;
                    evicted_txns += 1;
                    self.index_remove(&txn);
                    if !self.is_full() {
                        break;
                    }
                } else {
                    error!("Transaction not found in mempool while evicting from parking lot");
                    break;
                }
            }
            if evicted_txns > 0 {
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_COUNT.observe(evicted_txns as f64);
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_BYTES.observe(evicted_bytes as f64);
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_LATENCY
                    .observe(now.elapsed().as_secs_f64());
            }
        }
        self.is_full()
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L468-500)
```rust
    fn check_txn_ready(
        &self,
        txn: &MempoolTransaction,
        account_sequence_number: Option<u64>,
    ) -> bool {
        let tx_replay_protector = txn.get_replay_protector();
        match tx_replay_protector {
            ReplayProtector::SequenceNumber(tx_sequence_number) => {
                let account_sequence_number = account_sequence_number.expect("Account sequence number is always provided for transactions with sequence number");
                if tx_sequence_number == account_sequence_number {
                    return true;
                } else if tx_sequence_number == 0 {
                    // shouldn't really get here because filtering out old txn sequence numbers happens earlier in workflow
                    unreachable!("[mempool] already committed txn detected, cannot be checked for readiness upon insertion");
                }

                // check previous txn in sequence is ready
                if let Some(account_txns) = self.transactions.get(&txn.get_sender()) {
                    let prev_seq_number = ReplayProtector::SequenceNumber(tx_sequence_number - 1);
                    if let Some(prev_txn) = account_txns.get(&prev_seq_number) {
                        if let TimelineState::Ready(_) = prev_txn.timeline_state {
                            return true;
                        }
                    }
                }
                false
            },
            ReplayProtector::Nonce(_) => {
                // Nonce based transactions are always ready for broadcast
                true
            },
        }
    }
```

**File:** config/src/config/mempool_config.rs (L109-124)
```rust
    fn default() -> MempoolConfig {
        MempoolConfig {
            shared_mempool_tick_interval_ms: 10,
            shared_mempool_backoff_interval_ms: 30_000,
            shared_mempool_batch_size: 300,
            shared_mempool_max_batch_bytes: MAX_APPLICATION_MESSAGE_SIZE as u64,
            shared_mempool_ack_timeout_ms: 2_000,
            shared_mempool_max_concurrent_inbound_syncs: 4,
            max_broadcasts_per_peer: 20,
            max_sync_lag_before_unhealthy_secs: 30, // 30 seconds
            max_network_channel_size: 1024,
            mempool_snapshot_interval_secs: 180,
            capacity: 2_000_000,
            capacity_bytes: 2 * 1024 * 1024 * 1024,
            capacity_per_user: 100,
            default_failovers: 1,
```

**File:** config/src/config/mempool_config.rs (L129-129)
```rust
            system_transaction_timeout_secs: 600,
```

**File:** mempool/src/shared_mempool/network.rs (L349-354)
```rust
        // Backoff mode can only be turned off by executing a broadcast that was scheduled
        // as a backoff broadcast.
        // This ensures backpressure request from remote peer is honored at least once.
        if backoff {
            sync_state.broadcast_info.backoff_mode = true;
        }
```

**File:** mempool/src/core_mempool/index.rs (L636-646)
```rust
    /// Returns a random "non-ready" transaction (with highest sequence number for that account).
    pub(crate) fn get_poppable(&self) -> Option<TxnPointer> {
        let mut rng = rand::thread_rng();
        self.data.choose(&mut rng).and_then(|(sender, txns)| {
            txns.iter().next_back().map(|(seq_num, hash)| TxnPointer {
                sender: *sender,
                replay_protector: ReplayProtector::SequenceNumber(*seq_num),
                hash: *hash,
            })
        })
    }
```
