# Audit Report

## Title
Type Nesting Depth Mismatch Between Bytecode Verification and BCS Serialization Causes Transaction Failures in Resource Groups

## Summary
A configuration mismatch exists between the Move bytecode verifier's `max_type_depth` limit (20) and the BCS serialization depth limit (`MAX_TYPE_TAG_NESTING` = 8). This allows deployment of Move modules with resource types having deeply nested generic parameters that pass bytecode verification but fail during BCS serialization when accessed through resource groups, causing deterministic `VALUE_SERIALIZATION_ERROR` transaction failures.

## Finding Description

The vulnerability stems from inconsistent depth limits across validation layers in the Aptos Move VM:

**Bytecode Verification Layer**: When the `ENABLE_FUNCTION_VALUES` feature flag is enabled (standard production setting), the verifier allows types with depth up to 20. [1](#0-0) 

**BCS Serialization Layer**: The serialization system enforces a maximum nesting depth of 8 for `TypeTag` and `StructTag` serialization. [2](#0-1) 

The serialization depth check is enforced through a thread-local counter: [3](#0-2) 

**Attack Path**:
1. Attacker deploys a Move module containing a generic resource struct (e.g., `struct Wrapper<T> has key { inner: T }`)
2. The module passes bytecode verification because types can have depth up to 20
3. The resource is marked as `resource_group_member` via metadata attributes
4. Attacker instantiates the resource with 9-20 levels of nesting (e.g., `Wrapper<Wrapper<Wrapper<...>>>`)
5. When any transaction attempts to modify this resource in the group, the VM calls `group_tagged_resource_size()` to calculate gas costs [4](#0-3) 

6. Inside `group_tagged_resource_size()`, `bcs::serialized_size(&tag)` is invoked on the `StructTag` representing the deeply-nested type [5](#0-4) 

7. The serialization fails with "type tag nesting exceeded during serialization" error because depth exceeds 8
8. This is converted to `PartialVMError` with `StatusCode::VALUE_SERIALIZATION_ERROR`, aborting the transaction

**TypeTag Serialization**: The `StructTag` type contains a `type_args: Vec<TypeTag>` field, and nested `TypeTag::Struct`, `TypeTag::Vector`, and `TypeTag::Function` variants use custom serializers that enforce the depth limit. [6](#0-5) 

The vulnerability creates a logic error where types that pass all validation checks during module deployment and runtime type creation cannot be properly processed during gas calculation for resource group operations.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty criteria:

**Valid Impacts:**
1. **Denial of Service**: Malicious actors can deploy modules with deeply nested types and mark them as resource group members. Any transaction attempting to access these resource groups will fail deterministically with `VALUE_SERIALIZATION_ERROR`, rendering the resource group unusable for legitimate operations.

2. **Gas Calculation Failures**: The VM cannot calculate gas costs for operations involving types with 9-20 levels of nesting in resource groups, violating the design invariant that all successfully deployed and instantiated types should be processable.

3. **Transaction Failures**: Legitimate users interacting with affected resource groups will experience unexpected transaction failures, creating an availability issue.

**Severity Limitations:**
- The failure is deterministic across all validators (no consensus divergence)
- No direct loss of funds or state corruption occurs
- Limited to specific resource groups with maliciously crafted type definitions
- Does not require hardfork to resolve
- Transactions fail cleanly without violating blockchain invariants

The 12-level gap (20 vs 8) between verification and serialization limits provides ample exploitation space for types with depths 9-20.

## Likelihood Explanation

The vulnerability has **High Likelihood** of exploitation:

1. **No Special Privileges Required**: Any user can deploy Move modules with generic structs and mark them as resource group members through standard transaction submission.

2. **Easy to Trigger**: Deployment requires only defining a generic struct with the `key` ability, marking it with the `#[resource_group_member]` attribute, and instantiating it with sufficient nesting depth.

3. **Production Configuration Active**: The bytecode verifier's `max_type_depth = 20` is enabled when `ENABLE_FUNCTION_VALUES` feature flag is active, which is the standard production setting. [7](#0-6) 

4. **No Intermediate Validation**: The bytecode verification layer checks depth against limit 20, while serialization enforces limit 8, with no intermediate checks to catch this mismatch before gas calculation.

5. **Significant Gap**: The 12-level difference between limits provides substantial exploitation space.

This is a logic error in production configuration rather than an edge case, making it reliably exploitable.

## Recommendation

**Immediate Fix**: Align the `max_type_depth` limit in bytecode verification with `MAX_TYPE_TAG_NESTING` by setting both to 8, or increase `MAX_TYPE_TAG_NESTING` to match `max_type_depth` at 20 (after careful performance and DoS analysis).

**Option 1 (Conservative)**: Reduce `max_type_depth` to 8 in `aptos_prod_verifier_config()`:
```rust
max_type_depth: if enable_function_values {
    Some(8)  // Match MAX_TYPE_TAG_NESTING
} else {
    None
},
```

**Option 2 (Permissive)**: Increase `MAX_TYPE_TAG_NESTING` to 20 in `safe_serialize.rs`, but only after thorough analysis of:
- Stack depth implications during recursive serialization
- Performance impact of deeper nesting
- DoS risks from expensive serialization operations

**Additional Validation**: Add a pre-check in `group_tagged_resource_size()` to validate tag depth before attempting serialization, providing clearer error messages:
```rust
fn validate_tag_depth<T: Serialize>(tag: &T) -> PartialVMResult<()> {
    // Check depth before serialization attempt
    // Return clear error if exceeds limit
}
```

**Long-term**: Establish consistent depth limits across all type validation layers (bytecode verification, runtime type creation, and serialization) to prevent similar mismatches.

## Proof of Concept

```move
// malicious_module.move
module attacker::nested_type_dos {
    use std::signer;
    
    #[resource_group_member(group = attacker::nested_type_dos::Group)]
    struct Wrapper<T> has key {
        inner: T
    }
    
    #[resource_group]
    struct Group has key {}
    
    // Deploy with depth 9 nesting: Wrapper<Wrapper<Wrapper<...>>>
    // Call this function with sufficiently nested type arguments
    public fun create_nested<T: store>(account: &signer, value: T) {
        move_to(account, Wrapper<T> { inner: value });
    }
    
    // Any modification to this resource group will trigger:
    // 1. group_tagged_resource_size() call
    // 2. bcs::serialized_size() on StructTag with depth 9+
    // 3. MAX_TYPE_TAG_NESTING limit exceeded
    // 4. VALUE_SERIALIZATION_ERROR
}
```

When instantiated with type arguments creating depth â‰¥ 9, any transaction accessing this resource group will fail deterministically during gas calculation.

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-193)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    // Note: we reuse the `enable_function_values` flag to set various stricter limits on types.

    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
        _use_signature_checker_v2: true,
        sig_checker_v2_fix_script_ty_param_count,
        sig_checker_v2_fix_function_signatures,
        enable_enum_types,
        enable_resource_access_control,
        enable_function_values,
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
    }
```

**File:** third_party/move/move-core/types/src/safe_serialize.rs (L11-11)
```rust
pub(crate) const MAX_TYPE_TAG_NESTING: u8 = 8;
```

**File:** third_party/move/move-core/types/src/safe_serialize.rs (L25-37)
```rust
    const MAX_TYPE_TAG_NESTING_WHEN_SERIALIZING: u8 =
        MAX_TYPE_TAG_NESTING + if cfg!(test) { 1 } else { 0 };

    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        if *r >= MAX_TYPE_TAG_NESTING_WHEN_SERIALIZING {
            return Err(S::Error::custom(
                "type tag nesting exceeded during serialization",
            ));
        }
        *r += 1;
        Ok(())
    })?;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L183-189)
```rust
                let old_size = group_tagged_resource_size(&tag, old_tagged_value_size)?;
                decrement_size_for_remove_tag(&mut post_group_size, old_size)?;
            }

            match &current_op {
                MoveStorageOp::Modify((data, _)) | MoveStorageOp::New((data, _)) => {
                    let new_size = group_tagged_resource_size(&tag, data.len())?;
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L47-57)
```rust
pub fn group_tagged_resource_size<T: Serialize + Clone + Debug>(
    tag: &T,
    value_byte_len: usize,
) -> PartialVMResult<u64> {
    Ok((bcs::serialized_size(&tag).map_err(|e| {
        PartialVMError::new(StatusCode::VALUE_SERIALIZATION_ERROR).with_message(format!(
            "Tag serialization error for tag {:?}: {:?}",
            tag, e
        ))
    })? + bcs_size_of_byte_array(value_byte_len)) as u64)
}
```

**File:** third_party/move/move-core/types/src/language_storage.rs (L74-89)
```rust
    #[serde(rename = "vector", alias = "Vector")]
    Vector(
        #[serde(
            serialize_with = "safe_serialize::type_tag_recursive_serialize",
            deserialize_with = "safe_serialize::type_tag_recursive_deserialize"
        )]
        Box<TypeTag>,
    ),
    #[serde(rename = "struct", alias = "Struct")]
    Struct(
        #[serde(
            serialize_with = "safe_serialize::type_tag_recursive_serialize",
            deserialize_with = "safe_serialize::type_tag_recursive_deserialize"
        )]
        Box<StructTag>,
    ),
```
