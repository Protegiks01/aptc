# Audit Report

## Title
Missing Groth16 Verification Key Validation Enables Complete Denial-of-Service of Keyless Accounts via Governance Proposal

## Summary
The `set_groth16_verification_key_for_next_epoch` function in the keyless account module fails to validate the Groth16 verification key before storing it on-chain. A governance proposal can set an invalid verification key (e.g., malformed BN254 curve points, points not in the subgroup), which will cause all keyless account transactions to fail once applied, resulting in a complete denial-of-service requiring emergency governance intervention or hardfork to recover.

## Finding Description

The keyless authentication system includes a `validate_groth16_vk` function designed to pre-validate verification keys by checking that all BN254 elliptic curve points can be properly deserialized: [1](#0-0) 

However, this validation function is **never called** by the two functions that set the verification key: [2](#0-1) [3](#0-2) 

The `config_buffer::upsert` function performs no validation whatsoever - it simply packs the configuration into an `Any` type and stores it: [4](#0-3) 

When the environment loads the verification key from on-chain state, it attempts to deserialize the curve points. If deserialization fails due to invalid points, the error is silently converted to `None`: [5](#0-4) 

With `keyless_pvk` set to `None`, all transactions using keyless authenticators with zero-knowledge proofs are rejected: [6](#0-5) 

**Attack Path:**
1. Attacker crafts a governance proposal with an invalid `Groth16VerificationKey` (e.g., invalid BN254 G1/G2 points, zero points, points not in the correct subgroup)
2. Proposal passes governance vote and calls `set_groth16_verification_key_for_next_epoch`
3. Invalid VK is stored on-chain without validation
4. At next epoch transition, nodes attempt to load the VK
5. Deserialization fails in the Rust layer, `keyless_pvk` becomes `None`
6. **All keyless accounts with ZK proofs become completely unusable**

## Impact Explanation

This vulnerability meets **Critical Severity** criteria:

- **Total loss of liveness for keyless accounts**: All users with keyless accounts using zero-knowledge proofs would be unable to submit transactions. This represents a significant portion of the Aptos user base given keyless accounts are a key feature.

- **Non-recoverable without governance intervention**: Recovery requires either:
  - Emergency governance proposal to set a valid VK (but governance may be slow)
  - Hard fork if governance is unable to respond quickly enough

- **Affects consensus indirectly**: While not a direct consensus violation, the inability for a large portion of users to transact could cause economic disruption and network instability.

The warning comment acknowledges the severity: [7](#0-6) 

## Likelihood Explanation

**Likelihood: Medium-to-High**

- **Attacker Requirements**: Requires ability to submit and pass a governance proposal. While governance is permissioned, the requirement is significantly lower than validator insider access.

- **Technical Complexity**: Low - attacker simply needs to craft malformed BN254 points, which is trivial (e.g., all zeros, invalid field elements, points not on curve).

- **Detection Difficulty**: High - without validation, there's no automatic detection until the VK is applied and nodes attempt to deserialize it.

- **Mitigation Gaps**: The code comment in `groth16_vk.rs` incorrectly claims validation happens in Move, suggesting developers believed this was already protected: [8](#0-7) 

## Recommendation

Add validation before storing the verification key in both update functions:

```move
public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk);  // ADD THIS LINE
    config_buffer::upsert<Groth16VerificationKey>(vk);
}

public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    chain_status::assert_genesis();
    validate_groth16_vk(&vk);  // ADD THIS LINE
    move_to(fx, vk);
}
```

This ensures all VKs are validated before being stored, preventing invalid VKs from reaching the runtime environment.

## Proof of Concept

```move
#[test(aptos_framework = @0x1)]
#[expected_failure(abort_code = 0x10002, location = aptos_framework::keyless_account)]
fun test_invalid_vk_rejected(aptos_framework: &signer) {
    use aptos_framework::keyless_account;
    
    // Create an invalid verification key with all-zero bytes (invalid BN254 points)
    let invalid_vk = keyless_account::new_groth16_verification_key(
        vector[0u8; 32],  // invalid alpha_g1
        vector[0u8; 64],  // invalid beta_g2
        vector[0u8; 64],  // invalid gamma_g2
        vector[0u8; 64],  // invalid delta_g2
        vector[vector[0u8; 32], vector[0u8; 32]]  // invalid gamma_abc_g1
    );
    
    // This should fail with E_INVALID_BN254_G1_SERIALIZATION but currently succeeds
    keyless_account::set_groth16_verification_key_for_next_epoch(aptos_framework, invalid_vk);
}
```

Without the fix, this test will pass when it should abort. With the validation added, it will correctly abort with `E_INVALID_BN254_G1_SERIALIZATION`.

## Notes

The `validate_groth16_vk` function was clearly implemented with the intention of preventing this exact attack, but it was never integrated into the actual update flow. The existence of detailed warning comments about malicious VKs further confirms the developers were aware of the risk but failed to implement the protection correctly.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L198-203)
```text
    public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        chain_status::assert_genesis();
        // There should not be a previous resource set here.
        move_to(fx, vk);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L259-262)
```text
    /// WARNING: To mitigate against DoS attacks, a VK change should be done together with a training wheels PK change,
    /// so that old ZKPs for the old VK cannot be replayed as potentially-valid ZKPs.
    ///
    /// WARNING: If a malicious key is set, this would lead to stolen funds.
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/config_buffer.move (L65-70)
```text
    public(friend) fun upsert<T: drop + store>(config: T) acquires PendingConfigs {
        let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);
        let key = type_info::type_name<T>();
        let value = any::pack(config);
        simple_map::upsert(&mut configs.configs, key, value);
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L289-293)
```rust
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L188-191)
```rust
    // If there are ZK authenticators, the Groth16 VK must have been set on-chain.
    if with_zk && pvk.is_none() {
        return Err(invalid_signature!("Groth16 VK has not been set on-chain"));
    }
```

**File:** types/src/keyless/groth16_vk.rs (L70-73)
```rust
        // NOTE: Technically, we already validate the points when we set the VK in Move, so we could
        // make this 2x faster by avoiding the point validation checks  via
        // `deserialize_with_mode(..., Compress::Yes, Validate::No)`. Due to paranoia, will not
        // optimize this for now.
```
