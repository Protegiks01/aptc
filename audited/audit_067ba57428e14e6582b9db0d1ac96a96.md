# Audit Report

## Title
Consensus Observer Channel Saturation DoS via Pre-Validation Message Flooding

## Summary
An attacker can flood the consensus observer network channels (max_network_channel_size=1000) with messages from non-subscribed peers, causing legitimate consensus messages to be dropped and forcing nodes into fallback mode. The vulnerability exists because subscription validation occurs **after** messages occupy channel slots, allowing any authenticated peer to saturate the channels before validation rejects their messages.

## Finding Description

The consensus observer system uses a two-stage channel architecture with FIFO queuing (drops newest messages when full):

1. **Network layer channel** (1000 capacity) - receives messages from network peers
2. **Internal routing channel** (1000 capacity) - routes messages to observer/publisher [1](#0-0) 

The critical flaw is in the message flow sequence:

**Network Layer** → Messages from ANY authenticated peer are accepted into the network channel: [2](#0-1) 

The network peer handler pushes messages to the upstream handler channel without verifying subscription status - it only checks that a handler exists for the protocol_id.

**Network Handler** → Messages are forwarded to internal routing channel: [3](#0-2) 

When the channel push fails (channel full), the error is only logged and the message is dropped silently.

**Observer Processing** → Subscription validation occurs ONLY when processing from the channel: [4](#0-3) 

**Channel Behavior** → FIFO queues drop the newest message when full: [5](#0-4) 

**Attack Scenario:**
1. Attacker establishes authenticated network connection (any peer can connect)
2. Attacker rapidly sends ConsensusObserverDirectSend messages (OrderedBlock, CommitDecision, etc.)
3. Messages fill network layer channel (1000 slots) and routing channel (1000 slots) = 2000 total
4. Legitimate messages from subscribed peers are dropped (FIFO drops newest)
5. Consensus observer cannot process new blocks, stops making progress
6. After 10 seconds without progress, fallback mode triggers: [6](#0-5) 

7. Node uses state sync for 10 minutes (observer_fallback_duration_ms default): [7](#0-6) 

The attacker can sustain this by sending small messages within bandwidth limits (rate limiting is byte-based, not message-based), repeatedly forcing nodes into degraded fallback mode.

## Impact Explanation

This vulnerability causes **High Severity** impact per the Aptos bug bounty classification:
- **Validator node slowdowns**: Affected nodes forced into 10-minute fallback periods repeatedly
- VFNs and consensus observer-enabled nodes cannot efficiently sync via fast consensus path
- Performance degrades to state sync speed during fallback
- Attack is sustainable and repeatable

Does NOT reach Critical severity because:
- No consensus safety violation (fallback is a designed recovery mechanism)
- No fund loss or theft
- Temporary performance issue, not permanent network partition
- Node recovers after fallback period

## Likelihood Explanation

**Likelihood: HIGH**

Attack requirements are minimal:
- Attacker needs authenticated network connection (public/VFN networks accept connections)
- No privileged access required
- No validator collusion needed
- Attack can be sustained within bandwidth limits by sending small messages
- Multiple attackers can target different nodes simultaneously

The attack is **trivial to execute**:
- Standard network client can send protocol messages
- No cryptographic bypasses needed
- Rate limits are byte-based, not message-based
- 1000-message channel capacity is relatively small for high-throughput flooding

## Recommendation

**Immediate Fix**: Implement subscription validation BEFORE accepting messages into channels.

Modify the network handler to validate subscriptions before pushing to internal routing:

```rust
// In consensus/src/consensus_observer/network/network_handler.rs
fn handle_observer_message(
    &mut self,
    peer_network_id: PeerNetworkId,
    message: ConsensusObserverDirectSend,
) {
    // Drop the message if the observer is not enabled
    if !self.consensus_observer_config.observer_enabled {
        return;
    }

    // ADD: Validate subscription BEFORE consuming channel slot
    if !self.is_peer_subscribed(&peer_network_id) {
        warn!(LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Dropped message from non-subscribed peer: {}",
            peer_network_id
        )));
        return;
    }

    // Create and send the consensus observer message
    let network_message = ConsensusObserverNetworkMessage::new(peer_network_id, message);
    if let Err(error) = self.observer_message_sender.push((), network_message) {
        error!(LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Failed to forward the observer message! Error: {:?}",
            error
        )));
    }
}
```

Add subscription state tracking to NetworkHandler:
- Share active subscription state from SubscriptionManager
- Use Arc<Mutex<>> or message passing for subscription updates
- Reject messages from non-subscribed peers early

**Alternative/Additional Mitigations**:
1. Implement per-peer message rate limiting at network layer
2. Increase channel capacity (temporary mitigation, doesn't solve root cause)
3. Use LIFO or KLAST queue style to preserve some recent messages
4. Add per-peer quotas in the channel (requires custom channel implementation)

## Proof of Concept

```rust
// Integration test demonstrating the attack
#[tokio::test]
async fn test_consensus_observer_channel_saturation_attack() {
    // Setup: Create a consensus observer node with default config
    let mut node_config = NodeConfig::default();
    node_config.consensus_observer.observer_enabled = true;
    node_config.consensus_observer.max_network_channel_size = 1000;
    
    // Create attacker peer (not subscribed)
    let attacker_peer = create_test_peer("attacker");
    
    // Create legitimate subscribed peer
    let legitimate_peer = create_test_peer("legitimate");
    subscribe_peer(&legitimate_peer);
    
    // Attack: Flood with 2000 small messages from attacker
    for i in 0..2000 {
        let fake_message = create_minimal_ordered_block_message(i);
        send_consensus_observer_message(&attacker_peer, fake_message);
        // Small delay to respect bandwidth limits
        tokio::time::sleep(Duration::from_micros(100)).await;
    }
    
    // Verify: Legitimate message is dropped
    let legitimate_message = create_legitimate_ordered_block();
    send_consensus_observer_message(&legitimate_peer, legitimate_message.clone());
    
    tokio::time::sleep(Duration::from_secs(1)).await;
    
    // Assert: Legitimate message was not processed (channel was full)
    assert!(!was_message_processed(&legitimate_message));
    
    // Wait for fallback trigger (10 seconds without progress)
    tokio::time::sleep(Duration::from_secs(11)).await;
    
    // Assert: Node entered fallback mode
    assert!(is_in_fallback_mode());
}
```

**Notes**

- The vulnerability stems from a **time-of-check-to-time-of-use (TOCTOU)** issue where resource allocation (channel slots) occurs before authorization check (subscription validation)
- The two-layer channel architecture (network + routing) doubles the attack surface to 2000 message slots
- FIFO queue policy ensures newest (likely legitimate) messages are dropped first
- Byte-based rate limiting at infrastructure layers cannot prevent message-count-based channel saturation
- Attack affects all nodes with consensus observer enabled (VFNs, configured fullnodes)
- The fallback mechanism itself is working as designed, but should not be triggerable by external attackers through resource exhaustion

### Citations

**File:** config/src/config/consensus_observer_config.rs (L68-68)
```rust
            max_network_channel_size: 1000,
```

**File:** config/src/config/consensus_observer_config.rs (L79-79)
```rust
            observer_fallback_duration_ms: 600_000, // 10 minutes
```

**File:** network/framework/src/peer/mod.rs (L459-491)
```rust
                match self.upstream_handlers.get(&direct.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(data_len as u64);
                    },
                    Some(handler) => {
                        let key = (self.connection_metadata.remote_peer_id, direct.protocol_id);
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        match handler.push(key, ReceivedMessage::new(message, sender)) {
                            Err(_err) => {
                                // NOTE: aptos_channel never returns other than Ok(()), but we might switch to tokio::sync::mpsc and then this would work
                                counters::direct_send_messages(
                                    &self.network_context,
                                    DECLINED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, DECLINED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                            Ok(_) => {
                                counters::direct_send_messages(
                                    &self.network_context,
                                    RECEIVED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, RECEIVED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                        }
                    },
```

**File:** consensus/src/consensus_observer/network/network_handler.rs (L183-190)
```rust
        if let Err(error) = self.observer_message_sender.push((), network_message) {
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to forward the observer message to the consensus observer! Error: {:?}",
                    error
                ))
            );
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L579-594)
```rust
        if let Err(error) = self
            .subscription_manager
            .verify_message_for_subscription(peer_network_id)
        {
            // Update the rejected message counter
            increment_rejected_message_counter(&peer_network_id, &message);

            // Log the error and return
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received message that was not from an active subscription! Error: {:?}",
                    error,
                ))
            );
            return;
        }
```

**File:** crates/channel/src/message_queues.rs (L138-147)
```rust
            match self.queue_style {
                // Drop the newest message for FIFO
                QueueStyle::FIFO => Some(message),
                // Drop the oldest message for LIFO
                QueueStyle::LIFO | QueueStyle::KLAST => {
                    let oldest = key_message_queue.pop_front();
                    key_message_queue.push_back(message);
                    oldest
                },
            }
```

**File:** consensus/src/consensus_observer/observer/fallback_manager.rs (L97-111)
```rust
        if latest_ledger_info_version <= highest_synced_version {
            // The synced version hasn't increased. Check if we should enter fallback mode.
            let duration_since_highest_seen = time_now.duration_since(highest_version_timestamp);
            let fallback_threshold = Duration::from_millis(
                self.consensus_observer_config
                    .observer_fallback_progress_threshold_ms,
            );
            if duration_since_highest_seen > fallback_threshold {
                Err(Error::ObserverProgressStopped(format!(
                    "Consensus observer is not making progress! Highest synced version: {}, elapsed: {:?}",
                    highest_synced_version, duration_since_highest_seen
                )))
            } else {
                Ok(()) // We haven't passed the fallback threshold yet
            }
```
