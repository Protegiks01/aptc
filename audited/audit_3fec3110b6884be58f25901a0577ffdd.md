# Audit Report

## Title
Fresh Account Priority Bypass via Missing Sender Spread Factor in Delayed Queue

## Summary
An attacker can gain unfair transaction priority by sending transactions from fresh accounts to use cases (contracts) that are already under delay. New accounts created in the `queue_txn` path receive `try_delay_till = output_idx + 1` without the `sender_spread_factor`, while existing accounts have `try_delay_till = output_idx + 1 + sender_spread_factor`. This allows fresh accounts to be processed up to `sender_spread_factor` output slots earlier than accounts that have been actively processing transactions, breaking the fairness guarantees of the transaction shuffler.

## Finding Description
The use-case-aware transaction shuffler implements a delay mechanism to spread transactions across time using `sender_spread_factor` and `use_case_spread_factor`. The `try_delay_till` field determines when an account's transactions become eligible for processing.

**The vulnerability exists in how new accounts are initialized:**

When a new account is created in the `queue_txn` function because its transaction must be queued (due to use case delay), the account receives: [1](#0-0) 

This creates the account with `try_delay_till = output_idx + 1` **without** applying the `sender_spread_factor`.

**In contrast, when accounts are created or updated through other paths:**

When a transaction is selected for output, the account is created with: [2](#0-1) [3](#0-2) 

When an account processes a transaction from the delayed queue: [4](#0-3) 

Both paths correctly apply `try_delay_till = output_idx + 1 + sender_spread_factor`.

**Priority Ordering:**

Accounts within a use case are ordered by their `DelayKey`, which uses `try_delay_till` as the primary sort key: [5](#0-4) 

Lower `try_delay_till` values receive higher priority.

**Attack Scenario:**

1. **Initial State**: `output_idx = 100`, `sender_spread_factor = 32` (typical production value)
2. Account Alice sends transaction to ContractA at `input_idx = 0`, gets processed immediately
3. Alice's account is created with `try_delay_till = 101 + 32 = 133`
4. Alice sends another transaction to ContractA at `input_idx = 1`
5. Since Alice has `try_delay_till = 133 > 100`, this transaction is queued
6. ContractA now has delay tracking
7. **Attacker (Bob, fresh account)** sends transaction to ContractA at `input_idx = 2`
8. Since ContractA is tracked with delay, Bob's transaction is queued via `queue_txn`
9. Bob's account is created with `try_delay_till = 100 + 1 = 101` (missing spread factor!)
10. When ContractA's delay expires and becomes ready, Bob's account (`try_delay_till = 101`) is processed **before** Alice's account (`try_delay_till = 133`)
11. Bob's transaction (input_idx=2) executes before Alice's transaction (input_idx=1), despite arriving later

The attacker can repeat this by creating multiple fresh accounts, each receiving a 32-slot priority advantage over legitimate users.

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violation**: Breaks the fairness guarantees of the transaction shuffler, which is designed to prevent transaction ordering manipulation

2. **Priority Manipulation**: Allows attackers to bypass the `sender_spread_factor` mechanism entirely by using fresh accounts, gaining up to `sender_spread_factor` slots of unfair advantage (32 slots in typical production configurations)

3. **Front-Running Enablement**: An attacker can observe pending transactions to popular contracts and submit transactions from fresh accounts to execute ahead of legitimate users, enabling:
   - MEV (Maximal Extractable Value) extraction
   - Front-running attacks on DeFi protocols
   - Unfair advantage in time-sensitive operations (auctions, NFT mints, etc.)

4. **Consensus Transaction Ordering Impact**: While this doesn't break consensus safety directly, it undermines the deterministic and fair transaction ordering that the shuffler is designed to provide, potentially affecting all validators' transaction selection

5. **Wide Exploitability**: Any transaction sender can exploit this without special permissions or validator access

## Likelihood Explanation
**Likelihood: High**

The vulnerability is highly likely to be exploited because:

1. **Easy to Execute**: Requires only the ability to create new accounts and send transactions - no special privileges needed

2. **Low Cost**: Creating fresh accounts on Aptos is inexpensive, making it economically viable for attackers

3. **High Reward**: Gaining 32 output slots of priority advantage (with default `sender_spread_factor = 32`) provides significant opportunities for front-running and MEV extraction

4. **Detectable Pattern**: Attackers can monitor popular contracts (DEX pools, NFT marketplaces) and exploit this whenever those contracts accumulate delay

5. **No Technical Barriers**: The attack requires only standard transaction submission capabilities available to any user

## Recommendation
Apply the `sender_spread_factor` when creating new accounts in the `queue_txn` function, consistent with other account creation paths.

**Fix for line 455 in `delayed_queue.rs`:**

Change:
```rust
let account = Account::new_with_txn(self.output_idx + 1, input_idx, txn);
```

To:
```rust
let account = Account::new_with_txn(
    self.output_idx + 1 + self.config.sender_spread_factor(), 
    input_idx, 
    txn
);
```

This ensures all new accounts, regardless of creation path, receive the same delay treatment and prevents fresh accounts from gaining unfair priority advantages.

## Proof of Concept

```rust
#[test]
fn test_fresh_account_priority_bypass() {
    use crate::transaction_shuffler::use_case_aware::{
        iterator::ShuffledTransactionIterator,
        tests::{Account, Contract, into_txns},
        Config,
    };
    
    // Production-like configuration with sender_spread_factor
    let config = Config {
        sender_spread_factor: 32,
        platform_use_case_spread_factor: 0,
        user_use_case_spread_factor: 0,
    };
    
    let txns = vec![
        // Alice (A1) sends first transaction to Contract C1 - gets processed immediately
        (Contract::User(0xC1), Account(1)),
        // Alice sends second transaction to C1 - gets delayed (try_delay_till = 1 + 32 = 33)
        (Contract::User(0xC1), Account(1)),
        // Attacker Bob (A2, fresh account) sends to C1 - should be delayed fairly
        // BUG: Bob's account created with try_delay_till = 1 (missing spread factor!)
        (Contract::User(0xC1), Account(2)),
        // Alice sends third transaction
        (Contract::User(0xC1), Account(1)),
    ];
    
    let actual_order: Vec<usize> = ShuffledTransactionIterator::new(config)
        .extended_with(into_txns(txns))
        .map(|txn| txn.original_idx)
        .collect();
    
    // Expected fair order: [0, 1, 3, 2] 
    // - txn 0: Alice's first (processed immediately)
    // - txn 1: Alice's second (delayed but queued first)
    // - txn 3: Alice's third (queued second from same account)
    // - txn 2: Bob's (arrived after Alice's, should go last)
    
    // ACTUAL BUGGY order: [0, 2, 1, 3]
    // - txn 0: Alice's first (processed immediately)  
    // - txn 2: Bob's (UNFAIR: jumps ahead due to missing spread factor!)
    // - txn 1: Alice's second (unfairly delayed)
    // - txn 3: Alice's third
    
    // This demonstrates Bob (fresh account) getting processed before Alice's 
    // earlier transactions, breaking fairness
    assert_eq!(actual_order, vec![0, 2, 1, 3], 
        "Fresh account bypasses sender_spread_factor and gains unfair priority");
}
```

**Notes**

This vulnerability affects the consensus layer's transaction ordering mechanism. While it doesn't break consensus safety (all validators will order transactions identically), it breaks the **fairness invariant** that the transaction shuffler is designed to enforce. The `sender_spread_factor` mechanism exists specifically to prevent any single sender from dominating transaction ordering, but this bug allows attackers to circumvent it entirely by using fresh accounts. This is particularly concerning for high-value DeFi operations where transaction ordering directly impacts economic outcomes.

### Citations

**File:** consensus/src/transaction_shuffler/use_case_aware/delayed_queue.rs (L20-24)
```rust
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
struct DelayKey {
    try_delay_till: OutputIdx,
    input_idx: InputIdx,
}
```

**File:** consensus/src/transaction_shuffler/use_case_aware/delayed_queue.rs (L336-336)
```rust
        account.update_try_delay_till(self.output_idx + 1 + self.config.sender_spread_factor());
```

**File:** consensus/src/transaction_shuffler/use_case_aware/delayed_queue.rs (L455-455)
```rust
                let account = Account::new_with_txn(self.output_idx + 1, input_idx, txn);
```

**File:** consensus/src/transaction_shuffler/use_case_aware/delayed_queue.rs (L482-482)
```rust
        let account_try_delay_till = self.output_idx + 1 + self.config.sender_spread_factor();
```

**File:** consensus/src/transaction_shuffler/use_case_aware/delayed_queue.rs (L509-509)
```rust
        let new_account = Account::new_empty(account_try_delay_till, input_idx);
```
