# Audit Report

## Title
JWKConsensusMsg Lacks Versioning Support Leading to Protocol Upgrade Incompatibility and Consensus Liveness Failure

## Summary
The `JWKConsensusMsg` enum uses BCS (Binary Canonical Serialization) without any version field or compatibility mechanism. Adding new message variants during protocol upgrades will cause deserialization failures on older nodes, preventing quorum formation and causing JWK consensus liveness failures during rolling upgrades.

## Finding Description

The `JWKConsensusMsg` enum is defined without version support: [1](#0-0) 

BCS serialization encodes enums as a variant index (u32) followed by variant data. When a new variant is added (e.g., variant index 3), older nodes that only know about variants 0-2 will fail to deserialize messages containing the new variant. [2](#0-1) 

The serialization occurs through the `ProtocolId::from_bytes` method, which performs BCS deserialization. When deserialization fails, the network layer logs the error and drops the message: [3](#0-2) 

During a rolling upgrade where new validators send messages with new variant types:
1. Old validators receive messages with unknown variant indices
2. BCS deserialization fails with "unknown variant" error
3. The RPC request fails and is retried with exponential backoff: [4](#0-3) 

4. The failed responses don't contribute to quorum certification: [5](#0-4) 

5. If â‰¥1/3 of validators are on different versions and cannot communicate, the 2f+1 quorum threshold cannot be reached
6. `QuorumCertifiedUpdate` production fails, blocking JWK updates
7. Keyless authentication feature becomes stale or broken

In contrast, the main `ConsensusMsg` enum handles upgrades properly by maintaining both old and new variants: [6](#0-5) 

Note the versioned variants like `BatchMsgV2`, `SignedBatchInfoMsgV2`, `ProofOfStoreMsgV2`, and deprecated variants like `DeprecatedBlockRetrievalRequest` that allow gradual migration.

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention"

This issue causes:
- **JWK consensus liveness failure** during rolling upgrades
- **Keyless authentication degradation** as JWK updates cannot be certified
- **Operational complexity** requiring coordinated flag-day upgrades instead of rolling upgrades
- **NOT a core consensus safety violation** - AptosBFT consensus remains unaffected
- **NO funds at risk** - only affects the JWK subsystem

The impact is limited to the JWK consensus subsystem and does not affect core blockchain safety or fund security, but does require operational intervention during upgrades.

## Likelihood Explanation

**High likelihood** during protocol evolution:
- Occurs automatically when developers add new `JWKConsensusMsg` variants
- Affects every rolling upgrade that introduces new message types
- No attacker involvement needed - it's a design flaw
- Already evidenced by the need for V2 variants in `ConsensusMsg`
- Will become more likely as JWK consensus protocol evolves

The issue is not about malicious exploitation but about inevitable protocol evolution breaking compatibility.

## Recommendation

Implement versioning similar to `ConsensusMsg`:

**Option 1: Explicit Versioning Wrapper**
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
pub enum JWKConsensusMsg {
    V1(JWKConsensusMsgV1),
    // Future versions can be added here without breaking compatibility
}

#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
pub enum JWKConsensusMsgV1 {
    ObservationRequest(ObservedUpdateRequest),
    ObservationResponse(ObservedUpdateResponse),
    KeyLevelObservationRequest(ObservedKeyLevelUpdateRequest),
}
```

**Option 2: Maintain Old and New Variants**
```rust
#[derive(Clone, Debug, EnumConversion, Deserialize, Serialize, PartialEq)]
pub enum JWKConsensusMsg {
    ObservationRequest(ObservedUpdateRequest),
    ObservationResponse(ObservedUpdateResponse),
    KeyLevelObservationRequest(ObservedKeyLevelUpdateRequest),
    // When adding new features, add V2 variants:
    ObservationRequestV2(ObservedUpdateRequestV2),
    ObservationResponseV2(ObservedUpdateResponseV2),
    // Keep old variants for backward compatibility during transition
}
```

**Option 3: Version Field in Messages**
Add version field to each message type's inner structure rather than the enum itself.

The recommended approach is Option 1 as it provides the clearest upgrade path and follows the pattern used elsewhere in Aptos consensus protocols.

## Proof of Concept

**Rust Test Demonstrating Deserialization Failure:**

```rust
#[test]
fn test_jwk_consensus_msg_version_incompatibility() {
    use serde::{Deserialize, Serialize};
    
    // Old version with 3 variants
    #[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
    enum JWKConsensusMsgOld {
        ObservationRequest(u64),
        ObservationResponse(u64),
        KeyLevelObservationRequest(u64),
    }
    
    // New version with 4 variants
    #[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
    enum JWKConsensusMsgNew {
        ObservationRequest(u64),
        ObservationResponse(u64),
        KeyLevelObservationRequest(u64),
        NewMessageType(u64),  // NEW variant
    }
    
    // Serialize new message type from upgraded node
    let new_msg = JWKConsensusMsgNew::NewMessageType(42);
    let serialized = bcs::to_bytes(&new_msg).unwrap();
    
    // Old node tries to deserialize - this WILL FAIL
    let result: Result<JWKConsensusMsgOld, _> = bcs::from_bytes(&serialized);
    
    // Assertion: deserialization fails on old node
    assert!(result.is_err());
    println!("Deserialization error: {:?}", result.unwrap_err());
    // Output: "unknown variant index: expected value in range [0, 2], found 3"
}
```

This demonstrates that BCS deserialization fails when encountering unknown enum variants, confirming the backward compatibility issue during rolling upgrades.

## Notes

This vulnerability is specific to the JWK consensus subsystem and does not affect core AptosBFT consensus safety. The issue manifests during protocol upgrades when new message types are introduced. While not exploitable by external attackers, it creates operational risk and could cause service degradation for keyless authentication features during rolling upgrades. The fix requires implementing proper versioning before adding new message variants to `JWKConsensusMsg`.

### Citations

**File:** crates/aptos-jwk-consensus/src/types.rs (L16-22)
```rust
#[derive(Clone, Debug, EnumConversion, Deserialize, Serialize, PartialEq)]
pub enum JWKConsensusMsg {
    ObservationRequest(ObservedUpdateRequest),
    ObservationResponse(ObservedUpdateResponse),
    KeyLevelObservationRequest(ObservedKeyLevelUpdateRequest),
    // In per-key mode we can reuse `ObservationResponse` and don't have a `KeyLevelObservationResponse`.
}
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L196-222)
```rust
    pub fn to_bytes<T: Serialize>(&self, value: &T) -> anyhow::Result<Vec<u8>> {
        // Start the serialization timer
        let serialization_timer = start_serialization_timer(*self, SERIALIZATION_LABEL);

        // Serialize the message
        let result = match self.encoding() {
            Encoding::Bcs(limit) => self.bcs_encode(value, limit),
            Encoding::CompressedBcs(limit) => {
                let compression_client = self.get_compression_client();
                let bcs_bytes = self.bcs_encode(value, limit)?;
                aptos_compression::compress(
                    bcs_bytes,
                    compression_client,
                    MAX_APPLICATION_MESSAGE_SIZE,
                )
                .map_err(|e| anyhow!("{:?}", e))
            },
            Encoding::Json => serde_json::to_vec(value).map_err(|e| anyhow!("{:?}", e)),
        };

        // Only record the duration if serialization was successful
        if result.is_ok() {
            serialization_timer.observe_duration();
        }

        result
    }
```

**File:** network/framework/src/protocols/network/mod.rs (L303-321)
```rust
fn request_to_network_event<TMessage: Message, Request: IncomingRequest>(
    peer_id: PeerId,
    request: &Request,
) -> Option<TMessage> {
    match request.to_message() {
        Ok(msg) => Some(msg),
        Err(err) => {
            let data = request.data();
            warn!(
                SecurityEvent::InvalidNetworkEvent,
                error = ?err,
                remote_peer_id = peer_id.short_str(),
                protocol_id = request.protocol_id(),
                data_prefix = hex::encode(&data[..min(16, data.len())]),
            );
            None
        },
    }
}
```

**File:** crates/reliable-broadcast/src/lib.rs (L184-201)
```rust
                        let (receiver, result) = result.expect("spawned task must succeed");
                        match result {
                            Ok(may_be_aggragated) => {
                                if let Some(aggregated) = may_be_aggragated {
                                    return Ok(aggregated);
                                }
                            },
                            Err(e) => {
                                log_rpc_failure(e, receiver);

                                let backoff_strategy = backoff_policies
                                    .get_mut(&receiver)
                                    .expect("should be present");
                                let duration = backoff_strategy.next().expect("should produce value");
                                rpc_futures
                                    .push(send_message(receiver, Some(duration)));
                            },
                        }
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L94-117)
```rust
        let power_check_result = self
            .epoch_state
            .verifier
            .check_voting_power(voters.iter(), true);
        let new_total_power = match &power_check_result {
            Ok(x) => Some(*x),
            Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => Some(*voting_power),
            _ => None,
        };

        info!(
            epoch = self.epoch_state.epoch,
            peer = sender,
            issuer = String::from_utf8(self.local_view.issuer.clone()).ok(),
            peer_power = peer_power,
            new_total_power = new_total_power,
            threshold = self.epoch_state.verifier.quorum_voting_power(),
            threshold_exceeded = power_check_result.is_ok(),
            "Peer vote aggregated."
        );

        if power_check_result.is_err() {
            return Ok(None);
        }
```

**File:** consensus/src/network_interface.rs (L39-105)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum ConsensusMsg {
    /// DEPRECATED: Once this is introduced in the next release, please use
    /// [`ConsensusMsg::BlockRetrievalRequest`](ConsensusMsg::BlockRetrievalRequest) going forward
    /// This variant was renamed from `BlockRetrievalRequest` to `DeprecatedBlockRetrievalRequest`
    /// RPC to get a chain of block of the given length starting from the given block id.
    DeprecatedBlockRetrievalRequest(Box<BlockRetrievalRequestV1>),
    /// Carries the returned blocks and the retrieval status.
    BlockRetrievalResponse(Box<BlockRetrievalResponse>),
    /// Request to get a EpochChangeProof from current_epoch to target_epoch
    EpochRetrievalRequest(Box<EpochRetrievalRequest>),
    /// ProposalMsg contains the required information for the proposer election protocol to make
    /// its choice (typically depends on round and proposer info).
    ProposalMsg(Box<ProposalMsg>),
    /// This struct describes basic synchronization metadata.
    SyncInfo(Box<SyncInfo>),
    /// A vector of LedgerInfo with contiguous increasing epoch numbers to prove a sequence of
    /// epoch changes from the first LedgerInfo's epoch.
    EpochChangeProof(Box<EpochChangeProof>),
    /// VoteMsg is the struct that is ultimately sent by the voter in response for receiving a
    /// proposal.
    VoteMsg(Box<VoteMsg>),
    /// CommitProposal is the struct that is sent by the validator after execution to propose
    /// on the committed state hash root.
    CommitVoteMsg(Box<CommitVote>),
    /// CommitDecision is the struct that is sent by the validator after collecting no fewer
    /// than 2f + 1 signatures on the commit proposal. This part is not on the critical path, but
    /// it can save slow machines to quickly confirm the execution result.
    CommitDecisionMsg(Box<CommitDecision>),
    /// Quorum Store: Send a Batch of transactions.
    BatchMsg(Box<BatchMsg<BatchInfo>>),
    /// Quorum Store: Request the payloads of a completed batch.
    BatchRequestMsg(Box<BatchRequest>),
    /// Quorum Store: Response to the batch request.
    BatchResponse(Box<Batch<BatchInfo>>),
    /// Quorum Store: Send a signed batch digest. This is a vote for the batch and a promise that
    /// the batch of transactions was received and will be persisted until batch expiration.
    SignedBatchInfo(Box<SignedBatchInfoMsg<BatchInfo>>),
    /// Quorum Store: Broadcast a certified proof of store (a digest that received 2f+1 votes).
    ProofOfStoreMsg(Box<ProofOfStoreMsg<BatchInfo>>),
    /// DAG protocol message
    DAGMessage(DAGNetworkMessage),
    /// Commit message
    CommitMessage(Box<CommitMessage>),
    /// Randomness generation message
    RandGenMessage(RandGenMessage),
    /// Quorum Store: Response to the batch request.
    BatchResponseV2(Box<BatchResponse>),
    /// OrderVoteMsg is the struct that is broadcasted by a validator on receiving quorum certificate
    /// on a block.
    OrderVoteMsg(Box<OrderVoteMsg>),
    /// RoundTimeoutMsg is broadcasted by a validator once it decides to timeout the current round.
    RoundTimeoutMsg(Box<RoundTimeoutMsg>),
    /// RPC to get a chain of block of the given length starting from the given block id, using epoch and round.
    BlockRetrievalRequest(Box<BlockRetrievalRequest>),
    /// OptProposalMsg contains the optimistic proposal and sync info.
    OptProposalMsg(Box<OptProposalMsg>),
    /// Quorum Store: Send a Batch of transactions.
    BatchMsgV2(Box<BatchMsg<BatchInfoExt>>),
    /// Quorum Store: Send a signed batch digest with BatchInfoExt. This is a vote for the batch and a promise that
    /// the batch of transactions was received and will be persisted until batch expiration.
    SignedBatchInfoMsgV2(Box<SignedBatchInfoMsg<BatchInfoExt>>),
    /// Quorum Store: Broadcast a certified proof of store (a digest that received 2f+1 votes) with BatchInfoExt.
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
    /// Secret share message: Used to share secrets per consensus round
    SecretShareMsg(SecretShareNetworkMessage),
}
```
