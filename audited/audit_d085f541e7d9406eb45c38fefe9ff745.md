# Audit Report

## Title
JWK Consensus State Discarded on Concurrent Key Updates Leading to Loss of Quorum Progress

## Summary
The `reset_with_on_chain_state()` function in the per-key JWK consensus manager uses issuer-level version comparison to determine which consensus states to retain, but operates on per-key consensus processes. This causes valid InProgress consensus states for unrelated keys to be incorrectly discarded when any key from the same issuer commits on-chain, resulting in loss of quorum progress and repeated consensus restarts.

## Finding Description
The JWK consensus system operates in per-key mode where each key (identified by `(Issuer, KID)`) has its own independent consensus process. However, the version tracking is per-issuer, not per-key. When multiple keys from the same issuer are updated concurrently, a fundamental race condition occurs: [1](#0-0) 

This retention logic discards all consensus states for an issuer when the issuer's version changes, regardless of which specific key caused the version change. 

**Attack Scenario:**

1. Issuer X has on-chain version 5 with keys {K1, K2, K3}
2. OIDC provider updates all three keys simultaneously
3. All validators observe the changes and start three concurrent consensus processes:
   - Consensus A for K1: base_version=5, proposing version=6
   - Consensus B for K2: base_version=5, proposing version=6  
   - Consensus C for K3: base_version=5, proposing version=6 [2](#0-1) 

4. Consensus A completes first and commits K1's update to the chain
5. The on-chain version increments from 5 to 6: [3](#0-2) 

6. An `ObservedJWKsUpdated` event is emitted, triggering all validators to call `reset_with_on_chain_state()`
7. The retention logic sees `new_version(6) != old_version(5)` and discards the InProgress states for K2 and K3
8. Even if these consensuses had already reached quorum, their progress is lost
9. When K2's validator transaction attempts to commit with version=6, it fails: [4](#0-3) 

10. Validators must restart consensus for K2 and K3 with base_version=6
11. If another key commits before they finish, the cycle repeats

This breaks the consensus liveness invariant by causing unnecessary restarts and wasting validator resources. With many concurrent key updates, this can lead to consensus starvation where keys repeatedly fail to commit.

## Impact Explanation
**High Severity** - This qualifies as a "significant protocol violation" under the Aptos bug bounty program:

- **Consensus Inefficiency**: Valid quorum progress is discarded, forcing unnecessary restarts
- **Validator Resource Waste**: Validators perform redundant work gathering signatures for consensus that gets discarded
- **Potential Liveness Issues**: In scenarios with frequent multi-key updates, consensus may repeatedly restart, delaying JWK updates significantly
- **Service Degradation**: Affects keyless account availability if JWK updates are delayed

The vulnerability affects all validators in the network whenever concurrent per-key updates occur for the same issuer.

## Likelihood Explanation
**High Likelihood** - This occurs naturally without requiring an attacker:

- OIDC providers commonly rotate multiple keys simultaneously for security (e.g., when upgrading cryptographic algorithms)
- Large providers like Google, Microsoft, Apple may have 5-10+ keys
- Bulk key rotations are standard practice during security incidents
- The per-key consensus mode is specifically designed to handle such scenarios but fails due to this bug

The issue is deterministic and will occur whenever multiple keys from the same issuer undergo concurrent consensus.

## Recommendation
The retention logic should be modified to check whether the specific key was affected by the on-chain update, not just whether the issuer's version changed. The corrected logic should:

1. For each `(issuer, kid)` entry in `states_by_key`, check if that specific key changed on-chain
2. If the key's JWK matches between old and new on-chain state, retain the consensus state but update its `base_version`
3. Only discard the state if the specific key was modified on-chain (making the in-progress consensus obsolete)

**Corrected Code:**

```rust
pub fn reset_with_on_chain_state(&mut self, on_chain_state: AllProvidersJWKs) -> Result<()> {
    info!(
        epoch = self.epoch_state.epoch,
        "reset_with_on_chain_state starting."
    );

    let new_onchain_jwks = on_chain_state.indexed().context(
        "KeyLevelJWKManager::reset_with_on_chain_state failed at onchain state indexing",
    )?;
    
    // Retain consensus states for keys that haven't changed on-chain
    self.states_by_key.retain(|(issuer, kid), state| {
        let old_jwk = self.onchain_jwks
            .get(issuer)
            .and_then(|provider| provider.jwks.get(kid));
        let new_jwk = new_onchain_jwks
            .get(issuer)
            .and_then(|provider| provider.jwks.get(kid));
        
        // If the specific key hasn't changed, retain the consensus
        old_jwk == new_jwk
    });

    self.onchain_jwks = new_onchain_jwks;

    info!(
        epoch = self.epoch_state.epoch,
        "reset_with_on_chain_state finished."
    );
    Ok(())
}
```

Alternatively, update the `base_version` for retained states to allow them to continue with the new version.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::jwks::{AllProvidersJWKs, ProviderJWKs, JWK, RSA_JWK};
    
    #[test]
    fn test_concurrent_key_updates_discard_progress() {
        // Setup: Issuer with version 5 and two keys
        let issuer = b"https://example.com".to_vec();
        let k1 = b"key1".to_vec();
        let k2 = b"key2".to_vec();
        
        let mut manager = /* initialize KeyLevelConsensusManager */;
        
        // Initial on-chain state: version 5, keys k1 and k2
        let initial_state = AllProvidersJWKs {
            entries: vec![ProviderJWKs {
                issuer: issuer.clone(),
                version: 5,
                jwks: vec![
                    JWK::RSA(RSA_JWK::new_256_aqab("key1", "n1")).into(),
                    JWK::RSA(RSA_JWK::new_256_aqab("key2", "n2")).into(),
                ],
            }],
        };
        manager.reset_with_on_chain_state(initial_state).unwrap();
        
        // Validators observe both keys changed
        manager.process_new_observation(issuer.clone(), vec![
            JWK::RSA(RSA_JWK::new_256_aqab("key1", "n1_new")),
            JWK::RSA(RSA_JWK::new_256_aqab("key2", "n2_new")),
        ]).unwrap();
        
        // Both consensuses should be InProgress
        assert!(matches!(
            manager.states_by_key.get(&(issuer.clone(), k1.clone())),
            Some(ConsensusState::InProgress { .. })
        ));
        assert!(matches!(
            manager.states_by_key.get(&(issuer.clone(), k2.clone())),
            Some(ConsensusState::InProgress { .. })
        ));
        
        // Simulate k1 committing on-chain first (version 5 -> 6)
        let updated_state = AllProvidersJWKs {
            entries: vec![ProviderJWKs {
                issuer: issuer.clone(),
                version: 6,
                jwks: vec![
                    JWK::RSA(RSA_JWK::new_256_aqab("key1", "n1_new")).into(),
                    JWK::RSA(RSA_JWK::new_256_aqab("key2", "n2")).into(), // k2 not yet updated
                ],
            }],
        };
        manager.reset_with_on_chain_state(updated_state).unwrap();
        
        // BUG: k2's InProgress consensus is incorrectly discarded
        // even though k2 itself hasn't changed on-chain
        assert!(manager.states_by_key.get(&(issuer.clone(), k2.clone())).is_none());
        
        // This causes loss of quorum progress and forces restart
    }
}
```

## Notes

The vulnerability is rooted in a design mismatch: the consensus system operates per-key but version tracking is per-issuer. The test at line 195 of the smoke test confirms that three key changes increment the version from 2 to 5, showing that each key update increments the shared issuer version. [5](#0-4) 

This is not a theoretical issueâ€”it will manifest in production whenever OIDC providers perform bulk key rotations, which is standard security practice.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L138-145)
```rust
                        let update = KeyLevelUpdate {
                            issuer: issuer.clone(),
                            base_version: effectively_onchain.version,
                            kid: kid.clone(),
                            to_upsert: Some(y.clone()),
                        };
                        self.maybe_start_consensus(update)
                            .context("process_new_observation failed at upsert consensus init")?;
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L244-254)
```rust
        self.states_by_key.retain(|(issuer, _), _| {
            new_onchain_jwks
                .get(issuer)
                .map(|jwks| jwks.version)
                .unwrap_or_default()
                == self
                    .onchain_jwks
                    .get(issuer)
                    .map(|jwks| jwks.version)
                    .unwrap_or_default()
        });
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L478-493)
```text
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
                    }
                });
                cur_issuer_jwks.version = cur_issuer_jwks.version + 1;
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L127-130)
```rust
        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```

**File:** testsuite/smoke-test/src/jwks/jwk_consensus_per_key.rs (L193-200)
```rust
                ProviderJWKs {
                    issuer: bob_issuer_id.as_bytes().to_vec(),
                    version: 5, // 3 changes since version 2: 1 delete and 2 upserts.
                    jwks: vec![
                        JWK::RSA(RSA_JWK::new_256_aqab("b1", "991ex")).into(),
                        JWK::RSA(RSA_JWK::new_256_aqab("b2", "992")).into(),
                    ],
                },
```
