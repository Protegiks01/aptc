# Audit Report

## Title
Unstable Bytecode Bypass via Malformed Compilation Metadata in Script Execution

## Summary
The `reject_unstable_bytecode_for_script()` function implements a fail-open security check that allows scripts with malformed or missing compilation metadata to execute on mainnet, enabling attackers to bypass unstable bytecode restrictions by corrupting metadata values.

## Finding Description

The Aptos VM enforces that scripts compiled with unstable compiler or language versions cannot execute on mainnet to prevent experimental, unvetted features from affecting production. This protection is implemented via compilation metadata that tags bytecode with an `unstable` flag. [1](#0-0) 

The vulnerability exists in the metadata retrieval logic: [2](#0-1) 

**Attack Path:**

1. Attacker compiles a script using an unstable compiler version (e.g., `CompilerVersion::V2_1`) or unstable language version (e.g., `LanguageVersion::V2_4` or `V2_5`) [3](#0-2) 

2. The compiler embeds `CompilationMetadata` with `unstable: true` into the script's metadata section [4](#0-3) 

3. Attacker modifies the script bytecode to corrupt the `compilation_metadata` value (e.g., changing bytes in the BCS-encoded metadata to create invalid data)

4. On mainnet execution:
   - Script deserialization succeeds (only validates bytecode version, not metadata validity)
   - `get_compilation_metadata()` attempts BCS deserialization, fails, and returns `None` (via `.ok()`)
   - Since `if let Some(metadata)` doesn't match, the rejection logic is skipped
   - Function returns `Ok(())`, allowing unstable bytecode to execute

**Invariant Violation:**

This breaks the **Deterministic Execution** invariant: unstable language versions may include experimental opcodes or features that could behave differently across validator nodes or consensus rounds, potentially causing state root mismatches. [5](#0-4) 

## Impact Explanation

**Severity: HIGH**

This qualifies as a **significant protocol violation** under the Aptos Bug Bounty High severity category because:

1. **Bypasses Critical Security Control**: The unstable bytecode check exists specifically to protect mainnet from experimental features that haven't undergone full security review and testing

2. **Consensus Risk**: Unstable language versions (V2_4, V2_5) use VERSION_10 bytecode which may include new opcodes or semantics. If different validator nodes interpret these features differently, it could lead to state divergence [6](#0-5) 

3. **Production Impact**: Allows untested, experimental code to run on mainnet where only stable, production-ready code should execute

4. **No Additional Safeguards**: The test suite shows no validation for missing or malformed compilation metadata in scripts [7](#0-6) 

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack is straightforward to execute:
- **Attacker Requirements**: Any user who can submit script transactions to mainnet
- **Technical Complexity**: Low - requires only basic bytecode manipulation (changing a few bytes in metadata)
- **Detection Difficulty**: Hard to detect - malformed metadata appears as legitimate absence of metadata
- **Execution Barrier**: None - the fail-open logic automatically allows execution when metadata is invalid

The likelihood is not CRITICAL only because:
- Requires knowledge of the internal validation logic
- Actual exploitation depends on whether unstable features provide meaningful attack capabilities

## Recommendation

Implement fail-safe behavior: reject scripts with missing or malformed compilation metadata on mainnet.

**Fixed Implementation:**

```rust
pub fn reject_unstable_bytecode_for_script(&self, script: &CompiledScript) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        match get_compilation_metadata(script) {
            Some(metadata) => {
                if metadata.unstable {
                    return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                        .with_message("script marked unstable cannot be run on mainnet".to_string())
                        .finish(Location::Script));
                }
            },
            None => {
                // Fail-safe: Require metadata on mainnet
                return Err(PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                    .with_message("compilation metadata is required for scripts on mainnet".to_string())
                    .finish(Location::Script));
            }
        }
    }
    Ok(())
}
```

Additionally, enhance metadata validation to catch malformed BCS data earlier: [8](#0-7) 

Add similar validation for compilation metadata in the `check_metadata_format()` function.

## Proof of Concept

```rust
#[test]
fn test_unstable_script_with_corrupted_metadata() {
    use aptos_types::chain_id::ChainId;
    use move_model::metadata::{CompilationMetadata, CompilerVersion, LanguageVersion};
    
    let mut h = MoveHarness::new();
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());
    
    // Set mainnet chain ID
    h.set_resource(
        CORE_CODE_ADDRESS,
        ChainId::struct_tag(),
        &ChainId::mainnet().id(),
    );
    
    // Build script with unstable compiler
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("script.move", r#"
        script {
            fun main() { }
        }
    "#);
    let path = builder.write_to_temp().unwrap();
    
    let package = BuiltPackage::build(
        path.path().to_path_buf(),
        BuildOptions {
            compiler_version: Some(CompilerVersion::V2_1), // Unstable!
            ..BuildOptions::default()
        }
    ).expect("building package must succeed");
    
    let mut code = package.extract_script_code().into_iter().next().unwrap();
    
    // Deserialize, corrupt metadata, re-serialize
    let mut script = CompiledScript::deserialize(&code).unwrap();
    
    // Find and corrupt compilation metadata
    for metadata in &mut script.metadata {
        if metadata.key == *COMPILATION_METADATA_KEY {
            // Corrupt the BCS value to make deserialization fail
            metadata.value[0] ^= 0xFF; 
            break;
        }
    }
    
    let mut corrupted_code = vec![];
    script.serialize(&mut corrupted_code).unwrap();
    
    let script_txn = TransactionPayload::Script(Script::new(corrupted_code, vec![], vec![]));
    
    // This should FAIL with UNSTABLE_BYTECODE_REJECTED but will SUCCESS due to the bug
    let result = h.run_transaction_payload_mainnet(&account, script_txn);
    
    // Currently passes (BUG) - should fail with StatusCode::UNSTABLE_BYTECODE_REJECTED
    assert_success!(result); // This demonstrates the vulnerability
}
```

**Notes:**

The vulnerability allows unstable bytecode to execute on mainnet by exploiting the fail-open behavior when compilation metadata deserialization fails. The fix requires fail-safe validation: rejecting scripts without valid compilation metadata on mainnet.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1760-1771)
```rust
    pub fn reject_unstable_bytecode_for_script(&self, script: &CompiledScript) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            if let Some(metadata) = get_compilation_metadata(script) {
                if metadata.unstable {
                    return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                        .with_message("script marked unstable cannot be run on mainnet".to_string())
                        .finish(Location::Script));
                }
            }
        }
        Ok(())
    }
```

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** types/src/vm/module_metadata.rs (L310-317)
```rust
/// Extract compilation metadata from a compiled module or script.
pub fn get_compilation_metadata(code: &impl CompiledCodeMetadata) -> Option<CompilationMetadata> {
    if let Some(data) = find_metadata(code.metadata(), COMPILATION_METADATA_KEY) {
        bcs::from_bytes::<CompilationMetadata>(&data.value).ok()
    } else {
        None
    }
}
```

**File:** third_party/move/move-model/src/metadata.rs (L49-85)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CompilationMetadata {
    /// A flag indicating whether, at time of creation, the compilation
    /// result was considered as unstable. Unstable code may have restrictions
    /// for deployment on production networks. This flag is true if either the
    /// compiler or language versions are unstable.
    pub unstable: bool,
    /// The version of the compiler, as a string. See
    /// `CompilationVersion::from_str` for supported version strings.
    pub compiler_version: String,
    /// The version of the language, as a string. See
    /// `LanguageVersion::from_str` for supported version strings.
    pub language_version: String,
}

impl CompilationMetadata {
    pub fn new(compiler_version: CompilerVersion, language_version: LanguageVersion) -> Self {
        Self {
            compiler_version: compiler_version.to_string(),
            language_version: language_version.to_string(),
            unstable: compiler_version.unstable() || language_version.unstable(),
        }
    }

    pub fn compiler_version(&self) -> anyhow::Result<CompilerVersion> {
        CompilerVersion::from_str(&self.compiler_version)
    }

    pub fn language_version(&self) -> anyhow::Result<LanguageVersion> {
        LanguageVersion::from_str(&self.language_version)
    }

    /// Returns true of the compilation was created as unstable.
    pub fn created_as_unstable(&self) -> bool {
        self.unstable
    }
}
```

**File:** third_party/move/move-model/src/metadata.rs (L286-294)
```rust
    /// Whether the language version is unstable. An unstable version
    /// should not be allowed on production networks.
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L3378-3408)
```rust
pub struct CompiledScript {
    /// Version number found during deserialization
    pub version: u32,
    /// Handles to all modules referenced.
    pub module_handles: Vec<ModuleHandle>,
    /// Handles to external/imported types.
    pub struct_handles: Vec<StructHandle>,
    /// Handles to external/imported functions.
    pub function_handles: Vec<FunctionHandle>,

    /// Function instantiations.
    pub function_instantiations: Vec<FunctionInstantiation>,

    pub signatures: SignaturePool,

    /// All identifiers used in this transaction.
    pub identifiers: IdentifierPool,
    /// All address identifiers used in this transaction.
    pub address_identifiers: AddressIdentifierPool,
    /// Constant pool. The constant values used in the transaction.
    pub constant_pool: ConstantPool,

    pub metadata: Vec<Metadata>,

    pub code: CodeUnit,
    pub type_parameters: Vec<AbilitySet>,

    pub parameters: SignatureIndex,

    pub access_specifiers: Option<Vec<AccessSpecifier>>,
}
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L565-575)
```rust
pub const VERSION_MAX: u32 = VERSION_10;

/// Mark which version is the default version. This is the version used by default by tools like
/// the compiler. Notice that this version might be different from the one supported on nodes.
/// The node's max version is determined by the on-chain config for that node.
/// !!! For user experience, the default version needs to be already in production.
pub const VERSION_DEFAULT: u32 = VERSION_9;

/// Mark which bytecode version is the default if compiling with language version 2.4 -
/// In general, these are used to set up the default bytecode version for language versions higher than the default.
pub const VERSION_DEFAULT_LANG_V2_4: u32 = VERSION_10;
```

**File:** aptos-move/e2e-move-tests/src/tests/metadata.rs (L303-316)
```rust
#[test]
fn test_compilation_metadata_for_script() {
    // run unstable compiler code to mainnet
    assert_vm_status!(
        test_compilation_metadata_script_internal(true, true),
        StatusCode::UNSTABLE_BYTECODE_REJECTED
    );
    // run stable compiler code to mainnet
    assert_success!(test_compilation_metadata_script_internal(true, false,));
    // run unstable compiler code to test
    assert_success!(test_compilation_metadata_script_internal(false, true,));
    // run stable compiler code to test
    assert_success!(test_compilation_metadata_script_internal(false, false,));
}
```
