# Audit Report

## Title
Subscription Stream Initialization Accepts Mismatched Version/Epoch Pairs Leading to Epoch Boundary Skip Vulnerability

## Summary
The subscription stream initialization in the storage service accepts client-provided `known_version_at_stream_start` and `known_epoch_at_stream_start` without validating their consistency. A malicious client can provide a version that belongs to epoch N while claiming to be in epoch N+1, causing the server to skip sending critical epoch-ending ledger information. This breaks state consistency guarantees and can lead to consensus desynchronization. [1](#0-0) 

## Finding Description

When a subscription stream is created, the server directly extracts and stores the `known_version_at_stream_start` and `known_epoch_at_stream_start` from the client's subscription request without validation: [2](#0-1) 

The system assumes these values are consistent (i.e., the version belongs to the claimed epoch), but never validates this assumption. This enables two attack vectors:

**Attack Vector 1: Epoch Boundary Skip (Critical Path)**

A malicious client provides:
- `known_version_at_stream_start` = 500 (actually in epoch 4)
- `known_epoch_at_stream_start` = 5 (falsely claiming epoch 5)

When the server checks if the subscription is ready, it uses these values to determine whether to send epoch-ending ledger info: [3](#0-2) 

The validation logic at lines 951-954 checks if `epoch_ending_ledger_info.version() <= highest_known_version`. With version 500 but claimed epoch 5:
- Server fetches epoch 5 ending ledger info (say, ends at version 999)
- Check: `999 <= 500` = FALSE
- Server marks subscription as READY without sending epoch 4 ending info

**Result:** The client never receives the epoch 4 ending ledger information, which contains:
- New validator set for epoch 5
- Epoch transition proofs
- Critical consensus state changes

**Attack Vector 2: False Invalid Detection**

A client provides:
- `known_version_at_stream_start` = 999 (end of epoch 5)
- `known_epoch_at_stream_start` = 4 (falsely claiming epoch 4)

The same validation logic will:
- Fetch epoch 4 ending ledger info (ends at version 500)
- Check: `500 <= 999` = TRUE
- Incorrectly mark valid subscription as INVALID

The system has a database function available to validate version-epoch consistency but doesn't use it: [4](#0-3) 

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos Bug Bounty)

This vulnerability causes **state inconsistencies requiring intervention** (Medium severity category):

1. **Consensus Desynchronization**: Nodes missing epoch boundary information will have inconsistent views of validator sets, potentially validating blocks with wrong validator signatures.

2. **State Inconsistency**: Nodes that skip epoch boundaries cannot properly validate state transitions across epochs, violating the State Consistency invariant.

3. **Validator Set Mismatch**: Without epoch-ending ledger info, nodes won't update their validator set, causing them to reject valid blocks from new validators or accept invalid blocks from old validators.

4. **Widespread Impact**: If multiple nodes follow malicious subscription data, significant portions of the network could become desynchronized, requiring manual intervention to restore consistency.

The issue doesn't directly cause fund loss (not Critical), but the state inconsistencies can cascade into consensus failures that require coordinated recovery efforts.

## Likelihood Explanation

**Likelihood: High**

- **No Authentication Required**: Any client can send subscription requests with arbitrary version/epoch values
- **No Validation Barriers**: The code path has zero validation checks for version-epoch consistency
- **Silent Failure**: The attack succeeds without triggering obvious errors, making detection difficult
- **Easy to Execute**: Attacker only needs to craft a subscription request with mismatched values
- **Persistent Effect**: Once a node accepts incorrect subscription data, it continues operating with inconsistent state

The attack requires minimal sophistication - just understanding the subscription protocol structure. The lack of validation makes this trivially exploitable.

## Recommendation

Add validation in `SubscriptionStreamRequests::new()` to verify that the provided version actually belongs to the claimed epoch: [2](#0-1) 

**Recommended Fix:**

```rust
impl SubscriptionStreamRequests {
    pub fn new(subscription_request: SubscriptionRequest, 
               time_service: TimeService,
               storage: &dyn StorageReaderInterface) -> Result<Self, Error> {
        // Extract the relevant information from the request
        let highest_known_version = subscription_request.highest_known_version_at_stream_start();
        let highest_known_epoch = subscription_request.highest_known_epoch_at_stream_start();
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();

        // VALIDATION: Verify version-epoch consistency
        let actual_epoch = storage.get_epoch(highest_known_version)
            .map_err(|e| Error::InvalidRequest(
                format!("Failed to verify epoch for version {}: {}", highest_known_version, e)
            ))?;
        
        if actual_epoch != highest_known_epoch {
            return Err(Error::InvalidRequest(
                format!(
                    "Version {} belongs to epoch {} but client claimed epoch {}. \
                     Rejecting subscription with mismatched version/epoch.",
                    highest_known_version, actual_epoch, highest_known_epoch
                )
            ));
        }

        // Create a new set of pending subscription requests using the first request
        let mut pending_subscription_requests = BTreeMap::new();
        pending_subscription_requests.insert(
            subscription_request.subscription_stream_index(),
            subscription_request,
        );

        Ok(Self {
            highest_known_version,
            highest_known_epoch,
            next_index_to_serve: 0,
            pending_subscription_requests,
            subscription_stream_metadata,
            last_stream_update_time: time_service.now(),
            time_service,
        })
    }
}
```

This fix ensures that subscription streams are only initialized with consistent version/epoch pairs, preventing both the epoch boundary skip and false invalid detection attacks.

## Proof of Concept

```rust
#[cfg(test)]
mod test_subscription_epoch_mismatch {
    use super::*;
    use aptos_storage_service_types::requests::{
        DataRequest, StorageServiceRequest, SubscriptionStreamMetadata,
        SubscribeTransactionsWithProofRequest,
    };
    
    #[test]
    fn test_mismatched_version_epoch_accepted() {
        // Setup: Create a mock storage with epoch boundaries
        // Epoch 4 ends at version 500
        // Epoch 5 ends at version 999
        let mock_storage = MockStorage::new_with_epochs(vec![
            (500, 4),  // Version 500 is epoch ending for epoch 4
            (999, 5),  // Version 999 is epoch ending for epoch 5
        ]);
        
        // Attack: Client claims to be at version 500 (end of epoch 4)
        // but falsely claims to be in epoch 5
        let subscription_metadata = SubscriptionStreamMetadata {
            known_version_at_stream_start: 500,  // Actually in epoch 4
            known_epoch_at_stream_start: 5,      // FALSE: claiming epoch 5
            subscription_stream_id: 1,
        };
        
        let request = StorageServiceRequest::new(
            DataRequest::SubscribeTransactionsWithProof(
                SubscribeTransactionsWithProofRequest {
                    subscription_stream_metadata: subscription_metadata,
                    subscription_stream_index: 0,
                    include_events: false,
                }
            ),
            false,
        );
        
        let subscription_request = SubscriptionRequest::new(
            request,
            ResponseSender::new(), // Mock response sender
            TimeService::mock(),
        );
        
        // BUG: This succeeds without validation!
        let subscription_stream = SubscriptionStreamRequests::new(
            subscription_request,
            TimeService::mock(),
        );
        
        assert!(subscription_stream.is_ok());
        
        // Verify the bug: server accepted mismatched version/epoch
        let stream = subscription_stream.unwrap();
        assert_eq!(stream.highest_known_version, 500);
        assert_eq!(stream.highest_known_epoch, 5);  // WRONG! Should be 4
        
        // When server checks for ready subscriptions with synced epoch 6:
        // - It will fetch epoch 5 ending ledger info (version 999)
        // - Check: 999 <= 500 = FALSE
        // - Server will skip epoch 4 ending info and send from version 501
        // - Client NEVER receives epoch 4 ending ledger info!
    }
}
```

**Reproduction Steps:**
1. Deploy a fullnode running the storage service
2. Create a subscription request with `known_version_at_stream_start` from epoch N but `known_epoch_at_stream_start` = N+1
3. Send the subscription request to the storage service
4. Observe that the subscription is accepted without validation
5. Monitor the data stream - epoch N's ending ledger info is never sent
6. Client's epoch state becomes desynchronized from the blockchain

### Citations

**File:** state-sync/storage-service/types/src/requests.rs (L417-422)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct SubscriptionStreamMetadata {
    pub known_version_at_stream_start: u64, // The highest known transaction version at stream start
    pub known_epoch_at_stream_start: u64,   // The highest known epoch at stream start
    pub subscription_stream_id: u64,        // The unique id of the subscription stream
}
```

**File:** state-sync/storage-service/server/src/subscription.rs (L314-336)
```rust
    pub fn new(subscription_request: SubscriptionRequest, time_service: TimeService) -> Self {
        // Extract the relevant information from the request
        let highest_known_version = subscription_request.highest_known_version_at_stream_start();
        let highest_known_epoch = subscription_request.highest_known_epoch_at_stream_start();
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();

        // Create a new set of pending subscription requests using the first request
        let mut pending_subscription_requests = BTreeMap::new();
        pending_subscription_requests.insert(
            subscription_request.subscription_stream_index(),
            subscription_request,
        );

        Self {
            highest_known_version,
            highest_known_epoch,
            next_index_to_serve: 0,
            pending_subscription_requests,
            subscription_stream_metadata,
            last_stream_update_time: time_service.now(),
            time_service,
        }
    }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L918-965)
```rust
        let active_task = runtime.spawn_blocking(move || {
            // Check if we have synced beyond the highest known version
            if highest_known_version < highest_synced_version {
                if highest_known_epoch < highest_synced_epoch {
                    // Fetch the epoch ending ledger info from storage (the
                    // peer needs to sync to their epoch ending ledger info).
                    let epoch_ending_ledger_info = match utils::get_epoch_ending_ledger_info(
                        cached_storage_server_summary.clone(),
                        optimistic_fetches.clone(),
                        subscriptions.clone(),
                        highest_known_epoch,
                        lru_response_cache.clone(),
                        request_moderator.clone(),
                        &peer_network_id,
                        storage.clone(),
                        time_service.clone(),
                    ) {
                        Ok(epoch_ending_ledger_info) => epoch_ending_ledger_info,
                        Err(error) => {
                            // Log the failure to fetch the epoch ending ledger info
                            error!(LogSchema::new(LogEntry::SubscriptionRefresh)
                                .error(&error)
                                .message(&format!(
                                    "Failed to get the epoch ending ledger info for epoch: {:?} !",
                                    highest_known_epoch
                                )));

                            return;
                        },
                    };

                    // Check that we haven't been sent an invalid subscription request
                    // (i.e., a request that does not respect an epoch boundary).
                    if epoch_ending_ledger_info.ledger_info().version() <= highest_known_version {
                        peers_with_invalid_subscriptions
                            .lock()
                            .push(peer_network_id);
                    } else {
                        peers_with_ready_subscriptions
                            .lock()
                            .push((peer_network_id, epoch_ending_ledger_info));
                    }
                } else {
                    peers_with_ready_subscriptions
                        .lock()
                        .push((peer_network_id, highest_synced_ledger_info.clone()));
                };
            }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L204-231)
```rust
    pub(crate) fn get_epoch(&self, version: Version) -> Result<u64> {
        let mut iter = self.db.iter::<EpochByVersionSchema>()?;
        // Search for the end of the previous epoch.
        iter.seek_for_prev(&version)?;
        let (epoch_end_version, epoch) = match iter.next().transpose()? {
            Some(x) => x,
            None => {
                // There should be a genesis LedgerInfo at version 0 (genesis only consists of one
                // transaction), so this normally doesn't happen. However this part of
                // implementation doesn't need to rely on this assumption.
                return Ok(0);
            },
        };
        ensure!(
            epoch_end_version <= version,
            "DB corruption: looking for epoch for version {}, got epoch {} ends at version {}",
            version,
            epoch,
            epoch_end_version
        );
        // If the obtained epoch ended before the given version, return epoch+1, otherwise
        // the given version is exactly the last version of the found epoch.
        Ok(if epoch_end_version < version {
            epoch + 1
        } else {
            epoch
        })
    }
```
