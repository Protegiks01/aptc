# Audit Report

## Title
Client-Side Sequence Number Desynchronization via Malicious API Server in SDK Transaction Submission

## Summary
The SDK's `CoinClient::transfer()` function increments the `LocalAccount` sequence number before receiving confirmation that the transaction was successfully submitted to mempool, allowing a malicious API server to cause permanent client-side denial of service by accepting transactions without broadcasting them.

## Finding Description

The vulnerability exists in the transaction signing and submission flow within the Aptos SDK. When a user calls `CoinClient::transfer()`, the sequence number is incremented in the client's `LocalAccount` object **before** the transaction is submitted to the API server. [1](#0-0) 

The critical flaw occurs in the transaction building process. The `get_signed_transfer_txn()` function reads the current sequence number and then calls `sign_with_transaction_builder()`: [2](#0-1) 

Inside `LocalAccount::sign_with_transaction_builder()`, the sequence number is incremented atomically **during the signing process**, not after successful submission: [3](#0-2) 

The `increment_sequence_number()` method uses an atomic fetch-add operation that permanently increments the local state: [4](#0-3) 

**Attack Scenario:**
1. User calls `transfer()` with sequence number N (matching on-chain state)
2. SDK increments `LocalAccount.sequence_number` from N to N+1 during signing
3. Signed transaction (containing sequence number N) is sent to API via `submit()`
4. Malicious API accepts the HTTP POST request but never forwards to mempool
5. On-chain sequence number remains N, but client's local sequence number is N+1
6. Next transaction from client uses sequence number N+1, which is rejected by mempool
7. User cannot submit any transactions until manually resynchronizing [5](#0-4) 

The API submission returns a `PendingTransaction`, but this is returned **before** mempool validation occurs. A malicious API can fabricate this response without actually submitting to mempool. [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Specific Impact:**
- **Client-Side Denial of Service**: Victims cannot submit transactions until manually fixing their sequence number via `set_sequence_number()` or `decrement_sequence_number()`
- **State Desynchronization**: The client's internal state becomes permanently inconsistent with on-chain state
- **User Confusion**: Transaction failures appear as cryptic "Invalid sequence number" errors without clear indication of the root cause
- **Operational Impact**: Users must query the blockchain, identify the correct sequence number, and manually resynchronize their `LocalAccount` state

While no funds are directly lost, this breaks the critical invariant that **SDK client state should remain synchronized with on-chain state** during normal operation. The SDK should be resilient against faulty or malicious APIs rather than assuming unconditional trust.

## Likelihood Explanation

**Likelihood: High**

The attack requires:
1. User connects to a malicious or compromised API server
2. Attacker accepts transactions but silently drops them

This is realistic because:
- Many users rely on public API endpoints (not self-hosted nodes)
- API endpoints can be compromised through various attack vectors
- The attacker needs no special privileges or validator access
- The attack is completely silent and difficult to detect
- The attack affects all SDK users connecting to the compromised API

**Complexity: Low** - The attacker simply needs to run a modified API server that accepts but doesn't forward transactions. No cryptographic knowledge or blockchain expertise required.

## Recommendation

The sequence number should only be incremented **after** receiving confirmation from mempool that the transaction was accepted, not during the signing phase.

**Recommended Fix:**

Modify `LocalAccount::sign_with_transaction_builder()` to NOT increment the sequence number automatically. Instead, create a new method `sign_without_increment()` and make the caller responsible for incrementing only after successful submission:

```rust
// In LocalAccount
pub fn sign_without_increment(&self, builder: TransactionBuilder) -> SignedTransaction {
    let raw_txn = if builder.has_nonce() {
        builder
            .sender(self.address())
            .sequence_number(u64::MAX)
            .build()
    } else {
        builder
            .sender(self.address())
            .sequence_number(self.sequence_number()) // Don't increment
            .build()
    };
    self.sign_transaction(raw_txn)
}
```

Then modify `CoinClient::transfer()` to increment only after successful API submission:

```rust
pub async fn transfer(
    &self,
    from_account: &mut LocalAccount,
    to_account: AccountAddress,
    amount: u64,
    options: Option<TransferOptions<'_>>,
) -> Result<PendingTransaction> {
    let signed_txn = self
        .get_signed_transfer_txn_without_increment(from_account, to_account, amount, options)
        .await?;
    
    // Submit to API
    let result = self
        .api_client
        .submit(&signed_txn)
        .await
        .context("Failed to submit transfer transaction")?;
    
    // Only increment if submission succeeded
    from_account.increment_sequence_number();
    
    Ok(result.into_inner())
}
```

Alternatively, implement automatic recovery by querying the on-chain sequence number before each transaction submission.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_sdk::{
        types::LocalAccount,
        crypto::ed25519::Ed25519PrivateKey,
    };
    
    #[test]
    fn test_sequence_number_desync_on_failed_submission() {
        // Create a LocalAccount with sequence number 5
        let mut account = LocalAccount::generate(&mut rand::thread_rng());
        account.set_sequence_number(5);
        
        // Initial state
        assert_eq!(account.sequence_number(), 5);
        
        // Build and sign a transaction
        let builder = TransactionBuilder::new(/* ... transaction payload ... */);
        let _signed_txn = account.sign_with_transaction_builder(builder);
        
        // Sequence number has been incremented BEFORE submission
        assert_eq!(account.sequence_number(), 6);
        
        // If the API fails or is malicious and doesn't submit:
        // - On-chain sequence number: still 5
        // - Client sequence number: 6
        // - Next transaction will use sequence 6, get rejected by mempool
        
        // User must manually recover:
        account.set_sequence_number(5); // Manual intervention required
    }
}
```

**Notes:**

This vulnerability demonstrates a critical design flaw where the SDK optimistically updates state before confirming network acceptance. The fix requires inverting the control flow to increment sequence numbers only after confirmed successful submission to mempool, or implementing automatic recovery mechanisms that query on-chain state before each transaction.

### Citations

**File:** sdk/src/coin_client.rs (L36-53)
```rust
    pub async fn transfer(
        &self,
        from_account: &mut LocalAccount,
        to_account: AccountAddress,
        amount: u64,
        options: Option<TransferOptions<'_>>,
    ) -> Result<PendingTransaction> {
        let signed_txn = self
            .get_signed_transfer_txn(from_account, to_account, amount, options)
            .await?;
        Ok(self
            .api_client
            .submit(&signed_txn)
            .await
            .context("Failed to submit transfer transaction")?
            .into_inner())
        // <:!:section_1
    }
```

**File:** sdk/src/coin_client.rs (L92-97)
```rust
        .sender(from_account.address())
        .sequence_number(from_account.sequence_number())
        .max_gas_amount(options.max_gas_amount)
        .gas_unit_price(options.gas_unit_price);
        let signed_txn = from_account.sign_with_transaction_builder(transaction_builder);
        Ok(signed_txn)
```

**File:** sdk/src/types.rs (L354-368)
```rust
    pub fn sign_with_transaction_builder(&self, builder: TransactionBuilder) -> SignedTransaction {
        let raw_txn = if builder.has_nonce() {
            // Do not increment sequence number for orderless transactions.
            builder
                .sender(self.address())
                .sequence_number(u64::MAX)
                .build()
        } else {
            builder
                .sender(self.address())
                .sequence_number(self.increment_sequence_number())
                .build()
        };
        self.sign_transaction(raw_txn)
    }
```

**File:** sdk/src/types.rs (L546-548)
```rust
    pub fn increment_sequence_number(&self) -> u64 {
        self.sequence_number.fetch_add(1, Ordering::SeqCst)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L572-588)
```rust
    pub async fn submit(
        &self,
        txn: &SignedTransaction,
    ) -> AptosResult<Response<PendingTransaction>> {
        let txn_payload = bcs::to_bytes(txn)?;
        let url = self.build_path("transactions")?;

        let response = self
            .inner
            .post(url)
            .header(CONTENT_TYPE, BCS_SIGNED_TRANSACTION)
            .body(txn_payload)
            .send()
            .await?;

        self.json::<PendingTransaction>(response).await
    }
```

**File:** api/src/transactions.rs (L1438-1448)
```rust
    async fn create_internal(&self, txn: SignedTransaction) -> Result<(), AptosError> {
        let (mempool_status, vm_status_opt) = self
            .context
            .submit_transaction(txn)
            .await
            .context("Mempool failed to initially evaluate submitted transaction")
            .map_err(|err| {
                aptos_api_types::AptosError::new_with_error_code(err, AptosErrorCode::InternalError)
            })?;
        match mempool_status.code {
            MempoolStatusCode::Accepted => Ok(()),
```
