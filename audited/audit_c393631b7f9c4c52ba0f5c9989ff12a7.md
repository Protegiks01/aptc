# Audit Report

## Title
Indexer Supply Divergence Due to Unrecognized ConcurrentSupply Resource

## Summary
The Aptos indexer fails to recognize `ConcurrentSupply` resources for fungible assets, causing indexed supply data to diverge from on-chain state and display as zero regardless of actual supply values.

## Finding Description
The indexer's fungible asset parsing logic only recognizes the legacy `Supply` resource type but not the modern `ConcurrentSupply` resource. When the `concurrent_fungible_assets_enabled` feature flag is active on-chain, new fungible assets are created with `ConcurrentSupply` instead of `Supply`. [1](#0-0) 

This whitelist only includes `"0x1::fungible_asset::Supply"`, not `"0x1::fungible_asset::ConcurrentSupply"`.

On-chain, fungible assets can use either resource type based on feature flags: [2](#0-1) 

When the indexer processes transactions involving fungible assets with `ConcurrentSupply`: [3](#0-2) 

The `fungible_asset_metadata` field populates correctly, but `fungible_asset_supply` remains `None`.

In the token data construction logic: [4](#0-3) 

When `fungible_asset_supply` is `None`, the nested condition fails, causing:
- Supply indexed as `BigDecimal::zero()` despite actual on-chain supply
- Decimals indexed as `0` instead of actual value (e.g., 8, 18)  
- `is_fungible_v2` set to `false` instead of `true`

## Impact Explanation
This is a **data integrity issue in the indexer** (off-chain component), NOT a core blockchain security vulnerability. The indexer does not affect:
- On-chain state (remains correct)
- Consensus operations
- Transaction execution
- Validator operations

However, it causes incorrect data to be served via indexer APIs, affecting:
- DeFi applications calculating token supplies
- Wallets displaying token balances (wrong decimal places)
- Market data aggregators

Per Aptos bug bounty categories, this does NOT meet Critical, High, or Medium severity as it:
- Does not cause loss of funds
- Does not violate consensus/safety invariants
- Does not break any core protocol components
- Is limited to data display/indexing layer

## Likelihood Explanation  
This occurs automatically for all fungible assets using `ConcurrentSupply`:
- New assets created when concurrent features are enabled
- Assets upgraded via `upgrade_to_concurrent()` function [5](#0-4) 

## Recommendation
Add support for `ConcurrentSupply` in the indexer's resource parser:

In `v2_fungible_asset_utils.rs`, update the resource type matching to include:
```rust
"0x1::fungible_asset::Supply" 
    | "0x1::fungible_asset::ConcurrentSupply"
    | "0x1::fungible_asset::Metadata"
    | "0x1::fungible_asset::FungibleStore"
```

Implement a `ConcurrentFungibleAssetSupply` struct that reads from the `Aggregator<u128>` field and provides the same interface as `FungibleAssetSupply`.

## Proof of Concept
Create a fungible asset with concurrent features enabled, then query the indexer API for its supply. The indexed supply will show 0 while on-chain reads via Move view functions return the actual supply value.

---

**Notes**

This finding represents a data quality bug in the auxiliary indexer service, not a vulnerability in the core Aptos blockchain protocol (consensus, execution engine, state management, or on-chain governance). The on-chain state remains correct and secure. Applications should validate critical data on-chain rather than relying solely on indexed data.

### Citations

**File:** crates/indexer/src/models/coin_models/v2_fungible_asset_utils.rs (L200-207)
```rust
    pub fn is_resource_supported(data_type: &str) -> bool {
        matches!(
            data_type,
            "0x1::fungible_asset::Supply"
                | "0x1::fungible_asset::Metadata"
                | "0x1::fungible_asset::FungibleStore"
        )
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L328-347)
```text
        if (default_to_concurrent_fungible_supply()) {
            let unlimited = maximum_supply.is_none();
            move_to(
                metadata_object_signer,
                ConcurrentSupply {
                    current: if (unlimited) {
                        aggregator_v2::create_unbounded_aggregator()
                    } else {
                        aggregator_v2::create_aggregator(
                            maximum_supply.extract()
                        )
                    }
                }
            );
        } else {
            move_to(
                metadata_object_signer,
                Supply { current: 0, maximum: maximum_supply }
            );
        };
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L1401-1425)
```text
    public fun upgrade_to_concurrent(ref: &ExtendRef) acquires Supply {
        let metadata_object_address = ref.address_from_extend_ref();
        let metadata_object_signer = ref.generate_signer_for_extending();
        assert!(
            features::concurrent_fungible_assets_enabled(),
            error::invalid_argument(ECONCURRENT_SUPPLY_NOT_ENABLED)
        );
        assert!(
            exists<Supply>(metadata_object_address),
            error::not_found(ESUPPLY_NOT_FOUND)
        );
        let Supply { current, maximum } = move_from<Supply>(metadata_object_address);

        let unlimited = maximum.is_none();
        let supply = ConcurrentSupply {
            current: if (unlimited) {
                aggregator_v2::create_unbounded_aggregator_with_value(current)
            } else {
                aggregator_v2::create_aggregator_with_value(
                    current, maximum.extract()
                )
            }
        };
        move_to(&metadata_object_signer, supply);
    }
```

**File:** crates/indexer/src/processors/token_processor.rs (L1146-1154)
```rust
                        if let Some(fungible_asset_metadata) =
                            FungibleAssetMetadata::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.fungible_asset_metadata = Some(fungible_asset_metadata);
                        }
                        if let Some(fungible_asset_supply) =
                            FungibleAssetSupply::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.fungible_asset_supply = Some(fungible_asset_supply);
```

**File:** crates/indexer/src/models/token_models/v2_token_datas.rs (L86-99)
```rust
            let (mut maximum, mut supply, mut decimals, mut is_fungible_v2) =
                (None, BigDecimal::zero(), 0, Some(false));
            // Get token properties from 0x4::property_map::PropertyMap
            let mut token_properties = serde_json::Value::Null;
            if let Some(metadata) = token_v2_metadata.get(&token_data_id) {
                let fungible_asset_metadata = metadata.fungible_asset_metadata.as_ref();
                let fungible_asset_supply = metadata.fungible_asset_supply.as_ref();
                if let Some(metadata) = fungible_asset_metadata {
                    if let Some(fa_supply) = fungible_asset_supply {
                        maximum = fa_supply.get_maximum();
                        supply = fa_supply.current.clone();
                        decimals = metadata.decimals as i64;
                        is_fungible_v2 = Some(true);
                    }
```
