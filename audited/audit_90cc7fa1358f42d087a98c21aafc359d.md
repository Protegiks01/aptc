# Audit Report

## Title
V1/V2 Protocol Conversion Drops Auxiliary Info Causing Verification Failures in State Sync

## Summary
The storage service's V1/V2 conversion mechanism discards `PersistedAuxiliaryInfo` data while retaining references to it in `TransactionInfo` objects, creating an inconsistent state that causes verification to fail. This breaks state synchronization for nodes using the V1 protocol, preventing them from syncing transaction outputs and participating in consensus.

## Finding Description

The vulnerability occurs in the round-trip conversion between V1 and V2 transaction output formats in state sync:

**Step 1: Server-side V2 → V1 conversion** [1](#0-0) 

The handler receives V2 data from storage containing both `TransactionOutputListWithProof` and `persisted_auxiliary_infos`. It then calls `consume_output_list_with_proof()` which extracts only the V1 proof and **discards the auxiliary info**: [2](#0-1) 

**Step 2: Network transmission**
The V1 data sent over the network contains `TransactionInfo` objects with `auxiliary_info_hash = Some(hash)` from the original committed data, but the actual `PersistedAuxiliaryInfo` data is lost.

**Step 3: Client-side V1 → V2 conversion** [3](#0-2) 

The client converts the V1 response back to V2 using `new_from_v1()`: [4](#0-3) 

This creates dummy auxiliary infos with `PersistedAuxiliaryInfo::None` values.

**Step 4: Verification failure**
When verification is performed during state sync: [5](#0-4) 

The verification logic checks auxiliary info consistency: [6](#0-5) 

The check at lines 2830-2837 expects that if `PersistedAuxiliaryInfo::None`, then `auxiliary_info_hash` must be `None`. However, the transaction infos still have `auxiliary_info_hash = Some(hash)` from the original committed data, causing verification to **fail**.

**Why this happens:**
Normal block execution creates transactions with `PersistedAuxiliaryInfo::V1 { transaction_index }`: [7](#0-6) 

This results in `auxiliary_info_hash = Some(hash)` being set in TransactionInfo: [8](#0-7) 

## Impact Explanation

**High Severity** - This meets the criteria for significant protocol violations causing validator node failures:

1. **State Sync Failure**: Any node using V1 protocol cannot verify and apply transaction outputs, breaking state synchronization
2. **Node Availability**: Affected nodes cannot catch up to the network, reducing validator availability
3. **Network Partition Risk**: Nodes may become isolated if they cannot sync, potentially affecting consensus participation
4. **Backward Compatibility Broken**: The V1 protocol path is completely broken for any transactions with auxiliary info (which is all normal transactions)

This does not reach Critical severity as it doesn't directly cause consensus safety violations or fund loss, but it significantly impairs network operation.

## Likelihood Explanation

**High Likelihood** - This occurs automatically under normal conditions:

1. **Common scenario**: Whenever `is_transaction_v2_enabled()` returns false (V1 protocol in use)
2. **Affects all transactions**: Normal block execution sets `PersistedAuxiliaryInfo::V1` for all transactions
3. **No attacker action required**: The bug triggers during normal state sync operations
4. **Deterministic failure**: Every V1 sync request for transaction outputs will fail verification

The only mitigation is ensuring all nodes use V2 protocol, but backward compatibility requirements mean V1 must work.

## Recommendation

**Fix the V1 conversion to preserve auxiliary info compatibility:**

Option 1: When converting to V1, strip auxiliary info hashes from TransactionInfo objects to maintain consistency:
```rust
// In consume_output_list_with_proof, create sanitized TransactionInfo objects
// that have auxiliary_info_hash set to None
```

Option 2: Deprecate V1 protocol entirely and enforce V2 usage:
```rust
// Remove V1 request paths and require all clients to use V2
```

Option 3: In the V1→V2 conversion, preserve the auxiliary_info_hash and use it for verification instead of computing from None:
```rust
// Modify new_from_v1 to extract auxiliary_info_hash from TransactionInfo
// and use it for verification without requiring the actual PersistedAuxiliaryInfo
```

**Recommended solution**: Option 3 is least breaking. Modify the verification logic to accept that when auxiliary info is None but auxiliary_info_hash exists in TransactionInfo, skip the consistency check (assuming V1 backward compatibility mode).

## Proof of Concept

```rust
// File: state-sync/storage-service/types/src/tests/v1_v2_conversion_test.rs

#[test]
fn test_v1_v2_conversion_drops_auxiliary_info() {
    use aptos_types::transaction::{
        TransactionInfo, TransactionInfoV0, TransactionOutputListWithProof,
        TransactionOutputListWithProofV2, PersistedAuxiliaryInfo,
    };
    use aptos_crypto::hash::CryptoHash;
    
    // Create auxiliary info with V1 variant
    let aux_info = PersistedAuxiliaryInfo::V1 { transaction_index: 42 };
    let aux_info_hash = Some(CryptoHash::hash(&aux_info));
    
    // Create TransactionInfo with auxiliary_info_hash set
    let txn_info = TransactionInfo::new(
        HashValue::zero(),
        HashValue::zero(),
        HashValue::zero(),
        None,
        0,
        ExecutionStatus::Success,
        aux_info_hash, // Hash is present
    );
    
    // Create V1 proof with this TransactionInfo
    let v1_proof = TransactionOutputListWithProof::new(
        vec![],
        Some(0),
        TransactionInfoListWithProof::new(vec![txn_info], None),
    );
    
    // Convert to V2 using new_from_v1
    let v2_proof = TransactionOutputListWithProofV2::new_from_v1(v1_proof);
    
    // Try to verify - this will FAIL
    let ledger_info = create_test_ledger_info(); // helper function
    let result = v2_proof.verify(&ledger_info, Some(0));
    
    // Assertion: verification should fail due to mismatch
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("auxiliary info hash does not match"));
}
```

**To reproduce:**
1. Set up a test network with V1 protocol enabled
2. Execute normal transactions (which create auxiliary info)
3. Attempt to sync transaction outputs using V1 requests
4. Observe verification failures in state sync bootstrapper

### Citations

**File:** state-sync/storage-service/server/src/handler.rs (L510-526)
```rust
    fn get_transaction_outputs_with_proof(
        &self,
        request: &TransactionOutputsWithProofRequest,
    ) -> aptos_storage_service_types::Result<DataResponse, Error> {
        let response = self.storage.get_transaction_outputs_with_proof(
            request.proof_version,
            request.start_version,
            request.end_version,
        )?;

        Ok(DataResponse::TransactionOutputsWithProof(
            response
                .transaction_output_list_with_proof
                .unwrap()
                .consume_output_list_with_proof(),
        ))
    }
```

**File:** types/src/transaction/mod.rs (L2675-2681)
```rust
    pub fn consume_output_list_with_proof(self) -> TransactionOutputListWithProof {
        match self {
            Self::TransactionOutputListWithAuxiliaryInfos(output_list_with_auxiliary_infos) => {
                output_list_with_auxiliary_infos.transaction_output_list_with_proof
            },
        }
    }
```

**File:** types/src/transaction/mod.rs (L2769-2782)
```rust
    /// A convenience function to create a v2 output list from a
    /// v1 list. In this case, all auxiliary infos are set to None.
    fn new_from_v1(transaction_output_list_with_proof: TransactionOutputListWithProof) -> Self {
        let num_transaction_infos = transaction_output_list_with_proof
            .proof
            .transaction_infos
            .len();
        let persisted_auxiliary_infos = vec![PersistedAuxiliaryInfo::None; num_transaction_infos];

        Self {
            transaction_output_list_with_proof,
            persisted_auxiliary_infos,
        }
    }
```

**File:** types/src/transaction/mod.rs (L2812-2850)
```rust
fn verify_auxiliary_infos_against_transaction_infos(
    auxiliary_infos: &[PersistedAuxiliaryInfo],
    transaction_infos: &[TransactionInfo],
) -> Result<()> {
    // Verify the lengths of the auxiliary infos and transaction infos match
    ensure!(
        auxiliary_infos.len() == transaction_infos.len(),
        "The number of auxiliary infos ({}) does not match the number of transaction infos ({})",
        auxiliary_infos.len(),
        transaction_infos.len(),
    );

    // Verify the auxiliary info hashes match those of the transaction infos
    auxiliary_infos
        .par_iter()
        .zip_eq(transaction_infos.par_iter())
        .map(|(aux_info, txn_info)| {
            match aux_info {
                PersistedAuxiliaryInfo::None
                | PersistedAuxiliaryInfo::TimestampNotYetAssignedV1 { .. } => {
                    ensure!(
                        txn_info.auxiliary_info_hash().is_none(),
                        "The transaction info has an auxiliary info hash: {:?}, \
                             but the persisted auxiliary info is None!",
                        txn_info.auxiliary_info_hash()
                    );
                },
                PersistedAuxiliaryInfo::V1 { .. } => {
                    let aux_info_hash = CryptoHash::hash(aux_info);
                    ensure!(
                        txn_info.auxiliary_info_hash() == Some(aux_info_hash),
                        "The auxiliary info hash does not match the transaction info! \
                             Auxiliary info hash: {:?}. Auxiliary info hash in txn_info: {:?}.",
                        aux_info_hash,
                        txn_info.auxiliary_info_hash()
                    );
                },
            }
            Ok(())
```

**File:** types/src/transaction/mod.rs (L3293-3300)
```rust
    fn auxiliary_info_at_txn_index(txn_index: u32) -> Self {
        Self {
            persisted_info: PersistedAuxiliaryInfo::V1 {
                transaction_index: txn_index,
            },
            ephemeral_info: None,
        }
    }
```

**File:** state-sync/storage-service/types/src/responses.rs (L479-508)
```rust
impl TryFrom<StorageServiceResponse> for TransactionOutputListWithProofV2 {
    type Error = crate::responses::Error;

    fn try_from(response: StorageServiceResponse) -> crate::Result<Self, Self::Error> {
        let data_response = response.get_data_response()?;
        match data_response {
            DataResponse::TransactionOutputsWithProof(output_list_with_proof) => Ok(
                TransactionOutputListWithProofV2::new_from_v1(output_list_with_proof),
            ),
            DataResponse::TransactionDataWithProof(response) => {
                if let TransactionDataResponseType::TransactionOutputData =
                    response.transaction_data_response_type
                {
                    if let Some(output_list_with_proof_v2) =
                        response.transaction_output_list_with_proof
                    {
                        return Ok(output_list_with_proof_v2);
                    }
                }
                Err(Error::UnexpectedResponseError(
                    "transaction_output_list_with_proof is empty".into(),
                ))
            },
            _ => Err(Error::UnexpectedResponseError(format!(
                "expected transaction_outputs_with_proof, found {}",
                data_response.get_label()
            ))),
        }
    }
}
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1294-1310)
```rust
                match transaction_outputs_with_proof.verify(
                    ledger_info_to_sync.ledger_info(),
                    Some(expected_start_version),
                ) {
                    Ok(()) => {
                        self.state_value_syncer
                            .set_transaction_output_to_sync(transaction_outputs_with_proof);
                    },
                    Err(error) => {
                        self.reset_active_stream(Some(NotificationAndFeedback::new(
                            notification_id,
                            NotificationFeedback::PayloadProofFailed,
                        )))
                        .await?;
                        return Err(Error::VerificationError(format!(
                            "Transaction outputs with proof is invalid! Error: {:?}",
                            error
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L61-87)
```rust
                let auxiliary_info_hash = match persisted_auxiliary_info {
                    PersistedAuxiliaryInfo::None => None,
                    PersistedAuxiliaryInfo::V1 { .. } => {
                        Some(CryptoHash::hash(persisted_auxiliary_info))
                    },
                    PersistedAuxiliaryInfo::TimestampNotYetAssignedV1 { .. } => None,
                };
                let state_checkpoint_hash = state_checkpoint_hashes[i];
                let event_hashes = txn_output
                    .events()
                    .iter()
                    .map(CryptoHash::hash)
                    .collect::<Vec<_>>();
                let event_root_hash =
                    InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash();
                let write_set_hash = CryptoHash::hash(txn_output.write_set());
                let txn_info = TransactionInfo::new(
                    txn.hash(),
                    write_set_hash,
                    event_root_hash,
                    state_checkpoint_hash,
                    txn_output.gas_used(),
                    txn_output
                        .status()
                        .as_kept_status()
                        .expect("Already sorted."),
                    auxiliary_info_hash,
```
