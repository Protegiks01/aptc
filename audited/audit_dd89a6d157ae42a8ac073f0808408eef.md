# Audit Report

## Title
Faucet CLI Sequence Number Desynchronization on Transaction Timeout Leading to Cascading Failures

## Summary
The faucet CLI's error handling mechanism unconditionally decrements the local sequence number when any transaction error occurs, including timeout errors where the transaction may still be pending or executing. This creates a race condition where subsequent funding attempts reuse sequence numbers, causing systematic transaction rejections and denial of service for the faucet CLI functionality.

## Finding Description

The vulnerability exists in the interaction between three code components:

1. **Transaction Submission with Timeout** [1](#0-0) 

The `submit_transaction` function calls `submit_and_wait_bcs()` which can timeout in multiple scenarios (server lag, slow consensus, expired transactions). The code explicitly acknowledges at lines 350-353 that "it is possible that the transaction timed out" and that "it's hard to tell because this function returns an opaque anyhow error."

2. **Unconditional Sequence Number Rollback** [2](#0-1) 

When ANY error occurs, the code unconditionally calls `decrement_sequence_number()`, making no distinction between definitive failures (invalid transaction, insufficient gas) and ambiguous timeouts where the transaction may still succeed.

3. **CLI Error Handling Without Backoff** [3](#0-2) 

The CLI loop catches errors from `fund()`, prints them, and immediately continues to the next account without any delay or sequence number verification.

**Attack/Failure Scenario:**

When timeout conditions occur, the following sequence creates cascading failures:

**Step 1 - Initial Timeout:** Transaction for Account A is signed with sequence number 100 (incrementing local counter to 101), submitted successfully to mempool, but `submit_and_wait_bcs()` times out due to fullnode lag [4](#0-3) 

**Step 2 - Incorrect Rollback:** Error handler decrements sequence number back to 100, even though transaction with seq 100 is still in mempool or executing.

**Step 3 - Sequence Number Collision:** CLI immediately attempts to fund Account B. The `update_sequence_numbers()` function [5](#0-4)  fetches on-chain state which may still show sequence 100 (if transaction hasn't executed or fullnode is lagging), signs new transaction with seq 100, creating a duplicate sequence number collision.

**Step 4 - Systematic Rejection:** Aptos blockchain rejects duplicate sequence numbers. All subsequent funding attempts fail until on-chain state synchronizes, which may take multiple iterations.

The `update_sequence_numbers()` recovery mechanism at lines 288-296 only activates after 30 seconds of consecutive failures, but the CLI loop executes iterations immediately without waiting, preventing this recovery from engaging during normal CLI execution.

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria for the following reasons:

**State Inconsistencies Requiring Intervention:** The local `LocalAccount` sequence number becomes desynchronized from on-chain state, causing systematic transaction failures until manual intervention or timeout-based recovery occurs.

**Limited Service Disruption:** While this creates a denial-of-service condition for the faucet CLI, it:
- Does not affect the core blockchain consensus or execution
- Does not impact validator operations  
- Does not result in fund loss or theft
- Is recoverable through retry or using the faucet service instead of CLI
- Only affects testnet tooling, not mainnet operations

The issue is more severe than a simple bug because it violates transaction sequence number invariants and can cause systematic failures under normal network conditions (congested networks, slow fullnodes).

## Likelihood Explanation

**High Likelihood** - This issue is easily triggered under common conditions:

- Network congestion causing slow transaction propagation
- Fullnode lag behind consensus (common in distributed systems)
- Server-side latency exceeding configured timeouts
- High transaction volume causing mempool delays

The CLI is configured with `wait_for_transactions: true` [6](#0-5)  and uses default timeout values, making timeout scenarios likely during periods of network stress or when targeting slow fullnodes.

## Recommendation

Implement proper error classification and retry logic in the transaction submission flow:

```rust
// In submit_transaction (common.rs):
match result {
    Ok(_) => { /* success path */ },
    Err(e) => {
        // Only rollback sequence number for definitive failures
        // Do NOT rollback for timeout errors where transaction may still succeed
        if is_definitive_failure(&e) {
            faucet_account.write().await.decrement_sequence_number();
        } else {
            warn!(
                "Transaction may still succeed despite error. Not rolling back sequence number."
            );
        }
        Err(e)
    }
}

fn is_definitive_failure(error: &AptosTapError) -> bool {
    // Check error message for definitive failures vs timeouts
    // Return false for timeout-related errors
}
```

Additionally, in the CLI main loop, implement exponential backoff and sequence number resynchronization:

```rust
// In main.rs run() function:
for account in accounts {
    let mut retry_count = 0;
    let max_retries = 3;
    
    loop {
        let response = mint_funder.fund(/*...*/).await;
        match response {
            Ok(response) => { /* success */ break; }
            Err(err) => {
                if retry_count >= max_retries {
                    println!("FAILURE after {} retries: {}", max_retries, err);
                    break;
                }
                retry_count += 1;
                
                // Wait before retry to allow sequence numbers to sync
                tokio::time::sleep(Duration::from_secs(2_u64.pow(retry_count))).await;
            }
        }
    }
}
```

## Proof of Concept

```rust
// Simulation demonstrating the vulnerability

use tokio::time::Duration;

#[tokio::test]
async fn test_sequence_number_collision_on_timeout() {
    // Setup: Create faucet with account at sequence 100
    let mut local_account = LocalAccount::new(test_address, test_key, 100);
    
    // Scenario 1: First transaction times out
    // 1. Sign transaction (increments to 101)
    let txn1 = local_account.sign_with_transaction_builder(
        transaction_factory.payload(create_account_payload(account_a))
    );
    assert_eq!(local_account.sequence_number(), 101);
    
    // 2. Simulate timeout error and rollback
    local_account.decrement_sequence_number();
    assert_eq!(local_account.sequence_number(), 100);
    
    // 3. Transaction with seq 100 still in mempool (simulated)
    
    // Scenario 2: Immediately try second transaction
    // 4. Sign transaction (increments to 101)
    let txn2 = local_account.sign_with_transaction_builder(
        transaction_factory.payload(create_account_payload(account_b))
    );
    assert_eq!(local_account.sequence_number(), 101);
    
    // 5. Both txn1 and txn2 have sequence number 100!
    // Blockchain will reject one or both
    assert_eq!(txn1.sequence_number(), 100);
    assert_eq!(txn2.sequence_number(), 100); // COLLISION!
    
    // Expected: Transaction failure due to duplicate sequence number
}
```

## Notes

**Severity Clarification:** While the security question categorizes this as "High," the actual impact is more accurately **Medium** severity according to the Aptos bug bounty criteria. The issue affects faucet CLI availability but does not impact core blockchain operations, consensus, or result in fund loss.

**Scope Consideration:** The faucet is peripheral infrastructure rather than a core blockchain component (consensus, execution, storage, governance, staking). However, the underlying sequence number management issue in `common.rs` is shared code that could affect other components using the same pattern.

**Existing Acknowledgment:** The comment at line 351-353 shows developers are aware that timeouts are ambiguous, but the error handling doesn't account for this distinction, making this a known-but-unmitigated issue.

### Citations

**File:** crates/aptos-faucet/core/src/funder/common.rs (L203-305)
```rust
pub async fn update_sequence_numbers(
    client: &Client,
    funder_account: &RwLock<LocalAccount>,
    // Each asset has its own queue: HashMap<asset_name, Vec<(AccountAddress, u64)>>
    outstanding_requests: &RwLock<HashMap<String, Vec<(AccountAddress, u64)>>>,
    receiver_address: AccountAddress,
    amount: u64,
    wait_for_outstanding_txns_secs: u64,
    asset_name: &str,
) -> Result<(u64, Option<u64>), AptosTapError> {
    let (mut funder_seq, mut receiver_seq) =
        get_sequence_numbers(client, funder_account, receiver_address).await?;
    let our_funder_seq = {
        let funder_account = funder_account.write().await;

        // If the onchain sequence_number is greater than what we have, update our
        // sequence_numbers
        if funder_seq > funder_account.sequence_number() {
            funder_account.set_sequence_number(funder_seq);
        }
        funder_account.sequence_number()
    };

    let _resetter = NumOutstandingTransactionsResetter;

    let mut set_outstanding = false;
    let request_key = (receiver_address, amount);

    // We shouldn't have too many outstanding txns
    for _ in 0..(wait_for_outstanding_txns_secs * 2) {
        if our_funder_seq < funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
            // Enforce a stronger ordering of priorities based upon the MintParams that arrived
            // first. Then put the other folks to sleep to try again until the queue fills up.
            if !set_outstanding {
                let mut requests_map = outstanding_requests.write().await;
                let queue = requests_map
                    .entry(asset_name.to_string())
                    .or_insert_with(Vec::new);
                queue.push(request_key);
                set_outstanding = true;
            }

            // Check if this request is at the front of the queue for this asset
            let requests_map = outstanding_requests.read().await;
            let is_at_front = if let Some(queue) = requests_map.get(asset_name) {
                queue.first() == Some(&request_key)
            } else {
                false
            };

            if is_at_front {
                // There might have been two requests with the same parameters, so we ensure that
                // we only pop off one of them. We do a read lock first since that is cheap,
                // followed by a write lock.
                drop(requests_map);
                let mut requests_map = outstanding_requests.write().await;
                if let Some(queue) = requests_map.get_mut(asset_name) {
                    if queue.first() == Some(&request_key) {
                        queue.remove(0);
                    }
                }
                break;
            }
            tokio::time::sleep(tokio::time::Duration::from_millis(1)).await;
            continue;
        }
        let num_outstanding = our_funder_seq - funder_seq;

        sample!(
            SampleRate::Duration(Duration::from_secs(2)),
            warn!(
                "We have too many outstanding transactions: {}. Sleeping to let the system catchup.",
                num_outstanding
            );
        );

        // Report the number of outstanding transactions.
        NUM_OUTSTANDING_TRANSACTIONS.set(num_outstanding as i64);

        tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
        (funder_seq, receiver_seq) =
            get_sequence_numbers(client, funder_account, receiver_address).await?;
    }

    // If after 30 seconds we still have not caught up, we are likely unhealthy.
    if our_funder_seq >= funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
        error!("We are unhealthy, transactions have likely expired.");
        let funder_account = funder_account.write().await;
        if funder_account.sequence_number() >= funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
            info!("Resetting the sequence number counter.");
            funder_account.set_sequence_number(funder_seq);
        } else {
            info!("Someone else reset the sequence number counter ahead of us.");
        }
    }

    // After this point we report 0 outstanding transactions. This happens by virtue
    // of the NumOutstandingTransactionsResetter dropping out of scope. We do it this
    // way instead of explicitly calling it here because if the caller hangs up part
    // way through the request, the future for the request handler stops getting polled,
    // meaning we'd never make it here. Leveraging Drop makes sure it always happens.

    Ok((funder_seq, receiver_seq))
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L349-375)
```rust
    let (result, event_on_success) = if wait_for_transactions {
        // If this fails, we assume it is the user's fault, e.g. because the
        // account already exists, but it is possible that the transaction
        // timed out. It's hard to tell because this function returns an opaque
        // anyhow error. https://github.com/aptos-labs/aptos-tap/issues/60.
        (
            client
                .submit_and_wait_bcs(&signed_transaction)
                .await
                .map(|_| ())
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::TransactionFailed)
                }),
            "transaction_success",
        )
    } else {
        (
            client
                .submit_bcs(&signed_transaction)
                .await
                .map(|_| ())
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::TransactionFailed)
                }),
            "transaction_submitted",
        )
    };
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L388-389)
```rust
        Err(e) => {
            faucet_account.write().await.decrement_sequence_number();
```

**File:** crates/aptos-faucet/cli/src/main.rs (L91-91)
```rust
            true, // wait_for_transactions
```

**File:** crates/aptos-faucet/cli/src/main.rs (L141-156)
```rust
        for account in accounts {
            let response = mint_funder
                .fund(Some(self.amount), account, None, false, false)
                .await;
            match response {
                Ok(response) => println!(
                    "SUCCESS: Account: {}, txn hashes: {:?}",
                    account,
                    response
                        .into_iter()
                        .map(|r| r.committed_hash().to_string())
                        .collect::<Vec<_>>()
                ),
                Err(err) => println!("FAILURE: Account: {} Response: {:#}", account, err),
            }
        }
```

**File:** crates/aptos-rest-client/src/lib.rs (L824-833)
```rust
            if let Some(max_server_lag_wait_duration) = max_server_lag_wait {
                if aptos_infallible::duration_since_epoch().as_secs()
                    > expiration_timestamp_secs + max_server_lag_wait_duration.as_secs()
                {
                    return Err(anyhow!(
                        "Ledger on endpoint ({}) is more than {}s behind current time, timing out waiting for the transaction. Warning, transaction ({}) might still succeed.",
                        self.path_prefix_string(),
                        max_server_lag_wait_duration.as_secs(),
                        hash,
                    ).into());
```
