# Audit Report

## Title
Validator Node Crash via Unimplemented Error Handler in Sharded Block Execution

## Summary
The sharded block executor contains an unimplemented error handler (`CrossShardCommitSender::on_execution_aborted`) that panics with `todo!()` when invoked. When sharded block execution falls back to sequential execution and encounters certain fatal VM errors, this unimplemented handler is called, causing the entire validator node to crash. This creates a Denial of Service (DoS) attack vector where malicious transactions can systematically crash all validators using sharded execution.

## Finding Description

The vulnerability exists in the error handling path when sharded block execution is used. The system violates the availability and liveness invariants through the following mechanism:

**The Core Issue:**

The `CrossShardCommitSender` struct implements the `TransactionCommitHook` trait to handle cross-shard transaction dependencies. However, the `on_execution_aborted` method is not implemented: [1](#0-0) 

This `todo!()` macro will panic the entire validator process when called.

**Attack Path:**

1. **Sharded Execution Setup**: When executing a block with sharded execution enabled, a `CrossShardCommitSender` is created and passed as the transaction commit hook: [2](#0-1) 

2. **Parallel to Sequential Fallback**: The block executor attempts parallel execution first. If parallel execution encounters errors, it falls back to sequential execution: [3](#0-2) 

3. **Fatal Error Triggers Abort**: During sequential execution, if a transaction encounters a fatal error (such as `ExecutionStatus::Abort`, `DelayedFieldsCodeInvariantError`, or `SpeculativeExecutionAbortError`), the commit hook's `on_execution_aborted` method is invoked: [4](#0-3) 

4. **Validator Crash**: The unimplemented `on_execution_aborted` in `CrossShardCommitSender` is called, executing `todo!()`, which panics and crashes the validator node.

**Secondary Issues:**

Additionally, when one shard encounters an error, other shards do NOT abort execution: [5](#0-4) 

The `?` operator on line 171 causes immediate return when a shard errors, but other shards continue executing in their threads, wasting computational resources.

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos Bug Bounty)

This vulnerability enables:

1. **Validator Node Crashes**: An attacker can craft transactions that trigger the sequential execution fallback with fatal errors, causing validator nodes using sharded execution to panic and crash. This directly impacts network availability.

2. **Systematic DoS**: By repeatedly submitting blocks containing such transactions, an attacker can systematically crash all validators using sharded execution, potentially bringing down the entire network if sharded execution is widely deployed.

3. **Resource Exhaustion**: Even without triggering the panic, malicious blocks can waste validator resources by causing one shard to fail quickly while others continue expensive computations unnecessarily.

This meets the **High Severity** criteria: "Validator node slowdowns / API crashes / Significant protocol violations" and potentially **Critical Severity** if it causes "Total loss of liveness/network availability."

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires:
- Sharded block execution to be enabled (may not be default configuration)
- Crafting transactions that cause parallel execution to fail AND trigger fatal errors in sequential fallback
- Knowledge of specific VM error conditions

However, once the attacker identifies the trigger conditions, the attack is:
- Repeatable and deterministic
- Requires no special privileges (any transaction sender can submit malicious transactions)
- Cannot be mitigated without code changes
- Affects all validators using sharded execution configuration

The presence of `todo!()` in production code indicates this code path may not be well-tested, making exploitation more likely to succeed without detection.

## Recommendation

Implement proper error handling for cross-shard execution aborts:

```rust
fn on_execution_aborted(&self, txn_idx: TxnIndex) {
    let global_txn_idx = txn_idx + self.index_offset;
    
    // Send abort notifications to dependent shards
    if let Some(edges) = self.dependent_edges.get(&global_txn_idx) {
        for (state_key, dependent_shard_ids) in edges.iter() {
            for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                    state_key.clone(),
                    None, // None indicates abort
                ));
                if *round_id == GLOBAL_ROUND_ID {
                    self.cross_shard_client.send_global_msg(message);
                } else {
                    self.cross_shard_client.send_cross_shard_msg(
                        *dependent_shard_id,
                        *round_id,
                        message,
                    );
                }
            }
        }
    }
}
```

Additionally, implement proper shard cancellation when one shard errors to prevent resource waste.

## Proof of Concept

```rust
// Rust test demonstrating the panic
#[test]
#[should_panic(expected = "not yet implemented")]
fn test_cross_shard_abort_panics() {
    use aptos_types::block_executor::partitioner::{ShardId, SubBlock};
    use std::sync::Arc;
    
    // Create a mock cross-shard client
    let cross_shard_client = Arc::new(MockCrossShardClient::new());
    
    // Create an empty sub-block
    let sub_block = SubBlock::new(0, 0, vec![]);
    
    // Create CrossShardCommitSender
    let sender = CrossShardCommitSender::new(
        0 as ShardId,
        cross_shard_client,
        &sub_block,
    );
    
    // Calling on_execution_aborted will panic with todo!()
    sender.on_execution_aborted(0);
}
```

To trigger in production:
1. Configure validators with sharded block execution enabled
2. Submit a block containing transactions that:
   - Cause parallel execution to fail (e.g., through resource group serialization errors)
   - Trigger a fatal VM error in sequential fallback (e.g., via `ExecutionStatus::Abort`)
3. The validator will panic when `on_execution_aborted` is called

## Notes

This vulnerability demonstrates a critical gap in error handling for the sharded execution feature. The presence of `todo!()` in production code suggests incomplete implementation of this feature. Validators using sharded execution are at risk of crashes that could be exploited for DoS attacks.

The secondary issue of lacking shard cancellation when errors occur also represents a resource exhaustion vector, though less severe than the crash vulnerability.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L149-151)
```rust
    fn on_execution_aborted(&self, _txn_idx: TxnIndex) {
        todo!("on_transaction_aborted not supported for sharded execution yet")
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L89-100)
```rust
        let cross_shard_commit_sender =
            CrossShardCommitSender::new(self.shard_id, self.cross_shard_client.clone(), &sub_block);
        Self::execute_transactions_with_dependencies(
            Some(self.shard_id),
            self.executor_thread_pool.clone(),
            sub_block.into_transactions_with_deps(),
            self.cross_shard_client.clone(),
            Some(cross_shard_commit_sender),
            round,
            state_view,
            config,
        )
```

**File:** aptos-move/block-executor/src/executor.rs (L2237-2248)
```rust
                ExecutionStatus::Abort(err) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    error!(
                        "Sequential execution FatalVMError by transaction {}",
                        idx as TxnIndex
                    );
                    // Record the status indicating the unrecoverable VM failure.
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalVMError(err),
                    ));
```

**File:** aptos-move/block-executor/src/executor.rs (L2577-2600)
```rust
            if let Ok(output) = parallel_result {
                return Ok(output);
            }

            if !self.config.local.allow_fallback {
                panic!("Parallel execution failed and fallback is not allowed");
            }

            // All logs from the parallel execution should be cleared and not reported.
            // Clear by re-initializing the speculative logs.
            init_speculative_logs(signature_verified_block.num_txns() + 1);

            // Flush all caches to re-run from the "clean" state.
            module_cache_manager_guard
                .environment()
                .runtime_environment()
                .flush_all_caches();
            module_cache_manager_guard.module_cache_mut().flush();

            info!("parallel execution requiring fallback");
        }

        // If we didn't run parallel, or it didn't finish successfully - run sequential
        let sequential_result = self.execute_transactions_sequential(
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L164-175)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        let _timer = WAIT_FOR_SHARDED_OUTPUT_SECONDS.start_timer();
        trace!("LocalExecutorClient Waiting for results");
        let mut results = vec![];
        for (i, rx) in self.result_rxs.iter().enumerate() {
            results.push(
                rx.recv()
                    .unwrap_or_else(|_| panic!("Did not receive output from shard {}", i))?,
            );
        }
        Ok(results)
    }
```
