# Audit Report

## Title
Weak TLS Cipher Suite Vulnerability in JWK Fetching Allows Potential MITM Attack on Consensus-Critical Data

## Summary
The `fetch_jwks_from_jwks_uri()` function in the JWK consensus system does not enforce minimum TLS protocol versions or restrict cipher suites when fetching JSON Web Keys from OIDC providers. This allows potential downgrade attacks to weak ciphers (RC4, DES, export-grade) on systems with vulnerable OpenSSL configurations, potentially compromising the integrity of consensus-critical JWK data used for keyless transaction validation.

## Finding Description

The vulnerability exists in the JWK fetching mechanism used by the Aptos consensus system for keyless authentication. [1](#0-0) 

The function creates a default `reqwest::Client` without any explicit TLS configuration. [2](#0-1) 

This client is used by the JWK Observer in the consensus layer to periodically fetch JWKs from OIDC providers. [3](#0-2) 

The workspace configuration uses `reqwest` with default features, meaning it relies on `native-tls` (OpenSSL on Unix systems) without explicit security hardening. [4](#0-3) 

**Security Invariant Violation**: This breaks the **Cryptographic Correctness** invariant (item 10), which states that cryptographic operations must be secure. It also undermines **Deterministic Execution** (item 1), as validators could potentially receive different JWKs if subjected to different MITM attacks.

**Attack Path**:
1. Attacker positions themselves as MITM between a validator node and an OIDC provider (e.g., Google, Apple)
2. If the validator runs on a system with outdated OpenSSL (pre-1.1.0) or misconfigured OpenSSL allowing weak ciphers
3. Attacker downgrades the TLS connection to use weak ciphers (RC4, DES, or export-grade)
4. Attacker decrypts the JWK response and injects malicious JWKs
5. The compromised validator includes malicious JWKs in the consensus voting process
6. If multiple validators are compromised (>1/3 stake), malicious JWKs could reach consensus
7. These malicious JWKs would be stored on-chain and used to validate keyless transactions, allowing fraudulent transactions to be accepted

**Contrast with Secure Implementation**: The codebase demonstrates awareness of TLS security best practices in other components. The Vault client explicitly sets minimum TLS version: [5](#0-4) 

This inconsistency shows that the JWK fetching code lacks the same security hardening applied elsewhere in consensus-critical paths.

## Impact Explanation

This qualifies as **Medium severity** under the Aptos bug bounty program for the following reasons:

1. **State Inconsistencies Requiring Intervention**: If validators fetch compromised JWKs, it could lead to consensus disagreements about which keyless transactions are valid, requiring manual intervention to resolve.

2. **Limited Funds Loss or Manipulation**: Successful exploitation could allow attackers to craft fraudulent keyless transactions that validators would incorrectly accept as valid, leading to unauthorized fund movements.

3. **Consensus Integrity Impact**: While the consensus protocol provides some protection (requiring >1/3 of validators to be compromised), the vulnerability undermines the security of a consensus-critical data source.

The impact does not reach **Critical** or **High** severity because:
- Exploitation requires specific environmental conditions (vulnerable OpenSSL configuration)
- Requires MITM positioning on validator network connections
- Consensus protocol provides partial mitigation (requires compromising multiple validators)
- No direct RCE, network partition, or immediate loss of liveness

However, it represents a significant defense-in-depth failure in consensus-critical infrastructure.

## Likelihood Explanation

**Likelihood: Medium-Low**

**Required Conditions**:
1. Validator nodes running on systems with OpenSSL versions that allow weak cipher negotiation (pre-1.1.0 or misconfigured)
2. Attacker with MITM capability on validator network connections to OIDC providers
3. Successful TLS downgrade attack
4. Compromise of multiple validators (>1/3 stake) for consensus impact

**Mitigating Factors**:
- Modern Linux distributions typically include OpenSSL 1.1.0+ with weak ciphers disabled by default
- Major OIDC providers (Google, Apple) enforce strong TLS and won't negotiate weak ciphers on their end
- Professional validator operations likely use updated systems with proper network security
- The JWK consensus protocol requires agreement from multiple validators

**Aggravating Factors**:
- No explicit enforcement means security relies entirely on environmental factors
- Operators may not be aware of this dependency on system OpenSSL configuration
- Legacy systems or containers with outdated base images could be vulnerable
- Defense-in-depth principle is violated â€“ the code should enforce security regardless of environment

## Recommendation

**Implement explicit TLS security configuration for the JWK fetching client**. Follow the pattern established in the Vault client by enforcing minimum TLS protocol version and secure cipher suites.

**Recommended Fix**:

Modify `fetch_jwks_from_jwks_uri()` in `crates/jwk-utils/src/lib.rs`:

```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    // Create client with secure TLS configuration
    let client = reqwest::ClientBuilder::new()
        .min_tls_version(reqwest::tls::Version::TLS_1_2)
        .https_only(true)
        .build()?;
    
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

Similarly, update `fetch_jwks_uri_from_openid_config()`:

```rust
pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::ClientBuilder::new()
        .min_tls_version(reqwest::tls::Version::TLS_1_2)
        .https_only(true)
        .build()?;
    
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

**Additional Recommendations**:
1. Consider switching to `rustls-tls` feature instead of `native-tls` for more consistent cross-platform behavior and explicit cipher suite control
2. Add validation to ensure JWK URIs use HTTPS scheme only
3. Implement certificate pinning for known OIDC providers for additional security
4. Add monitoring/alerting for TLS negotiation failures or downgrades

## Proof of Concept

```rust
// Test demonstrating the vulnerability - shows lack of TLS configuration
#[tokio::test]
async fn test_jwk_fetch_lacks_tls_hardening() {
    use reqwest::Client;
    
    // Current implementation - no TLS configuration
    let vulnerable_client = Client::new();
    
    // The client will negotiate TLS based on system OpenSSL defaults
    // On systems with weak OpenSSL config, this could allow:
    // - TLS 1.0/1.1 (deprecated protocols)
    // - RC4, DES, 3DES, or export-grade ciphers
    // - Lack of perfect forward secrecy
    
    // Secure implementation - explicit TLS configuration
    let secure_client = reqwest::ClientBuilder::new()
        .min_tls_version(reqwest::tls::Version::TLS_1_2)
        .https_only(true)
        .build()
        .expect("Failed to build secure client");
    
    // Demonstrate the difference by attempting connections
    // On vulnerable systems, vulnerable_client would accept weak ciphers
    // while secure_client would reject them
    
    // Test with a real OIDC provider
    let test_url = "https://accounts.google.com/.well-known/openid-configuration";
    
    // Both should work on modern systems, but vulnerable_client
    // doesn't provide security guarantees
    let result = vulnerable_client.get(test_url).send().await;
    assert!(result.is_ok(), "Connection should succeed on modern systems");
    
    // However, the vulnerability is that vulnerable_client doesn't
    // enforce minimum security standards, relying on system defaults
}

// Integration test showing consensus impact
#[tokio::test]
async fn test_jwk_consensus_with_mitm_vulnerable() {
    // Scenario: Attacker intercepts JWK fetch on vulnerable validator
    // 1. Validator fetches JWKs using vulnerable client
    // 2. MITM downgrades to weak cipher (on vulnerable system)
    // 3. MITM injects malicious JWK
    // 4. Validator includes malicious JWK in consensus vote
    // 5. If >1/3 validators compromised, malicious JWK reaches consensus
    
    // This test would require setting up:
    // - Mock OIDC server
    // - TLS MITM proxy that downgrades ciphers
    // - Multiple validator nodes in consensus
    // - Verification that malicious JWKs can reach consensus
    
    // The vulnerability is that the code doesn't prevent this attack
    // when run on systems with weak OpenSSL configurations
}
```

**Notes**:
- The vulnerability depends on system OpenSSL configuration, making it environment-specific
- Modern systems with OpenSSL 1.1.0+ have weak ciphers disabled by default, providing partial mitigation
- However, the code should enforce security explicitly rather than relying on environmental factors
- The pepper service's JWK fetcher has the same issue [6](#0-5)  and should also be hardened

### Citations

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L102-109)
```rust
async fn fetch_jwks(open_id_config_url: &str, my_addr: Option<AccountAddress>) -> Result<Vec<JWK>> {
    let jwks_uri = fetch_jwks_uri_from_openid_config(open_id_config_url)
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with open-id config request: {e}"))?;
    let jwks = fetch_jwks_from_jwks_uri(my_addr, jwks_uri.as_str())
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with jwks uri request: {e}"))?;
    Ok(jwks)
```

**File:** Cargo.toml (L761-767)
```text
reqwest = { version = "0.11.11", features = [
    "blocking",
    "cookies",
    "json",
    "multipart",
    "stream",
] }
```

**File:** secure/storage/vault/src/lib.rs (L133-134)
```rust
        let mut tls_builder = native_tls::TlsConnector::builder();
        tls_builder.min_protocol_version(Some(native_tls::Protocol::Tlsv12));
```

**File:** keyless/pepper/service/src/utils.rs (L17-22)
```rust
pub fn create_request_client() -> Client {
    Client::builder()
        .timeout(Duration::from_secs(CLIENT_REQUEST_TIMEOUT_SECS))
        .build()
        .expect("Failed to build the request client!")
}
```
