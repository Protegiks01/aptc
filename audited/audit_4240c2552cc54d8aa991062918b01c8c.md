# Audit Report

## Title
Transaction Filter Bypass via Multisig Payloads with None transaction_payload

## Summary
The transaction filter's `matches_entry_function()` function only inspects the `transaction_payload` field of Multisig transactions, but the actual executed payload can be stored on-chain. An attacker can bypass entry function filtering by creating a multisig transaction on-chain with a malicious payload, then executing it with a Multisig transaction that has `transaction_payload = None`, causing the filter to return false while the VM retrieves and executes the stored malicious payload.

## Finding Description

The Aptos transaction filtering system is designed to allow or deny transactions based on various criteria, including specific entry functions being called. However, there is a critical logic flaw in how multisig transactions are filtered.

**The Vulnerability:** [1](#0-0) 

When a transaction filter checks if a multisig transaction matches a specific entry function, it only examines the `transaction_payload` field. If this field is `None`, the function returns `false`, indicating no match. [2](#0-1) 

The Multisig struct explicitly allows `transaction_payload` to be `None` because payloads can be stored on-chain. The comment states: "Transaction payload is optional if already stored on chain." [3](#0-2) 

Attackers can use `create_transaction()` to store a full malicious entry function payload on-chain in the multisig account's transaction table. [4](#0-3) 

During execution, when `transaction_payload` is `None`, the VM calls `get_next_transaction_payload()` which retrieves the stored payload from on-chain storage and executes it. [5](#0-4) 

The `get_next_transaction_payload()` function returns the stored on-chain payload when `transaction.payload` is `Some`, completely bypassing what the filter examined.

**Attack Flow:**

1. Attacker creates/controls a multisig account
2. Attacker calls `create_transaction()` with malicious entry function (e.g., `0x1::coin::transfer` to steal funds)
3. Transaction gets approved by multisig owners
4. Attacker submits `SignedTransaction` with `TransactionPayload::Multisig` where `transaction_payload = None`
5. Mempool filter checks transaction: [6](#0-5) 

6. Filter's `matches_entry_function()` returns `false` because `transaction_payload.as_ref()` is `None`
7. Transaction passes filter and enters mempool
8. During execution, VM retrieves and executes the stored malicious payload
9. Filtered entry function executes successfully, bypassing security controls

This breaks the **Transaction Validation** invariant that "Prologue/epilogue checks must enforce all invariants" by allowing filtered transactions to execute through an indirect path.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria because it constitutes a "Significant protocol violation." The transaction filtering system is a security mechanism intended to protect validator nodes and network participants from executing unwanted or malicious transactions. Complete bypass of this system allows:

1. **Security Policy Violations**: Operators who configure filters to block specific entry functions (e.g., malicious contracts, high-risk operations) can be bypassed
2. **Node Protection Bypass**: Validators using filters to protect against resource exhaustion or malicious payloads lose this protection
3. **Governance Bypass**: If governance decisions result in filtering certain transactions, this can be circumvented
4. **Regulatory Compliance Issues**: Filters used for compliance purposes become ineffective

While this doesn't directly cause consensus violations or fund loss at the protocol level, it completely undermines a critical security control system, affecting all nodes that rely on transaction filtering.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Low Barrier to Entry**: Any user can create a multisig account (even single-owner) and exploit this
2. **Simple Execution**: The attack requires only standard multisig operations - no special permissions or insider access
3. **Clear Motivation**: Attackers have strong incentive to bypass filters that block malicious or restricted operations
4. **No Detection**: The bypass happens transparently - filtered transactions appear to pass through normal validation
5. **Common Use Case**: Multisig accounts with stored payloads are a legitimate feature, making malicious use indistinguishable

The attack complexity is LOW - it involves standard API calls that any developer can execute.

## Recommendation

The transaction filter must examine the actual payload that will be executed, not just the payload field in the transaction. For multisig transactions with `None` payload, the filter should retrieve and inspect the stored on-chain payload.

**Fix Option 1 - Retrieve and Inspect Stored Payload:**

Modify `matches_entry_function()` in `transaction_filter.rs` to query on-chain state for stored multisig payloads when `transaction_payload` is `None`. This requires adding state access capabilities to the filter.

**Fix Option 2 - Conservative Filtering (Recommended):**

When a multisig transaction has `transaction_payload = None`, apply conservative filtering rules:
- Always return `true` for deny rules (match all entry functions if we can't inspect)
- Always return `false` for allow rules (don't allow what we can't inspect)

This ensures that if the filter cannot determine what will execute, it errs on the side of caution.

**Fix Option 3 - Require Payload in Transaction:**

Introduce a feature flag or configuration that requires multisig transactions to include their payload in the transaction itself when filtering is enabled, preventing the `None` case entirely.

The recommended fix is Option 2 as it maintains security without requiring complex state access in the filtering layer, following the principle of "deny what you cannot inspect."

## Proof of Concept

```rust
// This PoC demonstrates the vulnerability conceptually
// It would be integrated into the Aptos test framework

#[test]
fn test_multisig_filter_bypass() {
    // Setup: Create filter that DENIES 0x1::coin::transfer
    let filter = TransactionFilter::new(vec![])
        .add_entry_function_filter(
            false, // deny
            AccountAddress::from_hex_literal("0x1").unwrap(),
            "coin".to_string(),
            "transfer".to_string(),
        );
    
    // Step 1: Create multisig account and store malicious payload on-chain
    // (via create_transaction with 0x1::coin::transfer payload)
    let multisig_address = AccountAddress::random();
    let malicious_entry_function = EntryFunction::new(
        ModuleId::new(
            AccountAddress::from_hex_literal("0x1").unwrap(),
            Identifier::new("coin").unwrap()
        ),
        Identifier::new("transfer").unwrap(),
        vec![],
        vec![], // arguments to steal funds
    );
    
    // Step 2: Create Multisig transaction with None payload
    let multisig_txn = Multisig {
        multisig_address,
        transaction_payload: None, // Key: payload is None
    };
    
    let raw_txn = RawTransaction::new(
        AccountAddress::random(),
        0,
        TransactionPayload::Multisig(multisig_txn),
        0,
        0,
        0,
        ChainId::new(1),
    );
    
    let signed_txn = SignedTransaction::new(
        raw_txn,
        Ed25519PrivateKey::generate_for_testing().public_key(),
        Ed25519PrivateKey::generate_for_testing().sign(&create_raw_transaction()).unwrap(),
    );
    
    // Step 3: Verify filter INCORRECTLY allows the transaction
    assert!(filter.allows_transaction(&signed_txn)); // BYPASSED!
    
    // But during execution, the stored 0x1::coin::transfer would execute
    // This demonstrates the security vulnerability
}
```

## Notes

This vulnerability affects all deployment configurations that use transaction filtering, including:
- Validator nodes filtering specific entry functions
- Mempool configurations with entry function restrictions  
- Custom filtering policies for compliance or security

The root cause is the semantic gap between what the filter inspects (the transaction structure) and what the VM executes (potentially stored on-chain data). This is a design-level issue in the filtering architecture that requires careful remediation to avoid breaking legitimate multisig functionality while closing the security hole.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L333-375)
```rust
fn matches_entry_function(
    signed_transaction: &SignedTransaction,
    address: &AccountAddress,
    module_name: &String,
    function: &String,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.payload() {
        TransactionPayload::Script(_) | TransactionPayload::ModuleBundle(_) => false,
        TransactionPayload::Multisig(multisig) => multisig
            .transaction_payload
            .as_ref()
            .map(|payload| match payload {
                MultisigTransactionPayload::EntryFunction(entry_function) => {
                    compare_entry_function(entry_function, address, module_name, function)
                },
            })
            .unwrap_or(false),
        TransactionPayload::EntryFunction(entry_function) => {
            compare_entry_function(entry_function, address, module_name, function)
        },
        TransactionPayload::Payload(TransactionPayloadInner::V1 { executable, .. }) => {
            match executable.as_ref() {
                TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                TransactionExecutableRef::EntryFunction(entry_function) => {
                    compare_entry_function(entry_function, address, module_name, function)
                },
            }
        },
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function(entry_function, address, module_name, function)
                    },
                }
            } else {
                false
            }
        },
    }
}
```

**File:** types/src/transaction/multisig.rs (L12-17)
```rust
pub struct Multisig {
    pub multisig_address: AccountAddress,

    // Transaction payload is optional if already stored on chain.
    pub transaction_payload: Option<MultisigTransactionPayload>,
}
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L393-404)
```text
    public fun get_next_transaction_payload(
        multisig_account: address, provided_payload: vector<u8>): vector<u8> acquires MultisigAccount {
        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);
        let sequence_number = multisig_account_resource.last_executed_sequence_number + 1;
        let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);

        if (option::is_some(&transaction.payload)) {
            *option::borrow(&transaction.payload)
        } else {
            provided_payload
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L954-973)
```text
    public entry fun create_transaction(
        owner: &signer,
        multisig_account: address,
        payload: vector<u8>,
    ) acquires MultisigAccount {
        assert!(vector::length(&payload) > 0, error::invalid_argument(EPAYLOAD_CANNOT_BE_EMPTY));

        assert_multisig_account_exists(multisig_account);
        assert_is_owner(owner, multisig_account);

        let creator = address_of(owner);
        let transaction = MultisigTransaction {
            payload: option::some(payload),
            payload_hash: option::none<vector<u8>>(),
            votes: simple_map::create<address, bool>(),
            creator,
            creation_time_secs: now_seconds(),
        };
        add_transaction(creator, multisig_account, transaction);
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1241-1282)
```rust
        let payload_bytes: Vec<Vec<u8>> = session
            .execute(|session| {
                session.execute_function_bypass_visibility(
                    &MULTISIG_ACCOUNT_MODULE,
                    GET_NEXT_TRANSACTION_PAYLOAD,
                    vec![],
                    serialize_values(&vec![
                        MoveValue::Address(multisig_address),
                        MoveValue::vector_u8(provided_payload),
                    ]),
                    gas_meter,
                    traversal_context,
                    module_storage,
                )
            })?
            .return_values
            .into_iter()
            .map(|(bytes, _ty)| bytes)
            .collect::<Vec<_>>();
        let payload_bytes = payload_bytes
            .first()
            // We expect the payload to either exists on chain or be passed along with the
            // transaction.
            .ok_or_else(|| {
                PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                    .with_message("Multisig payload bytes return error".to_string())
                    .finish(Location::Undefined)
            })?;
        // We have to deserialize twice as the first time returns the actual return type of the
        // function, which is vec<u8>. The second time deserializes it into the correct
        // EntryFunction payload type.
        // If either deserialization fails for some reason, that means the user provided incorrect
        // payload data either during transaction creation or execution.
        let deserialization_error = || {
            PartialVMError::new(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT)
                .finish(Location::Undefined)
        };
        let payload_bytes =
            bcs::from_bytes::<Vec<u8>>(payload_bytes).map_err(|_| deserialization_error())?;
        let payload = bcs::from_bytes::<MultisigTransactionPayload>(&payload_bytes)
            .map_err(|_| deserialization_error())?;

```

**File:** mempool/src/shared_mempool/tasks.rs (L435-438)
```rust
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
```
