# Audit Report

## Title
Event Sequence Number Mismatch During Fast Sync Leading to Indexer State Inconsistency

## Summary
During fast sync, the internal indexer database (including `EventSequenceNumberSchema`) is not transferred. When syncing nodes rebuild event sequence numbers from scratch, they use the **latest** on-chain resource state instead of the historical state at each transaction version, causing incorrect sequence number assignment and creating state divergence between nodes.

## Finding Description

The vulnerability occurs in the event v2-to-v1 translation system used by the internal indexer. The system maintains event sequence numbers in `EventSequenceNumberSchema` to ensure consistent event ordering across the network.

**The Problem:**

1. During fast sync, only the main state database (state KV and Merkle tree) is transferred. The internal indexer database is created with `None` for fast-synced nodes: [1](#0-0) 

2. After fast sync completes, the internal indexer starts processing from version 0 if its database is empty: [2](#0-1) 

3. **Critical Bug**: When translating events at historical version X, the code reads the **LATEST** state instead of the state at version X: [3](#0-2) 

4. The sequence number assignment uses the event handle count from this latest state as the default value: [4](#0-3) 

5. The `get_next_sequence_number` function returns the on-chain count directly when the DB is empty: [5](#0-4) 

**Concrete Attack Scenario:**

- **Genesis-synced node**: An account receives 100 deposits from version 0 to 10000. Events get sequence numbers 0-99.
- **Fast-synced node to version 10000**: 
  - Internal indexer processes version 50 (first deposit)
  - Reads `latest_state_checkpoint_view()` returning state at version 10000
  - Account's `CoinStore.deposit_events.count()` = 100 at version 10000
  - Assigns sequence number **100** (should be 0)
  - Subsequent events get 101, 102, ..., 199

**Result**: Different nodes have different sequence numbers for identical events, violating the State Consistency invariant.

The code even acknowledges this issue with a TODO comment: [6](#0-5) 

The `load_cache_from_db()` function exists to support proper restore, but it is **never called** anywhere in the codebase.

## Impact Explanation

This qualifies as **Medium Severity** under Aptos bug bounty criteria:

1. **State inconsistencies requiring intervention**: Fast-synced nodes have different `EventSequenceNumberSchema` content than genesis-synced nodes for identical blockchain state.

2. **API inconsistency**: Event queries by sequence number return different results from different nodes, breaking application assumptions about event ordering.

3. **Data integrity violation**: The internal indexer database, which serves critical API endpoints, contains incorrect data that doesn't match the canonical history.

4. **No automated recovery**: Once wrong sequence numbers are assigned and persisted, they remain incorrect unless the entire indexer database is wiped and rebuilt (expensive operation).

While this doesn't affect consensus directly (translated events are only in the indexer DB, not main state), it breaks a critical invariant: **State Consistency** - nodes should have deterministic, reproducible state for the same version.

## Likelihood Explanation

**High Likelihood** - This happens automatically and deterministically:

1. **Automatic trigger**: Any node performing fast sync will exhibit this behavior
2. **No attacker required**: The bug manifests during normal fast sync operations
3. **Persistent effect**: Once wrong sequence numbers are written, they persist indefinitely
4. **Widespread impact**: All fast-synced nodes (including archival nodes, indexers, API servers) are affected

The only mitigation currently available is:
- Using separate indexer database snapshots (not part of the standard fast sync)
- Full reindexing from genesis (defeats the purpose of fast sync)

## Recommendation

**Immediate Fix**: Call `load_cache_from_db()` after fast sync completes and before starting indexer processing:

```rust
// In InternalIndexerDBService::new() or get_start_version()
pub async fn get_start_version(&self, node_config: &NodeConfig) -> Result<Version> {
    // ... existing fast sync wait logic ...
    
    // NEW: Load event sequence numbers from DB if fast sync was used
    if fast_sync_enabled && start_version == 0 {
        if let Err(e) = self.db_indexer
            .event_v2_translation_engine
            .load_cache_from_db() 
        {
            warn!("Failed to load event sequence number cache: {:?}", e);
        }
    }
    
    // ... rest of function ...
}
```

**Long-term Solutions**:

1. **Include internal indexer in fast sync snapshots**: Backup and restore `EventSequenceNumberSchema` along with state snapshots
2. **Use versioned state reads**: Modify translation to read state at the transaction's version instead of latest:
   - Add version parameter to `get_state_value_bytes_for_resource()`  
   - Use `get_state_value_at_version()` instead of `latest_state_checkpoint_view()`
3. **Separate indexer snapshots**: Provide official indexer database snapshots alongside fast sync snapshots

## Proof of Concept

```rust
// PoC demonstrating the vulnerability (run in test environment)

#[test]
fn test_event_sequence_mismatch_after_fast_sync() {
    // Setup: Create account and generate 100 deposit events
    let mut genesis_node = create_test_node_from_genesis();
    let account = create_test_account(&mut genesis_node);
    
    for i in 0..100 {
        genesis_node.execute_deposit_transaction(&account, 100);
    }
    
    let target_version = genesis_node.get_latest_version(); // Version ~100
    
    // Genesis node: Check event sequence numbers
    let genesis_events = genesis_node
        .get_events_by_key(&deposit_event_key, 0, 100, target_version)
        .unwrap();
    assert_eq!(genesis_events[0].sequence_number, 0);
    assert_eq!(genesis_events[99].sequence_number, 99);
    
    // Fast sync node: Sync to same version
    let mut fast_sync_node = create_test_node_with_fast_sync();
    fast_sync_node.fast_sync_to_version(target_version).unwrap();
    
    // Wait for internal indexer to process events
    wait_for_indexer_catchup(&fast_sync_node, target_version).await;
    
    // Fast sync node: Check event sequence numbers
    let fast_sync_events = fast_sync_node
        .get_events_by_key(&deposit_event_key, 0, 100, target_version)
        .unwrap();
    
    // BUG: Fast sync node has wrong sequence numbers!
    // It reads latest state (count=100) when processing first event
    assert_eq!(fast_sync_events[0].sequence_number, 100); // Should be 0!
    assert_eq!(fast_sync_events[99].sequence_number, 199); // Should be 99!
    
    // VULNERABILITY: Sequence number mismatch between nodes
    assert_ne!(genesis_events[0].sequence_number, 
               fast_sync_events[0].sequence_number);
}
```

## Notes

- This vulnerability is explicitly acknowledged in code comments but remains unfixed
- The `load_cache_from_db()` function was implemented anticipating this issue but never integrated
- Affects all fast-synced nodes including archival nodes, public indexers, and API providers
- Creates API inconsistency that application developers may not expect or handle correctly
- The issue compounds over time as more events accumulate with incorrect sequence numbers

### Citations

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L78-90)
```rust
            db_dir.push(SECONDARY_DB_DIR);
            let secondary_db = AptosDB::open(
                StorageDirPaths::from_path(db_dir.as_path()),
                /*readonly=*/ false,
                config.storage.storage_pruner_config,
                config.storage.rocksdb_configs,
                config.storage.enable_indexer,
                config.storage.buffered_state_target_items,
                config.storage.max_num_nodes_per_lru_cache_shard,
                None,
                config.storage.hot_state_config,
            )
            .map_err(|err| anyhow!("Secondary DB failed to open {}", err))?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L102-106)
```rust
        let start_version = self
            .db_indexer
            .indexer_db
            .get_persisted_version()?
            .map_or(0, |v| v + 1);
```

**File:** storage/indexer/src/event_v2_translator.rs (L163-177)
```rust
    // When the node starts with a non-empty EventSequenceNumberSchema table, the in-memory cache
    // `event_sequence_number_cache` is empty. In the future, we decide to backup and restore the
    // event sequence number data to support fast sync, we may need to load the cache from the DB
    // when the node starts using this function `load_cache_from_db`.
    pub fn load_cache_from_db(&self) -> Result<()> {
        let mut iter = self
            .internal_indexer_db
            .iter::<EventSequenceNumberSchema>()?;
        iter.seek_to_first();
        while let Some((event_key, sequence_number)) = iter.next().transpose()? {
            self.event_sequence_number_cache
                .insert(event_key, sequence_number);
        }
        Ok(())
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L190-200)
```rust
    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
        if let Some(seq) = self.get_cached_sequence_number(event_key) {
            Ok(seq + 1)
        } else {
            let seq = self
                .internal_indexer_db
                .get::<EventSequenceNumberSchema>(event_key)?
                .map_or(default, |seq| seq + 1);
            Ok(seq)
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L207-214)
```rust
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        let state_key = StateKey::resource(address, struct_tag)?;
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L248-257)
```rust
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_deposit.account(), &struct_tag)?
        {
            // We can use `DummyCoinType` as it does not affect the correctness of deserialization.
            let coin_store_resource: CoinStoreResource<DummyCoinType> =
                bcs::from_bytes(&state_value_bytes)?;
            let key = *coin_store_resource.deposit_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, coin_store_resource.deposit_events().count())?;
            (key, sequence_number)
```
