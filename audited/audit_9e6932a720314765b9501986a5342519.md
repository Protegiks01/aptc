# Audit Report

## Title
Governance-Controlled Consensus Config Byte Limit Can Halt Network Through DKG Transaction Exclusion

## Summary
The `per_block_limit_total_bytes` parameter in `ValidatorTxnConfig` can be set to arbitrarily small values (e.g., 1 byte) through governance proposals without validation, effectively preventing DKG (Distributed Key Generation) transactions from being included in blocks. When randomness is enabled, this causes epoch transitions to fail and halts the network indefinitely. [1](#0-0) 

## Finding Description

The vulnerability exists in the consensus configuration update mechanism. When governance calls `consensus_config::set_for_next_epoch()`, the only validation performed is checking that the config bytes are non-empty. No validation exists on the actual values within the `ValidatorTxnConfig`, including `per_block_limit_total_bytes`. [2](#0-1) 

This limit is enforced during proposal creation and validation: [3](#0-2) [4](#0-3) 

**Attack Flow:**

1. A malicious governance participant submits a proposal containing `ValidatorTxnConfig::V1 { per_block_limit_txn_count: 2, per_block_limit_total_bytes: 1 }`
2. The proposal passes governance voting (requires voting power)
3. At next epoch boundary, `consensus_config::on_new_epoch()` applies the malicious config
4. When epoch timeout occurs, `block_prologue_ext()` triggers `reconfiguration_with_dkg::try_start()` [5](#0-4) 

5. DKG session starts, validators attempt to generate and submit DKG result transactions
6. DKG transactions are typically 1KB-14KB in size (depending on validator set size), calculated as approximately `96 + (n + 1) * 144 bytes` for n validators [6](#0-5) 

7. With a 1-byte limit, validators cannot pull DKG transactions into their proposals, as the limit constrains payload client operations
8. Without DKG result transactions being included, `dkg::finish()` cannot be called [7](#0-6) 

9. The DKG session remains in `in_progress` state indefinitely
10. Epoch transition cannot complete, network consensus halts

## Impact Explanation

This vulnerability causes **total loss of network liveness** when randomness is enabled, meeting the **Critical severity** criteria of "Total loss of liveness/network availability". However, since recovery is possible through:
- `aptos_governance::force_end_epoch()` to bypass DKG
- Validator operator manual configuration using `randomness_override_seq_num`

The issue is more appropriately classified as **High severity** ($50,000 category): "Significant protocol violations" causing extended network downtime requiring coordinated manual intervention across all validators. [8](#0-7) 

## Likelihood Explanation

**Likelihood: Medium-Low**

Execution requires:
- Governance proposal submission capability (anyone can submit)
- Sufficient voting power to pass proposal (requires stake or convincing legitimate voters)
- Randomness feature enabled (standard on mainnet)
- Network to reach epoch timeout after malicious config applied

While governance attacks require social/economic effort, the lack of validation makes exploitation straightforward once voting power is obtained. A compromised validator account with voting rights or coordination among malicious governance participants could execute this attack.

## Recommendation

Add validation in the `set_for_next_epoch()` function to enforce minimum safe values:

```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // Add validation to ensure values are within safe bounds
    let consensus_config: ConsensusConfig = bcs::to_bytes(&config);
    validate_consensus_config(&consensus_config); // New validation function
    
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}

// New validation function
fun validate_consensus_config(config: &ConsensusConfig) {
    // For V1 validator txn config, ensure limits are reasonable
    // Minimum 100KB to accommodate DKG transactions for large validator sets
    const MIN_VTXN_BYTES_LIMIT: u64 = 102400; // 100KB
    const MIN_VTXN_COUNT_LIMIT: u64 = 1;
    
    if (config.is_vtxn_enabled()) {
        assert!(
            config.per_block_limit_total_bytes() >= MIN_VTXN_BYTES_LIMIT,
            error::invalid_argument(EINVALID_VTXN_BYTES_LIMIT)
        );
        assert!(
            config.per_block_limit_txn_count() >= MIN_VTXN_COUNT_LIMIT,
            error::invalid_argument(EINVALID_VTXN_COUNT_LIMIT)
        );
    }
}
```

Additionally, add validation in Rust during deserialization: [9](#0-8) 

Update `VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT` to be a checked minimum rather than just a default.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
fun test_malicious_vtxn_byte_limit(aptos_framework: &signer) {
    use aptos_framework::consensus_config;
    use aptos_framework::reconfiguration_with_dkg;
    use aptos_framework::timestamp;
    
    // Initialize consensus config with normal values
    consensus_config::initialize(aptos_framework, create_valid_config());
    
    // Malicious actor submits governance proposal with 1-byte limit
    let malicious_config = create_malicious_config_with_1_byte_limit();
    consensus_config::set_for_next_epoch(aptos_framework, malicious_config);
    
    // Trigger epoch transition
    consensus_config::on_new_epoch(aptos_framework);
    
    // Advance time past epoch interval
    timestamp::update_global_time(aptos_framework, 7200000000); // 2 hours
    
    // Attempt to start DKG - this will succeed
    reconfiguration_with_dkg::try_start();
    
    // Now validators attempt to create proposals with DKG transactions
    // DKG transaction size will be > 1 byte (typically 1KB+)
    // Proposals will either exclude DKG transactions or be rejected
    
    // Network halts: DKG cannot complete, epoch cannot transition
    assert!(dkg::incomplete_session().is_some(), 0); // DKG stuck in progress
}

fun create_malicious_config_with_1_byte_limit(): vector<u8> {
    let config = ConsensusConfig::V5 {
        alg: /* normal config */,
        vtxn: ValidatorTxnConfig::V1 {
            per_block_limit_txn_count: 2,
            per_block_limit_total_bytes: 1, // MALICIOUS: Only 1 byte allowed
        },
        window_size: None,
        rand_check_enabled: true,
    };
    bcs::to_bytes(&config)
}
```

**Notes:**
- This is a governance-level attack requiring voting power, placing it at the boundary of the threat model
- The vulnerability is in the LACK OF VALIDATION, not governance itself
- Recovery requires coordinated manual intervention across all validators or emergency governance action
- The default 2MB limit is safe; the issue is that any value (including unsafe ones) can be set without validation

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L125-127)
```rust
const VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT: u64 = 2;
const VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT: u64 = 2097152; //2MB

```

**File:** types/src/on_chain_config/consensus_config.rs (L179-187)
```rust
    pub fn per_block_limit_total_bytes(&self) -> u64 {
        match self {
            ValidatorTxnConfig::V0 => 0,
            ValidatorTxnConfig::V1 {
                per_block_limit_total_bytes,
                ..
            } => *per_block_limit_total_bytes,
        }
    }
```

**File:** consensus/src/payload_client/mixed.rs (L73-76)
```rust
                min(
                    params.max_txns.size_in_bytes(),
                    self.validator_txn_config.per_block_limit_total_bytes(),
                ),
```

**File:** consensus/src/round_manager.rs (L1172-1177)
```rust
        ensure!(
            validator_txns_total_bytes <= vtxn_bytes_limit,
            "process_proposal failed with per-block vtxn bytes limit exceeded: limit={}, actual={}",
            self.vtxn_config.per_block_limit_total_bytes(),
            validator_txns_total_bytes
        );
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L244-246)
```text
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration_with_dkg::try_start();
        };
```

**File:** crates/aptos-crypto/src/blstrs/mod.rs (L27-31)
```rust
/// The size in bytes of a compressed G1 point (efficiently deserializable into projective coordinates)
pub const G1_PROJ_NUM_BYTES: usize = 48;

/// The size in bytes of a compressed G2 point (efficiently deserializable into projective coordinates)
pub const G2_PROJ_NUM_BYTES: usize = 96;
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L90-97)
```text
    public(friend) fun finish(transcript: vector<u8>) acquires DKGState {
        let dkg_state = borrow_global_mut<DKGState>(@aptos_framework);
        assert!(option::is_some(&dkg_state.in_progress), error::invalid_state(EDKG_NOT_IN_PROGRESS));
        let session = option::extract(&mut dkg_state.in_progress);
        session.transcript = transcript;
        dkg_state.last_completed = option::some(session);
        dkg_state.in_progress = option::none();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```
