# Audit Report

## Title
Consensus Observer Message Starvation via select_all() Stream Unfairness and FIFO Channel Saturation

## Summary
The consensus observer's use of `select_all()` to merge network streams from multiple NetworkIds (Validator, Vfn, Public) combined with a shared FIFO channel can be exploited by an attacker to cause message starvation. By flooding messages from an untrusted network (Public/Vfn), an attacker can fill the bounded channel, causing legitimate messages from the trusted Validator network to be dropped, forcing the observer into fallback mode.

## Finding Description

The vulnerability exists in how consensus observer network events are merged and processed: [1](#0-0) 

The `select_all()` function from the futures crate merges multiple network event streams without fairness guarantees. Combined with the FIFO channel behavior where **newest messages are dropped when full**, this creates a message starvation vulnerability. [2](#0-1) 

The attack path:

1. **Network Setup**: VFN nodes run consensus observer and accept connections from multiple NetworkIds. Public/Vfn networks use MaybeMutual authentication, allowing non-validator connections. [3](#0-2) 

2. **Single Shared Channel**: All NetworkIds share one FIFO channel (default size: 1000 messages). [4](#0-3) 

3. **Late Validation**: Subscription validation occurs AFTER messages are queued and dequeued, not before. [5](#0-4) 

4. **Attack Execution**:
   - Attacker connects to VFN's Public/Vfn network (up to 100 inbound connections allowed)
   - Floods ConsensusObserver protocol messages at network rate limit (100 KiB/s per IP = 10 MiB/s total)
   - Messages pass through `select_all()`, which has no fairness mechanism between streams
   - Channel fills with 1000 attacker messages awaiting processing
   - New legitimate messages from Validator network arrive
   - FIFO channel drops the newest (legitimate) messages
   - Observer processes attacker messages, rejects them (not subscribed), but legitimate messages already lost [6](#0-5) 

## Impact Explanation

**Medium Severity** - This vulnerability causes denial of service for consensus observer functionality:

- **Availability Impact**: VFN consensus observer falls behind due to dropped legitimate messages
- **Forced Fallback**: Observer enters fallback mode, requiring state sync intervention
- **Service Degradation**: Observer cannot maintain real-time consensus visibility during attack
- **Infrastructure Impact**: Affects VFN infrastructure supporting validator operations

This meets the **Medium severity** criteria of "State inconsistencies requiring intervention" as the observer state diverges from validator consensus state, requiring fallback mode and state sync recovery. [7](#0-6) 

Importantly, this does NOT affect core consensus safety (validators continue operating normally), does not cause fund loss, and has a recovery mechanism, preventing it from being High or Critical severity.

## Likelihood Explanation

**Medium Likelihood** - The attack is realistic but has some barriers:

**Attacker Requirements**:
- Ability to connect to VFN's Public/Vfn network (achievable - MaybeMutual auth accepts all connections)
- Ability to send properly formatted ConsensusObserver protocol messages
- Multiple connection sources to maximize flooding rate (up to 100 IPs)

**Mitigating Factors**:
- Network rate limiting (100 KiB/s per IP) reduces individual flood rate
- Fast subscription validation (HashMap lookup) enables quick rejection
- Observer may process messages faster than attacker can send them

**Realistic Scenario**: An attacker with moderate resources (100 IP addresses) sending small ConsensusObserver messages (10 KB each) at rate limit (~1000 messages/second total) can plausibly saturate the 1000-message channel faster than the observer drains it, especially during burst periods or if observer processing is temporarily slowed.

## Recommendation

Implement multi-layered defenses:

**1. Early Peer Validation** - Filter messages from non-subscribed peers BEFORE channel insertion:

```rust
// In network_handler.rs, handle_observer_message():
fn handle_observer_message(
    &mut self,
    peer_network_id: PeerNetworkId,
    message: ConsensusObserverDirectSend,
) {
    if !self.consensus_observer_config.observer_enabled {
        return;
    }
    
    // NEW: Early validation before channel push
    if !self.is_subscribed_peer(peer_network_id) {
        warn!("Dropping message from non-subscribed peer: {}", peer_network_id);
        metrics::increment_counter(&metrics::DROPPED_NON_SUBSCRIBED_MESSAGES, peer_network_id);
        return;
    }
    
    let network_message = ConsensusObserverNetworkMessage::new(peer_network_id, message);
    if let Err(error) = self.observer_message_sender.push((), network_message) {
        error!("Failed to forward observer message: {:?}", error);
    }
}
```

**2. Per-NetworkId Channels** - Use separate channels for each NetworkId with different priorities:

```rust
// Create prioritized channels
let (validator_sender, validator_receiver) = aptos_channel::new(QueueStyle::FIFO, 1000, None);
let (vfn_sender, vfn_receiver) = aptos_channel::new(QueueStyle::FIFO, 500, None);
let (public_sender, public_receiver) = aptos_channel::new(QueueStyle::FIFO, 100, None);

// Process with priority: validator > vfn > public
tokio::select! {
    biased; // Process in order
    Some(msg) = validator_receiver.next() => process(msg),
    Some(msg) = vfn_receiver.next() => process(msg),
    Some(msg) = public_receiver.next() => process(msg),
}
```

**3. Fair Stream Merging** - Replace `select_all()` with a fair round-robin implementation:

```rust
// Use a custom fair merger instead of select_all()
let network_events = FairStreamMerger::new(network_events).fuse();
```

## Proof of Concept

```rust
// Rust integration test demonstrating the vulnerability

#[tokio::test]
async fn test_consensus_observer_message_starvation() {
    // Setup: Create VFN with consensus observer enabled
    let mut node_config = NodeConfig::default();
    node_config.consensus_observer.observer_enabled = true;
    node_config.consensus_observer.max_network_channel_size = 10; // Small for testing
    
    // Create network interfaces for Validator and Public networks
    let network_ids = vec![NetworkId::Validator, NetworkId::Public];
    let peers_and_metadata = PeersAndMetadata::new(&network_ids);
    
    // Create attacker peer on Public network
    let attacker_peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    let legitimate_peer = PeerNetworkId::new(NetworkId::Validator, PeerId::random());
    
    // Setup network sender and receiver
    let (network_senders, network_events, _, mut inbound_senders) = 
        create_network_sender_and_events(&network_ids);
    
    let observer_events = ConsensusObserverNetworkEvents::new(network_events);
    let (handler, mut observer_receiver, _) = 
        ConsensusObserverNetworkHandler::new(node_config.consensus_observer, observer_events);
    
    tokio::spawn(handler.start());
    
    // Attack: Flood from Public network (attacker)
    let attacker_sender = inbound_senders.get_mut(&NetworkId::Public).unwrap();
    for i in 0..100 {
        let fake_message = ConsensusObserverMessage::new_ordered_block_message(
            vec![],
            create_dummy_ledger_info(),
        );
        send_message(attacker_sender, attacker_peer, fake_message);
    }
    
    // Legitimate message from Validator network
    let validator_sender = inbound_senders.get_mut(&NetworkId::Validator).unwrap();
    let legitimate_message = ConsensusObserverMessage::new_ordered_block_message(
        vec![],
        create_legitimate_ledger_info(),
    );
    send_message(validator_sender, legitimate_peer, legitimate_message);
    
    // Verify: Check if legitimate message was dropped
    let mut received_count = 0;
    let mut legitimate_received = false;
    
    while let Ok(Some(msg)) = timeout(Duration::from_secs(1), observer_receiver.next()).await {
        received_count += 1;
        if msg.peer_network_id == legitimate_peer {
            legitimate_received = true;
        }
    }
    
    // Assert: Legitimate message should be lost due to channel saturation
    assert!(!legitimate_received, "Legitimate message was not dropped - vulnerability not reproduced");
    assert!(received_count >= 10, "Channel should be saturated with attacker messages");
}
```

## Notes

This vulnerability specifically affects **Validator Full Nodes (VFNs)** running consensus observer, as they are the primary nodes configured with both observer enabled and connections to multiple network types (Validator + Public/Vfn). The attack does not affect core consensus safety on validators themselves, but degrades the observer infrastructure that supports validator operations. The vulnerability is a combination of architectural choices (shared channel, late validation, unfair stream merging) that together create an exploitable attack surface.

### Citations

**File:** consensus/src/consensus_observer/network/network_events.rs (L42-61)
```rust
    pub fn new(network_service_events: NetworkServiceEvents<ConsensusObserverMessage>) -> Self {
        // Transform the event streams to also include the network ID
        let network_events: Vec<_> = network_service_events
            .into_network_and_events()
            .into_iter()
            .map(|(network_id, events)| events.map(move |event| (network_id, event)))
            .collect();
        let network_events = select_all(network_events).fuse();

        // Transform each event to a network message
        let network_message_stream = network_events
            .filter_map(|(network_id, event)| {
                future::ready(Self::event_to_request(network_id, event))
            })
            .boxed();

        Self {
            network_message_stream,
        }
    }
```

**File:** crates/channel/src/message_queues.rs (L134-147)
```rust
        if key_message_queue.len() >= self.max_queue_size.get() {
            if let Some(c) = self.counters.as_ref() {
                c.with_label_values(&["dropped"]).inc();
            }
            match self.queue_style {
                // Drop the newest message for FIFO
                QueueStyle::FIFO => Some(message),
                // Drop the oldest message for LIFO
                QueueStyle::LIFO | QueueStyle::KLAST => {
                    let oldest = key_message_queue.pop_front();
                    key_message_queue.push_back(message);
                    oldest
                },
            }
```

**File:** consensus/src/consensus_observer/network/network_handler.rs (L94-98)
```rust
        let (observer_message_sender, observer_message_receiver) = aptos_channel::new(
            QueueStyle::FIFO,
            consensus_observer_config.max_network_channel_size as usize,
            None,
        );
```

**File:** config/src/consensus_observer_config.rs (L63-69)
```rust

```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L168-200)
```rust
    async fn check_progress(&mut self) {
        debug!(LogSchema::new(LogEntry::ConsensusObserver)
            .message("Checking consensus observer progress!"));

        // If we've fallen back to state sync, we should wait for it to complete
        if self.state_sync_manager.in_fallback_mode() {
            info!(LogSchema::new(LogEntry::ConsensusObserver)
                .message("Waiting for state sync to complete fallback syncing!",));
            return;
        }

        // If state sync is syncing to a commit decision, we should wait for it to complete
        if self.state_sync_manager.is_syncing_to_commit() {
            info!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Waiting for state sync to reach commit decision: {:?}!",
                    self.observer_block_data.lock().root().commit_info()
                ))
            );
            return;
        }

        // Check if we need to fallback to state sync
        if let Err(error) = self.observer_fallback_manager.check_syncing_progress() {
            // Log the error and enter fallback mode
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to make syncing progress! Entering fallback mode! Error: {:?}",
                    error
                ))
            );
            self.enter_fallback_mode().await;
            return;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L573-594)
```rust
    async fn process_network_message(&mut self, network_message: ConsensusObserverNetworkMessage) {
        // Unpack the network message and note the received time
        let message_received_time = Instant::now();
        let (peer_network_id, message) = network_message.into_parts();

        // Verify the message is from the peers we've subscribed to
        if let Err(error) = self
            .subscription_manager
            .verify_message_for_subscription(peer_network_id)
        {
            // Update the rejected message counter
            increment_rejected_message_counter(&peer_network_id, &message);

            // Log the error and return
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received message that was not from an active subscription! Error: {:?}",
                    error,
                ))
            );
            return;
        }
```

**File:** config/src/config/network_config.rs (L173-175)
```rust
        config.prepare_identity();

        config
```
