# Audit Report

## Title
Missing Validation for max_pruned_blocks_in_mem Allows Network Sync Degradation Through Immediate Block Pruning

## Summary
The `max_pruned_blocks_in_mem` configuration parameter lacks validation to prevent being set to 0, which causes immediate removal of all pruned blocks from memory and persistent storage, severely degrading the network's ability to serve blocks to syncing peers.

## Finding Description

The consensus system maintains a buffer of recently pruned blocks in memory to enable peers to retrieve them during synchronization. This buffer size is controlled by `max_pruned_blocks_in_mem`, which defaults to 100 but has no minimum value validation. [1](#0-0) 

When set to 0, the `process_pruned_blocks()` function immediately removes ALL pruned blocks from the in-memory block tree: [2](#0-1) 

The critical logic is:
- Line 502: When `pruned_block_ids.len() > 0` (always true after pruning)
- Line 503: `num_blocks_to_remove = pruned_block_ids.len() - 0 = all blocks`
- Lines 505-507: All pruned blocks are removed via `remove_block()`

These blocks are also permanently deleted from persistent storage: [3](#0-2) 

When peers request blocks via `process_block_retrieval_inner()`, the function only checks in-memory storage: [4](#0-3) 

If blocks don't exist (removed due to max_pruned_blocks_in_mem=0), the request fails with `BlockRetrievalStatus::NotEnoughBlocks` or `BlockRetrievalStatus::IdNotFound`.

The existence of this issue is confirmed by test code that explicitly marks it as expected failure: [5](#0-4) 

## Impact Explanation

**Severity: High** - This qualifies as "Validator node slowdowns" and "Significant protocol violations" per the Aptos bug bounty program.

**Impact:**
1. **Network-Wide Sync Degradation**: Validators with max_pruned_blocks_in_mem=0 cannot serve recently committed blocks to peers
2. **Forced Expensive State Sync**: Lagging peers must resort to full state synchronization instead of efficient block-by-block consensus sync
3. **Cascading Liveness Issues**: If multiple validators misconfigure this parameter, network synchronization capability is severely compromised
4. **Not Critical Data Loss**: Transaction data remains in ledger state; only block metadata becomes unavailable

The comment in block_tree.rs explicitly states the purpose of this buffer: [6](#0-5) 

## Likelihood Explanation

**Likelihood: Medium to Low**
- Requires operator misconfiguration (setting to 0 instead of default 100)
- No validation exists to prevent this misconfiguration
- Default value is safe (100)
- Could potentially affect production systems if operators misunderstand the parameter's purpose
- Test infrastructure uses values as low as 10, which might mislead operators about safe minimums

## Recommendation

Add validation in `ConsensusConfig::sanitize()` to enforce a minimum value:

```rust
// In consensus_config.rs, add to sanitize() method:
fn sanitize_pruned_blocks_limit(
    sanitizer_name: &str,
    config: &ConsensusConfig,
) -> Result<(), Error> {
    const MIN_PRUNED_BLOCKS_IN_MEM: usize = 10;
    
    if config.max_pruned_blocks_in_mem < MIN_PRUNED_BLOCKS_IN_MEM {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name.to_owned(),
            format!(
                "max_pruned_blocks_in_mem must be at least {}, got {}",
                MIN_PRUNED_BLOCKS_IN_MEM,
                config.max_pruned_blocks_in_mem
            ),
        ));
    }
    Ok(())
}

// Call this in sanitize() method around line 529
Self::sanitize_pruned_blocks_limit(&sanitizer_name, &node_config.consensus)?;
```

## Proof of Concept

The existing test demonstrates the issue: [7](#0-6) 

To reproduce:
1. Configure a validator with `max_pruned_blocks_in_mem: 0`
2. Start consensus and commit blocks
3. Attempt block retrieval from a peer for recently committed blocks
4. Observe `BlockRetrievalStatus::IdNotFound` failures
5. Peer must fall back to expensive state sync

The test confirms that with max_pruned_blocks_in_mem=0, pruned blocks "no longer exist in the block_store" and accessing them causes failures.

## Notes

While this does not cause transaction data loss (ledger state is preserved), it breaks a critical network invariant: validators must be able to serve recent blocks to enable efficient peer synchronization. The lack of validation for this safety-critical parameter represents a significant operational risk that could impact network availability if widely misconfigured.

### Citations

**File:** config/src/config/consensus_config.rs (L232-232)
```rust
            max_pruned_blocks_in_mem: 100,
```

**File:** consensus/src/block_storage/block_tree.rs (L492-495)
```rust
    /// be interested in doing extra work e.g. delete from persistent storage.
    /// Note that we do not necessarily remove the pruned blocks: they're kept in a separate buffer
    /// for some time in order to enable other peers to retrieve the blocks even after they've
    /// been committed.
```

**File:** consensus/src/block_storage/block_tree.rs (L496-510)
```rust
    pub(super) fn process_pruned_blocks(&mut self, mut newly_pruned_blocks: VecDeque<HashValue>) {
        counters::NUM_BLOCKS_IN_TREE.sub(newly_pruned_blocks.len() as i64);
        // The newly pruned blocks are pushed back to the deque pruned_block_ids.
        // In case the overall number of the elements is greater than the predefined threshold,
        // the oldest elements (in the front of the deque) are removed from the tree.
        self.pruned_block_ids.append(&mut newly_pruned_blocks);
        if self.pruned_block_ids.len() > self.max_pruned_blocks_in_mem {
            let num_blocks_to_remove = self.pruned_block_ids.len() - self.max_pruned_blocks_in_mem;
            for _ in 0..num_blocks_to_remove {
                if let Some(id) = self.pruned_block_ids.pop_front() {
                    self.remove_block(id);
                }
            }
        }
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L591-596)
```rust
        if let Err(e) = storage.prune_tree(ids_to_remove.clone().into_iter().collect()) {
            // it's fine to fail here, as long as the commit succeeds, the next restart will clean
            // up dangling blocks, and we need to prune the tree to keep the root consistent with
            // executor.
            warn!(error = ?e, "fail to delete block");
        }
```

**File:** consensus/src/block_storage/sync_manager.rs (L543-565)
```rust
    pub async fn process_block_retrieval_inner(
        &self,
        request: &BlockRetrievalRequest,
    ) -> Box<BlockRetrievalResponse> {
        let mut blocks = vec![];
        let mut status = BlockRetrievalStatus::Succeeded;
        let mut id = request.block_id();

        match &request {
            BlockRetrievalRequest::V1(req) => {
                while (blocks.len() as u64) < req.num_blocks() {
                    if let Some(executed_block) = self.get_block(id) {
                        blocks.push(executed_block.block().clone());
                        if req.match_target_id(id) {
                            status = BlockRetrievalStatus::SucceededWithTarget;
                            break;
                        }
                        id = executed_block.parent_id();
                    } else {
                        status = BlockRetrievalStatus::NotEnoughBlocks;
                        break;
                    }
                }
```

**File:** consensus/src/block_storage/execution_pool/block_window_test.rs (L104-126)
```rust
/// `get_block_window` on a block that has been pruned. Should panic if the
/// `max_pruned_blocks_in_mem` is 0.
#[should_panic]
#[tokio::test]
async fn test_execution_pool_block_window_with_pruning_failure() {
    const NUM_BLOCKS: usize = 5;
    let window_size = Some(3u64);

    // No pruned blocks are not kept in the block store if this is set to 0
    let max_pruned_blocks_in_mem: usize = 0;
    let (_, block_store, pipelined_blocks) = create_block_tree_no_forks_inner::<{ NUM_BLOCKS }>(
        NUM_BLOCKS as u64,
        window_size,
        max_pruned_blocks_in_mem,
    )
    .await;
    let [_, _, a2, a3, _] = pipelined_blocks;

    block_store.prune_tree(a3.id());

    // a2 was pruned, no longer exists in the block_store
    get_blocks_from_block_store_and_window(block_store.clone(), a2.block(), window_size);
}
```
