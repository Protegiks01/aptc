# Audit Report

## Title
Missing HQC Consistency Validation in TwoChainTimeoutCertificate Verification Enables State Inconsistency Attacks

## Summary
The `SyncInfo::verify()` function fails to validate that the highest quorum certificate round is at least as high as the timeout certificate's highest HQC round, allowing Byzantine validators to inject inconsistent consensus state into victim nodes.

## Finding Description

The verification logic in `SyncInfo::verify()` validates timeout certificate signatures and cryptographic correctness, but omits a critical semantic check. When a `SyncInfo` message contains both a `highest_quorum_cert` and a `highest_2chain_timeout_cert`, there is no validation that the HQC round is consistent with the TC's embedded HQC round. [1](#0-0) 

The verification performs epoch consistency checks and calls `tc.verify(validator)` to validate signatures, but never compares `self.highest_quorum_cert.certified_block().round()` with `tc.highest_hqc_round()`. [2](#0-1) 

Meanwhile, the `TwoChainTimeoutCertificate::verify()` implementation validates internal consistency (signatures match HQC rounds) but has no knowledge of the surrounding SyncInfo context: [3](#0-2) 

**Attack Vector:**

A Byzantine validator can craft a malicious `SyncInfo` with:
- `highest_quorum_cert` at round 5
- `highest_2chain_timeout_cert` at round 11 with embedded HQC at round 10

When processed by `BlockStore::add_certs()`: [4](#0-3) 

The victim node syncs to HQC round 5, then inserts a TC referencing blocks at round 10 it doesn't possess. The TC insertion only checks round ordering: [5](#0-4) 

This creates state where the victim has a timeout certificate referencing consensus rounds beyond its own validated state, violating the **State Consistency** invariant that all certificates should reference validated, available blocks.

## Impact Explanation

**Medium Severity** - This vulnerability enables **state inconsistencies requiring manual intervention** per the bug bounty criteria.

The attack creates nodes with divergent internal state where:
1. The victim's `highest_quorum_cert` references round R1
2. The victim's `highest_2chain_timeout_cert` references HQC at round R2 where R2 > R1
3. The victim lacks blocks/QCs for rounds [R1+1, R2]

This inconsistency manifests when the victim broadcasts its `SyncInfo` to peers, who may attempt to sync blocks the victim cannot provide. The victim becomes a "poisoned" sync source.

While this does not directly break consensus safety (voting rules in `SafetyRules::safe_to_vote()` validate incoming block QCs independently), it degrades network health by:
- Creating sync deadlocks when peers request unavailable blocks
- Forcing nodes into recovery modes
- Reducing effective validator participation [6](#0-5) 

## Likelihood Explanation

**Medium Likelihood** - Requires Byzantine validator access but is straightforward to execute:

**Requirements:**
- Attacker must be a validator or compromise validator keys (Byzantine assumption)
- Attacker collects legitimate timeout votes from honest validators at round R
- Attacker identifies victim nodes lagging behind (common during network partitions)

**Execution Complexity:** Low
- No cryptographic forgery needed (all signatures are legitimate)
- No consensus mechanism exploitation required
- Simple message crafting with valid but semantically inconsistent components

**Real-world Scenarios:**
- Network partition causes some validators to lag
- Byzantine validator targets lagging nodes with inconsistent SyncInfo
- Lagging nodes accept malicious state and propagate it during recovery

The vulnerability is triggered passively through normal sync protocols, making detection difficult.

## Recommendation

Add explicit HQC consistency validation in `SyncInfo::verify()`:

```rust
pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
    // ... existing epoch and round checks ...
    
    if let Some(tc) = &self.highest_2chain_timeout_cert {
        ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
        
        // ADD THIS CHECK:
        ensure!(
            self.highest_quorum_cert.certified_block().round() >= tc.highest_hqc_round(),
            "SyncInfo HQC round {} is lower than TC's HQC round {}",
            self.highest_quorum_cert.certified_block().round(),
            tc.highest_hqc_round()
        );
    }
    
    // ... rest of verification ...
}
```

This enforces the invariant that if a node possesses a timeout certificate, it must also possess (or have access to) the highest QC referenced by that certificate.

## Proof of Concept

```rust
#[test]
fn test_syncinfo_hqc_tc_inconsistency_detection() {
    use aptos_consensus_types::{
        block::Block,
        quorum_cert::QuorumCert,
        sync_info::SyncInfo,
        timeout_2chain::{TwoChainTimeout, TwoChainTimeoutWithPartialSignatures},
        vote_data::VoteData,
    };
    use aptos_crypto::hash::CryptoHash;
    use aptos_types::{
        aggregate_signature::PartialSignatures,
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        validator_verifier::random_validator_verifier,
    };

    let (signers, validators) = random_validator_verifier(4, None, false);
    
    // Create QC at round 5 (victim's HQC)
    let vote_data_r5 = VoteData::new(BlockInfo::random(5), BlockInfo::random(0));
    let mut li_r5 = LedgerInfoWithSignatures::new(
        LedgerInfo::new(BlockInfo::empty(), vote_data_r5.hash()),
        PartialSignatures::empty(),
    );
    for signer in &signers {
        li_r5.add_signature(signer.author(), signer.sign(li_r5.ledger_info()).unwrap());
    }
    let qc_r5 = QuorumCert::new(vote_data_r5, li_r5.aggregate_signatures(&validators).unwrap());
    
    // Create QC at round 10 (TC's embedded HQC)
    let vote_data_r10 = VoteData::new(BlockInfo::random(10), BlockInfo::random(0));
    let mut li_r10 = LedgerInfoWithSignatures::new(
        LedgerInfo::new(BlockInfo::empty(), vote_data_r10.hash()),
        PartialSignatures::empty(),
    );
    for signer in &signers {
        li_r10.add_signature(signer.author(), signer.sign(li_r10.ledger_info()).unwrap());
    }
    let qc_r10 = QuorumCert::new(vote_data_r10, li_r10.aggregate_signatures(&validators).unwrap());
    
    // Create TC at round 11 with HQC at round 10
    let timeout = TwoChainTimeout::new(1, 11, qc_r10);
    let mut tc_partial = TwoChainTimeoutWithPartialSignatures::new(timeout.clone());
    for signer in &signers {
        tc_partial.add(
            signer.author(),
            timeout.clone(),
            timeout.sign(signer).unwrap(),
            Default::default(),
        );
    }
    let tc = tc_partial.aggregate_signatures(&validators).unwrap();
    
    // Create malicious SyncInfo with HQC at round 5, TC at round 11 (TC's HQC is round 10)
    let wrapped_commit = qc_r5.clone().into_wrapped_ledger_info();
    let sync_info = SyncInfo::new(qc_r5, wrapped_commit, Some(tc));
    
    // This SHOULD fail but currently PASSES
    let result = sync_info.verify(&validators);
    
    // The vulnerability: verification succeeds despite inconsistency
    assert!(result.is_err(), "SyncInfo with HQC round 5 and TC HQC round 10 should be rejected");
}
```

**Notes**

This vulnerability represents a **defensive programming gap** in consensus state validation. While it does not enable direct consensus safety violations (vote forgery, equivocation), it creates attack surface for state poisoning that degrades network reliability. The fix is straightforward: enforce the semantic invariant that timeout certificates cannot reference rounds beyond the node's validated highest QC. This aligns with the 2-chain protocol's requirement that all consensus artifacts must chain properly from previously certified state.

### Citations

**File:** consensus/consensus-types/src/sync_info.rs (L138-212)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let epoch = self.highest_quorum_cert.certified_block().epoch();
        ensure!(
            epoch == self.highest_ordered_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HQC"
        );
        ensure!(
            epoch == self.highest_commit_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HCC"
        );
        if let Some(tc) = &self.highest_2chain_timeout_cert {
            ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
        }

        ensure!(
            self.highest_quorum_cert.certified_block().round()
                >= self.highest_ordered_cert().commit_info().round(),
            "HQC has lower round than HOC"
        );

        ensure!(
            self.highest_ordered_round() >= self.highest_commit_round(),
            format!(
                "HOC {} has lower round than HLI {}",
                self.highest_ordered_cert(),
                self.highest_commit_cert()
            )
        );

        ensure!(
            *self.highest_ordered_cert().commit_info() != BlockInfo::empty(),
            "HOC has no committed block"
        );

        ensure!(
            *self.highest_commit_cert().commit_info() != BlockInfo::empty(),
            "HLI has empty commit info"
        );

        // we don't have execution in unit tests, so this check would fail
        #[cfg(not(any(test, feature = "fuzzing")))]
        {
            ensure!(
                !self.highest_commit_cert().commit_info().is_ordered_only(),
                "HLI {} has ordered only commit info",
                self.highest_commit_cert().commit_info()
            );
        }

        self.highest_quorum_cert
            .verify(validator)
            .and_then(|_| {
                self.highest_ordered_cert
                    .as_ref()
                    .map_or(Ok(()), |cert| cert.verify(validator))
                    .context("Fail to verify ordered certificate")
            })
            .and_then(|_| {
                // we do not verify genesis ledger info
                if self.highest_commit_cert.commit_info().round() > 0 {
                    self.highest_commit_cert
                        .verify(validator)
                        .context("Fail to verify commit certificate")?
                }
                Ok(())
            })
            .and_then(|_| {
                if let Some(tc) = &self.highest_2chain_timeout_cert {
                    tc.verify(validator)?;
                }
                Ok(())
            })
            .context("Fail to verify SyncInfo")?;
        Ok(())
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L141-183)
```rust
    pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
        let hqc_round = self.timeout.hqc_round();
        // Verify the highest timeout validity.
        let (timeout_result, sig_result) = rayon::join(
            || self.timeout.verify(validators),
            || {
                let timeout_messages: Vec<_> = self
                    .signatures_with_rounds
                    .get_voters_and_rounds(
                        &validators
                            .get_ordered_account_addresses_iter()
                            .collect_vec(),
                    )
                    .into_iter()
                    .map(|(_, round)| TimeoutSigningRepr {
                        epoch: self.timeout.epoch(),
                        round: self.timeout.round(),
                        hqc_round: round,
                    })
                    .collect();
                let timeout_messages_ref: Vec<_> = timeout_messages.iter().collect();
                validators.verify_aggregate_signatures(
                    &timeout_messages_ref,
                    self.signatures_with_rounds.sig(),
                )
            },
        );
        timeout_result?;
        sig_result?;
        let signed_hqc = self
            .signatures_with_rounds
            .rounds()
            .iter()
            .max()
            .ok_or_else(|| anyhow::anyhow!("Empty rounds"))?;
        ensure!(
            hqc_round == *signed_hqc,
            "Inconsistent hqc round, qc has round {}, highest signed round {}",
            hqc_round,
            *signed_hqc
        );
        Ok(())
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L116-173)
```rust
    pub async fn add_certs(
        &self,
        sync_info: &SyncInfo,
        mut retriever: BlockRetriever,
    ) -> anyhow::Result<()> {
        // When the local ordered round is very old than the received sync_info, this function will
        // (1) resets the block store with highest commit cert = sync_info.highest_quorum_cert()
        // (2) insert all the blocks between (inclusive) highest_commit_cert.commit_info().id() to
        // highest_quorum_cert.certified_block().id() into the block store and storage
        // (3) insert the quorum cert for all the above blocks into the block store and storage
        // (4) executes all the blocks that are ordered while inserting the above quorum certs
        self.sync_to_highest_quorum_cert(
            sync_info.highest_quorum_cert().clone(),
            sync_info.highest_commit_cert().clone(),
            &mut retriever,
        )
        .await?;

        self.sync_to_highest_commit_cert(
            sync_info.highest_commit_cert().ledger_info(),
            retriever.network.clone(),
        )
        .await;

        // The insert_ordered_cert(order_cert) function call expects that order_cert.commit_info().id() block
        // is already stored in block_store. So, we first call insert_quorum_cert(highest_quorum_cert).
        // This call will ensure that the highest ceritified block along with all its ancestors are inserted
        // into the block store.
        self.insert_quorum_cert(sync_info.highest_quorum_cert(), &mut retriever)
            .await?;

        // Even though we inserted the highest_quorum_cert (and its ancestors) in the above step,
        // we still need to insert ordered cert explicitly. This will send the highest ordered block
        // to execution.
        if self.order_vote_enabled {
            self.insert_ordered_cert(&sync_info.highest_ordered_cert())
                .await?;
        } else {
            // When order votes are disabled, the highest_ordered_cert().certified_block().id() need not be
            // one of the ancestors of highest_quorum_cert.certified_block().id() due to forks. So, we call
            // insert_quorum_cert instead of insert_ordered_cert as in the above case. This will ensure that
            // highest_ordered_cert().certified_block().id() is inserted the block store.
            self.insert_quorum_cert(
                &self
                    .highest_ordered_cert()
                    .as_ref()
                    .clone()
                    .into_quorum_cert(self.order_vote_enabled)?,
                &mut retriever,
            )
            .await?;
        }

        if let Some(tc) = sync_info.highest_2chain_timeout_cert() {
            self.insert_2chain_timeout_certificate(Arc::new(tc.clone()))?;
        }
        Ok(())
    }
```

**File:** consensus/src/block_storage/block_store.rs (L560-575)
```rust
    pub fn insert_2chain_timeout_certificate(
        &self,
        tc: Arc<TwoChainTimeoutCertificate>,
    ) -> anyhow::Result<()> {
        let cur_tc_round = self
            .highest_2chain_timeout_cert()
            .map_or(0, |tc| tc.round());
        if tc.round() <= cur_tc_round {
            return Ok(());
        }
        self.storage
            .save_highest_2chain_timeout_cert(tc.as_ref())
            .context("Timeout certificate insert failed when persisting to DB")?;
        self.inner.write().replace_2chain_timeout_cert(tc);
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L150-166)
```rust
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```
