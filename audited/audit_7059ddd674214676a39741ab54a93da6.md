# Audit Report

## Title
Transaction Filter Bypass via Consensus Path Due to Independent Filter Configuration

## Summary
The Aptos transaction filtering system uses separate, independently configured filters for mempool submission (`mempool_filter`) and consensus block validation (`consensus_filter`). This allows transactions rejected by mempool filtering with `RejectedByFilter(7)` status to bypass the filtering policy by being included in block proposals, as the consensus validation path uses a different filter configuration with no consistency enforcement.

## Finding Description

The Aptos codebase implements multiple transaction filters at different layers: [1](#0-0) 

These filters operate independently at different validation points:

**Mempool Submission Path:**
When transactions are submitted via API or peer broadcast, they pass through `process_incoming_transactions()` which applies `filter_transactions()`: [2](#0-1) 

The filtering uses `transaction_filter_config` (mempool_filter): [3](#0-2) 

Transactions denied by this filter receive `MempoolStatusCode::RejectedByFilter`: [4](#0-3) 

**Consensus Validation Path:**
When validators receive block proposals, they validate inline transactions using a DIFFERENT filter (`consensus_filter`): [5](#0-4) 

This consensus validation path uses `BlockTransactionFilterConfig` (consensus_filter), not the mempool filter: [6](#0-5) 

**The Vulnerability:**
Since these filters are independently configured with no consistency enforcement, the following attack scenario is possible:

1. Transaction X is submitted to Node A
2. Node A's `mempool_filter` rejects X â†’ returns `RejectedByFilter(7)`
3. Transaction X is submitted to Node B with looser/different `mempool_filter`
4. Node B's mempool accepts transaction X
5. Node B becomes block proposer and includes X in a block proposal
6. Node A receives the proposal and validates using its `consensus_filter`
7. If Node A's `consensus_filter` is configured differently than its `mempool_filter`, the proposal is accepted
8. Transaction X executes on Node A, bypassing the intended filtering policy

This violates the security guarantee that transactions rejected by filtering policies should never be executed.

## Impact Explanation

**Severity: High**

This vulnerability allows policy bypass of transaction filtering mechanisms. The impact includes:

1. **Policy Violation**: Transactions explicitly denied by operators through mempool filtering can still be executed via the consensus path
2. **Compliance Bypass**: Regulatory or operational policies enforced through transaction filtering can be circumvented
3. **Inconsistent Security Posture**: Different nodes may have inconsistent enforcement of the same security policies

While this doesn't directly result in fund theft or consensus safety violations, it represents a **significant protocol violation** as it allows transactions that should be filtered to bypass security controls. Per the Aptos bug bounty criteria, significant protocol violations fall under **High Severity** ($50,000 category).

The vulnerability becomes critical in scenarios where transaction filtering is used to:
- Block transactions from sanctioned addresses
- Prevent specific attack patterns
- Enforce network-wide security policies

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability can manifest in several realistic scenarios:

1. **Configuration Drift**: During system updates or migrations, operators may update `mempool_filter` without updating `consensus_filter` accordingly, creating configuration inconsistency

2. **Multi-Operator Networks**: In networks with multiple independent operators, different nodes may intentionally or accidentally configure filters differently

3. **Default Configuration**: The default configuration disables filters: [7](#0-6) 

This makes it easy for operators to enable only one filter type without realizing the need for consistency.

4. **Lack of Documentation**: There's no explicit requirement or validation enforcing that `mempool_filter` and `consensus_filter` must be configured identically.

The attack requires no special privileges - any transaction sender can exploit inconsistent configurations if they exist.

## Recommendation

**Immediate Fix: Add Configuration Validation**

Add validation at node startup to enforce consistency between mempool and consensus filters:

```rust
// In aptos-node startup validation
impl TransactionFiltersConfig {
    pub fn validate(&self) -> Result<(), Error> {
        // Ensure mempool_filter and consensus_filter are consistent
        if self.mempool_filter.is_enabled() || self.consensus_filter.is_enabled() {
            warn!("Transaction filters enabled. Ensure mempool_filter and consensus_filter are consistent!");
            
            // Optionally enforce strict consistency
            if self.mempool_filter.is_enabled() != self.consensus_filter.is_enabled() {
                return Err(anyhow!("mempool_filter and consensus_filter must both be enabled or disabled"));
            }
        }
        Ok(())
    }
}
```

**Better Fix: Unified Filter**

Refactor to use a single unified filter configuration applied at all validation points:

```rust
pub struct TransactionFiltersConfig {
    pub unified_filter: UnifiedTransactionFilterConfig,  // Single source of truth
    pub api_filter: TransactionFilterConfig,            // API-specific only
}

impl UnifiedTransactionFilterConfig {
    pub fn apply_at_mempool(&self, txn: &SignedTransaction) -> bool {
        self.transaction_filter.allows_transaction(txn)
    }
    
    pub fn apply_at_consensus(&self, block: &Block) -> Result<()> {
        // Use same filter for consensus validation
        self.check_block_transactions(block)
    }
}
```

**Additional Recommendations:**

1. Add network-wide configuration consistency checks
2. Document the relationship between different filter types
3. Implement monitoring/alerting for filter configuration drift across nodes
4. Consider making filter consistency a consensus requirement

## Proof of Concept

The test suite already demonstrates the separation: [8](#0-7) 

To demonstrate the bypass:

```rust
#[tokio::test]
async fn test_filter_bypass_via_consensus() {
    let (private_key, sender_address) = create_sender_account();
    
    // Create swarm where:
    // - Node 0: Strict mempool_filter, loose consensus_filter
    // - Node 1: Loose mempool_filter (allows sender)
    let mut swarm = SwarmBuilder::new_local(2)
        .with_aptos()
        .with_init_config(Arc::new(move |idx, config, _| {
            if idx == 0 {
                // Node 0: Strict mempool, loose consensus
                filter_mempool_transactions(config, sender_address);
                // consensus_filter remains default (disabled)
            }
            // Node 1: Loose mempool (default - allows all)
        }))
        .build()
        .await;
    
    // Submit transaction to Node 1 (loose mempool) - accepted
    let txn = create_transaction_from_sender(private_key, sender_address, &mut swarm).await;
    let node1_client = swarm.validator(swarm.validators().nth(1).unwrap().peer_id())
        .unwrap()
        .rest_client();
    node1_client.submit(&txn).await.unwrap();
    
    // Wait for Node 1 to propose a block with the transaction
    // Node 0 will receive the proposal
    // Node 0's loose consensus_filter will accept it
    // Transaction executes on Node 0 despite mempool_filter rejecting it
    
    tokio::time::sleep(Duration::from_secs(5)).await;
    
    // Verify transaction was executed on Node 0
    let node0_client = swarm.validator(swarm.validators().nth(0).unwrap().peer_id())
        .unwrap()
        .rest_client();
    let result = node0_client.get_account(sender_address).await;
    assert!(result.is_ok()); // Transaction executed despite mempool filter
}
```

## Notes

The vulnerability exists because transaction filtering is implemented as separate, independently-configured filters at different validation points rather than as a unified policy enforced consistently across all transaction submission paths. While each individual filter works correctly in isolation, their independence creates a bypass opportunity when configurations are inconsistent.

The issue is exacerbated by the lack of:
1. Validation enforcing filter configuration consistency
2. Documentation warning about the need for consistency
3. Monitoring for configuration drift
4. Network-wide coordination of filter policies

This represents a fundamental architectural issue in how transaction filtering is designed and implemented in the Aptos codebase.

### Citations

**File:** config/src/config/transaction_filters_config.rs (L10-18)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
}
```

**File:** config/src/config/transaction_filters_config.rs (L46-53)
```rust
impl Default for TransactionFilterConfig {
    fn default() -> Self {
        Self {
            filter_enabled: false,                          // Disable the filter
            transaction_filter: TransactionFilter::empty(), // Use an empty filter
        }
    }
}
```

**File:** mempool/src/shared_mempool/tasks.rs (L318-326)
```rust
    // Filter out any disallowed transactions
    let mut statuses = vec![];
    let transactions =
        filter_transactions(&smp.transaction_filter_config, transactions, &mut statuses);

    // If there are no transactions left after filtering, return early
    if transactions.is_empty() {
        return statuses;
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L408-466)
```rust
fn filter_transactions(
    transaction_filter_config: &TransactionFilterConfig,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(
    SignedTransaction,
    Option<u64>,
    Option<BroadcastPeerPriority>,
)> {
    // If the filter is not enabled, return early
    if !transaction_filter_config.is_enabled() {
        return transactions;
    }

    // Start the filter processing timer
    let transaction_filter_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FILTER_TRANSACTIONS_LABEL])
        .start_timer();

    // Filter the transactions and update the statuses accordingly
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
            } else {
                info!(LogSchema::event_log(
                    LogEntry::TransactionFilter,
                    LogEvent::TransactionRejected
                )
                .message(&format!(
                    "Transaction {} rejected by filter",
                    transaction.committed_hash()
                )));

                statuses.push((
                    transaction.clone(),
                    (
                        MempoolStatus::new(MempoolStatusCode::RejectedByFilter),
                        None,
                    ),
                ));
                None
            }
        })
        .collect();

    // Update the filter processing latency metrics
    transaction_filter_timer.stop_and_record();

    transactions
}
```

**File:** types/src/mempool_status.rs (L66-67)
```rust
    // The transaction filter has rejected the transaction
    RejectedByFilter = 7,
```

**File:** consensus/src/round_manager.rs (L1202-1214)
```rust
        // If the proposal contains any inline transactions that need to be denied
        // (e.g., due to filtering) drop the message and do not vote for the block.
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** consensus/src/block_storage/block_store.rs (L596-603)
```rust
    pub fn check_denied_inline_transactions(
        &self,
        block: &Block,
        block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        self.payload_manager
            .check_denied_inline_transactions(block, block_txn_filter_config)
    }
```

**File:** testsuite/smoke-test/src/transaction_filter.rs (L246-270)
```rust
/// Adds a filter to the consensus config to ignore transactions from the given sender
fn filter_inline_transactions(node_config: &mut NodeConfig, sender_address: AccountAddress) {
    // Create the block transaction filter
    let block_transaction_filter = BlockTransactionFilter::empty()
        .add_multiple_matchers_filter(false, vec![BlockTransactionMatcher::Transaction(
            TransactionMatcher::Sender(sender_address),
        )])
        .add_all_filter(true);

    // Update the node config with the new filter
    node_config.transaction_filters.consensus_filter =
        BlockTransactionFilterConfig::new(true, block_transaction_filter);
}

/// Adds a filter to the mempool config to ignore transactions from the given sender
fn filter_mempool_transactions(node_config: &mut NodeConfig, sender_address: AccountAddress) {
    // Create the transaction filter
    let transaction_filter = TransactionFilter::empty()
        .add_multiple_matchers_filter(false, vec![TransactionMatcher::Sender(sender_address)])
        .add_all_filter(true);

    // Update the node config with the new filter
    node_config.transaction_filters.mempool_filter =
        TransactionFilterConfig::new(true, transaction_filter);
}
```
