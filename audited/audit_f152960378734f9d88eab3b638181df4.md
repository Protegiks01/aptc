# Audit Report

## Title
Authentication Bypass in Abstract Account Abstraction via Unvalidated Signing Message Digest During Block Execution

## Summary
During block execution, Abstract authenticators' `signing_message_digest` values are extracted and used without re-validation against the actual transaction. This allows a malicious validator to propose blocks containing transactions with mismatched digests, causing all validators to execute transactions with authentication intended for different transactions.

## Finding Description

The vulnerability exists in how `AuthenticationProof` is extracted and validated across the transaction lifecycle:

**Extraction Phase** (No Validation):
At `transaction_metadata.rs:47,53,60`, authentication proofs are extracted via `.authentication_proof()` without validating the contained data: [1](#0-0) 

For Abstract authenticators, this extraction clones the `signing_message_digest` directly from the transaction without verification: [2](#0-1) 

**Validation Phase** (Mempool Only):
The digest IS validated during mempool validation via `check_signature()`: [3](#0-2) 

Which calls `AccountAuthenticator::verify()` that checks the digest matches the transaction: [4](#0-3) 

**Execution Phase** (No Re-validation):
However, during block execution, `TransactionMetadata::new()` is called WITHOUT prior signature validation: [5](#0-4) 

Subsequently, `validate_signed_transaction()` uses these unvalidated proofs and calls `dispatchable_authenticate()` without re-checking the digest: [6](#0-5) [7](#0-6) 

**Attack Scenario:**
A malicious validator can:
1. Create and sign Transaction A legitimately
2. Construct Transaction B (different raw transaction)
3. Use Transaction A's `signing_message_digest` and `abstract_signature` in Transaction B's authenticator
4. Propose a block containing Transaction B
5. Honest validators execute the block without re-validating the digest
6. The Move authentication function validates the signature against the provided digest (succeeds)
7. Transaction B executes with authentication meant for Transaction A

## Impact Explanation

**Critical Severity** - This breaks multiple fundamental invariants:

1. **Authentication Bypass**: Transactions execute without valid authentication for their actual content
2. **Consensus Safety Violation**: All validators reach consensus on an invalid state where unauthenticated transactions execute
3. **Deterministic Execution Failure**: The system accepts different authentication than what was cryptographically committed to

This enables:
- Unauthorized fund transfers using signatures from unrelated transactions
- Arbitrary state manipulation without proper authorization
- Complete bypass of the Abstract authentication mechanism

Per Aptos Bug Bounty criteria, this qualifies as **Critical** due to being a Consensus/Safety violation that breaks transaction validation invariants.

## Likelihood Explanation

**Likelihood: Medium-to-High within threat model**

**Requirements:**
- Malicious validator with block proposal capability (within BFT threat model of <1/3 Byzantine nodes)
- Knowledge of the vulnerability
- Ability to construct transactions with mismatched authenticators

**Feasibility:**
- BFT consensus explicitly tolerates <1/3 Byzantine validators
- The vulnerability is in honest validators' failure to detect the attack
- No complex exploitation required - straightforward authenticator manipulation

**Triggering conditions:**
- Malicious validator proposes block (normal consensus operation)
- Honest validators execute without re-validation (current implementation)

Note: While this requires validator access, Byzantine validator behavior is within the explicit threat model of BFT consensus. The bug is in the honest validators' code that fails to properly validate these attacks.

## Recommendation

**Fix: Re-validate Abstract authenticator digests during execution**

Add digest validation in `validate_signed_transaction()` before calling `dispatchable_authenticate()`:

```rust
// In validate_signed_transaction(), before line 1885:
AuthenticationProof::Abstract {
    function_info,
    auth_data,
} => {
    // Re-validate the signing_message_digest matches the actual transaction
    let expected_digest = AASigningData::signing_message_digest(
        signing_message(transaction)?,
        function_info.clone()
    )?;
    
    if auth_data.signing_message_digest() != &expected_digest {
        return Err(VMStatus::error(
            StatusCode::INVALID_SIGNATURE,
            Some("Signing message digest does not match transaction".to_string())
        ));
    }
    
    // ... existing dispatchable_authenticate call
}
```

**Alternative Fix**: Store validated transaction hash in `TransactionMetadata` during extraction and verify it hasn't changed.

## Proof of Concept

```rust
// This PoC demonstrates the vulnerability conceptually
// Full reproduction requires consensus/validator framework

#[test]
fn test_abstract_auth_digest_mismatch() {
    // Create Transaction A with valid signature
    let txn_a = create_transaction_with_abstract_auth(...);
    let digest_a = compute_signing_message_digest(&txn_a);
    let signature_a = sign_digest(digest_a);
    
    // Create Transaction B (different content)
    let mut txn_b = create_different_transaction(...);
    
    // Maliciously use digest and signature from A
    txn_b.authenticator = AbstractAuthenticator {
        function_info: auth_function,
        auth_data: AbstractAuthenticationData::V1 {
            signing_message_digest: digest_a,  // From transaction A!
            abstract_signature: signature_a,    // From transaction A!
        }
    };
    
    // During mempool validation:
    // txn_b.check_signature() would FAIL (digest mismatch detected)
    
    // But if directly executed (as in block execution):
    let metadata = TransactionMetadata::new(&txn_b, &auxiliary_info);
    // metadata.authentication_proof contains the mismatched digest
    
    // validate_signed_transaction() uses this proof without re-checking
    // dispatchable_authenticate() verifies signature_a against digest_a (succeeds)
    // Transaction B executes with authentication meant for A!
}
```

**Notes:**
- Full exploitation requires validator infrastructure to propose blocks
- Honest validators would all execute the invalid transaction identically
- The authentication invariant is violated despite consensus convergence

### Citations

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L46-60)
```rust
            sender: txn.sender(),
            authentication_proof: txn.authenticator().sender().authentication_proof(),
            secondary_signers: txn.authenticator().secondary_signer_addresses(),
            secondary_authentication_proofs: txn
                .authenticator()
                .secondary_signers()
                .iter()
                .map(|account_auth| account_auth.authentication_proof())
                .collect(),
            replay_protector: txn.replay_protector(),
            fee_payer: txn.authenticator_ref().fee_payer_address(),
            fee_payer_authentication_proof: txn
                .authenticator()
                .fee_payer_signer()
                .map(|signer| signer.authentication_proof()),
```

**File:** types/src/transaction/authenticator.rs (L779-790)
```rust
            Self::Abstract { authenticator } => {
                let original_signing_message = signing_message(message)?;
                ensure!(
                    authenticator.signing_message_digest()
                        == &AASigningData::signing_message_digest(
                            original_signing_message,
                            authenticator.function_info().clone()
                        )?,
                    "The signing message digest provided in Abstract Authenticator is not expected"
                );
                Ok(())
            },
```

**File:** types/src/transaction/authenticator.rs (L821-835)
```rust
    pub fn authentication_proof(&self) -> AuthenticationProof {
        match self {
            Self::NoAccountAuthenticator => AuthenticationProof::None,
            Self::Abstract { authenticator } => AuthenticationProof::Abstract {
                function_info: authenticator.function_info().clone(),
                auth_data: authenticator.auth_data().clone(),
            },
            Self::Ed25519 { .. }
            | Self::MultiEd25519 { .. }
            | Self::SingleKey { .. }
            | Self::MultiKey { .. } => AuthenticationProof::Key(
                AuthenticationKey::from_preimage(self.public_key_bytes(), self.scheme()).to_vec(),
            ),
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1870-1907)
```rust
        let sender_signers = itertools::zip_eq(senders, proofs)
            .map(|(sender, proof)| match proof {
                AuthenticationProof::Abstract {
                    function_info,
                    auth_data,
                } => {
                    let enabled = match auth_data {
                        AbstractAuthenticationData::V1 { .. } => {
                            self.features().is_account_abstraction_enabled()
                        },
                        AbstractAuthenticationData::DerivableV1 { .. } => {
                            self.features().is_derivable_account_abstraction_enabled()
                        },
                    };
                    if enabled {
                        dispatchable_authenticate(
                            session,
                            gas_meter,
                            sender,
                            function_info.clone(),
                            auth_data,
                            traversal_context,
                            module_storage,
                        )
                        .map_err(|mut vm_error| {
                            if vm_error.major_status() == OUT_OF_GAS {
                                vm_error
                                    .set_major_status(ACCOUNT_AUTHENTICATION_GAS_LIMIT_EXCEEDED);
                            }
                            vm_error.into_vm_status()
                        })
                    } else {
                        Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None))
                    }
                },
                _ => Ok(serialized_signer(&sender)),
            })
            .collect::<Result<_, _>>()?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2143-2143)
```rust
        let txn_metadata = TransactionMetadata::new(txn, auxiliary_info);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3232-3239)
```rust
        let txn = match transaction.check_signature() {
            Ok(t) => t,
            _ => {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            },
        };
        let auxiliary_info = AuxiliaryInfo::new_timestamp_not_yet_assigned(0);
        let txn_data = TransactionMetadata::new(&txn, &auxiliary_info);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3400-3439)
```rust
fn dispatchable_authenticate(
    session: &mut SessionExt<impl AptosMoveResolver>,
    gas_meter: &mut impl GasMeter,
    account: AccountAddress,
    function_info: FunctionInfo,
    auth_data: &AbstractAuthenticationData,
    traversal_context: &mut TraversalContext,
    module_storage: &impl ModuleStorage,
) -> VMResult<Vec<u8>> {
    let auth_data = bcs::to_bytes(auth_data).expect("from rust succeeds");
    let mut params = serialize_values(&vec![
        MoveValue::Signer(account),
        function_info.as_move_value(),
    ]);
    params.push(auth_data);
    session
        .execute_function_bypass_visibility(
            &ACCOUNT_ABSTRACTION_MODULE,
            AUTHENTICATE,
            vec![],
            params,
            gas_meter,
            traversal_context,
            module_storage,
        )
        .map(|mut return_vals| {
            assert!(
                return_vals.mutable_reference_outputs.is_empty()
                    && return_vals.return_values.len() == 1,
                "Abstraction authentication function must only have 1 return value"
            );
            let (signer_data, signer_layout) = return_vals.return_values.pop().expect("Must exist");
            assert_eq!(
                signer_layout,
                MoveTypeLayout::Signer,
                "Abstraction authentication function returned non-signer."
            );
            signer_data
        })
}
```
