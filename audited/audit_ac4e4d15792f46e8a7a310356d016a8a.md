# Audit Report

## Title
Protocol Negotiation Bypass: Unauthenticated Protocol Message Injection via ProtocolId Confusion

## Summary
The network layer fails to validate that incoming messages use only protocols negotiated during the handshake. An attacker can send messages with any `ProtocolId` (including DKG protocols) even if that protocol was not agreed upon during connection establishment, bypassing the handshake security mechanism and potentially injecting unauthorized DKG messages into validator nodes.

## Finding Description

During the Aptos network handshake, two peers negotiate which application protocols they both support through `HandshakeMsg.perform_handshake()`, which computes the intersection of their supported protocols and stores it in `ConnectionMetadata.application_protocols`. [1](#0-0) 

The negotiated protocols are established during both inbound and outbound connection upgrades: [2](#0-1) 

However, when processing incoming network messages, the `Peer::handle_inbound_network_message()` function only validates whether an upstream handler exists for the message's `protocol_id`, but does NOT check if that `protocol_id` is in the negotiated `connection_metadata.application_protocols` set: [3](#0-2) [4](#0-3) 

On validator networks, multiple protocol handlers are registered simultaneously (Consensus, DKG, JWK Consensus): [5](#0-4) 

**Attack Scenario:**

1. Malicious peer connects to an honest validator node
2. During handshake, malicious peer only advertises support for Consensus protocols (omitting DKG)
3. Handshake negotiation succeeds with `application_protocols = {ConsensusRpcBcs, ConsensusDirectSendBcs, ...}` (no DKG protocols)
4. Malicious peer crafts a `DirectSendMsg` or `RpcRequest` with `protocol_id = DKGRpcBcs` (value 19)
5. Honest validator receives the message
6. In `handle_inbound_network_message()`, the code checks `upstream_handlers.get(&DKGRpcBcs)`
7. Since the validator has a DKG handler registered, the message is forwarded to the DKG subsystem
8. **DKG processes a message from a peer that never negotiated DKG support**

This bypasses the fundamental security assumption that all peers communicating via a protocol have explicitly negotiated support for that protocol during the handshake.

## Impact Explanation

**High Severity** - This constitutes a significant protocol violation:

- **Security Mechanism Bypass**: The handshake protocol negotiation is a critical security boundary that ensures both peers agree on which protocols to use. Bypassing this allows unauthorized protocol access.

- **DKG Security Risk**: DKG (Distributed Key Generation) is a security-critical subsystem for validator operations. Allowing unauthenticated DKG message injection could enable:
  - Sending malformed DKG messages to disrupt key generation ceremonies
  - Injecting crafted messages that exploit DKG implementation assumptions
  - Potential validator node slowdowns or crashes from unexpected DKG traffic

- **Protocol Isolation Violation**: Different protocols may have different security requirements and trust assumptions. This vulnerability allows protocol-level privilege escalation.

According to Aptos bug bounty criteria, this qualifies as **High Severity** due to being a "significant protocol violation" that could lead to "validator node slowdowns" or disruption of critical validator functions.

## Likelihood Explanation

**High Likelihood** of exploitation:

- **Low Attack Complexity**: The attack requires only standard network connection establishment capabilities. No special cryptographic material or validator insider access needed.

- **No Authentication Required**: Any peer that can establish a network connection can exploit this. The handshake will succeed with minimal protocol support, then unauthorized protocols can be used.

- **Multiple Attack Vectors**: Works for both `DirectSendMsg` and `RpcRequest` message types, affecting all protocol handlers registered on the network.

- **Production Relevance**: All validator nodes are affected as they register multiple protocol handlers (Consensus, DKG, JWK Consensus) on the same validator network.

## Recommendation

Add validation in `Peer::handle_inbound_network_message()` to verify that incoming message `protocol_id` values are in the negotiated `connection_metadata.application_protocols` set:

```rust
fn handle_inbound_network_message(
    &mut self,
    message: NetworkMessage,
) -> Result<(), PeerManagerError> {
    match &message {
        NetworkMessage::DirectSendMsg(direct) => {
            // ADDED: Validate protocol was negotiated during handshake
            if !self.connection_metadata.application_protocols.contains(direct.protocol_id) {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata(&self.connection_metadata),
                    protocol_id = ?direct.protocol_id,
                    "{} Received DirectSendMsg for non-negotiated protocol: {:?}",
                    self.network_context,
                    direct.protocol_id
                );
                counters::direct_send_messages(&self.network_context, "non_negotiated").inc();
                return Ok(()); // Drop the message
            }
            
            let data_len = direct.raw_msg.len();
            // ... rest of existing logic
        },
        NetworkMessage::RpcRequest(request) => {
            // ADDED: Validate protocol was negotiated during handshake
            if !self.connection_metadata.application_protocols.contains(request.protocol_id) {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata(&self.connection_metadata),
                    protocol_id = ?request.protocol_id,
                    "{} Received RpcRequest for non-negotiated protocol: {:?}",
                    self.network_context,
                    request.protocol_id
                );
                counters::rpc_messages(&self.network_context, "non_negotiated").inc();
                return Ok(()); // Drop the message
            }
            
            // ... rest of existing logic
        },
        // ... other cases
    }
}
```

This ensures that only protocols explicitly negotiated during the handshake can be used for communication, enforcing the protocol negotiation security boundary.

## Proof of Concept

```rust
// Test demonstrating protocol negotiation bypass
// Location: network/framework/src/peer/test.rs

#[tokio::test]
async fn test_protocol_negotiation_bypass() {
    use crate::protocols::wire::messaging::v1::{DirectSendMsg, NetworkMessage};
    use crate::protocols::wire::handshake::v1::{ProtocolId, ProtocolIdSet};
    
    // Setup two peers
    let (mut peer_a, mut peer_b) = build_test_connected_peers().await;
    
    // Peer A negotiated protocols: Consensus only
    let peer_a_protocols = ProtocolIdSet::from_iter([
        ProtocolId::ConsensusRpcBcs,
        ProtocolId::ConsensusDirectSendBcs,
    ]);
    
    // Peer B has handlers for both Consensus and DKG
    // (simulating a validator node setup)
    
    // Attack: Peer A sends a DKG message despite not negotiating DKG
    let malicious_msg = NetworkMessage::DirectSendMsg(DirectSendMsg {
        protocol_id: ProtocolId::DKGRpcBcs, // DKG protocol not negotiated!
        priority: 0,
        raw_msg: vec![0xDE, 0xAD, 0xBE, 0xEF], // Malicious DKG payload
    });
    
    // Send the message from Peer A to Peer B
    peer_a.send_message(malicious_msg).await.unwrap();
    
    // BUG: Peer B will forward this to DKG handler despite DKG not being negotiated
    // Expected: Message should be rejected due to protocol not in application_protocols
    // Actual: Message is forwarded if upstream_handler exists for DKGRpcBcs
    
    // This demonstrates the vulnerability:
    // - Peer A never negotiated DKG support
    // - Peer A can still send DKG messages
    // - Peer B's DKG subsystem receives unauthorized messages
}
```

This test would demonstrate that messages with non-negotiated `protocol_id` values are incorrectly accepted and forwarded to their respective handlers, bypassing the handshake negotiation security mechanism.

### Citations

**File:** network/framework/src/transport/mod.rs (L100-108)
```rust
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** network/framework/src/transport/mod.rs (L308-331)
```rust
    let (messaging_protocol, application_protocols) = handshake_msg
        .perform_handshake(&remote_handshake)
        .map_err(|err| {
            let err = format!(
                "handshake negotiation with peer {} failed: {}",
                remote_peer_id.short_str(),
                err
            );
            add_pp_addr(proxy_protocol_enabled, io::Error::other(err), &addr)
        })?;

    // return successful connection
    Ok(Connection {
        socket,
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
    })
```

**File:** network/framework/src/peer/mod.rs (L447-492)
```rust
    fn handle_inbound_network_message(
        &mut self,
        message: NetworkMessage,
    ) -> Result<(), PeerManagerError> {
        match &message {
            NetworkMessage::DirectSendMsg(direct) => {
                let data_len = direct.raw_msg.len();
                network_application_inbound_traffic(
                    self.network_context,
                    direct.protocol_id,
                    data_len as u64,
                );
                match self.upstream_handlers.get(&direct.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(data_len as u64);
                    },
                    Some(handler) => {
                        let key = (self.connection_metadata.remote_peer_id, direct.protocol_id);
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        match handler.push(key, ReceivedMessage::new(message, sender)) {
                            Err(_err) => {
                                // NOTE: aptos_channel never returns other than Ok(()), but we might switch to tokio::sync::mpsc and then this would work
                                counters::direct_send_messages(
                                    &self.network_context,
                                    DECLINED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, DECLINED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                            Ok(_) => {
                                counters::direct_send_messages(
                                    &self.network_context,
                                    RECEIVED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, RECEIVED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                        }
                    },
                }
```

**File:** network/framework/src/peer/mod.rs (L505-530)
```rust
            NetworkMessage::RpcRequest(request) => {
                match self.upstream_handlers.get(&request.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(request.raw_request.len() as u64);
                    },
                    Some(handler) => {
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        if let Err(err) = self
                            .inbound_rpcs
                            .handle_inbound_request(handler, ReceivedMessage::new(message, sender))
                        {
                            warn!(
                                NetworkSchema::new(&self.network_context)
                                    .connection_metadata(&self.connection_metadata),
                                error = %err,
                                "{} Error handling inbound rpc request: {}",
                                self.network_context,
                                err
                            );
                        }
                    },
                }
```

**File:** aptos-node/src/network.rs (L294-334)
```rust
        if network_id.is_validator_network() {
            // A validator node must have only a single consensus network handle
            if consensus_network_handle.is_some() {
                panic!("There can be at most one validator network!");
            } else {
                let network_handle = register_client_and_service_with_network(
                    &mut network_builder,
                    network_id,
                    &network_config,
                    consensus_network_configuration(node_config),
                    true,
                );
                consensus_network_handle = Some(network_handle);
            }

            if dkg_network_handle.is_some() {
                panic!("There can be at most one validator network!");
            } else {
                let network_handle = register_client_and_service_with_network(
                    &mut network_builder,
                    network_id,
                    &network_config,
                    dkg_network_configuration(node_config),
                    true,
                );
                dkg_network_handle = Some(network_handle);
            }

            if jwk_consensus_network_handle.is_some() {
                panic!("There can be at most one validator network!");
            } else {
                let network_handle = register_client_and_service_with_network(
                    &mut network_builder,
                    network_id,
                    &network_config,
                    jwk_consensus_network_configuration(node_config),
                    true,
                );
                jwk_consensus_network_handle = Some(network_handle);
            }
        }
```
