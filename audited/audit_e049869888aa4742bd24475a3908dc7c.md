# Audit Report

## Title
Case-Insensitive Filesystem Collision Enables Package Shadowing and Non-Deterministic Build Artifacts

## Summary
The `PackageName` struct uses case-sensitive comparison via derived `PartialEq`, but package names are used to create filesystem paths during compilation. On case-insensitive filesystems (Windows, macOS), two packages with names differing only in case can pass all validation checks but write to the same build directory, causing file collisions and non-deterministic behavior that could break the Deterministic Execution invariant.

## Finding Description

The Move package system has a critical mismatch between case-sensitive package name comparison and case-insensitive filesystem behavior:

**1. Case-Sensitive Package Name Comparison:** [1](#0-0) 

The `PackageName` struct derives `PartialEq`, making all package name comparisons case-sensitive throughout the codebase.

**2. No Case-Insensitive Conflict Detection:** [2](#0-1) 

The `check_for_name_conflicts` function groups packages by `identity.name.as_str()` without case normalization, so "MyLib" and "mylib" are treated as completely different packages.

**3. Package Names Used as Filesystem Paths:** [3](#0-2) 

Build artifacts are written to directories named after the package, using the package name directly in the path.

**4. Directory Deletion Before Write:** [4](#0-3) 

Before saving build artifacts, the system deletes any existing directory, ensuring file overwrites.

**5. Contrast with Module/Script Protection:** [5](#0-4) 

The codebase explicitly protects against case-insensitive collisions for module and script names using `.to_lowercase()`, acknowledging filesystem case-insensitivity concerns, but provides no such protection for package names.

**Attack Scenario:**

On a case-insensitive filesystem:
1. Malicious actor publishes package "aptosframework" (all lowercase) with backdoor code
2. Victim project legitimately depends on "AptosFramework" (proper casing) 
3. Through dependency confusion or typosquatting, project also depends on "aptosframework"
4. Both packages pass validation (names match their manifests)
5. Both added to resolution graph (case-sensitive check sees them as different)
6. During compilation on macOS/Windows:
   - "AptosFramework" compiles to `build/AptosFramework/`
   - "aptosframework" compiles to `build/aptosframework/` â†’ same directory!
   - Second package's `remove_dir_all` deletes first package's artifacts
   - Malicious code artifacts overwrite legitimate ones
7. Resulting bytecode contains attacker's code, attributed to trusted package name

## Impact Explanation

This vulnerability meets **Medium Severity** criteria with potential for **High Severity** impact:

1. **Breaks Deterministic Execution Invariant:** Validators or nodes running different operating systems (Linux vs macOS/Windows) would have different build artifacts for the same dependency graph, potentially leading to consensus divergence.

2. **State Inconsistencies:** Different build outputs across environments could cause unpredictable behavior requiring manual intervention to resolve.

3. **Dependency Confusion Attack Vector:** Enables package shadowing where malicious code can be substituted for legitimate packages on case-insensitive systems.

4. **Supply Chain Security Risk:** Developers on macOS/Windows could unknowingly build and deploy packages with wrong artifacts, affecting production systems.

## Likelihood Explanation

**Likelihood: Medium-High**

- Common development environments (macOS, Windows) use case-insensitive filesystems by default
- Package naming conventions in Move ecosystem may not enforce strict casing policies
- Typosquatting attacks commonly exploit case variations
- No runtime detection of this misconfiguration
- Silent failure mode: builds succeed but produce wrong artifacts
- Reproducible build verification would fail across different OS platforms

## Recommendation

Add case-insensitive package name collision detection, following the same approach used for module/script names:

```rust
// In resolver.rs, add before check_for_name_conflicts:
fn check_for_case_insensitive_name_conflicts(graph: &ResolutionGraph) -> Result<()> {
    let mut lowercase_name_map = BTreeMap::new();
    
    for node in graph.node_indices() {
        let identity = &graph[node].identity;
        let lowercase_name = identity.name.to_lowercase();
        
        let entries = lowercase_name_map
            .entry(lowercase_name)
            .or_insert_with(Vec::new);
        entries.push((identity.name.as_str(), &identity.location));
    }
    
    let conflicts = lowercase_name_map
        .into_iter()
        .filter(|(_lowercase, entries)| entries.len() > 1)
        .map(|(lowercase, entries)| {
            format!(
                "Package name case conflict (would collide on case-insensitive filesystems): {}\n{}",
                lowercase,
                entries.iter()
                    .map(|(name, loc)| format!("  {} @ {}", name, loc))
                    .collect::<Vec<_>>()
                    .join("\n")
            )
        })
        .collect::<Vec<_>>();
    
    if !conflicts.is_empty() {
        bail!("Case-insensitive package name conflicts detected:\n{}", conflicts.join("\n\n"));
    }
    
    Ok(())
}

// Call in resolve() function after existing checks:
check_for_case_insensitive_name_conflicts(&graph)?;
check_for_name_conflicts(&graph)?;
check_for_self_dependencies(&graph)?;
check_for_cyclic_dependencies(&graph)?;
```

## Proof of Concept

```bash
# On macOS or Windows:

# 1. Create legitimate package
mkdir -p AptosFramework/sources
cat > AptosFramework/Move.toml << EOF
[package]
name = "AptosFramework"
version = "1.0.0"

[addresses]
aptos_framework = "0x1"
EOF

echo 'module aptos_framework::safe { public fun call() {} }' > AptosFramework/sources/safe.move

# 2. Create malicious package with case-different name
mkdir -p aptosframework/sources
cat > aptosframework/Move.toml << EOF
[package]
name = "aptosframework"
version = "1.0.0"

[addresses]
aptos_framework = "0x1"
EOF

echo 'module aptos_framework::safe { public fun call() { abort 1 } }' > aptosframework/sources/safe.move

# 3. Create root package depending on both
mkdir -p my_project/sources
cat > my_project/Move.toml << EOF
[package]
name = "MyProject"
version = "1.0.0"

[dependencies]
AptosFramework = { local = "../AptosFramework" }
aptosframework = { local = "../aptosframework" }
EOF

# 4. Build - second package overwrites first due to case-insensitive FS
cd my_project
aptos move compile

# 5. Observe: build/AptosFramework/ and build/aptosframework/ resolve to same directory
# The malicious package's artifacts overwrite the legitimate ones
# No error is raised, silently producing compromised build
```

**Expected Result:** Build succeeds but produces non-deterministic artifacts depending on compilation order.

**Actual Security Impact:** On case-insensitive filesystems, the malicious "aptosframework" package's code overwrites "AptosFramework" artifacts, potentially deploying backdoored code to production.

### Citations

**File:** third_party/move/tools/move-package-manifest/src/package_name.rs (L20-21)
```rust
#[derive(Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct PackageName(String);
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L93-127)
```rust
fn check_for_name_conflicts(graph: &ResolutionGraph) -> Result<()> {
    let mut name_location_map = BTreeMap::new();

    for node in graph.node_indices() {
        let identity = &graph[node].identity;

        let locations = name_location_map
            .entry(identity.name.as_str())
            .or_insert_with(Vec::new);
        locations.push(&identity.location);
    }

    let conflicts = name_location_map
        .into_iter()
        .filter(|(_name, locations)| locations.len() > 1)
        .map(|(name, locations)| {
            format!(
                "Package name conflict: {}\n{}",
                name,
                locations
                    .iter()
                    .map(|l| format!("  {}", l))
                    .collect::<Vec<_>>()
                    .join("\n")
            )
        })
        .collect::<Vec<_>>()
        .join("\n\n");

    if !conflicts.is_empty() {
        bail!("{}", conflicts);
    }

    Ok(())
}
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L777-789)
```rust
    // We take the (restrictive) view that all filesystems are case insensitive to maximize
    // portability of packages.
    fn check_filepaths_ok(&self) -> Result<()> {
        // A mapping of (lowercase_name => [info_for_each_occurence]
        let mut insensitive_mapping = BTreeMap::new();
        for compiled_unit in &self.root_compiled_units {
            let is_module = matches!(&compiled_unit.unit, CompiledUnit::Module(_));
            let name = match &compiled_unit.unit {
                CompiledUnit::Script(named) => named.name.as_str(),
                CompiledUnit::Module(named) => named.name.as_str(),
            };
            let entry = insensitive_mapping
                .entry(name.to_lowercase())
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L841-841)
```rust
            root_path: under_path.join(root_package.as_str()),
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L863-865)
```rust
        if on_disk_package.root_path.is_dir() {
            std::fs::remove_dir_all(&on_disk_package.root_path)?;
        }
```
