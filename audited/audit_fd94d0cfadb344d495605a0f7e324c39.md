# Audit Report

## Title
Indexer Supply Tracking Corruption on Collection Metadata Updates Without FixedSupply Changes

## Summary
The Token V2 indexer incorrectly resets collection supply information (current_supply, max_supply, total_minted_v2) to default values when processing collection metadata updates that don't include the FixedSupply resource in the transaction's write set. This causes temporary data corruption in the indexer database until a subsequent transaction modifies the supply.

## Finding Description

The vulnerability exists in how the `parse_v2_token()` function builds supply metadata for Token V2 collections. The indexer processes transactions in two passes:

**First Pass:** Extracts ObjectCore resources from write set changes and stores them in `token_v2_metadata_helper` [1](#0-0) 

**Second Pass:** Populates additional resources (FixedSupply, UnlimitedSupply, etc.) IF they exist in the current transaction's write set [2](#0-1) 

The critical issue occurs in `CollectionV2::get_v2_from_write_resource()` when processing a Collection resource update:

1. It initializes supply values to defaults (BigDecimal::zero(), None, None) [3](#0-2) 

2. It attempts to retrieve FixedSupply from the metadata helper built from ONLY the current transaction's write set [4](#0-3) 

3. When FixedSupply is absent (not modified in this transaction), it uses the default zero values [5](#0-4) 

4. These incorrect values overwrite the database via upsert [6](#0-5) 

**The Move Framework Architecture confirms this vulnerability:**

In the Aptos Token Objects framework, Collection and FixedSupply are separate resources stored at the same collection object address: [7](#0-6) [8](#0-7) 

When collection metadata is mutated via `set_description()`, `set_uri()`, or `set_name()`, ONLY the Collection resource is modified: [9](#0-8) [10](#0-9) 

Therefore, the FixedSupply resource does NOT appear in the transaction's write set changes, causing the indexer to use default values.

**Attack Scenario:**
1. Transaction A: Collection created with max_supply=1000 → Indexer correctly stores max_supply=1000
2. Transaction B: Collection description updated → FixedSupply not in write set → Indexer stores max_supply=None (WRONG!)
3. Transaction C: Token minted → FixedSupply updated → Indexer restores max_supply=1000

Between transactions B and C, all queries return incorrect supply data.

## Impact Explanation

This is a **Medium Severity** vulnerability per the Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: The indexer database contains incorrect supply information
- **Limited data corruption**: Applications, marketplaces, and explorers querying the indexer receive wrong supply data
- **No consensus impact**: On-chain state remains correct; only the off-chain indexer view is corrupted
- **Requires operator intervention**: Database corrections needed if caught during the corruption window

The impact is limited to the indexer (an off-chain query service) and does not affect consensus, validator nodes, or on-chain funds. However, it can cause:
- Incorrect rarity calculations in NFT marketplaces
- Wrong minting limit displays
- Misleading collection statistics
- Poor user experience and loss of trust

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers automatically whenever:
- Any collection metadata is updated (description, URI, name changes)
- No minting/burning occurs in the same transaction

Common triggering operations include:
- Collection creators updating project descriptions
- URI updates for metadata changes  
- Rebranding with name changes

No special conditions or attacker actions are required—this is a normal operational bug that occurs during routine collection management.

## Recommendation

The indexer should implement conditional supply updates that preserve existing values when supply resources are not present in the write set:

**Option 1: Query blockchain state**
Before using default values, query the blockchain for FixedSupply/UnlimitedSupply resources at the collection address and use those values if the resources exist on-chain.

**Option 2: Conditional database updates**
Modify the upsert logic to only update supply fields when they are explicitly present in the transaction:

```rust
// In CollectionV2::get_v2_from_write_resource()
let supply_updated = metadata.fixed_supply.is_some() || metadata.unlimited_supply.is_some();

// Include a flag in the returned struct indicating whether supply was updated
// Then in the database upsert, conditionally update supply fields only when the flag is true
```

**Option 3: Preserve existing values**
Query the database for existing supply values before processing and only overwrite if new supply data is available in the transaction.

**Recommended Fix:** Implement Option 1 combined with caching to minimize performance impact while ensuring data accuracy.

## Proof of Concept

```move
// File: test_supply_corruption.move
// This Move test demonstrates the vulnerability scenario

#[test_only]
module test_addr::supply_corruption_test {
    use std::string;
    use std::option;
    use aptos_token_objects::collection;
    
    #[test(creator = @0x123)]
    fun test_supply_corruption_on_metadata_update(creator: &signer) {
        // Step 1: Create collection with fixed supply
        let collection_name = string::utf8(b"Test Collection");
        let constructor_ref = collection::create_fixed_collection(
            creator,
            string::utf8(b"Original Description"),
            1000, // max_supply
            collection_name,
            option::none(),
            string::utf8(b"https://example.com")
        );
        
        // Indexer now has: max_supply = 1000
        
        // Step 2: Update collection description
        let mutator_ref = collection::generate_mutator_ref(&constructor_ref);
        collection::set_description(
            &mutator_ref,
            string::utf8(b"Updated Description")
        );
        
        // At this point, only Collection resource is in write set
        // FixedSupply resource is NOT in write set (it wasn't modified)
        // Indexer processes this and sets: max_supply = None (CORRUPTED!)
        
        // Step 3: Anyone querying the indexer between step 2 and next mint
        // would see max_supply = None instead of 1000
        
        // This is the vulnerability: supply data is lost during metadata updates
    }
}
```

**Notes:**
- This is an **indexer-only vulnerability** that does not affect on-chain consensus or state
- The on-chain Collection and FixedSupply resources remain intact and correct
- Only the off-chain indexer database view is temporarily corrupted
- Data corruption persists until the next transaction that modifies supply resources

### Citations

**File:** crates/indexer/src/processors/token_processor.rs (L708-710)
```rust
                    current_supply.eq(excluded(current_supply)),
                    max_supply.eq(excluded(max_supply)),
                    total_minted_v2.eq(excluded(total_minted_v2)),
```

**File:** crates/indexer/src/processors/token_processor.rs (L1093-1115)
```rust
            for wsc in user_txn.info.changes.iter() {
                if let WriteSetChange::WriteResource(wr) = wsc {
                    if let Some(object) =
                        ObjectWithMetadata::from_write_resource(wr, txn_version).unwrap()
                    {
                        token_v2_metadata_helper.insert(
                            standardize_address(&wr.address.to_string()),
                            TokenV2AggregatedData {
                                aptos_collection: None,
                                fixed_supply: None,
                                object,
                                unlimited_supply: None,
                                property_map: None,
                                transfer_event: None,
                                token: None,
                                fungible_asset_metadata: None,
                                fungible_asset_supply: None,
                                fungible_asset_store: None,
                            },
                        );
                    }
                }
            }
```

**File:** crates/indexer/src/processors/token_processor.rs (L1118-1126)
```rust
            for wsc in user_txn.info.changes.iter() {
                if let WriteSetChange::WriteResource(wr) = wsc {
                    let address = standardize_address(&wr.address.to_string());
                    if let Some(aggregated_data) = token_v2_metadata_helper.get_mut(&address) {
                        if let Some(fixed_supply) =
                            FixedSupply::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.fixed_supply = Some(fixed_supply);
                        }
```

**File:** crates/indexer/src/models/token_models/v2_collections.rs (L106-107)
```rust
            let (mut current_supply, mut max_supply, mut total_minted_v2) =
                (BigDecimal::zero(), None, None);
```

**File:** crates/indexer/src/models/token_models/v2_collections.rs (L109-126)
```rust
            if let Some(metadata) = token_v2_metadata.get(&resource.address) {
                // Getting supply data (prefer fixed supply over unlimited supply although they should never appear at the same time anyway)
                let fixed_supply = metadata.fixed_supply.as_ref();
                let unlimited_supply = metadata.unlimited_supply.as_ref();
                if let Some(supply) = unlimited_supply {
                    (current_supply, max_supply, total_minted_v2) = (
                        supply.current_supply.clone(),
                        None,
                        Some(supply.total_minted.clone()),
                    );
                }
                if let Some(supply) = fixed_supply {
                    (current_supply, max_supply, total_minted_v2) = (
                        supply.current_supply.clone(),
                        Some(supply.max_supply.clone()),
                        Some(supply.total_minted.clone()),
                    );
                }
```

**File:** crates/indexer/src/models/token_models/v2_collections.rs (L154-156)
```rust
                    current_supply: current_supply.clone(),
                    max_supply: max_supply.clone(),
                    total_minted_v2: total_minted_v2.clone(),
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L64-76)
```text
    struct Collection has key {
        /// The creator of this collection.
        creator: address,
        /// A brief description of the collection.
        description: String,
        /// An optional categorization of similar token.
        name: String,
        /// The Uniform Resource Identifier (uri) pointing to the JSON file stored in off-chain
        /// storage; the URL length will likely need a maximum any suggestions?
        uri: String,
        /// Emitted upon any mutation of the collection.
        mutation_events: event::EventHandle<MutationEvent>,
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L102-111)
```text
    struct FixedSupply has key {
        /// Total minted - total burned
        current_supply: u64,
        max_supply: u64,
        total_minted: u64,
        /// Emitted upon burning a Token.
        burn_events: event::EventHandle<BurnEvent>,
        /// Emitted upon minting an Token.
        mint_events: event::EventHandle<MintEvent>,
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L671-687)
```text
    public fun set_description(mutator_ref: &MutatorRef, description: String) acquires Collection {
        assert!(description.length() <= MAX_DESCRIPTION_LENGTH, error::out_of_range(EDESCRIPTION_TOO_LONG));
        let collection = borrow_mut(mutator_ref);
        if (std::features::module_event_migration_enabled()) {
            event::emit(Mutation {
                mutated_field_name: string::utf8(b"description"),
                collection: object::address_to_object(mutator_ref.self),
                old_value: collection.description,
                new_value: description,
            });
        } else {
            event::emit_event(
                &mut collection.mutation_events,
                MutationEvent { mutated_field_name: string::utf8(b"description") },
            );
        };
        collection.description = description;
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L690-706)
```text
    public fun set_uri(mutator_ref: &MutatorRef, uri: String) acquires Collection {
        assert!(uri.length() <= MAX_URI_LENGTH, error::out_of_range(EURI_TOO_LONG));
        let collection = borrow_mut(mutator_ref);
        if (std::features::module_event_migration_enabled()) {
            event::emit(Mutation {
                mutated_field_name: string::utf8(b"uri"),
                collection: object::address_to_object(mutator_ref.self),
                old_value: collection.uri,
                new_value: uri,
            });
        } else {
            event::emit_event(
                &mut collection.mutation_events,
                MutationEvent { mutated_field_name: string::utf8(b"uri") },
            );
        };
        collection.uri = uri;
```
