# Audit Report

## Title
Rosetta API Lacks Cryptographic Verification of REST API Responses - Complete Trust in Upstream Data Source

## Summary
The Aptos Rosetta API implementation blindly trusts all data returned by the underlying REST API without any cryptographic verification. Account balances, sequence numbers, staking information, and all state queries are forwarded to users without validating Merkle proofs, enabling a compromised or malicious REST API to return arbitrary fake balances that would be accepted as legitimate.

## Finding Description

The Rosetta API retrieves account balances and state information through the REST client, but never performs cryptographic verification of the responses: [1](#0-0) 

The REST client implementation makes simple HTTP requests and deserializes responses without verification: [2](#0-1) [3](#0-2) 

The response validation only checks HTTP status codes and parses metadata headers, never cryptographic proofs: [4](#0-3) 

The `State` struct extracted from response headers contains only metadata (chain_id, version, timestamp) but no cryptographic proofs: [5](#0-4) 

**Critical Issue**: While the Aptos storage layer has full capability to generate Merkle proofs via `get_state_value_with_proof_by_version_ext`, these proofs are never exposed through the REST API endpoints that Rosetta uses, and even if they were, the Rosetta implementation doesn't verify them.

**Attack Scenario:**
1. Attacker compromises the REST API server (via server vulnerability, insider threat, or man-in-the-middle)
2. Attacker modifies account balance responses to return inflated balances
3. Rosetta API retrieves fake balance via `get_account_resource_at_version_bcs`
4. Rosetta API returns fake balance to user without any verification
5. User trusts the fake balance and makes financial decisions based on false information

This violates the fundamental blockchain invariant: **"State Consistency: State transitions must be atomic and verifiable via Merkle proofs"**. The Rosetta API provides no mechanism for users to independently verify the authenticity of state data.

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos bug bounty criteria)

This vulnerability creates a **single point of trust failure** and violates multiple security guarantees:

1. **Fake Balance Exposure**: Users receive unverified balance information that could be completely fabricated
2. **State Verification Failure**: No cryptographic proof chain exists for Rosetta users to validate data authenticity
3. **API Trust Violation**: Compromising the REST API gives complete control over what Rosetta reports to users

While this requires compromising the REST API server (significant prerequisite), it represents a **fundamental architectural vulnerability** where defense-in-depth is completely absent. Traditional blockchain light clients verify Merkle proofs against trusted block headers, but Rosetta provides no such verification.

The impact is classified as **High** rather than Critical because:
- Requires compromising the REST API infrastructure (not trivially exploitable)
- Does not directly steal funds from the blockchain itself
- Does not break consensus or validator operations
- Primarily affects Rosetta API consumers who could verify data through other means

However, this could lead to:
- Users making incorrect trading decisions based on fake balances
- Integration partners building on false state assumptions
- Reputation damage to the Aptos ecosystem

## Likelihood Explanation

**Likelihood: Medium-High**

The exploitation requires compromising the REST API server, which could occur through:

1. **Server-side vulnerabilities**: Unpatched REST API server software
2. **Supply chain attacks**: Compromised dependencies in REST API stack
3. **Insider threats**: Malicious operator with REST API access
4. **Network-level attacks**: Man-in-the-middle if TLS is misconfigured
5. **Infrastructure compromise**: Cloud provider account takeover

While these are not trivial attacks, they are realistic threat scenarios that any production system must defend against through defense-in-depth mechanisms. The complete absence of cryptographic verification means a single compromise point enables undetectable data manipulation.

The likelihood increases because:
- REST APIs are common attack targets with large attack surface
- No verification means attacks are undetectable by Rosetta users
- Rosetta is specifically designed for exchanges and financial integrations where fake balances have high value

## Recommendation

Implement cryptographic verification of all REST API responses using Merkle proofs. The fix requires:

**1. Expose state proofs in REST API:**
Extend REST API endpoints to optionally return Merkle proofs alongside state data.

**2. Add proof verification to Rosetta:**
Implement verification logic in the Rosetta layer that:
- Retrieves state values with Merkle proofs
- Verifies proofs against trusted block headers/state roots
- Rejects unverified data

**3. Trust anchor establishment:**
Rosetta should maintain trusted state roots (either from local full node or verified through consensus signatures) against which to verify proofs.

**Example verification flow:**
```
1. Rosetta requests: /accounts/{addr}/resource/{type}?with_proof=true
2. REST API returns: {resource_data, merkle_proof, state_root}
3. Rosetta verifies: SparseMerkleProof::verify(proof, state_root, resource_data)
4. Only return data to user if verification succeeds
```

The Aptos codebase already has proof generation capabilities: [6](#0-5) 

These capabilities should be exposed through the REST API and consumed by Rosetta with verification.

**Minimal fix**: At minimum, Rosetta should verify state roots against BFT consensus signatures to detect tampering, even if full Merkle proof verification is not implemented immediately.

## Proof of Concept

**Demonstrating the vulnerability:**

1. Deploy Rosetta API pointing to a REST API endpoint
2. Intercept or modify the REST API to return fake balance:

```rust
// Simulated attack: Modified REST API returns fake balance
// In get_account_resource_at_version_bcs response:
let fake_account = AccountResource::new(
    999_999_999_999_999, // Fake huge sequence number
    vec![],
);
// Return fake_account serialized to BCS
```

3. Query Rosetta API for account balance:
```bash
curl -X POST http://localhost:8080/account/balance \
  -H "Content-Type: application/json" \
  -d '{
    "network_identifier": {"blockchain": "aptos", "network": "mainnet"},
    "account_identifier": {"address": "0x1"}
  }'
```

4. **Expected**: Rosetta returns fake balance without any verification
5. **Should happen**: Rosetta detects proof mismatch and rejects response

**Testing verification absence:**

The current code path shows no verification occurs:
- `account_balance()` calls `get_balances()`
- `get_balances()` calls `rest_client.get_account_resource_at_version_bcs()`
- REST client calls `get_bcs()` which only checks HTTP status
- Response is directly deserialized and returned to user

No proof verification logic exists anywhere in the call chain.

## Notes

This vulnerability represents a **fundamental architectural gap** in the Rosetta implementation. While the Aptos blockchain itself maintains strong cryptographic guarantees through Merkle trees and BFT consensus, the Rosetta API layer bypasses all verification and creates a trusted intermediary that users must blindly trust.

The fix requires coordinated changes across REST API and Rosetta layers, but the proof generation infrastructure already exists in the storage layer and simply needs to be exposed and consumed properly.

### Citations

**File:** crates/aptos-rosetta/src/account.rs (L78-84)
```rust
    let (sequence_number, operators, balances, lockup_expiration) = get_balances(
        &server_context,
        request.account_identifier,
        balance_version,
        request.currencies,
    )
    .await?;
```

**File:** crates/aptos-rest-client/src/lib.rs (L1223-1238)
```rust
    pub async fn get_account_resource_at_version_bcs<T: DeserializeOwned>(
        &self,
        address: AccountAddress,
        resource_type: &str,
        version: u64,
    ) -> AptosResult<Response<T>> {
        let url = self.build_path(&format!(
            "accounts/{}/resource/{}?ledger_version={}",
            address.to_hex(),
            resource_type,
            version
        ))?;

        let response = self.get_bcs(url).await?;
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1645-1656)
```rust
    async fn check_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<(reqwest::Response, State)> {
        if !response.status().is_success() {
            Err(parse_error(response).await)
        } else {
            let state = parse_state(&response)?;

            Ok((response, state))
        }
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1687-1690)
```rust
    async fn get_bcs(&self, url: Url) -> AptosResult<Response<bytes::Bytes>> {
        let response = self.inner.get(url).header(ACCEPT, BCS).send().await?;
        self.check_and_parse_bcs_response(response).await
    }
```

**File:** crates/aptos-rest-client/src/state.rs (L10-20)
```rust
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct State {
    pub chain_id: u8,
    pub epoch: u64,
    pub version: u64,
    pub timestamp_usecs: u64,
    pub oldest_ledger_version: u64,
    pub oldest_block_height: u64,
    pub block_height: u64,
    pub cursor: Option<String>,
}
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```
