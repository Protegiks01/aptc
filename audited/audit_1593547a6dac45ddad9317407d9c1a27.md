# Audit Report

## Title
Missing Generator Validation in Chunky PVSS Commitment Base Enables Identity Point Attack

## Summary
The `Homomorphism` struct in `chunked_scalar_mul.rs` uses a base point for commitments that lacks validation to ensure it is not the identity element or has proper order. This allows an attacker who can control public parameters to set the commitment base to the identity point, causing all commitments to collapse to identity and completely breaking the PVSS security guarantees.

## Finding Description
The chunky PVSS implementation uses a `Homomorphism` struct with a `base` field that serves as the generator for commitments. [1](#0-0) 

This base point is used to compute commitments and dealt public keys through scalar multiplication. [2](#0-1) 

The critical vulnerability exists in multiple locations:

1. **No validation in `unsafe_hash_to_affine`**: The function generates the commitment base G_2 via hash-to-curve, applies `mul_by_cofactor()` to ensure the point is in the prime-order subgroup, but never checks if the result is the identity element. [3](#0-2) 

2. **Empty validation in PublicParameters**: The `Valid::check()` implementation for `PublicParameters<E>` is completely empty and performs no validation on G_2. [4](#0-3) 

3. **Arbitrary commitment base accepted**: The `new_with_commitment_base` function allows setting an arbitrary G_2 without any validation that it's a proper generator. [5](#0-4) 

4. **Deserialization without validation**: The custom `Deserialize` implementation directly assigns the deserialized G_2 field without validation. [6](#0-5) 

**Attack Scenario:**
An attacker who can provide malicious public parameters (via deserialization or direct instantiation) sets `G_2 = identity`. This causes:
- All commitments become identity: `base * scalar = identity * scalar = identity`
- All dealt public keys become identity
- The PVSS scheme provides no security - all secrets are exposed
- Discrete log problems become trivial (log of identity is undefined/trivial)

The cryptographic tests confirm identity points can be serialized/deserialized. [7](#0-6) 

## Impact Explanation
**Severity Assessment: Medium**

While the cryptographic vulnerability is severe in isolation, the impact is limited because:

1. **Limited Production Usage**: The actual production DKG for consensus randomness uses the DAS PVSS implementation, not the chunky PVSS. [8](#0-7) 

2. **Batch Encryption Usage**: The chunky PVSS is primarily used in the `aptos-batch-encryption` crate for FPTX schemes, which appears to be auxiliary functionality not directly in the consensus critical path. [9](#0-8) 

3. **Trusted Setup Required**: An attacker would need the ability to provide malicious public parameters, which typically requires compromising the setup phase or parameter distribution mechanism.

However, this still qualifies as Medium severity because:
- It breaks the **Cryptographic Correctness** invariant
- If the chunky PVSS were adopted for future consensus features, it would be critical
- The vulnerability exists in production code and could affect applications using this module
- It represents a fundamental cryptographic weakness that could enable discrete log attacks

## Likelihood Explanation
**Likelihood: Low to Medium**

The likelihood depends on:
1. **Attacker Capabilities**: Requires ability to inject malicious public parameters during setup or deserialization
2. **Usage Scope**: Currently limited to batch-encryption schemes, not core consensus
3. **Deterministic Hash**: The standard initialization via `unsafe_hash_to_affine(b"G_2", DST)` is unlikely to produce identity (probability ~1/r where r is the prime order), but no explicit check exists
4. **Future Adoption**: If chunky PVSS becomes more widely used in future upgrades, likelihood increases

## Recommendation

Add explicit validation that the commitment base is not the identity element and has proper order:

```rust
impl<E: Pairing> Valid for PublicParameters<E> {
    fn check(&self) -> Result<(), SerializationError> {
        // Validate G_2 is not the identity element
        if self.G_2.is_zero() {
            return Err(SerializationError::InvalidData);
        }
        
        // For pairing-based curves, verify G_2 is in the correct subgroup
        // (arkworks already ensures this via mul_by_cofactor, but explicit check is safer)
        if !self.G_2.is_on_curve() {
            return Err(SerializationError::InvalidData);
        }
        
        Ok(())
    }
}
```

Additionally, add validation in `new_with_commitment_base`:

```rust
pub fn new_with_commitment_base<R: RngCore + CryptoRng>(
    n: usize,
    ell: u8,
    max_aggregation: usize,
    commitment_base: E::G2Affine,
    rng: &mut R,
) -> Self {
    // Validate commitment_base is not identity
    assert!(!commitment_base.is_zero(), "Commitment base cannot be identity");
    
    let mut pp = Self::new(n, ell, max_aggregation, rng);
    pp.G_2 = commitment_base;
    pp
}
```

## Proof of Concept

```rust
use ark_bls12_381::{Bls12_381, G2Affine};
use ark_ec::AffineRepr;
use aptos_dkg::pvss::chunky::public_parameters::PublicParameters;
use rand::thread_rng;

#[test]
fn test_identity_commitment_base_vulnerability() {
    let mut rng = thread_rng();
    
    // Create public parameters with identity as commitment base
    let malicious_pp = PublicParameters::<Bls12_381>::new_with_commitment_base(
        10,  // max_num_shares
        16,  // ell
        10,  // max_aggregation
        G2Affine::zero(),  // IDENTITY POINT - should be rejected!
        &mut rng,
    );
    
    // This should fail but currently succeeds!
    // The Valid::check() is empty, so no validation occurs
    assert!(malicious_pp.check().is_ok()); // Currently passes, should fail
    
    // Now all commitments will be identity
    let commitment_base = malicious_pp.get_commitment_base();
    assert!(commitment_base.is_zero()); // Confirms base is identity
    
    // Any scalar multiplication yields identity
    use ark_ff::UniformRand;
    let secret = ark_bls12_381::Fr::rand(&mut rng);
    let dealt_pk = commitment_base * secret;
    assert!(dealt_pk.is_zero()); // All dealt PKs are identity - BROKEN!
}
```

## Notes

- The production DKG for Aptos consensus uses the DAS PVSS implementation which has more robust validation via `blstrs` library
- The vulnerability is primarily in the chunky PVSS implementation used for batch encryption schemes
- The mathematical analysis confirms that after `mul_by_cofactor()`, a point in the r-torsion (where r is prime) has order either 1 (identity) or r (full generator), making identity the only "weak" case
- Adding validation is straightforward and has negligible performance cost
- This issue highlights the importance of explicit cryptographic parameter validation even when using well-tested libraries

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_scalar_mul.rs (L29-32)
```rust
pub struct Homomorphism<C: CurveGroup> {
    pub base: C::Affine,
    pub ell: u8,
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L86-97)
```rust
        let serialized = SerializedFields::<E>::deserialize(deserializer)?;
        let G: E::G1 = serialized.pp_elgamal.G.into();

        Ok(Self {
            pp_elgamal: serialized.pp_elgamal,
            pk_range_proof: serialized.pk_range_proof,
            G_2: serialized.G_2,
            ell: serialized.ell,
            table: Self::build_dlog_table(G, serialized.ell, serialized.max_aggregation),
            powers_of_radix: compute_powers_of_radix::<E>(serialized.ell),
            max_aggregation: serialized.max_aggregation,
        })
```

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L120-124)
```rust
impl<E: Pairing> Valid for PublicParameters<E> {
    fn check(&self) -> Result<(), SerializationError> {
        Ok(())
    }
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L140-144)
```rust
        keys::DealtPubKey::new(
            pp.get_commitment_base()
                .mul(self.get_secret_a())
                .into_affine(),
        )
```

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L195-205)
```rust
    pub fn new_with_commitment_base<R: RngCore + CryptoRng>(
        n: usize,
        ell: u8,
        max_aggregation: usize,
        commitment_base: E::G2Affine,
        rng: &mut R,
    ) -> Self {
        let mut pp = Self::new(n, ell, max_aggregation, rng);
        pp.G_2 = commitment_base;
        pp
    }
```

**File:** crates/aptos-crypto/src/arkworks/hashing.rs (L27-51)
```rust
pub fn unsafe_hash_to_affine<P: AffineRepr>(msg: &[u8], dst: &[u8]) -> P {
    let dst_len = u8::try_from(dst.len())
        .expect("DST is too long; its length must be <= 255, as in RFC 9380 (Section 5.3.1)");

    let mut buf = Vec::with_capacity(msg.len() + dst.len() + 1);
    buf.extend_from_slice(msg);
    buf.extend_from_slice(dst);
    buf.push(dst_len);
    buf.push(0); // placeholder for counter

    for ctr in 0..=u8::MAX {
        *buf.last_mut()
            .expect("Could not access last byte of buffer") = ctr;

        let hashed = sha3::Sha3_512::digest(&buf);

        // `from_random_bytes()` first tries to construct an x-coordinate, and then a y-coordinate from that, see e.g.:
        // https://github.com/arkworks-rs/algebra/blob/c1f4f5665504154a9de2345f464b0b3da72c28ec/ec/src/models/short_weierstrass/affine.rs#L264
        if let Some(p) = P::from_random_bytes(&hashed) {
            return p.mul_by_cofactor(); // is needed to ensure that `p` lies in the prime order subgroup
        }
    }

    panic!("Failed to hash to affine group element");
}
```

**File:** crates/aptos-crypto/src/arkworks/serialization.rs (L93-106)
```rust
        let mut points = vec![G2Affine::zero()]; // Include zero
        let mut g = G2Projective::generator();

        for _ in 0..MAX_DOUBLINGS {
            points.push(g.into());
            g += g; // double for next
        }

        for p in points {
            let serialized = bcs::to_bytes(&A(p)).expect("Serialization failed");
            let deserialized: A = bcs::from_bytes(&serialized).expect("Deserialization failed");

            assert_eq!(deserialized.0, p, "G2 point round-trip failed for {:?}", p);
        }
```

**File:** types/src/dkg/real_dkg/mod.rs (L38-41)
```rust
pub type WTrx = pvss::das::WeightedTranscript;
pub type DkgPP = <WTrx as Transcript>::PublicParameters;
pub type SSConfig = <WTrx as Transcript>::SecretSharingConfig;
pub type EncPK = <WTrx as Transcript>::EncryptPubKey;
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L225-225)
```rust
    type SubTranscript = aptos_dkg::pvss::chunky::WeightedSubtranscript<Pairing>;
```
