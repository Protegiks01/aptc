# Audit Report

## Title
Path Traversal Vulnerability in VaultPolicy Namespace Isolation Allows Cross-Namespace Access to KV Secrets

## Summary
The `VaultPolicy` implementation in `secure/storage/src/vault.rs` fails to validate or sanitize key names before concatenating them with namespace prefixes. This allows attackers in one namespace to craft key names containing path traversal sequences (`../`) that can bypass namespace isolation and access or set policies for keys in other validators' namespaces when using the KV Secrets engine.

## Finding Description

The `VaultPolicy::name()` function constructs paths by directly concatenating a namespace prefix with user-supplied key names without any validation. [1](#0-0) 

For the KV Secrets engine, the namespace separator is `"/"` (NAMESPACE_SEPARATOR). [2](#0-1)  When an attacker in namespace `"validator_a"` provides a key name like `"../validator_b/config_secret"`, the resulting path becomes `"validator_a/../validator_b/config_secret"`.

This unsanitized path is then used in two critical operations:

1. **Policy Creation**: In `set_policy()`, the path is formatted and passed directly to Vault's policy system. [3](#0-2)  The policy path becomes `"secret/data/validator_a/../validator_b/config_secret"`, which HTTP servers (including Vault) typically normalize to `"secret/data/validator_b/config_secret"`.

2. **Data Access**: In KV storage operations, the path is used directly in HTTP requests to Vault. [4](#0-3)  The URL becomes `{host}/v1/secret/data/validator_a/../validator_b/config_secret`, which normalizes to access the victim's namespace.

**Attack Scenario:**
1. Attacker operates in namespace `"validator_a"`
2. Attacker calls `set_policies("../validator_b/api_token", &VaultEngine::KVSecrets, permissive_policy)`
3. The policy path `"secret/data/validator_a/../validator_b/api_token"` is normalized to `"secret/data/validator_b/api_token"`
4. Attacker's token now has access to `validator_b`'s secrets
5. Attacker reads or modifies `validator_b`'s configuration data

**Important Note:** Cryptographic keys stored via `CryptoStorage` use the Transit engine with `"__"` as the namespace separator [5](#0-4) , and additionally replace `"/"` with `"__"` in key names. [6](#0-5)  This prevents path traversal for private keys. However, KV secrets remain vulnerable.

The codebase contains no validation to prevent path traversal sequences in key names. [7](#0-6)  Tests verify cross-namespace access denial but do not test path traversal attacks. [8](#0-7) 

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty)

While validator private keys stored in `CryptoStorage` are protected by the Transit engine's `"__"` separator, this vulnerability allows unauthorized access to KV secrets across namespaces. In multi-tenant Vault deployments, validators may store:
- API tokens and authentication credentials
- Configuration data and operational parameters  
- Non-cryptographic secrets used in validator operations
- Metadata about validator operations

Unauthorized access to these secrets constitutes a **significant protocol violation** allowing:
- Information disclosure about validator operations
- Potential validator node compromise via leaked credentials
- Configuration tampering if write access is granted
- Violation of the access control invariant

This does not qualify as "Critical" severity because:
- Validator private keys (the most critical asset) are NOT directly accessible
- No direct loss of funds or consensus violation
- Impact is limited to KV secrets of varying sensitivity

However, it qualifies as "High" severity due to the **significant protocol violation** of namespace isolation and potential for validator node compromise through credential theft.

## Likelihood Explanation

**Likelihood: Medium**

**Requirements for exploitation:**
- Attacker must have legitimate access to a namespace in a multi-tenant Vault deployment
- Vault must normalize HTTP paths (standard behavior for most HTTP servers)
- Target validator must store sensitive data in KV secrets (likely but not guaranteed)

**Complexity:** Low - the attack requires only crafting a key name with `"../"` sequences

**Detection:** Unlikely - logs would show legitimate namespace access, making malicious activity hard to distinguish

The vulnerability is straightforward to exploit if the deployment scenario exists. However, some production deployments may use dedicated Vault instances per validator rather than multi-tenant setups, reducing real-world exposure.

## Recommendation

Implement strict input validation for all key names before namespace concatenation:

```rust
fn validate_key_name(name: &str) -> Result<(), Error> {
    // Reject path traversal attempts
    if name.contains("..") || name.starts_with('/') || name.contains("//") {
        return Err(Error::InvalidKeyName(format!(
            "Key name '{}' contains illegal path traversal sequences", 
            name
        )));
    }
    
    // Enforce alphanumeric + limited special characters
    let valid_chars = name.chars().all(|c| {
        c.is_alphanumeric() || c == '_' || c == '-' || c == '.'
    });
    
    if !valid_chars {
        return Err(Error::InvalidKeyName(format!(
            "Key name '{}' contains illegal characters", 
            name
        )));
    }
    
    Ok(())
}

fn name(&self, name: &str, engine: &VaultEngine) -> Result<String, Error> {
    validate_key_name(name)?;
    
    if let Some(namespace) = &self.namespace {
        Ok(format!("{}{}{}", namespace, engine.ns_seperator(), name))
    } else {
        Ok(name.into())
    }
}
```

Additionally, consider using Vault's native namespace feature instead of path-based isolation, or implementing path normalization before validation to prevent bypass attempts.

## Proof of Concept

```rust
#[cfg(test)]
mod path_traversal_test {
    use super::*;
    use crate::{Capability, Identity, Permission, Policy};
    
    #[test]
    fn test_path_traversal_attack() {
        // Setup: Two namespaces in the same Vault instance
        let mut attacker_storage = create_vault_policy_with_namespace(
            Some("attacker_ns".to_string())
        );
        let victim_storage = create_vault_policy_with_namespace(
            Some("victim_ns".to_string())
        );
        
        // Victim stores a secret
        victim_storage.set("api_token", "VICTIM_SECRET_TOKEN").unwrap();
        
        // Attacker attempts path traversal to access victim's secret
        let traversal_key = "../victim_ns/api_token";
        
        // Create permissive policy for traversed path
        let malicious_policy = Policy::new(vec![
            Permission::new(
                Identity::User("attacker".into()),
                vec![Capability::Read, Capability::Write]
            )
        ]);
        
        // Attacker sets policy for victim's secret via path traversal
        attacker_storage.set_policies(
            traversal_key,
            &VaultEngine::KVSecrets,
            &malicious_policy
        ).unwrap();
        
        // Create token with attacker policy
        let attacker_token = attacker_storage.create_token(vec!["attacker"]).unwrap();
        
        // Attacker can now read victim's secret (if Vault normalizes paths)
        let mut attacker_client = create_vault_storage(attacker_token, None, false);
        let stolen_secret = attacker_client.get::<String>(traversal_key);
        
        // This should fail but may succeed due to path normalization
        // Expected: Error::PermissionDenied
        // Actual (if vulnerable): Ok("VICTIM_SECRET_TOKEN")
        assert!(stolen_secret.is_err(), "Path traversal attack succeeded!");
    }
}
```

**Note:** This PoC demonstrates the attack vector. Actual exploitability depends on Vault's HTTP path normalization behavior, which should be verified in a test environment.

### Citations

**File:** secure/storage/src/vault.rs (L24-24)
```rust
const TRANSIT_NAMESPACE_SEPARATOR: &str = "__";
```

**File:** secure/storage/src/vault.rs (L135-137)
```rust
    fn crypto_name(&self, name: &str) -> String {
        name.replace(NAMESPACE_SEPARATOR, TRANSIT_NAMESPACE_SEPARATOR)
    }
```

**File:** secure/storage/src/vault.rs (L167-182)
```rust
    fn set<T: Serialize>(&mut self, key: &str, value: T) -> Result<(), Error> {
        let secret = key;
        let key = self.unnamespaced(key);
        let version = if self.use_cas {
            self.secret_versions.read().get(key).copied()
        } else {
            None
        };
        let new_version =
            self.client()
                .write_secret(secret, key, &serde_json::to_value(&value)?, version)?;
        self.secret_versions
            .write()
            .insert(key.to_string(), new_version);
        Ok(())
    }
```

**File:** secure/storage/src/vault.rs (L373-410)
```rust
        pub fn set_policy(
            &self,
            policy_name: &str,
            engine: &VaultEngine,
            key: &str,
            capabilities: &[Capability],
        ) -> Result<(), Error> {
            let policy_name = self.name(policy_name, engine);

            let mut vault_policy = self.client().read_policy(&policy_name).unwrap_or_default();
            let mut core_capabilities = Vec::new();
            for capability in capabilities {
                match capability {
                    Capability::Export => {
                        let export_capability = vec![vault::Capability::Read];
                        let export_policy = format!("transit/export/signing-key/{}", key);
                        vault_policy.add_policy(&export_policy, export_capability);
                    },
                    Capability::Read => core_capabilities.push(vault::Capability::Read),
                    Capability::Rotate => {
                        let rotate_capability = vec![vault::Capability::Update];
                        let rotate_policy = format!("transit/keys/{}/rotate", key);
                        vault_policy.add_policy(&rotate_policy, rotate_capability);
                    },
                    Capability::Sign => {
                        let sign_capability = vec![vault::Capability::Update];
                        let sign_policy = format!("transit/sign/{}", key);
                        vault_policy.add_policy(&sign_policy, sign_capability);
                    },
                    Capability::Write => core_capabilities.push(vault::Capability::Update),
                }
            }

            let path = format!("{}/{}", engine.to_policy_path(), self.name(key, engine));
            vault_policy.add_policy(&path, core_capabilities);
            self.client().set_policy(&policy_name, &vault_policy)?;
            Ok(())
        }
```

**File:** secure/storage/src/vault.rs (L438-444)
```rust
        fn name(&self, name: &str, engine: &VaultEngine) -> String {
            if let Some(namespace) = &self.namespace {
                format!("{}{}{}", namespace, engine.ns_seperator(), name)
            } else {
                name.into()
            }
        }
```

**File:** secure/storage/src/namespaced.rs (L11-11)
```rust
pub const NAMESPACE_SEPARATOR: &str = "/";
```

**File:** secure/storage/src/namespaced.rs (L45-47)
```rust
    fn namespaced(&self, name: &str) -> String {
        format!("{}{}{}", self.namespace, NAMESPACE_SEPARATOR, name)
    }
```

**File:** secure/storage/src/tests/vault.rs (L202-228)
```rust
    // Verify a reader with another namespace has no permission for the operations
    let mut reader_with_namespace = Namespaced::new(
        VAULT_NAMESPACE_1,
        create_vault_storage(reader_token, ttl, false),
    );
    assert_eq!(
        reader_with_namespace.get::<u64>(ANYONE),
        Err(Error::PermissionDenied)
    );
    assert_eq!(
        reader_with_namespace.set(ANYONE, 5),
        Err(Error::PermissionDenied)
    );

    // Verify a writer with another namespace has no permission for the operations
    let mut writer_with_namespace = Namespaced::new(
        VAULT_NAMESPACE_1,
        create_vault_storage(writer_token, ttl, false),
    );
    assert_eq!(
        writer_with_namespace.get::<u64>(ANYONE),
        Err(Error::PermissionDenied)
    );
    assert_eq!(
        writer_with_namespace.set(ANYONE, 5),
        Err(Error::PermissionDenied)
    );
```
