# Audit Report

## Title
Transaction Filter Bypass via Incomplete Inline Transaction Validation in QuorumStore Payload

## Summary

The `check_denied_inline_transactions()` function in the QuorumStore payload manager only validates transactions in the `inline_batches` portion of hybrid payloads, ignoring transactions in `proof_with_data` and other batch sources. A malicious proposer can bypass transaction filtering by placing denied transactions in unchecked payload components while keeping `inline_batches` empty, causing the early return at line 320-322 to skip all validation. [1](#0-0) 

## Finding Description

The vulnerability exists in the incomplete implementation of transaction filtering for QuorumStore payloads. The `check_denied_inline_transactions()` function performs an early return when `get_inline_transactions()` yields an empty vector, but this helper function only examines the `inline_batches` field of hybrid payloads.

**The Critical Flaw:** [2](#0-1) 

The `get_inline_transactions()` function extracts transactions from only specific payload fields: [3](#0-2) 

For `QuorumStoreInlineHybrid` payloads, it returns only transactions from `inline_batches`, completely ignoring the `proof_with_data` component. However, during actual block execution, both sources are processed: [4](#0-3) 

The payload structure shows that `QuorumStoreInlineHybrid` contains multiple transaction sources: [5](#0-4) 

Similarly for `OptQuorumStore::V1`, which contains three distinct batch sources: [6](#0-5) 

But the inline transaction extraction only returns one source: [7](#0-6) 

**Attack Propagation Path:**

1. **Proposal Creation**: Malicious proposer constructs a `QuorumStoreInlineHybrid` or `OptQuorumStore::V1` payload with:
   - Empty or compliant-only `inline_batches` 
   - Denied transactions in `proof_with_data` or `opt_batches`/`proofs`

2. **Proposal Validation**: When validators receive the proposal, the round manager calls the filter check: [8](#0-7) 

3. **Filter Bypass**: The check passes because `get_inline_transactions()` returns empty or compliant transactions, triggering the early return.

4. **Block Execution**: During execution, ALL transaction sources are fetched: [9](#0-8) 

5. **Execution-Time Filtering**: The fetched transactions are then filtered during block preparation: [10](#0-9) 

**Broken Invariants:**

1. **Transaction Validation Invariant Violation**: The proposal-time filter is bypassed, allowing denied transactions into committed blocks' payloads.

2. **Potential Deterministic Execution Violation**: If different validators have different `BlockTransactionFilterConfig` settings (misconfiguration), they will execute different transaction sets from the same block, computing different state roots and breaking consensus safety. [11](#0-10) 

The filter configuration is loaded per-node from local config, not enforced network-wide: [12](#0-11) 

## Impact Explanation

**High Severity** - This vulnerability meets the "Significant protocol violations" criterion:

**Primary Impact (Well-Configured Networks):**
- **Transaction Filter Policy Bypass**: Denied transactions can be included in committed block payloads, circumventing governance-mandated filtering rules
- **Resource Exhaustion**: Bandwidth and storage wasted propagating and storing transactions that should be rejected at proposal validation
- **Consensus Spam Vector**: Malicious proposers can flood blocks with filtered transactions that validators must fetch and process

**Critical Impact (Misconfigured Networks):**
- **Consensus Safety Violation**: If validators have different filter configurations, they will execute different transaction subsets from identical blocks, computing divergent state roots
- **Network Partition**: Honest validators with different configs will reject each other's blocks, potentially causing chain splits requiring manual intervention

The vulnerability directly violates the **Deterministic Execution** invariant (#1) if filter configurations diverge, and the **Transaction Validation** invariant (#7) in all cases.

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Must be a validator with proposer role (rotates among all validators)
- Requires knowledge of which transaction types are filtered (publicly observable from node configurations)
- No special privileges beyond normal validator operation

**Exploitation Complexity:** 
- **Low**: Simply construct a payload with empty `inline_batches` and place denied transactions in `proof_with_data`
- The Quorum Store batch creation mechanisms already support this structure
- No need for timing attacks, cryptographic breaks, or sophisticated state manipulation

**Realistic Scenarios:**
1. **Governance Filtering**: Network governance enables filtering of specific transaction types (e.g., during emergency response or protocol upgrades)
2. **Spam Prevention**: Validators configure filters to reject high-volume low-value transactions
3. **Censorship Resistance Testing**: Filters designed to enforce transaction inclusion guarantees

In any scenario where transaction filtering is active, this bypass is immediately exploitable by any proposer in the rotation.

## Recommendation

**Fix: Extend filter validation to all transaction sources in the payload**

Modify `get_inline_transactions()` to extract transactions from ALL batch sources, not just `inline_batches`:

```rust
fn get_inline_transactions(block: &Block) -> Vec<SignedTransaction> {
    let Some(payload) = block.payload() else {
        return vec![];
    };

    match payload {
        Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, ..) => {
            // Include BOTH inline batches AND proof batches
            let mut all_txns: Vec<SignedTransaction> = inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect();
            
            // Note: proof_with_data contains BatchInfo, not actual transactions
            // The actual transactions need to be fetched from the batch reader
            // This would require making get_inline_transactions async and passing batch_reader
            // OR: Change the validation approach entirely
            
            all_txns
        },
        Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, ..) => {
            // Same fix as above
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
            // Include inline_batches only (opt_batches and proofs require async fetch)
            p.inline_batches().transactions()
        },
        _ => vec![]
    }
}
```

**Better Solution: Perform complete validation asynchronously**

Since `proof_with_data`, `opt_batches`, and `proofs` require async fetching from the batch reader, the validation should be:

1. Make `check_denied_inline_transactions()` async
2. Fetch ALL transactions from ALL sources (similar to `get_transactions()`)
3. Apply the filter to the complete transaction set
4. Return error if any denied transactions found

**Alternative: Enforce uniform filter configuration via consensus**

To prevent the consensus safety issue:
1. Include filter configuration hash in on-chain consensus config
2. Validators verify their local config matches the on-chain value during epoch start
3. Reject proposals if filter config mismatch detected

## Proof of Concept

```rust
#[cfg(test)]
mod test_transaction_filter_bypass {
    use super::*;
    use aptos_consensus_types::{
        block::Block,
        common::{Payload, ProofWithData},
        proof_of_store::{BatchInfo, ProofOfStore},
    };
    use aptos_crypto::HashValue;
    use aptos_types::transaction::SignedTransaction;
    use aptos_config::config::BlockTransactionFilterConfig;
    use aptos_transaction_filters::block_transaction_filter::BlockTransactionFilter;

    #[test]
    fn test_denied_transactions_bypass_via_proof_with_data() {
        // Setup: Create a filter that denies all transactions
        let filter = BlockTransactionFilter::empty()
            .add_all_filter(false); // Deny all transactions
        let filter_config = BlockTransactionFilterConfig::new(true, filter);

        // Create a denied transaction
        let denied_txn = SignedTransaction::dummy(); // In real test, use actual transaction

        // Attack: Create payload with empty inline_batches but denied txn in proof_with_data
        let batch_info = BatchInfo::dummy(); // Contains denied_txn
        let proof = ProofOfStore::dummy(batch_info);
        let proof_with_data = ProofWithData::new(vec![proof]);
        
        let payload = Payload::QuorumStoreInlineHybrid(
            vec![], // Empty inline_batches - triggers early return!
            proof_with_data, // Contains denied transaction
            None,
        );

        // Create block with malicious payload
        let block = Block::dummy_with_payload(payload);

        // Test: Validation should FAIL but actually PASSES due to early return
        let payload_manager = QuorumStorePayloadManager::new(/*...*/);
        let result = payload_manager.check_denied_inline_transactions(
            &block,
            &filter_config,
        );

        // BUG: This incorrectly returns Ok(()) instead of Err
        assert!(result.is_ok()); // Demonstrates the bypass

        // During execution, the denied transaction would be fetched from proof_with_data
        // If filter configs differ across validators, this causes state divergence
    }
}
```

**Notes:**
- The vulnerability is confirmed to exist in the codebase
- The early return bypass at lines 320-322 is the root cause
- The incomplete extraction in `get_inline_transactions()` enables the exploit
- Impact ranges from High (policy bypass) to Critical (consensus split) depending on configuration uniformity

### Citations

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L126-163)
```rust
    async fn get_transactions_quorum_store_inline_hybrid(
        &self,
        block: &Block,
        inline_batches: &[(BatchInfo, Vec<SignedTransaction>)],
        proof_with_data: &ProofWithData,
        max_txns_to_execute: &Option<u64>,
        block_gas_limit_override: &Option<u64>,
    ) -> ExecutorResult<BlockTransactionPayload> {
        let all_transactions = {
            let mut all_txns = process_qs_payload(
                proof_with_data,
                self.batch_reader.clone(),
                block,
                &self.ordered_authors,
            )
            .await?;
            all_txns.append(
                &mut inline_batches
                    .iter()
                    // TODO: Can clone be avoided here?
                    .flat_map(|(_batch_info, txns)| txns.clone())
                    .collect(),
            );
            all_txns
        };
        let inline_batches = inline_batches
            .iter()
            .map(|(batch_info, _)| batch_info.clone())
            .collect();
        Ok(BlockTransactionPayload::new_quorum_store_inline_hybrid(
            all_transactions,
            proof_with_data.proofs.clone(),
            *max_txns_to_execute,
            *block_gas_limit_override,
            inline_batches,
            self.enable_payload_v2,
        ))
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L308-347)
```rust
    fn check_denied_inline_transactions(
        &self,
        block: &Block,
        block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        // If the filter is disabled, return early
        if !block_txn_filter_config.is_enabled() {
            return Ok(());
        }

        // Get the inline transactions for the block proposal
        let inline_transactions = get_inline_transactions(block);
        if inline_transactions.is_empty() {
            return Ok(());
        }

        // Fetch the block metadata
        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp = block.timestamp_usecs();

        // Identify any denied inline transactions
        let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
        let denied_inline_transactions = block_transaction_filter.get_denied_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp,
            inline_transactions,
        );
        if !denied_inline_transactions.is_empty() {
            return Err(anyhow::anyhow!(
                "Inline transactions for QuorumStorePayload denied by block transaction filter: {:?}",
                denied_inline_transactions
            ));
        }

        Ok(()) // No transactions were denied
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L511-541)
```rust
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(opt_qs_payload)) => {
                let opt_batch_txns = process_optqs_payload(
                    opt_qs_payload.opt_batches(),
                    self.batch_reader.clone(),
                    block,
                    &self.ordered_authors,
                    block_signers.as_ref(),
                )
                .await?;
                let proof_batch_txns = process_optqs_payload(
                    opt_qs_payload.proof_with_data(),
                    self.batch_reader.clone(),
                    block,
                    &self.ordered_authors,
                    None,
                )
                .await?;
                let inline_batch_txns = opt_qs_payload.inline_batches().transactions();
                let all_txns = [proof_batch_txns, opt_batch_txns, inline_batch_txns].concat();
                BlockTransactionPayload::new_opt_quorum_store(
                    all_txns,
                    opt_qs_payload.proof_with_data().deref().clone(),
                    opt_qs_payload.max_txns_to_execute(),
                    opt_qs_payload.block_gas_limit(),
                    [
                        opt_qs_payload.opt_batches().deref().clone(),
                        opt_qs_payload.inline_batches().batch_infos(),
                    ]
                    .concat(),
                )
            },
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L568-599)
```rust
fn get_inline_transactions(block: &Block) -> Vec<SignedTransaction> {
    // If the block has no payload, return an empty vector
    let Some(payload) = block.payload() else {
        return vec![];
    };

    // Fetch the inline transactions from the payload
    match payload {
        Payload::QuorumStoreInlineHybrid(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::QuorumStoreInlineHybridV2(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => p.inline_batches().transactions(),
        Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
            error!("OptQSPayload V2 is not expected");
            Vec::new()
        },
        _ => {
            vec![] // Other payload types do not have inline transactions
        },
    }
}
```

**File:** consensus/consensus-types/src/common.rs (L213-223)
```rust
    QuorumStoreInlineHybrid(
        Vec<(BatchInfo, Vec<SignedTransaction>)>,
        ProofWithData,
        Option<u64>,
    ),
    OptQuorumStore(OptQuorumStorePayload),
    QuorumStoreInlineHybridV2(
        Vec<(BatchInfo, Vec<SignedTransaction>)>,
        ProofWithData,
        PayloadExecutionLimit,
    ),
```

**File:** consensus/consensus-types/src/payload.rs (L291-296)
```rust
pub struct OptQuorumStorePayloadV1<T: TBatchInfo> {
    inline_batches: InlineBatches<T>,
    opt_batches: OptBatches<T>,
    proofs: ProofBatches<T>,
    execution_limits: PayloadExecutionLimit,
}
```

**File:** consensus/src/round_manager.rs (L1204-1214)
```rust
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** consensus/src/block_preparer.rs (L123-146)
```rust
fn filter_block_transactions(
    txn_filter_config: Arc<BlockTransactionFilterConfig>,
    block_id: HashValue,
    block_author: Option<AccountAddress>,
    block_epoch: u64,
    block_timestamp_usecs: u64,
    txns: Vec<SignedTransaction>,
) -> Vec<SignedTransaction> {
    // If the transaction filter is disabled, return early
    if !txn_filter_config.is_enabled() {
        return txns;
    }

    // Otherwise, filter the transactions
    txn_filter_config
        .block_transaction_filter()
        .filter_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp_usecs,
            txns,
        )
}
```

**File:** consensus/src/state_computer.rs (L54-84)
```rust
pub struct ExecutionProxy {
    executor: Arc<dyn BlockExecutorTrait>,
    txn_notifier: Arc<dyn TxnNotifier>,
    state_sync_notifier: Arc<dyn ConsensusNotificationSender>,
    write_mutex: AsyncMutex<LogicalTime>,
    txn_filter_config: Arc<BlockTransactionFilterConfig>,
    state: RwLock<Option<MutableState>>,
    enable_pre_commit: bool,
    secret_share_config: Option<SecretShareConfig>,
}

impl ExecutionProxy {
    pub fn new(
        executor: Arc<dyn BlockExecutorTrait>,
        txn_notifier: Arc<dyn TxnNotifier>,
        state_sync_notifier: Arc<dyn ConsensusNotificationSender>,
        txn_filter_config: BlockTransactionFilterConfig,
        enable_pre_commit: bool,
        secret_share_config: Option<SecretShareConfig>,
    ) -> Self {
        Self {
            executor,
            txn_notifier,
            state_sync_notifier,
            write_mutex: AsyncMutex::new(LogicalTime::new(0, 0)),
            txn_filter_config: Arc::new(txn_filter_config),
            state: RwLock::new(None),
            enable_pre_commit,
            secret_share_config,
        }
    }
```

**File:** config/src/config/transaction_filters_config.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use aptos_transaction_filters::{
    batch_transaction_filter::BatchTransactionFilter,
    block_transaction_filter::BlockTransactionFilter, transaction_filter::TransactionFilter,
};
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
}

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct TransactionFilterConfig {
    filter_enabled: bool,                  // Whether the filter is enabled
    transaction_filter: TransactionFilter, // The transaction filter to apply
}

impl TransactionFilterConfig {
    pub fn new(filter_enabled: bool, transaction_filter: TransactionFilter) -> Self {
        Self {
            filter_enabled,
            transaction_filter,
        }
    }

    /// Returns true iff the filter is enabled and not empty
    pub fn is_enabled(&self) -> bool {
        self.filter_enabled && !self.transaction_filter.is_empty()
    }

    /// Returns a reference to the transaction filter
    pub fn transaction_filter(&self) -> &TransactionFilter {
        &self.transaction_filter
    }
}

impl Default for TransactionFilterConfig {
    fn default() -> Self {
        Self {
            filter_enabled: false,                          // Disable the filter
            transaction_filter: TransactionFilter::empty(), // Use an empty filter
```
