# Audit Report

## Title
Integer Overflow in Database Truncation Causes Validator Node Crash and Recovery Failure

## Summary
The `truncate_state_kv_db_single_shard()` function performs unchecked arithmetic `target_version + 1` which causes a panic when `target_version` equals `u64::MAX`. While Rust's overflow checks prevent data deletion, this creates a critical liveness vulnerability where nodes cannot recover from certain database corruption states, potentially leading to network-wide availability issues. [1](#0-0) 

## Finding Description

The vulnerability exists in the database truncation logic used during node recovery and database maintenance. Multiple functions perform arithmetic operations on version numbers without validation:

**Primary Vulnerability Location:** [2](#0-1) 

**Similar Pattern in Other Functions:** [3](#0-2) [4](#0-3) 

**Attack Vector:**

1. Database corruption (from disk errors, bugs, or crashes) causes `OverallCommitProgress` to be stored as `u64::MAX` or a value near the maximum
2. Node starts and calls `StateStore::sync_commit_progress()` during initialization [5](#0-4) 

3. This reads the corrupted version value without validation: [6](#0-5) [7](#0-6) 

4. The truncation function is called with `target_version = u64::MAX`
5. Arithmetic `target_version + 1` triggers integer overflow
6. With `overflow-checks = true` in release builds, this causes an immediate panic: [8](#0-7) 

7. Node crashes and cannot complete database recovery

**Critical Finding:** While the security question suggests data deletion could occur, the Rust overflow checks actually **prevent** wrapping to 0, which means the intended deletion behavior (starting from version 0) does NOT happen. Instead, the node crashes, creating a different but still serious vulnerability.

## Impact Explanation

**Severity: Critical** (Non-recoverable network partition scenario)

This vulnerability qualifies as Critical under the Aptos bug bounty criteria because:

1. **Total Loss of Liveness**: Affected validators cannot restart or recover their databases without manual intervention, effectively removing them from the network

2. **Network Partition Risk**: If a systematic bug in state synchronization or storage causes multiple validators to experience the same corruption pattern (e.g., a specific sequence of operations writes `u64::MAX` as a version), multiple nodes could simultaneously become unrecoverable, potentially causing:
   - Loss of consensus quorum (if >1/3 validators affected)
   - Network partition requiring hard fork intervention
   - Extended downtime across the validator set

3. **State Consistency Violation**: The system cannot maintain the invariant that "State transitions must be atomic and verifiable" when nodes are trapped in unrecoverable states

While individual disk corruption is rare, systematic corruption from software bugs affecting multiple validators is the critical concern that elevates this to Critical severity.

## Likelihood Explanation

**Likelihood: Low to Medium**

**Factors Increasing Likelihood:**
- Database corruption can occur from disk errors, power failures, or software bugs
- No input validation on version values read from database metadata
- The `Version` type is a raw `u64` with no bounds checking: [9](#0-8) 
- Multiple code paths can trigger the vulnerability (ledger DB, state KV DB, state Merkle DB truncation)

**Factors Decreasing Likelihood:**
- Requires version to be exactly or very close to `u64::MAX` (18,446,744,073,709,551,615)
- Normal operation increments versions from 0, would take billions of years to reach MAX
- Modern filesystems and databases have corruption detection

**Most Realistic Scenario:** A bug in version management logic (not corruption) causes `u64::MAX` to be written as a sentinel value or through integer overflow elsewhere in the codebase, then gets persisted to database. During recovery, all nodes with this bug hit the panic.

## Recommendation

**Immediate Fixes:**

1. **Add input validation** when reading versions from database:

```rust
pub(crate) fn get_progress(db: &DB, progress_key: &DbMetadataKey) -> Result<Option<Version>> {
    let version_opt = db
        .get::<DbMetadataSchema>(progress_key)?
        .map(|v| v.expect_version());
    
    // Validate version is within reasonable bounds
    if let Some(version) = version_opt {
        ensure!(
            version < u64::MAX - 1000, // Leave safety margin
            "Invalid version {} read from database - possible corruption",
            version
        );
    }
    
    Ok(version_opt)
}
```

2. **Use checked arithmetic** explicitly in truncation functions:

```rust
pub(crate) fn truncate_state_kv_db_single_shard(
    state_kv_db: &StateKvDb,
    shard_id: usize,
    target_version: Version,
) -> Result<()> {
    let mut batch = SchemaBatch::new();
    
    // Use checked_add to explicitly handle overflow
    let start_version = target_version
        .checked_add(1)
        .ok_or_else(|| {
            AptosDbError::Other(format!(
                "Version overflow: cannot truncate at target_version {}",
                target_version
            ))
        })?;
    
    delete_state_value_and_index(
        state_kv_db.db_shard(shard_id),
        start_version,
        &mut batch,
        state_kv_db.enabled_sharding(),
    )?;
    state_kv_db.commit_single_shard(target_version, shard_id, batch)
}
```

3. **Apply same fix** to `truncate_ledger_db()` and `truncate_state_merkle_db_single_shard()`

4. **Add database corruption detection** during startup that checks for impossible version values

## Proof of Concept

```rust
// Test demonstrating the panic behavior
#[test]
#[should_panic(expected = "attempt to add with overflow")]
fn test_version_overflow_in_truncation() {
    use aptos_types::transaction::Version;
    
    // Simulate corrupted database returning u64::MAX
    let corrupted_version: Version = u64::MAX;
    
    // This will panic in release mode with overflow-checks = true
    let _start_version = corrupted_version + 1;
    
    // In production, this panic occurs during:
    // StateStore::sync_commit_progress() -> 
    // truncate_state_kv_db() -> 
    // truncate_state_kv_db_single_shard() ->
    // target_version + 1 (line 137)
}

// Reproduction steps for node crash:
// 1. Stop a validator node
// 2. Corrupt the database by writing u64::MAX to DbMetadataKey::OverallCommitProgress
// 3. Attempt to restart the node
// 4. Observe panic in truncation_helper.rs during sync_commit_progress()
// 5. Node cannot recover without manual database repair
```

## Notes

**Critical Clarification:** The original security question asked whether "overflow cause all data to be deleted" - the answer is **NO** due to Rust's overflow checks causing a panic instead of wrapping to 0. However, this panic behavior creates a **different but still critical vulnerability** related to node liveness and recovery, rather than data deletion.

The actual security impact is:
- ❌ **NOT** data deletion (overflow checks prevent this)
- ✅ **IS** node crash and inability to recover from corrupted database states
- ✅ **IS** potential network partition if multiple validators affected by systematic bug

This demonstrates defense-in-depth failure: while one safety mechanism (overflow checks) prevents data loss, the lack of input validation creates a separate critical availability vulnerability.

### Citations

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L76-76)
```rust
    let start_version = target_version + 1;
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L129-142)
```rust
pub(crate) fn truncate_state_kv_db_single_shard(
    state_kv_db: &StateKvDb,
    shard_id: usize,
    target_version: Version,
) -> Result<()> {
    let mut batch = SchemaBatch::new();
    delete_state_value_and_index(
        state_kv_db.db_shard(shard_id),
        target_version + 1,
        &mut batch,
        state_kv_db.enabled_sharding(),
    )?;
    state_kv_db.commit_single_shard(target_version, shard_id, batch)
}
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L201-201)
```rust
        target_version + 1,
```

**File:** storage/aptosdb/src/state_store/mod.rs (L354-359)
```rust
            Self::sync_commit_progress(
                Arc::clone(&ledger_db),
                Arc::clone(&state_kv_db),
                Arc::clone(&state_merkle_db),
                /*crash_if_difference_is_too_large=*/ true,
            );
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L76-78)
```rust
    pub(crate) fn get_synced_version(&self) -> Result<Option<Version>> {
        get_progress(&self.db, &DbMetadataKey::OverallCommitProgress)
    }
```

**File:** storage/aptosdb/src/utils/mod.rs (L14-18)
```rust
pub(crate) fn get_progress(db: &DB, progress_key: &DbMetadataKey) -> Result<Option<Version>> {
    Ok(db
        .get::<DbMetadataSchema>(progress_key)?
        .map(|v| v.expect_version()))
}
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** types/src/transaction/mod.rs (L98-98)
```rust
pub type Version = u64; // Height - also used for MVCC in StateDB
```
