# Audit Report

## Title
Unvalidated Block Gas Limit Override Enables Transaction Censorship and Gas Limit Bypass

## Summary
The `get_transactions` method returns a block gas limit value that is used without validation when `enable_per_block_gas_limit` is enabled. A malicious block proposer can set arbitrary gas limit values (e.g., 0 to censor all transactions, or u64::MAX to bypass gas limits entirely), violating the "Resource Limits" invariant.

## Finding Description
The `TPayloadManager::get_transactions` trait method returns a tuple `(Vec<SignedTransaction>, Option<u64>, Option<u64>)` where the third field is a per-block gas limit override. [1](#0-0) 

This gas limit value flows through the consensus pipeline and is applied via `BlockExecutorConfigFromOnchain.with_block_gas_limit_override()` [2](#0-1) 

The block executor then uses this override value to determine when to stop executing transactions: [3](#0-2) [4](#0-3) 

**Critical Issue**: There is **no validation** of the gas limit value returned by payload managers. The code even contains a TODO comment acknowledging this gap: [5](#0-4) 

A malicious proposer constructing a `QuorumStoreInlineHybridV2` or `OptQuorumStore` payload can set arbitrary gas limit values: [6](#0-5) 

**Attack Scenarios**:

1. **Transaction Censorship**: Set `gas_limit = 0` or `gas_limit = 1`
   - The executor will stop after block metadata, censoring all user transactions
   - Violates liveness and denies service to users

2. **Gas Limit Bypass**: Set `gas_limit = u64::MAX`  
   - Bypasses the on-chain gas limit entirely
   - Could enable resource exhaustion attacks
   - Violates the "Resource Limits: All operations must respect gas, storage, and computational limits" invariant

The vulnerability is active when `enable_per_block_gas_limit` is true: [7](#0-6) 

While this flag defaults to false [8](#0-7) , it can be enabled via governance and is present in ExecutionConfigV5/V6/V7.

## Impact Explanation
**Severity: Medium to High**

When `enable_per_block_gas_limit` is enabled:
- **Transaction Censorship**: A malicious proposer can censor all user transactions in blocks they propose by setting extremely low gas limits, creating targeted denial of service
- **Gas Limit Bypass**: Setting very high limits bypasses intended resource controls, potentially enabling resource exhaustion
- **Liveness Impact**: Systematic censorship by multiple validators could degrade network usability

This meets **Medium Severity** criteria ("State inconsistencies requiring intervention") and potentially **High Severity** ("Significant protocol violations") depending on validator behavior.

## Likelihood Explanation
**Likelihood: Medium**

Prerequisites:
1. Network governance must enable `enable_per_block_gas_limit` (currently false by default)
2. Attacker must be a validator with proposing rights
3. Network must use QuorumStoreInlineHybridV2 or OptQuorumStore payload types

The TODO comment indicates this validation gap is known but unfixed, suggesting it may become exploitable when the feature is fully deployed.

## Recommendation

Add validation for the block gas limit override value. The limit should be bounded by reasonable minimum and maximum values relative to the on-chain gas limit configuration:

**Suggested fix in `consensus/src/consensus_observer/network/observer_message.rs`**:

```rust
// In verify_against_ordered_payload method, around line 697:
Payload::QuorumStoreInlineHybridV2(
    inline_batches,
    proof_with_data,
    execution_limits,
) => {
    // Verify the batches in the requested block
    self.verify_batches(&proof_with_data.proofs)?;

    // Verify the inline batches
    self.verify_inline_batches(inline_batches)?;

    // Verify the transaction limit
    self.verify_transaction_limit(execution_limits.max_txns_to_execute())?;

    // Verify the block gas limit
    if let Some(gas_limit) = execution_limits.block_gas_limit() {
        self.verify_block_gas_limit(gas_limit)?;
    }
},
```

Add a new validation method:

```rust
fn verify_block_gas_limit(&self, gas_limit: u64) -> Result<(), Error> {
    // Ensure gas limit is non-zero and within reasonable bounds
    const MIN_BLOCK_GAS_LIMIT: u64 = 1000; // Enough for block metadata
    const MAX_BLOCK_GAS_LIMIT: u64 = 1_000_000_000; // Reasonable upper bound
    
    if gas_limit < MIN_BLOCK_GAS_LIMIT {
        return Err(Error::InvalidMessageError(format!(
            "Block gas limit {} is below minimum {}", 
            gas_limit, MIN_BLOCK_GAS_LIMIT
        )));
    }
    
    if gas_limit > MAX_BLOCK_GAS_LIMIT {
        return Err(Error::InvalidMessageError(format!(
            "Block gas limit {} exceeds maximum {}", 
            gas_limit, MAX_BLOCK_GAS_LIMIT
        )));
    }
    
    Ok(())
}
```

## Proof of Concept

```rust
// PoC demonstrating the vulnerability flow
// File: test_gas_limit_bypass.rs

#[test]
fn test_malicious_gas_limit_censorship() {
    // Setup: Create a block with QuorumStoreInlineHybridV2 payload
    // with gas_limit set to 0
    let malicious_payload = BlockTransactionPayload::new_quorum_store_inline_hybrid(
        transactions,
        proofs,
        Some(100), // transaction_limit
        Some(0),   // MALICIOUS: gas_limit = 0 to censor all txns
        inline_batches,
        true, // enable_payload_v2
    );
    
    // When enable_per_block_gas_limit is true, this will cause
    // the executor to stop after block metadata, censoring all user txns
    
    // The executor's block_gas_limit() will return Some(0)
    // Then should_end_block() will trigger immediately since
    // accumulated_gas (after metadata) >= 0 is always true
}

#[test]  
fn test_malicious_gas_limit_bypass() {
    // Setup: Create payload with extremely high gas limit
    let malicious_payload = BlockTransactionPayload::new_quorum_store_inline_hybrid(
        transactions,
        proofs,
        Some(1000),
        Some(u64::MAX), // MALICIOUS: bypass all gas limits
        inline_batches,
        true,
    );
    
    // This bypasses the on-chain block gas limit entirely
    // allowing resource exhaustion
}
```

## Notes

This vulnerability violates the **Deterministic Execution** and **Resource Limits** invariants. While all validators would execute identically (preventing consensus splits), malicious proposers can abuse the lack of validation to either censor transactions or bypass resource controls. The TODO comment at line 697 confirms this is a known validation gap that requires remediation before `enable_per_block_gas_limit` is widely deployed.

### Citations

**File:** consensus/src/payload_manager/mod.rs (L50-55)
```rust
    /// Get the transactions in a block's payload. This function returns a vector of transactions.
    async fn get_transactions(
        &self,
        block: &Block,
        block_voters: Option<BitVec>,
    ) -> ExecutorResult<(Vec<SignedTransaction>, Option<u64>, Option<u64>)>;
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L799-801)
```rust
        let (user_txns, block_gas_limit) = prepare_fut.await?;
        let onchain_execution_config =
            onchain_execution_config.with_block_gas_limit_override(block_gas_limit);
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L119-125)
```rust
    fn block_gas_limit(&self) -> Option<u64> {
        if self.block_gas_limit_override.is_some() {
            self.block_gas_limit_override
        } else {
            self.block_gas_limit_type.block_gas_limit()
        }
    }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L128-141)
```rust
        if let Some(per_block_gas_limit) = self.block_gas_limit() {
            // When the accumulated block gas of the committed txns exceeds
            // PER_BLOCK_GAS_LIMIT, early halt BlockSTM.
            let accumulated_block_gas = self.get_effective_accumulated_block_gas();
            if accumulated_block_gas >= per_block_gas_limit {
                counters::EXCEED_PER_BLOCK_GAS_LIMIT_COUNT.inc_with(&[mode]);
                info!(
                    "[BlockSTM]: execution ({}) early halted due to \
                    accumulated_block_gas {} >= PER_BLOCK_GAS_LIMIT {}",
                    mode, accumulated_block_gas, per_block_gas_limit,
                );
                return true;
            }
        }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L532-556)
```rust
    /// Creates a returns a new QuorumStoreInlineHybrid transaction payload
    pub fn new_quorum_store_inline_hybrid(
        transactions: Vec<SignedTransaction>,
        proofs: Vec<ProofOfStore<BatchInfo>>,
        transaction_limit: Option<u64>,
        gas_limit: Option<u64>,
        inline_batches: Vec<BatchInfo>,
        enable_payload_v2: bool,
    ) -> Self {
        let payload_with_proof = PayloadWithProof::new(transactions, proofs);
        if enable_payload_v2 {
            let proof_with_limits = TransactionsWithProof::TransactionsWithProofAndLimits(
                TransactionsWithProofAndLimits::new(
                    payload_with_proof,
                    transaction_limit,
                    gas_limit,
                ),
            );
            Self::QuorumStoreInlineHybridV2(proof_with_limits, inline_batches)
        } else {
            let proof_with_limit =
                PayloadWithProofAndLimit::new(payload_with_proof, transaction_limit);
            Self::QuorumStoreInlineHybrid(proof_with_limit, inline_batches)
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L697-697)
```rust
                // TODO: verify the block gas limit?
```

**File:** types/src/block_executor/config.rs (L155-161)
```rust
    pub fn block_gas_limit_override(&self) -> Option<u64> {
        if self.enable_per_block_gas_limit {
            self.per_block_gas_limit
        } else {
            None
        }
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L128-128)
```rust
            enable_per_block_gas_limit: false,
```
