# Audit Report

## Title
Unvalidated Git Repository Source in Genesis Generation Enables Complete Chain Compromise

## Summary
The genesis generation system accepts arbitrary GitHub repositories without validating that they belong to trusted sources (e.g., `aptos-labs`). An attacker can provide a malicious repository containing compromised validator configurations, backdoored Move framework code, and manipulated chain parameters, leading to complete blockchain compromise.

## Finding Description

The `GitOptions::get_client()` function creates a client that can fetch genesis configuration files from any GitHub repository without validation. [1](#0-0) 

When a GitHub repository is specified, the code only validates the format (`owner/repository`) but not the trustworthiness of the source. [2](#0-1) 

The `GithubClient::new()` constructor accepts any owner/repository combination without checking if it's from an authorized source. [3](#0-2) 

This vulnerability is exploited during genesis generation when critical chain initialization files are fetched from the repository:

1. **Layout configuration** containing chain parameters, validator set, and consensus configuration [4](#0-3) 

2. **Move framework bytecode** that runs all smart contracts on the chain [5](#0-4) 

3. **Validator configurations** including consensus keys, network keys, and stake amounts [6](#0-5) 

4. **Account balances** determining initial token distribution [7](#0-6) 

**Attack Scenario:**
1. Attacker creates repository `malicious-actor/fake-aptos-genesis` with poisoned configuration files
2. Via social engineering, documentation manipulation, or typosquatting (`apto-labs` instead of `aptos-labs`), victim is convinced to use: `aptos genesis generate-genesis --github-repository malicious-actor/fake-aptos-genesis --github-token-file token.txt`
3. Genesis blob is generated with attacker-controlled validator keys, backdoored framework, and manipulated balances
4. Chain is launched with compromised genesis, giving attacker complete control

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program:

1. **Consensus/Safety Violations**: Malicious validator configurations can compromise the consensus protocol by injecting attacker-controlled validator keys with majority stake, enabling arbitrary block production and finalization.

2. **Loss of Funds (Minting)**: Manipulated account balances in `balances.yaml` allow attackers to mint arbitrary amounts of APT tokens at genesis.

3. **Remote Code Execution**: Backdoored Move framework bytecode executes on all validator nodes, enabling arbitrary code execution as the framework is loaded during VM initialization and executed for every transaction.

4. **Governance Integrity Violation**: Malicious genesis can grant attacker addresses governance voting power, enabling complete control over on-chain governance proposals and feature flags.

5. **Access Control Bypass**: Framework code controls system addresses (`@aptos_framework`, `@core_resources`), allowing attackers to manipulate core protocol functionality.

The impact is **total chain compromise** - all critical invariants (deterministic execution, consensus safety, governance integrity, access control) are broken.

## Likelihood Explanation

**Likelihood: Medium**

While the automated genesis ceremony uses `--local-repository-dir`, the GitHub repository feature is documented and functional. Attack vectors include:

1. **Social Engineering**: Malicious tutorials/documentation directing users to compromised repositories
2. **Typosquatting**: Similar repository names (e.g., `aptos-lab/aptos-core` vs `aptos-labs/aptos-core`)
3. **Infrastructure Compromise**: Automated scripts modified to point to malicious repositories
4. **Insider Threat**: Malicious operator during genesis ceremony

The lack of any validation or allowlist makes exploitation straightforward once an attacker can influence the repository parameter through any of these vectors.

## Recommendation

Implement a repository allowlist validation in `GitOptions::get_client()`:

```rust
impl GitOptions {
    pub fn get_client(self) -> CliTypedResult<Client> {
        if self.github_repository.is_none()
            && self.github_token_file.is_none()
            && self.local_repository_dir.is_some()
        {
            Ok(Client::local(self.local_repository_dir.unwrap()))
        } else if self.github_repository.is_some()
            && self.github_token_file.is_some()
            && self.local_repository_dir.is_none()
        {
            // VALIDATION: Only allow trusted repository sources
            let repo = self.github_repository.as_ref().unwrap();
            const TRUSTED_OWNERS: &[&str] = &["aptos-labs", "aptos-foundation"];
            
            if !TRUSTED_OWNERS.contains(&repo.owner.as_str()) {
                return Err(CliError::CommandArgumentError(
                    format!(
                        "Untrusted repository owner '{}'. Only repositories from {} are allowed for genesis generation.",
                        repo.owner,
                        TRUSTED_OWNERS.join(", ")
                    )
                ));
            }
            
            Client::github(
                self.github_repository.unwrap(),
                self.github_branch,
                self.github_token_file.unwrap(),
            )
        } else {
            Err(CliError::CommandArgumentError("Must provide either only --local-repository-dir or both --github-repository and --github-token-path".to_string()))
        }
    }
}
```

Additionally, add a warning when using GitHub repositories and require explicit confirmation for non-standard repository owners.

## Proof of Concept

```bash
# Step 1: Create malicious repository
# On GitHub, create repository "attacker/malicious-aptos-genesis"
# with poisoned configuration files

# Step 2: Create malicious layout.yaml with attacker's validator
cat > malicious_layout.yaml << EOF
---
root_key: "0xATTACKER_ROOT_KEY_HERE"
users:
  - attacker_validator
chain_id: 99
allow_new_validators: false
epoch_duration_secs: 7200
is_test: true
min_stake: 100000000000000
min_voting_threshold: 100000000000000
max_stake: 100000000000000000
recurring_lockup_duration_secs: 86400
required_proposer_stake: 100000000000000
rewards_apy_percentage: 10
voting_duration_secs: 43200
voting_power_increase_limit: 50
EOF

# Step 3: Create attacker validator configuration
# owner.yaml, operator.yaml with attacker-controlled keys

# Step 4: Create malicious framework.mrb
# Framework bytecode with backdoor in critical modules

# Step 5: Upload to GitHub repository "attacker/malicious-aptos-genesis"

# Step 6: Generate genesis using malicious repository
aptos genesis generate-genesis \
    --github-repository attacker/malicious-aptos-genesis \
    --github-branch main \
    --github-token-file ~/.github-token \
    --output-dir ./compromised_genesis

# Result: genesis.blob and waypoint.txt generated with attacker's configuration
# Chain launched with this genesis is completely compromised
```

The vulnerability is exploitable without any special privileges - only the ability to convince an operator to use a specific repository parameter during genesis generation.

### Citations

**File:** crates/aptos/src/genesis/git.rs (L70-84)
```rust
impl FromStr for GithubRepo {
    type Err = CliError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<_> = s.split('/').collect();
        if parts.len() != 2 {
            Err(CliError::CommandArgumentError("Invalid repository must be of the form 'owner/repository` e.g. 'aptos-labs/aptos-core'".to_string()))
        } else {
            Ok(GithubRepo {
                owner: parts.first().unwrap().to_string(),
                repository: parts.get(1).unwrap().to_string(),
            })
        }
    }
}
```

**File:** crates/aptos/src/genesis/git.rs (L110-128)
```rust
    pub fn get_client(self) -> CliTypedResult<Client> {
        if self.github_repository.is_none()
            && self.github_token_file.is_none()
            && self.local_repository_dir.is_some()
        {
            Ok(Client::local(self.local_repository_dir.unwrap()))
        } else if self.github_repository.is_some()
            && self.github_token_file.is_some()
            && self.local_repository_dir.is_none()
        {
            Client::github(
                self.github_repository.unwrap(),
                self.github_branch,
                self.github_token_file.unwrap(),
            )
        } else {
            Err(CliError::CommandArgumentError("Must provide either only --local-repository-dir or both --github-repository and --github-token-path".to_string()))
        }
    }
```

**File:** crates/aptos/src/genesis/git.rs (L230-247)
```rust
    pub fn get_framework(&self) -> CliTypedResult<ReleaseBundle> {
        match self {
            Client::Local(local_repository_path) => {
                let path = local_repository_path.join(FRAMEWORK_NAME);
                if !path.exists() {
                    return Err(CliError::UnableToReadFile(
                        path.display().to_string(),
                        "File not found".to_string(),
                    ));
                }
                Ok(ReleaseBundle::read(path)?)
            },
            Client::Github(client) => {
                let bytes = base64::decode(client.get_file(FRAMEWORK_NAME)?)?;
                Ok(bcs::from_bytes::<ReleaseBundle>(&bytes)?)
            },
        }
    }
```

**File:** crates/aptos-github-client/src/lib.rs (L74-81)
```rust
    pub fn new(owner: String, repository: String, branch: String, token: String) -> Self {
        Self {
            branch,
            owner,
            repository,
            token,
        }
    }
```

**File:** crates/aptos/src/genesis/mod.rs (L139-140)
```rust
    let client = git_options.get_client()?;
    let layout: Layout = client.get(Path::new(LAYOUT_FILE))?;
```

**File:** crates/aptos/src/genesis/mod.rs (L152-153)
```rust
    let account_balance_map: AccountBalanceMap = client.get(Path::new(BALANCES_FILE))?;
    let accounts: Vec<AccountBalance> = account_balance_map.try_into()?;
```

**File:** crates/aptos/src/genesis/mod.rs (L197-197)
```rust
    let validators = get_validator_configs(&client, &layout, true).map_err(parse_error)?;
```
