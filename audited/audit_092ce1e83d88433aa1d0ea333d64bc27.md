# Audit Report

## Title
Missing Invariant Validation in PersistedValue Allows Inconsistent Batch Metadata and Payload State

## Summary
The `PersistedValue` structure can be constructed and persisted to the database with `None` payload while having `BatchInfo` metadata indicating transactions exist (`num_txns > 0`, `num_bytes > 0`). No validation enforces consistency between the payload state and batch metadata at construction, serialization, or deserialization time, creating potential for node crashes and consensus disruption.

## Finding Description

The `PersistedValue` type stores batch information and an optional payload in the quorum store database. The structure has two fields: `info: T` (containing `BatchInfo` metadata like transaction count and byte size) and `maybe_payload: Option<Vec<SignedTransaction>>`. [1](#0-0) 

The constructor accepts any combination of metadata and payload without validation: [2](#0-1) 

The `payload_storage_mode()` method derives the storage mode from whether the payload exists: [3](#0-2) 

This creates an invariant violation scenario where:
- `BatchInfo` has `num_txns = 100` and `num_bytes = 50000` (indicating transactions should exist)
- `maybe_payload = None` 
- `payload_storage_mode()` returns `StorageMode::PersistedOnly`

The database save operations perform no validation: [4](#0-3) [5](#0-4) 

The database schema uses raw BCS serialization without validation: [6](#0-5) [7](#0-6) 

When retrieving batches, the code assumes payloads exist and will panic if they don't: [8](#0-7) 

If `get_batch_from_local` returns a `PersistedValue` with `None` payload (due to database corruption, serialization bug, or future code error), the `.expect("Must have payload")` will cause a node panic.

The `get_batch_from_db` method returns whatever is in the database without validation: [9](#0-8) 

## Impact Explanation

**Severity: Medium**

This vulnerability falls under the Medium severity category: "State inconsistencies requiring intervention."

**Impact on Consensus Node Availability:**
- If a corrupted `PersistedValue` with `None` payload but non-zero `num_txns` is persisted to the database, the node will panic when attempting to retrieve and use that batch
- This causes validator downtime and degraded consensus performance
- Multiple validators experiencing this simultaneously could impact network liveness

**Attack Vectors:**
1. **Database Corruption**: File system corruption or hardware failure could create invalid serialized states
2. **Future Code Bugs**: New code that incorrectly constructs `PersistedValue` objects could introduce this state
3. **Serialization Vulnerabilities**: A bug in BCS deserialization could produce malformed objects

**Why Not Critical:**
- Does not directly cause consensus safety violations or fund loss
- Requires external corruption or a separate bug to trigger
- Can be recovered by database repair or node restart
- Does not affect deterministic execution across honest validators

## Likelihood Explanation

**Likelihood: Low-Medium**

**Factors Increasing Likelihood:**
- No defensive validation at multiple critical points (constructor, save, load)
- Database operations lack integrity checks
- Future code changes could inadvertently create invalid states
- Hardware/filesystem failures can corrupt RocksDB databases

**Factors Decreasing Likelihood:**
- Current code paths in `batch_store.rs` correctly persist the original payload to DB
- Normal operation creates valid `PersistedValue` objects from `Batch` conversions
- Requires either corruption or a future bug to manifest

**Real-World Scenarios:**
- Validator node experiencing disk corruption during write
- Software update introducing a bug in batch handling
- Race condition in concurrent database access

## Recommendation

Add validation at three critical points to enforce the invariant that `maybe_payload` must be `Some` when `num_txns > 0` or `num_bytes > 0`:

**1. Constructor validation:**
```rust
pub(crate) fn new(info: T, maybe_payload: Option<Vec<SignedTransaction>>) -> anyhow::Result<Self> {
    // Validate consistency between metadata and payload
    if info.num_txns() > 0 || info.num_bytes() > 0 {
        anyhow::ensure!(
            maybe_payload.is_some(),
            "PersistedValue must have payload when num_txns ({}) or num_bytes ({}) > 0",
            info.num_txns(),
            info.num_bytes()
        );
    }
    Ok(Self {
        info,
        maybe_payload,
    })
}
```

**2. Database save validation:**
```rust
fn save_batch(&self, batch: PersistedValue<BatchInfo>) -> Result<(), DbError> {
    // Validate before persisting
    if batch.num_txns() > 0 && batch.payload().is_none() {
        return Err(DbError::Other(anyhow::anyhow!(
            "Cannot save batch with transactions but no payload: digest {}",
            batch.digest()
        )));
    }
    self.put::<BatchSchema>(batch.digest(), &batch)
}
```

**3. Database load validation:**
```rust
fn get_batch(&self, digest: &HashValue) -> Result<Option<PersistedValue<BatchInfo>>, DbError> {
    let value = self.db.get::<BatchSchema>(digest)?;
    if let Some(ref v) = value {
        if v.num_txns() > 0 && v.payload().is_none() {
            warn!("Database contains invalid batch with missing payload: {}", digest);
            return Err(DbError::DataCorruption);
        }
    }
    Ok(value)
}
```

**4. Add safe payload extraction:**
```rust
// In get_or_fetch_batch
let payload = value.take_payload()
    .ok_or_else(|| ExecutorError::InternalError {
        error: format!("Batch {} missing payload", batch_digest)
    })?;
```

## Proof of Concept

```rust
#[test]
fn test_persisted_value_invariant_violation() {
    use crate::quorum_store::types::PersistedValue;
    use aptos_consensus_types::proof_of_store::BatchInfo;
    use aptos_types::{account_address::AccountAddress, quorum_store::BatchId};
    use aptos_crypto::HashValue;
    
    // Create BatchInfo indicating 100 transactions exist
    let batch_info = BatchInfo::new(
        AccountAddress::random(),
        BatchId::new_for_test(1),
        1, // epoch
        1000000, // expiration
        HashValue::random(), // digest
        100, // num_txns - indicates transactions exist!
        50000, // num_bytes - indicates non-zero size!
        0, // gas_bucket_start
    );
    
    // BUG: Can create PersistedValue with None payload despite metadata
    let invalid_value = PersistedValue::new(batch_info, None);
    
    // This returns PersistedOnly, implying payload is persisted somewhere
    assert_eq!(invalid_value.payload_storage_mode(), StorageMode::PersistedOnly);
    
    // But payload is actually None - INVARIANT VIOLATION!
    assert!(invalid_value.payload().is_none());
    assert_eq!(invalid_value.num_txns(), 100);
    assert_eq!(invalid_value.num_bytes(), 50000);
    
    // Now save to database - NO VALIDATION!
    let tmp_dir = TempPath::new();
    let db = QuorumStoreDB::new(&tmp_dir);
    assert!(db.save_batch(invalid_value.clone()).is_ok()); // Should fail but doesn't!
    
    // Read back from database - still no validation
    let retrieved = db.get_batch(invalid_value.digest())
        .expect("DB read failed")
        .expect("Batch not found");
    
    // Attempting to use this batch will panic
    // In batch_store.rs line 691: value.take_payload().expect("Must have payload")
    // This would crash the node!
    assert!(retrieved.payload().is_none()); // Invalid state persisted!
}
```

## Notes

While current code paths correctly persist full payloads to the database, the complete absence of validation creates a fragile system vulnerable to:
1. Database corruption creating invalid states that crash nodes on read
2. Future code changes introducing bugs that violate this invariant
3. Serialization/deserialization issues producing malformed objects

The defensive programming principle requires validating invariants at system boundaries (construction, persistence, retrieval) to prevent cascading failures and provide clear error messages rather than panics.

### Citations

**File:** consensus/src/quorum_store/types.rs (L21-25)
```rust
#[derive(Clone, Eq, Deserialize, Serialize, PartialEq, Debug)]
pub struct PersistedValue<T> {
    info: T,
    maybe_payload: Option<Vec<SignedTransaction>>,
}
```

**File:** consensus/src/quorum_store/types.rs (L34-39)
```rust
    pub(crate) fn new(info: T, maybe_payload: Option<Vec<SignedTransaction>>) -> Self {
        Self {
            info,
            maybe_payload,
        }
    }
```

**File:** consensus/src/quorum_store/types.rs (L41-46)
```rust
    pub(crate) fn payload_storage_mode(&self) -> StorageMode {
        match self.maybe_payload {
            Some(_) => StorageMode::MemoryAndPersisted,
            None => StorageMode::PersistedOnly,
        }
    }
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L110-117)
```rust
    fn save_batch(&self, batch: PersistedValue<BatchInfo>) -> Result<(), DbError> {
        trace!(
            "QS: db persists digest {} expiration {:?}",
            batch.digest(),
            batch.expiration()
        );
        self.put::<BatchSchema>(batch.digest(), &batch)
    }
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L140-147)
```rust
    fn save_batch_v2(&self, batch: PersistedValue<BatchInfoExt>) -> Result<(), DbError> {
        trace!(
            "QS: db persists digest {} expiration {:?}",
            batch.digest(),
            batch.expiration()
        );
        self.put::<BatchV2Schema>(batch.digest(), &batch)
    }
```

**File:** consensus/src/quorum_store/schema.rs (L38-46)
```rust
impl ValueCodec<BatchSchema> for PersistedValue<BatchInfo> {
    fn encode_value(&self) -> Result<Vec<u8>> {
        Ok(bcs::to_bytes(&self)?)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
}
```

**File:** consensus/src/quorum_store/schema.rs (L68-76)
```rust
impl ValueCodec<BatchV2Schema> for PersistedValue<BatchInfoExt> {
    fn encode_value(&self) -> Result<Vec<u8>> {
        Ok(bcs::to_bytes(&self)?)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
}
```

**File:** consensus/src/quorum_store/batch_store.rs (L545-569)
```rust
    fn get_batch_from_db(
        &self,
        digest: &HashValue,
        is_v2: bool,
    ) -> ExecutorResult<PersistedValue<BatchInfoExt>> {
        counters::GET_BATCH_FROM_DB_COUNT.inc();

        if is_v2 {
            match self.db.get_batch_v2(digest) {
                Ok(Some(value)) => Ok(value),
                Ok(None) | Err(_) => {
                    warn!("Could not get batch from db");
                    Err(ExecutorError::CouldNotGetData)
                },
            }
        } else {
            match self.db.get_batch(digest) {
                Ok(Some(value)) => Ok(value.into()),
                Ok(None) | Err(_) => {
                    warn!("Could not get batch from db");
                    Err(ExecutorError::CouldNotGetData)
                },
            }
        }
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L684-692)
```rust
                let fut = async move {
                    let batch_digest = *batch_info.digest();
                    defer!({
                        inflight_requests_clone.lock().remove(&batch_digest);
                    });
                    // TODO(ibalajiarun): Support V2 batch
                    if let Ok(mut value) = batch_store.get_batch_from_local(&batch_digest) {
                        Ok(value.take_payload().expect("Must have payload"))
                    } else {
```
