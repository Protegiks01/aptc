# Audit Report

## Title
Version-Slot Mapping Corruption in Indexer-GRPC Data Manager Due to Enumerate-Skip Order Bug

## Summary
A critical bug in `DataManager::update_data()` causes transactions to be stored at incorrect slot positions due to improper interaction between `.enumerate()` and `.skip()` iterator adapters, combined with variable shadowing. This allows `get_data()` to return transaction data for version X+k when version X is requested, violating data integrity guarantees of the indexer service.

## Finding Description

The vulnerability exists in the `update_data()` function where transactions are inserted into the circular buffer cache. [1](#0-0) 

The root cause involves two interconnected issues:

**Issue 1: Variable Shadowing**
Line 70 shadows the parameter `start_version` with a local variable that holds `start_version.max(self.start_version)`. This changes the semantic meaning of `start_version` used in the loop from "the version of the first input transaction" to "the first version we should actually process."

**Issue 2: Enumerate-Before-Skip**
The iteration chain uses `.enumerate().skip(num_to_skip)` instead of `.skip(num_to_skip).enumerate()`. In Rust, `.enumerate()` assigns indices starting from 0 for ALL elements, then `.skip(n)` discards the first n elements but keeps their original indices.

**The Bug Combination:**
When `update_data(start_version_param, transactions)` is called where `start_version_param < self.start_version`:

1. `num_to_skip = self.start_version - start_version_param` (e.g., 5000 - 4500 = 500)
2. `start_version` (local) = `max(4500, 5000) = 5000` (shadowed variable)
3. Enumeration creates pairs: `(0, tx4500), (1, tx4501), ..., (500, tx5000), ...`
4. Skip(500) yields: `(500, tx5000), (501, tx5001), ...` with indices preserved
5. Loop calculates: `version = start_version + i = 5000 + 500 = 5500` for first element
6. **Result: tx5000 stored at slot 5500 % num_slots instead of slot 5000 % num_slots**

This creates a systematic offset where every transaction is stored `num_to_skip` slots ahead of where it should be.

**Exploitation Path:**
When `get_data(version)` is subsequently called, it retrieves `data[version % num_slots]` without validating the actual transaction version. [2](#0-1) 

Since transactions are misplaced by the offset, requesting version X will return the transaction that was stored at that slot, which could be version X-offset or X+offset depending on cache progression.

**Concrete Example:**
- Cache: num_slots=1000, currently contains [5000, 5100)
- Call: `update_data(4500, [tx4500...tx5199])` (700 transactions)
- Expected: tx5000 at slot 0, tx5001 at slot 1, etc.
- Actual: tx5000 at slot 500, tx5001 at slot 501, etc.
- After update: cache claims [4200, 5200) but slots are corrupted
- Client request for version 5000: gets slot 0, which may contain stale/wrong data
- Client request for version 5500: gets slot 500, which contains tx5000 (wrong!)

The Transaction protobuf includes a version field [3](#0-2) , so clients can detect the mismatch, but the indexer has already violated its data integrity guarantee by serving incorrect data.

## Impact Explanation

**Severity: High (up to $50,000)**

This vulnerability breaks the fundamental data integrity guarantee of the indexer service. While this is not a consensus-layer bug, it affects critical infrastructure that applications rely on:

1. **Data Integrity Violation**: Indexer clients receive incorrect transaction data when requesting specific versions, breaking the trust model between indexer and downstream applications.

2. **Application Logic Corruption**: DApps, wallets, and analytics tools querying the indexer for historical transactions will receive wrong data, potentially causing:
   - Incorrect balance calculations
   - Failed transaction verification
   - Corrupted application state reconstruction
   - Auditing and compliance failures

3. **Silent Failure**: The bug doesn't cause crashes or obvious errors. The indexer appears to function normally while serving corrupted data, making detection difficult.

4. **Systemic Impact**: All indexer instances running this code are affected, impacting the entire Aptos ecosystem that depends on indexer data.

This qualifies as **High Severity** under the "Significant protocol violations" and "API crashes" categories, as it fundamentally breaks the indexer's data retrieval API contract.

## Likelihood Explanation

**Likelihood: High**

This bug triggers in production scenarios:

1. **Common Trigger Condition**: The bug activates whenever `update_data()` receives a batch of transactions that partially overlaps with the cache's valid range (i.e., `start_version < self.start_version < end_version`). This is **not** an edge case.

2. **Normal Operation Pattern**: When the indexer catches up after:
   - Brief network disconnections
   - Temporary upstream data source delays
   - Cache evictions forcing re-fetching of recent data
   - Multiple concurrent data fetchers providing overlapping ranges

3. **No Special Privileges Required**: Any indexer instance running this code will exhibit the bug during normal operation. No attacker manipulation needed.

4. **Deterministic Behavior**: Once triggered, the bug consistently corrupts data in a predictable pattern based on the offset calculation.

The combination of common trigger conditions and production-realistic scenarios makes exploitation highly likely during normal indexer operation.

## Recommendation

**Fix: Correct the enumerate/skip order and eliminate variable shadowing**

Replace lines 69-86 with:

```rust
let num_to_skip = self.start_version.saturating_sub(start_version);

let mut size_increased = 0;
let mut size_decreased = 0;

for (i, transaction) in transactions
    .into_iter()
    .skip(num_to_skip as usize)  // Skip BEFORE enumerate
    .enumerate()                  // Enumerate AFTER skip
{
    let version = start_version.max(self.start_version) + i as u64;  // Or use original start_version + num_to_skip + i
    let slot_index = version as usize % self.num_slots;
    if let Some(old_transaction) = self.data[slot_index].take() {
        size_decreased += old_transaction.encoded_len();
    }
    size_increased += transaction.encoded_len();
    self.data[slot_index] = Some(Box::new(transaction));
}
```

**Key changes:**
1. `.skip(num_to_skip).enumerate()` instead of `.enumerate().skip(num_to_skip)` - ensures `i` starts from 0 after skipping
2. Remove variable shadowing by keeping `start_version` as parameter
3. Calculate `version` correctly accounting for the skip offset
4. Use a different variable name (`old_transaction`) for the shadowed transaction in the if-let

**Alternative (more explicit):**
```rust
let first_version_to_process = start_version.max(self.start_version);
for (i, transaction) in transactions
    .into_iter()
    .skip(num_to_skip as usize)
    .enumerate()
{
    let version = first_version_to_process + i as u64;
    // ... rest of the logic
}
```

## Proof of Concept

**Rust Test Case:**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_protos::transaction::v1::Transaction;

    #[test]
    fn test_version_slot_mapping_corruption() {
        // Setup: cache with 100 slots, initially empty but claiming to contain [100, 200)
        let mut data_manager = DataManager::new(200, 100, 1_000_000);
        data_manager.start_version = 100;
        
        // Create test transactions for versions 50-149 (100 transactions)
        let mut transactions = Vec::new();
        for v in 50..150 {
            let mut tx = Transaction::default();
            tx.version = v;
            transactions.push(tx);
        }
        
        // Call update_data with start_version=50
        // This should skip first 50 transactions and process versions 100-149
        data_manager.update_data(50, transactions);
        
        // BUG CHECK: Due to the enumerate().skip() bug:
        // - num_to_skip = 100 - 50 = 50
        // - start_version (local) = max(50, 100) = 100
        // - First processed tx is transactions[50] (version 100), with i=50
        // - Calculated version = 100 + 50 = 150
        // - tx100 gets stored at slot 150 % 100 = 50 instead of slot 0
        
        // Verify the bug: slot 50 should contain tx150, but actually contains tx100
        let retrieved = data_manager.get_data(150);
        if let Some(tx) = retrieved.as_ref() {
            assert_eq!(tx.version, 100, "BUG CONFIRMED: Slot for version 150 contains tx100!");
        }
        
        // Verify: requesting version 100 gets wrong data
        let retrieved_100 = data_manager.get_data(100);
        if let Some(tx) = retrieved_100.as_ref() {
            // Slot 0 (100 % 100) might contain old data or be empty
            // Either way, it's not tx100 which is actually at slot 50
            assert_ne!(tx.version, 100, "Version 100 retrieves wrong transaction");
        }
    }
}
```

**Expected Output:** Test fails, demonstrating that version 150's slot contains transaction with version 100, confirming the mapping corruption.

**Real-World Scenario:**
```
1. Indexer starts with cache [5000, 6000), num_slots=1000
2. Upstream provides batch starting at version 4500 with 700 transactions [4500, 5200)
3. update_data(4500, [tx4500...tx5199]) is called
4. Bug triggers: num_to_skip=500, transactions stored at wrong slots
5. Client queries version 5500 via gRPC GetTransactions
6. Indexer returns tx5000 (from slot 500) instead of tx5500
7. Client's Transaction.version field shows 5000, not 5500
8. Application using this data experiences state corruption
```

This demonstrates a concrete, reproducible violation of the indexer's data integrity guarantee with realistic production parameters.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L40-42)
```rust
    pub(super) fn get_data(&self, version: u64) -> &Option<Box<Transaction>> {
        &self.data[version as usize % self.num_slots]
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L69-86)
```rust
        let num_to_skip = self.start_version.saturating_sub(start_version);
        let start_version = start_version.max(self.start_version);

        let mut size_increased = 0;
        let mut size_decreased = 0;

        for (i, transaction) in transactions
            .into_iter()
            .enumerate()
            .skip(num_to_skip as usize)
        {
            let version = start_version + i as u64;
            let slot_index = version as usize % self.num_slots;
            if let Some(transaction) = self.data[slot_index].take() {
                size_decreased += transaction.encoded_len();
            }
            size_increased += transaction.encoded_len();
            self.data[version as usize % self.num_slots] = Some(Box::new(transaction));
```

**File:** protos/proto/aptos/transaction/v1/transaction.proto (L40-42)
```text
message Transaction {
  aptos.util.timestamp.Timestamp timestamp = 1;
  uint64 version = 2 [jstype = JS_STRING];
```
