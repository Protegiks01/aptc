# Audit Report

## Title
Consensus Safety Violation: Validator Private Key Export Enables Multi-Instance Double-Signing Attacks

## Summary
Aptos validators can export their consensus private keys and run multiple validator instances with independent safety storage, enabling double-signing attacks that violate BFT consensus safety guarantees. The vulnerability arises from the combination of unrestricted private key export functionality and per-instance (rather than globally coordinated) safety rule enforcement.

## Finding Description

The Aptos consensus implementation uses `SafetyRules` to prevent double-signing through tracking `last_voted_round` and caching the `last_vote` in persistent storage. However, this protection is local to each `SafetyRules` instance and relies on a single storage backend.

**Vulnerability Components:**

1. **Unrestricted Private Key Export**: The `CryptoStorage` trait provides `export_private_key()` methods that allow extraction of consensus private keys from secure storage. [1](#0-0) 

2. **Per-Instance Safety State**: Each `SafetyRules` instance maintains its own `PersistentSafetyStorage` with local tracking of `last_voted_round` and `last_vote`. [2](#0-1) 

3. **Local-Only Vote Prevention**: The double-signing prevention check only examines the local storage's `last_voted_round`. [3](#0-2) 

4. **Exportable Keys by Default**: Vault storage creates keys with `exportable: true`, allowing private key retrieval. [4](#0-3) 

**Attack Scenario:**

A malicious validator operator can:
1. Export their consensus private key using the `export_private_key()` API
2. Deploy two separate validator nodes (Node A and Node B) with independent storage backends
3. Import the same consensus private key into both storage instances
4. At consensus round N:
   - Node A's SafetyRules checks its local storage, finds no vote for round N, signs Block X
   - Node B's SafetyRules checks its separate storage, finds no vote for round N, signs Block Y
5. Both nodes broadcast conflicting votes to the network

Each SafetyRules instance independently validates its local state and permits signing, as neither instance knows about the other's vote. [5](#0-4) 

**Why Post-Facto Detection is Insufficient:**

While the consensus layer detects equivocation when votes are received, this detection occurs after both conflicting votes have been signed and distributed. [6](#0-5) 

Furthermore, **no slashing mechanism exists** to penalize detected equivocation. The delegation pool module explicitly notes that slashing is not implemented. [7](#0-6) 

## Impact Explanation

**Severity: Critical** - This vulnerability constitutes a **Consensus Safety Violation**, which is explicitly listed as Critical severity in the Aptos Bug Bounty program.

This attack breaks the fundamental **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine." 

A single malicious validator with 7% voting power running two instances effectively becomes two independent voters with 7% each, allowing violations of the 1/3 Byzantine threshold. With enough validators participating, this could cause:
- Chain splits where different honest validators commit different blocks
- Double-spending if conflicting transactions appear in competing blocks
- Complete loss of consensus finality

This meets the Critical severity criteria of "Consensus/Safety violations" with potential for "Non-recoverable network partition."

## Likelihood Explanation

**Likelihood: Medium to High**

Required conditions:
- Attacker must be a legitimate validator operator (privileged access)
- Attacker must export their consensus key and set up multiple instances
- No technical barriers prevent this exploitation - all required APIs are publicly available

Mitigating factors:
- Requires validator operator cooperation (insider threat)
- Equivocation would be detected by network monitoring
- Reputation damage to validator operator

However, the **absence of slashing penalties** reduces the deterrent effect, and the attack could be executed during critical moments (governance votes, epoch transitions) for maximum impact before detection.

## Recommendation

Implement multiple defense layers:

**1. Prevent Key Export for Consensus Keys**
Remove or restrict the `export_private_key()` functionality for consensus keys specifically, or require hardware-backed key storage (HSM/TPM) that prevents extraction.

**2. Implement Hardware-Based Key Protection**
Require consensus keys to be generated and stored in non-exportable hardware security modules where private keys cannot be extracted.

**3. Add Cryptographic Vote Binding**
Bind each validator's vote to a deterministic sequence that prevents multiple instances from signing conflicting votes even with the same key.

**4. Implement Slashing for Equivocation**
Add automatic stake slashing when equivocation is detected to provide economic disincentive.

**5. Global Safety State Coordination** (if key export must remain)
If key export cannot be prevented, implement distributed coordination for safety state (e.g., consensus on consensus metadata) so multiple instances with the same key would share vote history.

## Proof of Concept

```rust
// This PoC demonstrates the vulnerability conceptually
// Actual exploitation requires validator infrastructure setup

use aptos_crypto::bls12381;
use aptos_secure_storage::{CryptoStorage, InMemoryStorage, Storage};
use consensus_safety_rules::{SafetyRules, PersistentSafetyStorage};

fn exploit_double_signing() {
    // Step 1: Export consensus private key from existing validator
    let validator_storage = Storage::from(InMemoryStorage::new());
    let consensus_key = validator_storage
        .export_private_key("consensus_key")
        .expect("Export consensus key");
    
    // Step 2: Create two independent SafetyRules instances
    // Instance A with storage backend A
    let storage_a = Storage::from(InMemoryStorage::new());
    storage_a.import_private_key("consensus_key", consensus_key.clone());
    let safety_storage_a = PersistentSafetyStorage::new(storage_a, true);
    let mut safety_rules_a = SafetyRules::new(safety_storage_a, false);
    
    // Instance B with storage backend B (separate/independent)
    let storage_b = Storage::from(InMemoryStorage::new());
    storage_b.import_private_key("consensus_key", consensus_key);
    let safety_storage_b = PersistentSafetyStorage::new(storage_b, true);
    let mut safety_rules_b = SafetyRules::new(safety_storage_b, false);
    
    // Step 3: Both instances can sign different blocks at the same round
    // Instance A signs block X at round N
    let vote_a = safety_rules_a.construct_and_sign_vote_two_chain(
        &vote_proposal_x, None
    ).expect("Sign vote A");
    
    // Instance B signs block Y at round N (conflict!)
    let vote_b = safety_rules_b.construct_and_sign_vote_two_chain(
        &vote_proposal_y, None  
    ).expect("Sign vote B"); // This succeeds - double-signing!
    
    // Both votes are valid signatures from the same validator
    // but for different blocks at the same round
    assert_eq!(vote_a.author(), vote_b.author());
    assert_eq!(vote_a.vote_data().proposed().round(), 
               vote_b.vote_data().proposed().round());
    assert_ne!(vote_a.vote_data().proposed().id(),
               vote_b.vote_data().proposed().id());
}
```

## Notes

This vulnerability requires the attacker to already be a validator operator (insider threat scenario as explicitly requested in the security question). While BFT consensus tolerates Byzantine validators, this design flaw allows a single Byzantine validator to effectively multiply their voting power by running multiple independent instances, potentially breaking the < 1/3 Byzantine fault tolerance threshold. The combination of exportable keys and instance-local safety rules creates a fundamental weakness in consensus safety enforcement.

### Citations

**File:** secure/storage/src/crypto_storage.rs (L16-17)
```rust
    /// Returns the Ed25519 private key stored at 'name'.
    fn export_private_key(&self, name: &str) -> Result<Ed25519PrivateKey, Error>;
```

**File:** consensus/safety-rules/src/safety_rules.rs (L41-48)
```rust
pub struct SafetyRules {
    pub(crate) persistent_storage: PersistentSafetyStorage,
    pub(crate) validator_signer: Option<ValidatorSigner>,
    pub(crate) epoch_state: Option<EpochState>,
    // Skip verification of signatures and well-formed, this can be set if it's used in local mode
    // where consensus already verifies.
    pub(crate) skip_sig_verify: bool,
}
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** secure/storage/src/vault.rs (L202-204)
```rust
        self.client().create_ed25519_key(&ns_name, true)?;
        self.get_public_key(name).map(|v| v.public_key)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L66-74)
```rust
        let mut safety_data = self.persistent_storage.safety_data()?;

        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }
```

**File:** consensus/src/pending_votes.rs (L287-308)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L153-157)
```text
    /// Slashing (if implemented) should not be applied to already `inactive` stake.
    /// Not only it invalidates the accounting of past observed lockup cycles (OLC),
    /// but is also unfair to delegators whose stake has been inactive before validator started misbehaving.
    /// Additionally, the inactive stake does not count on the voting power of validator.
    const ESLASHED_INACTIVE_STAKE_ON_PAST_OLC: u64 = 7;
```
