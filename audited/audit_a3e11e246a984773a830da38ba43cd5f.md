# Audit Report

## Title
Check 2 in verify_order_vote_proposal() is NOT Redundant - Essential Defense Against OrderVoteProposal Structural Invariant Violations

## Summary
The second validation check at lines 103-108 in `safety_rules.rs` is **not redundant** with the first check at lines 97-102. It catches a critical edge case where an `OrderVoteProposal` has mismatched `block` and `block_info` fields, preventing consensus safety violations. This is NOT a hash collision or `PartialEq` bug, but rather detection of structural invariant violations.

## Finding Description

The two checks serve distinct purposes:

**Check 1 (lines 97-102)**: [1](#0-0) 

This verifies that the QuorumCert's certified block matches the `block_info` field in the proposal using full `BlockInfo` equality.

**Check 2 (lines 103-108)**: [2](#0-1) 

This verifies that the QuorumCert's certified block ID matches the actual `Block` object's ID in the proposal.

The `OrderVoteProposal` structure contains three separate fields: [3](#0-2) 

The constructor does not validate that `block.id() == block_info.id()`: [4](#0-3) 

**The Edge Case**: When `order_vote_proposal.block_info().id() != proposed_block.id()`, Check 1 can pass (if the QC certifies the `block_info`) while Check 2 fails (because the QC doesn't certify the actual `block`).

This scenario is **explicitly tested** in the codebase: [5](#0-4) 

In this test case, `ov3` has:
- `block`: p2 (with id = hash_p2)
- `block_info`: p1's BlockInfo (with id = hash_p1)  
- `quorum_cert`: certifies p1

This passes Check 1 but **correctly fails** Check 2, demonstrating the checks are not redundant.

**Why This Matters**: In `guarded_construct_and_sign_order_vote()`, the safety validation uses the `block` object, but the signature is created for the `block_info`: [6](#0-5) 

Without Check 2, a validator could be tricked into signing an order vote for one block while safety checks ran on a different block, causing consensus safety violations.

## Impact Explanation

This is **NOT a vulnerability** in the current codebase because Check 2 is present and functioning correctly. However, removing Check 2 would create a **High Severity** vulnerability (Aptos bug bounty category: "Significant protocol violations") because:

1. It could lead to consensus safety violations where validators sign order votes for blocks they didn't properly validate
2. Different validators could sign order votes for different blocks
3. This breaks the consensus safety invariant

The current code is secure due to the presence of both checks working in tandem.

## Likelihood Explanation

In normal operation, `OrderVoteProposal` is created via `PipelinedBlock::order_vote_proposal()`: [7](#0-6) 

Where `block_info()` correctly derives from the block: [8](#0-7) 

The edge case could only occur through:
1. Programming errors in creating `OrderVoteProposal`
2. IPC manipulation when SafetyRules runs remotely (via serializer): [9](#0-8) 
3. Fuzzing/testing scenarios (already covered by tests)

## Recommendation

**No fix needed** - the code is currently secure. Both checks should be retained as they serve complementary validation purposes:

1. Check 1 validates QC consistency with the proposal's `block_info`
2. Check 2 validates internal consistency between `block` and `block_info` fields

To improve code clarity, consider adding a comment explaining why both checks are necessary, or add an explicit invariant check in `OrderVoteProposal::new()`:

```rust
pub fn new(block: Block, block_info: BlockInfo, quorum_cert: Arc<QuorumCert>) -> Self {
    debug_assert_eq!(
        block.id(),
        block_info.id(),
        "OrderVoteProposal invariant violated: block.id() must equal block_info.id()"
    );
    Self {
        block,
        block_info,
        quorum_cert,
    }
}
```

## Proof of Concept

The existing test case demonstrates the edge case: [10](#0-9) 

Running this test confirms that Check 2 correctly rejects malformed `OrderVoteProposal` instances where the block and block_info IDs don't match.

---

**Notes:**
- This is **not a hash collision** - the BlockInfo `PartialEq` implementation is correctly derived and compares all fields
- This is **not a `PartialEq` bug** - the implementation works as designed  
- The checks are **complementary, not redundant** - Check 1 validates external consistency (QC ↔ block_info), Check 2 validates internal consistency (block ↔ block_info)
- The current implementation is **secure** with both checks present
- Tests confirm the validation logic works correctly

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L97-102)
```rust
        if qc.certified_block() != order_vote_proposal.block_info() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                order_vote_proposal.block_info().id(),
            ));
        }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L103-108)
```rust
        if qc.certified_block().id() != proposed_block.id() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                proposed_block.id(),
            ));
        }
```

**File:** consensus/consensus-types/src/order_vote_proposal.rs (L15-22)
```rust
pub struct OrderVoteProposal {
    #[serde(bound(deserialize = "Block: Deserialize<'de>"))]
    block: Block,
    /// BlockInfo for the above block
    block_info: BlockInfo,
    /// QuorumCert for the above block
    quorum_cert: Arc<QuorumCert>,
}
```

**File:** consensus/consensus-types/src/order_vote_proposal.rs (L25-31)
```rust
    pub fn new(block: Block, block_info: BlockInfo, quorum_cert: Arc<QuorumCert>) -> Self {
        Self {
            block,
            block_info,
            quorum_cert,
        }
    }
```

**File:** consensus/safety-rules/src/tests/suite.rs (L212-248)
```rust
fn test_order_votes_incorrect_qc(safety_rules: &Callback) {
    let (mut safety_rules, signer) = safety_rules();

    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    let round = genesis_qc.certified_block().round();

    let data = random_payload(2048);

    let p0 = test_utils::make_proposal_with_qc(round + 1, genesis_qc.clone(), &signer);
    let p1 = test_utils::make_proposal_with_parent(data.clone(), round + 2, &p0, None, &signer);
    let p2 = test_utils::make_proposal_with_parent(data.clone(), round + 3, &p1, None, &signer);
    let p3 = test_utils::make_proposal_with_parent(data, round + 4, &p2, Some(&p0), &signer);

    let ov1 = OrderVoteProposal::new(
        p0.block().clone(),
        p1.block().quorum_cert().certified_block().clone(),
        Arc::new(p1.block().quorum_cert().clone()),
    );
    let ov2 = OrderVoteProposal::new(
        p1.block().clone(),
        p3.block().quorum_cert().certified_block().clone(),
        Arc::new(p2.block().quorum_cert().clone()),
    );
    let ov3 = OrderVoteProposal::new(
        p2.block().clone(),
        p2.block().quorum_cert().certified_block().clone(),
        Arc::new(p2.block().quorum_cert().clone()),
    );

    safety_rules.initialize(&proof).unwrap();

    safety_rules.construct_and_sign_order_vote(&ov1).unwrap();

    assert_err!(safety_rules.construct_and_sign_order_vote(&ov2));

    assert_err!(safety_rules.construct_and_sign_order_vote(&ov3));
}
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L104-116)
```rust
        let proposed_block = order_vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // Record 1-chain data
        self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

        self.safe_for_order_vote(proposed_block, &safety_data)?;
        // Construct and sign order vote
        let author = self.signer()?.author();
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
        let signature = self.sign(&ledger_info)?;
        let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-459)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L471-473)
```rust
    pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
        OrderVoteProposal::new(self.block.clone(), self.block_info(), quorum_cert)
    }
```

**File:** consensus/safety-rules/src/serializer.rs (L32-32)
```rust
    ConstructAndSignOrderVote(Box<OrderVoteProposal>),
```
