# Audit Report

## Title
Veiled Coin Balance Overflow Attack - Permanent Fund Locking via Unchecked Homomorphic Addition

## Summary
The `veiled_deposit()` function in the veiled coin module performs homomorphic ElGamal ciphertext addition without verifying that the resulting balance remains within the decryptable discrete logarithm range of [0, 2^32). An attacker can repeatedly deposit coins to a victim's veiled account, causing the encrypted balance to exceed the computationally feasible discrete logarithm solving limit, permanently locking the victim's funds.

## Finding Description

The veiled coin system uses ElGamal encryption "in the exponent" where values are encrypted as `v * G` on the Ristretto255 curve. [1](#0-0) 

Decryption requires solving the discrete logarithm problem, which is only feasible for values up to approximately 2^32 to 2^40 operations using baby-step giant-step algorithms. [2](#0-1) 

The system maintains a critical invariant that all veiled balances must remain in [0, 2^32) to ensure decryptability. [3](#0-2) 

However, the `veiled_deposit()` function violates this invariant by performing homomorphic addition without range proof verification. [4](#0-3) 

**Attack Path:**
1. Victim Alice registers a veiled account with balance B < 2^32
2. Attacker Mallory repeatedly calls `veil_to(alice_address, 2^32 - 1)` 
3. Each call homomorphically adds to Alice's encrypted balance without verification [5](#0-4) 
4. After N deposits: Alice's balance ≈ B + N × (2^32 - 1)
5. When balance exceeds 2^40, discrete log solving becomes computationally infeasible
6. Alice cannot decrypt her balance or withdraw (withdrawal requires range proof showing balance ∈ [0, 2^32))

**Contrast with Correct Implementation:**
The `unveil_to_internal()` and `fully_veiled_transfer_internal()` functions correctly verify range proofs on the resulting balance. [6](#0-5) [7](#0-6) 

But `veiled_deposit()` has no such verification, creating an asymmetry where withdrawals are properly protected but deposits are not.

The entry functions `veil_to()` and `veil()` expose this vulnerability to unprivileged attackers. [8](#0-7) 

## Impact Explanation

**Severity: CRITICAL** - Permanent freezing of funds

This vulnerability meets the Critical severity criteria per the Aptos bug bounty program:
- **Permanent freezing of funds**: Once a victim's balance exceeds the decryptable range, their coins are permanently locked and unrecoverable without a hardfork
- **Loss of Funds**: The victim loses access to all veiled coins in their account
- **No recovery mechanism**: The encrypted balance cannot be decrypted, and all withdrawal attempts will fail because the victim cannot generate valid range proofs

The attack requires no special permissions - any user with sufficient normal coins can execute it against any registered veiled account. The cost to the attacker is only the normal coins deposited (which they permanently lose to the victim's locked account), making this an economically viable griefing attack.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely because:
1. **Simple execution**: Requires only repeated calls to a public entry function `veil_to()`
2. **No special permissions**: Any user can execute this attack
3. **Deterministic outcome**: The math guarantees the balance will exceed decryptable range after sufficient deposits
4. **Observable target**: Veiled accounts are publicly visible through the `VeiledCoinStore` resource
5. **Economic feasibility**: Attacker needs ~256 deposits of 2^32-1 coins to push balance beyond 2^40 (total cost ~1.1 × 10^12 base units)

The only barrier is the attacker must have access to normal coins to deposit, but this is readily available through the standard coin system.

## Recommendation

Add range proof verification to `veiled_deposit()` to ensure the recipient's new balance remains in [0, 2^32):

```move
public fun veiled_deposit<CoinType>(
    to_addr: address, coin: VeiledCoin<CoinType>
) acquires VeiledCoinStore {
    assert!(
        has_veiled_coin_store<CoinType>(to_addr),
        error::not_found(EVEILED_COIN_STORE_NOT_PUBLISHED)
    );

    let veiled_coin_store = borrow_global_mut<VeiledCoinStore<CoinType>>(to_addr);
    let veiled_balance = elgamal::decompress_ciphertext(&veiled_coin_store.veiled_balance);
    
    // Add the veiled amount to the veiled balance
    elgamal::ciphertext_add_assign(&mut veiled_balance, &coin.veiled_amount);
    
    // NEW: Verify the new balance is still in range [0, 2^32)
    // This requires the depositor to provide a range proof commitment
    // Option 1: Require proof in VeiledCoin struct
    // Option 2: Check total_veiled_coins() doesn't exceed max balance
    // Option 3: Maintain running sum and reject deposits that would overflow
    
    veiled_coin_store.veiled_balance = elgamal::compress_ciphertext(&veiled_balance);
    let VeiledCoin<CoinType> { veiled_amount: _ } = coin;
    event::emit(Deposit { user: to_addr });
}
```

**Note**: The fix requires architectural changes because `veiled_deposit()` doesn't currently receive the randomness or commitment needed for range proof verification. The proper solution would be to:

1. Modify `VeiledCoin` struct to include a range proof for the deposited amount
2. Track cumulative deposits per account and reject deposits that would cause overflow
3. Or restrict deposits to only occur through `fully_veiled_transfer_internal()` where both parties provide proofs

## Proof of Concept

```move
#[test(deployer = @aptos_experimental, alice = @0xa11ce, mallory = @0xba5eba11)]
#[expected_failure(abort_code = ERANGE_PROOF_VERIFICATION_FAILED, location = Self)]
public fun test_balance_overflow_attack(
    deployer: &signer,
    alice: &signer, 
    mallory: &signer
) acquires VeiledCoinStore, VeiledCoinMinter {
    // Setup
    init_module_for_testing(deployer);
    let (alice_sk, alice_pk) = helpers::generate_elgamal_keypair();
    register_internal<AptosCoin>(alice, alice_pk);
    
    // Alice deposits initial balance of 100 coins
    coin::register<AptosCoin>(alice);
    aptos_coin::mint(deployer, signer::address_of(alice), 100_000_000); // 100 coins
    veil<AptosCoin>(alice, 100);
    
    // Mallory executes attack - repeatedly deposits max amount
    coin::register<AptosCoin>(mallory);
    let max_amount: u32 = 0xFFFFFFFF; // 2^32 - 1
    
    // Deposit 256 times to push balance over 2^40
    for (i in 0..256) {
        aptos_coin::mint(deployer, signer::address_of(mallory), cast_u32_to_u64_amount(max_amount));
        veil_to<AptosCoin>(mallory, signer::address_of(alice), max_amount);
    };
    
    // Now Alice's balance is approximately 256 * 2^32 ≈ 2^40
    // Alice cannot decrypt this balance (would require ~2^40 discrete log operations)
    // Alice cannot withdraw because she cannot prove new_balance ∈ [0, 2^32)
    
    // Attempt withdrawal - this will fail with range proof verification error
    let withdraw_amount: u32 = 50;
    let comm_new_balance = pedersen::new_commitment_for_bulletproof(&alice_sk, ...);
    let zkrp = bulletproofs::prove_range(...);
    unveil<AptosCoin>(alice, withdraw_amount, comm_new_balance, zkrp, ...);
    // This aborts because the actual balance > 2^32, making valid range proof impossible
}
```

The victim's veiled coins are permanently frozen, requiring a blockchain hardfork to recover.

### Citations

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_elgamal.move (L4-9)
```text
/// An ElGamal *ciphertext* is an encryption of a value `v` under a basepoint `G` and public key `Y = sk * G`, where `sk`
/// is the corresponding secret key, is `(v * G + r * Y, r * G)`, for a random scalar `r`.
///
/// Note that we place the value `v` "in the exponent" of `G` so that ciphertexts are additively homomorphic: i.e., so
/// that `Enc_Y(v, r) + Enc_Y(v', r') = Enc_Y(v + v', r + r')` where `v, v'` are plaintext messages, `Y` is a public key and `r, r'`
/// are the randomness of the ciphertexts.
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L63-64)
```text
/// scheme. Currently, our best candidate is ElGamal encryption in the exponent, which can only decrypt values around
/// 32 bits or slightly larger.
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L276-284)
```text
    public entry fun veil_to<CoinType>(
        sender: &signer, recipient: address, amount: u32
    ) acquires VeiledCoinMinter, VeiledCoinStore {
        let c = coin::withdraw<CoinType>(sender, cast_u32_to_u64_amount(amount));

        let vc = veiled_mint_from_coin(c);

        veiled_deposit<CoinType>(recipient, vc)
    }
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L543-568)
```text
    public fun veiled_deposit<CoinType>(
        to_addr: address, coin: VeiledCoin<CoinType>
    ) acquires VeiledCoinStore {
        assert!(
            has_veiled_coin_store<CoinType>(to_addr),
            error::not_found(EVEILED_COIN_STORE_NOT_PUBLISHED)
        );

        let veiled_coin_store = borrow_global_mut<VeiledCoinStore<CoinType>>(to_addr);

        // Fetch the veiled balance
        let veiled_balance =
            elgamal::decompress_ciphertext(&veiled_coin_store.veiled_balance);

        // Add the veiled amount to the veiled balance (leverages the homomorphism of the encryption scheme)
        elgamal::ciphertext_add_assign(&mut veiled_balance, &coin.veiled_amount);

        // Update the veiled balance
        veiled_coin_store.veiled_balance = elgamal::compress_ciphertext(&veiled_balance);

        // Make sure the veiled coin is dropped so it cannot be double spent
        let VeiledCoin<CoinType> { veiled_amount: _ } = coin;

        // Once successful, emit an event that a veiled deposit occurred.
        event::emit(Deposit { user: to_addr });
    }
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L605-610)
```text
        verify_range_proofs(
            &comm_new_balance,
            &withdrawal_proof.zkrp_new_balance,
            &std::option::none(),
            &std::option::none()
        );
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L673-678)
```text
        verify_range_proofs(
            &comm_new_balance,
            &transfer_proof.zkrp_new_balance,
            &std::option::some(comm_amount),
            &std::option::some(transfer_proof.zkrp_amount)
        );
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L708-723)
```text
        // the veild coin code: i.e., that every account has `new_bal \in [0, 2^{32})`.
        //
        // This invariant is enforced as follows:
        //
        //  1. We assume (by the invariant) that `bal \in [0, 2^{32})`.
        //
        //  2. We verify a ZK range proof that `amount \in [0, 2^{32})`. Otherwise, a sender could set `amount = p-1`
        //     where `p` is the order of the scalar field, which would give `new_bal = bal - (p-1) mod p = bal + 1`.
        //     Therefore, a malicious spender could create coins out of thin air for themselves.
        //
        //  3. We verify a ZK range proof that `new_bal \in [0, 2^{32})`. Otherwise, a sender could set `amount = bal + 1`,
        //     which would satisfy condition (2) from above but would give `new_bal = bal - (bal + 1) = -1`. Therefore,
        //     a malicious spender could spend more coins than they have.
        //
        // Altogether, these checks ensure that `bal - amount >= 0` (as integers) and therefore that `bal >= amount`
        // (again, as integers).
```
