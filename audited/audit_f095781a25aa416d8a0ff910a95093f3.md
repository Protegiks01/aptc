# Audit Report

## Title
Path Traversal via Symlink in Indexer Backup Service Allowing Arbitrary File Exfiltration

## Summary
The `create_tar_gz()` function in the indexer backup service does not canonicalize the `dir_path` parameter before archiving, allowing an attacker with filesystem access to create symlinks that cause the service to backup and upload arbitrary directories to GCS, potentially exposing sensitive files including private keys and credentials.

## Finding Description

The vulnerability exists in the backup flow for the indexer-grpc table-info service: [1](#0-0) 

The `create_tar_gz()` function receives a `dir_path` parameter and uses it directly without canonicalization. The path is passed to `tar_builder.append_dir_all()` which will follow symlinks.

The attack vector exists in how snapshots are discovered for backup: [2](#0-1) 

The `backup_snapshot_if_present()` function scans the data directory using `path.is_dir()`, which returns `true` for symlinks pointing to directories. An attacker who can create a symlink named `snapshot_chain_X_epoch_Y` pointing to an arbitrary directory (e.g., `/etc/`, `/root/.ssh/`, or key storage directories) can trigger the following attack chain:

1. Symlink passes the `is_dir()` check
2. Path is reconstructed and passed to `backup_db_snapshot_and_update_metadata()`
3. `create_tar_gz()` archives the symlink target without canonicalization
4. The tar.gz containing sensitive files is uploaded to GCS
5. Attacker retrieves the backup from GCS to access sensitive data [3](#0-2) 

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria due to significant information disclosure that could lead to:

1. **Exposure of cryptographic keys**: Private validator keys, signing keys, or wallet keys
2. **Credential leakage**: Database passwords, API tokens, cloud service credentials
3. **System configuration exposure**: Network topology, security configurations
4. **Potential for privilege escalation**: Exposed keys could enable further attacks on validators or governance

While this is an indexer service rather than a validator node, the exposed information could compromise the broader Aptos infrastructure, particularly if keys or credentials for validator operations are stored on the same filesystem.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- Write access to the node's data directory to create the symlink
- Knowledge of the chain_id to construct the proper symlink name
- The backup service must be enabled

However, this could be exploited through:
- Compromised container environments with partial filesystem access
- Exploitation of other vulnerabilities that allow file creation
- Misconfigured permissions in multi-tenant deployments
- Race conditions or TOCTOU vulnerabilities in directory creation

Once the prerequisite access is obtained, the exploitation is deterministic and automated by the backup service itself.

## Recommendation

Canonicalize the `dir_path` parameter before use and validate it's within the expected directory:

```rust
pub fn create_tar_gz(dir_path: PathBuf, backup_file_name: &str) -> Result<PathBuf, anyhow::Error> {
    // Canonicalize to resolve symlinks and get absolute path
    let canonical_path = dir_path
        .canonicalize()
        .context("Failed to canonicalize directory path")?;
    
    // Validate the canonical path is within expected directory bounds
    // (implement based on your security requirements)
    
    let gz_encoder = GzEncoder::new(Vec::new(), Compression::fast());
    let tar_data = BufWriter::new(gz_encoder);
    let mut tar_builder = Builder::new(tar_data);
    
    aptos_logger::info!(
        dir_path = canonical_path.to_str(),
        backup_file_name = backup_file_name,
        "[Table Info] Creating a tar.gz archive from the db snapshot directory"
    );
    
    tar_builder
        .append_dir_all(".", &canonical_path)
        .context("Tar building failed.")?;
    
    // Rest of the function using canonical_path...
}
```

Additionally, add symlink detection in `backup_snapshot_if_present()`:

```rust
// Check if path is a symlink
if path.is_symlink() {
    aptos_logger::warn!(
        path = path.to_str(),
        "[Table Info] Skipping symlink in snapshot directory"
    );
    continue;
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod symlink_attack_test {
    use super::*;
    use std::os::unix::fs::symlink;
    use tempfile::tempdir;

    #[test]
    fn test_symlink_traversal_vulnerability() -> anyhow::Result<()> {
        // Create a temporary directory structure
        let temp_dir = tempdir()?;
        let data_dir = temp_dir.path();
        
        // Create a sensitive directory to target
        let sensitive_dir = tempdir()?;
        let secret_file = sensitive_dir.path().join("secret_key.pem");
        std::fs::write(&secret_file, "SUPER_SECRET_PRIVATE_KEY")?;
        
        // Create a symlink with snapshot naming convention
        let symlink_path = data_dir.join("snapshot_chain_1_epoch_999");
        symlink(sensitive_dir.path(), &symlink_path)?;
        
        // Verify symlink passes is_dir() check
        assert!(symlink_path.is_dir()); // This returns true!
        
        // Create tar.gz - this will archive the sensitive directory
        let tar_path = create_tar_gz(symlink_path, "test_backup")?;
        
        // Verify the tar contains the sensitive file
        let file = File::open(&tar_path)?;
        let gz_decoder = GzDecoder::new(file);
        let mut archive = Archive::new(gz_decoder);
        
        let mut found_secret = false;
        for entry in archive.entries()? {
            let entry = entry?;
            if entry.path()?.to_str().unwrap().contains("secret_key.pem") {
                found_secret = true;
                break;
            }
        }
        
        assert!(found_secret, "Vulnerability confirmed: sensitive file was archived via symlink");
        
        Ok(())
    }
}
```

## Notes

This vulnerability represents a defense-in-depth failure in the indexer backup service. While the primary attack vector requires filesystem access, the lack of path canonicalization creates an automated exfiltration channel that could be exploited in conjunction with other vulnerabilities or misconfigurations. The fix is straightforward and should be implemented to prevent potential information disclosure.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/backup_restore/fs_ops.rs (L56-68)
```rust
pub fn create_tar_gz(dir_path: PathBuf, backup_file_name: &str) -> Result<PathBuf, anyhow::Error> {
    // Create a buffer to write the tar.gz archive.
    let gz_encoder = GzEncoder::new(Vec::new(), Compression::fast());
    let tar_data = BufWriter::new(gz_encoder);
    let mut tar_builder = Builder::new(tar_data);
    aptos_logger::info!(
        dir_path = dir_path.to_str(),
        backup_file_name = backup_file_name,
        "[Table Info] Creating a tar.gz archive from the db snapshot directory"
    );
    tar_builder
        .append_dir_all(".", &dir_path)
        .context("Tar building failed.")?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L451-462)
```rust
        for entry in std::fs::read_dir(context.node_config.get_data_dir()).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();
            let file_name = path.file_name().unwrap().to_string_lossy();
            if path.is_dir()
                && file_name.starts_with(&target_snapshot_directory_prefix)
                && !file_name.ends_with(".tmp")
            {
                let epoch = file_name.replace(&target_snapshot_directory_prefix, "");
                let epoch = epoch.parse::<u64>().unwrap();
                epochs_to_backup.push(epoch);
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L600-603)
```rust
    backup_restore_operator
        .backup_db_snapshot_and_update_metadata(ledger_chain_id as u64, epoch, snapshot_dir.clone())
        .await
        .expect("Failed to upload snapshot in table info service");
```
