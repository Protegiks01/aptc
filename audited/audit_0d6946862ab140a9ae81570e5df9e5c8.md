# Audit Report

## Title
Permanent Account Lockout via Unvalidated Key Rotation in `rotate_authentication_key_from_public_key`

## Summary
The `rotate_authentication_key_from_public_key` function in the Aptos account module allows users to rotate their authentication key to cryptographically invalid Ed25519 public keys, resulting in permanent account lockout and frozen funds. The function's documentation promises validation but the implementation fails to perform cryptographic checks.

## Finding Description

The vulnerability exists in the `rotate_authentication_key_from_public_key` entry function, which explicitly documents that it "will abort if the scheme is not recognized or if new_public_key_bytes is not a valid public key for the given scheme." [1](#0-0) 

However, for `ED25519_SCHEME`, the implementation uses `ed25519::new_unvalidated_public_key_from_bytes`, which only validates the length (32 bytes) without performing any cryptographic validation. [2](#0-1) 

The `new_unvalidated_public_key_from_bytes` function only checks that the input is exactly 32 bytes long, with no verification that the bytes represent a valid elliptic curve point, are not in a small-order subgroup, or are non-zero. [3](#0-2) 

**Attack Path:**

1. Account owner calls `rotate_authentication_key_from_public_key` with 32 bytes of invalid Ed25519 key data (e.g., all zeros, small-order point, or invalid curve point)

2. The function creates an `UnvalidatedPublicKey` without validation, derives the authentication key, and updates the account [4](#0-3) 

3. When the user attempts to sign future transactions, the native signature verification function performs strict cryptographic validation. The `verify_arbitrary_msg` function explicitly states: "This function will check both the signature and `public_key` for small subgroup attacks." [5](#0-4) 

4. The Rust implementation calls `verify_strict`, which validates the public key cryptographically and returns `false` for invalid keys. [6](#0-5) 

5. The signature verification implementation in the native layer attempts to deserialize the public key but does not validate for small subgroups at that stage. However, `verify_strict` performs comprehensive validation including small subgroup checks. [7](#0-6) 

**Recovery:** Recovery is only possible if the user previously delegated rotation capability via `offer_rotation_capability`. The `rotate_authentication_key_with_rotation_capability` function properly validates keys because it requires a valid signature from the new key, which implicitly validates the key during signature verification. [8](#0-7) 

This breaks fundamental security guarantees:
- **Specification-Implementation Mismatch**: Function promises validation but doesn't perform it
- **Cryptographic Correctness**: System accepts cryptographically invalid authentication keys
- **Access Control Invariant**: Users permanently lose access to their accounts

## Impact Explanation

This qualifies as **Critical Severity** under the Aptos bug bounty program's "Permanent Freezing of Funds" category.

**Impact:**
- **Permanent Account Lockout**: Users cannot sign any future transactions with the invalid authentication key
- **Frozen Funds**: All assets in the account become permanently inaccessible
- **No Standard Recovery**: Without pre-delegated rotation capability (which most users don't set up), there is no recovery mechanism
- **Protocol Violation**: Violates the fundamental guarantee that valid accounts should be accessible to their owners

While this doesn't affect network consensus or liveness, it represents a critical failure in the account authentication system that can result in irreversible loss of user funds.

## Likelihood Explanation

**Likelihood: Medium**

While this requires the account owner to call the function with invalid key bytes, several realistic scenarios make this exploitable:

1. **Wallet Implementation Bugs**: A bug in wallet software's key generation or encoding logic could produce invalid 32-byte sequences that pass length checks but fail cryptographic validation

2. **API Misuse**: Developers integrating Aptos APIs might not understand that `ED25519_SCHEME` requires valid Ed25519 public keys, leading to incorrect key bytes being passed

3. **Malicious Temporary Access**: An attacker with temporary access to an account's signer could permanently lock the account as a denial-of-service attack (though stealing funds would typically be more profitable)

4. **User Error**: Users manually constructing transactions or copying key bytes could introduce errors

The function was designed to support "non-standard key algorithms, such as passkeys" that cannot produce standard proofs-of-knowledge [9](#0-8) , but this legitimate use case inadvertently created a vulnerability for standard Ed25519 keys.

## Recommendation

Add cryptographic validation for Ed25519 public keys in `rotate_authentication_key_from_public_key`:

```move
if (scheme == ED25519_SCHEME) {
    let from_pk = ed25519::new_unvalidated_public_key_from_bytes(new_public_key_bytes);
    // Add validation to ensure the public key is cryptographically valid
    assert!(
        ed25519::public_key_validate(&from_pk).is_some(),
        error::invalid_argument(E_INVALID_PUBLIC_KEY)
    );
    new_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
}
```

This uses the existing `public_key_validate` function which checks that the key is on the curve and not in a small subgroup [10](#0-9) , ensuring the documentation's promise is fulfilled.

## Proof of Concept

```move
#[test(account = @0x1234)]
fun test_invalid_key_rotation_lockout(account: &signer) {
    use aptos_framework::account;
    use std::vector;
    
    // Create account
    account::create_account_for_test(@0x1234);
    
    // Create invalid Ed25519 public key (32 bytes of zeros - not a valid curve point)
    let invalid_key = vector::empty<u8>();
    let i = 0;
    while (i < 32) {
        vector::push_back(&mut invalid_key, 0u8);
        i = i + 1;
    };
    
    // This should fail but currently succeeds
    account::rotate_authentication_key_from_public_key(
        account,
        0, // ED25519_SCHEME
        invalid_key
    );
    
    // Now the account is locked - any future transaction will fail signature verification
    // because the authentication key is derived from an invalid public key
}
```

## Notes

- This vulnerability specifically affects `ED25519_SCHEME` (0) and `MULTI_ED25519_SCHEME` (1), both of which use unvalidated key construction
- `SINGLE_KEY_SCHEME` (2) also uses `ed25519::new_unvalidated_public_key_from_bytes` internally [11](#0-10)  and may have similar issues
- The discrepancy between the function's documented behavior and actual implementation represents a specification violation that could lead developers to incorrectly assume validation occurs

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L452-458)
```text
    /// Private entry function for key rotation that allows the signer to update their authentication key.
    /// Note that this does not update the `OriginatingAddress` table because the `new_auth_key` is not "verified": it
    /// does not come with a proof-of-knowledge of the underlying SK. Nonetheless, we need this functionality due to
    /// the introduction of non-standard key algorithms, such as passkeys, which cannot produce proofs-of-knowledge in
    /// the format expected in `rotate_authentication_key`.
    ///
    /// If you'd like to followup with updating the `OriginatingAddress` table, you can call
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L464-465)
```text
    /// Private entry function for key rotation that allows the signer to update their authentication key from a given public key.
    /// This function will abort if the scheme is not recognized or if new_public_key_bytes is not a valid public key for the given scheme.
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L473-475)
```text
        if (scheme == ED25519_SCHEME) {
            let from_pk = ed25519::new_unvalidated_public_key_from_bytes(new_public_key_bytes);
            new_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L486-486)
```text
        rotate_authentication_key_call(account, new_auth_key);
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L683-716)
```text
    public entry fun rotate_authentication_key_with_rotation_capability(
        delegate_signer: &signer,
        rotation_cap_offerer_address: address,
        new_scheme: u8,
        new_public_key_bytes: vector<u8>,
        cap_update_table: vector<u8>
    ) acquires Account, OriginatingAddress {
        check_rotation_permission(delegate_signer);
        assert!(resource_exists_at(rotation_cap_offerer_address), error::not_found(EOFFERER_ADDRESS_DOES_NOT_EXIST));

        // Check that there exists a rotation capability offer at the offerer's account resource for the delegate.
        let delegate_address = signer::address_of(delegate_signer);
        let offerer_account_resource = &Account[rotation_cap_offerer_address];
        let old_auth_key = offerer_account_resource.authentication_key;
        assert!(
            offerer_account_resource.rotation_capability_offer.for.contains(&delegate_address),
            error::not_found(ENO_SUCH_ROTATION_CAPABILITY_OFFER)
        );

        let curr_auth_key = from_bcs::to_address(offerer_account_resource.authentication_key);
        let challenge = RotationProofChallenge {
            sequence_number: get_sequence_number(delegate_address),
            originator: rotation_cap_offerer_address,
            current_auth_key: curr_auth_key,
            new_public_key: new_public_key_bytes,
        };

        // Verifies that the `RotationProofChallenge` from above is signed under the new public key that we are rotating to.        l
        let new_auth_key = assert_valid_rotation_proof_signature_and_get_auth_key(
            new_scheme,
            new_public_key_bytes,
            cap_update_table,
            &challenge
        );
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.move (L73-76)
```text
    public fun new_unvalidated_public_key_from_bytes(bytes: vector<u8>): UnvalidatedPublicKey {
        assert!(bytes.length() == PUBLIC_KEY_NUM_BYTES, std::error::invalid_argument(E_WRONG_PUBKEY_SIZE));
        UnvalidatedPublicKey { bytes }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.move (L124-128)
```text
    /// Takes in an *unvalidated* public key and attempts to validate it.
    /// Returns `Some(ValidatedPublicKey)` if successful and `None` otherwise.
    public fun public_key_validate(pk: &UnvalidatedPublicKey): Option<ValidatedPublicKey> {
        new_validated_public_key_from_bytes(pk.bytes)
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.move (L130-138)
```text
    /// Verifies a purported Ed25519 `signature` under an *unvalidated* `public_key` on the specified `message`.
    /// This call will validate the public key by checking it is NOT in the small subgroup.
    public fun signature_verify_strict(
        signature: &Signature,
        public_key: &UnvalidatedPublicKey,
        message: vector<u8>
    ): bool {
        signature_verify_strict_internal(signature.bytes, public_key.bytes, message)
    }
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_sigs.rs (L126-139)
```rust
    fn verify_arbitrary_msg(&self, message: &[u8], public_key: &Ed25519PublicKey) -> Result<()> {
        // NOTE: ed25519::PublicKey::verify_strict already checks that the s-component of the signature
        // is not mauled, but does so via an optimistic path which fails into a slower path. By doing
        // our own (much faster) checking here, we can ensure dalek's optimistic path always succeeds
        // and the slow path is never triggered.
        Ed25519Signature::check_s_malleability(&self.to_bytes())?;

        // NOTE: ed25519::PublicKey::verify_strict checks that the signature's R-component and
        // the public key are *not* in a small subgroup.
        public_key
            .0
            .verify_strict(message, &self.0)
            .map_err(|e| anyhow!("{}", e))
            .and(Ok(()))
```

**File:** aptos-move/framework/src/natives/cryptography/ed25519.rs (L112-135)
```rust
    let pk = match ed25519::Ed25519PublicKey::try_from(pubkey.as_slice()) {
        Ok(pk) => pk,
        Err(_) => {
            return Ok(smallvec![Value::bool(false)]);
        },
    };

    context.charge(ED25519_PER_SIG_DESERIALIZE * NumArgs::one())?;

    let sig = match ed25519::Ed25519Signature::try_from(signature.as_slice()) {
        Ok(sig) => sig,
        Err(_) => {
            return Ok(smallvec![Value::bool(false)]);
        },
    };

    // NOTE(Gas): hashing the message to the group and a size-2 multi-scalar multiplication
    let hash_then_verify_cost = ED25519_PER_SIG_STRICT_VERIFY * NumArgs::one()
        + ED25519_PER_MSG_HASHING_BASE * NumArgs::one()
        + ED25519_PER_MSG_BYTE_HASHING * NumBytes::new(msg.len() as u64);
    context.charge(hash_then_verify_cost)?;

    let verify_result = sig.verify_arbitrary_msg(msg.as_slice(), &pk).is_ok();
    Ok(smallvec![Value::bool(verify_result)])
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/single_key.move (L77-79)
```text
        if (scheme_id == ED25519_PUBLIC_KEY_TYPE) {
            let public_key_bytes = bcs_stream::deserialize_vector(stream, |x| deserialize_u8(x));
            pk = AnyPublicKey::Ed25519{pk: ed25519::new_unvalidated_public_key_from_bytes(public_key_bytes)}
```
