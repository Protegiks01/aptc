# Audit Report

## Title
BCS Native Function Deep Copy Bypasses Gas Metering and Memory Quota Limits

## Summary
The `bcs::to_bytes()` native function performs an uncharged deep copy of Move values before serialization, allowing attackers to double their effective memory usage and CPU consumption without paying corresponding gas fees. This bypasses both gas metering and memory quota enforcement, enabling DoS attacks against validator nodes.

## Finding Description

The BCS serialization native function contains a critical gas metering bypass that violates resource limit invariants. When `bcs::to_bytes<T>(&T)` is called from Move code, the implementation performs the following sequence: [1](#0-0) 

The vulnerability occurs at line 93 where `ref_to_val.read_ref()?` is called. This operation performs a **complete deep copy** of the referenced value without any gas charging or memory quota tracking: [2](#0-1) 

The deep copy implementation recursively allocates new memory for all nested containers: [3](#0-2) 

**Why This is a Vulnerability:**

1. **Normal Read Reference Charges Gas**: When Move bytecode executes a `ReadRef` instruction, the VM properly charges gas through the meter: [4](#0-3) 

The gas formula is: `735 + 14 * abstract_value_size` internal gas units.

2. **BCS Native Bypasses This**: The BCS native calls `read_ref()` directly on the `Reference` type, completely bypassing the gas meter's `charge_read_ref()` function that would normally track both gas and memory usage: [5](#0-4) 

3. **Only Serialization Output is Charged**: After the expensive deep copy, only the serialized output size is charged at 36 internal gas units per byte: [6](#0-5) 

**Attack Scenario:**

1. Attacker creates a large value filling the memory quota (10,000,000 abstract value units): [7](#0-6) 

2. Example: Create a vector of 1,250,000 u64 values (each u64 costs 8 abstract units when packed in a vector): [8](#0-7) 

3. Call `bcs::to_bytes(&vector)` which:
   - Deep copies 1.25M u64 values (allocating ~10MB new memory) **WITHOUT charging gas or tracking against quota**
   - Serializes to ~10MB output
   - Charges only 10M bytes Ã— 36 = 360M internal gas = 360 external gas units

4. The deep copy doubles memory usage from 10M to 20M abstract units, exceeding the quota without detection.

5. With maximum gas of 2,000,000 external units, attacker can perform ~5,555 such operations per transaction, amplifying memory usage by 55GB and consuming massive CPU time for deep copies that were never charged. [9](#0-8) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program:

- **Validator Node Slowdowns**: The uncharged deep copy operations consume significant CPU time proportional to the value size. For 1.25M u64 values, the deep copy allocates and copies 10MB of data without charging corresponding gas.

- **Memory Quota Bypass**: The memory quota system is designed to prevent excessive memory usage per transaction. However, the deep copy creates a second copy of data without incrementing memory usage counters, effectively allowing attackers to use 2x their allocated memory quota.

- **CPU Amplification**: Attackers pay gas for creating the value once but force validators to allocate and copy it again during serialization, achieving a 2x CPU amplification factor.

- **Repeated Exploitation**: Within a single transaction's gas limit, attackers can call `bcs::to_bytes()` multiple times on the same large value, multiplying the amplification effect.

The TODO comment acknowledges this inefficiency but doesn't recognize it as a security issue: [10](#0-9) 

## Likelihood Explanation

**Likelihood: High**

- **Easy to Execute**: Any user can submit transactions calling `bcs::to_bytes()` on self-created values
- **No Special Permissions Required**: Standard transaction with normal gas limits
- **Repeatable**: Can be performed in every transaction block
- **Amplifiable**: Multiple calls per transaction multiply the effect
- **Already Acknowledged**: The TODO comment shows developers are aware of the inefficiency but haven't treated it as a security concern

## Recommendation

**Immediate Fix**: Charge gas for the deep copy operation before performing it. The BCS native should calculate the abstract value size and charge both gas and memory quota:

```rust
fn native_to_bytes(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // ... existing type layout code ...
    
    // ADDED: Charge gas and memory for the deep copy operation
    let abstract_value_size = context
        .vm_gas_params()
        .misc
        .abs_val
        .abstract_value_size_dereferenced(&ref_to_val, context.feature_version())?;
    
    // Charge gas for read_ref operation
    context.charge(READ_REF_BASE + READ_REF_PER_ABS_VAL_UNIT * abstract_value_size)?;
    
    // Track memory usage for the copy
    let heap_size = context
        .vm_gas_params()
        .misc
        .abs_val
        .abstract_heap_size(&ref_to_val, context.feature_version())?;
    context.use_heap_memory_in_native_context(heap_size.into())?;
    
    let val = ref_to_val.read_ref()?;
    
    // ... existing serialization code ...
}
```

**Long-term Fix**: Implement zero-copy serialization as suggested by the TODO comment, eliminating the need for deep copy entirely.

## Proof of Concept

```move
module attacker::dos_exploit {
    use std::bcs;
    use std::vector;

    /// Create a large vector and serialize it repeatedly to exhaust validator resources
    public entry fun exploit_bcs_dos() {
        // Create vector with ~1M u64 values (limited by memory quota)
        let large_vec = vector::empty<u64>();
        let i = 0;
        while (i < 1000000) {
            vector::push_back(&mut large_vec, i);
            i = i + 1;
        };
        
        // Serialize multiple times in one transaction
        // Each call deep copies 1M u64s without charging gas for the copy
        // With 2M gas limit, can do ~5000 serializations = 50GB memory amplification
        let j = 0;
        while (j < 5000) {
            let _serialized = bcs::to_bytes(&large_vec); // Deep copy NOT charged!
            j = j + 1;
        };
    }
}
```

**Expected Impact**: Transaction executes within gas limits but causes validator to allocate 50GB of temporary memory and spend excessive CPU time on uncharged deep copy operations, potentially causing node slowdown or OOM crashes.

## Notes

The vulnerability exists because native functions bypass the normal VM instruction gas metering. While the `ReadRef` VM instruction properly charges gas and tracks memory: [11](#0-10) 

The BCS native's direct call to `Reference::read_ref()` skips this entirely. The same issue affects `native_serialized_size()` which also performs a deep copy: [12](#0-11)

### Citations

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L91-111)
```rust
    // TODO(#14175): Reading the reference performs a deep copy, and we can
    //               implement it in a more efficient way.
    let val = ref_to_val.read_ref()?;

    let function_value_extension = context.function_value_extension();
    let max_value_nest_depth = context.max_value_nest_depth();
    let serialized_value = match ValueSerDeContext::new(max_value_nest_depth)
        .with_legacy_signer()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&val, &layout)?
    {
        Some(serialized_value) => serialized_value,
        None => {
            context.charge(BCS_TO_BYTES_FAILURE)?;
            return Err(SafeNativeError::Abort {
                abort_code: NFE_BCS_SERIALIZATION_FAILURE,
            });
        },
    };
    context
        .charge(BCS_TO_BYTES_PER_BYTE_SERIALIZED * NumBytes::new(serialized_value.len() as u64))?;
```

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L159-161)
```rust
    // TODO(#14175): Reading the reference performs a deep copy, and we can
    //               implement it in a more efficient way.
    let value = reference.read_ref()?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L628-669)
```rust
impl Container {
    fn copy_value(&self, depth: u64, max_depth: Option<u64>) -> PartialVMResult<Self> {
        fn copy_rc_ref_vec_val(
            r: &Rc<RefCell<Vec<Value>>>,
            depth: u64,
            max_depth: Option<u64>,
        ) -> PartialVMResult<Rc<RefCell<Vec<Value>>>> {
            let vals = r.borrow();
            let mut copied_vals = Vec::with_capacity(vals.len());
            for val in vals.iter() {
                copied_vals.push(val.copy_value(depth + 1, max_depth)?);
            }
            Ok(Rc::new(RefCell::new(copied_vals)))
        }

        Ok(match self {
            Self::Vec(r) => Self::Vec(copy_rc_ref_vec_val(r, depth, max_depth)?),
            Self::Struct(r) => Self::Struct(copy_rc_ref_vec_val(r, depth, max_depth)?),

            Self::VecU8(r) => Self::VecU8(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecU16(r) => Self::VecU16(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecU32(r) => Self::VecU32(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecU64(r) => Self::VecU64(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecU128(r) => Self::VecU128(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecU256(r) => Self::VecU256(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecI8(r) => Self::VecI8(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecI16(r) => Self::VecI16(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecI32(r) => Self::VecI32(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecI64(r) => Self::VecI64(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecI128(r) => Self::VecI128(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecI256(r) => Self::VecI256(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecBool(r) => Self::VecBool(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecAddress(r) => Self::VecAddress(Rc::new(RefCell::new(r.borrow().clone()))),

            Self::Locals(_) => {
                return Err(
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                        .with_message("cannot copy a Locals container".to_string()),
                )
            },
        })
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L1612-1616)
```rust
impl Reference {
    #[cfg_attr(feature = "force-inline", inline(always))]
    pub fn read_ref(self) -> PartialVMResult<Value> {
        self.0.read_ref(1, Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH))
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/instr.rs (L101-102)
```rust
        [read_ref_base: InternalGas, "read_ref.base", 735],
        [read_ref_per_abs_val_unit: InternalGasPerAbstractValueUnit, "read_ref.per_abs_val_unit", 14],
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L502-510)
```rust
    fn charge_read_ref(&mut self, val: impl ValueView) -> PartialVMResult<()> {
        let (stack_size, heap_size) = self
            .vm_gas_params()
            .misc
            .abs_val
            .abstract_value_size_stack_and_heap(val, self.feature_version())?;

        self.charge_read_ref_cached(stack_size, heap_size)
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L664-668)
```rust
    ) -> PartialVMResult<()> {
        self.use_heap_memory(heap_size)?;

        self.base.charge_read_ref_cached(stack_size, heap_size)
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/move_stdlib.rs (L20-20)
```rust
        [bcs_to_bytes_per_byte_serialized: InternalGasPerByte, "bcs.to_bytes.per_byte_serialized", 36],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L142-142)
```rust
        [memory_quota: AbstractValueSize, { 1.. => "memory_quota" }, 10_000_000],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L54-54)
```rust
        [per_u64_packed: AbstractValueSizePerArg, "per_u64_packed", 8],
```

**File:** config/global-constants/src/lib.rs (L30-31)
```rust
#[cfg(not(any(test, feature = "testing")))]
pub const MAX_GAS_AMOUNT: u64 = 2_000_000;
```
