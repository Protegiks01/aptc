# Audit Report

## Title
Account Creation Fee Bypass via Out-of-Gas Storage Fee Accounting Inflation

## Summary
An attacker can create accounts while paying significantly less than the required storage fees by exploiting a flaw in how failed storage fee charges are accounted for in `finish_aborted_transaction()`. When a transaction runs out of gas during the account creation storage fee charging process, the `storage_fee_used` counter is inflated to the full amount even though the fee was never deducted, causing a verification check to incorrectly pass and allowing account creation for minimal cost.

## Finding Description

The vulnerability exists in the interaction between two components:

1. **Gas Meter Storage Fee Accounting** [1](#0-0) 

When `charge_storage_fee()` fails due to insufficient gas balance, it still increments `storage_fee_used` by the full requested amount despite not actually charging it.

2. **Verification Formula in Aborted Transaction Handling** [2](#0-1) 

The verification check calculates `actual = gas_used * gas_unit_price + storage_fee - storage_refund`, which adds the (inflated) `storage_fee_used` value to the payment calculation, making the check pass even when the user hasn't paid the storage fee.

**Attack Flow:**

1. Attacker crafts transaction with `sequence_number = 0` (new account), minimal `max_gas_amount` (e.g., 50,000 gas units - just enough for prologue), and minimum `gas_unit_price` (100 Octa/gas in production)

2. Transaction executes and quickly exhausts gas during execution phase

3. In `finish_aborted_transaction()`:
   - [3](#0-2)  determines account should be created
   - [4](#0-3)  Account creation with gas meter fails, succeeds with `UnmeteredGasMeter`
   - [5](#0-4)  attempts to charge for the account creation changeset, fails, but error is only logged

4. During `charge_change_set()` → `process_storage_fee_for_all()` → `charge_storage_fee()`, the storage fee charge fails due to insufficient balance, but `storage_fee_used` is set to the full account creation storage fee (~1,000,000+ Octa)

5. [6](#0-5)  creates fee statement with inflated `storage_fee_used`

6. Verification calculates: `actual = 50,000 * 100 + 1,000,000 = 6,000,000 Octa` vs `expected ≈ 1,000,000 Octa` → passes

7. [7](#0-6)  charges user only `100 * 50,000 = 5,000,000 Octa` instead of the full ~1,000,000+ Octa storage fee

**Broken Invariant:** "Resource Limits: All operations must respect gas, storage, and computational limits" - accounts can be created without paying sufficient storage fees.

## Impact Explanation

**Medium Severity** per Aptos Bug Bounty criteria: "Limited funds loss or manipulation"

- Attackers can create accounts while paying as little as prologue cost (~5,000,000 Octa = 0.05 APT with minimal gas) instead of the required ~1,000,000+ Octa storage fee
- This represents an 80%+ discount on account creation costs
- Mass exploitation could lead to storage spam, creating thousands of underpriced accounts
- Protocol loses intended storage fee revenue meant to disincentivize state bloat
- Does not result in total loss of funds but enables systematic undercharging

## Likelihood Explanation

**High Likelihood:**
- Requires no special privileges, any user can submit transactions
- Attack is deterministic once proper gas parameters are calculated
- No race conditions or timing dependencies beyond ensuring out-of-gas at right point
- Can be automated and repeated
- The vulnerability is always active when `DEFAULT_ACCOUNT_RESOURCE` or `SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION` feature is enabled [8](#0-7) 

## Recommendation

Fix the verification formula to correctly calculate the actual fee paid without double-counting storage fees:

```rust
// In finish_aborted_transaction() at line 767:
// Current (incorrect):
let actual = gas_used * gas_unit_price + storage_fee - storage_refund;

// Fixed:
let actual = gas_used * gas_unit_price - storage_refund;
```

The storage fee is already converted to gas units and included in `gas_used` [9](#0-8) , so it should not be added separately. Alternatively, prevent `storage_fee_used` inflation in the gas meter when charges fail, ensuring accounting accuracy [10](#0-9) .

## Proof of Concept

```rust
// Rust test to demonstrate the vulnerability
#[test]
fn test_account_creation_fee_bypass() {
    let mut executor = FakeExecutor::from_head_genesis();
    let account = executor.new_account_at(AccountAddress::random());
    
    // Craft transaction with minimal gas
    let minimal_gas = 50_000; // Just enough for prologue
    let min_gas_price = 100; // Minimum allowed
    
    let txn = account
        .transaction()
        .gas_unit_price(min_gas_price)
        .max_gas_amount(minimal_gas)
        .sequence_number(0) // New account trigger
        .payload(/* empty or minimal payload */)
        .sign();
    
    let output = executor.execute_transaction(txn);
    
    // Verify account was created
    assert!(executor.read_account_resource(&account).is_some());
    
    // Verify user paid minimal amount
    let gas_used = output.gas_used();
    let paid = gas_used * min_gas_price;
    let expected_storage_fee = 1_000_000; // Approximate account creation cost
    
    assert!(paid < expected_storage_fee); // User underpaid!
}
```

**Notes:**
- The exact gas parameters need to be tuned based on actual prologue costs
- Transaction payload should be crafted to consume minimal gas before abort
- Exploit works across all network configurations where account auto-creation is enabled

### Citations

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L282-290)
```rust
            None => {
                let old_balance = self.balance;
                self.balance = 0.into();
                if self.feature_version >= 12 {
                    self.storage_fee_in_internal_units += old_balance;
                    self.storage_fee_used += amount;
                }
                return Err(PartialVMError::new(StatusCode::OUT_OF_GAS));
            },
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L705-706)
```rust
        let should_create_account_resource =
            should_create_account_resource(txn_data, self.features(), resolver, module_storage)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L713-729)
```rust
                create_account_if_does_not_exist(
                    session,
                    module_storage,
                    gas_meter,
                    txn_data.sender(),
                    traversal_context,
                )
                // If this fails, it is likely due to out of gas, so we try again without metering
                // and then validate below that we charged sufficiently.
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L743-754)
```rust
            if let Err(err) = self.charge_change_set(
                &mut abort_hook_session_change_set,
                gas_meter,
                txn_data,
                resolver,
                module_storage,
            ) {
                info!(
                    *log_context,
                    "Failed during charge_change_set: {:?}. Most likely exceeded gas limited.", err,
                );
            };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L756-757)
```rust
            let fee_statement =
                AptosVM::fee_statement_from_gas_meter(txn_data, gas_meter, ZERO_STORAGE_REFUND);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L762-785)
```rust
            if gas_unit_price != 0 || !self.features().is_default_account_resource_enabled() {
                let gas_used = fee_statement.gas_used();
                let storage_fee = fee_statement.storage_fee_used();
                let storage_refund = fee_statement.storage_fee_refund();

                let actual = gas_used * gas_unit_price + storage_fee - storage_refund;
                let expected = u64::from(
                    gas_meter
                        .disk_space_pricing()
                        .hack_account_creation_fee_lower_bound(&gas_params.vm.txn),
                );
                if actual < expected {
                    expect_only_successful_execution(
                        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                            .with_message(
                                "Insufficient fee for storing account for lazy account creation"
                                    .to_string(),
                            )
                            .finish(Location::Undefined),
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )?;
                }
            }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3457-3460)
```rust
    if (features.is_enabled(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE)
        || (features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION)
            && txn_data.fee_payer.is_some()))
        && txn_data.replay_protector == ReplayProtector::SequenceNumber(0)
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L603-603)
```text
        let transaction_fee_amount = txn_gas_price * gas_used;
```

**File:** types/src/fee_statement.rs (L17-21)
```rust
///        - gas charge for execution (CPU time): `execution_gas_units`
///        - gas charge for IO (storage random access): `io_gas_units`
///        - storage fee charge (storage space): `storage_fee_octas`, to be included in
///          `total_charge_gas_unit`, this number is converted to gas units according to the user
///          specified `gas_unit_price` on the transaction.
```
