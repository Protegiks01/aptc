# Audit Report

## Title
Missing Per-Player Ciphertext Length Validation in Weighted PVSS Enables DKG Denial of Service

## Summary
The weighted PVSS transcript verification function fails to validate that each player's ciphertext array length matches their assigned weight, only checking the total flattened count. This allows a Byzantine dealer to create malformed transcripts that pass verification but cause reconstruction failures, breaking DKG liveness guarantees and potentially stalling epoch transitions.

## Finding Description

The weighted PVSS protocol in Aptos DKG assigns each validator a weight (number of shares) based on their stake. During dealing, the `Cs` array should contain exactly `player_weight` encrypted chunks for each player. However, the verification function only validates the aggregate flattened count, not per-player counts. [1](#0-0) 

The code checks only that the total flattened ciphertext count equals total weight, but does not verify that `Cs[player_id].len() == player_weight` for each player. A Byzantine dealer can exploit this by redistributing ciphertexts:
- Setting `Cs[victim_player]` to empty (length 0)
- Padding `Cs[other_player]` with extra chunks
- Total flattened count still matches, passing verification

The developers acknowledged this missing validation with a TODO comment: [2](#0-1) 

When honest validators decrypt their shares, only debug assertions (compiled out in production) check consistency: [3](#0-2) 

The decryption process uses `decrypt_chunked_scalars()` which employs zip iterators that silently stop at the shortest iterator: [4](#0-3) 

When `Cs` is empty but `Rs` is not, the zip produces zero iterations, returning an empty vector of secret key shares. During weighted reconstruction, the flattening process iterates over each player's sub-shares: [5](#0-4) 

A player with zero sub-shares contributes nothing to `flattened_shares`. If total shares fall below the reconstruction threshold, the assertion fails: [6](#0-5) 

## Impact Explanation

This vulnerability enables a **DKG liveness failure** where a single Byzantine validator can prevent successful DKG completion. This qualifies as **High Severity** under "Significant protocol violations" affecting critical network operations.

The DKG protocol is essential for:
- **Epoch transitions**: Validator set updates require successful DKG completion [7](#0-6) 

- **Randomness beacon generation**: On-chain randomness depends on DKG-generated keys
- **Network liveness**: Failed DKG can stall the network, requiring manual intervention through randomness override mechanisms

While not causing permanent network partition or consensus safety violations (Critical severity), this breaks liveness guarantees - a core protocol requirement. The attack affects all participating validators and requires only one malicious dealer within the 1/3 Byzantine fault tolerance assumption.

## Likelihood Explanation

**Likelihood: High** - Any Byzantine validator can trivially exploit this during their dealing turn in the DKG protocol. The attack is:

1. **Simple to execute**: Create a transcript with `Cs[victim] = []` and redistribute chunks to other players
2. **Deterministic**: No timing dependencies or race conditions required  
3. **Low cost**: Normal DKG participation, no additional resources needed
4. **Guaranteed to trigger**: The malformed transcript will pass all verification checks
5. **Within threat model**: Requires only 1 Byzantine validator (< 1/3 threshold)

The missing validation is a straightforward implementation gap acknowledged by the TODO comment, making exploitation trivial for any adversarial validator.

## Recommendation

Add explicit per-player ciphertext length validation in the `verify()` function:

```rust
// After line 252 in weighted_transcript.rs
for i in 0..sc.get_total_num_players() {
    let player = sc.get_player(i);
    let expected_weight = sc.get_player_weight(&player);
    ensure!(
        self.subtrs.Cs[i].len() == expected_weight,
        "Player {} has {} ciphertexts but expected {} based on weight",
        i,
        self.subtrs.Cs[i].len(),
        expected_weight
    );
}
```

Additionally, replace debug assertions with runtime checks in `decrypt_own_share()` functions to provide defense-in-depth.

## Proof of Concept

A complete PoC would involve:
1. Modifying the transcript generation to create malformed `Cs` arrays
2. Verifying the transcript passes `verify()` 
3. Attempting decryption and reconstruction to demonstrate failure

The vulnerability is confirmed through code analysis showing the missing validation, TODO comment acknowledgment, and the execution path that leads to reconstruction failure when shares are below threshold.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L247-252)
```rust
        let Cs_flat: Vec<_> = self.subtrs.Cs.iter().flatten().cloned().collect();
        assert_eq!(
            Cs_flat.len(),
            sc.get_total_weight(),
            "Number of ciphertexts does not equal number of weights"
        ); // TODO what if zero weight?
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L329-329)
```rust
        // TODO: put an assert here saying that len(Cs) = weight
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L578-578)
```rust
        debug_assert_eq!(Cs.len(), sc.get_player_weight(player));
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L327-333)
```rust
    for (row, Rs_row) in Cs_rows.iter().zip(Rs_rows.iter()) {
        // Compute C - d_k * R for each chunk
        let exp_chunks: Vec<C> = row
            .iter()
            .zip(Rs_row.iter())
            .map(|(C_ij, &R_j)| C_ij.sub(R_j * *dk))
            .collect();
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L394-410)
```rust
        for (player, sub_shares) in shares {
            // println!(
            //     "Flattening {} share(s) for player {player}",
            //     sub_shares.len()
            // );
            for (pos, share) in sub_shares.iter().enumerate() {
                let virtual_player = sc.get_virtual_player(player, pos);

                // println!(
                //     " + Adding share {pos} as virtual player {virtual_player}: {:?}",
                //     share
                // );
                // TODO(Performance): Avoiding the cloning here might be nice
                let tuple = (virtual_player, share.clone());
                flattened_shares.push(tuple);
            }
        }
```

**File:** crates/aptos-dkg/src/pvss/dealt_secret_key.rs (L92-93)
```rust
                assert_ge!(shares.len(), sc.get_threshold());
                assert_le!(shares.len(), sc.get_total_num_players());
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```
