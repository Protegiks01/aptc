# Audit Report

## Title
Consensus Liveness Failure Due to Non-Atomic AugData and CertifiedAugData Storage in Randomness Generation

## Summary
The randomness generation system stores AugData and CertifiedAugData in separate column families with non-atomic writes, allowing validators to persist inconsistent states on disk. When validators crash between receiving AugData and CertifiedAugData messages and then restart, they cannot verify randomness shares from affected peers due to missing certified augmented public keys (APKs), potentially causing consensus liveness failures.

## Finding Description
The Aptos consensus randomness generation protocol uses augmented data to establish cryptographic keys needed for weighted VUF (Verifiable Unpredictable Function) share verification. The storage layer maintains two separate schemas in distinct column families: [1](#0-0) [2](#0-1) 

These are written via separate, non-atomic database transactions: [3](#0-2) 

During normal operation, validators follow a two-phase protocol:
1. **Phase 1**: Receive AugData from peer, save it, return signature
2. **Phase 2**: Receive CertifiedAugData (AugData + aggregate signatures), save it, apply delta to config

The critical security issue occurs because only CertifiedAugData triggers the `augment()` method that populates certified APKs required for share verification: [4](#0-3) [5](#0-4) 

When a validator crashes after saving AugData but before saving CertifiedAugData, the recovery process loads both datasets independently without consistency validation: [6](#0-5) 

The recovered validator will have AugData in the `data` map but no corresponding CertifiedAugData in the `certified_data` map. Consequently, the certified APK for that peer is never populated. When the validator later attempts to verify randomness shares from that peer, verification fails: [7](#0-6) 

There is no catch-up mechanism to request missing CertifiedAugData. Unlike randomness shares which have a `RequestShare` message, no `RequestCertifiedAugData` message exists: [8](#0-7) 

While reliable broadcast will eventually deliver CertifiedAugData if the originating validator remains online, if multiple validators crash simultaneously (due to software upgrades, network partitions, or coordinated attacks) and restart before receiving CertifiedAugData from several peers, they will all have incomplete certified APK sets. If sufficient validators are affected, randomness quorum cannot be reached.

Since block processing is gated on having certified augmented data: [9](#0-8) 

And randomness is required for consensus, this creates a consensus liveness failure.

## Impact Explanation
This vulnerability constitutes **High Severity** per Aptos bug bounty criteria as it causes "Significant protocol violations" and "Validator node slowdowns" that can escalate to consensus liveness failures.

Specifically:
- **Consensus Liveness**: Validators cannot generate randomness without verified shares from quorum validators, blocking block commitment
- **Network-Wide Impact**: Affects all validators that restart during the inconsistency window
- **Cascading Failures**: Multiple simultaneous validator restarts amplify the issue
- **No Self-Healing for Permanent Outages**: If the originating validator goes offline permanently, the inconsistency persists for the entire epoch

While this does not directly cause loss of funds, consensus liveness is a critical invariant (Invariant #2: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine"). The inability to generate randomness prevents the network from making progress.

## Likelihood Explanation
The likelihood is **Medium to High** because:

**Triggering Conditions:**
- Validator crashes during the window between receiving AugData and CertifiedAugData (common during deployments)
- Network partitions causing message delivery delays
- Coordinated validator restarts during software upgrades
- Natural operational events (OOM, crashes, restarts)

**Amplification Factors:**
- The window of vulnerability spans the entire reliable broadcast duration
- Multiple validators restarting simultaneously (common in coordinated upgrades)
- No catch-up mechanism means manual intervention may be required

**Realistic Scenario:**
During a network-wide validator software upgrade:
1. Validators restart in rolling fashion
2. Some restart before receiving all CertifiedAugData messages
3. They recover with incomplete certified APK sets
4. Cannot verify shares from missing peers
5. Randomness generation stalls
6. Consensus blocks until manual intervention or all validators eventually receive delayed CertifiedAugData

## Recommendation
Implement atomic writes for related AugData and CertifiedAugData, or add validation and recovery mechanisms:

**Option 1: Atomic Storage (Preferred)**
Modify the storage layer to write both AugData and CertifiedAugData in a single atomic transaction using SchemaBatch:

```rust
impl<D: TAugmentedData> RandStorage<D> for RandDb {
    fn save_certified_aug_data(&self, certified_aug_data: &CertifiedAugData<D>) -> Result<()> {
        let mut batch = SchemaBatch::new();
        // Extract AugData from CertifiedAugData
        let aug_data = certified_aug_data.aug_data();
        // Write both atomically
        batch.put::<AugDataSchema<D>>(&aug_data.id(), aug_data)?;
        batch.put::<CertifiedAugDataSchema<D>>(&certified_aug_data.id(), certified_aug_data)?;
        self.commit(batch)?;
        Ok(())
    }
}
```

**Option 2: Consistency Validation**
Add validation during recovery to detect and handle inconsistencies:

```rust
pub fn new(...) -> Self {
    let all_data = db.get_all_aug_data().unwrap_or_default();
    let all_certified_data = db.get_all_certified_aug_data().unwrap_or_default();
    
    // Validate consistency
    for (id, certified_data) in &certified_data {
        if !aug_data.iter().any(|(aid, _)| aid == id) {
            warn!("CertifiedAugData exists without corresponding AugData for {:?}", id);
            // Could delete inconsistent CertifiedAugData or request AugData
        }
    }
    
    // Only augment for entries with both AugData and CertifiedAugData
    for (id, certified_data) in &certified_data {
        if aug_data.iter().any(|(aid, _)| aid == id) {
            certified_data.data().augment(&config, &fast_config, certified_data.author());
        }
    }
}
```

**Option 3: Add Catch-up Mechanism**
Implement `RequestCertifiedAugData` message type to allow validators to request missing data from peers.

## Proof of Concept

```rust
// This PoC demonstrates the inconsistent state observable after crash
// Place in consensus/src/rand/rand_gen/tests/storage_inconsistency_test.rs

#[test]
fn test_augdata_certified_augdata_inconsistency() {
    use crate::rand::rand_gen::{
        aug_data_store::AugDataStore,
        storage::in_memory::InMemRandDb,
        types::{AugData, AugmentedData, RandConfig},
    };
    use aptos_types::validator_signer::ValidatorSigner;
    use std::sync::Arc;
    
    // Setup
    let signer = Arc::new(ValidatorSigner::random(None));
    let db = Arc::new(InMemRandDb::<AugmentedData>::new());
    let epoch = 1;
    
    // Simulate normal flow: validator receives AugData from peer
    let peer_author = ValidatorSigner::random(None).author();
    let peer_aug_data = AugData::new(epoch, peer_author, AugmentedData {
        delta: /* ... */,
        fast_delta: None,
    });
    
    // Save AugData (simulating add_aug_data call)
    db.save_aug_data(&peer_aug_data).unwrap();
    
    // ** CRASH HAPPENS HERE - before CertifiedAugData is saved **
    // On recovery, validator loads from DB
    
    let store = AugDataStore::new(
        epoch,
        signer.clone(),
        config,
        None,
        db.clone(),
    );
    
    // Verify inconsistent state: 
    // - AugData exists in storage
    // - CertifiedAugData does NOT exist
    // - Certified APK is NOT populated
    // - Share verification from peer will FAIL
    
    assert!(store.data.contains_key(&peer_author)); // AugData exists
    assert!(!store.certified_data.contains_key(&peer_author)); // CertifiedAugData missing
    
    // Attempting to verify a share from peer will fail with 
    // "No augmented public key for validator id" error
    let share = /* create test share from peer */;
    let result = share.verify(&config);
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("No augmented public key"));
}
```

## Notes
- The vulnerability is confirmed by code inspection across multiple files showing separate storage schemas, non-atomic writes, and lack of consistency validation
- The issue affects consensus liveness rather than safety, but liveness is still a critical property
- The severity is amplified during network-wide events (upgrades, partitions) when multiple validators may be affected simultaneously
- While reliable broadcast provides eventual consistency if validators remain online, there is no recovery mechanism for permanent outages or extended downtime
- This represents a violation of the atomic state transition invariant (Invariant #4: "State Consistency: State transitions must be atomic and verifiable via Merkle proofs")

### Citations

**File:** consensus/src/rand/rand_gen/storage/schema.rs (L36-45)
```rust
pub(crate) const AUG_DATA_CF_NAME: ColumnFamilyName = "aug_data";
#[derive(Debug)]
pub struct AugDataSchema<D>(PhantomData<D>);

impl<D: TAugmentedData> Schema for AugDataSchema<D> {
    type Key = AugDataId;
    type Value = AugData<D>;

    const COLUMN_FAMILY_NAME: ColumnFamilyName = AUG_DATA_CF_NAME;
}
```

**File:** consensus/src/rand/rand_gen/storage/schema.rs (L67-76)
```rust
pub(crate) const CERTIFIED_AUG_DATA_CF_NAME: ColumnFamilyName = "certified_aug_data";
#[derive(Debug)]
pub struct CertifiedAugDataSchema<D>(PhantomData<D>);

impl<D: TAugmentedData> Schema for CertifiedAugDataSchema<D> {
    type Key = AugDataId;
    type Value = CertifiedAugData<D>;

    const COLUMN_FAMILY_NAME: ColumnFamilyName = CERTIFIED_AUG_DATA_CF_NAME;
}
```

**File:** consensus/src/rand/rand_gen/storage/db.rs (L90-96)
```rust
    fn save_aug_data(&self, aug_data: &AugData<D>) -> Result<()> {
        Ok(self.put::<AugDataSchema<D>>(&aug_data.id(), aug_data)?)
    }

    fn save_certified_aug_data(&self, certified_aug_data: &CertifiedAugData<D>) -> Result<()> {
        Ok(self.put::<CertifiedAugDataSchema<D>>(&certified_aug_data.id(), certified_aug_data)?)
    }
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L51-71)
```rust
        let all_data = db.get_all_aug_data().unwrap_or_default();
        let (to_remove, aug_data) = Self::filter_by_epoch(epoch, all_data.into_iter());
        if let Err(e) = db.remove_aug_data(to_remove) {
            error!("[AugDataStore] failed to remove aug data: {:?}", e);
        }

        let all_certified_data = db.get_all_certified_aug_data().unwrap_or_default();
        let (to_remove, certified_data) =
            Self::filter_by_epoch(epoch, all_certified_data.into_iter());
        if let Err(e) = db.remove_certified_aug_data(to_remove) {
            error!(
                "[AugDataStore] failed to remove certified aug data: {:?}",
                e
            );
        }

        for (_, certified_data) in &certified_data {
            certified_data
                .data()
                .augment(&config, &fast_config, certified_data.author());
        }
```

**File:** consensus/src/rand/rand_gen/types.rs (L63-79)
```rust
        let maybe_apk = &rand_config.keys.certified_apks[index];
        if let Some(apk) = maybe_apk.get() {
            WVUF::verify_share(
                &rand_config.vuf_pp,
                apk,
                bcs::to_bytes(&rand_metadata)
                    .map_err(|e| anyhow!("Serialization failed: {}", e))?
                    .as_slice(),
                &self.share,
            )?;
        } else {
            bail!(
                "[RandShare] No augmented public key for validator id {}, {}",
                index,
                author
            );
        }
```

**File:** consensus/src/rand/rand_gen/types.rs (L178-194)
```rust
    fn augment(
        &self,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        author: &Author,
    ) {
        let AugmentedData { delta, fast_delta } = self;
        rand_config
            .add_certified_delta(author, delta.clone())
            .expect("Add delta should succeed");

        if let (Some(config), Some(fast_delta)) = (fast_rand_config, fast_delta) {
            config
                .add_certified_delta(author, fast_delta.clone())
                .expect("Add delta for fast path should succeed");
        }
    }
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L24-33)
```rust
#[derive(Clone, Serialize, Deserialize, EnumConversion)]
pub enum RandMessage<S, D> {
    RequestShare(RequestShare),
    Share(RandShare<S>),
    AugData(AugData<D>),
    AugDataSignature(AugDataSignature),
    CertifiedAugData(CertifiedAugData<D>),
    CertifiedAugDataAck(CertifiedAugDataAck),
    FastShare(FastShare<S>),
}
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L380-381)
```rust
                Some(blocks) = incoming_blocks.next(), if self.aug_data_store.my_certified_aug_data_exists() => {
                    self.process_incoming_blocks(blocks);
```
