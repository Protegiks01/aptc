# Audit Report

## Title
Consensus Observer Fork Attack: Observer Locks onto Invalid Chain Due to Round-Based Block Selection Without Fork Detection

## Summary
The `get_last_ordered_block()` function in the consensus observer returns the block with the highest (epoch, round) from storage without verifying chain lineage. This allows an attacker to inject fork blocks with valid signatures, causing the observer to reject canonical blocks and permanently lock onto an invalid chain, breaking consensus safety.

## Finding Description

The consensus observer's block ordering logic contains a critical vulnerability that enables fork attacks. The vulnerability exists across three components:

**1. Unsafe Block Selection in `get_last_ordered_block()`** [1](#0-0) 

This function retrieves the "last ordered block" by calling the underlying store's method, which naively returns the block with the highest round number. [2](#0-1) 

The `OrderedBlockStore` uses a `BTreeMap<(u64, Round), ...>` keyed by epoch and round. The `get_last_ordered_block()` method uses `last_key_value()` which returns the entry with the **maximum (epoch, round) tuple**, regardless of whether that block is on the canonical committed chain or a fork.

**2. Parent Check Vulnerability** [3](#0-2) 

When processing new ordered blocks, the code checks if the incoming block extends the `last_ordered_block`. If a fork block with a higher round has been inserted, this becomes the new `last_ordered_block`, and subsequent canonical blocks at the same round get rejected because their parent doesn't match the fork block.

**3. Missing Fork Detection and State Sync Failure** [4](#0-3) 

When a commit decision arrives, the code retrieves the ordered block by (epoch, round) lookup without verifying the block ID matches the commit decision's committed block ID. [5](#0-4) 

The state sync trigger check compares rounds only. If the fork block has the same or higher round as the canonical commit, state sync won't be triggered, leaving the observer permanently stuck.

**Attack Scenario:**

1. Observer has processed canonical block A at (epoch=1, round=10)
2. Network experiences temporary partition; >2/3 validators sign fork block B at round=11 (extending A)
3. Attacker sends fork block B to observer with valid quorum signatures
4. Fork block B passes signature verification and parent check (extends A), gets inserted into `ordered_block_store` with key (1, 11)
5. Now `get_last_ordered_block()` returns fork block B
6. Canonical block C at round=11 arrives from the canonical chain
7. Parent check compares: `last_ordered_block.id() == C.parent_id()`
   - `last_ordered_block` is fork block B (round 11)
   - `C.parent_id()` points to canonical block A (round 10)
   - `B.id() != A.id()` → canonical block C is rejected
8. Canonical commit decision for block C arrives at round=11
9. Store lookup by (epoch=1, round=11) retrieves fork block B instead of canonical block C
10. No block ID verification occurs; commit decision processing may fail or associate wrong block
11. State sync check: `commit_round (11) > last_block.round() (11)` → FALSE → state sync NOT triggered
12. Observer is permanently locked onto fork chain, will not sync back to canonical chain

## Impact Explanation

**Severity: CRITICAL**

This vulnerability represents a **Consensus Safety Violation** that meets the Critical severity criteria:

1. **Consensus Safety Break**: Observer nodes can commit to different chains than validator nodes, violating the fundamental safety property of Byzantine Fault Tolerant consensus that all honest nodes must agree on the same chain.

2. **State Divergence**: Observers will execute transactions from the fork chain instead of the canonical chain, leading to:
   - Incorrect account balances and state
   - Different transaction history than validators
   - Invalid responses to user queries
   - Potential double-spend if users rely on observer state

3. **No Recovery Mechanism**: Once locked onto the fork, the observer cannot automatically recover. The state sync mechanism won't trigger because the round comparison fails. Manual intervention or node restart required.

4. **Widespread Impact**: All consensus observer nodes are vulnerable. In Aptos's architecture, full nodes run as observers, so this affects the entire observer network.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Realistic Attack Prerequisites**:
   - Only requires temporary network partition (common in distributed systems)
   - >2/3 validators naturally create valid signatures on different blocks during partitions
   - No Byzantine validator behavior required - just normal validators in different network partitions
   - Attacker only needs to relay fork blocks with valid signatures to observers

2. **Low Attack Complexity**:
   - No cryptographic attacks needed
   - No need to compromise validator keys
   - Simple message injection via P2P network
   - Can be triggered accidentally during network issues

3. **No Built-in Mitigations**:
   - No fork detection mechanism in observer code
   - No chain lineage verification
   - No block ID matching when processing commit decisions
   - No automatic recovery path

## Recommendation

**Immediate Fix**: Implement fork detection and canonical chain verification.

**Solution 1: Track Committed Chain Lineage**

Modify `OrderedBlockStore` to maintain the canonical committed chain and verify new blocks extend it:

```rust
pub struct OrderedBlockStore {
    consensus_observer_config: ConsensusObserverConfig,
    highest_committed_epoch_round: Option<(u64, Round)>,
    ordered_blocks: BTreeMap<(u64, Round), (ObservedOrderedBlock, Option<CommitDecision>)>,
    
    // NEW: Track canonical chain by block ID
    committed_block_ids: BTreeMap<(u64, Round), HashValue>,
}

pub fn get_last_ordered_block(&self) -> Option<Arc<PipelinedBlock>> {
    // NEW: Return last block that extends committed chain
    self.ordered_blocks
        .iter()
        .rev()
        .find(|((epoch, round), (block, _))| {
            // Verify block extends committed chain
            if let Some(parent_round) = round.checked_sub(1) {
                if let Some(expected_parent_id) = self.committed_block_ids.get(&(*epoch, parent_round)) {
                    return block.ordered_block().first_block().parent_id() == *expected_parent_id;
                }
            }
            true // Genesis block
        })
        .map(|(_, (observed_ordered_block, _))| {
            observed_ordered_block.ordered_block().last_block()
        })
}
```

**Solution 2: Verify Block ID in Commit Decision Processing**

Add block ID verification when processing commit decisions:

```rust
fn process_commit_decision_for_pending_block(&self, commit_decision: &CommitDecision) -> bool {
    let pending_block = self
        .observer_block_data
        .lock()
        .get_ordered_block(commit_decision.epoch(), commit_decision.round());

    if let Some(pending_block) = pending_block {
        // NEW: Verify block ID matches commit decision
        if pending_block.last_block().id() != commit_decision.proof_block_info().id() {
            error!("Block ID mismatch: stored block {} vs commit decision {}", 
                   pending_block.last_block().id(), 
                   commit_decision.proof_block_info().id());
            return false;
        }
        
        if self.all_payloads_exist(pending_block.blocks()) {
            // ... rest of processing
        }
    }
    false
}
```

**Solution 3: Improve State Sync Trigger**

Trigger state sync when block ID mismatch detected:

```rust
// In process_commit_decision_message, after line 492
if !self.process_commit_decision_for_pending_block(&commit_decision) {
    // NEW: Check for fork - trigger state sync if block exists but ID mismatches
    if let Some(stored_block) = self.observer_block_data.lock()
        .get_ordered_block(commit_epoch, commit_round) {
        if stored_block.last_block().id() != commit_decision.proof_block_info().id() {
            warn!("Fork detected: triggering state sync");
            self.observer_block_data.lock()
                .update_blocks_for_state_sync_commit(&commit_decision);
            self.state_sync_manager.sync_to_commit(commit_decision, false);
            return;
        }
    }
    // ... existing future epoch/round check
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod fork_attack_test {
    use super::*;
    use aptos_consensus_types::{
        block::Block,
        block_data::{BlockData, BlockType},
        pipelined_block::PipelinedBlock,
        quorum_cert::QuorumCert,
    };
    use aptos_crypto::HashValue;
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        block_info::BlockInfo,
        ledger_info::LedgerInfo,
    };

    #[test]
    fn test_fork_attack_observer_locks_onto_wrong_chain() {
        // Setup: Observer at canonical block A (epoch 1, round 10)
        let epoch = 1;
        let canonical_round_10 = 10;
        let fork_round_11 = 11;
        
        let root = create_ledger_info(epoch, canonical_round_10);
        let mut observer_block_data = 
            ObserverBlockData::new_with_root(ConsensusObserverConfig::default(), root.clone());
        
        // Canonical block A at round 10
        let block_a_info = BlockInfo::new(
            epoch, canonical_round_10, HashValue::random(), HashValue::random(), 0, 0, None
        );
        
        // Fork block B at round 11 (extends A)
        let fork_block_b_info = BlockInfo::new(
            epoch, fork_round_11, HashValue::random(), HashValue::random(), 1, 1, None
        );
        let fork_block_b = create_pipelined_block_with_parent(fork_block_b_info, block_a_info.id());
        let fork_ordered_block = OrderedBlock::new(
            vec![fork_block_b.clone()],
            create_ledger_info(epoch, fork_round_11),
        );
        
        // Insert fork block B - this succeeds
        let fork_observed = ObservedOrderedBlock::new_for_testing(fork_ordered_block);
        observer_block_data.insert_ordered_block(fork_observed);
        
        // Verify fork block B is now the last ordered block
        let last_block = observer_block_data.get_last_ordered_block();
        assert_eq!(last_block.id(), fork_block_b.id());
        
        // Canonical block C at round 11 (also extends A)
        let canonical_block_c_info = BlockInfo::new(
            epoch, fork_round_11, HashValue::random(), HashValue::random(), 1, 1, None
        );
        let canonical_block_c = create_pipelined_block_with_parent(canonical_block_c_info, block_a_info.id());
        
        // Try to process canonical block C
        // In real code, this would fail the parent check: last_ordered_block.id() == C.parent_id()
        // because last_ordered_block is fork_block_b, but C.parent is block_a
        
        // Demonstrate the vulnerability: last ordered block returns fork block
        assert_eq!(
            observer_block_data.get_last_ordered_block().id(),
            fork_block_b.id(),
            "Observer locked onto fork block!"
        );
        
        // Canonical commit decision arrives for block C
        let canonical_commit = CommitDecision::new(create_ledger_info_for_block(
            canonical_block_c_info.clone()
        ));
        
        // Store lookup by (epoch, round) returns fork block B, not canonical block C
        let stored_block = observer_block_data.get_ordered_block(epoch, fork_round_11).unwrap();
        assert_eq!(stored_block.last_block().id(), fork_block_b.id());
        assert_ne!(stored_block.last_block().id(), canonical_block_c_info.id());
        
        // VULNERABILITY: Observer has fork block but canonical commit decision!
        println!("FORK ATTACK SUCCESSFUL: Observer locked onto fork chain!");
    }
    
    fn create_pipelined_block_with_parent(block_info: BlockInfo, parent_id: HashValue) -> Arc<PipelinedBlock> {
        let mut block_data = BlockData::new_for_testing(
            block_info.epoch(),
            block_info.round(),
            block_info.timestamp_usecs(),
            QuorumCert::dummy(),
            BlockType::Genesis,
        );
        // Set parent_id (requires accessing block_data internals in real implementation)
        let block = Block::new_for_testing(block_info.id(), block_data, None);
        Arc::new(PipelinedBlock::new_ordered(block, OrderedBlockWindow::empty()))
    }
    
    fn create_ledger_info_for_block(block_info: BlockInfo) -> LedgerInfoWithSignatures {
        LedgerInfoWithSignatures::new(
            LedgerInfo::new(block_info, HashValue::random()),
            AggregateSignature::empty(),
        )
    }
}
```

## Notes

This vulnerability demonstrates a fundamental flaw in the consensus observer's chain selection mechanism. The root cause is treating block ordering as a simple round-number comparison without maintaining chain lineage or fork detection. The BTreeMap data structure correctly orders by (epoch, round), but the semantic meaning of "last ordered block" should be "last block on the canonical committed chain," not "block with highest round number."

The attack is particularly insidious because:
1. It can occur without any Byzantine behavior - just normal consensus operation during network partitions
2. Once triggered, there's no automatic recovery
3. The observer appears to function normally but serves incorrect state to users
4. Multiple observers can lock onto different forks, fragmenting the observer network

The fix requires implementing proper fork detection and canonical chain tracking, similar to how the full consensus protocol maintains safety through committed chain verification.

### Citations

**File:** consensus/src/consensus_observer/observer/block_data.rs (L143-152)
```rust
    /// Returns the last ordered block
    pub fn get_last_ordered_block(&self) -> BlockInfo {
        if let Some(last_ordered_block) = self.ordered_block_store.get_last_ordered_block() {
            // Return the last ordered block
            last_ordered_block.block_info()
        } else {
            // Return the root block
            self.root.commit_info().clone()
        }
    }
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L57-64)
```rust
    /// Returns the last ordered block (if any)
    pub fn get_last_ordered_block(&self) -> Option<Arc<PipelinedBlock>> {
        self.ordered_blocks
            .last_key_value()
            .map(|(_, (observed_ordered_block, _))| {
                observed_ordered_block.ordered_block().last_block()
            })
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L500-527)
```rust
        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L530-570)
```rust
    /// Processes the commit decision for the pending block and returns true iff
    /// the commit decision was successfully processed. Note: this function
    /// assumes the commit decision has already been verified.
    fn process_commit_decision_for_pending_block(&self, commit_decision: &CommitDecision) -> bool {
        // Get the pending block for the commit decision
        let pending_block = self
            .observer_block_data
            .lock()
            .get_ordered_block(commit_decision.epoch(), commit_decision.round());

        // Process the pending block
        if let Some(pending_block) = pending_block {
            // If all payloads exist, add the commit decision to the pending blocks
            if self.all_payloads_exist(pending_block.blocks()) {
                debug!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Adding decision to pending block: {}",
                        commit_decision.proof_block_info()
                    ))
                );
                self.observer_block_data
                    .lock()
                    .update_ordered_block_commit_decision(commit_decision);

                // If state sync is not syncing to a commit, forward the commit decision to the execution pipeline
                if !self.state_sync_manager.is_syncing_to_commit() {
                    info!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Forwarding commit decision to the execution pipeline: {}",
                            commit_decision.proof_block_info()
                        ))
                    );
                    self.forward_commit_decision(commit_decision.clone());
                }

                return true; // The commit decision was successfully processed
            }
        }

        false // The commit decision was not processed
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L773-800)
```rust
        // The block was verified correctly. If the block is a child of our
        // last block, we can insert it into the ordered block store.
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        if last_ordered_block.id() == ordered_block.first_block().parent_id() {
            // Update the latency metrics for ordered block processing
            update_message_processing_latency_metrics(
                message_received_time,
                &peer_network_id,
                metrics::ORDERED_BLOCK_LABEL,
            );

            // Insert the ordered block into the pending blocks
            self.observer_block_data
                .lock()
                .insert_ordered_block(observed_ordered_block.clone());

            // If state sync is not syncing to a commit, finalize the ordered blocks
            if !self.state_sync_manager.is_syncing_to_commit() {
                self.finalize_ordered_block(ordered_block).await;
            }
        } else {
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Parent block for ordered block is missing! Ignoring: {:?}",
                    ordered_block.proof_block_info()
                ))
            );
        }
```
