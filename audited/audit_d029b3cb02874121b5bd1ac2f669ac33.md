# Audit Report

## Title
Recursive Stack Overflow in BooleanTransactionFilter Causes Indexer gRPC API Crash

## Summary
The `BooleanTransactionFilter::matches()` function contains unbounded recursion that allows an attacker to crash the indexer gRPC service by sending a deeply nested filter (e.g., 10,000 nested NOT operators). The current size-based validation does not prevent depth-based attacks, enabling a Denial of Service on the indexer API.

## Finding Description

The `BooleanTransactionFilter` enum supports recursive nesting through the `LogicalNot` variant, which contains a `Box<BooleanTransactionFilter>`. [1](#0-0) 

When filtering transactions, the `matches()` function recursively evaluates nested filters: [2](#0-1) 

For `LogicalNot`, this triggers recursive evaluation: [3](#0-2) 

The validation in `new_from_proto()` only checks the **encoded byte size** of the protobuf message, not the nesting depth: [4](#0-3) 

The default maximum filter size is only 10,000 bytes: [5](#0-4) 

**Attack Path:**

1. Attacker constructs a protobuf `BooleanTransactionFilter` with 10,000 nested NOT operators wrapping a simple base filter
2. The total encoded size remains under 10,000 bytes (each NOT adds minimal overhead)
3. Attacker sends `GetTransactionsRequest` to the indexer gRPC service with this malicious filter
4. The filter is accepted and stored: [6](#0-5) 

5. For each transaction processed, `matches()` is called: [7](#0-6) 

6. With 10,000 nesting levels, this creates 10,000 stack frames (~200-500 bytes each)
7. Stack overflow occurs (default Rust stack: 2MB), causing a panic
8. The spawned task crashes, disrupting the client stream

**Invariant Violation:**
This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The unbounded recursion allows consumption of arbitrary stack space.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos Bug Bounty criteria: **"API crashes"**.

The indexer gRPC service is critical infrastructure that provides indexed blockchain data to applications, wallets, and services. Crashing this service causes:

- **API Unavailability**: Client applications lose access to historical transaction data
- **Service Disruption**: The indexer process may crash entirely or individual streams fail
- **Repeated Attacks**: Attacker can continuously send malicious filters to maintain DoS
- **Resource Exhaustion**: Multiple concurrent malicious requests amplify the impact

While this does not affect consensus or validator operations directly, the indexer is an officially supported Aptos service whose availability is critical for ecosystem functionality.

## Likelihood Explanation

**High Likelihood:**

- **Easy to Exploit**: Constructing a deeply nested protobuf filter requires minimal effort
- **No Authentication Barriers**: Any client with API access can send the malicious filter
- **Immediate Impact**: Stack overflow occurs on first transaction match attempt
- **Low Cost**: No economic cost to attacker (no gas fees for gRPC requests)
- **Undetected**: The size validation provides false sense of security

The protobuf structure naturally supports this nesting, and there are no depth checks anywhere in the codebase: [8](#0-7) 

## Recommendation

Implement a maximum recursion depth check during filter construction and validation:

```rust
const MAX_FILTER_DEPTH: usize = 100;

impl BooleanTransactionFilter {
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        // Existing size check
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
        
        // NEW: Depth check
        let filter = Self::from_proto_with_depth(&proto_filter, 0)?;
        Ok(filter)
    }
    
    fn from_proto_with_depth(
        proto_filter: &aptos_protos::indexer::v1::BooleanTransactionFilter,
        current_depth: usize,
    ) -> Result<Self> {
        ensure!(
            current_depth <= MAX_FILTER_DEPTH,
            format!(
                "Filter nesting too deep. Max depth: {}, Current depth: {}",
                MAX_FILTER_DEPTH,
                current_depth
            )
        );
        
        // Parse based on filter type, incrementing depth for nested filters
        // ... implementation details
    }
}
```

Additionally, consider iterative implementations of `matches()` using an explicit stack to eliminate recursion entirely.

## Proof of Concept

```rust
#[cfg(test)]
mod stack_overflow_test {
    use super::*;
    use aptos_transaction_filter::{BooleanTransactionFilter, TransactionRootFilterBuilder};
    use aptos_protos::transaction::v1::Transaction;
    
    #[test]
    #[should_panic(expected = "stack overflow")]
    fn test_deeply_nested_not_causes_stack_overflow() {
        // Create a simple base filter
        let base_filter = TransactionRootFilterBuilder::default()
            .success(true)
            .build()
            .unwrap();
        
        // Wrap it in 10,000 NOT operators
        let mut filter = BooleanTransactionFilter::from(base_filter);
        for _ in 0..10000 {
            filter = filter.not();
        }
        
        // Create a dummy transaction
        let transaction = Transaction::default();
        
        // This should cause stack overflow
        filter.matches(&transaction);
    }
}
```

**Notes:**

This vulnerability affects the indexer-grpc service, not validator nodes. However, per Aptos Bug Bounty program, "API crashes" qualify as High Severity issues. The indexer is critical infrastructure for the Aptos ecosystem, and its availability is essential for applications to query blockchain data.

The vulnerability stems from the mismatch between protobuf's structural flexibility (allowing arbitrary nesting) and Rust's call stack limitations. The size-based validation provides inadequate protection against depth-based resource exhaustion attacks.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L98-106)
```rust
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L250-257)
```rust
    fn matches(&self, item: &Transaction) -> bool {
        match self {
            BooleanTransactionFilter::And(and) => and.matches(item),
            BooleanTransactionFilter::Or(or) => or.matches(item),
            BooleanTransactionFilter::Not(not) => not.matches(item),
            BooleanTransactionFilter::Filter(filter) => filter.matches(item),
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L340-343)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct LogicalNot {
    not: Box<BooleanTransactionFilter>,
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L365-367)
```rust
    fn matches(&self, item: &Transaction) -> bool {
        !self.not.matches(item)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L20-21)
```rust
// Default maximum size in bytes for transaction filters.
pub const DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES: usize = 10_000;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L98-115)
```rust
                let filter = if let Some(proto_filter) = request.transaction_filter {
                    match filter_utils::parse_transaction_filter(
                        proto_filter,
                        self.max_transaction_filter_size_bytes,
                    ) {
                        Ok(filter) => Some(filter),
                        Err(err) => {
                            info!("Client error: {err:?}.");
                            let _ = response_sender.blocking_send(Err(err));
                            COUNTER
                                .with_label_values(&["live_data_service_invalid_filter"])
                                .inc();
                            continue;
                        },
                    }
                } else {
                    None
                };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/in_memory_cache.rs (L90-90)
```rust
                    if filter.is_none() || filter.as_ref().unwrap().matches(transaction) {
```

**File:** protos/proto/aptos/indexer/v1/filter.proto (L58-65)
```text
message BooleanTransactionFilter {
  oneof filter {
      APIFilter api_filter = 1;
      LogicalAndFilters logical_and = 2;
      LogicalOrFilters logical_or = 3;
      BooleanTransactionFilter logical_not = 4;
  }
}
```
