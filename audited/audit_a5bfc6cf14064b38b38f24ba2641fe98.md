# Audit Report

## Title
Critical Information Leak: Inspection Service Exposes Validator Network Topology Enabling Targeted Eclipse Attacks

## Summary
The Aptos inspection service exposes both validator network identity information (peer_id) and active peer connection metadata (including IP addresses and ports) through unauthenticated HTTP endpoints that are enabled by default. This allows attackers to map validator peer_ids to their actual network addresses, enabling targeted eclipse attacks, network topology reconnaissance, and validator-specific exploits that could compromise consensus safety.

## Finding Description

The vulnerability exists in the inspection service's configuration and endpoint design, specifically involving two endpoints:

1. **`/identity_information` endpoint** - Exposes the validator's own peer_id [1](#0-0) 

2. **`/peer_information` endpoint** - Exposes connection metadata for all connected peers, including both peer_ids AND their network addresses (IP + port) [2](#0-1) 

The `ConnectionMetadata` struct contains the network address field that gets serialized and exposed [3](#0-2) 

**Critical Configuration Flaws:**

1. **Default exposure enabled**: Both `expose_identity_information` and `expose_peer_information` default to `true` [4](#0-3) 

2. **No mainnet sanitizer**: Unlike `expose_configuration`, there is NO sanitizer preventing mainnet validators from exposing identity and peer information [5](#0-4) 

3. **Binds to 0.0.0.0**: The service is accessible from any network interface by default, not localhost-only [4](#0-3) 

4. **No authentication**: The inspection service has no authentication mechanism [6](#0-5) 

**Attack Path:**

1. Attacker queries the on-chain `ValidatorSet` resource to obtain all validator peer_ids (public information) [7](#0-6) 

2. Attacker scans for accessible inspection service endpoints (default port 9101) across the network

3. Attacker queries `/peer_information` on discovered endpoints to retrieve active connection metadata containing peer_ids and their corresponding network addresses

4. Attacker correlates validator peer_ids from step 1 with actual network addresses from step 3

5. With this mapping, attacker can:
   - Launch targeted eclipse attacks by controlling network routing to specific validators
   - Identify and exploit validator-specific network-level vulnerabilities
   - Map the entire validator network topology
   - Target specific validators for sophisticated attacks that could compromise consensus

**Why This Breaks Security Guarantees:**

While validator network addresses are published on-chain, those are **advertised addresses** that validators choose to publicize. The inspection service exposes **actual active connection addresses**, which may differ due to NAT, proxies, load balancers, or privacy-enhancing network configurations. This breaks the assumption that validators can maintain network-level privacy while participating in consensus.

## Impact Explanation

This vulnerability enables **eclipse attacks** on validators, which can compromise consensus safety. An eclipse attack isolates a validator by controlling its network connections, potentially allowing an attacker to:

- Feed false blockchain state to the isolated validator
- Prevent the validator from receiving legitimate blocks and votes
- Cause the validator to sign conflicting blocks (equivocation)
- Manipulate consensus participation and voting behavior

While direct network-level DoS attacks are out of scope, **eclipse attacks represent a significant protocol violation** because they can cause consensus safety failures without requiring control of validator private keys or stake.

Additionally, this enables:
- **Network topology mapping**: Understanding validator interconnections aids in planning sophisticated attacks
- **Targeted exploitation**: If validators run vulnerable software versions, attackers can target specific nodes
- **Consensus manipulation**: Isolating strategic validators could impact block production and finality

According to the Aptos bug bounty severity categories, this qualifies as **High Severity** because it enables "Significant protocol violations" through eclipse attacks that could affect consensus.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Default configuration vulnerability**: The endpoints are enabled by default with no sanitizer for mainnet validators
2. **Zero attacker sophistication required**: Simple HTTP GET requests to publicly accessible endpoints
3. **No authentication barrier**: Anyone can access these endpoints
4. **Public service port**: Port 9101 is easily discoverable through port scanning
5. **Correlation is trivial**: Matching peer_ids between on-chain data and inspection service responses requires minimal effort

The only requirement is that some validators run with default configurations and have port 9101 accessible, which is highly probable given the default settings.

## Recommendation

**Immediate Fixes:**

1. **Add mainnet sanitizer** to prevent exposing identity and peer information on production validators:

```rust
// In config/src/config/inspection_service_config.rs
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                // Prevent exposing configuration
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                
                // ADD THIS: Prevent exposing identity information
                if inspection_service_config.expose_identity_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose identity information!".to_string(),
                    ));
                }
                
                // ADD THIS: Prevent exposing peer information
                if inspection_service_config.expose_peer_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose peer information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

2. **Change defaults** to false for production security:

```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(), // Bind to localhost only
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false, // CHANGE: Default to false
            expose_peer_information: false,      // CHANGE: Default to false
            expose_system_information: false,
        }
    }
}
```

3. **Add authentication** to the inspection service for sensitive endpoints

4. **Implement IP-based access control** to restrict endpoint access to trusted networks

5. **Add rate limiting** to prevent enumeration attacks

## Proof of Concept

**Step 1: Query on-chain ValidatorSet (public information)**
```bash
curl -X GET "https://fullnode.mainnet.aptoslabs.com/v1/accounts/0x1/resource/0x1::stake::ValidatorSet"
# Extract all validator account addresses (peer_ids)
```

**Step 2: Scan for accessible inspection services**
```python
import requests
import json

# Assume we've identified a validator node IP from network reconnaissance
validator_ips = ["<validator_ip_1>", "<validator_ip_2>", ...]

for ip in validator_ips:
    try:
        # Query identity information
        identity_resp = requests.get(f"http://{ip}:9101/identity_information", timeout=5)
        if identity_resp.status_code == 200:
            print(f"[+] Validator {ip} exposes identity:")
            print(identity_resp.text)
            
        # Query peer information with network addresses
        peer_resp = requests.get(f"http://{ip}:9101/peer_information", timeout=5)
        if peer_resp.status_code == 200:
            print(f"[+] Validator {ip} exposes peer connections:")
            print(peer_resp.text)
            # Parse connection metadata to extract peer_id -> IP mappings
            
    except requests.exceptions.RequestException:
        continue
```

**Step 3: Correlation attack**
```python
# Extract validator peer_ids from on-chain ValidatorSet
onchain_validator_peer_ids = [...]  # From Step 1

# Extract peer_id -> IP mappings from inspection service responses
peer_id_to_ip_map = {}  # From Step 2

# Identify which IPs correspond to validators
validator_ip_map = {}
for peer_id in onchain_validator_peer_ids:
    if peer_id in peer_id_to_ip_map:
        validator_ip_map[peer_id] = peer_id_to_ip_map[peer_id]
        print(f"[!] VALIDATOR MAPPED: {peer_id} -> {peer_id_to_ip_map[peer_id]}")

# Now attacker knows exactly which IPs run which validators
# Can launch targeted eclipse attacks, DDoS, or exploit specific validators
```

**Step 4: Eclipse attack (conceptual)**
- Use validator IP map to identify network paths to target validator
- Manipulate BGP routing or use network position to intercept connections
- Isolate validator from legitimate peers
- Feed false consensus messages to isolated validator

**Notes**

The vulnerability is exacerbated by the fact that the inspection service provides ACTUAL connection addresses rather than just the advertised addresses from the on-chain ValidatorSet. This means even validators using NAT, proxies, or other privacy-enhancing configurations have their real network locations exposed.

The absence of a sanitizer for mainnet validators (unlike the configuration endpoint) suggests this may be an oversight rather than intentional design, especially given the security implications for consensus protocols that rely on network diversity and resistance to targeted attacks.

### Citations

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L29-40)
```rust
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L148-168)
```rust
/// Displays connection metadata for each peer
fn display_peer_connection_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Connection metadata for each peer:".into());

    // Fetch and display the connection metadata for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let connection_metadata = peer_metadata.get_connection_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, connection state: {:?}, connection metadata: {}",
                peer,
                peer_metadata.get_connection_state(),
                serde_json::to_string(&connection_metadata).unwrap_or_default()
            ));
        }
    }
}
```

**File:** network/framework/src/transport/mod.rs (L98-108)
```rust
/// Metadata associated with an established and fully upgraded connection.
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L54-68)
```rust
        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L103-169)
```rust
/// A simple helper function that handles each endpoint request
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };
```

**File:** network/discovery/src/validator_set.rs (L108-150)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```
