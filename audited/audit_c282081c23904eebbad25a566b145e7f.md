# Audit Report

## Title
Chain ID Validation Missing in GrpcManager Heartbeat Handler Allows Cross-Chain Data Contamination

## Summary
The GrpcManager service in the Aptos indexer infrastructure accepts heartbeats from data services without validating that their `chain_id` matches the manager's configured chain. This allows data services from different blockchain networks (e.g., testnet, devnet) to register with a manager from another network (e.g., mainnet), causing indexers to potentially process and mix transactions from multiple chains simultaneously.

## Finding Description

The indexer gRPC infrastructure uses a heartbeat-based service discovery mechanism where data services (LiveDataService and HistoricalDataService) periodically send `HeartbeatRequest` messages containing their `ServiceInfo` to a `GrpcManager`. Each `ServiceInfo` includes chain-specific metadata like `chain_id`, `known_latest_version`, and service address.

The vulnerability exists in the heartbeat handling flow:

1. Data services send heartbeats containing `LiveDataServiceInfo` or `HistoricalDataServiceInfo` with their `chain_id` [1](#0-0) 

2. The GrpcManager receives these heartbeats and passes them to the MetadataManager [2](#0-1) 

3. The MetadataManager stores service information **without validating chain_id**:
   - For LiveDataServiceInfo: [3](#0-2) 
   
   - For HistoricalDataServiceInfo: [4](#0-3) 

4. When clients request data via `get_data_service_for_request`, the manager selects from the registered services without chain_id filtering: [5](#0-4) 

The MetadataManager has a `chain_id` field but never compares it against incoming service heartbeats: [6](#0-5) 

**Attack Scenario:**
1. Attacker runs a testnet data service (chain_id = 3)
2. Misconfigures or intentionally points it to send heartbeats to a mainnet GrpcManager (chain_id = 1) 
3. The mainnet manager accepts the heartbeat without validation and adds the testnet service to its pool
4. Mainnet indexer clients requesting data get routed to the testnet service
5. Clients receive testnet transactions thinking they are mainnet data, causing data contamination

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "Significant protocol violations" category. While it doesn't directly affect blockchain consensus, it violates critical data integrity guarantees in the indexer infrastructure that numerous applications depend on:

- **Block Explorers**: Display transactions from wrong chain, confusing users
- **DeFi Protocols**: Make financial decisions based on wrong chain state
- **Wallets**: Show incorrect balances and transaction history
- **Cross-chain Bridges**: Read incorrect state leading to potential fund loss
- **Analytics Platforms**: Generate misleading metrics and reports

The impact is amplified because:
- No authentication exists on the GrpcManager, allowing any service to register
- Clients may not consistently validate the `chain_id` field in `TransactionsResponse`
- Multiple indexers could be simultaneously contaminated if pointing to the same manager
- Detection requires manual monitoring and intervention

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can occur through:
1. **Misconfiguration**: Accidental deployment of services with wrong manager addresses (common in multi-network deployments)
2. **Malicious Intent**: Deliberate attack by running wrong-chain service and registering with target manager
3. **Network Issues**: DNS misresolution or load balancer misconfiguration routing services to wrong managers

The attack requires:
- Ability to run a data service (low barrier - just infrastructure)
- Network connectivity to target manager (standard requirement)
- No authentication or authorization required

Mitigating factors:
- Production environments typically have network isolation
- `TransactionsResponse` includes `chain_id` field that clients could validate (though not enforced)
- Internal data service validation between cache and file store exists, but doesn't prevent registration

## Recommendation

Add chain_id validation in all heartbeat handlers within `MetadataManager`. Reject services with mismatched chain IDs:

```rust
fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    mut info: LiveDataServiceInfo,
) -> Result<()> {
    // Validate chain_id matches
    if info.chain_id != self.chain_id {
        bail!(
            "Chain ID mismatch: service reports chain_id {} but manager expects {}",
            info.chain_id,
            self.chain_id
        );
    }
    
    let mut entry = self
        .live_data_services
        .entry(address.clone())
        .or_insert(LiveDataService::new(address));
    if info.stream_info.is_none() {
        info.stream_info = Some(StreamInfo {
            active_streams: vec![],
        });
    }
    entry.value_mut().recent_states.push_back(info);
    if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
        entry.value_mut().recent_states.pop_front();
    }

    Ok(())
}
```

Apply similar validation to:
- `handle_historical_data_service_info`
- `handle_fullnode_info` 
- `handle_grpc_manager_info`

Additionally, log rejected services for security monitoring.

## Proof of Concept

**Setup:**
1. Deploy a testnet indexer data service with chain_id = 3
2. Configure mainnet GrpcManager with chain_id = 1
3. Point testnet service to send heartbeats to mainnet manager

**Test Script:**
```rust
// In ecosystem/indexer-grpc/indexer-grpc-manager/tests/chain_id_validation_test.rs
use aptos_protos::indexer::v1::{
    service_info::Info, HeartbeatRequest, LiveDataServiceInfo, ServiceInfo,
};

#[tokio::test]
async fn test_cross_chain_service_registration() {
    // Start mainnet manager with chain_id = 1
    let mainnet_manager = MetadataManager::new(
        1, // mainnet chain_id
        "http://mainnet-manager:50051".to_string(),
        vec![],
        vec![],
        None,
    );
    
    // Create testnet service info with chain_id = 3
    let testnet_service_info = ServiceInfo {
        address: Some("http://testnet-service:50052".to_string()),
        info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
            chain_id: 3, // TESTNET chain_id
            timestamp: Some(timestamp_now_proto()),
            known_latest_version: Some(1000),
            stream_info: Some(StreamInfo { active_streams: vec![] }),
            min_servable_version: Some(0),
        })),
    };
    
    // Attempt to register testnet service with mainnet manager
    let result = mainnet_manager.handle_heartbeat(
        "http://testnet-service:50052".to_string(),
        testnet_service_info.info.unwrap(),
    );
    
    // Currently PASSES (vulnerability) - should FAIL after fix
    assert!(result.is_err(), "Should reject mismatched chain_id");
    assert!(result.unwrap_err().to_string().contains("Chain ID mismatch"));
}
```

**Validation:**
Run the test before fix - it will fail (services accepted despite mismatch). After implementing the fix, the test passes and cross-chain services are rejected.

## Notes

While chain_id validation exists in some downstream components (cache worker, data service internal checks), the vulnerability at the GrpcManager registration layer is critical because it's the entry point for service discovery. Without validation here, wrong-chain services enter the routing pool and can contaminate the entire indexer infrastructure.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L262-276)
```rust
            Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                chain_id: self.chain_id,
                timestamp,
                known_latest_version,
                stream_info,
                min_servable_version,
            }))
        } else {
            Some(Info::HistoricalDataServiceInfo(HistoricalDataServiceInfo {
                chain_id: self.chain_id,
                timestamp,
                known_latest_version,
                stream_info,
            }))
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L71-88)
```rust
    fn pick_live_data_service(&self, starting_version: u64) -> Option<String> {
        let mut candidates = vec![];
        for candidate in self.metadata_manager.get_live_data_services_info() {
            if let Some(info) = candidate.1.back().as_ref() {
                // TODO(grao): Handle the case when the requested starting version is beyond the
                // latest version.
                if info.min_servable_version.is_none()
                    || starting_version < info.min_servable_version.unwrap()
                {
                    continue;
                }
                let num_active_streams = info.stream_info.as_ref().unwrap().active_streams.len();
                candidates.push((candidate.0, num_active_streams));
            }
        }

        Self::pick_data_service_from_candidate(candidates)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L127-137)
```rust
pub(crate) struct MetadataManager {
    chain_id: u64,
    self_advertised_address: GrpcAddress,
    grpc_managers: DashMap<GrpcAddress, Peer>,
    fullnodes: DashMap<GrpcAddress, Fullnode>,
    live_data_services: DashMap<GrpcAddress, LiveDataService>,
    historical_data_services: DashMap<GrpcAddress, HistoricalDataService>,
    known_latest_version: AtomicU64,
    // NOTE: We assume the master is statically configured for now.
    master_address: Mutex<Option<GrpcAddress>>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L511-531)
```rust
    fn handle_historical_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: HistoricalDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .historical_data_services
            .entry(address.clone())
            .or_insert(HistoricalDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```
