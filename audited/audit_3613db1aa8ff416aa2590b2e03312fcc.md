# Audit Report

## Title
Optimistic Proposal Equivocation Attack via Missing Signature Validation and Buffer Overwriting

## Summary
`OptProposalMsg` lacks cryptographic signature validation and uses a buffer with overwrite semantics, allowing a malicious proposer to send conflicting proposals to different validators, causing vote splitting and consensus liveness failures.

## Finding Description

**Validation Gap Between ProposalMsg and OptProposalMsg:**

For regular proposals, `ProposalMsg` requires BLS signature verification: [1](#0-0) 

The proposer must sign the block_data, and this signature is cryptographically verified. In contrast, `OptProposalMsg` only verifies that the network-authenticated sender matches the claimed author: [2](#0-1) 

When converted to a Block, optimistic proposals explicitly have no signature: [3](#0-2) 

And signature validation for `OptimisticProposal` blocks only verifies QCs, not the proposer's signature: [4](#0-3) 

**Buffer Overwriting Vulnerability:**

OptProposalMsg messages for future rounds are buffered: [5](#0-4) 

The critical issue is that `BTreeMap::insert()` **overwrites** any existing entry for the same round. If a malicious proposer sends multiple different `OptProposalMsg` for the same round, the last one received replaces earlier ones. Different validators may receive these messages in different orders, causing them to buffer different proposals.

**Attack Scenario:**

1. Malicious validator M is elected proposer for round R
2. M crafts two different OptProposalMsg (A with payload P_A, B with payload P_B)
3. M sends OptProposalMsg_A to validators V1, V2
4. M sends OptProposalMsg_B to validators V3, V4
5. All validators buffer these proposals since they're in round R-1
6. Due to network timing or M sending both messages to all validators in different orders:
   - V1, V2 end up with OptProposalMsg_A in buffer
   - V3, V4 end up with OptProposalMsg_B in buffer
7. When validators advance to round R:
   - V1, V2 process block A via `process_opt_proposal`
   - V3, V4 process block B
8. Each block is valid (passes `is_valid_proposal` check per validator)
9. Votes split: A gets 2 votes, B gets 2 votes
10. Neither achieves 2/3+ quorum → round timeout → liveness failure

This is **not possible** with regular ProposalMsg because: [6](#0-5) 

Regular proposals are not buffered - they're processed immediately or discarded as stale, preventing the overwrite vulnerability.

## Impact Explanation

This vulnerability enables a **consensus liveness attack** with **High Severity** impact:

- **Significant Protocol Violation**: Malicious proposer can prevent consensus progress during their elected rounds
- **Repeated Attacks**: Can be executed every time the malicious validator is elected proposer
- **No Collusion Required**: Single malicious proposer (< 1/3 Byzantine assumption)
- **Partial Network Unavailability**: Consensus cannot make progress during affected rounds

According to Aptos bug bounty criteria, "Validator node slowdowns" and "Significant protocol violations" qualify as **High Severity** ($50,000). This is more severe than slowdowns but less than "Total loss of liveness" (would be Critical) because the network recovers after timeout and next round begins.

## Likelihood Explanation

**High Likelihood** - This attack is realistic and straightforward:

1. **Attacker Requirements**: Only need to be a validator (elected proposer occasionally)
2. **Technical Complexity**: Low - simply craft two different OptProposalMsg and control network message timing
3. **Detection Difficulty**: Hard to distinguish from benign network delays/reordering
4. **Frequency**: Occurs whenever malicious proposer is elected (probabilistic based on validator count)
5. **No Cryptographic Proof**: Unlike ProposalMsg equivocation (which leaves signed evidence), OptProposalMsg equivocation leaves no cryptographic trace, only network-level evidence

## Recommendation

**Solution 1: Add Signature Requirement to OptProposalMsg (Preferred)**

Generate and verify BLS signatures for optimistic proposals:

```rust
// In consensus/src/round_manager.rs, modify generate_opt_proposal:
async fn generate_opt_proposal(...) -> anyhow::Result<OptProposalMsg> {
    let proposal = proposal_generator.generate_opt_proposal(...).await?;
    let signature = safety_rules.lock().sign_opt_proposal(&proposal)?;
    let signed_proposal = OptProposalMsg::new_signed(proposal, sync_info, signature);
    Ok(signed_proposal)
}
```

Then verify the signature in `OptProposalMsg::verify()`.

**Solution 2: Add Deduplication Check Before Buffering**

Prevent buffer overwriting by detecting duplicate rounds:

```rust
// In consensus/src/round_manager.rs, line 832:
ensure!(
    !self.pending_opt_proposals.contains_key(&proposal_msg.round()),
    "Already received OptProposalMsg for round {}, rejecting duplicate from {}",
    proposal_msg.round(),
    proposal_msg.proposer()
);
self.pending_opt_proposals.insert(proposal_msg.round(), proposal_msg.take_block_data());
```

This prevents overwriting but still allows equivocation by sending different proposals to different subsets. **Solution 1 is preferred** as it provides cryptographic non-repudiation.

## Proof of Concept

```rust
#[cfg(test)]
mod opt_proposal_equivocation_test {
    use super::*;
    
    #[tokio::test]
    async fn test_opt_proposal_buffer_overwrite_attack() {
        // Setup: 4 validators, malicious validator is proposer for round 3
        let (mut round_manager, malicious_signer) = setup_test_round_manager(4);
        
        // Round 2: Validators are here
        round_manager.advance_to_round(2).await.unwrap();
        
        // Malicious proposer creates two different OptProposalMsg for round 3
        let opt_proposal_a = create_opt_proposal(3, &malicious_signer, b"payload_A");
        let opt_proposal_b = create_opt_proposal(3, &malicious_signer, b"payload_B");
        
        // Simulate: Validator receives proposal A, buffers it
        round_manager.process_opt_proposal_msg(opt_proposal_a.clone()).await.unwrap();
        assert!(round_manager.pending_opt_proposals.contains_key(&3));
        let buffered_hash_a = round_manager.pending_opt_proposals.get(&3).unwrap().hash();
        
        // Attack: Validator receives proposal B for SAME round, overwrites!
        round_manager.process_opt_proposal_msg(opt_proposal_b.clone()).await.unwrap();
        let buffered_hash_b = round_manager.pending_opt_proposals.get(&3).unwrap().hash();
        
        // Verify: Proposal B overwrote proposal A
        assert_ne!(buffered_hash_a, buffered_hash_b);
        
        // Different validators now have different proposals buffered
        // When round 3 starts, they'll vote on different blocks
        // causing vote splitting and liveness failure
    }
}
```

## Notes

The fundamental issue is that optimistic proposals sacrifice **non-repudiation** (cryptographic proof of authorship) for **latency** (sending proposals before parent is certified). While network-level authentication prevents identity spoofing, it doesn't prevent equivocation because the malicious proposer legitimately controls their network connection. The buffer overwriting semantics exacerbate this by allowing different validators to end up with different proposals through timing manipulation.

### Citations

**File:** consensus/consensus-types/src/proposal_msg.rs (L82-118)
```rust
    pub fn verify(
        &self,
        sender: Author,
        validator: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> Result<()> {
        if let Some(proposal_author) = self.proposal.author() {
            ensure!(
                proposal_author == sender,
                "Proposal author {:?} doesn't match sender {:?}",
                proposal_author,
                sender
            );
        }
        let (payload_result, sig_result) = rayon::join(
            || {
                self.proposal().payload().map_or(Ok(()), |p| {
                    p.verify(validator, proof_cache, quorum_store_enabled)
                })
            },
            || {
                self.proposal()
                    .validate_signature(validator)
                    .map_err(|e| format_err!("{:?}", e))
            },
        );
        payload_result?;
        sig_result?;

        // if there is a timeout certificate, verify its signatures
        if let Some(tc) = self.sync_info.highest_2chain_timeout_cert() {
            tc.verify(validator).map_err(|e| format_err!("{:?}", e))?;
        }
        // Note that we postpone the verification of SyncInfo until it's being used.
        self.verify_well_formed()
    }
```

**File:** consensus/consensus-types/src/opt_proposal_msg.rs (L96-123)
```rust
    pub fn verify(
        &self,
        sender: Author,
        validator: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> Result<()> {
        ensure!(
            self.proposer() == sender,
            "OptProposal author {:?} doesn't match sender {:?}",
            self.proposer(),
            sender
        );

        let (payload_verify_result, qc_verify_result) = rayon::join(
            || {
                self.block_data()
                    .payload()
                    .verify(validator, proof_cache, quorum_store_enabled)
            },
            || self.block_data().grandparent_qc().verify(validator),
        );
        payload_verify_result?;
        qc_verify_result?;

        // Note that we postpone the verification of SyncInfo until it's being used.
        self.verify_well_formed()
    }
```

**File:** consensus/consensus-types/src/block.rs (L410-417)
```rust
    pub fn new_from_opt(opt_block_data: OptBlockData, quorum_cert: QuorumCert) -> Self {
        let block_data = BlockData::new_from_opt(opt_block_data, quorum_cert);
        Block {
            id: block_data.hash(),
            block_data,
            signature: None,
        }
    }
```

**File:** consensus/consensus-types/src/block.rs (L453-461)
```rust
            BlockType::OptimisticProposal(p) => {
                // Note: Optimistic proposal is not signed by proposer unlike normal proposal
                let (res1, res2) = rayon::join(
                    || p.grandparent_qc().verify(validator),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
```

**File:** consensus/src/round_manager.rs (L743-764)
```rust
        let in_correct_round = self
            .ensure_round_and_sync_up(
                proposal_msg.proposal().round(),
                proposal_msg.sync_info(),
                proposal_msg.proposer(),
            )
            .await
            .context("[RoundManager] Process proposal")?;
        if in_correct_round {
            self.process_proposal(proposal_msg.take_proposal()).await
        } else {
            sample!(
                SampleRate::Duration(Duration::from_secs(30)),
                warn!(
                    "[sampled] Stale proposal {}, current round {}",
                    proposal_msg.proposal(),
                    self.round_state.current_round()
                )
            );
            counters::ERROR_COUNT.inc();
            Ok(())
        }
```

**File:** consensus/src/round_manager.rs (L822-834)
```rust
            // Pre-check that proposal is from valid proposer before queuing it.
            // This check is done after syncing up to sync info to ensure proposer
            // election provider is up to date.
            ensure!(
                self.proposer_election
                    .is_valid_proposer(proposal_msg.proposer(), proposal_msg.round()),
                "[OptProposal] Not a valid proposer for round {}: {}",
                proposal_msg.round(),
                proposal_msg.proposer()
            );
            self.pending_opt_proposals
                .insert(proposal_msg.round(), proposal_msg.take_block_data());
        }
```
