# Audit Report

## Title
API Content-Length Limit Mismatch Enables Resource Exhaustion via Oversized Transaction Flooding

## Summary
A significant gap exists between the API's HTTP content-length limit (8MB) and the VM's actual transaction size limit (64KB), creating a 125x amplification attack vector. Attackers can repeatedly submit oversized transactions that pass API validation but fail during VM validation, consuming substantial validator resources before rejection.

## Finding Description

The vulnerability stems from a validation gap in the transaction submission pipeline:

The API middleware enforces an 8MB content-length limit: [1](#0-0) 

This limit is applied via the `PostSizeLimit` middleware which only validates the HTTP Content-Length header: [2](#0-1) 

However, the actual transaction size limit enforced by the VM is only 64KB: [3](#0-2) 

This validation occurs during VM gas checking, well after significant resources have been consumed: [4](#0-3) 

The transaction validation flow shows that VM validation happens only after:
1. HTTP request parsing and body reading (up to 8MB)
2. Transaction deserialization (BCS or JSON)
3. Database reads for sequence number lookup
4. Submission to mempool processing [5](#0-4) 

**Attack Execution:**
1. Attacker crafts transactions between 64KB and 8MB in size
2. Submits them repeatedly via POST to `/v1/transactions`
3. Each request passes the API size check (â‰¤ 8MB)
4. Resources are consumed for parsing, deserialization, and DB operations
5. Transactions are rejected only at VM validation with `EXCEEDED_MAX_TRANSACTION_SIZE`
6. No API-level rate limiting prevents repeated submissions from same or different sources

This violates the **Resource Limits** invariant: the API layer fails to enforce proper transaction size constraints before consuming validator resources.

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria:

- **Validator Node Slowdowns**: The attack can exhaust API worker threads, consume network bandwidth, and cause memory pressure through repeated oversized transaction processing
- **API Unavailability**: Legitimate users may experience degraded or unavailable API service during an attack
- **Resource Exhaustion**: Each 8MB request consumes 125x more network/processing resources than the actual 64KB transaction limit allows

While mempool capacity limits provide some protection once transactions reach that stage: [6](#0-5) 

The resource consumption occurs **before** mempool admission, making these protections ineffective against this specific attack vector.

The attack does not directly compromise consensus safety or cause fund loss, but significantly degrades validator availability and performance, justifying Medium severity classification.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack Complexity**: Trivial - requires only HTTP POST requests with oversized transaction payloads
- **Attacker Requirements**: No special privileges, authentication, or insider access needed
- **Detection Difficulty**: Oversized transactions appear as legitimate API requests until VM validation
- **Amplification Factor**: 125x (8MB accepted vs 64KB actual limit)
- **Automation**: Easily scriptable and can be distributed across multiple source IPs/accounts
- **No Rate Limiting**: The codebase shows no API-level rate limiting mechanisms: [7](#0-6) 

The absence of early transaction size validation makes this attack vector immediately exploitable by any external actor.

## Recommendation

Implement early transaction size validation at the API layer before deserialization and processing:

**1. Add Early Size Validation in API Layer:**

Modify `api/src/transactions.rs` to validate transaction size immediately after deserialization and before mempool submission. Add a check in `get_signed_transaction` method around line 1224:

```rust
let signed_transaction: SignedTransaction = 
    bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
    .context("Failed to deserialize input into SignedTransaction")
    .map_err(|err| { /* ... */ })?;

// Add early size validation
let txn_size = signed_transaction.txn_bytes_len();
if txn_size > 64 * 1024 {  // Match VM limit
    return Err(SubmitTransactionError::bad_request_with_code(
        format!("Transaction size {} exceeds maximum allowed size of 64KB", txn_size),
        AptosErrorCode::InvalidInput,
        ledger_info,
    ));
}
```

**2. Align API Content-Length Limit with VM Limit:**

Update `config/src/config/api_config.rs` to reduce the default content-length limit to match or slightly exceed the actual transaction size limit (e.g., 128KB for overhead):

```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 128 * 1024; // 128 KB
```

**3. Implement API-Level Rate Limiting:**

Add rate limiting middleware in `api/src/runtime.rs` to restrict requests per IP/account within a time window, preventing rapid flooding attempts.

## Proof of Concept

```rust
// File: api/src/tests/transaction_flooding_test.rs
#[tokio::test]
async fn test_oversized_transaction_resource_exhaustion() {
    use aptos_api_test_context::{new_test_context, TestContext};
    use aptos_types::transaction::{RawTransaction, TransactionPayload, Script};
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
    use bcs;
    
    // Initialize test context
    let mut context = new_test_context("test_oversized_txn".to_string(), 
                                       NodeConfig::default(), false);
    
    // Generate a large transaction payload (> 64KB but < 8MB)
    let large_payload = vec![0u8; 100 * 1024]; // 100KB payload
    let script = Script::new(large_payload, vec![], vec![]);
    
    let sender_key = Ed25519PrivateKey::generate_for_testing();
    let sender = aptos_types::account_address::AccountAddress::random();
    
    let raw_txn = RawTransaction::new(
        sender,
        0,
        TransactionPayload::Script(script),
        1_000_000,
        0,
        0,
    );
    
    let signed_txn = raw_txn.sign(&sender_key, sender_key.public_key()).unwrap();
    let txn_bytes = bcs::to_bytes(&signed_txn).unwrap();
    
    // Verify transaction is larger than VM limit (64KB) but within API limit (8MB)
    assert!(txn_bytes.len() > 64 * 1024, "Transaction should exceed 64KB");
    assert!(txn_bytes.len() < 8 * 1024 * 1024, "Transaction should be under 8MB");
    
    // Submit via API - should pass content-length check
    let client = context.api_client();
    let response = client.post("/v1/transactions")
        .header("Content-Type", "application/x.aptos.signed_transaction+bcs")
        .body(txn_bytes.clone())
        .send()
        .await
        .unwrap();
    
    // Transaction should be rejected with VM error, but only after consuming resources
    assert_eq!(response.status(), 400); // Bad Request
    let error: serde_json::Value = response.json().await.unwrap();
    assert!(error["message"].as_str().unwrap().contains("EXCEEDED_MAX_TRANSACTION_SIZE"));
    
    // Demonstrate resource exhaustion by submitting many oversized transactions rapidly
    for _ in 0..100 {
        let _ = client.post("/v1/transactions")
            .header("Content-Type", "application/x.aptos.signed_transaction+bcs")
            .body(txn_bytes.clone())
            .send()
            .await;
    }
    
    // API worker threads and network bandwidth consumed before each rejection
}
```

### Citations

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** api/src/check_size.rs (L43-58)
```rust
    async fn call(&self, req: Request) -> Result<Self::Output> {
        if req.method() != Method::POST {
            return self.inner.call(req).await;
        }

        let content_length = req
            .headers()
            .typed_get::<headers::ContentLength>()
            .ok_or(SizedLimitError::MissingContentLength)?;

        if content_length.0 > self.max_size {
            return Err(SizedLimitError::PayloadTooLarge.into());
        }

        self.inner.call(req).await
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-121)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L490-504)
```rust
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
    vm_validation_timer.stop_and_record();
```

**File:** config/src/config/mempool_config.rs (L121-123)
```rust
            capacity: 2_000_000,
            capacity_bytes: 2 * 1024 * 1024 * 1024,
            capacity_per_user: 100,
```

**File:** api/src/runtime.rs (L253-259)
```rust
            .with(cors)
            .with_if(config.api.compression_enabled, Compression::new())
            .with(PostSizeLimit::new(size_limit))
            .with(CatchPanic::new().with_handler(panic_handler))
            // NOTE: Make sure to keep this after all the `with` middleware.
            .catch_all_error(convert_error)
            .around(middleware_log);
```
