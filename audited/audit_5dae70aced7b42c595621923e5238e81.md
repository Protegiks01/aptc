# Audit Report

## Title
VFN Network Identity Reuse Violates Network Isolation and Exposes Validator Fullnode Credentials to Public Network

## Summary
The `Builder::generate_validator_config()` function incorrectly configures both the validator's Public fullnode network and VFN (Validator Full Node) network to use the same identity file, causing them to share the same network private key and peer ID. This architectural flaw breaks the cryptographic isolation between trusted and untrusted network boundaries, exposing VFN network credentials on the public network.

## Finding Description
In `crates/aptos-genesis/src/builder.rs`, the `generate_validator_config()` function creates two distinct fullnode networks for validators: a Public network (for untrusted public fullnode connections) and a VFN network (for secure validator-to-VFN communication). However, both networks are configured to use the identical identity file. [1](#0-0) 

Both `fullnode_network` (NetworkId::Public) and `vfn_network` (NetworkId::Vfn) use `Identity::from_file(vfn_identity_path)`, causing them to share:

1. **Same network private key**: The x25519::PrivateKey from the VFN identity blob
2. **Same peer ID**: Derived from the account_address in the vfn_blob [2](#0-1) 

The VFN identity contains the `full_node_network_key`, which should be isolated to secure VFN communication, not exposed on the public network. [3](#0-2) 

When the identity is loaded from file, both networks extract the same `network_private_key`, eliminating any cryptographic distinction between the trusted VFN network and the untrusted Public network.

**Violation of Network Isolation Invariant:**
The VFN network exists specifically to provide a secure, authenticated channel between validators and their VFNs. The Public network is for open communication with any public fullnode. These represent fundamentally different trust boundaries: [4](#0-3) 

By sharing the same network identity, the validator exposes its VFN credentials to any peer connecting to the Public network, violating the principle of defense in depth and network isolation.

**Comparison with Correct Implementation:**
The `attach_to_validator()` function demonstrates the correct approach: when configuring a VFN fullnode, it explicitly generates a NEW identity for the VFN's VFN network rather than reusing the Public network identity: [5](#0-4) [6](#0-5) 

This confirms that separate identities SHOULD be used for different networks.

## Impact Explanation
**Severity: High**

This vulnerability represents a significant protocol violation that weakens the security architecture of the Aptos network:

1. **Credential Exposure**: VFN network credentials (peer ID and public key) are unnecessarily exposed on the untrusted Public network, where any malicious actor can observe them.

2. **Loss of Network Isolation**: The entire purpose of having separate VFN and Public networks is to maintain distinct trust boundaries. Sharing identities eliminates the cryptographic separation between these security domains.

3. **Reduced Defense in Depth**: If any future vulnerability or misconfiguration fails to properly validate NetworkId in authorization checks, the shared identity could enable privilege escalation or unauthorized access.

4. **Attack Surface Expansion**: The VFN network's identity, which should only be known to the validator's trusted VFNs, becomes public knowledge accessible to all Public network peers.

While the current codebase properly checks `NetworkId` in most places (preventing immediate exploitation), this architectural weakness creates fragility and violates fundamental security principles. It represents a "significant protocol violation" qualifying for High severity under the Aptos bug bounty program.

## Likelihood Explanation
**Likelihood: High**

This bug affects ALL validators configured through the genesis builder:
- Every validator using `Builder::generate_validator_config()` will have this misconfiguration
- The issue occurs automatically during genesis/configuration generation
- No special conditions or attacker actions are required for the vulnerability to exist
- The shared identity is exposed on every connection to the Public network

The likelihood of future exploitation is elevated because:
- Any new code that fails to properly validate NetworkId could be exploited
- Security reviews might not catch NetworkId validation issues if they assume cryptographic isolation exists
- The exposed credentials make reconnaissance trivial for attackers

## Recommendation
Generate and use separate identity files for the Public fullnode network and VFN network. The VFN network should maintain its own unique private key and peer ID.

**Proposed Fix:**

```rust
// Generate separate identity for the public fullnode network
let public_identity_path = validator.dir.join("public-identity.yaml");
if !public_identity_path.exists() {
    let mut keygen = KeyGen::from_os_rng();
    let key = keygen.generate_x25519_private_key()?;
    let peer_id = aptos_types::account_address::from_identity_public_key(key.public_key());
    let public_blob = IdentityBlob {
        account_address: Some(peer_id),
        account_private_key: None,
        consensus_private_key: None,
        network_private_key: key,
    };
    write_yaml(public_identity_path.as_path(), &public_blob)?;
}

let fullnode_network = NetworkConfig {
    listen_address: fullnode_network_listen_address,
    network_id: NetworkId::Public,
    max_outbound_connections: 0,
    discovery_method: DiscoveryMethod::Onchain,
    identity: Identity::from_file(public_identity_path), // Use separate identity
    ..Default::default()
};

// VFN network continues to use vfn_identity_path
let vfn_identity_path = validator.dir.join(VFN_IDENTITY);
let vfn_network = NetworkConfig {
    listen_address: aptos_config::utils::get_available_port_in_multiaddr(true),
    network_id: NetworkId::Vfn,
    max_outbound_connections: 0,
    identity: Identity::from_file(vfn_identity_path),
    ..Default::default()
};
```

This ensures cryptographic separation between the Public and VFN networks, maintaining proper network isolation.

## Proof of Concept
**Demonstration of Identity Reuse:**

```rust
use aptos_genesis::builder::Builder;
use aptos_config::config::NodeConfig;
use std::path::PathBuf;

#[test]
fn test_vfn_identity_reuse_vulnerability() {
    // Create a genesis builder
    let temp_dir = tempfile::tempdir().unwrap();
    let framework = aptos_framework::ReleaseBundle::current();
    let mut builder = Builder::new(temp_dir.path(), framework).unwrap();
    
    // Generate a validator config
    let template = NodeConfig::get_default_validator_config();
    let mut rng = rand::rngs::OsRng;
    let mut validator = builder
        .generate_validator_config(0, &mut rng, &template)
        .unwrap();
    
    // Extract the two fullnode networks
    let config = validator.config.override_config();
    let networks = &config.full_node_networks;
    
    let public_network = networks
        .iter()
        .find(|n| n.network_id == aptos_config::network_id::NetworkId::Public)
        .unwrap();
    
    let vfn_network = networks
        .iter()
        .find(|n| n.network_id == aptos_config::network_id::NetworkId::Vfn)
        .unwrap();
    
    // Extract peer IDs from both networks
    let public_peer_id = public_network.peer_id();
    let vfn_peer_id = vfn_network.peer_id();
    
    // Extract private keys from both networks
    let public_key = public_network.identity_key();
    let vfn_key = vfn_network.identity_key();
    
    // VULNERABILITY: Both networks share the same identity
    assert_eq!(
        public_peer_id, vfn_peer_id,
        "BUG: Public and VFN networks share the same peer ID"
    );
    assert_eq!(
        public_key.to_bytes(),
        vfn_key.to_bytes(),
        "BUG: Public and VFN networks share the same private key"
    );
    
    // This breaks network isolation - credentials intended for secure VFN
    // network are exposed on the untrusted Public network
    println!(
        "SECURITY VIOLATION: VFN credentials exposed on Public network\n\
         Shared Peer ID: {:?}\n\
         This violates network isolation between trusted and untrusted boundaries",
        vfn_peer_id
    );
}
```

**Notes:**
This architectural flaw exists in all validators configured through the genesis builder. While the current code properly validates NetworkId in most authorization paths, the lack of cryptographic separation between security domains violates fundamental security principles and creates unnecessary risk. The VFN network's identity should remain private to the validator and its trusted VFNs, not be exposed to all Public network peers.

### Citations

**File:** crates/aptos-genesis/src/builder.rs (L389-391)
```rust
        // Set the identity for the VFN port
        set_identity_for_network(fullnode_vfn_network)?;

```

**File:** crates/aptos-genesis/src/builder.rs (L402-410)
```rust
fn set_identity_for_network(network: &mut NetworkConfig) -> anyhow::Result<()> {
    if let Identity::None = network.identity {
        let mut keygen = KeyGen::from_os_rng();
        let key = keygen.generate_x25519_private_key()?;
        let peer_id = aptos_types::account_address::from_identity_public_key(key.public_key());
        network.identity = Identity::from_config(key, peer_id);
    }
    Ok(())
}
```

**File:** crates/aptos-genesis/src/builder.rs (L587-613)
```rust
        let vfn_identity_path = validator.dir.join(VFN_IDENTITY);

        let config = &mut validator.config.override_config_mut();
        let fullnode_network_listen_address =
            if let Some(template_fullnode_config) = config.full_node_networks.first() {
                template_fullnode_config.listen_address.clone()
            } else {
                aptos_config::utils::get_available_port_in_multiaddr(true)
            };

        let fullnode_network = NetworkConfig {
            listen_address: fullnode_network_listen_address,
            network_id: NetworkId::Public,
            max_outbound_connections: 0,
            discovery_method: DiscoveryMethod::Onchain,
            identity: Identity::from_file(vfn_identity_path.clone()),
            ..Default::default()
        };

        // VFN has the same credentials as the public full node identity
        let vfn_network = NetworkConfig {
            listen_address: aptos_config::utils::get_available_port_in_multiaddr(true),
            network_id: NetworkId::Vfn,
            max_outbound_connections: 0,
            identity: Identity::from_file(vfn_identity_path),
            ..Default::default()
        };
```

**File:** crates/aptos-genesis/src/keys.rs (L53-58)
```rust
    let vfn_blob = IdentityBlob {
        account_address: Some(account_address),
        account_private_key: None,
        consensus_private_key: None,
        network_private_key: full_node_network_key.private_key(),
    };
```

**File:** config/src/config/network_config.rs (L187-206)
```rust
    pub fn identity_key(&self) -> x25519::PrivateKey {
        let key = match &self.identity {
            Identity::FromConfig(config) => Some(config.key.private_key()),
            Identity::FromStorage(config) => {
                let storage: Storage = (&config.backend).into();
                let key = storage
                    .export_private_key(&config.key_name)
                    .expect("Unable to read key");
                let key = x25519::PrivateKey::from_ed25519_private_bytes(&key.to_bytes())
                    .expect("Unable to convert key");
                Some(key)
            },
            Identity::FromFile(config) => {
                let identity_blob: IdentityBlob = IdentityBlob::from_file(&config.path).unwrap();
                Some(identity_blob.network_private_key)
            },
            Identity::None => None,
        };
        key.expect("identity key should be present")
    }
```

**File:** config/src/network_id.rs (L159-212)
```rust
impl NetworkId {
    pub fn is_public_network(&self) -> bool {
        self == &NetworkId::Public
    }

    pub fn is_vfn_network(&self) -> bool {
        self == &NetworkId::Vfn
    }

    pub fn is_validator_network(&self) -> bool {
        self == &NetworkId::Validator
    }

    /// Roles for a prioritization of relative upstreams
    pub fn upstream_roles(&self, role: &RoleType) -> &'static [PeerRole] {
        match self {
            NetworkId::Validator => &[PeerRole::Validator],
            NetworkId::Public => &[
                PeerRole::PreferredUpstream,
                PeerRole::Upstream,
                PeerRole::ValidatorFullNode,
            ],
            NetworkId::Vfn => match role {
                RoleType::Validator => &[],
                RoleType::FullNode => &[PeerRole::Validator],
            },
        }
    }

    /// Roles for a prioritization of relative downstreams
    pub fn downstream_roles(&self, role: &RoleType) -> &'static [PeerRole] {
        match self {
            NetworkId::Validator => &[PeerRole::Validator],
            // In order to allow fallbacks, we must allow for nodes to accept ValidatorFullNodes
            NetworkId::Public => &[
                PeerRole::ValidatorFullNode,
                PeerRole::Downstream,
                PeerRole::Known,
                PeerRole::Unknown,
            ],
            NetworkId::Vfn => match role {
                RoleType::Validator => &[PeerRole::ValidatorFullNode],
                RoleType::FullNode => &[],
            },
        }
    }

    pub fn as_str(&self) -> &str {
        match self {
            NetworkId::Validator => "Validator",
            NetworkId::Public => "Public",
            NetworkId::Vfn => VFN_NETWORK,
        }
    }
```
