# Audit Report

## Title
Stale Module Verification Cache Allows Execution of Code Verified Against Outdated Framework Dependencies

## Summary
The `VERIFIED_MODULES_CACHE` in the Move VM does not invalidate verified modules when their framework dependencies are upgraded. This allows modules that were verified against old framework versions (potentially containing known vulnerabilities) to continue executing without re-verification against the updated framework, breaking verification freshness guarantees.

## Finding Description

The Move VM uses a global LRU cache (`VERIFIED_MODULES_CACHE`) to skip repeated bytecode verification of modules based solely on their hash. When a module is verified, its hash is cached, and subsequent loads of the same module skip local verification. [1](#0-0) 

The critical flaw exists in the verification logic where the cache check only considers the module's own hash, not the state of its dependencies: [2](#0-1) 

The comment claims "as long as the hash is the same, the deployed bytecode and any dependencies are the same," but this is **incorrect**. The module hash only represents that specific module's bytecode, not its dependencies. When a framework module is upgraded, dependent modules' hashes don't change.

The cache is only flushed when the **verifier configuration** changes, not when framework modules are upgraded: [3](#0-2) 

Additionally, when modules are published, only the specific published module is marked as overridden in the global cache—dependent modules remain valid: [4](#0-3) 

**Attack Scenario:**

1. Attacker deploys Module A at address 0x123 that depends on Framework Module B v1 (which has a security vulnerability)
2. Module A passes verification against Framework B v1, and its hash is stored in `VERIFIED_MODULES_CACHE`
3. Framework governance upgrades Module B to v2 with critical security fixes (e.g., adds access control checks, fixes type system bugs)
4. Module B is marked as overridden in `GlobalModuleCache`, but Module A's hash remains in `VERIFIED_MODULES_CACHE`
5. When Module A is executed again:
   - Its hash is found in the cache (line 184 in environment.rs)
   - Local bytecode verification is **skipped**
   - Module A executes with assumptions about Framework B v1, not v2
6. Module A can now bypass new security checks or exploit fixed vulnerabilities that should no longer be accessible

## Impact Explanation

This vulnerability has **High to Critical** severity impact:

**Consensus Violations (Critical):** If different validator nodes have different cache states (e.g., some flushed, some not), they may execute the same module with different verification states, leading to divergent state roots and consensus failure. This breaks the **Deterministic Execution** invariant.

**Security Bypass (High):** Modules verified against vulnerable framework versions can continue executing even after the vulnerabilities are patched. This allows:
- Bypassing new access control checks added in framework upgrades
- Exploiting type system vulnerabilities that were fixed
- Executing code with ABI mismatches if function signatures changed
- Circumventing new safety invariants introduced in framework updates

**Framework Upgrade Ineffectiveness (High):** Security-critical framework upgrades become partially ineffective because existing modules continue operating under old security assumptions.

## Likelihood Explanation

**Likelihood: High**

This vulnerability will occur automatically whenever:
1. Any user deploys a module depending on framework code (common operation)
2. The Aptos framework is upgraded via governance (happens regularly for bug fixes and improvements)
3. The verifier configuration is not changed (typical for most upgrades)

No attacker sophistication is required—this is a systemic cache invalidation bug that affects all modules. The attack requires only:
- Deploying a module (any user can do this)
- Waiting for a framework upgrade (inevitable for a maintained blockchain)

The vulnerability is **easier to exploit** than most because the attacker doesn't need to craft special bytecode or manipulate state—normal module deployment followed by normal framework upgrades triggers the issue.

## Recommendation

**Immediate Fix:** Flush the `VERIFIED_MODULES_CACHE` whenever any framework module is published, not just when the verifier config changes.

In `code_cache_global_manager.rs`, modify the cache invalidation logic:

```rust
fn check_ready(
    &mut self,
    storage_environment: AptosEnvironment,
    config: &BlockExecutorModuleCacheLocalConfig,
    transaction_slice_metadata: TransactionSliceMetadata,
) -> Result<(), VMStatus> {
    // ... existing code ...
    
    let environment_requires_update = self.environment.as_ref() != Some(&storage_environment);
    if environment_requires_update {
        // SECURITY FIX: Always flush verifier cache when environment changes,
        // as this may indicate framework module upgrades
        RuntimeEnvironment::flush_verified_module_cache();
        
        self.environment = Some(storage_environment);
        self.module_cache.flush();
    }
    
    // ... rest of code ...
}
```

**Better Long-term Fix:** Include dependency hashes in the cache key, or track dependency versions:

```rust
// In verified_module_cache.rs
pub(crate) struct VerifiedModuleCacheKey {
    module_hash: [u8; 32],
    dependency_version: u64, // Incremented on any framework change
}
```

**Alternative Fix:** When marking a module as overridden in `GlobalModuleCache`, also invalidate all cached modules that depend on it by flushing `VERIFIED_MODULES_CACHE`.

## Proof of Concept

```rust
// Test in aptos-move/aptos-vm/tests/module_cache_test.rs

#[test]
fn test_stale_verification_after_dependency_upgrade() {
    use aptos_types::account_address::AccountAddress;
    use move_core_types::identifier::Identifier;
    use move_vm_runtime::RuntimeEnvironment;
    
    // Step 1: Deploy framework module B v1
    let framework_addr = AccountAddress::ONE;
    let user_addr = AccountAddress::from_hex_literal("0x123").unwrap();
    
    // Deploy and verify framework module B v1
    let framework_module_v1 = compile_module("
        module 0x1::framework_b {
            public fun check(): bool { false } // Vulnerable: always returns false
        }
    ");
    
    // Step 2: Deploy user module A that depends on B
    let user_module = compile_module("
        module 0x123::user_a {
            use 0x1::framework_b;
            
            public fun exploit(): bool {
                // Assumes old behavior where check() returns false
                !framework_b::check()
            }
        }
    ");
    
    // Verify module A - it passes and hash is cached
    let module_a_hash = hash_module(&user_module);
    // Module A is now in VERIFIED_MODULES_CACHE
    
    // Step 3: Upgrade framework module B to v2 with security fix
    let framework_module_v2 = compile_module("
        module 0x1::framework_b {
            public fun check(): bool { true } // Fixed: now returns true
        }
    ");
    
    // Publish v2 - only B is marked as overridden
    // Module A's hash REMAINS in VERIFIED_MODULES_CACHE
    
    // Step 4: Execute module A again
    // BUG: Module A's verification is skipped (cache hit)
    // Module A executes with old assumptions about framework_b::check()
    // It returns true (!false), but framework_b::check() now returns true
    // This creates an ABI mismatch: A expects false, gets true
    
    // Expected: Module A should be re-verified against B v2
    // Actual: Module A uses cached verification against B v1
    
    assert!(verification_cache_contains(module_a_hash)); // BUG: Still cached
    assert!(execute_module_a_returns_incorrect_result()); // BUG: Wrong behavior
}
```

**Notes:**
- The vulnerability is present in production code and affects all module deployments
- The cache invalidation logic incorrectly assumes module hashes capture dependency state
- Framework upgrades are a regular occurrence in Aptos, making this highly exploitable
- The issue breaks both deterministic execution (consensus) and security update effectiveness

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L8-13)
```rust

/// Cache for already verified modules. Since loader V1 uses such a cache to not perform repeated
/// verifications, possibly even across blocks, for comparative performance we need to have it as
/// well. For now, we keep it as a separate cache to make sure there is no interference between V1
/// and V2 implementations.
pub(crate) struct VerifiedModuleCache(Mutex<lru::LruCache<[u8; 32], ()>>);
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L184-197)
```rust
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L118-125)
```rust
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L317-318)
```rust
    global_module_cache.mark_overridden(write.module_id());
    Ok(())
```
