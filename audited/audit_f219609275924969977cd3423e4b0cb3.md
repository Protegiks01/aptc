# Audit Report

## Title
Denial of Service for Keyless Authentication During OIDC Provider Removal with `keep_observed_jwks=false`

## Summary
When a governance proposal removes an OIDC provider with `keep_observed_jwks=false`, it immediately deletes the provider's JWKs from `ObservedJWKs` and `PatchedJWKs` while validators continue observing that provider until the next epoch. This creates a denial-of-service window (10-20+ seconds) during which all users with valid tokens from that provider cannot authenticate, causing transaction failures.

## Finding Description

The vulnerability exists in the OIDC provider removal flow implemented in the governance proposal generation code. When `write_op()` processes a `Remove` operation with `keep_observed_jwks=false`, it generates Move function calls that create a timing mismatch between JWK removal and validator observer shutdown. [1](#0-0) 

The function first calls `remove_oidc_provider_for_next_epoch()` which stages the provider removal for the **next epoch** using the config buffer pattern: [2](#0-1) 

However, when `keep_observed_jwks=false`, it then immediately calls `remove_issuer_from_observed_jwks()`, which **immediately** removes the issuer from `ObservedJWKs` in the current epoch: [3](#0-2) 

This function immediately updates `ObservedJWKs`, emits an event, and calls `regenerate_patched_jwks()` which updates `PatchedJWKs`: [4](#0-3) 

**The Critical Timing Issue:**

At epoch start, validators spawn JWK observers based on `SupportedOIDCProviders`: [5](#0-4) [6](#0-5) 

These observers run on a 10-second interval: [7](#0-6) 

**The Denial of Service Window:**

1. Governance transaction executes, removing JWKs from `ObservedJWKs`/`PatchedJWKs` immediately
2. When users attempt keyless authentication, `get_jwks_onchain()` fetches the now-empty `PatchedJWKs`: [8](#0-7) 

3. `get_jwk_for_authenticator()` fails to find the JWK: [9](#0-8) 

4. For non-federated keyless accounts, this causes immediate authentication failure: [10](#0-9) 

5. Validators are still observing the provider and will eventually produce a new update, but this takes:
   - Up to 10 seconds for next observation
   - Additional time for consensus
   - Additional time for validator transaction execution

During this entire window, **all users with valid tokens from the removed provider cannot submit transactions**.

## Impact Explanation

This vulnerability meets the **High Severity** criteria per the Aptos bug bounty program:

- **API crashes**: User transactions with valid keyless authentication fail due to missing JWKs
- **Significant protocol violations**: The timing mismatch between config changes and JWK availability violates the expected atomicity of provider management
- **Temporary denial of service**: Affects all users authenticated via the removed OIDC provider (potentially thousands of users if removing a major provider like Google)

While the system eventually recovers automatically (validators re-observe and restore the JWKs), the 10-20+ second outage window can cause:
- Failed transactions during critical operations (DeFi trades, NFT mints, time-sensitive governance votes)
- Poor user experience and loss of confidence in keyless authentication
- Potential for malicious timing if coordinated with other attacks

This is not Critical severity because:
- No permanent loss of funds
- No consensus safety violation
- System recovers automatically without hard fork
- Does not affect non-keyless authentication methods

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability can occur through:

1. **Legitimate governance actions**: Well-intentioned governance participants may not understand the implications of `keep_observed_jwks=false` and inadvertently cause DoS when removing outdated providers
2. **Malicious governance proposals**: A governance actor could intentionally exploit this to cause temporary disruption during critical moments
3. **Provider deprecation**: When deprecating an OIDC provider, the natural inclination is to set `keep_observed_jwks=false` to "clean up" old JWKs

The attack requires:
- Governance proposal approval (requires token holder voting)
- Understanding of the `keep_observed_jwks` parameter
- No additional technical complexity

The likelihood is elevated because:
- The parameter name `keep_observed_jwks` suggests it's a cleanup option, not a DoS trigger
- No warnings or documentation about the timing implications
- The vulnerability occurs during routine provider management operations

## Recommendation

**Fix 1: Delay JWK Removal Until Next Epoch**

Modify `remove_issuer_from_observed_jwks()` to also use the config buffer pattern, delaying the removal until epoch change:

```move
// In jwks.move - Create a new buffered removal function
public fun remove_issuer_from_observed_jwks_for_next_epoch(
    fx: &signer, 
    issuer: vector<u8>
): Option<ProviderJWKs> acquires ObservedJWKs {
    system_addresses::assert_aptos_framework(fx);
    
    // Store the removal request in config_buffer
    let removal_marker = PendingObservedJWKsRemoval { issuer };
    config_buffer::upsert(removal_marker);
    
    // Return current value without modifying it
    let observed_jwks = borrow_global<ObservedJWKs>(@aptos_framework);
    // ... lookup and return the current provider_jwks if it exists
}

// In on_new_epoch(), apply the buffered removal
public(friend) fun on_new_epoch(framework: &signer) acquires ObservedJWKs {
    // ... existing SupportedOIDCProviders logic ...
    
    // Apply pending removals
    if (config_buffer::does_exist<PendingObservedJWKsRemoval>()) {
        let removal = config_buffer::extract_v2<PendingObservedJWKsRemoval>();
        remove_issuer_from_observed_jwks(framework, removal.issuer);
    }
}
```

Update the Rust code generator: [11](#0-10) 

Change to call the buffered removal function instead.

**Fix 2: Remove the `keep_observed_jwks` Parameter**

Simpler approach: Always keep observed JWKs when removing a provider. The JWKs will naturally be cleaned up through the normal JWK consensus process when they're no longer needed.

**Fix 3: Add Grace Period Warning**

If immediate removal is required, add a two-step process:
1. First proposal: Remove provider from `SupportedOIDCProviders` for next epoch
2. After epoch change completes and validators stop observing: Second proposal to remove JWKs

## Proof of Concept

```move
#[test_only]
module aptos_framework::jwks_removal_dos_test {
    use aptos_framework::jwks;
    use aptos_framework::reconfiguration;
    use aptos_framework::account::create_account_for_test;
    use std::string::utf8;
    
    #[test(aptos_framework = @aptos_framework)]
    fun test_provider_removal_causes_jwk_loss(aptos_framework: &signer) {
        // Setup
        create_account_for_test(@aptos_framework);
        reconfiguration::initialize_for_test(aptos_framework);
        jwks::initialize(aptos_framework);
        
        // Add a provider and some JWKs
        let issuer = b"https://accounts.google.com";
        jwks::upsert_oidc_provider(
            aptos_framework,
            issuer,
            b"https://accounts.google.com/.well-known/openid-configuration"
        );
        
        // Simulate validator consensus adding JWKs
        let jwk = jwks::new_rsa_jwk(
            utf8(b"test_kid"),
            utf8(b"RS256"),
            utf8(b"AQAB"),
            utf8(b"test_n_value")
        );
        let provider_jwks = jwks::ProviderJWKs {
            issuer,
            version: 1,
            jwks: vector[jwk],
        };
        jwks::upsert_into_observed_jwks(aptos_framework, vector[provider_jwks]);
        
        // Verify JWKs are available
        let patched = jwks::get_patched_jwk(issuer, b"test_kid");
        assert!(option::is_some(&patched), 1);
        
        // Remove provider with keep_observed_jwks=false
        // This simulates what the governance proposal would do
        jwks::remove_oidc_provider_for_next_epoch(aptos_framework, issuer);
        jwks::remove_issuer_from_observed_jwks(aptos_framework, issuer);
        
        // NOW: JWKs are immediately gone from PatchedJWKs
        // but validators are still in current epoch and still have observers running
        
        // Try to get JWK - this will fail, causing DoS for users
        let result = jwks::try_get_patched_jwk(issuer, b"test_kid");
        assert!(option::is_none(&result), 2); // FAILS - JWK is gone
        
        // This represents the DoS window where users cannot authenticate
        // Validators will eventually re-observe and restore, but users are blocked until then
    }
}
```

**Notes:**

The vulnerability is confirmed by the code flow showing that `remove_issuer_from_observed_jwks()` immediately modifies on-chain state while validators continue observing based on the pre-epoch-change configuration. The timing mismatch between configuration application (immediate for JWKs, delayed for provider list) creates the denial-of-service window.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/oidc_providers.rs (L61-79)
```rust
        OidcProviderOp::Remove {
            issuer,
            keep_observed_jwks,
        } => {
            emitln!(
                writer,
                "jwks::remove_oidc_provider_for_next_epoch({}, b\"{}\");",
                signer_arg,
                issuer
            );
            if !keep_observed_jwks {
                emitln!(
                    writer,
                    "jwks::remove_issuer_from_observed_jwks({}, b\"{}\");",
                    signer_arg,
                    issuer
                );
            }
        },
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L352-363)
```text
    public fun remove_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };
        let ret = remove_oidc_provider_internal(&mut provider_set, name);
        config_buffer::upsert(provider_set);
        ret
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L510-520)
```text
    public fun remove_issuer_from_observed_jwks(fx: &signer, issuer: vector<u8>): Option<ProviderJWKs> acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);
        let old_value = remove_issuer(&mut observed_jwks.jwks, issuer);

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();

        old_value
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L523-531)
```text
    fun regenerate_patched_jwks() acquires PatchedJWKs, Patches, ObservedJWKs {
        let jwks = borrow_global<ObservedJWKs>(@aptos_framework).jwks;
        let patches = borrow_global<Patches>(@aptos_framework);
        vector::for_each_ref(&patches.patches, |obj|{
            let patch: &Patch = obj;
            apply_patch(&mut jwks, *patch);
        });
        *borrow_global_mut<PatchedJWKs>(@aptos_framework) = PatchedJWKs { jwks };
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L177-195)
```rust
        let (jwk_manager_should_run, oidc_providers) = match jwk_consensus_config {
            Ok(config) => {
                let should_run =
                    config.jwk_consensus_enabled() && onchain_consensus_config.is_vtxn_enabled();
                let providers = config
                    .oidc_providers_cloned()
                    .into_iter()
                    .map(jwks::OIDCProvider::from)
                    .collect();
                (should_run, Some(SupportedOIDCProviders { providers }))
            },
            Err(_) => {
                //TODO: remove this case once the framework change of this commit is published.
                let should_run = features.is_enabled(FeatureFlag::JWK_CONSENSUS)
                    && onchain_consensus_config.is_vtxn_enabled();
                let providers = payload.get::<SupportedOIDCProviders>().ok();
                (should_run, providers)
            },
        };
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L59-89)
```rust
        let mut interval = tokio::time::interval(fetch_interval);
        interval.set_missed_tick_behavior(MissedTickBehavior::Delay);
        let mut close_rx = close_rx.into_stream();
        let my_addr = if cfg!(feature = "smoke-test") {
            // Include self validator address in JWK request,
            // so dummy OIDC providers in smoke tests can do things like "key A for validator 1, key B for validator 2".
            Some(my_addr)
        } else {
            None
        };

        loop {
            tokio::select! {
                _ = interval.tick().fuse() => {
                    let timer = Instant::now();
                    let result = fetch_jwks(open_id_config_url.as_str(), my_addr).await;
                    debug!(issuer = issuer, "observe_result={:?}", result);
                    let secs = timer.elapsed().as_secs_f64();
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
                    } else {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "err"]).observe(secs);
                    }
                },
                _ = close_rx.select_next_some() => {
                    break;
                }
            }
        }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L121-126)
```rust
    let jwk_move_struct = jwks.get_jwk(&pk.iss_val, &jwt_header.kid).map_err(|_| {
        invalid_signature!(format!(
            "JWK for {} with KID {} was not found",
            pk.iss_val, jwt_header.kid
        ))
    })?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L220-220)
```rust
    let patched_jwks = get_jwks_onchain(resolver)?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L237-259)
```rust
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
            // 1: If found in 0x1, then we consider that the ground truth & we are done.
            Ok(jwk) => jwk,
            // 2: If not found in 0x1, we check the Keyless PK type.
            Err(e) => {
                match pk {
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
```
