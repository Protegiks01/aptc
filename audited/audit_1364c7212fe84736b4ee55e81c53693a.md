# Audit Report

## Title
Unencrypted GRPC Connections in Remote Executor Communication Expose Transaction Data to Network Eavesdroppers

## Summary
The remote executor service uses unencrypted HTTP for GRPC communication, allowing network eavesdroppers to observe transaction contents, including user addresses, transaction payloads, signatures, and state access patterns when executor shards are deployed across separate machines.

## Finding Description

The Aptos sharded execution system supports remote executor shards through `RemoteExecutorClient`, which coordinates transaction execution across multiple machines. However, all network communication between the coordinator and remote executor shards uses **unencrypted HTTP** instead of HTTPS. [1](#0-0) 

The GRPC client connection is established using a plain HTTP URL (`format!("http://{}", remote_addr)`), with no TLS configuration applied to the tonic transport endpoint.

Similarly, the server-side implementation lacks any TLS configuration: [2](#0-1) 

This NetworkController is used by `RemoteExecutorClient` to transmit `ExecuteBlockCommand` messages containing complete transaction blocks: [3](#0-2) 

The `ExecuteBlockCommand` contains: [4](#0-3) 

These sub_blocks contain `AnalyzedTransaction` objects with full transaction details including sender addresses, payloads, signatures, gas prices, and sequence numbers - all serialized via BCS and transmitted in plaintext.

While the benchmark runner itself currently has a TODO comment indicating remote executors are not yet used: [5](#0-4) 

The `RemoteExecutorClient` is already implemented and used in production when remote addresses are configured: [6](#0-5) 

**Attack Path:**
1. Operator deploys sharded executor configuration with `remote_executor_addresses` pointing to executors on separate machines
2. Coordinator sends `ExecuteBlockCommand` via `RemoteExecutorClient`
3. NetworkController serializes transaction data using BCS
4. GRPC client sends data over HTTP (port 52200 by default) without encryption
5. Network eavesdropper on the path between coordinator and executor shard captures packets
6. Attacker deserializes BCS data to extract complete transaction contents

## Impact Explanation

This is an **information disclosure vulnerability**. According to Aptos bug bounty criteria, this falls under **Low Severity** ("Minor information leaks" - up to $1,000), though the question tags it as Medium.

**Data Exposed:**
- User account addresses (privacy violation)
- Transaction payloads revealing smart contract interactions
- Trading strategies in DeFi transactions
- Governance voting patterns before finalization
- Gas price bidding strategies
- State keys being accessed

While this doesn't directly cause loss of funds or consensus violations, it compromises transaction privacy and could enable:
- Front-running based on observed transaction patterns
- Privacy violations for users expecting transaction confidentiality
- Competitive intelligence gathering from transaction analysis

## Likelihood Explanation

**Likelihood: Medium to Low**

This vulnerability only manifests when:
1. Remote executor shards are deployed (not the default localhost configuration)
2. Network traffic between coordinator and executors traverses untrusted networks
3. Attacker has network access to intercept traffic (data center network, cloud provider network, or internet)

For production deployments within secure data centers or VPCs, the risk is lower. However, cloud deployments or geographically distributed shards would be vulnerable to:
- Malicious cloud provider employees
- Compromised network infrastructure
- Man-in-the-middle attacks on cross-datacenter links

## Recommendation

Implement TLS encryption for all remote executor communication, following the pattern already used in other Aptos GRPC services (indexer-grpc-data-service).

**Solution:**

1. Add TLS configuration to `NetworkController`:
   - Add `cert_path` and `key_path` configuration options
   - Load certificates using `tokio::fs::read()`
   - Create `tonic::transport::Identity::from_pem(cert, key)`

2. Update server initialization:
   - Configure `tonic::transport::Server::builder()` with `tls_config(ServerTlsConfig::new().identity(identity))`

3. Update client connection:
   - Change `format!("http://{}", remote_addr)` to `format!("https://{}", remote_addr)`
   - Configure client with TLS root certificates for server verification

Reference implementation pattern from indexer GRPC service: [7](#0-6) 

## Proof of Concept

**Setup:**
1. Configure two machines with remote executor deployment
2. Set remote_executor_addresses to point to remote IP

**Capture Traffic:**
```bash
# On network between coordinator and executor shard
sudo tcpdump -i eth0 -w executor_traffic.pcap port 52200

# Decode captured GRPC messages
# The NetworkMessage protobuf contains the BCS-serialized ExecuteBlockCommand
# Deserialize using aptos-core BCS library to extract transaction contents
```

**Expected Result:**
Network capture reveals complete transaction data in plaintext, including user addresses, function calls, and signatures.

## Notes

- The benchmark_runner.rs file mentioned in the question does not currently use remote executors (TODO at line 84-86 of transaction_bench_state.rs)
- However, the production RemoteExecutorClient implementation has this vulnerability and is used when remote_executor_addresses are configured
- The Aptos codebase already has TLS support in other GRPC services, so the implementation pattern exists
- Default configuration uses localhost, limiting exposure, but any distributed deployment is vulnerable
- This should be classified as Low Severity per strict bounty criteria, though it represents a significant privacy concern for production deployments with remote executors

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L75-87)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
        info!("Server shutdown at {:?}", server_addr);
```

**File:** secure/net/src/grpc_network_service/mod.rs (L124-138)
```rust
    pub fn new(rt: &Runtime, remote_addr: SocketAddr) -> Self {
        Self {
            remote_addr: remote_addr.to_string(),
            remote_channel: rt
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }

    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L180-212)
```rust
    fn execute_block(
        &self,
        state_view: Arc<S>,
        transactions: PartitionedTransactions,
        concurrency_level_per_shard: usize,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<ShardedExecutionOutput, VMStatus> {
        trace!("RemoteExecutorClient Sending block to shards");
        self.state_view_service.set_state_view(state_view);
        let (sub_blocks, global_txns) = transactions.into();
        if !global_txns.is_empty() {
            panic!("Global transactions are not supported yet");
        }
        for (shard_id, sub_blocks) in sub_blocks.into_iter().enumerate() {
            let senders = self.command_txs.clone();
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
        }

        let execution_results = self.get_output_from_shards()?;

        self.state_view_service.drop_state_view();
        Ok(ShardedExecutionOutput::new(execution_results, vec![]))
    }
```

**File:** execution/executor-service/src/lib.rs (L48-53)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExecuteBlockCommand {
    pub(crate) sub_blocks: SubBlocksForShard<AnalyzedTransaction>,
    pub(crate) concurrency_level: usize,
    pub(crate) onchain_config: BlockExecutorConfigFromOnchain,
}
```

**File:** aptos-move/aptos-transaction-benchmarks/src/transaction_bench_state.rs (L84-86)
```rust
        // TODO(skedia): add support for remote executor addresses.
        _remote_executor_addresses: Option<Vec<SocketAddr>>,
    ) -> Self {
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::service::RawDataServerWrapper;
use anyhow::{bail, Result};
use aptos_indexer_grpc_server_framework::RunnableConfig;
use aptos_indexer_grpc_utils::{
    compression_util::StorageFormat, config::IndexerGrpcFileStoreConfig,
    in_memory_cache::InMemoryCacheConfig, types::RedisUrl,
};
use aptos_protos::{
    indexer::v1::FILE_DESCRIPTOR_SET as INDEXER_V1_FILE_DESCRIPTOR_SET,
    transaction::v1::FILE_DESCRIPTOR_SET as TRANSACTION_V1_TESTING_FILE_DESCRIPTOR_SET,
    util::timestamp::FILE_DESCRIPTOR_SET as UTIL_TIMESTAMP_FILE_DESCRIPTOR_SET,
};
use aptos_transaction_filter::BooleanTransactionFilter;
use serde::{Deserialize, Serialize};
use std::{net::SocketAddr, sync::Arc};
use tonic::{codec::CompressionEncoding, transport::Server};

pub const SERVER_NAME: &str = "idxdatasvc";

// Default max response channel size.
const DEFAULT_MAX_RESPONSE_CHANNEL_SIZE: usize = 3;

// HTTP2 ping interval and timeout.
// This can help server to garbage collect dead connections.
// tonic server: https://docs.rs/tonic/latest/tonic/transport/server/struct.Server.html#method.http2_keepalive_interval
const HTTP2_PING_INTERVAL_DURATION: std::time::Duration = std::time::Duration::from_secs(60);
const HTTP2_PING_TIMEOUT_DURATION: std::time::Duration = std::time::Duration::from_secs(10);

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TlsConfig {
    /// The address for the TLS GRPC server to listen on.
    pub data_service_grpc_listen_address: SocketAddr,
    pub cert_path: String,
    pub key_path: String,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct NonTlsConfig {
    /// The address for the TLS GRPC server to listen on.
    pub data_service_grpc_listen_address: SocketAddr,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcDataServiceConfig {
```
