# Audit Report

## Title
Integer Overflow in IoPricingV4::calculate_read_gas Leading to Gas Undercharging for Large Resource Reads

## Summary
The `IoPricingV4::calculate_read_gas` function contains an integer overflow vulnerability when rounding resource sizes to page boundaries. When a resource size is near `u64::MAX`, the page-alignment calculation overflows, wrapping to a very small value and causing massive gas undercharging for storage reads.

## Finding Description

The vulnerability exists in the `IoPricingV4` pricing model's read gas calculation. [1](#0-0) 

The issue occurs in the page-rounding logic. When `loaded_u64` is in the range `[u64::MAX - 4094, u64::MAX]`, the calculation performs unchecked addition:

```
rounded_up = loaded_u64 + if r == 0 { 0 } else { PAGE_SIZE - r }
```

**Example overflow scenario:**
- If `loaded_u64 = u64::MAX` (18,446,744,073,709,551,615)
- Then `r = u64::MAX % 4096 = 4095`
- So `PAGE_SIZE - r = 4096 - 4095 = 1`
- Therefore `rounded_up = u64::MAX + 1` → **wraps to 0** in release mode

This creates a `NumBytes` with value 0, resulting in zero gas charged for reading massive resources.

**How it violates safe arithmetic:**

The `NumBytes` type uses saturating arithmetic throughout the codebase: [2](#0-1) [3](#0-2) 

However, `IoPricingV4::calculate_read_gas` extracts the raw `u64` value, performs unchecked arithmetic, and creates a new `NumBytes` from the overflowed result, bypassing the type's safety guarantees.

**Attack flow:**
1. Attacker stores a resource of size ≥ `u64::MAX - 4094` bytes on-chain
2. When loading this resource, `bytes_loaded` is reported as the actual size
3. Gas meter calls `calculate_read_gas(bytes_loaded)`
4. Page rounding calculation overflows to 0 or small value
5. Gas charged is `STORAGE_IO_PER_STATE_SLOT_READ + (STORAGE_IO_PER_STATE_BYTE_READ * 0)` ≈ minimal cost
6. Attacker loads massive resources for nearly free, enabling DoS or resource exhaustion

## Impact Explanation

**Theoretical Impact:** High severity

This breaks the **Resource Limits invariant** - "All operations must respect gas, storage, and computational limits." Successful exploitation would enable:

1. **Gas undercharging:** Loading gigantic resources for minimal gas
2. **Node resource exhaustion:** Force nodes to deserialize massive resources while paying minimal gas
3. **Consensus impact:** If different nodes handle overflow differently (debug vs release builds), could cause state divergence

**Practical Constraints:**

However, current write limits significantly reduce exploitability: [4](#0-3) 

The `max_bytes_per_write_op` is typically 1 MB (1,048,576 bytes), preventing storage of resources large enough to trigger the overflow (which requires ≥ 18,446,744,073,709,547,521 bytes). [5](#0-4) 

Write limits were introduced at feature_version 3, while `IoPricingV4` is only used for feature_version ≥ 12: [6](#0-5) 

## Likelihood Explanation

**Likelihood: Very Low**

Exploitation requires:
1. A resource of size ≥ `u64::MAX - 4094` bytes stored on-chain
2. Current write limits (1 MB) make this impossible
3. No evidence of historical unlimited-size resources existing on mainnet

The vulnerability represents a **defense-in-depth failure** rather than a realistic exploit path. It could only be triggered by:
- Storage layer bugs returning incorrect `bytes_loaded` values
- Corrupted storage data
- Hypothetical future changes removing write limits

## Recommendation

Replace unchecked arithmetic with saturating operations to maintain consistency with `NumBytes` design:

```rust
fn calculate_read_gas(
    &self,
    loaded: NumBytes,
) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
    const PAGE_SIZE: u64 = 4096;

    let loaded_u64: u64 = loaded.into();
    let r = loaded_u64 % PAGE_SIZE;
    
    // Use saturating_add to prevent overflow
    let rounded_up = loaded_u64.saturating_add(
        if r == 0 { 0 } else { PAGE_SIZE - r }
    );

    STORAGE_IO_PER_STATE_SLOT_READ * NumArgs::from(1)
        + STORAGE_IO_PER_STATE_BYTE_READ * NumBytes::new(rounded_up)
}
```

Alternatively, add defensive validation:
```rust
// Validate bytes_loaded is within reasonable bounds
const MAX_REASONABLE_RESOURCE_SIZE: u64 = 10 * 1024 * 1024; // 10 MB
if loaded_u64 > MAX_REASONABLE_RESOURCE_SIZE {
    return Err(/* appropriate error */);
}
```

## Proof of Concept

Due to write limits preventing storage of sufficiently large resources, a realistic end-to-end PoC cannot be created. However, the overflow can be demonstrated via unit test:

```rust
#[test]
fn test_calculate_read_gas_overflow() {
    use aptos_move_vm_types::storage::io_pricing::IoPricingV4;
    use move_core_types::gas_algebra::NumBytes;
    
    let pricing = IoPricingV4;
    
    // Test with value that causes overflow
    let large_bytes = NumBytes::new(u64::MAX - 4094);
    let gas = pricing.calculate_read_gas(large_bytes);
    
    // In release mode, this would wrap to a very small value
    // Expected: massive gas charge
    // Actual: minimal gas charge due to overflow
    
    println!("Gas charged for u64::MAX - 4094 bytes: {:?}", gas);
    // This demonstrates the overflow, though not a realistic exploit
}
```

**Notes:**

This is a **code quality and defensive programming issue** rather than an immediately exploitable vulnerability. While the overflow is real and violates safe arithmetic principles, practical write limits prevent exploitation. The issue should be fixed to maintain defense-in-depth and code consistency, but does not represent an active security threat under current constraints.

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L204-218)
```rust
    fn calculate_read_gas(
        &self,
        loaded: NumBytes,
    ) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
        // Round up bytes to whole pages
        // TODO(gas): make PAGE_SIZE configurable
        const PAGE_SIZE: u64 = 4096;

        let loaded_u64: u64 = loaded.into();
        let r = loaded_u64 % PAGE_SIZE;
        let rounded_up = loaded_u64 + if r == 0 { 0 } else { PAGE_SIZE - r };

        STORAGE_IO_PER_STATE_SLOT_READ * NumArgs::from(1)
            + STORAGE_IO_PER_STATE_BYTE_READ * NumBytes::new(rounded_up)
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L264-265)
```rust
            12.. => V4(IoPricingV4),
        }
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L205-211)
```rust
impl<U> Add<GasQuantity<U>> for GasQuantity<U> {
    type Output = Self;

    fn add(self, rhs: Self) -> Self::Output {
        Self::new(self.val.saturating_add(rhs.val))
    }
}
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L229-231)
```rust
fn mul_impl<U1, U2>(x: GasQuantity<U2>, y: GasQuantity<UnitDiv<U1, U2>>) -> GasQuantity<U1> {
    GasQuantity::new(x.val.saturating_mul(y.val))
}
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L68-72)
```rust
    fn for_feature_version_3() -> Self {
        const MB: u64 = 1 << 20;

        Self::new_impl(3, MB, u64::MAX, MB, 10 * MB, u64::MAX)
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L103-108)
```rust
            if let Some(len) = op_size.write_len() {
                let write_op_size = len + (key.size() as u64);
                if write_op_size > self.max_bytes_per_write_op {
                    return storage_write_limit_reached(None);
                }
                write_set_size += write_op_size;
```
