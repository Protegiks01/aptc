# Audit Report

## Title
Genesis Consensus Configuration Injection via Unvalidated Layout File

## Summary
`Layout::from_disk()` performs YAML deserialization without validating the internal structure of `OnChainConsensusConfig` and `OnChainExecutionConfig` fields. An attacker can inject malicious consensus parameters (e.g., all validator weights set to 0) that cause immediate consensus failure when genesis is generated and the blockchain attempts to start. [1](#0-0) 

## Finding Description

The `SetupGit::execute()` function loads a layout file using `Layout::from_disk()` and immediately stores it to git storage without any validation beyond YAML deserialization: [2](#0-1) 

While `validate_genesis_config()` validates basic genesis parameters (epoch_duration_secs, min_stake, max_stake, etc.), it does NOT validate the internal fields of `OnChainConsensusConfig`: [3](#0-2) 

This allows an attacker to inject malicious `ProposerAndVoterConfig` values that will break consensus: [4](#0-3) 

**Attack Scenario:**

1. Attacker creates a malicious `layout.yaml` with `OnChainConsensusConfig` containing:
   - `active_weight: 0`
   - `inactive_weight: 0` 
   - `failed_weight: 0`
   - `proposer_window_num_validators_multiplier: 0`
   - `voter_window_num_validators_multiplier: 0`

2. Attacker runs: `aptos genesis setup-git --layout-file malicious.yaml`

3. The layout is stored without validation

4. Genesis is later generated using this layout via `fetch_genesis_info()`: [5](#0-4) 

5. When the blockchain starts and attempts proposer election, `choose_index()` is called with all zero weights: [6](#0-5) 

6. At line 54-58, `total_weight` accumulates to 0. At line 59, `next_in_range(state, 0)` causes **division by zero** (line 45: `u128::from_le_bytes(temp) % 0`), causing the node to **panic** and halt consensus.

Additionally, with `window_num_validators_multiplier: 0`, the reputation window size becomes 0: [7](#0-6) 

This eliminates all reputation history, degrading proposer election quality even if the division by zero were somehow avoided.

## Impact Explanation

**Severity: High** (Significant Protocol Violations per Aptos Bug Bounty)

This vulnerability enables complete consensus failure from genesis through:

1. **Total Loss of Liveness**: Division by zero in proposer election causes node panic, preventing any block production
2. **Consensus Protocol Violation**: Zero weights violate the fundamental assumption that validators have non-zero selection probability
3. **Broken Deterministic Execution**: Different nodes may handle the panic differently during startup
4. **Requires Hardfork Recovery**: Once genesis is deployed with corrupted config, a new genesis must be generated

While mainnet genesis uses hardcoded configurations and wouldn't be affected, this impacts:
- **Testnets and Devnets**: Where setup-git workflow is commonly used
- **Private Networks**: Organizations deploying Aptos-based chains
- **Development Environments**: Forge tests and local networks

The attack requires no privileged accessâ€”only the ability to provide a layout file during genesis setup.

## Likelihood Explanation

**Likelihood: Medium-High**

- **Attack Complexity: Low** - Creating malicious YAML is trivial
- **Attacker Requirements: None** - No privileged access needed, just ability to run genesis setup
- **Detection: Difficult** - The corrupted config is syntactically valid YAML and passes deserialization
- **Impact Scope**: Any network using the setup-git workflow for genesis is vulnerable

The vulnerability is particularly likely to be exploited in:
- Compromised CI/CD pipelines generating genesis
- Social engineering attacks where malicious layout files are distributed
- Insider threats in organizations deploying private Aptos networks

## Recommendation

Add comprehensive validation for `OnChainConsensusConfig` and `OnChainExecutionConfig` in `Layout::from_disk()` or in a separate validation function called by `SetupGit::execute()`:

```rust
impl Layout {
    pub fn from_disk(path: &Path) -> anyhow::Result<Self> {
        let mut file = File::open(path).map_err(|e| {
            anyhow::Error::msg(format!("Failed to open file {}, {}", path.display(), e))
        })?;
        let mut contents = String::new();
        file.read_to_string(&mut contents).map_err(|e| {
            anyhow::Error::msg(format!("Failed to read file {}, {}", path.display(), e))
        })?;

        let layout: Layout = serde_yaml::from_str(&contents)?;
        layout.validate()?; // ADD VALIDATION HERE
        Ok(layout)
    }

    fn validate(&self) -> anyhow::Result<()> {
        // Validate consensus config
        match &self.on_chain_consensus_config {
            OnChainConsensusConfig::V5 { alg, .. } => {
                if let ConsensusAlgorithmConfig::JolteonV2 { main, .. } = alg {
                    if let ProposerElectionType::LeaderReputation(rep_type) = &main.proposer_election_type {
                        if let LeaderReputationType::ProposerAndVoterV2(config) = rep_type {
                            ensure!(
                                config.active_weight > 0 || config.inactive_weight > 0 || config.failed_weight > 0,
                                "At least one validator weight must be non-zero"
                            );
                            ensure!(
                                config.proposer_window_num_validators_multiplier > 0,
                                "proposer_window_num_validators_multiplier must be > 0"
                            );
                            ensure!(
                                config.voter_window_num_validators_multiplier > 0,
                                "voter_window_num_validators_multiplier must be > 0"
                            );
                            ensure!(
                                config.failure_threshold_percent <= 100,
                                "failure_threshold_percent must be <= 100"
                            );
                        }
                    }
                }
            },
            _ => {}
        }
        
        // Validate other fields...
        Ok(())
    }
}
```

Alternatively, extend `validate_genesis_config()` to validate these fields before genesis generation.

## Proof of Concept

Create a malicious `layout.yaml`:

```yaml
root_key: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
users: ["alice"]
chain_id: 4
allow_new_validators: false
epoch_duration_secs: 7200
is_test: true
min_stake: 100000000000000
min_voting_threshold: 100000000000000
max_stake: 100000000000000000
recurring_lockup_duration_secs: 86400
required_proposer_stake: 100000000000000
rewards_apy_percentage: 10
voting_duration_secs: 43200
voting_power_increase_limit: 20
on_chain_consensus_config:
  V5:
    alg:
      JolteonV2:
        main:
          decoupled_execution: true
          back_pressure_limit: 10
          exclude_round: 40
          max_failed_authors_to_store: 10
          proposer_election_type:
            LeaderReputation:
              ProposerAndVoterV2:
                active_weight: 0
                inactive_weight: 0
                failed_weight: 0
                failure_threshold_percent: 10
                proposer_window_num_validators_multiplier: 0
                voter_window_num_validators_multiplier: 0
                weight_by_voting_power: false
                use_history_from_previous_epoch_max_count: 0
        quorum_store_enabled: true
        order_vote_enabled: true
    vtxn:
      V1:
        per_block_limit_txn_count: 2
        per_block_limit_total_bytes: 2097152
    window_size: null
    rand_check_enabled: true
```

Run:
```bash
aptos genesis setup-git --layout-file malicious.yaml --local-repository-dir ./genesis-data
```

The layout will be accepted and stored. When genesis is generated and nodes attempt to start, they will panic during proposer election due to division by zero with total_weight = 0.

**Expected Result**: Node panic in `choose_index()` when attempting first proposer election, halting consensus completely.

### Citations

**File:** crates/aptos-genesis/src/config.rs (L94-104)
```rust
    pub fn from_disk(path: &Path) -> anyhow::Result<Self> {
        let mut file = File::open(path).map_err(|e| {
            anyhow::Error::msg(format!("Failed to open file {}, {}", path.display(), e))
        })?;
        let mut contents = String::new();
        file.read_to_string(&mut contents).map_err(|e| {
            anyhow::Error::msg(format!("Failed to read file {}, {}", path.display(), e))
        })?;

        Ok(serde_yaml::from_str(&contents)?)
    }
```

**File:** crates/aptos/src/genesis/git.rs (L53-61)
```rust
    async fn execute(self) -> CliTypedResult<()> {
        let layout = Layout::from_disk(&self.layout_file)?;

        // Upload layout file to ensure we can read later
        let client = self.git_options.get_client()?;
        client.put(Path::new(LAYOUT_FILE), &layout)?;

        Ok(())
    }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L405-439)
```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    assert!(
        genesis_config.min_stake <= genesis_config.max_stake,
        "Min stake must be smaller than or equal to max stake"
    );
    assert!(
        genesis_config.epoch_duration_secs > 0,
        "Epoch duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs > 0,
        "Recurring lockup duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs >= genesis_config.epoch_duration_secs,
        "Recurring lockup duration must be at least as long as epoch duration"
    );
    assert!(
        genesis_config.rewards_apy_percentage > 0 && genesis_config.rewards_apy_percentage < 100,
        "Rewards APY must be > 0% and < 100%"
    );
    assert!(
        genesis_config.voting_duration_secs > 0,
        "On-chain voting duration must be > 0"
    );
    assert!(
        genesis_config.voting_duration_secs < genesis_config.recurring_lockup_duration_secs,
        "Voting duration must be strictly smaller than recurring lockup"
    );
    assert!(
        genesis_config.voting_power_increase_limit > 0
            && genesis_config.voting_power_increase_limit <= 50,
        "voting_power_increase_limit must be > 0 and <= 50"
    );
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L552-575)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ProposerAndVoterConfig {
    // Selection weight for active validators with proposer failures below threshold
    pub active_weight: u64,
    // Selection weight for inactive validators with proposer failures below threshold
    pub inactive_weight: u64,
    // Selection weight for validators with proposer failures above threshold
    pub failed_weight: u64,
    // Thresholed of failures in the rounds validator was selected to be proposer
    // integer values representing percentages, i.e. 12 is 12%.
    pub failure_threshold_percent: u32,
    // Window into history considered for proposer statistics, multiplier
    // on top of number of validators
    pub proposer_window_num_validators_multiplier: usize,
    // Window into history considered for votre statistics, multiplier
    // on top of number of validators
    pub voter_window_num_validators_multiplier: usize,
    // Flag whether to use voting power as multiplier to the weights
    pub weight_by_voting_power: bool,
    // Flag whether to use history from previous epoch (0 if not),
    // representing a number of historical epochs (beyond the current one)
    // to consider.
    pub use_history_from_previous_epoch_max_count: u32,
}
```

**File:** crates/aptos/src/genesis/mod.rs (L288-311)
```rust
        &GenesisConfiguration {
            allow_new_validators: layout.allow_new_validators,
            epoch_duration_secs: layout.epoch_duration_secs,
            is_test: layout.is_test,
            min_stake: layout.min_stake,
            min_voting_threshold: layout.min_voting_threshold,
            max_stake: layout.max_stake,
            recurring_lockup_duration_secs: layout.recurring_lockup_duration_secs,
            required_proposer_stake: layout.required_proposer_stake,
            rewards_apy_percentage: layout.rewards_apy_percentage,
            voting_duration_secs: layout.voting_duration_secs,
            voting_power_increase_limit: layout.voting_power_increase_limit,
            employee_vesting_start: layout.employee_vesting_start,
            employee_vesting_period_duration: layout.employee_vesting_period_duration,
            consensus_config: layout.on_chain_consensus_config,
            execution_config: layout.on_chain_execution_config,
            gas_schedule: default_gas_schedule(),
            initial_features_override: None,
            randomness_config_override: None,
            jwk_consensus_config_override: layout.jwk_consensus_config_override.clone(),
            initial_jwks: layout.initial_jwks.clone(),
            keyless_groth16_vk: layout.keyless_groth16_vk_override.clone(),
        },
    )?)
```

**File:** consensus/src/liveness/proposer_election.rs (L49-69)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
    weights
        .binary_search_by(|w| {
            if *w <= chosen_weight {
                Ordering::Less
            } else {
                Ordering::Greater
            }
        })
        .expect_err("Comparison never returns equals, so it's always guaranteed to be error")
}
```

**File:** consensus/src/epoch_manager.rs (L314-331)
```rust
                        let proposer_window_size = proposers.len()
                            * proposer_and_voter_config.proposer_window_num_validators_multiplier;
                        let voter_window_size = proposers.len()
                            * proposer_and_voter_config.voter_window_num_validators_multiplier;
                        let heuristic: Box<dyn ReputationHeuristic> =
                            Box::new(ProposerAndVoterHeuristic::new(
                                self.author,
                                proposer_and_voter_config.active_weight,
                                proposer_and_voter_config.inactive_weight,
                                proposer_and_voter_config.failed_weight,
                                proposer_and_voter_config.failure_threshold_percent,
                                voter_window_size,
                                proposer_window_size,
                                leader_reputation_type.use_reputation_window_from_stale_end(),
                            ));
                        (
                            heuristic,
                            std::cmp::max(proposer_window_size, voter_window_size),
```
