# Audit Report

## Title
Indexer Denial of Service via UTF-8 Character Boundary Panic in Coin Symbol Truncation

## Summary
The `truncate_str()` utility function in the Aptos indexer does not safely handle multi-byte UTF-8 characters during truncation. When processing coin metadata with symbols exceeding 10 bytes, the indexer will panic if the truncation point falls within a multi-byte character sequence, causing a Denial of Service.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Move Framework Validation**: The Move coin framework validates coin symbols to be at most 32 bytes. [1](#0-0) 

The validation occurs during coin initialization: [2](#0-1) 

2. **Database Schema Constraint**: The indexer database schema restricts the symbol column to only 10 bytes: [3](#0-2) 

3. **Unsafe Truncation Implementation**: The `truncate_str()` function uses Rust's `String::truncate()` which operates on byte positions without checking character boundaries: [4](#0-3) 

The function is called when processing coin info: [5](#0-4) [6](#0-5) 

**Attack Path:**
1. Attacker deploys a coin with symbol "å¸å¸å¸ğŸ‰" (13 bytes: 9 bytes of Chinese characters + 4-byte emoji)
2. Move validation passes because 13 â‰¤ 32 bytes
3. Coin creation transaction is executed and committed to blockchain
4. Indexer processes the transaction and attempts to store coin info
5. `get_symbol_trunc()` calls `truncate_str(&"å¸å¸å¸ğŸ‰", 10)`
6. `String::truncate(10)` attempts to truncate at byte 10, which falls inside the 4-byte emoji (bytes 9-12)
7. Rust's `String::truncate()` panics per its documented behavior when truncation point is not on a character boundary
8. Indexer thread crashes

The Move string implementation confirms that `string::length()` returns byte length, not character count: [7](#0-6) 

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This vulnerability causes:
- **Indexer Crash/DoS**: Any coin created with a carefully crafted symbol will cause the indexer to panic and crash when processing that transaction
- **Blockchain Observability Loss**: Indexers provide critical infrastructure for wallets, explorers, and dApps to query blockchain state. A crash prevents processing of all subsequent transactions
- **Service Disruption**: Indexer operators must manually intervene to skip the problematic transaction or fix the code

This qualifies as "API crashes" and "significant protocol violations" under High Severity criteria. While it doesn't directly affect consensus or validator nodes, it disrupts critical infrastructure relied upon by the entire ecosystem.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Only requires ability to deploy a coin with a specific symbol (publicly available functionality)
- **Complexity**: Trivial - attacker simply needs to choose a symbol with multi-byte characters at the right position
- **Cost**: Only gas fees for coin deployment
- **Detectability**: The vulnerability is in production code and affects any indexer processing the malicious transaction
- **Persistence**: Once created, the malicious coin permanently exists on-chain, causing repeated crashes for any indexer that attempts to process it

The mismatch between Move validation (32 bytes) and database schema (10 bytes) makes this exploit straightforward and deterministic.

## Recommendation

Replace the `truncate_str()` function with a UTF-8-aware implementation that truncates at the nearest character boundary:

```rust
pub fn truncate_str(val: &str, max_bytes: usize) -> String {
    let mut trunc = val.to_string();
    if trunc.len() > max_bytes {
        // Find the last valid character boundary at or before max_bytes
        let mut idx = max_bytes;
        while idx > 0 && !trunc.is_char_boundary(idx) {
            idx -= 1;
        }
        trunc.truncate(idx);
    }
    trunc
}
```

Additionally, consider aligning the database schema with Move validation limits or adding explicit validation warnings when truncation will occur.

## Proof of Concept

**Rust Test Case:**
```rust
#[test]
#[should_panic(expected = "not a char boundary")]
fn test_truncate_str_panics_on_multibyte_character() {
    use crate::util::truncate_str;
    
    // Create a symbol with Chinese characters and emoji
    // "å¸å¸å¸ğŸ‰" = 9 bytes (3 chars Ã— 3 bytes) + 4 bytes (emoji) = 13 bytes
    // The emoji starts at byte 9 and ends at byte 12
    let symbol = "å¸å¸å¸ğŸ‰";
    
    assert_eq!(symbol.len(), 13); // Verify byte length
    
    // This will panic because byte 10 is in the middle of the ğŸ‰ emoji
    let _ = truncate_str(symbol, 10);
}
```

**Move Deployment Script:**
```move
script {
    use aptos_framework::coin;
    use std::string;
    
    fun create_malicious_coin<CoinType>(account: &signer) {
        // Symbol: "å¸å¸å¸ğŸ‰" (13 bytes)
        let name = string::utf8(b"Test Coin");
        let symbol = string::utf8(b"\xE5\xB8\x81\xE5\xB8\x81\xE5\xB8\x81\xF0\x9F\x8E\x89");
        
        // This passes Move validation (13 <= 32)
        coin::initialize<CoinType>(
            account,
            name,
            symbol,
            8, // decimals
            true // monitor_supply
        );
        // When the indexer processes this, it will panic
    }
}
```

## Notes

While the security question asked whether truncation "causes invalid UTF-8 that violates database encoding constraints," the actual behavior is more severe: Rust's `String::truncate()` **panics** before any invalid UTF-8 can be created or inserted into the database. This is a fail-fast safety mechanism in Rust, but it transforms what could have been a data integrity issue into a Denial of Service vulnerability.

The same fundamental flaw exists for other fields using `truncate_str()`, though the symbol field presents the highest risk due to the large mismatch between Move validation (32 bytes) and database storage (10 bytes).

### Citations

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L126-126)
```text
    const MAX_COIN_SYMBOL_LENGTH: u64 = 32;
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1074-1077)
```text
        assert!(
            string::length(&symbol) <= MAX_COIN_SYMBOL_LENGTH,
            error::invalid_argument(ECOIN_SYMBOL_TOO_LONG)
        );
```

**File:** crates/indexer/src/schema.rs (L83-84)
```rust
        #[max_length = 10]
        symbol -> Varchar,
```

**File:** crates/indexer/src/util.rs (L23-27)
```rust
pub fn truncate_str(val: &str, max_chars: usize) -> String {
    let mut trunc = val.to_string();
    trunc.truncate(max_chars);
    trunc
}
```

**File:** crates/indexer/src/models/coin_models/coin_utils.rs (L34-36)
```rust
    pub fn get_symbol_trunc(&self) -> String {
        truncate_str(&self.symbol, 10)
    }
```

**File:** crates/indexer/src/models/coin_models/coin_infos.rs (L71-72)
```rust
                    name: inner.get_name_trunc(),
                    symbol: inner.get_symbol_trunc(),
```

**File:** aptos-move/framework/move-stdlib/sources/string.move (L47-50)
```text
    /// Returns the length of this string, in bytes.
    public fun length(self: &String): u64 {
        self.bytes.length()
    }
```
