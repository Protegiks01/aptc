# Audit Report

## Title
State Value Deletion Bug in Truncation Logic Using Wrong Version Field

## Summary
The `delete_state_value_and_index()` function in the storage layer uses the incorrect field (`stale_since_version` instead of `version`) when deleting state values during database truncation operations, leading to storage corruption and operational failures requiring manual intervention.

## Finding Description

The `delete_state_value_and_index()` function in `truncation_helper.rs` is responsible for cleaning up stale state values during truncation operations. The function incorrectly uses `index.stale_since_version` when it should use `index.version` to identify which state values to delete. [1](#0-0) [2](#0-1) 

The `StaleStateValueIndex` structure contains two distinct version fields with different semantic meanings: [3](#0-2) 

- `stale_since_version`: The version when the value became stale (was overwritten)
- `version`: The version when the stale value was originally written

The pruner code demonstrates the correct pattern by using `index.version`: [4](#0-3) [5](#0-4) 

**Execution Path:**

The bug is triggered when `sync_commit_progress()` is called during crash recovery or database synchronization: [6](#0-5) 

This calls `truncate_state_kv_db()`, which eventually invokes `delete_state_value_and_index()` with incorrect field usage: [7](#0-6) 

**How the bug manifests:**

When truncating, the function seeks stale indices where `stale_since_version >= start_version` and for each index `{stale_since_version: S, version: V, state_key_hash: H}`:
- It attempts to delete `StateValue[(H, S)]` ❌ WRONG
- It should delete `StateValue[(H, V)]` ✅ CORRECT

This causes:
1. The actual stale value at `(H, V)` is never deleted (storage leak)
2. If a value exists at `(H, S)`, it gets incorrectly deleted (data corruption)

## Impact Explanation

**Severity: Medium** (State inconsistencies requiring manual intervention per Aptos Bug Bounty categories)

The bug causes storage-level corruption affecting node operational reliability:

1. **Storage Leak**: Stale values that should be deleted accumulate in the database, causing storage bloat over time

2. **Incorrect Deletion**: State values at the wrong version numbers may be deleted, potentially including valid or current state values

3. **Operational Failure**: After incorrect truncation, the affected node may experience:
   - Database inconsistency errors during state reads
   - Sync failures when attempting to recover
   - Inability to properly participate in consensus
   - Requirement for manual intervention to repair database

This is a local node reliability issue rather than a network-wide consensus vulnerability. It does not directly enable fund theft or consensus breaks, but requires manual intervention to resolve, fitting the MEDIUM severity category.

## Likelihood Explanation

**Likelihood: Medium-High**

The bug triggers during operational scenarios that occur regularly in production:

1. **Crash Recovery**: When a node restarts after an unclean shutdown and needs to reconcile database state
2. **State Synchronization**: When commit progress levels differ between database components
3. **Database Reconciliation**: Whenever `sync_commit_progress()` is invoked [8](#0-7) 

These conditions occur during normal node operations, particularly after crashes or during state sync, making this a realistic and repeatable scenario.

## Recommendation

Change the `delete_state_value_and_index()` function to use `index.version` instead of `index.stale_since_version` when deleting state values, matching the pattern used in the pruner code:

**For sharded version (lines 564-567):**
```rust
batch.delete::<StateValueByKeyHashSchema>(&(
    index.state_key_hash,
    index.version,  // Changed from index.stale_since_version
))?;
```

**For non-sharded version (line 576):**
```rust
batch.delete::<StateValueSchema>(&(index.state_key, index.version))?;  // Changed from index.stale_since_version
```

## Proof of Concept

While a complete end-to-end PoC would require setting up a node, triggering a crash, and observing truncation behavior, the bug can be demonstrated through code analysis:

1. The stale index schema documentation confirms the semantic difference between the two version fields
2. The pruner implementations demonstrate the correct pattern
3. The truncation helper uses the wrong field, creating a discrepancy
4. This discrepancy will manifest during any truncation operation when stale indices exist

The bug is deterministic and will execute every time truncation is performed with stale state indices present in the database.

## Notes

This vulnerability represents a database integrity issue that affects node operational reliability rather than a direct consensus or fund theft vulnerability. The impact is limited to individual nodes requiring manual intervention for database repair, not network-wide state corruption. The bug breaks storage consistency guarantees but does not compromise consensus safety or enable direct attacks on the protocol.

### Citations

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L135-140)
```rust
    delete_state_value_and_index(
        state_kv_db.db_shard(shard_id),
        target_version + 1,
        &mut batch,
        state_kv_db.enabled_sharding(),
    )?;
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L564-567)
```rust
            batch.delete::<StateValueByKeyHashSchema>(&(
                index.state_key_hash,
                index.stale_since_version,
            ))?;
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L576-576)
```rust
            batch.delete::<StateValueSchema>(&(index.state_key, index.stale_since_version))?;
```

**File:** types/src/state_store/state_value.rs (L366-376)
```rust
/// Indicates a state value becomes stale since `stale_since_version`.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
pub struct StaleStateValueIndex {
    /// The version since when the node is overwritten and becomes stale.
    pub stale_since_version: Version,
    /// The version identifying the value associated with this record.
    pub version: Version,
    /// The `StateKey` identifying the value associated with this record.
    pub state_key: StateKey,
}
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_metadata_pruner.rs (L63-63)
```rust
                batch.delete::<StateValueSchema>(&(index.state_key, index.version))?;
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs (L64-64)
```rust
            batch.delete::<StateValueByKeyHashSchema>(&(index.state_key_hash, index.version))?;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L430-436)
```rust
            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);
```

**File:** storage/aptosdb/src/state_store/mod.rs (L461-467)
```rust
            truncate_state_kv_db(
                &state_kv_db,
                state_kv_commit_progress,
                overall_commit_progress,
                std::cmp::max(difference as usize, 1), /* batch_size */
            )
            .expect("Failed to truncate state K/V db.");
```
