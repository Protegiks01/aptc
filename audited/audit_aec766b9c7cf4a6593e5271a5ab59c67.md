# Audit Report

## Title
Missing Encryption Key Validation in Batch Encrypted Transactions Allows DoS via Undecryptable Ciphertexts

## Summary
The `bibe_encrypt()` function accepts arbitrary `EncryptionKey` values without cryptographic binding to the legitimate system key. The ciphertext verification process fails to validate that ciphertexts were encrypted under the authorized encryption key, allowing attackers to submit transactions encrypted with malicious keys that pass validation but fail decryption, causing resource exhaustion and transaction processing failures.

## Finding Description

The BIBE (Batch Identity-Based Encryption) system establishes a legitimate `EncryptionKey` during validator setup via DKG/PVSS. [1](#0-0) 

However, the `EncryptionKey` struct exposes its cryptographic parameters as serializable fields without cryptographic binding. [2](#0-1) 

When encrypting, the `bibe_encrypt()` function directly uses `self.sig_mpk_g2` and `self.tau_g2` from any provided `EncryptionKey` without validation. [3](#0-2) 

**Critical Gap**: The ciphertext verification only validates the Ed25519 signature, ID binding, and associated data - it does NOT verify the ciphertext was encrypted under the legitimate system encryption key. [4](#0-3) 

When encrypted transactions are submitted via API, they only undergo this insufficient verification. [5](#0-4) 

During consensus decryption, validators attempt to decrypt using legitimate keys derived from the system's master public key, but ciphertexts encrypted under different keys fail decryption. [6](#0-5) 

**Attack Path**:
1. Attacker constructs malicious `EncryptionKey{sig_mpk_g2: G2_ATTACKER, tau_g2: TAU_ATTACKER}`
2. Encrypts transaction payload using this key via `bibe_encrypt()`
3. Submits encrypted transaction through API - passes all validation checks
4. Transaction enters mempool and gets included in consensus blocks
5. All validators attempt decryption with legitimate keys - universally fails
6. Transaction marked as `FailedDecryption`, wasting validator CPU cycles

**Invariant Violation**: The system violates the Transaction Validation invariant by accepting encrypted transactions without verifying cryptographic consistency with the established encryption infrastructure.

## Impact Explanation

**Severity: Medium** (per Aptos bug bounty criteria)

This constitutes a **validation bypass** enabling:

1. **Resource Exhaustion**: Attackers can submit unlimited undecryptable ciphertexts that consume validator CPU during pairing computations and decryption attempts
2. **Transaction Processing Disruption**: Failed decryptions waste block space and processing capacity
3. **Potential State Inconsistencies**: If validators implement different failure handling logic, this could cause state divergence

While this does not directly cause fund loss or consensus safety violations (validators deterministically fail to decrypt the same ciphertexts), it represents a **significant protocol violation** allowing availability degradation.

The issue does NOT cause "misdirected decryption" where decryption succeeds with wrong results - instead, decryption fails deterministically across all validators. However, the validation bypass itself is the core vulnerability.

## Likelihood Explanation

**Likelihood: High**

This attack is trivially executable:
- No special privileges required (any transaction sender)
- Malicious `EncryptionKey` construction is straightforward serialization
- No cryptographic knowledge needed (attacker doesn't need to break any crypto)
- API endpoints accept these transactions without additional checks
- Attack cost is only transaction submission fees

The absence of encryption key validation is a systematic design gap affecting all encrypted transaction flows.

## Recommendation

Implement cryptographic binding between ciphertexts and the legitimate encryption key. Add verification that compares the encryption key used against the system's established key before accepting ciphertexts:

```rust
// In Ciphertext::verify() or EncryptedPayload::verify()
pub fn verify(&self, associated_data: &impl AssociatedData, 
              expected_encryption_key: &EncryptionKey) -> Result<()> {
    // Existing signature and ID checks...
    
    // NEW: Verify ciphertext was encrypted under expected key
    // Option 1: Include encryption key commitment in ciphertext
    // Option 2: Verify pairing equation consistency
    // Option 3: Require encryption key signature over ciphertext
    
    let hashed_id = Id::from_verifying_key(&self.vk);
    (self.bibe_ct.id() == hashed_id).then_some(()).ok_or(...)?;
    
    // Verify encryption key binding (implementation depends on chosen approach)
    verify_encryption_key_binding(&self.bibe_ct, expected_encryption_key)?;
    
    // Existing signature verification...
}
```

The system encryption key should be retrieved from consensus state and passed to verification functions at transaction submission and block validation points.

## Proof of Concept

```rust
// Rust PoC demonstrating the vulnerability

use aptos_batch_encryption::{
    group::G2Affine,
    shared::{encryption_key::EncryptionKey, ciphertext::CTEncrypt},
};
use ark_ec::AffineRepr;
use ark_std::rand::thread_rng;

fn main() {
    let mut rng = thread_rng();
    
    // Legitimate system encryption key (established via DKG)
    let legitimate_ek = EncryptionKey::new(
        G2Affine::generator(), // sig_mpk_g2 from PVSS
        G2Affine::generator(), // tau_g2 from digest key
    );
    
    // ATTACK: Attacker creates malicious encryption key with different values
    let malicious_ek = EncryptionKey::new(
        (G2Affine::generator() * 999u64).into(), // Different sig_mpk_g2
        (G2Affine::generator() * 777u64).into(), // Different tau_g2
    );
    
    // Encrypt transaction with malicious key
    let plaintext = String::from("malicious payload");
    let associated_data = String::from("sender_data");
    
    let malicious_ct = malicious_ek
        .encrypt(&mut rng, &plaintext, &associated_data)
        .expect("Encryption succeeds with malicious key");
    
    // VULNERABILITY: This ciphertext passes verification
    // because verify() only checks signature, not encryption key
    assert!(malicious_ct.verify(&associated_data).is_ok());
    
    // But validators cannot decrypt it with legitimate keys
    // Decryption fails, wasting validator resources
    
    println!("Malicious ciphertext passed verification!");
    println!("Validators will waste CPU attempting to decrypt this");
}
```

**Notes**

The vulnerability exists because the BIBE encryption scheme lacks cryptographic binding between ciphertexts and the authorized encryption key. While the system includes `verify_decryption_key()` methods, these are only used post-decryption for key validation, not during ciphertext acceptance. The missing validation at transaction submission/verification allows injection of undecryptable ciphertexts that deterministically fail processing across all validators, enabling targeted DoS attacks against the encrypted transaction infrastructure.

### Citations

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L241-243)
```rust
        let mpk_g2: G2Affine = subtranscript.get_dealt_public_key().as_g2();

        let ek = EncryptionKey::new(mpk_g2, digest_key.tau_g2);
```

**File:** crates/aptos-batch-encryption/src/shared/encryption_key.rs (L14-20)
```rust
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct EncryptionKey {
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    pub(crate) sig_mpk_g2: G2Affine,
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    pub(crate) tau_g2: G2Affine,
}
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L119-132)
```rust
    fn bibe_encrypt<R: RngCore + CryptoRng>(
        &self,
        rng: &mut R,
        plaintext: &impl Plaintext,
        id: Id,
    ) -> Result<BIBECiphertext> {
        let r = [Fr::rand(rng), Fr::rand(rng)];
        let hashed_encryption_key: G1Affine = symmetric::hash_g2_element(self.sig_mpk_g2)?;

        let ct_g2 = [
            (G2Affine::generator() * r[0] + self.sig_mpk_g2 * r[1]).into(),
            ((G2Affine::generator() * id.x() - self.tau_g2) * r[0]).into(),
            (-(G2Affine::generator() * r[1])).into(),
        ];
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L111-131)
```rust
    pub fn verify(&self, associated_data: &impl AssociatedData) -> Result<()> {
        let hashed_id = Id::from_verifying_key(&self.vk);

        (self.bibe_ct.id() == hashed_id).then_some(()).ok_or(
            BatchEncryptionError::CTVerifyError(CTVerifyError::IdDoesNotMatchHashedVK),
        )?;
        (self.associated_data_bytes == bcs::to_bytes(associated_data)?)
            .then_some(())
            .ok_or(BatchEncryptionError::CTVerifyError(
                CTVerifyError::AssociatedDataDoesNotMatch,
            ))?;

        let to_verify = (&self.bibe_ct, &self.associated_data_bytes);

        self.vk
            .verify(&bcs::to_bytes(&to_verify)?, &self.signature)
            .map_err(|e| {
                BatchEncryptionError::CTVerifyError(CTVerifyError::SigVerificationFailed(e))
            })?;

        Ok(())
```

**File:** api/src/transactions.rs (L1340-1346)
```rust
                if let Err(e) = payload.verify(signed_transaction.sender()) {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        e.context("Encrypted transaction payload could not be verified"),
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L126-145)
```rust
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
```
