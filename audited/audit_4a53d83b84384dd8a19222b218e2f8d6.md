# Audit Report

## Title
Admin Service Unauthenticated Network Exposure on Non-Mainnet Networks

## Summary
The admin service binds to all network interfaces (0.0.0.0) by default with no authentication on testnet and other non-mainnet networks, exposing sensitive consensus state, validator operations data, and debugging endpoints to potential attackers.

## Finding Description

The `AdminServiceConfig` has a critical security misconfiguration in its default settings that creates an information disclosure vulnerability on non-mainnet networks.

**The vulnerability chain:**

1. **Insecure Default Binding Address**: The default configuration binds to "0.0.0.0" which listens on ALL network interfaces [1](#0-0) 

2. **No Default Authentication**: The default `authentication_configs` is an empty vector, providing no authentication [2](#0-1) 

3. **Authentication Bypass for Empty Config**: When `authentication_configs` is empty, authentication is automatically granted [3](#0-2) 

4. **Testnet Auto-Enable**: The optimizer automatically enables the admin service on testnet by default [4](#0-3) 

5. **Sanitizer Only Checks Mainnet**: The security sanitizer only enforces authentication on mainnet, ignoring testnet [5](#0-4) 

**Exposed Sensitive Endpoints:**

The admin service exposes highly sensitive consensus and operational data through unauthenticated endpoints:

- `/debug/consensus/consensusdb` - Dumps complete consensus state including last vote, highest timeout certificate, all consensus blocks with metadata (epoch, round, author, parent_id, timestamp), and all quorum certificates [6](#0-5) 

- `/debug/consensus/quorumstoredb` - Exposes quorum store batches with transaction digests [7](#0-6) 

- `/debug/consensus/block` - Dumps full block transactions in BCS or text format [8](#0-7) 

- `/debug/mempool/parking-lot/addresses` - Reveals mempool parking lot addresses [9](#0-8) 

**Attack Scenario:**

1. Validator operator deploys testnet node with default configuration
2. Admin service starts on 0.0.0.0:9102 with no authentication [10](#0-9) 
3. Port 9102 is exposed to internet (common in cloud deployments with permissive security groups)
4. Attacker discovers open port via network scanning
5. Attacker queries `/debug/consensus/consensusdb` without authentication
6. Attacker obtains:
   - Validator voting patterns and timing
   - Block authorship and proposal patterns
   - Round progression and consensus state
   - Quorum certificate signatures
7. Attacker uses intelligence for:
   - Identifying optimal timing for consensus disruption
   - Profiling specific validators for targeted attacks
   - Understanding network topology for mempool manipulation
   - Planning timing attacks based on observed patterns

## Impact Explanation

This vulnerability represents **Low Severity** according to Aptos bug bounty criteria as it constitutes "Minor information leaks."

While the exposed information is operationally sensitive and includes internal consensus state, it does not directly:
- Cause loss of funds or enable fund theft
- Break consensus safety guarantees
- Create network partitions or liveness failures
- Enable immediate exploitation without additional vulnerabilities

The information disclosure enables reconnaissance for potential future attacks but does not immediately compromise system security on its own.

## Likelihood Explanation

**Likelihood: Medium to High on testnet deployments**

Factors increasing likelihood:
- Default configuration creates the vulnerability automatically
- Cloud deployments often have permissive default security groups
- Testnet operators may assume reduced security requirements
- The 0.0.0.0 binding is unnecessary for an admin service
- Service starts early in node initialization before other security controls

Factors reducing likelihood:
- Requires port 9102 to be network-accessible
- Mainnet has proper protections (service disabled by default)
- Well-configured firewalls would block external access
- Only affects non-mainnet networks

## Recommendation

**Immediate Fix:**

1. Change default binding address from "0.0.0.0" to "127.0.0.1" (localhost only):

```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "127.0.0.1".to_string(),  // Changed from "0.0.0.0"
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
}
```

2. Enforce authentication requirement on all networks (not just mainnet):

```rust
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if node_config.admin_service.enabled == Some(true) {
            // Enforce authentication on ALL networks, not just mainnet
            if node_config.admin_service.authentication_configs.is_empty() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Must enable authentication for AdminService on all networks.".into(),
                ));
            }
        }

        Ok(())
    }
}
```

3. Add explicit warning in documentation about network exposure risks

4. Consider requiring explicit opt-in for 0.0.0.0 binding with configuration validation

## Proof of Concept

**Step 1: Deploy testnet node with default configuration**

```yaml
# node.yaml - minimal testnet config
admin_service:
  # enabled: not set (defaults to true on testnet)
  # address: not set (defaults to "0.0.0.0")
  # port: not set (defaults to 9102)
  # authentication_configs: not set (defaults to [])
```

**Step 2: Node starts with vulnerable configuration**

The admin service will bind to 0.0.0.0:9102 without authentication on testnet.

**Step 3: Exploit from remote attacker**

```bash
# Discover exposed port
nmap -p 9102 <validator-ip>

# Exploit: Dump consensus database without authentication
curl http://<validator-ip>:9102/debug/consensus/consensusdb

# Response contains sensitive consensus state:
# Last vote: Vote { ... }
# Highest tc: TimeoutCertificate { ... }
# Blocks: [Block { id: ..., author: ..., epoch: ..., round: ..., parent_id: ..., timestamp: ..., payload: ... }]
# QCs: [QuorumCert { ... }]

# Exploit: Dump specific block transactions
curl http://<validator-ip>:9102/debug/consensus/block?block_id=<hash>&bcs=false

# Exploit: Get mempool parking lot addresses
curl http://<validator-ip>:9102/debug/mempool/parking-lot/addresses
```

**Step 4: Verify vulnerability**

The attacker successfully retrieves sensitive consensus and operational data without any authentication, confirming the vulnerability.

---

**Notes:**

This vulnerability only affects non-mainnet networks where the admin service defaults to enabled. Mainnet deployments have proper protections (service disabled by default, authentication required if enabled). However, the insecure default of binding to 0.0.0.0 with no authentication creates unnecessary risk for testnet validators and development environments, potentially exposing sensitive operational data that could facilitate more sophisticated attacks.

### Citations

**File:** config/src/config/admin_service_config.rs (L45-45)
```rust
            address: "0.0.0.0".to_string(),
```

**File:** config/src/config/admin_service_config.rs (L47-47)
```rust
            authentication_configs: vec![],
```

**File:** config/src/config/admin_service_config.rs (L68-76)
```rust
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
```

**File:** config/src/config/admin_service_config.rs (L95-96)
```rust
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L155-156)
```rust
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L130-156)
```rust
fn dump_consensus_db(consensus_db: &dyn PersistentLivenessStorage) -> anyhow::Result<String> {
    let mut body = String::new();

    let (last_vote, highest_tc, consensus_blocks, consensus_qcs) =
        consensus_db.consensus_db().get_data()?;

    body.push_str(&format!("Last vote: \n{last_vote:?}\n\n"));
    body.push_str(&format!("Highest tc: \n{highest_tc:?}\n\n"));
    body.push_str("Blocks: \n");
    for block in consensus_blocks {
        body.push_str(&format!(
            "[id: {:?}, author: {:?}, epoch: {}, round: {:02}, parent_id: {:?}, timestamp: {}, payload: {:?}]\n\n",
            block.id(),
            block.author(),
            block.epoch(),
            block.round(),
            block.parent_id(),
            block.timestamp_usecs(),
            block.payload(),
        ));
    }
    body.push_str("QCs: \n");
    for qc in consensus_qcs {
        body.push_str(&format!("{qc:?}\n\n"));
    }
    Ok(body)
}
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L158-177)
```rust
fn dump_quorum_store_db(
    quorum_store_db: &dyn QuorumStoreStorage,
    digest: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    if let Some(digest) = digest {
        body.push_str(&format!("{digest:?}:\n"));
        body.push_str(&format!(
            "{:?}",
            quorum_store_db.get_batch(&digest).map_err(Error::msg)?
        ));
    } else {
        for (digest, _batch) in quorum_store_db.get_all_batches()? {
            body.push_str(&format!("{digest:?}:\n"));
        }
    }

    Ok(body)
}
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L179-215)
```rust
fn dump_blocks(
    consensus_db: &dyn PersistentLivenessStorage,
    quorum_store_db: &dyn QuorumStoreStorage,
    block_id: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    let all_batches = quorum_store_db.get_all_batches()?;

    let (_, _, blocks, _) = consensus_db.consensus_db().get_data()?;

    for block in blocks {
        let id = block.id();
        if block_id.is_none() || id == block_id.unwrap() {
            body.push_str(&format!("Block ({id:?}): \n\n"));
            match extract_txns_from_block(&block, &all_batches) {
                Ok(txns) => {
                    body.push_str(&format!("{txns:?}"));
                },
                Err(e) => {
                    body.push_str(&format!("Not available: {e:?}"));
                },
            };
            body.push_str("\n\n");
        }
    }

    if body.is_empty() {
        if let Some(block_id) = block_id {
            body.push_str(&format!("Done, block ({block_id:?}) is not found."));
        } else {
            body.push_str("Done, no block is found.");
        }
    }

    Ok(body)
}
```

**File:** crates/aptos-admin-service/src/server/mempool/mod.rs (L12-38)
```rust
pub async fn mempool_handle_parking_lot_address_request(
    _req: Request<Body>,
    mempool_client_sender: MempoolClientSender,
) -> hyper::Result<Response<Body>> {
    match get_parking_lot_addresses(mempool_client_sender).await {
        Ok(addresses) => {
            info!("Finished getting parking lot addresses from mempool.");
            match bcs::to_bytes(&addresses) {
                Ok(addresses) => Ok(reply_with(vec![], addresses)),
                Err(e) => {
                    info!("Failed to bcs serialize parking lot addresses from mempool: {e:?}");
                    Ok(reply_with_status(
                        StatusCode::INTERNAL_SERVER_ERROR,
                        e.to_string(),
                    ))
                },
            }
        },
        Err(e) => {
            info!("Failed to get parking lot addresses from mempool: {e:?}");
            Ok(reply_with_status(
                StatusCode::INTERNAL_SERVER_ERROR,
                e.to_string(),
            ))
        },
    }
}
```

**File:** aptos-node/src/lib.rs (L701-701)
```rust
    let mut admin_service = services::start_admin_service(&node_config);
```
