# Audit Report

## Title
Consensus Database Dump Endpoint Lacks Response Size Limits Leading to Memory Exhaustion and Service Disruption

## Summary
The `/debug/consensus/consensusdb` admin endpoint can generate unbounded response sizes when dumping consensus database contents, potentially causing memory exhaustion or HAProxy timeout failures. Unlike similar debug endpoints (e.g., `/malloc/stats` with a 2MB limit), this endpoint lacks protective size constraints, creating a denial-of-service risk against the admin service.

## Finding Description

The `handle_dump_consensus_db_request()` function retrieves and formats all blocks and quorum certificates from the consensus database without any size validation: [1](#0-0) 

The `dump_consensus_db()` function uses debug formatting on all consensus data, including block payloads: [2](#0-1) 

Block payloads can contain large transaction sets via the `Payload` enum variants: [3](#0-2) 

The `ConsensusDB::get_data()` retrieves ALL blocks and QCs without pagination: [4](#0-3) 

**Contrast with protected endpoints**: The malloc stats endpoint explicitly limits output to 2MB: [5](#0-4) [6](#0-5) 

**Attack scenario:**
1. Attacker authenticates to the admin service (requires credentials on testnet/mainnet)
2. Calls `/debug/consensus/consensusdb`
3. If consensus DB contains many blocks with large payloads (DirectMempool or InlineHybrid variants containing hundreds of transactions each)
4. Server attempts to build a multi-hundred MB or multi-GB String in memory
5. Either: (a) Server runs out of memory → process crash, or (b) Response generation exceeds HAProxy's 60-second timeout → connection terminates mid-transfer [7](#0-6) 

## Impact Explanation

This qualifies as **Low Severity** per Aptos bug bounty criteria ("Non-critical implementation bugs"). The impact is limited because:

1. **Authentication required**: Exploiting requires valid admin service credentials
2. **Mainnet protection**: Admin service is disabled by default on mainnet networks
3. **Scope limitation**: Only affects the admin service, not consensus or validator operations
4. **Debug-only endpoint**: Not intended for production use

However, the denial-of-service potential exists when the admin service is enabled on testnets or development networks.

## Likelihood Explanation

**Likelihood: Low to Medium** depending on deployment configuration:

**Low likelihood on mainnet:** Admin service disabled by default per configuration optimizer: [8](#0-7) 

**Medium likelihood on testnets:** Admin service typically enabled, and authentication may use weaker passcodes. During high-throughput testing or if pruning logic fails, the consensus DB could accumulate hundreds of large blocks (each potentially containing 100-1000 transactions), generating responses exceeding practical memory/timeout limits.

## Recommendation

Implement response size limits consistent with other admin endpoints:

```rust
// In AdminServiceConfig
pub struct AdminServiceConfig {
    // ... existing fields ...
    pub malloc_stats_max_len: usize,
    pub consensus_dump_max_len: usize, // Add new field with default 10 * 1024 * 1024 (10MB)
}

// In dump_consensus_db()
fn dump_consensus_db(
    consensus_db: &dyn PersistentLivenessStorage,
    max_len: usize,
) -> anyhow::Result<String> {
    let mut body = String::new();
    
    let (last_vote, highest_tc, consensus_blocks, consensus_qcs) =
        consensus_db.consensus_db().get_data()?;
    
    // Add size tracking
    let mut current_len = 0;
    const TRUNCATION_MSG: &str = "\n\n[TRUNCATED: Response size limit exceeded]";
    
    // ... format data but check size after each append ...
    body.push_str(&format!("Last vote: \n{last_vote:?}\n\n"));
    current_len += body.len();
    
    if current_len + TRUNCATION_MSG.len() > max_len {
        body.truncate(max_len - TRUNCATION_MSG.len());
        body.push_str(TRUNCATION_MSG);
        return Ok(body);
    }
    
    // Continue with similar checks for blocks and QCs...
}
```

Alternatively, implement streaming/chunked responses or pagination for large data sets.

## Proof of Concept

```rust
// Reproduction test (conceptual - would need full test harness)
#[tokio::test]
async fn test_consensus_db_dump_memory_exhaustion() {
    // Setup: Populate consensus DB with many large blocks
    let mut consensus_db = MockConsensusDB::new();
    
    // Create 500 blocks, each with 1000 transactions
    for i in 0..500 {
        let mut transactions = Vec::new();
        for j in 0..1000 {
            transactions.push(create_large_signed_transaction(/* 5KB payload */));
        }
        let block = Block::new_with_payload(
            Payload::DirectMempool(transactions),
            /* ... other fields ... */
        );
        consensus_db.save_block(block);
    }
    
    // Expected size: 500 blocks * 1000 txns * ~5KB/txn debug output = ~2.5GB
    
    // Attempt to dump - should exhaust memory or timeout
    let req = Request::builder()
        .uri("/debug/consensus/consensusdb?passcode=test")
        .body(Body::empty())
        .unwrap();
    
    let result = handle_dump_consensus_db_request(req, Arc::new(consensus_db)).await;
    
    // In current implementation: likely OOM or timeout
    // In fixed implementation: should return truncated response with warning
}
```

## Notes

This vulnerability demonstrates an inconsistency in the admin service's defensive practices. The codebase already recognizes the need for response size limits (as evidenced by `malloc_stats_max_len`), but this protection was not applied uniformly across all debug endpoints. The consensus DB dump endpoint is particularly vulnerable due to the unbounded nature of consensus data and verbose debug formatting of transaction payloads. While the impact is limited by authentication requirements and deployment patterns, it represents a denial-of-service vector that should be addressed for operational robustness.

### Citations

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L17-38)
```rust
pub async fn handle_dump_consensus_db_request(
    _req: Request<Body>,
    consensus_db: Arc<dyn PersistentLivenessStorage>,
) -> hyper::Result<Response<Body>> {
    info!("Dumping consensus db.");

    match spawn_blocking(move || dump_consensus_db(consensus_db.as_ref())).await {
        Ok(result) => {
            info!("Finished dumping consensus db.");
            let headers: Vec<(_, HeaderValue)> =
                vec![(CONTENT_LENGTH, HeaderValue::from(result.len()))];
            Ok(reply_with(headers, result))
        },
        Err(e) => {
            info!("Failed to dump consensus db: {e:?}");
            Ok(reply_with_status(
                StatusCode::INTERNAL_SERVER_ERROR,
                e.to_string(),
            ))
        },
    }
}
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L130-156)
```rust
fn dump_consensus_db(consensus_db: &dyn PersistentLivenessStorage) -> anyhow::Result<String> {
    let mut body = String::new();

    let (last_vote, highest_tc, consensus_blocks, consensus_qcs) =
        consensus_db.consensus_db().get_data()?;

    body.push_str(&format!("Last vote: \n{last_vote:?}\n\n"));
    body.push_str(&format!("Highest tc: \n{highest_tc:?}\n\n"));
    body.push_str("Blocks: \n");
    for block in consensus_blocks {
        body.push_str(&format!(
            "[id: {:?}, author: {:?}, epoch: {}, round: {:02}, parent_id: {:?}, timestamp: {}, payload: {:?}]\n\n",
            block.id(),
            block.author(),
            block.epoch(),
            block.round(),
            block.parent_id(),
            block.timestamp_usecs(),
            block.payload(),
        ));
    }
    body.push_str("QCs: \n");
    for qc in consensus_qcs {
        body.push_str(&format!("{qc:?}\n\n"));
    }
    Ok(body)
}
```

**File:** consensus/consensus-types/src/common.rs (L207-224)
```rust
/// The payload in block.
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]
pub enum Payload {
    DirectMempool(Vec<SignedTransaction>),
    InQuorumStore(ProofWithData),
    InQuorumStoreWithLimit(ProofWithDataWithTxnLimit),
    QuorumStoreInlineHybrid(
        Vec<(BatchInfo, Vec<SignedTransaction>)>,
        ProofWithData,
        Option<u64>,
    ),
    OptQuorumStore(OptQuorumStorePayload),
    QuorumStoreInlineHybridV2(
        Vec<(BatchInfo, Vec<SignedTransaction>)>,
        ProofWithData,
        PayloadExecutionLimit,
    ),
}
```

**File:** consensus/src/consensusdb/mod.rs (L80-106)
```rust
    pub fn get_data(
        &self,
    ) -> Result<(
        Option<Vec<u8>>,
        Option<Vec<u8>>,
        Vec<Block>,
        Vec<QuorumCert>,
    )> {
        let last_vote = self.get_last_vote()?;
        let highest_2chain_timeout_certificate = self.get_highest_2chain_timeout_certificate()?;
        let consensus_blocks = self
            .get_all::<BlockSchema>()?
            .into_iter()
            .map(|(_, block)| block)
            .collect();
        let consensus_qcs = self
            .get_all::<QCSchema>()?
            .into_iter()
            .map(|(_, qc)| qc)
            .collect();
        Ok((
            last_vote,
            highest_2chain_timeout_certificate,
            consensus_blocks,
            consensus_qcs,
        ))
    }
```

**File:** config/src/config/admin_service_config.rs (L41-50)
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
```

**File:** config/src/config/admin_service_config.rs (L84-107)
```rust
impl ConfigOptimizer for AdminServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        _local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let mut modified_config = false;

        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

            modified_config = true; // The config was modified
        }

        Ok(modified_config)
    }
}
```

**File:** crates/aptos-admin-service/src/server/malloc.rs (L22-34)
```rust
fn get_jemalloc_stats_string(max_len: usize) -> anyhow::Result<String> {
    let _ = jemalloc_ctl::epoch::advance();

    let mut stats = Vec::with_capacity(max_len);
    unsafe {
        jemalloc_sys::malloc_stats_print(
            Some(write_cb),
            &mut stats as *mut _ as *mut c_void,
            std::ptr::null(),
        );
    }
    Ok(String::from_utf8(stats)?)
}
```

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L30-38)
```text
    # Set timeouts for connections
    timeout client 60s
    timeout connect 10s
    timeout server 60s
    timeout queue 10s

    # Prevent long-running HTTP requests
    timeout http-request 60s
    timeout http-keep-alive 5s
```
