# Audit Report

## Title
File-Based Peer Discovery Lacks Integrity Verification Allowing Authentication Bypass

## Summary
The file-based peer discovery mechanism in `network/discovery/src/file.rs` reads peer configuration files without any integrity verification (checksums, signatures, or MACs). An attacker with write access to the discovery file path can inject malicious peer identities and public keys that will be directly trusted by the node, resulting in complete authentication bypass during Noise handshake.

## Finding Description

The `load_file()` function reads peer configuration files using standard filesystem operations without any integrity verification mechanism. [1](#0-0) 

The loaded `PeerSet` is polled periodically by `FileStream` and sent directly to the `ConnectivityManager` via `UpdateDiscoveredPeers` requests. [2](#0-1) 

The `ConnectivityManager` processes these discovered peers and updates the trusted peer set without any validation beyond YAML parsing. [3](#0-2) 

Critically, when public keys are updated from the file, the system calls `set_trusted_peers()` to update the authentication trust store. [4](#0-3) 

These trusted peers are then used during Noise handshake authentication to verify incoming connections. In `Mutual` authentication mode, only peers whose public keys match the trusted set are accepted. [5](#0-4) 

The authentication verification simply checks if the remote peer's public key is in the trusted set. [6](#0-5) 

**Attack Flow:**
1. Attacker gains write access to the file discovery path (via container escape, misconfigurations, or exploiting another vulnerability)
2. Attacker crafts malicious YAML file containing their own PeerId and x25519 public key with `PeerRole::Validator`
3. On next poll interval, `FileStream` loads the malicious configuration
4. `ConnectivityManager` updates the trusted peer set with attacker's public key
5. Attacker connects to the node with their corresponding private key
6. Node authenticates the attacker as a trusted validator
7. Attacker gains access to consensus messages, can participate in Byzantine attacks, perform MitM, and compromise network integrity

**Broken Invariants:**
- **Consensus Safety**: Malicious authenticated peers can participate in consensus and cause safety violations
- **Cryptographic Correctness**: Trust establishment bypasses proper authentication chains
- **Access Control**: Unauthorized peers gain privileged network access

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty criteria for "Significant protocol violations."

The authentication bypass enables:
- **Consensus manipulation**: Attacker authenticated as validator can send malicious consensus messages, potentially causing safety violations or liveness issues
- **Man-in-the-middle attacks**: Trusted status allows interception of sensitive validator communications
- **Network partition**: Malicious peer can selectively drop or delay messages to cause network splits
- **Information disclosure**: Access to confidential validator-to-validator communications

While this doesn't directly result in fund theft, it represents a fundamental breach of the network's trust model and can enable attacks on consensus integrity.

## Likelihood Explanation

**Likelihood: Medium-High**

**Prerequisites:**
- Write access to the file discovery configuration path

**Realistic Attack Vectors:**
1. **Container escape**: In containerized deployments, a container escape vulnerability could provide file system access without full node compromise
2. **Configuration management exploit**: Compromise of CI/CD or configuration management systems that manage discovery files
3. **Privilege escalation**: Local privilege escalation from a low-privilege service account to the node configuration directory
4. **Misconfigured permissions**: Overly permissive file permissions in cloud or shared storage environments
5. **Supply chain attack**: Injection during deployment pipeline before integrity checks occur

The likelihood is elevated because:
- File-based discovery may be used in production environments
- No defense-in-depth protection exists once file access is obtained
- The attack is deterministic and reliable once the prerequisite is met
- No cryptographic barriers exist to prevent the attack

## Recommendation

Implement cryptographic integrity verification for file-based discovery configurations:

**Option 1: Digital Signatures (Recommended)**
Add signature verification to `load_file()`:

```rust
fn load_file(path: &Path, public_key: &ed25519::PublicKey) -> Result<PeerSet, DiscoveryError> {
    // Read file contents
    let contents = std::fs::read_to_string(path).map_err(DiscoveryError::IO)?;
    
    // Read signature file
    let sig_path = path.with_extension("sig");
    let signature_bytes = std::fs::read(sig_path).map_err(DiscoveryError::IO)?;
    let signature = ed25519::Signature::try_from(signature_bytes.as_slice())
        .map_err(|e| DiscoveryError::Parsing(format!("Invalid signature: {}", e)))?;
    
    // Verify signature
    if !public_key.verify_signature(&contents.as_bytes(), &signature) {
        return Err(DiscoveryError::InvalidSignature);
    }
    
    // Parse only after signature verification
    serde_yaml::from_str(&contents).map_err(|err| DiscoveryError::Parsing(err.to_string()))
}
```

Update `FileDiscovery` configuration to include the signing public key:
```rust
pub struct FileDiscovery {
    pub path: PathBuf,
    pub interval_secs: u64,
    pub signature_public_key: ed25519::PublicKey,  // Add this field
}
```

**Option 2: HMAC Verification (Alternative)**
If key distribution is simpler, use HMAC-SHA256 with a shared secret key.

**Option 3: File Permissions + Monitoring**
As a minimum, document that file-based discovery requires:
- Strict file permissions (0400 or 0600, owned by node process user)
- File integrity monitoring (detect unauthorized modifications)
- Restrict to development/testing environments only

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_malicious_peer_injection() {
    use aptos_config::config::{Peer, PeerRole, PeerSet};
    use aptos_crypto::x25519;
    use aptos_temppath::TempPath;
    use aptos_types::PeerId;
    use std::collections::HashSet;
    
    // Step 1: Create discovery file path
    let discovery_path = TempPath::new();
    discovery_path.create_as_file().unwrap();
    
    // Step 2: Attacker generates their own keypair
    let attacker_private_key = x25519::PrivateKey::generate(&mut OsRng);
    let attacker_public_key = attacker_private_key.public_key();
    let attacker_peer_id = from_identity_public_key(attacker_public_key);
    
    // Step 3: Attacker crafts malicious PeerSet
    let mut malicious_peers = PeerSet::new();
    let mut keys = HashSet::new();
    keys.insert(attacker_public_key);
    
    // Attacker claims to be a Validator with fake address
    let fake_addr = NetworkAddress::from_str(
        "/ip4/127.0.0.1/tcp/6180/noise-ik/<attacker_pubkey_hex>/handshake/0"
    ).unwrap();
    
    malicious_peers.insert(
        attacker_peer_id,
        Peer::new(vec![fake_addr], keys, PeerRole::Validator),
    );
    
    // Step 4: Attacker writes malicious config (simulating write access)
    let yaml_content = serde_yaml::to_vec(&malicious_peers).unwrap();
    std::fs::write(discovery_path.as_ref(), yaml_content).unwrap();
    
    // Step 5: Node loads the file without integrity checks
    let loaded_peers = load_file(discovery_path.as_ref()).unwrap();
    
    // Step 6: Verify attacker's peer is trusted
    assert!(loaded_peers.contains_key(&attacker_peer_id));
    assert_eq!(loaded_peers.get(&attacker_peer_id).unwrap().role, PeerRole::Validator);
    
    // Step 7: This malicious peer will now be authenticated during Noise handshake
    // allowing the attacker to participate as a trusted validator
}
```

## Notes

This vulnerability exists because the file-based discovery system lacks defense-in-depth protections. While OS-level file permissions are the primary security boundary, adding cryptographic integrity verification would:

1. Protect against time-of-check-time-of-use (TOCTOU) attacks
2. Detect tampering even if file permissions are misconfigured
3. Provide audit trail through signature verification logs
4. Align with security best practices for configuration file handling
5. Match the security model of other discovery methods (e.g., OnChain discovery uses cryptographic verification)

The vulnerability is particularly concerning because file-based discovery is likely used in production environments where configuration files may be managed through automated systems, increasing the attack surface for injection attacks.

### Citations

**File:** network/discovery/src/file.rs (L38-46)
```rust
    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        // Wait for delay, or add the delay for next call
        futures::ready!(self.interval.as_mut().poll_next(cx));

        Poll::Ready(Some(match load_file(self.file_path.as_path()) {
            Ok(peers) => Ok(peers),
            Err(error) => Err(error),
        }))
    }
```

**File:** network/discovery/src/file.rs (L50-53)
```rust
fn load_file(path: &Path) -> Result<PeerSet, DiscoveryError> {
    let contents = std::fs::read_to_string(path).map_err(DiscoveryError::IO)?;
    serde_yaml::from_str(&contents).map_err(|err| DiscoveryError::Parsing(err.to_string()))
}
```

**File:** network/framework/src/connectivity_manager/mod.rs (L886-945)
```rust
    fn handle_update_discovered_peers(
        &mut self,
        src: DiscoverySource,
        new_discovered_peers: PeerSet,
    ) {
        // Log the update event
        info!(
            NetworkSchema::new(&self.network_context),
            "{} Received updated list of discovered peers! Source: {:?}, num peers: {:?}",
            self.network_context,
            src,
            new_discovered_peers.len()
        );

        // Remove peers that no longer have relevant network information
        let mut keys_updated = false;
        let mut peers_to_check_remove = Vec::new();
        for (peer_id, peer) in self.discovered_peers.write().peer_set.iter_mut() {
            let new_peer = new_discovered_peers.get(peer_id);
            let check_remove = if let Some(new_peer) = new_peer {
                if new_peer.keys.is_empty() {
                    keys_updated |= peer.keys.clear_src(src);
                }
                if new_peer.addresses.is_empty() {
                    peer.addrs.clear_src(src);
                }
                new_peer.addresses.is_empty() && new_peer.keys.is_empty()
            } else {
                keys_updated |= peer.keys.clear_src(src);
                peer.addrs.clear_src(src);
                true
            };
            if check_remove {
                peers_to_check_remove.push(*peer_id);
            }
        }

        // Remove peers that no longer have state
        for peer_id in peers_to_check_remove {
            self.discovered_peers.write().remove_peer_if_empty(&peer_id);
        }

        // Make updates to the peers accordingly
        for (peer_id, discovered_peer) in new_discovered_peers {
            // Don't include ourselves, because we don't need to dial ourselves
            if peer_id == self.network_context.peer_id() {
                continue;
            }

            // Create the new `DiscoveredPeer`, role is set when a `Peer` is first discovered
            let mut discovered_peers = self.discovered_peers.write();
            let peer = discovered_peers
                .peer_set
                .entry(peer_id)
                .or_insert_with(|| DiscoveredPeer::new(discovered_peer.role));

            // Update the peer's pubkeys
            let mut peer_updated = false;
            if peer.keys.update(src, discovered_peer.keys) {
                info!(
```

**File:** network/framework/src/connectivity_manager/mod.rs (L985-1001)
```rust
        if keys_updated {
            // For each peer, union all of the pubkeys from each discovery source
            // to generate the new eligible peers set.
            let new_eligible = self.discovered_peers.read().get_eligible_peers();

            // Swap in the new eligible peers set
            if let Err(error) = self
                .peers_and_metadata
                .set_trusted_peers(&self.network_context.network_id(), new_eligible)
            {
                error!(
                    NetworkSchema::new(&self.network_context),
                    error = %error,
                    "Failed to update trusted peers set"
                );
            }
        }
```

**File:** network/framework/src/noise/handshake.rs (L369-382)
```rust
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```
