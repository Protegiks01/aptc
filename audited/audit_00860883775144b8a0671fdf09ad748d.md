# Audit Report

## Title
ErrorMapping Consensus Vulnerability: Missing Version Tracking Enables Non-Deterministic Error Resolution

## Summary
The `ErrorMapping` structure lacks version tracking for module error codes, and error information is injected post-execution by fetching the current module from storage rather than preserving the version that actually executed. This creates a consensus-critical vulnerability where validators can disagree on `AbortInfo` content when modules are upgraded mid-block, producing different transaction hashes.

## Finding Description

The vulnerability exists in the interaction between module upgrades, error map resolution, and consensus-critical transaction hashing. 

**The Core Issue:**

1. `ErrorMapping` contains no version tracking - it maps abort codes to error descriptions without recording which module version they belong to [1](#0-0) 

2. When transactions abort, `inject_abort_info_if_available()` performs an *unmetered* module lookup to populate `AbortInfo` with error descriptions [2](#0-1) 

3. This lookup fetches the module from storage using `unmetered_get_deserialized_module()`, which retrieves whatever version currently exists, not necessarily the version that executed [3](#0-2) 

4. `AbortInfo` (containing `reason_name` and `description`) is part of `ExecutionStatus`, which is serialized into `TransactionInfoV0` [4](#0-3) 

5. `TransactionInfoV0` derives `BCSCryptoHash` and its hash forms the transaction accumulator - this is consensus-critical [5](#0-4) 

**Attack Scenario:**

Within a single block:
- Transaction T5: Publishes module `M` version 2 with error code 42 mapped to `"ENEW_ERROR"` (old version had `"EOLD_ERROR"`)
- Transaction T10: Calls old cached module `M` version 1, aborts with code 42
- `inject_abort_info_if_available()` fetches module `M` from storage (now version 2)
- Error map lookup returns `"ENEW_ERROR"` for code that came from version 1's execution

If validators have different module caching behaviors (due to timing, cache invalidation bugs, or speculative execution differences), they could fetch different module versions during error injection, producing different `AbortInfo` → different `ExecutionStatus` → different `TransactionInfo` hashes → **consensus failure**.

## Impact Explanation

**Critical Severity** - This is a **Consensus Safety Violation**. 

The vulnerability breaks Critical Invariant #1: "Deterministic Execution - All validators must produce identical state roots for identical blocks."

When validators disagree on `TransactionInfo` hashes due to different error map versions:
- The transaction accumulator root differs across validators
- Validators cannot reach consensus on the block
- The network experiences a **non-recoverable partition** requiring manual intervention or hardfork

This meets the Critical Severity criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Medium-High Likelihood:**

1. **Common operation**: Module upgrades happen regularly on Aptos for framework updates and dApp deployments
2. **Multiple transactions per block**: Blocks contain many transactions, increasing chance of upgrade + abort in same block  
3. **Parallel execution**: Aptos uses parallel block execution which may cache modules differently across speculative paths
4. **No safeguards**: The code explicitly uses "unmetered" access without version validation [6](#0-5) 

The warning comment acknowledges unmetered access for "consistent error message" but doesn't address version mismatches between execution and error resolution.

## Recommendation

**Solution 1: Capture error map version at execution time**

Modify `ExecutionStatus::MoveAbort` to store the module version (from `PackageMetadata.upgrade_number`) alongside the abort code:

```rust
MoveAbort {
    location: AbortLocation::Module(module_id),
    code,
    module_version: Option<u64>,  // NEW: version that executed
    info: Option<AbortInfo>,
}
```

Then in `inject_abort_info_if_available()`, verify the fetched module matches the execution version, or store the error map at abort time.

**Solution 2: Include module hash in AbortInfo lookup**

When injecting abort info, verify the fetched module's code hash matches what the VM loaded during execution. Reject injection if versions mismatch.

**Solution 3: Remove AbortInfo from consensus**

Move `AbortInfo` to `TransactionAuxiliaryData` (which is excluded from hashing via `#[serde(skip)]`) [7](#0-6) . Only include the abort code in consensus-critical data, resolve human-readable names separately.

## Proof of Concept

```move
// Module V1
module 0xCAFE::test {
    const EERROR: u64 = 42;
    
    public entry fun trigger_v1() {
        abort EERROR  // Error map: 42 -> "EERROR"
    }
}

// Upgrade to Module V2 (same transaction block)
module 0xCAFE::test {
    const ENEW_ERROR: u64 = 42;
    
    public entry fun trigger_v2() {
        abort ENEW_ERROR  // Error map: 42 -> "ENEW_ERROR"  
    }
}

// Attack sequence:
// TX1: Publish module V2 (error 42 now maps to "ENEW_ERROR")
// TX2: Call trigger_v1() with cached V1 code -> aborts with EERROR
// inject_abort_info_if_available() fetches V2, finds "ENEW_ERROR"
// Validator A (fresh cache): AbortInfo.reason_name = "ENEW_ERROR"
// Validator B (stale cache): AbortInfo.reason_name = "EERROR"
// -> Different TransactionInfo hashes -> Consensus failure
```

## Notes

The vulnerability is exacerbated by:
- Thread-local metadata caching without version invalidation [8](#0-7) 
- Unmetered module access bypassing normal validation [9](#0-8) 
- No correlation between `PackageMetadata.upgrade_number` and `RuntimeModuleMetadataV1.error_map` [10](#0-9) 

While Aptos is designed for deterministic execution, the explicit use of "unmetered" access and lack of version binding creates a consensus race condition during module upgrades.

### Citations

**File:** third_party/move/move-core/types/src/errmap.rs (L22-28)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ErrorMapping {
    /// The set of error categories and their descriptions
    pub error_categories: BTreeMap<u64, ErrorDescription>,
    /// The set of modules, and the module-specific errors
    pub module_error_maps: BTreeMap<String, BTreeMap<u64, ErrorDescription>>,
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L634-687)
```rust
    fn inject_abort_info_if_available(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &TraversalContext,
        log_context: &AdapterLogSchema,
        status: ExecutionStatus,
    ) -> ExecutionStatus {
        if let ExecutionStatus::MoveAbort {
            location: AbortLocation::Module(module_id),
            code,
            info: current_info,
        } = status
        {
            // Note: in general, this module should have been charged for (because the location is
            // set). This cannot be enforced though, so the best option is to perform unmetered
            // access in any case to get a consistent error message. In case it was not metered,
            // log an error.
            if self.features().is_lazy_loading_enabled()
                && traversal_context
                    .check_is_special_or_visited(module_id.address(), module_id.name())
                    .is_err()
            {
                alert!(
                    *log_context,
                    "Unmetered metadata access for {}::{} when injecting abort info",
                    module_id.address(),
                    module_id.name()
                );
            }

            let mut info = module_storage
                .unmetered_get_deserialized_module(module_id.address(), module_id.name())
                .ok()
                .flatten()
                .and_then(|module| get_metadata(&module.metadata))
                .and_then(|m| m.extract_abort_info(code));

            // If the abort had a message, override the description with the message.
            if let Some(mut current_info) = current_info {
                if let Some(info) = info {
                    current_info.reason_name = info.reason_name;
                }
                info = Some(current_info);
            }

            ExecutionStatus::MoveAbort {
                location: AbortLocation::Module(module_id),
                code,
                info,
            }
        } else {
            status
        }
    }
```

**File:** types/src/transaction/mod.rs (L1780-1782)
```rust
    /// The transaction auxiliary data that includes detail error info that is not used for calculating the hash
    #[serde(skip)]
    auxiliary_data: TransactionAuxiliaryData,
```

**File:** types/src/transaction/mod.rs (L2023-2051)
```rust
#[derive(Clone, CryptoHasher, BCSCryptoHash, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct TransactionInfoV0 {
    /// The amount of gas used.
    gas_used: u64,

    /// The vm status. If it is not `Executed`, this will provide the general error class. Execution
    /// failures and Move abort's receive more detailed information. But other errors are generally
    /// categorized with no status code or other information
    status: ExecutionStatus,

    /// The hash of this transaction.
    transaction_hash: HashValue,

    /// The root hash of Merkle Accumulator storing all events emitted during this transaction.
    event_root_hash: HashValue,

    /// The hash value summarizing all changes caused to the world state by this transaction.
    /// i.e. hash of the output write set.
    state_change_hash: HashValue,

    /// The root hash of the Sparse Merkle Tree describing the world state at the end of this
    /// transaction. Depending on the protocol configuration, this can be generated periodical
    /// only, like per block.
    state_checkpoint_hash: Option<HashValue>,

    /// The hash value summarizing PersistedAuxiliaryInfo.
    auxiliary_info_hash: Option<HashValue>,
}
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L77-90)
```rust
                let txn_info = TransactionInfo::new(
                    txn.hash(),
                    write_set_hash,
                    event_root_hash,
                    state_checkpoint_hash,
                    txn_output.gas_used(),
                    txn_output
                        .status()
                        .as_kept_status()
                        .expect("Already sorted."),
                    auxiliary_info_hash,
                );
                let txn_info_hash = txn_info.hash();
                (txn_info, txn_info_hash)
```

**File:** types/src/vm/module_metadata.rs (L192-196)
```rust
thread_local! {
    static V1_METADATA_CACHE: RefCell<LruCache<Vec<u8>, Option<Arc<RuntimeModuleMetadataV1>>>> = RefCell::new(LruCache::new(METADATA_CACHE_SIZE));

    static V0_METADATA_CACHE: RefCell<LruCache<Vec<u8>, Option<Arc<RuntimeModuleMetadataV1>>>> = RefCell::new(LruCache::new(METADATA_CACHE_SIZE));
}
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L30-49)
```text
    struct PackageMetadata has copy, drop, store {
        /// Name of this package.
        name: String,
        /// The upgrade policy of this package.
        upgrade_policy: UpgradePolicy,
        /// The numbers of times this module has been upgraded. Also serves as the on-chain version.
        /// This field will be automatically assigned on successful upgrade.
        upgrade_number: u64,
        /// The source digest of the sources in the package. This is constructed by first building the
        /// sha256 of each individual source, than sorting them alphabetically, and sha256 them again.
        source_digest: String,
        /// The package manifest, in the Move.toml format. Gzipped text.
        manifest: vector<u8>,
        /// The list of modules installed by this package.
        modules: vector<ModuleMetadata>,
        /// Holds PackageDeps.
        deps: vector<PackageDep>,
        /// For future extension
        extension: Option<Any>
    }
```
