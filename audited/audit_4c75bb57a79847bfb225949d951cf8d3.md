# Audit Report

## Title
Race Condition in `hack_reset()` Allows State Corruption During Concurrent Commit Operations

## Summary
The `hack_reset()` function in `PersistedState` has a documented precondition stating it "Can only be used when no on the fly commit is in the queue," but this constraint is not enforced programmatically. This allows the function to execute while the HotState's async Committer thread has pending commits, creating a race condition that corrupts the synchronization between the state summary and committed state, violating the State Consistency invariant.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **PersistedState::hack_reset()** directly sets both the summary and the committed state: [1](#0-0) 

2. **HotState maintains an async Committer thread** that processes commits from a queue: [2](#0-1) 

3. **The Committer thread continuously processes queued commits** and updates the committed state: [3](#0-2) 

**Race Condition Scenario:**

1. Normal block commit operations call `PersistedState::set()` which enqueues commits to the HotState async queue: [4](#0-3) 

2. During restore operations, `StateStore::set_state_ignoring_summary()` calls `hack_reset()` without draining pending commits: [5](#0-4) 

3. The race occurs when:
   - Thread A: Enqueues commit for version V100 via `persisted_state.set(state_v100)`
   - Thread B: Calls `hack_reset(state_v50)` setting committed state to V50
   - Thread A's Committer: Processes queued V100, overwriting V50
   - Result: `summary` points to V50, but `committed` state is V100

**Why There's No Protection:**

A `wait_for_commit()` method exists to drain commits, but it's test-only: [6](#0-5) 

The `BufferedState::drain_commits()` mechanism exists for the BufferedState layer: [7](#0-6) 

However, this only drains BufferedState commits, not the HotState's internal commit queue. There is no production-code mechanism to wait for HotState's async commits before calling `hack_reset()`.

## Impact Explanation

**Severity: Medium** - State inconsistencies requiring intervention

This vulnerability breaks the **State Consistency** invariant that state transitions must be atomic and verifiable via Merkle proofs. The specific impacts are:

1. **State Summary Mismatch**: The persisted state summary will reference version V50 while the committed state contains V100, causing Merkle proof verification failures

2. **Consensus Divergence Risk**: If different nodes execute restore operations at different times relative to pending commits, they could end up with different state summaries, potentially causing consensus disagreements

3. **Database Corruption**: Subsequent operations that rely on the summary-state relationship being consistent will operate on corrupted data, potentially causing cascading failures

4. **Recovery Complications**: The inconsistency would require manual intervention or database reconstruction to resolve

While this reaches Medium severity, it does not qualify as Critical because:
- It requires administrative restore operations to trigger
- It doesn't directly cause fund loss or total network failure
- It's recoverable with intervention

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability is unlikely to occur in normal operations because:

1. **Requires Specific Timing**: Restore operations (`set_state_ignoring_summary`) are typically only performed during:
   - Initial node bootstrap
   - Recovery from backup
   - Catching up from offline state

2. **Operational Context**: During restore, nodes should not be processing regular blocks

However, the likelihood increases in these scenarios:

1. **Improper Restore Procedures**: If operators incorrectly trigger restore while the node is still active
2. **Race During Shutdown/Restart**: Residual commits queued before shutdown could race with restore on restart
3. **Code Bugs**: Higher-level bugs that call restore operations at inappropriate times
4. **State Sync Edge Cases**: Complex state synchronization scenarios might trigger this

The lack of enforcement means any code path that calls these functions incorrectly will trigger the bug.

## Recommendation

**Add explicit synchronization to drain HotState commits before `hack_reset()`:**

1. **Make `wait_for_commit()` available in production code** by removing the `#[cfg(test)]` attribute, or create a production equivalent:

```rust
// In hot_state.rs - Remove #[cfg(test)] and make production-ready
pub fn wait_for_commit(&self, target_version: Version) {
    while self.committed.lock().next_version() < target_version {
        std::thread::sleep(std::time::Duration::from_millis(1));
    }
}

// Or add a drain method:
pub fn drain_commits(&self) {
    let current_version = self.committed.lock().next_version();
    self.wait_for_commit(current_version);
}
```

2. **Modify `hack_reset()` to enforce the precondition**:

```rust
// In persisted_state.rs
pub fn hack_reset(&self, state_with_summary: StateWithSummary) {
    // Enforce the documented precondition
    let target_version = state_with_summary.version()
        .expect("State must have version");
    self.hot_state.wait_for_commit(target_version);
    
    let (state, summary) = state_with_summary.into_inner();
    *self.summary.lock() = summary;
    self.hot_state.set_commited(state);
}
```

3. **Add assertions or checks** to detect violations:

```rust
pub fn hack_reset(&self, state_with_summary: StateWithSummary) {
    // Check that commit queue is empty
    assert_eq!(
        self.hot_state.get_queue_size(), 
        0, 
        "hack_reset called with pending commits in queue"
    );
    // ... rest of implementation
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_config::config::HotStateConfig;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_hack_reset_race_condition() {
        // Create a PersistedState with initial state at version 0
        let config = HotStateConfig::default();
        let persisted_state = PersistedState::new_empty(config);
        
        // Simulate normal operation: enqueue commit for version 100
        let state_v100 = State::new_at_version(
            Some(100), 
            StateStorageUsage::zero(),
            config
        );
        let summary_v100 = StateSummary::new_at_version(
            Some(100),
            SparseMerkleTree::new(HashValue::zero()),
            SparseMerkleTree::new(HashValue::zero()),
            config
        );
        let state_with_summary_v100 = StateWithSummary::new(state_v100, summary_v100);
        
        // Enqueue the commit (goes to async queue)
        persisted_state.set(state_with_summary_v100);
        
        // Immediately call hack_reset with version 50 (before v100 is processed)
        let state_v50 = State::new_at_version(
            Some(50), 
            StateStorageUsage::zero(),
            config
        );
        let summary_v50 = StateSummary::new_at_version(
            Some(50),
            SparseMerkleTree::new(HashValue::zero()),
            SparseMerkleTree::new(HashValue::zero()),
            config
        );
        let state_with_summary_v50 = StateWithSummary::new(state_v50, summary_v50);
        
        persisted_state.hack_reset(state_with_summary_v50);
        
        // Wait for async commit to process
        thread::sleep(Duration::from_millis(100));
        
        // Check for inconsistency
        let summary = persisted_state.get_state_summary();
        let (_, committed_state) = persisted_state.get_state();
        
        // BUG: Summary says version 50, but committed state is version 100
        assert_eq!(summary.version(), Some(50));  // Summary was set to 50
        assert_eq!(committed_state.version(), Some(100));  // But committed is 100!
        
        // This inconsistency violates the state consistency invariant
        println!("State corruption detected: summary v{:?} != committed v{:?}",
                 summary.version(), committed_state.version());
    }
}
```

## Notes

This vulnerability demonstrates a classic race condition where asynchronous operations (the HotState Committer thread) race with synchronous state resets. The comment at line 64 documents the precondition but lacks enforcement, making it a latent bug that could manifest during restore operations, especially in complex operational scenarios or if higher-level code incorrectly triggers restore while the node is active.

The fix requires adding proper synchronization to ensure the HotState commit queue is drained before `hack_reset()` modifies the state, converting the documented precondition into an enforced invariant.

### Citations

**File:** storage/aptosdb/src/state_store/persisted_state.rs (L50-62)
```rust
    pub fn set(&self, persisted: StateWithSummary) {
        let (state, summary) = persisted.into_inner();

        // n.b. Summary must be updated before committing the hot state, otherwise in the execution
        // pipeline we risk having a state generated based on a persisted version (v2) that's newer
        // than that of the summary (v1). That causes issue down the line where we commit the diffs
        // between a later snapshot (v3) and a persisted snapshot (v1) to the JMT, at which point
        // we will not be able to calculate the difference (v1 - v3) because the state links only
        // to as far as v2 (code will panic)
        *self.summary.lock() = summary;

        self.hot_state.enqueue_commit(state);
    }
```

**File:** storage/aptosdb/src/state_store/persisted_state.rs (L64-69)
```rust
    // n.b. Can only be used when no on the fly commit is in the queue.
    pub fn hack_reset(&self, state_with_summary: StateWithSummary) {
        let (state, summary) = state_with_summary.into_inner();
        *self.summary.lock() = summary;
        self.hot_state.set_commited(state);
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L108-125)
```rust
pub struct HotState {
    base: Arc<HotStateBase>,
    committed: Arc<Mutex<State>>,
    commit_tx: SyncSender<State>,
}

impl HotState {
    pub fn new(state: State, config: HotStateConfig) -> Self {
        let base = Arc::new(HotStateBase::new_empty(config.max_items_per_shard));
        let committed = Arc::new(Mutex::new(state));
        let commit_tx = Committer::spawn(base.clone(), committed.clone());

        Self {
            base,
            committed,
            commit_tx,
        }
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L146-152)
```rust
    /// Wait until the asynchronous commit finishes and the state reaches certain version.
    #[cfg(test)]
    pub fn wait_for_commit(&self, next_version: Version) {
        while self.committed.lock().next_version() < next_version {
            std::thread::sleep(std::time::Duration::from_millis(1));
        }
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L192-205)
```rust
    fn run(&mut self) {
        info!("HotState committer thread started.");

        while let Some(to_commit) = self.next_to_commit() {
            self.commit(&to_commit);
            *self.committed.lock() = to_commit;

            GAUGE.set_with(&["hot_state_items"], self.base.len() as i64);
            GAUGE.set_with(&["hot_state_key_bytes"], self.total_key_bytes as i64);
            GAUGE.set_with(&["hot_state_value_bytes"], self.total_value_bytes as i64);
        }

        info!("HotState committer quitting.");
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1208-1239)
```rust
    pub fn set_state_ignoring_summary(&self, ledger_state: LedgerState) {
        let hot_smt = SparseMerkleTree::new(*CORRUPTION_SENTINEL);
        let smt = SparseMerkleTree::new(*CORRUPTION_SENTINEL);
        let last_checkpoint_summary = StateSummary::new_at_version(
            ledger_state.last_checkpoint().version(),
            hot_smt.clone(),
            smt.clone(),
            HotStateConfig::default(),
        );
        let summary = StateSummary::new_at_version(
            ledger_state.version(),
            hot_smt,
            smt,
            HotStateConfig::default(),
        );

        let last_checkpoint = StateWithSummary::new(
            ledger_state.last_checkpoint().clone(),
            last_checkpoint_summary.clone(),
        );
        let latest = StateWithSummary::new(ledger_state.latest().clone(), summary);
        let current = LedgerStateWithSummary::from_latest_and_last_checkpoint(
            latest,
            last_checkpoint.clone(),
        );

        self.persisted_state.hack_reset(last_checkpoint.clone());
        *self.current_state_locked() = current;
        self.buffered_state
            .lock()
            .force_last_snapshot(last_checkpoint);
    }
```

**File:** storage/aptosdb/src/state_store/buffered_state.rs (L136-144)
```rust
    fn drain_commits(&mut self) {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["buffered_state___drain_commits"]);

        let (commit_sync_sender, commit_sync_receiver) = mpsc::channel();
        self.state_commit_sender
            .send(CommitMessage::Sync(commit_sync_sender))
            .unwrap();
        commit_sync_receiver.recv().unwrap();
    }
```
