# Audit Report

## Title
Compiler Panic in Friend Relationship Inference During Inline Function Expansion

## Summary
The Move compiler v2 contains a logic flaw where inline function expansion can create direct calls to `public(package)` functions without updating friend declarations, causing a panic during access validation. This allows unprivileged attackers to trigger compilation denial-of-service by crafting specific module structures.

## Finding Description

The vulnerability exists in the friend relationship inference mechanism for package-visible functions. The compilation pipeline performs friend inference in two phases:

1. **Initial inference** (before inlining): [1](#0-0) 

2. **Post-inlining update**: Only performed by the unused `inlining_optimization` module, NOT by the standard inlining pass [2](#0-1) 

The standard inlining implementation [3](#0-2)  expands inline functions without updating friend declarations. When an inline function contains calls to `public(package)` functions, these calls become direct calls in the caller module after expansion.

During the access check phase, the compiler validates friend relationships [4](#0-3) . At line 606, a defensive panic triggers when the expected friend declaration is missing, with the comment "we should've inferred the friend declaration".

**Attack Scenario:**
1. Module A (primary target) contains an inline function that calls a `public(package)` function in Module B
2. Module C (primary target) calls Module A's inline function  
3. All modules share the same address (same package)
4. During initial friend inference, C→B call doesn't exist, so C is not added to B's friend list
5. Inlining expands A's function into C, creating the C→B call
6. Standard inliner doesn't update friend declarations
7. Access validation finds the C→B call but no friend relationship
8. Compiler panics at line 606

## Impact Explanation

**Severity: High** - This qualifies as "API crashes" under the Aptos bug bounty program. 

The compiler panic causes complete termination of the compilation process. If the Move compiler is exposed through any public API or service (developer tools, on-chain compilation services, or IDE integrations), an attacker can submit malicious Move code to crash the service repeatedly.

The impact is amplified because:
- The panic is deterministic and reproducible
- No special privileges required beyond code submission
- Multiple crash attempts can overwhelm compilation infrastructure
- Legitimate compilation requests are blocked during attack

This does NOT affect blockchain consensus, execution, or funds, but disrupts the development and deployment pipeline.

## Likelihood Explanation

**Likelihood: High**

The attack requires only:
- Ability to submit Move code for compilation (standard for any developer)
- Knowledge of package visibility and inline functions (documented features)
- Three simple modules with specific structure

No exploitation complexity, no race conditions, no state manipulation required. The bug is in deterministic compiler logic and triggers reliably.

## Recommendation

**Fix:** Modify the standard inlining implementation to update friend declarations after inline function expansion.

Add this call in [3](#0-2)  after inlining completes:

```rust
pub fn run_inlining(
    env: &mut GlobalEnv,
    scope: RewritingScope,
    keep_inline_functions: bool,
    lift_inline_funs: bool,
) {
    // ... existing inlining logic ...
    
    // Add this update after inlining
    env.update_friend_decls_in_targets();
}
```

This mirrors the fix already present in [5](#0-4) .

**Alternative:** Convert the panic to a proper compilation error with diagnostic message, preventing the crash while still catching the invalid state.

## Proof of Concept

Create three Move source files in the same package:

**ModuleB.move:**
```move
module 0xCAFE::ModuleB {
    public(package) fun package_function(): u64 {
        42
    }
}
```

**ModuleA.move:**
```move
module 0xCAFE::ModuleA {
    use 0xCAFE::ModuleB;
    
    public inline fun inline_wrapper(): u64 {
        ModuleB::package_function()
    }
}
```

**ModuleC.move:**
```move
module 0xCAFE::ModuleC {
    use 0xCAFE::ModuleA;
    
    public fun trigger_panic(): u64 {
        ModuleA::inline_wrapper()
    }
}
```

**Compilation command:**
```bash
aptos move compile --package-dir <path> --skip-fetch-latest-git-deps
```

**Expected Result:** Compiler panics with message:
```
thread 'main' panicked at '0xCAFE::ModuleB should have friend 0xCAFE::ModuleC'
```

The panic occurs because:
1. Initial friend inference sees no direct C→B call
2. Inlining expands `inline_wrapper` into ModuleC, creating C→B call
3. Friend declarations are not updated
4. Access validation triggers panic at line 606

### Citations

**File:** third_party/move/move-model/src/lib.rs (L382-382)
```rust
    builder.add_friend_decl_for_package_visibility();
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inlining_optimization.rs (L113-116)
```rust
    // Inlining can cause direct calls to `package` functions that were previously
    // indirect. Thus, it may require additional caller modules to become friends
    // of the callee modules.
    env.update_friend_decls_in_targets();
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs (L79-84)
```rust
pub fn run_inlining(
    env: &mut GlobalEnv,
    scope: RewritingScope,
    keep_inline_functions: bool,
    lift_inline_funs: bool,
) {
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/function_checker.rs (L595-610)
```rust
                                Visibility::Friend => {
                                    if callee_func.module_env.has_friend(&caller_module_id) {
                                        true
                                    } else if callee_func.has_package_visibility() {
                                        if callee_func.module_env.self_address()
                                            == caller_func.module_env.self_address()
                                        {
                                            // if callee is also a primary target, then they are in the same package
                                            // TODO(#13745): fix when we can tell in general if two modules are in the same package
                                            if callee_func.module_env.is_primary_target() {
                                                // we should've inferred the friend declaration
                                                panic!(
                                                    "{} should have friend {}",
                                                    callee_func.module_env.get_full_name_str(),
                                                    caller_func.module_env.get_full_name_str()
                                                );
```
