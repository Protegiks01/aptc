# Audit Report

## Title
Storage Inconsistency Due to Block Tree Pruning Race Between Pre-Commit and Commit Operations

## Summary
A race condition exists in the block executor where a block can be pruned from the block tree between `pre_commit_block()` and `commit_ledger()` operations, causing the commit to fail while leaving the storage in an inconsistent state with pre-committed but uncommitted transactions.

## Finding Description

The vulnerability exists in the `commit_ledger()` function where it attempts to retrieve a block from the block tree before committing to storage. If the block was pruned by a concurrent commit operation on a different chain, this lookup fails and prevents the storage commit, while the block's transactions remain pre-committed in storage.

**Critical Code Path:**

At line 381, `commit_ledger()` validates that the block exists in the block tree: [1](#0-0) 

This check occurs AFTER the block may have been pre-committed but BEFORE the actual storage commit. If another concurrent `commit_ledger()` call prunes this block from the tree, the validation fails.

**Concurrent Operations Are Allowed:**

The executor uses only read locks for commit operations: [2](#0-1) 

The storage layer has separate locks for pre-commit and commit, explicitly allowing them to run concurrently: [3](#0-2) [4](#0-3) 

**Block Tree Pruning Mechanism:**

When `commit_ledger()` completes, it prunes the block tree by updating the root: [5](#0-4) 

The pruning operation removes blocks from the lookup table when they are dropped: [6](#0-5) 

**Pre-Commit Storage Writes:**

The `pre_commit_ledger()` operation writes all transaction data and updates `LedgerCommitProgress`: [7](#0-6) 

**Race Condition Scenario:**

1. **T1**: `pre_commit_block(B)` completes successfully
   - Block B's transactions written to storage
   - `LedgerCommitProgress` updated to include B
   - Block B exists in block tree

2. **T2**: Network partition/view change occurs, consensus shifts to different chain
   - `commit_ledger(E)` executes on competing chain
   - Commits E to storage
   - Calls `block_tree.prune(E.ledger_info)` setting root to E
   - Block B (not ancestor of E) becomes unreachable and is dropped
   - B is removed from block lookup via `Block::drop()`

3. **T3**: `commit_ledger(B)` attempts to execute
   - At line 381: `get_block(B)` returns `BlockNotFound` error
   - Function returns error immediately
   - Storage commit at lines 388-390 is NEVER executed
   - Block B remains pre-committed but not committed

**Storage Inconsistency Result:**
- Transaction data for B exists in storage (from pre-commit)
- `LedgerCommitProgress` includes B's version
- `OverallCommitProgress` does NOT include B's version
- No `LedgerInfo` written for B
- Buffered state may be inconsistent

This violates the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs."

## Impact Explanation

**Severity: Medium to High**

This vulnerability causes storage inconsistency that could require manual intervention to resolve. According to Aptos bug bounty criteria:

- **Medium Severity** ($10,000): "State inconsistencies requiring intervention" - The pre-committed transactions exist in storage but are not properly committed, creating a gap between `LedgerCommitProgress` and `OverallCommitProgress`.

- **Potential High Severity** ($50,000): If the inconsistency causes node crashes, inability to sync, or consensus failures, severity escalates to "Significant protocol violations."

**Impact Scope:**
- Affects nodes experiencing view changes or chain reorganizations
- Storage state becomes inconsistent between different metadata markers
- May cause state sync failures for new nodes
- Could require database rollback or manual reconciliation
- Potential consensus divergence if different nodes have different storage states

## Likelihood Explanation

**Likelihood: Medium**

This race condition can occur during normal consensus operation under specific conditions:

**Triggering Conditions:**
1. Network partition or view change causing chain fork
2. Speculative execution of blocks on multiple chains
3. Pre-commit completing before consensus finalizes
4. Timing window where commit for competing chain prunes blocks
5. Pipeline cancellation not completing before commit_ledger executes

**When It Can Occur:**
- During validator view changes in AptosBFT
- Network partitions resolving with chain reorganization  
- State sync operations with competing chains
- Epoch transitions with multiple proposed blocks

**Frequency:**
- Not constant, depends on network conditions
- More likely in unstable network environments
- Higher probability during high validator churn

The pipeline attempts to prevent this via parent-block ordering: [8](#0-7) 

However, the abort mechanism and timing windows still allow the race condition to occur.

## Recommendation

**Immediate Fix: Add Block Ancestry Validation Before Commit**

Modify `commit_ledger()` to verify the block is a valid descendant of the current root AFTER acquiring any necessary locks but BEFORE allowing concurrent pruning:

```rust
fn commit_ledger(&self, ledger_info_with_sigs: LedgerInfoWithSignatures) -> ExecutorResult<()> {
    let block_id = ledger_info_with_sigs.ledger_info().consensus_block_id();
    
    // Early return check for already committed blocks
    let committed_block = self.block_tree.root_block();
    if committed_block.num_persisted_transactions()? 
        == ledger_info_with_sigs.ledger_info().version() + 1 
    {
        return Ok(());
    }

    // NEW: Validate block exists AND is descendant of root atomically
    // This should hold a lock to prevent concurrent pruning
    let block = self.block_tree.get_block_and_validate_ancestry(block_id)?;
    
    let target_version = ledger_info_with_sigs.ledger_info().version();
    
    // Commit to storage with the validated block reference
    self.db.writer.commit_ledger(target_version, Some(&ledger_info_with_sigs), None)?;
    
    // Prune happens after successful storage commit
    self.block_tree.prune(ledger_info_with_sigs.ledger_info())?;
    
    Ok(())
}
```

**Alternative Solutions:**

1. **Serialization Lock**: Use a write lock in the executor wrapper for `commit_ledger()` to prevent concurrent commits entirely

2. **Two-Phase Validation**: Check block existence both before AND after storage commit, rolling back if pruned in between

3. **Reference Counting**: Keep strong references to blocks during commit operations to prevent premature pruning

4. **Commit Queue**: Serialize all commit operations through a single-threaded queue

**Long-term Fix:**

Redesign the pre-commit/commit flow to be fully atomic with respect to block tree modifications, ensuring that blocks cannot be pruned while they have pending commit operations.

## Proof of Concept

The following Rust test demonstrates the race condition (note: actual execution requires careful thread synchronization):

```rust
#[tokio::test]
async fn test_commit_ledger_race_condition() {
    // Setup: Create executor with blocks A -> B and A -> C (fork)
    let executor = create_test_executor();
    
    // Execute and pre-commit block B
    let block_b = create_test_block(/* parent: A */);
    executor.execute_and_update_state(block_b.clone(), parent_a_id, config).await.unwrap();
    executor.pre_commit_block(block_b.id()).await.unwrap();
    
    // Execute and pre-commit block C on different chain
    let block_c = create_test_block(/* parent: A, different chain */);
    executor.execute_and_update_state(block_c.clone(), parent_a_id, config).await.unwrap();
    executor.pre_commit_block(block_c.id()).await.unwrap();
    
    // Simulate race condition:
    // Thread 1: Start commit_ledger(B) but delay at get_block
    // Thread 2: Complete commit_ledger(C) which prunes B
    
    let executor_clone = executor.clone();
    let handle_c = tokio::spawn(async move {
        let ledger_info_c = create_ledger_info(block_c.id(), version_c);
        executor_clone.commit_ledger(ledger_info_c).await
    });
    
    // Allow C's commit to complete and prune B
    handle_c.await.unwrap().unwrap();
    
    // Now attempt to commit B (should fail with BlockNotFound)
    let ledger_info_b = create_ledger_info(block_b.id(), version_b);
    let result = executor.commit_ledger(ledger_info_b).await;
    
    // Verify: B's commit fails
    assert!(matches!(result, Err(ExecutorError::BlockNotFound(_))));
    
    // Verify storage inconsistency:
    // - LedgerCommitProgress includes B's transactions (from pre-commit)
    // - OverallCommitProgress does NOT include B (commit failed)
    let db = executor.get_db();
    let commit_progress = db.get_ledger_commit_progress().unwrap();
    let overall_progress = db.get_overall_commit_progress().unwrap();
    
    assert!(commit_progress >= version_b); // B was pre-committed
    assert!(overall_progress == version_c); // Only C was committed
    assert!(commit_progress != overall_progress); // INCONSISTENCY DETECTED
}
```

**Notes:**
- This is a timing-dependent race condition requiring specific thread interleaving
- Real-world reproduction would occur during view changes or network partitions
- The test demonstrates the storage inconsistency that results from the race
- Actual exploitation requires consensus-level conditions, not direct attacker control

### Citations

**File:** execution/executor/src/block_executor/mod.rs (L141-149)
```rust
    fn commit_ledger(&self, ledger_info_with_sigs: LedgerInfoWithSignatures) -> ExecutorResult<()> {
        let _guard = CONCURRENCY_GAUGE.concurrency_with(&["block", "commit_ledger"]);

        self.inner
            .read()
            .as_ref()
            .expect("BlockExecutor is not reset")
            .commit_ledger(ledger_info_with_sigs)
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L381-381)
```rust
        self.block_tree.get_block(block_id)?;
```

**File:** execution/executor/src/block_executor/mod.rs (L392-392)
```rust
        self.block_tree.prune(ledger_info_with_sigs.ledger_info())?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L44-53)
```rust
    fn pre_commit_ledger(&self, chunk: ChunkToCommit, sync_commit: bool) -> Result<()> {
        gauged_api("pre_commit_ledger", || {
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
            let _lock = self
                .pre_commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L78-92)
```rust
    fn commit_ledger(
        &self,
        version: Version,
        ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
        chunk_opt: Option<ChunkToCommit>,
    ) -> Result<()> {
        gauged_api("commit_ledger", || {
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
            let _lock = self
                .commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L360-365)
```rust
        ledger_metadata_batch
            .put::<DbMetadataSchema>(
                &DbMetadataKey::LedgerCommitProgress,
                &DbMetadataValue::Version(chunk.expect_last_version()),
            )
            .unwrap();
```

**File:** execution/executor/src/block_executor/block_tree/mod.rs (L34-42)
```rust
impl Drop for Block {
    fn drop(&mut self) {
        self.block_lookup.remove(self.id);
        debug!(
            LogSchema::new(LogEntry::SpeculationCache).block_id(self.id),
            "Block dropped."
        );
    }
}
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1086-1089)
```rust
        let mut tracker = Tracker::start_waiting("commit_ledger", &block);
        parent_block_commit_fut.await?;
        pre_commit_fut.await?;
        let ledger_info_with_sigs = commit_proof_fut.await?;
```
