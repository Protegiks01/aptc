# Audit Report

## Title
Resource Exhaustion via Unchecked CertifiedAugData Construction Enabling BLS Verification DoS

## Summary
The `CertifiedAugData::new()` constructor accepts unverified signatures, allowing attackers to craft messages with invalid BLS signatures that force validators to perform expensive cryptographic verification before rejection, causing resource exhaustion in the consensus layer's verification thread pool.

## Finding Description

The `CertifiedAugData::new()` function constructs certified augmented data without any signature validation: [1](#0-0) 

This public constructor allows an attacker to create `CertifiedAugData` objects with arbitrary invalid `AggregateSignature` values. When validators receive such messages over the network, the processing flow is:

1. **Deserialization** happens first in the verification task: [2](#0-1) 

2. **Expensive verification** occurs only after deserialization: [3](#0-2) 

3. The verification directly calls the computationally expensive `verify_multi_signatures`: [4](#0-3) 

4. This method performs expensive BLS cryptographic operations (key aggregation and signature verification): [5](#0-4) 

The BLS public key aggregation and signature verification are pairing-based cryptographic operations with significant computational cost. An attacker can spam validators with `CertifiedAugData` messages containing:
- Valid epoch numbers (publicly known)
- Arbitrary `AugData<D>` payloads  
- Invalid/garbage `AggregateSignature` values

Each malicious message will:
1. Successfully deserialize (BCS accepts any valid structure)
2. Pass epoch validation check
3. Trigger expensive BLS verification operations
4. Only then be rejected as invalid

The verification tasks are spawned on a bounded executor with limited capacity (default 16 threads): [6](#0-5) 

An attacker can saturate this thread pool with verification of invalid signatures, preventing legitimate consensus messages from being processed promptly.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria: **"Validator node slowdowns"** is explicitly listed as a High Severity impact.

The attack causes:
- **CPU exhaustion** from continuous BLS signature verification
- **Thread pool saturation** of the bounded executor verification threads
- **Delayed processing** of legitimate consensus messages
- **Consensus liveness degradation** as validators struggle to process valid randomness generation messages

While network-level rate limiting exists, it operates on message volume rather than computational cost. An attacker can send a moderate number of malicious messages that collectively consume significant validator resources through expensive but ultimately failed verifications.

## Likelihood Explanation

**Likelihood: High**

The attack is trivially exploitable by any network participant:
1. **No privileged access required** - attacker only needs to send network messages to validators
2. **Public constructor** - `CertifiedAugData::new()` is publicly accessible
3. **No early filtering** - expensive verification happens before rejection
4. **Known current epoch** - epoch values are publicly observable
5. **No duplicate detection** - same invalid message can be sent repeatedly

The attacker complexity is minimal - craft invalid signatures, serialize with BCS, and broadcast to validator network endpoints.

## Recommendation

**Implement signature verification within the constructor** or add mandatory validation before expensive cryptographic operations:

```rust
impl<D: TAugmentedData> CertifiedAugData<D> {
    pub fn new_verified(
        aug_data: AugData<D>, 
        signatures: AggregateSignature,
        verifier: &ValidatorVerifier
    ) -> anyhow::Result<Self> {
        let instance = Self {
            aug_data,
            signatures,
        };
        instance.verify(verifier)?;
        Ok(instance)
    }

    // Keep unsafe constructor private for internal use only
    pub(crate) fn new_unchecked(aug_data: AugData<D>, signatures: AggregateSignature) -> Self {
        Self {
            aug_data,
            signatures,
        }
    }
    
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        verifier.verify_multi_signatures(&self.aug_data, &self.signatures)?;
        Ok(())
    }
}
```

Update the construction site to use the private unchecked version: [7](#0-6) 

**Alternative mitigation:** Add a lightweight pre-verification check before spawning verification tasks, such as validating the signature bitvec structure or implementing a bloom filter for recently rejected signatures.

## Proof of Concept

```rust
// PoC demonstrating resource exhaustion attack
use aptos_crypto::bls12381::Signature;
use aptos_types::aggregate_signature::AggregateSignature;
use consensus::rand::rand_gen::types::{AugData, AugmentedData, CertifiedAugData};
use std::time::Instant;

#[test]
fn test_certified_aug_data_verification_dos() {
    // Setup: Create valid AugData
    let author = account_address::from_hex_literal("0xCAFE").unwrap();
    let epoch = 100;
    let data = AugmentedData { 
        delta: Delta::default(),
        fast_delta: None 
    };
    let aug_data = AugData::new(epoch, author, data);
    
    // Attack: Create invalid signatures
    let mut malicious_messages = vec![];
    for i in 0..100 {
        // Create garbage signature
        let fake_sig = Signature::dummy_signature();
        let fake_agg = AggregateSignature::new(
            bitvec![u8, Lsb0; 1; i % 10], 
            Some(fake_sig)
        );
        
        // Construct CertifiedAugData with invalid signature - NO VALIDATION
        let malicious = CertifiedAugData::new(aug_data.clone(), fake_agg);
        malicious_messages.push(malicious);
    }
    
    // Measure verification cost
    let validator_verifier = setup_validator_verifier();
    let start = Instant::now();
    
    for msg in &malicious_messages {
        // Each verify() call performs expensive BLS operations
        let _ = msg.verify(&validator_verifier);
        // All will fail, but after expensive cryptographic verification
    }
    
    let elapsed = start.elapsed();
    println!("100 invalid signature verifications took: {:?}", elapsed);
    
    // With 16 verification threads, attacker can saturate the pool
    // by sending messages at rate: (16 threads) / (verification_time)
    assert!(elapsed.as_millis() > 100, "BLS verification is expensive");
}
```

**Notes**

While the bounded executor and network rate limiting provide some defense, they are insufficient because:

1. The verification thread pool has limited capacity (16 threads by default)
2. Each invalid message consumes a verification thread slot for the duration of BLS signature verification
3. Network rate limiting operates on message count/bytes, not computational cost
4. No caching or duplicate detection prevents repeated processing of the same invalid signature

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The system performs expensive cryptographic operations on attacker-controlled data before validation, enabling computational DoS attacks against consensus validators.

### Citations

**File:** consensus/src/rand/rand_gen/types.rs (L536-541)
```rust
    pub fn new(aug_data: AugData<D>, signatures: AggregateSignature) -> Self {
        Self {
            aug_data,
            signatures,
        }
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L555-557)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        verifier.verify_multi_signatures(&self.aug_data, &self.signatures)?;
        Ok(())
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L236-236)
```rust
                    match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L50-52)
```rust
            RandMessage::CertifiedAugData(certified_aug_data) => {
                certified_aug_data.verify(&epoch_state.verifier)
            },
```

**File:** types/src/validator_verifier.rs (L379-384)
```rust
        let aggregated_key =
            PublicKey::aggregate(pub_keys).map_err(|_| VerifyError::FailedToAggregatePubKey)?;

        multi_sig
            .verify(message, &aggregated_key)
            .map_err(|_| VerifyError::InvalidMultiSignature)?;
```

**File:** config/src/config/consensus_config.rs (L379-379)
```rust
            num_bounded_executor_tasks: 16,
```

**File:** consensus/src/rand/rand_gen/reliable_broadcast_state.rs (L63-63)
```rust
                CertifiedAugData::new(self.aug_data.clone(), aggregated_signature)
```
