# Audit Report

## Title
Sensitive Authentication Credential Exposure in Faucet Startup Logs

## Summary
The `magic_header_value` authentication secret is logged in plaintext during faucet startup, exposing it to anyone with access to application logs and completely defeating the magic header authentication mechanism.

## Finding Description
The Aptos faucet implements a magic header authentication mechanism where requests must include a specific header key-value pair to be processed. The secret value is stored in `MagicHeaderCheckerConfig.magic_header_value` and should remain confidential. [1](#0-0) 

However, during faucet startup, the entire configuration structure is logged using Debug formatting, which includes the sensitive `magic_header_value`: [2](#0-1) 

The `RunConfig` structure derives `Debug` and contains `checker_configs`: [3](#0-2) 

When the `{:#?}` format specifier is used, it recursively formats all nested structures including the `MagicHeaderCheckerConfig`, exposing the `magic_header_value` in plaintext logs.

While failed authentication attempts themselves only log the header key name (not the value), the startup logging completely exposes the secret credential that attackers need to bypass authentication. [4](#0-3) 

## Impact Explanation
This is a **Medium severity** information disclosure vulnerability per the Aptos bug bounty program. The impact includes:

1. **Authentication Bypass**: Any attacker who gains read access to application logs can extract the `magic_header_value` and use it to bypass the magic header authentication check completely
2. **Wide Log Exposure**: Logs are typically accessible to many parties including operations teams, monitoring systems, log aggregation services, and cloud platform providers
3. **Persistent Exposure**: The credential is logged on every startup, creating multiple opportunities for compromise
4. **Defeats Security Control**: The magic header mechanism is designed to restrict faucet access, and this exposure renders it ineffective

## Likelihood Explanation
This vulnerability has **HIGH likelihood** of exploitation:

1. **Automatic Occurrence**: The credential is automatically logged on every faucet startup without any attacker action required
2. **Common Log Access**: In production environments, logs are often accessible through dashboards, SIEM systems, or cloud logging platforms that may have broader access controls than the application itself
3. **Persistent in Storage**: Logs are typically retained for extended periods, creating a long window for compromise
4. **No Special Privileges Needed**: An attacker only needs read access to logs, which is far easier to obtain than system or database access

## Recommendation
Implement custom `Debug` formatting for `MagicHeaderCheckerConfig` to redact the sensitive `magic_header_value`:

```rust
use std::fmt;

#[derive(Clone, Deserialize, Serialize)]
pub struct MagicHeaderCheckerConfig {
    pub magic_header_key: String,
    pub magic_header_value: String,
}

impl fmt::Debug for MagicHeaderCheckerConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("MagicHeaderCheckerConfig")
            .field("magic_header_key", &self.magic_header_key)
            .field("magic_header_value", &"[REDACTED]")
            .finish()
    }
}
```

Alternatively, use the `secrecy` crate or similar to wrap sensitive values and prevent their accidental logging.

## Proof of Concept
1. Create a faucet configuration file with a magic header checker:
```yaml
checker_configs:
  - type: MagicHeader
    magic_header_key: "X-Secret-Key"
    magic_header_value: "supersecretvalue123"
```

2. Start the faucet service with this configuration
3. Observe the startup logs containing:
```
Running with config: RunConfig {
    ...
    checker_configs: [
        MagicHeader(
            MagicHeaderCheckerConfig {
                magic_header_key: "X-Secret-Key",
                magic_header_value: "supersecretvalue123",
            }
        )
    ]
    ...
}
```

4. An attacker with log access can now extract `supersecretvalue123` and include it in their requests to bypass authentication

## Notes
While the security question specifically asked about "failed authentication attempts," the vulnerability found is in startup configuration logging. Failed authentication rejection messages themselves are secure and do not expose the `magic_header_value`. However, the startup logging vulnerability is more severe as it provides a direct path for attackers to obtain the credential needed to bypass authentication entirely.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/magic_header.rs (L10-14)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MagicHeaderCheckerConfig {
    pub magic_header_key: String,
    pub magic_header_value: String,
}
```

**File:** crates/aptos-faucet/core/src/checkers/magic_header.rs (L42-50)
```rust
        if header_value != &self.config.magic_header_value {
            return Ok(vec![RejectionReason::new(
                format!(
                    "Magic header value wrong {} not found",
                    self.config.magic_header_key
                ),
                RejectionReasonCode::MagicHeaderIncorrect,
            )]);
        }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L55-67)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RunConfig {
    /// API server config.
    pub server_config: ServerConfig,

    /// Metrics server config.
    metrics_server_config: MetricsServerConfig,

    /// Configs for any Bypassers we might want to enable.
    bypasser_configs: Vec<BypasserConfig>,

    /// Configs for any Checkers we might want to enable.
    checker_configs: Vec<CheckerConfig>,
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L85-86)
```rust
    async fn run_impl(self, port_tx: Option<OneShotSender<u16>>) -> Result<()> {
        info!("Running with config: {:#?}", self);
```
