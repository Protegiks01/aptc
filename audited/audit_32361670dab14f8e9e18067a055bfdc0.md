# Audit Report

## Title
Missing Type Validation in TableItemRequest Enables Type Confusion Attacks on Table API

## Summary
The `verify()` method in `TableItemRequest` only validates that `key_type` and `value_type` are syntactically valid Move types, but does not verify they match the table's canonical types stored in `TableInfo`. This allows attackers to provide arbitrary types (including swapped key/value types) that are used for key serialization and value deserialization without validation, potentially leading to type confusion attacks and silent return of incorrectly interpreted data.

## Finding Description
The table item retrieval API endpoint has a critical validation gap that breaks the invariant of type-safe data access: [1](#0-0) 

The `verify()` method only checks that both types are valid `MoveType` instances independently, with no cross-validation against the table's actual types.

When processing table item requests, the API blindly trusts user-provided types: [2](#0-1) 

The user-provided `key_type` is used to serialize the lookup key: [3](#0-2) 

And the user-provided `value_type` is used to deserialize the returned value: [4](#0-3) 

**Critically, there is NO validation that these types match the table's canonical types.** While `TableInfo` stores the correct types and a `get_table_info()` method exists: [5](#0-4) [6](#0-5) 

This validation is never called in the `table_item()` function. The converter has access to table metadata but doesn't use it for validation in the API read path.

**Attack Scenario - Type Confusion:**
1. A table exists as `Table<u64, StructA>` (e.g., account balances)
2. Attacker provides: `key_type=i64, value_type=StructB, key=-1`
3. Since BCS serialization of `i64(-1)` produces identical bytes to `u64(18446744073709551615)` (both are `[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]` in little-endian), the key lookup succeeds
4. The value bytes are deserialized as `StructB` instead of `StructA`
5. If both structs have compatible BCS layouts, data is silently reinterpreted

**Attack Scenario - Swapped Types:**
1. Table exists as `Table<TypeA, TypeB>` where both serialize to similar byte lengths
2. Attacker provides swapped types: `key_type=TypeB, value_type=TypeA`
3. If the serialization produces bytes that happen to match an existing key, wrong entry accessed
4. Value returned is deserialized with wrong type, causing silent data corruption

## Impact Explanation
This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty criteria:

**State Inconsistencies:** The API returns incorrectly typed data without raising errors, leading to silent failures where applications receive structurally valid but semantically incorrect data. While the blockchain state itself is not corrupted, the API layer (critical infrastructure for dapps, wallets, and indexers) provides corrupted views of state.

**Limited Impact Scope:** 
- Does not directly affect consensus or validator operations (API is read-only)
- Primarily impacts API consumers (wallets, dapps, indexers)
- Applications receiving wrong data may make incorrect decisions
- Could indirectly lead to application-level funds loss if data is used for critical logic

The vulnerability breaks the **State Consistency** invariant at the API layer: clients must receive accurate, correctly-typed representations of on-chain data.

## Likelihood Explanation
**Moderate Likelihood** of exploitation:

**Requirements for successful attack:**
1. Knowledge of table handle (publicly available for many tables)
2. Understanding of target table's actual types
3. Crafting types that serialize compatibly or finding BCS layout collisions
4. Target structs must have compatible deserialization paths

**Likelihood factors:**
- **High:** Any API user can call this endpoint with arbitrary types
- **Medium:** Requires understanding of BCS serialization and target table structure  
- **Low:** Successful silent type confusion requires compatible struct layouts
- Most attempts result in "not found" (wrong key bytes) or deserialization errors (incompatible value bytes)

However, the u64/i64 confusion scenario is highly practical and demonstrates the fundamental validation gap.

## Recommendation
Add mandatory type validation in the `table_item()` function to verify user-provided types against the table's canonical types:

```rust
// After line 401 in api/src/state.rs, add:
let table_handle = TableHandle(table_handle.into());

// Validate types against stored TableInfo if available
if let Some(table_info) = converter.get_table_info(table_handle)? {
    // Check key_type matches
    if table_info.key_type.to_canonical_string() != 
       key_type.to_canonical_string() {
        return Err(BasicErrorWith404::bad_request_with_code(
            format!(
                "Provided key_type '{}' does not match table's actual key type '{}'",
                key_type.to_canonical_string(),
                table_info.key_type.to_canonical_string()
            ),
            AptosErrorCode::InvalidInput,
            &ledger_info,
        ));
    }
    
    // Check value_type matches
    if table_info.value_type.to_canonical_string() != 
       value_type.to_canonical_string() {
        return Err(BasicErrorWith404::bad_request_with_code(
            format!(
                "Provided value_type '{}' does not match table's actual value type '{}'",
                value_type.to_canonical_string(),
                table_info.value_type.to_canonical_string()
            ),
            AptosErrorCode::InvalidInput,
            &ledger_info,
        ));
    }
}
```

This ensures type safety at the API boundary and prevents all type confusion attacks.

## Proof of Concept

```rust
// Test demonstrating type confusion vulnerability
#[tokio::test]
async fn test_table_type_confusion() {
    let mut context = new_test_context("test_table_type_confusion");
    let mut account = context.root_account().await;
    
    // Deploy test contract with Table<u64, u64>
    make_test_tables(&mut context, &mut account).await;
    let test_tables = context.api_get_account_resource(
        account.address(),
        &format!("0x{}::TableTestData::TestTables", account.address().to_hex()),
    ).await["data"].to_owned();
    
    let u64_table = &test_tables["u64_table"];
    let handle = u64_table["handle"].as_str().unwrap();
    
    // Normal request (should work)
    let normal_response = context.post(
        &format!("/tables/{}/item", handle),
        json!({
            "key_type": "u64",
            "value_type": "u64",
            "key": "1"
        })
    ).await;
    assert_eq!(normal_response, json!("1")); // Correct value
    
    // Type confusion attack: use i64 instead of u64
    // i64(1) serializes to same bytes as u64(1)
    let confused_response = context.post(
        &format!("/tables/{}/item", handle),
        json!({
            "key_type": "i64",  // WRONG TYPE - should be u64
            "value_type": "i64", // WRONG TYPE - should be u64
            "key": "1"
        })
    ).await;
    
    // VULNERABILITY: Request succeeds with wrong types
    // Should have returned error, but instead returns data
    assert!(confused_response.is_ok()); // Silent failure!
    
    // Swapped types attack
    let swapped_response = context.post(
        &format!("/tables/{}/item", handle),
        json!({
            "key_type": "u64",   // Correct for key
            "value_type": "u128", // WRONG - should be u64
            "key": "1"
        })
    ).await;
    
    // May succeed or fail depending on deserialization compatibility
    // If succeeds, returns incorrectly typed data
}
```

**Notes:**
- The vulnerability exists because `get_table_info()` validation is available but not used in the API read path
- Indexer code properly uses TableInfo for validation, but the public API does not
- BCS serialization makes u64/i64 interchangeable at the byte level, enabling practical type confusion
- Fix requires minimal code change but prevents entire class of type confusion attacks

### Citations

**File:** api/types/src/table.rs (L18-23)
```rust
impl VerifyInput for TableItemRequest {
    fn verify(&self) -> anyhow::Result<()> {
        self.key_type.verify(0)?;
        self.value_type.verify(0)
    }
}
```

**File:** api/src/state.rs (L388-401)
```rust
        // Parse the key and value types for the table
        let key_type = (&table_item_request.key_type)
            .try_into()
            .context("Failed to parse key_type")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;
        let key = table_item_request.key;
        let value_type = (&table_item_request.value_type)
            .try_into()
            .context("Failed to parse value_type")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;
```

**File:** api/src/state.rs (L412-427)
```rust
        let vm_key = converter
            .try_into_vm_value(&key_type, key.clone())
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code(
                    err,
                    AptosErrorCode::InvalidInput,
                    &ledger_info,
                )
            })?;
        let raw_key = vm_key.undecorate().simple_serialize().ok_or_else(|| {
            BasicErrorWith404::bad_request_with_code(
                "Failed to serialize table key",
                AptosErrorCode::InvalidInput,
                &ledger_info,
            )
        })?;
```

**File:** api/src/state.rs (L450-459)
```rust
                let move_value = converter
                    .try_into_move_value(&value_type, &bytes)
                    .context("Failed to deserialize table item retrieved from DB")
                    .map_err(|err| {
                        BasicErrorWith404::internal_with_code(
                            err,
                            AptosErrorCode::InternalError,
                            &ledger_info,
                        )
                    })?;
```

**File:** third_party/move/extensions/move-table-extension/src/lib.rs (L59-71)
```rust
pub struct TableInfo {
    pub key_type: TypeTag,
    pub value_type: TypeTag,
}

impl TableInfo {
    pub fn new(key_type: TypeTag, value_type: TypeTag) -> Self {
        Self {
            key_type,
            value_type,
        }
    }
}
```

**File:** api/types/src/convert.rs (L1060-1065)
```rust
    fn get_table_info(&self, handle: TableHandle) -> Result<Option<TableInfo>> {
        if let Some(indexer_reader) = self.indexer_reader.as_ref() {
            return Ok(indexer_reader.get_table_info(handle).unwrap_or(None));
        }
        Ok(None)
    }
```
