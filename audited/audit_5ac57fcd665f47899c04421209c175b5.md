# Audit Report

## Title
Insecure Filesystem Permissions in Move Compiler Output Directory Creation Enable Information Disclosure of Proprietary Move Code

## Summary
The Move compiler's `output_compiled_units` function and `CompiledPackage::save_to_disk` method create directories and write compiled bytecode files without explicitly setting restrictive filesystem permissions. In multi-user environments with default umask settings (typically 0022), this creates world-readable compilation outputs containing proprietary Move code, source maps, and interface files that can be accessed by unauthorized local users.

## Finding Description

The Move compiler creates output directories and writes compiled artifacts using standard filesystem operations without explicit permission controls: [1](#0-0) [2](#0-1) [3](#0-2) 

These operations rely on the system's default umask (commonly 0022 on Linux systems), which creates files with 0644 permissions (world-readable) and directories with 0755 permissions (world-readable and executable).

**Sensitive Data Exposed:**
- Compiled Move bytecode (.mv files) revealing contract logic
- Source maps (.mvsm files) mapping bytecode back to source lines
- Move interface files (.move files) exposing public APIs and type definitions
- ABI files revealing function signatures

**Attack Scenarios:**

1. **Information Leakage**: On shared development servers, CI/CD systems, or multi-tenant environments, any local user can read another user's compiled Move modules from the default `build/` directory, accessing proprietary business logic before deployment.

2. **Supply Chain Attack (Low Probability)**: In environments with extremely permissive umask (0002 with shared group ownership), an attacker could potentially modify compiled bytecode before deployment, though this requires additional security failures.

**Contrast with Secure Implementation:**

The Aptos CLI properly implements secure file operations for sensitive data: [4](#0-3) 

This sets Unix mode 0600 (user read/write only), preventing unauthorized access. However, this pattern is NOT used in the core Move compiler.

## Impact Explanation

**Severity Assessment: LOW to MEDIUM**

Per the Aptos bug bounty categories, this falls under "Minor information leaks" (Low Severity). However, the security question rates it as Medium, acknowledging that in certain contexts (enterprise development, competitive environments), unauthorized access to proprietary Move code before deployment could have business impact.

**Why NOT Higher Severity:**
- Does not affect on-chain consensus, execution, or state
- Does not enable direct loss of funds
- Requires local system access (not remote exploit)
- Affects development phase, not deployed contracts
- Deployed bytecode is public anyway (on-chain visibility)

**Why NOT Lower Severity:**
- Exposes proprietary logic before deployment
- Source maps significantly aid reverse engineering
- Common in enterprise/team development environments
- Inconsistent with security practices used elsewhere in Aptos CLI

## Likelihood Explanation

**Likelihood: MEDIUM in applicable environments**

**Common Scenarios:**
- Shared development servers with multiple developers
- CI/CD pipeline environments with service accounts
- Docker containers with bind-mounted volumes
- University/research computing environments
- Cloud development instances with team access

**Default Linux umask (0022)** creates world-readable files on most distributions, making this issue present by default unless administrators explicitly harden permissions.

**Mitigating Factors:**
- Many organizations use single-user development VMs
- Container isolation limits exposure
- Version control provides alternate source access
- Proprietary code often protected by other layers

## Recommendation

**Implement explicit permission controls for all compiler output operations:**

```rust
// In compiler.rs - Replace emit_unit macro
#[cfg(unix)]
use std::os::unix::fs::OpenOptionsExt;

macro_rules! emit_unit {
    ($path:ident, $unit:ident) => {{
        let mut opts = OpenOptions::new();
        opts.write(true).create(true).truncate(true);
        #[cfg(unix)]
        opts.mode(0o600); // User read/write only
        
        if emit_source_maps {
            $path.set_extension(SOURCE_MAP_EXTENSION);
            let mut file = opts.open($path.as_path())?;
            file.write_all(&$unit.serialize_source_map())?;
        }
        
        $path.set_extension(MOVE_COMPILED_EXTENSION);
        let mut file = opts.open($path.as_path())?;
        file.write_all(&$unit.serialize(bytecode_version))?
    }};
}

// Set directory permissions to 0700 (user only)
#[cfg(unix)]
use std::os::unix::fs::DirBuilderExt;

let mut builder = std::fs::DirBuilder::new();
builder.recursive(true);
#[cfg(unix)]
builder.mode(0o700);
builder.create(dir_path!(out_dir, MODULE_SUB_DIR))?;
```

**Apply similar fixes to:**
- `compiled_package.rs::save_under()` method
- All `create_dir_all()` calls in compilation paths

## Proof of Concept

```rust
#[test]
fn test_compiler_output_permissions() {
    use std::fs;
    use std::os::unix::fs::PermissionsExt;
    use tempfile::TempDir;
    
    // Create test environment
    let temp_dir = TempDir::new().unwrap();
    let out_dir = temp_dir.path().join("build");
    
    // Compile a simple Move module
    let source = r#"
        module 0x1::test {
            public fun secret_logic(): u64 { 42 }
        }
    "#;
    
    // Simulate compilation (simplified)
    std::fs::create_dir_all(&out_dir.join("modules")).unwrap();
    std::fs::write(out_dir.join("modules/test.mv"), b"compiled_bytecode").unwrap();
    
    // Check permissions
    let metadata = fs::metadata(out_dir.join("modules/test.mv")).unwrap();
    let permissions = metadata.permissions();
    let mode = permissions.mode();
    
    // Verify world-readable (0o644)
    assert!(mode & 0o004 != 0, "File is world-readable!");
    println!("Permission leak confirmed: mode = {:o}", mode);
}
```

## Notes

**Scope Clarification**: This vulnerability affects the Move compiler development toolchain rather than the on-chain Aptos blockchain runtime. While it represents a valid security concern for protecting proprietary Move code during development, it does not directly impact consensus safety, transaction execution, or on-chain state integrityâ€”the primary focus areas of blockchain security audits.

The issue is most relevant in:
- Enterprise development environments with shared infrastructure
- Multi-tenant cloud development platforms  
- CI/CD pipelines with multiple service accounts
- Academic or research computing clusters

For production blockchain security, the more critical concern is ensuring deployed bytecode integrity through cryptographic verification and code review processes, which operate independently of filesystem permissions during compilation.

### Citations

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/command_line/compiler.rs (L379-383)
```rust
                fs::write($path.as_path(), &$unit.serialize_source_map())?;
            }

            $path.set_extension(MOVE_COMPILED_EXTENSION);
            fs::write($path.as_path(), &$unit.serialize(bytecode_version))?
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/command_line/compiler.rs (L394-394)
```rust
        std::fs::create_dir_all(dir_path!(out_dir, MODULE_SUB_DIR))?;
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L282-283)
```rust
        std::fs::create_dir_all(parent)?;
        std::fs::write(path_to_save, bytes).map_err(|err| err.into())
```

**File:** crates/aptos/src/common/utils.rs (L224-228)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
```
