# Audit Report

## Title
Missing Epoch Validation in JWK Consensus Allows Cross-Epoch QuorumCertifiedUpdate Processing

## Summary
The `process_jwk_update_inner` function in the JWK consensus validator transaction processing pipeline lacks explicit epoch validation, unlike its DKG counterpart. This allows `QuorumCertifiedUpdate` objects created in one epoch to potentially be processed in a different epoch, violating the invariant that validator transactions should only be processed in the epoch they were created for.

## Finding Description

The `QuorumCertifiedUpdate` structure does not contain epoch information: [1](#0-0) 

The underlying `ProviderJWKs` payload also lacks an epoch field: [2](#0-1) 

When processing JWK updates, the VM loads the **current** epoch's `ValidatorSet` from on-chain state and uses it to verify the multi-signature: [3](#0-2) 

Notice there is **no epoch validation** - the function proceeds directly from loading resources to version checking and signature verification.

In stark contrast, DKG transaction processing explicitly validates the epoch: [4](#0-3) 

During the reliable broadcast aggregation phase, epoch validation exists for incoming responses: [5](#0-4) 

However, this validation only applies during the **creation** of the `QuorumCertifiedUpdate`. Once created, the `QuorumCertifiedUpdate` object itself carries no epoch information.

**Attack Scenario:**

1. A validator participates in JWK consensus during epoch N, producing a valid `QuorumCertifiedUpdate` with multi-signatures from epoch N validators
2. The validator retains a copy of this `QuorumCertifiedUpdate` 
3. An epoch change occurs (N â†’ N+1), potentially with validator set changes
4. If the validator remains in the validator set for epoch N+1, they can propose a block containing the old `ValidatorTransaction::ObservedJWKUpdate`
5. The VM processes it using epoch N+1's validator set, but the signatures were created by epoch N validators
6. If there is sufficient validator overlap between epochs and the overlapping validators happened to sign in epoch N, the signature verification may incorrectly succeed
7. This applies a stale JWK update in the wrong epoch, violating state consistency

## Impact Explanation

This vulnerability constitutes a **Medium to High severity** issue:

**State Consistency Violation**: The system processes validator transactions signed by validators from a different epoch than the current one. This breaks the fundamental invariant that validator transactions are epoch-specific.

**Authentication Impact**: JWKs (JSON Web Keys) are critical for authentication. Applying stale JWK updates could:
- Allow previously revoked keys to become valid again
- Prevent newly added keys from being recognized
- Create inconsistencies in authentication state across validators

**Consensus Determinism Risk**: Different validators might process the transaction at different times relative to epoch boundaries, potentially causing state divergence.

This qualifies as "State inconsistencies requiring intervention" (Medium) or potentially "Significant protocol violations" (High) depending on the exploitability with actual validator set compositions.

## Likelihood Explanation

**Medium Likelihood** with the following constraints:

**Required Conditions:**
1. Attacker must be a validator in both epoch N (to create the QC) and epoch N+1 (to propose it)
2. Sufficient validator overlap between epochs for signature verification to potentially succeed
3. Overlapping validators must have signed the update in epoch N

**Mitigating Factors:**
- The epoch manager's `shutdown_current_processor` should drop transaction guards during epoch transitions
- Validator set changes might cause signature verification failures
- The attack requires validator privileges

**Aggravating Factors:**
- Validator sets often have high continuity between epochs
- A single Byzantine validator can execute this attack
- No explicit check prevents it

## Recommendation

Add explicit epoch validation to match the DKG implementation:

**Step 1**: Add epoch field to `QuorumCertifiedUpdate` or `ProviderJWKs`:

```rust
pub struct QuorumCertifiedUpdate {
    pub epoch: u64,  // Add this field
    pub update: ProviderJWKs,
    pub multi_sig: AggregateSignature,
}
```

**Step 2**: Update `start_produce` to include epoch in the request: [6](#0-5) 

Modify to embed epoch in the `QuorumCertifiedUpdate`.

**Step 3**: Add epoch validation in `process_jwk_update_inner`:

```rust
fn process_jwk_update_inner(..., update: jwks::QuorumCertifiedUpdate) -> Result<...> {
    // Load current epoch
    let config_resource = ConfigurationResource::fetch_config(resolver)
        .ok_or(Expected(MissingResourceConfiguration))?;
    
    // Validate epoch matches (like DKG does)
    if update.epoch != config_resource.epoch() {
        return Err(Expected(EpochNotCurrent));
    }
    
    // ... rest of existing validation
}
```

**Step 4**: Define the `EpochNotCurrent` error code in the expected failures enum.

## Proof of Concept

The following trace demonstrates the missing validation:

1. **Epoch N - Create QC:**
```rust
// In update_certifier.rs start_produce()
let epoch = epoch_state.epoch; // epoch = N
let req = ConsensusMode::new_rb_request(epoch, &payload)?;
let agg_state = ObservationAggregationState::new(epoch_state, payload);
// Creates QuorumCertifiedUpdate with signatures from epoch N validators
```

2. **Epoch N+1 - Process QC:**
```rust
// In jwk.rs process_jwk_update_inner()
let validator_set = ValidatorSet::fetch_config(resolver)?; // Loads epoch N+1
let verifier = ValidatorVerifier::from(&validator_set); // Uses epoch N+1 verifier

// NO EPOCH CHECK HERE - should verify update.epoch == config_resource.epoch()

verifier.verify_multi_signatures(&observed, &multi_sig)?; 
// Verifies epoch N signatures against epoch N+1 validator set
// May succeed if sufficient validator overlap exists
```

**Demonstration:**
Create a test showing that if validator sets V(N) and V(N+1) have >2/3 overlap in the first k positions, a `QuorumCertifiedUpdate` from epoch N can be verified against epoch N+1's validator set, despite being created for a different epoch.

## Notes

This finding represents a **missing security control** rather than a directly exploitable vulnerability in all scenarios. The comparison with DKG processing strongly suggests this validation was intended but omitted. The practical exploitability depends on validator set composition across epoch boundaries, but defense-in-depth principles require explicit epoch validation regardless of whether signature verification might incidentally catch some mismatches.

### Citations

**File:** types/src/jwks/mod.rs (L122-128)
```rust
#[derive(Clone, Default, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct ProviderJWKs {
    #[serde(with = "serde_bytes")]
    pub issuer: Issuer,
    pub version: u64,
    pub jwks: Vec<JWKMoveStruct>,
}
```

**File:** types/src/jwks/mod.rs (L303-307)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct QuorumCertifiedUpdate {
    pub update: ProviderJWKs,
    pub multi_sig: AggregateSignature,
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L109-142)
```rust
        let validator_set =
            ValidatorSet::fetch_config(resolver).ok_or(Expected(MissingResourceValidatorSet))?;
        let observed_jwks =
            ObservedJWKs::fetch_config(resolver).ok_or(Expected(MissingResourceObservedJWKs))?;

        let mut jwks_by_issuer: HashMap<Issuer, ProviderJWKs> =
            observed_jwks.into_providers_jwks().into();
        let issuer = update.update.issuer.clone();
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
        let verifier = ValidatorVerifier::from(&validator_set);

        let QuorumCertifiedUpdate {
            update: observed,
            multi_sig,
        } = update;

        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }

        let authors = multi_sig.get_signers_addresses(&verifier.get_ordered_account_addresses());

        // Check voting power.
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L99-102)
```rust
        // Check epoch number.
        if dkg_node.metadata.epoch != config_resource.epoch() {
            return Err(Expected(EpochNotCurrent));
        }
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L60-63)
```rust
        ensure!(
            epoch == self.epoch_state.epoch,
            "adding peer observation failed with invalid epoch",
        );
```

**File:** crates/aptos-jwk-consensus/src/update_certifier.rs (L58-66)
```rust
        ConsensusMode::log_certify_start(epoch_state.epoch, &payload);
        let rb = self.reliable_broadcast.clone();
        let epoch = epoch_state.epoch;
        let req = ConsensusMode::new_rb_request(epoch, &payload)
            .context("UpdateCertifier::start_produce failed at rb request construction")?;
        let agg_state = Arc::new(ObservationAggregationState::<ConsensusMode>::new(
            epoch_state,
            payload,
        ));
```
