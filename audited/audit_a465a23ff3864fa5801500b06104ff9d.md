# Audit Report

## Title
Indexer Fails to Track Staking Activity for Non-Signing Delegators in Table-Based Operations

## Summary
The indexer's `account_transactions` table fails to capture staking activity when delegation pool operations modify table items affecting delegators who are not transaction signers. This occurs because lines 74-83 ignore `WriteTableItem` and `DeleteTableItem` changes, and these change types lack address fields to identify affected accounts.

## Finding Description
The delegation pool system uses Move tables to track delegation state, including:
- `pending_withdrawals: Table<address, ObservedLockupCycle>` for tracking pending unlocks
- `vote_delegation: SmartTable<address, VoteDelegation>` for voting power delegation  
- `delegated_votes: SmartTable<address, DelegatedVotes>` for vote tallying [1](#0-0) 

When these tables are modified, they generate `WriteTableItem` or `DeleteTableItem` write set changes. However, the indexer's processing logic explicitly ignores these variants: [2](#0-1) 

Unlike `WriteResource` which contains an `address` field, `WriteTableItem` only has `handle`, `key`, `value`, and `state_key_hash`: [3](#0-2) 

The critical attack scenario occurs with the `evict_delegator` function, where a pool owner can forcibly unlock another delegator's stake: [4](#0-3) 

This function calls `unlock_internal`, which modifies the `pending_withdrawals` table: [5](#0-4) 

In this scenario:
1. The pool owner signs the transaction (not the delegator being evicted)
2. The `pending_withdrawals` table is modified with the delegator's address as key
3. This generates a `WriteTableItem` change with no address field
4. The delegator is NOT captured via signatures (didn't sign)
5. The delegator is NOT captured via table processing (ignored by line 82)
6. Events use V2 model with DUMMY_GUID pointing to 0x0, not the delegator [6](#0-5) 

The code explicitly acknowledges this gap via TODO comment: [7](#0-6) 

## Impact Explanation
This represents a **Medium severity** state inconsistency issue where the indexed view of blockchain state diverges from actual on-chain state. Applications relying on the indexer's `account_transactions` table will:
- Miss delegator eviction events affecting user accounts
- Fail to show pending withdrawals initiated by others
- Provide incomplete staking activity history

While the blockchain state remains correct, the indexer serves as critical infrastructure for wallets, explorers, and dApps. Incomplete indexing creates information asymmetry where affected users may not realize their stake has been unlocked, potentially missing withdrawal windows or failing to monitor their delegation status. This qualifies as "state inconsistencies requiring intervention" per Medium severity criteria, as fixing requires indexer reprocessing and application updates.

## Likelihood Explanation
**HIGH likelihood**. The `evict_delegator` function is a standard delegation pool feature enabling pool operators to remove non-allowlisted delegators. This occurs regularly in allowlist-enabled pools during:
- Initial allowlist enforcement
- Removal of problematic delegators
- Pool management operations

Every eviction transaction currently fails to index the affected delegator's account, making this a systematic and reproducible issue rather than an edge case.

## Recommendation
Extend the `from_transaction` function to process `WriteTableItem` and `DeleteTableItem` variants. Since these lack direct address fields, implement table handle tracking to resolve affected accounts:

```rust
for wsc in wscs {
    match wsc {
        WriteSetChange::DeleteResource(res) => {
            account_transactions.extend(Self::from_delete_resource(res, txn_version)?);
        },
        WriteSetChange::WriteResource(res) => {
            account_transactions.extend(Self::from_write_resource(res, txn_version)?);
        },
        WriteSetChange::WriteTableItem(item) => {
            account_transactions.extend(Self::from_write_table_item(item, txn_version)?);
        },
        WriteSetChange::DeleteTableItem(item) => {
            account_transactions.extend(Self::from_delete_table_item(item, txn_version)?);
        },
        _ => {},
    }
}
```

Implement helper functions to decode table keys and extract affected addresses from known table structures (delegation pools, governance records, etc.).

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, owner = @0x123, delegator = @0x456)]
public entry fun test_evict_delegator_not_indexed(
    aptos_framework: &signer,
    owner: &signer,
    delegator: &signer,
) {
    // Setup delegation pool with allowlisting
    delegation_pool::initialize_delegation_pool(owner, 0, b"seed");
    let pool_address = delegation_pool::get_owned_pool_address(signer::address_of(owner));
    delegation_pool::enable_delegators_allowlisting(owner, pool_address);
    
    // Delegator adds stake before allowlist is enforced
    delegation_pool::add_stake(delegator, pool_address, 1000000000);
    
    // Owner evicts delegator (delegator doesn't sign this transaction)
    delegation_pool::evict_delegator(owner, signer::address_of(delegator));
    
    // Query indexer's account_transactions table
    // Expected: delegator's address should appear for this eviction transaction
    // Actual: delegator's address is MISSING from account_transactions
    // Only the owner's address (signer) is recorded, not the affected delegator
}
```

## Notes
This vulnerability demonstrates a systematic gap in the indexer's ability to track table-based state changes affecting accounts that don't directly sign transactions. While delegation pool evictions provide the clearest example, the issue potentially extends to any Move contract using tables to track per-account state where modifications can be initiated by third parties. The TODO comment at line 37 indicates the development team is aware of this limitation but hasn't yet implemented table item tracking.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L262-285)
```text
    struct DelegationPool has key {
        // Shares pool of `active` + `pending_active` stake
        active_shares: pool_u64::Pool,
        // Index of current observed lockup cycle on the delegation pool since its creation
        observed_lockup_cycle: ObservedLockupCycle,
        // Shares pools of `inactive` stake on each ended OLC and `pending_inactive` stake on the current one.
        // Tracks shares of delegators who requested withdrawals in each OLC
        inactive_shares: Table<ObservedLockupCycle, pool_u64::Pool>,
        // Mapping from delegator address to the OLC of its pending withdrawal if having one
        pending_withdrawals: Table<address, ObservedLockupCycle>,
        // Signer capability of the resource account owning the stake pool
        stake_pool_signer_cap: account::SignerCapability,
        // Total (inactive) coins on the shares pools over all ended OLCs
        total_coins_inactive: u64,
        // Commission fee paid to the node operator out of pool rewards
        operator_commission_percentage: u64,

        // The events emitted by stake-management operations on the delegation pool
        add_stake_events: EventHandle<AddStakeEvent>,
        reactivate_stake_events: EventHandle<ReactivateStakeEvent>,
        unlock_stake_events: EventHandle<UnlockStakeEvent>,
        withdraw_stake_events: EventHandle<WithdrawStakeEvent>,
        distribute_commission_events: EventHandle<DistributeCommissionEvent>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L1537-1558)
```text
    public entry fun evict_delegator(
        owner: &signer,
        delegator_address: address,
    ) acquires DelegationPoolOwnership, DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {
        check_delegation_pool_management_permission(owner);
        let pool_address = get_owned_pool_address(signer::address_of(owner));
        assert_allowlisting_enabled(pool_address);
        assert!(
            !delegator_allowlisted(pool_address, delegator_address),
            error::invalid_state(ECANNOT_EVICT_ALLOWLISTED_DELEGATOR)
        );

        // synchronize pool in order to query latest balance of delegator
        synchronize_delegation_pool(pool_address);

        let pool = borrow_global<DelegationPool>(pool_address);
        if (get_delegator_active_shares(pool, delegator_address) == 0) { return };

        unlock_internal(delegator_address, pool_address, pool_u64::balance(&pool.active_shares, delegator_address));

        event::emit(EvictDelegator { pool_address, delegator_address });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L1875-1907)
```text
    fun buy_in_pending_inactive_shares(
        pool: &mut DelegationPool,
        shareholder: address,
        coins_amount: u64,
    ): u128 acquires GovernanceRecords {
        let new_shares = pool_u64::amount_to_shares(pending_inactive_shares_pool(pool), coins_amount);
        // never create a new pending withdrawal unless delegator owns some pending_inactive shares
        if (new_shares == 0) { return 0 };

        // Always update governance records before any change to the shares pool.
        let pool_address = get_pool_address(pool);
        if (partial_governance_voting_enabled(pool_address)) {
            update_governance_records_for_buy_in_pending_inactive_shares(pool, pool_address, new_shares, shareholder);
        };

        // cannot buy inactive shares, only pending_inactive at current lockup cycle
        pool_u64::buy_in(pending_inactive_shares_pool_mut(pool), shareholder, coins_amount);

        // execute the pending withdrawal if exists and is inactive before creating a new one
        execute_pending_withdrawal(pool, shareholder);

        // save observed lockup cycle for the new pending withdrawal
        let observed_lockup_cycle = pool.observed_lockup_cycle;
        assert!(*table::borrow_mut_with_default(
            &mut pool.pending_withdrawals,
            shareholder,
            observed_lockup_cycle
        ) == observed_lockup_cycle,
            error::invalid_state(EPENDING_WITHDRAWAL_EXISTS)
        );

        new_shares
    }
```

**File:** crates/indexer/src/models/coin_models/account_transactions.rs (L36-37)
```rust
    /// TODO: recursively find the parent account of an object
    /// TODO: include table items in the detection path
```

**File:** crates/indexer/src/models/coin_models/account_transactions.rs (L74-83)
```rust
        for wsc in wscs {
            match wsc {
                WriteSetChange::DeleteResource(res) => {
                    account_transactions.extend(Self::from_delete_resource(res, txn_version)?);
                },
                WriteSetChange::WriteResource(res) => {
                    account_transactions.extend(Self::from_write_resource(res, txn_version)?);
                },
                _ => {},
            }
```

**File:** api/types/src/transaction.rs (L886-892)
```rust
            ContractEvent::V2(v2) => Self {
                guid: *DUMMY_GUID,
                sequence_number: *DUMMY_SEQUENCE_NUMBER,
                typ: v2.type_tag().into(),
                data,
            },
        }
```

**File:** api/types/src/transaction.rs (L1177-1187)
```rust
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, Object)]
pub struct WriteTableItem {
    pub state_key_hash: String,
    pub handle: HexEncodedBytes,
    pub key: HexEncodedBytes,
    pub value: HexEncodedBytes,
    // This is optional, and only possible to populate if the table indexer is enabled for this node
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub data: Option<DecodedTableData>,
}
```
