# Audit Report

## Title
Transaction Filter Bypass for Encrypted Payloads via Error Handling in Entry Function Matching

## Summary
The `matches_entry_function()` function in the transaction filter system incorrectly handles errors from `EncryptedPayload::executable_ref()`. When an encrypted or failed-decryption transaction is checked against DENY rules for specific entry functions, the error case returns `false` (no match), allowing these transactions to bypass the filter and be included in blocks despite potentially matching the denied entry function once decrypted.

## Finding Description

The Aptos blockchain implements a transaction filtering system that allows operators to configure rules to ALLOW or DENY transactions based on various criteria, including specific entry functions. This mechanism is critical for consensus validation and governance controls. [1](#0-0) 

When evaluating whether an `EncryptedPayload` transaction matches an entry function filter, the code attempts to extract the executable content via `payload.executable_ref()`. However, this method only succeeds when the payload is in the `Decrypted` state, returning an error for `Encrypted` or `FailedDecryption` states: [2](#0-1) 

The critical flaw occurs in the error handling: when `executable_ref()` returns an error, the matcher returns `false`, indicating the transaction does NOT match the entry function criteria. This behavior is present in three matching functions:

1. `matches_entry_function()` - for specific entry function matching
2. `matches_entry_function_module_address()` - for module address matching  
3. `matches_script_argument_address()` - for script argument matching [3](#0-2) 

The transaction filter operates with a default-allow policy: if no rules match, the transaction is allowed. This creates an exploitable bypass: [4](#0-3) 

**Attack Scenario:**

1. An operator configures a DENY rule to block transactions calling a critical entry function (e.g., `0x1::aptos_governance::vote`)
2. An attacker submits an `EncryptedPayload` transaction that, when decrypted, would call the denied entry function
3. During consensus block validation, the filter check runs before decryption: [5](#0-4) 

4. Since the transaction is still encrypted, `executable_ref()` fails, and the matcher returns `false`
5. The DENY rule doesn't match, so the transaction is allowed through
6. Later in the pipeline, the transaction is decrypted and executes the denied function: [6](#0-5) 

This breaks the **Access Control** invariant: transaction filters are designed to enforce restrictions on which operations can be performed, but encrypted payloads can circumvent these controls.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty criteria:

1. **Filter Bypass**: The core security mechanism designed to block specific transactions can be circumvented
2. **Governance Implications**: If filters are used to prevent certain governance operations during critical periods, this bypass could undermine governance integrity
3. **Consensus Impact**: Malicious validators can include encrypted transactions that should be denied, and honest validators won't reject the block due to the filter bypass
4. **Limited Scope**: While serious, this doesn't directly cause fund loss or consensus safety violations; it's a control bypass that undermines an optional security feature

The impact is constrained because:
- Transaction filters are not always enabled
- The vulnerability requires pre-configuration of DENY rules to exploit
- Encrypted transactions still undergo normal validation and execution

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is likely to be exploitable in practice because:

1. **Encrypted transactions are supported**: The system includes full infrastructure for encrypted payloads, indicating they are used in production [7](#0-6) 

2. **Inline transactions can be encrypted**: The consensus validation specifically checks inline transactions, which can include encrypted payloads [8](#0-7) 

3. **No special privileges required**: Any user can submit encrypted transactions through the standard API
4. **Real-world use cases exist**: Transaction filters are tested and documented, suggesting they're used for operational security [9](#0-8) 

## Recommendation

The error handling should treat undecryptable payloads conservatively. Since the filter cannot verify whether an encrypted transaction matches a DENY rule, it should apply a fail-safe approach based on the rule type:

**Option 1 - Conservative (Recommended):** For DENY rules that use entry function matchers, treat error cases as potential matches and deny the transaction:

```rust
TransactionPayload::EncryptedPayload(payload) => {
    match payload.executable_ref() {
        Ok(executable) => match executable {
            TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
            TransactionExecutableRef::EntryFunction(entry_function) => {
                compare_entry_function(entry_function, address, module_name, function)
            },
        },
        Err(_) => {
            // Cannot determine if encrypted payload matches the entry function.
            // For security, treat as a potential match to be safe.
            // This errs on the side of caution for DENY rules.
            true
        }
    }
},
```

**Option 2 - Explicit Configuration:** Add a configuration option to control behavior for undecryptable payloads, allowing operators to choose between:
- Block all encrypted payloads when DENY rules exist
- Allow encrypted payloads (current behavior)
- Require decryption before filtering

**Option 3 - Defer Filtering:** Move transaction filter checks to after the decryption pipeline, ensuring all transactions are decrypted before filter evaluation.

## Proof of Concept

```rust
#[cfg(test)]
mod encrypted_payload_filter_bypass_test {
    use super::*;
    use aptos_types::transaction::{
        TransactionPayload, SignedTransaction, RawTransaction,
        encrypted_payload::EncryptedPayload,
    };
    use aptos_crypto::HashValue;
    use move_core_types::account_address::AccountAddress;
    
    #[test]
    fn test_encrypted_payload_bypasses_entry_function_deny_filter() {
        // Create a transaction filter that DENIES a specific entry function
        let denied_address = AccountAddress::from_hex_literal("0x1").unwrap();
        let denied_module = "governance".to_string();
        let denied_function = "vote".to_string();
        
        let filter = TransactionFilter::empty()
            .add_entry_function_filter(
                false, // DENY
                denied_address,
                denied_module.clone(),
                denied_function.clone(),
            );
        
        // Create an encrypted payload transaction (still in Encrypted state)
        let encrypted_payload = EncryptedPayload::Encrypted {
            ciphertext: /* encrypted data containing the denied entry function */,
            extra_config: TransactionExtraConfig::default(),
            payload_hash: HashValue::random(),
        };
        
        let raw_txn = RawTransaction::new(
            AccountAddress::random(),
            0,
            TransactionPayload::EncryptedPayload(encrypted_payload),
            0,
            0,
            0,
            ChainId::test(),
        );
        
        let signed_txn = /* sign transaction */;
        
        // The filter should deny this transaction, but due to the bug,
        // it allows it through because executable_ref() fails
        assert!(filter.allows_transaction(&signed_txn)); // BUG: Returns true
        
        // After decryption, the transaction would execute the denied function
        // This demonstrates the bypass: encrypted transactions evade DENY rules
    }
}
```

## Notes

This vulnerability also affects `matches_entry_function_module_address()` and `matches_script_argument_address()` with identical error handling patterns: [10](#0-9) [11](#0-10) 

All three functions should be fixed to handle undecryptable payloads securely.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L30-47)
```rust
    pub fn allows_transaction(&self, signed_transaction: &SignedTransaction) -> bool {
        // If the filter is empty, allow the transaction by default
        if self.is_empty() {
            return true;
        }

        // Check if any rule matches the transaction
        for transaction_rule in &self.transaction_rules {
            if transaction_rule.matches(signed_transaction) {
                return match transaction_rule {
                    TransactionRule::Allow(_) => true,
                    TransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the transaction by default)
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L332-375)
```rust
/// Returns true iff the transaction's entry function matches the given account address, module name, and function name
fn matches_entry_function(
    signed_transaction: &SignedTransaction,
    address: &AccountAddress,
    module_name: &String,
    function: &String,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.payload() {
        TransactionPayload::Script(_) | TransactionPayload::ModuleBundle(_) => false,
        TransactionPayload::Multisig(multisig) => multisig
            .transaction_payload
            .as_ref()
            .map(|payload| match payload {
                MultisigTransactionPayload::EntryFunction(entry_function) => {
                    compare_entry_function(entry_function, address, module_name, function)
                },
            })
            .unwrap_or(false),
        TransactionPayload::EntryFunction(entry_function) => {
            compare_entry_function(entry_function, address, module_name, function)
        },
        TransactionPayload::Payload(TransactionPayloadInner::V1 { executable, .. }) => {
            match executable.as_ref() {
                TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                TransactionExecutableRef::EntryFunction(entry_function) => {
                    compare_entry_function(entry_function, address, module_name, function)
                },
            }
        },
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function(entry_function, address, module_name, function)
                    },
                }
            } else {
                false
            }
        },
    }
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L405-416)
```rust
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function_module_address(entry_function, module_address)
                    },
                }
            } else {
                false
            }
        },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L471-483)
```rust
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::EntryFunction(_)
                    | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::Script(script) => {
                        compare_script_argument_address(script, address)
                    },
                }
            } else {
                false
            }
        },
```

**File:** types/src/transaction/encrypted_payload.rs (L42-64)
```rust
pub enum EncryptedPayload {
    Encrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
    },
    FailedDecryption {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,
    },
    Decrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,

        // decrypted things
        executable: TransactionExecutable,
        decryption_nonce: u64,
    },
}
```

**File:** types/src/transaction/encrypted_payload.rs (L82-87)
```rust
    pub fn executable_ref(&self) -> Result<TransactionExecutableRef<'_>> {
        let Self::Decrypted { executable, .. } = self else {
            bail!("Transaction is encrypted");
        };
        Ok(executable.as_ref())
    }
```

**File:** consensus/src/round_manager.rs (L1202-1214)
```rust
        // If the proposal contains any inline transactions that need to be denied
        // (e.g., due to filtering) drop the message and do not vote for the block.
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L24-55)
```rust
impl PipelineBuilder {
    /// Precondition: Block is materialized and the transactions are available locally
    /// What it does: Decrypt encrypted transactions in the block
    pub(crate) async fn decrypt_encrypted_txns(
        materialize_fut: TaskFuture<MaterializeResult>,
        block: Arc<Block>,
        author: Author,
        secret_share_config: Option<SecretShareConfig>,
        derived_self_key_share_tx: oneshot::Sender<Option<SecretShare>>,
        secret_shared_key_rx: oneshot::Receiver<Option<SecretSharedKey>>,
    ) -> TaskResult<DecryptionResult> {
        let mut tracker = Tracker::start_waiting("decrypt_encrypted_txns", &block);
        let (input_txns, max_txns_from_block_to_execute, block_gas_limit) = materialize_fut.await?;

        tracker.start_working();

        if secret_share_config.is_none() {
            return Ok((input_txns, max_txns_from_block_to_execute, block_gas_limit));
        }

        let (encrypted_txns, unencrypted_txns): (Vec<_>, Vec<_>) = input_txns
            .into_iter()
            .partition(|txn| txn.is_encrypted_txn());

        // TODO: figure out handling of
        if encrypted_txns.is_empty() {
            return Ok((
                unencrypted_txns,
                max_txns_from_block_to_execute,
                block_gas_limit,
            ));
        }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L568-590)
```rust
fn get_inline_transactions(block: &Block) -> Vec<SignedTransaction> {
    // If the block has no payload, return an empty vector
    let Some(payload) = block.payload() else {
        return vec![];
    };

    // Fetch the inline transactions from the payload
    match payload {
        Payload::QuorumStoreInlineHybrid(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::QuorumStoreInlineHybridV2(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => p.inline_batches().transactions(),
```

**File:** crates/aptos-transaction-filters/src/tests/block_transaction_filter_config.rs (L64-98)
```rust
fn test_block_transaction_filter_config_deny() {
    for use_new_txn_payload_format in [false, true] {
        // Create a filter that denies transactions based on multiple criteria
        let transactions = utils::create_entry_function_transactions(use_new_txn_payload_format);
        let block_transaction_filter_string = format!(
            r#"
            block_transaction_rules:
                - Deny:
                    - Transaction:
                        ModuleAddress: "0000000000000000000000000000000000000000000000000000000000000000"
                - Deny:
                    - Transaction:
                        Sender: "{}"
                - Deny:
                    - Transaction:
                        EntryFunction:
                            - "0000000000000000000000000000000000000000000000000000000000000002"
                            - entry
                            - new
                - Deny:
                    - Transaction:
                        ModuleAddress: "0000000000000000000000000000000000000000000000000000000000000003"
                - Deny:
                    - Transaction:
                        AccountAddress: "{}"
                - Allow:
                    - Transaction:
                        All
          "#,
            transactions[1].sender().to_standard_string(),
            utils::get_module_address(&transactions[4]).to_standard_string(),
        );
        let block_transaction_filter =
            serde_yaml::from_str::<BlockTransactionFilter>(&block_transaction_filter_string)
                .unwrap();
```
