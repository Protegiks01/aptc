# Audit Report

## Title
Consensus Observer Timeout Cascading Denial of Service via Malicious Peer Subscription Attempts

## Summary
The consensus observer subscription creation mechanism is vulnerable to a timeout cascading attack where malicious peers can cause extended periods of service unavailability by deliberately timing out subscription requests. An attacker controlling multiple well-positioned peers can force the observer to sequentially timeout on each peer, causing the observer to lose consensus updates for 10+ seconds before entering fallback mode.

## Finding Description

The vulnerability exists in the subscription creation flow when all active subscriptions become unhealthy. The system terminates all subscriptions immediately, then spawns an asynchronous task to create new ones by sequentially trying peers from a sorted list. [1](#0-0) 

The subscription creation task iterates through peers sequentially, sending subscription RPC requests with individual timeouts: [2](#0-1) 

Each RPC request has a timeout of 5 seconds (default configuration): [3](#0-2) 

**Attack Path:**

1. Attacker controls N malicious peers and manipulates their reported `distance_from_validators` metric to appear optimal (e.g., distance=1)
2. These peers are prioritized in the sorted peer list due to low reported distance
3. When all legitimate subscriptions fail health checks, the observer terminates them and spawns a subscription creation task
4. The task sequentially tries malicious peers, each deliberately delaying responses to trigger the 5-second timeout
5. Total blocking time = N × 5 seconds (e.g., 10 peers = 50 seconds)
6. During this period, the observer has no active subscriptions and cannot receive consensus updates
7. After ~10 seconds of no database progress, the observer enters fallback mode [4](#0-3) 

The subscription creation task cannot be interrupted or canceled once started, and only one task can run at a time: [5](#0-4) 

**Manipulating Peer Metrics:**

An attacker can falsify the `distance_from_validators` metric because peers self-report this value without cryptographic proof: [6](#0-5) 

The distance calculation uses reported values from connected peers without verification: [7](#0-6) 

## Impact Explanation

This vulnerability causes **temporary service degradation** of consensus observer nodes:

- **Duration**: ~10-15 seconds of unavailability before fallback mode engages
- **Affected Systems**: Validator fullnodes (VFNs) and public fullnodes using consensus observer
- **Automatic Recovery**: Fallback mode provides alternative sync mechanism via state sync
- **No Critical Impact**: Does not affect validator consensus, fund security, or state integrity

The severity is **Medium** per bug bounty criteria as it causes "State inconsistencies requiring intervention" (though intervention is automatic via fallback mode). However, this vulnerability may be considered **out of scope** as network-level DoS attacks are excluded, and this has characteristics of a protocol-level availability attack with limited impact.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires:
- Attacker controls multiple network peers (feasible on public networks)
- Peers report false metrics (no cryptographic verification required)
- Peers have genuinely low network latency (achievable via geographic proximity)
- All legitimate subscriptions fail simultaneously (can be triggered via network disruption)

The attack is practical but limited in impact due to automatic fallback recovery.

## Recommendation

Implement overall timeout and circuit breaker mechanisms for subscription creation:

```rust
// In subscription_manager.rs - add to SubscriptionManager struct:
subscription_creation_start_time: Option<Instant>,

// In spawn_subscription_creation_task, add timeout tracking:
let subscription_creation_start_time = time_service.now();
let max_creation_duration = Duration::from_millis(
    consensus_observer_config.max_subscription_creation_timeout_ms  // e.g., 15_000ms
);

// In create_new_subscriptions, check overall timeout:
let elapsed = time_service.now().duration_since(start_time);
if elapsed > max_creation_duration {
    warn!("Subscription creation timed out after {:?}, aborting", elapsed);
    break;
}

// Add peer reputation tracking to deprioritize repeatedly failing peers
```

Additionally, implement cryptographic verification of peer distance metrics or use independent measurement to prevent metric falsification.

## Proof of Concept

```rust
// Test demonstrating timeout cascading (add to subscription_utils.rs tests)
#[tokio::test(flavor = "multi_thread")]
async fn test_timeout_cascading_attack() {
    // Setup: Create observer with multiple malicious peers
    let consensus_observer_config = ConsensusObserverConfig {
        network_request_timeout_ms: 5_000,  // 5 second timeout
        ..Default::default()
    };
    
    // Create 10 malicious peers with low distance (appear optimal)
    let num_malicious_peers = 10;
    for i in 0..num_malicious_peers {
        create_peer_and_connection(
            NetworkId::Public,
            peers_and_metadata.clone(),
            1,  // Low distance - appears optimal
            Some(0.1),  // Low latency
            true
        );
    }
    
    // Spawn subscription creation
    let start_time = Instant::now();
    let subscription_task = create_new_subscriptions(
        consensus_observer_config,
        consensus_observer_client.clone(),
        None,
        db_reader,
        TimeService::real(),
        connected_peers_and_metadata,
        2,  // Try to create 2 subscriptions
        vec![],
        vec![],
    );
    
    // Simulate malicious peers timing out
    // Each peer delays response by 5+ seconds
    for _ in 0..num_malicious_peers {
        tokio::time::sleep(Duration::from_secs(5)).await;
        // Respond with failure after timeout
    }
    
    let subscriptions = subscription_task.await;
    let elapsed = start_time.elapsed();
    
    // Verify cascading timeout occurred
    assert!(elapsed >= Duration::from_secs(50)); // 10 peers × 5 seconds
    assert_eq!(subscriptions.len(), 0);  // No successful subscriptions
}
```

**Notes:**
- This vulnerability may be **out of scope** as DoS attacks are excluded from the bug bounty program
- Impact is limited by automatic fallback recovery after ~10 seconds
- No critical consensus or fund security invariants are broken
- Severity assessment is borderline between valid Medium severity and out-of-scope DoS

### Citations

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L114-139)
```rust
        let terminated_subscriptions =
            self.terminate_unhealthy_subscriptions(&connected_peers_and_metadata);

        // Check if all subscriptions were terminated
        let num_terminated_subscriptions = terminated_subscriptions.len();
        let all_subscriptions_terminated = num_terminated_subscriptions > 0
            && num_terminated_subscriptions == initial_subscription_peers.len();

        // Calculate the number of new subscriptions to create
        let remaining_subscription_peers = self.get_active_subscription_peers();
        let max_concurrent_subscriptions =
            self.consensus_observer_config.max_concurrent_subscriptions as usize;
        let num_subscriptions_to_create =
            max_concurrent_subscriptions.saturating_sub(remaining_subscription_peers.len());

        // Update the total subscription metrics
        update_total_subscription_metrics(&remaining_subscription_peers);

        // Spawn a task to create the new subscriptions (asynchronously)
        self.spawn_subscription_creation_task(
            num_subscriptions_to_create,
            remaining_subscription_peers,
            terminated_subscriptions,
            connected_peers_and_metadata,
        )
        .await;
```

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L192-197)
```rust
        // If there is an active subscription creation task, return early
        if let Some(subscription_creation_task) = &*self.active_subscription_creation_task.lock() {
            if !subscription_creation_task.is_finished() {
                return; // The task is still running
            }
        }
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L126-139)
```rust
    for potential_peer in sorted_potential_peers {
        // Log the subscription attempt
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Attempting to subscribe to potential peer: {}!",
                potential_peer
            ))
        );

        // Send a subscription request to the peer and wait for the response
        let subscription_request = ConsensusObserverRequest::Subscribe;
        let request_timeout_ms = consensus_observer_config.network_request_timeout_ms;
        let response = consensus_observer_client
            .send_rpc_request_to_peer(&potential_peer, subscription_request, request_timeout_ms)
```

**File:** config/src/config/consensus_observer_config.rs (L70-70)
```rust
            network_request_timeout_ms: 5_000,                 // 5 seconds
```

**File:** consensus/src/consensus_observer/observer/fallback_manager.rs (L100-111)
```rust
            let fallback_threshold = Duration::from_millis(
                self.consensus_observer_config
                    .observer_fallback_progress_threshold_ms,
            );
            if duration_since_highest_seen > fallback_threshold {
                Err(Error::ObserverProgressStopped(format!(
                    "Consensus observer is not making progress! Highest synced version: {}, elapsed: {:?}",
                    highest_synced_version, duration_since_highest_seen
                )))
            } else {
                Ok(()) // We haven't passed the fallback threshold yet
            }
```

**File:** peer-monitoring-service/server/src/lib.rs (L217-248)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L321-339)
```rust
    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
```
