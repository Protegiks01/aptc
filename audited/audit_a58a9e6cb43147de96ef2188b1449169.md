# Audit Report

## Title
Division by Zero Panic in Proposer Election with Empty Validator Set Causes Network Halt

## Summary
The `choose_index()` function in proposer election performs a modulo operation with zero when called with an empty weights vector, causing a panic that crashes all consensus nodes. This can occur when all validators fall below the minimum stake requirement during epoch transitions, resulting in an empty validator set and complete network failure requiring a hard fork.

## Finding Description

The vulnerability exists in the proposer election logic when the validator set becomes empty. The attack chain is:

**Step 1: Empty Validator Set Creation**

During `on_new_epoch()` in the staking module, validators below the minimum stake are filtered out. If all validators fall below this threshold, an empty validator set is created: [1](#0-0) 

The code creates an empty `next_epoch_validators` vector and only adds validators meeting the minimum stake requirement. No validation prevents this from remaining empty, and the empty vector is directly assigned to `validator_set.active_validators` without any checks.

**Step 2: Empty Validator Set Propagates to Consensus**

The empty `ValidatorSet` is converted to a `ValidatorVerifier`, which accepts empty validator lists: [2](#0-1) 

When the validator list is empty, `quorum_voting_power` is set to 0, but no error is raised.

**Step 3: LeaderReputation Created with Empty Vectors**

The consensus layer extracts proposers from the epoch state and creates a `LeaderReputation` instance: [3](#0-2) 

The `LeaderReputation` constructor only validates that vector lengths match, not that they are non-empty: [4](#0-3) 

**Step 4: Division by Zero Panic**

When consensus needs to select a proposer, it calls `get_valid_proposer()`, which ultimately invokes `choose_index()` with the empty stake weights: [5](#0-4) 

The `choose_index()` function calculates a total weight of 0 for the empty vector and calls `next_in_range()` with `max = 0`: [6](#0-5) 

The `next_in_range()` function performs a modulo operation by zero, causing a panic: [7](#0-6) 

**Step 5: Network Halt**

This panic occurs during the normal consensus flow when trying to advance to a new round: [8](#0-7) 

All consensus nodes crash when attempting to select a proposer, causing complete network liveness failure.

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program:

- **Non-recoverable network partition (requires hardfork)**: Once the validator set becomes empty, all nodes crash when trying to select a proposer. The network cannot recover because every node will panic at the same point. Recovery requires a hard fork to inject a valid validator set.

- **Total loss of liveness/network availability**: No blocks can be produced once this condition is triggered, as proposer election is essential for consensus progress.

The vulnerability breaks the following critical invariants:
1. **Consensus Safety**: The network can no longer maintain consensus as all nodes crash
2. **Deterministic Execution**: The panic prevents any execution from occurring

## Likelihood Explanation

While this requires all validators to fall below the minimum stake, several realistic scenarios could trigger this:

1. **Natural validator churn**: In early network deployments with few validators, mass exits or performance issues could cause all validators to fall below minimum stake simultaneously.

2. **Governance attack**: A malicious governance proposal could increase the minimum stake requirement to a value exceeding all current validators' stakes.

3. **Cascading slashing**: If the network experiences severe issues causing all validators to be slashed, they could simultaneously drop below the minimum threshold.

4. **Economic conditions**: During periods of low participation or economic stress, validators might reduce their stakes below the minimum.

The likelihood is moderate to low on mainnet with many validators, but **very high** in:
- Testnets with limited validators
- New network deployments
- Networks under governance attacks
- Edge cases during development

## Recommendation

Add validation at multiple layers to prevent empty validator sets:

**1. In stake.move on_new_epoch():**
```move
// After line 1401
validator_set.active_validators = next_epoch_validators;
assert!(vector::length(&validator_set.active_validators) > 0, 
    error::invalid_state(ENO_ACTIVE_VALIDATORS));
```

**2. In ValidatorVerifier::new():**
```rust
pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
    assert!(!validator_infos.is_empty(), 
        "ValidatorVerifier cannot be created with empty validator set");
    let total_voting_power = sum_voting_power(&validator_infos);
    let quorum_voting_power = total_voting_power * 2 / 3 + 1;
    Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
}
```

**3. In LeaderReputation::new():**
```rust
pub fn new(...) -> Self {
    assert!(epoch_to_proposers.contains_key(&epoch));
    let proposers = &epoch_to_proposers[&epoch];
    assert!(!proposers.is_empty(), "Proposer set cannot be empty");
    assert_eq!(proposers.len(), voting_powers.len());
    // ... rest of constructor
}
```

**4. In choose_index() as defense-in-depth:**
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    assert!(!weights.is_empty(), "Cannot choose from empty weights vector");
    // ... rest of function
}
```

The primary fix should be in the staking module to prevent empty validator sets from ever being created, with additional defensive checks in the Rust consensus code.

## Proof of Concept

**Rust Test:**
```rust
#[test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
fn test_choose_index_empty_weights_panic() {
    use consensus::liveness::proposer_election::choose_index;
    
    // Create empty weights vector
    let weights: Vec<u128> = vec![];
    let state = vec![1, 2, 3, 4]; // arbitrary state
    
    // This will panic with division by zero
    let _ = choose_index(weights, state);
}
```

**Move Test Scenario:**
```move
#[test(aptos_framework = @0x1)]
#[expected_failure(abort_code = ENO_ACTIVE_VALIDATORS)]
fun test_empty_validator_set_prevented(aptos_framework: &signer) {
    // Setup: Create validators with stakes below minimum
    // ... setup code ...
    
    // Increase minimum stake above all validators
    staking_config::update_required_stake(aptos_framework, 1000000000000, 1000000000000);
    
    // Trigger epoch change - should abort with ENO_ACTIVE_VALIDATORS
    stake::on_new_epoch();
}
```

**Impact Demonstration:**
1. Deploy network with minimal validators
2. Have all validators reduce stake or increase minimum requirement via governance
3. Trigger epoch transition 
4. Observe all consensus nodes panic with "division by zero" when attempting proposer selection
5. Network becomes permanently stuck, requiring hard fork to recover

**Notes**

The vulnerability demonstrates a critical gap in validator set validation across the stack. While the Move layer has checks preventing the last validator from leaving (`ELAST_VALIDATOR` error), it lacks protection against all validators simultaneously falling below the minimum stake threshold. The Rust consensus layer assumes validator sets are always non-empty, creating a critical failure mode.

This is a genuine architectural vulnerability requiring defense-in-depth fixes at multiple layers: on-chain staking logic, validator verifier construction, and proposer election. The primary fix should be in `stake.move` to make empty validator sets impossible, with additional assertions in Rust code as safety nets.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1401)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** consensus/src/epoch_manager.rs (L292-295)
```rust
        let proposers = epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .collect::<Vec<_>>();
```

**File:** consensus/src/liveness/leader_reputation.rs (L579-580)
```rust
        assert!(epoch_to_proposers.contains_key(&epoch));
        assert_eq!(epoch_to_proposers[&epoch].len(), voting_powers.len());
```

**File:** consensus/src/liveness/leader_reputation.rs (L732-732)
```rust
        let chosen_index = choose_index(stake_weights, state);
```

**File:** consensus/src/liveness/proposer_election.rs (L39-46)
```rust
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    // hash = SHA-3-256(state)
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    // return hash[0..16]
    u128::from_le_bytes(temp) % max
}
```

**File:** consensus/src/liveness/proposer_election.rs (L49-59)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
```

**File:** consensus/src/round_manager.rs (L428-430)
```rust
        let prev_proposer = self
            .proposer_election
            .get_valid_proposer(new_round.saturating_sub(1));
```
