# Audit Report

## Title
Backup Restore Signature Verification Bypass Allows Injection of Unvalidated Transactions

## Summary
The transaction backup restore system contains a critical vulnerability where BLS signature verification of `LedgerInfoWithSignatures` can be completely bypassed when restoring backups. This occurs when the `--skip-epoch-endings` CLI flag is used or when epoch data is missing, allowing an attacker to restore malicious backups containing fake transactions that were never validated by the validator quorum.

## Finding Description

The Aptos backup/restore system is designed to restore blockchain state from backup files. Each transaction backup chunk includes a proof file containing a `TransactionAccumulatorRangeProof` and a `LedgerInfoWithSignatures` that commits to the transactions via BLS signatures from 2f+1 validators. [1](#0-0) 

The critical security flaw exists in the restore process where signature verification is conditionally skipped: [2](#0-1) 

The verification is skipped when `epoch_history` is `None`. This happens in three attack scenarios:

**Attack Path 1 - `--skip-epoch-endings` Flag:**
The restore coordinator exposes a CLI flag that sets `epoch_history` to `None`: [3](#0-2) [4](#0-3) 

**Attack Path 2 - Oneoff Restore:**
The db-tool oneoff restore command explicitly passes `None` for epoch_history: [5](#0-4) 

**Attack Path 3 - Epoch Too New:**
Even when `epoch_history` is provided, if the `LedgerInfo` has an epoch newer than the epoch history, verification is skipped with only a warning: [6](#0-5) 

When signature verification is bypassed, only Merkle proof verification occurs: [7](#0-6) [8](#0-7) 

This Merkle proof verification only confirms that transaction infos are consistent with the accumulator root in the `LedgerInfo`, but **does NOT verify that the LedgerInfo was signed by validators**. An attacker can craft valid Merkle proofs for any set of fake transactions.

The unverified transactions are then written directly to the database: [9](#0-8) 

**Exploitation Steps:**

1. Attacker crafts a malicious backup containing:
   - Fake transactions (e.g., minting tokens to attacker's account)
   - Corresponding `TransactionInfo` objects with correct hashes
   - A `TransactionAccumulatorRangeProof` linking the infos to a fake accumulator root
   - A `LedgerInfoWithSignatures` with the fake root but **stripped/invalid signatures**

2. Attacker provides this backup to a node operator (via social engineering, compromised backup storage, or man-in-the-middle attack)

3. Node operator restores using:
   - `aptos-db-tool restore bootstrap-db --skip-epoch-endings` (debugging flag)
   - `aptos-db-tool restore oneoff transaction` (no epoch verification)
   - Or regular restore with incomplete epoch history

4. The malicious transactions bypass signature verification and are written to the database as valid ledger history

5. The node now has a corrupted ledger containing fake transactions that never achieved validator consensus

## Impact Explanation

This is **CRITICAL SEVERITY** (up to $1,000,000) per Aptos bug bounty criteria:

- **Consensus Safety Violation**: The fundamental invariant "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" is broken. Transactions can enter the ledger without 2f+1 validator signatures.

- **Loss of Funds**: Fake transactions can mint tokens, transfer funds, or modify balances arbitrarily, leading to theft or unauthorized minting.

- **State Consistency Violation**: The invariant "State Consistency: State transitions must be atomic and verifiable via Merkle proofs" is violated. State changes occur without cryptographic validation.

- **Cryptographic Correctness**: The invariant "Cryptographic Correctness: BLS signatures must be secure" is completely bypassed.

The impact is network-wide: any node restoring from a malicious backup will have a forked ledger state diverging from the legitimate chain. This requires manual intervention or a hard fork to resolve.

## Likelihood Explanation

**High Likelihood:**

1. **Accessible Attack Surface**: The `--skip-epoch-endings` flag is documented and accessible in production builds via `aptos-debugger aptos-db restore`

2. **Legitimate Use Case Confusion**: The flag is documented as "used for debugging" but is available in production code, making it likely that operators use it incorrectly

3. **Oneoff Restore Exposure**: The oneoff transaction restore command is a legitimate operation that inherently bypasses signature verification

4. **Social Engineering Vector**: Attackers can provide malicious backups through compromised storage, MITM attacks, or social engineering against node operators

5. **No Runtime Validation**: Once restored, there's no subsequent validation that catches the fake transactions

The only barrier is convincing a node operator to restore from the attacker's backup, which is feasible through various attack vectors.

## Recommendation

**Immediate Fix:**

1. **Remove the `--skip-epoch-endings` flag** from production code or make it only available in test/debug builds with explicit warnings

2. **Make epoch_history mandatory** for transaction restore operations:

```rust
// In LoadedChunk::load()
async fn load(
    manifest: TransactionChunk,
    storage: &Arc<dyn BackupStorage>,
    epoch_history: &Arc<EpochHistory>, // Remove Option, make mandatory
) -> Result<Self> {
    // ... existing code ...
    
    let (range_proof, ledger_info) = storage
        .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
            &manifest.proof,
        )
        .await?;
    
    // Always verify - no conditional logic
    epoch_history.verify_ledger_info(&ledger_info)?;
    
    // ... rest of code ...
}
```

3. **Fix the "epoch too new" bypass** in `EpochHistory::verify_ledger_info()`:

```rust
pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
    let epoch = li_with_sigs.ledger_info().epoch();
    ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.");
    
    // Remove the bypass - make it an error instead
    ensure!(
        epoch <= self.epoch_endings.len() as u64,
        "LedgerInfo epoch {} is newer than epoch history (up to epoch {}). \
        Cannot verify signatures without complete epoch history.",
        epoch,
        self.epoch_endings.len() - 1
    );
    
    // ... rest of verification logic ...
}
```

4. **Add explicit validation** in `RestoreCoordinator::new()`:

```rust
pub fn new(
    opt: RestoreCoordinatorOpt,
    global_opt: GlobalRestoreOptions,
    storage: Arc<dyn BackupStorage>,
) -> Self {
    // Fail fast if skip_epoch_endings is used in production
    if opt.skip_epoch_endings {
        panic!(
            "SECURITY ERROR: --skip-epoch-endings bypasses signature verification. \
            This flag must not be used in production environments."
        );
    }
    // ... rest of constructor ...
}
```

5. **Add post-restore validation**: After restore completes, verify that all ledger infos in the database have valid epoch states

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_signature_bypass_vulnerability() {
    use aptos_types::{
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        transaction::{Transaction, TransactionInfo, Version},
        proof::TransactionAccumulatorRangeProof,
    };
    use aptos_crypto::HashValue;
    
    // Step 1: Create a malicious backup
    let fake_txn = Transaction::GenesisTransaction(/* fake genesis */);
    let fake_txn_info = TransactionInfo::new(
        HashValue::random(),  // fake transaction hash
        HashValue::zero(),    // fake state root
        HashValue::zero(),    // fake event root
        None,                 // no state checkpoint
        0,                    // gas used
        ExecutionStatus::Success,
    );
    
    // Create a LedgerInfo with fake accumulator root
    let fake_ledger_info = LedgerInfo::new(
        /* ... fake block info ... */,
        HashValue::random(), // fake transaction accumulator root
    );
    
    // Create LedgerInfoWithSignatures with EMPTY or INVALID signatures
    let fake_ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        AggregateSignature::empty(), // NO SIGNATURES!
    );
    
    // Create a valid-looking Merkle proof (can be crafted for any data)
    let fake_proof = TransactionAccumulatorRangeProof::new(/* ... */);
    
    // Step 2: Write this to a backup file
    let backup_data = bcs::to_bytes(&(fake_proof, fake_ledger_info_with_sigs))?;
    storage.write_proof_file(backup_data).await?;
    
    // Step 3: Restore with --skip-epoch-endings (epoch_history = None)
    let restore_controller = TransactionRestoreController::new(
        opt,
        global_opt,
        storage,
        None, // <-- THIS BYPASSES SIGNATURE VERIFICATION
        VerifyExecutionMode::NoVerify,
    );
    
    restore_controller.run().await?;
    
    // Step 4: Verify the fake transaction is now in the database
    let db_txn = db.get_transaction_by_version(version)?;
    assert_eq!(db_txn, fake_txn); // FAKE TRANSACTION IS IN THE LEDGER!
    
    // The node now has a forked ledger with unvalidated transactions
}
```

**Notes:**

The vulnerability exists because the backup system treats signature verification as optional rather than mandatory. The `--skip-epoch-endings` flag was likely intended for testing/debugging but remains accessible in production builds, creating a critical security bypass. Any node operator who uses this flag or the oneoff restore command can have malicious transactions injected into their database without any cryptographic validation by the validator set.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L19-34)
```rust
#[derive(Clone, Deserialize, Serialize, Debug)]
pub struct TransactionChunk {
    pub first_version: Version,
    pub last_version: Version,
    /// Repeated `len(record) + record`, where `record` is BCS serialized tuple
    /// `(Transaction, TransactionInfo)`
    pub transactions: FileHandle,
    /// BCS serialized `(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)`.
    /// The `TransactionAccumulatorRangeProof` links the transactions to the
    /// `LedgerInfoWithSignatures`, and the `LedgerInfoWithSignatures` can be verified by the
    /// signatures it carries, against the validator set in the epoch. (Hence proper
    /// `EpochEndingBackup` is needed for verification.)
    pub proof: FileHandle,
    #[serde(default = "default_to_v0")]
    pub format: TransactionChunkFormat,
}
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L147-154)
```rust
        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L507-517)
```rust
                        tokio::task::spawn_blocking(move || {
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
                        })
                        .await??;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L42-43)
```rust
    #[clap(long, help = "Skip restoring epoch ending info, used for debugging.")]
    pub skip_epoch_endings: bool,
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/db-tool/src/restore.rs (L102-110)
```rust
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-288)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
```

**File:** types/src/transaction/mod.rs (L2334-2336)
```rust
        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;
```

**File:** types/src/proof/definition.rs (L910-925)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_info_version: Option<Version>,
    ) -> Result<()> {
        let txn_info_hashes: Vec<_> = self
            .transaction_infos
            .iter()
            .map(CryptoHash::hash)
            .collect();
        self.ledger_info_to_transaction_infos_proof.verify(
            ledger_info.transaction_accumulator_hash(),
            first_transaction_info_version,
            &txn_info_hashes,
        )
    }
```
