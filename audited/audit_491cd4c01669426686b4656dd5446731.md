# Audit Report

## Title
Incomplete Test Native Validation Allows Debug Functionality in Production via Feature Unification

## Summary
The `assert_no_test_natives()` validation in the production validator node does not check for debug module natives, allowing them to bypass the safety check if testing features are accidentally enabled through Cargo feature unification. This creates a gap in the defense-in-depth strategy against production builds with test functionality.

## Finding Description

The Aptos validator node includes a runtime safety check to prevent accidental inclusion of test-only native functions: [1](#0-0) 

This check validates that specific test natives are not present in the native function table: [2](#0-1) 

However, the validation is incomplete. It only checks for:
- `unit_test::create_signers_for_testing`
- Cryptography test functions (`generate_keys_internal`, `sign_internal`)
- `event::emitted_events_internal`

The debug module natives are **not validated** despite being conditionally functional based on the `testing` feature flag: [3](#0-2) 

The debug natives are always registered in the native function table: [4](#0-3) 

These natives have corresponding public Move functions that can be called by any deployed contract: [5](#0-4) 

**Attack Scenario:**
1. Operator builds `aptos-node` in an environment where Cargo feature unification enables the `testing` feature (e.g., building with other test tools, using `--all-features`, or transitive dependencies)
2. The `assert_no_test_natives()` check passes because it doesn't verify debug natives
3. The validator node starts successfully
4. An attacker deploys a Move contract that calls `aptos_std::debug::print()` or `debug::print_stack_trace()`
5. Sensitive information (stack traces, internal state) leaks to validator logs
6. Different validators may have different feature flags, causing non-deterministic behavior

The developers are aware of feature unification issues: [6](#0-5) 

## Impact Explanation

**High Severity** - This meets the criteria for significant protocol violations:

1. **Information Disclosure**: Stack traces and debug output could leak sensitive validator state, transaction details, or internal VM execution flows
2. **Non-Deterministic Execution**: If validators have different feature flags, debug prints could affect timing or execution paths, potentially causing consensus divergence
3. **Defense-in-Depth Failure**: The safety check that should catch this scenario has a gap, allowing test functionality to slip into production
4. **DoS Potential**: Excessive debug printing could slow down validator nodes

This does not quite reach Critical severity as it requires operator error and doesn't directly cause fund loss or consensus breaks, but represents a significant security control failure.

## Likelihood Explanation

**Medium Likelihood**: While this requires operator error, the risk is real:

1. **Feature Unification**: Cargo's feature unification can unexpectedly enable features when building multiple crates together
2. **CI/CD Complexity**: Complex build pipelines might inadvertently enable testing features
3. **Incomplete Validation**: The existing check creates false confidence that all test natives are validated
4. **Public Functions**: The debug functions are public in Move, so any contract can call them

The explicit error message shows this is a known concern, making it more likely to occur than purely theoretical issues.

## Recommendation

Add debug module natives to the `assert_no_test_natives()` validation:

```rust
pub fn assert_no_test_natives(err_msg: &str) {
    assert!(
        aptos_natives(
            LATEST_GAS_FEATURE_VERSION,
            NativeGasParameters::zeros(),
            MiscGasParameters::zeros(),
            TimedFeaturesBuilder::enable_all().build(),
            Features::default()
        )
        .into_iter()
        .all(|(_, module_name, func_name, _)| {
            !(module_name.as_str() == "unit_test"
                && func_name.as_str() == "create_signers_for_testing"
                // ... existing checks ...
                || module_name.as_str() == "debug"
                    && func_name.as_str() == "native_print"
                || module_name.as_str() == "debug"
                    && func_name.as_str() == "native_stack_trace")
        }),
        "{}",
        err_msg
    )
}
```

Alternatively, modify debug natives to use `#[cfg(feature = "testing")]` at registration time instead of runtime checks, ensuring they're completely excluded from production builds.

## Proof of Concept

**Step 1**: Build aptos-node with testing features:
```bash
cd aptos-node
cargo build --features testing
```

**Step 2**: The assert_no_test_natives() check will pass despite debug natives being functional (verify in source).

**Step 3**: Deploy a Move contract that calls debug functions:
```move
module attacker::leak_info {
    use aptos_std::debug;
    
    public entry fun leak_stack_trace() {
        debug::print_stack_trace();  // Leaks internal VM state to logs
    }
}
```

**Step 4**: Execute the contract - debug output will appear in validator logs if testing features were enabled, but the node started successfully.

**Notes**

The validation gap exists because debug natives use runtime feature checks (`cfg!(feature = "testing")`) instead of compile-time exclusion (`#[cfg(feature = "testing")]`), yet the assertion doesn't verify them. This represents an incomplete implementation of the defense-in-depth strategy documented in the error message about feature unification.

### Citations

**File:** aptos-node/src/main.rs (L21-23)
```rust
fn main() {
    // Check that we are not including any Move test natives
    aptos_vm::natives::assert_no_test_natives(ERROR_MSG_BAD_FEATURE_FLAGS);
```

**File:** aptos-move/aptos-vm/src/natives.rs (L161-191)
```rust
pub fn assert_no_test_natives(err_msg: &str) {
    assert!(
        aptos_natives(
            LATEST_GAS_FEATURE_VERSION,
            NativeGasParameters::zeros(),
            MiscGasParameters::zeros(),
            TimedFeaturesBuilder::enable_all().build(),
            Features::default()
        )
        .into_iter()
        .all(|(_, module_name, func_name, _)| {
            !(module_name.as_str() == "unit_test"
                && func_name.as_str() == "create_signers_for_testing"
                || module_name.as_str() == "ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "multi_ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "multi_ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "bls12381" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_proof_of_possession_internal"
                || module_name.as_str() == "event"
                    && func_name.as_str() == "emitted_events_internal")
        }),
        "{}",
        err_msg
    )
}
```

**File:** aptos-move/framework/src/natives/debug.rs (L28-47)
```rust
fn native_print(
    _: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.is_empty());
    debug_assert!(args.len() == 1);

    if cfg!(feature = "testing") {
        let val = safely_pop_arg!(args, Struct);
        let bytes = val.unpack()?.next().unwrap();

        println!(
            "[debug] {}",
            std::str::from_utf8(&bytes.value_as::<Vec<u8>>()?).unwrap()
        );
    }

    Ok(smallvec![])
}
```

**File:** aptos-move/framework/src/natives/mod.rs (L88-88)
```rust
    add_natives_from_module!("debug", debug::make_all(builder));
```

**File:** aptos-move/framework/aptos-stdlib/sources/debug.move (L5-11)
```text
    public fun print<T>(x: &T) {
        native_print(format(x));
    }

    public fun print_stack_trace() {
        native_print(native_stack_trace());
    }
```

**File:** aptos-node/src/utils.rs (L19-29)
```rust
/// Error message to display when non-production features are enabled
pub const ERROR_MSG_BAD_FEATURE_FLAGS: &str = r#"
aptos-node was compiled with feature flags that shouldn't be enabled.

This is caused by cargo's feature unification.
When you compile two crates with a shared dependency, if one enables a feature flag for the dependency, then it is also enabled for the other crate.

To resolve this issue, try the following methods:
- Recompile `aptos-node` SEPARATELY
- Check if a disallowed feature flag is enabled by a dependency in the build tree
"#;
```
