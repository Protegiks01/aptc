# Audit Report

## Title
Cross-Block Type Confusion in GlobalModuleCache Due to Fresh StructNameIndexMap Per Environment

## Summary
The GlobalModuleCache persists verified Module instances across blocks without flushing when on-chain configuration remains unchanged. However, each block creates a fresh RuntimeEnvironment with a new StructNameIndexMap. This causes cached modules containing StructNameIndex values from one RuntimeEnvironment to be reused in a different RuntimeEnvironment with a different StructNameIndexMap, leading to type confusion where struct types from different modules can be confused with each other.

## Finding Description

The vulnerability occurs in the interaction between the global module caching system and the RuntimeEnvironment lifecycle management.

**Root Cause Chain:**

1. **Fresh RuntimeEnvironment per block**: Every time `AptosModuleCacheManager::try_lock_inner` is called, it creates a NEW `AptosEnvironment` instance: [1](#0-0) 

2. **Fresh StructNameIndexMap per RuntimeEnvironment**: Each `AptosEnvironment` creates a fresh `RuntimeEnvironment` with a brand new `StructNameIndexMap`: [2](#0-1) [3](#0-2) 

3. **Environment equality based on hash, not instance**: The `check_ready` function compares environments using `PartialEq`, which compares configuration hashes, NOT instance identity: [4](#0-3) [5](#0-4) 

4. **Module caching preserves StructNameIndex values**: When modules are built, they contain StructTypes with StructNameIndex values assigned by the current StructNameIndexMap: [6](#0-5) 

5. **Cached modules retrieved without re-validation**: The GlobalModuleCache returns cached modules as-is: [7](#0-6) 

**Exploitation Path:**

**Block N:**
- RuntimeEnvironment_N is created with fresh StructNameIndexMap_N
- Module M1 containing struct `Foo` is loaded first
- `StructIdentifier(M1::Foo)` → `StructNameIndex(0)` in Map_N
- Module M2 containing struct `Bar` is loaded second  
- `StructIdentifier(M2::Bar)` → `StructNameIndex(1)` in Map_N
- Modules cached in GlobalModuleCache with these indices

**Block N+1:**
- RuntimeEnvironment_N+1 is created with fresh StructNameIndexMap_N+1
- Config hash unchanged, so cache NOT flushed per `check_ready`
- Module M2 is loaded FIRST (different transaction ordering)
- `StructIdentifier(M2::Bar)` → `StructNameIndex(0)` in Map_N+1
- Module M1 retrieved from cache (still has idx=0 for Foo)
- When `Type::Struct{idx: 0}` from M1 is used, native functions call `idx_to_struct_name(0)` on Map_N+1
- Map_N+1 returns `M2::Bar` instead of `M1::Foo` - **TYPE CONFUSION!**

The StructNameIndex assignment is order-dependent: [8](#0-7) 

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This vulnerability breaks the **"Deterministic Execution"** invariant (Invariant #1). Different validators will:

1. **Experience different module loading orders** due to transaction propagation timing, mempool ordering variations, or deliberate attacker manipulation
2. **Build different StructNameIndexMap state** across blocks with different index assignments for the same structs
3. **Interpret cached StructNameIndex values differently**, causing the same Type to resolve to different structs on different validators
4. **Produce different execution results** when native functions or VM operations perform type-dependent logic
5. **Generate different state roots** for identical blocks, causing consensus failure

This satisfies the **Critical Severity** criteria:
- **Consensus/Safety violations**: Different validators execute identical transactions differently
- **Non-recoverable network partition**: Once validators diverge, the chain cannot progress without manual intervention or rollback
- Requires no privileged access - any transaction sender can trigger module loading

## Likelihood Explanation

**High Likelihood:**

1. **Automatic trigger**: Happens automatically when:
   - Two consecutive blocks have unchanged on-chain configuration (common)
   - Module loading order differs between blocks (common with varying transaction ordering)
   
2. **No special privileges required**: Any user can submit transactions that load modules

3. **Non-determinism inherent to system**: Transaction ordering varies naturally across validators due to:
   - Network latency differences
   - Mempool priority variations
   - Parallel execution scheduling

4. **No explicit safeguards**: The system does not validate StructNameIndex consistency across RuntimeEnvironment boundaries

## Recommendation

**Immediate Fix**: Flush the module cache whenever a new RuntimeEnvironment instance is created, regardless of configuration hash equality.

**Option 1 - Track RuntimeEnvironment Instance Identity:**

```rust
// In ModuleCacheManager
struct ModuleCacheManager<K, D, V, E> {
    transaction_slice_metadata: TransactionSliceMetadata,
    environment: Option<AptosEnvironment>,
    // Add: Track RuntimeEnvironment identity via pointer equality
    runtime_env_identity: Option<*const RuntimeEnvironment>,
    module_cache: GlobalModuleCache<K, D, V, E>,
}

fn check_ready(&mut self, storage_environment: AptosEnvironment, ...) -> Result<(), VMStatus> {
    let new_runtime_env_ptr = storage_environment.runtime_environment() as *const _;
    
    // Check if RuntimeEnvironment instance changed (pointer inequality)
    let runtime_env_changed = self.runtime_env_identity
        .map_or(true, |old_ptr| old_ptr != new_runtime_env_ptr);
    
    if runtime_env_changed {
        self.module_cache.flush();
        self.runtime_env_identity = Some(new_runtime_env_ptr);
    }
    
    self.environment = Some(storage_environment);
    // ... rest of checks
}
```

**Option 2 - Share RuntimeEnvironment Across Blocks (Preferred):**

Modify `try_lock_inner` to reuse existing RuntimeEnvironment when configuration unchanged:

```rust
fn try_lock_inner(&self, state_view: &impl StateView, ...) -> Result<...> {
    let mut guard = self.inner.try_lock()?;
    
    // Check if we can reuse existing environment
    if let Some(existing_env) = &guard.environment {
        let config_changed = /* compute config hash and compare */;
        if !config_changed {
            // Reuse existing environment (shares RuntimeEnvironment)
            guard.check_ready_with_existing_env(...)?;
            return Ok(AptosModuleCacheManagerGuard::Guard { guard });
        }
    }
    
    // Only create new environment if config changed
    let storage_environment = AptosEnvironment::new_with_delayed_field_optimization_enabled(state_view);
    guard.check_ready(storage_environment, ...)?;
    Ok(AptosModuleCacheManagerGuard::Guard { guard })
}
```

## Proof of Concept

```rust
// Pseudo-code demonstrating the vulnerability

// Block N
let env_n = RuntimeEnvironment::new_with_config(natives, config);
let map_n = env_n.struct_name_index_map();

// Load M1::Foo first
let foo_id = StructIdentifier::new(pool, module_m1, "Foo");
let foo_idx = map_n.struct_name_to_idx(&foo_id)?; // Gets idx=0

// Load M2::Bar second
let bar_id = StructIdentifier::new(pool, module_m2, "Bar");
let bar_idx = map_n.struct_name_to_idx(&bar_id)?; // Gets idx=1

// Cache module M1 with Foo having idx=0
let module_m1 = Module::new(natives, size, compiled_m1, map_n, ...)?;
global_cache.insert(module_m1_id, module_m1.clone());

// Block N+1 with same config
let env_n1 = RuntimeEnvironment::new_with_config(natives, config);
let map_n1 = env_n1.struct_name_index_map(); // FRESH MAP!

// Config unchanged, cache NOT flushed
assert_eq!(env_n.vm_config().hash(), env_n1.vm_config().hash());

// Load M2::Bar FIRST this time
let bar_idx_n1 = map_n1.struct_name_to_idx(&bar_id)?; // Gets idx=0 (!)

// Retrieve M1 from cache
let cached_m1 = global_cache.get(&module_m1_id).unwrap();

// cached_m1 still has Foo with idx=0
// But in map_n1, idx=0 now maps to M2::Bar!
let resolved = map_n1.idx_to_struct_name(StructNameIndex(0))?;
assert_eq!(resolved.name(), "Bar"); // Wrong! Should be "Foo"

// Type confusion achieved: M1::Foo is interpreted as M2::Bar
```

**Notes**

This vulnerability demonstrates a fundamental design flaw in the caching architecture where stateful index mappings (StructNameIndexMap) are not properly synchronized with cached data structures (Modules) that reference those indices. The issue is exacerbated by the non-deterministic nature of module loading order across validators, making consensus failures inevitable under normal operation.

### Citations

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L115-130)
```rust
        let environment_requires_update = self.environment.as_ref() != Some(&storage_environment);
        if environment_requires_update {
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
            }

            self.environment = Some(storage_environment);
            self.module_cache.flush();
        }
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L211-213)
```rust
        // Get the current environment from storage.
        let storage_environment =
            AptosEnvironment::new_with_delayed_field_optimization_enabled(&state_view);
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L152-155)
```rust
impl PartialEq for AptosEnvironment {
    fn eq(&self, other: &Self) -> bool {
        self.0.hash == other.0.hash
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L285-285)
```rust
        let runtime_environment = RuntimeEnvironment::new_with_config(natives, vm_config);
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L103-116)
```rust
    pub fn new_with_config(
        natives: impl IntoIterator<Item = (AccountAddress, Identifier, Identifier, NativeFunction)>,
        vm_config: VMConfig,
    ) -> Self {
        let natives = NativeFunctions::new(natives)
            .unwrap_or_else(|e| panic!("Failed to create native functions: {}", e));
        Self {
            vm_config,
            natives,
            struct_name_index_map: Arc::new(StructNameIndexMap::empty()),
            ty_tag_cache: Arc::new(TypeTagCache::empty()),
            interned_ty_pool: Arc::new(InternedTypePool::new()),
            interned_module_id_pool: Arc::new(InternedModuleIdPool::new()),
        }
```

**File:** third_party/move/move-vm/runtime/src/loader/modules.rs (L191-203)
```rust
        let mut struct_idxs = vec![];
        let mut struct_names = vec![];

        // validate the correctness of struct handle references.
        for struct_handle in module.struct_handles() {
            let struct_name = module.identifier_at(struct_handle.name);
            let module_handle = module.module_handle_at(struct_handle.module);
            let module_id = module.module_id_for_handle(module_handle);
            let struct_name =
                StructIdentifier::new(module_id_pool, module_id, struct_name.to_owned());
            struct_idxs.push(struct_name_index_map.struct_name_to_idx(&struct_name)?);
            struct_names.push(struct_name)
        }
```

**File:** aptos-move/block-executor/src/code_cache.rs (L156-162)
```rust
                if let Some(module) = self.global_module_cache.get(key) {
                    state
                        .captured_reads
                        .borrow_mut()
                        .capture_global_cache_read(key.clone(), module.clone());
                    return Ok(Some((module, Self::Version::default())));
                }
```

**File:** third_party/move/move-vm/types/src/loaded_data/struct_name_indexing.rs (L85-96)
```rust
        let idx = {
            let mut index_map = self.0.write();

            if let Some(idx) = index_map.forward_map.get(struct_name) {
                return Ok(StructNameIndex(*idx));
            }

            let idx = index_map.backward_map.len() as u32;
            index_map.backward_map.push(backward_value);
            index_map.forward_map.insert(forward_key, idx);
            idx
        };
```
