# Audit Report

## Title
State Merkle Pruner Lacks Batching Threshold Check Leading to Excessive Pruning Operations Under High Throughput

## Summary
The `maybe_set_pruner_target_db_version()` function in the State Merkle Pruner Manager lacks a batching threshold check present in both the Ledger Pruner and State KV Pruner. This causes the state merkle pruner to trigger on every state snapshot commit after reaching the prune window, creating continuous database I/O operations that can degrade validator performance under high transaction throughput.

## Finding Description

The State Merkle Pruner Manager implements an inconsistent wake-up condition compared to other pruners in the system:

**State Merkle Pruner** checks only `latest_version >= min_readable_version + prune_window` [1](#0-0) 

**Ledger Pruner** checks `latest_version >= min_readable_version + pruning_batch_size + prune_window` [2](#0-1) 

**State KV Pruner** checks `latest_version >= min_readable_version + pruning_batch_size + prune_window` [3](#0-2) 

With default configuration (prune_window = 1,000,000, batch_size = 1,000) [4](#0-3) , the Ledger and State KV pruners trigger approximately every 1,000 commits, while the State Merkle Pruner triggers on every single commit.

The issue occurs because:

1. After every state snapshot commit, `maybe_set_pruner_target_db_version()` is called [5](#0-4) 

2. When triggered, `set_pruner_target_db_version()` updates `min_readable_version = latest_version - prune_window` [6](#0-5) 

3. On the next commit, the condition `latest_version >= min_readable_version + prune_window` becomes `(latest_version + 1) >= latest_version`, which is always true

4. The pruner worker continuously executes without sleeping when `is_pruning_pending()` returns true [7](#0-6) , which checks `target_version > progress` [8](#0-7) 

The root cause is that `StateMerklePrunerManager` lacks the `pruning_batch_size` field [9](#0-8)  that exists in both `LedgerPrunerManager` [10](#0-9)  and `StateKvPrunerManager` [11](#0-10) .

## Impact Explanation

**High Severity** - This qualifies as "Validator Node Slowdowns" per Aptos bug bounty criteria.

Under normal blockchain operation at moderate to high throughput (100+ TPS):

1. **Continuous CPU Usage**: The pruner worker thread runs continuously without sleep periods, consuming CPU cycles that should be available for consensus operations

2. **Database I/O Contention**: Excessive pruning operations create continuous read/write pressure on the database, competing with consensus block processing and state commitment operations

3. **Validator Performance Degradation**: The cumulative effect can slow down validator operations, potentially causing delayed block processing, slower consensus participation, increased risk of missing rounds, and degraded validator reputation

4. **Scalability Impact**: As blockchain throughput increases toward Aptos's target of 1000+ TPS, this inefficiency becomes more severe, with the pruner being updated 1000+ times per second

While modern hardware may currently mask this issue, it represents a design flaw that creates unnecessary resource contention and will become increasingly problematic at scale.

## Likelihood Explanation

**Very High** - This issue manifests automatically under normal blockchain operation once the chain reaches 1 million versions (approximately 2-3 hours at 100 TPS).

No attacker action is required. The issue is a design flaw affecting all validator nodes running with default pruner configuration. The mathematical certainty of the trigger condition means every validator experiences this inefficiency continuously after the initial prune window is reached.

## Recommendation

Add a `pruning_batch_size` field to `StateMerklePrunerManager` and update the wake-up condition to match the pattern used by Ledger Pruner and State KV Pruner:

```rust
pub struct StateMerklePrunerManager<S: StaleNodeIndexSchemaTrait> {
    state_merkle_db: Arc<StateMerkleDb>,
    prune_window: Version,
    pruning_batch_size: usize,  // Add this field
    pruner_worker: Option<PrunerWorker>,
    min_readable_version: AtomicVersion,
    _phantom: PhantomData<S>,
}

fn maybe_set_pruner_target_db_version(&self, latest_version: Version) {
    let min_readable_version = self.get_min_readable_version();
    // Add pruning_batch_size to condition
    if self.is_pruner_enabled() 
        && latest_version >= min_readable_version + self.pruning_batch_size as u64 + self.prune_window 
    {
        self.set_pruner_target_db_version(latest_version);
    }
}
```

Initialize `pruning_batch_size` from `StateMerklePrunerConfig.batch_size` in the constructor, consistent with the other pruner managers.

## Proof of Concept

This can be observed through metrics monitoring:
1. Deploy a validator node with default pruner configuration
2. Monitor the `PRUNER_VERSIONS` metric for `state_merkle_pruner` with label `target`
3. After reaching 1M versions, observe the target version is updated on every state snapshot commit (multiple times per second at normal TPS)
4. Compare with `ledger_pruner` target version, which updates approximately every 1000 commits

The continuous updating of the target version and corresponding pruner worker activity can be observed through system monitoring tools showing constant CPU usage and I/O operations from the pruner thread.

## Notes

This is a design consistency issue where the State Merkle Pruner diverges from the established pattern used by both Ledger Pruner and State KV Pruner. The batching threshold serves an important purpose in preventing excessive wake-ups, and its absence in the State Merkle Pruner creates unnecessary resource contention that impacts validator performance at scale.

### Citations

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs (L33-46)
```rust
pub struct StateMerklePrunerManager<S: StaleNodeIndexSchemaTrait>
where
    StaleNodeIndex: KeyCodec<S>,
{
    state_merkle_db: Arc<StateMerkleDb>,
    /// DB version window, which dictates how many versions of state merkle data to keep.
    prune_window: Version,
    /// It is None iff the pruner is not enabled.
    pruner_worker: Option<PrunerWorker>,
    /// The minimal readable version for the state merkle data.
    min_readable_version: AtomicVersion,

    _phantom: PhantomData<S>,
}
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs (L67-72)
```rust
    fn maybe_set_pruner_target_db_version(&self, latest_version: Version) {
        let min_readable_version = self.get_min_readable_version();
        if self.is_pruner_enabled() && latest_version >= min_readable_version + self.prune_window {
            self.set_pruner_target_db_version(latest_version);
        }
    }
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs (L159-174)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());

        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&[S::name(), "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L20-35)
```rust
pub(crate) struct LedgerPrunerManager {
    ledger_db: Arc<LedgerDb>,
    /// DB version window, which dictates how many version of other stores like transaction, ledger
    /// info, events etc to keep.
    prune_window: Version,
    /// It is None iff the pruner is not enabled.
    pruner_worker: Option<PrunerWorker>,
    /// Ideal batch size of the versions to be sent to the ledger pruner
    pruning_batch_size: usize,
    /// latest version
    latest_version: Arc<Mutex<Version>>,
    /// Offset for displaying to users
    user_pruning_window_offset: u64,
    /// The minimal readable version for the ledger data.
    min_readable_version: AtomicVersion,
}
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L66-78)
```rust
    fn maybe_set_pruner_target_db_version(&self, latest_version: Version) {
        *self.latest_version.lock() = latest_version;

        let min_readable_version = self.get_min_readable_version();
        // Only wake up the ledger pruner if there are `ledger_pruner_pruning_batch_size` pending
        // versions.
        if self.is_pruner_enabled()
            && latest_version
                >= min_readable_version + self.pruning_batch_size as u64 + self.prune_window
        {
            self.set_pruner_target_db_version(latest_version);
        }
    }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L18-28)
```rust
pub(crate) struct StateKvPrunerManager {
    state_kv_db: Arc<StateKvDb>,
    /// DB version window, which dictates how many version of state values to keep.
    prune_window: Version,
    /// It is None iff the pruner is not enabled.
    pruner_worker: Option<PrunerWorker>,
    /// Ideal batch size of the versions to be sent to the state kv pruner.
    pruning_batch_size: usize,
    /// The minimal readable version for the ledger data.
    min_readable_version: AtomicVersion,
}
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L46-55)
```rust
    fn maybe_set_pruner_target_db_version(&self, latest_version: Version) {
        let min_readable_version = self.get_min_readable_version();
        // Only wake up the state kv pruner if there are `ledger_pruner_pruning_batch_size` pending
        if self.is_pruner_enabled()
            && latest_version
                >= min_readable_version + self.pruning_batch_size as u64 + self.prune_window
        {
            self.set_pruner_target_db_version(latest_version);
        }
    }
```

**File:** config/src/config/storage_config.rs (L398-412)
```rust
impl Default for StateMerklePrunerConfig {
    fn default() -> Self {
        StateMerklePrunerConfig {
            enable: true,
            // This allows a block / chunk being executed to have access to a non-latest state tree.
            // It needs to be greater than the number of versions the state committing thread is
            // able to commit during the execution of the block / chunk. If the bad case indeed
            // happens due to this being too small, a node restart should recover it.
            // Still, defaulting to 1M to be super safe.
            prune_window: 1_000_000,
            // A 10k transaction block (touching 60k state values, in the case of the account
            // creation benchmark) on a 4B items DB (or 1.33B accounts) yields 300k JMT nodes
            batch_size: 1_000,
        }
    }
```

**File:** storage/aptosdb/src/state_store/state_merkle_batch_committer.rs (L93-98)
```rust
                    self.state_db
                        .state_merkle_pruner
                        .maybe_set_pruner_target_db_version(current_version);
                    self.state_db
                        .epoch_snapshot_pruner
                        .maybe_set_pruner_target_db_version(current_version);
```

**File:** storage/aptosdb/src/pruner/pruner_worker.rs (L53-68)
```rust
    fn work(&self) {
        while !self.quit_worker.load(Ordering::SeqCst) {
            let pruner_result = self.pruner.prune(self.batch_size);
            if pruner_result.is_err() {
                sample!(
                    SampleRate::Duration(Duration::from_secs(1)),
                    error!(error = ?pruner_result.err().unwrap(),
                        "Pruner has error.")
                );
                sleep(Duration::from_millis(self.pruning_time_interval_in_ms));
                continue;
            }
            if !self.pruner.is_pruning_pending() {
                sleep(Duration::from_millis(self.pruning_time_interval_in_ms));
            }
        }
```

**File:** storage/aptosdb/src/pruner/db_pruner.rs (L37-39)
```rust
    fn is_pruning_pending(&self) -> bool {
        self.target_version() > self.progress()
    }
```
