# Audit Report

## Title
Non-Deterministic Layout Validation Causes Consensus Divergence and Chain Splits

## Summary
The `randomly_check_layout_matches()` function uses non-deterministic randomness (`rand::thread_rng()`) during consensus-critical transaction materialization, creating a critical vulnerability where validators produce different execution results for identical blocks when type layout mismatches occur.

## Finding Description

The vulnerability exists in the `randomly_check_layout_matches()` function which uses non-deterministic randomness to validate type layout consistency. [1](#0-0) 

The function generates a random number using `rand::thread_rng()` and only performs layout validation with 1% probability. When the random number equals 1 AND layouts don't match, it returns a `PanicError`. Otherwise, it returns `Ok(())` even if layouts are mismatched.

This function is invoked in consensus-critical execution paths:

1. **Transaction Materialization During Block Execution**: The function is called during delayed field materialization when transactions are being committed. [2](#0-1) 

2. **Parallel Execution Worker Loop**: The materialization process occurs in the worker loop that processes transaction commits. [3](#0-2) 

3. **Sequential Execution Fallback**: Even the sequential execution fallback uses the same non-deterministic check. [4](#0-3) 

4. **Resource Group Operations**: Called during resource group reads in transaction sessions. [5](#0-4) 

5. **Change Set Squashing**: Used during write operation squashing. [6](#0-5) 

**Attack Scenario:**

When a transaction triggers a type layout mismatch (through complex delayed field operations, resource group edge cases, module upgrades, or Move bytecode triggering type system bugs):

1. All validators execute the same block containing this transaction
2. During materialization, each validator independently generates a random number
3. Validator A gets random_number = 1, detects the mismatch, propagates `PanicError`, block execution fails
4. Validator B gets random_number = 42, skips the check, returns `Ok()`, block execution succeeds
5. Validators compute different state roots (or some fail entirely)
6. Consensus cannot be reached on the block

The error propagation is verified: the `PanicError` is converted to `BlockExecutionError::FatalBlockExecutorError` [7](#0-6)  and causes worker loop failure [8](#0-7)  leading to block execution error return. [9](#0-8) 

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under Aptos bug bounty criteria:

**Consensus/Safety Violation**: Different validators produce different execution outcomes for identical blocks, directly violating the deterministic execution requirement. The function's own comment acknowledges layouts are "supposed to" match (not "guaranteed to"), indicating edge cases exist. [10](#0-9) 

**Non-Recoverable Network Partition**: When triggered, approximately 1% of validators will detect the mismatch and fail execution, while 99% will succeed. This prevents consensus agreement on state roots and requires coordinated recovery or hard fork.

**Network-Wide Impact**: Affects all validators simultaneously when the condition occurs. No special privileges required - any transaction causing a layout mismatch (through legitimate bugs or crafted inputs) triggers the divergence.

**Determinism Invariant Violation**: Aptos consensus requires validators to sign the state root after execution, making the protocol resistant to non-determinism bugs. This vulnerability directly breaks that invariant by introducing randomness in state computation.

## Likelihood Explanation

**Likelihood: Medium**

The trigger condition is a type layout mismatch during transaction execution. While the code comment indicates layouts "are supposed to" match, several factors indicate this can occur:

1. **Check Exists For A Reason**: The validation function was implemented because layout mismatches are anticipated in edge cases
2. **Complex Features**: Delayed fields, resource groups, and dynamic type handling create opportunities for layout inconsistencies
3. **Module Upgrades**: Type evolution during module upgrades may cause temporary layout mismatches
4. **Type System Edge Cases**: Complex Move type operations may expose bugs in layout computation

The comment's use of "generally" and "supposed to" (rather than "always" and "guaranteed") indicates acknowledged edge cases. [11](#0-10) 

**Critical Point**: This is a logic vulnerability. Even if layout mismatches are rare, using non-deterministic randomness in deterministic consensus code is fundamentally incorrect and creates a consensus time bomb.

## Recommendation

Replace the non-deterministic probabilistic check with either:

**Option 1 - Always Check (Security Over Performance)**:
```rust
pub fn check_layout_matches(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
) -> Result<(), PanicError> {
    if layout_1 != layout_2 {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    Ok(())
}
```

**Option 2 - Deterministic Sampling (Performance With Determinism)**:
Use deterministic sampling based on transaction hash or block height, ensuring all validators make the same check/skip decision.

## Proof of Concept

The vulnerability can be demonstrated by creating a transaction that causes type layout mismatch (e.g., through complex delayed field operations or resource group edge cases), then observing that different validator processes executing the same block produce different results due to different random number generation.

A minimal reproduction would require:
1. Setting up multiple validator instances
2. Crafting a transaction that triggers layout mismatch during materialization
3. Observing that some validators fail while others succeed due to random check outcomes
4. Verifying different state roots are computed

The core proof is in the code itself: `rand::thread_rng()` is provably non-deterministic, and the function is provably called in consensus-critical paths. The combination of these facts constitutes the vulnerability.

## Notes

This is a **logic vulnerability** where the non-deterministic implementation in deterministic consensus code is inherently wrong, independent of triggering frequency. The Aptos blockchain's security depends on all validators producing identical results for identical inputs, and this code violates that fundamental invariant through its use of `rand::thread_rng()` in the consensus-critical execution path.

### Citations

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L60-63)
```rust
        // Checking if 2 layouts are equal is a recursive operation and is expensive.
        // We generally call this `randomly_check_layout_matches` function when we know
        // that the layouts are supposed to match. As an optimization, we only randomly
        // check if the layouts are matching.
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L64-66)
```rust
        let mut rng = rand::thread_rng();
        let random_number: u32 = rng.gen_range(0, 100);
        if random_number == 1 && layout_1 != layout_2 {
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L534-537)
```rust
                    randomly_check_layout_matches(
                        type_layout.as_deref(),
                        additional_type_layout.as_deref(),
                    )?;
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L64-64)
```rust
            randomly_check_layout_matches(Some(&existing_layout), Some(layout.as_ref()))?;
```

**File:** aptos-move/block-executor/src/executor.rs (L1203-1208)
```rust
        let resource_writes_to_materialize = resource_writes_to_materialize!(
            resource_write_set,
            last_input_output,
            last_input_output,
            txn_idx
        )?;
```

**File:** aptos-move/block-executor/src/executor.rs (L1935-1954)
```rust
                    if let Err(err) = self.worker_loop(
                        &executor,
                        environment,
                        signature_verified_block,
                        &scheduler,
                        &skip_module_reads_validation,
                        &shared_sync_params,
                        num_workers,
                    ) {
                        // If there are multiple errors, they all get logged:
                        // ModulePathReadWriteError and FatalVMError variant is logged at construction,
                        // and below we log CodeInvariantErrors.
                        if let PanicOr::CodeInvariantError(err_msg) = err {
                            alert!("[BlockSTM] worker loop: CodeInvariantError({:?})", err_msg);
                        }
                        shared_maybe_error.store(true, Ordering::SeqCst);

                        // Make sure to halt the scheduler if it hasn't already been halted.
                        scheduler.halt();
                    }
```

**File:** aptos-move/block-executor/src/executor.rs (L1994-1996)
```rust
        if has_error {
            return Err(());
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L2444-2448)
```rust
                        let resource_writes_to_materialize = resource_writes_to_materialize!(
                            resource_write_set,
                            output_before_guard,
                            unsync_map,
                        )?;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/view_with_change_set.rs (L330-330)
```rust
                    randomly_check_layout_matches(maybe_layout, layout.as_deref())?;
```

**File:** aptos-move/block-executor/src/errors.rs (L48-53)
```rust
impl<E> From<PanicError> for SequentialBlockExecutionError<E> {
    fn from(err: PanicError) -> Self {
        SequentialBlockExecutionError::ErrorToReturn(BlockExecutionError::FatalBlockExecutorError(
            err,
        ))
    }
```
