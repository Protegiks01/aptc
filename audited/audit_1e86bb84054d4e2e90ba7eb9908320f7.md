# Audit Report

## Title
Encrypted Transaction Filter Bypass Enables Resource Exhaustion via Fail-Open Design

## Summary
When transaction filters are configured to deny specific entry functions or module addresses, encrypted transactions in `Encrypted` or `FailedDecryption` states bypass these content-based filters due to fail-open behavior when `EncryptedPayload.executable_ref()` returns an error. This allows such transactions to consume mempool, consensus, and validation resources before eventual rejection at the VM layer. [1](#0-0) 

## Finding Description

The transaction filtering system implements a fail-open design where transactions are **allowed by default** when no rules match. When content-based matchers (EntryFunction, ModuleAddress, ScriptArgument) attempt to inspect encrypted payloads, the `executable_ref()` method fails because the payload is not in the `Decrypted` state: [2](#0-1) 

This causes all content-based matchers to return `false` (no match), which means deny rules do not apply: [3](#0-2) [4](#0-3) [5](#0-4) 

When no rules match, the default behavior is to allow the transaction: [6](#0-5) 

**Attack Path:**

1. Operator configures mempool filter to deny transactions calling malicious entry functions (e.g., `Deny: 0xbad::exploit::steal`)
2. Attacker submits encrypted transaction with this payload
3. Mempool filter executes - `executable_ref()` fails on encrypted payload
4. Entry function matcher returns `false` (doesn't match deny rule)
5. No rules match â†’ transaction **allowed by default** (line 46)
6. Transaction enters mempool and propagates through consensus [7](#0-6) 

7. In consensus pipeline, decryption may fail, creating `FailedDecryption` state [8](#0-7) 

8. Block preparation filters again - still cannot inspect content
9. Transaction proceeds to execution, eventually rejected by VM [9](#0-8) 

## Impact Explanation

**Severity: High** - This constitutes a "Validator node slowdown" attack vector as defined in the High severity category.

While encrypted transactions are currently feature-gated and rejected at VM validation, this fail-open design creates several issues:

1. **Resource Exhaustion**: Attackers can bypass content-based filters by wrapping malicious payloads in encrypted transactions, consuming:
   - Mempool space (blocking legitimate transactions)
   - Consensus bandwidth (unnecessary block propagation)
   - Validation resources (signature verification, decryption attempts)

2. **Filter Ineffectiveness**: Operators cannot effectively enforce content-based security policies against encrypted transactions, even when using legitimate deny rules for malicious contracts.

3. **Future Risk**: If encryption support is fully enabled and the VM validation check is modified, this bypass could allow unfiltered execution of previously-blocked malicious contracts.

The impact is amplified because:
- Filters run at **multiple stages** (mempool, consensus, execution) and fail at each stage
- No mechanism exists to fail-closed when payload inspection is impossible
- The `EncryptedTransaction` matcher only filters by encryption status, not content

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Minimal - any user can submit encrypted transactions
- **Complexity**: Low - simple transaction submission with encrypted payload
- **Detection**: Difficult - encrypted transactions appear legitimate until VM rejection
- **Cost**: Standard gas fees only (paid even on rejection)

The attack is trivially executable and can be automated to continuously spam the network with filter-bypassing encrypted transactions.

## Recommendation

Implement **fail-closed** behavior for encrypted/uninspectable payloads when content-based deny rules are active:

```rust
// In transaction_filter.rs, modify matches() functions:

fn matches_entry_function(...) -> bool {
    match signed_transaction.payload() {
        TransactionPayload::EncryptedPayload(payload) => {
            // Fail-closed: If we can't inspect, match deny rules
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function(entry_function, address, module_name, function)
                    },
                    _ => false,
                }
            } else {
                // CRITICAL FIX: Return true to match deny rules for uninspectable payloads
                // This ensures encrypted/failed transactions are caught by deny rules
                true  // Changed from false
            }
        },
        // ... rest of match arms
    }
}
```

Alternatively, add explicit configuration option:
```rust
pub struct TransactionFilterConfig {
    filter_enabled: bool,
    transaction_filter: TransactionFilter,
    deny_uninspectable_payloads: bool,  // NEW: Fail-closed for encrypted
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::tests::utils;

    #[test]
    fn test_encrypted_transaction_bypasses_entry_function_filter() {
        // Create a filter that denies a specific entry function
        let denied_address = AccountAddress::from_hex_literal("0x1").unwrap();
        let denied_module = "malicious".to_string();
        let denied_function = "steal".to_string();
        
        let filter = TransactionFilter::empty()
            .add_entry_function_filter(false, denied_address, denied_module, denied_function)
            .add_all_filter(true);  // Allow all others

        // Create an encrypted transaction (content unknown to filter)
        let encrypted_txn = utils::create_encrypted_transaction();
        
        // VULNERABILITY: Encrypted transaction bypasses the deny rule
        assert!(filter.allows_transaction(&encrypted_txn));
        // ^^^ This should return FALSE (denied) but returns TRUE (allowed)
        
        // Create a plaintext transaction with the denied entry function
        let plaintext_txn = utils::create_entry_function_transaction(
            str::parse(&format!("{}::malicious::steal", denied_address)).unwrap(),
            false
        );
        
        // Plaintext version is correctly denied
        assert!(!filter.allows_transaction(&plaintext_txn));
        
        // This demonstrates the bypass: same payload content, different treatment
        // Attacker can wrap malicious calls in encryption to bypass filters
    }

    #[test]
    fn test_failed_decryption_bypasses_module_address_filter() {
        // Create a filter that denies transactions to a specific module
        let denied_address = AccountAddress::from_hex_literal("0xbad").unwrap();
        
        let filter = TransactionFilter::empty()
            .add_module_address_filter(false, denied_address)
            .add_all_filter(true);

        // Create a transaction in FailedDecryption state
        let failed_decrypt_txn = utils::create_encrypted_transaction_failed_state();
        
        // VULNERABILITY: FailedDecryption transactions bypass module filters
        assert!(filter.allows_transaction(&failed_decrypt_txn));
        // ^^^ Should be denied if policy is fail-closed, but is allowed
        
        println!("Filter bypass confirmed: Encrypted transactions with unknown content are allowed despite deny rules");
    }
}
```

**Notes**

- The vulnerability exists across **all transaction filter stages**: mempool, consensus (quorum store), and block preparation
- The `EncryptedTransaction` matcher provides a workaround but requires operators to explicitly deny ALL encrypted transactions, which may be too broad
- The fail-open design documented at line 18 creates a **security-by-obscurity** assumption that uninspectable transactions are safe
- This violates the principle of least privilege - transactions that cannot be verified against security policies should be denied, not allowed
- Current mitigation (VM rejection) prevents execution but doesn't prevent resource consumption attacks

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L13-18)
```rust
/// A transaction filter that applies a set of rules to determine
/// if a transaction should be allowed or denied.
///
/// Rules are applied in the order they are defined, and the first
/// matching rule determines the outcome for the transaction.
/// If no rules match, the transaction is allowed by default.
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L30-47)
```rust
    pub fn allows_transaction(&self, signed_transaction: &SignedTransaction) -> bool {
        // If the filter is empty, allow the transaction by default
        if self.is_empty() {
            return true;
        }

        // Check if any rule matches the transaction
        for transaction_rule in &self.transaction_rules {
            if transaction_rule.matches(signed_transaction) {
                return match transaction_rule {
                    TransactionRule::Allow(_) => true,
                    TransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the transaction by default)
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L362-374)
```rust
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function(entry_function, address, module_name, function)
                    },
                }
            } else {
                false
            }
        },
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L405-416)
```rust
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function_module_address(entry_function, module_address)
                    },
                }
            } else {
                false
            }
        },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L471-483)
```rust
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::EntryFunction(_)
                    | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::Script(script) => {
                        compare_script_argument_address(script, address)
                    },
                }
            } else {
                false
            }
        },
```

**File:** types/src/transaction/encrypted_payload.rs (L82-87)
```rust
    pub fn executable_ref(&self) -> Result<TransactionExecutableRef<'_>> {
        let Self::Decrypted { executable, .. } = self else {
            bail!("Transaction is encrypted");
        };
        Ok(executable.as_ref())
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L435-440)
```rust
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
            } else {
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L140-145)
```rust
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3229-3231)
```rust
        if transaction.payload().is_encrypted_variant() {
            return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
        }
```
