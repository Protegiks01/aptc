# Audit Report

## Title
Stale Pending Blocks Retained Across Epoch Transitions During Commit Sync

## Summary
The `PendingBlockStore` in the consensus observer fails to clear stale pending blocks from old epochs during commit sync epoch transitions, causing state inconsistency and unnecessary resource consumption. This differs from fallback sync epoch transitions, which properly clear pending blocks.

## Finding Description

The consensus observer maintains a `PendingBlockStore` that holds ordered blocks awaiting their transaction payloads. There is a critical inconsistency in how epoch transitions are handled between two different sync modes:

**Vulnerable Path - Commit Sync Epoch Transition:**

When an ordered block message is received, it is inserted into `PendingBlockStore` without epoch validation. [1](#0-0) 

The epoch check only occurs later during `process_ordered_block`, where blocks from wrong epochs are rejected. [2](#0-1) 

During commit sync epoch transitions, the code verifies payloads for the new epoch and processes ready blocks, but **never clears stale pending blocks from the old epoch**. [3](#0-2) 

**Contrast with Fallback Sync:**

Fallback sync epoch transitions properly clear pending blocks by calling `clear_pending_block_state()`. [4](#0-3) 

The `clear_block_data()` method clears all pending blocks. [5](#0-4) 

**Why Stale Blocks Accumulate:**

When payloads arrive for blocks from old epochs, they cannot be verified (epoch mismatch), so `verified_payload` is set to false. [6](#0-5) 

Only verified payloads trigger ready block processing, so stale pending blocks are never removed through normal processing. [7](#0-6) 

The garbage collection mechanism only removes blocks based on age when the limit is exceeded, not based on epoch validity. [8](#0-7) 

**Exploitation Scenario:**

1. During epoch N, ordered blocks without payloads arrive (naturally or maliciously) and are inserted into `PendingBlockStore`
2. Network transitions from epoch N to epoch N+1 via commit sync
3. Commit sync does NOT call `clear_pending_block_state()`, leaving stale epoch N blocks in the store
4. When payloads eventually arrive for old epoch blocks, they cannot be verified (wrong epoch), so blocks are never removed
5. Process repeats across multiple epochs, accumulating stale blocks until `max_num_pending_blocks` limit is reached
6. When limit is reached, legitimate blocks from current epoch may be rejected or garbage collected

## Impact Explanation

**Severity: Medium** - This qualifies as "State inconsistencies requiring intervention" under the Aptos bug bounty Medium severity category.

**Specific Impacts:**

1. **State Inconsistency**: The system maintains stale state from old epochs that should have been cleared, violating state consistency invariants between sync modes.

2. **Resource Waste**: Stale pending blocks consume memory unnecessarily. While bounded by `max_num_pending_blocks`, this represents wasted resources that grow with each epoch transition.

3. **Operational Impact**: When the limit is reached, legitimate pending blocks from the current epoch may be rejected or incorrectly garbage collected, potentially causing temporary operational issues.

4. **Metrics Pollution**: Pending block metrics become inaccurate, reporting blocks from multiple old epochs as "pending," making monitoring and debugging more difficult.

This does NOT reach Critical or High severity because:
- Memory is bounded (no unbounded exhaustion)
- No fund loss or theft
- No consensus safety violation
- No permanent network partition
- Stale blocks don't affect execution (they're rejected when processed)

## Likelihood Explanation

**Likelihood: High**

1. **Common Trigger**: Commit sync epoch transitions occur regularly during normal network operation as the network advances through epochs.

2. **No Special Privileges Required**: Any network peer can send ordered block messages without payloads, and this can occur naturally due to network delays.

3. **Natural Occurrence**: Even without malicious intent, network conditions can cause ordered blocks to arrive before their payloads, naturally triggering insertion into `PendingBlockStore`.

4. **Accumulation Over Time**: The issue compounds across multiple epoch transitions. Each epoch transition via commit sync leaves behind stale blocks, making manifestation increasingly likely as the network ages.

## Recommendation

Add a call to `clear_pending_block_state()` in the commit sync epoch transition handler to maintain consistency with fallback sync behavior:

```rust
// In process_commit_sync_notification, after lines 1044, add:
if synced_epoch > current_epoch_state.epoch {
    // Wait for the latest epoch to start
    self.execution_client.end_epoch().await;
    self.wait_for_epoch_start().await;

    // Verify the block payloads for the new epoch
    let new_epoch_state = self.get_epoch_state();
    let verified_payload_rounds = self
        .observer_block_data
        .lock()
        .verify_payload_signatures(&new_epoch_state);

    // Clear stale pending blocks from old epochs
    self.clear_pending_block_state().await;

    // Order all the pending blocks that are now ready
    for payload_round in verified_payload_rounds {
        self.order_ready_pending_block(new_epoch_state.epoch, payload_round)
            .await;
    }
};
```

Note: The order matters - clear pending blocks BEFORE ordering ready blocks, to ensure only blocks from the new epoch are processed.

Alternatively, implement epoch-aware cleanup in `PendingBlockStore` to automatically remove blocks from old epochs during insertion or garbage collection.

## Proof of Concept

While a complete PoC would require setting up a full consensus observer environment with epoch transitions, the vulnerability is clearly demonstrated through code analysis showing:

1. The inconsistency between fallback sync (clears pending blocks) and commit sync (does not)
2. The lack of epoch validation at insertion time
3. The inability to verify payloads from old epochs
4. The age-based (not epoch-based) garbage collection mechanism

This can be observed in practice by:
1. Running a consensus observer node
2. Monitoring `PendingBlockStore` metrics across commit sync epoch transitions
3. Observing that pending block counts do not reset to zero after epoch transitions (unlike fallback sync)
4. Observing memory consumption of stale pending blocks accumulating over multiple epochs

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L401-418)
```rust
        let verified_payload = if block_epoch == epoch_state.epoch {
            // Verify the block proof signatures
            if let Err(error) = block_payload.verify_payload_signatures(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify block payload signatures! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                        block_payload.block(), peer_network_id, error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
                return;
            }

            true // We have successfully verified the signatures
        } else {
            false // We can't verify the signatures yet
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L435-438)
```rust
        if verified_payload {
            self.order_ready_pending_block(block_epoch, block_round)
                .await;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L710-712)
```rust
            self.observer_block_data
                .lock()
                .insert_pending_block(pending_block_with_metadata);
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L728-752)
```rust
        let epoch_state = self.get_epoch_state();
        if ordered_block.proof_block_info().epoch() == epoch_state.epoch {
            if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify ordered proof! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        ordered_block.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
                return;
            }
        } else {
            // Drop the block and log an error (the block should always be for the current epoch)
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received ordered block for a different epoch! Ignoring: {:?}",
                    ordered_block.proof_block_info()
                ))
            );
            return;
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L960-961)
```rust
        // Reset the pending block state
        self.clear_pending_block_state().await;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1026-1045)
```rust
        // If the epoch has changed, end the current epoch and start the latest one.
        let current_epoch_state = self.get_epoch_state();
        if synced_epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;

            // Verify the block payloads for the new epoch
            let new_epoch_state = self.get_epoch_state();
            let verified_payload_rounds = self
                .observer_block_data
                .lock()
                .verify_payload_signatures(&new_epoch_state);

            // Order all the pending blocks that are now ready (these were buffered during state sync)
            for payload_round in verified_payload_rounds {
                self.order_ready_pending_block(new_epoch_state.epoch, payload_round)
                    .await;
            }
        };
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L93-105)
```rust
    pub fn clear_block_data(&mut self) -> LedgerInfoWithSignatures {
        // Clear the payload store
        self.block_payload_store.clear_all_payloads();

        // Clear the ordered blocks
        self.ordered_block_store.clear_all_ordered_blocks();

        // Clear the pending blocks
        self.pending_block_store.clear_missing_blocks();

        // Return the root ledger info
        self.root()
    }
```

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L158-195)
```rust
    fn garbage_collect_pending_blocks(&mut self) {
        // Verify that both stores have the same number of entries.
        // If not, log an error as this should never happen.
        let num_pending_blocks = self.blocks_without_payloads.len() as u64;
        let num_pending_blocks_by_hash = self.blocks_without_payloads_by_hash.len() as u64;
        if num_pending_blocks != num_pending_blocks_by_hash {
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "The pending block stores have different numbers of entries: {} and {} (by hash)",
                    num_pending_blocks, num_pending_blocks_by_hash
                ))
            );
        }

        // Calculate the number of blocks to remove
        let max_pending_blocks = self.consensus_observer_config.max_num_pending_blocks;
        let num_blocks_to_remove = num_pending_blocks.saturating_sub(max_pending_blocks);

        // Remove the oldest blocks if the store is too large
        for _ in 0..num_blocks_to_remove {
            if let Some((oldest_epoch_round, pending_block)) =
                self.blocks_without_payloads.pop_first()
            {
                // Log a warning message for the removed block
                warn!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "The pending block store is too large: {:?} blocks. Removing the block for the oldest epoch and round: {:?}",
                        num_pending_blocks, oldest_epoch_round
                    ))
                );

                // Remove the block from the hash store
                let first_block = pending_block.ordered_block().first_block();
                self.blocks_without_payloads_by_hash
                    .remove(&first_block.id());
            }
        }
    }
```
