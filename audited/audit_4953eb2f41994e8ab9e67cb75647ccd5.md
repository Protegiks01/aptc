# Audit Report

## Title
Hot State Merkle Proofs Unverifiable by Light Clients Due to Missing `hot_since_version` Metadata

## Summary
Light clients cannot verify Merkle proofs generated from the hot state tree because the `StateSlot` structure and proof generation system do not provide the `hot_since_version` metadata required to reconstruct the `HotStateValue` hash used in the Merkle tree. This breaks the fundamental security guarantee that light clients can trustlessly verify state validity.

## Finding Description

The hot state system in Aptos maintains a separate Merkle tree for frequently accessed state, where leaf values are hashed as `HotStateValue` structures containing both the `StateValue` and a `hot_since_version` timestamp: [1](#0-0) 

When generating Merkle proofs from the hot state tree, the system hashes the `HotStateValue` (including `hot_since_version`) and inserts this hash into the Merkle tree: [2](#0-1) 

However, when a light client retrieves a state value with proof via `get_state_value_with_proof_by_version_ext` with `use_hot_state=true`, they receive only:
1. The `StateValue` itself
2. A `SparseMerkleProofExt` containing the leaf hash (hash of `HotStateValue`) [3](#0-2) 

To verify the proof, the light client must:
1. Hash the `StateKey` to match against `proof.leaf.key`
2. Hash the value to match against `proof.leaf.value_hash` [4](#0-3) 

**The vulnerability**: For hot state proofs, `proof.leaf.value_hash` is the hash of `HotStateValue` (which includes `hot_since_version`), not just the hash of `StateValue`. The light client receives `StateValue` but **not** `hot_since_version`, making it impossible to reconstruct `HotStateValue` and verify the proof.

The codebase explicitly acknowledges this issue: [5](#0-4) 

**Attack scenario**:
1. A malicious node serves a light client a hot state proof with an incorrect `StateValue`
2. The light client cannot verify the proof because it lacks `hot_since_version`
3. The light client must either trust the node blindly or reject all hot state proofs
4. This undermines the trustless verification model that light clients depend on

## Impact Explanation

This is **High Severity** per the Aptos bug bounty program because:

1. **Significant Protocol Violation**: Light clients are fundamental to blockchain security models, allowing resource-constrained devices to verify state without trusting third parties. The inability to verify hot state proofs breaks this core security guarantee.

2. **Trust Assumption Violation**: Light clients must either:
   - Blindly trust validators providing hot state proofs (defeating the purpose of light clients)
   - Reject hot state optimization entirely and always request cold state proofs (performance degradation)
   - Accept unverifiable state (security risk)

3. **State Consistency Risk**: Without verifiable proofs, light clients cannot detect:
   - Malicious nodes serving incorrect state values
   - State inconsistencies between validators
   - Byzantine behavior in state serving

4. **Scope**: Affects all light client implementations using hot state proofs, including wallets, indexers, and state sync protocols.

## Likelihood Explanation

**Likelihood: High**

1. **Automatic Trigger**: Any light client requesting state with `use_hot_state=true` encounters this issue automatically - no special conditions required.

2. **Common Use Case**: Hot state is specifically designed for frequently accessed state, which is exactly what light clients typically query (account balances, resource states, etc.).

3. **Detection Difficulty**: Light clients may not immediately notice the issue since they might default to trusting nodes rather than cryptographically verifying every proof.

4. **Current Status**: The TODO comment indicates developers are aware of this limitation but it remains unfixed in the production codebase.

## Recommendation

**Option 1: Include `hot_since_version` in proof responses**

Modify the return type of `get_state_value_with_proof_by_version_ext` when `use_hot_state=true` to include `hot_since_version`:

```rust
// In storage-interface/src/lib.rs
fn get_state_value_with_proof_by_version_ext(
    &self,
    key_hash: &HashValue,
    version: Version,
    root_depth: usize,
    use_hot_state: bool,
) -> Result<(Option<StateValueWithMetadata>, SparseMerkleProofExt)>;

// New struct to carry metadata
pub struct StateValueWithMetadata {
    pub value: StateValue,
    pub value_version: Version,
    pub hot_since_version: Option<Version>, // Only set when use_hot_state=true
}
```

Light clients can then reconstruct `HotStateValue` and verify:
```rust
let hot_state_value = HotStateValue::new(
    Some(metadata.value.clone()), 
    metadata.hot_since_version.unwrap()
);
proof.verify_by_hash(root_hash, key_hash, Some(hot_state_value.hash()))?;
```

**Option 2: Persist hot state metadata to database**

Store `hot_since_version` in the state KV database alongside `StateValue` so it can be retrieved during proof generation. This requires schema changes to include hot state metadata in the persisted state.

**Option 3: Disable hot state proofs for light clients**

Until the issue is fixed, always return `use_hot_state=false` for external proof requests, ensuring light clients only receive verifiable cold state proofs.

## Proof of Concept

```rust
// Rust test demonstrating the verification failure
#[test]
fn test_hot_state_proof_verification_fails() {
    use aptos_crypto::hash::CryptoHash;
    use aptos_types::{
        state_store::{
            state_key::StateKey,
            state_value::StateValue,
            hot_state::HotStateValue,
        },
        proof::SparseMerkleProofExt,
    };
    
    // Scenario: Light client receives hot state proof
    let state_key = StateKey::raw(b"test_key");
    let state_value = StateValue::new_legacy(b"test_value".to_vec());
    let hot_since_version = 12345u64;
    
    // What the Merkle tree actually contains (hash of HotStateValue)
    let hot_state_value = HotStateValue::new(Some(state_value.clone()), hot_since_version);
    let actual_value_hash = hot_state_value.hash();
    
    // What the light client receives and can compute (hash of StateValue only)
    let light_client_value_hash = state_value.hash();
    
    // The hashes don't match! Light client cannot verify.
    assert_ne!(
        actual_value_hash, 
        light_client_value_hash,
        "Light client computes wrong hash without hot_since_version"
    );
    
    // If light client attempts verification with just StateValue:
    // proof.verify(root_hash, key_hash, Some(&state_value))
    // This will FAIL because proof.leaf.value_hash == actual_value_hash,
    // but state_value.hash() == light_client_value_hash â‰  actual_value_hash
    
    // The only way to verify is if light client has hot_since_version:
    let reconstructed_hot_value = HotStateValue::new(
        Some(state_value.clone()), 
        hot_since_version
    );
    assert_eq!(
        actual_value_hash,
        reconstructed_hot_value.hash(),
        "With hot_since_version, verification succeeds"
    );
}
```

**Notes**

This vulnerability represents a fundamental gap in the hot state architecture where the optimization (separate hot state Merkle tree) inadvertently breaks the verifiability guarantee for light clients. The issue stems from the design decision to hash `HotStateValue` (value + timestamp) rather than just `StateValue` when building the hot state Merkle tree, combined with the fact that `hot_since_version` metadata is not persisted or returned to clients requesting proofs.

The developers are aware of this limitation as evidenced by the TODO comment, but the issue remains unresolved. Until fixed, hot state proofs should not be served to light clients, or the hot state feature should be considered incomplete for trustless verification use cases.

### Citations

**File:** types/src/state_store/hot_state.rs (L44-58)
```rust
/// `HotStateValue` is what gets hashed into the hot state Merkle tree.
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, BCSCryptoHash, CryptoHasher)]
pub struct HotStateValue {
    /// `Some` means occupied and `None` means vacant.
    value: Option<StateValue>,
    hot_since_version: Version,
}

impl HotStateValue {
    pub fn new(value: Option<StateValue>, hot_since_version: Version) -> Self {
        Self {
            value,
            hot_since_version,
        }
    }
```

**File:** storage/aptosdb/src/state_store/state_snapshot_committer.rs (L112-122)
```rust
                                if slot.is_hot() {
                                    hot_updates.push((
                                        CryptoHash::hash(&key),
                                        Some((
                                            HotStateValueRef::from_slot(&slot).hash(),
                                            key.clone(),
                                        )),
                                    ));
                                } else {
                                    hot_updates.push((CryptoHash::hash(&key), None));
                                }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L209-236)
```rust
    fn get_state_value_with_proof_by_version_ext(
        &self,
        key_hash: &HashValue,
        version: Version,
        root_depth: usize,
        use_hot_state: bool,
    ) -> Result<(Option<StateValue>, SparseMerkleProofExt)> {
        let db = if use_hot_state {
            if self.state_merkle_db.sharding_enabled() {
                self.hot_state_merkle_db
                    .as_ref()
                    .ok_or(AptosDbError::HotStateError)?
            } else {
                // Unsharded unit tests still rely on this.
                &self.state_merkle_db
            }
        } else {
            &self.state_merkle_db
        };
        let (leaf_data, proof) = db.get_with_proof_ext(key_hash, version, root_depth)?;
        Ok((
            match leaf_data {
                Some((_val_hash, (key, ver))) => Some(self.expect_value_by_version(&key, ver)?),
                None => None,
            },
            proof,
        ))
    }
```

**File:** types/src/proof/definition.rs (L245-256)
```rust
    pub fn verify<V: CryptoHash>(
        &self,
        expected_root_hash: HashValue,
        element_key: HashValue,
        element_value: Option<&V>,
    ) -> Result<()> {
        self.verify_by_hash(
            expected_root_hash,
            element_key,
            element_value.map(|v| v.hash()),
        )
    }
```

**File:** storage/storage-interface/src/state_store/state_summary.rs (L300-303)
```rust
        // TODO(HotState): we cannot verify proof yet. In order to verify the proof, we need to
        // fetch and construct the corresponding `HotStateValue` for `key` at `version`, including
        // `hot_since_version`. However, the current in-memory hot state does not support this
        // query, and we might need persist hot state KV to db first.
```
