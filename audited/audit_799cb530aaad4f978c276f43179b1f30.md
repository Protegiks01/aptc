# Audit Report

## Title
Ghost Token Ownership Records in Indexer API Due to Unfiltered Zero-Balance Entries

## Summary
The Aptos indexer creates zero-balance token ownership records in `current_token_ownerships` when tokens are deleted, and these records are exposed via the GraphQL API without automatic filtering. This can lead to applications displaying incorrect "ghost" ownership data to users.

## Finding Description
When a token deletion event occurs (via `DeleteTableItem`), the indexer processes it through the `from_delete_table_item()` function, which sets the token amount to zero: [1](#0-0) 

This zero-balance record is then propagated to create a `CurrentTokenOwnership` entry: [2](#0-1) 

The record is upserted into the `current_token_ownerships` database table: [3](#0-2) 

The Hasura GraphQL API exposes this table with an empty filter, allowing zero-balance records to be returned: [4](#0-3) 

While a filtered SQL view exists that excludes zero-balance tokens: [5](#0-4) 

The base GraphQL endpoint remains unfiltered, exposing ghost ownership records to applications that query it directly.

## Impact Explanation
This is a **Medium severity** data integrity issue per Aptos bug bounty criteria. While it does not directly cause loss of funds or consensus violations, it creates state inconsistencies in the indexer layer that can mislead applications and users:

- NFT wallets querying the API may display tokens the user no longer owns (with amount=0)
- NFT count queries will be inflated by including zero-balance entries
- Marketplaces might attempt to display or trade non-existent tokens
- Users may be confused by seeing tokens they've transferred away still appearing in their holdings

This does not meet Critical or High severity because:
- The blockchain state itself is correct (tokens are properly deleted on-chain)
- No funds are at risk
- Consensus and validator operations are unaffected
- This is isolated to the indexer/API layer

## Likelihood Explanation
This occurs **automatically** on every token deletion event. Every time a token is burned, transferred (removing from sender's TokenStore), or otherwise deleted:

1. The blockchain emits a `DeleteTableItem` write set change
2. The indexer processes it and creates a zero-balance ownership record
3. The record persists indefinitely in `current_token_ownerships`
4. Applications querying the GraphQL API receive this ghost ownership data

The likelihood is **HIGH** because:
- No attacker action is required—it happens during normal token operations
- All applications using the base GraphQL endpoint (not the filtered SQL view) are affected
- There is no cleanup mechanism to remove old zero-balance records

## Recommendation

**Option 1: Filter at API Layer (Recommended)**
Modify the Hasura GraphQL API configuration to automatically filter out zero-balance records: [6](#0-5) 

Change the filter from `"filter": {}` to `"filter": {"amount": {"_gt": "0"}}` to exclude zero-balance tokens.

**Option 2: Database-Level Cleanup**
Add a trigger or periodic cleanup job to DELETE zero-balance records from `current_token_ownerships` table, treating it as a true "current state" snapshot rather than historical data.

**Option 3: Documentation**
If the current behavior is intentional, add clear documentation that applications MUST filter `amount > 0` when querying token ownerships, and prominently recommend using the `current_collection_ownership_view` SQL view instead of the raw table.

## Proof of Concept

```sql
-- Query that demonstrates ghost ownership records
-- Run after a token transfer/burn operation

-- Step 1: Transfer a token from Alice to Bob (on-chain transaction)
-- This creates a DeleteTableItem for Alice's TokenStore

-- Step 2: Query the indexer database
SELECT 
    owner_address,
    name,
    amount,
    last_transaction_version
FROM current_token_ownerships
WHERE owner_address = '<alice_address>'
  AND token_data_id_hash = '<transferred_token_hash>';

-- Expected Result: Record exists with amount = 0 (ghost ownership)
-- Correct Behavior: Record should not exist OR API should filter it out

-- Step 3: Query via GraphQL API
{
  current_token_ownerships(
    where: {owner_address: {_eq: "<alice_address>"}}
  ) {
    name
    amount
    owner_address
  }
}

-- Result: Returns the token with amount: "0"
-- Applications not filtering amount > 0 will show Alice as owning this token
```

**Notes**

This issue is specific to the **indexer component**, which is an off-chain data aggregation layer, not the core blockchain consensus or execution layer. The on-chain state is correct—the `TokenStore` resource properly removes deleted tokens. However, the indexer's API representation creates data integrity issues for downstream applications that don't implement proper filtering.

The existence of the filtered SQL view `current_collection_ownership_view` suggests this is a known design consideration, but the lack of filtering on the primary GraphQL endpoint creates a usability and data integrity gap that affects application developers who may not be aware they need to filter explicitly.

### Citations

**File:** crates/indexer/src/models/token_models/tokens.rs (L332-332)
```rust
                BigDecimal::zero(),
```

**File:** crates/indexer/src/models/token_models/token_ownerships.rs (L95-110)
```rust
        let (curr_token_ownership, owner_address, table_type) = match maybe_table_metadata {
            Some(tm) => (
                Some(CurrentTokenOwnership {
                    collection_data_id_hash: token.collection_data_id_hash.clone(),
                    token_data_id_hash: token.token_data_id_hash.clone(),
                    property_version: token.property_version.clone(),
                    owner_address: standardize_address(&tm.owner_address),
                    creator_address: standardize_address(&token.creator_address.clone()),
                    collection_name: token.collection_name.clone(),
                    name: token.name.clone(),
                    amount: amount.clone(),
                    token_properties: token.token_properties.clone(),
                    last_transaction_version: txn_version,
                    table_type: tm.table_type.clone(),
                    last_transaction_timestamp: token.transaction_timestamp,
                }),
```

**File:** crates/indexer/src/processors/token_processor.rs (L380-409)
```rust
fn insert_current_token_ownerships(
    conn: &mut PgConnection,
    items_to_insert: &[CurrentTokenOwnership],
) -> Result<(), diesel::result::Error> {
    use schema::current_token_ownerships::dsl::*;

    let chunks = get_chunks(items_to_insert.len(), CurrentTokenOwnership::field_count());

    for (start_ind, end_ind) in chunks {
        execute_with_better_error(
            conn,
            diesel::insert_into(schema::current_token_ownerships::table)
                .values(&items_to_insert[start_ind..end_ind])
                .on_conflict((token_data_id_hash, property_version, owner_address))
                .do_update()
                .set((
                    creator_address.eq(excluded(creator_address)),
                    collection_name.eq(excluded(collection_name)),
                    name.eq(excluded(name)),
                    amount.eq(excluded(amount)),
                    token_properties.eq(excluded(token_properties)),
                    last_transaction_version.eq(excluded(last_transaction_version)),
                    collection_data_id_hash.eq(excluded(collection_data_id_hash)),
                    table_type.eq(excluded(table_type)),
                    inserted_at.eq(excluded(inserted_at)),
                )),
            Some(" WHERE current_token_ownerships.last_transaction_version <= excluded.last_transaction_version "),
        )?;
    }
    Ok(())
```

**File:** crates/aptos-localnet/src/hasura_metadata.json (L519-541)
```json
            "select_permissions": [
              {
                "role": "anonymous",
                "permission": {
                  "columns": [
                    "amount",
                    "collection_data_id_hash",
                    "collection_name",
                    "creator_address",
                    "last_transaction_timestamp",
                    "last_transaction_version",
                    "name",
                    "owner_address",
                    "property_version",
                    "table_type",
                    "token_data_id_hash",
                    "token_properties"
                  ],
                  "filter": {},
                  "limit": 100,
                  "allow_aggregations": true
                }
              }
```

**File:** crates/indexer/migrations/2023-04-14-033932_optimize_queries/up.sql (L17-29)
```sql
CREATE OR REPLACE VIEW current_collection_ownership_view AS
SELECT owner_address,
  creator_address,
  collection_name,
  collection_data_id_hash,
  MAX(last_transaction_version) AS last_transaction_version,
  COUNT(DISTINCT name) AS distinct_tokens
FROM current_token_ownerships
WHERE amount > 0
GROUP BY 1,
  2,
  3,
  4;
```
