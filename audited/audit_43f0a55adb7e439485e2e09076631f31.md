# Audit Report

## Title
Lack of Port Validation in Indexer gRPC Cache Worker Configuration Allows Connection to Arbitrary Services

## Summary
The `fullnode_grpc_address` field in `IndexerGrpcCacheWorkerConfig` accepts any URL without validating the port number, allowing connections to arbitrary network services if the configuration is compromised.

## Finding Description

The indexer-grpc-cache-worker configuration accepts a `fullnode_grpc_address` field typed as `url::Url` without any port validation. [1](#0-0) 

The configuration struct does not implement custom validation logic. [2](#0-1) 

The framework calls `validate()` during config loading, but `IndexerGrpcCacheWorkerConfig` uses the default implementation that always returns `Ok(())`. [3](#0-2) 

The URL is directly passed to `create_grpc_client` which attempts connection to any address:port combination. [4](#0-3) 

The gRPC client creation has no port restrictions and will attempt to connect to the specified address. [5](#0-4) 

**Attack Path**: If an attacker can modify the configuration file (through CI/CD compromise, supply chain attack, or misconfiguration), they could:
1. Set `fullnode_grpc_address` to point to internal services (SSH port 22, database ports, etc.)
2. Use the cache worker as a network scanning tool to probe internal services
3. Potentially connect to malicious gRPC servers under attacker control

## Impact Explanation

This issue falls into **Medium** severity per the Aptos bug bounty criteria as it represents a configuration security weakness that could lead to:
- Internal network reconnaissance if configuration is compromised
- Service disruption by pointing to incorrect endpoints
- Potential information disclosure through connection attempts

However, it does NOT directly cause funds loss, consensus violations, or validator compromise.

## Likelihood Explanation

**Likelihood: Low-Medium**

The attack requires:
- Write access to configuration files (significant privilege escalation already achieved)
- The indexer-grpc-cache-worker is infrastructure, not core consensus
- Typical deployment scenarios have configuration managed by trusted operators

However, configuration injection can occur through:
- Supply chain attacks on configuration management
- CI/CD pipeline compromise
- Container image tampering
- Misconfigured file permissions

## Recommendation

Implement port validation in the `validate()` method of `IndexerGrpcCacheWorkerConfig`:

```rust
impl RunnableConfig for IndexerGrpcCacheWorkerConfig {
    fn validate(&self) -> Result<()> {
        // Validate URL scheme
        if self.fullnode_grpc_address.scheme() != "http" && 
           self.fullnode_grpc_address.scheme() != "https" {
            return Err(anyhow::anyhow!(
                "fullnode_grpc_address must use http or https scheme"
            ));
        }
        
        // Validate port is in acceptable range
        if let Some(port) = self.fullnode_grpc_address.port() {
            if port < 1024 {
                return Err(anyhow::anyhow!(
                    "fullnode_grpc_address port must be >= 1024 (got {})", 
                    port
                ));
            }
        }
        
        Ok(())
    }
    
    // ... rest of implementation
}
```

## Proof of Concept

Create a malicious configuration file:

```yaml
health_check_port: 8081
server_config:
  fullnode_grpc_address: "http://localhost:22"  # SSH port
  file_store_config:
    file_store_type: GcsFileStore
    gcs_file_store_bucket_name: test-bucket
  redis_main_instance_address: "redis://localhost:6379"
  enable_cache_compression: false
```

The cache worker will attempt to establish a gRPC connection to SSH port 22, which could:
1. Reveal internal network topology through connection timing
2. Trigger security monitoring alerts
3. Cause service disruption when connection fails

## Notes

**Important Context**:
- This is a defense-in-depth issue in the indexer infrastructure, not core consensus
- The attacker already needs significant system access (config file modification)
- The indexer-grpc-cache-worker reads data from fullnodes; it doesn't affect consensus
- Standard deployment practices with proper access controls mitigate this risk
- This addresses operational security but doesn't break critical blockchain invariants

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/lib.rs (L17-17)
```rust
    pub fullnode_grpc_address: Url,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/lib.rs (L44-66)
```rust
#[async_trait::async_trait]
impl RunnableConfig for IndexerGrpcCacheWorkerConfig {
    async fn run(&self) -> Result<()> {
        let mut worker = Worker::new(
            self.fullnode_grpc_address.clone(),
            self.redis_main_instance_address.clone(),
            self.file_store_config.clone(),
            self.enable_cache_compression,
        )
        .await
        .context("Failed to create cache worker")?;
        worker
            .run()
            .await
            .context("Failed to run cache worker")
            .expect("Cache worker failed");
        Ok(())
    }

    fn get_server_name(&self) -> String {
        "idxcachewrkr".to_string()
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L38-41)
```rust
        let config = load::<GenericConfig<C>>(&self.config_path)?;
        config
            .validate()
            .context("Config did not pass validation")?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L117-117)
```rust
            let mut rpc_client = create_grpc_client(self.fullnode_grpc_address.clone()).await;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/lib.rs (L36-63)
```rust
pub async fn create_grpc_client(address: Url) -> GrpcClientType {
    backoff::future::retry(backoff::ExponentialBackoff::default(), || async {
        match FullnodeDataClient::connect(address.to_string()).await {
            Ok(client) => {
                tracing::info!(
                    address = address.to_string(),
                    "[Indexer Cache] Connected to indexer gRPC server."
                );
                Ok(client
                    .max_decoding_message_size(usize::MAX)
                    .max_encoding_message_size(usize::MAX)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip)
                    .accept_compressed(CompressionEncoding::Zstd))
            },
            Err(e) => {
                tracing::error!(
                    address = address.to_string(),
                    "[Indexer Cache] Failed to connect to indexer gRPC server: {}",
                    e
                );
                Err(backoff::Error::transient(e))
            },
        }
    })
    .await
    .unwrap()
}
```
