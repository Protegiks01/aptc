# Audit Report

## Title
Block Proposer Can Bypass Governance-Set Gas Limits via Unvalidated Payload Execution Limits

## Summary
A malicious block proposer can include an arbitrarily high `block_gas_limit` value in their block payload that overrides on-chain governance-configured execution limits without validation. This allows them to execute more transactions than intended by governance and bypass resource constraints.

## Finding Description

The vulnerability exists in how block gas limits flow from block payloads to execution without validation against on-chain configured maximums.

**Attack Flow:**

1. During epoch initialization, the on-chain execution configuration (including gas limits) is read from committed state and stored in `PipelineBuilder.block_executor_onchain_config` [1](#0-0) 

2. When a malicious validator is the block proposer, they create a payload with an arbitrarily high `block_gas_limit` in the `PayloadExecutionLimit` structure [2](#0-1) 

3. The payload manager extracts this gas limit from the payload and returns it [3](#0-2) 

4. When validators receive and validate the proposal via `process_proposal()`, they check payload size and transaction counts but **do not validate the `block_gas_limit` field** in the payload [4](#0-3) 

5. During the execute phase, the gas limit from the payload is used to override the on-chain configuration **without any bounds checking** [5](#0-4) 

6. The `with_block_gas_limit_override()` method sets the override value without validation [6](#0-5) 

7. During execution, `BlockGasLimitProcessor` prioritizes the override value over the on-chain configured limits [7](#0-6) 

**Broken Invariants:**
- **Resource Limits (Invariant #9)**: "All operations must respect gas, storage, and computational limits" - The proposer can set limits exceeding governance-configured values
- **Governance Integrity (Invariant #5)**: Execution limits set through on-chain governance can be bypassed by individual proposers

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program criteria:

1. **Significant Protocol Violation**: The attack allows bypassing governance-established execution limits, which are a fundamental protocol mechanism for resource management and network safety.

2. **Validator Node Slowdowns**: A malicious proposer setting extremely high gas limits could cause honest validator nodes to execute excessively large blocks, leading to performance degradation and potential node slowdowns.

3. **Governance Undermining**: On-chain governance decisions regarding block execution limits can be circumvented by any proposer during their turn, rendering governance controls ineffective for resource management.

While this doesn't cause direct fund loss or consensus safety violations (all validators still execute the same block deterministically), it represents a significant protocol violation that undermines governance and could impact validator performance.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Any validator in the active set can exploit this when they become the block proposer for a round (happens regularly in round-robin rotation)
- **Complexity**: Low - the attacker simply needs to set a high value in the payload's execution limits field
- **Detection**: Difficult to detect in real-time since the payload structure appears valid and passes all current validation checks
- **Frequency**: Can be exploited in every block the malicious validator proposes

The attack is straightforward to execute and requires no special circumstances beyond being a block proposer.

## Recommendation

Add validation in `process_proposal()` to ensure the `block_gas_limit` in the payload does not exceed the on-chain configured maximum:

```rust
// In consensus/src/round_manager.rs, process_proposal() function
// After existing payload validation (around line 1193):

// Validate block gas limit from payload against on-chain config
if let Some(payload) = proposal.payload() {
    let payload_gas_limit = match payload {
        Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => p.block_gas_limit(),
        Payload::QuorumStoreInlineHybridV2(_, _, execution_limits) => 
            execution_limits.block_gas_limit(),
        _ => None,
    };
    
    if let Some(payload_limit) = payload_gas_limit {
        let onchain_max = self.onchain_execution_config
            .block_executor_onchain_config()
            .block_gas_limit_type
            .block_gas_limit();
            
        if let Some(max_limit) = onchain_max {
            ensure!(
                payload_limit <= max_limit,
                "Payload gas limit {} exceeds on-chain configured maximum {}",
                payload_limit,
                max_limit
            );
        }
    }
}
```

Alternatively, validators should ignore the payload's gas limit and always use the on-chain configured value, removing the override mechanism entirely unless there's a specific protocol reason for allowing proposer-specified limits.

## Proof of Concept

Since this is a consensus-level vulnerability, a full PoC would require a multi-validator testnet. Here's a conceptual demonstration:

```rust
// Conceptual PoC - demonstrates the vulnerability path
#[test]
fn test_malicious_gas_limit_bypass() {
    // 1. Setup: On-chain config sets block gas limit to 1,000,000
    let onchain_config = BlockExecutorConfigFromOnchain::new(
        BlockGasLimitType::Limit(1_000_000),
        false,
        None,
    );
    
    // 2. Malicious proposer creates payload with 10x higher limit
    let malicious_gas_limit = 10_000_000_u64;
    let malicious_payload = create_payload_with_gas_limit(malicious_gas_limit);
    
    // 3. Create block with malicious payload
    let malicious_block = create_block_with_payload(malicious_payload);
    
    // 4. Validator receives and processes proposal
    // process_proposal() validates size/counts but NOT gas_limit
    assert!(round_manager.process_proposal(malicious_block.clone()).is_ok());
    
    // 5. During execution, the malicious limit is used
    let extracted_limit = payload_manager
        .get_transactions(&malicious_block, None)
        .await
        .unwrap()
        .2; // Third element is block_gas_limit
    
    assert_eq!(extracted_limit, Some(malicious_gas_limit));
    
    // 6. Execution uses the malicious limit, bypassing on-chain governance
    let config_with_override = onchain_config
        .with_block_gas_limit_override(extracted_limit);
    
    // The override is now 10x higher than governance intended
    assert_eq!(
        config_with_override.block_gas_limit_override(),
        Some(malicious_gas_limit)
    );
}
```

To fully exploit this in practice, a malicious validator would:
1. Wait for their turn to propose a block
2. Create a payload with `PayloadExecutionLimit::TxnAndGasLimits` containing a gas_limit field set to an arbitrarily high value
3. Include many transactions (potentially their own or high-fee transactions)
4. Propose the block - honest validators will accept and execute it with the inflated limit
5. Collect fees from the extra transactions that wouldn't have fit under governance limits

## Notes

This vulnerability exists because the block gas limit can be specified in two places:
1. On-chain governance configuration (trusted, consensus-protected)
2. Block payload execution limits (proposer-controlled, not validated)

The system prioritizes the payload value when present, creating an opportunity for proposers to bypass governance controls. The fix requires either validating the payload value against on-chain limits or removing the override mechanism entirely.

### Citations

**File:** consensus/src/pipeline/execution_client.rs (L562-563)
```rust
        let block_executor_onchain_config: aptos_types::block_executor::config::BlockExecutorConfigFromOnchain =
            onchain_execution_config.block_executor_onchain_config();
```

**File:** consensus/consensus-types/src/payload.rs (L113-116)
```rust
pub struct TxnAndGasLimits {
    pub transaction_limit: Option<u64>,
    pub gas_limit: Option<u64>,
}
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L559-563)
```rust
        Ok((
            transaction_payload.transactions(),
            transaction_payload.transaction_limit(),
            transaction_payload.gas_limit(),
        ))
```

**File:** consensus/src/round_manager.rs (L1178-1193)
```rust
        let payload_len = proposal.payload().map_or(0, |payload| payload.len());
        let payload_size = proposal.payload().map_or(0, |payload| payload.size());
        ensure!(
            num_validator_txns + payload_len as u64 <= self.local_config.max_receiving_block_txns,
            "Payload len {} exceeds the limit {}",
            payload_len,
            self.local_config.max_receiving_block_txns,
        );

        ensure!(
            validator_txns_total_bytes + payload_size as u64
                <= self.local_config.max_receiving_block_bytes,
            "Payload size {} exceeds the limit {}",
            payload_size,
            self.local_config.max_receiving_block_bytes,
        );
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L800-801)
```rust
        let onchain_execution_config =
            onchain_execution_config.with_block_gas_limit_override(block_gas_limit);
```

**File:** types/src/block_executor/config.rs (L146-152)
```rust
    pub fn with_block_gas_limit_override(self, block_gas_limit_override: Option<u64>) -> Self {
        Self {
            block_gas_limit_type: self.block_gas_limit_type,
            enable_per_block_gas_limit: self.enable_per_block_gas_limit,
            per_block_gas_limit: block_gas_limit_override,
            gas_price_to_burn: self.gas_price_to_burn,
        }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L119-125)
```rust
    fn block_gas_limit(&self) -> Option<u64> {
        if self.block_gas_limit_override.is_some() {
            self.block_gas_limit_override
        } else {
            self.block_gas_limit_type.block_gas_limit()
        }
    }
```
