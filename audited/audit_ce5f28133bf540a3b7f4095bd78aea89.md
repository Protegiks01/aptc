# Audit Report

## Title
Cyclic Instantiation Checker Fails to Detect Spec Function Recursion with Growing Type Parameters

## Summary
The cyclic instantiation checker only validates `MoveFunction` and `Closure` operations for recursive type instantiation cycles, but does not check `SpecFunction` operations. This allows specification functions to recursively call themselves with expanding type parameters (e.g., `spec_fun f<T>() { f<Box<T>>() }`), causing the monomorphization analyzer to loop indefinitely during compilation/verification, resulting in a denial of service.

## Finding Description

The cyclic instantiation checker in the Move compiler v2 is designed to prevent unbounded type growth from recursive generic function calls. When a function `f<T>` calls itself as `f<S<T>>`, it creates an infinite instantiation chain: `T → S<T> → S<S<T>> → ...` [1](#0-0) 

The `visit_call` function only checks `MoveFunction` and `Closure` operations. For all other operation types, including `SpecFunction`, it returns `true` without performing cycle detection. [2](#0-1) 

Specification functions can have generic type parameters and can be recursive, as demonstrated in existing code: [3](#0-2) 

When spec blocks are visited during function checking, spec function calls are encountered but not validated for cyclic instantiations: [4](#0-3) 

During monomorphization analysis, spec function calls with instantiations are queued for processing: [5](#0-4) 

The analyzer processes the todo list without bounds: [6](#0-5) 

A malicious spec function like:
```move
spec fun attack<T>(): T {
    attack<Box<T>>()
}
```

Would cause the analyzer to queue: `attack<T>`, `attack<Box<T>>`, `attack<Box<Box<T>>>`, etc., indefinitely.

## Impact Explanation

**Severity: Medium** - This vulnerability causes denial of service during Move code compilation and verification, but does not affect blockchain runtime execution or consensus.

While spec functions are not executed on-chain (they exist only for formal verification), the compilation process is critical infrastructure. An attacker deploying a malicious module with cyclic spec function instantiations would:

1. Cause compilation to hang or exhaust memory when processing the module
2. Prevent verification of any code that depends on the malicious module
3. Potentially block deployment pipelines if automated verification is required

However, this does not meet the **Critical** or **High** severity criteria as defined by the Aptos bug bounty, which focus on runtime impacts (consensus violations, fund loss, validator node runtime slowdowns). It fits **Medium** severity as it can cause "state inconsistencies requiring intervention" in the development/deployment pipeline.

## Likelihood Explanation

**Likelihood: Medium** - The attack requires:
1. An attacker with module deployment permissions
2. Knowledge of spec function syntax and recursive patterns
3. Automated verification processes that would be affected

The attack is straightforward to execute but requires the target environment to use formal verification, which may not be universal. However, for projects that do use the Move Prover, the impact is immediate and disruptive.

## Recommendation

Extend the cyclic instantiation checker to validate `SpecFunction` operations in addition to `MoveFunction` and `Closure`:

```rust
fn visit_call(
    &self,
    nid: &NodeId,
    op: &Operation,
    insts: &[Type],
    callers_chain: &mut Vec<(Loc, QualifiedInstId<FunId>)>,
) -> bool {
    if let Operation::MoveFunction(mod_id, fun_id) 
        | Operation::Closure(mod_id, fun_id, _) 
        | Operation::SpecFunction(mod_id, fun_id, _) = op  // Add this case
    {
        // Perform the same cyclic instantiation check for spec functions
        // Convert SpecFunId to FunId equivalent or use separate tracking
        // ...existing logic...
    } else {
        true
    }
}
```

Note: This requires adapting the checker to handle `SpecFunId` in addition to `FunId`, potentially by maintaining a separate `callers_chain` for spec functions or creating a unified tracking mechanism.

## Proof of Concept

Create a Move module with a cyclic spec function:

```move
module 0x1::cyclic_spec {
    struct Box<T> { value: T }
    
    spec fun cyclic_attack<T>(): T {
        cyclic_attack<Box<T>>()
    }
    
    fun trigger() {
        // Spec block that calls the cyclic spec function
        spec {
            let _x = cyclic_attack<u64>();
        };
    }
}
```

Attempt to compile this module with the Move compiler v2:
```bash
move compile --package cyclic_spec
```

Expected behavior: Compilation hangs or exhausts memory during monomorphization analysis.

Observed behavior: The cyclic instantiation checker does not detect the issue, allowing the analyzer to enter an infinite loop processing `cyclic_attack<u64>`, `cyclic_attack<Box<u64>>`, `cyclic_attack<Box<Box<u64>>>`, etc.

## Notes

While the original question asked specifically about `Pack`, `Unpack`, and `OpaqueCallBegin`, the investigation revealed that these operation types do not "hide" recursive calls because:

1. **Pack/Unpack**: These construct/destruct struct values and their arguments are recursively visited, so any nested `MoveFunction` calls would be detected
2. **OpaqueCallBegin**: This is a bytecode-level operation, not an AST operation, and is not relevant to the AST-level cyclic instantiation checker

The actual gap found is in `SpecFunction` handling, which represents a different but related vulnerability class. This demonstrates that operation type filtering creates subtle gaps in validation coverage, though the specific examples in the question were not exploitable.

### Citations

**File:** third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs (L84-130)
```rust
    fn visit_call(
        &self,
        nid: &NodeId,
        op: &Operation,
        insts: &[Type],
        callers_chain: &mut Vec<(Loc, QualifiedInstId<FunId>)>,
    ) -> bool {
        if let Operation::MoveFunction(mod_id, fun_id) | Operation::Closure(mod_id, fun_id, _) = op
        {
            let callee_uninst = mod_id.qualified_inst(*fun_id, self.get_inst(*nid));
            let callee = callee_uninst.instantiate(insts);
            if *mod_id != self.mod_env.get_id() || self.def_not_recursive(callee.to_qualified_id())
            {
                // skips if callee from another module (since there is no cyclic module dependency),
                // or if the callee is not recursive
                true
            } else {
                for (_, ancestor_caller) in callers_chain.iter() {
                    if ancestor_caller.to_qualified_id() == callee.to_qualified_id() {
                        // we are checking for the root caller
                        let (_, checking_for) = &callers_chain[0];
                        if checking_for.to_qualified_id() != callee.to_qualified_id() {
                            // check and report diagnostics when `callee` is checked
                            // this happens when root caller `f` calls `g` which then calls `g` itself
                            return true;
                        } else {
                            #[allow(clippy::collapsible_else_if)]
                            if let Some(_ty_param) = callee
                                .inst
                                .iter()
                                .filter_map(ty_properly_contains_ty_parameter)
                                .next()
                            {
                                self.report_error(*nid, callee, callers_chain);
                                return false;
                            } else {
                                return true;
                            }
                        }
                    }
                }
                self.visit_callees(*nid, callee, insts, callers_chain)
            }
        } else {
            true
        }
    }
```

**File:** third_party/move/move-model/src/ast.rs (L1667-1680)
```rust
            SpecBlock(_, spec) => Self::visit_positions_spec_impl(spec, visitor)?,
            // Explicitly list all enum variants
            LoopCont(..) | Value(..) | LocalVar(..) | Temporary(..) | Invalid(..) => {},
        }
        visitor(VisitorPosition::Post, self)
    }

    fn visit_positions_spec_impl<F>(spec: &Spec, visitor: &mut F) -> Option<()>
    where
        F: FnMut(VisitorPosition, &ExpData) -> Option<()>,
    {
        for cond in &spec.conditions {
            Self::visit_positions_cond_impl(cond, visitor)?;
        }
```

**File:** third_party/move/move-model/src/ast.rs (L2025-2050)
```rust
pub enum Operation {
    MoveFunction(ModuleId, FunId),
    Pack(ModuleId, StructId, /*variant*/ Option<Symbol>),
    Closure(ModuleId, FunId, ClosureMask),
    Tuple,
    Select(ModuleId, StructId, FieldId),
    SelectVariants(
        ModuleId,
        StructId,
        /* fields from different variants */ Vec<FieldId>,
    ),
    TestVariants(ModuleId, StructId, /* variants */ Vec<Symbol>),

    // Specification specific
    SpecFunction(ModuleId, SpecFunId, Option<Vec<MemoryLabel>>),
    UpdateField(ModuleId, StructId, FieldId),
    /// Behavior predicate for function values (requires_of, aborts_of, ensures_of, modifies_of).
    /// Arguments: kind of predicate, pre-state label, target function/parameter, post-state label.
    /// Labels are currently ignored but reserved for future state-binding functionality.
    Behavior(
        BehaviorKind,
        Option<MemoryLabel>,
        BehaviorTarget,
        Option<MemoryLabel>,
    ),
    Result(usize),
```

**File:** third_party/move/move-prover/tests/sources/functional/macro_verification.move (L59-65)
```text
    spec fun spec_sum(v: vector<u64>, end: num): num {
        if (end <= 0 || end > len(v))
            0
        else
            // lambda substituted, where old(sum) == spec_sum(v, end - 1)
            spec_sum(v, end - 1) + v[end - 1]
    }
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/mono_analysis.rs (L257-269)
```rust
        // Finally do spec functions, after all regular functions and axioms are done.
        while let Some((fun, inst)) = self.todo_spec_funs.pop() {
            self.inst_opt = Some(inst);
            self.analyze_spec_fun(fun);
            let inst = std::mem::take(&mut self.inst_opt).unwrap();
            // Insert it into final analysis result.
            self.info
                .spec_funs
                .entry(fun)
                .or_default()
                .insert(inst.clone());
            self.done_spec_funs.insert((fun, inst));
        }
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/mono_analysis.rs (L521-564)
```rust
            if let ExpData::Call(node_id, ast::Operation::SpecFunction(mid, fid, _), _) = e {
                let actuals = self.instantiate_vec(&self.env.get_node_instantiation(*node_id));
                let module = self.env.get_module(*mid);
                let spec_fun = module.get_spec_fun(*fid);

                // the type reflection functions are specially handled here
                if self.env.get_extlib_address() == *module.get_name().addr() {
                    let qualified_name = format!(
                        "{}::{}",
                        module.get_name().name().display(self.env.symbol_pool()),
                        spec_fun.name.display(self.env.symbol_pool()),
                    );
                    if qualified_name == TYPE_NAME_SPEC
                        || qualified_name == TYPE_INFO_SPEC
                        || qualified_name == TYPE_SPEC_IS_STRUCT
                    {
                        self.add_type(&actuals[0]);
                    }
                }
                if self.env.get_stdlib_address() == *module.get_name().addr() {
                    let qualified_name = format!(
                        "{}::{}",
                        module.get_name().name().display(self.env.symbol_pool()),
                        spec_fun.name.display(self.env.symbol_pool()),
                    );
                    if qualified_name == TYPE_NAME_GET_SPEC {
                        self.add_type(&actuals[0]);
                    }
                }

                if spec_fun.is_native && !actuals.is_empty() {
                    // Add module to native modules
                    self.info
                        .native_inst
                        .entry(module.get_id())
                        .or_default()
                        .insert(actuals);
                } else {
                    let entry = (mid.qualified(*fid), actuals);
                    // Only if this call has not been processed yet, queue it for future processing.
                    if !self.done_spec_funs.contains(&entry) {
                        self.todo_spec_funs.push(entry);
                    }
                }
```
