# Audit Report

## Title
Governance Bypass: Validators Can Initialize JWKs for Non-Approved Issuers

## Summary
The `process_jwk_update_inner()` function fails to validate that JWK updates are only accepted for issuers present in the governance-controlled `SupportedOIDCProviders` allowlist. This allows validators with quorum to bypass governance and inject JWKs for arbitrary issuers, potentially compromising keyless accounts.

## Finding Description

The JWK update mechanism is designed to maintain JWKs only for OIDC providers approved through on-chain governance via the `SupportedOIDCProviders` resource. However, a critical validation is missing. [1](#0-0) 

When processing a JWK update, the code uses `or_insert_with()` to create a new `ProviderJWKs` with version 0 for any issuer not currently in `ObservedJWKs`, without checking if that issuer is in `SupportedOIDCProviders`. [2](#0-1) 

The version check at line 128 then passes when the attacker sets their update's version to 1 (since 0 + 1 == 1). After multi-signature verification (which only checks validator quorum, not issuer authorization), the malicious JWKs are inserted. [3](#0-2) 

In contrast, legitimate JWK observations only occur for issuers in `SupportedOIDCProviders`: [4](#0-3) 

The malicious JWKs propagate to `PatchedJWKs` which is used for keyless authentication: [5](#0-4) [6](#0-5) 

Critically, keyless authentication validates JWTs by fetching JWKs from `PatchedJWKs` without verifying the issuer is in `SupportedOIDCProviders`. This means maliciously injected JWKs can be used to forge authentication.

**Attack Path:**
1. Validators with >2/3 stake create `QuorumCertifiedUpdate` for issuer "https://evil.com" (not in `SupportedOIDCProviders`)
2. Set version=1, include malicious RSA JWK with attacker-controlled private key
3. Submit as `ValidatorTransaction::ObservedJWKUpdate` (no upfront validation occurs) [7](#0-6) 
4. During execution, `or_insert_with` creates new entry with version 0
5. Version check passes (0+1==1), multi-sig verification passes
6. Malicious JWKs inserted into `ObservedJWKs` and propagated to `PatchedJWKs`
7. Attacker can now forge JWTs for "https://evil.com" to compromise keyless accounts

## Impact Explanation

This constitutes a **High Severity** governance bypass vulnerability because:

1. **Governance Integrity Violation**: The `SupportedOIDCProviders` allowlist is governance-controlled specifically to limit which OIDC providers can be trusted. This bug allows validators to bypass that control.

2. **Keyless Account Compromise**: Attackers can inject JWKs for arbitrary issuers and forge JWTs to authenticate as any user using that issuer, enabling unauthorized access to keyless accounts.

3. **Broader than Expected Byzantine Tolerance**: While AptosBFT tolerates up to 1/3 Byzantine validators for consensus, JWK updates should still respect governance-approved issuer allowlists. This bug extends Byzantine validator power beyond consensus into governance bypass.

Per Aptos bug bounty criteria, this qualifies as High Severity due to "Significant protocol violations" - specifically violation of governance-controlled access controls.

## Likelihood Explanation

**Likelihood: Medium**

While requiring >2/3 validator stake (Byzantine quorum), this is distinct from a simple "51% attack" because:
- It represents a **logic bug** allowing governance bypass
- Validators might collude temporarily without fully compromising the network
- Could occur during epoch transitions or validator set changes
- The attack is straightforward once quorum is achieved

## Recommendation

Add explicit validation that the issuer exists in `SupportedOIDCProviders` before accepting JWK updates:

```rust
fn process_jwk_update_inner(
    &self,
    resolver: &impl AptosMoveResolver,
    // ... other params
) -> Result<(VMStatus, VMOutput), ExecutionFailure> {
    // Load resources
    let validator_set = ValidatorSet::fetch_config(resolver)
        .ok_or(Expected(MissingResourceValidatorSet))?;
    let observed_jwks = ObservedJWKs::fetch_config(resolver)
        .ok_or(Expected(MissingResourceObservedJWKs))?;
    
    // ADD THIS CHECK:
    let supported_providers = SupportedOIDCProviders::fetch_config(resolver)
        .ok_or(Expected(MissingSupportedProviders))?;
    
    let issuer = update.update.issuer.clone();
    
    // Verify issuer is in supported list
    let is_supported = supported_providers.providers.iter()
        .any(|p| p.name == issuer);
    if !is_supported {
        return Err(Expected(IssuerNotSupported));
    }
    
    // Continue with existing logic...
    let mut jwks_by_issuer: HashMap<Issuer, ProviderJWKs> = 
        observed_jwks.into_providers_jwks().into();
    // ...
}
```

This ensures only governance-approved issuers can have JWKs in the system, even when validators have quorum.

## Proof of Concept

```rust
#[test]
fn test_jwk_update_rejects_unsupported_issuer() {
    // Setup: Initialize with SupportedOIDCProviders containing only "https://trusted.com"
    // 
    // Attack: Create QuorumCertifiedUpdate for "https://evil.com" (not in supported list)
    let evil_issuer = b"https://evil.com".to_vec();
    let malicious_update = QuorumCertifiedUpdate {
        update: ProviderJWKs {
            issuer: evil_issuer.clone(),
            version: 1,
            jwks: vec![/* malicious JWK */],
        },
        multi_sig: /* valid quorum signature */,
    };
    
    // Execute: Process the update
    let result = vm.process_jwk_update(
        &resolver,
        &module_storage,
        &log_context,
        session_id,
        malicious_update,
    );
    
    // Expected: Should reject with IssuerNotSupported error
    // Actual (VULNERABLE): Accepts the update, creates ProviderJWKs with version 0,
    //                      passes version check, inserts malicious JWKs
    assert!(result.is_err()); // This assertion currently FAILS
}
```

## Notes

The vulnerability exists because the Rust validation layer assumes JWK consensus (which filters by `SupportedOIDCProviders`) is the only source of updates. However, the validation must be defense-in-depth, checking the issuer allowlist even during execution, since validator transactions can be crafted with quorum signatures to bypass normal consensus flows.

### Citations

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L114-119)
```rust
        let mut jwks_by_issuer: HashMap<Issuer, ProviderJWKs> =
            observed_jwks.into_providers_jwks().into();
        let issuer = update.update.issuer.clone();
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L128-130)
```rust
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```

**File:** types/src/jwks/mod.rs (L131-137)
```rust
    pub fn new(issuer: Issuer) -> Self {
        Self {
            issuer,
            version: 0,
            jwks: vec![],
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L522-531)
```text
    /// Regenerate `PatchedJWKs` from `ObservedJWKs` and `Patches` and save the result.
    fun regenerate_patched_jwks() acquires PatchedJWKs, Patches, ObservedJWKs {
        let jwks = borrow_global<ObservedJWKs>(@aptos_framework).jwks;
        let patches = borrow_global<Patches>(@aptos_framework);
        vector::for_each_ref(&patches.patches, |obj|{
            let patch: &Patch = obj;
            apply_patch(&mut jwks, *patch);
        });
        *borrow_global_mut<PatchedJWKs>(@aptos_framework) = PatchedJWKs { jwks };
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L236-259)
```rust
        // Try looking up the jwk in 0x1.
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
            // 1: If found in 0x1, then we consider that the ground truth & we are done.
            Ok(jwk) => jwk,
            // 2: If not found in 0x1, we check the Keyless PK type.
            Err(e) => {
                match pk {
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
```

**File:** types/src/validator_txn.rs (L45-52)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        match self {
            ValidatorTransaction::DKGResult(dkg_result) => dkg_result
                .verify(verifier)
                .context("DKGResult verification failed"),
            ValidatorTransaction::ObservedJWKUpdate(_) => Ok(()),
        }
    }
```
