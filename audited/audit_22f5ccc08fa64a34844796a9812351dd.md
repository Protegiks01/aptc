# Audit Report

## Title
Division by Zero in Consensus Proposer Election Causes Network Halt When ValidatorSet Becomes Empty

## Summary
A critical vulnerability exists where the Move staking module can create an empty `ValidatorSet` during epoch transitions if all validators fall below the minimum stake requirement. This empty validator set propagates to the Rust consensus layer, causing a division by zero panic in `RotatingProposer::get_valid_proposer()`, which halts all consensus nodes and requires a hard fork to recover.

## Finding Description

The vulnerability spans both Move and Rust code layers:

**Move Layer (Missing Validation):**
In the staking module's `on_new_epoch()` function, validators are filtered based on minimum stake requirements. The code creates an empty `next_epoch_validators` vector and only adds validators meeting the threshold: [1](#0-0) 

If all active validators have `voting_power < minimum_stake`, none are added to `next_epoch_validators`, and line 1401 assigns this empty vector to `validator_set.active_validators`. **Critically, there is no validation ensuring at least one validator remains.**

While the `leave_validator_set()` function has a "last validator" check: [2](#0-1) 

The `on_new_epoch()` function lacks equivalent protection, creating an inconsistent safety guarantee.

**Rust Layer (No Defensive Checks):**
When the Rust consensus code reads the on-chain configuration during epoch transition, it directly converts the empty `ValidatorSet` to a `ValidatorVerifier`: [3](#0-2) 

The `ValidatorVerifier::new()` constructor explicitly allows empty validator sets: [4](#0-3) 

This empty verifier is then used to create a `RotatingProposer` with an empty `proposers` vector: [5](#0-4) 

**Division by Zero Panic:**
When consensus operations call `get_valid_proposer()`, the modulo operation triggers a division by zero: [6](#0-5) 

The expression `% self.proposers.len() as u64` where `len()` is 0 causes an immediate panic. This occurs in critical consensus paths: [7](#0-6) [8](#0-7) 

**Attack Scenarios:**
1. **Governance Attack**: An attacker with sufficient voting power raises `minimum_stake` via governance proposal above all current validators' stakes
2. **Economic Manipulation**: Mass slashing or unstaking events reduce all validators below threshold
3. **Configuration Bug**: Genesis or reconfiguration error sets impossibly high minimum stake
4. **Cascading Failure**: A bug in penalty calculation simultaneously reduces all validators' stakes

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per Aptos bug bounty:

- **"Total loss of liveness/network availability"**: All consensus nodes crash simultaneously with a panic, halting block production completely
- **"Non-recoverable network partition (requires hardfork)"**: Recovery requires manual intervention to restore a valid validator set, necessitating a hard fork
- **Consensus Invariant Violation**: Breaks the fundamental requirement that "AptosBFT must prevent... chain splits" by creating an unrecoverable halt condition

The impact affects the entire network:
- No new blocks can be produced
- All transactions freeze
- State cannot advance
- Economic damage from prolonged downtime
- Requires coordinated hard fork with manual validator set restoration

## Likelihood Explanation

**Likelihood: Medium-Low**

While the bug is real, exploitation requires specific preconditions:

**Feasible Scenarios:**
- Governance proposal raising minimum stake dramatically (requires >50% voting power)
- Bug in slashing/reward logic affecting all validators simultaneously
- Genesis misconfiguration (one-time risk during network launch)
- Coordinated validator unstaking (requires validator collusion)

**Barriers:**
- Governance changes require community approval
- Validators have economic incentive to maintain stakes
- The staking module has other protections (though incomplete)

**However**, the likelihood increases because:
- The Move code has an explicit check in `leave_validator_set()` but not `on_new_epoch()`, suggesting oversight
- No defensive validation in Rust consensus layer
- Economic/governance attacks are within scope per bug bounty rules
- Even accidental triggering (via bug) has critical impact

## Recommendation

**Multi-Layer Defense:**

**1. Move Layer - Add Minimum Validator Validation:**
```move
// In stake.move, on_new_epoch() function, after line 1401:
validator_set.active_validators = next_epoch_validators;
assert!(
    vector::length(&validator_set.active_validators) > 0, 
    error::invalid_state(EINVALID_VALIDATOR_SET)  // New error code
);
```

**2. Rust Layer - Add Defensive Check in RotatingProposer:**
```rust
// In rotating_proposer_election.rs, RotatingProposer::new():
pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
    assert!(
        !proposers.is_empty(),
        "Cannot create RotatingProposer with empty proposers vector"
    );
    assert!(
        contiguous_rounds > 0,
        "contiguous_rounds must be positive"
    );
    Self {
        proposers,
        contiguous_rounds,
    }
}
```

**3. Rust Layer - Validate in EpochManager:**
```rust
// In epoch_manager.rs, start_new_epoch(), after line 1168:
let mut verifier: ValidatorVerifier = (&validator_set).into();
ensure!(
    !verifier.get_ordered_account_addresses_iter().collect::<Vec<_>>().is_empty(),
    "Cannot start epoch with empty validator set"
);
```

**4. Additional Safeguard - Minimum Stake Change Validation:**
Add governance validation preventing minimum stake increases that would exclude all current validators.

## Proof of Concept

**Rust Test - Demonstrating the Panic:**
```rust
#[test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
fn test_empty_proposers_panic() {
    use aptos_consensus::liveness::rotating_proposer_election::RotatingProposer;
    use aptos_consensus::liveness::proposer_election::ProposerElection;
    
    // Create RotatingProposer with empty proposers vector
    let proposers = vec![];  // Empty!
    let rotating_proposer = RotatingProposer::new(proposers, 1);
    
    // This call will panic with division by zero
    let _ = rotating_proposer.get_valid_proposer(1);
}
```

**Move Test - Creating Empty ValidatorSet:**
```move
#[test(aptos_framework = @aptos_framework)]
fun test_empty_validator_set_creation(aptos_framework: &signer) {
    // Setup: Initialize staking with validators
    stake::initialize_for_test(aptos_framework);
    
    // Add validators with stake = 100
    let validators = create_test_validators(5, 100);
    add_validators_to_set(validators);
    
    // Raise minimum stake to 200 (above all validators)
    staking_config::update_required_stake(aptos_framework, 200, 1000);
    
    // Trigger epoch transition
    stake::on_new_epoch();
    
    // Verify: ValidatorSet is now empty
    let validator_set = borrow_global<ValidatorSet>(@aptos_framework);
    assert!(vector::length(&validator_set.active_validators) == 0, 0);
    
    // This would cause Rust consensus to panic when reading this config
}
```

**Notes:**
- The vulnerability exists due to missing validation at the Move layer combined with lack of defensive programming in Rust consensus
- The `EpochState::empty()` helper function confirms the codebase contemplates empty validator sets, but doesn't protect against their use in production
- Multiple call sites in consensus (round timeout, proposal generation) would trigger the panic
- Recovery requires manual intervention and hard fork to inject a valid validator set

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1255-1255)
```text
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1401)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** consensus/src/epoch_manager.rs (L292-298)
```rust
        let proposers = epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .collect::<Vec<_>>();
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
```

**File:** consensus/src/epoch_manager.rs (L1165-1174)
```rust
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
        let mut verifier: ValidatorVerifier = (&validator_set).into();
        verifier.set_optimistic_sig_verification_flag(self.config.optimistic_sig_verification);

        let epoch_state = Arc::new(EpochState {
            epoch: payload.epoch(),
            verifier: verifier.into(),
        });
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** consensus/src/round_manager.rs (L1040-1040)
```rust
                remote_peer = self.proposer_election.get_valid_proposer(round),
```

**File:** consensus/src/liveness/proposal_generator.rs (L898-898)
```rust
            failed_authors.push((i, proposer_election.get_valid_proposer(i)));
```
