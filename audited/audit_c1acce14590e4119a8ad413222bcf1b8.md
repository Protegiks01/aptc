# Audit Report

## Title
Type Safety Bypass in Closure Deserialization Enables VM Type Confusion

## Summary
The `create_from_serialization_data()` function creates `AbstractFunction` instances from deserialized closure data without validating that the closure mask and captured argument layouts match the actual function signature. This allows deserialized closures to bypass type checking during execution, potentially causing type confusion in the Move VM.

## Finding Description

### Vulnerability Location
The vulnerability spans multiple components in the closure handling system:

**Deserialization without validation:** [1](#0-0) 

**Creation of unvalidated function:** [2](#0-1) 

**No validation during resolution:** [3](#0-2) 

**Type checking bypass during execution:** [4](#0-3) 

### The Security Guarantee Broken

The Move VM's **type safety invariant** requires that all function parameters have their types validated before execution. This ensures memory safety and prevents undefined behavior. The vulnerability breaks this guarantee by allowing closures with mismatched type information to execute without validation.

**Normal closure creation path (safe):**
When closures are created via the `PackClosure` bytecode instruction, type validation occurs: [5](#0-4) 

This validates that captured arguments match the expected function parameter types using `mask.extract(func.param_tys(), true)` and performs assignability checks.

**Deserialization path (unsafe):**
When closures are deserialized from storage (e.g., from tables or resources), the validation is bypassed:

1. `ClosureVisitor::visit_seq()` reads the `SerializedFunctionData` including `mask` and `captured_layouts`
2. `create_from_serialization_data()` creates a `LazyLoadedFunction::new_unresolved()` with no validation
3. When resolved via `as_resolved()`, the function is loaded but the mask and layouts are not validated against the actual function signature
4. During execution in `make_call_frame()`, captured arguments skip type checking based on the assumption that "Captured arguments are already verified against function signature" - but this is false for deserialized closures

### Attack Scenario

An attacker could exploit this by:

1. **Creating malicious closure data** with:
   - Valid `module_id` and `fun_id` pointing to an existing function
   - `mask` claiming certain parameters are captured
   - `captured_layouts` specifying incorrect types (e.g., `[U64, U64]` instead of `[Address, Bool]`)
   - Corresponding `captured` values that match the fake layouts

2. **Injecting the malicious closure** into storage through:
   - Storage layer vulnerabilities
   - Race conditions during module upgrades
   - Transaction argument injection if closures are accepted as script arguments
   - Exploiting other bugs that allow controlled serialization

3. **Triggering execution** by calling the stored closure

4. **Type confusion occurs** when:
   - The VM loads u64 values but the function expects address/bool types
   - Memory is reinterpreted with incorrect type assumptions
   - Undefined behavior or memory corruption results

### Consensus Impact

This breaks the **Deterministic Execution** invariant (Invariant #1) because:
- Different validators might handle type confusion differently depending on memory layout, optimization levels, or timing
- Undefined behavior is inherently non-deterministic
- This could cause validators to produce different state roots for the same block, leading to consensus failure

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This vulnerability meets Critical severity criteria:

1. **Consensus/Safety violations**: Type confusion can cause non-deterministic VM execution, leading to state divergence between validators and potential chain splits

2. **Breaks Move VM Safety** (Invariant #3): The VM's type system is fundamental to memory safety and correct execution. Bypassing it violates core security guarantees

3. **Potential for exploitation**: While the exact attack vector requires further investigation, the vulnerability exists in production code handling deserialized closures from storage

4. **Wide impact**: Any contract using closures stored in tables or resources is potentially affected

The severity aligns with the Aptos Bug Bounty program's Critical category: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Medium Likelihood**

The vulnerability requires:
- ✅ **Code path exists**: Closures are regularly deserialized from storage via table natives
- ✅ **Validation is missing**: Confirmed through code analysis
- ❓ **Attack vector**: Requires method to inject malicious closure data into storage

While direct exploitation requires additional conditions (storage manipulation or other bugs), the defense-in-depth principle demands that deserialization validates all safety-critical properties. The absence of this validation represents a serious weakness that could be exploited through:
- Future vulnerabilities in storage layer
- Module upgrade race conditions
- Transaction processing bugs
- Native function implementation errors

## Recommendation

**Add comprehensive validation during closure resolution:**

The `LazyLoadedFunction::as_resolved()` method should validate the mask and captured_layouts against the loaded function signature before transitioning to the Resolved state:

```rust
// After line 436 in loader/function.rs, add validation:
let fun = loader.load_closure(...)?;

// VALIDATE: Check mask doesn't exceed parameter count
let param_count = fun.param_tys().len();
if let Some(max_captured) = mask.max_captured() {
    if max_captured >= param_count {
        return Err(PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
            .with_message(format!(
                "Invalid closure mask: captures parameter {} but function only has {} parameters",
                max_captured, param_count
            )));
    }
}

// VALIDATE: Check captured_layouts match actual parameter types
let expected_captured_tys = mask.extract(fun.param_tys(), true);
if captured_layouts.len() != expected_captured_tys.len() {
    return Err(PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
        .with_message("Closure captured count doesn't match mask".to_string()));
}

// VALIDATE: Convert expected types to layouts and compare
for (i, (expected_ty, captured_layout)) in expected_captured_tys.iter()
    .zip(captured_layouts.iter()).enumerate() {
    let expected_layout = layout_converter.type_to_type_layout_with_delayed_fields(
        gas_meter, traversal_context, expected_ty, true
    )?.into_layout_when_has_no_delayed_fields()
        .ok_or_else(|| PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
            .with_message("Cannot capture delayed fields".to_string()))?;
    
    if captured_layout != &expected_layout {
        return Err(PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
            .with_message(format!(
                "Closure captured argument {} has wrong type: expected {:?}, got {:?}",
                i, expected_layout, captured_layout
            )));
    }
}
```

This validation should occur in the loader where both the function signature and the layout converter are available.

## Proof of Concept

```move
// PoC demonstrating the vulnerability concept
// This would require additional infrastructure to inject malicious closure data

module 0x1::closure_confusion {
    use std::signer;
    use aptos_std::table::{Self, Table};
    
    struct ClosureStore has key {
        closures: Table<u64, |u64, u64| u64>,  // Claims to store closure taking (u64, u64)
    }
    
    public fun init(account: &signer) {
        move_to(account, ClosureStore {
            closures: table::new()
        });
    }
    
    // This function signature: (address, bool) -> u64
    public fun target_function(addr: address, flag: bool): u64 {
        // If called with u64 values interpreted as address/bool, undefined behavior occurs
        if (flag) { 
            // Reading address as u64 - memory corruption
            1 
        } else { 
            0 
        }
    }
    
    // Attacker would craft malicious closure data claiming:
    // - function: target_function
    // - mask: 0b11 (both params captured)
    // - captured_layouts: [U64, U64]  // WRONG! Should be [Address, Bool]
    // - captured_values: [0xDEADBEEF, 0x1]
    
    // When this closure is deserialized and called:
    // - Type checking is skipped (line 964-966 of interpreter.rs)
    // - target_function executes with u64 values where address/bool expected
    // - Type confusion and potential memory corruption
}
```

**Notes**

This is a defense-in-depth vulnerability where the missing validation creates a dangerous code path. The exact exploitation method depends on finding a way to inject malicious closure data into storage, but the fundamental weakness - trusting deserialized type information without validation - represents a critical flaw in the VM's type safety architecture. All deserialized data from storage should be treated as untrusted and validated against the current module definitions.

### Citations

**File:** third_party/move/move-vm/types/src/values/function_values_impl.rs (L198-207)
```rust
        let fun = fun_ext
            .create_from_serialization_data(SerializedFunctionData {
                format_version: FUNCTION_DATA_SERIALIZATION_FORMAT_V1,
                module_id,
                fun_id,
                ty_args,
                mask,
                captured_layouts,
            })
            .map_err(A::Error::custom)?;
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L533-538)
```rust
    fn create_from_serialization_data(
        &self,
        data: SerializedFunctionData,
    ) -> PartialVMResult<Box<dyn AbstractFunction>> {
        Ok(Box::new(LazyLoadedFunction::new_unresolved(data)))
    }
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L410-446)
```rust
    pub(crate) fn as_resolved(
        &self,
        loader: &impl Loader,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
    ) -> PartialVMResult<Rc<LoadedFunction>> {
        let mut state = self.state.borrow_mut();
        Ok(match &mut *state {
            LazyLoadedFunctionState::Resolved { fun, .. } => fun.clone(),
            LazyLoadedFunctionState::Unresolved {
                data:
                    SerializedFunctionData {
                        format_version: _,
                        module_id,
                        fun_id,
                        ty_args,
                        mask,
                        captured_layouts,
                    },
            } => {
                let fun = loader.load_closure(
                    gas_meter,
                    traversal_context,
                    module_id,
                    fun_id,
                    ty_args,
                )?;
                *state = LazyLoadedFunctionState::Resolved {
                    fun: fun.clone(),
                    ty_args: mem::take(ty_args),
                    mask: *mask,
                    captured_layouts: Some(mem::take(captured_layouts)),
                };
                fun
            },
        })
    }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L964-966)
```rust
            if should_check && !is_captured {
                // Only perform paranoid type check for actual operands on the stack.
                // Captured arguments are already verified against function signature.
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L142-188)
```rust
pub fn verify_pack_closure(
    ty_builder: &TypeBuilder,
    operand_stack: &mut Stack,
    func: &LoadedFunction,
    mask: ClosureMask,
) -> PartialVMResult<()> {
    // Accumulated abilities
    let mut abilities = if func.function.is_persistent() {
        AbilitySet::PUBLIC_FUNCTIONS
    } else {
        AbilitySet::PRIVATE_FUNCTIONS
    };
    // Verify that captured arguments are assignable against types in the function
    // signature, and that they are no references.
    let expected_capture_tys = mask.extract(func.param_tys(), true);

    let given_capture_tys = operand_stack.popn_tys(expected_capture_tys.len() as u16)?;
    for (expected, given) in expected_capture_tys
        .into_iter()
        .zip(given_capture_tys.into_iter())
    {
        expected.paranoid_check_is_no_ref("Captured argument type")?;
        with_instantiation(ty_builder, func, expected, |expected| {
            // Intersect the captured type with the accumulated abilities
            abilities = abilities.intersect(given.abilities()?);
            given.paranoid_check_assignable(expected)
        })?
    }
    // Push result type onto stack
    let args = mask
        .extract(func.param_tys(), false)
        .into_iter()
        .map(|curried| with_owned_instantiation(ty_builder, func, curried, Ok))
        .collect::<PartialVMResult<Vec<_>>>()?;
    let results = func
        .return_tys()
        .iter()
        .map(|ret| with_owned_instantiation(ty_builder, func, ret, Ok))
        .collect::<PartialVMResult<Vec<_>>>()?;
    operand_stack.push_ty(Type::Function {
        args,
        results,
        abilities,
    })?;

    Ok(())
}
```
