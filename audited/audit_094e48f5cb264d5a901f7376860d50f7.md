# Audit Report

## Title
Unmetered BCS Deserialization in `validator_txn_enabled()` Allows Validator Node CPU Exhaustion Attack

## Summary
The native function `validator_txn_enabled()` performs BCS deserialization of `OnChainConsensusConfig` without charging gas for the computational cost. An attacker can exploit this by repeatedly calling the public Move function `consensus_config::validator_txn_enabled()` to force validators to perform expensive deserialization operations while only paying for storage reads, causing validator node CPU exhaustion and block processing slowdowns.

## Finding Description

The vulnerability exists in the native function implementation: [1](#0-0) 

The function accepts `config_bytes` as input and deserializes it using `bcs::from_bytes::<OnChainConsensusConfig>()` without charging any gas. The `SafeNativeContext` parameter is prefixed with underscore (`_context`), indicating it is intentionally unused and no gas charging occurs.

This violates the established pattern for BCS deserialization in native functions. The correct implementation requires charging gas before deserialization: [2](#0-1) 

The vulnerable function is exposed through a public Move interface: [3](#0-2) 

The `OnChainConsensusConfig` data structure can be highly complex, containing nested enums, multiple variants (V1-V5), and potentially large `HashMap<Round, AccountAddress>` mappings in the `ProposerElectionType::RoundProposer` variant: [4](#0-3) [5](#0-4) 

**Attack Scenario:**

1. Governance sets a complex `OnChainConsensusConfig` (this is legitimate - the attacker doesn't control the config)
2. The config could contain a `ProposerElectionType::RoundProposer` with a large HashMap mapping many rounds to validators
3. An attacker crafts transactions that call `consensus_config::validator_txn_enabled()` repeatedly in a loop
4. Each call reads the config from storage (gas charged) but deserializes it without charging gas for the CPU-intensive operation
5. Validators must execute all transactions and spend significant CPU time on unmetered deserialization
6. This causes validator node CPU exhaustion and block processing slowdowns

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria: "Validator node slowdowns".

The attack breaks the critical invariant: "Resource Limits: All operations must respect gas, storage, and computational limits" and "Move VM Safety: Bytecode execution must respect gas limits and memory constraints."

**Quantified Impact:**
- According to gas parameters, BCS deserialization should cost `UTIL_FROM_BYTES_BASE (1102) + UTIL_FROM_BYTES_PER_BYTE (18) * bytes.len()` [6](#0-5) 

- For a 10KB config: 1,102 + 18 × 10,240 = ~185,000 internal gas units are NOT being charged
- An attacker can call this function hundreds of times per transaction for minimal cost
- All validators in the network are affected as they must execute every transaction
- Network throughput degrades as validators spend CPU on unmetered operations

## Likelihood Explanation

**Likelihood: High**

- The function is publicly callable by any user without restrictions
- No special permissions or governance control required
- Attack is deterministic and repeatable
- Complexity of OnChainConsensusConfig can legitimately be high through normal governance operations
- Single attacker can impact entire validator network
- Relatively simple to exploit with standard transaction submission

## Recommendation

Add gas charging to the `validator_txn_enabled` native function following the established pattern:

```rust
pub fn validator_txn_enabled(
    context: &mut SafeNativeContext,  // Remove underscore prefix
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    
    // Charge gas BEFORE deserialization
    context.charge(
        UTIL_FROM_BYTES_BASE 
            + UTIL_FROM_BYTES_PER_BYTE * NumBytes::new(config_bytes.len() as u64)
    )?;
    
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes)
        .unwrap_or_default();
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

Additionally, consider adding a gas parameter specifically for consensus config operations if the cost profile differs significantly from generic BCS deserialization.

## Proof of Concept

**Move PoC:**

```move
script {
    use aptos_framework::consensus_config;
    
    fun exploit_unmetered_deserialization() {
        // Call the function repeatedly to exhaust validator CPU
        // Each iteration performs expensive BCS deserialization without proper gas charging
        let i = 0;
        while (i < 1000) {
            // This call reads from storage (charged) but deserializes without charging
            let _ = consensus_config::validator_txn_enabled();
            i = i + 1;
        };
    }
}
```

**Exploitation Steps:**

1. Compile the Move script above
2. Submit multiple transactions containing this script to the network
3. Each transaction will force validators to deserialize the OnChainConsensusConfig 1000 times
4. Validators pay CPU cost for ~185,000 gas units × 1000 iterations = 185M gas units worth of computation per transaction
5. Attacker only pays for storage reads and loop execution, not deserialization
6. Monitor validator block processing time - will increase proportionally to attack traffic
7. Network throughput degrades as validators spend CPU on unmetered operations

**Notes**

The vulnerability is particularly severe because:
1. It affects core consensus configuration reading, used by the governance reconfiguration flow [7](#0-6) 

2. The deserialization complexity scales with the OnChainConsensusConfig structure size
3. No rate limiting or special permissions protect this function
4. All validators must execute the malicious transactions, amplifying the attack impact across the entire network
5. The attack is cost-effective for the attacker (low gas cost) but expensive for validators (high CPU cost)

### Citations

**File:** aptos-move/framework/src/natives/consensus_config.rs (L13-21)
```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).unwrap_or_default();
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

**File:** aptos-move/framework/src/natives/util.rs (L30-44)
```rust
fn native_from_bytes(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert_eq!(ty_args.len(), 1);
    debug_assert_eq!(args.len(), 1);

    // TODO(Gas): charge for getting the layout
    let layout = context.type_to_type_layout(&ty_args[0])?;

    let bytes = safely_pop_arg!(args, Vec<u8>);
    context.charge(
        UTIL_FROM_BYTES_BASE + UTIL_FROM_BYTES_PER_BYTE * NumBytes::new(bytes.len() as u64),
    )?;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L71-76)
```text
    public fun validator_txn_enabled(): bool acquires ConsensusConfig {
        let config_bytes = borrow_global<ConsensusConfig>(@aptos_framework).config;
        validator_txn_enabled_internal(config_bytes)
    }

    native fun validator_txn_enabled_internal(config_bytes: vector<u8>): bool;
```

**File:** types/src/on_chain_config/consensus_config.rs (L192-213)
```rust
pub enum OnChainConsensusConfig {
    V1(ConsensusConfigV1),
    V2(ConsensusConfigV1),
    V3 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
    },
    V4 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
    },
    V5 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
        // Whether to check if we can skip generating randomness for blocks
        rand_check_enabled: bool,
    },
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L508-523)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "snake_case")] // cannot use tag = "type" as nested enums cannot work, and bcs doesn't support it
pub enum ProposerElectionType {
    // Choose the smallest PeerId as the proposer
    // with specified param contiguous_rounds
    FixedProposer(u32),
    // Round robin rotation of proposers
    // with specified param contiguous_rounds
    RotatingProposer(u32),
    // Committed history based proposer election
    LeaderReputation(LeaderReputationType),
    // Pre-specified proposers for each round,
    // or default proposer if round proposer not
    // specified
    RoundProposer(HashMap<Round, AccountAddress>),
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L300-301)
```rust
        [util_from_bytes_base: InternalGas, "util.from_bytes.base", 1102],
        [util_from_bytes_per_byte: InternalGasPerByte, "util.from_bytes.per_byte", 18],
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```
