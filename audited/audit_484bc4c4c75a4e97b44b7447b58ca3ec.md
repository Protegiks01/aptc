# Audit Report

## Title
Incomplete NetworkAddress Validation Allows Storage of Invalid Validator Network Configurations

## Summary
The `NetworkAddress` validation in `types/src/network_address/mod.rs` allows incomplete addresses (missing required `NoiseIK` and `Handshake` protocol layers) to pass deserialization checks. The Move staking contracts accept raw bytes without validation, enabling validators to store malformed network addresses on-chain that cause connection failures across the network.

## Finding Description

The vulnerability exists in the validation pipeline for validator network addresses across three components:

**1. Permissive Rust Validation** [1](#0-0) 

The `NetworkAddress::from_protocols` function allows incomplete addresses by returning early when optional protocol layers are missing. Specifically, it returns `Ok` at lines 281, 290, and 298 if addresses contain only:
- Just network layer (IP/DNS)
- Network + transport layers (IP/DNS + TCP)  
- Network + transport + session layers (IP/DNS + TCP + NoiseIK)

All of these are incomplete according to AptosNet requirements.

**2. Missing Move-Level Validation** [2](#0-1) 

The `initialize_validator` function accepts `network_addresses: vector<u8>` and stores it directly without any validation of the BCS-encoded NetworkAddress bytes. [3](#0-2) 

Similarly, `update_network_and_fullnode_addresses` accepts and stores raw bytes without validation.

**3. Strict Requirements at Connection Time** [4](#0-3) 

The `parse_dial_addr` function strictly requires complete addresses with `NoiseIK` and `Handshake` protocols. Addresses missing these layers fail with `InvalidInput` error at connection time.

**Attack Path:**

1. Attacker (or misconfigured validator) submits transaction to `stake::initialize_validator` or `stake::update_network_and_fullnode_addresses`
2. Provides BCS-encoded bytes representing incomplete NetworkAddress (e.g., `Vec<Protocol>[Ip4(1.2.3.4), Tcp(6180)]`)
3. Move code accepts and stores bytes without validation
4. Bytes deserialize successfully via `from_protocols` due to early return at line 281 or 290
5. Incomplete address is included in validator set [5](#0-4) 

6. Other nodes attempt to connect using these addresses
7. Connection fails in `parse_dial_addr` because required protocols are missing
8. Validator becomes permanently unreachable until address is corrected

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" per Aptos bug bounty criteria:

- **Network Availability**: Affected validators become unreachable to all peers, requiring manual intervention to correct addresses
- **State Corruption**: Invalid network configurations are stored on-chain in validator set
- **Operational Impact**: Multiple validators with malformed addresses could significantly degrade network connectivity
- **No Direct Fund Loss**: Funds are not at risk, but network operations are impaired

If multiple validators (>10-20% of set) have malformed addresses, network discovery and connectivity could be severely degraded, though consensus would continue with reachable validators.

## Likelihood Explanation

**Medium Likelihood:**

- **Easy to Trigger**: Any account registering as validator can provide malformed bytes
- **Accidental Triggering**: Custom tooling or direct transaction crafting could accidentally create incomplete addresses
- **Self-Harm Nature**: Primarily affects the attacker's own validator, reducing malicious motivation
- **Detection**: Failed connections would be logged and detectable, enabling rapid response
- **No Special Privileges**: Does not require validator insider access

While primarily a configuration error vulnerability, it could be exploited maliciously or triggered accidentally through tooling errors.

## Recommendation

**Fix 1: Add Validation in Move Contract**

Modify `stake.move` to validate NetworkAddress bytes before storage:

```move
// Add native function to validate network addresses
native fun validate_network_addresses(addresses: vector<u8>): bool;

public entry fun initialize_validator(
    account: &signer,
    consensus_pubkey: vector<u8>,
    proof_of_possession: vector<u8>,
    network_addresses: vector<u8>,
    fullnode_addresses: vector<u8>,
) acquires AllowedValidators {
    // ... existing checks ...
    
    // Validate network addresses are complete
    assert!(
        validate_network_addresses(network_addresses),
        error::invalid_argument(EINVALID_NETWORK_ADDRESS)
    );
    assert!(
        vector::is_empty(&fullnode_addresses) || validate_network_addresses(fullnode_addresses),
        error::invalid_argument(EINVALID_NETWORK_ADDRESS)
    );
    
    // ... rest of function ...
}
```

**Fix 2: Strengthen Rust Validation**

Modify `NetworkAddress::from_protocols` to enforce complete addresses:

```rust
pub fn from_protocols(protocols: Vec<Protocol>) -> Result<Self, ParseError> {
    // ... existing network and transport validation ...
    
    // Require session layer (NoiseIK)
    p = iter.next();
    if !is_session_layer(p, false) {  // Changed from true to false
        return Err(ParseError::SessionLayerMissing);
    }
    
    // Require handshake layer
    p = iter.next();
    if !is_handshake_layer(p, false) {  // Changed from true to false
        return Err(ParseError::HandshakeLayerMissing);
    }
    
    // ... rest of validation ...
}
```

**Fix 3: Validate at Deserialization**

Add explicit validation in `ValidatorConfig`: [6](#0-5) 

```rust
pub fn validator_network_addresses(&self) -> Result<Vec<NetworkAddress>, bcs::Error> {
    let addrs: Vec<NetworkAddress> = bcs::from_bytes(&self.validator_network_addresses)?;
    // Validate all addresses are complete
    for addr in &addrs {
        if !addr.is_aptosnet_addr() {
            return Err(bcs::Error::Custom("incomplete network address".to_string()));
        }
    }
    Ok(addrs)
}
```

## Proof of Concept

```rust
// Rust test demonstrating incomplete address passing validation
#[test]
fn test_incomplete_address_vulnerability() {
    use aptos_types::network_address::{NetworkAddress, Protocol};
    use std::net::Ipv4Addr;
    
    // Create incomplete address (IP + TCP only, missing NoiseIK and Handshake)
    let incomplete_protocols = vec![
        Protocol::Ip4(Ipv4Addr::new(1, 2, 3, 4)),
        Protocol::Tcp(6180),
    ];
    
    // This should fail but currently succeeds
    let incomplete_addr = NetworkAddress::from_protocols(incomplete_protocols);
    assert!(incomplete_addr.is_ok()); // VULNERABILITY: This passes
    
    let addr = incomplete_addr.unwrap();
    
    // Can BCS-serialize it
    let bytes = bcs::to_bytes(&addr).unwrap();
    
    // Can BCS-deserialize it
    let deserialized: NetworkAddress = bcs::from_bytes(&bytes).unwrap();
    
    // But is_aptosnet_addr correctly identifies it as incomplete
    assert!(!deserialized.is_aptosnet_addr());
    
    // And parse_dial_addr would fail when trying to use it
    // (This demonstrates the inconsistency in validation)
}
```

**Notes:**

- The vulnerability stems from inconsistent validation between storage and usage
- `from_protocols` is too permissive, while `parse_dial_addr` and `is_aptosnet_addr` are appropriately strict
- This creates a validation gap where invalid data can be stored on-chain
- The primary impact is operational (network connectivity) rather than consensus-breaking
- Fixing requires either stricter validation at storage time or more lenient handling at usage time

### Citations

**File:** types/src/network_address/mod.rs (L263-310)
```rust
    pub fn from_protocols(protocols: Vec<Protocol>) -> Result<Self, ParseError> {
        use Protocol::*;

        let mut iter = protocols.iter();

        let mut p = iter.next();

        if p.is_none() {
            return Ok(Self(protocols));
        }

        if !is_network_layer(p) {
            return Err(ParseError::NetworkLayerMissing);
        }

        if !matches!(p, Some(Memory(_))) {
            p = iter.next();
            if p.is_none() {
                return Ok(Self(protocols));
            }
            if !is_transport_layer(p) {
                return Err(ParseError::TransportLayerMissing);
            }
        }

        p = iter.next();
        if p.is_none() {
            return Ok(Self(protocols));
        }
        if !is_session_layer(p, true) {
            return Err(ParseError::SessionLayerMissing);
        }

        p = iter.next();
        if p.is_none() {
            return Ok(Self(protocols));
        }
        if !is_handshake_layer(p, true) {
            return Err(ParseError::HandshakeLayerMissing);
        }

        p = iter.next();
        if p.is_none() {
            Ok(Self(protocols))
        } else {
            Err(ParseError::RedundantLayer)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L670-692)
```text
    public entry fun initialize_validator(
        account: &signer,
        consensus_pubkey: vector<u8>,
        proof_of_possession: vector<u8>,
        network_addresses: vector<u8>,
        fullnode_addresses: vector<u8>,
    ) acquires AllowedValidators {
        check_stake_permission(account);
        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));

        initialize_owner(account);
        move_to(account, ValidatorConfig {
            consensus_pubkey,
            network_addresses,
            fullnode_addresses,
            validator_index: 0,
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-995)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** network/framework/src/transport/mod.rs (L471-513)
```rust
    fn parse_dial_addr(
        addr: &NetworkAddress,
    ) -> io::Result<(NetworkAddress, x25519::PublicKey, u8)> {
        use aptos_types::network_address::Protocol::*;

        let protos = addr.as_slice();

        // parse out the base transport protocol(s), which we will just ignore
        // and leave for the base_transport to actually parse and dial.
        // TODO(philiphayes): protos[..X] is kinda hacky. `Transport` trait
        // should handle this.
        let (base_transport_protos, base_transport_suffix) = parse_ip_tcp(protos)
            .map(|x| (&protos[..2], x.1))
            .or_else(|| parse_dns_tcp(protos).map(|x| (&protos[..2], x.1)))
            .or_else(|| parse_memory(protos).map(|x| (&protos[..1], x.1)))
            .ok_or_else(|| {
                io::Error::new(
                    io::ErrorKind::InvalidInput,
                    format!(
                        "Unexpected dialing network address: '{}', expected: \
                         memory, ip+tcp, or dns+tcp",
                        addr
                    ),
                )
            })?;

        // parse out the aptosnet protocols (noise ik and handshake)
        match base_transport_suffix {
            [NoiseIK(pubkey), Handshake(version)] => {
                let base_addr = NetworkAddress::try_from(base_transport_protos.to_vec())
                    .expect("base_transport_protos is always non-empty");
                Ok((base_addr, *pubkey, *version))
            },
            _ => Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!(
                    "Unexpected dialing network address: '{}', expected: \
                     '/../noise-ik/<pubkey>/handshake/<version>'",
                    addr
                ),
            )),
        }
    }
```

**File:** network/discovery/src/validator_set.rs (L108-150)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```

**File:** types/src/validator_config.rs (L60-66)
```rust
    pub fn fullnode_network_addresses(&self) -> Result<Vec<NetworkAddress>, bcs::Error> {
        bcs::from_bytes(&self.fullnode_network_addresses)
    }

    pub fn validator_network_addresses(&self) -> Result<Vec<NetworkAddress>, bcs::Error> {
        bcs::from_bytes(&self.validator_network_addresses)
    }
```
