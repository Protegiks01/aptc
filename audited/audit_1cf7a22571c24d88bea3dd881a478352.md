# Audit Report

## Title
Missing Root Key Validation in Genesis Initialization Allows Permanent Lock of @core_resources Account in Test Networks

## Summary
The `GenesisInfo::new()` function accepts an `Ed25519PublicKey` as the `root_key` parameter without any validation. This allows an invalid, zero, or small-subgroup key to be used during test network genesis, resulting in the permanent locking of the `@core_resources` account and loss of all administrative capabilities post-genesis. [1](#0-0) 

## Finding Description
The vulnerability exists in the genesis initialization flow for test networks. When `GenesisInfo::new()` is called, the `root_key` parameter is directly stored without validation. [1](#0-0) 

During genesis transaction generation for test networks (`genesis_config.is_test == true`), this key is passed to `initialize_core_resources_and_aptos_coin()`: [2](#0-1) 

The function then derives an authentication key from the unvalidated root_key: [3](#0-2) 

The `AuthenticationKey::ed25519()` function performs NO validationâ€”it simply hashes the key bytes: [4](#0-3) [5](#0-4) 

The Ed25519PublicKey type explicitly allows invalid keys during deserialization: [6](#0-5) 

This authentication key is then set for the `@core_resources` account: [7](#0-6) 

**Attack Path:**
1. Attacker provides a zero Ed25519PublicKey (32 bytes of 0x00) or invalid curve point during test network genesis setup
2. `GenesisInfo::new()` accepts it without validation
3. Genesis transaction derives an authentication key from the invalid key
4. The `@core_resources` account is created with an authentication key that cannot be matched by any valid signature
5. All administrative operations requiring `@core_resources` are permanently blocked

**Broken Invariants:**
- **Access Control**: The @core_resources system address must be protected, but an invalid authentication key makes it permanently inaccessible
- **Cryptographic Correctness**: Invalid/zero keys violate the assumption that authentication keys correspond to valid cryptographic material

## Impact Explanation
This vulnerability allows permanent denial of administrative capabilities in test networks. The `@core_resources` account has critical privileges:

1. **MintCapability<AptosCoin>** - Can mint unlimited test coins and delegate minting to other accounts [8](#0-7) 

2. **SetVersionCapability** - Can update the blockchain version number [9](#0-8) 

If locked, these operations become impossible, rendering the test network unusable for its intended purposes. While this only affects test networks (not mainnet), it breaks critical testing and development workflows.

**Severity**: High - This constitutes a significant protocol violation in test network operations, causing permanent loss of administrative functionality and requiring network recreation to recover.

## Likelihood Explanation
**Likelihood: Medium to High**

This can occur through:
- Accidental misconfiguration in automated genesis generation tools
- Uninitialized memory being passed as the key parameter  
- Supply chain attacks on genesis configuration pipelines
- Malicious insider during testnet setup

The likelihood is elevated because there are NO safeguards preventing this scenario, and genesis configuration often involves complex automation where bugs can occur.

## Recommendation
Add validation in `GenesisInfo::new()` to ensure the root_key is valid:

```rust
pub fn new(
    chain_id: ChainId,
    root_key: Ed25519PublicKey,
    configs: Vec<ValidatorConfiguration>,
    framework: ReleaseBundle,
    genesis_config: &GenesisConfiguration,
) -> anyhow::Result<GenesisInfo> {
    // Validate root_key is not zero
    if root_key.to_bytes() == [0u8; 32] {
        anyhow::bail!("Invalid root_key: zero key not allowed");
    }
    
    // Validate root_key is a valid curve point by attempting to decompress
    let compressed_point = root_key.to_compressed_edwards_y();
    let decompressed = compressed_point.decompress()
        .ok_or_else(|| anyhow::anyhow!("Invalid root_key: not a valid curve point"))?;
    
    // Validate root_key is not in small subgroup
    if decompressed.is_small_order() {
        anyhow::bail!("Invalid root_key: key in small subgroup not allowed");
    }
    
    let mut validators = Vec::new();
    for config in configs {
        validators.push(config.try_into()?)
    }

    Ok(GenesisInfo {
        chain_id,
        root_key,
        validators,
        framework,
        genesis: None,
        // ... rest of fields
    })
}
```

## Proof of Concept

```rust
#[test]
fn test_genesis_with_zero_root_key() {
    use aptos_crypto::ed25519::Ed25519PublicKey;
    use aptos_genesis::{GenesisInfo, builder::GenesisConfiguration};
    
    // Create a zero Ed25519PublicKey (invalid)
    let zero_key_bytes = [0u8; 32];
    let zero_key = Ed25519PublicKey::try_from(&zero_key_bytes[..])
        .expect("Zero key should deserialize without validation");
    
    // Attempt to create genesis with zero key
    let genesis_config = GenesisConfiguration::default_for_test();
    let result = GenesisInfo::new(
        ChainId::test(),
        zero_key,
        vec![],
        ReleaseBundle::devnet_release(),
        &genesis_config,
    );
    
    // This SHOULD fail but currently succeeds
    assert!(result.is_ok(), "Zero key was accepted without validation!");
    
    // Generate genesis transaction
    let mut genesis_info = result.unwrap();
    let genesis_txn = genesis_info.get_genesis();
    
    // After this genesis is applied, @core_resources account will have
    // authentication key derived from zero key, making it permanently locked
    assert!(matches!(genesis_txn, Transaction::GenesisTransaction(_)));
}
```

**Notes**

This vulnerability only affects test networks where `initialize_core_resources_and_aptos_coin` is called during genesis. Mainnet uses a different initialization path that does not create the `@core_resources` account with this mechanism. However, the lack of validation is a violation of secure coding principles and could lead to operational failures in development and testing environments.

### Citations

**File:** crates/aptos-genesis/src/lib.rs (L86-101)
```rust
    pub fn new(
        chain_id: ChainId,
        root_key: Ed25519PublicKey,
        configs: Vec<ValidatorConfiguration>,
        framework: ReleaseBundle,
        genesis_config: &GenesisConfiguration,
    ) -> anyhow::Result<GenesisInfo> {
        let mut validators = Vec::new();

        for config in configs {
            validators.push(config.try_into()?)
        }

        Ok(GenesisInfo {
            chain_id,
            root_key,
```

**File:** aptos-move/vm-genesis/src/lib.rs (L312-318)
```rust
    if genesis_config.is_test {
        initialize_core_resources_and_aptos_coin(
            &mut session,
            &module_storage,
            &mut traversal_context,
            core_resources_key,
        );
```

**File:** aptos-move/vm-genesis/src/lib.rs (L864-883)
```rust
fn initialize_core_resources_and_aptos_coin(
    session: &mut SessionExt<impl AptosMoveResolver>,
    module_storage: &impl AptosModuleStorage,
    traversal_context: &mut TraversalContext,
    core_resources_key: &Ed25519PublicKey,
) {
    let core_resources_auth_key = AuthenticationKey::ed25519(core_resources_key);
    exec_function(
        session,
        module_storage,
        traversal_context,
        GENESIS_MODULE_NAME,
        "initialize_core_resources_and_aptos_coin",
        vec![],
        serialize_values(&vec![
            MoveValue::Signer(CORE_CODE_ADDRESS),
            MoveValue::vector_u8(core_resources_auth_key.to_vec()),
        ]),
    );
}
```

**File:** types/src/transaction/authenticator.rs (L884-887)
```rust
    pub fn from_preimage(mut public_key_bytes: Vec<u8>, scheme: Scheme) -> AuthenticationKey {
        public_key_bytes.push(scheme as u8);
        AuthenticationKey::new(*HashValue::sha3_256_of(&public_key_bytes).as_ref())
    }
```

**File:** types/src/transaction/authenticator.rs (L914-916)
```rust
    pub fn ed25519(public_key: &Ed25519PublicKey) -> AuthenticationKey {
        Self::from_preimage(public_key.to_bytes().to_vec(), Scheme::Ed25519)
    }
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L295-304)
```rust
impl TryFrom<&[u8]> for Ed25519PublicKey {
    type Error = CryptoMaterialError;

    /// Deserialize an Ed25519PublicKey. This method will NOT check for key validity, which means
    /// the returned public key could be in a small subgroup. Nonetheless, our signature
    /// verification implicitly checks if the public key lies in a small subgroup, so canonical
    /// uses of this library will not be susceptible to small subgroup attacks.
    fn try_from(bytes: &[u8]) -> std::result::Result<Ed25519PublicKey, CryptoMaterialError> {
        Ed25519PublicKey::from_bytes_unchecked(bytes)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L153-173)
```text
    fun initialize_core_resources_and_aptos_coin(
        aptos_framework: &signer,
        core_resources_auth_key: vector<u8>,
    ) {
        let (burn_cap, mint_cap) = aptos_coin::initialize(aptos_framework);

        coin::create_coin_conversion_map(aptos_framework);
        coin::create_pairing<AptosCoin>(aptos_framework);

        // Give stake module MintCapability<AptosCoin> so it can mint rewards.
        stake::store_aptos_coin_mint_cap(aptos_framework, mint_cap);
        // Give transaction_fee module BurnCapability<AptosCoin> so it can burn gas.
        transaction_fee::store_aptos_coin_burn_cap(aptos_framework, burn_cap);
        // Give transaction_fee module MintCapability<AptosCoin> so it can mint refunds.
        transaction_fee::store_aptos_coin_mint_cap(aptos_framework, mint_cap);

        let core_resources = account::create_account(@core_resources);
        account::rotate_authentication_key_internal(&core_resources, core_resources_auth_key);
        aptos_account::register_apt(&core_resources); // registers APT store
        aptos_coin::configure_accounts_for_test(aptos_framework, &core_resources, mint_cap);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L110-134)
```text
    /// Only callable in tests and testnets where the core resources account exists.
    /// Create delegated token for the address so the account could claim MintCapability later.
    public entry fun delegate_mint_capability(account: signer, to: address) acquires Delegations {
        system_addresses::assert_core_resource(&account);
        let delegations = &mut borrow_global_mut<Delegations>(@core_resources).inner;
        vector::for_each_ref(delegations, |element| {
            let element: &DelegatedMintCapability = element;
            assert!(element.to != to, error::invalid_argument(EALREADY_DELEGATED));
        });
        vector::push_back(delegations, DelegatedMintCapability { to });
    }

    /// Only callable in tests and testnets where the core resources account exists.
    /// Claim the delegated mint capability and destroy the delegated token.
    public entry fun claim_mint_capability(account: &signer) acquires Delegations, MintCapStore {
        let maybe_index = find_delegation(signer::address_of(account));
        assert!(option::is_some(&maybe_index), EDELEGATION_NOT_FOUND);
        let idx = *option::borrow(&maybe_index);
        let delegations = &mut borrow_global_mut<Delegations>(@core_resources).inner;
        let DelegatedMintCapability { to: _ } = vector::swap_remove(delegations, idx);

        // Make a copy of mint cap and give it to the specified account.
        let mint_cap = borrow_global<MintCapStore>(@core_resources).mint_cap;
        move_to(account, MintCapStore { mint_cap });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L79-84)
```text
    /// Only called in tests and testnets. This allows the core resources account, which only exists in tests/testnets,
    /// to update the version.
    fun initialize_for_test(core_resources: &signer) {
        system_addresses::assert_core_resource(core_resources);
        move_to(core_resources, SetVersionCapability {});
    }
```
