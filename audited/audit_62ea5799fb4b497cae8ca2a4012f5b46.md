# Audit Report

## Title
Path Traversal Vulnerability in Legacy Move Package Git Dependency Resolution Allows Arbitrary File Read

## Summary
The legacy Move package manifest parser (`move-package` crate) fails to validate the `subdir` field in Git dependencies for path traversal attacks. An attacker can craft a malicious `Move.toml` file with a Git dependency containing path traversal sequences (e.g., `../../../../etc`), enabling arbitrary file read on any machine that builds the package. This affects Aptos Core since the vulnerable legacy parser is still actively used in production code.

## Finding Description

Aptos Core contains two Move package parsing systems:
1. **New system** (`move-package-manifest` + `move-package-resolver`): Properly validates `subdir` for path traversal
2. **Legacy system** (`move-package`): No validation for `subdir` field - **VULNERABLE**

The legacy system is still actively used in Aptos Core production code, specifically imported and used in the Aptos framework build process. [1](#0-0) 

The vulnerability exists in the legacy manifest parser where the `subdir` field from a Git dependency is parsed and used without any path traversal validation: [2](#0-1) 

The unvalidated `subdir` is joined with the git cache path to create `dep.local`, which is later used to construct filesystem paths. When resolving dependencies, this path is used to read files: [3](#0-2) 

**Attack Flow:**
1. Attacker creates malicious `Move.toml`:
   ```toml
   [dependencies]
   Malicious = { git = "https://attacker.com/repo.git", rev = "main", subdir = "../../../../etc" }
   ```

2. Victim builds the package using `aptos move compile` or framework build tools

3. The legacy parser reads `subdir = "../../../../etc"` without validation

4. At line 387 in `manifest_parser.rs`, this creates:
   - `dep.local = /path/to/.move/git/repo_main/../../../../etc`

5. At lines 504-505 in `resolution_graph.rs`, the system attempts to read:
   - `/path/to/.move/git/repo_main/../../../../etc/Move.toml`
   - After filesystem normalization, this escapes the git cache directory

6. The attacker can read arbitrary files on the victim's filesystem, limited only by:
   - File permissions of the process building the package
   - Need for the file to parse as valid Move.toml (or trigger exploitable error messages)

In contrast, the new system properly validates the `subdir` field: [4](#0-3) 

The new system normalizes paths and checks if they start with `ParentDir` components, preventing escape from the repository root.

## Impact Explanation

**High Severity** - This vulnerability enables:

1. **Information Disclosure**: Arbitrary file read on developer and validator machines that build Move packages
2. **Supply Chain Attack Vector**: Malicious packages in dependencies can compromise build systems
3. **Validator Infrastructure Risk**: If validators build untrusted packages on nodes with access to private keys or sensitive configuration files, this could lead to key theft
4. **CI/CD Pipeline Compromise**: Automated build systems processing untrusted Move packages are at risk

This qualifies as **High Severity** under Aptos Bug Bounty criteria:
- "Validator node slowdowns" - Potential for validator compromise through file disclosure
- "Significant protocol violations" - Breaks security boundary between Move package system and host filesystem

While this doesn't directly break consensus, it compromises the security of nodes and build infrastructure, which are critical to network security.

## Likelihood Explanation

**High Likelihood**:
- The vulnerable code path is actively used in Aptos Core production code
- Exploitation requires only crafting a malicious `Move.toml` file
- No special privileges needed - any package that gets built is vulnerable
- Attack is silent and may not be noticed until sensitive data is accessed
- Developers regularly build third-party packages during development and testing
- CI/CD systems automatically build packages, making them susceptible to automated attacks

## Recommendation

**Immediate Fix**: Migrate all Aptos Core code to use the new `move-package-manifest`/`move-package-resolver` system that includes proper validation, or backport the validation to the legacy system.

**Short-term Fix**: Add path traversal validation to the legacy manifest parser in `manifest_parser.rs` after line 375:

```rust
let subdir = PathBuf::from(match table.remove("subdir") {
    None => "".to_string(),
    Some(path) => path
        .as_str()
        .ok_or_else(|| format_err!("'subdir' not a string"))?
        .to_string(),
});

// ADD VALIDATION HERE
if subdir.is_absolute() {
    bail!("subdir cannot be an absolute path: {}", subdir.display());
}
let normalized_subdir = normalize_path(&subdir);
if let Some(std::path::Component::ParentDir) = normalized_subdir.components().next() {
    bail!("subdir outside of repo root: {}", subdir.display());
}
```

Where `normalize_path` is imported from: [5](#0-4) 

**Long-term Fix**: 
1. Fully deprecate the legacy `move-package` manifest parser
2. Migrate all code to use the validated `move-package-manifest` system
3. Add integration tests specifically for path traversal in `subdir` fields
4. Audit all file path construction in the Move toolchain for similar issues

## Proof of Concept

Create a malicious Move package:

**Step 1**: Create `malicious_package/Move.toml`:
```toml
[package]
name = "MaliciousPackage"
version = "0.0.1"

[dependencies]
# Attempt to read /etc/passwd by traversing up from git cache
Exploit = { git = "https://github.com/aptos-labs/aptos-core.git", rev = "main", subdir = "../../../../../../../../etc" }
```

**Step 2**: Attempt to build:
```bash
cd malicious_package
aptos move compile
```

**Expected Result (Vulnerable System)**: 
- The system attempts to read `/etc/Move.toml` or similar path outside git cache
- Error messages may leak information about file existence and permissions
- If a valid Move.toml exists at the traversed path, it gets loaded and processed

**Expected Result (Patched System)**:
- Build fails immediately with: `"subdir outside of repo root: ../../../../../../../../etc"`
- No file access outside intended directories

**Notes**:
- The actual exploitation impact depends on what files exist on the target system
- Validators and developers building untrusted packages are most at risk
- The vulnerability can be chained with social engineering to target specific high-value files

### Citations

**File:** aptos-move/framework/src/built_package.rs (L37-44)
```rust
use move_package::{
    compilation::{compiled_package::CompiledPackage, package_layout::CompiledPackageLayout},
    resolution::resolution_graph::ResolvedGraph,
    source_package::{
        manifest_parser::{parse_move_manifest_string, parse_source_manifest},
        std_lib::StdVersion,
    },
    BuildConfig, CompilerConfig, ModelConfig,
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L369-390)
```rust
                    let subdir = PathBuf::from(match table.remove("subdir") {
                        None => "".to_string(),
                        Some(path) => path
                            .as_str()
                            .ok_or_else(|| format_err!("'subdir' not a string"))?
                            .to_string(),
                    });
                    git_info = Some(PM::GitInfo {
                        git_url: Symbol::from(git_url),
                        git_rev: rev_name,
                        subdir: subdir.clone(),
                        download_to: local_path.clone(),
                    });

                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
                        local: local_path.join(subdir),
                        git_info,
                        node_info,
                    })
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L499-517)
```rust
    fn parse_package_manifest(
        dep: &Dependency,
        dep_name: &PackageName,
        mut root_path: PathBuf,
    ) -> Result<(SourceManifest, PathBuf)> {
        root_path.push(&dep.local);
        match fs::read_to_string(root_path.join(SourcePackageLayout::Manifest.path())) {
            Ok(contents) => {
                let source_package: SourceManifest =
                    parse_move_manifest_string(contents).and_then(parse_source_manifest)?;
                Ok((source_package, root_path))
            },
            Err(_) => Err(anyhow::format_err!(
                "Unable to find package manifest for '{}' at {:?}",
                dep_name,
                SourcePackageLayout::Manifest.path().join(root_path),
            )),
        }
    }
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L392-399)
```rust
            let subdir = PathBuf::from_str(&subdir.unwrap_or(String::new()))?;
            if subdir.is_absolute() {
                bail!("subdir cannot be an absolute path: {}", subdir.display());
            }
            let normalized_subdir = NormalizedPath::new(&subdir);
            if let Some(std::path::Component::ParentDir) = normalized_subdir.components().next() {
                bail!("subdir outside of repo root: {}", subdir.display());
            }
```

**File:** third_party/move/tools/move-package-resolver/src/path.rs (L44-71)
```rust
fn normalize_path(path: impl AsRef<Path>) -> PathBuf {
    let path = path.as_ref();
    let mut stack = vec![];

    for component in path.components() {
        match &component {
            Component::CurDir => (),
            Component::ParentDir => match stack.last() {
                Some(Component::Prefix(_) | Component::RootDir) => (),
                Some(Component::Normal(_)) => {
                    stack.pop();
                },
                Some(Component::ParentDir) | None => {
                    stack.push(component);
                },
                Some(Component::CurDir) => unreachable!(),
            },
            Component::Prefix(_) | Component::RootDir | Component::Normal(_) => {
                stack.push(component);
            },
        }
    }

    stack
        .into_iter()
        .map(|c| c.as_os_str())
        .collect::<PathBuf>()
}
```
