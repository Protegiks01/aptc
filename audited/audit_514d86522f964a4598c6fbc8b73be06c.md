# Audit Report

## Title
Missing JWT Expiration and IAT/EXP Consistency Validation in Keyless Authentication

## Summary
The keyless authentication system fails to validate the JWT's `exp` claim and does not verify the logical consistency between `iat` and `exp` timestamps. This allows malicious or compromised OIDC providers to issue JWTs with reversed or invalid timestamp values, enabling the creation of ephemeral keys with lifespans extending centuries into the future, bypassing intended expiration controls.

## Finding Description

The `OidcClaims` struct defines both `iat` (issued at) and `exp` (expiration) fields, but the validation logic fails to check either the JWT's expiration or the relationship between these timestamps. [1](#0-0) 

In the `verify_jwt_claims()` function, validation only ensures that the ephemeral key's expiration is within the allowed horizon from `iat`, but never validates the JWT's own `exp` claim or checks that `iat < exp`: [2](#0-1) 

Furthermore, JWT signature verification explicitly disables expiration validation: [3](#0-2) 

The same pattern appears in the pepper service: [4](#0-3) 

**Attack Scenario:**

1. An attacker deploys a federated keyless account with their own OIDC provider
2. The malicious provider issues a JWT with manipulated timestamps:
   - `iat = 9999999999` (September 2286)
   - `exp = 1000000000` (September 2001)
   - `nonce` = correctly computed commitment to ephemeral key
3. The attacker creates an ephemeral key with:
   - `exp_timestamp_secs = 9999999999 + max_exp_horizon_secs - 1` (potentially year 2318)
4. During validation in `verify_jwt_claims()`, the check passes:
   - `exp_timestamp_secs < iat + max_exp_horizon_secs` ✓ (valid)
   - No validation of JWT's `exp` claim ✗ (missing)
   - No check that `iat < exp` ✗ (missing)
5. During `verify_expiry()` at transaction time, the check passes because blockchain time (2024) is far less than the ephemeral key expiration (2318) [5](#0-4) 

This breaks the **Transaction Validation** invariant that all authentication tokens must have proper expiration controls.

## Impact Explanation

This is a **High severity** issue per Aptos bug bounty criteria due to "Significant protocol violations":

1. **Security Control Bypass**: Completely bypasses JWT expiration mechanisms intended by OIDC providers
2. **Extended Unauthorized Access**: Enables authentication sessions lasting decades or centuries beyond reasonable limits
3. **Federated Account Risk**: Particularly exploitable with federated keyless accounts where users control the OIDC provider
4. **Trust Model Violation**: Breaks the assumption that OIDC provider timestamp claims are validated

While it doesn't directly cause loss of funds or break consensus, it represents a fundamental flaw in the authentication security model that could enable long-term account compromise if ephemeral keys are leaked.

## Likelihood Explanation

**Likelihood: Medium to High**

For federated keyless accounts:
- Users can deploy their own OIDC providers at arbitrary addresses
- No validation prevents malicious providers from issuing invalid JWTs
- Attack is straightforward once a malicious provider is set up

For standard keyless accounts:
- Requires compromise of a legitimate OIDC provider (Google, Apple, etc.)
- Lower likelihood but higher impact if it occurs
- No defense-in-depth if a provider is compromised

The vulnerability is **easily exploitable** once the attacker controls an OIDC provider, which is the case for federated keyless accounts.

## Recommendation

Add validation to ensure JWT timestamp claims are valid and consistent:

```rust
// In verify_jwt_claims() function, add after parsing claims:

// Validate that iat < exp (logical consistency)
ensure!(
    claims.oidc_claims.iat < claims.oidc_claims.exp,
    "JWT 'iat' claim must be less than 'exp' claim"
);

// Validate that the JWT's exp hasn't passed
let current_time = seconds_from_epoch(
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map_err(|e| anyhow::anyhow!("System time error: {}", e))?
        .as_secs()
)?;
let jwt_expiration = seconds_from_epoch(claims.oidc_claims.exp)?;
ensure!(
    current_time < jwt_expiration,
    "JWT has expired according to its 'exp' claim"
);

// Validate that iat is not unreasonably far in the future (e.g., max 1 hour ahead)
let iat_time = seconds_from_epoch(claims.oidc_claims.iat)?;
let max_future_iat = seconds_from_epoch(
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map_err(|e| anyhow::anyhow!("System time error: {}", e))?
        .as_secs()
        .checked_add(3600)
        .ok_or_else(|| anyhow::anyhow!("Overflow in iat future check"))?
)?;
ensure!(
    iat_time < max_future_iat,
    "JWT 'iat' claim is unreasonably far in the future"
);
```

## Proof of Concept

```rust
#[test]
fn test_reversed_iat_exp_bypass() {
    use crate::keyless::{Configuration, OpenIdSig, KeylessPublicKey};
    use crate::transaction::authenticator::EphemeralPublicKey;
    
    // Create a malicious JWT with reversed iat and exp
    let mut malicious_claims = SAMPLE_JWT_PARSED.clone();
    malicious_claims.oidc_claims.iat = 9999999999; // Year 2286
    malicious_claims.oidc_claims.exp = 1000000000; // Year 2001 (in the past)
    
    let malicious_jwt_json = serde_json::to_string(&malicious_claims).unwrap();
    
    let mut openid_sig = get_sample_openid_sig_and_pk().0.cert;
    let openid_sig = match openid_sig {
        EphemeralCertificate::OpenIdSig(mut sig) => {
            sig.jwt_payload_json = malicious_jwt_json;
            sig
        },
        _ => panic!("Expected OpenIdSig"),
    };
    
    let config = Configuration::new_for_testing();
    let (_, pk) = get_sample_openid_sig_and_pk();
    let epk = EphemeralPublicKey::ed25519(Ed25519PublicKey::try_from([0u8; 32].as_ref()).unwrap());
    
    // This should FAIL but currently PASSES due to missing validation
    let far_future_exp = 9999999999u64 + config.max_exp_horizon_secs - 1;
    
    let result = openid_sig.verify_jwt_claims(
        far_future_exp,
        &epk,
        &pk,
        &config,
    );
    
    // Current behavior: PASSES (vulnerability)
    // Expected behavior: FAILS with "iat must be less than exp" error
    assert!(result.is_ok(), "Current code incorrectly accepts reversed iat/exp");
    
    // After fix, this assertion should pass:
    // assert!(result.is_err());
    // assert!(result.unwrap_err().to_string().contains("iat"));
}
```

**Notes:**

The vulnerability is confirmed across multiple validation paths:
- VM validation layer doesn't check JWT `exp` claim
- Pepper service validation doesn't check JWT `exp` claim  
- No consistency validation between `iat` and `exp` timestamps anywhere in the codebase

This represents a fundamental gap in the keyless authentication security model that should be addressed immediately to prevent potential long-term account compromise through malicious OIDC providers, especially in federated keyless deployments.

### Citations

**File:** types/src/keyless/openid_sig.rs (L64-78)
```rust
        let max_expiration_date = seconds_from_epoch(
            claims
                .oidc_claims
                .iat
                .checked_add(config.max_exp_horizon_secs)
                .ok_or_else(|| {
                    anyhow::anyhow!("Overflow when adding iat and max_exp_horizon_secs")
                })?,
        )?;
        let expiration_date = seconds_from_epoch(exp_timestamp_secs)?;

        ensure!(
            expiration_date < max_expiration_date,
            "The ephemeral public key's expiration date is too far into the future"
        );
```

**File:** types/src/keyless/openid_sig.rs (L172-181)
```rust
pub struct OidcClaims {
    pub iss: String,
    pub aud: String,
    pub sub: String,
    pub nonce: String,
    pub iat: u64,
    pub exp: u64,
    pub email: Option<String>,
    pub email_verified: Option<Value>,
}
```

**File:** types/src/jwks/rsa/mod.rs (L89-95)
```rust
    pub fn verify_signature_without_exp_check(&self, jwt_token: &str) -> Result<TokenData<Claims>> {
        let mut validation = Validation::new(Algorithm::RS256);
        validation.validate_exp = false;
        let key = &DecodingKey::from_rsa_components(&self.n, &self.e)?;
        let claims = jsonwebtoken::decode::<Claims>(jwt_token, key, &validation)?;
        Ok(claims)
    }
```

**File:** keyless/pepper/service/src/dedicated_handlers/pepper_request.rs (L388-395)
```rust
    // TODO: can we avoid decoding the JWT twice?
    let mut validation_with_sig_verification = Validation::new(RS256);
    validation_with_sig_verification.validate_exp = false; // Don't validate the exp time
    jsonwebtoken::decode::<Claims>(jwt, &jwk_decoding_key, &validation_with_sig_verification) // Signature verification happens here
        .map_err(|e| {
            PepperServiceError::BadRequest(format!("JWT signature verification failed: {e}"))
        })?;

```

**File:** types/src/keyless/mod.rs (L202-212)
```rust
    pub fn verify_expiry(&self, current_time_microseconds: u64) -> anyhow::Result<()> {
        let block_time = UNIX_EPOCH.checked_add(Duration::from_micros(current_time_microseconds))
            .ok_or_else(|| anyhow::anyhow!("Overflowed on UNIX_EPOCH + current_time_microseconds when checking exp_date_secs"))?;
        let expiry_time = seconds_from_epoch(self.exp_date_secs)?;

        if block_time > expiry_time {
            bail!("Keyless signature is expired");
        } else {
            Ok(())
        }
    }
```
