# Audit Report

## Title
Fee Payer Signature Confusion Attack: Transaction Integrity Violation Through Mixed Message Signing

## Summary
The fee payer verification logic in `TransactionAuthenticator::verify()` allows different transaction signers to sign cryptographically different messages, violating the fundamental security invariant that all parties must agree on the complete transaction. An attacker can combine signatures where the sender signs a message with `fee_payer=AccountAddress::ZERO` while the fee payer signs with `fee_payer=actual_address`, creating a transaction where not all signers committed to the same data. [1](#0-0) 

## Finding Description

The dual-verification approach in the fee payer verification logic creates a critical transaction integrity violation. The verification logic operates as follows:

1. Creates a message with `fee_payer_address = AccountAddress::ZERO`
2. Verifies sender and secondary signers against this ZERO-address message
3. Collects signers that fail verification into a `remaining` list
4. Adds the fee payer to `remaining`
5. Creates a second message with the actual `fee_payer_address`
6. Verifies all `remaining` signers against the actual-address message [2](#0-1) 

**Attack Scenario:**
An attacker can construct a transaction where:
- The sender signs: `RawTransactionWithData { raw_txn, secondary_addresses, fee_payer: ZERO }`
- The fee payer signs: `RawTransactionWithData { raw_txn, secondary_addresses, fee_payer: actual_address }`

Since `RawTransactionWithData` is an enum that serializes differently based on the `fee_payer_address` field, these produce **different cryptographic hashes**. [3](#0-2) 

During verification:
- Sender's signature verifies against ZERO message → passes → NOT added to `remaining`
- Fee payer added to `remaining` → verifies against actual address message → passes
- Transaction is accepted despite different messages being signed

**Real-World Exploitation Path:**
The existing test code demonstrates this exact attack vector, where signatures from two different transactions (one signed with ZERO, one with actual address) are mixed into a single valid transaction: [4](#0-3) 

**Critical Security Implication:**
The fee payer address is accessible during Move execution via `transaction_context::gas_payer()`, allowing smart contracts to make authorization decisions based on who is paying for gas: [5](#0-4) 

The gas payer value returned during execution comes from the `fee_payer_address` field stored in the transaction: [6](#0-5) 

This means:
- Move code during execution sees `gas_payer() = actual_fee_payer_address`
- But the sender **never cryptographically committed** to this specific fee payer
- The sender only signed a commitment with `fee_payer = ZERO`

## Impact Explanation

**Critical Severity** - This vulnerability breaks the fundamental transaction integrity invariant:

1. **Transaction Validation Invariant Violation**: The core principle that "all signers must sign the same message" is violated. Different parties sign different commitments yet the transaction is accepted.

2. **Authorization Bypass Potential**: If Move smart contracts implement authorization logic based on `transaction_context::gas_payer()` (e.g., granting privileges based on who pays gas), an attacker can:
   - Get a victim to sign with `fee_payer=ZERO` (claiming it's for simulation/testing)
   - Use a privileged account as the actual fee payer
   - Execute the transaction where the victim's signature is used but never actually agreed to the privileged fee payer

3. **Semantic Confusion**: The sender and fee payer fundamentally disagree about the transaction structure:
   - Sender committed to: "unknown/test fee payer (ZERO)"
   - Fee payer committed to: "I will pay for this specific transaction"
   - System accepts both despite contradiction

4. **State Consistency Risk**: In multi-agent transactions with complex authorization requirements, this could lead to unexpected state transitions where parties didn't all agree on the transaction parameters.

This qualifies as **Critical** under Aptos Bug Bounty criteria as it represents a significant protocol violation that could enable authorization bypasses and breaks transaction integrity guarantees.

## Likelihood Explanation

**High Likelihood** - The vulnerability is:

1. **Already Demonstrated**: Test code actively uses this pattern, indicating it's a known behavior that could be exploited
2. **Easy to Execute**: No special privileges required - any transaction sender can craft such transactions
3. **No Additional Constraints**: Standard signature operations are sufficient
4. **Realistic Attack Vectors**: 
   - Social engineering to get victim to sign "test" transactions with ZERO fee payer
   - Wallet UX confusion where users don't realize the significance of fee payer address
   - Third-party integrations that might sign with ZERO for flexibility

## Recommendation

The verification logic must enforce that ALL signers sign the SAME message. The dual-verification approach should be removed. Instead:

**Option 1 - Enforce Single Message (Recommended):**
All signers must sign the same `fee_payer_address`. Remove the dual verification:

```rust
Self::FeePayer {
    sender,
    secondary_signer_addresses,
    secondary_signers,
    fee_payer_address,
    fee_payer_signer,
} => {
    let message = RawTransactionWithData::new_fee_payer(
        raw_txn.clone(),
        secondary_signer_addresses.clone(),
        *fee_payer_address,
    );
    
    sender.verify(&message)?;
    for signer in secondary_signers {
        signer.verify(&message)?;
    }
    fee_payer_signer.verify(&message)?;
    
    Ok(())
}
```

**Option 2 - Require Explicit Opt-In:**
If backward compatibility with ZERO-address signing is required, add explicit verification that ZERO was intentional:

```rust
// Only allow ZERO if fee_payer_address is actually ZERO
if *fee_payer_address == AccountAddress::ZERO {
    // All sign with ZERO
    let message = RawTransactionWithData::new_fee_payer(
        raw_txn.clone(),
        secondary_signer_addresses.clone(),
        AccountAddress::ZERO,
    );
    verify_all_signers(&message)?;
} else {
    // All must sign with actual address - no mixing allowed
    let message = RawTransactionWithData::new_fee_payer(
        raw_txn.clone(),
        secondary_signer_addresses.clone(),
        *fee_payer_address,
    );
    verify_all_signers(&message)?;
}
```

## Proof of Concept

The vulnerability is already demonstrated in the existing test suite. The following test shows signature mixing is accepted: [7](#0-6) 

This test:
1. Creates transaction A signed with `fee_payer=ZERO` (line 731)
2. Extracts sender signature from transaction A (lines 736-749)
3. Creates transaction B signed with `fee_payer=actual_address` (line 757)
4. Extracts fee payer signature from transaction B (lines 762-777)
5. **Mixes signatures**: sender from A + fee payer from B (lines 770-776)
6. **Submits mixed transaction** - expects success (lines 785-789)

**Reproduction Steps:**

1. Create a transaction payload
2. Have sender sign with: `RawTransactionWithData::new_fee_payer(txn, [], AccountAddress::ZERO)`
3. Have fee payer sign with: `RawTransactionWithData::new_fee_payer(txn, [], fee_payer_address)`
4. Construct `TransactionAuthenticator::FeePayer` with:
   - `sender` = sender's signature (from step 2)
   - `fee_payer_address` = actual address
   - `fee_payer_signer` = fee payer's signature (from step 3)
5. Submit transaction → verification passes
6. During execution, `transaction_context::gas_payer()` returns the actual fee payer address that the sender never agreed to

## Notes

This vulnerability stems from a design decision to provide "flexibility" in fee payer transactions, allowing signers to optionally include or exclude the fee payer address in their commitments. However, this flexibility comes at the cost of transaction integrity. The comments in the code acknowledge this design choice: [8](#0-7) 

While the intent was to support both "modern" (ZERO-address) and "legacy" (actual-address) signing approaches, the implementation allows **mixing** of these approaches within a single transaction, which breaks the security invariant that all parties must agree on the complete transaction structure.

The `sign_aa_transaction` function explicitly uses this dual-signing pattern for account abstraction, signing user and secondary signers with ZERO and fee payer with actual address: [9](#0-8) 

This indicates the behavior is intentional but creates a critical security vulnerability where different signers commit to different transaction parameters.

### Citations

**File:** types/src/transaction/authenticator.rs (L175-221)
```rust
            Self::FeePayer {
                sender,
                secondary_signer_addresses,
                secondary_signers,
                fee_payer_address,
                fee_payer_signer,
            } => {
                // In the fee payer model, the fee payer address can be optionally signed. We
                // realized when we designed the fee payer model, that we made it too restrictive
                // by requiring the signature over the fee payer address. So now we need to live in
                // a world where we support a multitude of different solutions. The modern approach
                // assumes that some may sign over the address and others will sign over the zero
                // address, so we verify both and only fail if the signature fails for either of
                // them. The legacy approach is to assume the address of the fee payer is signed
                // over.
                let mut to_verify = vec![sender];
                let _ = secondary_signers
                    .iter()
                    .map(|signer| to_verify.push(signer))
                    .collect::<Vec<_>>();

                let no_fee_payer_address_message = RawTransactionWithData::new_fee_payer(
                    raw_txn.clone(),
                    secondary_signer_addresses.clone(),
                    AccountAddress::ZERO,
                );

                let mut remaining = to_verify
                    .iter()
                    .filter(|verifier| verifier.verify(&no_fee_payer_address_message).is_err())
                    .collect::<Vec<_>>();

                remaining.push(&fee_payer_signer);

                let fee_payer_address_message = RawTransactionWithData::new_fee_payer(
                    raw_txn.clone(),
                    secondary_signer_addresses.clone(),
                    *fee_payer_address,
                );

                for verifier in remaining {
                    verifier.verify(&fee_payer_address_message)?;
                }

                Ok(())
            },
            Self::MultiEd25519 {
```

**File:** types/src/transaction/mod.rs (L470-498)
```rust
        let user_signed_message = if fee_payer.is_some() {
            RawTransactionWithData::new_fee_payer(
                self.clone(),
                secondary_signers.clone(),
                AccountAddress::ZERO,
            )
        } else {
            RawTransactionWithData::new_multi_agent(self.clone(), secondary_signers.clone())
        };
        let sender_authenticator = gen_auth(sender_auth, &user_signed_message)?;

        if secondary_auths.len() != secondary_signers.len() {
            return Err(format_err!(
                "number of secondary private keys and number of secondary signers don't match"
            ));
        }
        let mut secondary_authenticators = vec![];
        for auth in secondary_auths {
            let secondary_authenticator = gen_auth(auth, &user_signed_message)?;
            secondary_authenticators.push(secondary_authenticator);
        }

        if let Some((fee_payer_address, fee_payer_auth)) = fee_payer {
            let user_signed_message = RawTransactionWithData::new_fee_payer(
                self.clone(),
                secondary_signers.clone(),
                fee_payer_address,
            );
            let fee_payer_authenticator = gen_auth(fee_payer_auth, &user_signed_message)?;
```

**File:** types/src/transaction/mod.rs (L641-678)
```rust
#[derive(
    Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash,
)]
pub enum RawTransactionWithData {
    MultiAgent {
        raw_txn: RawTransaction,
        secondary_signer_addresses: Vec<AccountAddress>,
    },
    MultiAgentWithFeePayer {
        raw_txn: RawTransaction,
        secondary_signer_addresses: Vec<AccountAddress>,
        fee_payer_address: AccountAddress,
    },
}

impl RawTransactionWithData {
    pub fn new_fee_payer(
        raw_txn: RawTransaction,
        secondary_signer_addresses: Vec<AccountAddress>,
        fee_payer_address: AccountAddress,
    ) -> Self {
        Self::MultiAgentWithFeePayer {
            raw_txn,
            secondary_signer_addresses,
            fee_payer_address,
        }
    }

    pub fn new_multi_agent(
        raw_txn: RawTransaction,
        secondary_signer_addresses: Vec<AccountAddress>,
    ) -> Self {
        Self::MultiAgent {
            raw_txn,
            secondary_signer_addresses,
        }
    }
}
```

**File:** api/src/tests/transactions_test.rs (L725-797)
```rust
    let another_txn = another_raw_txn
        .clone()
        .sign_fee_payer(
            another_account.private_key(),
            vec![],
            vec![],
            AccountAddress::ZERO,
            fee_payer.private_key(),
        )
        .unwrap();

    let (sender, secondary_signer_addresses, secondary_signers) = match another_txn.authenticator()
    {
        TransactionAuthenticator::FeePayer {
            sender,
            secondary_signer_addresses,
            secondary_signers,
            fee_payer_address: _,
            fee_payer_signer: _,
        } => (sender, secondary_signer_addresses, secondary_signers),
        _ => panic!(
            "expecting TransactionAuthenticator::FeePayer, but got: {:?}",
            txn.authenticator()
        ),
    };

    let another_txn = another_raw_txn
        .clone()
        .sign_fee_payer(
            another_account.private_key(),
            vec![],
            vec![],
            fee_payer.address(),
            fee_payer.private_key(),
        )
        .unwrap();

    let another_txn = match another_txn.authenticator() {
        TransactionAuthenticator::FeePayer {
            sender: _,
            secondary_signer_addresses: _,
            secondary_signers: _,
            fee_payer_address,
            fee_payer_signer,
        } => {
            let auth = TransactionAuthenticator::fee_payer(
                sender,
                secondary_signer_addresses,
                secondary_signers,
                fee_payer_address,
                fee_payer_signer,
            );
            SignedTransaction::new_signed_transaction(another_raw_txn, auth)
        },
        _ => panic!(
            "expecting TransactionAuthenticator::FeePayer, but got: {:?}",
            txn.authenticator()
        ),
    };

    let body = bcs::to_bytes(&another_txn).unwrap();
    let resp = context
        .expect_status_code(202)
        .post_bcs_txn("/transactions", body)
        .await;
    // TODO[Orderless]: When the input is given in JSON format, the /transactions endpoint will use payload v1 format
    // to construct the transactions. So, the supplied signature that is signed on payload v2 format will not match.
    if !context.use_txn_payload_v2_format || context.use_orderless_transactions {
        context
            .expect_status_code(202)
            .post("/transactions", resp)
            .await;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_context.move (L103-111)
```text
    /// Returns the gas payer address for the current transaction.
    /// It is either the sender's address if no separate gas fee payer is specified for the current transaction,
    /// or the address of the separate gas fee payer if one is specified.
    /// This function aborts if called outside of the transaction prologue, execution, or epilogue phases.
    public fun gas_payer(): address {
        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));
        gas_payer_internal()
    }
    native fun gas_payer_internal(): address;
```

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L209-223)
```rust
    pub fn as_user_transaction_context(&self) -> UserTransactionContext {
        UserTransactionContext::new(
            self.sender,
            self.secondary_signers.clone(),
            self.fee_payer.unwrap_or(self.sender),
            self.max_gas_amount.into(),
            self.gas_unit_price.into(),
            self.chain_id.id(),
            self.entry_function_payload()
                .map(|entry_func| entry_func.as_entry_function_payload()),
            self.multisig_payload()
                .map(|multisig| multisig.as_multisig_payload()),
            self.transaction_index_kind,
        )
    }
```
