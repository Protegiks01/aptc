# Audit Report

## Title
Gas Metering Bypass in Access Control Check: O(n) Stack Iteration Not Charged

## Summary
The `check_access()` function in the Move VM's access control system performs O(n) iteration over the access specifier stack without charging proportional gas, where n can be up to 256 entries. This allows attackers to perform expensive computational work for a fixed gas cost, enabling validator node slowdowns and potential DoS attacks. [1](#0-0) 

## Finding Description
The vulnerability exists in how the Move VM charges gas for access control validation. When any resource operation (borrow_global, exists, move_from, move_to) is performed, the system must validate that the access is allowed by checking all active access specifiers on the stack. [2](#0-1) 

The `check_access()` function iterates over the entire `specifier_stack` in reverse order. The stack can grow up to 256 entries (ACCESS_STACK_SIZE_LIMIT). [3](#0-2) 

Each access specifier is pushed onto the stack when entering a function with a non-`Any` access specifier: [4](#0-3) 

For each specifier on the stack, the `enables()` method is called, which iterates through inclusion and exclusion clauses: [5](#0-4) 

**The critical issue**: Gas is charged for resource operations (borrow_global, exists, etc.) BEFORE the check_access call, but NOT for the O(n*m) iteration work where n=stack depth and m=clauses per specifier: [6](#0-5) 

The GasMeter trait has no method for charging access control checking costs: [7](#0-6) 

**Attack Scenario:**
1. Attacker deploys a Move module with 256 nested function calls
2. Each function has access specifiers with multiple clauses (e.g., `reads R, writes S, reads T`)
3. At the deepest level (256th function), perform 100+ resource accesses
4. Each access triggers check_access() â†’ 100 * 256 = 25,600 specifier checks
5. Gas charged: Only for 256 function calls + 100 resource operations (fixed per-operation cost)
6. Gas NOT charged: The 25,600+ `enables()` checks iterating through clauses

This breaks **Invariant #9** (Resource Limits: All operations must respect gas limits) and **Invariant #3** (Move VM Safety: Bytecode execution must respect gas limits).

## Impact Explanation
This qualifies as **High Severity** under the Aptos bug bounty criteria: "Validator node slowdowns" (up to $50,000).

**Impact:**
- Attackers can craft transactions that force validators to perform O(n*m*k) computation where n=stack depth (256), m=clauses per specifier, k=number of resource accesses
- Gas cost is only O(k), creating a massive computation-to-gas cost imbalance
- Repeated exploitation causes validator node slowdowns affecting block production
- Different validators may experience varying performance degradation based on hardware, potentially affecting consensus timing
- Network-wide spam with such transactions could degrade overall blockchain performance

The issue enables computational DoS attacks against validators at a fraction of the expected gas cost.

## Likelihood Explanation
**Likelihood: High**

The attack is straightforward to execute:
- Any user can deploy Move modules with nested function calls and access specifiers
- No special permissions or validator access required
- Access specifiers (`reads`, `writes`, `acquires`) are a standard Move language feature
- The 256 stack depth limit is sufficient for significant exploitation
- Multiple resource operations at the deepest level amplify the impact

The only barrier is that an attacker needs to understand Move's access control system and craft appropriately nested functions, which is well within the capability of any competent Move developer.

## Recommendation
Implement gas charging proportional to access specifier stack depth in the `check_access()` function. 

**Proposed Fix:**
1. Add a new gas charging method to the GasMeter trait:
```rust
fn charge_access_control_check(&mut self, stack_depth: usize, num_clauses: usize) -> PartialVMResult<()>;
```

2. Modify the interpreter to charge gas before calling check_access:
```rust
// In interpreter.rs, before check_access calls
let stack_depth = self.access_control.stack_depth();
gas_meter.charge_access_control_check(stack_depth, /* estimate clauses */)?;
self.check_access(runtime_environment, kind, ty, addr)?;
```

3. Add a method to AccessControlState to expose stack depth:
```rust
// In access_control.rs
pub(crate) fn stack_depth(&self) -> usize {
    self.specifier_stack.len()
}
```

4. Set appropriate gas costs in the gas schedule that scale with stack depth, for example:
```
ACCESS_CONTROL_CHECK_BASE = 10 gas units
ACCESS_CONTROL_CHECK_PER_DEPTH = 2 gas units
Total cost = BASE + (PER_DEPTH * stack_depth)
```

## Proof of Concept

```move
// File: exploit_access_control.move
module 0x42::exploit {
    struct Resource has key { value: u64 }
    
    // Create 256 nested functions, each with access specifiers
    public fun level_256(addr: address): u64 reads Resource { level_255(addr) }
    public fun level_255(addr: address): u64 reads Resource { level_254(addr) }
    public fun level_254(addr: address): u64 reads Resource { level_253(addr) }
    // ... continue pattern for all 256 levels ...
    public fun level_2(addr: address): u64 reads Resource { level_1(addr) }
    
    public fun level_1(addr: address): u64 reads Resource {
        // At maximum stack depth, perform many resource accesses
        let sum = 0u64;
        let i = 0;
        while (i < 100) {
            // Each exists() triggers check_access() over 256 specifiers
            if (exists<Resource>(addr)) {
                sum = sum + 1;
            };
            i = i + 1;
        };
        sum
    }
    
    // Entry point
    public entry fun exploit(sender: &signer) {
        let addr = signer::address_of(sender);
        move_to(sender, Resource { value: 0 });
        
        // This performs 100 access checks * 256 stack iterations = 25,600 checks
        // But gas is only charged for: 256 function calls + 100 exists operations
        let _ = level_256(addr);
    }
}
```

**To demonstrate:**
1. Deploy the module with 256 nested functions (abbreviated in PoC above)
2. Call `exploit()` as an entry function
3. Observe that gas charged is approximately: `256 * CALL_BASE + 100 * EXISTS_BASE`
4. Actual computation performed: `100 * 256 = 25,600` specifier checks with no corresponding gas charge
5. Repeat in rapid succession to degrade validator performance

## Notes
- The TODO comment in the code acknowledges that stack size limits should be based on gas limits, suggesting awareness of this issue: [8](#0-7) 

- Access specifiers are loaded from Move bytecode and can have arbitrary complexity in terms of inclusion/exclusion clauses: [9](#0-8) 

- The vulnerability affects all resource operations that trigger access control checks: borrow_global, borrow_global_mut, exists, move_from, and move_to.

### Citations

**File:** third_party/move/move-vm/runtime/src/access_control.rs (L26-48)
```rust
    pub(crate) fn enter_function(
        &mut self,
        env: &impl AccessSpecifierEnv,
        fun: &LoadedFunction,
    ) -> PartialVMResult<()> {
        if matches!(fun.access_specifier(), AccessSpecifier::Any) {
            // Shortcut case that no access is specified
            return Ok(());
        }
        if self.specifier_stack.len() >= ACCESS_STACK_SIZE_LIMIT {
            Err(
                PartialVMError::new(StatusCode::ACCESS_STACK_LIMIT_EXCEEDED).with_message(format!(
                    "access specifier stack overflow (limit = {})",
                    ACCESS_STACK_SIZE_LIMIT
                )),
            )
        } else {
            // Specialize the functions access specifier and push it on the stack.
            let mut fun_specifier = fun.access_specifier().clone();
            fun_specifier.specialize(env)?;
            self.specifier_stack.push(fun_specifier);
            Ok(())
        }
```

**File:** third_party/move/move-vm/runtime/src/access_control.rs (L68-77)
```rust
    /// Check whether the given access is allowed in the current state.
    pub(crate) fn check_access(&self, access: AccessInstance) -> PartialVMResult<()> {
        for specifier in self.specifier_stack.iter().rev() {
            if !specifier.enables(&access) {
                return Err(PartialVMError::new(StatusCode::ACCESS_DENIED)
                    .with_message(format!("not allowed to perform `{}`", access)));
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1380-1398)
```rust
        gas_meter.charge_borrow_global(
            is_mut,
            is_generic,
            TypeWithRuntimeEnvironment {
                ty,
                runtime_environment,
            },
            res.is_ok(),
        )?;
        self.check_access(
            runtime_environment,
            if is_mut {
                AccessKind::Writes
            } else {
                AccessKind::Reads
            },
            ty,
            addr,
        )?;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1765-1765)
```rust
// TODO Determine stack size limits based on gas limit
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1768-1768)
```rust
pub(crate) const ACCESS_STACK_SIZE_LIMIT: usize = 256;
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L144-153)
```rust
    pub fn enables(&self, access: &AccessInstance) -> bool {
        use AccessSpecifier::*;
        match self {
            Any => true,
            Constraint(incls, excls) => {
                (incls.is_empty() && !excls.is_empty() || incls.iter().any(|c| c.includes(access)))
                    && excls.iter().all(|c| !c.excludes(access))
            },
        }
    }
```

**File:** third_party/move/move-vm/types/src/gas.rs (L210-330)
```rust
pub trait GasMeter: NativeGasMeter {
    fn balance_internal(&self) -> InternalGas;

    /// Charge an instruction and fail if not enough gas units are left.
    fn charge_simple_instr(&mut self, instr: SimpleInstruction) -> PartialVMResult<()>;

    fn charge_br_true(&mut self, target_offset: Option<CodeOffset>) -> PartialVMResult<()>;

    fn charge_br_false(&mut self, target_offset: Option<CodeOffset>) -> PartialVMResult<()>;

    fn charge_branch(&mut self, target_offset: CodeOffset) -> PartialVMResult<()>;

    fn charge_pop(&mut self, popped_val: impl ValueView) -> PartialVMResult<()>;

    fn charge_call(
        &mut self,
        module_id: &ModuleId,
        func_name: &str,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
        num_locals: NumArgs,
    ) -> PartialVMResult<()>;

    fn charge_call_generic(
        &mut self,
        module_id: &ModuleId,
        func_name: &str,
        ty_args: impl ExactSizeIterator<Item = impl TypeView> + Clone,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
        num_locals: NumArgs,
    ) -> PartialVMResult<()>;

    fn charge_ld_const(&mut self, size: NumBytes) -> PartialVMResult<()>;

    fn charge_ld_const_after_deserialization(&mut self, val: impl ValueView)
        -> PartialVMResult<()>;

    fn charge_copy_loc(&mut self, val: impl ValueView) -> PartialVMResult<()>;

    fn charge_move_loc(&mut self, val: impl ValueView) -> PartialVMResult<()>;

    fn charge_store_loc(&mut self, val: impl ValueView) -> PartialVMResult<()>;

    fn charge_pack(
        &mut self,
        is_generic: bool,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()>;

    fn charge_pack_variant(
        &mut self,
        is_generic: bool,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()> {
        // Currently mapped to pack, can be specialized if needed
        self.charge_pack(is_generic, args)
    }

    fn charge_unpack(
        &mut self,
        is_generic: bool,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()>;

    fn charge_unpack_variant(
        &mut self,
        is_generic: bool,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()> {
        // Currently mapped to pack, can be specialized if needed
        self.charge_unpack(is_generic, args)
    }

    fn charge_pack_closure(
        &mut self,
        is_generic: bool,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()>;

    fn charge_read_ref(&mut self, val: impl ValueView) -> PartialVMResult<()>;

    fn charge_write_ref(
        &mut self,
        new_val: impl ValueView,
        old_val: impl ValueView,
    ) -> PartialVMResult<()>;

    fn charge_eq(&mut self, lhs: impl ValueView, rhs: impl ValueView) -> PartialVMResult<()>;

    fn charge_neq(&mut self, lhs: impl ValueView, rhs: impl ValueView) -> PartialVMResult<()>;

    fn charge_borrow_global(
        &mut self,
        is_mut: bool,
        is_generic: bool,
        ty: impl TypeView,
        is_success: bool,
    ) -> PartialVMResult<()>;

    fn charge_exists(
        &mut self,
        is_generic: bool,
        ty: impl TypeView,
        // TODO(Gas): see if we can get rid of this param
        exists: bool,
    ) -> PartialVMResult<()>;

    fn charge_move_from(
        &mut self,
        is_generic: bool,
        ty: impl TypeView,
        val: Option<impl ValueView>,
    ) -> PartialVMResult<()>;

    fn charge_move_to(
        &mut self,
        is_generic: bool,
        ty: impl TypeView,
        val: impl ValueView,
        is_success: bool,
    ) -> PartialVMResult<()>;

```

**File:** third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs (L19-48)
```rust
/// Loads an access specifier from the file format into the runtime representation.
pub fn load_access_specifier(
    module: BinaryIndexedView,
    signature_table: &[Vec<Type>],
    struct_names: &[StructIdentifier],
    specifier: &Option<Vec<FF::AccessSpecifier>>,
) -> PartialVMResult<AccessSpecifier> {
    if let Some(specs) = specifier {
        let mut incls = vec![];
        let mut excls = vec![];
        for spec in specs {
            let resource =
                load_resource_specifier(module, signature_table, struct_names, &spec.resource)?;
            let address = load_address_specifier(module, &spec.address)?;
            let clause = AccessSpecifierClause {
                kind: spec.kind,
                resource,
                address,
            };
            if spec.negated {
                excls.push(clause)
            } else {
                incls.push(clause)
            }
        }
        Ok(AccessSpecifier::Constraint(incls, excls))
    } else {
        Ok(AccessSpecifier::Any)
    }
}
```
