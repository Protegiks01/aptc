# Audit Report

## Title
Incomplete StatusCode Coverage in LimitExceededError::from_err() Causes Incorrect Error Classification and Potential Consensus Divergence

## Summary
The `LimitExceededError::from_err()` function in `aptos-move/aptos-native-interface/src/errors.rs` uses a non-exhaustive match statement that only handles 6 specific limit-related `StatusCode` variants, while at least 12 other limit-related status codes exist in the codebase. These unmatched codes fall through to a catch-all pattern and are incorrectly classified as `InvariantViolation` errors instead of `LimitExceeded` errors. This violates semantic contracts, creates future-proofing issues, and could lead to consensus divergence if different node versions handle error codes differently.

## Finding Description

The function at [1](#0-0)  only explicitly matches on 6 StatusCode variants (OUT_OF_GAS, EXECUTION_LIMIT_REACHED, DEPENDENCY_LIMIT_REACHED, MEMORY_LIMIT_EXCEEDED, TOO_MANY_TYPE_NODES, VM_MAX_VALUE_DEPTH_REACHED) and maps all other codes to `InvariantViolation` via the catch-all `_` pattern.

However, the StatusCode enum defined at [2](#0-1)  contains numerous additional limit-related variants that are actively used in the codebase, including:

- **IO_LIMIT_REACHED** (4031) - Generated by gas meter at [3](#0-2) 
- **STORAGE_LIMIT_REACHED** (4032) - Generated by gas meter at [4](#0-3) 
- **TYPE_TAG_LIMIT_EXCEEDED** (4033)
- **ACCESS_STACK_LIMIT_EXCEEDED** (4035)
- **TOO_MANY_DELAYED_FIELDS** (4036)
- **ABORT_MESSAGE_LIMIT_EXCEEDED** (4043)
- **STORAGE_WRITE_LIMIT_REACHED** (4027)
- **VM_MAX_TYPE_NODES_REACHED** (4029)
- **MAX_DEPENDENCY_DEPTH_REACHED** (1118)
- **MAX_FUNCTION_DEFINITIONS_REACHED** (1119)
- **MAX_STRUCT_DEFINITIONS_REACHED** (1120)
- **MAX_FIELD_DEFINITIONS_REACHED** (1121)

These errors are user-triggerable limit violations, not internal invariant violations. The function is invoked during gas charging operations in native functions at [5](#0-4)  and [6](#0-5) , meaning any PartialVMError returned by the gas meter passes through this classification logic.

Notably, the VM's own error handling at [7](#0-6)  explicitly treats IO_LIMIT_REACHED, STORAGE_LIMIT_REACHED, TOO_MANY_DELAYED_FIELDS, and UNABLE_TO_CAPTURE_DELAYED_FIELDS as `MiscellaneousError` cases that should charge gas, contradicting their classification as invariant violations in the native context.

The semantic contract violation is documented in the SafeNativeError definition at [8](#0-7) , which states that InvariantViolation indicates "internal errors that shall not normally be triggerable by user inputs." However, limit errors are explicitly user-triggerable.

## Impact Explanation

This issue qualifies as **High severity** under the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: This breaks the **Deterministic Execution** invariant. If upstream Move VM versions add new limit-related status codes, different nodes running different code versions could classify the same error differently, leading to divergent execution paths.

2. **Consensus Risk**: While not an immediate consensus break, this creates a ticking time bomb. When new limit-related StatusCode variants are added to the Move VM (which happens as the protocol evolves), nodes that have updated their Move VM dependency but not the native interface error handling will misclassify these errors. This could cause validators to disagree on transaction outcomes.

3. **Incorrect Error Semantics**: The distinction between `LimitExceeded` and `InvariantViolation` is not merely cosmeticâ€”it signals whether an error is user-triggerable (limit) or represents an internal bug (invariant violation). Misclassification violates the API contract and could affect error handling logic at higher layers.

4. **Gas Charging Inconsistency**: Errors like IO_LIMIT_REACHED and STORAGE_LIMIT_REACHED are already being generated by the gas meter and should be handled as limit violations that charge gas appropriately, not as invariant violations.

## Likelihood Explanation

**Likelihood: High**

This issue has high likelihood of causing problems because:

1. **Active Code Paths**: The affected status codes are actively generated by the gas meter in production code paths, meaning this misclassification occurs in real transaction execution.

2. **Future Evolution**: The Move VM is under active development. New limit-related status codes will inevitably be added as the protocol evolves (e.g., new resource limits, new metering dimensions). Each new addition that isn't explicitly added to the match statement will fall through incorrectly.

3. **Exploitability**: An attacker can intentionally craft transactions that trigger these specific limit errors (e.g., by causing excessive I/O operations or storage operations) to observe and potentially exploit divergent error handling behavior.

4. **Version Skew**: In a distributed system, different nodes may upgrade at different times, creating temporary inconsistencies in how these errors are classified across the network.

## Recommendation

Replace the catch-all pattern with explicit handling for all limit-related status codes. The function should be refactored as follows:

```rust
impl LimitExceededError {
    pub fn from_err(err: PartialVMError) -> SafeNativeError {
        match err.major_status() {
            // Execution limits
            StatusCode::OUT_OF_GAS
            | StatusCode::EXECUTION_LIMIT_REACHED
            | StatusCode::MEMORY_LIMIT_EXCEEDED
            | StatusCode::VM_MAX_VALUE_DEPTH_REACHED
            | StatusCode::IO_LIMIT_REACHED
            | StatusCode::STORAGE_LIMIT_REACHED
            | StatusCode::STORAGE_WRITE_LIMIT_REACHED
            | StatusCode::TYPE_TAG_LIMIT_EXCEEDED
            | StatusCode::ACCESS_STACK_LIMIT_EXCEEDED
            | StatusCode::TOO_MANY_DELAYED_FIELDS
            | StatusCode::ABORT_MESSAGE_LIMIT_EXCEEDED
            | StatusCode::VM_MAX_TYPE_NODES_REACHED
            // Verification/loading limits
            | StatusCode::DEPENDENCY_LIMIT_REACHED
            | StatusCode::TOO_MANY_TYPE_NODES
            | StatusCode::MAX_DEPENDENCY_DEPTH_REACHED
            | StatusCode::MAX_FUNCTION_DEFINITIONS_REACHED
            | StatusCode::MAX_STRUCT_DEFINITIONS_REACHED
            | StatusCode::MAX_FIELD_DEFINITIONS_REACHED
            | StatusCode::UNABLE_TO_CAPTURE_DELAYED_FIELDS => SafeNativeError::LimitExceeded(
                LimitExceededError::LimitExceeded(MeteringError(err)),
            ),
            // All other codes are genuine invariant violations
            _ => SafeNativeError::InvariantViolation(err),
        }
    }
}
```

Additionally, add a compile-time assertion or test to ensure this list stays synchronized with the StatusCode enum definition to prevent future drift.

## Proof of Concept

```rust
#[test]
fn test_limit_status_codes_classified_correctly() {
    use move_binary_format::errors::PartialVMError;
    use move_core_types::vm_status::StatusCode;
    
    // Test that IO_LIMIT_REACHED is classified as LimitExceeded, not InvariantViolation
    let err = PartialVMError::new(StatusCode::IO_LIMIT_REACHED);
    let result = LimitExceededError::from_err(err);
    
    match result {
        SafeNativeError::LimitExceeded(_) => {
            // EXPECTED: Should be classified as a limit error
        }
        SafeNativeError::InvariantViolation(_) => {
            panic!("BUG: IO_LIMIT_REACHED incorrectly classified as InvariantViolation");
        }
        _ => panic!("Unexpected error type"),
    }
    
    // Test STORAGE_LIMIT_REACHED
    let err = PartialVMError::new(StatusCode::STORAGE_LIMIT_REACHED);
    let result = LimitExceededError::from_err(err);
    
    match result {
        SafeNativeError::LimitExceeded(_) => {
            // EXPECTED
        }
        SafeNativeError::InvariantViolation(_) => {
            panic!("BUG: STORAGE_LIMIT_REACHED incorrectly classified as InvariantViolation");
        }
        _ => panic!("Unexpected error type"),
    }
    
    // Test that genuine invariant violations are still classified correctly
    let err = PartialVMError::new(StatusCode::UNREACHABLE);
    let result = LimitExceededError::from_err(err);
    
    match result {
        SafeNativeError::InvariantViolation(_) => {
            // EXPECTED: UNREACHABLE is a genuine invariant violation
        }
        _ => panic!("Genuine invariant violation misclassified"),
    }
}
```

This test demonstrates that the current implementation incorrectly classifies IO_LIMIT_REACHED and STORAGE_LIMIT_REACHED as InvariantViolation when they should be LimitExceeded errors, confirming the vulnerability.

### Citations

**File:** aptos-move/aptos-native-interface/src/errors.rs (L30-47)
```rust
    pub fn from_err(err: PartialVMError) -> SafeNativeError {
        match err.major_status() {
            StatusCode::OUT_OF_GAS
            | StatusCode::EXECUTION_LIMIT_REACHED
            | StatusCode::DEPENDENCY_LIMIT_REACHED
            | StatusCode::MEMORY_LIMIT_EXCEEDED
            | StatusCode::TOO_MANY_TYPE_NODES
            | StatusCode::VM_MAX_VALUE_DEPTH_REACHED => SafeNativeError::LimitExceeded(
                LimitExceededError::LimitExceeded(MeteringError(err)),
            ),
            // Treat all other code as invariant violations and leave it for the VM to propagate
            // these further. Note that we do not remap the errors. For example, if there is a
            // speculative error returned (signaling Block-STM to stop executing this transaction),
            // we better not remap it.
            // TODO(Gas): Have a single method to convert partial VM error to safe native error.
            _ => SafeNativeError::InvariantViolation(err),
        }
    }
```

**File:** aptos-move/aptos-native-interface/src/errors.rs (L70-72)
```rust
    /// Indicating that the native function ran into some internal errors that shall not normally
    /// be triggerable by user inputs.
    InvariantViolation(PartialVMError),
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L255-272)
```rust
            VMStatus::ExecutionFailure {
                status_code:
                    StatusCode::EXECUTION_LIMIT_REACHED
                    | StatusCode::IO_LIMIT_REACHED
                    | StatusCode::STORAGE_LIMIT_REACHED
                    | StatusCode::TOO_MANY_DELAYED_FIELDS
                    | StatusCode::UNABLE_TO_CAPTURE_DELAYED_FIELDS,
                ..
            }
            | VMStatus::Error {
                status_code:
                    StatusCode::EXECUTION_LIMIT_REACHED
                    | StatusCode::IO_LIMIT_REACHED
                    | StatusCode::STORAGE_LIMIT_REACHED
                    | StatusCode::TOO_MANY_DELAYED_FIELDS
                    | StatusCode::UNABLE_TO_CAPTURE_DELAYED_FIELDS,
                ..
            } => Ok(KeptVMStatus::MiscellaneousError),
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L562-976)
```rust
derive_status_try_from_repr! {
#[repr(u64)]
#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]
/// We don't derive Arbitrary on this enum because it is too large and breaks proptest. It is
/// written for a subset of these in proptest_types. We test conversion between this and protobuf
/// with a hand-written test.
pub enum StatusCode {
    // The status of a transaction as determined by the prologue.
    // Validation Errors: 0-999
    // We don't want the default value to be valid
    UNKNOWN_VALIDATION_STATUS = 0,
    // The transaction has a bad signature
    INVALID_SIGNATURE = 1,
    // Bad account authentication key
    INVALID_AUTH_KEY = 2,
    // Sequence number is too old
    SEQUENCE_NUMBER_TOO_OLD = 3,
    // Sequence number is too new
    SEQUENCE_NUMBER_TOO_NEW = 4,
    // Insufficient balance to pay for max_gas specified in the transaction.
    // Balance needs to be above max_gas_amount * gas_unit_price to proceed.
    INSUFFICIENT_BALANCE_FOR_TRANSACTION_FEE = 5,
    // The transaction has expired
    TRANSACTION_EXPIRED = 6,
    // The sending account does not exist
    SENDING_ACCOUNT_DOES_NOT_EXIST = 7,
    // This write set transaction was rejected because it did not meet the
    // requirements for one.
    REJECTED_WRITE_SET = 8,
    // This write set transaction cannot be applied to the current state.
    INVALID_WRITE_SET = 9,
    // Length of program field in raw transaction exceeded max length
    EXCEEDED_MAX_TRANSACTION_SIZE = 10,
    // This script is not in our allowlist of scripts.
    UNKNOWN_SCRIPT = 11,
    // Transaction is trying to publish a new module.
    UNKNOWN_MODULE = 12,
    // Max gas units submitted with transaction exceeds max gas units bound
    // in VM
    MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND = 13,
    // Max gas units submitted with transaction not enough to cover the
    // intrinsic cost of the transaction.
    MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS = 14,
    // Gas unit price submitted with transaction is below minimum gas price
    // set in the VM.
    GAS_UNIT_PRICE_BELOW_MIN_BOUND = 15,
    // Gas unit price submitted with the transaction is above the maximum
    // gas price set in the VM.
    GAS_UNIT_PRICE_ABOVE_MAX_BOUND = 16,
    // Gas specifier submitted is either malformed (not a valid identifier),
    // or does not refer to an accepted gas specifier
    INVALID_GAS_SPECIFIER = 17,
    // The sending account is frozen
    SENDING_ACCOUNT_FROZEN = 18,
    // Unable to deserialize the account blob
    UNABLE_TO_DESERIALIZE_ACCOUNT = 19,
    // The currency info was unable to be found
    CURRENCY_INFO_DOES_NOT_EXIST = 20,
    // The account sender doesn't have permissions to publish modules
    INVALID_MODULE_PUBLISHER = 21,
    // The sending account has no role
    NO_ACCOUNT_ROLE = 22,
    // The transaction's chain_id does not match the one published on-chain
    BAD_CHAIN_ID = 23,
    // The sequence number is too large and would overflow if the transaction were executed
    SEQUENCE_NUMBER_TOO_BIG = 24,
    // The gas currency is not registered as a TransactionFee currency
    BAD_TRANSACTION_FEE_CURRENCY = 25,
    // Discards a transaction, because newly added code path hasn't yet been enabled,
    // and transactions were discarded before the feature was introduced.
    // To be used for example when new variants in the transaction - like new payload or authenticator
    // types are introduced, that wouldn't be deserialized successfully by the previous binary.
    //
    // When the feature is "double" gated, i.e. new bytecode version introduces new things,
    // but we don't want all the be enabled at the same time, such that it is safe to abort,
    // use the verification error code FEATURE_NOT_ENABLED instead.
    FEATURE_UNDER_GATING = 26,
    // The number of secondary signer addresses is different from the number of secondary
    // public keys provided.
    SECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH = 27,
    // There are duplicates among signers, including the sender and all the secondary signers
    SIGNERS_CONTAIN_DUPLICATES = 28,
    // The sequence nonce in the transaction is invalid (too new, too old, or already used).
    SEQUENCE_NONCE_INVALID = 29,
    // There was an error when accessing chain-specific account information
    CHAIN_ACCOUNT_INFO_DOES_NOT_EXIST = 30,
    // Multisig account specific error codes
    ACCOUNT_NOT_MULTISIG = 31,
    NOT_MULTISIG_OWNER = 32,
    MULTISIG_TRANSACTION_NOT_FOUND = 33,
    MULTISIG_TRANSACTION_INSUFFICIENT_APPROVALS = 34,
    MULTISIG_TRANSACTION_PAYLOAD_DOES_NOT_MATCH_HASH = 35,
    GAS_PAYER_ACCOUNT_MISSING = 36,
    INSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT = 37,
    GAS_PARAMS_MISSING = 38,
    REQUIRED_DEPOSIT_INCONSISTENT_WITH_TXN_MAX_GAS = 39,
    MULTISIG_TRANSACTION_PAYLOAD_DOES_NOT_MATCH = 40,
    ACCOUNT_AUTHENTICATION_GAS_LIMIT_EXCEEDED = 41,
    NONCE_ALREADY_USED = 42,
    EMPTY_PAYLOAD_PROVIDED = 43,
    TRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE = 44,
    INVALID_NUMBER_OF_AUTHENTICATION_PROOFS = 45,

    // Reserved error code for future use
    RESERVED_VALIDATION_ERROR_11 = 46,
    RESERVED_VALIDATION_ERROR_12 = 47,
    RESERVED_VALIDATION_ERROR_13 = 48,
    RESERVED_VALIDATION_ERROR_14 = 49,
    RESERVED_VALIDATION_ERROR_15 = 50,


    // When a code module/script is published it is verified. These are the
    // possible errors that can arise from the verification process.
    // Verification Errors: 1000-1999
    UNKNOWN_VERIFICATION_ERROR = 1000,
    INDEX_OUT_OF_BOUNDS = 1001,
    INVALID_SIGNATURE_TOKEN = 1003,
    RECURSIVE_STRUCT_DEFINITION = 1005,
    FIELD_MISSING_TYPE_ABILITY = 1006,
    INVALID_FALL_THROUGH = 1007,
    NEGATIVE_STACK_SIZE_WITHIN_BLOCK = 1009,
    INVALID_MAIN_FUNCTION_SIGNATURE = 1011,
    DUPLICATE_ELEMENT = 1012,
    INVALID_MODULE_HANDLE = 1013,
    UNIMPLEMENTED_HANDLE = 1014,
    LOOKUP_FAILED = 1017,
    TYPE_MISMATCH = 1020,
    MISSING_DEPENDENCY = 1021,
    POP_WITHOUT_DROP_ABILITY = 1023,
    BR_TYPE_MISMATCH_ERROR = 1025,
    ABORT_TYPE_MISMATCH_ERROR = 1026,
    STLOC_TYPE_MISMATCH_ERROR = 1027,
    STLOC_UNSAFE_TO_DESTROY_ERROR = 1028,
    UNSAFE_RET_LOCAL_OR_RESOURCE_STILL_BORROWED = 1029,
    RET_TYPE_MISMATCH_ERROR = 1030,
    RET_BORROWED_MUTABLE_REFERENCE_ERROR = 1031,
    FREEZEREF_TYPE_MISMATCH_ERROR = 1032,
    FREEZEREF_EXISTS_MUTABLE_BORROW_ERROR = 1033,
    BORROWFIELD_TYPE_MISMATCH_ERROR = 1034,
    BORROWFIELD_BAD_FIELD_ERROR = 1035,
    BORROWFIELD_EXISTS_MUTABLE_BORROW_ERROR = 1036,
    COPYLOC_UNAVAILABLE_ERROR = 1037,
    COPYLOC_WITHOUT_COPY_ABILITY = 1038,
    COPYLOC_EXISTS_BORROW_ERROR = 1039,
    MOVELOC_UNAVAILABLE_ERROR = 1040,
    MOVELOC_EXISTS_BORROW_ERROR = 1041,
    BORROWLOC_REFERENCE_ERROR = 1042,
    BORROWLOC_UNAVAILABLE_ERROR = 1043,
    BORROWLOC_EXISTS_BORROW_ERROR = 1044,
    CALL_TYPE_MISMATCH_ERROR = 1045,
    CALL_BORROWED_MUTABLE_REFERENCE_ERROR = 1046,
    PACK_TYPE_MISMATCH_ERROR = 1047,
    UNPACK_TYPE_MISMATCH_ERROR = 1048,
    READREF_TYPE_MISMATCH_ERROR = 1049,
    READREF_WITHOUT_COPY_ABILITY = 1050,
    READREF_EXISTS_MUTABLE_BORROW_ERROR = 1051,
    WRITEREF_TYPE_MISMATCH_ERROR = 1052,
    WRITEREF_WITHOUT_DROP_ABILITY = 1053,
    WRITEREF_EXISTS_BORROW_ERROR = 1054,
    WRITEREF_NO_MUTABLE_REFERENCE_ERROR = 1055,
    INTEGER_OP_TYPE_MISMATCH_ERROR = 1056,
    BOOLEAN_OP_TYPE_MISMATCH_ERROR = 1057,
    EQUALITY_OP_TYPE_MISMATCH_ERROR = 1058,
    EXISTS_WITHOUT_KEY_ABILITY_OR_BAD_ARGUMENT = 1059,
    BORROWGLOBAL_TYPE_MISMATCH_ERROR = 1060,
    BORROWGLOBAL_WITHOUT_KEY_ABILITY= 1061,
    MOVEFROM_TYPE_MISMATCH_ERROR = 1062,
    MOVEFROM_WITHOUT_KEY_ABILITY = 1063,
    MOVETO_TYPE_MISMATCH_ERROR = 1064,
    MOVETO_WITHOUT_KEY_ABILITY= 1065,
    // The self address of a module the transaction is publishing is not the sender address
    MODULE_ADDRESS_DOES_NOT_MATCH_SENDER = 1067,
    // The module does not have any module handles. Each module or script must have at least one
    // module handle.
    NO_MODULE_HANDLES = 1068,
    POSITIVE_STACK_SIZE_AT_BLOCK_END = 1069,
    MISSING_ACQUIRES_ANNOTATION = 1070,
    EXTRANEOUS_ACQUIRES_ANNOTATION = 1071,
    DUPLICATE_ACQUIRES_ANNOTATION = 1072,
    INVALID_ACQUIRES_ANNOTATION = 1073,
    GLOBAL_REFERENCE_ERROR = 1074,
    CONSTRAINT_NOT_SATISFIED = 1075,
    NUMBER_OF_TYPE_ARGUMENTS_MISMATCH = 1076,
    LOOP_IN_INSTANTIATION_GRAPH = 1077,
    // Reported when a struct has zero fields
    ZERO_SIZED_STRUCT = 1080,
    LINKER_ERROR = 1081,
    INVALID_CONSTANT_TYPE = 1082,
    MALFORMED_CONSTANT_DATA = 1083,
    EMPTY_CODE_UNIT = 1084,
    INVALID_LOOP_SPLIT = 1085,
    INVALID_LOOP_BREAK = 1086,
    INVALID_LOOP_CONTINUE = 1087,
    UNSAFE_RET_UNUSED_VALUES_WITHOUT_DROP = 1088,
    TOO_MANY_LOCALS = 1089,
    GENERIC_MEMBER_OPCODE_MISMATCH = 1090,
    FUNCTION_RESOLUTION_FAILURE = 1091,
    INVALID_OPERATION_IN_SCRIPT = 1094,
    // The sender is trying to publish two modules with the same name in one transaction
    DUPLICATE_MODULE_NAME = 1095,
    // The sender is trying to publish a module that breaks the compatibility checks
    BACKWARD_INCOMPATIBLE_MODULE_UPDATE = 1096,
    // The updated module introduces a cyclic dependency (i.e., A uses B and B also uses A)
    CYCLIC_MODULE_DEPENDENCY = 1097,
    NUMBER_OF_ARGUMENTS_MISMATCH = 1098,
    INVALID_PARAM_TYPE_FOR_DESERIALIZATION = 1099,
    FAILED_TO_DESERIALIZE_ARGUMENT = 1100,
    NUMBER_OF_SIGNER_ARGUMENTS_MISMATCH = 1101,
    CALLED_SCRIPT_VISIBLE_FROM_NON_SCRIPT_VISIBLE = 1102,
    EXECUTE_ENTRY_FUNCTION_CALLED_ON_NON_ENTRY_FUNCTION = 1103,
    // Cannot mark the module itself as a friend
    INVALID_FRIEND_DECL_WITH_SELF = 1104,
    // Cannot declare modules outside of account address as friends
    INVALID_FRIEND_DECL_WITH_MODULES_OUTSIDE_ACCOUNT_ADDRESS = 1105,
    // Cannot declare modules that this module depends on as friends
    INVALID_FRIEND_DECL_WITH_MODULES_IN_DEPENDENCIES = 1106,
    // The updated module introduces a cyclic friendship (i.e., A friends B and B also friends A)
    CYCLIC_MODULE_FRIENDSHIP = 1107,
    // A phantom type parameter was used in a non-phantom position.
    INVALID_PHANTOM_TYPE_PARAM_POSITION = 1108,
    VEC_UPDATE_EXISTS_MUTABLE_BORROW_ERROR = 1109,
    VEC_BORROW_ELEMENT_EXISTS_MUTABLE_BORROW_ERROR = 1110,
    // Loops are too deeply nested.
    LOOP_MAX_DEPTH_REACHED = 1111,
    TOO_MANY_TYPE_PARAMETERS = 1112,
    TOO_MANY_PARAMETERS = 1113,
    TOO_MANY_BASIC_BLOCKS = 1114,
    VALUE_STACK_OVERFLOW = 1115,
    TOO_MANY_TYPE_NODES = 1116,
    VALUE_STACK_PUSH_OVERFLOW = 1117,
    MAX_DEPENDENCY_DEPTH_REACHED = 1118,
    MAX_FUNCTION_DEFINITIONS_REACHED = 1119,
    MAX_STRUCT_DEFINITIONS_REACHED = 1120,
    MAX_FIELD_DEFINITIONS_REACHED = 1121,
    TOO_MANY_BACK_EDGES = 1122,
    EVENT_METADATA_VALIDATION_ERROR = 1123,
    DEPENDENCY_LIMIT_REACHED = 1124,
    // This error indicates that unstable bytecode generated by the compiler cannot be published to mainnet
    UNSTABLE_BYTECODE_REJECTED = 1125,
    PROGRAM_TOO_COMPLEX = 1126,
    USER_DEFINED_NATIVE_NOT_ALLOWED = 1127,
    // Bound on the number of struct variants per struct exceeded.
    MAX_STRUCT_VARIANTS_REACHED = 1128,
    // A variant test has wrong argument type
    TEST_VARIANT_TYPE_MISMATCH_ERROR = 1129,
    // A variant list is empty
    ZERO_VARIANTS_ERROR = 1130,
    // A feature is not enabled, and transaction will abort and be committed on chain.
    // Use only when there is no backward incompatibility concern - as it is
    // double-gated by an additional flag, i.e. new bytecode version introduces new things,
    // but we don't want all the be enabled at the same time, such that it is safe to abort.
    //
    // If we are introducing code, that previous binary would discard such a transaction,
    // you need to use FEATURE_UNDER_GATING flag instead.
    FEATURE_NOT_ENABLED = 1131,
    // Closure mask invalid
    INVALID_CLOSURE_MASK = 1132,
    // Closure eval type is not a function
    CLOSURE_CALL_REQUIRES_FUNCTION = 1133,
    // Returned if init_module function is not valid during code publishing.
    INVALID_INIT_MODULE = 1134,
    // When publishing a module bundle, all friends declared there must be in this bundle. If it is
    // not the case, an error with this status code is returned.
    FRIEND_NOT_FOUND_IN_MODULE_BUNDLE = 1135,

    // Reserved error code for future use
    RESERVED_VERIFICATION_ERROR_1 = 1136,
    RESERVED_VERIFICATION_ERROR_2 = 1137,
    RESERVED_VERIFICATION_ERROR_3 = 1138,
    RESERVED_VERIFICATION_ERROR_4 = 1139,

    // These are errors that the VM might raise if a violation of internal
    // invariants takes place.
    // Invariant Violation Errors: 2000-2999
    UNKNOWN_INVARIANT_VIOLATION_ERROR = 2000,
    EMPTY_VALUE_STACK = 2003,
    PC_OVERFLOW = 2005,
    VERIFICATION_ERROR = 2006,
    STORAGE_ERROR = 2008,
    INTERNAL_TYPE_ERROR = 2009,
    EVENT_KEY_MISMATCH = 2010,
    UNREACHABLE = 2011,
    VM_STARTUP_FAILURE = 2012,
    UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION = 2015,
    VERIFIER_INVARIANT_VIOLATION = 2016,
    UNEXPECTED_VERIFIER_ERROR = 2017,
    UNEXPECTED_DESERIALIZATION_ERROR = 2018,
    FAILED_TO_SERIALIZE_WRITE_SET_CHANGES = 2019,
    FAILED_TO_DESERIALIZE_RESOURCE = 2020,
    // Failed to resolve type due to linking being broken after verification
    TYPE_RESOLUTION_FAILURE = 2021,
    DUPLICATE_NATIVE_FUNCTION = 2022,
    // code invariant error while handling delayed materialization, should never happen,
    // always indicates a code bug. Delayed materialization includes handling of
    // Resource Groups and Delayed Fields. Unlike regular CODE_INVARIANT_ERROR, this
    // is a signal to BlockSTM, which it might do something about (i.e. fallback to
    // sequential execution).
    // Note: This status is created both from third_party (move) and block executor
    // (aptos-move in the adapter). In the later case, it can now also represent more
    // general invariant violations beyond delayed fields, due to the convenience of
    // handling such issues with asserts (e.g. by falling back to sequential execution).
    // TODO: can be audited and broken down into specific types, once implementation
    // is also not duplicated.
    DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR = 2023,
    // Speculative error means that there was an issue because of speculative
    // reads provided to the transaction, and the transaction needs to
    // be re-executed.
    // Should never be committed on chain
    SPECULATIVE_EXECUTION_ABORT_ERROR = 2024,
    ACCESS_CONTROL_INVARIANT_VIOLATION = 2025,

    // Reserved error code for future use
    RESERVED_INVARIANT_VIOLATION_ERROR_1 = 2026,
    RESERVED_INVARIANT_VIOLATION_ERROR_2 = 2027,
    RESERVED_INVARIANT_VIOLATION_ERROR_3 = 2028,
    RESERVED_INVARIANT_VIOLATION_ERROR_4 = 2039,
    RESERVED_INVARIANT_VIOLATION_ERROR_5 = 2040,

    // Errors that can arise from binary decoding (deserialization)
    // Deserialization Errors: 3000-3999
    UNKNOWN_BINARY_ERROR = 3000,
    MALFORMED = 3001,
    BAD_MAGIC = 3002,
    UNKNOWN_VERSION = 3003,
    UNKNOWN_TABLE_TYPE = 3004,
    UNKNOWN_SIGNATURE_TYPE = 3005,
    UNKNOWN_SERIALIZED_TYPE = 3006,
    UNKNOWN_OPCODE = 3007,
    BAD_HEADER_TABLE = 3008,
    UNEXPECTED_SIGNATURE_TYPE = 3009,
    DUPLICATE_TABLE = 3010,
    UNKNOWN_ABILITY = 3013,
    UNKNOWN_NATIVE_STRUCT_FLAG = 3014,
    BAD_U16 = 3017,
    BAD_U32 = 3018,
    BAD_U64 = 3019,
    BAD_U128 = 3020,
    BAD_U256 = 3021,
    VALUE_SERIALIZATION_ERROR = 3022,
    VALUE_DESERIALIZATION_ERROR = 3023,
    CODE_DESERIALIZATION_ERROR = 3024,
    INVALID_FLAG_BITS = 3025,
    // Returned when a function value is trying to capture an option. This is not allowed
    // until the feature flag ENABLE_CAPTURE_OPTION is on.
    UNABLE_TO_CAPTURE_OPTION_TYPE = 3026,

    // Reserved error code for future use
    RESERVED_DESERIALIZAION_ERROR_1 = 3027,
    RESERVED_DESERIALIZAION_ERROR_2 = 3028,
    RESERVED_DESERIALIZAION_ERROR_3 = 3029,
    RESERVED_DESERIALIZAION_ERROR_4 = 3030,
    RESERVED_DESERIALIZAION_ERROR_5 = 3031,

    // Errors that can arise at runtime
    // Runtime Errors: 4000-4999
    UNKNOWN_RUNTIME_STATUS = 4000,
    EXECUTED = 4001,
    OUT_OF_GAS = 4002,
    // We tried to access a resource that does not exist under the account.
    RESOURCE_DOES_NOT_EXIST = 4003,
    // We tried to create a resource under an account where that resource
    // already exists.
    RESOURCE_ALREADY_EXISTS = 4004,
    MISSING_DATA = 4008,
    DATA_FORMAT_ERROR = 4009,
    ABORTED = 4016,
    ARITHMETIC_ERROR = 4017,
    VECTOR_OPERATION_ERROR = 4018,
    EXECUTION_STACK_OVERFLOW = 4020,
    CALL_STACK_OVERFLOW = 4021,
    VM_MAX_TYPE_DEPTH_REACHED = 4024,
    VM_MAX_VALUE_DEPTH_REACHED = 4025,
    VM_EXTENSION_ERROR = 4026,
    STORAGE_WRITE_LIMIT_REACHED = 4027,
    MEMORY_LIMIT_EXCEEDED = 4028,
    VM_MAX_TYPE_NODES_REACHED = 4029,
    EXECUTION_LIMIT_REACHED = 4030,
    IO_LIMIT_REACHED = 4031,
    STORAGE_LIMIT_REACHED = 4032,
    TYPE_TAG_LIMIT_EXCEEDED = 4033,
    // A resource was accessed in a way which is not permitted by the active access control
    // specifier.
    ACCESS_DENIED = 4034,
    // The stack of access control specifier has overflowed.
    ACCESS_STACK_LIMIT_EXCEEDED = 4035,
    // We tried to create resource with more than currently allowed number of DelayedFields
    TOO_MANY_DELAYED_FIELDS = 4036,
    // Dynamic function call errors.
    RUNTIME_DISPATCH_ERROR = 4037,
    // Struct variant not matching. This error appears on an attempt to unpack or borrow a
    // field from a value which is not of the expected variant.
    STRUCT_VARIANT_MISMATCH = 4038,
    // An unimplemented functionality in the VM.
    UNIMPLEMENTED_FUNCTIONALITY = 4039,
    // Modules are cyclic (module A uses module B which uses module A). Detected at runtime in case
    // module loading is performed lazily.
    RUNTIME_CYCLIC_MODULE_DEPENDENCY = 4040,
    // Returned when a function value is trying to capture a delayed field. This is not allowed
    // because layouts for values with delayed fields are not serializable.
    UNABLE_TO_CAPTURE_DELAYED_FIELDS = 4041,
    // The abort message is not a valid UTF-8 string.
    INVALID_ABORT_MESSAGE = 4042,
    // The abort message exceeded the size limit.
    ABORT_MESSAGE_LIMIT_EXCEEDED = 4043,

    // Reserved error code for future use. Always keep this buffer of well-defined new codes.
    RESERVED_RUNTIME_ERROR_1 = 4044,
    RESERVED_RUNTIME_ERROR_2 = 4045,
    RESERVED_RUNTIME_ERROR_3 = 4046,

    // A reserved status to represent an unknown vm status.
    // this is u64::MAX, but we can't pattern match on that, so put the hardcoded value in
    UNKNOWN_STATUS = 18446744073709551615,
}
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L232-233)
```rust
        if self.feature_version >= 7 && self.io_gas_used > self.max_io_gas {
            Err(PartialVMError::new(StatusCode::IO_LIMIT_REACHED))
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L293-294)
```rust
        if self.feature_version >= 7 && self.storage_fee_used > self.max_storage_fee {
            return Err(PartialVMError::new(StatusCode::STORAGE_LIMIT_REACHED));
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L86-89)
```rust
        if self.has_direct_gas_meter_access_in_native_context() {
            self.gas_meter()
                .charge_native_execution(amount)
                .map_err(LimitExceededError::from_err)?;
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L207-210)
```rust
            if self.has_direct_gas_meter_access_in_native_context() {
                self.gas_meter()
                    .use_heap_memory_in_native_context(amount)
                    .map_err(LimitExceededError::from_err)?;
```
