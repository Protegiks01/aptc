# Audit Report

## Title
Missing Defense-in-Depth: Critical Validations Skipped When `ledger_info_with_sigs` is None in Commit Path

## Summary
The `commit_ledger` function skips critical validations (root hash verification, epoch continuity checks, and state checkpoint verification) when `ledger_info_with_sigs` is `None`. While the state sync path has protections via `StateSyncChunkVerifier`, the database commit layer lacks independent verification, creating a defense-in-depth gap that could lead to database corruption if upstream protections fail or are bypassed.

## Finding Description

When `commit_ledger` is invoked with `ledger_info_with_sigs = None`, three critical validation steps are skipped: [1](#0-0) 

**1. Root Hash Verification** - When a ledger info is provided, the system verifies that the transaction accumulator root hash in the database matches the signed ledger info: [2](#0-1) 

**2. Epoch Continuity Verification** - Ensures no gaps in epoch progression: [3](#0-2) 

**3. State Checkpoint Verification** - Ensures state snapshots exist at epoch boundaries: [4](#0-3) 

The storage interface explicitly documents this behavior: [5](#0-4) 

**State Sync Path Protection:**

For state sync, `StateSyncChunkVerifier` enforces that epoch-ending chunks must have ledger infos: [6](#0-5) 

This ensures that if execution produces a `next_epoch_state`, a ledger info must be provided, or the operation errors.

**Backup Restore Path Vulnerability:**

However, the backup restore path uses `ReplayChunkVerifier` which ALWAYS returns `None`: [7](#0-6) 

This is used in production backup restore operations: [8](#0-7) 

During backup restore, epoch-ending chunks are committed without ledger infos, skipping all critical database-level validations. While backup data is expected to be trusted, corrupted or maliciously crafted backups could result in:
- Missing state checkpoints at epoch boundaries
- Incorrect epoch progression in the database
- Inconsistent transaction accumulator state

## Impact Explanation

**High Severity** - This represents a significant protocol violation and defense-in-depth failure. If exploited through corrupted backup data or a future bug in chunk verification, it could lead to:

1. **Database Corruption**: Missing epoch snapshots would break state sync for other nodes trying to sync from this node
2. **Consensus Divergence**: Incorrect epoch boundaries could cause nodes to disagree on validator sets
3. **State Inconsistency**: Missing validations could allow accumulator corruption to persist

While not directly exploitable by external attackers (requires operational access or upstream bugs), this violates the principle that the storage layer should independently verify critical invariants rather than trusting all callers.

## Likelihood Explanation

**Medium Likelihood** for the defense-in-depth issue to be triggered:
- Backup restore operations occur regularly in production
- Corrupted backups (due to storage issues, bugs, or operational errors) could trigger the issue
- Any future bug in `StateSyncChunkVerifier` would not be caught by the database layer

The lack of independent verification at the commit layer means a single point of failure in upstream validation could lead to database corruption.

## Recommendation

Add independent validation in `commit_ledger` for epoch-critical invariants, even when `ledger_info_with_sigs` is `None`:

```rust
fn commit_ledger(
    &self,
    version: Version,
    ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
    chunk_opt: Option<ChunkToCommit>,
) -> Result<()> {
    // ... existing code ...
    
    let old_committed_ver = self.get_and_check_commit_range(version)?;
    
    let mut ledger_batch = SchemaBatch::new();
    
    // NEW: Check if this version ends an epoch, even without ledger_info
    if let Some(chunk) = &chunk_opt {
        if chunk.is_reconfig {
            // Verify state checkpoint exists at epoch boundary
            let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
            ensure!(
                state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
                "State checkpoint required at epoch boundary for version {}",
                version
            );
        }
    }
    
    // Write down LedgerInfo if provided
    if let Some(li) = ledger_info_with_sigs {
        self.check_and_put_ledger_info(version, li, &mut ledger_batch)?;
    }
    
    // ... rest of existing code ...
}
```

Additionally, consider requiring `ReplayChunkVerifier` to provide epoch-ending ledger infos during backup restore, or implement separate epoch boundary validation.

## Proof of Concept

The vulnerability manifests during backup restore operations. To demonstrate:

```rust
// In backup restore path:
// 1. Create backup data with epoch boundary at version 1500
// 2. Ensure no epoch_change_li is provided for that chunk
// 3. ReplayChunkVerifier returns None (line 151 of chunk_result_verifier.rs)
// 4. commit_ledger is called with ledger_info_with_sigs = None
// 5. State checkpoint validation at lines 585-594 is skipped
// 6. Database commits version 1500 without verifying state snapshot exists
// 7. Result: Database missing required epoch snapshot

// To test:
// 1. Use backup-cli to restore from a backup
// 2. Inject a chunk at an epoch boundary without providing epoch ledger info
// 3. Verify that state checkpoint validation is skipped
// 4. Check database after restore - epoch snapshot will be missing
// 5. Attempt to sync another node from this node - will fail at epoch boundary
```

The issue is demonstrable by examining the code paths where `ledger_info_with_sigs = None` is passed through `save_transactions` to `commit_ledger`, bypassing the validation checks at lines 540-601 of aptosdb_writer.rs.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L99-101)
```rust
            if let Some(li) = ledger_info_with_sigs {
                self.check_and_put_ledger_info(version, li, &mut ledger_batch)?;
            }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L557-569)
```rust
        let db_root_hash = self
            .ledger_db
            .transaction_accumulator_db()
            .get_root_hash(version)?;
        let li_root_hash = ledger_info_with_sig
            .ledger_info()
            .transaction_accumulator_hash();
        ensure!(
            db_root_hash == li_root_hash,
            "Root hash pre-committed doesn't match LedgerInfo. pre-commited: {:?} vs in LedgerInfo: {:?}",
            db_root_hash,
            li_root_hash,
        );
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L572-582)
```rust
        let current_epoch = self
            .ledger_db
            .metadata_db()
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            ledger_info_with_sig.ledger_info().epoch() == current_epoch,
            "Gap in epoch history. Trying to put in LedgerInfo in epoch: {}, current epoch: {}",
            ledger_info_with_sig.ledger_info().epoch(),
            current_epoch,
        );
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L585-594)
```rust
        if ledger_info_with_sig.ledger_info().ends_epoch() {
            let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
            ensure!(
                state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
                "State checkpoint not persisted at the end of the epoch, version {}, next_epoch {}, snapshot in db: {:?}",
                version,
                ledger_info_with_sig.ledger_info().next_block_epoch(),
                state_snapshot,
            );
        }
```

**File:** storage/storage-interface/src/lib.rs (L645-646)
```rust
    /// If a LedgerInfoWithSigs is provided, both the "synced version" and "committed version" will
    /// advance, otherwise only the synced version will advance.
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L119-125)
```rust
            ensure!(
                next_epoch_state.is_none(),
                "End of epoch chunk based on local computation but no EoE LedgerInfo provided. version: {:?}",
                txn_accumulator.num_leaves().checked_sub(1),
            );
            Ok(None)
        }
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L146-152)
```rust
    fn maybe_select_chunk_ending_ledger_info(
        &self,
        _ledger_update_output: &LedgerUpdateOutput,
        _next_epoch_state: Option<&EpochState>,
    ) -> Result<Option<LedgerInfoWithSignatures>> {
        Ok(None)
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L673-683)
```rust
                    let _timer = OTHER_TIMERS_SECONDS.timer_with(&["enqueue_chunks"]);

                    tokio::task::spawn_blocking(move || {
                        chunk_replayer.enqueue_chunks(
                            txns,
                            persisted_aux_info,
                            txn_infos,
                            write_sets,
                            events,
                            &verify_execution_mode,
                        )
```
