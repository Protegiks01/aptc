# Audit Report

## Title
Missing Expiration Validation in BatchMsg Allows Extended Storage Retention

## Summary
The `BatchMsg::verify()` function lacks upper-bound validation on batch expiration times, unlike `SignedBatchInfo::verify()`. This allows validators to broadcast batches with arbitrarily far-future expirations, causing extended storage retention. However, the per-peer quota system limits the practical impact.

## Finding Description
The Aptos consensus quorum store has two message types for batch propagation:

1. **SignedBatchInfoMsg** - Contains batch metadata with signatures, validated by `SignedBatchInfo::verify()` which enforces: [1](#0-0) 
   
   This check ensures `expiration <= current_time + max_batch_expiry_gap_usecs` (default 60 seconds).

2. **BatchMsg** - Contains full batches with transactions, validated by `BatchMsg::verify()` which does NOT check expiration upper bounds: [2](#0-1) 

When validators create local batches, they set reasonable expiration: [3](#0-2) 

However, a malicious validator could modify their code to set `expiration = current_time + 1 year` and broadcast via: [4](#0-3) 

When honest validators receive this BatchMsg, verification passes because `Batch::verify()` only checks structural properties: [5](#0-4) 

The batches are persisted, but `BatchStore::save()` only validates `expiration > last_certified_time`: [6](#0-5) 

Cleanup occurs based on expiration time: [7](#0-6) 

With far-future expiration, batches persist until `certified_time - 60 seconds >= expiration`, potentially for extended periods.

## Impact Explanation
**Severity: Low** (not Medium as initially suggested)

The impact is **significantly mitigated** by the per-peer quota system: [8](#0-7) 

Each peer has limits:
- `db_quota: 300_000_000` bytes (300 MB)
- `memory_quota: 120_000_000` bytes (120 MB)  
- `batch_quota: 300_000` batches

The quota prevents unbounded storage growth. A malicious validator can only lock up 300 MB of storage on other nodes, not cause true "storage exhaustion." The quota is managed per-peer: [9](#0-8) 

This reduces the finding from Medium to **Low severity** - it's a logic inconsistency that allows quota lockup but cannot cause network-wide storage exhaustion as the quota system was designed precisely to prevent this attack vector.

## Likelihood Explanation
Low likelihood because:
- Requires a malicious validator willing to modify their node software
- Only affects their own quota allocation on other nodes
- Provides minimal strategic advantage to the attacker
- Easy to detect through monitoring

## Recommendation
Add expiration validation to `BatchMsg::verify()` and `Batch::verify()` consistent with `SignedBatchInfo::verify()`:

```rust
pub fn verify(
    &self,
    peer_id: PeerId,
    max_num_batches: usize,
    max_batch_expiry_gap_usecs: u64,
    verifier: &ValidatorVerifier,
) -> anyhow::Result<()> {
    // ... existing checks ...
    
    for batch in self.batches.iter() {
        // Add expiration check
        if batch.expiration() > aptos_infallible::duration_since_epoch().as_micros() as u64 
            + max_batch_expiry_gap_usecs 
        {
            bail!(
                "Batch expiration too far in future: {} > {}",
                batch.expiration(),
                aptos_infallible::duration_since_epoch().as_micros() as u64 
                    + max_batch_expiry_gap_usecs
            );
        }
        
        // ... existing checks ...
    }
    Ok(())
}
```

## Proof of Concept
This requires modifying validator node code, which is impractical for a typical PoC. The attack scenario is:

1. Modify `batch_generator.rs:383-384` to set `expiry_time = current_time + Duration::from_days(365).as_micros()`
2. Run modified validator node
3. Observe batches being accepted by honest validators
4. Monitor that batches persist in storage until quota exhausted
5. Verify cleanup only occurs after extended period

**However**, due to quota limits, the maximum impact is 300 MB per peer, not network-wide exhaustion. The quota system makes this a **minor issue** rather than a critical vulnerability.

## Notes
Upon thorough analysis, while the expiration validation is indeed missing from `BatchMsg::verify()`, the per-peer quota system provides robust defense-in-depth that prevents the "storage exhaustion" outcome described in the security question. The maximum bounded impact (300 MB per malicious peer) does not constitute a Medium severity vulnerability per Aptos bug bounty criteria, making this a Low severity logic inconsistency at most.

### Citations

**File:** consensus/consensus-types/src/proof_of_store.rs (L469-478)
```rust
        if self.expiration()
            > aptos_infallible::duration_since_epoch().as_micros() as u64
                + max_batch_expiry_gap_usecs
        {
            bail!(
                "Batch expiration too far in future: {} > {}",
                self.expiration(),
                aptos_infallible::duration_since_epoch().as_micros() as u64
                    + max_batch_expiry_gap_usecs
            );
```

**File:** consensus/src/quorum_store/types.rs (L262-290)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        ensure!(
            self.payload.author() == self.author(),
            "Payload author doesn't match the info"
        );
        ensure!(
            self.payload.hash() == *self.digest(),
            "Payload hash doesn't match the digest"
        );
        ensure!(
            self.payload.num_txns() as u64 == self.num_txns(),
            "Payload num txns doesn't match batch info"
        );
        ensure!(
            self.payload.num_bytes() as u64 == self.num_bytes(),
            "Payload num bytes doesn't match batch info"
        );
        for txn in self.payload.txns() {
            ensure!(
                txn.gas_unit_price() >= self.gas_bucket_start(),
                "Payload gas unit price doesn't match batch info"
            );
            ensure!(
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/types.rs (L433-461)
```rust
    pub fn verify(
        &self,
        peer_id: PeerId,
        max_num_batches: usize,
        verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(!self.batches.is_empty(), "Empty message");
        ensure!(
            self.batches.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.batches.len(),
            max_num_batches
        );
        let epoch_authors = verifier.address_to_validator_index();
        for batch in self.batches.iter() {
            ensure!(
                epoch_authors.contains_key(&batch.author()),
                "Invalid author {} for batch {} in current epoch",
                batch.author(),
                batch.digest()
            );
            ensure!(
                batch.author() == peer_id,
                "Batch author doesn't match sender"
            );
            batch.verify()?
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L383-384)
```rust
        let expiry_time = aptos_infallible::duration_since_epoch().as_micros() as u64
            + self.config.batch_expiry_gap_when_init_usecs;
```

**File:** consensus/src/quorum_store/batch_generator.rs (L495-495)
```rust
                                network_sender.broadcast_batch_msg_v2(batches).await;
```

**File:** consensus/src/quorum_store/batch_store.rs (L342-348)
```rust
    fn free_quota(&self, value: PersistedValue<BatchInfoExt>) {
        let mut quota_manager = self
            .peer_quota
            .get_mut(&value.author())
            .expect("No QuotaManager for batch author");
        quota_manager.free_quota(value.num_bytes() as usize, value.payload_storage_mode());
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L419-438)
```rust
    pub(crate) fn save(&self, value: &PersistedValue<BatchInfoExt>) -> anyhow::Result<bool> {
        let last_certified_time = self.last_certified_time();
        if value.expiration() > last_certified_time {
            fail_point!("quorum_store::save", |_| {
                // Skip caching and storing value to the db
                Ok(false)
            });
            counters::GAP_BETWEEN_BATCH_EXPIRATION_AND_CURRENT_TIME_WHEN_SAVE.observe(
                Duration::from_micros(value.expiration() - last_certified_time).as_secs_f64(),
            );

            return self.insert_to_cache(value);
        }
        counters::NUM_BATCH_EXPIRED_WHEN_SAVE.inc();
        bail!(
            "Incorrect expiration {} in epoch {}, last committed timestamp {}",
            value.expiration(),
            self.epoch(),
            last_certified_time,
        );
```

**File:** consensus/src/quorum_store/batch_store.rs (L443-472)
```rust
    pub(crate) fn clear_expired_payload(&self, certified_time: u64) -> Vec<HashValue> {
        // To help slow nodes catch up via execution without going to state sync we keep the blocks for 60 extra seconds
        // after the expiration time. This will help remote peers fetch batches that just expired but are within their
        // execution window.
        let expiration_time = certified_time.saturating_sub(self.expiration_buffer_usecs);
        let expired_digests = self.expirations.lock().expire(expiration_time);
        let mut ret = Vec::new();
        for h in expired_digests {
            let removed_value = match self.db_cache.entry(h) {
                Occupied(entry) => {
                    // We need to check up-to-date expiration again because receiving the same
                    // digest with a higher expiration would update the persisted value and
                    // effectively extend the expiration.
                    if entry.get().expiration() <= expiration_time {
                        self.persist_subscribers.remove(entry.get().digest());
                        Some(entry.remove())
                    } else {
                        None
                    }
                },
                Vacant(_) => unreachable!("Expired entry not in cache"),
            };
            // No longer holding the lock on db_cache entry.
            if let Some(value) = removed_value {
                self.free_quota(value);
                ret.push(h);
            }
        }
        ret
    }
```

**File:** config/src/config/quorum_store_config.rs (L131-135)
```rust
            batch_expiry_gap_when_init_usecs: Duration::from_secs(60).as_micros() as u64,
            remote_batch_expiry_gap_when_init_usecs: Duration::from_millis(500).as_micros() as u64,
            memory_quota: 120_000_000,
            db_quota: 300_000_000,
            batch_quota: 300_000,
```
