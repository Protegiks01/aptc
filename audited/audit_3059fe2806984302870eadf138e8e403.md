# Audit Report

## Title
TOCTOU Vulnerability in NetworkBuilder Configuration Allows Trusted Peer Manipulation Leading to Consensus Compromise

## Summary
A Time-of-Check-Time-of-Use (TOCTOU) vulnerability exists in the network builder initialization flow where the `PeersAndMetadata` configuration object is shared via `Arc` and can be mutated externally after being passed to `NetworkBuilder` but before the network starts operating. This allows an attacker with code execution to inject malicious peers into the trusted peer set, potentially causing network partitioning and consensus safety violations.

## Finding Description

The vulnerability stems from the design pattern where `PeersAndMetadata` is passed as `Arc<PeersAndMetadata>` to `NetworkBuilder`, creating a shared reference that remains mutable by the caller throughout the network initialization lifecycle.

**In the test code** [1](#0-0) , the `listener_peers_and_metadata` object is created and passed to `NetworkBuilder::new_for_test()`. The Arc is cloned but points to the same underlying object, meaning the original reference can still be used to mutate the configuration.

**The core issue** is that `PeersAndMetadata` exposes a public `set_trusted_peers()` method [2](#0-1)  that allows external mutation of the trusted peer set at any time. The trusted peers are stored in an `ArcSwap` container [3](#0-2) , making them atomically swappable without locks.

**The attack sequence:**

1. `NetworkBuilder` is created with `peers_and_metadata.clone()` - this shares the same underlying object [4](#0-3) 

2. During initialization, `ConnectivityManager` is created and verifies trusted_peers is empty, then populates it from seeds [5](#0-4) 

3. **TOCTOU Window**: After initialization but before or during `build()`/`start()`, an attacker calls `peers_and_metadata.set_trusted_peers()` to inject malicious peers

4. When `ConnectivityManager` starts its event loop and calls `get_trusted_peers()` [6](#0-5) , it retrieves the attacker-modified trusted peer set

5. The node then uses these malicious trusted peers for connection decisions in `close_stale_connections()` and `cancel_stale_dials()` [7](#0-6) 

**This pattern exists in production code** [8](#0-7)  where `peers_and_metadata` is passed to `setup_networks_and_get_interfaces()` and the caller retains the reference for use with other services [9](#0-8) .

## Impact Explanation

This vulnerability qualifies as **CRITICAL** severity under the Aptos bug bounty program for the following reasons:

1. **Consensus/Safety Violations**: By manipulating which peers a validator connects to, an attacker can:
   - Force the node to connect only to attacker-controlled peers (eclipse attack)
   - Disconnect the node from legitimate validators
   - Create network partitions where different subsets of validators see different network topologies
   - Cause validators to produce different blocks due to seeing different transaction sets
   - Enable double-spend attacks by partitioning the network

2. **Non-recoverable Network Partition**: If multiple validators are compromised using this technique, the network could split into disjoint partitions that cannot reach consensus, potentially requiring a hard fork to recover.

3. **Breaks Critical Invariants**:
   - **Consensus Safety**: AptosBFT consensus safety guarantees are violated when nodes connect to different peer sets
   - **Deterministic Execution**: Validators may produce different state roots if they receive transactions in different orders due to network manipulation

The attack enables an adversary to fundamentally compromise the network's consensus properties, justifying Critical severity classification.

## Likelihood Explanation

**Likelihood: Medium-High** in specific threat models:

**Attack Requirements:**
- Code execution capability within the validator node process
- Ability to call `set_trusted_peers()` after NetworkBuilder creation but before/during network operation

**Realistic Attack Vectors:**
1. **Malicious Validator Operator**: A compromised or malicious validator operator with access to the node binary could inject code to exploit this vulnerability
2. **Supply Chain Attack**: Compromised dependencies or build tooling could inject malicious code
3. **Remote Code Execution**: If an RCE vulnerability exists elsewhere in the stack, this TOCTOU could be chained for consensus compromise
4. **Malicious Plugins/Extensions**: If the node supports any plugin architecture, malicious plugins could exploit this

**Complexity**: Low - the attack is straightforward once code execution is achieved (single function call)

**Detection Difficulty**: High - the mutation happens in-memory with no audit trail, making it difficult to detect without runtime monitoring

While the attack requires code execution within the node process (limiting the attacker pool), the potential for complete consensus compromise makes this a serious vulnerability worthy of attention.

## Recommendation

**Primary Fix**: Eliminate the shared mutable state pattern by making trusted peers immutable after initialization:

```rust
// In network/framework/src/application/storage.rs
impl PeersAndMetadata {
    // Make set_trusted_peers() private or remove it entirely
    // Add initialization-only method
    pub(crate) fn initialize_trusted_peers(
        &self,
        network_id: &NetworkId,
        trusted_peer_set: PeerSet,
    ) -> Result<(), Error> {
        let trusted_peers = self.get_trusted_peer_set_for_network(network_id)?;
        // Only allow setting once during initialization
        let current = trusted_peers.load();
        if !current.is_empty() {
            return Err(Error::UnexpectedError(
                "Trusted peers already initialized".to_string()
            ));
        }
        trusted_peers.store(Arc::new(trusted_peer_set));
        Ok(())
    }
}
```

**Alternative Fix**: Add integrity verification to detect unauthorized mutations:

```rust
// In ConnectivityManager, store a hash of the initial trusted peers
// and verify it hasn't changed on each access
impl<TBackoff> ConnectivityManager<TBackoff> {
    fn get_trusted_peers(&self) -> Option<PeerSet> {
        let network_id = self.network_context.network_id();
        match self.peers_and_metadata.get_trusted_peers(&network_id) {
            Ok(trusted_peers) => {
                // Verify integrity hash matches expected value
                let hash = compute_trusted_peers_hash(&trusted_peers);
                if hash != self.expected_trusted_peers_hash {
                    error!("Trusted peers have been tampered with!");
                    return None;
                }
                Some(trusted_peers)
            },
            Err(error) => {
                error!("Failed to find trusted peers: {:?}", error);
                None
            },
        }
    }
}
```

**Best Practice**: Combine both approaches - restrict access to `set_trusted_peers()` AND add integrity verification as defense-in-depth.

## Proof of Concept

```rust
#[cfg(test)]
mod toctou_vulnerability_test {
    use super::*;
    use aptos_config::config::{Peer, PeerRole, PeerSet};
    use aptos_types::PeerId;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_trusted_peers_toctou_vulnerability() {
        // Setup: Create PeersAndMetadata and NetworkBuilder
        let network_id = NetworkId::Validator;
        let peers_and_metadata = PeersAndMetadata::new(&[network_id]);
        
        // Create initial seeds with legitimate peer
        let mut seeds = PeerSet::new();
        let legitimate_peer = PeerId::random();
        seeds.insert(
            legitimate_peer,
            Peer::new(vec![], HashSet::new(), PeerRole::Validator),
        );
        
        // Pass to NetworkBuilder (this is where TOCTOU window opens)
        let mut network_builder = NetworkBuilder::new_for_test(
            ChainId::test(),
            seeds.clone(),
            NetworkContext::new(RoleType::Validator, network_id, PeerId::random()),
            TimeService::real(),
            "/ip4/127.0.0.1/tcp/0".parse().unwrap(),
            AuthenticationMode::Mutual(x25519::PrivateKey::generate(&mut rand::thread_rng())),
            peers_and_metadata.clone(),
        );
        
        // ATTACK: Spawn attacker thread that mutates trusted peers
        let attacker_peers_and_metadata = peers_and_metadata.clone();
        thread::spawn(move || {
            thread::sleep(Duration::from_millis(10)); // Wait for initialization
            
            // Inject malicious peer
            let mut malicious_peers = PeerSet::new();
            let malicious_peer = PeerId::random();
            malicious_peers.insert(
                malicious_peer,
                Peer::new(vec![], HashSet::new(), PeerRole::Validator),
            );
            
            // This succeeds because set_trusted_peers is public!
            attacker_peers_and_metadata
                .set_trusted_peers(&network_id, malicious_peers)
                .expect("Attacker successfully injected malicious peers");
        });
        
        // Build and start network (during this, attacker modifies trusted_peers)
        network_builder.add_client_and_service::<_, DummyNetworkEvents>(
            &dummy_network_config(),
            None,
            true,
        );
        network_builder.build(runtime.handle().clone());
        thread::sleep(Duration::from_millis(50)); // Allow attacker time to inject
        network_builder.start();
        
        // Verify: The node now uses malicious trusted peers
        let trusted_peers = peers_and_metadata
            .get_trusted_peers(&network_id)
            .expect("Should have trusted peers");
            
        // If vulnerability exists, trusted_peers contains ONLY the malicious peer,
        // not the legitimate peer from seeds
        assert_ne!(
            trusted_peers.get(&legitimate_peer),
            None,
            "VULNERABILITY: Legitimate peer was removed by attacker!"
        );
    }
}
```

**Notes:**
- This vulnerability is exploitable in both test code (dummy.rs) and production code (network.rs)
- The shared Arc<PeersAndMetadata> pattern creates a mutable shared state that violates secure initialization principles
- The public `set_trusted_peers()` API lacks access control or integrity protection
- Exploitation requires code execution within the node process but does not require validator consensus powers
- Impact is severe: enables eclipse attacks, network partitioning, and consensus safety violations

### Citations

**File:** network/builder/src/dummy.rs (L99-115)
```rust
    let listener_peers_and_metadata = PeersAndMetadata::new(&[network_id]);
    let mut listener_connection_events = listener_peers_and_metadata.subscribe();
    // Set up the listener network
    let network_context = NetworkContext::new(role, network_id, listener_peer.peer_id());
    let mut network_builder = NetworkBuilder::new_for_test(
        chain_id,
        seeds.clone(),
        network_context,
        TimeService::real(),
        listener_addr,
        authentication_mode,
        listener_peers_and_metadata.clone(),
    );

    let (listener_sender, listener_events) = network_builder
        .add_client_and_service::<_, DummyNetworkEvents>(&dummy_network_config(), None, true);
    network_builder.build(runtime.handle().clone()).start();
```

**File:** network/framework/src/application/storage.rs (L44-44)
```rust
    trusted_peers: HashMap<NetworkId, Arc<ArcSwap<PeerSet>>>,
```

**File:** network/framework/src/application/storage.rs (L361-369)
```rust
    pub fn set_trusted_peers(
        &self,
        network_id: &NetworkId,
        trusted_peer_set: PeerSet,
    ) -> Result<(), Error> {
        let trusted_peers = self.get_trusted_peer_set_for_network(network_id)?;
        trusted_peers.store(Arc::new(trusted_peer_set));
        Ok(())
    }
```

**File:** network/builder/src/builder.rs (L118-157)
```rust
    pub fn new_for_test(
        chain_id: ChainId,
        seeds: PeerSet,
        network_context: NetworkContext,
        time_service: TimeService,
        listen_address: NetworkAddress,
        authentication_mode: AuthenticationMode,
        peers_and_metadata: Arc<PeersAndMetadata>,
    ) -> NetworkBuilder {
        let mutual_authentication = matches!(authentication_mode, AuthenticationMode::Mutual(_));

        let mut builder = NetworkBuilder::new(
            chain_id,
            peers_and_metadata.clone(),
            network_context,
            time_service,
            listen_address,
            authentication_mode,
            MAX_FRAME_SIZE,
            MAX_MESSAGE_SIZE,
            false, /* Disable proxy protocol */
            NETWORK_CHANNEL_SIZE,
            MAX_INBOUND_CONNECTIONS,
            TCPBufferCfg::default(),
        );

        builder.add_connectivity_manager(
            seeds,
            peers_and_metadata,
            MAX_FULLNODE_OUTBOUND_CONNECTIONS,
            CONNECTION_BACKOFF_BASE,
            MAX_CONNECTION_DELAY_MS,
            CONNECTIVITY_CHECK_INTERVAL_MS,
            NETWORK_CHANNEL_SIZE,
            mutual_authentication,
            true, /* enable_latency_aware_dialing */
        );

        builder
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L363-402)
```rust
        // Verify that the trusted peers set exists and that it is empty
        let trusted_peers = peers_and_metadata
            .get_trusted_peers(&network_context.network_id())
            .unwrap_or_else(|error| {
                panic!("Trusted peers must exist, but found error: {:?}", error)
            });
        assert!(
            trusted_peers.is_empty(),
            "Trusted peers must be empty. Found: {:?}",
            trusted_peers
        );

        info!(
            NetworkSchema::new(&network_context),
            "{} Initialized connectivity manager", network_context
        );

        let mut connmgr = Self {
            network_context,
            time_service,
            peers_and_metadata,
            connected: HashMap::new(),
            discovered_peers: Arc::new(RwLock::new(DiscoveredPeerSet::default())),
            connection_reqs_tx,
            connection_notifs_rx,
            requests_rx,
            dial_queue: HashMap::new(),
            dial_states: HashMap::new(),
            connectivity_check_interval,
            backoff_strategy,
            max_delay,
            event_id: 0,
            outbound_connection_limit,
            mutual_authentication,
            enable_latency_aware_dialing,
        };

        // Set the initial seed config addresses and public keys
        connmgr.handle_update_discovered_peers(DiscoverySource::Config, seeds);
        connmgr
```

**File:** network/framework/src/connectivity_manager/mod.rs (L463-477)
```rust
    fn get_trusted_peers(&self) -> Option<PeerSet> {
        let network_id = self.network_context.network_id();
        match self.peers_and_metadata.get_trusted_peers(&network_id) {
            Ok(trusted_peers) => Some(trusted_peers),
            Err(error) => {
                error!(
                    NetworkSchema::new(&self.network_context),
                    "Failed to find trusted peers for network context: {:?}, error: {:?}",
                    self.network_context,
                    error
                );
                None
            },
        }
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L484-540)
```rust
    async fn close_stale_connections(&mut self) {
        if let Some(trusted_peers) = self.get_trusted_peers() {
            // Identify stale peer connections
            let stale_peers = self
                .connected
                .iter()
                .filter(|(peer_id, _)| !trusted_peers.contains_key(peer_id))
                .filter_map(|(peer_id, metadata)| {
                    // If we're using server only auth, we need to not evict unknown peers
                    // TODO: We should prevent `Unknown` from discovery sources
                    if !self.mutual_authentication
                        && metadata.origin == ConnectionOrigin::Inbound
                        && (metadata.role == PeerRole::ValidatorFullNode
                            || metadata.role == PeerRole::Unknown)
                    {
                        None
                    } else {
                        Some(*peer_id) // The peer is stale
                    }
                });

            // Close existing connections to stale peers
            for stale_peer in stale_peers {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&stale_peer),
                    "{} Closing stale connection to peer {}",
                    self.network_context,
                    stale_peer.short_str()
                );

                if let Err(disconnect_error) = self
                    .connection_reqs_tx
                    .disconnect_peer(stale_peer, DisconnectReason::StaleConnection)
                    .await
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .remote_peer(&stale_peer),
                        error = %disconnect_error,
                        "{} Failed to close stale connection to peer {}, error: {}",
                        self.network_context,
                        stale_peer.short_str(),
                        disconnect_error
                    );
                }
            }
        }
    }

    /// Cancel all pending dials to peers that are no longer eligible.
    ///
    /// For instance, a validator might leave the validator set after a
    /// reconfiguration. If there is a pending dial to this validator, calling
    /// this function will remove it from the dial queue.
    async fn cancel_stale_dials(&mut self) {
        if let Some(trusted_peers) = self.get_trusted_peers() {
            // Identify stale peer dials
```

**File:** aptos-node/src/network.rs (L245-290)
```rust
pub fn setup_networks_and_get_interfaces(
    node_config: &NodeConfig,
    chain_id: ChainId,
    peers_and_metadata: Arc<PeersAndMetadata>,
    event_subscription_service: &mut EventSubscriptionService,
) -> (
    Vec<Runtime>,
    Option<ApplicationNetworkInterfaces<ConsensusMsg>>,
    Option<ApplicationNetworkInterfaces<ConsensusObserverMessage>>,
    Option<ApplicationNetworkInterfaces<DKGMessage>>,
    Option<ApplicationNetworkInterfaces<JWKConsensusMsg>>,
    ApplicationNetworkInterfaces<MempoolSyncMsg>,
    ApplicationNetworkInterfaces<PeerMonitoringServiceMessage>,
    ApplicationNetworkInterfaces<StorageServiceMessage>,
) {
    // Gather all network configs
    let network_configs = extract_network_configs(node_config);

    // Create each network and register the application handles
    let mut network_runtimes = vec![];
    let mut consensus_network_handle = None;
    let mut consensus_observer_network_handles: Option<
        Vec<ApplicationNetworkHandle<ConsensusObserverMessage>>,
    > = None;
    let mut dkg_network_handle = None;
    let mut jwk_consensus_network_handle = None;
    let mut mempool_network_handles = vec![];
    let mut peer_monitoring_service_network_handles = vec![];
    let mut storage_service_network_handles = vec![];
    let mut netbench_handles = Vec::<ApplicationNetworkHandle<NetbenchMessage>>::new();
    for network_config in network_configs.into_iter() {
        // Create a network runtime for the config
        let runtime = create_network_runtime(&network_config);

        // Entering gives us a runtime to instantiate all the pieces of the builder
        let _enter = runtime.enter();

        // Create a new network builder
        let mut network_builder = NetworkBuilder::create(
            chain_id,
            node_config.base.role,
            &network_config,
            TimeService::real(),
            Some(event_subscription_service),
            peers_and_metadata.clone(),
        );
```

**File:** aptos-node/src/lib.rs (L747-776)
```rust
    ) = network::setup_networks_and_get_interfaces(
        &node_config,
        chain_id,
        peers_and_metadata.clone(),
        &mut event_subscription_service,
    );

    // Start the peer monitoring service
    let peer_monitoring_service_runtime = services::start_peer_monitoring_service(
        &node_config,
        peer_monitoring_service_network_interfaces,
        db_rw.reader.clone(),
    );

    // Start state sync and get the notification endpoints for mempool and consensus
    let (aptos_data_client, state_sync_runtimes, mempool_listener, consensus_notifier) =
        state_sync::start_state_sync_and_get_notification_handles(
            &node_config,
            storage_service_network_interfaces,
            genesis_waypoint,
            event_subscription_service,
            db_rw.clone(),
        )?;

    // Start the node inspection service
    services::start_node_inspection_service(
        &node_config,
        aptos_data_client,
        peers_and_metadata.clone(),
    );
```
