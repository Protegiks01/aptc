# Audit Report

## Title
Silent Deserialization Failures in validator_txn_enabled() Enable Consensus Divergence and Undetectable Protocol Degradation

## Summary
The `validator_txn_enabled()` native function silently falls back to a default configuration when BCS deserialization fails, without emitting any logs, metrics, or traces. This can cause consensus divergence when validators disagree on whether validator transactions are enabled, leading to liveness failures, or enable network-wide silent degradation of critical features like randomness and DKG.

## Finding Description

The native function `validator_txn_enabled()` deserializes on-chain consensus configuration bytes to determine if validator transactions are enabled: [1](#0-0) 

When `bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes)` fails, `unwrap_or_default()` silently returns a default configuration without any observability. The default configuration has validator transactions disabled: [2](#0-1) [3](#0-2) [4](#0-3) 

This boolean value controls critical consensus behavior:

**1. Governance Reconfiguration Decision:**
The `reconfigure()` function uses this to decide between starting DKG or immediately finishing reconfiguration: [5](#0-4) 

**2. Block Proposal Type Selection:**
Validators create different block types based on this flag: [6](#0-5) 

**3. Block Validation:**
Validators reject `ProposalExt` blocks when validator transactions are disabled: [7](#0-6) 

**Attack Scenario 1: Consensus Divergence via Config Corruption**

If the `ConsensusConfig` bytes stored on-chain become corrupted (e.g., through a buggy governance proposal): [8](#0-7) 

The Move code only validates that `vector::length(&config) > 0`, allowing malformed BCS bytes. Different validators may handle deserialization inconsistently:

- **Validator A:** Deserializes successfully → `vtxn_enabled() = true` → proposes `ProposalExt` blocks
- **Validator B:** Deserialization fails → defaults to `vtxn_enabled() = false` → rejects `ProposalExt` blocks

This breaks the **Deterministic Execution** invariant: validators produce different interpretations from identical on-chain state, causing consensus to halt.

**Attack Scenario 2: Silent Network-Wide Degradation**

If all validators fail to deserialize (e.g., after a config upgrade with incompatible format changes):
- All silently fall back to `vtxn_enabled() = false`
- Validator transactions stop working network-wide
- Randomness DKG doesn't run (governance reconfiguration takes the `else` branch)
- No logs, metrics, or monitoring alerts fire
- Network operates in degraded mode indefinitely until operators manually notice

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

1. **Validator node slowdowns / liveness failures:** Consensus divergence causes validators to reject each other's proposals, halting block production. This requires manual intervention to diagnose and resolve.

2. **Significant protocol violations:** The protocol's deterministic execution guarantee is violated when validators process identical on-chain state differently. This is a fundamental consensus safety requirement.

3. **State inconsistencies requiring intervention:** Silent degradation of validator transactions and randomness features creates an inconsistent network state that differs from the intended configuration without any visibility.

The vulnerability does not quite reach Critical severity because:
- It requires corrupted on-chain config (not arbitrary attacker control)
- Recovery is possible through governance intervention
- No permanent fund loss occurs

However, it borders on Critical if we consider that non-recoverable network partition could occur if validators cannot agree on the config interpretation.

## Likelihood Explanation

**Medium-to-High Likelihood:**

1. **Config corruption can occur through legitimate bugs:** Governance proposals are complex, and serialization errors in proposal scripts could write malformed bytes. The validation only checks length, not format validity.

2. **Format evolution creates risk:** As `OnChainConsensusConfig` evolves through new variants (V1→V2→V3→V4→V5), old validators may fail to deserialize new formats, or vice versa during upgrades.

3. **No defense-in-depth:** There's no validation that the bytes are deserializable before writing them on-chain, and no monitoring when deserialization fails at runtime.

4. **Silent failures are hard to detect:** Operators won't know about the issue until consensus symptoms appear, making diagnosis difficult and slow.

## Recommendation

Add comprehensive observability and fail-safe validation:

**1. Add logging/metrics in the native function:**

```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = match bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes) {
        Ok(c) => c,
        Err(e) => {
            // CRITICAL: Log deserialization failure
            error!(
                "Failed to deserialize OnChainConsensusConfig: {}. \
                 Falling back to default (vtxn disabled). \
                 This indicates corrupted on-chain config!",
                e
            );
            // Emit metric
            counters::CONSENSUS_CONFIG_DESERIALIZATION_FAILURES.inc();
            OnChainConsensusConfig::default()
        }
    };
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

**2. Add pre-validation in Move before accepting config updates:**

```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // NEW: Validate that bytes are deserializable before accepting
    assert!(
        validator_txn_enabled_internal(config), // This will fail if deserialization fails
        error::invalid_argument(EINVALID_CONFIG)
    );
    
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

Actually, this won't work because `unwrap_or_default()` doesn't fail. Better approach:

Add a validation native function:

```rust
pub fn validate_consensus_config(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let is_valid = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).is_ok();
    Ok(smallvec![Value::bool(is_valid)])
}
```

Then in Move:
```move
native fun validate_consensus_config_internal(config_bytes: vector<u8>): bool;

public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    assert!(
        validate_consensus_config_internal(config),
        error::invalid_argument(EINVALID_CONFIG)
    );
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

## Proof of Concept

**Rust Test Demonstrating Silent Failure:**

```rust
#[test]
fn test_validator_txn_enabled_silent_deserialization_failure() {
    use aptos_native_interface::SafeNativeContext;
    use move_vm_types::values::Value;
    use std::collections::VecDeque;
    
    let mut context = SafeNativeContext::new(/* mock context */);
    
    // Create corrupted config bytes (invalid BCS)
    let corrupted_bytes = vec![0xFF, 0xFF, 0xFF, 0xFF];
    let mut args = VecDeque::new();
    args.push_back(Value::vector_u8(corrupted_bytes));
    
    // Call the native function
    let result = validator_txn_enabled(&mut context, &[], args).unwrap();
    
    // Assert it returns false (default) without any error
    // In production, this would be a silent failure
    assert_eq!(result[0], Value::bool(false));
    
    // TODO: Add assertion that no log/metric was emitted
    // (This demonstrates the bug - silent failure with no observability)
}
```

**Move Integration Test Demonstrating Consensus Impact:**

```move
#[test(framework = @aptos_framework)]
fun test_corrupted_config_causes_silent_degradation(framework: &signer) {
    // Set up valid config initially
    let valid_config = /* serialize valid OnChainConsensusConfig with vtxn enabled */;
    consensus_config::initialize(framework, valid_config);
    
    assert!(consensus_config::validator_txn_enabled() == true, 0);
    
    // Simulate config corruption (e.g., from buggy governance proposal)
    let corrupted_config = vector[0xFF, 0xFF, 0xFF, 0xFF];
    consensus_config::set_for_next_epoch(framework, corrupted_config);
    consensus_config::on_new_epoch(framework);
    
    // Now vtxn is silently disabled without any error
    assert!(consensus_config::validator_txn_enabled() == false, 1);
    
    // Reconfigure would now skip DKG (silent degradation)
    // No logs or metrics would alert operators
}
```

## Notes

This vulnerability is particularly insidious because:

1. **No error propagation:** The `unwrap_or_default()` pattern converts a critical deserialization error into a silent fallback, making debugging extremely difficult.

2. **Consensus-critical path:** The affected function controls fundamental consensus behavior (block types, validation rules, epoch transitions), so silent failures have cascading effects.

3. **Different validators may diverge:** If some validators successfully deserialize while others fail (e.g., due to version differences during upgrades), they'll operate with different consensus rules, violating safety.

4. **Governance attack surface:** While not directly exploitable by arbitrary attackers, buggy or maliciously crafted governance proposals could trigger this by submitting malformed config bytes that pass the length check but fail BCS deserialization.

The recommended fix adds defense-in-depth through both runtime observability (logging/metrics) and upfront validation (rejecting invalid configs before they're stored on-chain).

### Citations

**File:** aptos-move/framework/src/natives/consensus_config.rs (L13-21)
```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).unwrap_or_default();
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L147-149)
```rust
    pub fn default_if_missing() -> Self {
        Self::V0
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L162-167)
```rust
    pub fn enabled(&self) -> bool {
        match self {
            ValidatorTxnConfig::V0 => false,
            ValidatorTxnConfig::V1 { .. } => true,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-451)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** consensus/src/liveness/proposal_generator.rs (L534-553)
```rust
        let block = if self.vtxn_config.enabled() {
            BlockData::new_proposal_ext(
                validator_txns,
                payload,
                self.author,
                failed_authors,
                round,
                timestamp,
                quorum_cert,
            )
        } else {
            BlockData::new_proposal(
                payload,
                self.author,
                failed_authors,
                round,
                timestamp,
                quorum_cert,
            )
        };
```

**File:** consensus/src/round_manager.rs (L1116-1124)
```rust
        if !self.vtxn_config.enabled()
            && matches!(
                proposal.block_data().block_type(),
                BlockType::ProposalExt(_)
            )
        {
            counters::UNEXPECTED_PROPOSAL_EXT_COUNT.inc();
            bail!("ProposalExt unexpected while the vtxn feature is disabled.");
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```
