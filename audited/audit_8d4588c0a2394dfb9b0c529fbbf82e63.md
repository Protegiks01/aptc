# Audit Report

## Title
Protobuf Deserialization Vulnerability in Indexer gRPC Gateway - Potential Resource Exhaustion via Deeply Nested Transaction Filters

## Summary
The indexer-grpc-gateway deserializes `GetTransactionsRequest` protobuf messages without explicit message size limits or depth validation. While the gateway only performs proto-level deserialization (not full conversion to `BooleanTransactionFilter`), malicious clients could potentially exploit this to cause resource exhaustion through crafted messages with deeply nested `transaction_filter` structures or large repeated fields. [1](#0-0) 

## Finding Description
The vulnerability exists in how the gateway handles incoming `GetTransactionsRequest` messages. The gateway creates a `Streaming<GetTransactionsRequest>` decoder using `ProstCodec::default()` without configuring `max_decoding_message_size`. This means it relies on tonic's default 4MB limit. [2](#0-1) 

The `BooleanTransactionFilter` protobuf definition allows recursive nesting through the `logical_not` field, and unbounded repeated fields in `logical_and` and `logical_or`: [3](#0-2) 

While the gateway only deserializes to the proto type (not converting to the Rust `BooleanTransactionFilter`), and prost likely has internal recursion limits, there are no explicit protections configured. Other services in the codebase explicitly set message size limits: [4](#0-3) [5](#0-4) 

The gateway lacks these explicit protections.

## Impact Explanation
This qualifies as **High Severity** per the bug bounty criteria ("API crashes"). A successful attack could:

1. **Gateway Crashes**: Deeply nested structures exceeding prost's internal limits could cause panics during deserialization
2. **CPU Exhaustion**: Large repeated fields within the 4MB limit could cause excessive CPU usage during proto parsing
3. **Memory Exhaustion**: Malformed messages could trigger unbounded memory allocation
4. **Service Disruption**: All indexer API clients depending on the gateway would be affected

While this doesn't affect consensus or validator nodes directly, the indexer gRPC gateway is a critical infrastructure component for the Aptos ecosystem.

## Likelihood Explanation
**Likelihood: Medium-to-High**

An attacker needs:
- Network access to the gateway endpoint
- Ability to craft malicious protobuf messages (trivial with standard tools)
- No authentication is required for the deserialization to occur

The attack is **highly feasible** because:
1. The gateway endpoint is publicly accessible
2. Crafting nested protobuf structures is straightforward
3. The vulnerability is triggered before any authentication or validation
4. The gateway processes the message immediately upon receipt

## Recommendation
Implement explicit message size and recursion depth limits at the gateway level:

```rust
// In gateway.rs, configure max_decoding_message_size
const MAX_GRPC_MESSAGE_SIZE: usize = 4 * 1024 * 1024; // 4MB

// When creating the ProstCodec, add explicit limits
let mut codec = tonic::codec::ProstCodec::<GetTransactionsRequest, GetTransactionsRequest>::default();

// If using a server, configure limits:
Server::builder()
    .max_decoding_message_size(MAX_GRPC_MESSAGE_SIZE)
    // ... rest of configuration
```

Additionally, implement early validation of the `transaction_filter` size before forwarding to the grpc_manager:

```rust
if let Some(filter) = &request.transaction_filter {
    if filter.encoded_len() > DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES {
        return Err(Status::invalid_argument(
            format!("Transaction filter too large: {} bytes", filter.encoded_len())
        ));
    }
}
``` [6](#0-5) 

## Proof of Concept
```rust
use aptos_protos::indexer::v1::{GetTransactionsRequest, BooleanTransactionFilter, boolean_transaction_filter::Filter};
use prost::Message;

fn create_deeply_nested_filter(depth: usize) -> BooleanTransactionFilter {
    if depth == 0 {
        // Base case: simple filter
        BooleanTransactionFilter {
            filter: Some(Filter::ApiFilter(/* ... */)),
        }
    } else {
        // Recursive case: wrap in LogicalNot
        BooleanTransactionFilter {
            filter: Some(Filter::LogicalNot(
                Box::new(create_deeply_nested_filter(depth - 1))
            )),
        }
    }
}

fn main() {
    // Create request with deeply nested filter (e.g., depth 10000)
    let malicious_request = GetTransactionsRequest {
        starting_version: Some(0),
        transaction_filter: Some(create_deeply_nested_filter(10000)),
        ..Default::default()
    };
    
    // Serialize to bytes
    let mut buf = Vec::new();
    malicious_request.encode(&mut buf).unwrap();
    
    println!("Malicious request size: {} bytes", buf.len());
    
    // Send to gateway endpoint
    // This could cause stack overflow or excessive CPU during deserialization
}
```

**Notes:**
While the gateway doesn't convert to `BooleanTransactionFilter` (only the data service does), prost's proto deserialization may still be affected by extremely deep nesting or large repeated fields. The lack of explicit limits makes this a potential attack vector for API availability disruption.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-gateway/src/gateway.rs (L115-136)
```rust
    if head.uri.path() == "/aptos.indexer.v1.RawData/GetTransactions" {
        let body_bytes = body
            .collect()
            .await
            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
            .to_bytes();
        body = body_bytes.clone().into();
        let stream = Streaming::<GetTransactionsRequest>::new_request(
            <ProstCodec<GetTransactionsRequest, GetTransactionsRequest> as Codec>::decoder(
                &mut tonic::codec::ProstCodec::<GetTransactionsRequest, GetTransactionsRequest>::default(),
            ),
            Full::new(body_bytes),
            request_compression_encoding,
            None,
        );

        tokio::pin!(stream);

        if let Ok(Some(request)) = stream.try_next().await {
            user_request = Some(request);
        }
    }
```

**File:** protos/proto/aptos/indexer/v1/filter.proto (L58-65)
```text
message BooleanTransactionFilter {
  oneof filter {
      APIFilter api_filter = 1;
      LogicalAndFilters logical_and = 2;
      LogicalOrFilters logical_or = 3;
      BooleanTransactionFilter logical_not = 4;
  }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L31-31)
```rust
pub(crate) const MAX_MESSAGE_SIZE: usize = 256 * (1 << 20);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L240-241)
```rust
                .max_decoding_message_size(MAX_MESSAGE_SIZE)
                .max_encoding_message_size(MAX_MESSAGE_SIZE);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L21-21)
```rust
pub const DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES: usize = 10_000;
```
