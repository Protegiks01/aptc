# Audit Report

## Title
Resource Exhaustion via Pre-Authentication Handshake Exchange on Cross-Chain Connections

## Summary
The network handshake protocol performs expensive cryptographic operations (Noise IK handshake) and message exchanges before verifying the chain_id, allowing attackers from different chains to exhaust node resources through repeated connection attempts that are rejected only after consuming significant CPU, memory, and bandwidth.

## Finding Description

The vulnerability exists in the connection upgrade flow where chain_id verification occurs too late in the handshake sequence. [1](#0-0) 

The attack unfolds as follows:

1. **Noise Handshake Completes First**: An attacker from a different chain connects and successfully completes the Noise IK cryptographic handshake, which involves expensive elliptic curve operations and anti-replay timestamp validation. [2](#0-1) 

2. **HandshakeMsg Exchange**: After Noise authentication, both peers exchange HandshakeMsg structures containing their chain_id, network_id, and supported protocols. This involves BCS serialization/deserialization with up to 65KB buffers per direction. [3](#0-2) 

3. **Chain ID Verification (Too Late)**: Only after both expensive operations complete does the code verify chain_id compatibility. If mismatched, the connection is rejected. [4](#0-3) 

4. **Inbound Connection Limits Don't Apply**: The critical flaw is that `inbound_connection_limit` checks occur in `PeerManager::handle_new_connection_event` only AFTER successful upgrade completion. Connections failing at chain_id verification never reach this check. [5](#0-4) 

5. **Unbounded Concurrent Upgrades**: The `TransportHandler` uses `FuturesUnordered` to manage pending connection upgrades with no explicit limit. [6](#0-5) 

**Attack Scenario in MaybeMutual Authentication Mode:**

In `HandshakeAuthMode::MaybeMutual` (used by public-facing fullnodes and VFN networks), any peer with a validly-derived PeerId can complete the Noise handshake. [7](#0-6) 

An attacker operates nodes on `ChainId::new(999)` while targeting mainnet nodes on `ChainId::mainnet()`. Each connection attempt:
- Consumes ~130KB memory for HandshakeMsg buffers (65KB inbound + 65KB outbound as per u16 framing limit) [8](#0-7) 
- Executes Noise IK crypto operations (curve25519, ChaCha20-Poly1305)
- Takes up to 30 seconds before TRANSPORT_TIMEOUT [9](#0-8) 

With HAProxy's `maxconnrate = 300`, an attacker sustains 300 new connections/second. At steady state: **300 conn/sec × 30 seconds = 9,000 concurrent upgrades**, consuming approximately **1.14 GB memory** (9,000 × 130KB) plus massive CPU for concurrent cryptographic operations.

## Impact Explanation

This qualifies as **Medium Severity** ($10,000) under "State inconsistencies requiring intervention" / "Validator node slowdowns":

- **Resource Exhaustion**: Nodes experience memory pressure (1+ GB) and CPU saturation from concurrent crypto operations
- **Degraded Performance**: Legitimate connections may timeout or be delayed
- **Liveness Impact**: Validators may miss consensus rounds due to resource contention
- **Requires Operator Intervention**: Node operators must implement network-level filtering or restart affected nodes

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." Pre-authentication operations consume unbounded resources without proper rate limiting.

The vulnerability affects public-facing nodes (fullnodes, VFNs) running in `MaybeMutual` authentication mode more severely than validators using `Mutual` mode with strict trusted peer sets.

## Likelihood Explanation

**High Likelihood** for public-facing nodes:

- **Low Attack Complexity**: Attacker only needs to run nodes on a different chain_id and open TCP connections
- **No Authentication Required**: In MaybeMutual mode, any valid PeerId can complete Noise handshake
- **Amplification Factor**: Each connection consumes disproportionate resources (130KB + crypto) for minimal attacker cost
- **Sustainable Attack**: With distributed attack infrastructure, maintaining high connection rates is trivial
- **Detection Evasion**: Appears as legitimate connection attempts from new peers

The attack is limited by HAProxy rate limits (`maxconnrate = 300`) but these still allow significant resource exhaustion. [10](#0-9) 

## Recommendation

**Immediate Fix**: Move chain_id verification before expensive operations by including it in the Noise handshake prologue.

**Implementation Approach:**

1. Extend the Noise handshake prologue to include `chain_id` alongside `remote_peer_id` and `self_public_key`
2. Verify chain_id immediately after receiving the client's first message, before parsing the Noise handshake
3. Reject connections with mismatched chain_id before allocating crypto state or executing handshake operations

**Code Changes Required:**

In `network/framework/src/noise/handshake.rs`, modify `upgrade_inbound` to verify chain_id early:

```rust
// After line 332 (prologue extraction)
let (remote_peer_id, self_expected_public_key) = 
    client_message[..Self::PROLOGUE_SIZE].split_at(PeerId::LENGTH);

// ADD: Chain ID verification before crypto operations
let expected_chain_id = self.network_context.chain_id();
if prologue_chain_id != expected_chain_id {
    return Err(NoiseHandshakeError::InvalidChainId(
        remote_peer_short,
        prologue_chain_id,
        expected_chain_id
    ));
}

// Then proceed with existing crypto operations...
```

**Alternative Mitigation** (if protocol changes are too invasive):

Implement aggressive rate limiting on failed handshakes per source IP in `TransportHandler` before creating upgrade futures.

## Proof of Concept

```rust
// Integration test demonstrating resource exhaustion
// Place in network/framework/src/peer_manager/tests.rs

#[tokio::test]
async fn test_cross_chain_handshake_resource_exhaustion() {
    use aptos_types::chain_id::ChainId;
    use std::time::Duration;
    
    // Setup: Create a node on mainnet chain
    let mainnet_node = setup_network_node(ChainId::mainnet());
    
    // Attack: Spawn 100 connections from wrong chain
    let wrong_chain = ChainId::new(999);
    let mut handles = vec![];
    
    for _ in 0..100 {
        let handle = tokio::spawn(async move {
            let attacker_node = create_peer(wrong_chain);
            
            // Measure resources before connection
            let mem_before = get_memory_usage();
            let cpu_before = get_cpu_usage();
            
            // Attempt connection (will fail at chain_id check)
            let result = attacker_node.connect_to(mainnet_node.address()).await;
            
            // Measure resources consumed despite failure
            let mem_consumed = get_memory_usage() - mem_before;
            let cpu_consumed = get_cpu_usage() - cpu_before;
            
            assert!(result.is_err()); // Connection fails
            assert!(mem_consumed > 100_000); // But consumed >100KB
            assert!(cpu_consumed > 0.01); // And significant CPU
        });
        handles.push(handle);
    }
    
    // Wait for all attack attempts
    for handle in handles {
        handle.await.unwrap();
    }
    
    // Verify: Node consumed resources before rejecting all connections
    // Expected: ~13MB memory + high CPU for 100 concurrent invalid handshakes
    assert!(mainnet_node.memory_used() > 10_000_000);
    
    // Verify: Inbound connection limit was NOT triggered
    // (because connections failed before reaching PeerManager)
    assert_eq!(mainnet_node.rejected_by_connection_limit(), 0);
}
```

## Notes

This vulnerability is particularly concerning for public fullnode networks where `MaybeMutual` authentication allows any peer to initiate connections. Validators using strict `Mutual` authentication with curated trusted peer sets are less exposed but not immune if their VFN-facing networks accept untrusted peers.

The root cause is a protocol design flaw where authentication order (Noise → HandshakeMsg → chain_id check) doesn't align with resource cost (chain_id is cheap to verify but checked last). Defense-in-depth requires verifying cheapest checks first before expensive operations.

HAProxy rate limits provide partial mitigation but don't prevent sustained resource exhaustion, as 300 connections/second is sufficient to maintain thousands of concurrent invalid handshakes given the 30-second timeout window.

### Citations

**File:** network/framework/src/transport/mod.rs (L41-41)
```rust
pub const TRANSPORT_TIMEOUT: Duration = Duration::from_secs(30);
```

**File:** network/framework/src/transport/mod.rs (L249-332)
```rust
async fn upgrade_inbound<T: TSocket>(
    ctxt: Arc<UpgradeContext>,
    fut_socket: impl Future<Output = io::Result<T>>,
    addr: NetworkAddress,
    proxy_protocol_enabled: bool,
) -> io::Result<Connection<NoiseStream<T>>> {
    let origin = ConnectionOrigin::Inbound;
    let mut socket = fut_socket.await?;

    // If we have proxy protocol enabled, process the event, otherwise skip it
    // TODO: This would make more sense to build this in at instantiation so we don't need to put the if statement here
    let addr = if proxy_protocol_enabled {
        proxy_protocol::read_header(&addr, &mut socket)
            .await
            .map_err(|err| {
                debug!(
                    network_address = addr,
                    error = %err,
                    "ProxyProtocol: Failed to read header: {}",
                    err
                );
                err
            })?
    } else {
        addr
    };

    // try authenticating via noise handshake
    let (mut socket, remote_peer_id, peer_role) =
        ctxt.noise.upgrade_inbound(socket).await.map_err(|err| {
            if err.should_security_log() {
                sample!(
                    SampleRate::Duration(Duration::from_secs(15)),
                    warn!(
                        SecurityEvent::NoiseHandshake,
                        NetworkSchema::new(&ctxt.noise.network_context)
                            .network_address(&addr)
                            .connection_origin(&origin),
                        error = %err,
                    )
                );
            }
            let err = io::Error::other(err);
            add_pp_addr(proxy_protocol_enabled, err, &addr)
        })?;
    let remote_pubkey = socket.get_remote_static();
    let addr = addr.append_prod_protos(remote_pubkey, HANDSHAKE_VERSION);

    // exchange HandshakeMsg
    let handshake_msg = HandshakeMsg {
        supported_protocols: ctxt.supported_protocols.clone(),
        chain_id: ctxt.chain_id,
        network_id: ctxt.network_id,
    };
    let remote_handshake = exchange_handshake(&handshake_msg, &mut socket)
        .await
        .map_err(|err| add_pp_addr(proxy_protocol_enabled, err, &addr))?;

    // try to negotiate common aptosnet version and supported application protocols
    let (messaging_protocol, application_protocols) = handshake_msg
        .perform_handshake(&remote_handshake)
        .map_err(|err| {
            let err = format!(
                "handshake negotiation with peer {} failed: {}",
                remote_peer_id.short_str(),
                err
            );
            add_pp_addr(proxy_protocol_enabled, io::Error::other(err), &addr)
        })?;

    // return successful connection
    Ok(Connection {
        socket,
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
    })
}
```

**File:** network/framework/src/protocols/identity.rs (L13-40)
```rust
pub async fn exchange_handshake<T>(
    own_handshake: &HandshakeMsg,
    socket: &mut T,
) -> io::Result<HandshakeMsg>
where
    T: AsyncRead + AsyncWrite + Unpin,
{
    // Send serialized handshake message to remote peer.
    let msg = bcs::to_bytes(own_handshake).map_err(|e| {
        io::Error::new(
            io::ErrorKind::InvalidData,
            format!("Failed to serialize identity msg: {}", e),
        )
    })?;
    write_u16frame(socket, &msg).await?;
    socket.flush().await?;

    // Read handshake message from the Remote
    let mut response = BytesMut::new();
    read_u16frame(socket, &mut response).await?;
    let identity = bcs::from_bytes(&response).map_err(|e| {
        io::Error::new(
            io::ErrorKind::InvalidData,
            format!("Failed to parse identity msg: {}", e),
        )
    })?;
    Ok(identity)
}
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L431-465)
```rust
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/peer_manager/mod.rs (L352-389)
```rust
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
```

**File:** network/framework/src/peer_manager/transport.rs (L91-109)
```rust
        let mut pending_inbound_connections = FuturesUnordered::new();
        let mut pending_outbound_connections = FuturesUnordered::new();

        debug!(
            NetworkSchema::new(&self.network_context),
            "{} Incoming connections listener Task started", self.network_context
        );

        loop {
            futures::select! {
                dial_request = self.transport_reqs_rx.select_next_some() => {
                    if let Some(fut) = self.dial_peer(dial_request) {
                        pending_outbound_connections.push(fut);
                    }
                },
                inbound_connection = self.listener.select_next_some() => {
                    if let Some(fut) = self.upgrade_inbound_connection(inbound_connection) {
                        pending_inbound_connections.push(fut);
                    }
```

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** network/netcore/src/framing.rs (L8-22)
```rust
/// Read a u16 length prefixed frame from `Stream` into `buf`.
pub async fn read_u16frame<'stream, 'buf, 'c, TSocket>(
    mut stream: &'stream mut TSocket,
    buf: &'buf mut BytesMut,
) -> Result<()>
where
    'stream: 'c,
    'buf: 'c,
    TSocket: AsyncRead + Unpin,
{
    let len = read_u16frame_len(&mut stream).await?;
    buf.resize(len as usize, 0);
    stream.read_exact(buf.as_mut()).await?;
    Ok(())
}
```

**File:** docker/compose/aptos-node/haproxy.cfg (L1-50)
```text
# Config manual: https://www.haproxy.com/documentation/haproxy-configuration-manual/latest/

## Global settings
global
    # Specify the stdout log format and size
    log stdout len 10240 format raw local0

    # Limit the maximum number of connections to 500 (this is ~5x the validator set size)
    maxconn 500

    # Limit the maximum number of connections per second to 300 (this is ~3x the validator set size)
    maxconnrate 300

    # Limit user privileges
    user haproxy

## Default settings
defaults
    # Enable logging of events and traffic
    log global

    # Set the default mode to TCP
    mode tcp

    # Don't log normal events
    option dontlog-normal

    # Set timeouts for connections
    timeout client 60s
    timeout connect 10s
    timeout server 60s
    timeout queue 10s

    # Prevent long-running HTTP requests
    timeout http-request 60s
    timeout http-keep-alive 5s

## Specify the validator network frontend
frontend fe-validator
    bind :6180
    default_backend validator

    # Deny requests from blocked IPs
    tcp-request connection silent-drop if { src -n -f /usr/local/etc/haproxy/blocked.ips }

    # Create TCP request bandwidth limits of 25 MB/s (per TCP stream)
    filter bwlim-in incoming-limit default-limit 25m default-period 1s
    filter bwlim-out outgoing-limit default-limit 25m default-period 1s
    tcp-request content set-bandwidth-limit incoming-limit
    tcp-request content set-bandwidth-limit outgoing-limit
```
