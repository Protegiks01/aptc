# Audit Report

## Title
TrustedState Deserialization Bypass Allows Light Client Compromise via Validator Set Substitution

## Summary
The `TrustedState` enum derives `Serialize` and `Deserialize` without validation, allowing an attacker to construct and inject a malicious `TrustedState::EpochState` with arbitrary validator sets. This bypasses cryptographic binding between waypoints and epoch states, enabling complete compromise of light client blockchain verification.

## Finding Description

The `TrustedState` enum is designed to track light clients' trusted view of the ledger state. [1](#0-0) 

The critical security invariant for `TrustedState::EpochState` is that the `waypoint` and `epoch_state` fields must be cryptographically boundâ€”they should have been derived from the same epoch-change `LedgerInfo`. When constructed through the safe `try_from_epoch_change_li` method, this invariant is enforced. [2](#0-1) 

However, at line 24, `TrustedState` derives both `Serialize` and `Deserialize`: [3](#0-2) 

These derives use serde's automatic implementation, which directly reconstructs struct fields without validation. An attacker can craft a malicious `TrustedState::EpochState` with:
- A plausible `waypoint` (any version/hash combination)
- An `epoch_state` containing a `ValidatorVerifier` with attacker-controlled public keys [4](#0-3) 

When `verify_and_ratchet` is called on this malicious state, the signature verification uses the injected validator set. [5](#0-4) 

The verification chain follows through `EpochChangeProof.verify()` [6](#0-5)  which calls `verifier.verify()` on ledger infos, ultimately using `EpochState.verify()` [7](#0-6)  that verifies signatures against the fake validator set.

The attacker can then:
1. Create a malicious `TrustedState` with their own validators
2. Serialize it using BCS [8](#0-7) 
3. Inject it (e.g., tamper with persisted state, configuration files, or checkpoint data)
4. The light client deserializes and uses this state for verification
5. Attacker creates fake `LedgerInfoWithSignatures` signed by their fake validators
6. These signatures pass verification, causing the light client to accept arbitrary blockchain state

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per Aptos bug bounty:

- **Consensus/Safety Violations**: The light client's consensus safety is completely broken. It will accept blockchain states that violate actual consensus, leading to chain fork perception from the light client's perspective.

- **Potential Loss of Funds**: If the light client relies on this state for transaction verification (e.g., verifying transaction inclusion proofs), an attacker can convince it that fraudulent transactions occurred, potentially leading to asset transfers based on false information.

- **State Consistency Violation**: Breaks the critical invariant that "State transitions must be atomic and verifiable via Merkle proofs" by allowing verification against fake validator sets.

The impact is complete compromise of the light client's blockchain view, which is the fundamental security property that `TrustedState` exists to protect.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires:
1. The ability to inject serialized data where `TrustedState` is persisted (file system access, database manipulation, or malicious configuration)
2. A light client implementation that persists and reloads `TrustedState`

While the current codebase doesn't show explicit TrustedState persistence in production code, the presence of `Serialize`/`Deserialize` derives indicates intended persistence. Light client SDKs, mobile wallets, or checkpoint systems would naturally persist this state for resumption after restarts.

The vulnerability is exploitable by:
- Malware on a user's device accessing light client storage
- Compromised backup/restore systems
- Man-in-the-middle attacks on unencrypted checkpoint data
- Malicious applications with file system permissions

## Recommendation

Add deserialization validation to ensure the cryptographic binding between `waypoint` and `epoch_state` is maintained. Implement a custom `Deserialize` that validates consistency:

```rust
// Remove automatic Deserialize derive, implement manually:
impl<'de> Deserialize<'de> for TrustedState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        enum TrustedStateHelper {
            EpochWaypoint(Waypoint),
            EpochState {
                waypoint: Waypoint,
                epoch_state: EpochState,
            },
        }
        
        let helper = TrustedStateHelper::deserialize(deserializer)?;
        match helper {
            TrustedStateHelper::EpochWaypoint(w) => Ok(TrustedState::EpochWaypoint(w)),
            TrustedStateHelper::EpochState { waypoint, epoch_state } => {
                // Validate that waypoint is actually an epoch boundary waypoint
                // This cannot be fully validated without the original LedgerInfo,
                // so the best approach is to NOT persist EpochState at all
                Err(serde::de::Error::custom(
                    "TrustedState::EpochState should not be deserialized. Only persist EpochWaypoint."
                ))
            }
        }
    }
}
```

**Better solution**: Only serialize `EpochWaypoint` variant. Light clients should reconstruct `EpochState` from waypoints and epoch change proofs, never from direct deserialization.

## Proof of Concept

```rust
#[cfg(test)]
mod deserialization_attack_poc {
    use super::*;
    use crate::{
        epoch_state::EpochState,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        validator_verifier::{ValidatorConsensusInfo, ValidatorVerifier},
        validator_signer::ValidatorSigner,
        waypoint::Waypoint,
        block_info::BlockInfo,
        aggregate_signature::PartialSignatures,
    };
    use aptos_crypto::hash::HashValue;
    use std::sync::Arc;

    #[test]
    fn test_malicious_trusted_state_deserialization() {
        // Step 1: Attacker creates their own validator signers
        let attacker_signer = ValidatorSigner::random([0u8; 32]);
        let attacker_verifier = ValidatorVerifier::new(vec![
            ValidatorConsensusInfo::new(
                attacker_signer.author(),
                attacker_signer.public_key(),
                100,
            )
        ]);

        // Step 2: Create malicious TrustedState with fake validator set
        let fake_waypoint = Waypoint::new_any(&LedgerInfo::new(
            BlockInfo::empty(),
            HashValue::zero(),
        ));
        
        let malicious_trusted_state = TrustedState::EpochState {
            waypoint: fake_waypoint,
            epoch_state: EpochState {
                epoch: 5,
                verifier: Arc::new(attacker_verifier.clone()),
            },
        };

        // Step 3: Serialize the malicious state
        let serialized = bcs::to_bytes(&malicious_trusted_state).unwrap();

        // Step 4: Deserialize (simulating loading from storage)
        let deserialized: TrustedState = bcs::from_bytes(&serialized).unwrap();

        // Step 5: Create a fake LedgerInfo signed by attacker
        let fake_ledger_info = LedgerInfo::new(
            BlockInfo::new(
                5, // epoch matches malicious state
                0,
                HashValue::zero(),
                HashValue::random(),
                1000, // arbitrary version
                0,
                None,
            ),
            HashValue::zero(),
        );

        // Step 6: Sign with attacker's key
        let attacker_sig = attacker_signer.sign(&fake_ledger_info).unwrap();
        let partial = PartialSignatures::new(
            vec![(attacker_signer.author(), attacker_sig)].into_iter().collect()
        );
        let agg_sig = attacker_verifier.aggregate_signatures(partial.signatures_iter()).unwrap();
        let fake_li_with_sigs = LedgerInfoWithSignatures::new(fake_ledger_info, agg_sig);

        // Step 7: The malicious validator set accepts the fake signatures!
        match &deserialized {
            TrustedState::EpochState { epoch_state, .. } => {
                // This should fail with real validators, but succeeds with fake ones
                let result = epoch_state.verify(&fake_li_with_sigs);
                assert!(result.is_ok(), "Fake validator set accepted fake signatures!");
            }
            _ => panic!("Wrong variant"),
        }

        // This demonstrates that deserialized TrustedState with attacker-controlled
        // validators will accept attacker-created signatures, completely compromising
        // light client security.
    }
}
```

## Notes

The vulnerability exists because `TrustedState` derives automatic `Serialize`/`Deserialize` without enforcing the critical invariant that `waypoint` and `epoch_state` must be cryptographically bound. While the current codebase doesn't show explicit production code deserializing `TrustedState` from untrusted sources, the presence of these derives indicates intended persistence for light client implementations. Any system that persists and reloads `TrustedState` (light client SDKs, wallets, checkpoint systems) would be vulnerable to validator set substitution attacks, allowing complete compromise of blockchain state verification.

### Citations

**File:** types/src/trusted_state.rs (L21-40)
```rust
/// `TrustedState` keeps track of light clients' latest, trusted view of the
/// ledger state. Light clients can use proofs from a state proof to "ratchet"
/// their view forward to a newer state.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize, CryptoHasher, BCSCryptoHash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub enum TrustedState {
    /// The current trusted state is an epoch waypoint, which is a commitment to
    /// an epoch change ledger info. Most light clients will start here when
    /// syncing for the first time.
    EpochWaypoint(Waypoint),
    /// The current trusted state is inside a verified epoch (which includes the
    /// validator set inside that epoch).
    EpochState {
        /// The current trusted version and a commitment to a ledger info inside
        /// the current trusted epoch.
        waypoint: Waypoint,
        /// The current epoch and validator set inside that epoch.
        epoch_state: EpochState,
    },
}
```

**File:** types/src/trusted_state.rs (L75-90)
```rust
    pub fn try_from_epoch_change_li(
        epoch_change_li: &LedgerInfo,
        accumulator: TransactionAccumulatorSummary,
    ) -> Result<Self> {
        // Ensure the accumulator and ledger info are at the same version/root hash.
        accumulator.verify_consistency(epoch_change_li)?;

        let epoch_state = epoch_change_li.next_epoch_state().cloned().ok_or_else(|| {
            format_err!("No EpochState in LedgerInfo; it must not be on an epoch boundary")
        })?;

        Ok(Self::EpochState {
            waypoint: Waypoint::new_epoch_boundary(epoch_change_li)?,
            epoch_state,
        })
    }
```

**File:** types/src/trusted_state.rs (L161-163)
```rust
        if self.epoch_change_verification_required(latest_li.ledger_info().next_block_epoch()) {
            // Verify the EpochChangeProof to move us into the latest epoch.
            let epoch_change_li = epoch_change_proof.verify(self)?;
```

**File:** types/src/epoch_state.rs (L17-22)
```rust
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct EpochState {
    pub epoch: u64,
    pub verifier: Arc<ValidatorVerifier>,
}
```

**File:** types/src/epoch_state.rs (L40-49)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
```

**File:** types/src/epoch_change.rs (L66-107)
```rust
    pub fn verify(&self, verifier: &dyn Verifier) -> Result<&LedgerInfoWithSignatures> {
        ensure!(
            !self.ledger_info_with_sigs.is_empty(),
            "The EpochChangeProof is empty"
        );
        ensure!(
            !verifier
                .is_ledger_info_stale(self.ledger_info_with_sigs.last().unwrap().ledger_info()),
            "The EpochChangeProof is stale as our verifier is already ahead \
             of the entire EpochChangeProof"
        );
        let mut verifier_ref = verifier;

        for ledger_info_with_sigs in self
            .ledger_info_with_sigs
            .iter()
            // Skip any stale ledger infos in the proof prefix. Note that with
            // the assertion above, we are guaranteed there is at least one
            // non-stale ledger info in the proof.
            //
            // It's useful to skip these stale ledger infos to better allow for
            // concurrent client requests.
            //
            // For example, suppose the following:
            //
            // 1. My current trusted state is at epoch 5.
            // 2. I make two concurrent requests to two validators A and B, who
            //    live at epochs 9 and 11 respectively.
            //
            // If A's response returns first, I will ratchet my trusted state
            // to epoch 9. When B's response returns, I will still be able to
            // ratchet forward to 11 even though B's EpochChangeProof
            // includes a bunch of stale ledger infos (for epochs 5, 6, 7, 8).
            //
            // Of course, if B's response returns first, we will reject A's
            // response as it's completely stale.
            .skip_while(|&ledger_info_with_sigs| {
                verifier.is_ledger_info_stale(ledger_info_with_sigs.ledger_info())
            })
        {
            // Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof.
            verifier_ref.verify(ledger_info_with_sigs)?;
```

**File:** types/src/unit_tests/trusted_state_test.rs (L245-247)
```rust
    fn test_trusted_state_roundtrip_canonical_serialization(trusted_state in any::<TrustedState>()) {
        assert_canonical_encode_decode(trusted_state);
    }
```
