# Audit Report

## Title
Indexer gRPC Manager Lacks TLS Configuration Exposing Transaction Data to Network Interception and Manipulation

## Summary
The `indexer-grpc-manager` service creates a gRPC server without TLS configuration, accepting unencrypted connections that expose blockchain transaction data, service routing information, and heartbeat metadata to network attackers. This enables man-in-the-middle (MITM) attacks for data interception and manipulation.

## Finding Description

The `indexer-grpc-manager` serves as a critical load balancer and router in the Aptos indexer infrastructure, coordinating between clients and data services. The service handles three primary RPC methods that expose sensitive data:

1. **GetTransactions** - Returns blockchain transaction data to clients
2. **Heartbeat** - Receives service metadata and health information from data services  
3. **GetDataServiceForRequest** - Routes clients to appropriate data service endpoints [1](#0-0) 

The server is created without any TLS configuration. The `Server::builder()` at line 101 only configures HTTP2 keepalive parameters but completely omits TLS setup: [2](#0-1) 

The `ServiceConfig` structure used by this service only contains a `listen_address` field with no TLS configuration options: [3](#0-2) 

In stark contrast, other indexer gRPC services in the same codebase properly implement TLS support. For example, `indexer-grpc-data-service-v2` defines a `TlsConfig` structure and conditionally enables TLS when configured: [4](#0-3) [5](#0-4) 

Similarly, `indexer-grpc-data-service` implements both TLS and non-TLS configurations, allowing operators to choose: [6](#0-5) [7](#0-6) 

The workspace configuration includes the necessary tonic TLS features (`tls-roots`, `transport`) to support encrypted connections: [8](#0-7) 

**Attack Scenario:**

A network attacker positioned between clients and the indexer-grpc-manager can:

1. **Intercept transaction data**: Capture all blockchain transactions being served via the `GetTransactions` RPC, including potentially sensitive user transactions, smart contract interactions, and account state changes.

2. **Manipulate transaction responses**: Modify transaction data returned to clients, causing them to process incorrect blockchain state information, which could lead to incorrect indexing, application logic errors, or display of false data to end users.

3. **Redirect service routing**: Alter `GetDataServiceForRequest` responses to redirect clients to malicious data services under attacker control, enabling sustained data manipulation attacks.

4. **Inject false heartbeat data**: Manipulate heartbeat messages from data services to disrupt load balancing decisions, causing the manager to route traffic incorrectly or believe services are available when they are not.

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violations**: The indexer-grpc infrastructure is a critical component for blockchain data access. Compromising its integrity violates data authenticity guarantees that indexers and applications depend on.

2. **API Integrity Compromise**: Manipulated transaction data could cause API crashes or undefined behavior in downstream consumers that expect well-formed, authentic blockchain data.

3. **Validator Node Impact**: While not directly affecting consensus, corrupted indexer data could mislead monitoring tools and operational dashboards, potentially causing validator operators to make incorrect decisions based on false chain state information.

4. **Widespread Data Exposure**: The service handles bulk transaction data for the entire blockchain, making this a high-value target for reconnaissance, competitive intelligence gathering, or preparation for more sophisticated attacks.

The issue does not reach Critical severity because it does not directly cause loss of funds, consensus violations, or network partitions. However, it represents a fundamental breach of confidentiality and integrity for a critical infrastructure component.

## Likelihood Explanation

The likelihood of exploitation is **HIGH**:

1. **Common Attack Vector**: Man-in-the-middle attacks are well-understood and easily executed in numerous network environments including public clouds, enterprise networks, compromised routers, and ISP-level interception.

2. **No Special Access Required**: Any attacker with network position between clients and the server can exploit this vulnerability. No authentication, authorization, or insider access is needed.

3. **Standard Tooling**: Tools like `mitmproxy`, `Wireshark`, and network tap devices can trivially intercept and manipulate unencrypted gRPC traffic.

4. **Production Exposure**: Based on the docker-compose configuration, these services are deployed in network-accessible environments where MITM attacks are feasible. [9](#0-8) 

5. **Persistent Vulnerability**: Unlike ephemeral bugs, this vulnerability persists across all deployments until explicitly fixed with TLS configuration.

## Recommendation

Add TLS configuration support to `indexer-grpc-manager` following the pattern used by other indexer gRPC services:

1. **Add TLS configuration structure** to `config.rs`:
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TlsConfig {
    pub cert_path: String,
    pub key_path: String,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub(crate) struct ServiceConfig {
    pub(crate) listen_address: SocketAddr,
    pub(crate) tls_config: Option<TlsConfig>,
}
```

2. **Update server initialization** in `grpc_manager.rs` to conditionally enable TLS:
```rust
pub(crate) fn start(&self, service_config: &ServiceConfig) -> Result<()> {
    let service = GrpcManagerServer::new(GrpcManagerService::new(
        self.chain_id,
        self.metadata_manager.clone(),
        self.data_manager.clone(),
    ))
    .send_compressed(CompressionEncoding::Zstd)
    .accept_compressed(CompressionEncoding::Zstd)
    .max_encoding_message_size(MAX_MESSAGE_SIZE)
    .max_decoding_message_size(MAX_MESSAGE_SIZE);
    
    let mut server = Server::builder()
        .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
        .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION));

    // Add TLS configuration if provided
    let server = if let Some(tls_config) = &service_config.tls_config {
        let cert = std::fs::read(&tls_config.cert_path)?;
        let key = std::fs::read(&tls_config.key_path)?;
        let identity = tonic::transport::Identity::from_pem(cert, key);
        info!(
            grpc_address = service_config.listen_address.to_string().as_str(),
            "[GrpcManager] Starting gRPC server with TLS."
        );
        server.tls_config(tonic::transport::ServerTlsConfig::new().identity(identity))?
    } else {
        info!(
            grpc_address = service_config.listen_address.to_string().as_str(),
            "[GrpcManager] Starting gRPC server without TLS (INSECURE)."
        );
        server
    }.add_service(service);

    // ... rest of the implementation
}
```

3. **Update documentation and deployment guides** to strongly recommend TLS configuration in production environments.

4. **Consider making TLS mandatory** in production builds with appropriate validation in the `RunnableConfig::validate()` method.

## Proof of Concept

**Setup MITM Interception:**

1. Deploy indexer-grpc-manager on `192.168.1.10:50051`
2. Configure mitmproxy to intercept gRPC traffic:
```bash
mitmproxy --mode transparent --listen-port 8080
```

3. Route client traffic through the proxy using iptables or network configuration

4. Client makes a GetTransactions request:
```bash
grpcurl -d '{"starting_version": 1000}' \
  -import-path protos/proto \
  -proto aptos/indexer/v1/grpc.proto \
  -plaintext 192.168.1.10:50051 \
  aptos.indexer.v1.GrpcManager/GetTransactions
```

**Observed Result:**

The mitmproxy console displays the complete unencrypted gRPC request and response, including:
- Full transaction payloads
- User addresses
- Smart contract interactions  
- Account state changes
- Signatures and authentication data

The attacker can use mitmproxy's scripting API to:
- Log all transaction data for analysis
- Modify transaction responses to inject false data
- Delay or drop specific transactions
- Redirect GetDataServiceForRequest responses to malicious endpoints

**Expected Result with TLS:**

With proper TLS configuration, the connection would be encrypted end-to-end. The mitmproxy would only see encrypted binary data, and any attempt to modify the traffic would cause TLS handshake failures or certificate validation errors, protecting the data confidentiality and integrity.

## Notes

This vulnerability affects the indexer infrastructure layer rather than core consensus or execution components. However, the indexer-grpc services are critical for blockchain data access by applications, explorers, analytics platforms, and monitoring tools. Compromising this layer undermines trust in the entire ecosystem's data integrity.

The fix is straightforward and follows established patterns already present in the codebase, making it low-risk to implement. The primary consideration is ensuring backward compatibility with existing deployments while strongly encouraging (or requiring) TLS adoption in production environments.

### Citations

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L103-107)
```text
service GrpcManager {
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);
  rpc GetTransactions(GetTransactionsRequest) returns (TransactionsResponse);
  rpc GetDataServiceForRequest(GetDataServiceForRequestRequest) returns (GetDataServiceForRequestResponse);
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L101-104)
```rust
        let server = Server::builder()
            .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
            .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
            .add_service(service);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L18-21)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub(crate) struct ServiceConfig {
    pub(crate) listen_address: SocketAddr,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L43-54)
```rust
pub struct TlsConfig {
    pub cert_path: String,
    pub key_path: String,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ServiceConfig {
    /// The address to listen on.
    pub(crate) listen_address: SocketAddr,
    pub(crate) tls_config: Option<TlsConfig>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L254-269)
```rust
        if let Some(config) = &self.service_config.tls_config {
            let cert = tokio::fs::read(config.cert_path.clone()).await?;
            let key = tokio::fs::read(config.key_path.clone()).await?;
            let identity = tonic::transport::Identity::from_pem(cert, key);
            server_builder = server_builder
                .tls_config(tonic::transport::ServerTlsConfig::new().identity(identity))?;
            info!(
                grpc_address = listen_address.to_string().as_str(),
                "[Data Service] Starting gRPC server with TLS."
            );
        } else {
            info!(
                grpc_address = listen_address.to_string().as_str(),
                "[data service] starting gRPC server with non-TLS."
            );
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L34-54)
```rust
pub struct TlsConfig {
    /// The address for the TLS GRPC server to listen on.
    pub data_service_grpc_listen_address: SocketAddr,
    pub cert_path: String,
    pub key_path: String,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct NonTlsConfig {
    /// The address for the TLS GRPC server to listen on.
    pub data_service_grpc_listen_address: SocketAddr,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcDataServiceConfig {
    /// If given, we will run a server that uses TLS.
    pub data_service_grpc_tls_config: Option<TlsConfig>,
    /// If given, we will run a server that does not use TLS.
    pub data_service_grpc_non_tls_config: Option<NonTlsConfig>,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L215-235)
```rust
        if let Some(config) = &self.data_service_grpc_tls_config {
            let listen_address = config.data_service_grpc_listen_address;
            let cert = tokio::fs::read(config.cert_path.clone()).await?;
            let key = tokio::fs::read(config.key_path.clone()).await?;
            let identity = tonic::transport::Identity::from_pem(cert, key);
            tracing::info!(
                grpc_address = listen_address.to_string().as_str(),
                "[Data Service] Starting gRPC server with TLS."
            );
            tasks.push(tokio::spawn(async move {
                Server::builder()
                    .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
                    .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
                    .tls_config(tonic::transport::ServerTlsConfig::new().identity(identity))?
                    .add_service(svc)
                    .add_service(reflection_service)
                    .serve(listen_address)
                    .await
                    .map_err(|e| anyhow::anyhow!(e))
            }));
        }
```

**File:** Cargo.toml (L835-842)
```text
tonic = { version = "0.12.3", features = [
    "tls-roots",
    "transport",
    "prost",
    "gzip",
    "codegen",
    "zstd",
] }
```

**File:** docker/compose/indexer-grpc/docker-compose.yaml (L80-110)
```yaml
  indexer-grpc-data-service:
    image: "${INDEXER_GRPC_IMAGE_REPO:-aptoslabs/indexer-grpc}:${IMAGE_TAG:-main}"
    networks:
      shared:
        ipv4_address: 172.16.1.15
    restart: unless-stopped
    volumes:
      - type: volume # XXX: needed now before refactor https://github.com/aptos-labs/aptos-core/pull/8139
        source: indexer-grpc-file-store
        target: /opt/aptos/file-store
      - type: bind
        source: ./data-service-config.yaml
        target: /opt/aptos/data-service-config.yaml
      - type: bind
        source: ./data-service-grpc-server.key
        target: /opt/aptos/certs/data-service-grpc-server.key
      - type: bind
        source: ./data-service-grpc-server.crt
        target: /opt/aptos/certs/data-service-grpc-server.crt
    command:
      - '/usr/local/bin/aptos-indexer-grpc-data-service'
      - '--config-path'
      - '/opt/aptos/data-service-config.yaml'
    ports:
      - "50052:50052" # GRPC non-secure
      - "50053:50053" # GRPC secure
      - "18084:8084" # health
    depends_on:
      - indexer-grpc-cache-worker
      - indexer-grpc-file-store
      - redis-replica
```
