# Audit Report

## Title
Memory Limit Bypass via Disabled Feature Flag in Native Function Memory Tracking

## Summary
The `use_heap_memory()` function in `SafeNativeContext` completely bypasses memory tracking when the `FixMemoryUsageTracking` timed feature flag is disabled. This allows attackers to create transactions with arbitrarily large table values that exhaust node memory without triggering memory quota limits, breaking consensus determinism and enabling denial-of-service attacks.

## Finding Description

The `use_heap_memory()` function is the critical entry point for tracking heap memory usage in native functions. However, it contains a fatal flaw: the entire memory tracking logic is gated behind a timed feature flag that can be disabled. [1](#0-0) 

When `FixMemoryUsageTracking` is disabled, the function immediately returns `Ok(())` without performing any memory accounting. The feature flag has scheduled future activation dates: [2](#0-1) 

This means before March 2025 on mainnet (and March 7, 2025 on testnet), all memory tracking is completely disabled. Table native functions rely on this function to track memory: [3](#0-2) 

When memory tracking is disabled, large values can be added to tables without any memory accounting. This breaks two critical invariants:
- **Move VM Safety (Invariant #3)**: Bytecode execution must respect memory constraints
- **Resource Limits (Invariant #9)**: All operations must respect computational limits

The attack vector is:
1. Attacker submits transaction with `table::add` operations containing large vectors (e.g., `vector<u8>` with millions of elements)
2. `native_add_box` calls `use_heap_memory()` to track memory usage
3. With feature flag disabled, no memory is tracked
4. Large allocation succeeds without consuming memory quota
5. Repeated transactions can exhaust node memory
6. Different nodes may run out of memory at different times, causing non-deterministic transaction execution and consensus failures

Additionally, even when the feature IS enabled, there's a silent underflow protection that can mask bugs: [4](#0-3) 

If `stack_size > abs_size` due to misconfigured gas parameters or calculation bugs, this returns 0 instead of erroring, allowing large allocations to be tracked as having zero heap usage.

## Impact Explanation

This is **HIGH severity** based on Aptos bug bounty criteria:

1. **Consensus Determinism Violation**: Different validators with different available memory will execute the same transaction differently, potentially causing state divergence and chain splits
2. **Denial of Service**: Attackers can exhaust validator memory, causing crashes or severe performance degradation
3. **Protocol-Level Resource Limit Bypass**: The memory quota system is completely circumvented, undermining a fundamental safety mechanism

The vulnerability affects ALL validators on the network before the feature flag activates, making it a systemic protocol-level issue rather than an isolated node problem.

## Likelihood Explanation

**Likelihood: HIGH**

- **Ease of Exploitation**: Any user can submit transactions with table operations - no special privileges required
- **Attack Cost**: Minimal - only requires gas fees for transactions, which is far cheaper than the memory exhaustion damage caused
- **Detection Difficulty**: Memory exhaustion appears as normal operational issues, making attribution difficult
- **Current Status**: Vulnerability is ACTIVE on mainnet until March 11, 2025 at 5:00 PM PST

The timed feature flag comment explicitly acknowledges this bug: [5](#0-4) 

## Recommendation

**Immediate Actions:**
1. Accelerate the `FixMemoryUsageTracking` feature flag activation to an emergency deployment
2. Add validation in `use_heap_memory()` to error instead of silently returning when memory tracking should be active but isn't
3. Implement runtime checks in `abstract_heap_size()` to detect and error on underflow conditions rather than silently returning 0

**Code Fix for underflow protection:**

```rust
pub fn abstract_heap_size(
    &self,
    val: impl ValueView,
    feature_version: u64,
) -> PartialVMResult<AbstractValueSize> {
    let stack_size = self.abstract_stack_size(&val, feature_version)?;
    let abs_size = self.abstract_value_size(val, feature_version)?;
    
    // Error instead of silently returning 0
    abs_size.checked_sub(stack_size)
        .ok_or_else(|| PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
            .with_message(format!("Heap size calculation underflow: abs_size={}, stack_size={}", 
                u64::from(abs_size), u64::from(stack_size))))
}
```

**Gas Schedule Validation:** [6](#0-5) 

Implement the TODO by adding validation that verifies:
- All `per_X_packed` parameters are reasonable (> 0)
- Container overhead parameters (vector, struct_, etc.) are consistent with packed element costs
- Stack size will never exceed total abstract size for any valid value

## Proof of Concept

```move
#[test_only]
module test_addr::memory_exploit {
    use std::vector;
    use aptos_std::table::{Self, Table};
    use std::signer;

    struct LargeDataStore has key {
        data: Table<u64, vector<u8>>
    }

    // This function will succeed in exhausting memory when 
    // FixMemoryUsageTracking is disabled
    public entry fun exploit_memory_tracking(account: &signer) {
        let store = LargeDataStore {
            data: table::new()
        };
        
        let i = 0;
        while (i < 100) {
            // Create a 10MB vector - should consume memory quota
            // but won't if feature flag is disabled
            let large_vec = vector::empty<u8>();
            let j = 0;
            while (j < 10_000_000) {
                vector::push_back(&mut large_vec, 0u8);
                j = j + 1;
            };
            
            table::add(&mut store.data, i, large_vec);
            i = i + 1;
        };
        
        move_to(account, store);
        // Total: ~1GB of data stored without proper memory accounting
    }
}
```

Before feature flag activation, this test will NOT hit memory limits despite allocating ~1GB. After activation, it will properly fail with `MEMORY_LIMIT_EXCEEDED`.

## Notes

The vulnerability exists as production code with a scheduled fix. The timed feature flag approach indicates the Aptos team is aware of the issue, but the fix is not yet active on mainnet. This represents a window of exploitability from now until March 11, 2025, during which the vulnerability can be actively exploited to cause consensus issues and validator crashes.

### Citations

**File:** aptos-move/aptos-native-interface/src/context.rs (L205-217)
```rust
    pub fn use_heap_memory(&mut self, amount: u64) -> SafeNativeResult<()> {
        if self.timed_feature_enabled(TimedFeatureFlag::FixMemoryUsageTracking) {
            if self.has_direct_gas_meter_access_in_native_context() {
                self.gas_meter()
                    .use_heap_memory_in_native_context(amount)
                    .map_err(LimitExceededError::from_err)?;
            } else {
                self.legacy_heap_memory_usage =
                    self.legacy_heap_memory_usage.saturating_add(amount);
            }
        }
        Ok(())
    }
```

**File:** types/src/on_chain_config/timed_features.rs (L20-21)
```rust
    // Fixes the bug of table natives not tracking the memory usage of the global values they create.
    FixMemoryUsageTracking,
```

**File:** types/src/on_chain_config/timed_features.rs (L101-109)
```rust
            (FixMemoryUsageTracking, TESTING) => Utc.with_ymd_and_hms(1970, 1, 1, 1, 0, 0).unwrap(),
            (FixMemoryUsageTracking, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 7, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (FixMemoryUsageTracking, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 11, 17, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L439-441)
```rust
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L956-965)
```rust
    pub fn abstract_heap_size(
        &self,
        val: impl ValueView,
        feature_version: u64,
    ) -> PartialVMResult<AbstractValueSize> {
        let stack_size = self.abstract_stack_size(&val, feature_version)?;
        let abs_size = self.abstract_value_size(val, feature_version)?;

        Ok(abs_size.checked_sub(stack_size).unwrap_or_else(|| 0.into()))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-48)
```text
        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
```
