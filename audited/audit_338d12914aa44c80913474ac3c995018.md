# Audit Report

## Title
Resource Group Initialization Race Condition Causes Cache Poisoning in Parallel Execution

## Summary
A race condition exists in the resource group initialization logic where concurrent transactions can poison the multi-version cache with incorrect deletion entries instead of actual storage values. This occurs because group entries become visible in the DashMap before individual tag values are written, allowing concurrent reads to observe a partially initialized state and write incorrect sentinel values that override the correct storage data.

## Finding Description

The vulnerability exists in the interaction between `VersionedGroupData::set_raw_base_values` and `fetch_tagged_data_*` methods during parallel execution, violating the deterministic execution invariant required for consensus.

**Critical Code Path:**

In `set_raw_base_values`, the group entry is inserted into the DashMap, making it immediately visible to concurrent threads: [1](#0-0) 

However, individual tag values are only written later in the loop: [2](#0-1) 

This creates a timing window where other threads can observe the group as initialized but find specific tags uninitialized.

**Race Condition Trigger:**

The `fetch_tagged_data_and_record_dependency` method checks initialization via `contains_key()`: [3](#0-2) 

Critically, the code comment states "we always write size after data" but the implementation does the opposite - it writes the size entry at line 173 before writing data at lines 178-181: [4](#0-3) 

When a concurrent thread observes `initialized = true` but gets `Uninitialized` from the values map, `convert_tagged_data` returns `TagNotFound`: [5](#0-4) 

**Cache Poisoning Mechanism:**

The `TagNotFound` error handler writes a deletion to the base value: [6](#0-5) 

This deletion is written as `ValueWithLayout::Exchanged`: [7](#0-6) 

When the initialization thread subsequently tries to write the actual storage value as `RawFromStorage`, it is ignored due to prioritization logic: [8](#0-7) 

**Validation Bypass:**

During validation, if the cache still contains the poisoned deletion, the validation passes by comparing against a sentinel deletion: [9](#0-8) 

This allows transactions to commit based on incorrect base values, potentially causing different validators to produce different state roots.

## Impact Explanation

This vulnerability represents a **consensus safety violation** that could escalate to Critical severity:

**Immediate Impact (Medium):**
- State inconsistencies requiring manual intervention - different transactions observe different values based on non-deterministic thread scheduling
- Validation failures for transactions that read correct values while cache contains poisoned deletions
- Potential for temporary execution delays and unnecessary transaction aborts

**Escalation Risk (Critical):**
- Different validators with different hardware/OS scheduling could experience the race condition manifesting differently
- This would cause validators to execute the same block with different base values, producing different state roots
- Consensus divergence requiring manual intervention or potential chain halt

The severity is conservatively assessed as Medium per the Aptos bounty criteria ("State inconsistencies requiring intervention"), but the potential for consensus violation means this warrants immediate attention.

## Likelihood Explanation

**Likelihood: High** during production workloads.

The race condition occurs naturally without malicious intent:
- Resource groups are fundamental to Aptos (coin stores, token collections, account resources)
- BlockSTM's parallel execution model actively encourages concurrent access to shared resources
- The timing window exists between DashMap entry creation (line 155) and tag value writes (lines 178-181)
- High transaction throughput increases probability of concurrent initialization attempts
- The TODO comment explicitly acknowledges initialization issues: [10](#0-9) 

Under high-throughput scenarios with multiple transactions accessing the same resource groups, the race condition becomes increasingly likely to manifest.

## Recommendation

**Immediate Fix:**
Ensure atomic initialization by writing individual tag values before making the group visible:

1. Write all tag values to a local buffer first
2. Insert the group entry into `group_sizes` only after all tag values are written
3. Alternatively, use proper locking to prevent concurrent reads during initialization

**Long-term Solution:**
Implement the planned "complete overhaul of initialization logic" mentioned in the TODO comment to eliminate non-atomic state transitions.

## Proof of Concept

Due to the non-deterministic nature of race conditions, a reliable PoC requires specific timing controls. However, the vulnerability can be demonstrated conceptually:

```rust
// Thread 1: Initialization
set_raw_base_values(group_key, [(tag1, value1), (tag2, value2)])
// Line 155 executes - group becomes visible
// Race window opens here
// Lines 176-182 not yet executed

// Thread 2: Concurrent read (during race window)
fetch_tagged_data_and_record_dependency(group_key, tag1, txn_idx, inc)
// Returns TagNotFound (group initialized but tag1 not written yet)
// Writes deletion for tag1

// Thread 1: Continues
// Tries to write value1 for tag1
// Ignored due to Exchanged prioritization
// Cache now poisoned
```

Under high-throughput testing with aggressive parallel transaction execution targeting the same resource groups, this race can be triggered and observed through divergent execution outcomes.

## Notes

The vulnerability is exacerbated by the contradiction between the code comment (claiming "we always write size after data") and the actual implementation (which writes size before data). This indicates the developers intended a different ordering to prevent this exact issue, but the implementation doesn't match the design intent.

The presence of the TODO comment about initialization logic overhaul suggests the Aptos team is aware of initialization complexities, making this a high-priority issue for the planned refactoring.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L155-155)
```rust
        let mut group_sizes = self.group_sizes.entry(group_key.clone()).or_default();
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L176-182)
```rust
            for (tag, value) in base_values.into_iter() {
                superset_tags.insert(tag.clone());
                self.values.set_base_value(
                    (group_key.clone(), tag),
                    ValueWithLayout::RawFromStorage(Arc::new(value)),
                );
            }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L195-198)
```rust
        self.values.set_base_value(
            (group_key, tag),
            ValueWithLayout::Exchanged(Arc::new(value), layout.clone()),
        );
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L445-451)
```rust
        // We are accessing group_sizes and values non-atomically, hence the order matters.
        // It is important that initialization check happens before fetch data below. O.w.
        // we could incorrectly get a TagNotFound error (do not find data, but then find
        // size initialized in between the calls). In fact, we always write size after data,
        // and sometimes (e.g. during initialization) even hold the sizes lock during writes.
        // It is fine to observe initialized = false, but find data, in convert_tagged_data.
        // TODO(BlockSTMv2): complete overhaul of initialization logic.
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L452-452)
```rust
        let initialized = self.group_sizes.contains_key(group_key);
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L683-684)
```rust
            Err(MVDataError::Uninitialized) => Err(if initialized {
                MVGroupError::TagNotFound
```

**File:** aptos-move/block-executor/src/view.rs (L815-827)
```rust
                Err(TagNotFound) => {
                    // TagNotFound means group was initialized (o.w. Uninitialized branch
                    // would be visited), but the tag didn't exist. So record an empty resource
                    // as a base value, and do continue to retry the read.
                    self.versioned_map
                        .group_data()
                        .update_tagged_base_value_with_layout(
                            group_key.clone(),
                            resource_tag.clone(),
                            TransactionWrite::from_state_value(None),
                            None,
                        );
                    continue;
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L586-588)
```rust
                        (Exchanged(_, _), RawFromStorage(_)) => {
                            // Stored value contains more info, nothing to do.
                        },
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1119-1129)
```rust
                    Err(TagNotFound) => {
                        let sentinel_deletion =
                            TriompheArc::<T::Value>::new(TransactionWrite::from_state_value(None));
                        assert!(sentinel_deletion.is_deletion());
                        matches!(
                            self.data_read_comparator.compare_data_reads(
                                &DataRead::Versioned(Err(StorageVersion), sentinel_deletion, None),
                                r,
                            ),
                            DataReadComparison::Contains
                        )
```
